{"sha": "9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc3MWIyNjM5NmMzOWRmYWVjZDVhNzZkZDM1OWZiNjVkM2JlNGNiNg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2012-11-18T02:54:30Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-11-18T02:54:30Z"}, "message": "This patch rewrites the old VEC macro-based interface into a new one based on the template class 'vec'.\n\nThis patch rewrites the old VEC macro-based interface into a new one\nbased on the template class 'vec'.  The user-visible changes are\ndescribed in http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec.\n\nI have tested the patch pretty extensively:\n\n- Regular bootstraps on x86_64, ppc, ia64, sparc and hppa.\n- Bootstraps with --enable-checking=release\n- Bootstraps with --enable-checking=gc,gcac\n- Basic builds on all targets (using contrib/config-list.mk).\n\nWe no longer access the vectors via VEC_* macros.  The pattern is\n\"VEC_operation (T, A, V, args)\" becomes \"V.operation (args)\".\n\nThe only thing I could not do is create proper ctors and dtors for the\nvec class.  Since these vectors are stored in unions, we\nhave to keep them as PODs (C++03 does not allow non-PODs in unions).\n\nThis means that creation and destruction must be explicit.  There is a\nnew method vec<type, allocation, layout>::create() and another vec<type,\nallocation, layout>::destroy() to allocate the internal vector.\n\nFor vectors that must be pointers, there is a family of free functions\nthat implement the operations that need to tolerate NULL vectors.\nThese functions all start with the prefix 'vec_safe_'.  See the wiki\npage for details.\n\nThe gengtype change removes the special handling for VEC() that used\nto exist in gengtype. Additionally, it allows gengtype to recognize\ntemplates of more than one argument and introduces the concept of an\nundefined type (useful for template arguments that may or may not be\ntypes).\n\nWhen a TYPE_UNDEFINED is reached, gengtype will ignore it if it\nhappens inside a type marked with GTY((user)).  Otherwise, it will\nemit an error.\n\nFinally, gengtype rejects root types marked GTY((user)) that are not\nfirst class pointers.\n\n2012-11-16  Diego Novillo  <dnovillo@google.com>\n\n\tVEC API overhaul (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n\n\t* vec.c (register_overhead): Convert it into\n\tmember function of vec_prefix.\n\t(release_overhead): Likewise.\n\t(calculate_allocation): Likewise.\n\t(vec_heap_free): Remove.\n\t(vec_gc_o_reserve_1): Remove.\n\t(vec_heap_o_reserve_1): Remove.\n\t(vec_stack_o_reserve_1): Remove.\n\t(vec_stack_o_reserve_exact): Remove.\n\t(register_stack_vec): New.\n\t(stack_vec_register_index): New.\n\t(unregister_stack_vec): New.\n\t(vec_assert_fail): Remove.\n\t* vec.h: Conditionally include ggc.h.  Document conditional\n\thackery.\n\tUpdate top-level documentation.\n\t(ALONE_VEC_CHECK_INFO): Remove.\n\t(VEC_CHECK_INFO): Remove.\n\t(ALONE_VEC_CHECK_DECL): Remove.\n\t(VEC_CHECK_DECL): Remove.\n\t(ALONE_VEC_CHECK_PASS): Remove.\n\t(VEC_CHECK_PASS): Remove.\n\t(VEC_ASSERT): Remove.\n\t(vec_prefix): Add friends va_gc, va_gc_atomic, va_heap and\n\tva_stack.\n\tMark fields alloc_ and num_ as protected.\n\t(struct vec_t): Remove.  Remove all function members.\n\t(struct vl_embed): Declare.\n\t(struct vl_ptr): Declare.\n\t(free): Remove.\n\t(reserve_exact): Remove.\n\t(reserve): Remove.\n\t(safe_splice): Remove.\n\t(safe_push): Remove.\n\t(safe_grow): Remove.\n\t(safe_grow_cleared): Remove.\n\t(safe_insert): Remove.\n\t(DEF_VEC_I): Remove.\n\t(DEF_VEC_ALLOC_I): Remove.\n\t(DEF_VEC_P): Remove.\n\t(DEF_VEC_ALLOC_P): Remove.\n\t(DEF_VEC_O): Remove.\n\t(DEF_VEC_ALLOC_O): Remove.\n\t(DEF_VEC_ALLOC_P_STACK): Remove.\n\t(DEF_VEC_ALLOC_O_STACK): Remove.\n\t(DEF_VEC_ALLOC_I_STACK): Remove.\n\t(DEF_VEC_A): Remove.\n\t(DEF_VEC_ALLOC_A): Remove.\n\t(vec_stack_p_reserve_exact_1): Remove.\n\t(vec_stack_o_reserve): Remove.\n\t(vec_stack_o_reserve_exact): Remove.\n\t(VEC_length): Remove.\n\t(VEC_empty): Remove.\n\t(VEC_address): Remove.\n\t(vec_address): Remove.\n\t(VEC_last): Remove.\n\t(VEC_index): Remove.\n\t(VEC_iterate): Remove.\n\t(VEC_embedded_size): Remove.\n\t(VEC_embedded_init): Remove.\n\t(VEC_free): Remove.\n\t(VEC_copy): Remove.\n\t(VEC_space): Remove.\n\t(VEC_reserve): Remove.\n\t(VEC_reserve_exact): Remove.\n\t(VEC_splice): Remove.\n\t(VEC_safe_splice): Remove.\n\t(VEC_quick_push): Remove.\n\t(VEC_safe_push): Remove.\n\t(VEC_pop): Remove.\n\t(VEC_truncate): Remove.\n\t(VEC_safe_grow): Remove.\n\t(VEC_replace): Remove.\n\t(VEC_quick_insert): Remove.\n\t(VEC_safe_insert): Remove.\n\t(VEC_ordered_remove): Remove.\n\t(VEC_unordered_remove): Remove.\n\t(VEC_block_remove): Remove.\n\t(VEC_lower_bound): Remove.\n\t(VEC_alloc): Remove.\n\t(VEC_qsort): Remove.\n\n\t(va_heap): Declare.\n\t(va_heap::default_layout): New typedef to vl_ptr.\n\t(va_heap::reserve): New.\n\t(va_heap::release): New.\n\t(va_gc): Declare.\n\t(va_gc::default_layout): New typedef to vl_embed.\n\t(va_gc::reserve): New.\n\t(va_gc::release): New.\n\t(va_gc_atomic): Declare.  Inherit from va_gc.\n\t(va_stack): Declare.\n\t(va_stack::default_layout): New typedef to vl_ptr.\n\t(va_stack::alloc): New.\n\t(va_stack::reserve): New.\n\t(va_stack::release): New.\n\t(register_stack_vec): Declare.\n\t(stack_vec_register_index): Declare.\n\t(unregister_stack_vec): Declare.\n\n\t(vec<T, A = va_heap, L = typename A::default_layout>): Declare\n\tempty vec template.\n\t(vec<T, A, vl_embed>): Partial specialization for embedded\n\tlayout.\n\t(vec<T, A, vl_embed>::allocated): New.\n\t(vec<T, A, vl_embed>::length): New.\n\t(vec<T, A, vl_embed>::is_empty): New.\n\t(vec<T, A, vl_embed>::address): New.\n\t(vec<T, A, vl_embed>::operator[]): New.\n\t(vec<T, A, vl_embed>::last New.\n\t(vec<T, A, vl_embed>::space): New.\n\t(vec<T, A, vl_embed>::iterate): New.\n\t(vec<T, A, vl_embed>::iterate): New.\n\t(vec<T, A, vl_embed>::copy): New.\n\t(vec<T, A, vl_embed>::splice): New.\n\t(vec<T, A, vl_embed>::quick_push New.\n\t(vec<T, A, vl_embed>::pop New.\n\t(vec<T, A, vl_embed>::truncate): New.\n\t(vec<T, A, vl_embed>::quick_insert): New.\n\t(vec<T, A, vl_embed>::ordered_remove): New.\n\t(vec<T, A, vl_embed>::unordered_remove): New.\n\t(vec<T, A, vl_embed>::block_remove): New.\n\t(vec<T, A, vl_embed>::qsort): New.\n\t(vec<T, A, vl_embed>::lower_bound): New.\n\t(vec<T, A, vl_embed>::embedded_size): New.\n\t(vec<T, A, vl_embed>::embedded_init): New.\n\t(vec<T, A, vl_embed>::quick_grow): New.\n\t(vec<T, A, vl_embed>::quick_grow_cleared): New.\n\t(vec_safe_space): New.\n\t(vec_safe_length): New.\n\t(vec_safe_address): New.\n\t(vec_safe_is_empty): New.\n\t(vec_safe_reserve): New.\n\t(vec_safe_reserve_exact): New.\n\t(vec_alloc): New.\n\t(vec_free): New.\n\t(vec_safe_grow): New.\n\t(vec_safe_grow_cleared): New.\n\t(vec_safe_iterate): New.\n\t(vec_safe_push): New.\n\t(vec_safe_insert): New.\n\t(vec_safe_truncate): New.\n\t(vec_safe_copy): New.\n\t(vec_safe_splice): New.\n\n\t(vec<T, A, vl_ptr>): New partial specialization for the space\n\tefficient layout.\n\t(vec<T, A, vl_ptr>::exists): New.\n\t(vec<T, A, vl_ptr>::is_empty): New.\n\t(vec<T, A, vl_ptr>::length): New.\n\t(vec<T, A, vl_ptr>::address): New.\n\t(vec<T, A, vl_ptr>::operator[]): New.\n\t(vec<T, A, vl_ptr>::operator!=): New.\n\t(vec<T, A, vl_ptr>::operator==): New.\n\t(vec<T, A, vl_ptr>::last): New.\n\t(vec<T, A, vl_ptr>::space): New.\n\t(vec<T, A, vl_ptr>::iterate): New.\n\t(vec<T, A, vl_ptr>::copy): New.\n\t(vec<T, A, vl_ptr>::reserve): New.\n\t(vec<T, A, vl_ptr>::reserve_exact): New.\n\t(vec<T, A, vl_ptr>::splice): New.\n\t(vec<T, A, vl_ptr>::safe_splice): New.\n\t(vec<T, A, vl_ptr>::quick_push): New.\n\t(vec<T, A, vl_ptr>::safe_push): New.\n\t(vec<T, A, vl_ptr>::pop): New.\n\t(vec<T, A, vl_ptr>::truncate): New.\n\t(vec<T, A, vl_ptr>::safe_grow): New.\n\t(vec<T, A, vl_ptr>::safe_grow_cleared): New.\n\t(vec<T, A, vl_ptr>::quick_grow): New.\n\t(vec<T, A, vl_ptr>::quick_grow_cleared): New.\n\t(vec<T, A, vl_ptr>::quick_insert): New.\n\t(vec<T, A, vl_ptr>::safe_insert): New.\n\t(vec<T, A, vl_ptr>::ordered_remove): New.\n\t(vec<T, A, vl_ptr>::unordered_remove): New.\n\t(vec<T, A, vl_ptr>::block_remove): New.\n\t(vec<T, A, vl_ptr>::qsort): New.\n\t(vec<T, A, vl_ptr>::lower_bound): New.\n\t(vec_stack_alloc): Define.\n\t(FOR_EACH_VEC_SAFE_ELT): Define.\n\t* vecir.h: Remove.  Update all users.\n\t* vecprim.h: Remove.  Update all users.\n\tMove uchar to coretypes.h.\n\n\t* Makefile.in (VEC_H): Add $(GGC_H).\n\tRemove vecir.h and vecprim.h dependencies everywhere.\n\n2012-11-16  Diego Novillo  <dnovillo@google.com>\n\n\t* gengtype-lex.l (VEC): Remove.\n\tAdd characters in the set [\\!\\>\\.-].\n\t* gengtype-parse.c (token_names): Remove \"VEC\".\n\t(require_template_declaration): Remove handling of VEC_TOKEN.\n\t(type): Likewise.\n\tCall create_user_defined_type when parsing GTY((user)).\n\t* gengtype-state.c (type_lineloc): handle TYPE_UNDEFINED.\n\t(write_state_undefined_type): New.\n\t(write_state_type): Call write_state_undefined_type for\n\tTYPE_UNDEFINED.\n\t(read_state_type): Call read_state_undefined_type for\n\tTYPE_UNDEFINED.\n\t* gengtype.c (dbgprint_count_type_at): Handle TYPE_UNDEFINED.\n\t(create_user_defined_type): Make extern.\n\t(type_for_name): Factor out of resolve_typedef.\n\t(create_undefined_type): New\n\t(resolve_typedef): Call it when we cannot find a previous\n\ttypedef and the type is not a template.\n\t(find_structure): Accept TYPE_UNDEFINED.\n\t(set_gc_used_type): Add argument ALLOWED_UNDEFINED_TYPES,\n\tdefault to false.\n\tEmit an error for TYPE_UNDEFINED unless LEVEL is GC_UNUSED or\n\tALLOWED_UNDEFINED_TYPES is set.\n\tSet ALLOWED_UNDEFINED_TYPES to true for TYPE_USER_STRUCT.\n\t(filter_type_name): Accept templates with more than one\n\targument.\n\t(output_mangled_typename): Handle TYPE_UNDEFINED\n\t(walk_type): Likewise.\n\t(write_types_process_field): Likewise.\n\t(write_func_for_structure): If CHAIN_NEXT is set, ORIG_S\n\tshould not be a user-defined type.\n\t(write_types_local_user_process_field): Handle TYPE_ARRAY,\n\tTYPE_NONE and TYPE_UNDEFINED.\n\t(write_types_local_process_field): Likewise.\n\t(contains_scalar_p): Return 0 for TYPE_USER_STRUCT.\n\t(write_root): Reject user-defined types that are not pointers.\n\tHandle TYPE_NONE, TYPE_UNDEFINED, TYPE_UNION, TYPE_LANG_STRUCT\n\tand TYPE_PARAM_STRUCT.\n\t(output_typename): Handle TYPE_NONE, TYPE_UNDEFINED, and\n\tTYPE_ARRAY.\n\t(dump_typekind): Handle TYPE_UNDEFINED.\n\t* gengtype.h (enum typekind): Add TYPE_UNDEFINED.\n\t(create_user_defined_type): Declare.\n\t(enum gty_token): Remove VEC_TOKEN.\n\n2012-11-16  Diego Novillo  <dnovillo@google.com>\n\n\tAdjust for new vec API (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n\n\t* coretypes.h (uchar): Define.\n\t* alias.c: Use new vec API in vec.h.\n\t* asan.c: Likewise.\n\t* attribs.c: Likewise.\n\t* basic-block.h: Likewise.\n\t* bb-reorder.c: Likewise.\n\t* builtins.c: Likewise.\n\t* calls.c: Likewise.\n\t* cfg.c: Likewise.\n\t* cfganal.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfgexpand.c: Likewise.\n\t* cfghooks.c: Likewise.\n\t* cfghooks.h: Likewise.\n\t* cfgloop.c: Likewise.\n\t* cfgloop.h: Likewise.\n\t* cfgloopanal.c: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* cgraphclones.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* combine.c: Likewise.\n\t* compare-elim.c: Likewise.\n\t* coverage.c: Likewise.\n\t* cprop.c: Likewise.\n\t* data-streamer.h: Likewise.\n\t* dbxout.c: Likewise.\n\t* dce.c: Likewise.\n\t* df-core.c: Likewise.\n\t* df-problems.c: Likewise.\n\t* df-scan.c: Likewise.\n\t* dominance.c: Likewise.\n\t* domwalk.c: Likewise.\n\t* domwalk.h: Likewise.\n\t* dse.c: Likewise.\n\t* dwarf2cfi.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* dwarf2out.h: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* except.c: Likewise.\n\t* except.h: Likewise.\n\t* expr.c: Likewise.\n\t* expr.h: Likewise.\n\t* final.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\t* function.h: Likewise.\n\t* fwprop.c: Likewise.\n\t* gcc.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattr.c: Likewise.\n\t* genattrtab.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* genextract.c: Likewise.\n\t* genopinit.c: Likewise\n\t* ggc-common.c: Likewise.\n\t* ggc.h: Likewise.\n\t* gimple-low.c: Likewise.\n\t* gimple-ssa-strength-reduction.c: Likewise.\n\t* gimple-streamer-in.c: Likewise.\n\t* gimple.c: Likewise.\n\t* gimple.h: Likewise.\n\t* gimplify.c: Likewise.\n\t* graph.c: Likewise.\n\t* graphds.c: Likewise.\n\t* graphds.h: Likewise.\n\t* graphite-blocking.c: Likewise.\n\t* graphite-clast-to-gimple.c: Likewise.\n\t* graphite-dependences.c: Likewise.\n\t* graphite-interchange.c: Likewise.\n\t* graphite-optimize-isl.c: Likewise.\n\t* graphite-poly.c: Likewise.\n\t* graphite-poly.h: Likewise.\n\t* graphite-scop-detection.c: Likewise.\n\t* graphite-scop-detection.h: Likewise.\n\t* graphite-sese-to-poly.c: Likewise.\n\t* graphite.c: Likewise.\n\t* godump.c: Likewise.\n\t* haifa-sched.c: Likewise.\n\t* hw-doloop.c: Likewise.\n\t* hw-doloop.h: Likewise.\n\t* ifcvt.c: Likewise.\n\t* insn-addr.h: Likewise.\n\t* ipa-cp.c: Likewise.\n\t* ipa-inline-analysis.c: Likewise.\n\t* ipa-inline-transform.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* ipa-inline.h: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-prop.h: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* ipa-ref-inline.h: Likewise.\n\t* ipa-ref.c: Likewise.\n\t* ipa-ref.h: Likewise.\n\t* ipa-reference.c: Likewise.\n\t* ipa-split.c: Likewise.\n\t* ipa-utils.c: Likewise.\n\t* ipa-utils.h: Likewise.\n\t* ipa.c: Likewise.\n\t* ira-build.c: Likewise.\n\t* ira-color.c: Likewise.\n\t* ira-emit.c: Likewise.\n\t* ira-int.h: Likewise.\n\t* ira.c: Likewise.\n\t* loop-invariant.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* lower-subreg.c: Likewise.\n\t* lra-lives.c: Likewise.\n\t* lra.c: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* lto-section-out.c: Likewise.\n\t* lto-streamer-in.c: Likewise.\n\t* lto-streamer-out.c: Likewise.\n\t* lto-streamer.h: Likewise.\n\t* lto-symtab.c: Likewise.\n\t* mcf.c: Likewise.\n\t* modulo-sched.c: Likewise.\n\t* omp-low.c: Likewise.\n\t* opts-common.c: Likewise.\n\t* opts-global.c: Likewise.\n\t* opts.c: Likewise.\n\t* opts.h: Likewise.\n\t* passes.c: Likewise.\n\t* predict.c: Likewise.\n\t* print-tree.c: Likewise.\n\t* profile.c: Likewise.\n\t* profile.h: Likewise.\n\t* read-rtl.c: Likewise.\n\t* ree.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* regrename.c: Likewise.\n\t* regrename.h: Likewise.\n\t* reload.c: Likewise.\n\t* reload.h: Likewise.\n\t* reload1.c: Likewise.\n\t* rtl.h: Likewise.\n\t* sched-deps.c: Likewise.\n\t* sched-int.h: Likewise.\n\t* sdbout.c: Likewise.\n\t* sel-sched-dump.c: Likewise.\n\t* sel-sched-ir.c: Likewise.\n\t* sel-sched-ir.h: Likewise.\n\t* sel-sched.c: Likewise.\n\t* sese.c: Likewise.\n\t* sese.h: Likewise.\n\t* statistics.h: Likewise.\n\t* stmt.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* store-motion.c: Likewise.\n\t* tlink.c: Likewise.\n\t* toplev.c: Likewise.\n\t* trans-mem.c: Likewise.\n\t* tree-browser.c: Likewise.\n\t* tree-call-cdce.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* tree-cfgcleanup.c: Likewise.\n\t* tree-chrec.c: Likewise.\n\t* tree-chrec.h: Likewise.\n\t* tree-complex.c: Likewise.\n\t* tree-data-ref.c: Likewise.\n\t* tree-data-ref.h: Likewise.\n\t* tree-dfa.c: Likewise.\n\t* tree-diagnostic.c: Likewise.\n\t* tree-dump.c: Likewise.\n\t* tree-eh.c: Likewise.\n\t* tree-emutls.c: Likewise.\n\t* tree-flow.h: Likewise.\n\t* tree-if-conv.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-inline.h: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-iterator.c: Likewise.\n\t* tree-loop-distribution.c: Likewise.\n\t* tree-mudflap.c: Likewise.\n\t* tree-optimize.c: Likewise.\n\t* tree-outof-ssa.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* tree-phinodes.c: Likewise.\n\t* tree-predcom.c: Likewise.\n\t* tree-pretty-print.c: Likewise.\n\t* tree-scalar-evolution.c: Likewise.\n\t* tree-sra.c: Likewise.\n\t* tree-ssa-address.c: Likewise.\n\t* tree-ssa-alias.c: Likewise.\n\t* tree-ssa-ccp.c: Likewise.\n\t* tree-ssa-coalesce.c: Likewise.\n\t* tree-ssa-dce.c: Likewise.\n\t* tree-ssa-dom.c: Likewise.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\t* tree-ssa-live.h: Likewise.\n\t* tree-ssa-loop-im.c: Likewise.\n\t* tree-ssa-loop-ivcanon.c: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-ssa-loop-manip.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-ssa-loop-prefetch.c: Likewise.\n\t* tree-ssa-math-opts.c: Likewise.\n\t* tree-ssa-operands.c: Likewise.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* tree-ssa-phiprop.c: Likewise.\n\t* tree-ssa-pre.c: Likewise.\n\t* tree-ssa-propagate.c: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* tree-ssa-sccvn.c: Likewise.\n\t* tree-ssa-sccvn.h: Likewise.\n\t* tree-ssa-strlen.c: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* tree-ssa-tail-merge.c: Likewise.\n\t* tree-ssa-threadedge.c: Likewise.\n\t* tree-ssa-threadupdate.c: Likewise.\n\t* tree-ssa-uncprop.c: Likewise.\n\t* tree-ssa-uninit.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* tree-ssanames.c: Likewise.\n\t* tree-stdarg.c: Likewise.\n\t* tree-streamer-in.c: Likewise.\n\t* tree-streamer-out.c: Likewise.\n\t* tree-streamer.c: Likewise.\n\t* tree-streamer.h: Likewise.\n\t* tree-switch-conversion.c: Likewise.\n\t* tree-vect-data-refs.c: Likewise.\n\t* tree-vect-generic.c: Likewise.\n\t* tree-vect-loop-manip.c: Likewise.\n\t* tree-vect-loop.c: Likewise.\n\t* tree-vect-patterns.c: Likewise.\n\t* tree-vect-slp.c: Likewise.\n\t* tree-vect-stmts.c: Likewise.\n\t* tree-vectorizer.c: Likewise.\n\t* tree-vectorizer.h: Likewise.\n\t* tree-vrp.c: Likewise.\n\t* tree.c: Likewise.\n\t* tree.h: Likewise.\n\t* value-prof.c: Likewise.\n\t* value-prof.h: Likewise.\n\t* var-tracking.c: Likewise.\n\t* varasm.c: Likewise.\n\t* varpool.c: Likewise.\n\t* vmsdbgout.c: Likewise.\n\t* config/bfin/bfin.c: Likewise.\n\t* config/c6x/c6x.c: Likewise.\n\t* config/darwin.c: Likewise.\n\t* config/i386/i386.c: Likewise.\n\t* config/ia64/ia64.c: Likewise.\n\t* config/mep/mep.c: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/rs6000/rs6000-c.c: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/rx/rx.c: Likewise.\n\t* config/spu/spu-c.c: Likewise.\n\t* config/vms/vms.c: Likewise.\n\t* config/vxworks.c: Likewise.\n\t* config/epiphany/resolve-sw-modes.c: Likewise.\n\nFrom-SVN: r193595", "tree": {"sha": "1b9f930d315fa3e0a5ed7fa6e27ec5bd0a3436a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b9f930d315fa3e0a5ed7fa6e27ec5bd0a3436a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f4119158064e271e48a14ce3f88a67e7baf14e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4119158064e271e48a14ce3f88a67e7baf14e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4119158064e271e48a14ce3f88a67e7baf14e0"}], "stats": {"total": 23694, "additions": 11886, "deletions": 11808}, "files": [{"sha": "d4d54d4cf8d16f25c84d8eba144696d8b5006ba5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1,3 +1,501 @@\n+2012-11-17  Diego Novillo  <dnovillo@google.com>\n+\n+\tVEC API overhaul (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n+\n+\t* vec.c (register_overhead): Convert it into\n+\tmember function of vec_prefix.\n+\t(release_overhead): Likewise.\n+\t(calculate_allocation): Likewise.\n+\t(vec_heap_free): Remove.\n+\t(vec_gc_o_reserve_1): Remove.\n+\t(vec_heap_o_reserve_1): Remove.\n+\t(vec_stack_o_reserve_1): Remove.\n+\t(vec_stack_o_reserve_exact): Remove.\n+\t(register_stack_vec): New.\n+\t(stack_vec_register_index): New.\n+\t(unregister_stack_vec): New.\n+\t(vec_assert_fail): Remove.\n+\t* vec.h: Conditionally include ggc.h.  Document conditional\n+\thackery.\n+\tUpdate top-level documentation.\n+\t(ALONE_VEC_CHECK_INFO): Remove.\n+\t(VEC_CHECK_INFO): Remove.\n+\t(ALONE_VEC_CHECK_DECL): Remove.\n+\t(VEC_CHECK_DECL): Remove.\n+\t(ALONE_VEC_CHECK_PASS): Remove.\n+\t(VEC_CHECK_PASS): Remove.\n+\t(VEC_ASSERT): Remove.\n+\t(vec_prefix): Add friends va_gc, va_gc_atomic, va_heap and\n+\tva_stack.\n+\tMark fields alloc_ and num_ as protected.\n+\t(struct vec_t): Remove.  Remove all function members.\n+\t(struct vl_embed): Declare.\n+\t(struct vl_ptr): Declare.\n+\t(free): Remove.\n+\t(reserve_exact): Remove.\n+\t(reserve): Remove.\n+\t(safe_splice): Remove.\n+\t(safe_push): Remove.\n+\t(safe_grow): Remove.\n+\t(safe_grow_cleared): Remove.\n+\t(safe_insert): Remove.\n+\t(DEF_VEC_I): Remove.\n+\t(DEF_VEC_ALLOC_I): Remove.\n+\t(DEF_VEC_P): Remove.\n+\t(DEF_VEC_ALLOC_P): Remove.\n+\t(DEF_VEC_O): Remove.\n+\t(DEF_VEC_ALLOC_O): Remove.\n+\t(DEF_VEC_ALLOC_P_STACK): Remove.\n+\t(DEF_VEC_ALLOC_O_STACK): Remove.\n+\t(DEF_VEC_ALLOC_I_STACK): Remove.\n+\t(DEF_VEC_A): Remove.\n+\t(DEF_VEC_ALLOC_A): Remove.\n+\t(vec_stack_p_reserve_exact_1): Remove.\n+\t(vec_stack_o_reserve): Remove.\n+\t(vec_stack_o_reserve_exact): Remove.\n+\t(VEC_length): Remove.\n+\t(VEC_empty): Remove.\n+\t(VEC_address): Remove.\n+\t(vec_address): Remove.\n+\t(VEC_last): Remove.\n+\t(VEC_index): Remove.\n+\t(VEC_iterate): Remove.\n+\t(VEC_embedded_size): Remove.\n+\t(VEC_embedded_init): Remove.\n+\t(VEC_free): Remove.\n+\t(VEC_copy): Remove.\n+\t(VEC_space): Remove.\n+\t(VEC_reserve): Remove.\n+\t(VEC_reserve_exact): Remove.\n+\t(VEC_splice): Remove.\n+\t(VEC_safe_splice): Remove.\n+\t(VEC_quick_push): Remove.\n+\t(VEC_safe_push): Remove.\n+\t(VEC_pop): Remove.\n+\t(VEC_truncate): Remove.\n+\t(VEC_safe_grow): Remove.\n+\t(VEC_replace): Remove.\n+\t(VEC_quick_insert): Remove.\n+\t(VEC_safe_insert): Remove.\n+\t(VEC_ordered_remove): Remove.\n+\t(VEC_unordered_remove): Remove.\n+\t(VEC_block_remove): Remove.\n+\t(VEC_lower_bound): Remove.\n+\t(VEC_alloc): Remove.\n+\t(VEC_qsort): Remove.\n+\n+\t(va_heap): Declare.\n+\t(va_heap::default_layout): New typedef to vl_ptr.\n+\t(va_heap::reserve): New.\n+\t(va_heap::release): New.\n+\t(va_gc): Declare.\n+\t(va_gc::default_layout): New typedef to vl_embed.\n+\t(va_gc::reserve): New.\n+\t(va_gc::release): New.\n+\t(va_gc_atomic): Declare.  Inherit from va_gc.\n+\t(va_stack): Declare.\n+\t(va_stack::default_layout): New typedef to vl_ptr.\n+\t(va_stack::alloc): New.\n+\t(va_stack::reserve): New.\n+\t(va_stack::release): New.\n+\t(register_stack_vec): Declare.\n+\t(stack_vec_register_index): Declare.\n+\t(unregister_stack_vec): Declare.\n+\n+\t(vec<T, A = va_heap, L = typename A::default_layout>): Declare\n+\tempty vec template.\n+\t(vec<T, A, vl_embed>): Partial specialization for embedded\n+\tlayout.\n+\t(vec<T, A, vl_embed>::allocated): New.\n+\t(vec<T, A, vl_embed>::length): New.\n+\t(vec<T, A, vl_embed>::is_empty): New.\n+\t(vec<T, A, vl_embed>::address): New.\n+\t(vec<T, A, vl_embed>::operator[]): New.\n+\t(vec<T, A, vl_embed>::last New.\n+\t(vec<T, A, vl_embed>::space): New.\n+\t(vec<T, A, vl_embed>::iterate): New.\n+\t(vec<T, A, vl_embed>::iterate): New.\n+\t(vec<T, A, vl_embed>::copy): New.\n+\t(vec<T, A, vl_embed>::splice): New.\n+\t(vec<T, A, vl_embed>::quick_push New.\n+\t(vec<T, A, vl_embed>::pop New.\n+\t(vec<T, A, vl_embed>::truncate): New.\n+\t(vec<T, A, vl_embed>::quick_insert): New.\n+\t(vec<T, A, vl_embed>::ordered_remove): New.\n+\t(vec<T, A, vl_embed>::unordered_remove): New.\n+\t(vec<T, A, vl_embed>::block_remove): New.\n+\t(vec<T, A, vl_embed>::qsort): New.\n+\t(vec<T, A, vl_embed>::lower_bound): New.\n+\t(vec<T, A, vl_embed>::embedded_size): New.\n+\t(vec<T, A, vl_embed>::embedded_init): New.\n+\t(vec<T, A, vl_embed>::quick_grow): New.\n+\t(vec<T, A, vl_embed>::quick_grow_cleared): New.\n+\t(vec_safe_space): New.\n+\t(vec_safe_length): New.\n+\t(vec_safe_address): New.\n+\t(vec_safe_is_empty): New.\n+\t(vec_safe_reserve): New.\n+\t(vec_safe_reserve_exact): New.\n+\t(vec_alloc): New.\n+\t(vec_free): New.\n+\t(vec_safe_grow): New.\n+\t(vec_safe_grow_cleared): New.\n+\t(vec_safe_iterate): New.\n+\t(vec_safe_push): New.\n+\t(vec_safe_insert): New.\n+\t(vec_safe_truncate): New.\n+\t(vec_safe_copy): New.\n+\t(vec_safe_splice): New.\n+\n+\t(vec<T, A, vl_ptr>): New partial specialization for the space\n+\tefficient layout.\n+\t(vec<T, A, vl_ptr>::exists): New.\n+\t(vec<T, A, vl_ptr>::is_empty): New.\n+\t(vec<T, A, vl_ptr>::length): New.\n+\t(vec<T, A, vl_ptr>::address): New.\n+\t(vec<T, A, vl_ptr>::operator[]): New.\n+\t(vec<T, A, vl_ptr>::operator!=): New.\n+\t(vec<T, A, vl_ptr>::operator==): New.\n+\t(vec<T, A, vl_ptr>::last): New.\n+\t(vec<T, A, vl_ptr>::space): New.\n+\t(vec<T, A, vl_ptr>::iterate): New.\n+\t(vec<T, A, vl_ptr>::copy): New.\n+\t(vec<T, A, vl_ptr>::reserve): New.\n+\t(vec<T, A, vl_ptr>::reserve_exact): New.\n+\t(vec<T, A, vl_ptr>::splice): New.\n+\t(vec<T, A, vl_ptr>::safe_splice): New.\n+\t(vec<T, A, vl_ptr>::quick_push): New.\n+\t(vec<T, A, vl_ptr>::safe_push): New.\n+\t(vec<T, A, vl_ptr>::pop): New.\n+\t(vec<T, A, vl_ptr>::truncate): New.\n+\t(vec<T, A, vl_ptr>::safe_grow): New.\n+\t(vec<T, A, vl_ptr>::safe_grow_cleared): New.\n+\t(vec<T, A, vl_ptr>::quick_grow): New.\n+\t(vec<T, A, vl_ptr>::quick_grow_cleared): New.\n+\t(vec<T, A, vl_ptr>::quick_insert): New.\n+\t(vec<T, A, vl_ptr>::safe_insert): New.\n+\t(vec<T, A, vl_ptr>::ordered_remove): New.\n+\t(vec<T, A, vl_ptr>::unordered_remove): New.\n+\t(vec<T, A, vl_ptr>::block_remove): New.\n+\t(vec<T, A, vl_ptr>::qsort): New.\n+\t(vec<T, A, vl_ptr>::lower_bound): New.\n+\t(vec_stack_alloc): Define.\n+\t(FOR_EACH_VEC_SAFE_ELT): Define.\n+\t* vecir.h: Remove.  Update all users.\n+\t* vecprim.h: Remove.  Update all users.\n+\tMove uchar to coretypes.h.\n+\n+\t* Makefile.in (VEC_H): Add $(GGC_H).\n+\tRemove vecir.h and vecprim.h dependencies everywhere.\n+\n+2012-11-16  Diego Novillo  <dnovillo@google.com>\n+\n+\t* gengtype-lex.l (VEC): Remove.\n+\tAdd characters in the set [\\!\\>\\.-].\n+\t* gengtype-parse.c (token_names): Remove \"VEC\".\n+\t(require_template_declaration): Remove handling of VEC_TOKEN.\n+\t(type): Likewise.\n+\tCall create_user_defined_type when parsing GTY((user)).\n+\t* gengtype-state.c (type_lineloc): handle TYPE_UNDEFINED.\n+\t(write_state_undefined_type): New.\n+\t(write_state_type): Call write_state_undefined_type for\n+\tTYPE_UNDEFINED.\n+\t(read_state_type): Call read_state_undefined_type for\n+\tTYPE_UNDEFINED.\n+\t* gengtype.c (dbgprint_count_type_at): Handle TYPE_UNDEFINED.\n+\t(create_user_defined_type): Make extern.\n+\t(type_for_name): Factor out of resolve_typedef.\n+\t(create_undefined_type): New\n+\t(resolve_typedef): Call it when we cannot find a previous\n+\ttypedef and the type is not a template.\n+\t(find_structure): Accept TYPE_UNDEFINED.\n+\t(set_gc_used_type): Add argument ALLOWED_UNDEFINED_TYPES,\n+\tdefault to false.\n+\tEmit an error for TYPE_UNDEFINED unless LEVEL is GC_UNUSED or\n+\tALLOWED_UNDEFINED_TYPES is set.\n+\tSet ALLOWED_UNDEFINED_TYPES to true for TYPE_USER_STRUCT.\n+\t(filter_type_name): Accept templates with more than one\n+\targument.\n+\t(output_mangled_typename): Handle TYPE_UNDEFINED\n+\t(walk_type): Likewise.\n+\t(write_types_process_field): Likewise.\n+\t(write_func_for_structure): If CHAIN_NEXT is set, ORIG_S\n+\tshould not be a user-defined type.\n+\t(write_types_local_user_process_field): Handle TYPE_ARRAY,\n+\tTYPE_NONE and TYPE_UNDEFINED.\n+\t(write_types_local_process_field): Likewise.\n+\t(contains_scalar_p): Return 0 for TYPE_USER_STRUCT.\n+\t(write_root): Reject user-defined types that are not pointers.\n+\tHandle TYPE_NONE, TYPE_UNDEFINED, TYPE_UNION, TYPE_LANG_STRUCT\n+\tand TYPE_PARAM_STRUCT.\n+\t(output_typename): Handle TYPE_NONE, TYPE_UNDEFINED, and\n+\tTYPE_ARRAY.\n+\t(dump_typekind): Handle TYPE_UNDEFINED.\n+\t* gengtype.h (enum typekind): Add TYPE_UNDEFINED.\n+\t(create_user_defined_type): Declare.\n+\t(enum gty_token): Remove VEC_TOKEN.\n+\n+2012-11-16  Diego Novillo  <dnovillo@google.com>\n+\n+\tAdjust for new vec API (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n+\n+\t* coretypes.h (uchar): Define.\n+\t* alias.c: Use new vec API in vec.h.\n+\t* asan.c: Likewise.\n+\t* attribs.c: Likewise.\n+\t* basic-block.h: Likewise.\n+\t* bb-reorder.c: Likewise.\n+\t* builtins.c: Likewise.\n+\t* calls.c: Likewise.\n+\t* cfg.c: Likewise.\n+\t* cfganal.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfgexpand.c: Likewise.\n+\t* cfghooks.c: Likewise.\n+\t* cfghooks.h: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* cfgloop.h: Likewise.\n+\t* cfgloopanal.c: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cgraphclones.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* compare-elim.c: Likewise.\n+\t* coverage.c: Likewise.\n+\t* cprop.c: Likewise.\n+\t* data-streamer.h: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* dce.c: Likewise.\n+\t* df-core.c: Likewise.\n+\t* df-problems.c: Likewise.\n+\t* df-scan.c: Likewise.\n+\t* dominance.c: Likewise.\n+\t* domwalk.c: Likewise.\n+\t* domwalk.h: Likewise.\n+\t* dse.c: Likewise.\n+\t* dwarf2cfi.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* dwarf2out.h: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* except.c: Likewise.\n+\t* except.h: Likewise.\n+\t* expr.c: Likewise.\n+\t* expr.h: Likewise.\n+\t* final.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\t* function.h: Likewise.\n+\t* fwprop.c: Likewise.\n+\t* gcc.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattr.c: Likewise.\n+\t* genattrtab.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* genextract.c: Likewise.\n+\t* genopinit.c: Likewise\n+\t* ggc-common.c: Likewise.\n+\t* ggc.h: Likewise.\n+\t* gimple-low.c: Likewise.\n+\t* gimple-ssa-strength-reduction.c: Likewise.\n+\t* gimple-streamer-in.c: Likewise.\n+\t* gimple.c: Likewise.\n+\t* gimple.h: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* graph.c: Likewise.\n+\t* graphds.c: Likewise.\n+\t* graphds.h: Likewise.\n+\t* graphite-blocking.c: Likewise.\n+\t* graphite-clast-to-gimple.c: Likewise.\n+\t* graphite-dependences.c: Likewise.\n+\t* graphite-interchange.c: Likewise.\n+\t* graphite-optimize-isl.c: Likewise.\n+\t* graphite-poly.c: Likewise.\n+\t* graphite-poly.h: Likewise.\n+\t* graphite-scop-detection.c: Likewise.\n+\t* graphite-scop-detection.h: Likewise.\n+\t* graphite-sese-to-poly.c: Likewise.\n+\t* graphite.c: Likewise.\n+\t* godump.c: Likewise.\n+\t* haifa-sched.c: Likewise.\n+\t* hw-doloop.c: Likewise.\n+\t* hw-doloop.h: Likewise.\n+\t* ifcvt.c: Likewise.\n+\t* insn-addr.h: Likewise.\n+\t* ipa-cp.c: Likewise.\n+\t* ipa-inline-analysis.c: Likewise.\n+\t* ipa-inline-transform.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* ipa-inline.h: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-prop.h: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* ipa-ref-inline.h: Likewise.\n+\t* ipa-ref.c: Likewise.\n+\t* ipa-ref.h: Likewise.\n+\t* ipa-reference.c: Likewise.\n+\t* ipa-split.c: Likewise.\n+\t* ipa-utils.c: Likewise.\n+\t* ipa-utils.h: Likewise.\n+\t* ipa.c: Likewise.\n+\t* ira-build.c: Likewise.\n+\t* ira-color.c: Likewise.\n+\t* ira-emit.c: Likewise.\n+\t* ira-int.h: Likewise.\n+\t* ira.c: Likewise.\n+\t* loop-invariant.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* lower-subreg.c: Likewise.\n+\t* lra-lives.c: Likewise.\n+\t* lra.c: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* lto-section-out.c: Likewise.\n+\t* lto-streamer-in.c: Likewise.\n+\t* lto-streamer-out.c: Likewise.\n+\t* lto-streamer.h: Likewise.\n+\t* lto-symtab.c: Likewise.\n+\t* mcf.c: Likewise.\n+\t* modulo-sched.c: Likewise.\n+\t* omp-low.c: Likewise.\n+\t* opts-common.c: Likewise.\n+\t* opts-global.c: Likewise.\n+\t* opts.c: Likewise.\n+\t* opts.h: Likewise.\n+\t* passes.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* print-tree.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* profile.h: Likewise.\n+\t* read-rtl.c: Likewise.\n+\t* ree.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* regrename.c: Likewise.\n+\t* regrename.h: Likewise.\n+\t* reload.c: Likewise.\n+\t* reload.h: Likewise.\n+\t* reload1.c: Likewise.\n+\t* rtl.h: Likewise.\n+\t* sched-deps.c: Likewise.\n+\t* sched-int.h: Likewise.\n+\t* sdbout.c: Likewise.\n+\t* sel-sched-dump.c: Likewise.\n+\t* sel-sched-ir.c: Likewise.\n+\t* sel-sched-ir.h: Likewise.\n+\t* sel-sched.c: Likewise.\n+\t* sese.c: Likewise.\n+\t* sese.h: Likewise.\n+\t* statistics.h: Likewise.\n+\t* stmt.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* store-motion.c: Likewise.\n+\t* tlink.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* trans-mem.c: Likewise.\n+\t* tree-browser.c: Likewise.\n+\t* tree-call-cdce.c: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* tree-cfgcleanup.c: Likewise.\n+\t* tree-chrec.c: Likewise.\n+\t* tree-chrec.h: Likewise.\n+\t* tree-complex.c: Likewise.\n+\t* tree-data-ref.c: Likewise.\n+\t* tree-data-ref.h: Likewise.\n+\t* tree-dfa.c: Likewise.\n+\t* tree-diagnostic.c: Likewise.\n+\t* tree-dump.c: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* tree-emutls.c: Likewise.\n+\t* tree-flow.h: Likewise.\n+\t* tree-if-conv.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-inline.h: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-iterator.c: Likewise.\n+\t* tree-loop-distribution.c: Likewise.\n+\t* tree-mudflap.c: Likewise.\n+\t* tree-optimize.c: Likewise.\n+\t* tree-outof-ssa.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* tree-phinodes.c: Likewise.\n+\t* tree-predcom.c: Likewise.\n+\t* tree-pretty-print.c: Likewise.\n+\t* tree-scalar-evolution.c: Likewise.\n+\t* tree-sra.c: Likewise.\n+\t* tree-ssa-address.c: Likewise.\n+\t* tree-ssa-alias.c: Likewise.\n+\t* tree-ssa-ccp.c: Likewise.\n+\t* tree-ssa-coalesce.c: Likewise.\n+\t* tree-ssa-dce.c: Likewise.\n+\t* tree-ssa-dom.c: Likewise.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\t* tree-ssa-live.h: Likewise.\n+\t* tree-ssa-loop-im.c: Likewise.\n+\t* tree-ssa-loop-ivcanon.c: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-ssa-loop-manip.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-ssa-loop-prefetch.c: Likewise.\n+\t* tree-ssa-math-opts.c: Likewise.\n+\t* tree-ssa-operands.c: Likewise.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* tree-ssa-phiprop.c: Likewise.\n+\t* tree-ssa-pre.c: Likewise.\n+\t* tree-ssa-propagate.c: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* tree-ssa-sccvn.c: Likewise.\n+\t* tree-ssa-sccvn.h: Likewise.\n+\t* tree-ssa-strlen.c: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* tree-ssa-tail-merge.c: Likewise.\n+\t* tree-ssa-threadedge.c: Likewise.\n+\t* tree-ssa-threadupdate.c: Likewise.\n+\t* tree-ssa-uncprop.c: Likewise.\n+\t* tree-ssa-uninit.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* tree-ssanames.c: Likewise.\n+\t* tree-stdarg.c: Likewise.\n+\t* tree-streamer-in.c: Likewise.\n+\t* tree-streamer-out.c: Likewise.\n+\t* tree-streamer.c: Likewise.\n+\t* tree-streamer.h: Likewise.\n+\t* tree-switch-conversion.c: Likewise.\n+\t* tree-vect-data-refs.c: Likewise.\n+\t* tree-vect-generic.c: Likewise.\n+\t* tree-vect-loop-manip.c: Likewise.\n+\t* tree-vect-loop.c: Likewise.\n+\t* tree-vect-patterns.c: Likewise.\n+\t* tree-vect-slp.c: Likewise.\n+\t* tree-vect-stmts.c: Likewise.\n+\t* tree-vectorizer.c: Likewise.\n+\t* tree-vectorizer.h: Likewise.\n+\t* tree-vrp.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.h: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* value-prof.h: Likewise.\n+\t* var-tracking.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* varpool.c: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\t* config/bfin/bfin.c: Likewise.\n+\t* config/c6x/c6x.c: Likewise.\n+\t* config/darwin.c: Likewise.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/ia64/ia64.c: Likewise.\n+\t* config/mep/mep.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/rs6000/rs6000-c.c: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/rx/rx.c: Likewise.\n+\t* config/spu/spu-c.c: Likewise.\n+\t* config/vms/vms.c: Likewise.\n+\t* config/vxworks.c: Likewise.\n+\t* config/epiphany/resolve-sw-modes.c: Likewise.\n+\n 2012-11-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/55236"}, {"sha": "0a46425a4097fa0f47f8a3a7996feb6c50260206", "filename": "gcc/Makefile.in", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -835,9 +835,9 @@ REVISION_s  := \"\\\"\\\"\"\n endif\n \n # Shorthand variables for dependency lists.\n-VEC_H = vec.h statistics.h\n+VEC_H = vec.h statistics.h $(GGC_H)\n HASH_TABLE_H = $(HASHTAB_H) hash-table.h\n-EXCEPT_H = except.h $(HASHTAB_H) vecprim.h vecir.h\n+EXCEPT_H = except.h $(HASHTAB_H)\n TARGET_DEF = target.def target-hooks-macros.h\n C_TARGET_DEF = c-family/c-target.def target-hooks-macros.h\n COMMON_TARGET_DEF = common/common-target.def target-hooks-macros.h\n@@ -857,7 +857,7 @@ RTL_BASE_H = coretypes.h rtl.h rtl.def $(MACHMODE_H) reg-notes.def \\\n   insn-notes.def $(INPUT_H) $(REAL_H) statistics.h $(VEC_H) \\\n   $(FIXED_VALUE_H) alias.h $(HASHTAB_H)\n FIXED_VALUE_H = fixed-value.h $(MACHMODE_H) double-int.h\n-RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h vecir.h\n+RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h\n RTL_ERROR_H = rtl-error.h $(RTL_H) $(DIAGNOSTIC_CORE_H)\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params.def\n@@ -868,13 +868,13 @@ INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_H = coretypes.h tree.h all-tree.def tree.def c-family/c-common.def \\\n \t$(lang_tree_files) $(MACHMODE_H) tree-check.h $(BUILTINS_DEF) \\\n \t$(INPUT_H) statistics.h $(VEC_H) treestruct.def $(HASHTAB_H) \\\n-\tdouble-int.h alias.h $(SYMTAB_H) $(FLAGS_H) vecir.h \\\n+\tdouble-int.h alias.h $(SYMTAB_H) $(FLAGS_H) \\\n \t$(REAL_H) $(FIXED_VALUE_H)\n REGSET_H = regset.h $(BITMAP_H) hard-reg-set.h\n BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) \\\n \tcfg-flags.def cfghooks.h\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \\\n-\tvecir.h $(GGC_H) $(BASIC_BLOCK_H) $(TREE_H) tree-ssa-operands.h \\\n+\t$(GGC_H) $(BASIC_BLOCK_H) $(TREE_H) tree-ssa-operands.h \\\n \ttree-ssa-alias.h $(INTERNAL_FN_H)\n TRANS_MEM_H = trans-mem.h\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n@@ -885,17 +885,17 @@ ALIAS_H = alias.h\n EMIT_RTL_H = emit-rtl.h\n FLAGS_H = flags.h flag-types.h $(OPTIONS_H)\n OPTIONS_H = options.h flag-types.h $(OPTIONS_H_EXTRA)\n-FUNCTION_H = function.h $(HASHTAB_H) vecprim.h $(TM_H) hard-reg-set.h \\\n-\t$(VEC_H) vecir.h $(INPUT_H) $(MACHMODE_H)\n+FUNCTION_H = function.h $(HASHTAB_H) $(TM_H) hard-reg-set.h \\\n+\t$(VEC_H) $(INPUT_H) $(MACHMODE_H)\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n OPTABS_H = optabs.h insn-codes.h insn-opinit.h\n REGS_H = regs.h $(MACHMODE_H) hard-reg-set.h\n SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H) \\\n-\tvecprim.h $(REGSET_H)\n+\t$(REGSET_H)\n SEL_SCHED_IR_H = sel-sched-ir.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) \\\n-\t$(GGC_H) $(BITMAP_H) vecprim.h $(SCHED_INT_H) $(CFGLOOP_H) $(REGSET_H)\n+\t$(GGC_H) $(BITMAP_H) $(SCHED_INT_H) $(CFGLOOP_H) $(REGSET_H)\n SEL_SCHED_DUMP_H = sel-sched-dump.h $(SEL_SCHED_IR_H)\n-CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) vecprim.h double-int.h \\\n+CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) double-int.h \\\n \t$(BITMAP_H) sbitmap.h\n IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h $(BITMAP_H) $(TREE_H)\n@@ -912,7 +912,7 @@ GGC_H = ggc.h gtype-desc.h statistics.h\n GGC_INTERNAL_H = ggc-internal.h $(GGC_H)\n TIMEVAR_H = timevar.h timevar.def\n INSN_ATTR_H = insn-attr.h insn-attr-common.h $(INSN_ADDR_H)\n-INSN_ADDR_H = $(srcdir)/insn-addr.h vecprim.h\n+INSN_ADDR_H = $(srcdir)/insn-addr.h\n C_COMMON_H = c-family/c-common.h c-family/c-common.def $(TREE_H) \\\n \t$(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H) $(DIAGNOSTIC_CORE_H)\n C_PRAGMA_H = c-family/c-pragma.h $(CPPLIB_H)\n@@ -938,7 +938,7 @@ TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n \t\t$(BITMAP_H) sbitmap.h $(BASIC_BLOCK_H) $(GIMPLE_H) \\\n \t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H) \\\n \t\ttree-ssa-alias.h\n-TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H) vecprim.h\n+TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H)\n SSAEXPAND_H = ssaexpand.h $(TREE_SSA_LIVE_H)\n PRETTY_PRINT_H = pretty-print.h $(INPUT_H) $(OBSTACK_H)\n TREE_PRETTY_PRINT_H = tree-pretty-print.h $(PRETTY_PRINT_H)\n@@ -951,13 +951,13 @@ C_PRETTY_PRINT_H = c-family/c-pretty-print.h $(PRETTY_PRINT_H) \\\n SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n OMEGA_H = omega.h $(PARAMS_H)\n TREE_DATA_REF_H = tree-data-ref.h $(OMEGA_H) graphds.h $(SCEV_H)\n-TREE_INLINE_H = tree-inline.h vecir.h\n+TREE_INLINE_H = tree-inline.h\n REAL_H = real.h $(MACHMODE_H)\n IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h\n LRA_INT_H = lra.h $(BITMAP_H) $(RECOG_H) $(INSN_ATTR_H) insn-codes.h lra-int.h\n DBGCNT_H = dbgcnt.h dbgcnt.def\n LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n-\t\t$(CGRAPH_H) $(VEC_H) vecprim.h $(TREE_H) $(GIMPLE_H) \\\n+\t\t$(CGRAPH_H) $(VEC_H) $(TREE_H) $(GIMPLE_H) \\\n \t\t$(GCOV_IO_H) $(DIAGNOSTIC_H) alloc-pool.h\n DATA_STREAMER_H = data-streamer.h $(VEC_H) $(LTO_STREAMER_H)\n GIMPLE_STREAMER_H = gimple-streamer.h $(LTO_STREAMER_H) $(BASIC_BLOCK_H) \\\n@@ -2258,8 +2258,7 @@ tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(FUNCTION_H) $(TM_H) coretypes.h \\\n    langhooks.h domwalk.h $(TREE_PASS_H) $(PARAMS_H) $(BASIC_BLOCK_H) \\\n    $(BITMAP_H) $(CFGLOOP_H) $(FLAGS_H) $(HASHTAB_H) \\\n-   $(GIMPLE_H) $(TREE_INLINE_H) vecprim.h \\\n-   $(GIMPLE_PRETTY_PRINT_H)\n+   $(GIMPLE_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)\n tree-ssa-ter.o : tree-ssa-ter.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h dumpfile.h \\\n    $(TREE_SSA_LIVE_H) $(BITMAP_H) $(FLAGS_H) \\\n@@ -2488,7 +2487,7 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    langhooks.h \\\n    $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(GIMPLE_H) $(VEC_H) $(TARGET_H) \\\n-   vecprim.h pointer-set.h alloc-pool.h \\\n+   pointer-set.h alloc-pool.h \\\n    $(TREE_PRETTY_PRINT_H)\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) \\\n@@ -2740,7 +2739,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_\n    $(OPTABS_H) $(LIBFUNCS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h  $(EXCEPT_H) $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n    gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(PREDICT_H) \\\n-   $(TREE_PASS_H) $(DF_H) vecprim.h $(PARAMS_H) bb-reorder.h \\\n+   $(TREE_PASS_H) $(DF_H) $(PARAMS_H) bb-reorder.h \\\n    $(COMMON_TARGET_H)\n statistics.o : statistics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_PASS_H) $(TREE_DUMP_H) $(HASHTAB_H) statistics.h $(FUNCTION_H)\n@@ -2763,12 +2762,12 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    typeclass.h hard-reg-set.h toplev.h $(DIAGNOSTIC_CORE_H) hard-reg-set.h $(EXCEPT_H) \\\n    reload.h langhooks.h intl.h $(TM_P_H) $(TARGET_H) \\\n    tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \\\n-   $(TREE_PASS_H) $(DF_H) $(DIAGNOSTIC_H) vecprim.h $(SSAEXPAND_H) \\\n+   $(TREE_PASS_H) $(DF_H) $(DIAGNOSTIC_H) $(SSAEXPAND_H) \\\n    $(PARAMS_H) $(COMMON_TARGET_H) target-globals.h\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TM_P_H) \\\n    $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n-   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H)\n+   langhooks.h $(GGC_H) gt-dojump.h $(BASIC_BLOCK_H)\n builtins.o : builtins.c builtins.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(TARGET_H) $(FUNCTION_H) $(REGS_H) \\\n    $(EXPR_H) $(OPTABS_H) insn-config.h $(RECOG_H) output.h typeclass.h \\\n@@ -2826,7 +2825,7 @@ xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n godump.o : godump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) \\\n    $(TREE_H) $(GGC_H) pointer-set.h $(OBSTACK_H) debug.h gt-godump.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) vecprim.h \\\n+   $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \\\n    $(GGC_H) $(EXPR_H) hard-reg-set.h $(BITMAP_H) $(DIAGNOSTIC_CORE_H) $(BASIC_BLOCK_H) \\\n    $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h $(TREE_PASS_H) gt-emit-rtl.h \\\n    $(DF_H) $(PARAMS_H) $(TARGET_H)\n@@ -3045,7 +3044,7 @@ df-core.o : df-core.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n df-problems.o : df-problems.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \\\n-   $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(EXCEPT_H) dce.h vecprim.h $(VALTRACK_H)\n+   $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(EXCEPT_H) dce.h $(VALTRACK_H)\n df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h \\\n@@ -3105,7 +3104,7 @@ cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \\\n    $(TREE_PASS_H) $(DF_H) $(GGC_H) $(COMMON_TARGET_H) gt-cfgrtl.h\n cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(BASIC_BLOCK_H) \\\n-   $(TIMEVAR_H) vecprim.h sbitmap.h $(BITMAP_H)\n+   $(TIMEVAR_H) sbitmap.h $(BITMAP_H)\n cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h $(DIAGNOSTIC_CORE_H) \\\n    $(FUNCTION_H) $(EXCEPT_H) $(TIMEVAR_H) $(TREE_H) $(EXPR_H) sbitmap.h\n@@ -3122,7 +3121,7 @@ cfgloopanal.o : cfgloopanal.c coretypes.h dumpfile.h $(CONFIG_H) $(SYSTEM_H) $(R\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) $(TM_H) \\\n    $(OBSTACK_H) graphds.h $(PARAMS_H)\n graphds.o : graphds.c graphds.h $(CONFIG_H) $(SYSTEM_H) $(BITMAP_H) $(OBSTACK_H) \\\n-   coretypes.h $(VEC_H) vecprim.h\n+   coretypes.h $(VEC_H)\n loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \\\n    $(RTL_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) $(TM_H) $(OBSTACK_H) \\\n@@ -3147,7 +3146,7 @@ loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \\\n    $(OBSTACK_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) $(DIAGNOSTIC_CORE_H) \\\n-   $(TIMEVAR_H) graphds.h vecprim.h pointer-set.h $(BITMAP_H)\n+   $(TIMEVAR_H) graphds.h pointer-set.h $(BITMAP_H)\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    et-forest.h alloc-pool.h $(BASIC_BLOCK_H)\n combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n@@ -3156,7 +3155,7 @@ combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(TREE_H) $(TARGET_H) \\\n    output.h $(PARAMS_H) $(OPTABS_H) \\\n    insn-codes.h $(TREE_PASS_H) $(DF_H) $(VALTRACK_H) \\\n-   vecprim.h $(CGRAPH_H) $(OBSTACK_H)\n+   $(CGRAPH_H) $(OBSTACK_H)\n reginfo.o : reginfo.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) addresses.h $(REGS_H) \\\n    insn-config.h $(RECOG_H) reload.h $(DIAGNOSTIC_CORE_H) \\\n@@ -3198,7 +3197,7 @@ caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \\\n bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(EXCEPT_H) \\\n    $(RTL_H) hard-reg-set.h $(REGS_H) $(TM_P_H) $(FIBHEAP_H) $(EXPR_H) \\\n    $(TARGET_H) $(FLAGS_H) $(INSN_ATTR_H) $(FUNCTION_H) $(TREE_PASS_H) \\\n-   $(DIAGNOSTIC_CORE_H) $(DF_H) vecprim.h $(RECOG_H) $(CFGLOOP_H)\n+   $(DIAGNOSTIC_CORE_H) $(DF_H) $(RECOG_H) $(CFGLOOP_H)\n reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    conditions.h hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \\\n    $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) $(FUNCTION_H) $(FLAGS_H) output.h \\\n@@ -3350,7 +3349,7 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(EXCEPT_H) debug.h xcoffout.h toplev.h $(DIAGNOSTIC_CORE_H) reload.h $(DWARF2OUT_H) \\\n    $(TREE_PASS_H) $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) \\\n    dbxout.h $(CGRAPH_H) $(COVERAGE_H) \\\n-   $(DF_H) vecprim.h $(GGC_H) $(CFGLOOP_H) $(PARAMS_H) $(TREE_FLOW_H) \\\n+   $(DF_H) $(GGC_H) $(CFGLOOP_H) $(PARAMS_H) $(TREE_FLOW_H) \\\n    $(TARGET_DEF_H) $(TREE_PRETTY_PRINT_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) \\\n@@ -3361,7 +3360,7 @@ reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_ERROR_H) $(TREE_H) $(RECOG_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    insn-config.h reload.h $(FUNCTION_H) $(TM_P_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) \\\n-   $(TREE_PASS_H) $(TARGET_H) vecprim.h $(DF_H) $(EMIT_RTL_H)\n+   $(TREE_PASS_H) $(TARGET_H) $(DF_H) $(EMIT_RTL_H)\n sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h sreal.h\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \\\n@@ -3689,7 +3688,6 @@ s-tm-texi: build/genhooks$(build_exeext) $(srcdir)/doc/tm.texi.in\n \tfi\n \n GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n-  $(srcdir)/vecprim.h $(srcdir)/vecir.h \\\n   $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n   $(srcdir)/alias.h $(srcdir)/coverage.c $(srcdir)/rtl.h \\\n@@ -3851,7 +3849,7 @@ build/genattr-common.o : genattr-common.c $(RTL_BASE_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)\t\\\n-  $(READ_MD_H) gensupport.h vecprim.h $(FNMATCH_H)\n+  $(READ_MD_H) gensupport.h $(FNMATCH_H)\n build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(VEC_H)\t\\\n   $(HASHTAB_H) gensupport.h $(FNMATCH_H)\n@@ -3873,8 +3871,7 @@ build/genemit.o : genemit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n build/genenums.o : genenums.c $(BCONFIG_H) $(SYSTEM_H)\t\t\t\\\n   coretypes.h errors.h $(READ_MD_H)\n build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H)\t\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\t\\\n-  vecprim.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def"}, {"sha": "d01835486ba0b37cc6305d207c02fe6e0e5e65c2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1,3 +1,13 @@\n+2012-11-16  Diego Novillo  <dnovillo@google.com>\n+\n+\tAdjust for new vec API (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n+\n+\t* gcc-interface/decl.c: Use new vec API in vec.h.\n+\t* gcc-interface/gigi.h: Likewise.\n+\t* gcc-interface/trans.c: Likewise.\n+\t* gcc-interface/utils.c: Likewise.\n+\t* gcc-interface/utils2.c: Likewise.\n+\n 2012-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR other/52438"}, {"sha": "b3cf22c51c71569732f8898a20a3e43f523609d4", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -106,8 +106,6 @@ typedef struct subst_pair_d {\n   tree replacement;\n } subst_pair;\n \n-DEF_VEC_O(subst_pair);\n-DEF_VEC_ALLOC_O(subst_pair,heap);\n \n typedef struct variant_desc_d {\n   /* The type of the variant.  */\n@@ -123,8 +121,6 @@ typedef struct variant_desc_d {\n   tree new_type;\n } variant_desc;\n \n-DEF_VEC_O(variant_desc);\n-DEF_VEC_ALLOC_O(variant_desc,heap);\n \n /* A hash table used to cache the result of annotate_value.  */\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n@@ -153,21 +149,21 @@ static void components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n-static VEC(subst_pair,heap) *build_subst_list (Entity_Id, Entity_Id, bool);\n-static VEC(variant_desc,heap) *build_variant_list (tree,\n-\t\t\t\t\t\t   VEC(subst_pair,heap) *,\n-\t\t\t\t\t\t   VEC(variant_desc,heap) *);\n+static vec<subst_pair> build_subst_list (Entity_Id, Entity_Id, bool);\n+static vec<variant_desc> build_variant_list (tree,\n+\t\t\t\t\t\t   vec<subst_pair> ,\n+\t\t\t\t\t\t   vec<variant_desc> );\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n static tree create_field_decl_from (tree, tree, tree, tree, tree,\n-\t\t\t\t    VEC(subst_pair,heap) *);\n+\t\t\t\t    vec<subst_pair> );\n static tree create_rep_part (tree, tree, tree);\n static tree get_rep_part (tree);\n-static tree create_variant_part_from (tree, VEC(variant_desc,heap) *, tree,\n-\t\t\t\t      tree, VEC(subst_pair,heap) *);\n-static void copy_and_substitute_in_size (tree, tree, VEC(subst_pair,heap) *);\n+static tree create_variant_part_from (tree, vec<variant_desc> , tree,\n+\t\t\t\t      tree, vec<subst_pair> );\n+static void copy_and_substitute_in_size (tree, tree, vec<subst_pair> );\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n    to pass around calls performing profile compatibility checks.  */\n@@ -1157,7 +1153,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = TYPE_PADDING_P (gnu_type)\n \t\t? TYPE_FIELDS (TREE_TYPE (TYPE_FIELDS (gnu_type)))\n \t\t: TYPE_FIELDS (gnu_type);\n-\t    VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n+\t    vec<constructor_elt, va_gc> *v;\n+\t    vec_alloc (v, 1);\n \t    tree t = build_template (TREE_TYPE (template_field),\n \t\t\t\t     TREE_TYPE (DECL_CHAIN (template_field)),\n \t\t\t\t     NULL_TREE);\n@@ -1329,8 +1326,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_alloc_type)));\n \n \t\t    if (TREE_CODE (gnu_expr) == CONSTRUCTOR\n-\t\t\t&& 1 == VEC_length (constructor_elt,\n-\t\t\t\t\t    CONSTRUCTOR_ELTS (gnu_expr)))\n+\t\t\t&& 1 == vec_safe_length (CONSTRUCTOR_ELTS (gnu_expr)))\n \t\t      gnu_expr = 0;\n \t\t    else\n \t\t      gnu_expr\n@@ -3293,13 +3289,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      && Present (Discriminant_Constraint (gnat_entity))\n \t      && Stored_Constraint (gnat_entity) != No_Elist)\n \t    {\n-\t      VEC(subst_pair,heap) *gnu_subst_list\n+\t      vec<subst_pair> gnu_subst_list\n \t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n \t      tree gnu_unpad_base_type, gnu_rep_part, gnu_variant_part, t;\n \t      tree gnu_pos_list, gnu_field_list = NULL_TREE;\n \t      bool selected_variant = false;\n \t      Entity_Id gnat_field;\n-\t      VEC(variant_desc,heap) *gnu_variant_list;\n+\t      vec<variant_desc> gnu_variant_list;\n \n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n@@ -3330,12 +3326,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t  gnu_variant_list\n \t\t    = build_variant_list (TREE_TYPE (gnu_variant_part),\n-\t\t\t\t\t  gnu_subst_list, NULL);\n+\t\t\t\t\t  gnu_subst_list,\n+\t\t\t\t\t  vec<variant_desc>());\n \n \t\t  /* If all the qualifiers are unconditionally true, the\n \t\t     innermost variant is statically selected.  */\n \t\t  selected_variant = true;\n-\t\t  FOR_EACH_VEC_ELT (variant_desc, gnu_variant_list, i, v)\n+\t\t  FOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n \t\t    if (!integer_onep (v->qual))\n \t\t      {\n \t\t\tselected_variant = false;\n@@ -3344,7 +3341,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t  /* Otherwise, create the new variants.  */\n \t\t  if (!selected_variant)\n-\t\t    FOR_EACH_VEC_ELT (variant_desc, gnu_variant_list, i, v)\n+\t\t    FOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n \t\t      {\n \t\t\ttree old_variant = v->type;\n \t\t\ttree new_variant = make_node (RECORD_TYPE);\n@@ -3362,13 +3359,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \t      else\n \t\t{\n-\t\t  gnu_variant_list = NULL;\n+\t\t  gnu_variant_list.create (0);\n \t\t  selected_variant = false;\n \t\t}\n \n \t      gnu_pos_list\n \t\t= build_position_list (gnu_unpad_base_type,\n-\t\t\t\t       gnu_variant_list && !selected_variant,\n+\t\t\t\t       gnu_variant_list.exists ()\n+\t\t\t\t\t  && !selected_variant,\n \t\t\t\t       size_zero_node, bitsize_zero_node,\n \t\t\t\t       BIGGEST_ALIGNMENT, NULL_TREE);\n \n@@ -3449,7 +3447,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\tunsigned int i;\n \n \t\t\tt = NULL_TREE;\n-\t\t\tFOR_EACH_VEC_ELT (variant_desc, gnu_variant_list, i, v)\n+\t\t\tFOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n \t\t\t  if (gnu_context == v->type\n \t\t\t      || ((gnu_rep_part = get_rep_part (v->type))\n \t\t\t\t  && gnu_context == TREE_TYPE (gnu_rep_part)))\n@@ -3515,7 +3513,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* If there is a variant list and no selected variant, we need\n \t\t to create the nest of variant parts from the old nest.  */\n-\t      if (gnu_variant_list && !selected_variant)\n+\t      if (gnu_variant_list.exists () && !selected_variant)\n \t\t{\n \t\t  tree new_variant_part\n \t\t    = create_variant_part_from (gnu_variant_part,\n@@ -3587,8 +3585,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t gnat_entity);\n \t\t}\n \n-\t      VEC_free (variant_desc, heap, gnu_variant_list);\n-\t      VEC_free (subst_pair, heap, gnu_subst_list);\n+\t      gnu_variant_list.release ();\n+\t      gnu_subst_list.release ();\n \n \t      /* Now we can finalize it.  */\n \t      rest_of_record_type_compilation (gnu_type);\n@@ -7551,10 +7549,10 @@ build_position_list (tree gnu_type, bool do_not_flatten_variant, tree gnu_pos,\n    of operands to SUBSTITUTE_IN_EXPR.  DEFINITION is true if this is for\n    a definition of GNAT_SUBTYPE.  */\n \n-static VEC(subst_pair,heap) *\n+static vec<subst_pair> \n build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n {\n-  VEC(subst_pair,heap) *gnu_list = NULL;\n+  vec<subst_pair> gnu_list = vec<subst_pair>();\n   Entity_Id gnat_discrim;\n   Node_Id gnat_value;\n \n@@ -7573,7 +7571,7 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n \t\t\t\t     get_entity_name (gnat_discrim),\n \t\t\t\t     definition, true, false));\n \tsubst_pair s = {gnu_field, replacement};\n-\tVEC_safe_push (subst_pair, heap, gnu_list, s);\n+\tgnu_list.safe_push (s);\n       }\n \n   return gnu_list;\n@@ -7584,9 +7582,9 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n    the substitutions described in SUBST_LIST.  GNU_LIST is a pre-existing\n    list to be prepended to the newly created entries.  */\n \n-static VEC(variant_desc,heap) *\n-build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n-\t\t    VEC(variant_desc,heap) *gnu_list)\n+static vec<variant_desc> \n+build_variant_list (tree qual_union_type, vec<subst_pair> subst_list,\n+\t\t    vec<variant_desc> gnu_list)\n {\n   tree gnu_field;\n \n@@ -7598,7 +7596,7 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n       unsigned int i;\n       subst_pair *s;\n \n-      FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n+      FOR_EACH_VEC_ELT (subst_list, i, s)\n \tqual = SUBSTITUTE_IN_EXPR (qual, s->discriminant, s->replacement);\n \n       /* If the new qualifier is not unconditionally false, its variant may\n@@ -7608,7 +7606,7 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n \t  tree variant_type = TREE_TYPE (gnu_field), variant_subpart;\n \t  variant_desc v = {variant_type, gnu_field, qual, NULL_TREE};\n \n-\t  VEC_safe_push (variant_desc, heap, gnu_list, v);\n+\t  gnu_list.safe_push (v);\n \n \t  /* Recurse on the variant subpart of the variant, if any.  */\n \t  variant_subpart = get_variant_part (variant_type);\n@@ -8170,7 +8168,7 @@ intrin_profiles_compatible_p (intrin_binding_t * inb)\n static tree\n create_field_decl_from (tree old_field, tree field_type, tree record_type,\n \t\t\ttree size, tree pos_list,\n-\t\t\tVEC(subst_pair,heap) *subst_list)\n+\t\t\tvec<subst_pair> subst_list)\n {\n   tree t = TREE_VALUE (purpose_member (old_field, pos_list));\n   tree pos = TREE_VEC_ELT (t, 0), bitpos = TREE_VEC_ELT (t, 2);\n@@ -8180,7 +8178,7 @@ create_field_decl_from (tree old_field, tree field_type, tree record_type,\n   subst_pair *s;\n \n   if (CONTAINS_PLACEHOLDER_P (pos))\n-    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n+    FOR_EACH_VEC_ELT (subst_list, i, s)\n       pos = SUBSTITUTE_IN_EXPR (pos, s->discriminant, s->replacement);\n \n   /* If the position is now a constant, we can set it as the position of the\n@@ -8276,9 +8274,9 @@ get_variant_part (tree record_type)\n \n static tree\n create_variant_part_from (tree old_variant_part,\n-\t\t\t  VEC(variant_desc,heap) *variant_list,\n+\t\t\t  vec<variant_desc> variant_list,\n \t\t\t  tree record_type, tree pos_list,\n-\t\t\t  VEC(subst_pair,heap) *subst_list)\n+\t\t\t  vec<subst_pair> subst_list)\n {\n   tree offset = DECL_FIELD_OFFSET (old_variant_part);\n   tree old_union_type = TREE_TYPE (old_variant_part);\n@@ -8315,7 +8313,7 @@ create_variant_part_from (tree old_variant_part,\n     copy_and_substitute_in_size (new_union_type, old_union_type, subst_list);\n \n   /* Now finish up the new variants and populate the union type.  */\n-  FOR_EACH_VEC_ELT_REVERSE (variant_desc, variant_list, i, v)\n+  FOR_EACH_VEC_ELT_REVERSE (variant_list, i, v)\n     {\n       tree old_field = v->field, new_field;\n       tree old_variant, old_variant_subpart, new_variant, field_list;\n@@ -8397,7 +8395,7 @@ create_variant_part_from (tree old_variant_part,\n \n static void\n copy_and_substitute_in_size (tree new_type, tree old_type,\n-\t\t\t     VEC(subst_pair,heap) *subst_list)\n+\t\t\t     vec<subst_pair> subst_list)\n {\n   unsigned int i;\n   subst_pair *s;\n@@ -8409,19 +8407,19 @@ copy_and_substitute_in_size (tree new_type, tree old_type,\n   relate_alias_sets (new_type, old_type, ALIAS_SET_COPY);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (new_type)))\n-    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n+    FOR_EACH_VEC_ELT (subst_list, i, s)\n       TYPE_SIZE (new_type)\n \t= SUBSTITUTE_IN_EXPR (TYPE_SIZE (new_type),\n \t\t\t      s->discriminant, s->replacement);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (new_type)))\n-    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n+    FOR_EACH_VEC_ELT (subst_list, i, s)\n       TYPE_SIZE_UNIT (new_type)\n \t= SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (new_type),\n \t\t\t      s->discriminant, s->replacement);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_ADA_SIZE (new_type)))\n-    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n+    FOR_EACH_VEC_ELT (subst_list, i, s)\n       SET_TYPE_ADA_SIZE\n \t(new_type, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (new_type),\n \t\t\t\t       s->discriminant, s->replacement));"}, {"sha": "1d0d2fb216789f5b4806bc147ba29ff60ac12f58", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -884,7 +884,7 @@ extern tree build_call_raise_column (int msg, Node_Id gnat_node);\n \n /* Return a CONSTRUCTOR of TYPE whose elements are V.  This is not the\n    same as build_constructor in the language-independent tree.c.  */\n-extern tree gnat_build_constructor (tree type, VEC(constructor_elt,gc) *v);\n+extern tree gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v);\n \n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,"}, {"sha": "2b23627681b0ea4ea3ffec30e61af6e99fc57e85", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 87, "deletions": 103, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -110,11 +110,9 @@ bool type_annotate_only;\n /* Current filename without path.  */\n const char *ref_filename;\n \n-DEF_VEC_I(Node_Id);\n-DEF_VEC_ALLOC_I(Node_Id,heap);\n \n /* List of N_Validate_Unchecked_Conversion nodes in the unit.  */\n-static VEC(Node_Id,heap) *gnat_validate_uc_list;\n+static vec<Node_Id> gnat_validate_uc_list;\n \n /* When not optimizing, we cache the 'First, 'Last and 'Length attributes\n    of unconstrained array IN parameters to avoid emitting a great deal of\n@@ -129,13 +127,11 @@ struct GTY (()) parm_attr_d {\n \n typedef struct parm_attr_d *parm_attr;\n \n-DEF_VEC_P(parm_attr);\n-DEF_VEC_ALLOC_P(parm_attr,gc);\n \n struct GTY(()) language_function {\n-  VEC(parm_attr,gc) *parm_attr_cache;\n+  vec<parm_attr, va_gc> *parm_attr_cache;\n   bitmap named_ret_val;\n-  VEC(tree,gc) *other_ret_val;\n+  vec<tree, va_gc> *other_ret_val;\n   int gnat_ret;\n };\n \n@@ -184,21 +180,21 @@ static GTY(()) struct elab_info *elab_info_list;\n /* Stack of exception pointer variables.  Each entry is the VAR_DECL\n    that stores the address of the raised exception.  Nonzero means we\n    are in an exception handler.  Not used in the zero-cost case.  */\n-static GTY(()) VEC(tree,gc) *gnu_except_ptr_stack;\n+static GTY(()) vec<tree, va_gc> *gnu_except_ptr_stack;\n \n /* In ZCX case, current exception pointer.  Used to re-raise it.  */\n static GTY(()) tree gnu_incoming_exc_ptr;\n \n /* Stack for storing the current elaboration procedure decl.  */\n-static GTY(()) VEC(tree,gc) *gnu_elab_proc_stack;\n+static GTY(()) vec<tree, va_gc> *gnu_elab_proc_stack;\n \n /* Stack of labels to be used as a goto target instead of a return in\n    some functions.  See processing for N_Subprogram_Body.  */\n-static GTY(()) VEC(tree,gc) *gnu_return_label_stack;\n+static GTY(()) vec<tree, va_gc> *gnu_return_label_stack;\n \n /* Stack of variable for the return value of a function with copy-in/copy-out\n    parameters.  See processing for N_Subprogram_Body.  */\n-static GTY(()) VEC(tree,gc) *gnu_return_var_stack;\n+static GTY(()) vec<tree, va_gc> *gnu_return_var_stack;\n \n /* Structure used to record information for a range check.  */\n struct GTY(()) range_check_info_d {\n@@ -210,28 +206,24 @@ struct GTY(()) range_check_info_d {\n \n typedef struct range_check_info_d *range_check_info;\n \n-DEF_VEC_P(range_check_info);\n-DEF_VEC_ALLOC_P(range_check_info,gc);\n \n /* Structure used to record information for a loop.  */\n struct GTY(()) loop_info_d {\n   tree label;\n   tree loop_var;\n-  VEC(range_check_info,gc) *checks;\n+  vec<range_check_info, va_gc> *checks;\n };\n \n typedef struct loop_info_d *loop_info;\n \n-DEF_VEC_P(loop_info);\n-DEF_VEC_ALLOC_P(loop_info,gc);\n \n /* Stack of loop_info structures associated with LOOP_STMT nodes.  */\n-static GTY(()) VEC(loop_info,gc) *gnu_loop_stack;\n+static GTY(()) vec<loop_info, va_gc> *gnu_loop_stack;\n \n /* The stacks for N_{Push,Pop}_*_Label.  */\n-static GTY(()) VEC(tree,gc) *gnu_constraint_error_label_stack;\n-static GTY(()) VEC(tree,gc) *gnu_storage_error_label_stack;\n-static GTY(()) VEC(tree,gc) *gnu_program_error_label_stack;\n+static GTY(()) vec<tree, va_gc> *gnu_constraint_error_label_stack;\n+static GTY(()) vec<tree, va_gc> *gnu_storage_error_label_stack;\n+static GTY(()) vec<tree, va_gc> *gnu_program_error_label_stack;\n \n /* Map GNAT tree codes to GCC tree codes for simple expressions.  */\n static enum tree_code gnu_codes[Number_Node_Kinds];\n@@ -242,7 +234,7 @@ static void record_code_position (Node_Id);\n static void insert_code_for (Node_Id);\n static void add_cleanup (tree, Node_Id);\n static void add_stmt_list (List_Id);\n-static void push_exception_label_stack (VEC(tree,gc) **, Entity_Id);\n+static void push_exception_label_stack (vec<tree, va_gc> **, Entity_Id);\n static tree build_stmt_group (List_Id, bool);\n static inline bool stmt_group_may_fallthru (void);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n@@ -588,14 +580,12 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       tree null_node = fold_convert (ptr_void_ftype, null_pointer_node);\n       tree field_list = NULL_TREE;\n       int j;\n-      VEC(constructor_elt,gc) *null_vec = NULL;\n+      vec<constructor_elt, va_gc> *null_vec = NULL;\n       constructor_elt *elt;\n \n       fdesc_type_node = make_node (RECORD_TYPE);\n-      VEC_safe_grow (constructor_elt, gc, null_vec,\n-\t\t     TARGET_VTABLE_USES_DESCRIPTORS);\n-      elt = (VEC_address (constructor_elt,null_vec)\n-\t     + TARGET_VTABLE_USES_DESCRIPTORS - 1);\n+      vec_safe_grow (null_vec, TARGET_VTABLE_USES_DESCRIPTORS);\n+      elt = (null_vec->address () + TARGET_VTABLE_USES_DESCRIPTORS - 1);\n \n       for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; j++)\n \t{\n@@ -651,10 +641,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n      user available facilities for Intrinsic imports.  */\n   gnat_install_builtins ();\n \n-  VEC_safe_push (tree, gc, gnu_except_ptr_stack, NULL_TREE);\n-  VEC_safe_push (tree, gc, gnu_constraint_error_label_stack, NULL_TREE);\n-  VEC_safe_push (tree, gc, gnu_storage_error_label_stack, NULL_TREE);\n-  VEC_safe_push (tree, gc, gnu_program_error_label_stack, NULL_TREE);\n+  vec_safe_push (gnu_except_ptr_stack, NULL_TREE);\n+  vec_safe_push (gnu_constraint_error_label_stack, NULL_TREE);\n+  vec_safe_push (gnu_storage_error_label_stack, NULL_TREE);\n+  vec_safe_push (gnu_program_error_label_stack, NULL_TREE);\n \n   /* Process any Pragma Ident for the main unit.  */\n   if (Present (Ident_String (Main_Unit)))\n@@ -671,9 +661,9 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   /* Then process the N_Validate_Unchecked_Conversion nodes.  We do this at\n      the very end to avoid having to second-guess the front-end when we run\n      into dummy nodes during the regular processing.  */\n-  for (i = 0; VEC_iterate (Node_Id, gnat_validate_uc_list, i, gnat_iter); i++)\n+  for (i = 0; gnat_validate_uc_list.iterate (i, &gnat_iter); i++)\n     validate_unchecked_conversion (gnat_iter);\n-  VEC_free (Node_Id, heap, gnat_validate_uc_list);\n+  gnat_validate_uc_list.release ();\n \n   /* Finally see if we have any elaboration procedures to deal with.  */\n   for (info = elab_info_list; info; info = info->next)\n@@ -1367,7 +1357,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  /* Descriptors can only be built here for top-level functions.  */\n \t  bool build_descriptor = (global_bindings_p () != 0);\n \t  int i;\n-\t  VEC(constructor_elt,gc) *gnu_vec = NULL;\n+\t  vec<constructor_elt, va_gc> *gnu_vec = NULL;\n \t  constructor_elt *elt;\n \n \t  gnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -1383,10 +1373,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t      gnu_result = build1 (INDIRECT_REF, gnu_result_type, gnu_result);\n \t    }\n \n-\t  VEC_safe_grow (constructor_elt, gc, gnu_vec,\n-\t\t\t TARGET_VTABLE_USES_DESCRIPTORS);\n-\t  elt = (VEC_address (constructor_elt, gnu_vec)\n-\t\t + TARGET_VTABLE_USES_DESCRIPTORS - 1);\n+\t  vec_safe_grow (gnu_vec, TARGET_VTABLE_USES_DESCRIPTORS);\n+\t  elt = (gnu_vec->address () + TARGET_VTABLE_USES_DESCRIPTORS - 1);\n \t  for (gnu_field = TYPE_FIELDS (gnu_result_type), i = 0;\n \t       i < TARGET_VTABLE_USES_DESCRIPTORS;\n \t       gnu_field = DECL_CHAIN (gnu_field), i++)\n@@ -1739,7 +1727,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t   and the dimension in the cache and create a new one on failure.  */\n \tif (!optimize && Present (gnat_param))\n \t  {\n-\t    FOR_EACH_VEC_ELT (parm_attr, f_parm_attr_cache, i, pa)\n+\t    FOR_EACH_VEC_SAFE_ELT (f_parm_attr_cache, i, pa)\n \t      if (pa->id == gnat_param && pa->dim == Dimension)\n \t\tbreak;\n \n@@ -1748,7 +1736,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\tpa = ggc_alloc_cleared_parm_attr_d ();\n \t\tpa->id = gnat_param;\n \t\tpa->dim = Dimension;\n-\t\tVEC_safe_push (parm_attr, gc, f_parm_attr_cache, pa);\n+\t\tvec_safe_push (f_parm_attr_cache, pa);\n \t      }\n \t  }\n \n@@ -2210,7 +2198,7 @@ push_range_check_info (tree var)\n   struct loop_info_d *iter = NULL;\n   unsigned int i;\n \n-  if (VEC_empty (loop_info, gnu_loop_stack))\n+  if (vec_safe_is_empty (gnu_loop_stack))\n     return NULL;\n \n   var = remove_conversions (var, false);\n@@ -2221,16 +2209,16 @@ push_range_check_info (tree var)\n   if (decl_function_context (var) != current_function_decl)\n     return NULL;\n \n-  for (i = VEC_length (loop_info, gnu_loop_stack) - 1;\n-       VEC_iterate (loop_info, gnu_loop_stack, i, iter);\n+  for (i = vec_safe_length (gnu_loop_stack) - 1;\n+       vec_safe_iterate (gnu_loop_stack, i, &iter);\n        i--)\n     if (var == iter->loop_var)\n       break;\n \n   if (iter)\n     {\n       struct range_check_info_d *rci = ggc_alloc_range_check_info_d ();\n-      VEC_safe_push (range_check_info, gc, iter->checks, rci);\n+      vec_safe_push (iter->checks, rci);\n       return rci;\n     }\n \n@@ -2312,7 +2300,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   tree gnu_result;\n \n   /* Push the loop_info structure associated with the LOOP_STMT.  */\n-  VEC_safe_push (loop_info, gc, gnu_loop_stack, gnu_loop_info);\n+  vec_safe_push (gnu_loop_stack, gnu_loop_info);\n \n   /* Set location information for statement and end label.  */\n   set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n@@ -2576,7 +2564,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   if (Present (gnat_iter_scheme) && No (Condition (gnat_iter_scheme)))\n     {\n       struct range_check_info_d *rci;\n-      unsigned n_checks = VEC_length (range_check_info, gnu_loop_info->checks);\n+      unsigned n_checks = vec_safe_length (gnu_loop_info->checks);\n       unsigned int i;\n \n       /* First, if we have computed a small number of invariant conditions for\n@@ -2593,7 +2581,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t\t that can be entirely optimized away in the end.  */\n       if (1 <= n_checks && n_checks <= 4)\n \tfor (i = 0;\n-\t     VEC_iterate (range_check_info, gnu_loop_info->checks, i, rci);\n+\t     vec_safe_iterate (gnu_loop_info->checks, i, &rci);\n \t     i++)\n \t  {\n \t    tree low_ok\n@@ -2636,7 +2624,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   else\n     gnu_result = gnu_loop_stmt;\n \n-  VEC_pop (loop_info, gnu_loop_stack);\n+  gnu_loop_stack->pop ();\n \n   return gnu_result;\n }\n@@ -2928,10 +2916,8 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  if (TYPE_IS_FAT_POINTER_P (TREE_TYPE (ret_val)))\n \t    ret_val\n-\t      = VEC_index (constructor_elt,\n-\t\t\t   CONSTRUCTOR_ELTS\n-\t\t\t   (TREE_OPERAND (TREE_OPERAND (ret_val, 0), 1)),\n-\t\t\t    1).value;\n+\t      = (*CONSTRUCTOR_ELTS (TREE_OPERAND (TREE_OPERAND (ret_val, 0),\n+\t\t\t\t\t\t1)))[1].value;\n \t  else\n \t    ret_val = TREE_OPERAND (TREE_OPERAND (ret_val, 0), 1);\n \t}\n@@ -2960,7 +2946,8 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n       tree saved_current_function_decl = current_function_decl;\n       tree var = DECL_EXPR_DECL (t);\n       tree alloc, p_array, new_var, new_ret;\n-      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n+      vec<constructor_elt, va_gc> *v;\n+      vec_alloc (v, 2);\n \n       /* Create an artificial context to build the allocation.  */\n       current_function_decl = decl_function_context (var);\n@@ -2988,19 +2975,15 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n \t  DECL_INITIAL (new_var)\n \t    = build2 (COMPOUND_EXPR, TREE_TYPE (new_var),\n \t\t      TREE_OPERAND (alloc, 0),\n-\t\t      VEC_index (constructor_elt,\n-\t\t\t\t CONSTRUCTOR_ELTS (TREE_OPERAND (alloc, 1)),\n-\t\t\t\t\t\t   0).value);\n+\t\t      (*CONSTRUCTOR_ELTS (TREE_OPERAND (alloc, 1)))[0].value);\n \n \t  /* Build a modified CONSTRUCTOR that references NEW_VAR.  */\n \t  p_array = TYPE_FIELDS (TREE_TYPE (alloc));\n \t  CONSTRUCTOR_APPEND_ELT (v, p_array,\n \t\t\t\t  fold_convert (TREE_TYPE (p_array), new_var));\n \t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (p_array),\n-\t\t\t\t  VEC_index (constructor_elt,\n-\t\t\t\t\t     CONSTRUCTOR_ELTS\n-\t\t\t\t\t     (TREE_OPERAND (alloc, 1)),\n-\t\t\t\t\t      1).value);\n+\t\t\t\t  (*CONSTRUCTOR_ELTS (\n+\t\t\t\t      TREE_OPERAND (alloc, 1)))[1].value);\n \t  new_ret = build_constructor (TREE_TYPE (alloc), v);\n \t}\n       else\n@@ -3048,7 +3031,7 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n    the other return values.  GNAT_RET is a representative return node.  */\n \n static void\n-finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other, Node_Id gnat_ret)\n+finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret)\n {\n   struct cgraph_node *node;\n   struct nrv_data data;\n@@ -3064,7 +3047,7 @@ finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other, Node_Id gnat_ret)\n   data.nrv = nrv;\n   data.result = NULL_TREE;\n   data.visited = NULL;\n-  for (i = 0; VEC_iterate(tree, other, i, iter); i++)\n+  for (i = 0; vec_safe_iterate (other, i, &iter); i++)\n     walk_tree_without_duplicates (&iter, prune_nrv_r, &data);\n   if (bitmap_empty_p (nrv))\n     return;\n@@ -3186,7 +3169,7 @@ build_return_expr (tree ret_obj, tree ret_val)\n \t     totally transparent given the read-compose-write semantics of\n \t     assignments from CONSTRUCTORs.  */\n \t  else if (EXPR_P (ret_val))\n-\t    VEC_safe_push (tree, gc, f_other_ret_val, ret_val);\n+\t    vec_safe_push (f_other_ret_val, ret_val);\n \t}\n     }\n   else\n@@ -3204,7 +3187,7 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n   tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n   tree gnu_subprog_param, gnu_stub_param, gnu_param;\n   tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n-  VEC(tree,gc) *gnu_param_vec = NULL;\n+  vec<tree, va_gc> *gnu_param_vec = NULL;\n \n   gnu_subprog_type = TREE_TYPE (gnu_subprog);\n \n@@ -3238,7 +3221,7 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n       else\n \tgnu_param = gnu_stub_param;\n \n-      VEC_safe_push (tree, gc, gnu_param_vec, gnu_param);\n+      vec_safe_push (gnu_param_vec, gnu_param);\n     }\n \n   /* Invoke the internal subprogram.  */\n@@ -3286,7 +3269,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   tree gnu_return_var_elmt = NULL_TREE;\n   tree gnu_result;\n   struct language_function *gnu_subprog_language;\n-  VEC(parm_attr,gc) *cache;\n+  vec<parm_attr, va_gc> *cache;\n \n   /* If this is a generic object or if it has been eliminated,\n      ignore it.  */\n@@ -3340,7 +3323,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     {\n       tree gnu_return_var = NULL_TREE;\n \n-      VEC_safe_push (tree, gc, gnu_return_label_stack,\n+      vec_safe_push (gnu_return_label_stack, \n \t\t     create_artificial_label (input_location));\n \n       start_stmt_group ();\n@@ -3366,7 +3349,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t  TREE_VALUE (gnu_return_var_elmt) = gnu_return_var;\n \t}\n \n-      VEC_safe_push (tree, gc, gnu_return_var_stack, gnu_return_var);\n+      vec_safe_push (gnu_return_var_stack, gnu_return_var);\n \n       /* See whether there are parameters for which we don't have a GCC tree\n \t yet.  These must be Out parameters.  Make a VAR_DECL for them and\n@@ -3392,7 +3375,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t  }\n     }\n   else\n-    VEC_safe_push (tree, gc, gnu_return_label_stack, NULL_TREE);\n+    vec_safe_push (gnu_return_label_stack, NULL_TREE);\n \n   /* Get a tree corresponding to the code for the subprogram.  */\n   start_stmt_group ();\n@@ -3433,7 +3416,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n       start_stmt_group ();\n \n-      FOR_EACH_VEC_ELT (parm_attr, cache, i, pa)\n+      FOR_EACH_VEC_ELT (*cache, i, pa)\n \t{\n \t  if (pa->first)\n \t    add_stmt_with_node_force (pa->first, gnat_node);\n@@ -3467,7 +3450,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n       add_stmt (gnu_result);\n       add_stmt (build1 (LABEL_EXPR, void_type_node,\n-\t\t\tVEC_last (tree, gnu_return_label_stack)));\n+\t\t\tgnu_return_label_stack->last ()));\n \n       if (list_length (gnu_cico_list) == 1)\n \tgnu_retval = TREE_VALUE (gnu_cico_list);\n@@ -3481,7 +3464,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       gnu_result = end_stmt_group ();\n     }\n \n-  VEC_pop (tree, gnu_return_label_stack);\n+  gnu_return_label_stack->pop ();\n \n   /* Attempt setting the end_locus of our GCC body tree, typically a\n      BIND_EXPR or STATEMENT_LIST, then the end_locus of our GCC subprogram\n@@ -3639,7 +3622,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   /* The return type of the FUNCTION_TYPE.  */\n   tree gnu_result_type = TREE_TYPE (gnu_subprog_type);\n   tree gnu_subprog_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_subprog);\n-  VEC(tree,gc) *gnu_actual_vec = NULL;\n+  vec<tree, va_gc> *gnu_actual_vec = NULL;\n   tree gnu_name_list = NULL_TREE;\n   tree gnu_stmt_list = NULL_TREE;\n   tree gnu_after_list = NULL_TREE;\n@@ -4042,7 +4025,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    gnu_actual = convert (DECL_ARG_TYPE (gnu_formal), gnu_actual);\n \t}\n \n-      VEC_safe_push (tree, gc, gnu_actual_vec, gnu_actual);\n+      vec_safe_push (gnu_actual_vec, gnu_actual);\n     }\n \n   gnu_call\n@@ -4402,7 +4385,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       start_stmt_group ();\n       gnat_pushlevel ();\n \n-      VEC_safe_push (tree, gc, gnu_except_ptr_stack,\n+      vec_safe_push (gnu_except_ptr_stack, \n \t\t     create_var_decl (get_identifier (\"EXCEPT_PTR\"), NULL_TREE,\n \t\t\t\t      build_pointer_type (except_type_node),\n \t\t\t\t      build_call_n_expr (get_excptr_decl, 0),\n@@ -4431,7 +4414,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       /* If none of the exception handlers did anything, re-raise but do not\n \t defer abortion.  */\n       gnu_expr = build_call_n_expr (raise_nodefer_decl, 1,\n-\t\t\t\t    VEC_last (tree, gnu_except_ptr_stack));\n+\t\t\t\t    gnu_except_ptr_stack->last ());\n       set_expr_location_from_node\n \t(gnu_expr,\n \t Present (End_Label (gnat_node)) ? End_Label (gnat_node) : gnat_node);\n@@ -4443,7 +4426,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \n       /* End the binding level dedicated to the exception handlers and get the\n \t whole statement group.  */\n-      VEC_pop (tree, gnu_except_ptr_stack);\n+      gnu_except_ptr_stack->pop ();\n       gnat_poplevel ();\n       gnu_handler = end_stmt_group ();\n \n@@ -4536,7 +4519,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t  build_component_ref\n \t\t  (build_unary_op\n \t\t   (INDIRECT_REF, NULL_TREE,\n-\t\t    VEC_last (tree, gnu_except_ptr_stack)),\n+\t\t    gnu_except_ptr_stack->last ()),\n \t\t   get_identifier (\"not_handled_by_others\"), NULL_TREE,\n \t\t   false)),\n \t\t integer_zero_node);\n@@ -4558,8 +4541,8 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t  this_choice\n \t    = build_binary_op\n \t      (EQ_EXPR, boolean_type_node,\n-\t       VEC_last (tree, gnu_except_ptr_stack),\n-\t       convert (TREE_TYPE (VEC_last (tree, gnu_except_ptr_stack)),\n+\t       gnu_except_ptr_stack->last (),\n+\t       convert (TREE_TYPE (gnu_except_ptr_stack->last ()),\n \t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr)));\n \n \t  /* If this is the distinguished exception \"Non_Ada_Error\" (and we are\n@@ -4570,7 +4553,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t      tree gnu_comp\n \t\t= build_component_ref\n \t\t  (build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t   VEC_last (tree, gnu_except_ptr_stack)),\n+\t\t\t\t   gnu_except_ptr_stack->last ()),\n \t\t   get_identifier (\"lang\"), NULL_TREE, false);\n \n \t      this_choice\n@@ -4711,7 +4694,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n        gnat_unit);\n   struct elab_info *info;\n \n-  VEC_safe_push (tree, gc, gnu_elab_proc_stack, gnu_elab_proc_decl);\n+  vec_safe_push (gnu_elab_proc_stack, gnu_elab_proc_decl);\n   DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n \n   /* Initialize the information structure for the function.  */\n@@ -4792,7 +4775,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n \n   /* Generate elaboration code for this unit, if necessary, and say whether\n      we did or not.  */\n-  VEC_pop (tree, gnu_elab_proc_stack);\n+  gnu_elab_proc_stack->pop ();\n \n   /* Invalidate the global renaming pointers.  This is necessary because\n      stabilization of the renamed entities may create SAVE_EXPRs which\n@@ -5235,8 +5218,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  int length = String_Length (gnat_string);\n \t  int i;\n \t  tree gnu_idx = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n-\t  VEC(constructor_elt,gc) *gnu_vec\n-\t    = VEC_alloc (constructor_elt, gc, length);\n+\t  vec<constructor_elt, va_gc> *gnu_vec;\n+\t  vec_alloc (gnu_vec, length);\n \n \t  for (i = 0; i < length; i++)\n \t    {\n@@ -5658,7 +5641,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_aggr_type = TYPE_REPRESENTATIVE_ARRAY (gnu_result_type);\n \n \tif (Null_Record_Present (gnat_node))\n-\t  gnu_result = gnat_build_constructor (gnu_aggr_type, NULL);\n+\t  gnu_result = gnat_build_constructor (gnu_aggr_type,\n+\t\t\t\t\t       NULL);\n \n \telse if (TREE_CODE (gnu_aggr_type) == RECORD_TYPE\n \t\t || TREE_CODE (gnu_aggr_type) == UNION_TYPE)\n@@ -6231,7 +6215,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n \t\t  (Present (Name (gnat_node))\n \t\t   ? get_gnu_tree (Entity (Name (gnat_node)))\n-\t\t   : VEC_last (loop_info, gnu_loop_stack)->label));\n+\t\t   : gnu_loop_stack->last ()->label));\n       break;\n \n     case N_Simple_Return_Statement:\n@@ -6246,7 +6230,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    /* If this function has copy-in/copy-out parameters, get the real\n \t       object for the return.  See Subprogram_to_gnu.  */\n \t    if (TYPE_CI_CO_LIST (gnu_subprog_type))\n-\t      gnu_ret_obj = VEC_last (tree, gnu_return_var_stack);\n+\t      gnu_ret_obj = gnu_return_var_stack->last ();\n \t    else\n \t      gnu_ret_obj = DECL_RESULT (current_function_decl);\n \n@@ -6331,18 +6315,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t/* If we have a return label defined, convert this into a branch to\n \t   that label.  The return proper will be handled elsewhere.  */\n-\tif (VEC_last (tree, gnu_return_label_stack))\n+\tif (gnu_return_label_stack->last ())\n \t  {\n \t    if (gnu_ret_obj)\n \t      add_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_ret_obj,\n \t\t\t\t\t gnu_ret_val));\n \n \t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n-\t\t\t\t VEC_last (tree, gnu_return_label_stack));\n+\t\t\t\t gnu_return_label_stack->last ());\n \n \t    /* When not optimizing, make sure the return is preserved.  */\n \t    if (!optimize && Comes_From_Source (gnat_node))\n-\t      DECL_ARTIFICIAL (VEC_last (tree, gnu_return_label_stack)) = 0;\n+\t      DECL_ARTIFICIAL (gnu_return_label_stack->last ()) = 0;\n \t  }\n \n \t/* Otherwise, build a regular return.  */\n@@ -6569,15 +6553,15 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Pop_Constraint_Error_Label:\n-      VEC_pop (tree, gnu_constraint_error_label_stack);\n+      gnu_constraint_error_label_stack->pop ();\n       break;\n \n     case N_Pop_Storage_Error_Label:\n-      VEC_pop (tree, gnu_storage_error_label_stack);\n+      gnu_storage_error_label_stack->pop ();\n       break;\n \n     case N_Pop_Program_Error_Label:\n-      VEC_pop (tree, gnu_program_error_label_stack);\n+      gnu_program_error_label_stack->pop ();\n       break;\n \n     /******************************/\n@@ -6857,7 +6841,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* The only validation we currently do on an unchecked conversion is\n \t that of aliasing assumptions.  */\n       if (flag_strict_aliasing)\n-\tVEC_safe_push (Node_Id, heap, gnat_validate_uc_list, gnat_node);\n+\tgnat_validate_uc_list.safe_push (gnat_node);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -7032,13 +7016,13 @@ gnat_to_gnu (Node_Id gnat_node)\n    label to push onto the stack.  */\n \n static void\n-push_exception_label_stack (VEC(tree,gc) **gnu_stack, Entity_Id gnat_label)\n+push_exception_label_stack (vec<tree, va_gc> **gnu_stack, Entity_Id gnat_label)\n {\n   tree gnu_label = (Present (gnat_label)\n \t\t    ? gnat_to_gnu_entity (gnat_label, NULL_TREE, 0)\n \t\t    : NULL_TREE);\n \n-  VEC_safe_push (tree, gc, *gnu_stack, gnu_label);\n+  vec_safe_push (*gnu_stack, gnu_label);\n }\n \f\n /* Record the current code position in GNAT_NODE.  */\n@@ -8678,7 +8662,7 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n {\n   tree gnu_index = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_array_type));\n   tree gnu_expr;\n-  VEC(constructor_elt,gc) *gnu_expr_vec = NULL;\n+  vec<constructor_elt, va_gc> *gnu_expr_vec = NULL;\n \n   for ( ; Present (gnat_expr); gnat_expr = Next (gnat_expr))\n     {\n@@ -8719,7 +8703,7 @@ static tree\n extract_values (tree values, tree record_type)\n {\n   tree field, tem;\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n \n   for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n     {\n@@ -8737,7 +8721,7 @@ extract_values (tree values, tree record_type)\n \t{\n \t  value = extract_values (values, TREE_TYPE (field));\n \t  if (TREE_CODE (value) == CONSTRUCTOR\n-\t      && VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (value)))\n+\t      && vec_safe_is_empty (CONSTRUCTOR_ELTS (value)))\n \t    value = 0;\n \t}\n       else\n@@ -9126,11 +9110,11 @@ tree\n get_exception_label (char kind)\n {\n   if (kind == N_Raise_Constraint_Error)\n-    return VEC_last (tree, gnu_constraint_error_label_stack);\n+    return gnu_constraint_error_label_stack->last ();\n   else if (kind == N_Raise_Storage_Error)\n-    return VEC_last (tree, gnu_storage_error_label_stack);\n+    return gnu_storage_error_label_stack->last ();\n   else if (kind == N_Raise_Program_Error)\n-    return VEC_last (tree, gnu_program_error_label_stack);\n+    return gnu_program_error_label_stack->last ();\n   else\n     return NULL_TREE;\n }\n@@ -9140,7 +9124,7 @@ get_exception_label (char kind)\n tree\n get_elaboration_procedure (void)\n {\n-  return VEC_last (tree, gnu_elab_proc_stack);\n+  return gnu_elab_proc_stack->last ();\n }\n \n #include \"gt-ada-trans.h\""}, {"sha": "6aa465b8de81830aa5b20544d21d9ddc77e08cda", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -201,13 +201,13 @@ static GTY((deletable)) struct gnat_binding_level *free_binding_level;\n static GTY(()) tree global_context;\n \n /* An array of global declarations.  */\n-static GTY(()) VEC(tree,gc) *global_decls;\n+static GTY(()) vec<tree, va_gc> *global_decls;\n \n /* An array of builtin function declarations.  */\n-static GTY(()) VEC(tree,gc) *builtin_decls;\n+static GTY(()) vec<tree, va_gc> *builtin_decls;\n \n /* An array of global renaming pointers.  */\n-static GTY(()) VEC(tree,gc) *global_renaming_pointers;\n+static GTY(()) vec<tree, va_gc> *global_renaming_pointers;\n \n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n@@ -576,10 +576,10 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n       if (DECL_EXTERNAL (decl))\n \t{\n \t  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl))\n-\t    VEC_safe_push (tree, gc, builtin_decls, decl);\n+\t    vec_safe_push (builtin_decls, decl);\n \t}\n       else if (global_bindings_p ())\n-\tVEC_safe_push (tree, gc, global_decls, decl);\n+\tvec_safe_push (global_decls, decl);\n       else\n \t{\n \t  DECL_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n@@ -1953,11 +1953,11 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n   /* A list of the data type nodes of the subprogram formal parameters.\n      This list is generated by traversing the input list of PARM_DECL\n      nodes.  */\n-  VEC(tree,gc) *param_type_list = NULL;\n+  vec<tree, va_gc> *param_type_list = NULL;\n   tree t, type;\n \n   for (t = param_decl_list; t; t = DECL_CHAIN (t))\n-    VEC_safe_push (tree, gc, param_type_list, TREE_TYPE (t));\n+    vec_safe_push (param_type_list, TREE_TYPE (t));\n \n   type = build_function_type_vec (return_type, param_type_list);\n \n@@ -2517,7 +2517,7 @@ void\n record_global_renaming_pointer (tree decl)\n {\n   gcc_assert (!DECL_LOOP_PARM_P (decl) && DECL_RENAMED_OBJECT (decl));\n-  VEC_safe_push (tree, gc, global_renaming_pointers, decl);\n+  vec_safe_push (global_renaming_pointers, decl);\n }\n \n /* Invalidate the global renaming pointers.   */\n@@ -2528,10 +2528,13 @@ invalidate_global_renaming_pointers (void)\n   unsigned int i;\n   tree iter;\n \n-  FOR_EACH_VEC_ELT (tree, global_renaming_pointers, i, iter)\n+  if (global_renaming_pointers == NULL)\n+    return;\n+\n+  FOR_EACH_VEC_ELT (*global_renaming_pointers, i, iter)\n     SET_DECL_RENAMED_OBJECT (iter, NULL_TREE);\n \n-  VEC_free (tree, gc, global_renaming_pointers);\n+  vec_free (global_renaming_pointers);\n }\n \n /* Return true if VALUE is a known to be a multiple of FACTOR, which must be\n@@ -3091,7 +3094,7 @@ max_size (tree exp, bool max_p)\n tree\n build_template (tree template_type, tree array_type, tree expr)\n {\n-  VEC(constructor_elt,gc) *template_elts = NULL;\n+  vec<constructor_elt, va_gc> *template_elts = NULL;\n   tree bound_list = NULL_TREE;\n   tree field;\n \n@@ -3755,7 +3758,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n tree\n fill_vms_descriptor (tree gnu_type, tree gnu_expr, Node_Id gnat_actual)\n {\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n   tree field;\n \n   gnu_expr = maybe_unconstrained_array (gnu_expr);\n@@ -3813,7 +3816,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       /* See the head comment of build_vms_descriptor.  */\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n       tree lfield, ufield;\n-      VEC(constructor_elt,gc) *v;\n+      vec<constructor_elt, va_gc> *v;\n \n       /* Convert POINTER to the pointer-to-array type.  */\n       gnu_expr64 = convert (p_array_type, gnu_expr64);\n@@ -3823,7 +3826,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 1:  /* Class S  */\n \tcase 15: /* Class SB */\n \t  /* Build {1, LENGTH} template; LENGTH64 is the 5th field.  */\n-\t  v = VEC_alloc (constructor_elt, gc, 2);\n+\t  vec_alloc (v, 2);\n \t  t = DECL_CHAIN (DECL_CHAIN (klass));\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  CONSTRUCTOR_APPEND_ELT (v, min_field,\n@@ -3855,7 +3858,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n            (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n \n \t  /* Build the template in the form of a constructor. */\n-\t  v = VEC_alloc (constructor_elt, gc, 2);\n+\t  vec_alloc (v, 2);\n \t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n \t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (template_type)),\n \t\t\t\t  ufield);\n@@ -3903,7 +3906,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n            (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n \n \t  /* Build the template in the form of a constructor. */\n-\t  v = VEC_alloc (constructor_elt, gc, 2);\n+\t  vec_alloc (v, 2);\n \t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n \t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (template_type)),\n \t\t\t\t  ufield);\n@@ -3924,7 +3927,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t}\n \n       /* Build the fat pointer in the form of a constructor.  */\n-      v = VEC_alloc (constructor_elt, gc, 2);\n+      vec_alloc (v, 2);\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr64);\n       CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (gnu_type)),\n \t\t\t      template_addr);\n@@ -3966,7 +3969,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n-      VEC(constructor_elt,gc) *v;\n+      vec<constructor_elt, va_gc> *v;\n \n       /* Convert POINTER to the pointer-to-array type.  */\n       gnu_expr32 = convert (p_array_type, gnu_expr32);\n@@ -3976,7 +3979,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 1:  /* Class S  */\n \tcase 15: /* Class SB */\n \t  /* Build {1, LENGTH} template; LENGTH is the 1st field.  */\n-\t  v = VEC_alloc (constructor_elt, gc, 2);\n+\t  vec_alloc (v, 2);\n \t  t = TYPE_FIELDS (desc_type);\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  CONSTRUCTOR_APPEND_ELT (v, min_field,\n@@ -4048,7 +4051,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t}\n \n       /* Build the fat pointer in the form of a constructor.  */\n-      v = VEC_alloc (constructor_elt, gc, 2);\n+      vec_alloc (v, 2);\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr32);\n       CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (gnu_type)),\n \t\t\t      template_addr);\n@@ -4306,7 +4309,8 @@ convert_to_fat_pointer (tree type, tree expr)\n   tree p_array_type = TREE_TYPE (TYPE_FIELDS (type));\n   tree etype = TREE_TYPE (expr);\n   tree template_tree;\n-  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n+  vec<constructor_elt, va_gc> *v;\n+  vec_alloc (v, 2);\n \n   /* If EXPR is null, make a fat pointer that contains a null pointer to the\n      array (compare_fat_pointers ensures that this is the full discriminant)\n@@ -4323,7 +4327,8 @@ convert_to_fat_pointer (tree type, tree expr)\n \t{\n \t  /* The template type can still be dummy at this point so we build an\n \t     empty constructor.  The middle-end will fill it in with zeros.  */\n-\t  t = build_constructor (template_type, NULL);\n+\t  t = build_constructor (template_type,\n+\t\t\t\t NULL);\n \t  TREE_CONSTANT (t) = TREE_STATIC (t) = 1;\n \t  null_bounds = build_unary_op (ADDR_EXPR, NULL_TREE, t);\n \t  SET_TYPE_NULL_BOUNDS (ptr_template_type, null_bounds);\n@@ -4425,7 +4430,7 @@ convert (tree type, tree expr)\n      constructor to build the record, unless a variable size is involved.  */\n   else if (code == RECORD_TYPE && TYPE_PADDING_P (type))\n     {\n-      VEC(constructor_elt,gc) *v;\n+      vec<constructor_elt, va_gc> *v;\n \n       /* If we previously converted from another type and our type is\n \t of variable size, remove the conversion to avoid the need for\n@@ -4478,7 +4483,7 @@ convert (tree type, tree expr)\n \t\t\t\t\t   expr),\n \t\t\t\t  false);\n \n-      v = VEC_alloc (constructor_elt, gc, 1);\n+      vec_alloc (v, 1);\n       CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n \t\t\t      convert (TREE_TYPE (TYPE_FIELDS (type)), expr));\n       return gnat_build_constructor (type, v);\n@@ -4495,11 +4500,9 @@ convert (tree type, tree expr)\n       /* If we have just converted to this padded type, just get the\n \t inner expression.  */\n       if (TREE_CODE (expr) == CONSTRUCTOR\n-\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (expr))\n-\t  && VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0).index\n-\t     == TYPE_FIELDS (etype))\n-\tunpadded\n-\t  = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0).value;\n+\t  && !vec_safe_is_empty (CONSTRUCTOR_ELTS (expr))\n+\t  && (*CONSTRUCTOR_ELTS (expr))[0].index == TYPE_FIELDS (etype))\n+\tunpadded = (*CONSTRUCTOR_ELTS (expr))[0].value;\n \n       /* Otherwise, build an explicit component reference.  */\n       else\n@@ -4533,7 +4536,8 @@ convert (tree type, tree expr)\n   if (code == RECORD_TYPE && TYPE_CONTAINS_TEMPLATE_P (type))\n     {\n       tree obj_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type)));\n-      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n+      vec<constructor_elt, va_gc> *v;\n+      vec_alloc (v, 2);\n \n       /* If the source already has a template, get a reference to the\n \t associated array only, as we are going to rebuild a template\n@@ -4592,8 +4596,7 @@ convert (tree type, tree expr)\n \t{\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n-\t  CONSTRUCTOR_ELTS (expr)\n-\t    = VEC_copy (constructor_elt, gc, CONSTRUCTOR_ELTS (expr));\n+\t  CONSTRUCTOR_ELTS (expr) = vec_safe_copy (CONSTRUCTOR_ELTS (expr));\n \t  return expr;\n \t}\n \n@@ -4606,9 +4609,10 @@ convert (tree type, tree expr)\n \t      || tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (etype))))\n \n \t{\n-\t  VEC(constructor_elt,gc) *e = CONSTRUCTOR_ELTS (expr);\n-\t  unsigned HOST_WIDE_INT len = VEC_length (constructor_elt, e);\n-\t  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, len);\n+\t  vec<constructor_elt, va_gc> *e = CONSTRUCTOR_ELTS (expr);\n+\t  unsigned HOST_WIDE_INT len = vec_safe_length (e);\n+\t  vec<constructor_elt, va_gc> *v;\n+\t  vec_alloc (v, len);\n \t  tree efield = TYPE_FIELDS (etype), field = TYPE_FIELDS (type);\n \t  unsigned HOST_WIDE_INT idx;\n \t  tree index, value;\n@@ -4626,7 +4630,7 @@ convert (tree type, tree expr)\n \t      if (!SAME_FIELD_P (efield, field))\n \t\tbreak;\n \t      constructor_elt elt = {field, convert (TREE_TYPE (field), value)};\n-\t      VEC_quick_push (constructor_elt, v, elt);\n+\t      v->quick_push (elt);\n \n \t      /* If packing has made this field a bitfield and the input\n \t\t value couldn't be emitted statically any more, we need to\n@@ -4663,9 +4667,9 @@ convert (tree type, tree expr)\n \t       && gnat_types_compatible_p (TYPE_REPRESENTATIVE_ARRAY (type),\n \t\t\t\t\t   etype))\n \t{\n-\t  VEC(constructor_elt,gc) *e = CONSTRUCTOR_ELTS (expr);\n-\t  unsigned HOST_WIDE_INT len = VEC_length (constructor_elt, e);\n-\t  VEC(constructor_elt,gc) *v;\n+\t  vec<constructor_elt, va_gc> *e = CONSTRUCTOR_ELTS (expr);\n+\t  unsigned HOST_WIDE_INT len = vec_safe_length (e);\n+\t  vec<constructor_elt, va_gc> *v;\n \t  unsigned HOST_WIDE_INT ix;\n \t  tree value;\n \n@@ -4689,11 +4693,11 @@ convert (tree type, tree expr)\n \t    }\n \n \t  /* Otherwise, build a regular vector constructor.  */\n-\t  v = VEC_alloc (constructor_elt, gc, len);\n+\t  vec_alloc (v, len);\n \t  FOR_EACH_CONSTRUCTOR_VALUE (e, ix, value)\n \t    {\n \t      constructor_elt elt = {NULL_TREE, value};\n-\t      VEC_quick_push (constructor_elt, v, elt);\n+\t      v->quick_push (elt);\n \t    }\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n@@ -4880,7 +4884,8 @@ convert (tree type, tree expr)\n     case RECORD_TYPE:\n       if (TYPE_JUSTIFIED_MODULAR_P (type) && !AGGREGATE_TYPE_P (etype))\n \t{\n-\t  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n+\t  vec<constructor_elt, va_gc> *v;\n+\t  vec_alloc (v, 1);\n \n \t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n \t\t\t\t  convert (TREE_TYPE (TYPE_FIELDS (type)),\n@@ -5048,9 +5053,7 @@ remove_conversions (tree exp, bool true_address)\n \t  && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n \t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (exp)))\n \treturn\n-\t  remove_conversions (VEC_index (constructor_elt,\n-\t\t\t\t\t CONSTRUCTOR_ELTS (exp), 0).value,\n-\t\t\t      true);\n+\t  remove_conversions ((*CONSTRUCTOR_ELTS (exp))[0].value, true);\n       break;\n \n     case COMPONENT_REF:\n@@ -5292,7 +5295,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n       unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (etype));\n-      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n+      vec<constructor_elt, va_gc> *v;\n+      vec_alloc (v, 1);\n       tree field_type, field;\n \n       if (TYPE_UNSIGNED (etype))\n@@ -5575,7 +5579,7 @@ gnat_write_global_declarations (void)\n \n   /* If we have declared types as used at the global level, insert them in\n      the global hash table.  We use a dummy variable for this purpose.  */\n-  if (!VEC_empty (tree, types_used_by_cur_var_decl))\n+  if (types_used_by_cur_var_decl && !types_used_by_cur_var_decl->is_empty ())\n     {\n       struct varpool_node *node;\n       char *label;\n@@ -5589,9 +5593,9 @@ gnat_write_global_declarations (void)\n       node = varpool_node_for_decl (dummy_global);\n       node->symbol.force_output = 1;\n \n-      while (!VEC_empty (tree, types_used_by_cur_var_decl))\n+      while (!types_used_by_cur_var_decl->is_empty ())\n \t{\n-\t  tree t = VEC_pop (tree, types_used_by_cur_var_decl);\n+\t  tree t = types_used_by_cur_var_decl->pop ();\n \t  types_used_by_var_decl_insert (t, dummy_global);\n \t}\n     }\n@@ -5600,7 +5604,7 @@ gnat_write_global_declarations (void)\n      ensures that global types whose compilation hasn't been finalized yet,\n      for example pointers to Taft amendment types, have their compilation\n      finalized in the right context.  */\n-  FOR_EACH_VEC_ELT (tree, global_decls, i, iter)\n+  FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n     if (TREE_CODE (iter) == TYPE_DECL)\n       debug_hooks->global_decl (iter);\n \n@@ -5612,7 +5616,7 @@ gnat_write_global_declarations (void)\n   if (!seen_error ())\n     {\n       timevar_push (TV_SYMOUT);\n-      FOR_EACH_VEC_ELT (tree, global_decls, i, iter)\n+      FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n \tif (TREE_CODE (iter) != TYPE_DECL)\n \t  debug_hooks->global_decl (iter);\n       timevar_pop (TV_SYMOUT);\n@@ -5641,7 +5645,7 @@ builtin_decl_for (tree name)\n   unsigned i;\n   tree decl;\n \n-  FOR_EACH_VEC_ELT (tree, builtin_decls, i, decl)\n+  FOR_EACH_VEC_SAFE_ELT (builtin_decls, i, decl)\n     if (DECL_NAME (decl) == name)\n       return decl;\n "}, {"sha": "4bb16eca37d20ac774d4def8e982726e96a4b48f", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -441,7 +441,7 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n \n   /* The constant folder doesn't fold fat pointer types so we do it here.  */\n   if (TREE_CODE (p1) == CONSTRUCTOR)\n-    p1_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 0).value;\n+    p1_array = (*CONSTRUCTOR_ELTS (p1))[0].value;\n   else\n     p1_array = build_component_ref (p1, NULL_TREE,\n \t\t\t\t    TYPE_FIELDS (TREE_TYPE (p1)), true);\n@@ -452,7 +452,7 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n \t\t\t\t\t null_pointer_node));\n \n   if (TREE_CODE (p2) == CONSTRUCTOR)\n-    p2_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 0).value;\n+    p2_array = (*CONSTRUCTOR_ELTS (p2))[0].value;\n   else\n     p2_array = build_component_ref (p2, NULL_TREE,\n \t\t\t\t    TYPE_FIELDS (TREE_TYPE (p2)), true);\n@@ -473,14 +473,14 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n     = fold_build2_loc (loc, EQ_EXPR, result_type, p1_array, p2_array);\n \n   if (TREE_CODE (p1) == CONSTRUCTOR)\n-    p1_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 1).value;\n+    p1_bounds = (*CONSTRUCTOR_ELTS (p1))[1].value;\n   else\n     p1_bounds\n       = build_component_ref (p1, NULL_TREE,\n \t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p1))), true);\n \n   if (TREE_CODE (p2) == CONSTRUCTOR)\n-    p2_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 1).value;\n+    p2_bounds = (*CONSTRUCTOR_ELTS (p2))[1].value;\n   else\n     p2_bounds\n       = build_component_ref (p2, NULL_TREE,\n@@ -1334,9 +1334,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t     a pointer to our type.  */\n \t  if (TYPE_IS_PADDING_P (type))\n \t    {\n-\t      result = VEC_index (constructor_elt,\n-\t\t\t\t  CONSTRUCTOR_ELTS (operand),\n-\t\t\t\t  0).value;\n+\t      result = (*CONSTRUCTOR_ELTS (operand))[0].value;\n \t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n \t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n \t      break;\n@@ -1831,7 +1829,7 @@ compare_elmt_bitpos (const PTR rt1, const PTR rt2)\n /* Return a CONSTRUCTOR of TYPE whose elements are V.  */\n \n tree\n-gnat_build_constructor (tree type, VEC(constructor_elt,gc) *v)\n+gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n {\n   bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n   bool side_effects = false;\n@@ -1859,7 +1857,7 @@ gnat_build_constructor (tree type, VEC(constructor_elt,gc) *v)\n      by increasing bit position.  This is necessary to ensure the\n      constructor can be output as static data.  */\n   if (allconstant && TREE_CODE (type) == RECORD_TYPE && n_elmts > 1)\n-    VEC_qsort (constructor_elt, v, compare_elmt_bitpos);\n+    v->qsort (compare_elmt_bitpos);\n \n   result = build_constructor (type, v);\n   TREE_CONSTANT (result) = TREE_STATIC (result) = allconstant;\n@@ -1989,7 +1987,7 @@ build_simple_component_ref (tree record_variable, tree component,\n   if (TREE_CODE (record_variable) == CONSTRUCTOR\n       && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record_variable)))\n     {\n-      VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (record_variable);\n+      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (record_variable);\n       unsigned HOST_WIDE_INT idx;\n       tree index, value;\n       FOR_EACH_CONSTRUCTOR_ELT (elts, idx, index, value)\n@@ -2302,7 +2300,8 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t If there is no initializing expression, just set the bounds.  */\n       if (init)\n \t{\n-\t  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n+\t  vec<constructor_elt, va_gc> *v;\n+\t  vec_alloc (v, 2);\n \n \t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (storage_type),\n \t\t\t\t  build_template (template_type, type, init));\n@@ -2673,12 +2672,10 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n       /* Constructors with 1 element are used extensively to formally\n \t convert objects to special wrapping types.  */\n       if (TREE_CODE (type) == RECORD_TYPE\n-\t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (ref)) == 1)\n+\t  && vec_safe_length (CONSTRUCTOR_ELTS (ref)) == 1)\n \t{\n-\t  tree index\n-\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0).index;\n-\t  tree value\n-\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0).value;\n+\t  tree index = (*CONSTRUCTOR_ELTS (ref))[0].index;\n+\t  tree value = (*CONSTRUCTOR_ELTS (ref))[0].value;\n \t  result\n \t    = build_constructor_single (type, index,\n \t\t\t\t\tgnat_stabilize_reference_1 (value,"}, {"sha": "2ef13cc755b05dbc4c8d49fd6f9591634d4ffebe", "filename": "gcc/alias.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -206,7 +206,7 @@ static void memory_modified_1 (rtx, const_rtx, void *);\n    The ADDRESS in group (1) _may_ alias globals; it has VOIDmode to\n    indicate this.  */\n \n-static GTY(()) VEC(rtx,gc) *reg_base_value;\n+static GTY(()) vec<rtx, va_gc> *reg_base_value;\n static rtx *new_reg_base_value;\n \n /* The single VOIDmode ADDRESS that represents all argument bases.\n@@ -219,7 +219,7 @@ static int unique_id;\n /* We preserve the copy of old array around to avoid amount of garbage\n    produced.  About 8% of garbage produced were attributed to this\n    array.  */\n-static GTY((deletable)) VEC(rtx,gc) *old_reg_base_value;\n+static GTY((deletable)) vec<rtx, va_gc> *old_reg_base_value;\n \n /* Values of XINT (address, 0) of Pmode ADDRESS rtxes for special\n    registers.  */\n@@ -231,14 +231,14 @@ static GTY((deletable)) VEC(rtx,gc) *old_reg_base_value;\n #define static_reg_base_value \\\n   (this_target_rtl->x_static_reg_base_value)\n \n-#define REG_BASE_VALUE(X)\t\t\t\t\\\n-  (REGNO (X) < VEC_length (rtx, reg_base_value)\t\t\\\n-   ? VEC_index (rtx, reg_base_value, REGNO (X)) : 0)\n+#define REG_BASE_VALUE(X)\t\t\t\t\t\\\n+  (REGNO (X) < vec_safe_length (reg_base_value)\t\t\t\\\n+   ? (*reg_base_value)[REGNO (X)] : 0)\n \n /* Vector indexed by N giving the initial (unchanging) value known for\n    pseudo-register N.  This vector is initialized in init_alias_analysis,\n    and does not change until end_alias_analysis is called.  */\n-static GTY(()) VEC(rtx,gc) *reg_known_value;\n+static GTY(()) vec<rtx, va_gc> *reg_known_value;\n \n /* Vector recording for each reg_known_value whether it is due to a\n    REG_EQUIV note.  Future passes (viz., reload) may replace the\n@@ -258,11 +258,9 @@ static sbitmap reg_known_equiv_p;\n    NOTE_INSN_FUNCTION_BEG note.  */\n static bool copying_arguments;\n \n-DEF_VEC_P(alias_set_entry);\n-DEF_VEC_ALLOC_P(alias_set_entry,gc);\n \n /* The splay-tree used to store the various alias set entries.  */\n-static GTY (()) VEC(alias_set_entry,gc) *alias_sets;\n+static GTY (()) vec<alias_set_entry, va_gc> *alias_sets;\n \f\n /* Build a decomposed reference object for querying the alias-oracle\n    from the MEM rtx and store it in *REF.\n@@ -391,7 +389,7 @@ rtx_refs_may_alias_p (const_rtx x, const_rtx mem, bool tbaa_p)\n static inline alias_set_entry\n get_alias_set_entry (alias_set_type alias_set)\n {\n-  return VEC_index (alias_set_entry, alias_sets, alias_set);\n+  return (*alias_sets)[alias_set];\n }\n \n /* Returns nonzero if the alias sets for MEM1 and MEM2 are such that\n@@ -854,9 +852,9 @@ new_alias_set (void)\n   if (flag_strict_aliasing)\n     {\n       if (alias_sets == 0)\n-\tVEC_safe_push (alias_set_entry, gc, alias_sets, 0);\n-      VEC_safe_push (alias_set_entry, gc, alias_sets, 0);\n-      return VEC_length (alias_set_entry, alias_sets) - 1;\n+\tvec_safe_push (alias_sets, (alias_set_entry) 0);\n+      vec_safe_push (alias_sets, (alias_set_entry) 0);\n+      return alias_sets->length () - 1;\n     }\n   else\n     return 0;\n@@ -900,7 +898,7 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n \t\t\t      ggc_alloc_splay_tree_scalar_scalar_splay_tree_s,\n \t\t\t      ggc_alloc_splay_tree_scalar_scalar_splay_tree_node_s);\n       superset_entry->has_zero_child = 0;\n-      VEC_replace (alias_set_entry, alias_sets, superset, superset_entry);\n+      (*alias_sets)[superset] = superset_entry;\n     }\n \n   if (subset == 0)\n@@ -1079,16 +1077,16 @@ find_base_value (rtx src)\n \t The test above is not sufficient because the scheduler may move\n \t a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */\n       if ((regno >= FIRST_PSEUDO_REGISTER || fixed_regs[regno])\n-\t  && regno < VEC_length (rtx, reg_base_value))\n+\t  && regno < vec_safe_length (reg_base_value))\n \t{\n \t  /* If we're inside init_alias_analysis, use new_reg_base_value\n \t     to reduce the number of relaxation iterations.  */\n \t  if (new_reg_base_value && new_reg_base_value[regno]\n \t      && DF_REG_DEF_COUNT (regno) == 1)\n \t    return new_reg_base_value[regno];\n \n-\t  if (VEC_index (rtx, reg_base_value, regno))\n-\t    return VEC_index (rtx, reg_base_value, regno);\n+\t  if ((*reg_base_value)[regno])\n+\t    return (*reg_base_value)[regno];\n \t}\n \n       return 0;\n@@ -1233,7 +1231,7 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \n   regno = REGNO (dest);\n \n-  gcc_checking_assert (regno < VEC_length (rtx, reg_base_value));\n+  gcc_checking_assert (regno < reg_base_value->length ());\n \n   /* If this spans multiple hard registers, then we must indicate that every\n      register has an unusable value.  */\n@@ -1338,7 +1336,7 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n rtx\n get_reg_base_value (unsigned int regno)\n {\n-  return VEC_index (rtx, reg_base_value, regno);\n+  return (*reg_base_value)[regno];\n }\n \n /* If a value is known for REGNO, return it.  */\n@@ -1349,8 +1347,8 @@ get_reg_known_value (unsigned int regno)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < VEC_length (rtx, reg_known_value))\n-\treturn VEC_index (rtx, reg_known_value, regno);\n+      if (regno < vec_safe_length (reg_known_value))\n+\treturn (*reg_known_value)[regno];\n     }\n   return NULL;\n }\n@@ -1363,8 +1361,8 @@ set_reg_known_value (unsigned int regno, rtx val)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < VEC_length (rtx, reg_known_value))\n-\tVEC_replace (rtx, reg_known_value, regno, val);\n+      if (regno < vec_safe_length (reg_known_value))\n+\t(*reg_known_value)[regno] = val;\n     }\n }\n \n@@ -1376,7 +1374,7 @@ get_reg_known_equiv_p (unsigned int regno)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < VEC_length (rtx, reg_known_value))\n+      if (regno < vec_safe_length (reg_known_value))\n \treturn bitmap_bit_p (reg_known_equiv_p, regno);\n     }\n   return false;\n@@ -1388,7 +1386,7 @@ set_reg_known_equiv_p (unsigned int regno, bool val)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       regno -= FIRST_PSEUDO_REGISTER;\n-      if (regno < VEC_length (rtx, reg_known_value))\n+      if (regno < vec_safe_length (reg_known_value))\n \t{\n \t  if (val)\n \t    bitmap_set_bit (reg_known_equiv_p, regno);\n@@ -2811,17 +2809,17 @@ init_alias_analysis (void)\n \n   timevar_push (TV_ALIAS_ANALYSIS);\n \n-  reg_known_value = VEC_alloc (rtx, gc, maxreg - FIRST_PSEUDO_REGISTER);\n+  vec_alloc (reg_known_value, maxreg - FIRST_PSEUDO_REGISTER);\n   reg_known_equiv_p = sbitmap_alloc (maxreg - FIRST_PSEUDO_REGISTER);\n \n   /* If we have memory allocated from the previous run, use it.  */\n   if (old_reg_base_value)\n     reg_base_value = old_reg_base_value;\n \n   if (reg_base_value)\n-    VEC_truncate (rtx, reg_base_value, 0);\n+    reg_base_value->truncate (0);\n \n-  VEC_safe_grow_cleared (rtx, gc, reg_base_value, maxreg);\n+  vec_safe_grow_cleared (reg_base_value, maxreg);\n \n   new_reg_base_value = XNEWVEC (rtx, maxreg);\n   reg_seen = sbitmap_alloc (maxreg);\n@@ -2969,11 +2967,10 @@ init_alias_analysis (void)\n       for (ui = 0; ui < maxreg; ui++)\n \t{\n \t  if (new_reg_base_value[ui]\n-\t      && new_reg_base_value[ui] != VEC_index (rtx, reg_base_value, ui)\n-\t      && ! rtx_equal_p (new_reg_base_value[ui],\n-\t\t\t\tVEC_index (rtx, reg_base_value, ui)))\n+\t      && new_reg_base_value[ui] != (*reg_base_value)[ui]\n+\t      && ! rtx_equal_p (new_reg_base_value[ui], (*reg_base_value)[ui]))\n \t    {\n-\t      VEC_replace (rtx, reg_base_value, ui, new_reg_base_value[ui]);\n+\t      (*reg_base_value)[ui] = new_reg_base_value[ui];\n \t      changed = 1;\n \t    }\n \t}\n@@ -2982,7 +2979,7 @@ init_alias_analysis (void)\n   XDELETEVEC (rpo);\n \n   /* Fill in the remaining entries.  */\n-  FOR_EACH_VEC_ELT (rtx, reg_known_value, i, val)\n+  FOR_EACH_VEC_ELT (*reg_known_value, i, val)\n     {\n       int regno = i + FIRST_PSEUDO_REGISTER;\n       if (! val)\n@@ -3003,14 +3000,14 @@ init_alias_analysis (void)\n void\n vt_equate_reg_base_value (const_rtx reg1, const_rtx reg2)\n {\n-  VEC_replace (rtx, reg_base_value, REGNO (reg1), REG_BASE_VALUE (reg2));\n+  (*reg_base_value)[REGNO (reg1)] = REG_BASE_VALUE (reg2);\n }\n \n void\n end_alias_analysis (void)\n {\n   old_reg_base_value = reg_base_value;\n-  VEC_free (rtx, gc, reg_known_value);\n+  vec_free (reg_known_value);\n   sbitmap_free (reg_known_equiv_p);\n }\n "}, {"sha": "bd90e0a54d55369449f66a36d980540eb3e3075d", "filename": "gcc/asan.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1436,12 +1436,12 @@ asan_global_struct (void)\n    TYPE is __asan_global struct type as returned by asan_global_struct.  */\n \n static void\n-asan_add_global (tree decl, tree type, VEC(constructor_elt, gc) *v)\n+asan_add_global (tree decl, tree type, vec<constructor_elt, va_gc> *v)\n {\n   tree init, uptr = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type)));\n   unsigned HOST_WIDE_INT size;\n   tree str_cst, refdecl = decl;\n-  VEC(constructor_elt, gc) *vinner = NULL;\n+  vec<constructor_elt, va_gc> *vinner = NULL;\n \n   if (!asan_pp_initialized)\n     asan_pp_initialize ();\n@@ -1460,8 +1460,7 @@ asan_add_global (tree decl, tree type, VEC(constructor_elt, gc) *v)\n   if (asan_needs_local_alias (decl))\n     {\n       char buf[20];\n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LASAN\",\n-\t\t\t\t   VEC_length (constructor_elt, v) + 1);\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LASAN\", vec_safe_length (v) + 1);\n       refdecl = build_decl (DECL_SOURCE_LOCATION (decl),\n \t\t\t    VAR_DECL, get_identifier (buf), TREE_TYPE (decl));\n       TREE_ADDRESSABLE (refdecl) = TREE_ADDRESSABLE (decl);\n@@ -1515,7 +1514,7 @@ asan_finish_file (void)\n       tree type = asan_global_struct (), var, ctor, decl;\n       tree uptr = build_nonstandard_integer_type (POINTER_SIZE, 1);\n       tree dtor_statements = NULL_TREE;\n-      VEC(constructor_elt, gc) *v;\n+      vec<constructor_elt, va_gc> *v;\n       char buf[20];\n \n       type = build_array_type_nelts (type, gcount);\n@@ -1526,7 +1525,7 @@ asan_finish_file (void)\n       TREE_PUBLIC (var) = 0;\n       DECL_ARTIFICIAL (var) = 1;\n       DECL_IGNORED_P (var) = 1;\n-      v = VEC_alloc (constructor_elt, gc, gcount);\n+      vec_alloc (v, gcount);\n       FOR_EACH_DEFINED_VARIABLE (vnode)\n \tif (asan_protect_global (vnode->symbol.decl))\n \t  asan_add_global (vnode->symbol.decl, TREE_TYPE (type), v);"}, {"sha": "1c55ca3b8ac04ad4d6bb76417d7e4a57e5949a14", "filename": "gcc/attribs.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -46,23 +46,17 @@ struct substring\n   int length;\n };\n \n-DEF_VEC_O (attribute_spec);\n-DEF_VEC_ALLOC_O (attribute_spec, heap);\n-\n /* Scoped attribute name representation.  */\n \n struct scoped_attributes\n {\n   const char *ns;\n-  VEC (attribute_spec, heap) *attributes;\n+  vec<attribute_spec> attributes;\n   htab_t attribute_hash;\n };\n \n-DEF_VEC_O (scoped_attributes);\n-DEF_VEC_ALLOC_O (scoped_attributes, heap);\n-\n /* The table of scope attributes.  */\n-static VEC(scoped_attributes, heap) *attributes_table;\n+static vec<scoped_attributes> attributes_table;\n \n static scoped_attributes* find_attribute_namespace (const char*);\n static void register_scoped_attribute (const struct attribute_spec *,\n@@ -140,21 +134,20 @@ register_scoped_attributes (const struct attribute_spec * attributes,\n       /* We don't have any namespace NS yet.  Create one.  */\n       scoped_attributes sa;\n \n-      if (attributes_table == NULL)\n-\tattributes_table = VEC_alloc (scoped_attributes, heap, 64);\n+      if (!attributes_table.is_empty ())\n+\tattributes_table.create (64);\n \n       memset (&sa, 0, sizeof (sa));\n       sa.ns = ns;\n-      sa.attributes = VEC_alloc (attribute_spec, heap, 64);\n-      result = VEC_safe_push (scoped_attributes, heap, attributes_table, sa);\n+      sa.attributes.create (64);\n+      result = attributes_table.safe_push (sa);\n       result->attribute_hash = htab_create (200, hash_attr, eq_attr, NULL);\n     }\n \n   /* Really add the attributes to their namespace now.  */\n   for (unsigned i = 0; attributes[i].name != NULL; ++i)\n     {\n-      VEC_safe_push (attribute_spec, heap,\n-\t\t     result->attributes, attributes[i]);\n+      result->attributes.safe_push (attributes[i]);\n       register_scoped_attribute (&attributes[i], result);\n     }\n \n@@ -171,7 +164,7 @@ find_attribute_namespace (const char* ns)\n   unsigned ix;\n   scoped_attributes *iter;\n \n-  FOR_EACH_VEC_ELT (scoped_attributes, attributes_table, ix, iter)\n+  FOR_EACH_VEC_ELT (attributes_table, ix, iter)\n     if (ns == iter->ns\n \t|| (iter->ns != NULL\n \t    && ns != NULL"}, {"sha": "03ba0cea9e5e4959164b15438370e69becfee8e9", "filename": "gcc/basic-block.h", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -61,9 +61,6 @@ struct GTY((user)) edge_def {\n \t\t\t\t   in profile.c  */\n };\n \n-DEF_VEC_P(edge);\n-DEF_VEC_ALLOC_P(edge,gc);\n-DEF_VEC_ALLOC_P(edge,heap);\n \n /* Garbage collection and PCH support for edge_def.  */\n extern void gt_ggc_mx (edge_def *e);\n@@ -182,8 +179,8 @@ struct GTY(()) gimple_bb_info {\n /* Basic block information indexed by block number.  */\n struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_def {\n   /* The edges into and out of the block.  */\n-  VEC(edge,gc) *preds;\n-  VEC(edge,gc) *succs;\n+  vec<edge, va_gc> *preds;\n+  vec<edge, va_gc> *succs;\n \n   /* Auxiliary info specific to a pass.  */\n   PTR GTY ((skip (\"\"))) aux;\n@@ -231,9 +228,6 @@ typedef int __assert_gimple_bb_smaller_rtl_bb\n               [(int)sizeof(struct rtl_bb_info)\n                - (int)sizeof (struct gimple_bb_info)];\n \n-DEF_VEC_P(basic_block);\n-DEF_VEC_ALLOC_P(basic_block,gc);\n-DEF_VEC_ALLOC_P(basic_block,heap);\n \n #define BB_FREQ_MAX 10000\n \n@@ -299,7 +293,7 @@ struct GTY(()) control_flow_graph {\n   basic_block x_exit_block_ptr;\n \n   /* Index by basic block number, get basic block struct info.  */\n-  VEC(basic_block,gc) *x_basic_block_info;\n+  vec<basic_block, va_gc> *x_basic_block_info;\n \n   /* Number of basic blocks in this flow graph.  */\n   int x_n_basic_blocks;\n@@ -315,7 +309,7 @@ struct GTY(()) control_flow_graph {\n \n   /* Mapping of labels to their associated blocks.  At present\n      only used for the gimple CFG.  */\n-  VEC(basic_block,gc) *x_label_to_block_map;\n+  vec<basic_block, va_gc> *x_label_to_block_map;\n \n   enum profile_status_d x_profile_status;\n \n@@ -341,9 +335,9 @@ struct GTY(()) control_flow_graph {\n #define profile_status_for_function(FN)\t     ((FN)->cfg->x_profile_status)\n \n #define BASIC_BLOCK_FOR_FUNCTION(FN,N) \\\n-  (VEC_index (basic_block, basic_block_info_for_function(FN), (N)))\n+  ((*basic_block_info_for_function(FN))[(N)])\n #define SET_BASIC_BLOCK_FOR_FUNCTION(FN,N,BB) \\\n-  (VEC_replace (basic_block, basic_block_info_for_function(FN), (N), (BB)))\n+  ((*basic_block_info_for_function(FN))[(N)] = (BB))\n \n /* Defines for textual backward source compatibility.  */\n #define ENTRY_BLOCK_PTR\t\t(cfun->cfg->x_entry_block_ptr)\n@@ -355,8 +349,8 @@ struct GTY(()) control_flow_graph {\n #define label_to_block_map\t(cfun->cfg->x_label_to_block_map)\n #define profile_status\t\t(cfun->cfg->x_profile_status)\n \n-#define BASIC_BLOCK(N)\t\t(VEC_index (basic_block, basic_block_info, (N)))\n-#define SET_BASIC_BLOCK(N,BB)\t(VEC_replace (basic_block, basic_block_info, (N), (BB)))\n+#define BASIC_BLOCK(N)\t\t((*basic_block_info)[(N)])\n+#define SET_BASIC_BLOCK(N,BB)\t((*basic_block_info)[(N)] = (BB))\n \n /* For iterating over basic blocks.  */\n #define FOR_BB_BETWEEN(BB, FROM, TO, DIR) \\\n@@ -473,7 +467,7 @@ typedef struct ce_if_block\n } ce_if_block_t;\n \n /* This structure maintains an edge list vector.  */\n-/* FIXME: Make this a VEC(edge).  */\n+/* FIXME: Make this a vec<edge>.  */\n struct edge_list\n {\n   int num_edges;\n@@ -518,10 +512,10 @@ struct edge_list\n #define EDGE_CRITICAL_P(e)\t\t(EDGE_COUNT ((e)->src->succs) >= 2 \\\n \t\t\t\t\t && EDGE_COUNT ((e)->dest->preds) >= 2)\n \n-#define EDGE_COUNT(ev)\t\t\tVEC_length (edge, (ev))\n-#define EDGE_I(ev,i)\t\t\tVEC_index  (edge, (ev), (i))\n-#define EDGE_PRED(bb,i)\t\t\tVEC_index  (edge, (bb)->preds, (i))\n-#define EDGE_SUCC(bb,i)\t\t\tVEC_index  (edge, (bb)->succs, (i))\n+#define EDGE_COUNT(ev)\t\t\tvec_safe_length (ev)\n+#define EDGE_I(ev,i)\t\t\t(*ev)[(i)]\n+#define EDGE_PRED(bb,i)\t\t\t(*(bb)->preds)[(i)]\n+#define EDGE_SUCC(bb,i)\t\t\t(*(bb)->succs)[(i)]\n \n /* Returns true if BB has precisely one successor.  */\n \n@@ -581,10 +575,10 @@ single_pred (const_basic_block bb)\n \n typedef struct {\n   unsigned index;\n-  VEC(edge,gc) **container;\n+  vec<edge, va_gc> **container;\n } edge_iterator;\n \n-static inline VEC(edge,gc) *\n+static inline vec<edge, va_gc> *\n ei_container (edge_iterator i)\n {\n   gcc_checking_assert (i.container);\n@@ -596,7 +590,7 @@ ei_container (edge_iterator i)\n \n /* Return an iterator pointing to the start of an edge vector.  */\n static inline edge_iterator\n-ei_start_1 (VEC(edge,gc) **ev)\n+ei_start_1 (vec<edge, va_gc> **ev)\n {\n   edge_iterator i;\n \n@@ -609,7 +603,7 @@ ei_start_1 (VEC(edge,gc) **ev)\n /* Return an iterator pointing to the last element of an edge\n    vector.  */\n static inline edge_iterator\n-ei_last_1 (VEC(edge,gc) **ev)\n+ei_last_1 (vec<edge, va_gc> **ev)\n {\n   edge_iterator i;\n \n@@ -848,21 +842,21 @@ extern void set_immediate_dominator (enum cdi_direction, basic_block,\n \t\t\t\t     basic_block);\n extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n extern bool dominated_by_p (enum cdi_direction, const_basic_block, const_basic_block);\n-extern VEC (basic_block, heap) *get_dominated_by (enum cdi_direction, basic_block);\n-extern VEC (basic_block, heap) *get_dominated_by_region (enum cdi_direction,\n+extern vec<basic_block> get_dominated_by (enum cdi_direction, basic_block);\n+extern vec<basic_block> get_dominated_by_region (enum cdi_direction,\n \t\t\t\t\t\t\t basic_block *,\n \t\t\t\t\t\t\t unsigned);\n-extern VEC (basic_block, heap) *get_dominated_to_depth (enum cdi_direction,\n+extern vec<basic_block> get_dominated_to_depth (enum cdi_direction,\n \t\t\t\t\t\t\tbasic_block, int);\n-extern VEC (basic_block, heap) *get_all_dominated_blocks (enum cdi_direction,\n+extern vec<basic_block> get_all_dominated_blocks (enum cdi_direction,\n \t\t\t\t\t\t\t  basic_block);\n extern void add_to_dominance_info (enum cdi_direction, basic_block);\n extern void delete_from_dominance_info (enum cdi_direction, basic_block);\n basic_block recompute_dominator (enum cdi_direction, basic_block);\n extern void redirect_immediate_dominators (enum cdi_direction, basic_block,\n \t\t\t\t\t   basic_block);\n extern void iterate_fix_dominators (enum cdi_direction,\n-\t\t\t\t    VEC (basic_block, heap) *, bool);\n+\t\t\t\t    vec<basic_block> , bool);\n extern void verify_dominators (enum cdi_direction);\n extern basic_block first_dom_son (enum cdi_direction, basic_block);\n extern basic_block next_dom_son (enum cdi_direction, basic_block);\n@@ -918,7 +912,7 @@ bb_has_abnormal_pred (basic_block bb)\n \n /* Return the fallthru edge in EDGES if it exists, NULL otherwise.  */\n static inline edge\n-find_fallthru_edge (VEC(edge,gc) *edges)\n+find_fallthru_edge (vec<edge, va_gc> *edges)\n {\n   edge e;\n   edge_iterator ei;"}, {"sha": "433b1a7ae3be8e64df5ed4ed04bb6e822e2adbba", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1458,10 +1458,10 @@ fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n    a separate section of the .o file (to cut down on paging and improve\n    cache locality).  Return a vector of all edges that cross.  */\n \n-static VEC(edge, heap) *\n+static vec<edge> \n find_rarely_executed_basic_blocks_and_crossing_edges (void)\n {\n-  VEC(edge, heap) *crossing_edges = NULL;\n+  vec<edge> crossing_edges = vec<edge>();\n   basic_block bb;\n   edge e;\n   edge_iterator ei;\n@@ -1483,7 +1483,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n       unsigned i;\n       eh_landing_pad lp;\n \n-      FOR_EACH_VEC_ELT (eh_landing_pad, cfun->eh->lp_array, i, lp)\n+      FOR_EACH_VEC_ELT (*cfun->eh->lp_array, i, lp)\n \t{\n \t  bool all_same, all_diff;\n \n@@ -1530,7 +1530,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n \t    && e->dest != EXIT_BLOCK_PTR\n \t    && BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n \t  {\n-\t    VEC_safe_push (edge, heap, crossing_edges, e);\n+\t    crossing_edges.safe_push (e);\n \t    flags |= EDGE_CROSSING;\n \t  }\n \n@@ -1583,12 +1583,12 @@ set_edge_can_fallthru_flag (void)\n    Convert any easy fall-through crossing edges to unconditional jumps.  */\n \n static void\n-add_labels_and_missing_jumps (VEC(edge, heap) *crossing_edges)\n+add_labels_and_missing_jumps (vec<edge> crossing_edges)\n {\n   size_t i;\n   edge e;\n \n-  FOR_EACH_VEC_ELT (edge, crossing_edges, i, e)\n+  FOR_EACH_VEC_ELT (crossing_edges, i, e)\n     {\n       basic_block src = e->src;\n       basic_block dest = e->dest;\n@@ -2500,15 +2500,15 @@ gate_handle_partition_blocks (void)\n static unsigned\n partition_hot_cold_basic_blocks (void)\n {\n-  VEC(edge, heap) *crossing_edges;\n+  vec<edge> crossing_edges;\n \n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n   crossing_edges = find_rarely_executed_basic_blocks_and_crossing_edges ();\n-  if (crossing_edges == NULL)\n+  if (!crossing_edges.exists ())\n     return 0;\n \n   /* Make sure the source of any crossing edge ends in a jump and the\n@@ -2539,7 +2539,7 @@ partition_hot_cold_basic_blocks (void)\n   /* Clear bb->aux fields that the above routines were using.  */\n   clear_aux_for_blocks ();\n \n-  VEC_free (edge, heap, crossing_edges);\n+  crossing_edges.release ();\n \n   /* ??? FIXME: DF generates the bb info for a block immediately.\n      And by immediately, I mean *during* creation of the block."}, {"sha": "fbeac7517c61beec0d67e00718d85af531b802c7", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -6581,7 +6581,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n       {\n \tunsigned int nargs, z;\n-\tVEC(tree,gc) *vec;\n+\tvec<tree, va_gc> *vec;\n \n \tmode = \n \t    get_builtin_sync_mode (fcode - BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1);\n@@ -6592,12 +6592,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \t/* If this is turned into an external library call, the weak parameter\n \t   must be dropped to match the expected parameter list.  */\n \tnargs = call_expr_nargs (exp);\n-\tvec = VEC_alloc (tree, gc, nargs - 1);\n+\tvec_alloc (vec, nargs - 1);\n \tfor (z = 0; z < 3; z++)\n-\t  VEC_quick_push (tree, vec, CALL_EXPR_ARG (exp, z));\n+\t  vec->quick_push (CALL_EXPR_ARG (exp, z));\n \t/* Skip the boolean weak parameter.  */\n \tfor (z = 4; z < 6; z++)\n-\t  VEC_quick_push (tree, vec, CALL_EXPR_ARG (exp, z));\n+\t  vec->quick_push (CALL_EXPR_ARG (exp, z));\n \texp = build_call_vec (TREE_TYPE (exp), CALL_EXPR_FN (exp), vec);\n \tbreak;\n       }\n@@ -11206,10 +11206,10 @@ build_call_expr_loc_array (location_t loc, tree fndecl, int n, tree *argarray)\n    VEC.  */\n \n tree\n-build_call_expr_loc_vec (location_t loc, tree fndecl, VEC(tree,gc) *vec)\n+build_call_expr_loc_vec (location_t loc, tree fndecl, vec<tree, va_gc> *vec)\n {\n-  return build_call_expr_loc_array (loc, fndecl, VEC_length (tree, vec),\n-\t\t\t\t    VEC_address (tree, vec));\n+  return build_call_expr_loc_array (loc, fndecl, vec_safe_length (vec),\n+\t\t\t\t    vec_safe_address (vec));\n }\n \n "}, {"sha": "fac71901e0f4ad640b4af01e6d4df83d93aeafa3", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 119, "deletions": 126, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1839,7 +1839,7 @@ strict_aliasing_warning (tree otype, tree type, tree expr)\n \n void\n sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n-\t\t\t\t  VEC(tree, gc) *params, tree *sizeof_arg,\n+\t\t\t\t  vec<tree, va_gc> *params, tree *sizeof_arg,\n \t\t\t\t  bool (*comp_types) (tree, tree))\n {\n   tree type, dest = NULL_TREE, src = NULL_TREE, tem;\n@@ -1849,7 +1849,7 @@ sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n \n   if (TREE_CODE (callee) != FUNCTION_DECL\n       || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n-      || VEC_length (tree, params) <= 1)\n+      || vec_safe_length (params) <= 1)\n     return;\n \n   switch (DECL_FUNCTION_CODE (callee))\n@@ -1870,55 +1870,55 @@ sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n     case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMMOVE:\n     case BUILT_IN_MEMMOVE_CHK:\n-      if (VEC_length (tree, params) < 3)\n+      if (params->length () < 3)\n \treturn;\n-      src = VEC_index (tree, params, 1);\n-      dest = VEC_index (tree, params, 0);\n+      src = (*params)[1];\n+      dest = (*params)[0];\n       idx = 2;\n       break;\n     case BUILT_IN_BCOPY:\n-      if (VEC_length (tree, params) < 3)\n+      if (params->length () < 3)\n \treturn;\n-      src = VEC_index (tree, params, 0);\n-      dest = VEC_index (tree, params, 1);\n+      src = (*params)[0];\n+      dest = (*params)[1];\n       idx = 2;\n       break;\n     case BUILT_IN_MEMCMP:\n     case BUILT_IN_BCMP:\n-      if (VEC_length (tree, params) < 3)\n+      if (params->length () < 3)\n \treturn;\n-      src = VEC_index (tree, params, 1);\n-      dest = VEC_index (tree, params, 0);\n+      src = (*params)[1];\n+      dest = (*params)[0];\n       idx = 2;\n       cmp = true;\n       break;\n     case BUILT_IN_MEMSET:\n     case BUILT_IN_MEMSET_CHK:\n-      if (VEC_length (tree, params) < 3)\n+      if (params->length () < 3)\n \treturn;\n-      dest = VEC_index (tree, params, 0);\n+      dest = (*params)[0];\n       idx = 2;\n       break;\n     case BUILT_IN_BZERO:\n-      dest = VEC_index (tree, params, 0);\n+      dest = (*params)[0];\n       idx = 1;\n       break;\n     case BUILT_IN_STRNDUP:\n-      src = VEC_index (tree, params, 0);\n+      src = (*params)[0];\n       strop = true;\n       idx = 1;\n       break;\n     case BUILT_IN_MEMCHR:\n-      if (VEC_length (tree, params) < 3)\n+      if (params->length () < 3)\n \treturn;\n-      src = VEC_index (tree, params, 0);\n+      src = (*params)[0];\n       idx = 2;\n       break;\n     case BUILT_IN_SNPRINTF:\n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF:\n     case BUILT_IN_VSNPRINTF_CHK:\n-      dest = VEC_index (tree, params, 0);\n+      dest = (*params)[0];\n       idx = 1;\n       strop = true;\n       break;\n@@ -8729,9 +8729,7 @@ handle_target_attribute (tree *node, tree name, tree args, int flags,\n \n /* Arguments being collected for optimization.  */\n typedef const char *const_char_p;\t\t/* For DEF_VEC_P.  */\n-DEF_VEC_P(const_char_p);\n-DEF_VEC_ALLOC_P(const_char_p, gc);\n-static GTY(()) VEC(const_char_p, gc) *optimize_args;\n+static GTY(()) vec<const_char_p, va_gc> *optimize_args;\n \n \n /* Inner function to convert a TREE_LIST to argv string to parse the optimize\n@@ -8752,8 +8750,8 @@ parse_optimize_options (tree args, bool attr_p)\n \n   /* Build up argv vector.  Just in case the string is stored away, use garbage\n      collected strings.  */\n-  VEC_truncate (const_char_p, optimize_args, 0);\n-  VEC_safe_push (const_char_p, gc, optimize_args, NULL);\n+  vec_safe_truncate (optimize_args, 0);\n+  vec_safe_push (optimize_args, (const char *) NULL);\n \n   for (ap = args; ap != NULL_TREE; ap = TREE_CHAIN (ap))\n     {\n@@ -8763,7 +8761,7 @@ parse_optimize_options (tree args, bool attr_p)\n \t{\n \t  char buffer[20];\n \t  sprintf (buffer, \"-O%ld\", (long) TREE_INT_CST_LOW (value));\n-\t  VEC_safe_push (const_char_p, gc, optimize_args, ggc_strdup (buffer));\n+\t  vec_safe_push (optimize_args, ggc_strdup (buffer));\n \t}\n \n       else if (TREE_CODE (value) == STRING_CST)\n@@ -8825,17 +8823,17 @@ parse_optimize_options (tree args, bool attr_p)\n \n \t      memcpy (r, p, len2);\n \t      r[len2] = '\\0';\n-\t      VEC_safe_push (const_char_p, gc, optimize_args, q);\n+\t      vec_safe_push (optimize_args, (const char *) q);\n \t    }\n \n \t}\n     }\n \n-  opt_argc = VEC_length (const_char_p, optimize_args);\n+  opt_argc = optimize_args->length ();\n   opt_argv = (const char **) alloca (sizeof (char *) * (opt_argc + 1));\n \n   for (i = 1; i < opt_argc; i++)\n-    opt_argv[i] = VEC_index (const_char_p, optimize_args, i);\n+    opt_argv[i] = (*optimize_args)[i];\n \n   saved_flag_strict_aliasing = flag_strict_aliasing;\n \n@@ -8852,7 +8850,7 @@ parse_optimize_options (tree args, bool attr_p)\n   /* Don't allow changing -fstrict-aliasing.  */\n   flag_strict_aliasing = saved_flag_strict_aliasing;\n \n-  VEC_truncate (const_char_p, optimize_args, 0);\n+  optimize_args->truncate (0);\n   return ret;\n }\n \n@@ -9736,9 +9734,9 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t}\n       else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n \t{\n-\t  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (initial_value);\n+\t  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (initial_value);\n \n-\t  if (VEC_empty (constructor_elt, v))\n+\t  if (vec_safe_is_empty (v))\n \t    {\n \t      if (pedantic)\n \t\tfailure = 3;\n@@ -9751,15 +9749,12 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t      constructor_elt *ce;\n \t      bool fold_p = false;\n \n-\t      if (VEC_index (constructor_elt, v, 0).index)\n+\t      if ((*v)[0].index)\n \t\tmaxindex = fold_convert_loc (input_location, sizetype,\n-\t\t\t\t\t     VEC_index (constructor_elt,\n-\t\t\t\t\t\t\tv, 0).index);\n+\t\t\t\t\t     (*v)[0].index);\n \t      curindex = maxindex;\n \n-\t      for (cnt = 1;\n-\t\t   VEC_iterate (constructor_elt, v, cnt, ce);\n-\t\t   cnt++)\n+\t      for (cnt = 1; vec_safe_iterate (v, cnt, &ce); cnt++)\n \t\t{\n \t\t  bool curfold_p = false;\n \t\t  if (ce->index)\n@@ -9879,18 +9874,18 @@ builtin_type_for_size (int size, bool unsignedp)\n    Returns 0 if an error is encountered.  */\n \n static int\n-sync_resolve_size (tree function, VEC(tree,gc) *params)\n+sync_resolve_size (tree function, vec<tree, va_gc> *params)\n {\n   tree type;\n   int size;\n \n-  if (VEC_empty (tree, params))\n+  if (!params)\n     {\n       error (\"too few arguments to function %qE\", function);\n       return 0;\n     }\n \n-  type = TREE_TYPE (VEC_index (tree, params, 0));\n+  type = TREE_TYPE ((*params)[0]);\n   if (TREE_CODE (type) != POINTER_TYPE)\n     goto incompatible;\n \n@@ -9914,7 +9909,7 @@ sync_resolve_size (tree function, VEC(tree,gc) *params)\n \n static bool\n sync_resolve_params (location_t loc, tree orig_function, tree function,\n-\t\t     VEC(tree, gc) *params, bool orig_format)\n+\t\t     vec<tree, va_gc> *params, bool orig_format)\n {\n   function_args_iterator iter;\n   tree ptype;\n@@ -9925,7 +9920,7 @@ sync_resolve_params (location_t loc, tree orig_function, tree function,\n      as the pointer parameter, so we shouldn't get any complaints from the\n      call to check_function_arguments what ever type the user used.  */\n   function_args_iter_next (&iter);\n-  ptype = TREE_TYPE (TREE_TYPE (VEC_index (tree, params, 0)));\n+  ptype = TREE_TYPE (TREE_TYPE ((*params)[0]));\n \n   /* For the rest of the values, we need to cast these to FTYPE, so that we\n      don't get warnings for passing pointer types, etc.  */\n@@ -9940,7 +9935,7 @@ sync_resolve_params (location_t loc, tree orig_function, tree function,\n \tbreak;\n \n       ++parmnum;\n-      if (VEC_length (tree, params) <= parmnum)\n+      if (params->length () <= parmnum)\n \t{\n \t  error_at (loc, \"too few arguments to function %qE\", orig_function);\n \t  return false;\n@@ -9956,17 +9951,17 @@ sync_resolve_params (location_t loc, tree orig_function, tree function,\n \t  /* Ideally for the first conversion we'd use convert_for_assignment\n \t     so that we get warnings for anything that doesn't match the pointer\n \t     type.  This isn't portable across the C and C++ front ends atm.  */\n-\t  val = VEC_index (tree, params, parmnum);\n+\t  val = (*params)[parmnum];\n \t  val = convert (ptype, val);\n \t  val = convert (arg_type, val);\n-\t  VEC_replace (tree, params, parmnum, val);\n+\t  (*params)[parmnum] = val;\n \t}\n \n       function_args_iter_next (&iter);\n     }\n \n   /* __atomic routines are not variadic.  */\n-  if (!orig_format && VEC_length (tree, params) != parmnum + 1)\n+  if (!orig_format && params->length () != parmnum + 1)\n     {\n       error_at (loc, \"too many arguments to function %qE\", orig_function);\n       return false;\n@@ -9976,7 +9971,7 @@ sync_resolve_params (location_t loc, tree orig_function, tree function,\n      being \"an optional list of variables protected by the memory barrier\".\n      No clue what that's supposed to mean, precisely, but we consider all\n      call-clobbered variables to be protected so we're safe.  */\n-  VEC_truncate (tree, params, parmnum + 1);\n+  params->truncate (parmnum + 1);\n \n   return true;\n }\n@@ -10004,7 +9999,8 @@ sync_resolve_return (tree first_param, tree result, bool orig_format)\n    0 is returned if the parameters are invalid.  */\n \n static int\n-get_atomic_generic_size (location_t loc, tree function, VEC(tree,gc) *params)\n+get_atomic_generic_size (location_t loc, tree function,\n+\t\t\t vec<tree, va_gc> *params)\n {\n   unsigned int n_param;\n   unsigned int n_model;\n@@ -10032,14 +10028,14 @@ get_atomic_generic_size (location_t loc, tree function, VEC(tree,gc) *params)\n       gcc_unreachable ();\n     }\n \n-  if (VEC_length (tree, params) != n_param)\n+  if (vec_safe_length (params) != n_param)\n     {\n       error_at (loc, \"incorrect number of arguments to function %qE\", function);\n       return 0;\n     }\n \n   /* Get type of first parameter, and determine its size.  */\n-  type_0 = TREE_TYPE (VEC_index (tree, params, 0));\n+  type_0 = TREE_TYPE ((*params)[0]);\n   if (TREE_CODE (type_0) != POINTER_TYPE || VOID_TYPE_P (TREE_TYPE (type_0)))\n     {\n       error_at (loc, \"argument 1 of %qE must be a non-void pointer type\",\n@@ -10071,7 +10067,7 @@ get_atomic_generic_size (location_t loc, tree function, VEC(tree,gc) *params)\n   for (x = 0; x < n_param - n_model; x++)\n     {\n       int size;\n-      tree type = TREE_TYPE (VEC_index (tree, params, x));\n+      tree type = TREE_TYPE ((*params)[x]);\n       /* __atomic_compare_exchange has a bool in the 4th postion, skip it.  */\n       if (n_param == 6 && x == 3)\n         continue;\n@@ -10093,7 +10089,7 @@ get_atomic_generic_size (location_t loc, tree function, VEC(tree,gc) *params)\n   /* Check memory model parameters for validity.  */\n   for (x = n_param - n_model ; x < n_param; x++)\n     {\n-      tree p = VEC_index (tree, params, x);\n+      tree p = (*params)[x];\n       if (TREE_CODE (p) == INTEGER_CST)\n         {\n \t  int i = tree_low_cst (p, 1);\n@@ -10126,30 +10122,30 @@ get_atomic_generic_size (location_t loc, tree function, VEC(tree,gc) *params)\n \n static tree\n add_atomic_size_parameter (unsigned n, location_t loc, tree function, \n-\t\t\t   VEC(tree,gc) *params)\n+\t\t\t   vec<tree, va_gc> *params)\n {\n   tree size_node;\n \n   /* Insert a SIZE_T parameter as the first param.  If there isn't\n      enough space, allocate a new vector and recursively re-build with that.  */\n-  if (!VEC_space (tree, params, 1))\n+  if (!params->space (1))\n     {\n       unsigned int z, len;\n-      VEC(tree,gc) *vec;\n+      vec<tree, va_gc> *v;\n       tree f;\n \n-      len = VEC_length (tree, params);\n-      vec = VEC_alloc (tree, gc, len + 1);\n+      len = params->length ();\n+      vec_alloc (v, len + 1);\n       for (z = 0; z < len; z++)\n-\tVEC_quick_push (tree, vec, VEC_index (tree, params, z));\n-      f = build_function_call_vec (loc, function, vec, NULL);\n-      VEC_free (tree, gc, vec);\n+\tv->quick_push ((*params)[z]);\n+      f = build_function_call_vec (loc, function, v, NULL);\n+      vec_free (v);\n       return f;\n     }\n \n   /* Add the size parameter and leave as a function call for processing.  */\n   size_node = build_int_cst (size_type_node, n);\n-  VEC_quick_insert (tree, params, 0, size_node);\n+  params->quick_insert (0, size_node);\n   return NULL_TREE;\n }\n \n@@ -10165,7 +10161,7 @@ add_atomic_size_parameter (unsigned n, location_t loc, tree function,\n    NEW_RETURN is set to the the return value the result is copied into.  */\n static bool\n resolve_overloaded_atomic_exchange (location_t loc, tree function, \n-\t\t\t\t    VEC(tree,gc) *params, tree *new_return)\n+\t\t\t\t    vec<tree, va_gc> *params, tree *new_return)\n {\t\n   tree p0, p1, p2, p3;\n   tree I_type, I_type_ptr;\n@@ -10190,26 +10186,26 @@ resolve_overloaded_atomic_exchange (location_t loc, tree function,\n      into\n        *return = (T) (fn (In* mem, (In) *desired, model))  */\n \n-  p0 = VEC_index (tree, params, 0);\n-  p1 = VEC_index (tree, params, 1);\n-  p2 = VEC_index (tree, params, 2);\n-  p3 = VEC_index (tree, params, 3);\n+  p0 = (*params)[0];\n+  p1 = (*params)[1];\n+  p2 = (*params)[2];\n+  p3 = (*params)[3];\n   \n   /* Create pointer to appropriate size.  */\n   I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n   I_type_ptr = build_pointer_type (I_type);\n \n   /* Convert object pointer to required type.  */\n   p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n-  VEC_replace (tree, params, 0, p0); \n+  (*params)[0] = p0; \n   /* Convert new value to required type, and dereference it.  */\n   p1 = build_indirect_ref (loc, p1, RO_UNARY_STAR);\n   p1 = build1 (VIEW_CONVERT_EXPR, I_type, p1);\n-  VEC_replace (tree, params, 1, p1);\n+  (*params)[1] = p1;\n \n   /* Move memory model to the 3rd position, and end param list.  */\n-  VEC_replace (tree, params, 2, p3);\n-  VEC_truncate (tree, params, 3);\n+  (*params)[2] = p3;\n+  params->truncate (3);\n \n   /* Convert return pointer and dereference it for later assignment.  */\n   *new_return = build_indirect_ref (loc, p2, RO_UNARY_STAR);\n@@ -10229,7 +10225,7 @@ resolve_overloaded_atomic_exchange (location_t loc, tree function,\n \n static bool\n resolve_overloaded_atomic_compare_exchange (location_t loc, tree function, \n-\t\t\t\t\t    VEC(tree,gc) *params, \n+\t\t\t\t\t    vec<tree, va_gc> *params, \n \t\t\t\t\t    tree *new_return)\n {\t\n   tree p0, p1, p2;\n@@ -10253,9 +10249,9 @@ resolve_overloaded_atomic_compare_exchange (location_t loc, tree function,\n \t there is no danger this will be done twice.  */\n       if (n > 0)\n         {\n-\t  VEC_replace (tree, params, 3, VEC_index (tree, params, 4));\n-\t  VEC_replace (tree, params, 4, VEC_index (tree, params, 5));\n-\t  VEC_truncate (tree, params, 5);\n+\t  (*params)[3] = (*params)[4];\n+\t  (*params)[4] = (*params)[5];\n+\t  params->truncate (5);\n \t}\n       *new_return = add_atomic_size_parameter (n, loc, function, params);\n       return true;\n@@ -10266,26 +10262,26 @@ resolve_overloaded_atomic_compare_exchange (location_t loc, tree function,\n      into\n        bool fn ((In *)mem, (In *)expected, (In) *desired, weak, succ, fail)  */\n \n-  p0 = VEC_index (tree, params, 0);\n-  p1 = VEC_index (tree, params, 1);\n-  p2 = VEC_index (tree, params, 2);\n+  p0 = (*params)[0];\n+  p1 = (*params)[1];\n+  p2 = (*params)[2];\n   \n   /* Create pointer to appropriate size.  */\n   I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n   I_type_ptr = build_pointer_type (I_type);\n \n   /* Convert object pointer to required type.  */\n   p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n-  VEC_replace (tree, params, 0, p0);\n+  (*params)[0] = p0;\n \n   /* Convert expected pointer to required type.  */\n   p1 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p1);\n-  VEC_replace (tree, params, 1, p1);\n+  (*params)[1] = p1;\n \n   /* Convert desired value to required type, and dereference it.  */\n   p2 = build_indirect_ref (loc, p2, RO_UNARY_STAR);\n   p2 = build1 (VIEW_CONVERT_EXPR, I_type, p2);\n-  VEC_replace (tree, params, 2, p2);\n+  (*params)[2] = p2;\n \n   /* The rest of the parameters are fine. NULL means no special return value\n      processing.*/\n@@ -10306,7 +10302,7 @@ resolve_overloaded_atomic_compare_exchange (location_t loc, tree function,\n \n static bool\n resolve_overloaded_atomic_load (location_t loc, tree function, \n-\t\t\t\tVEC(tree,gc) *params, tree *new_return)\n+\t\t\t\tvec<tree, va_gc> *params, tree *new_return)\n {\t\n   tree p0, p1, p2;\n   tree I_type, I_type_ptr;\n@@ -10331,21 +10327,21 @@ resolve_overloaded_atomic_load (location_t loc, tree function,\n      into\n        *return = (T) (fn ((In *) mem, model))  */\n \n-  p0 = VEC_index (tree, params, 0);\n-  p1 = VEC_index (tree, params, 1);\n-  p2 = VEC_index (tree, params, 2);\n+  p0 = (*params)[0];\n+  p1 = (*params)[1];\n+  p2 = (*params)[2];\n   \n   /* Create pointer to appropriate size.  */\n   I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n   I_type_ptr = build_pointer_type (I_type);\n \n   /* Convert object pointer to required type.  */\n   p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n-  VEC_replace (tree, params, 0, p0);\n+  (*params)[0] = p0;\n \n   /* Move memory model to the 2nd position, and end param list.  */\n-  VEC_replace (tree, params, 1, p2);\n-  VEC_truncate (tree, params, 2);\n+  (*params)[1] = p2;\n+  params->truncate (2);\n \n   /* Convert return pointer and dereference it for later assignment.  */\n   *new_return = build_indirect_ref (loc, p1, RO_UNARY_STAR);\n@@ -10366,7 +10362,7 @@ resolve_overloaded_atomic_load (location_t loc, tree function,\n \n static bool\n resolve_overloaded_atomic_store (location_t loc, tree function, \n-\t\t\t\t VEC(tree,gc) *params, tree *new_return)\n+\t\t\t\t vec<tree, va_gc> *params, tree *new_return)\n {\t\n   tree p0, p1;\n   tree I_type, I_type_ptr;\n@@ -10391,21 +10387,21 @@ resolve_overloaded_atomic_store (location_t loc, tree function,\n      into\n        fn ((In *) mem, (In) *value, model)  */\n \n-  p0 = VEC_index (tree, params, 0);\n-  p1 = VEC_index (tree, params, 1);\n+  p0 = (*params)[0];\n+  p1 = (*params)[1];\n   \n   /* Create pointer to appropriate size.  */\n   I_type = builtin_type_for_size (BITS_PER_UNIT * n, 1);\n   I_type_ptr = build_pointer_type (I_type);\n \n   /* Convert object pointer to required type.  */\n   p0 = build1 (VIEW_CONVERT_EXPR, I_type_ptr, p0);\n-  VEC_replace (tree, params, 0, p0);\n+  (*params)[0] = p0;\n \n   /* Convert new value to required type, and dereference it.  */\n   p1 = build_indirect_ref (loc, p1, RO_UNARY_STAR);\n   p1 = build1 (VIEW_CONVERT_EXPR, I_type, p1);\n-  VEC_replace (tree, params, 1, p1);\n+  (*params)[1] = p1;\n   \n   /* The memory model is in the right spot already. Return is void.  */\n   *new_return = NULL_TREE;\n@@ -10426,7 +10422,8 @@ resolve_overloaded_atomic_store (location_t loc, tree function,\n    continue.  */\n \n tree\n-resolve_overloaded_builtin (location_t loc, tree function, VEC(tree,gc) *params)\n+resolve_overloaded_builtin (location_t loc, tree function,\n+\t\t\t    vec<tree, va_gc> *params)\n {\n   enum built_in_function orig_code = DECL_FUNCTION_CODE (function);\n   bool orig_format = true;\n@@ -10550,7 +10547,7 @@ resolve_overloaded_builtin (location_t loc, tree function, VEC(tree,gc) *params)\n \t\t\t\t  orig_format))\n \t  return error_mark_node;\n \n-\tfirst_param = VEC_index (tree, params, 0);\n+\tfirst_param = (*params)[0];\n \tresult = build_function_call_vec (loc, new_function, params, NULL);\n \tif (result == error_mark_node)\n \t  return result;\n@@ -11097,9 +11094,9 @@ record_types_used_by_current_var_decl (tree decl)\n {\n   gcc_assert (decl && DECL_P (decl) && TREE_STATIC (decl));\n \n-  while (!VEC_empty (tree, types_used_by_cur_var_decl))\n+  while (types_used_by_cur_var_decl && !types_used_by_cur_var_decl->is_empty ())\n     {\n-      tree type = VEC_pop (tree, types_used_by_cur_var_decl);\n+      tree type = types_used_by_cur_var_decl->pop ();\n       types_used_by_var_decl_insert (type, decl);\n     }\n }\n@@ -11121,7 +11118,7 @@ record_locally_defined_typedef (tree decl)\n     return;\n \n   l = (struct c_language_function *) cfun->language;\n-  VEC_safe_push (tree, gc, l->local_typedefs, decl);\n+  vec_safe_push (l->local_typedefs, decl);\n }\n \n /* If T is a TYPE_DECL declared locally, mark it as used.  */\n@@ -11159,94 +11156,90 @@ maybe_warn_unused_local_typedefs (void)\n   if (warn_unused_local_typedefs\n       && errorcount == unused_local_typedefs_warn_count)\n     {\n-      FOR_EACH_VEC_ELT (tree, l->local_typedefs, i, decl)\n+      FOR_EACH_VEC_SAFE_ELT (l->local_typedefs, i, decl)\n \tif (!TREE_USED (decl))\n \t  warning_at (DECL_SOURCE_LOCATION (decl),\n \t\t      OPT_Wunused_local_typedefs,\n \t\t      \"typedef %qD locally defined but not used\", decl);\n       unused_local_typedefs_warn_count = errorcount;\n     }\n \n-  if (l->local_typedefs)\n-    {\n-      VEC_free (tree, gc, l->local_typedefs);\n-      l->local_typedefs = NULL;\n-    }\n+  vec_free (l->local_typedefs);\n }\n \n /* The C and C++ parsers both use vectors to hold function arguments.\n    For efficiency, we keep a cache of unused vectors.  This is the\n    cache.  */\n \n-typedef VEC(tree,gc)* tree_gc_vec;\n-DEF_VEC_P(tree_gc_vec);\n-DEF_VEC_ALLOC_P(tree_gc_vec,gc);\n-static GTY((deletable)) VEC(tree_gc_vec,gc) *tree_vector_cache;\n+typedef vec<tree, va_gc> *tree_gc_vec;\n+static GTY((deletable)) vec<tree_gc_vec, va_gc> *tree_vector_cache;\n \n /* Return a new vector from the cache.  If the cache is empty,\n    allocate a new vector.  These vectors are GC'ed, so it is OK if the\n    pointer is not released..  */\n \n-VEC(tree,gc) *\n+vec<tree, va_gc> *\n make_tree_vector (void)\n {\n-  if (!VEC_empty (tree_gc_vec, tree_vector_cache))\n-    return VEC_pop (tree_gc_vec, tree_vector_cache);\n+  if (tree_vector_cache && !tree_vector_cache->is_empty ())\n+    return tree_vector_cache->pop ();\n   else\n     {\n-      /* Passing 0 to VEC_alloc returns NULL, and our callers require\n+      /* Passing 0 to vec::alloc returns NULL, and our callers require\n \t that we always return a non-NULL value.  The vector code uses\n \t 4 when growing a NULL vector, so we do too.  */\n-      return VEC_alloc (tree, gc, 4);\n+      vec<tree, va_gc> *v;\n+      vec_alloc (v, 4);\n+      return v;\n     }\n }\n \n /* Release a vector of trees back to the cache.  */\n \n void\n-release_tree_vector (VEC(tree,gc) *vec)\n+release_tree_vector (vec<tree, va_gc> *vec)\n {\n   if (vec != NULL)\n     {\n-      VEC_truncate (tree, vec, 0);\n-      VEC_safe_push (tree_gc_vec, gc, tree_vector_cache, vec);\n+      vec->truncate (0);\n+      vec_safe_push (tree_vector_cache, vec);\n     }\n }\n \n /* Get a new tree vector holding a single tree.  */\n \n-VEC(tree,gc) *\n+vec<tree, va_gc> *\n make_tree_vector_single (tree t)\n {\n-  VEC(tree,gc) *ret = make_tree_vector ();\n-  VEC_quick_push (tree, ret, t);\n+  vec<tree, va_gc> *ret = make_tree_vector ();\n+  ret->quick_push (t);\n   return ret;\n }\n \n /* Get a new tree vector of the TREE_VALUEs of a TREE_LIST chain.  */\n \n-VEC(tree,gc) *\n+vec<tree, va_gc> *\n make_tree_vector_from_list (tree list)\n {\n-  VEC(tree,gc) *ret = make_tree_vector ();\n+  vec<tree, va_gc> *ret = make_tree_vector ();\n   for (; list; list = TREE_CHAIN (list))\n-    VEC_safe_push (tree, gc, ret, TREE_VALUE (list));\n+    vec_safe_push (ret, TREE_VALUE (list));\n   return ret;\n }\n \n /* Get a new tree vector which is a copy of an existing one.  */\n \n-VEC(tree,gc) *\n-make_tree_vector_copy (const VEC(tree,gc) *orig)\n+vec<tree, va_gc> *\n+make_tree_vector_copy (const vec<tree, va_gc> *orig)\n {\n-  VEC(tree,gc) *ret;\n+  vec<tree, va_gc> *ret;\n   unsigned int ix;\n   tree t;\n \n   ret = make_tree_vector ();\n-  VEC_reserve (tree, gc, ret, VEC_length (tree, orig));\n-  FOR_EACH_VEC_ELT (tree, orig, ix, t)\n-    VEC_quick_push (tree, ret, t);\n+  vec_safe_reserve (ret, vec_safe_length (orig));\n+  FOR_EACH_VEC_SAFE_ELT (orig, ix, t)\n+    ret->quick_push (t);\n   return ret;\n }\n "}, {"sha": "afd8f07e72f937fe29f91616d6fd2ea14abe71d5", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -486,7 +486,7 @@ typedef enum ref_operator {\n \n struct GTY(()) stmt_tree_s {\n   /* A stack of statement lists being collected.  */\n-  VEC(tree,gc) *x_cur_stmt_list;\n+  vec<tree, va_gc> *x_cur_stmt_list;\n \n   /* In C++, Nonzero if we should treat statements as full\n      expressions.  In particular, this variable is non-zero if at the\n@@ -512,20 +512,16 @@ struct GTY(()) c_language_function {\n \n   /* Vector of locally defined typedefs, for\n      -Wunused-local-typedefs.  */\n-  VEC(tree,gc) *local_typedefs;\n+  vec<tree, va_gc> *local_typedefs;\n };\n \n #define stmt_list_stack (current_stmt_tree ()->x_cur_stmt_list)\n \n /* When building a statement-tree, this is the current statement list\n-   being collected.  We define it in this convoluted way, rather than\n-   using VEC_last, because it must be an lvalue.  */\n+   being collected.  */\n+#define cur_stmt_list\t(stmt_list_stack->last ())\n \n-#define cur_stmt_list\t\t\t\t\t\t\t\\\n-  (*(VEC_address (tree, stmt_list_stack)\t\t\t\t\\\n-     + VEC_length (tree, stmt_list_stack) - 1))\n-\n-#define building_stmt_list_p() (!VEC_empty (tree, stmt_list_stack))\n+#define building_stmt_list_p() (stmt_list_stack && !stmt_list_stack->is_empty())\n \n /* Language-specific hooks.  */\n \n@@ -759,7 +755,7 @@ extern void constant_expression_warning (tree);\n extern void constant_expression_error (tree);\n extern bool strict_aliasing_warning (tree, tree, tree);\n extern void sizeof_pointer_memaccess_warning (location_t *, tree,\n-\t\t\t\t\t      VEC(tree, gc) *, tree *,\n+\t\t\t\t\t      vec<tree, va_gc> *, tree *,\n \t\t\t\t\t      bool (*) (tree, tree));\n extern void warnings_for_convert_and_check (tree, tree, tree);\n extern tree convert_and_check (tree, tree);\n@@ -899,10 +895,10 @@ extern void c_do_switch_warnings (splay_tree, location_t, tree, tree);\n \n extern tree build_function_call (location_t, tree, tree);\n \n-extern tree build_function_call_vec (location_t, tree,\n-    \t\t\t\t     VEC(tree,gc) *, VEC(tree,gc) *);\n+extern tree build_function_call_vec (location_t, tree, vec<tree, va_gc> *,\n+\t\t\t\t     vec<tree, va_gc> *);\n \n-extern tree resolve_overloaded_builtin (location_t, tree, VEC(tree,gc) *);\n+extern tree resolve_overloaded_builtin (location_t, tree, vec<tree, va_gc> *);\n \n extern tree finish_label_address_expr (tree, location_t);\n \n@@ -997,11 +993,11 @@ extern void set_underlying_type (tree);\n extern void record_locally_defined_typedef (tree);\n extern void maybe_record_typedef_use (tree);\n extern void maybe_warn_unused_local_typedefs (void);\n-extern VEC(tree,gc) *make_tree_vector (void);\n-extern void release_tree_vector (VEC(tree,gc) *);\n-extern VEC(tree,gc) *make_tree_vector_single (tree);\n-extern VEC(tree,gc) *make_tree_vector_from_list (tree);\n-extern VEC(tree,gc) *make_tree_vector_copy (const VEC(tree,gc) *);\n+extern vec<tree, va_gc> *make_tree_vector (void);\n+extern void release_tree_vector (vec<tree, va_gc> *);\n+extern vec<tree, va_gc> *make_tree_vector_single (tree);\n+extern vec<tree, va_gc> *make_tree_vector_from_list (tree);\n+extern vec<tree, va_gc> *make_tree_vector_copy (const vec<tree, va_gc> *);\n \n /* In c-gimplify.c  */\n extern void c_genericize (tree);"}, {"sha": "27814e1a1fb66b1d8485996b5af5d29e1a1df600", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -108,9 +108,9 @@ add_block_to_enclosing (tree block)\n   unsigned i;\n   tree enclosing;\n   gimple bind;\n-  VEC(gimple, heap) *stack = gimple_bind_expr_stack ();\n+  vec<gimple> stack = gimple_bind_expr_stack ();\n \n-  FOR_EACH_VEC_ELT (gimple, stack, i, bind)\n+  FOR_EACH_VEC_ELT (stack, i, bind)\n     if (gimple_bind_block (bind))\n       break;\n "}, {"sha": "f04cc6f13f900dfd9c9ebd629f0960b7ceb5d6ac", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -33,7 +33,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\t\t/* For REGISTER_TARGET_PRAGMAS (why is\n \t\t\t\t   this not a target hook?).  */\n #include \"vec.h\"\n-#include \"vecprim.h\"\n #include \"target.h\"\n #include \"diagnostic.h\"\n #include \"opts.h\"\n@@ -241,10 +240,8 @@ typedef struct GTY(()) pending_weak_d\n   tree value;\n } pending_weak;\n \n-DEF_VEC_O(pending_weak);\n-DEF_VEC_ALLOC_O(pending_weak,gc);\n \n-static GTY(()) VEC(pending_weak,gc) *pending_weaks;\n+static GTY(()) vec<pending_weak, va_gc> *pending_weaks;\n \n static void apply_pragma_weak (tree, tree);\n static void handle_pragma_weak (cpp_reader *);\n@@ -294,11 +291,11 @@ maybe_apply_pragma_weak (tree decl)\n \n   id = DECL_ASSEMBLER_NAME (decl);\n \n-  FOR_EACH_VEC_ELT (pending_weak, pending_weaks, i, pe)\n+  FOR_EACH_VEC_ELT (*pending_weaks, i, pe)\n     if (id == pe->name)\n       {\n \tapply_pragma_weak (decl, pe->value);\n-\tVEC_unordered_remove (pending_weak, pending_weaks, i);\n+\tpending_weaks->unordered_remove (i);\n \tbreak;\n       }\n }\n@@ -313,7 +310,10 @@ maybe_apply_pending_pragma_weaks (void)\n   pending_weak *pe;\n   symtab_node target;\n \n-  FOR_EACH_VEC_ELT (pending_weak, pending_weaks, i, pe)\n+  if (!pending_weaks)\n+    return;\n+\n+  FOR_EACH_VEC_ELT (*pending_weaks, i, pe)\n     {\n       alias_id = pe->name;\n       id = pe->value;\n@@ -373,7 +373,7 @@ handle_pragma_weak (cpp_reader * ARG_UNUSED (dummy))\n   else\n     {\n       pending_weak pe = {name, value};\n-      VEC_safe_push (pending_weak, gc, pending_weaks, pe);\n+      vec_safe_push (pending_weaks, pe);\n     }\n }\n \n@@ -414,10 +414,8 @@ typedef struct GTY(()) pending_redefinition_d {\n   tree newname;\n } pending_redefinition;\n \n-DEF_VEC_O(pending_redefinition);\n-DEF_VEC_ALLOC_O(pending_redefinition,gc);\n \n-static GTY(()) VEC(pending_redefinition,gc) *pending_redefine_extname;\n+static GTY(()) vec<pending_redefinition, va_gc> *pending_redefine_extname;\n \n static void handle_pragma_redefine_extname (cpp_reader *);\n \n@@ -488,7 +486,7 @@ add_to_renaming_pragma_list (tree oldname, tree newname)\n   unsigned ix;\n   pending_redefinition *p;\n \n-  FOR_EACH_VEC_ELT (pending_redefinition, pending_redefine_extname, ix, p)\n+  FOR_EACH_VEC_SAFE_ELT (pending_redefine_extname, ix, p)\n     if (oldname == p->oldname)\n       {\n \tif (p->newname != newname)\n@@ -498,7 +496,7 @@ add_to_renaming_pragma_list (tree oldname, tree newname)\n       }\n \n   pending_redefinition e = {oldname, newname};\n-  VEC_safe_push (pending_redefinition, gc, pending_redefine_extname, e);\n+  vec_safe_push (pending_redefine_extname, e);\n }\n \n /* The current prefix set by #pragma extern_prefix.  */\n@@ -532,28 +530,26 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)\n \t\t   \"conflict with previous rename\");\n \n       /* Take any pending redefine_extname off the list.  */\n-      FOR_EACH_VEC_ELT (pending_redefinition, pending_redefine_extname, ix, p)\n+      FOR_EACH_VEC_SAFE_ELT (pending_redefine_extname, ix, p)\n \tif (DECL_NAME (decl) == p->oldname)\n \t  {\n \t    /* Only warn if there is a conflict.  */\n \t    if (strcmp (IDENTIFIER_POINTER (p->newname), oldname))\n \t      warning (OPT_Wpragmas, \"#pragma redefine_extname ignored due to \"\n \t\t       \"conflict with previous rename\");\n \n-\t    VEC_unordered_remove (pending_redefinition,\n-\t\t\t\t  pending_redefine_extname, ix);\n+\t    pending_redefine_extname->unordered_remove (ix);\n \t    break;\n \t  }\n       return 0;\n     }\n \n   /* Find out if we have a pending #pragma redefine_extname.  */\n-  FOR_EACH_VEC_ELT (pending_redefinition, pending_redefine_extname, ix, p)\n+  FOR_EACH_VEC_SAFE_ELT (pending_redefine_extname, ix, p)\n     if (DECL_NAME (decl) == p->oldname)\n       {\n \ttree newname = p->newname;\n-\tVEC_unordered_remove (pending_redefinition,\n-\t\t\t      pending_redefine_extname, ix);\n+\tpending_redefine_extname->unordered_remove (ix);\n \n \t/* If we already have an asmname, #pragma redefine_extname is\n \t   ignored (with a warning if it conflicts).  */\n@@ -600,7 +596,7 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)\n \n static void handle_pragma_visibility (cpp_reader *);\n \n-static VEC (int, heap) *visstack;\n+static vec<int> visstack;\n \n /* Push the visibility indicated by STR onto the top of the #pragma\n    visibility stack.  KIND is 0 for #pragma GCC visibility, 1 for\n@@ -612,8 +608,7 @@ static VEC (int, heap) *visstack;\n void\n push_visibility (const char *str, int kind)\n {\n-  VEC_safe_push (int, heap, visstack,\n-\t\t ((int) default_visibility) | (kind << 8));\n+  visstack.safe_push (((int) default_visibility) | (kind << 8));\n   if (!strcmp (str, \"default\"))\n     default_visibility = VISIBILITY_DEFAULT;\n   else if (!strcmp (str, \"internal\"))\n@@ -633,14 +628,14 @@ push_visibility (const char *str, int kind)\n bool\n pop_visibility (int kind)\n {\n-  if (!VEC_length (int, visstack))\n+  if (!visstack.length ())\n     return false;\n-  if ((VEC_last (int, visstack) >> 8) != kind)\n+  if ((visstack.last () >> 8) != kind)\n     return false;\n   default_visibility\n-    = (enum symbol_visibility) (VEC_pop (int, visstack) & 0xff);\n+    = (enum symbol_visibility) (visstack.pop () & 0xff);\n   visibility_options.inpragma\n-    = VEC_length (int, visstack) != 0;\n+    = visstack.length () != 0;\n   return true;\n }\n \n@@ -1152,21 +1147,17 @@ handle_pragma_float_const_decimal64 (cpp_reader *ARG_UNUSED (dummy))\n }\n \n /* A vector of registered pragma callbacks, which is never freed.   */\n-DEF_VEC_O (internal_pragma_handler);\n-DEF_VEC_ALLOC_O (internal_pragma_handler, heap);\n \n-static VEC(internal_pragma_handler, heap) *registered_pragmas;\n+static vec<internal_pragma_handler> registered_pragmas;\n \n typedef struct\n {\n   const char *space;\n   const char *name;\n } pragma_ns_name;\n \n-DEF_VEC_O (pragma_ns_name);\n-DEF_VEC_ALLOC_O (pragma_ns_name, heap);\n \n-static VEC(pragma_ns_name, heap) *registered_pp_pragmas;\n+static vec<pragma_ns_name> registered_pp_pragmas;\n \n struct omp_pragma_def { const char *name; unsigned int id; };\n static const struct omp_pragma_def omp_pragmas[] = {\n@@ -1202,13 +1193,10 @@ c_pp_lookup_pragma (unsigned int id, const char **space, const char **name)\n       }\n \n   if (id >= PRAGMA_FIRST_EXTERNAL\n-      && (id < PRAGMA_FIRST_EXTERNAL\n-\t  + VEC_length (pragma_ns_name, registered_pp_pragmas)))\n+      && (id < PRAGMA_FIRST_EXTERNAL + registered_pp_pragmas.length ()))\n     {\n-      *space = VEC_index (pragma_ns_name, registered_pp_pragmas,\n-\t\t\t  id - PRAGMA_FIRST_EXTERNAL).space;\n-      *name = VEC_index (pragma_ns_name, registered_pp_pragmas,\n-\t\t\t id - PRAGMA_FIRST_EXTERNAL).name;\n+      *space = registered_pp_pragmas[id - PRAGMA_FIRST_EXTERNAL].space;\n+      *name = registered_pp_pragmas[id - PRAGMA_FIRST_EXTERNAL].name;\n       return;\n     }\n \n@@ -1233,15 +1221,14 @@ c_register_pragma_1 (const char *space, const char *name,\n \n       ns_name.space = space;\n       ns_name.name = name;\n-      VEC_safe_push (pragma_ns_name, heap, registered_pp_pragmas, ns_name);\n-      id = VEC_length (pragma_ns_name, registered_pp_pragmas);\n+      registered_pp_pragmas.safe_push (ns_name);\n+      id = registered_pp_pragmas.length ();\n       id += PRAGMA_FIRST_EXTERNAL - 1;\n     }\n   else\n     {\n-      VEC_safe_push (internal_pragma_handler, heap, registered_pragmas,\n-                     ihandler);\n-      id = VEC_length (internal_pragma_handler, registered_pragmas);\n+      registered_pragmas.safe_push (ihandler);\n+      id = registered_pragmas.length ();\n       id += PRAGMA_FIRST_EXTERNAL - 1;\n \n       /* The C++ front end allocates 6 bits in cp_token; the C front end\n@@ -1331,7 +1318,7 @@ c_invoke_pragma_handler (unsigned int id)\n   pragma_handler_2arg handler_2arg;\n \n   id -= PRAGMA_FIRST_EXTERNAL;\n-  ihandler = &VEC_index (internal_pragma_handler, registered_pragmas, id);\n+  ihandler = &registered_pragmas[id];\n   if (ihandler->extra_data)\n     {\n       handler_2arg = ihandler->handler.handler_2arg;"}, {"sha": "c8df1acf29fdec13f52e6c3e4e8db9fe5f01fd99", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1662,15 +1662,15 @@ pp_c_expression_list (c_pretty_printer *pp, tree e)\n /* Print out V, which contains the elements of a constructor.  */\n \n void\n-pp_c_constructor_elts (c_pretty_printer *pp, VEC(constructor_elt,gc) *v)\n+pp_c_constructor_elts (c_pretty_printer *pp, vec<constructor_elt, va_gc> *v)\n {\n   unsigned HOST_WIDE_INT ix;\n   tree value;\n \n   FOR_EACH_CONSTRUCTOR_VALUE (v, ix, value)\n     {\n       pp_expression (pp, value);\n-      if (ix != VEC_length (constructor_elt, v) - 1)\n+      if (ix != vec_safe_length (v) - 1)\n \tpp_separate_with (pp, ',');\n     }\n }"}, {"sha": "801663c3fc5f1c38d5f75c223830df415b9a63a7", "filename": "gcc/c-family/c-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -198,7 +198,7 @@ void pp_c_statement (c_pretty_printer *, tree);\n void pp_c_expression (c_pretty_printer *, tree);\n void pp_c_logical_or_expression (c_pretty_printer *, tree);\n void pp_c_expression_list (c_pretty_printer *, tree);\n-void pp_c_constructor_elts (c_pretty_printer *, VEC(constructor_elt,gc) *);\n+void pp_c_constructor_elts (c_pretty_printer *, vec<constructor_elt, va_gc> *);\n void pp_c_call_argument_list (c_pretty_printer *, tree);\n void pp_c_unary_expression (c_pretty_printer *, tree);\n void pp_c_cast_expression (c_pretty_printer *, tree);"}, {"sha": "dca7ec93add67bf5baed99b481fd903bb6374240", "filename": "gcc/c-family/c-semantics.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc-family%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-semantics.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -37,7 +37,7 @@ push_stmt_list (void)\n {\n   tree t;\n   t = alloc_stmt_list ();\n-  VEC_safe_push (tree, gc, stmt_list_stack, t);\n+  vec_safe_push (stmt_list_stack, t);\n   return t;\n }\n \n@@ -52,10 +52,10 @@ pop_stmt_list (tree t)\n      nestings will be due to outstanding cleanups.  */\n   while (1)\n     {\n-      u = VEC_pop (tree, stmt_list_stack);\n-      if (!VEC_empty (tree, stmt_list_stack))\n+      u = stmt_list_stack->pop ();\n+      if (!stmt_list_stack->is_empty ())\n \t{\n-\t  tree x = VEC_last (tree, stmt_list_stack);\n+\t  tree x = stmt_list_stack->last ();\n \t  STATEMENT_LIST_HAS_LABEL (x) |= STATEMENT_LIST_HAS_LABEL (u);\n \t}\n       if (t == u)"}, {"sha": "e6ef408a6973366157fab86574d068f5ccc35025", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1,3 +1,19 @@\n+2012-11-16  Diego Novillo  <dnovillo@google.com>\n+\n+\tAdjust for new vec API (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n+\n+\t* c-common.c: Use new vec API in vec.h.\n+\t* c-common.h: Likewise.\n+\t* c-gimplify.c: Likewise.\n+\t* c-pragma.c: Likewise.\n+\t* c-pretty-print.c: Likewise.\n+\t* c-pretty-print.h: Likewise.\n+\t* c-semantics.c: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* c-parser.c: Likewise.\n+\t* c-tree.h: Likewise.\n+\t* c-typeck.c: Likewise.\n+\n 2012-10-29  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR c++/54930"}, {"sha": "b1c88bdd96ed084f29b179200420878c9af2e8ca", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 45, "deletions": 53, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -286,8 +286,6 @@ struct GTY(()) c_goto_bindings {\n };\n \n typedef struct c_goto_bindings *c_goto_bindings_p;\n-DEF_VEC_P(c_goto_bindings_p);\n-DEF_VEC_ALLOC_P(c_goto_bindings_p,gc);\n \n /* The additional information we keep track of for a label binding.\n    These fields are updated as scopes are popped.  */\n@@ -302,11 +300,11 @@ struct GTY(()) c_label_vars {\n      warn if a goto branches to this label from later in the function.\n      Decls are added to this list as scopes are popped.  We only add\n      the decls that matter.  */\n-  VEC(tree,gc) *decls_in_scope;\n+  vec<tree, va_gc> *decls_in_scope;\n   /* A list of goto statements to this label.  This is only used for\n      goto statements seen before the label was defined, so that we can\n      issue appropriate warnings for them.  */\n-  VEC(c_goto_bindings_p,gc) *gotos;\n+  vec<c_goto_bindings_p, va_gc> *gotos;\n };\n \n /* Each c_scope structure describes the complete contents of one\n@@ -496,11 +494,9 @@ static bool keep_next_level_flag;\n \n static bool next_is_function_body;\n \n-/* A VEC of pointers to c_binding structures.  */\n+/* A vector of pointers to c_binding structures.  */\n \n typedef struct c_binding *c_binding_ptr;\n-DEF_VEC_P(c_binding_ptr);\n-DEF_VEC_ALLOC_P(c_binding_ptr,heap);\n \n /* Information that we keep for a struct or union while it is being\n    parsed.  */\n@@ -509,15 +505,15 @@ struct c_struct_parse_info\n {\n   /* If warn_cxx_compat, a list of types defined within this\n      struct.  */\n-  VEC(tree,heap) *struct_types;\n+  vec<tree> struct_types;\n   /* If warn_cxx_compat, a list of field names which have bindings,\n      and which are defined in this struct, but which are not defined\n      in any enclosing struct.  This is used to clear the in_struct\n      field of the c_bindings structure.  */\n-  VEC(c_binding_ptr,heap) *fields;\n+  vec<c_binding_ptr> fields;\n   /* If warn_cxx_compat, a list of typedef names used when defining\n      fields in this struct.  */\n-  VEC(tree,heap) *typedefs_seen;\n+  vec<tree> typedefs_seen;\n };\n \n /* Information for the struct or union currently being parsed, or\n@@ -1019,16 +1015,14 @@ update_label_decls (struct c_scope *scope)\n \t\t\t     of B1, if any.  Save it to issue a\n \t\t\t     warning if needed.  */\n \t\t\t  if (decl_jump_unsafe (b1->decl))\n-\t\t\t    VEC_safe_push (tree, gc,\n-\t\t\t\t\t   label_vars->decls_in_scope,\n-\t\t\t\t\t   b1->decl);\n+\t\t\t    vec_safe_push(label_vars->decls_in_scope, b1->decl);\n \t\t\t}\n \t\t    }\n \t\t}\n \n \t      /* Update the bindings of any goto statements associated\n \t\t with this label.  */\n-\t      FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n+\t      FOR_EACH_VEC_SAFE_ELT (label_vars->gotos, ix, g)\n \t\tupdate_spot_bindings (scope, &g->goto_bindings);\n \t    }\n \t}\n@@ -1375,7 +1369,7 @@ c_bindings_start_stmt_expr (struct c_spot_bindings* switch_bindings)\n \t    continue;\n \t  label_vars = b->u.label;\n \t  ++label_vars->label_bindings.stmt_exprs;\n-\t  FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n+\t  FOR_EACH_VEC_SAFE_ELT (label_vars->gotos, ix, g)\n \t    ++g->goto_bindings.stmt_exprs;\n \t}\n     }\n@@ -1413,7 +1407,7 @@ c_bindings_end_stmt_expr (struct c_spot_bindings *switch_bindings)\n \t      label_vars->label_bindings.left_stmt_expr = true;\n \t      label_vars->label_bindings.stmt_exprs = 0;\n \t    }\n-\t  FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n+\t  FOR_EACH_VEC_SAFE_ELT (label_vars->gotos, ix, g)\n \t    {\n \t      --g->goto_bindings.stmt_exprs;\n \t      if (g->goto_bindings.stmt_exprs < 0)\n@@ -3056,7 +3050,7 @@ make_label (location_t location, tree name, bool defining,\n   label_vars->shadowed = NULL;\n   set_spot_bindings (&label_vars->label_bindings, defining);\n   label_vars->decls_in_scope = make_tree_vector ();\n-  label_vars->gotos = VEC_alloc (c_goto_bindings_p, gc, 0);\n+  label_vars->gotos = NULL;\n   *p_label_vars = label_vars;\n \n   return label;\n@@ -3153,7 +3147,7 @@ lookup_label_for_goto (location_t loc, tree name)\n       g = ggc_alloc_c_goto_bindings ();\n       g->loc = loc;\n       set_spot_bindings (&g->goto_bindings, true);\n-      VEC_safe_push (c_goto_bindings_p, gc, label_vars->gotos, g);\n+      vec_safe_push (label_vars->gotos, g);\n       return label;\n     }\n \n@@ -3165,7 +3159,7 @@ lookup_label_for_goto (location_t loc, tree name)\n        ...\n        goto lab;\n      Issue a warning or error.  */\n-  FOR_EACH_VEC_ELT (tree, label_vars->decls_in_scope, ix, decl)\n+  FOR_EACH_VEC_SAFE_ELT (label_vars->decls_in_scope, ix, decl)\n     warn_about_goto (loc, label, decl);\n \n   if (label_vars->label_bindings.left_stmt_expr)\n@@ -3217,7 +3211,7 @@ check_earlier_gotos (tree label, struct c_label_vars* label_vars)\n   unsigned int ix;\n   struct c_goto_bindings *g;\n \n-  FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n+  FOR_EACH_VEC_SAFE_ELT (label_vars->gotos, ix, g)\n     {\n       struct c_binding *b;\n       struct c_scope *scope;\n@@ -3267,7 +3261,7 @@ check_earlier_gotos (tree label, struct c_label_vars* label_vars)\n \n   /* Now that the label is defined, we will issue warnings about\n      subsequent gotos to this label when we see them.  */\n-  VEC_truncate (c_goto_bindings_p, label_vars->gotos, 0);\n+  vec_safe_truncate (label_vars->gotos, 0);\n   label_vars->gotos = NULL;\n }\n \n@@ -3939,10 +3933,10 @@ add_flexible_array_elts_to_size (tree decl, tree init)\n {\n   tree elt, type;\n \n-  if (VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (init)))\n+  if (vec_safe_is_empty (CONSTRUCTOR_ELTS (init)))\n     return;\n \n-  elt = VEC_last (constructor_elt, CONSTRUCTOR_ELTS (init)).value;\n+  elt = CONSTRUCTOR_ELTS (init)->last ().value;\n   type = TREE_TYPE (elt);\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_SIZE (type) == NULL_TREE\n@@ -4509,15 +4503,15 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t  tree cleanup_id = TREE_VALUE (TREE_VALUE (attr));\n \t  tree cleanup_decl = lookup_name (cleanup_id);\n \t  tree cleanup;\n-\t  VEC(tree,gc) *vec;\n+\t  vec<tree, va_gc> *v;\n \n \t  /* Build \"cleanup(&decl)\" for the destructor.  */\n \t  cleanup = build_unary_op (input_location, ADDR_EXPR, decl, 0);\n-\t  vec = VEC_alloc (tree, gc, 1);\n-\t  VEC_quick_push (tree, vec, cleanup);\n+\t  vec_alloc (v, 1);\n+\t  v->quick_push (cleanup);\n \t  cleanup = build_function_call_vec (DECL_SOURCE_LOCATION (decl),\n-\t      \t\t\t\t     cleanup_decl, vec, NULL);\n-\t  VEC_free (tree, gc, vec);\n+\t      \t\t\t\t     cleanup_decl, v, NULL);\n+\t  vec_free (v);\n \n \t  /* Don't warn about decl unused; the cleanup uses it.  */\n \t  TREE_USED (decl) = 1;\n@@ -5656,7 +5650,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t      c_arg_tag *tag;\n \t      unsigned ix;\n \n-\t      FOR_EACH_VEC_ELT_REVERSE (c_arg_tag, arg_info->tags, ix, tag)\n+\t      FOR_EACH_VEC_SAFE_ELT_REVERSE (arg_info->tags, ix, tag)\n \t\tTYPE_CONTEXT (tag->type) = type;\n \t    }\n \t    break;\n@@ -6398,7 +6392,7 @@ get_parm_info (bool ellipsis, tree expr)\n   struct c_arg_info *arg_info = build_arg_info ();\n \n   tree parms    = 0;\n-  VEC(c_arg_tag,gc) *tags = NULL;\n+  vec<c_arg_tag, va_gc> *tags = NULL;\n   tree types    = 0;\n   tree others   = 0;\n \n@@ -6523,7 +6517,7 @@ get_parm_info (bool ellipsis, tree expr)\n \n \t  tag.id = b->id;\n \t  tag.type = decl;\n-\t  VEC_safe_push (c_arg_tag, gc, tags, tag);\n+\t  vec_safe_push (tags, tag);\n \t  break;\n \n \tcase CONST_DECL:\n@@ -6735,9 +6729,9 @@ start_struct (location_t loc, enum tree_code code, tree name,\n \n   *enclosing_struct_parse_info = struct_parse_info;\n   struct_parse_info = XNEW (struct c_struct_parse_info);\n-  struct_parse_info->struct_types = VEC_alloc (tree, heap, 0);\n-  struct_parse_info->fields = VEC_alloc (c_binding_ptr, heap, 0);\n-  struct_parse_info->typedefs_seen = VEC_alloc (tree, heap, 0);\n+  struct_parse_info->struct_types.create (0);\n+  struct_parse_info->fields.create (0);\n+  struct_parse_info->typedefs_seen.create (0);\n \n   /* FIXME: This will issue a warning for a use of a type defined\n      within a statement expr used within sizeof, et. al.  This is not\n@@ -6847,8 +6841,7 @@ grokfield (location_t loc,\n \t     to be cleared when this struct is finished.  */\n \t  if (!b->in_struct)\n \t    {\n-\t      VEC_safe_push (c_binding_ptr, heap,\n-\t\t\t     struct_parse_info->fields, b);\n+\t      struct_parse_info->fields.safe_push (b);\n \t      b->in_struct = 1;\n \t    }\n \t}\n@@ -7028,7 +7021,7 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n      because the flag is used to issue visibility warnings, and we\n      only want to issue those warnings if the type is referenced\n      outside of the struct declaration.  */\n-  FOR_EACH_VEC_ELT (tree, struct_parse_info->struct_types, ix, x)\n+  FOR_EACH_VEC_ELT (struct_parse_info->struct_types, ix, x)\n     C_TYPE_DEFINED_IN_STRUCT (x) = 1;\n \n   /* The TYPEDEFS_SEEN field of STRUCT_PARSE_INFO is a list of\n@@ -7037,14 +7030,14 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n      not parse in C++, because the C++ lookup rules say that the\n      typedef name would be looked up in the context of the struct, and\n      would thus be the field rather than the typedef.  */\n-  if (!VEC_empty (tree, struct_parse_info->typedefs_seen)\n+  if (!struct_parse_info->typedefs_seen.is_empty ()\n       && fieldlist != NULL_TREE)\n     {\n       /* Use a pointer_set using the name of the typedef.  We can use\n \t a pointer_set because identifiers are interned.  */\n       struct pointer_set_t *tset = pointer_set_create ();\n \n-      FOR_EACH_VEC_ELT (tree, struct_parse_info->typedefs_seen, ix, x)\n+      FOR_EACH_VEC_ELT (struct_parse_info->typedefs_seen, ix, x)\n \tpointer_set_insert (tset, DECL_NAME (x));\n \n       for (x = fieldlist; x != NULL_TREE; x = DECL_CHAIN (x))\n@@ -7066,7 +7059,7 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n \n   /* For each field which has a binding and which was not defined in\n      an enclosing struct, clear the in_struct field.  */\n-  FOR_EACH_VEC_ELT (c_binding_ptr, struct_parse_info->fields, ix, b)\n+  FOR_EACH_VEC_ELT (struct_parse_info->fields, ix, b)\n     b->in_struct = 0;\n }\n \n@@ -7353,9 +7346,9 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   if (warn_cxx_compat)\n     warn_cxx_compat_finish_struct (fieldlist);\n \n-  VEC_free (tree, heap, struct_parse_info->struct_types);\n-  VEC_free (c_binding_ptr, heap, struct_parse_info->fields);\n-  VEC_free (tree, heap, struct_parse_info->typedefs_seen);\n+  struct_parse_info->struct_types.release ();\n+  struct_parse_info->fields.release ();\n+  struct_parse_info->typedefs_seen.release ();\n   XDELETE (struct_parse_info);\n \n   struct_parse_info = enclosing_struct_parse_info;\n@@ -7365,7 +7358,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   if (warn_cxx_compat\n       && struct_parse_info != NULL\n       && !in_sizeof && !in_typeof && !in_alignof)\n-    VEC_safe_push (tree, heap, struct_parse_info->struct_types, t);\n+    struct_parse_info->struct_types.safe_push (t);\n \n   return t;\n }\n@@ -7583,7 +7576,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   if (warn_cxx_compat\n       && struct_parse_info != NULL\n       && !in_sizeof && !in_typeof && !in_alignof)\n-    VEC_safe_push (tree, heap, struct_parse_info->struct_types, enumtype);\n+    struct_parse_info->struct_types.safe_push (enumtype);\n \n   return enumtype;\n }\n@@ -7981,7 +7974,7 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n     }\n \n   /* And all the tag declarations.  */\n-  FOR_EACH_VEC_ELT_REVERSE (c_arg_tag, arg_info->tags, ix, tag)\n+  FOR_EACH_VEC_SAFE_ELT_REVERSE (arg_info->tags, ix, tag)\n     if (tag->id)\n       bind (tag->id, tag->type, current_scope,\n \t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n@@ -8598,8 +8591,7 @@ c_push_function_context (void)\n     cfun->language = p = ggc_alloc_cleared_language_function ();\n \n   p->base.x_stmt_tree = c_stmt_tree;\n-  c_stmt_tree.x_cur_stmt_list\n-    = VEC_copy (tree, gc, c_stmt_tree.x_cur_stmt_list);\n+  c_stmt_tree.x_cur_stmt_list = vec_safe_copy (c_stmt_tree.x_cur_stmt_list);\n   p->x_break_label = c_break_label;\n   p->x_cont_label = c_cont_label;\n   p->x_switch_stack = c_switch_stack;\n@@ -9538,7 +9530,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t  /* If we are parsing a struct, record that a struct field\n \t     used a typedef.  */\n \t  if (warn_cxx_compat && struct_parse_info != NULL)\n-\t    VEC_safe_push (tree, heap, struct_parse_info->typedefs_seen, type);\n+\t    struct_parse_info->typedefs_seen.safe_push (type);\n \t}\n     }\n   else if (TREE_CODE (type) == IDENTIFIER_NODE)\n@@ -10040,7 +10032,7 @@ collect_all_refs (const char *source_file)\n   tree t;\n   unsigned i;\n \n-  FOR_EACH_VEC_ELT (tree, all_translation_units, i, t)\n+  FOR_EACH_VEC_ELT (*all_translation_units, i, t)\n     collect_ada_nodes (BLOCK_VARS (DECL_INITIAL (t)), source_file);\n \n   collect_ada_nodes (BLOCK_VARS (ext_block), source_file);\n@@ -10056,7 +10048,7 @@ for_each_global_decl (void (*callback) (tree decl))\n   tree decl;\n   unsigned i;\n \n-  FOR_EACH_VEC_ELT (tree, all_translation_units, i, t)\n+  FOR_EACH_VEC_ELT (*all_translation_units, i, t)\n     { \n       decls = DECL_INITIAL (t);\n       for (decl = BLOCK_VARS (decls); decl; decl = TREE_CHAIN (decl))\n@@ -10116,7 +10108,7 @@ c_write_global_declarations (void)\n \n   /* Process all file scopes in this compilation, and the external_scope,\n      through wrapup_global_declarations and check_global_declarations.  */\n-  FOR_EACH_VEC_ELT (tree, all_translation_units, i, t)\n+  FOR_EACH_VEC_ELT (*all_translation_units, i, t)\n     c_write_global_declarations_1 (BLOCK_VARS (DECL_INITIAL (t)));\n   c_write_global_declarations_1 (BLOCK_VARS (ext_block));\n \n@@ -10135,7 +10127,7 @@ c_write_global_declarations (void)\n   if (!seen_error ())\n     {\n       timevar_push (TV_SYMOUT);\n-      FOR_EACH_VEC_ELT (tree, all_translation_units, i, t)\n+      FOR_EACH_VEC_ELT (*all_translation_units, i, t)\n \tc_write_global_declarations_2 (BLOCK_VARS (DECL_INITIAL (t)));\n       c_write_global_declarations_2 (BLOCK_VARS (ext_block));\n       timevar_pop (TV_SYMOUT);"}, {"sha": "d85bff0a2d982081773fa27ae194e7219c6aef9d", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1178,9 +1178,9 @@ static struct c_expr c_parser_transaction_expression (c_parser *, enum rid);\n static tree c_parser_transaction_cancel (c_parser *);\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n-static VEC(tree,gc) *c_parser_expr_list (c_parser *, bool, bool,\n-\t\t\t\t\t VEC(tree,gc) **, location_t *,\n-\t\t\t\t\t tree *);\n+static vec<tree, va_gc> *c_parser_expr_list (c_parser *, bool, bool,\n+\t\t\t\t\t     vec<tree, va_gc> **, location_t *,\n+\t\t\t\t\t     tree *);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n@@ -3540,7 +3540,7 @@ c_parser_attributes (c_parser *parser)\n \t     || c_parser_next_token_is (parser, CPP_KEYWORD))\n \t{\n \t  tree attr, attr_name, attr_args;\n-\t  VEC(tree,gc) *expr_list;\n+\t  vec<tree, va_gc> *expr_list;\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n \t      c_parser_consume_token (parser);\n@@ -6123,10 +6123,10 @@ c_parser_alignof_expression (c_parser *parser)\n    stores the arguments in CEXPR_LIST.  */\n static bool\n c_parser_get_builtin_args (c_parser *parser, const char *bname,\n-\t\t\t   VEC(c_expr_t,gc) **ret_cexpr_list)\n+\t\t\t   vec<c_expr_t, va_gc> **ret_cexpr_list)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n-  VEC (c_expr_t,gc) *cexpr_list;\n+  vec<c_expr_t, va_gc> *cexpr_list;\n   c_expr_t expr;\n \n   *ret_cexpr_list = NULL;\n@@ -6145,7 +6145,7 @@ c_parser_get_builtin_args (c_parser *parser, const char *bname,\n     }\n \n   expr = c_parser_expr_no_commas (parser, NULL);\n-  cexpr_list = VEC_alloc (c_expr_t, gc, 1);\n+  vec_alloc (cexpr_list, 1);\n   C_EXPR_APPEND (cexpr_list, expr);\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n@@ -6511,7 +6511,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  break;\n \tcase RID_CHOOSE_EXPR:\n \t  {\n-\t    VEC (c_expr_t, gc) *cexpr_list;\n+\t    vec<c_expr_t, va_gc> *cexpr_list;\n \t    c_expr_t *e1_p, *e2_p, *e3_p;\n \t    tree c;\n \n@@ -6524,17 +6524,17 @@ c_parser_postfix_expression (c_parser *parser)\n \t\tbreak;\n \t      }\n \n-\t    if (VEC_length (c_expr_t, cexpr_list) != 3)\n+\t    if (vec_safe_length (cexpr_list) != 3)\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \"\n \t\t\t       \"%<__builtin_choose_expr%>\");\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n \n-\t    e1_p = &VEC_index (c_expr_t, cexpr_list, 0);\n-\t    e2_p = &VEC_index (c_expr_t, cexpr_list, 1);\n-\t    e3_p = &VEC_index (c_expr_t, cexpr_list, 2);\n+\t    e1_p = &(*cexpr_list)[0];\n+\t    e2_p = &(*cexpr_list)[1];\n+\t    e3_p = &(*cexpr_list)[2];\n \n \t    c = e1_p->value;\n \t    mark_exp_read (e2_p->value);\n@@ -6594,7 +6594,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  break;\n \tcase RID_BUILTIN_COMPLEX:\n \t  {\n-\t    VEC(c_expr_t, gc) *cexpr_list;\n+\t    vec<c_expr_t, va_gc> *cexpr_list;\n \t    c_expr_t *e1_p, *e2_p;\n \n \t    c_parser_consume_token (parser);\n@@ -6606,16 +6606,16 @@ c_parser_postfix_expression (c_parser *parser)\n \t\tbreak;\n \t      }\n \n-\t    if (VEC_length (c_expr_t, cexpr_list) != 2)\n+\t    if (vec_safe_length (cexpr_list) != 2)\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \"\n \t\t\t       \"%<__builtin_complex%>\");\n \t\texpr.value = error_mark_node;\n \t\tbreak;\n \t      }\n \n-\t    e1_p = &VEC_index (c_expr_t, cexpr_list, 0);\n-\t    e2_p = &VEC_index (c_expr_t, cexpr_list, 1);\n+\t    e1_p = &(*cexpr_list)[0];\n+\t    e2_p = &(*cexpr_list)[1];\n \n \t    mark_exp_read (e1_p->value);\n \t    if (TREE_CODE (e1_p->value) == EXCESS_PRECISION_EXPR)\n@@ -6655,7 +6655,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  }\n \tcase RID_BUILTIN_SHUFFLE:\n \t  {\n-\t    VEC(c_expr_t,gc) *cexpr_list;\n+\t    vec<c_expr_t, va_gc> *cexpr_list;\n \t    unsigned int i;\n \t    c_expr_t *p;\n \n@@ -6668,21 +6668,21 @@ c_parser_postfix_expression (c_parser *parser)\n \t\tbreak;\n \t      }\n \n-\t    FOR_EACH_VEC_ELT (c_expr_t, cexpr_list, i, p)\n+\t    FOR_EACH_VEC_SAFE_ELT (cexpr_list, i, p)\n \t      mark_exp_read (p->value);\n \n-\t    if (VEC_length (c_expr_t, cexpr_list) == 2)\n+\t    if (vec_safe_length (cexpr_list) == 2)\n \t      expr.value =\n \t\tc_build_vec_perm_expr\n-\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0).value,\n-\t\t   NULL_TREE, VEC_index (c_expr_t, cexpr_list, 1).value);\n+\t\t  (loc, (*cexpr_list)[0].value,\n+\t\t   NULL_TREE, (*cexpr_list)[1].value);\n \n-\t    else if (VEC_length (c_expr_t, cexpr_list) == 3)\n+\t    else if (vec_safe_length (cexpr_list) == 3)\n \t      expr.value =\n \t\tc_build_vec_perm_expr\n-\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0).value,\n-\t\t   VEC_index (c_expr_t, cexpr_list, 1).value,\n-\t\t   VEC_index (c_expr_t, cexpr_list, 2).value);\n+\t\t  (loc, (*cexpr_list)[0].value,\n+\t\t   (*cexpr_list)[1].value,\n+\t\t   (*cexpr_list)[2].value);\n \t    else\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \"\n@@ -6872,8 +6872,8 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n   location_t sizeof_arg_loc[3];\n   tree sizeof_arg[3];\n   unsigned int i;\n-  VEC(tree,gc) *exprlist;\n-  VEC(tree,gc) *origtypes;\n+  vec<tree, va_gc> *exprlist;\n+  vec<tree, va_gc> *origtypes;\n   while (true)\n     {\n       location_t op_loc = c_parser_peek_token (parser)->location;\n@@ -6922,7 +6922,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      && DECL_FUNCTION_CODE (orig_expr.value) == BUILT_IN_CONSTANT_P)\n \t    expr.original_code = C_MAYBE_CONST_EXPR;\n \t  expr.original_type = NULL;\n-\t  if (exprlist != NULL)\n+\t  if (exprlist)\n \t    {\n \t      release_tree_vector (exprlist);\n \t      release_tree_vector (origtypes);\n@@ -7069,13 +7069,13 @@ c_parser_expression_conv (c_parser *parser)\n      nonempty-expr-list , assignment-expression\n */\n \n-static VEC(tree,gc) *\n+static vec<tree, va_gc> *\n c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n-\t\t    VEC(tree,gc) **p_orig_types, location_t *sizeof_arg_loc,\n-\t\t    tree *sizeof_arg)\n+\t\t    vec<tree, va_gc> **p_orig_types,\n+\t\t    location_t *sizeof_arg_loc, tree *sizeof_arg)\n {\n-  VEC(tree,gc) *ret;\n-  VEC(tree,gc) *orig_types;\n+  vec<tree, va_gc> *ret;\n+  vec<tree, va_gc> *orig_types;\n   struct c_expr expr;\n   location_t loc = c_parser_peek_token (parser)->location;\n   location_t cur_sizeof_arg_loc = UNKNOWN_LOCATION;\n@@ -7095,9 +7095,9 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n     expr = default_function_array_read_conversion (loc, expr);\n   if (fold_p)\n     expr.value = c_fully_fold (expr.value, false, NULL);\n-  VEC_quick_push (tree, ret, expr.value);\n-  if (orig_types != NULL)\n-    VEC_quick_push (tree, orig_types, expr.original_type);\n+  ret->quick_push (expr.value);\n+  if (orig_types)\n+    orig_types->quick_push (expr.original_type);\n   if (sizeof_arg != NULL\n       && cur_sizeof_arg_loc != UNKNOWN_LOCATION\n       && expr.original_code == SIZEOF_EXPR)\n@@ -7119,9 +7119,9 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \texpr = default_function_array_read_conversion (loc, expr);\n       if (fold_p)\n \texpr.value = c_fully_fold (expr.value, false, NULL);\n-      VEC_safe_push (tree, gc, ret, expr.value);\n-      if (orig_types != NULL)\n-\tVEC_safe_push (tree, gc, orig_types, expr.original_type);\n+      vec_safe_push (ret, expr.value);\n+      if (orig_types)\n+\tvec_safe_push (orig_types, expr.original_type);\n       if (++idx < 3\n \t  && sizeof_arg != NULL\n \t  && cur_sizeof_arg_loc != UNKNOWN_LOCATION\n@@ -7131,7 +7131,7 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \t  sizeof_arg_loc[idx] = cur_sizeof_arg_loc;\n \t}\n     }\n-  if (orig_types != NULL)\n+  if (orig_types)\n     *p_orig_types = orig_types;\n   return ret;\n }\n@@ -8209,13 +8209,13 @@ static tree\n c_parser_objc_keywordexpr (c_parser *parser)\n {\n   tree ret;\n-  VEC(tree,gc) *expr_list = c_parser_expr_list (parser, true, true,\n+  vec<tree, va_gc> *expr_list = c_parser_expr_list (parser, true, true,\n \t\t\t\t\t\tNULL, NULL, NULL);\n-  if (VEC_length (tree, expr_list) == 1)\n+  if (vec_safe_length (expr_list) == 1)\n     {\n       /* Just return the expression, remove a level of\n \t indirection.  */\n-      ret = VEC_index (tree, expr_list, 0);\n+      ret = (*expr_list)[0];\n     }\n   else\n     {\n@@ -9923,7 +9923,7 @@ c_parser_omp_for_loop (location_t loc,\n   bool fail = false, open_brace_parsed = false;\n   int i, collapse = 1, nbraces = 0;\n   location_t for_loc;\n-  VEC(tree,gc) *for_block = make_tree_vector ();\n+  vec<tree, va_gc> *for_block = make_tree_vector ();\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n@@ -9955,7 +9955,7 @@ c_parser_omp_for_loop (location_t loc,\n       if (c_parser_next_tokens_start_declaration (parser))\n \t{\n \t  if (i > 0)\n-\t    VEC_safe_push (tree, gc, for_block, c_begin_compound_stmt (true));\n+\t    vec_safe_push (for_block, c_begin_compound_stmt (true));\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true, true, NULL);\n \t  decl = check_for_loop_decls (for_loc, flag_isoc99);\n \t  if (decl == NULL)\n@@ -10186,12 +10186,12 @@ c_parser_omp_for_loop (location_t loc,\n       ret = stmt;\n     }\n pop_scopes:\n-  while (!VEC_empty (tree, for_block))\n+  while (!for_block->is_empty ())\n     {\n       /* FIXME diagnostics: LOC below should be the actual location of\n \t this particular for block.  We need to build a list of\n \t locations to go along with FOR_BLOCK.  */\n-      stmt = c_end_compound_stmt (loc, VEC_pop (tree, for_block), true);\n+      stmt = c_end_compound_stmt (loc, for_block->pop (), true);\n       add_stmt (stmt);\n     }\n   release_tree_vector (for_block);"}, {"sha": "531cc7c6d4509588af327588ed7b91b091e9bfdb", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -135,15 +135,12 @@ struct c_expr\n typedef struct c_expr c_expr_t;\n \n /* A varray of c_expr_t.  */\n-DEF_VEC_O (c_expr_t);\n-DEF_VEC_ALLOC_O (c_expr_t, gc);\n-DEF_VEC_ALLOC_O (c_expr_t, heap);\n \n /* Append a new c_expr_t element to V.  */\n #define C_EXPR_APPEND(V, ELEM) \\\n   do { \\\n     c_expr_t __elem = (ELEM); \\\n-    VEC_safe_push (c_expr_t, gc, V, __elem); \\\n+    vec_safe_push (V, __elem); \\\n   } while (0)\n \n /* A kind of type specifier.  Note that this information is currently\n@@ -363,15 +360,13 @@ typedef struct c_arg_tag_d {\n   tree type;\n } c_arg_tag;\n \n-DEF_VEC_O(c_arg_tag);\n-DEF_VEC_ALLOC_O(c_arg_tag,gc);\n \n /* Information about the parameters in a function declarator.  */\n struct c_arg_info {\n   /* A list of parameter decls.  */\n   tree parms;\n   /* A list of structure, union and enum tags defined.  */\n-  VEC(c_arg_tag,gc) *tags;\n+  vec<c_arg_tag, va_gc> *tags;\n   /* A list of argument types to go in the FUNCTION_TYPE.  */\n   tree types;\n   /* A list of non-parameter decls (notably enumeration constants)"}, {"sha": "2032f66f3631d6fed3197362449f601441b6852d", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -80,8 +80,8 @@ static int function_types_compatible_p (const_tree, const_tree, bool *,\n \t\t\t\t\tbool *);\n static int type_lists_compatible_p (const_tree, const_tree, bool *, bool *);\n static tree lookup_field (tree, tree);\n-static int convert_arguments (tree, VEC(tree,gc) *, VEC(tree,gc) *, tree,\n-\t\t\t      tree);\n+static int convert_arguments (tree, vec<tree, va_gc> *, vec<tree, va_gc> *,\n+\t\t\t      tree, tree);\n static tree pointer_diff (location_t, tree, tree);\n static tree convert_for_assignment (location_t, tree, tree, tree,\n \t\t\t\t    enum impl_conv, bool, tree, tree, int);\n@@ -2662,14 +2662,14 @@ c_expr_sizeof_type (location_t loc, struct c_type_name *t)\n tree\n build_function_call (location_t loc, tree function, tree params)\n {\n-  VEC(tree,gc) *vec;\n+  vec<tree, va_gc> *v;\n   tree ret;\n \n-  vec = VEC_alloc (tree, gc, list_length (params));\n+  vec_alloc (v, list_length (params));\n   for (; params; params = TREE_CHAIN (params))\n-    VEC_quick_push (tree, vec, TREE_VALUE (params));\n-  ret = build_function_call_vec (loc, function, vec, NULL);\n-  VEC_free (tree, gc, vec);\n+    v->quick_push (TREE_VALUE (params));\n+  ret = build_function_call_vec (loc, function, v, NULL);\n+  vec_free (v);\n   return ret;\n }\n \n@@ -2690,8 +2690,9 @@ static void inform_declaration (tree decl)\n    PARAMS.  */\n \n tree\n-build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n-\t\t\t VEC(tree,gc) *origtypes)\n+build_function_call_vec (location_t loc, tree function,\n+\t\t\t vec<tree, va_gc> *params,\n+\t\t\t vec<tree, va_gc> *origtypes)\n {\n   tree fntype, fundecl = 0;\n   tree name = NULL_TREE, result;\n@@ -2729,9 +2730,8 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n-  if (!VEC_empty (tree, params))\n-    function = objc_rewrite_function_call (function,\n-\t\t\t\t\t   VEC_index (tree, params, 0));\n+  if (params && !params->is_empty ())\n+    function = objc_rewrite_function_call (function, (*params)[0]);\n \n   function = c_fully_fold (function, false, NULL);\n \n@@ -2800,8 +2800,7 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n       /* Before the abort, allow the function arguments to exit or\n \t call longjmp.  */\n       for (i = 0; i < nargs; i++)\n-\ttrap = build2 (COMPOUND_EXPR, void_type_node,\n-\t\t       VEC_index (tree, params, i), trap);\n+\ttrap = build2 (COMPOUND_EXPR, void_type_node, (*params)[i], trap);\n \n       if (VOID_TYPE_P (return_type))\n \t{\n@@ -2816,7 +2815,8 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n \n \t  if (AGGREGATE_TYPE_P (return_type))\n \t    rhs = build_compound_literal (loc, return_type,\n-\t\t\t\t\t  build_constructor (return_type, 0),\n+\t\t\t\t\t  build_constructor (return_type,\n+\t\t\t\t\t    NULL),\n \t\t\t\t\t  false);\n \t  else\n \t    rhs = build_zero_cst (return_type);\n@@ -2826,7 +2826,7 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n \t}\n     }\n \n-  argarray = VEC_address (tree, params);\n+  argarray = vec_safe_address (params);\n \n   /* Check that arguments to builtin functions match the expectations.  */\n   if (fundecl\n@@ -2886,8 +2886,8 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n    failure.  */\n \n static int\n-convert_arguments (tree typelist, VEC(tree,gc) *values,\n-\t\t   VEC(tree,gc) *origtypes, tree function, tree fundecl)\n+convert_arguments (tree typelist, vec<tree, va_gc> *values,\n+\t\t   vec<tree, va_gc> *origtypes, tree function, tree fundecl)\n {\n   tree typetail, val;\n   unsigned int parmnum;\n@@ -2934,7 +2934,7 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n      converted arguments.  */\n \n   for (typetail = typelist, parmnum = 0;\n-       VEC_iterate (tree, values, parmnum, val);\n+       values && values->iterate (parmnum, &val);\n        ++parmnum)\n     {\n       tree type = typetail ? TREE_VALUE (typetail) : 0;\n@@ -3127,9 +3127,7 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n \t\t sake of better warnings from convert_and_check.  */\n \t      if (excess_precision)\n \t\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n-\t      origtype = (origtypes == NULL\n-\t\t\t  ? NULL_TREE\n-\t\t\t  : VEC_index (tree, origtypes, parmnum));\n+\t      origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n \t      parmval = convert_for_assignment (input_location, type, val,\n \t\t\t\t\t\torigtype, ic_argpass, npc,\n \t\t\t\t\t\tfundecl, function,\n@@ -3173,15 +3171,15 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n \t/* Convert `short' and `char' to full-size `int'.  */\n \tparmval = default_conversion (val);\n \n-      VEC_replace (tree, values, parmnum, parmval);\n+      (*values)[parmnum] = parmval;\n       if (parmval == error_mark_node)\n \terror_args = true;\n \n       if (typetail)\n \ttypetail = TREE_CHAIN (typetail);\n     }\n \n-  gcc_assert (parmnum == VEC_length (tree, values));\n+  gcc_assert (parmnum == vec_safe_length (values));\n \n   if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n     {\n@@ -6341,7 +6339,7 @@ static tree constructor_bit_index;\n /* If we are saving up the elements rather than allocating them,\n    this is the list of elements so far (in reverse order,\n    most recent first).  */\n-static VEC(constructor_elt,gc) *constructor_elements;\n+static vec<constructor_elt, va_gc> *constructor_elements;\n \n /* 1 if constructor should be incrementally stored into a constructor chain,\n    0 if all the elements should be kept in AVL tree.  */\n@@ -6417,7 +6415,7 @@ struct constructor_stack\n   tree unfilled_index;\n   tree unfilled_fields;\n   tree bit_index;\n-  VEC(constructor_elt,gc) *elements;\n+  vec<constructor_elt, va_gc> *elements;\n   struct init_node *pending_elts;\n   int offset;\n   int depth;\n@@ -6462,7 +6460,7 @@ struct initializer_stack\n   tree decl;\n   struct constructor_stack *constructor_stack;\n   struct constructor_range_stack *constructor_range_stack;\n-  VEC(constructor_elt,gc) *elements;\n+  vec<constructor_elt, va_gc> *elements;\n   struct spelling *spelling;\n   struct spelling *spelling_base;\n   int spelling_size;\n@@ -6611,7 +6609,7 @@ really_start_incremental_init (tree type)\n   constructor_simple = 1;\n   constructor_nonconst = 0;\n   constructor_depth = SPELLING_DEPTH ();\n-  constructor_elements = 0;\n+  constructor_elements = NULL;\n   constructor_pending_elts = 0;\n   constructor_type = type;\n   constructor_incremental = 1;\n@@ -6757,7 +6755,7 @@ push_init_level (int implicit, struct obstack * braced_init_obstack)\n   constructor_simple = 1;\n   constructor_nonconst = 0;\n   constructor_depth = SPELLING_DEPTH ();\n-  constructor_elements = 0;\n+  constructor_elements = NULL;\n   constructor_incremental = 1;\n   constructor_designated = 0;\n   constructor_pending_elts = 0;\n@@ -6807,7 +6805,7 @@ push_init_level (int implicit, struct obstack * braced_init_obstack)\n       constructor_simple = TREE_STATIC (value);\n       constructor_nonconst = CONSTRUCTOR_NON_CONST (value);\n       constructor_elements = CONSTRUCTOR_ELTS (value);\n-      if (!VEC_empty (constructor_elt, constructor_elements)\n+      if (!vec_safe_is_empty (constructor_elements)\n \t  && (TREE_CODE (constructor_type) == RECORD_TYPE\n \t      || TREE_CODE (constructor_type) == ARRAY_TYPE))\n \tset_nonincremental_init (braced_init_obstack);\n@@ -6957,9 +6955,8 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n       && constructor_unfilled_fields)\n     {\n \tbool constructor_zeroinit =\n-\t (VEC_length (constructor_elt, constructor_elements) == 1\n-\t  && integer_zerop\n-\t      (VEC_index (constructor_elt, constructor_elements, 0).value));\n+\t (vec_safe_length (constructor_elements) == 1\n+\t  && integer_zerop ((*constructor_elements)[0].value));\n \n \t/* Do not warn for flexible array members or zero-length arrays.  */\n \twhile (constructor_unfilled_fields\n@@ -6997,19 +6994,19 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n     {\n       /* A nonincremental scalar initializer--just return\n \t the element, after verifying there is just one.  */\n-      if (VEC_empty (constructor_elt,constructor_elements))\n+      if (vec_safe_is_empty (constructor_elements))\n \t{\n \t  if (!constructor_erroneous)\n \t    error_init (\"empty scalar initializer\");\n \t  ret.value = error_mark_node;\n \t}\n-      else if (VEC_length (constructor_elt,constructor_elements) != 1)\n+      else if (vec_safe_length (constructor_elements) != 1)\n \t{\n \t  error_init (\"extra elements in scalar initializer\");\n-\t  ret.value = VEC_index (constructor_elt,constructor_elements,0).value;\n+\t  ret.value = (*constructor_elements)[0].value;\n \t}\n       else\n-\tret.value = VEC_index (constructor_elt,constructor_elements,0).value;\n+\tret.value = (*constructor_elements)[0].value;\n     }\n   else\n     {\n@@ -7534,7 +7531,7 @@ set_nonincremental_init (struct obstack * braced_init_obstack)\n       add_pending_init (index, value, NULL_TREE, true,\n \t\t\tbraced_init_obstack);\n     }\n-  constructor_elements = 0;\n+  constructor_elements = NULL;\n   if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n       constructor_unfilled_fields = TYPE_FIELDS (constructor_type);\n@@ -7679,10 +7676,9 @@ find_init_member (tree field, struct obstack * braced_init_obstack)\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE)\n     {\n-      if (!VEC_empty (constructor_elt, constructor_elements)\n-\t  && (VEC_last (constructor_elt, constructor_elements).index\n-\t      == field))\n-\treturn VEC_last (constructor_elt, constructor_elements).value;\n+      if (!vec_safe_is_empty (constructor_elements)\n+\t  && (constructor_elements->last ().index == field))\n+\treturn constructor_elements->last ().value;\n     }\n   return 0;\n }\n@@ -7859,27 +7855,26 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE\n-\t   && !VEC_empty (constructor_elt, constructor_elements))\n+\t   && !vec_safe_is_empty (constructor_elements))\n     {\n       if (!implicit)\n \t{\n-\t  if (TREE_SIDE_EFFECTS (VEC_last (constructor_elt,\n-\t\t\t\t\t   constructor_elements).value))\n+\t  if (TREE_SIDE_EFFECTS (constructor_elements->last ().value))\n \t    warning_init (0,\n \t\t\t  \"initialized field with side-effects overwritten\");\n \t  else if (warn_override_init)\n \t    warning_init (OPT_Woverride_init, \"initialized field overwritten\");\n \t}\n \n       /* We can have just one union field set.  */\n-      constructor_elements = 0;\n+      constructor_elements = NULL;\n     }\n \n   /* Otherwise, output this element either to\n      constructor_elements or to the assembler file.  */\n \n   constructor_elt celt = {field, value};\n-  VEC_safe_push (constructor_elt, gc, constructor_elements, celt);\n+  vec_safe_push (constructor_elements, celt);\n \n   /* Advance the variable that indicates sequential elements output.  */\n   if (TREE_CODE (constructor_type) == ARRAY_TYPE)"}, {"sha": "f4bed747e842463ff5f85feb3737832ce23ea5ab", "filename": "gcc/calls.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1696,7 +1696,7 @@ static struct\n      based on crtl->args.internal_arg_pointer.  The element is NULL_RTX if the\n      pseudo isn't based on it, a CONST_INT offset if the pseudo is based on it\n      with fixed offset, or PC if this is with variable or unknown offset.  */\n-  VEC(rtx, heap) *cache;\n+  vec<rtx> cache;\n } internal_arg_pointer_exp_state;\n \n static rtx internal_arg_pointer_based_exp (rtx, bool);\n@@ -1725,21 +1725,17 @@ internal_arg_pointer_based_exp_scan (void)\n \t  rtx val = NULL_RTX;\n \t  unsigned int idx = REGNO (SET_DEST (set)) - FIRST_PSEUDO_REGISTER;\n \t  /* Punt on pseudos set multiple times.  */\n-\t  if (idx < VEC_length (rtx, internal_arg_pointer_exp_state.cache)\n-\t      && (VEC_index (rtx, internal_arg_pointer_exp_state.cache, idx)\n+\t  if (idx < internal_arg_pointer_exp_state.cache.length ()\n+\t      && (internal_arg_pointer_exp_state.cache[idx]\n \t\t  != NULL_RTX))\n \t    val = pc_rtx;\n \t  else\n \t    val = internal_arg_pointer_based_exp (SET_SRC (set), false);\n \t  if (val != NULL_RTX)\n \t    {\n-\t      if (idx\n-\t\t  >= VEC_length (rtx, internal_arg_pointer_exp_state.cache))\n-\t\tVEC_safe_grow_cleared (rtx, heap,\n-\t\t\t\t       internal_arg_pointer_exp_state.cache,\n-\t\t\t\t       idx + 1);\n-\t      VEC_replace (rtx, internal_arg_pointer_exp_state.cache,\n-\t\t\t   idx, val);\n+\t      if (idx >= internal_arg_pointer_exp_state.cache.length ())\n+\t\tinternal_arg_pointer_exp_state.cache.safe_grow_cleared(idx + 1);\n+\t      internal_arg_pointer_exp_state.cache[idx] = val;\n \t    }\n \t}\n       if (NEXT_INSN (insn) == NULL_RTX)\n@@ -1799,8 +1795,8 @@ internal_arg_pointer_based_exp (rtx rtl, bool toplevel)\n   if (REG_P (rtl))\n     {\n       unsigned int idx = REGNO (rtl) - FIRST_PSEUDO_REGISTER;\n-      if (idx < VEC_length (rtx, internal_arg_pointer_exp_state.cache))\n-\treturn VEC_index (rtx, internal_arg_pointer_exp_state.cache, idx);\n+      if (idx < internal_arg_pointer_exp_state.cache.length ())\n+\treturn internal_arg_pointer_exp_state.cache[idx];\n \n       return NULL_RTX;\n     }\n@@ -3443,7 +3439,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n \t  sbitmap_free (stored_args_map);\n \t  internal_arg_pointer_exp_state.scan_start = NULL_RTX;\n-\t  VEC_free (rtx, heap, internal_arg_pointer_exp_state.cache);\n+\t  internal_arg_pointer_exp_state.cache.release ();\n \t}\n       else\n \t{"}, {"sha": "4ad53502e3774b3ac8011da20c61c7a6a343a0de", "filename": "gcc/cfg.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -107,14 +107,14 @@ clear_edges (void)\n     {\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tfree_edge (e);\n-      VEC_truncate (edge, bb->succs, 0);\n-      VEC_truncate (edge, bb->preds, 0);\n+      vec_safe_truncate (bb->succs, 0);\n+      vec_safe_truncate (bb->preds, 0);\n     }\n \n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     free_edge (e);\n-  VEC_truncate (edge, EXIT_BLOCK_PTR->preds, 0);\n-  VEC_truncate (edge, ENTRY_BLOCK_PTR->succs, 0);\n+  vec_safe_truncate (EXIT_BLOCK_PTR->preds, 0);\n+  vec_safe_truncate (ENTRY_BLOCK_PTR->succs, 0);\n \n   gcc_assert (!n_edges);\n }\n@@ -199,7 +199,7 @@ expunge_block (basic_block b)\n static inline void\n connect_src (edge e)\n {\n-  VEC_safe_push (edge, gc, e->src->succs, e);\n+  vec_safe_push (e->src->succs, e);\n   df_mark_solutions_dirty ();\n }\n \n@@ -209,7 +209,7 @@ static inline void\n connect_dest (edge e)\n {\n   basic_block dest = e->dest;\n-  VEC_safe_push (edge, gc, dest->preds, e);\n+  vec_safe_push (dest->preds, e);\n   e->dest_idx = EDGE_COUNT (dest->preds) - 1;\n   df_mark_solutions_dirty ();\n }\n@@ -227,7 +227,7 @@ disconnect_src (edge e)\n     {\n       if (tmp == e)\n \t{\n-\t  VEC_unordered_remove (edge, src->succs, ei.index);\n+\t  src->succs->unordered_remove (ei.index);\n \t  df_mark_solutions_dirty ();\n \t  return;\n \t}\n@@ -246,7 +246,7 @@ disconnect_dest (edge e)\n   basic_block dest = e->dest;\n   unsigned int dest_idx = e->dest_idx;\n \n-  VEC_unordered_remove (edge, dest->preds, dest_idx);\n+  dest->preds->unordered_remove (dest_idx);\n \n   /* If we removed an edge in the middle of the edge vector, we need\n      to update dest_idx of the edge that moved into the \"hole\".  */"}, {"sha": "89cc6a329d1e10f29d2de35415de258c71978495", "filename": "gcc/cfganal.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -24,7 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"basic-block.h\"\n #include \"vec.h\"\n-#include \"vecprim.h\"\n #include \"bitmap.h\"\n #include \"sbitmap.h\"\n #include \"timevar.h\"\n@@ -1139,27 +1138,27 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n {\n   bitmap_iterator bi;\n   unsigned bb_index, i;\n-  VEC(int,heap) *work_stack;\n+  vec<int> work_stack;\n   bitmap phi_insertion_points;\n \n-  work_stack = VEC_alloc (int, heap, n_basic_blocks);\n+  work_stack.create (n_basic_blocks);\n   phi_insertion_points = BITMAP_ALLOC (NULL);\n \n   /* Seed the work list with all the blocks in DEF_BLOCKS.  We use\n-     VEC_quick_push here for speed.  This is safe because we know that\n+     vec::quick_push here for speed.  This is safe because we know that\n      the number of definition blocks is no greater than the number of\n      basic blocks, which is the initial capacity of WORK_STACK.  */\n   EXECUTE_IF_SET_IN_BITMAP (def_blocks, 0, bb_index, bi)\n-    VEC_quick_push (int, work_stack, bb_index);\n+    work_stack.quick_push (bb_index);\n \n   /* Pop a block off the worklist, add every block that appears in\n      the original block's DF that we have not already processed to\n      the worklist.  Iterate until the worklist is empty.   Blocks\n      which are added to the worklist are potential sites for\n      PHI nodes.  */\n-  while (VEC_length (int, work_stack) > 0)\n+  while (work_stack.length () > 0)\n     {\n-      bb_index = VEC_pop (int, work_stack);\n+      bb_index = work_stack.pop ();\n \n       /* Since the registration of NEW -> OLD name mappings is done\n \t separately from the call to update_ssa, when updating the SSA\n@@ -1174,12 +1173,12 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n \t  /* Use a safe push because if there is a definition of VAR\n \t     in every basic block, then WORK_STACK may eventually have\n \t     more than N_BASIC_BLOCK entries.  */\n-\t  VEC_safe_push (int, heap, work_stack, i);\n+\t  work_stack.safe_push (i);\n \t  bitmap_set_bit (phi_insertion_points, i);\n \t}\n     }\n \n-  VEC_free (int, heap, work_stack);\n+  work_stack.release ();\n \n   return phi_insertion_points;\n }"}, {"sha": "eccbb411f8ff7853c093dee5cebb5b25fac57da2", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -2816,12 +2816,12 @@ delete_unreachable_blocks (void)\n \t\tdelete_basic_block (b);\n \t      else\n \t\t{\n-\t\t  VEC (basic_block, heap) *h\n+\t\t  vec<basic_block> h\n \t\t    = get_all_dominated_blocks (CDI_DOMINATORS, b);\n \n-\t\t  while (VEC_length (basic_block, h))\n+\t\t  while (h.length ())\n \t\t    {\n-\t\t      b = VEC_pop (basic_block, h);\n+\t\t      b = h.pop ();\n \n \t\t      prev_bb = b->prev_bb;\n \n@@ -2830,7 +2830,7 @@ delete_unreachable_blocks (void)\n \t\t      delete_basic_block (b);\n \t\t    }\n \n-\t\t  VEC_free (basic_block, heap, h);\n+\t\t  h.release ();\n \t\t}\n \n \t      changed = true;"}, {"sha": "856baa94d9473a0810d62a0e07b2e652ce66ed02", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -848,18 +848,15 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n   set_rtl (decl, x);\n }\n \n-DEF_VEC_I(HOST_WIDE_INT);\n-DEF_VEC_ALLOC_I(HOST_WIDE_INT,heap);\n-\n struct stack_vars_data\n {\n   /* Vector of offset pairs, always end of some padding followed\n      by start of the padding that needs Address Sanitizer protection.\n      The vector is in reversed, highest offset pairs come first.  */\n-  VEC(HOST_WIDE_INT, heap) *asan_vec;\n+  vec<HOST_WIDE_INT> asan_vec;\n \n   /* Vector of partition representative decls in between the paddings.  */\n-  VEC(tree, heap) *asan_decl_vec;\n+  vec<tree> asan_decl_vec;\n };\n \n /* A subroutine of expand_used_vars.  Give each partition representative\n@@ -953,10 +950,8 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t\t= alloc_stack_frame_space (stack_vars[i].size\n \t\t\t\t\t   + ASAN_RED_ZONE_SIZE,\n \t\t\t\t\t   MAX (alignb, ASAN_RED_ZONE_SIZE));\n-\t      VEC_safe_push (HOST_WIDE_INT, heap, data->asan_vec,\n-\t\t\t     prev_offset);\n-\t      VEC_safe_push (HOST_WIDE_INT, heap, data->asan_vec,\n-\t\t\t     offset + stack_vars[i].size);\n+\t      data->asan_vec.safe_push (prev_offset);\n+\t      data->asan_vec.safe_push (offset + stack_vars[i].size);\n \t      /* Find best representative of the partition.\n \t\t Prefer those with DECL_NAME, even better\n \t\t satisfying asan_protect_stack_decl predicate.  */\n@@ -973,7 +968,7 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t\t  repr_decl = stack_vars[j].decl;\n \t      if (repr_decl == NULL_TREE)\n \t\trepr_decl = stack_vars[i].decl;\n-\t      VEC_safe_push (tree, heap, data->asan_decl_vec, repr_decl);\n+\t      data->asan_decl_vec.safe_push (repr_decl);\n \t    }\n \t  else\n \t    offset = alloc_stack_frame_space (stack_vars[i].size, alignb);\n@@ -1526,7 +1521,7 @@ static rtx\n expand_used_vars (void)\n {\n   tree var, outer_block = DECL_INITIAL (current_function_decl);\n-  VEC(tree,heap) *maybe_local_decls = NULL;\n+  vec<tree> maybe_local_decls = vec<tree>();\n   rtx var_end_seq = NULL_RTX;\n   struct pointer_map_t *ssa_name_decls;\n   unsigned i;\n@@ -1585,7 +1580,7 @@ expand_used_vars (void)\n   /* At this point all variables on the local_decls with TREE_USED\n      set are not associated with any block scope.  Lay them out.  */\n \n-  len = VEC_length (tree, cfun->local_decls);\n+  len = vec_safe_length (cfun->local_decls);\n   FOR_EACH_LOCAL_DECL (cfun, i, var)\n     {\n       bool expand_now = false;\n@@ -1630,7 +1625,7 @@ expand_used_vars (void)\n \t    /* If rtl isn't set yet, which can happen e.g. with\n \t       -fstack-protector, retry before returning from this\n \t       function.  */\n-\t    VEC_safe_push (tree, heap, maybe_local_decls, var);\n+\t    maybe_local_decls.safe_push (var);\n \t}\n     }\n \n@@ -1645,8 +1640,8 @@ expand_used_vars (void)\n      We just want the duplicates, as those are the artificial\n      non-ignored vars that we want to keep until instantiate_decls.\n      Move them down and truncate the array.  */\n-  if (!VEC_empty (tree, cfun->local_decls))\n-    VEC_block_remove (tree, cfun->local_decls, 0, len);\n+  if (!vec_safe_is_empty (cfun->local_decls))\n+    cfun->local_decls->block_remove (0, len);\n \n   /* At this point, all variables within the block tree with TREE_USED\n      set are actually used by the optimized function.  Lay them out.  */\n@@ -1680,8 +1675,8 @@ expand_used_vars (void)\n     {\n       struct stack_vars_data data;\n \n-      data.asan_vec = NULL;\n-      data.asan_decl_vec = NULL;\n+      data.asan_vec = vec<HOST_WIDE_INT>();\n+      data.asan_decl_vec = vec<tree>();\n \n       /* Reorder decls to be protected by iterating over the variables\n \t array multiple times, and allocating out of each phase in turn.  */\n@@ -1703,37 +1698,34 @@ expand_used_vars (void)\n \t   in addition to phase 1 and 2.  */\n \texpand_stack_vars (asan_decl_phase_3, &data);\n \n-      if (!VEC_empty (HOST_WIDE_INT, data.asan_vec))\n+      if (!data.asan_vec.is_empty ())\n \t{\n \t  HOST_WIDE_INT prev_offset = frame_offset;\n \t  HOST_WIDE_INT offset\n \t    = alloc_stack_frame_space (ASAN_RED_ZONE_SIZE,\n \t\t\t\t       ASAN_RED_ZONE_SIZE);\n-\t  VEC_safe_push (HOST_WIDE_INT, heap, data.asan_vec, prev_offset);\n-\t  VEC_safe_push (HOST_WIDE_INT, heap, data.asan_vec, offset);\n+\t  data.asan_vec.safe_push (prev_offset);\n+\t  data.asan_vec.safe_push (offset);\n \n \t  var_end_seq\n \t    = asan_emit_stack_protection (virtual_stack_vars_rtx,\n-\t\t\t\t\t  VEC_address (HOST_WIDE_INT,\n-\t\t\t\t\t\t       data.asan_vec),\n-\t\t\t\t\t  VEC_address (tree,\n-\t\t\t\t\t\t       data.asan_decl_vec),\n-\t\t\t\t\t  VEC_length (HOST_WIDE_INT,\n-\t\t\t\t\t\t      data.asan_vec));\n+\t\t\t\t\t  data.asan_vec.address (),\n+\t\t\t\t\t  data.asan_decl_vec. address(),\n+\t\t\t\t\t  data.asan_vec.length ());\n \t}\n \n       expand_stack_vars (NULL, &data);\n \n-      VEC_free (HOST_WIDE_INT, heap, data.asan_vec);\n-      VEC_free (tree, heap, data.asan_decl_vec);\n+      data.asan_vec.release ();\n+      data.asan_decl_vec.release ();\n     }\n \n   fini_vars_expansion ();\n \n   /* If there were any artificial non-ignored vars without rtl\n      found earlier, see if deferred stack allocation hasn't assigned\n      rtl to them.  */\n-  FOR_EACH_VEC_ELT_REVERSE (tree, maybe_local_decls, i, var)\n+  FOR_EACH_VEC_ELT_REVERSE (maybe_local_decls, i, var)\n     {\n       rtx rtl = DECL_RTL_IF_SET (var);\n \n@@ -1742,7 +1734,7 @@ expand_used_vars (void)\n       if (rtl && (MEM_P (rtl) || GET_CODE (rtl) == CONCAT))\n \tadd_local_decl (cfun, var);\n     }\n-  VEC_free (tree, heap, maybe_local_decls);\n+  maybe_local_decls.release ();\n \n   /* If the target requires that FRAME_OFFSET be aligned, do it.  */\n   if (STACK_ALIGNMENT_NEEDED)\n@@ -2104,12 +2096,12 @@ expand_call_stmt (gimple stmt)\n   /* Ensure RTL is created for debug args.  */\n   if (decl && DECL_HAS_DEBUG_ARGS_P (decl))\n     {\n-      VEC(tree, gc) **debug_args = decl_debug_args_lookup (decl);\n+      vec<tree, va_gc> **debug_args = decl_debug_args_lookup (decl);\n       unsigned int ix;\n       tree dtemp;\n \n       if (debug_args)\n-\tfor (ix = 1; VEC_iterate (tree, *debug_args, ix, dtemp); ix += 2)\n+\tfor (ix = 1; (*debug_args)->iterate (ix, &dtemp); ix += 2)\n \t  {\n \t    gcc_assert (TREE_CODE (dtemp) == DEBUG_EXPR_DECL);\n \t    expand_debug_expr (dtemp);\n@@ -3657,13 +3649,13 @@ expand_debug_source_expr (tree exp)\n \t    if (DECL_CONTEXT (aexp)\n \t\t== DECL_ABSTRACT_ORIGIN (current_function_decl))\n \t      {\n-\t\tVEC(tree, gc) **debug_args;\n+\t\tvec<tree, va_gc> **debug_args;\n \t\tunsigned int ix;\n \t\ttree ddecl;\n \t\tdebug_args = decl_debug_args_lookup (current_function_decl);\n \t\tif (debug_args != NULL)\n \t\t  {\n-\t\t    for (ix = 0; VEC_iterate (tree, *debug_args, ix, ddecl);\n+\t\t    for (ix = 0; vec_safe_iterate (*debug_args, ix, &ddecl);\n \t\t\t ix += 2)\n \t\t      if (ddecl == aexp)\n \t\t\treturn gen_rtx_DEBUG_PARAMETER_REF (mode, aexp);"}, {"sha": "dfeff08312304cae7fe3d2ecf59976ae474a7a50", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -814,11 +814,12 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \n   if (dom_info_available_p (CDI_DOMINATORS))\n     {\n-      VEC (basic_block, heap) *doms_to_fix = VEC_alloc (basic_block, heap, 2);\n-      VEC_quick_push (basic_block, doms_to_fix, dummy);\n-      VEC_quick_push (basic_block, doms_to_fix, bb);\n+      vec<basic_block> doms_to_fix;\n+      doms_to_fix.create (2);\n+      doms_to_fix.quick_push (dummy);\n+      doms_to_fix.quick_push (bb);\n       iterate_fix_dominators (CDI_DOMINATORS, doms_to_fix, false);\n-      VEC_free (basic_block, heap, doms_to_fix);\n+      doms_to_fix.release ();\n     }\n \n   if (current_loops != NULL)\n@@ -1144,7 +1145,7 @@ bool\n cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t\t\t\t\tunsigned int ndupl,\n \t\t\t\t\tsbitmap wont_exit, edge orig,\n-\t\t\t\t\tVEC (edge, heap) **to_remove,\n+\t\t\t\t\tvec<edge> *to_remove,\n \t\t\t\t\tint flags)\n {\n   gcc_assert (cfg_hooks->cfg_hook_duplicate_loop_to_header_edge);"}, {"sha": "cb81f5a0e2e912fd16176e5294cc81c9e6ca292d", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -119,7 +119,7 @@ struct cfg_hooks\n      in loop versioning.  */\n   bool (*cfg_hook_duplicate_loop_to_header_edge) (struct loop *, edge,\n \t\t\t\t\t\t  unsigned, sbitmap,\n-\t\t\t\t\t\t  edge, VEC (edge, heap) **,\n+\t\t\t\t\t\t  edge, vec<edge> *,\n \t\t\t\t\t\t  int);\n \n   /* Add condition to new basic block and update CFG used in loop\n@@ -186,7 +186,7 @@ extern bool cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge,\n \t\t\t\t\t\t    unsigned int ndupl,\n \t\t\t\t\t\t    sbitmap wont_exit,\n \t\t\t\t\t\t    edge orig,\n-\t\t\t\t\t\t    VEC (edge, heap) **to_remove,\n+\t\t\t\t\t\t    vec<edge> *to_remove,\n \t\t\t\t\t\t    int flags);\n \n extern void lv_flush_pending_stmts (edge);"}, {"sha": "8c5b45ad2aed9b7c2b979c56a388968aac7e0bf8", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -66,7 +66,7 @@ flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n   unsigned odepth = loop_depth (outer);\n \n   return (loop_depth (loop) > odepth\n-\t  && VEC_index (loop_p, loop->superloops, odepth) == outer);\n+\t  && (*loop->superloops)[odepth] == outer);\n }\n \n /* Returns the loop such that LOOP is nested DEPTH (indexed from zero)\n@@ -82,22 +82,22 @@ superloop_at_depth (struct loop *loop, unsigned depth)\n   if (depth == ldepth)\n     return loop;\n \n-  return VEC_index (loop_p, loop->superloops, depth);\n+  return (*loop->superloops)[depth];\n }\n \n /* Returns the list of the latch edges of LOOP.  */\n \n-static VEC (edge, heap) *\n+static vec<edge> \n get_loop_latch_edges (const struct loop *loop)\n {\n   edge_iterator ei;\n   edge e;\n-  VEC (edge, heap) *ret = NULL;\n+  vec<edge> ret = vec<edge>();\n \n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     {\n       if (dominated_by_p (CDI_DOMINATORS, e->src, loop->header))\n-\tVEC_safe_push (edge, heap, ret, e);\n+\tret.safe_push (e);\n     }\n \n   return ret;\n@@ -113,7 +113,7 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n {\n   basic_block *bbs;\n   unsigned i;\n-  VEC (edge, heap) *latches;\n+  vec<edge> latches;\n   edge e;\n \n   if (! loop || ! loop->header)\n@@ -128,9 +128,9 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n     {\n       fprintf (file, \"multiple latches:\");\n       latches = get_loop_latch_edges (loop);\n-      FOR_EACH_VEC_ELT (edge, latches, i, e)\n+      FOR_EACH_VEC_ELT (latches, i, e)\n \tfprintf (file, \" %d\", e->src->index);\n-      VEC_free (edge, heap, latches);\n+      latches.release ();\n       fprintf (file, \"\\n\");\n     }\n \n@@ -179,7 +179,7 @@ flow_loop_free (struct loop *loop)\n {\n   struct loop_exit *exit, *next;\n \n-  VEC_free (loop_p, gc, loop->superloops);\n+  vec_free (loop->superloops);\n \n   /* Break the list of the loop exit records.  They will be freed when the\n      corresponding edge is rescanned or removed, and this avoids\n@@ -207,15 +207,15 @@ flow_loops_free (struct loops *loops)\n       loop_p loop;\n \n       /* Free the loop descriptors.  */\n-      FOR_EACH_VEC_ELT (loop_p, loops->larray, i, loop)\n+      FOR_EACH_VEC_SAFE_ELT (loops->larray, i, loop)\n \t{\n \t  if (!loop)\n \t    continue;\n \n \t  flow_loop_free (loop);\n \t}\n \n-      VEC_free (loop_p, gc, loops->larray);\n+      vec_free (loops->larray);\n     }\n }\n \n@@ -225,7 +225,7 @@ flow_loops_free (struct loops *loops)\n int\n flow_loop_nodes_find (basic_block header, struct loop *loop)\n {\n-  VEC (basic_block, heap) *stack = NULL;\n+  vec<basic_block> stack = vec<basic_block>();\n   int num_nodes = 1;\n   edge latch;\n   edge_iterator latch_ei;\n@@ -239,16 +239,16 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n \tcontinue;\n \n       num_nodes++;\n-      VEC_safe_push (basic_block, heap, stack, latch->src);\n+      stack.safe_push (latch->src);\n       latch->src->loop_father = loop;\n \n-      while (!VEC_empty (basic_block, stack))\n+      while (!stack.is_empty ())\n \t{\n \t  basic_block node;\n \t  edge e;\n \t  edge_iterator ei;\n \n-\t  node = VEC_pop (basic_block, stack);\n+\t  node = stack.pop ();\n \n \t  FOR_EACH_EDGE (e, ei, node->preds)\n \t    {\n@@ -258,12 +258,12 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n \t\t{\n \t\t  ancestor->loop_father = loop;\n \t\t  num_nodes++;\n-\t\t  VEC_safe_push (basic_block, heap, stack, ancestor);\n+\t\t  stack.safe_push (ancestor);\n \t\t}\n \t    }\n \t}\n     }\n-  VEC_free (basic_block, heap, stack);\n+  stack.release ();\n \n   return num_nodes;\n }\n@@ -278,11 +278,11 @@ establish_preds (struct loop *loop, struct loop *father)\n   unsigned depth = loop_depth (father) + 1;\n   unsigned i;\n \n-  VEC_truncate (loop_p, loop->superloops, 0);\n-  VEC_reserve (loop_p, gc, loop->superloops, depth);\n-  FOR_EACH_VEC_ELT (loop_p, father->superloops, i, ploop)\n-    VEC_quick_push (loop_p, loop->superloops, ploop);\n-  VEC_quick_push (loop_p, loop->superloops, father);\n+  loop->superloops = 0;\n+  vec_alloc (loop->superloops, depth);\n+  FOR_EACH_VEC_SAFE_ELT (father->superloops, i, ploop)\n+    loop->superloops->quick_push (ploop);\n+  loop->superloops->quick_push (father);\n \n   for (ploop = loop->inner; ploop; ploop = ploop->next)\n     establish_preds (ploop, loop);\n@@ -320,7 +320,7 @@ flow_loop_tree_node_remove (struct loop *loop)\n       prev->next = loop->next;\n     }\n \n-  VEC_truncate (loop_p, loop->superloops, 0);\n+  loop->superloops = NULL;\n }\n \n /* Allocates and returns new loop structure.  */\n@@ -346,7 +346,7 @@ init_loops_structure (struct loops *loops, unsigned num_loops)\n   struct loop *root;\n \n   memset (loops, 0, sizeof *loops);\n-  loops->larray = VEC_alloc (loop_p, gc, num_loops);\n+  vec_alloc (loops->larray, num_loops);\n \n   /* Dummy loop containing whole function.  */\n   root = alloc_loop ();\n@@ -356,7 +356,7 @@ init_loops_structure (struct loops *loops, unsigned num_loops)\n   ENTRY_BLOCK_PTR->loop_father = root;\n   EXIT_BLOCK_PTR->loop_father = root;\n \n-  VEC_quick_push (loop_p, loops->larray, root);\n+  loops->larray->quick_push (root);\n   loops->tree_root = root;\n }\n \n@@ -457,7 +457,7 @@ flow_loops_find (struct loops *loops)\n \t  header = BASIC_BLOCK (rc_order[b]);\n \n \t  loop = alloc_loop ();\n-\t  VEC_quick_push (loop_p, loops->larray, loop);\n+\t  loops->larray->quick_push (loop);\n \n \t  loop->header = header;\n \t  loop->num = num_loops;\n@@ -492,7 +492,7 @@ flow_loops_find (struct loops *loops)\n   sbitmap_free (headers);\n \n   loops->exits = NULL;\n-  return VEC_length (loop_p, loops->larray);\n+  return loops->larray->length ();\n }\n \n /* Ratio of frequencies of edges so that one of more latch edges is\n@@ -513,13 +513,13 @@ flow_loops_find (struct loops *loops)\n    derive the loop structure from it).  */\n \n static edge\n-find_subloop_latch_edge_by_profile (VEC (edge, heap) *latches)\n+find_subloop_latch_edge_by_profile (vec<edge> latches)\n {\n   unsigned i;\n   edge e, me = NULL;\n   gcov_type mcount = 0, tcount = 0;\n \n-  FOR_EACH_VEC_ELT (edge, latches, i, e)\n+  FOR_EACH_VEC_ELT (latches, i, e)\n     {\n       if (e->count > mcount)\n \t{\n@@ -553,22 +553,22 @@ find_subloop_latch_edge_by_profile (VEC (edge, heap) *latches)\n    another edge.  */\n \n static edge\n-find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, VEC (edge, heap) *latches)\n+find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, vec<edge> latches)\n {\n-  edge e, latch = VEC_index (edge, latches, 0);\n+  edge e, latch = latches[0];\n   unsigned i;\n   gimple phi;\n   gimple_stmt_iterator psi;\n   tree lop;\n   basic_block bb;\n \n   /* Find the candidate for the latch edge.  */\n-  for (i = 1; VEC_iterate (edge, latches, i, e); i++)\n+  for (i = 1; latches.iterate (i, &e); i++)\n     if (dominated_by_p (CDI_DOMINATORS, latch->src, e->src))\n       latch = e;\n \n   /* Verify that it dominates all the latch edges.  */\n-  FOR_EACH_VEC_ELT (edge, latches, i, e)\n+  FOR_EACH_VEC_ELT (latches, i, e)\n     if (!dominated_by_p (CDI_DOMINATORS, e->src, latch->src))\n       return NULL;\n \n@@ -587,7 +587,7 @@ find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, VEC (edge, h\n       if (!bb || !flow_bb_inside_loop_p (loop, bb))\n \tcontinue;\n \n-      FOR_EACH_VEC_ELT (edge, latches, i, e)\n+      FOR_EACH_VEC_ELT (latches, i, e)\n \tif (e != latch\n \t    && PHI_ARG_DEF_FROM_EDGE (phi, e) == lop)\n \t  return NULL;\n@@ -607,10 +607,10 @@ find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, VEC (edge, h\n static edge\n find_subloop_latch_edge (struct loop *loop)\n {\n-  VEC (edge, heap) *latches = get_loop_latch_edges (loop);\n+  vec<edge> latches = get_loop_latch_edges (loop);\n   edge latch = NULL;\n \n-  if (VEC_length (edge, latches) > 1)\n+  if (latches.length () > 1)\n     {\n       latch = find_subloop_latch_edge_by_profile (latches);\n \n@@ -622,7 +622,7 @@ find_subloop_latch_edge (struct loop *loop)\n \tlatch = find_subloop_latch_edge_by_ivs (loop, latches);\n     }\n \n-  VEC_free (edge, heap, latches);\n+  latches.release ();\n   return latch;\n }\n \n@@ -671,21 +671,21 @@ form_subloop (struct loop *loop, edge latch)\n static void\n merge_latch_edges (struct loop *loop)\n {\n-  VEC (edge, heap) *latches = get_loop_latch_edges (loop);\n+  vec<edge> latches = get_loop_latch_edges (loop);\n   edge latch, e;\n   unsigned i;\n \n-  gcc_assert (VEC_length (edge, latches) > 0);\n+  gcc_assert (latches.length () > 0);\n \n-  if (VEC_length (edge, latches) == 1)\n-    loop->latch = VEC_index (edge, latches, 0)->src;\n+  if (latches.length () == 1)\n+    loop->latch = latches[0]->src;\n   else\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Merged latch edges of loop %d\\n\", loop->num);\n \n       mfb_reis_set = pointer_set_create ();\n-      FOR_EACH_VEC_ELT (edge, latches, i, e)\n+      FOR_EACH_VEC_ELT (latches, i, e)\n \tpointer_set_insert (mfb_reis_set, e);\n       latch = make_forwarder_block (loop->header, mfb_redirect_edges_in_set,\n \t\t\t\t    NULL);\n@@ -695,7 +695,7 @@ merge_latch_edges (struct loop *loop)\n       loop->latch = latch->src;\n     }\n \n-  VEC_free (edge, heap, latches);\n+  latches.release ();\n }\n \n /* LOOP may have several latch edges.  Transform it into (possibly several)\n@@ -1114,10 +1114,10 @@ release_recorded_exits (void)\n \n /* Returns the list of the exit edges of a LOOP.  */\n \n-VEC (edge, heap) *\n+vec<edge> \n get_loop_exit_edges (const struct loop *loop)\n {\n-  VEC (edge, heap) *edges = NULL;\n+  vec<edge> edges = vec<edge>();\n   edge e;\n   unsigned i;\n   basic_block *body;\n@@ -1131,7 +1131,7 @@ get_loop_exit_edges (const struct loop *loop)\n   if (loops_state_satisfies_p (LOOPS_HAVE_RECORDED_EXITS))\n     {\n       for (exit = loop->exits->next; exit->e; exit = exit->next)\n-\tVEC_safe_push (edge, heap, edges, exit->e);\n+\tedges.safe_push (exit->e);\n     }\n   else\n     {\n@@ -1140,7 +1140,7 @@ get_loop_exit_edges (const struct loop *loop)\n \tFOR_EACH_EDGE (e, ei, body[i]->succs)\n \t  {\n \t    if (!flow_bb_inside_loop_p (loop, e->dest))\n-\t      VEC_safe_push (edge, heap, edges, e);\n+\t      edges.safe_push (e);\n \t  }\n       free (body);\n     }\n@@ -1180,7 +1180,7 @@ add_bb_to_loop (basic_block bb, struct loop *loop)\n   gcc_assert (bb->loop_father == NULL);\n   bb->loop_father = loop;\n   loop->num_nodes++;\n-  FOR_EACH_VEC_ELT (loop_p, loop->superloops, i, ploop)\n+  FOR_EACH_VEC_SAFE_ELT (loop->superloops, i, ploop)\n     ploop->num_nodes++;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1197,15 +1197,15 @@ add_bb_to_loop (basic_block bb, struct loop *loop)\n void\n remove_bb_from_loops (basic_block bb)\n {\n-  int i;\n+  unsigned i;\n   struct loop *loop = bb->loop_father;\n   loop_p ploop;\n   edge_iterator ei;\n   edge e;\n \n   gcc_assert (loop != NULL);\n   loop->num_nodes--;\n-  FOR_EACH_VEC_ELT (loop_p, loop->superloops, i, ploop)\n+  FOR_EACH_VEC_SAFE_ELT (loop->superloops, i, ploop)\n     ploop->num_nodes--;\n   bb->loop_father = NULL;\n \n@@ -1232,9 +1232,9 @@ find_common_loop (struct loop *loop_s, struct loop *loop_d)\n   ddepth = loop_depth (loop_d);\n \n   if (sdepth < ddepth)\n-    loop_d = VEC_index (loop_p, loop_d->superloops, sdepth);\n+    loop_d = (*loop_d->superloops)[sdepth];\n   else if (sdepth > ddepth)\n-    loop_s = VEC_index (loop_p, loop_s->superloops, ddepth);\n+    loop_s = (*loop_s->superloops)[ddepth];\n \n   while (loop_s != loop_d)\n     {\n@@ -1253,7 +1253,7 @@ delete_loop (struct loop *loop)\n   flow_loop_tree_node_remove (loop);\n \n   /* Remove loop from loops array.  */\n-  VEC_replace (loop_p, current_loops->larray, loop->num, NULL);\n+  (*current_loops->larray)[loop->num] = NULL;\n \n   /* Free loop data.  */\n   flow_loop_free (loop);"}, {"sha": "9e2e02de93dac26403ce714a1d9b6b7c12447aae", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_CFGLOOP_H\n \n #include \"basic-block.h\"\n-#include \"vecprim.h\"\n #include \"double-int.h\"\n \n #include \"bitmap.h\"\n@@ -91,9 +90,6 @@ struct GTY (()) loop_exit {\n };\n \n typedef struct loop *loop_p;\n-DEF_VEC_P (loop_p);\n-DEF_VEC_ALLOC_P (loop_p, heap);\n-DEF_VEC_ALLOC_P (loop_p, gc);\n \n /* An integer estimation of the number of iterations.  Estimate_state\n    describes what is the state of the estimation.  */\n@@ -129,7 +125,7 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n   unsigned num_nodes;\n \n   /* Superloops of the loop, starting with the outermost loop.  */\n-  VEC (loop_p, gc) *superloops;\n+  vec<loop_p, va_gc> *superloops;\n \n   /* The first inner (child) loop or NULL if innermost loop.  */\n   struct loop *inner;\n@@ -198,7 +194,7 @@ struct GTY (()) loops {\n   int state;\n \n   /* Array of the loops.  */\n-  VEC (loop_p, gc) *larray;\n+  vec<loop_p, va_gc> *larray;\n \n   /* Maps edges to the list of their descriptions as loop exits.  Edges\n      whose sources or destinations have loop_father == NULL (which may\n@@ -253,7 +249,7 @@ extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n extern basic_block *get_loop_body_in_custom_order (const struct loop *,\n \t\t\t       int (*) (const void *, const void *));\n \n-extern VEC (edge, heap) *get_loop_exit_edges (const struct loop *);\n+extern vec<edge> get_loop_exit_edges (const struct loop *);\n extern edge single_exit (const struct loop *);\n extern edge single_likely_exit (struct loop *loop);\n extern unsigned num_loop_branches (const struct loop *);\n@@ -314,7 +310,7 @@ extern void copy_loop_info (struct loop *loop, struct loop *target);\n extern void duplicate_subloops (struct loop *, struct loop *);\n extern bool duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t   unsigned, sbitmap, edge,\n- \t\t\t\t\t   VEC (edge, heap) **, int);\n+ \t\t\t\t\t   vec<edge> *, int);\n extern struct loop *loopify (edge, edge,\n \t\t\t     basic_block, edge, edge, bool,\n \t\t\t     unsigned, unsigned);\n@@ -434,15 +430,15 @@ simple_loop_desc (struct loop *loop)\n static inline struct loop *\n get_loop (unsigned num)\n {\n-  return VEC_index (loop_p, current_loops->larray, num);\n+  return (*current_loops->larray)[num];\n }\n \n /* Returns the number of superloops of LOOP.  */\n \n static inline unsigned\n loop_depth (const struct loop *loop)\n {\n-  return VEC_length (loop_p, loop->superloops);\n+  return vec_safe_length (loop->superloops);\n }\n \n /* Returns the loop depth of the loop BB belongs to.  */\n@@ -459,12 +455,12 @@ bb_loop_depth (const_basic_block bb)\n static inline struct loop *\n loop_outer (const struct loop *loop)\n {\n-  unsigned n = VEC_length (loop_p, loop->superloops);\n+  unsigned n = vec_safe_length (loop->superloops);\n \n   if (n == 0)\n     return NULL;\n \n-  return VEC_index (loop_p, loop->superloops, n - 1);\n+  return (*loop->superloops)[n - 1];\n }\n \n /* Returns true if LOOP has at least one exit edge.  */\n@@ -477,7 +473,7 @@ loop_has_exit_edges (const struct loop *loop)\n \n /* Returns the list of loops in current_loops.  */\n \n-static inline VEC (loop_p, gc) *\n+static inline vec<loop_p, va_gc> *\n get_loops (void)\n {\n   if (!current_loops)\n@@ -495,7 +491,7 @@ number_of_loops (void)\n   if (!current_loops)\n     return 0;\n \n-  return VEC_length (loop_p, current_loops->larray);\n+  return vec_safe_length (current_loops->larray);\n }\n \n /* Returns true if state of the loops satisfies all properties\n@@ -542,7 +538,7 @@ enum li_flags\n typedef struct\n {\n   /* The list of loops to visit.  */\n-  VEC(int,heap) *to_visit;\n+  vec<int> to_visit;\n \n   /* The index of the actual loop.  */\n   unsigned idx;\n@@ -553,15 +549,15 @@ fel_next (loop_iterator *li, loop_p *loop)\n {\n   int anum;\n \n-  while (VEC_iterate (int, li->to_visit, li->idx, anum))\n+  while (li->to_visit.iterate (li->idx, &anum))\n     {\n       li->idx++;\n       *loop = get_loop (anum);\n       if (*loop)\n \treturn;\n     }\n \n-  VEC_free (int, heap, li->to_visit);\n+  li->to_visit.release ();\n   *loop = NULL;\n }\n \n@@ -575,21 +571,21 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n   li->idx = 0;\n   if (!current_loops)\n     {\n-      li->to_visit = NULL;\n+      li->to_visit.create (0);\n       *loop = NULL;\n       return;\n     }\n \n-  li->to_visit = VEC_alloc (int, heap, number_of_loops ());\n+  li->to_visit.create (number_of_loops ());\n   mn = (flags & LI_INCLUDE_ROOT) ? 0 : 1;\n \n   if (flags & LI_ONLY_INNERMOST)\n     {\n-      for (i = 0; VEC_iterate (loop_p, current_loops->larray, i, aloop); i++)\n+      for (i = 0; vec_safe_iterate (current_loops->larray, i, &aloop); i++)\n \tif (aloop != NULL\n \t    && aloop->inner == NULL\n \t    && aloop->num >= mn)\n-\t  VEC_quick_push (int, li->to_visit, aloop->num);\n+\t  li->to_visit.quick_push (aloop->num);\n     }\n   else if (flags & LI_FROM_INNERMOST)\n     {\n@@ -602,7 +598,7 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n       while (1)\n \t{\n \t  if (aloop->num >= mn)\n-\t    VEC_quick_push (int, li->to_visit, aloop->num);\n+\t    li->to_visit.quick_push (aloop->num);\n \n \t  if (aloop->next)\n \t    {\n@@ -624,7 +620,7 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n       while (1)\n \t{\n \t  if (aloop->num >= mn)\n-\t    VEC_quick_push (int, li->to_visit, aloop->num);\n+\t    li->to_visit.quick_push (aloop->num);\n \n \t  if (aloop->inner != NULL)\n \t    aloop = aloop->inner;\n@@ -649,7 +645,7 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n \n #define FOR_EACH_LOOP_BREAK(LI) \\\n   { \\\n-    VEC_free (int, heap, (LI).to_visit); \\\n+    (LI).to_visit.release (); \\\n     break; \\\n   }\n \n@@ -714,19 +710,18 @@ extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n extern bool finite_loop_p (struct loop *);\n extern void scale_loop_profile (struct loop *loop, int scale, int iteration_bound);\n-extern VEC (basic_block, heap) * get_loop_hot_path (const struct loop *loop);\n+extern vec<basic_block> get_loop_hot_path (const struct loop *loop);\n \n /* Returns the outermost loop of the loop nest that contains LOOP.*/\n static inline struct loop *\n loop_outermost (struct loop *loop)\n {\n-  \n-  unsigned n = VEC_length (loop_p, loop->superloops);\n+  unsigned n = vec_safe_length (loop->superloops);\n \n   if (n <= 1)\n     return loop;\n \n-  return VEC_index (loop_p, loop->superloops, 1);\n+  return (*loop->superloops)[1];\n }\n \n "}, {"sha": "9b102849bd2b6a4774e004b48cc699aa7731e97e", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -129,7 +129,7 @@ mark_irreducible_loops (void)\n \t    if (depth == loop_depth (act->loop_father))\n \t      cloop = act->loop_father;\n \t    else\n-\t      cloop = VEC_index (loop_p, act->loop_father->superloops, depth);\n+\t      cloop = (*act->loop_father->superloops)[depth];\n \n \t    src = LOOP_REPR (cloop);\n \t  }\n@@ -454,14 +454,14 @@ edge\n single_likely_exit (struct loop *loop)\n {\n   edge found = single_exit (loop);\n-  VEC (edge, heap) *exits;\n+  vec<edge> exits;\n   unsigned i;\n   edge ex;\n \n   if (found)\n     return found;\n   exits = get_loop_exit_edges (loop);\n-  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n+  FOR_EACH_VEC_ELT (exits, i, ex)\n     {\n       if (ex->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n \tcontinue;\n@@ -476,11 +476,11 @@ single_likely_exit (struct loop *loop)\n \tfound = ex;\n       else\n \t{\n-\t  VEC_free (edge, heap, exits);\n+\t  exits.release ();\n \t  return NULL;\n \t}\n     }\n-  VEC_free (edge, heap, exits);\n+  exits.release ();\n   return found;\n }\n \n@@ -489,11 +489,11 @@ single_likely_exit (struct loop *loop)\n    order against direction of edges from latch.  Specially, if\n    header != latch, latch is the 1-st block.  */\n \n-VEC (basic_block, heap) *\n+vec<basic_block>\n get_loop_hot_path (const struct loop *loop)\n {\n   basic_block bb = loop->header;\n-  VEC (basic_block, heap) *path = NULL;\n+  vec<basic_block> path = vec<basic_block>();\n   bitmap visited = BITMAP_ALLOC (NULL);\n \n   while (true)\n@@ -502,7 +502,7 @@ get_loop_hot_path (const struct loop *loop)\n       edge e;\n       edge best = NULL;\n \n-      VEC_safe_push (basic_block, heap, path, bb);\n+      path.safe_push (bb);\n       bitmap_set_bit (visited, bb->index);\n       FOR_EACH_EDGE (e, ei, bb->succs)\n         if ((!best || e->probability > best->probability)"}, {"sha": "a1972ed84d0f905172020f4bda3656a578728d8b", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -119,11 +119,11 @@ fix_loop_placement (struct loop *loop)\n {\n   unsigned i;\n   edge e;\n-  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n+  vec<edge> exits = get_loop_exit_edges (loop);\n   struct loop *father = current_loops->tree_root, *act;\n   bool ret = false;\n \n-  FOR_EACH_VEC_ELT (edge, exits, i, e)\n+  FOR_EACH_VEC_ELT (exits, i, e)\n     {\n       act = find_common_loop (loop, e->dest->loop_father);\n       if (flow_loop_nested_p (father, act))\n@@ -139,13 +139,13 @@ fix_loop_placement (struct loop *loop)\n \n       /* The exit edges of LOOP no longer exits its original immediate\n \t superloops; remove them from the appropriate exit lists.  */\n-      FOR_EACH_VEC_ELT (edge, exits, i, e)\n+      FOR_EACH_VEC_ELT (exits, i, e)\n \trescan_loop_exit (e, false, false);\n \n       ret = true;\n     }\n \n-  VEC_free (edge, heap, exits);\n+  exits.release ();\n   return ret;\n }\n \n@@ -285,7 +285,7 @@ remove_path (edge e)\n {\n   edge ae;\n   basic_block *rem_bbs, *bord_bbs, from, bb;\n-  VEC (basic_block, heap) *dom_bbs;\n+  vec<basic_block> dom_bbs;\n   int i, nrem, n_bord_bbs;\n   sbitmap seen;\n   bool irred_invalidated = false;\n@@ -354,7 +354,7 @@ remove_path (edge e)\n   /* Remove the path.  */\n   from = e->src;\n   remove_branch (e);\n-  dom_bbs = NULL;\n+  dom_bbs.create (0);\n \n   /* Cancel loops contained in the path.  */\n   for (i = 0; i < nrem; i++)\n@@ -379,14 +379,14 @@ remove_path (edge e)\n \t   ldom;\n \t   ldom = next_dom_son (CDI_DOMINATORS, ldom))\n \tif (!dominated_by_p (CDI_DOMINATORS, from, ldom))\n-\t  VEC_safe_push (basic_block, heap, dom_bbs, ldom);\n+\t  dom_bbs.safe_push (ldom);\n     }\n \n   free (seen);\n \n   /* Recount dominators.  */\n   iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, true);\n-  VEC_free (basic_block, heap, dom_bbs);\n+  dom_bbs.release ();\n   free (bord_bbs);\n \n   /* Fix placements of basic blocks inside loops and the placement of\n@@ -407,7 +407,7 @@ static void\n place_new_loop (struct loop *loop)\n {\n   loop->num = number_of_loops ();\n-  VEC_safe_push (loop_p, gc, current_loops->larray, loop);\n+  vec_safe_push (current_loops->larray, loop);\n }\n \n /* Given LOOP structure with filled header and latch, find the body of the\n@@ -588,7 +588,7 @@ scale_loop_profile (struct loop *loop, int scale, int iteration_bound)\n static void\n update_dominators_in_loop (struct loop *loop)\n {\n-  VEC (basic_block, heap) *dom_bbs = NULL;\n+  vec<basic_block> dom_bbs = vec<basic_block>();\n   sbitmap seen;\n   basic_block *body;\n   unsigned i;\n@@ -610,14 +610,14 @@ update_dominators_in_loop (struct loop *loop)\n \tif (!bitmap_bit_p (seen, ldom->index))\n \t  {\n \t    bitmap_set_bit (seen, ldom->index);\n-\t    VEC_safe_push (basic_block, heap, dom_bbs, ldom);\n+\t    dom_bbs.safe_push (ldom);\n \t  }\n     }\n \n   iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, false);\n   free (body);\n   free (seen);\n-  VEC_free (basic_block, heap, dom_bbs);\n+  dom_bbs.release ();\n }\n \n /* Creates an if region as shown above. CONDITION is used to create\n@@ -1115,7 +1115,7 @@ set_zero_probability (edge e)\n bool\n duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t\t\t       unsigned int ndupl, sbitmap wont_exit,\n-\t\t\t       edge orig, VEC (edge, heap) **to_remove,\n+\t\t\t       edge orig, vec<edge> *to_remove,\n \t\t\t       int flags)\n {\n   struct loop *target, *aloop;\n@@ -1345,7 +1345,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       if (orig && bitmap_bit_p (wont_exit, j + 1))\n \t{\n \t  if (to_remove)\n-\t    VEC_safe_push (edge, heap, *to_remove, new_spec_edges[SE_ORIG]);\n+\t    to_remove->safe_push (new_spec_edges[SE_ORIG]);\n \t  set_zero_probability (new_spec_edges[SE_ORIG]);\n \n \t  /* Scale the frequencies of the blocks dominated by the exit.  */\n@@ -1381,7 +1381,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   if (orig && bitmap_bit_p (wont_exit, 0))\n     {\n       if (to_remove)\n-\tVEC_safe_push (edge, heap, *to_remove, orig);\n+\tto_remove->safe_push (orig);\n       set_zero_probability (orig);\n \n       /* Scale the frequencies of the blocks dominated by the exit.  */\n@@ -1408,22 +1408,22 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   for (i = 0; i < n; i++)\n     {\n       basic_block dominated, dom_bb;\n-      VEC (basic_block, heap) *dom_bbs;\n+      vec<basic_block> dom_bbs;\n       unsigned j;\n \n       bb = bbs[i];\n       bb->aux = 0;\n \n       dom_bbs = get_dominated_by (CDI_DOMINATORS, bb);\n-      FOR_EACH_VEC_ELT (basic_block, dom_bbs, j, dominated)\n+      FOR_EACH_VEC_ELT (dom_bbs, j, dominated)\n \t{\n \t  if (flow_bb_inside_loop_p (loop, dominated))\n \t    continue;\n \t  dom_bb = nearest_common_dominator (\n \t\t\tCDI_DOMINATORS, first_active[i], first_active_latch);\n \t  set_immediate_dominator (CDI_DOMINATORS, dominated, dom_bb);\n \t}\n-      VEC_free (basic_block, heap, dom_bbs);\n+      dom_bbs.release ();\n     }\n   free (first_active);\n "}, {"sha": "a5bb97462a657811c8ee1645319328a58d3271d1", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -350,10 +350,10 @@ rtl_create_basic_block (void *headp, void *endp, basic_block after)\n   basic_block bb;\n \n   /* Grow the basic block array if needed.  */\n-  if ((size_t) last_basic_block >= VEC_length (basic_block, basic_block_info))\n+  if ((size_t) last_basic_block >= basic_block_info->length ())\n     {\n       size_t new_size = last_basic_block + (last_basic_block + 3) / 4;\n-      VEC_safe_grow_cleared (basic_block, gc, basic_block_info, new_size);\n+      vec_safe_grow_cleared (basic_block_info, new_size);\n     }\n \n   n_basic_blocks++;\n@@ -1401,7 +1401,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t    {\n \t      if (tmp == e)\n \t\t{\n-\t\t  VEC_unordered_remove (edge, ENTRY_BLOCK_PTR->succs, ei.index);\n+\t\t  ENTRY_BLOCK_PTR->succs->unordered_remove (ei.index);\n \t\t  found = true;\n \t\t  break;\n \t\t}\n@@ -1411,7 +1411,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \n \t  gcc_assert (found);\n \n-\t  VEC_safe_push (edge, gc, bb->succs, e);\n+\t  vec_safe_push (bb->succs, e);\n \t  make_single_succ_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n \t}\n     }"}, {"sha": "c53e51cebdfb1a1e9acac2fd5bb964b95dc79a77", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1291,8 +1291,7 @@ cgraph_release_function_body (struct cgraph_node *node)\n \tfree_histograms ();\n       pop_cfun();\n       gimple_set_body (node->symbol.decl, NULL);\n-      VEC_free (ipa_opt_pass, heap,\n-      \t\tnode->ipa_transforms_to_apply);\n+      node->ipa_transforms_to_apply.release ();\n       /* Struct function hangs a lot of data that would leak if we didn't\n          removed all pointers to it.   */\n       ggc_free (DECL_STRUCT_FUNCTION (node->symbol.decl));\n@@ -1317,8 +1316,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   cgraph_call_node_removal_hooks (node);\n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n-  VEC_free (ipa_opt_pass, heap,\n-            node->ipa_transforms_to_apply);\n+  node->ipa_transforms_to_apply.release ();\n \n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n@@ -2168,25 +2166,25 @@ cgraph_only_called_directly_p (struct cgraph_node *node)\n static bool\n collect_callers_of_node_1 (struct cgraph_node *node, void *data)\n {\n-  VEC (cgraph_edge_p, heap) ** redirect_callers = (VEC (cgraph_edge_p, heap) **)data;\n+  vec<cgraph_edge_p> *redirect_callers = (vec<cgraph_edge_p> *)data;\n   struct cgraph_edge *cs;\n   enum availability avail;\n   cgraph_function_or_thunk_node (node, &avail);\n \n   if (avail > AVAIL_OVERWRITABLE)\n     for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n       if (!cs->indirect_inlining_edge)\n-        VEC_safe_push (cgraph_edge_p, heap, *redirect_callers, cs);\n+        redirect_callers->safe_push (cs);\n   return false;\n }\n \n /* Collect all callers of NODE and its aliases that are known to lead to NODE\n    (i.e. are not overwritable).  */\n \n-VEC (cgraph_edge_p, heap) *\n+vec<cgraph_edge_p> \n collect_callers_of_node (struct cgraph_node *node)\n {\n-  VEC (cgraph_edge_p, heap) * redirect_callers = NULL;\n+  vec<cgraph_edge_p> redirect_callers = vec<cgraph_edge_p>();\n   cgraph_for_node_and_aliases (node, collect_callers_of_node_1,\n \t\t\t       &redirect_callers, false);\n   return redirect_callers;\n@@ -2229,9 +2227,8 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n       /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n \t Remove this once edges are actually removed from the function at that time.  */\n       && (e->frequency\n-\t  || (inline_edge_summary_vec\n-\t      && ((VEC_length(inline_edge_summary_t, inline_edge_summary_vec)\n-\t\t  <= (unsigned) e->uid)\n+\t  || (inline_edge_summary_vec.exists ()\n+\t      && ((inline_edge_summary_vec.length () <= (unsigned) e->uid)\n \t          || !inline_edge_summary (e)->predicate)))\n       && (e->frequency\n \t  != compute_call_stmt_bb_frequency (e->caller->symbol.decl,"}, {"sha": "28c3497c5666c6f75566406ce84bd6d517d5a3f0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -191,12 +191,10 @@ struct GTY(()) ipa_replace_map\n   bool ref_p;\n };\n typedef struct ipa_replace_map *ipa_replace_map_p;\n-DEF_VEC_P(ipa_replace_map_p);\n-DEF_VEC_ALLOC_P(ipa_replace_map_p,gc);\n \n struct GTY(()) cgraph_clone_info\n {\n-  VEC(ipa_replace_map_p,gc)* tree_map;\n+  vec<ipa_replace_map_p, va_gc> *tree_map;\n   bitmap args_to_skip;\n   bitmap combined_args_to_skip;\n };\n@@ -238,7 +236,7 @@ struct GTY(()) cgraph_node {\n   /* Interprocedural passes scheduled to have their transform functions\n      applied next time we execute local pass on them.  We maintain it\n      per-function in order to allow IPA passes to introduce new functions.  */\n-  VEC(ipa_opt_pass,heap) * GTY((skip)) ipa_transforms_to_apply;\n+  vec<ipa_opt_pass> GTY((skip)) ipa_transforms_to_apply;\n \n   struct cgraph_local_info local;\n   struct cgraph_global_info global;\n@@ -284,15 +282,9 @@ struct GTY(()) cgraph_node {\n   unsigned dispatcher_function : 1;\n };\n \n-DEF_VEC_P(symtab_node);\n-DEF_VEC_ALLOC_P(symtab_node,heap);\n-DEF_VEC_ALLOC_P(symtab_node,gc);\n \n typedef struct cgraph_node *cgraph_node_ptr;\n \n-DEF_VEC_P(cgraph_node_ptr);\n-DEF_VEC_ALLOC_P(cgraph_node_ptr,heap);\n-DEF_VEC_ALLOC_P(cgraph_node_ptr,gc);\n \n /* Function Multiversioning info.  */\n struct GTY(()) cgraph_function_version_info {\n@@ -340,34 +332,25 @@ void delete_function_version (tree decl);\n struct cgraph_node_set_def\n {\n   struct pointer_map_t *map;\n-  VEC(cgraph_node_ptr, heap) *nodes;\n+  vec<cgraph_node_ptr> nodes;\n };\n \n typedef struct varpool_node *varpool_node_ptr;\n \n-DEF_VEC_P(varpool_node_ptr);\n-DEF_VEC_ALLOC_P(varpool_node_ptr,heap);\n-DEF_VEC_ALLOC_P(varpool_node_ptr,gc);\n \n /* A varpool node set is a collection of varpool nodes.  A varpool node\n    can appear in multiple sets.  */\n struct varpool_node_set_def\n {\n   struct pointer_map_t * map;\n-  VEC(varpool_node_ptr, heap) *nodes;\n+  vec<varpool_node_ptr> nodes;\n };\n \n typedef struct cgraph_node_set_def *cgraph_node_set;\n \n-DEF_VEC_P(cgraph_node_set);\n-DEF_VEC_ALLOC_P(cgraph_node_set,gc);\n-DEF_VEC_ALLOC_P(cgraph_node_set,heap);\n \n typedef struct varpool_node_set_def *varpool_node_set;\n \n-DEF_VEC_P(varpool_node_set);\n-DEF_VEC_ALLOC_P(varpool_node_set,gc);\n-DEF_VEC_ALLOC_P(varpool_node_set,heap);\n \n /* Iterator structure for cgraph node sets.  */\n typedef struct\n@@ -462,8 +445,6 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n \n typedef struct cgraph_edge *cgraph_edge_p;\n \n-DEF_VEC_P(cgraph_edge_p);\n-DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n \n /* The varpool data structure.\n    Each static variable decl has assigned varpool_node.  */\n@@ -640,7 +621,7 @@ bool cgraph_for_node_thunks_and_aliases (struct cgraph_node *,\n bool cgraph_for_node_and_aliases (struct cgraph_node *,\n \t\t                  bool (*) (struct cgraph_node *, void *),\n \t\t\t          void *, bool);\n-VEC (cgraph_edge_p, heap) * collect_callers_of_node (struct cgraph_node *node);\n+vec<cgraph_edge_p>  collect_callers_of_node (struct cgraph_node *node);\n void verify_cgraph (void);\n void verify_cgraph_node (struct cgraph_node *);\n void cgraph_mark_address_taken_node (struct cgraph_node *);\n@@ -691,12 +672,12 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tstruct cgraph_node *, gimple,\n \t\t\t\t\tunsigned, gcov_type, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n-\t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *,\n+\t\t\t\t\tint, bool, vec<cgraph_edge_p>,\n \t\t\t\t\tbool);\n tree clone_function_name (tree decl, const char *);\n struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n-\t\t\t                          VEC(cgraph_edge_p,heap)*,\n-\t\t\t                          VEC(ipa_replace_map_p,gc)* tree_map,\n+\t\t\t                          vec<cgraph_edge_p>,\n+\t\t\t                          vec<ipa_replace_map_p, va_gc> *tree_map,\n \t\t\t                          bitmap args_to_skip,\n \t\t\t\t\t\t  const char *clone_name);\n struct cgraph_node *cgraph_find_replacement_node (struct cgraph_node *);\n@@ -708,13 +689,13 @@ void cgraph_create_edge_including_clones (struct cgraph_node *,\n \t\t\t\t\t  cgraph_inline_failed_t);\n void cgraph_materialize_all_clones (void);\n struct cgraph_node * cgraph_copy_node_for_versioning (struct cgraph_node *,\n-\t\ttree, VEC(cgraph_edge_p,heap)*, bitmap);\n+\t\ttree, vec<cgraph_edge_p>, bitmap);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n-\t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n-\t\t\t\t\t\tVEC(ipa_replace_map_p,gc)*,\n+\t\t\t\t\t\tvec<cgraph_edge_p>,\n+\t\t\t\t\t\tvec<ipa_replace_map_p, va_gc> *,\n \t\t\t\t\t\tbitmap, bool, bitmap,\n \t\t\t\t\t\tbasic_block, const char *);\n-void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*,\n+void tree_function_versioning (tree, tree, vec<ipa_replace_map_p, va_gc> *,\n \t\t\t       bool, bitmap, bool, bitmap, basic_block);\n \n /* In cgraphbuild.c  */\n@@ -1051,7 +1032,7 @@ tree add_new_static_var (tree type);\n static inline bool\n csi_end_p (cgraph_node_set_iterator csi)\n {\n-  return csi.index >= VEC_length (cgraph_node_ptr, csi.set->nodes);\n+  return csi.index >= csi.set->nodes.length ();\n }\n \n /* Advance iterator CSI.  */\n@@ -1065,7 +1046,7 @@ csi_next (cgraph_node_set_iterator *csi)\n static inline struct cgraph_node *\n csi_node (cgraph_node_set_iterator csi)\n {\n-  return VEC_index (cgraph_node_ptr, csi.set->nodes, csi.index);\n+  return csi.set->nodes[csi.index];\n }\n \n /* Return an iterator to the first node in SET.  */\n@@ -1092,14 +1073,14 @@ cgraph_node_in_set_p (struct cgraph_node *node, cgraph_node_set set)\n static inline size_t\n cgraph_node_set_size (cgraph_node_set set)\n {\n-  return VEC_length (cgraph_node_ptr, set->nodes);\n+  return set->nodes.length ();\n }\n \n /* Return true if iterator VSI points to nothing.  */\n static inline bool\n vsi_end_p (varpool_node_set_iterator vsi)\n {\n-  return vsi.index >= VEC_length (varpool_node_ptr, vsi.set->nodes);\n+  return vsi.index >= vsi.set->nodes.length ();\n }\n \n /* Advance iterator VSI.  */\n@@ -1113,7 +1094,7 @@ vsi_next (varpool_node_set_iterator *vsi)\n static inline struct varpool_node *\n vsi_node (varpool_node_set_iterator vsi)\n {\n-  return VEC_index (varpool_node_ptr, vsi.set->nodes, vsi.index);\n+  return vsi.set->nodes[vsi.index];\n }\n \n /* Return an iterator to the first node in SET.  */\n@@ -1140,7 +1121,7 @@ varpool_node_in_set_p (struct varpool_node *node, varpool_node_set set)\n static inline size_t\n varpool_node_set_size (varpool_node_set set)\n {\n-  return VEC_length (varpool_node_ptr, set->nodes);\n+  return set->nodes.length ();\n }\n \n /* Uniquize all constants that appear in memory.\n@@ -1164,14 +1145,14 @@ struct GTY(()) constant_descriptor_tree {\n static inline bool\n cgraph_node_set_nonempty_p (cgraph_node_set set)\n {\n-  return !VEC_empty (cgraph_node_ptr, set->nodes);\n+  return !set->nodes.is_empty ();\n }\n \n /* Return true if set is nonempty.  */\n static inline bool\n varpool_node_set_nonempty_p (varpool_node_set set)\n {\n-  return !VEC_empty (varpool_node_ptr, set->nodes);\n+  return !set->nodes.is_empty ();\n }\n \n /* Return true when function NODE is only called directly or it has alias."}, {"sha": "d5bc04e0b09cf53050f3263452d5b0e27110adfc", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -173,7 +173,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n struct cgraph_node *\n cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \t\t   bool update_original,\n-\t\t   VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t   vec<cgraph_edge_p> redirect_callers,\n \t\t   bool call_duplication_hook)\n {\n   struct cgraph_node *new_node = cgraph_create_empty_node ();\n@@ -198,7 +198,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   new_node->count = count;\n   new_node->frequency = n->frequency;\n   new_node->clone = n->clone;\n-  new_node->clone.tree_map = 0;\n+  new_node->clone.tree_map = NULL;\n   if (n->count)\n     {\n       if (new_node->count > n->count)\n@@ -215,7 +215,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \tn->count = 0;\n     }\n \n-  FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n+  FOR_EACH_VEC_ELT (redirect_callers, i, e)\n     {\n       /* Redirect calls to the old version node to point to its new\n \t version.  */\n@@ -276,8 +276,8 @@ clone_function_name (tree decl, const char *suffix)\n    */\n struct cgraph_node *\n cgraph_create_virtual_clone (struct cgraph_node *old_node,\n-\t\t\t     VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t\t     VEC(ipa_replace_map_p,gc) *tree_map,\n+\t\t\t     vec<cgraph_edge_p> redirect_callers,\n+\t\t\t     vec<ipa_replace_map_p, va_gc> *tree_map,\n \t\t\t     bitmap args_to_skip,\n \t\t\t     const char * suffix)\n {\n@@ -323,7 +323,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   DECL_STATIC_DESTRUCTOR (new_node->symbol.decl) = 0;\n   new_node->clone.tree_map = tree_map;\n   new_node->clone.args_to_skip = args_to_skip;\n-  FOR_EACH_VEC_ELT (ipa_replace_map_p, tree_map, i, map)\n+  FOR_EACH_VEC_SAFE_ELT (tree_map, i, map)\n     {\n       tree var = map->new_tree;\n       symtab_node ref_node;\n@@ -615,7 +615,7 @@ update_call_expr (struct cgraph_node *new_version)\n struct cgraph_node *\n cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \t\t\t\t tree new_decl,\n-\t\t\t\t VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t\t\t vec<cgraph_edge_p> redirect_callers,\n \t\t\t\t bitmap bbs_to_copy)\n  {\n    struct cgraph_node *new_version;\n@@ -648,7 +648,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n \t\t\t  CGRAPH_FREQ_BASE,\n \t\t\t  true);\n-   FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n+   FOR_EACH_VEC_ELT (redirect_callers, i, e)\n      {\n        /* Redirect calls to the old version node to point to its new\n \t  version.  */\n@@ -682,8 +682,8 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n struct cgraph_node *\n cgraph_function_versioning (struct cgraph_node *old_version_node,\n-\t\t\t    VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t\t    VEC (ipa_replace_map_p,gc)* tree_map,\n+\t\t\t    vec<cgraph_edge_p> redirect_callers,\n+\t\t\t    vec<ipa_replace_map_p, va_gc> *tree_map,\n \t\t\t    bitmap args_to_skip,\n \t\t\t    bool skip_return,\n \t\t\t    bitmap bbs_to_copy,\n@@ -822,14 +822,12 @@ cgraph_materialize_all_clones (void)\n \t\t        {\n \t\t\t  unsigned int i;\n \t\t          fprintf (cgraph_dump_file, \"   replace map: \");\n-\t\t\t  for (i = 0; i < VEC_length (ipa_replace_map_p,\n-\t\t\t  \t\t\t      node->clone.tree_map);\n-\t\t\t\t\t\t      i++)\n+\t\t\t  for (i = 0;\n+\t\t\t       i < vec_safe_length (node->clone.tree_map);\n+\t\t\t       i++)\n \t\t\t    {\n \t\t\t      struct ipa_replace_map *replace_info;\n-\t\t\t      replace_info = VEC_index (ipa_replace_map_p,\n-\t\t\t      \t\t\t\tnode->clone.tree_map,\n-\t\t\t\t\t\t\ti);\n+\t\t\t      replace_info = (*node->clone.tree_map)[i];\n \t\t\t      print_generic_expr (cgraph_dump_file, replace_info->old_tree, 0);\n \t\t\t      fprintf (cgraph_dump_file, \" -> \");\n \t\t\t      print_generic_expr (cgraph_dump_file, replace_info->new_tree, 0);"}, {"sha": "4d508cb6b84d524a8b0da4dd045be05de9d41cd0", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -610,7 +610,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t    input_location = saved_loc;\n \t    return;\n \t  }\n-      if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n+      if (!vec_safe_length (node->symbol.ref_list.references))\n         ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n \t\t\t      IPA_REF_ALIAS, NULL);\n       if (node->same_body_alias)\n@@ -695,7 +695,7 @@ cgraph_process_same_body_aliases (void)\n   struct cgraph_node *node;\n   FOR_EACH_FUNCTION (node)\n     if (node->same_body_alias\n-\t&& !VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n+\t&& !vec_safe_length (node->symbol.ref_list.references))\n       {\n         struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n         ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n@@ -1060,7 +1060,7 @@ handle_alias_pairs (void)\n   alias_pair *p;\n   unsigned i;\n   \n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p);)\n+  for (i = 0; alias_pairs && alias_pairs->iterate (i, &p);)\n     {\n       symtab_node target_node = symtab_node_for_asm (p->target);\n \n@@ -1074,13 +1074,13 @@ handle_alias_pairs (void)\n \t  else\n \t    varpool_get_node (p->decl)->alias = true;\n \t  DECL_EXTERNAL (p->decl) = 1;\n-\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t  alias_pairs->unordered_remove (i);\n \t  continue;\n \t}\n       else if (!target_node)\n \t{\n \t  error (\"%q+D aliased to undefined symbol %qE\", p->decl, p->target);\n-\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t  alias_pairs->unordered_remove (i);\n \t  continue;\n \t}\n \n@@ -1113,24 +1113,24 @@ handle_alias_pairs (void)\n \t  if (src_node && src_node->local.finalized)\n             cgraph_reset_node (src_node);\n \t  cgraph_create_function_alias (p->decl, target_node->symbol.decl);\n-\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t  alias_pairs->unordered_remove (i);\n \t}\n       else if (TREE_CODE (p->decl) == VAR_DECL\n \t       && target_node && is_a <varpool_node> (target_node))\n \t{\n \t  varpool_create_variable_alias (p->decl, target_node->symbol.decl);\n-\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t  alias_pairs->unordered_remove (i);\n \t}\n       else\n \t{\n \t  error (\"%q+D alias in between function and variable is not supported\",\n \t\t p->decl);\n \t  warning (0, \"%q+D aliased declaration\",\n \t\t   target_node->symbol.decl);\n-\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t  alias_pairs->unordered_remove (i);\n \t}\n     }\n-  VEC_free (alias_pair, gc, alias_pairs);\n+  vec_free (alias_pairs);\n }\n \n \n@@ -1440,7 +1440,7 @@ assemble_thunk (struct cgraph_node *node)\n       int i;\n       tree resdecl;\n       tree restmp = NULL;\n-      VEC(tree, heap) *vargs;\n+      vec<tree> vargs;\n \n       gimple call;\n       gimple ret;\n@@ -1482,18 +1482,16 @@ assemble_thunk (struct cgraph_node *node)\n \n       for (arg = a; arg; arg = DECL_CHAIN (arg))\n         nargs++;\n-      vargs = VEC_alloc (tree, heap, nargs);\n+      vargs.create (nargs);\n       if (this_adjusting)\n-        VEC_quick_push (tree, vargs,\n-\t\t\tthunk_adjust (&bsi,\n-\t\t\t\t      a, 1, fixed_offset,\n-\t\t\t\t      virtual_offset));\n+        vargs.quick_push (thunk_adjust (&bsi, a, 1, fixed_offset,\n+\t\t\t\t\tvirtual_offset));\n       else\n-        VEC_quick_push (tree, vargs, a);\n+        vargs.quick_push (a);\n       for (i = 1, arg = DECL_CHAIN (a); i < nargs; i++, arg = DECL_CHAIN (arg))\n-\tVEC_quick_push (tree, vargs, arg);\n+\tvargs.quick_push (arg);\n       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n-      VEC_free (tree, heap, vargs);\n+      vargs.release ();\n       gimple_call_set_from_thunk (call, true);\n       if (restmp)\n         gimple_call_set_lhs (call, restmp);"}, {"sha": "5bf08ff2fb6d34580ffceac39656190b0f730581", "filename": "gcc/combine.c", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -252,10 +252,8 @@ typedef struct reg_stat_struct {\n   ENUM_BITFIELD(machine_mode)\ttruncated_to_mode : 8;\n } reg_stat_type;\n \n-DEF_VEC_O(reg_stat_type);\n-DEF_VEC_ALLOC_O(reg_stat_type,heap);\n \n-static VEC(reg_stat_type,heap) *reg_stat;\n+static vec<reg_stat_type> reg_stat;\n \n /* Record the luid of the last insn that invalidated memory\n    (anything that writes memory, and subroutine calls, but not pushes).  */\n@@ -510,8 +508,8 @@ combine_split_insns (rtx pattern, rtx insn)\n \n   ret = split_insns (pattern, insn);\n   nregs = max_reg_num ();\n-  if (nregs > VEC_length (reg_stat_type, reg_stat))\n-    VEC_safe_grow_cleared (reg_stat_type, heap, reg_stat, nregs);\n+  if (nregs > reg_stat.length ())\n+    reg_stat.safe_grow_cleared (nregs);\n   return ret;\n }\n \n@@ -1121,7 +1119,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   rtl_hooks = combine_rtl_hooks;\n \n-  VEC_safe_grow_cleared (reg_stat_type, heap, reg_stat, nregs);\n+  reg_stat.safe_grow_cleared (nregs);\n \n   init_recog_no_volatile ();\n \n@@ -1446,7 +1444,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   obstack_free (&insn_link_obstack, NULL);\n   free (uid_log_links);\n   free (uid_insn_cost);\n-  VEC_free (reg_stat_type, heap, reg_stat);\n+  reg_stat.release ();\n \n   {\n     struct undo *undo, *next;\n@@ -1480,7 +1478,7 @@ init_reg_last (void)\n   unsigned int i;\n   reg_stat_type *p;\n \n-  FOR_EACH_VEC_ELT (reg_stat_type, reg_stat, i, p)\n+  FOR_EACH_VEC_ELT (reg_stat, i, p)\n     memset (p, 0, offsetof (reg_stat_type, sign_bit_copies));\n }\n \f\n@@ -1587,7 +1585,7 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n            (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x))\n       && HWI_COMPUTABLE_MODE_P (GET_MODE (x)))\n     {\n-      reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+      reg_stat_type *rsp = &reg_stat[REGNO (x)];\n \n       if (set == 0 || GET_CODE (set) == CLOBBER)\n \t{\n@@ -3637,22 +3635,18 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t (REG_P (temp)\n-\t\t  && VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\tREGNO (temp)).nonzero_bits != 0\n+\t\t  && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t  && GET_MODE_PRECISION (GET_MODE (temp)) < BITS_PER_WORD\n \t\t  && GET_MODE_PRECISION (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t  && (VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\t REGNO (temp)).nonzero_bits\n+\t\t  && (reg_stat[REGNO (temp)].nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n \t\t     (REG_P (temp)\n-\t\t      && VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\t    REGNO (temp)).nonzero_bits != 0\n+\t\t      && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t      && GET_MODE_PRECISION (GET_MODE (temp)) < BITS_PER_WORD\n \t\t      && GET_MODE_PRECISION (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t      && (VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\t     REGNO (temp)).nonzero_bits\n+\t\t      && (reg_stat[REGNO (temp)].nonzero_bits\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t\t SET_SRC (XVECEXP (newpat, 0, 1)))\n@@ -9413,7 +9407,7 @@ reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n      value.  Otherwise, use the previously-computed global nonzero bits\n      for this register.  */\n \n-  rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  rsp = &reg_stat[REGNO (x)];\n   if (rsp->last_set_value != 0\n       && (rsp->last_set_mode == mode\n \t  || (GET_MODE_CLASS (rsp->last_set_mode) == MODE_INT\n@@ -9482,7 +9476,7 @@ reg_num_sign_bit_copies_for_combine (const_rtx x, enum machine_mode mode,\n   rtx tem;\n   reg_stat_type *rsp;\n \n-  rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  rsp = &reg_stat[REGNO (x)];\n   if (rsp->last_set_value != 0\n       && rsp->last_set_mode == mode\n       && ((rsp->last_set_label >= label_tick_ebb_start\n@@ -12046,7 +12040,7 @@ update_table_tick (rtx x)\n \n       for (r = regno; r < endregno; r++)\n \t{\n-\t  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, r);\n+\t  reg_stat_type *rsp = &reg_stat[r];\n \t  rsp->last_set_table_tick = label_tick;\n \t}\n \n@@ -12148,7 +12142,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n      register.  */\n   for (i = regno; i < endregno; i++)\n     {\n-      rsp = &VEC_index (reg_stat_type, reg_stat, i);\n+      rsp = &reg_stat[i];\n \n       if (insn)\n \trsp->last_set = insn;\n@@ -12174,7 +12168,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n   for (i = regno; i < endregno; i++)\n     {\n-      rsp = &VEC_index (reg_stat_type, reg_stat, i);\n+      rsp = &reg_stat[i];\n       rsp->last_set_label = label_tick;\n       if (!insn\n \t  || (value && rsp->last_set_table_tick >= label_tick_ebb_start))\n@@ -12186,7 +12180,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   /* The value being assigned might refer to X (like in \"x++;\").  In that\n      case, we must replace it with (clobber (const_int 0)) to prevent\n      infinite loops.  */\n-  rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n+  rsp = &reg_stat[regno];\n   if (value && !get_last_value_validate (&value, insn, label_tick, 0))\n     {\n       value = copy_rtx (value);\n@@ -12284,7 +12278,7 @@ record_dead_and_set_regs (rtx insn)\n \t    {\n \t      reg_stat_type *rsp;\n \n-\t      rsp = &VEC_index (reg_stat_type, reg_stat, i);\n+\t      rsp = &reg_stat[i];\n \t      rsp->last_death = insn;\n \t    }\n \t}\n@@ -12299,7 +12293,7 @@ record_dead_and_set_regs (rtx insn)\n \t{\n \t  reg_stat_type *rsp;\n \n-\t  rsp = &VEC_index (reg_stat_type, reg_stat, i);\n+\t  rsp = &reg_stat[i];\n \t  rsp->last_set_invalid = 1;\n \t  rsp->last_set = insn;\n \t  rsp->last_set_value = 0;\n@@ -12357,7 +12351,7 @@ record_promoted_value (rtx insn, rtx subreg)\n \t  continue;\n \t}\n \n-      rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n+      rsp = &reg_stat[regno];\n       if (rsp->last_set == insn)\n \t{\n \t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)\n@@ -12382,7 +12376,7 @@ record_promoted_value (rtx insn, rtx subreg)\n static bool\n reg_truncated_to_mode (enum machine_mode mode, const_rtx x)\n {\n-  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  reg_stat_type *rsp = &reg_stat[REGNO (x)];\n   enum machine_mode truncated = rsp->truncated_to_mode;\n \n   if (truncated == 0\n@@ -12427,7 +12421,7 @@ record_truncated_value (rtx *p, void *data ATTRIBUTE_UNUSED)\n   else\n     return 0;\n \n-  rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  rsp = &reg_stat[REGNO (x)];\n   if (rsp->truncated_to_mode == 0\n       || rsp->truncation_label < label_tick_ebb_start\n       || (GET_MODE_SIZE (truncated_mode)\n@@ -12506,7 +12500,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n \n       for (j = regno; j < endregno; j++)\n \t{\n-\t  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, j);\n+\t  reg_stat_type *rsp = &reg_stat[j];\n \t  if (rsp->last_set_invalid\n \t      /* If this is a pseudo-register that was only set once and not\n \t\t live at the beginning of the function, it is always valid.  */\n@@ -12610,7 +12604,7 @@ get_last_value (const_rtx x)\n     return 0;\n \n   regno = REGNO (x);\n-  rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n+  rsp = &reg_stat[regno];\n   value = rsp->last_set_value;\n \n   /* If we don't have a value, or if it isn't for this basic block and\n@@ -12674,7 +12668,7 @@ use_crosses_set_p (const_rtx x, int from_luid)\n #endif\n       for (; regno < endreg; regno++)\n \t{\n-\t  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n+\t  reg_stat_type *rsp = &reg_stat[regno];\n \t  if (rsp->last_set\n \t      && rsp->last_set_label == label_tick\n \t      && DF_INSN_LUID (rsp->last_set) > from_luid)\n@@ -12920,7 +12914,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx to_insn,\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      rtx where_dead = VEC_index (reg_stat_type, reg_stat, regno).last_death;\n+      rtx where_dead = reg_stat[regno].last_death;\n \n       /* Don't move the register if it gets killed in between from and to.  */\n       if (maybe_kill_insn && reg_set_p (x, maybe_kill_insn)\n@@ -13535,7 +13529,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  if (place && REG_NOTE_KIND (note) == REG_DEAD)\n \t    {\n \t      unsigned int regno = REGNO (XEXP (note, 0));\n-\t      reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n+\t      reg_stat_type *rsp = &reg_stat[regno];\n \n \t      if (dead_or_set_p (place, XEXP (note, 0))\n \t\t  || reg_bitfield_target_p (XEXP (note, 0), PATTERN (place)))"}, {"sha": "cc1502d8162b72555f95974236202817e04e3e95", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -120,10 +120,8 @@ struct comparison\n };\n   \n typedef struct comparison *comparison_struct_p;\n-DEF_VEC_P(comparison_struct_p);\n-DEF_VEC_ALLOC_P(comparison_struct_p, heap);\n \n-static VEC(comparison_struct_p, heap) *all_compares;\n+static vec<comparison_struct_p> all_compares;\n \n /* Look for a \"conforming\" comparison, as defined above.  If valid, return\n    the rtx for the COMPARE itself.  */\n@@ -337,7 +335,7 @@ find_comparisons_in_bb (struct dom_walk_data *data ATTRIBUTE_UNUSED,\n \t  last_cmp->in_a = XEXP (src, 0);\n \t  last_cmp->in_b = XEXP (src, 1);\n \t  last_cmp->orig_mode = src_mode;\n-\t  VEC_safe_push (comparison_struct_p, heap, all_compares, last_cmp);\n+\t  all_compares.safe_push (last_cmp);\n \n \t  /* It's unusual, but be prepared for comparison patterns that\n \t     also clobber an input, or perhaps a scratch.  */\n@@ -623,24 +621,23 @@ execute_compare_elim_after_reload (void)\n {\n   df_analyze ();\n \n-  gcc_checking_assert (all_compares == NULL);\n+  gcc_checking_assert (!all_compares.exists ());\n \n   /* Locate all comparisons and their uses, and eliminate duplicates.  */\n   find_comparisons ();\n-  if (all_compares)\n+  if (all_compares.exists ())\n     {\n       struct comparison *cmp;\n       size_t i;\n \n       /* Eliminate comparisons that are redundant with flags computation.  */\n-      FOR_EACH_VEC_ELT (comparison_struct_p, all_compares, i, cmp)\n+      FOR_EACH_VEC_ELT (all_compares, i, cmp)\n \t{\n \t  try_eliminate_compare (cmp);\n \t  XDELETE (cmp);\n \t}\n \n-      VEC_free (comparison_struct_p, heap, all_compares);\n-      all_compares = NULL;\n+      all_compares.release ();\n     }\n \n   return 0;"}, {"sha": "f2d8473946ed1c2d4c78ef37a7c08af56c762e46", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -3480,8 +3480,8 @@ hwloop_optimize (hwloop_info loop)\n       insn = BB_END (loop->incoming_src);\n       /* If we have to insert the LSETUP before a jump, count that jump in the\n \t length.  */\n-      if (VEC_length (edge, loop->incoming) > 1\n-\t  || !(VEC_last (edge, loop->incoming)->flags & EDGE_FALLTHRU))\n+      if (vec_safe_length (loop->incoming) > 1\n+\t  || !(loop->incoming->last ()->flags & EDGE_FALLTHRU))\n \t{\n \t  gcc_assert (JUMP_P (insn));\n \t  insn = PREV_INSN (insn);\n@@ -3749,8 +3749,8 @@ hwloop_optimize (hwloop_info loop)\n   if (loop->incoming_src)\n     {\n       rtx prev = BB_END (loop->incoming_src);\n-      if (VEC_length (edge, loop->incoming) > 1\n-\t  || !(VEC_last (edge, loop->incoming)->flags & EDGE_FALLTHRU))\n+      if (vec_safe_length (loop->incoming) > 1\n+\t  || !(loop->incoming->last ()->flags & EDGE_FALLTHRU))\n \t{\n \t  gcc_assert (JUMP_P (prev));\n \t  prev = PREV_INSN (prev);"}, {"sha": "175e119b688ea8b3421ec3c791f8bf7057f78b2c", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -119,14 +119,12 @@ typedef struct\n   unsigned int unit_mask;\n } c6x_sched_insn_info;\n \n-DEF_VEC_O(c6x_sched_insn_info);\n-DEF_VEC_ALLOC_O(c6x_sched_insn_info, heap);\n \n /* Record a c6x_sched_insn_info structure for every insn in the function.  */\n-static VEC(c6x_sched_insn_info, heap) *insn_info;\n+static vec<c6x_sched_insn_info> insn_info;\n \n-#define INSN_INFO_LENGTH (VEC_length (c6x_sched_insn_info, insn_info))\n-#define INSN_INFO_ENTRY(N) (VEC_index (c6x_sched_insn_info, insn_info, (N)))\n+#define INSN_INFO_LENGTH (insn_info).length ()\n+#define INSN_INFO_ENTRY(N) (insn_info[(N)])\n \n static bool done_cfi_sections;\n \n@@ -1971,7 +1969,7 @@ c6x_get_unit_specifier (rtx insn)\n {\n   enum attr_units units;\n \n-  if (insn_info)\n+  if (insn_info.exists ())\n     {\n       int unit = INSN_INFO_ENTRY (INSN_UID (insn)).reservation;\n       return c6x_unit_names[unit][0];\n@@ -2023,7 +2021,7 @@ c6x_print_unit_specifier_field (FILE *file, rtx insn)\n       return;\n     }\n \n-  if (insn_info)\n+  if (insn_info.exists ())\n     {\n       int unit = INSN_INFO_ENTRY (INSN_UID (insn)).reservation;\n       fputs (\".\", file);\n@@ -3422,7 +3420,7 @@ try_rename_operands (rtx head, rtx tail, unit_req_table reqs, rtx insn,\n   int i;\n   unsigned tmp_mask;\n   int best_reg, old_reg;\n-  VEC (du_head_p, heap) *involved_chains = NULL;\n+  vec<du_head_p> involved_chains = vec<du_head_p>();\n   unit_req_table new_reqs;\n \n   for (i = 0, tmp_mask = op_mask; tmp_mask; i++)\n@@ -3433,23 +3431,22 @@ try_rename_operands (rtx head, rtx tail, unit_req_table reqs, rtx insn,\n       if (info->op_info[i].n_chains != 1)\n \tgoto out_fail;\n       op_chain = regrename_chain_from_id (info->op_info[i].heads[0]->id);\n-      VEC_safe_push (du_head_p, heap, involved_chains, op_chain);\n+      involved_chains.safe_push (op_chain);\n       tmp_mask &= ~(1 << i);\n     }\n \n-  if (VEC_length (du_head_p, involved_chains) > 1)\n+  if (involved_chains.length () > 1)\n     goto out_fail;\n \n-  this_head = VEC_index (du_head_p, involved_chains, 0);\n+  this_head = involved_chains[0];\n   if (this_head->cannot_rename)\n     goto out_fail;\n \n   for (chain = this_head->first; chain; chain = chain->next_use)\n     {\n       unsigned int mask1, mask2, mask_changed;\n       int count, side1, side2, req1, req2;\n-      insn_rr_info *this_rr = &VEC_index (insn_rr_info, insn_rr,\n-\t\t\t\t\t  INSN_UID (chain->insn));\n+      insn_rr_info *this_rr = &insn_rr[INSN_UID (chain->insn)];\n \n       count = get_unit_reqs (chain->insn, &req1, &side1, &req2, &side2);\n \n@@ -3508,7 +3505,7 @@ try_rename_operands (rtx head, rtx tail, unit_req_table reqs, rtx insn,\n     memcpy (reqs, new_reqs, sizeof (unit_req_table));\n \n  out_fail:\n-  VEC_free (du_head_p, heap, involved_chains);\n+  involved_chains.release ();\n }\n \n /* Find insns in LOOP which would, if shifted to the other side\n@@ -3555,7 +3552,7 @@ reshuffle_units (basic_block loop)\n       if (!get_unit_operand_masks (insn, &mask1, &mask2))\n \tcontinue;\n \n-      info = &VEC_index (insn_rr_info, insn_rr, INSN_UID (insn));\n+      info = &insn_rr[INSN_UID (insn)];\n       if (info->op_info == NULL)\n \tcontinue;\n \n@@ -3707,7 +3704,7 @@ insn_set_clock (rtx insn, int cycle)\n   unsigned uid = INSN_UID (insn);\n \n   if (uid >= INSN_INFO_LENGTH)\n-    VEC_safe_grow (c6x_sched_insn_info, heap, insn_info, uid * 5 / 4 + 10);\n+    insn_info.safe_grow (uid * 5 / 4 + 10);\n \n   INSN_INFO_ENTRY (uid).clock = cycle;\n   INSN_INFO_ENTRY (uid).new_cond = NULL;\n@@ -4361,7 +4358,7 @@ c6x_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n     ss.last_scheduled_iter0 = insn;\n   if (GET_CODE (PATTERN (insn)) != USE && GET_CODE (PATTERN (insn)) != CLOBBER)\n     ss.issued_this_cycle++;\n-  if (insn_info)\n+  if (insn_info.exists ())\n     {\n       state_t st_after = alloca (dfa_state_size);\n       int curr_clock = ss.curr_sched_clock;\n@@ -5537,7 +5534,7 @@ hwloop_optimize (hwloop_info loop)\n   gcc_assert (loop->incoming_dest == loop->head);\n \n   entry_edge = NULL;\n-  FOR_EACH_VEC_ELT (edge, loop->incoming, i, entry_edge)\n+  FOR_EACH_VEC_SAFE_ELT (loop->incoming, i, entry_edge)\n     if (entry_edge->flags & EDGE_FALLTHRU)\n       break;\n   if (entry_edge == NULL)\n@@ -5777,7 +5774,7 @@ hwloop_optimize (hwloop_info loop)\n \n   seq = get_insns ();\n \n-  if (!single_succ_p (entry_bb) || VEC_length (edge, loop->incoming) > 1)\n+  if (!single_succ_p (entry_bb) || vec_safe_length (loop->incoming) > 1)\n     {\n       basic_block new_bb;\n       edge e;\n@@ -5809,7 +5806,7 @@ hwloop_optimize (hwloop_info loop)\n   end_sequence ();\n \n   /* Make sure we don't try to schedule this loop again.  */\n-  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n+  for (ix = 0; loop->blocks.iterate (ix, &bb); ix++)\n     bb->flags |= BB_DISABLE_SCHEDULE;\n \n   return true;\n@@ -5928,7 +5925,7 @@ c6x_reorg (void)\n     {\n       int sz = get_max_uid () * 3 / 2 + 1;\n \n-      insn_info = VEC_alloc (c6x_sched_insn_info, heap, sz);\n+      insn_info.create (sz);\n     }\n \n   /* Make sure the real-jump insns we create are not deleted.  When modulo-\n@@ -5993,9 +5990,7 @@ c6x_function_end (FILE *file, const char *fname)\n {\n   c6x_output_fn_unwind (file);\n \n-  if (insn_info)\n-    VEC_free (c6x_sched_insn_info, heap, insn_info);\n-  insn_info = NULL;\n+  insn_info.release ();\n \n   if (!flag_inhibit_size_directive)\n     ASM_OUTPUT_MEASURED_SIZE (file, fname);"}, {"sha": "6645270a380a4e9cf86e0434f0f8436131701822", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1791,10 +1791,8 @@ static unsigned int lto_section_num = 0;\n typedef struct GTY (()) darwin_lto_section_e {\n   const char *sectname;\n } darwin_lto_section_e ;\n-DEF_VEC_O(darwin_lto_section_e);\n-DEF_VEC_ALLOC_O(darwin_lto_section_e, gc);\n \n-static GTY (()) VEC (darwin_lto_section_e, gc) * lto_section_names;\n+static GTY (()) vec<darwin_lto_section_e, va_gc> *lto_section_names;\n \n /* Segment for LTO data.  */\n #define LTO_SEGMENT_NAME \"__GNU_LTO\"\n@@ -1877,8 +1875,8 @@ darwin_asm_named_section (const char *name,\n          TODO: check that we do not revisit sections, that would break\n          the assumption of how this is done.  */\n       if (lto_section_names == NULL)\n-        lto_section_names = VEC_alloc (darwin_lto_section_e, gc, 16);\n-      VEC_safe_push (darwin_lto_section_e, gc, lto_section_names, e);\n+        vec_alloc (lto_section_names, 16);\n+      vec_safe_push (lto_section_names, e);\n    }\n   else if (strncmp (name, \"__DWARF,\", 8) == 0)\n     darwin_asm_dwarf_section (name, flags, decl);\n@@ -2635,7 +2633,7 @@ darwin_assemble_visibility (tree decl, int vis)\n \t     \"not supported in this configuration; ignored\");\n }\n \n-/* VEC Used by darwin_asm_dwarf_section.\n+/* vec used by darwin_asm_dwarf_section.\n    Maybe a hash tab would be better here - but the intention is that this is\n    a very short list (fewer than 16 items) and each entry should (ideally, \n    eventually) only be presented once.\n@@ -2648,11 +2646,9 @@ typedef struct GTY(()) dwarf_sect_used_entry {\n }\n dwarf_sect_used_entry;\n \n-DEF_VEC_O(dwarf_sect_used_entry);\n-DEF_VEC_ALLOC_O(dwarf_sect_used_entry, gc);\n \n /* A list of used __DWARF sections.  */\n-static GTY (()) VEC (dwarf_sect_used_entry, gc) * dwarf_sect_names_table;\n+static GTY (()) vec<dwarf_sect_used_entry, va_gc> *dwarf_sect_names_table;\n \n /* This is called when we are asked to assemble a named section and the \n    name begins with __DWARF,.  We keep a list of the section names (without\n@@ -2675,10 +2671,10 @@ darwin_asm_dwarf_section (const char *name, unsigned int flags,\n   namelen = strchr (sname, ',') - sname;\n   gcc_assert (namelen);\n   if (dwarf_sect_names_table == NULL)\n-    dwarf_sect_names_table = VEC_alloc (dwarf_sect_used_entry, gc, 16);\n+    vec_alloc (dwarf_sect_names_table, 16);\n   else\n     for (i = 0; \n-\t VEC_iterate (dwarf_sect_used_entry, dwarf_sect_names_table, i, ref);\n+\t dwarf_sect_names_table->iterate (i, &ref);\n \t i++)\n       {\n \tif (!ref)\n@@ -2698,7 +2694,7 @@ darwin_asm_dwarf_section (const char *name, unsigned int flags,\n       fprintf (asm_out_file, \"Lsection%.*s:\\n\", namelen, sname);\n       e.count = 1;\n       e.name = xstrdup (sname);\n-      VEC_safe_push (dwarf_sect_used_entry, gc, dwarf_sect_names_table, e);\n+      vec_safe_push (dwarf_sect_names_table, e);\n     }\n }\n \n@@ -2813,7 +2809,7 @@ darwin_file_end (void)\n     }\n \n   /* Output the names and indices.  */\n-  if (lto_section_names && VEC_length (darwin_lto_section_e, lto_section_names))\n+  if (lto_section_names && lto_section_names->length ())\n     {\n       int count;\n       darwin_lto_section_e *ref;\n@@ -2824,7 +2820,7 @@ darwin_file_end (void)\n       /* Emit the names.  */\n       fprintf (asm_out_file, \"\\t.section %s,%s,regular,debug\\n\",\n \t       LTO_SEGMENT_NAME, LTO_NAMES_SECTION);\n-      FOR_EACH_VEC_ELT (darwin_lto_section_e, lto_section_names, count, ref)\n+      FOR_EACH_VEC_ELT (*lto_section_names, count, ref)\n \t{\n \t  fprintf (asm_out_file, \"L_GNU_LTO_NAME%d:\\n\", count);\n          /* We have to jump through hoops to get the values of the intra-section\n@@ -2847,7 +2843,7 @@ darwin_file_end (void)\n       fputs (\"\\t.align\\t2\\n\", asm_out_file);\n       fputs (\"# Section offset, Section length, Name offset, Name length\\n\",\n \t     asm_out_file);\n-      FOR_EACH_VEC_ELT (darwin_lto_section_e, lto_section_names, count, ref)\n+      FOR_EACH_VEC_ELT (*lto_section_names, count, ref)\n \t{\n \t  fprintf (asm_out_file, \"%s L$gnu$lto$offs%d\\t;# %s\\n\",\n \t\t   op, count, ref->sectname);\n@@ -3338,7 +3334,7 @@ darwin_build_constant_cfstring (tree str)\n   if (!desc)\n     {\n       tree var, constructor, field;\n-      VEC(constructor_elt,gc) *v = NULL;\n+      vec<constructor_elt, va_gc> *v = NULL;\n       int length = TREE_STRING_LENGTH (str) - 1;\n \n       if (darwin_warn_nonportable_cfstrings)"}, {"sha": "970455374974f89b44fe027e1950374264c8a095", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -56,12 +56,12 @@ resolve_sw_modes (void)\n {\n   basic_block bb;\n   rtx insn, src;\n-  VEC (basic_block, heap) *todo;\n+  vec<basic_block> todo;\n   sbitmap pushed;\n   bool need_commit = false;\n   bool finalize_fp_sets = (MACHINE_FUNCTION (cfun)->unknown_mode_sets == 0);\n \n-  todo = VEC_alloc (basic_block, heap, last_basic_block);\n+  todo.create (last_basic_block);\n   pushed = sbitmap_alloc (last_basic_block);\n   bitmap_clear (pushed);\n   if (!finalize_fp_sets)\n@@ -98,17 +98,17 @@ resolve_sw_modes (void)\n \t       checking the total frequency of the affected edges.  */\n \t    selected_mode = (enum attr_fp_mode) epiphany_normal_fp_rounding;\n \n-\t    VEC_quick_push (basic_block, todo, bb);\n+\t    todo.quick_push (bb);\n \t    bitmap_set_bit (pushed, bb->index);\n \t  }\n \tXVECEXP (XEXP (src, 0), 0, 0) = GEN_INT (selected_mode);\n \tSET_SRC (XVECEXP (PATTERN (insn), 0, 1)) = copy_rtx (src);\n \tSET_SRC (XVECEXP (PATTERN (insn), 0, 2)) = copy_rtx (src);\n \tdf_insn_rescan (insn);\n       }\n-  while (VEC_length (basic_block, todo))\n+  while (todo.length ())\n     {\n-      basic_block bb = VEC_pop (basic_block, todo);\n+      basic_block bb = todo.pop ();\n       int selected_reg, jilted_reg;\n       enum attr_fp_mode jilted_mode;\n       edge e;\n@@ -141,7 +141,7 @@ resolve_sw_modes (void)\n \t    {\n \t      if (bitmap_bit_p (pushed, succ->index))\n \t\tcontinue;\n-\t      VEC_quick_push (basic_block, todo, succ);\n+\t      todo.quick_push (succ);\n \t      bitmap_set_bit (pushed, bb->index);\n \t      continue;\n \t    }\n@@ -154,7 +154,7 @@ resolve_sw_modes (void)\n \t  insert_insn_on_edge (seq, e);\n \t}\n     }\n-  VEC_free (basic_block, heap, todo);\n+  todo.release ();\n   sbitmap_free (pushed);\n   if (need_commit)\n     commit_edge_insertions ();"}, {"sha": "4bc105dc8560fa87f86821338e07a37492764ca4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -28737,7 +28737,7 @@ dispatch_function_versions (tree dispatch_decl,\n   gimple_seq gseq;\n   int ix;\n   tree ele;\n-  VEC (tree, heap) *fndecls;\n+  vec<tree> *fndecls;\n   unsigned int num_versions = 0;\n   unsigned int actual_versions = 0;\n   unsigned int i;\n@@ -28754,33 +28754,33 @@ dispatch_function_versions (tree dispatch_decl,\n \t      && empty_bb != NULL);\n \n   /*fndecls_p is actually a vector.  */\n-  fndecls = (VEC (tree, heap) *)fndecls_p;\n+  fndecls = static_cast<vec<tree> *> (fndecls_p);\n \n   /* At least one more version other than the default.  */\n-  num_versions = VEC_length (tree, fndecls);\n+  num_versions = fndecls->length ();\n   gcc_assert (num_versions >= 2);\n \n   function_version_info = (struct _function_version_info *)\n     XNEWVEC (struct _function_version_info, (num_versions - 1));\n \n   /* The first version in the vector is the default decl.  */\n-  default_decl = VEC_index (tree, fndecls, 0);\n+  default_decl = (*fndecls)[0];\n \n   push_cfun (DECL_STRUCT_FUNCTION (dispatch_decl));\n \n   gseq = bb_seq (*empty_bb);\n   /* Function version dispatch is via IFUNC.  IFUNC resolvers fire before\n      constructors, so explicity call __builtin_cpu_init here.  */\n   ifunc_cpu_init_stmt = gimple_build_call_vec (\n-                     ix86_builtins [(int) IX86_BUILTIN_CPU_INIT], NULL);\n+                     ix86_builtins [(int) IX86_BUILTIN_CPU_INIT], vec<tree>());\n   gimple_seq_add_stmt (&gseq, ifunc_cpu_init_stmt);\n   gimple_set_bb (ifunc_cpu_init_stmt, *empty_bb);\n   set_bb_seq (*empty_bb, gseq);\n \n   pop_cfun ();\n \n \n-  for (ix = 1; VEC_iterate (tree, fndecls, ix, ele); ++ix)\n+  for (ix = 1; fndecls->iterate (ix, &ele); ++ix)\n     {\n       tree version_decl = ele;\n       tree predicate_chain = NULL_TREE;\n@@ -29276,7 +29276,7 @@ ix86_generate_version_dispatcher_body (void *node_p)\n {\n   tree resolver_decl;\n   basic_block empty_bb;\n-  VEC (tree, heap) *fn_ver_vec = NULL;\n+  vec<tree> fn_ver_vec = vec<tree>();\n   tree default_ver_decl;\n   struct cgraph_node *versn;\n   struct cgraph_node *node;\n@@ -29306,7 +29306,7 @@ ix86_generate_version_dispatcher_body (void *node_p)\n \n   push_cfun (DECL_STRUCT_FUNCTION (resolver_decl));\n \n-  fn_ver_vec = VEC_alloc (tree, heap, 2);\n+  fn_ver_vec.create (2);\n \n   for (versn_info = node_version_info->next; versn_info;\n        versn_info = versn_info->next)\n@@ -29320,10 +29320,10 @@ ix86_generate_version_dispatcher_body (void *node_p)\n       if (DECL_VINDEX (versn->symbol.decl))\n         error_at (DECL_SOURCE_LOCATION (versn->symbol.decl),\n \t\t  \"Virtual function multiversioning not supported\");\n-      VEC_safe_push (tree, heap, fn_ver_vec, versn->symbol.decl);\n+      fn_ver_vec.safe_push (versn->symbol.decl);\n     }\n \n-  dispatch_function_versions (resolver_decl, fn_ver_vec, &empty_bb);\n+  dispatch_function_versions (resolver_decl, &fn_ver_vec, &empty_bb);\n \n   rebuild_cgraph_edges (); \n   pop_cfun ();"}, {"sha": "9a7528f346a93a60056bd45ed5ead226726cdb15", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -5937,21 +5937,22 @@ ia64_option_override (void)\n {\n   unsigned int i;\n   cl_deferred_option *opt;\n-  VEC(cl_deferred_option,heap) *vec\n-    = (VEC(cl_deferred_option,heap) *) ia64_deferred_options;\n+  vec<cl_deferred_option> *v\n+    = (vec<cl_deferred_option> *) ia64_deferred_options;\n \n-  FOR_EACH_VEC_ELT (cl_deferred_option, vec, i, opt)\n-    {\n-      switch (opt->opt_index)\n-\t{\n-\tcase OPT_mfixed_range_:\n-\t  fix_range (opt->arg);\n-\t  break;\n+  if (v)\n+    FOR_EACH_VEC_ELT (*v, i, opt)\n+      {\n+\tswitch (opt->opt_index)\n+\t  {\n+\t  case OPT_mfixed_range_:\n+\t    fix_range (opt->arg);\n+\t    break;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n \n   if (TARGET_AUTO_PIC)\n     target_flags |= MASK_CONST_GP;"}, {"sha": "a44e521594e912e6a2f6a71fb50fa33222cb9bd3", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -300,54 +300,54 @@ mep_option_override (void)\n   unsigned int i;\n   int j;\n   cl_deferred_option *opt;\n-  VEC(cl_deferred_option,heap) *vec\n-    = (VEC(cl_deferred_option,heap) *) mep_deferred_options;\n+  vec<cl_deferred_option> *v = (vec<cl_deferred_option> *) mep_deferred_options;\n \n-  FOR_EACH_VEC_ELT (cl_deferred_option, vec, i, opt)\n-    {\n-      switch (opt->opt_index)\n-\t{\n-\tcase OPT_mivc2:\n-\t  for (j = 0; j < 32; j++)\n-\t    fixed_regs[j + 48] = 0;\n-\t  for (j = 0; j < 32; j++)\n-\t    call_used_regs[j + 48] = 1;\n-\t  for (j = 6; j < 8; j++)\n-\t    call_used_regs[j + 48] = 0;\n+  if (v)\n+    FOR_EACH_VEC_ELT (*v, i, opt)\n+      {\n+\tswitch (opt->opt_index)\n+\t  {\n+\t  case OPT_mivc2:\n+\t    for (j = 0; j < 32; j++)\n+\t      fixed_regs[j + 48] = 0;\n+\t    for (j = 0; j < 32; j++)\n+\t      call_used_regs[j + 48] = 1;\n+\t    for (j = 6; j < 8; j++)\n+\t      call_used_regs[j + 48] = 0;\n \n #define RN(n,s) reg_names[FIRST_CCR_REGNO + n] = s\n-\t  RN (0, \"$csar0\");\n-\t  RN (1, \"$cc\");\n-\t  RN (4, \"$cofr0\");\n-\t  RN (5, \"$cofr1\");\n-\t  RN (6, \"$cofa0\");\n-\t  RN (7, \"$cofa1\");\n-\t  RN (15, \"$csar1\");\n-\n-\t  RN (16, \"$acc0_0\");\n-\t  RN (17, \"$acc0_1\");\n-\t  RN (18, \"$acc0_2\");\n-\t  RN (19, \"$acc0_3\");\n-\t  RN (20, \"$acc0_4\");\n-\t  RN (21, \"$acc0_5\");\n-\t  RN (22, \"$acc0_6\");\n-\t  RN (23, \"$acc0_7\");\n-\n-\t  RN (24, \"$acc1_0\");\n-\t  RN (25, \"$acc1_1\");\n-\t  RN (26, \"$acc1_2\");\n-\t  RN (27, \"$acc1_3\");\n-\t  RN (28, \"$acc1_4\");\n-\t  RN (29, \"$acc1_5\");\n-\t  RN (30, \"$acc1_6\");\n-\t  RN (31, \"$acc1_7\");\n+\t    RN (0, \"$csar0\");\n+\t    RN (1, \"$cc\");\n+\t    RN (4, \"$cofr0\");\n+\t    RN (5, \"$cofr1\");\n+\t    RN (6, \"$cofa0\");\n+\t    RN (7, \"$cofa1\");\n+\t    RN (15, \"$csar1\");\n+\n+\t    RN (16, \"$acc0_0\");\n+\t    RN (17, \"$acc0_1\");\n+\t    RN (18, \"$acc0_2\");\n+\t    RN (19, \"$acc0_3\");\n+\t    RN (20, \"$acc0_4\");\n+\t    RN (21, \"$acc0_5\");\n+\t    RN (22, \"$acc0_6\");\n+\t    RN (23, \"$acc0_7\");\n+\n+\t    RN (24, \"$acc1_0\");\n+\t    RN (25, \"$acc1_1\");\n+\t    RN (26, \"$acc1_2\");\n+\t    RN (27, \"$acc1_3\");\n+\t    RN (28, \"$acc1_4\");\n+\t    RN (29, \"$acc1_5\");\n+\t    RN (30, \"$acc1_6\");\n+\t    RN (31, \"$acc1_7\");\n #undef RN\n-\t  break;\n+\t    break;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n \n   if (flag_pic == 1)\n     warning (OPT_fpic, \"-fpic is not supported\");"}, {"sha": "78c5a884ac7afbb942d438df0b7921a2f6f8af7e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -4012,12 +4012,8 @@ struct mips_multi_member {\n };\n typedef struct mips_multi_member mips_multi_member;\n \n-/* Vector definitions for the above.  */\n-DEF_VEC_O(mips_multi_member);\n-DEF_VEC_ALLOC_O(mips_multi_member, heap);\n-\n /* The instructions that make up the current multi-insn sequence.  */\n-static VEC (mips_multi_member, heap) *mips_multi_members;\n+static vec<mips_multi_member> mips_multi_members;\n \n /* How many instructions (as opposed to labels) are in the current\n    multi-insn sequence.  */\n@@ -4028,7 +4024,7 @@ static unsigned int mips_multi_num_insns;\n static void\n mips_multi_start (void)\n {\n-  VEC_truncate (mips_multi_member, mips_multi_members, 0);\n+  mips_multi_members.truncate (0);\n   mips_multi_num_insns = 0;\n }\n \n@@ -4038,7 +4034,7 @@ static struct mips_multi_member *\n mips_multi_add (void)\n {\n   mips_multi_member empty;\n-  return VEC_safe_push (mips_multi_member, heap, mips_multi_members, empty);\n+  return mips_multi_members.safe_push (empty);\n }\n \n /* Add a normal insn with the given asm format to the current multi-insn\n@@ -4081,7 +4077,7 @@ mips_multi_add_label (const char *label)\n static unsigned int\n mips_multi_last_index (void)\n {\n-  return VEC_length (mips_multi_member, mips_multi_members) - 1;\n+  return mips_multi_members.length () - 1;\n }\n \n /* Add a copy of an existing instruction to the current multi-insn\n@@ -4093,8 +4089,7 @@ mips_multi_copy_insn (unsigned int i)\n   struct mips_multi_member *member;\n \n   member = mips_multi_add ();\n-  memcpy (member, &VEC_index (mips_multi_member, mips_multi_members, i),\n-\t  sizeof (*member));\n+  memcpy (member, &mips_multi_members[i], sizeof (*member));\n   gcc_assert (!member->is_label_p);\n }\n \n@@ -4105,7 +4100,7 @@ mips_multi_copy_insn (unsigned int i)\n static void\n mips_multi_set_operand (unsigned int i, unsigned int op, rtx x)\n {\n-  VEC_index (mips_multi_member, mips_multi_members, i).operands[op] = x;\n+  mips_multi_members[i].operands[op] = x;\n }\n \n /* Write out the asm code for the current multi-insn sequence.  */\n@@ -4116,7 +4111,7 @@ mips_multi_write (void)\n   struct mips_multi_member *member;\n   unsigned int i;\n \n-  FOR_EACH_VEC_ELT (mips_multi_member, mips_multi_members, i, member)\n+  FOR_EACH_VEC_ELT (mips_multi_members, i, member)\n     if (member->is_label_p)\n       fprintf (asm_out_file, \"%s\\n\", member->format);\n     else"}, {"sha": "8b93aa9e5ad397f5ecfa76a7ef22677e3f39fa70", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -469,21 +469,22 @@ pa_option_override (void)\n {\n   unsigned int i;\n   cl_deferred_option *opt;\n-  VEC(cl_deferred_option,heap) *vec\n-    = (VEC(cl_deferred_option,heap) *) pa_deferred_options;\n+  vec<cl_deferred_option> *v\n+    = (vec<cl_deferred_option> *) pa_deferred_options;\n \n-  FOR_EACH_VEC_ELT (cl_deferred_option, vec, i, opt)\n-    {\n-      switch (opt->opt_index)\n-\t{\n-\tcase OPT_mfixed_range_:\n-\t  fix_range (opt->arg);\n-\t  break;\n+  if (v)\n+    FOR_EACH_VEC_ELT (*v, i, opt)\n+      {\n+\tswitch (opt->opt_index)\n+\t  {\n+\t  case OPT_mfixed_range_:\n+\t    fix_range (opt->arg);\n+\t    break;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n \n   /* Unconditional branches in the delay slot are not compatible with dwarf2\n      call frame information.  There is no benefit in using this optimization\n@@ -4401,7 +4402,7 @@ hppa_pic_save_rtx (void)\n \n \n /* Vector of funcdef numbers.  */\n-static VEC(int,heap) *funcdef_nos;\n+static vec<int> funcdef_nos;\n \n /* Output deferred profile counters.  */\n static void\n@@ -4410,20 +4411,20 @@ output_deferred_profile_counters (void)\n   unsigned int i;\n   int align, n;\n \n-  if (VEC_empty (int, funcdef_nos))\n+  if (funcdef_nos.is_empty ())\n    return;\n \n   switch_to_section (data_section);\n   align = MIN (BIGGEST_ALIGNMENT, LONG_TYPE_SIZE);\n   ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n \n-  for (i = 0; VEC_iterate (int, funcdef_nos, i, n); i++)\n+  for (i = 0; funcdef_nos.iterate (i, &n); i++)\n     {\n       targetm.asm_out.internal_label (asm_out_file, \"LP\", n);\n       assemble_integer (const0_rtx, LONG_TYPE_SIZE / BITS_PER_UNIT, align, 1);\n     }\n \n-  VEC_free (int, heap, funcdef_nos);\n+  funcdef_nos.release ();\n }\n \n void\n@@ -4465,7 +4466,7 @@ hppa_profile_hook (int label_no)\n     rtx count_label_rtx, addr, r24;\n     char count_label_name[16];\n \n-    VEC_safe_push (int, heap, funcdef_nos, label_no);\n+    funcdef_nos.safe_push (label_no);\n     ASM_GENERATE_INTERNAL_LABEL (count_label_name, \"LP\", label_no);\n     count_label_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (count_label_name));\n \n@@ -9948,11 +9949,9 @@ typedef struct GTY(()) extern_symbol\n } extern_symbol;\n \n /* Define gc'd vector type for extern_symbol.  */\n-DEF_VEC_O(extern_symbol);\n-DEF_VEC_ALLOC_O(extern_symbol,gc);\n \n /* Vector of extern_symbol pointers.  */\n-static GTY(()) VEC(extern_symbol,gc) *extern_symbols;\n+static GTY(()) vec<extern_symbol, va_gc> *extern_symbols;\n \n #ifdef ASM_OUTPUT_EXTERNAL_REAL\n /* Mark DECL (name NAME) as an external reference (assembler output\n@@ -9964,7 +9963,7 @@ pa_hpux_asm_output_external (FILE *file, tree decl, const char *name)\n {\n   gcc_assert (file == asm_out_file);\n   extern_symbol p = {decl, name};\n-  VEC_safe_push (extern_symbol, gc, extern_symbols, p);\n+  vec_safe_push (extern_symbols, p);\n }\n \n /* Output text required at the end of an assembler file.\n@@ -9982,7 +9981,7 @@ pa_hpux_file_end (void)\n \n   output_deferred_plabels ();\n \n-  for (i = 0; VEC_iterate (extern_symbol, extern_symbols, i, p); i++)\n+  for (i = 0; vec_safe_iterate (extern_symbols, i, &p); i++)\n     {\n       tree decl = p->decl;\n \n@@ -9991,7 +9990,7 @@ pa_hpux_file_end (void)\n \tASM_OUTPUT_EXTERNAL_REAL (asm_out_file, decl, p->name);\n     }\n \n-  VEC_free (extern_symbol, gc, extern_symbols);\n+  vec_free (extern_symbols);\n }\n #endif\n "}, {"sha": "79da7a62db32822c46cf565ec2d0d73786c1c58e", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -3505,8 +3505,8 @@ tree\n altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\t    void *passed_arglist)\n {\n-  VEC(tree,gc) *arglist = (VEC(tree,gc) *) passed_arglist;\n-  unsigned int nargs = VEC_length (tree, arglist);\n+  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n+  unsigned int nargs = vec_safe_length (arglist);\n   enum rs6000_builtins fcode\n     = (enum rs6000_builtins)DECL_FUNCTION_CODE (fndecl);\n   tree fnargs = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n@@ -3529,7 +3529,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       int size;\n       int i;\n       bool unsigned_p;\n-      VEC(constructor_elt,gc) *vec;\n+      vec<constructor_elt, va_gc> *vec;\n       const char *name = fcode == ALTIVEC_BUILTIN_VEC_SPLATS ? \"vec_splats\": \"vec_promote\";\n \n       if (nargs == 0)\n@@ -3549,10 +3549,10 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t}\n       /* Ignore promote's element argument.  */\n       if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE\n-\t  && !INTEGRAL_TYPE_P (TREE_TYPE (VEC_index (tree, arglist, 1))))\n+\t  && !INTEGRAL_TYPE_P (TREE_TYPE ((*arglist)[1])))\n \tgoto bad;\n \n-      arg = VEC_index (tree, arglist, 0);\n+      arg = (*arglist)[0];\n       type = TREE_TYPE (arg);\n       if (!SCALAR_FLOAT_TYPE_P (type)\n \t  && !INTEGRAL_TYPE_P (type))\n@@ -3582,11 +3582,11 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    goto bad;\n \t}\n       arg = save_expr (fold_convert (TREE_TYPE (type), arg));\n-      vec = VEC_alloc (constructor_elt, gc, size);\n+      vec_alloc (vec, size);\n       for(i = 0; i < size; i++)\n \t{\n \t  constructor_elt elt = {NULL_TREE, arg};\n-\t  VEC_quick_push (constructor_elt, vec, elt);\n+\t  vec->quick_push (elt);\n \t}\n \treturn build_constructor (type, vec);\n     }\n@@ -3610,8 +3610,8 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  return error_mark_node;\n \t}\n \n-      arg2 = VEC_index (tree, arglist, 1);\n-      arg1 = VEC_index (tree, arglist, 0);\n+      arg2 = (*arglist)[1];\n+      arg1 = (*arglist)[0];\n       arg1_type = TREE_TYPE (arg1);\n \n       if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n@@ -3686,10 +3686,10 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  return error_mark_node;\n \t}\n \n-      arg0 = VEC_index (tree, arglist, 0);\n-      arg1 = VEC_index (tree, arglist, 1);\n+      arg0 = (*arglist)[0];\n+      arg1 = (*arglist)[1];\n       arg1_type = TREE_TYPE (arg1);\n-      arg2 = VEC_index (tree, arglist, 2);\n+      arg2 = (*arglist)[2];\n \n       if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n \tgoto bad; \n@@ -3752,7 +3752,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n        fnargs = TREE_CHAIN (fnargs), n++)\n     {\n       tree decl_type = TREE_VALUE (fnargs);\n-      tree arg = VEC_index (tree, arglist, n);\n+      tree arg = (*arglist)[n];\n       tree type;\n \n       if (arg == error_mark_node)"}, {"sha": "4bde3201a54421fecff819e9b360d163aa1901cf", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -24928,10 +24928,8 @@ typedef struct branch_island_d {\n   int line_number;\n } branch_island;\n \n-DEF_VEC_O(branch_island);\n-DEF_VEC_ALLOC_O(branch_island,gc);\n \n-static VEC(branch_island,gc) *branch_islands;\n+static vec<branch_island, va_gc> *branch_islands;\n \n /* Remember to generate a branch island for far calls to the given\n    function.  */\n@@ -24941,7 +24939,7 @@ add_compiler_branch_island (tree label_name, tree function_name,\n \t\t\t    int line_number)\n {\n   branch_island bi = {function_name, label_name, line_number};\n-  VEC_safe_push (branch_island, gc, branch_islands, bi);\n+  vec_safe_push (branch_islands, bi);\n }\n \n /* Generate far-jump branch islands for everything recorded in\n@@ -24955,9 +24953,9 @@ macho_branch_islands (void)\n {\n   char tmp_buf[512];\n \n-  while (!VEC_empty (branch_island, branch_islands))\n+  while (!vec_safe_is_empty (branch_islands))\n     {\n-      branch_island *bi = &VEC_last (branch_island, branch_islands);\n+      branch_island *bi = &branch_islands->last ();\n       const char *label = IDENTIFIER_POINTER (bi->label_name);\n       const char *name = IDENTIFIER_POINTER (bi->function_name);\n       char name_buf[512];\n@@ -25025,7 +25023,7 @@ macho_branch_islands (void)\n       if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n \tdbxout_stabd (N_SLINE, bi->line_number);\n #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n-      VEC_pop (branch_island, branch_islands);\n+      branch_islands->pop ();\n     }\n }\n \n@@ -25038,7 +25036,7 @@ no_previous_def (tree function_name)\n   branch_island *bi;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (branch_island, branch_islands, ix, bi)\n+  FOR_EACH_VEC_SAFE_ELT (branch_islands, ix, bi)\n     if (function_name == bi->function_name)\n       return 0;\n   return 1;\n@@ -25053,7 +25051,7 @@ get_prev_label (tree function_name)\n   branch_island *bi;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (branch_island, branch_islands, ix, bi)\n+  FOR_EACH_VEC_SAFE_ELT (branch_islands, ix, bi)\n     if (function_name == bi->function_name)\n       return bi->label_name;\n   return NULL_TREE;"}, {"sha": "8cd9253e4d588bb0cd9aaf419fc2f04f31ab226a", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -2614,43 +2614,43 @@ rx_option_override (void)\n {\n   unsigned int i;\n   cl_deferred_option *opt;\n-  VEC(cl_deferred_option,heap) *vec\n-    = (VEC(cl_deferred_option,heap) *) rx_deferred_options;\n+  vec<cl_deferred_option> *v = (vec<cl_deferred_option> *) rx_deferred_options;\n \n-  FOR_EACH_VEC_ELT (cl_deferred_option, vec, i, opt)\n-    {\n-      switch (opt->opt_index)\n-\t{\n-\tcase OPT_mint_register_:\n-\t  switch (opt->value)\n-\t    {\n-\t    case 4:\n-\t      fixed_regs[10] = call_used_regs [10] = 1;\n-\t      /* Fall through.  */\n-\t    case 3:\n-\t      fixed_regs[11] = call_used_regs [11] = 1;\n-\t      /* Fall through.  */\n-\t    case 2:\n-\t      fixed_regs[12] = call_used_regs [12] = 1;\n-\t      /* Fall through.  */\n-\t    case 1:\n-\t      fixed_regs[13] = call_used_regs [13] = 1;\n-\t      /* Fall through.  */\n-\t    case 0:\n-\t      rx_num_interrupt_regs = opt->value;\n-\t      break;\n-\t    default:\n-\t      rx_num_interrupt_regs = 0;\n-\t      /* Error message already given because rx_handle_option\n-\t\t returned false.  */\n-\t      break;\n-\t    }\n-\t  break;\n+  if (v)\n+    FOR_EACH_VEC_ELT (*v, i, opt)\n+      {\n+\tswitch (opt->opt_index)\n+\t  {\n+\t  case OPT_mint_register_:\n+\t    switch (opt->value)\n+\t      {\n+\t      case 4:\n+\t\tfixed_regs[10] = call_used_regs [10] = 1;\n+\t\t/* Fall through.  */\n+\t      case 3:\n+\t\tfixed_regs[11] = call_used_regs [11] = 1;\n+\t\t/* Fall through.  */\n+\t      case 2:\n+\t\tfixed_regs[12] = call_used_regs [12] = 1;\n+\t\t/* Fall through.  */\n+\t      case 1:\n+\t\tfixed_regs[13] = call_used_regs [13] = 1;\n+\t\t/* Fall through.  */\n+\t      case 0:\n+\t\trx_num_interrupt_regs = opt->value;\n+\t\tbreak;\n+\t      default:\n+\t\trx_num_interrupt_regs = 0;\n+\t\t/* Error message already given because rx_handle_option\n+\t\t  returned false.  */\n+\t\tbreak;\n+\t      }\n+\t    break;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n \n   /* This target defaults to strict volatile bitfields.  */\n   if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))"}, {"sha": "6fa8d17e4670c3f1952c2657e1a8d80ea7aca6dc", "filename": "gcc/config/spu/spu-c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fspu%2Fspu-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fspu%2Fspu-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-c.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -93,8 +93,8 @@ spu_resolve_overloaded_builtin (location_t loc, tree fndecl, void *passed_args)\n #define SCALAR_TYPE_P(t) (INTEGRAL_TYPE_P (t) \\\n \t\t\t  || SCALAR_FLOAT_TYPE_P (t) \\\n \t\t\t  || POINTER_TYPE_P (t))\n-  VEC(tree,gc) *fnargs = (VEC(tree,gc) *) passed_args;\n-  unsigned int nargs = VEC_length (tree, fnargs);\n+  vec<tree, va_gc> *fnargs = static_cast <vec<tree, va_gc> *> (passed_args);\n+  unsigned int nargs = vec_safe_length (fnargs);\n   int new_fcode, fcode = DECL_FUNCTION_CODE (fndecl);\n   struct spu_builtin_description *desc;\n   tree match = NULL_TREE;\n@@ -137,7 +137,7 @@ spu_resolve_overloaded_builtin (location_t loc, tree fndecl, void *passed_args)\n \t      return error_mark_node;\n \t    }\n \n-\t  var = VEC_index (tree, fnargs, p);\n+\t  var = (*fnargs)[p];\n \n \t  if (TREE_CODE (var) == NON_LVALUE_EXPR)\n \t    var = TREE_OPERAND (var, 0);"}, {"sha": "65bf42acc5ff340256216095c5abe0de7a0e7c1b", "filename": "gcc/config/vms/vms.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fvms%2Fvms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fvms%2Fvms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvms%2Fvms.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -101,7 +101,7 @@ static const struct vms_crtl_name vms_crtl_names[] =\n \n /* List of aliased identifiers.  They must be persistent across gc.  */\n \n-static GTY(()) VEC(tree,gc) *aliases_id;\n+static GTY(()) vec<tree, va_gc> *aliases_id;\n \n /* Add a CRTL translation.  This simply use the transparent alias\n    mechanism, which is platform independent and works with the\n@@ -120,7 +120,7 @@ vms_add_crtl_xlat (const char *name, size_t nlen,\n   IDENTIFIER_TRANSPARENT_ALIAS (targ) = 1;\n   TREE_CHAIN (targ) = get_identifier_with_length (id_str, id_len);\n \n-  VEC_safe_push (tree, gc, aliases_id, targ);\n+  vec_safe_push (aliases_id, targ);\n }\n \n /* Do VMS specific stuff on builtins: disable the ones that are not"}, {"sha": "e3059044d8d6088b9bbab90b29971c1a1483f68b", "filename": "gcc/config/vxworks.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fvxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fconfig%2Fvxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -96,23 +96,24 @@ vxworks_emutls_var_fields (tree type, tree *name)\n static tree\n vxworks_emutls_var_init (tree var, tree decl, tree tmpl_addr)\n {\n-  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 3);\n+  vec<constructor_elt, va_gc> *v;\n+  vec_alloc (v, 3);\n   \n   tree type = TREE_TYPE (var);\n   tree field = TYPE_FIELDS (type);\n   \n   constructor_elt elt = {field, fold_convert (TREE_TYPE (field), tmpl_addr)};\n-  VEC_quick_push (constructor_elt, v, elt);\n+  v->quick_push (elt);\n   \n   field = DECL_CHAIN (field);\n   elt.index = field;\n   elt.value = build_int_cst (TREE_TYPE (field), 0);\n-  VEC_quick_push (constructor_elt, v, elt);\n+  v->quick_push (elt);\n   \n   field = DECL_CHAIN (field);\n   elt.index = field;\n   elt.value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n-  VEC_quick_push (constructor_elt, v, elt);\n+  v->quick_push (elt);\n   \n   return build_constructor (type, v);\n }"}, {"sha": "3bc2f404559058c644bc55b5d349e5085bf3f721", "filename": "gcc/coretypes.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -200,5 +200,8 @@ enum memmodel\n    is a pointer to a pointer, the second a cookie.  */\n typedef void (*gt_pointer_operator) (void *, void *);\n \n-#endif /* coretypes.h */\n+#if !defined (HAVE_UCHAR)\n+typedef unsigned char uchar;\n+#endif\n \n+#endif /* coretypes.h */"}, {"sha": "7581a97f35f9162814d2186dbec503453fb31d05", "filename": "gcc/coverage.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -128,9 +128,9 @@ static void build_info_type (tree, tree);\n static tree build_fn_info (const struct coverage_data *, tree, tree);\n static tree build_info (tree, tree);\n static bool coverage_obj_init (void);\n-static VEC(constructor_elt,gc) *coverage_obj_fn\n-(VEC(constructor_elt,gc) *, tree, struct coverage_data const *);\n-static void coverage_obj_finish (VEC(constructor_elt,gc) *);\n+static vec<constructor_elt, va_gc> *coverage_obj_fn\n+(vec<constructor_elt, va_gc> *, tree, struct coverage_data const *);\n+static void coverage_obj_finish (vec<constructor_elt, va_gc> *);\n \f\n /* Return the type node for gcov_type.  */\n \n@@ -764,8 +764,8 @@ build_fn_info (const struct coverage_data *data, tree type, tree key)\n   tree fields = TYPE_FIELDS (type);\n   tree ctr_type;\n   unsigned ix;\n-  VEC(constructor_elt,gc) *v1 = NULL;\n-  VEC(constructor_elt,gc) *v2 = NULL;\n+  vec<constructor_elt, va_gc> *v1 = NULL;\n+  vec<constructor_elt, va_gc> *v2 = NULL;\n \n   /* key */\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n@@ -795,7 +795,7 @@ build_fn_info (const struct coverage_data *data, tree type, tree key)\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))\n       {\n-\tVEC(constructor_elt,gc) *ctr = NULL;\n+\tvec<constructor_elt, va_gc> *ctr = NULL;\n \ttree var = data->ctr_vars[ix];\n \tunsigned count = 0;\n \n@@ -898,8 +898,8 @@ build_info (tree info_type, tree fn_ary)\n   unsigned ix;\n   tree filename_string;\n   int da_file_name_len;\n-  VEC(constructor_elt,gc) *v1 = NULL;\n-  VEC(constructor_elt,gc) *v2 = NULL;\n+  vec<constructor_elt, va_gc> *v1 = NULL;\n+  vec<constructor_elt, va_gc> *v2 = NULL;\n \n   /* Version ident */\n   CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n@@ -1043,8 +1043,8 @@ coverage_obj_init (void)\n /* Generate the coverage function info for FN and DATA.  Append a\n    pointer to that object to CTOR and return the appended CTOR.  */\n \n-static VEC(constructor_elt,gc) *\n-coverage_obj_fn (VEC(constructor_elt,gc) *ctor, tree fn,\n+static vec<constructor_elt, va_gc> *\n+coverage_obj_fn (vec<constructor_elt, va_gc> *ctor, tree fn,\n \t\t struct coverage_data const *data)\n {\n   tree init = build_fn_info (data, gcov_fn_info_type, gcov_info_var);\n@@ -1062,9 +1062,9 @@ coverage_obj_fn (VEC(constructor_elt,gc) *ctor, tree fn,\n    function objects from CTOR.  Generate the gcov_info initializer.  */\n \n static void\n-coverage_obj_finish (VEC(constructor_elt,gc) *ctor)\n+coverage_obj_finish (vec<constructor_elt, va_gc> *ctor)\n {\n-  unsigned n_functions = VEC_length(constructor_elt, ctor);\n+  unsigned n_functions = vec_safe_length (ctor);\n   tree fn_info_ary_type = build_array_type\n     (build_qualified_type (gcov_fn_info_ptr_type, TYPE_QUAL_CONST),\n      build_index_type (size_int (n_functions - 1)));\n@@ -1153,7 +1153,7 @@ coverage_finish (void)\n \n   if (coverage_obj_init ())\n     {\n-      VEC(constructor_elt,gc) *fn_ctor = NULL;\n+      vec<constructor_elt, va_gc> *fn_ctor = NULL;\n       struct coverage_data *fn;\n       \n       for (fn = functions_head; fn; fn = fn->next)"}, {"sha": "110cdc4368895e89cc0c8a06aeafd427d19d888f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1,3 +1,33 @@\n+2012-11-17  Diego Novillo  <dnovillo@google.com>\n+\n+\tAdjust for new vec API (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n+\n+\t* Make-lang.in: Remove dependencies on vecir.h and vecprim.h everywhere.\n+\t* call.c: Use new vec API in vec.h.\n+\t* class.c: Likewise.\n+\t* cp-gimplify.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* error.c: Likewise.\n+\t* except.c: Likewise.\n+\t* init.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* method.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* name-lookup.h: Likewise.\n+\t* parser.c: Likewise.\n+\t* parser.h: Likewise.\n+\t* pt.c: Likewise.\n+\t* repo.c: Likewise.\n+\t* rtti.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2012-11-17  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* semantics.c (finish_id_expression): Tidy diagnostic message."}, {"sha": "9d92f648bee14193ed52c80b0aee90aed6eb3572", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -317,7 +317,7 @@ cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n   cp/cfns.h $(TREE_INLINE_H) $(TARGET_H) gt-cp-except.h\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/cp-objcp-common.h \\\n-  toplev.h $(TREE_INLINE_H) pointer-set.h gt-cp-pt.h vecprim.h intl.h \\\n+  toplev.h $(TREE_INLINE_H) pointer-set.h gt-cp-pt.h intl.h \\\n   c-family/c-objc.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_H) \\\n   $(FLAGS_H) $(REAL_H) $(LANGHOOKS_DEF_H) $(CXX_PRETTY_PRINT_H) \\"}, {"sha": "35a3f919997653d9156f17e74bee6eb937391e96", "filename": "gcc/cp/call.c", "status": "modified", "additions": 107, "deletions": 111, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -169,14 +169,14 @@ static tree build_this (tree);\n static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n-\t(struct z_candidate **, tree, tree, tree, tree, const VEC(tree,gc) *,\n+\t(struct z_candidate **, tree, tree, tree, tree, const vec<tree, va_gc> *,\n \t tree, tree, tree, int, unification_kind_t, tsubst_flags_t);\n static struct z_candidate *add_template_candidate_real\n-\t(struct z_candidate **, tree, tree, tree, tree, const VEC(tree,gc) *,\n+\t(struct z_candidate **, tree, tree, tree, tree, const vec<tree, va_gc> *,\n \t tree, tree, tree, int, tree, unification_kind_t, tsubst_flags_t);\n static struct z_candidate *add_template_conv_candidate\n-\t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n-\t tree, tree, tsubst_flags_t);\n+\t(struct z_candidate **, tree, tree, tree, const vec<tree, va_gc> *,\n+\t tree, tree, tree, tsubst_flags_t);\n static void add_builtin_candidates\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n \t tree, tree *, int, tsubst_flags_t);\n@@ -188,10 +188,10 @@ static void build_builtin_candidate\n \t(struct z_candidate **, tree, tree, tree, tree *, tree *,\n \t int, tsubst_flags_t);\n static struct z_candidate *add_conv_candidate\n-\t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n+\t(struct z_candidate **, tree, tree, tree, const vec<tree, va_gc> *, tree,\n \t tree, tsubst_flags_t);\n static struct z_candidate *add_function_candidate\n-\t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n+\t(struct z_candidate **, tree, tree, tree, const vec<tree, va_gc> *, tree,\n \t tree, int, tsubst_flags_t);\n static conversion *implicit_conversion (tree, tree, tree, bool, int,\n \t\t\t\t\ttsubst_flags_t);\n@@ -205,7 +205,7 @@ static bool is_subseq (conversion *, conversion *);\n static conversion *maybe_handle_ref_bind (conversion **);\n static void maybe_handle_implicit_object (conversion **);\n static struct z_candidate *add_candidate\n-\t(struct z_candidate **, tree, tree, const VEC(tree,gc) *, size_t,\n+\t(struct z_candidate **, tree, tree, const vec<tree, va_gc> *, size_t,\n \t conversion **, tree, tree, int, struct rejection_reason *);\n static tree source_type (conversion *);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n@@ -215,8 +215,8 @@ static bool promoted_arithmetic_type_p (tree);\n static conversion *conditional_conversion (tree, tree, tsubst_flags_t);\n static char *name_as_c_string (tree, tree, bool *);\n static tree prep_operand (tree);\n-static void add_candidates (tree, tree, const VEC(tree,gc) *, tree, tree, bool,\n-\t\t\t    tree, tree, int, struct z_candidate **,\n+static void add_candidates (tree, tree, const vec<tree, va_gc> *, tree, tree,\n+\t\t\t    bool, tree, tree, int, struct z_candidate **,\n \t\t\t    tsubst_flags_t);\n static conversion *merge_conversion_sequences (conversion *, conversion *);\n static bool magic_varargs_p (tree);\n@@ -511,7 +511,7 @@ struct z_candidate {\n   /* The rest of the arguments to use when calling this function.  If\n      there are no further arguments this may be NULL or it may be an\n      empty vector.  */\n-  const VEC(tree,gc) *args;\n+  const vec<tree, va_gc> *args;\n   /* The implicit conversion sequences for each of the arguments to\n      FN.  */\n   conversion **convs;\n@@ -1772,7 +1772,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \n static struct z_candidate *\n add_candidate (struct z_candidate **candidates,\n-\t       tree fn, tree first_arg, const VEC(tree,gc) *args,\n+\t       tree fn, tree first_arg, const vec<tree, va_gc> *args,\n \t       size_t num_convs, conversion **convs,\n \t       tree access_path, tree conversion_path,\n \t       int viable, struct rejection_reason *reason)\n@@ -1822,7 +1822,7 @@ remaining_arguments (tree arg)\n static struct z_candidate *\n add_function_candidate (struct z_candidate **candidates,\n \t\t\ttree fn, tree ctype, tree first_arg,\n-\t\t\tconst VEC(tree,gc) *args, tree access_path,\n+\t\t\tconst vec<tree, va_gc> *args, tree access_path,\n \t\t\ttree conversion_path, int flags,\n \t\t\ttsubst_flags_t complain)\n {\n@@ -1855,7 +1855,7 @@ add_function_candidate (struct z_candidate **candidates,\n   else\n     skip = 0;\n \n-  len = VEC_length (tree, args) - skip + (first_arg != NULL_TREE ? 1 : 0);\n+  len = vec_safe_length (args) - skip + (first_arg != NULL_TREE ? 1 : 0);\n   convs = alloc_conversions (len);\n \n   /* 13.3.2 - Viable functions [over.match.viable]\n@@ -1927,8 +1927,7 @@ add_function_candidate (struct z_candidate **candidates,\n \targ = first_arg;\n       else\n \targ = CONST_CAST_TREE (\n-\t\tVEC_index (tree, args,\n-\t\t\t   i + skip - (first_arg != NULL_TREE ? 1 : 0)));\n+\t\t(*args)[i + skip - (first_arg != NULL_TREE ? 1 : 0)]);\n       argtype = lvalue_type (arg);\n \n       is_this = (i == 0 && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n@@ -2032,7 +2031,7 @@ add_function_candidate (struct z_candidate **candidates,\n \n static struct z_candidate *\n add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n-\t\t    tree first_arg, const VEC(tree,gc) *arglist,\n+\t\t    tree first_arg, const vec<tree, va_gc> *arglist,\n \t\t    tree access_path, tree conversion_path,\n \t\t    tsubst_flags_t complain)\n {\n@@ -2046,7 +2045,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n     parmlist = TREE_TYPE (parmlist);\n   parmlist = TYPE_ARG_TYPES (parmlist);\n \n-  len = VEC_length (tree, arglist) + (first_arg != NULL_TREE ? 1 : 0) + 1;\n+  len = vec_safe_length (arglist) + (first_arg != NULL_TREE ? 1 : 0) + 1;\n   convs = alloc_conversions (len);\n   parmnode = parmlist;\n   viable = 1;\n@@ -2067,8 +2066,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n       else if (i == 1 && first_arg != NULL_TREE)\n \targ = first_arg;\n       else\n-\targ = VEC_index (tree, arglist,\n-\t\t\t i - (first_arg != NULL_TREE ? 1 : 0) - 1);\n+\targ = (*arglist)[i - (first_arg != NULL_TREE ? 1 : 0) - 1];\n       argtype = lvalue_type (arg);\n \n       if (i == 0)\n@@ -2676,7 +2674,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n   tree type, argtypes[3], t;\n   /* TYPES[i] is the set of possible builtin-operator parameter types\n      we will consider for the Ith argument.  */\n-  VEC(tree,gc) *types[2];\n+  vec<tree, va_gc> *types[2];\n   unsigned ix;\n \n   for (i = 0; i < 3; ++i)\n@@ -2758,11 +2756,9 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t  if (code == COND_EXPR)\n \t    {\n \t      if (real_lvalue_p (args[i]))\n-\t\tVEC_safe_push (tree, gc, types[i],\n-\t\t\t       build_reference_type (argtypes[i]));\n+\t\tvec_safe_push (types[i], build_reference_type (argtypes[i]));\n \n-\t      VEC_safe_push (tree, gc, types[i],\n-\t\t\t     TYPE_MAIN_VARIANT (argtypes[i]));\n+\t      vec_safe_push (types[i], TYPE_MAIN_VARIANT (argtypes[i]));\n \t    }\n \n \t  else if (! convs)\n@@ -2778,49 +2774,48 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \t\tcontinue;\n \n \t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n-\t\tVEC_safe_push (tree, gc, types[i], type);\n+\t\tvec_safe_push (types[i], type);\n \n \t      type = non_reference (type);\n \t      if (i != 0 || ! ref1)\n \t\t{\n \t\t  type = cv_unqualified (type_decays_to (type));\n \t\t  if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t    VEC_safe_push (tree, gc, types[i], type);\n+\t\t    vec_safe_push (types[i], type);\n \t\t  if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n \t\t    type = type_promotes_to (type);\n \t\t}\n \n \t      if (! vec_member (type, types[i]))\n-\t\tVEC_safe_push (tree, gc, types[i], type);\n+\t\tvec_safe_push (types[i], type);\n \t    }\n \t}\n       else\n \t{\n \t  if (code == COND_EXPR && real_lvalue_p (args[i]))\n-\t    VEC_safe_push (tree, gc, types[i],\n-\t\t\t   build_reference_type (argtypes[i]));\n+\t    vec_safe_push (types[i], build_reference_type (argtypes[i]));\n \t  type = non_reference (argtypes[i]);\n \t  if (i != 0 || ! ref1)\n \t    {\n \t      type = cv_unqualified (type_decays_to (type));\n \t      if (enum_p && UNSCOPED_ENUM_P (type))\n-\t\tVEC_safe_push (tree, gc, types[i], type);\n+\t\tvec_safe_push (types[i], type);\n \t      if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n \t\ttype = type_promotes_to (type);\n \t    }\n-\t  VEC_safe_push (tree, gc, types[i], type);\n+\t  vec_safe_push (types[i], type);\n \t}\n     }\n \n   /* Run through the possible parameter types of both arguments,\n      creating candidates with those parameter types.  */\n-  FOR_EACH_VEC_ELT_REVERSE (tree, types[0], ix, t)\n+  FOR_EACH_VEC_ELT_REVERSE (*(types[0]), ix, t)\n     {\n       unsigned jx;\n       tree u;\n \n-      if (!VEC_empty (tree, types[1]))\n-\tFOR_EACH_VEC_ELT_REVERSE (tree, types[1], jx, u)\n+      if (!types[1]->is_empty ())\n+\tFOR_EACH_VEC_ELT_REVERSE (*(types[1]), jx, u)\n \t  add_builtin_candidate\n \t    (candidates, code, code2, fnname, t,\n \t     u, args, argtypes, flags, complain);\n@@ -2848,14 +2843,14 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n static struct z_candidate*\n add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \t\t\t     tree ctype, tree explicit_targs, tree first_arg,\n-\t\t\t     const VEC(tree,gc) *arglist, tree return_type,\n+\t\t\t     const vec<tree, va_gc> *arglist, tree return_type,\n \t\t\t     tree access_path, tree conversion_path,\n \t\t\t     int flags, tree obj, unification_kind_t strict,\n \t\t\t     tsubst_flags_t complain)\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_tree_vec (ntparms);\n-  unsigned int len = VEC_length (tree, arglist);\n+  unsigned int len = vec_safe_length (arglist);\n   unsigned int nargs = (first_arg == NULL_TREE ? 0 : 1) + len;\n   unsigned int skip_without_in_chrg = 0;\n   tree first_arg_without_in_chrg = first_arg;\n@@ -2901,7 +2896,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n       ++ia;\n     }\n   for (ix = skip_without_in_chrg;\n-       VEC_iterate (tree, arglist, ix, arg);\n+       vec_safe_iterate (arglist, ix, &arg);\n        ++ix)\n     {\n       args_without_in_chrg[ia] = arg;\n@@ -3002,7 +2997,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n static struct z_candidate *\n add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n \t\t\ttree explicit_targs, tree first_arg,\n-\t\t\tconst VEC(tree,gc) *arglist, tree return_type,\n+\t\t\tconst vec<tree, va_gc> *arglist, tree return_type,\n \t\t\ttree access_path, tree conversion_path, int flags,\n \t\t\tunification_kind_t strict, tsubst_flags_t complain)\n {\n@@ -3017,7 +3012,7 @@ add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n static struct z_candidate *\n add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n \t\t\t     tree obj, tree first_arg,\n-\t\t\t     const VEC(tree,gc) *arglist,\n+\t\t\t     const vec<tree, va_gc> *arglist,\n \t\t\t     tree return_type, tree access_path,\n \t\t\t     tree conversion_path, tsubst_flags_t complain)\n {\n@@ -3336,7 +3331,7 @@ merge_conversion_sequences (conversion *user_seq, conversion *std_seq)\n    non-list constructor.\n \n    Parameters are as for add_candidates, except that the arguments are in\n-   the form of a CONSTRUCTOR (the initializer list) rather than a VEC, and\n+   the form of a CONSTRUCTOR (the initializer list) rather than a vector, and\n    the RETURN_TYPE parameter is replaced by TOTYPE, the desired type.  */\n \n static void\n@@ -3348,7 +3343,7 @@ add_list_candidates (tree fns, tree first_arg,\n \t\t     struct z_candidate **candidates,\n \t\t     tsubst_flags_t complain)\n {\n-  VEC(tree,gc) *args;\n+  vec<tree, va_gc> *args;\n \n   gcc_assert (*candidates == NULL);\n \n@@ -3403,7 +3398,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n   tree conv_fns = NULL_TREE;\n   conversion *conv = NULL;\n   tree first_arg = NULL_TREE;\n-  VEC(tree,gc) *args = NULL;\n+  vec<tree, va_gc> *args = NULL;\n   bool any_viable_p;\n   int convflags;\n \n@@ -3734,13 +3729,13 @@ build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n \n /* Do any initial processing on the arguments to a function call.  */\n \n-static VEC(tree,gc) *\n-resolve_args (VEC(tree,gc) *args, tsubst_flags_t complain)\n+static vec<tree, va_gc> *\n+resolve_args (vec<tree, va_gc> *args, tsubst_flags_t complain)\n {\n   unsigned int ix;\n   tree arg;\n \n-  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n+  FOR_EACH_VEC_SAFE_ELT (args, ix, arg)\n     {\n       if (error_operand_p (arg))\n \treturn NULL;\n@@ -3770,7 +3765,7 @@ resolve_args (VEC(tree,gc) *args, tsubst_flags_t complain)\n \n static struct z_candidate *\n perform_overload_resolution (tree fn,\n-\t\t\t     const VEC(tree,gc) *args,\n+\t\t\t     const vec<tree, va_gc> *args,\n \t\t\t     struct z_candidate **candidates,\n \t\t\t     bool *any_viable_p, tsubst_flags_t complain)\n {\n@@ -3823,7 +3818,7 @@ perform_overload_resolution (tree fn,\n    functions.  */\n \n static void\n-print_error_for_call_failure (tree fn, VEC(tree,gc) *args, bool any_viable_p,\n+print_error_for_call_failure (tree fn, vec<tree, va_gc> *args, bool any_viable_p,\n \t\t\t      struct z_candidate *candidates)\n {\n   tree name = DECL_NAME (OVL_CURRENT (fn));\n@@ -3844,7 +3839,7 @@ print_error_for_call_failure (tree fn, VEC(tree,gc) *args, bool any_viable_p,\n    ARGS.  */\n \n tree\n-build_new_function_call (tree fn, VEC(tree,gc) **args, bool koenig_p, \n+build_new_function_call (tree fn, vec<tree, va_gc> **args, bool koenig_p, \n \t\t\t tsubst_flags_t complain)\n {\n   struct z_candidate *candidates, *cand;\n@@ -3929,7 +3924,7 @@ build_new_function_call (tree fn, VEC(tree,gc) **args, bool koenig_p,\n    function called.  */\n \n tree\n-build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n+build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n \t\t\t tree *size, tree *cookie_size, tree size_check,\n \t\t\t tree *fn, tsubst_flags_t complain)\n {\n@@ -3945,7 +3940,7 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n   if (size_check != NULL_TREE)\n     *size = fold_build3 (COND_EXPR, sizetype, size_check,\n \t\t\t original_size, TYPE_MAX_VALUE (sizetype));\n-  VEC_safe_insert (tree, gc, *args, 0, *size);\n+  vec_safe_insert (*args, 0, *size);\n   *args = resolve_args (*args, complain);\n   if (*args == NULL)\n     return error_mark_node;\n@@ -3985,9 +3980,8 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n \t   /* In G++ 3.2, the check was implemented incorrectly; it\n \t      looked at the placement expression, rather than the\n \t      type of the function.  */\n-\t   if (VEC_length (tree, *args) == 2\n-\t       && same_type_p (TREE_TYPE (VEC_index (tree, *args, 1)),\n-\t\t\t       ptr_type_node))\n+\t   if ((*args)->length () == 2\n+\t       && same_type_p (TREE_TYPE ((**args)[1]), ptr_type_node))\n \t     use_cookie = false;\n \t }\n        else\n@@ -4014,7 +4008,7 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n \t   *size = fold_build3 (COND_EXPR, sizetype, size_check,\n \t\t\t\t*size, TYPE_MAX_VALUE (sizetype));\n \t   /* Update the argument list to reflect the adjusted size.  */\n-\t   VEC_replace (tree, *args, 0, *size);\n+\t   (**args)[0] = *size;\n \t }\n        else\n \t *cookie_size = NULL_TREE;\n@@ -4031,7 +4025,7 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n /* Build a new call to operator().  This may change ARGS.  */\n \n static tree\n-build_op_call_1 (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n+build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, first_mem_arg = NULL_TREE;\n@@ -4165,7 +4159,7 @@ build_op_call_1 (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n /* Wrapper for above.  */\n \n tree\n-build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n+build_op_call (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_OVERLOAD);\n@@ -4899,7 +4893,7 @@ prep_operand (tree operand)\n    add_function_candidate.  */\n \n static void\n-add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n+add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t\ttree return_type,\n \t\ttree explicit_targs, bool template_only,\n \t\ttree conversion_path, tree access_path,\n@@ -4908,7 +4902,7 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n \t\ttsubst_flags_t complain)\n {\n   tree ctype;\n-  const VEC(tree,gc) *non_static_args;\n+  const vec<tree, va_gc> *non_static_args;\n   bool check_list_ctor;\n   bool check_converting;\n   unification_kind_t strict;\n@@ -4964,7 +4958,7 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n   for (; fns; fns = OVL_NEXT (fns))\n     {\n       tree fn_first_arg;\n-      const VEC(tree,gc) *fn_args;\n+      const vec<tree, va_gc> *fn_args;\n \n       fn = OVL_CURRENT (fns);\n \n@@ -4982,12 +4976,12 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n \t    {\n \t      unsigned int ix;\n \t      tree arg;\n-\t      VEC(tree,gc) *tempvec\n-\t\t= VEC_alloc (tree, gc, VEC_length (tree, args) - 1);\n-\t      for (ix = 1; VEC_iterate (tree, args, ix, arg); ++ix)\n-\t\tVEC_quick_push (tree, tempvec, arg);\n+\t      vec<tree, va_gc> *tempvec;\n+\t      vec_alloc (tempvec, args->length () - 1);\n+\t      for (ix = 1; args->iterate (ix, &arg); ++ix)\n+\t\ttempvec->quick_push (arg);\n \t      non_static_args = tempvec;\n-\t      first_arg = build_this (VEC_index (tree, args, 0));\n+\t      first_arg = build_this ((*args)[0]);\n \t    }\n \n \t  fn_first_arg = first_arg;\n@@ -5031,7 +5025,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t\ttree arg2, tree arg3, tree *overload, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n-  VEC(tree,gc) *arglist;\n+  vec<tree, va_gc> *arglist;\n   tree fnname;\n   tree args[3];\n   tree result = NULL_TREE;\n@@ -5098,12 +5092,12 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n   if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n     arg2 = integer_zero_node;\n \n-  arglist = VEC_alloc (tree, gc, 3);\n-  VEC_quick_push (tree, arglist, arg1);\n+  vec_alloc (arglist, 3);\n+  arglist->quick_push (arg1);\n   if (arg2 != NULL_TREE)\n-    VEC_quick_push (tree, arglist, arg2);\n+    arglist->quick_push (arg2);\n   if (arg3 != NULL_TREE)\n-    VEC_quick_push (tree, arglist, arg3);\n+    arglist->quick_push (arg3);\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n@@ -5645,12 +5639,13 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       else\n \t{\n \t  tree ret;\n-\t  VEC(tree,gc) *args = VEC_alloc (tree, gc, 2);\n-\t  VEC_quick_push (tree, args, addr);\n+\t  vec<tree, va_gc> *args;\n+\t  vec_alloc (args, 2);\n+\t  args->quick_push (addr);\n \t  if (FUNCTION_ARG_CHAIN (fn) != void_list_node)\n-\t    VEC_quick_push (tree, args, size);\n+\t    args->quick_push (size);\n \t  ret = cp_build_function_call_vec (fn, &args, complain);\n-\t  VEC_free (tree, gc, args);\n+\t  vec_free (args);\n \t  return ret;\n \t}\n     }\n@@ -5715,7 +5710,7 @@ build_temp (tree expr, tree type, int flags,\n \t    diagnostic_t *diagnostic_kind, tsubst_flags_t complain)\n {\n   int savew, savee;\n-  VEC(tree,gc) *args;\n+  vec<tree, va_gc> *args;\n \n   savew = warningcount, savee = errorcount;\n   args = make_tree_vector_single (expr);\n@@ -5965,7 +5960,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \ttree new_ctor = build_constructor (init_list_type_node, NULL);\n \tunsigned len = CONSTRUCTOR_NELTS (expr);\n \ttree array, val, field;\n-\tVEC(constructor_elt,gc) *vec = NULL;\n+\tvec<constructor_elt, va_gc> *vec = NULL;\n \tunsigned ix;\n \n \t/* Convert all the elements.  */\n@@ -6340,13 +6335,14 @@ cxx_type_promotes_to (tree type)\n    zero-based argument number.  Do any required conversions.  Return\n    the converted value.  */\n \n-static GTY(()) VEC(tree,gc) *default_arg_context;\n+static GTY(()) vec<tree, va_gc> *default_arg_context;\n void\n push_defarg_context (tree fn)\n-{ VEC_safe_push (tree, gc, default_arg_context, fn); }\n+{ vec_safe_push (default_arg_context, fn); }\n+\n void\n pop_defarg_context (void)\n-{ VEC_pop (tree, default_arg_context); }\n+{ default_arg_context->pop (); }\n \n tree\n convert_default_arg (tree type, tree arg, tree fn, int parmnum,\n@@ -6359,7 +6355,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum,\n   fn = DECL_ORIGIN (fn);\n \n   /* Detect recursion.  */\n-  FOR_EACH_VEC_ELT (tree, default_arg_context, i, t)\n+  FOR_EACH_VEC_SAFE_ELT (default_arg_context, i, t)\n     if (t == fn)\n       {\n \tif (complain & tf_error)\n@@ -6581,7 +6577,7 @@ static tree\n build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n {\n   tree fn = cand->fn;\n-  const VEC(tree,gc) *args = cand->args;\n+  const vec<tree, va_gc> *args = cand->args;\n   tree first_arg = cand->first_arg;\n   conversion **convs = cand->convs;\n   conversion *conv;\n@@ -6608,9 +6604,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       unsigned int nargs;\n \n       return_type = TREE_TYPE (TREE_TYPE (fn));\n-      nargs = VEC_length (tree, args);\n+      nargs = vec_safe_length (args);\n       if (first_arg == NULL_TREE)\n-\targarray = VEC_address (tree, CONST_CAST (VEC(tree,gc) *, args));\n+\targarray = args->address ();\n       else\n \t{\n \t  tree *alcarray;\n@@ -6620,7 +6616,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  ++nargs;\n \t  alcarray = XALLOCAVEC (tree, nargs);\n \t  alcarray[0] = first_arg;\n-\t  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n+\t  FOR_EACH_VEC_SAFE_ELT (args, ix, arg)\n \t    alcarray[ix + 1] = arg;\n \t  argarray = alcarray;\n \t}\n@@ -6705,7 +6701,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \n   /* Find maximum size of vector to hold converted arguments.  */\n   parmlen = list_length (parm);\n-  nargs = VEC_length (tree, args) + (first_arg != NULL_TREE ? 1 : 0);\n+  nargs = vec_safe_length (args) + (first_arg != NULL_TREE ? 1 : 0);\n   if (parmlen > nargs)\n     nargs = parmlen;\n   argarray = XALLOCAVEC (tree, nargs);\n@@ -6721,7 +6717,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t}\n       else\n \t{\n-\t  argarray[j++] = VEC_index (tree, args, arg_index);\n+\t  argarray[j++] = (*args)[arg_index];\n \t  ++arg_index;\n \t}\n       parm = TREE_CHAIN (parm);\n@@ -6730,7 +6726,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \n       if (DECL_HAS_VTT_PARM_P (fn))\n \t{\n-\t  argarray[j++] = VEC_index (tree, args, arg_index);\n+\t  argarray[j++] = (*args)[arg_index];\n \t  ++arg_index;\n \t  parm = TREE_CHAIN (parm);\n \t}\n@@ -6741,7 +6737,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       tree parmtype = TREE_VALUE (parm);\n       tree arg = (first_arg != NULL_TREE\n \t\t  ? first_arg\n-\t\t  : VEC_index (tree, args, arg_index));\n+\t\t  : (*args)[arg_index]);\n       tree argtype = TREE_TYPE (arg);\n       tree converted_arg;\n       tree base_binfo;\n@@ -6800,11 +6796,11 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     }\n \n   gcc_assert (first_arg == NULL_TREE);\n-  for (; arg_index < VEC_length (tree, args) && parm;\n+  for (; arg_index < vec_safe_length (args) && parm;\n        parm = TREE_CHAIN (parm), ++arg_index, ++i)\n     {\n       tree type = TREE_VALUE (parm);\n-      tree arg = VEC_index (tree, args, arg_index);\n+      tree arg = (*args)[arg_index];\n       bool conversion_warning = true;\n \n       conv = convs[i];\n@@ -6889,9 +6885,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     }\n \n   /* Ellipsis */\n-  for (; arg_index < VEC_length (tree, args); ++arg_index)\n+  for (; arg_index < vec_safe_length (args); ++arg_index)\n     {\n-      tree a = VEC_index (tree, args, arg_index);\n+      tree a = (*args)[arg_index];\n       if (magic_varargs_p (fn))\n \t/* Do no conversions for magic varargs.  */\n \ta = mark_type_use (a);\n@@ -7221,13 +7217,13 @@ in_charge_arg_for_name (tree name)\n    store the newly constructed object into a VAR_DECL.  */\n \n tree\n-build_special_member_call (tree instance, tree name, VEC(tree,gc) **args,\n+build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n \t\t\t   tree binfo, int flags, tsubst_flags_t complain)\n {\n   tree fns;\n   /* The type of the subobject to be constructed or destroyed.  */\n   tree class_type;\n-  VEC(tree,gc) *allocated = NULL;\n+  vec<tree, va_gc> *allocated = NULL;\n   tree ret;\n \n   gcc_assert (name == complete_ctor_identifier\n@@ -7260,7 +7256,7 @@ build_special_member_call (tree instance, tree name, VEC(tree,gc) **args,\n       if (name == complete_dtor_identifier\n \t  || name == base_dtor_identifier\n \t  || name == deleting_dtor_identifier)\n-\tgcc_assert (args == NULL || VEC_empty (tree, *args));\n+\tgcc_assert (args == NULL || vec_safe_is_empty (*args));\n \n       /* Convert to the base class, if necessary.  */\n       if (!same_type_ignoring_top_level_qualifiers_p\n@@ -7318,7 +7314,7 @@ build_special_member_call (tree instance, tree name, VEC(tree,gc) **args,\n \t  args = &allocated;\n \t}\n \n-      VEC_safe_insert (tree, gc, *args, 0, sub_vtt);\n+      vec_safe_insert (*args, 0, sub_vtt);\n     }\n \n   ret = build_new_method_call (instance, fns, args,\n@@ -7382,7 +7378,7 @@ name_as_c_string (tree name, tree type, bool *free_p)\n    This may change ARGS.  */\n \n static tree\n-build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n+build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\t         tree conversion_path, int flags,\n \t\t         tree *fn_p, tsubst_flags_t complain)\n {\n@@ -7395,14 +7391,14 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n   tree instance_ptr;\n   tree name;\n   bool skip_first_for_error;\n-  VEC(tree,gc) *user_args;\n+  vec<tree, va_gc> *user_args;\n   tree call;\n   tree fn;\n   int template_only = 0;\n   bool any_viable_p;\n   tree orig_instance;\n   tree orig_fns;\n-  VEC(tree,gc) *orig_args = NULL;\n+  vec<tree, va_gc> *orig_args = NULL;\n   void *p;\n \n   gcc_assert (instance != NULL_TREE);\n@@ -7522,14 +7518,14 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n \n   /* If CONSTRUCTOR_IS_DIRECT_INIT is set, this was a T{ } form\n      initializer, not T({ }).  */\n-  if (DECL_CONSTRUCTOR_P (fn) && args != NULL && !VEC_empty (tree, *args)\n-      && BRACE_ENCLOSED_INITIALIZER_P (VEC_index (tree, *args, 0))\n-      && CONSTRUCTOR_IS_DIRECT_INIT (VEC_index (tree, *args, 0)))\n+  if (DECL_CONSTRUCTOR_P (fn) && args != NULL && !vec_safe_is_empty (*args)\n+      && BRACE_ENCLOSED_INITIALIZER_P ((**args)[0])\n+      && CONSTRUCTOR_IS_DIRECT_INIT ((**args)[0]))\n     {\n-      tree init_list = VEC_index (tree, *args, 0);\n+      tree init_list = (**args)[0];\n       tree init = NULL_TREE;\n \n-      gcc_assert (VEC_length (tree, *args) == 1\n+      gcc_assert ((*args)->length () == 1\n \t\t  && !(flags & LOOKUP_ONLYCONVERTING));\n \n       /* If the initializer list has no elements and T is a class type with\n@@ -7732,7 +7728,7 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n /* Wrapper for above.  */\n \n tree\n-build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n+build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\t       tree conversion_path, int flags,\n \t\t       tree *fn_p, tsubst_flags_t complain)\n {\n@@ -8896,7 +8892,7 @@ perform_direct_initialization_if_possible (tree type,\n      ill-formed.  */\n   if (CLASS_TYPE_P (type))\n     {\n-      VEC(tree,gc) *args = make_tree_vector_single (expr);\n+      vec<tree, va_gc> *args = make_tree_vector_single (expr);\n       expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t\t&args, type, LOOKUP_NORMAL, complain);\n       release_tree_vector (args);\n@@ -9003,7 +8999,7 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n    code to initialize the new variable is returned through INITP.  */\n \n static tree\n-set_up_extended_ref_temp (tree decl, tree expr, VEC(tree,gc) **cleanups,\n+set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,\n \t\t\t  tree *initp)\n {\n   tree init;\n@@ -9076,7 +9072,7 @@ set_up_extended_ref_temp (tree decl, tree expr, VEC(tree,gc) **cleanups,\n \t{\n \t  tree cleanup = cxx_maybe_build_cleanup (var, tf_warning_or_error);\n \t  if (cleanup)\n-\t    VEC_safe_push (tree, gc, *cleanups, cleanup);\n+\t    vec_safe_push (*cleanups, cleanup);\n \t}\n \n       /* We must be careful to destroy the temporary only\n@@ -9170,7 +9166,7 @@ initialize_reference (tree type, tree expr,\n    which is bound either to a reference or a std::initializer_list.  */\n \n static tree\n-extend_ref_init_temps_1 (tree decl, tree init, VEC(tree,gc) **cleanups)\n+extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups)\n {\n   tree sub = init;\n   tree *p;\n@@ -9201,7 +9197,7 @@ extend_ref_init_temps_1 (tree decl, tree init, VEC(tree,gc) **cleanups)\n    lifetime to match that of DECL.  */\n \n tree\n-extend_ref_init_temps (tree decl, tree init, VEC(tree,gc) **cleanups)\n+extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)\n {\n   tree type = TREE_TYPE (init);\n   if (processing_template_decl)\n@@ -9226,8 +9222,8 @@ extend_ref_init_temps (tree decl, tree init, VEC(tree,gc) **cleanups)\n     {\n       unsigned i;\n       constructor_elt *p;\n-      VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (init);\n-      FOR_EACH_VEC_ELT (constructor_elt, elts, i, p)\n+      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (init);\n+      FOR_EACH_VEC_SAFE_ELT (elts, i, p)\n \tp->value = extend_ref_init_temps (decl, p->value, cleanups);\n     }\n "}, {"sha": "56fe1d1073c56ed41fc2e6c90c43de0056a44d34", "filename": "gcc/cp/class.c", "status": "modified", "additions": 85, "deletions": 88, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -79,13 +79,13 @@ typedef struct vtbl_init_data_s\n   tree rtti_binfo;\n   /* The negative-index vtable initializers built up so far.  These\n      are in order from least negative index to most negative index.  */\n-  VEC(constructor_elt,gc) *inits;\n+  vec<constructor_elt, va_gc> *inits;\n   /* The binfo for the virtual base for which we're building\n      vcall offset initializers.  */\n   tree vbase;\n   /* The functions in vbase for which we have already provided vcall\n      offsets.  */\n-  VEC(tree,gc) *fns;\n+  vec<tree, va_gc> *fns;\n   /* The vtable index of the next vcall or vbase offset.  */\n   tree index;\n   /* Nonzero if we are building the initializer for the primary\n@@ -112,7 +112,7 @@ static GTY (()) tree sizeof_biggest_empty_class;\n \n /* An array of all local classes present in this translation unit, in\n    declaration order.  */\n-VEC(tree,gc) *local_classes;\n+vec<tree, va_gc> *local_classes;\n \n static tree get_vfield_name (tree);\n static void finish_struct_anon (tree);\n@@ -137,7 +137,7 @@ static tree fixed_type_or_null (tree, int *, int *);\n static tree build_simple_base_path (tree expr, tree binfo);\n static tree build_vtbl_ref_1 (tree, tree);\n static void build_vtbl_initializer (tree, tree, tree, tree, int *,\n-\t\t\t\t    VEC(constructor_elt,gc) **);\n+\t\t\t\t    vec<constructor_elt, va_gc> **);\n static int count_fields (tree);\n static int add_fields_to_record_type (tree, struct sorted_fields_type*, int);\n static void insert_into_classtype_sorted_fields (tree, tree, int);\n@@ -175,15 +175,15 @@ static void dump_vtable (tree, tree, tree);\n static void dump_vtt (tree, tree);\n static void dump_thunk (FILE *, int, tree);\n static tree build_vtable (tree, tree, tree);\n-static void initialize_vtable (tree, VEC(constructor_elt,gc) *);\n+static void initialize_vtable (tree, vec<constructor_elt, va_gc> *);\n static void layout_nonempty_base_or_field (record_layout_info,\n \t\t\t\t\t   tree, tree, splay_tree);\n static tree end_of_class (tree, int);\n static bool layout_empty_base (record_layout_info, tree, tree, splay_tree);\n static void accumulate_vtbl_inits (tree, tree, tree, tree, tree,\n-\t\t\t\t   VEC(constructor_elt,gc) **);\n+\t\t\t\t   vec<constructor_elt, va_gc> **);\n static void dfs_accumulate_vtbl_inits (tree, tree, tree, tree, tree,\n-\t\t\t\t       VEC(constructor_elt,gc) **);\n+\t\t\t\t       vec<constructor_elt, va_gc> **);\n static void build_rtti_vtbl_entries (tree, vtbl_init_data *);\n static void build_vcall_and_vbase_vtbl_entries (tree, vtbl_init_data *);\n static void clone_constructors_and_destructors (tree);\n@@ -192,7 +192,8 @@ static void update_vtable_entry_for_fn (tree, tree, tree, tree *, unsigned);\n static void build_ctor_vtbl_group (tree, tree);\n static void build_vtt (tree);\n static tree binfo_ctor_vtable (tree);\n-static void build_vtt_inits (tree, tree, VEC(constructor_elt,gc) **, tree *);\n+static void build_vtt_inits (tree, tree, vec<constructor_elt, va_gc> **,\n+\t\t\t     tree *);\n static tree dfs_build_secondary_vptr_vtt_inits (tree, void *);\n static tree dfs_fixup_binfo_vtbls (tree, void *);\n static int record_subobject_offset (tree, tree, splay_tree);\n@@ -948,7 +949,7 @@ add_method (tree type, tree method, tree using_decl)\n   tree overload;\n   bool template_conv_p = false;\n   bool conv_p;\n-  VEC(tree,gc) *method_vec;\n+  vec<tree, va_gc> *method_vec;\n   bool complete_p;\n   bool insert_p = false;\n   tree current_fns;\n@@ -970,10 +971,10 @@ add_method (tree type, tree method, tree using_decl)\n \t allocate at least two (for constructors and destructors), and\n \t we're going to end up with an assignment operator at some\n \t point as well.  */\n-      method_vec = VEC_alloc (tree, gc, 8);\n+      vec_alloc (method_vec, 8);\n       /* Create slots for constructors and destructors.  */\n-      VEC_quick_push (tree, method_vec, NULL_TREE);\n-      VEC_quick_push (tree, method_vec, NULL_TREE);\n+      method_vec->quick_push (NULL_TREE);\n+      method_vec->quick_push (NULL_TREE);\n       CLASSTYPE_METHOD_VEC (type) = method_vec;\n     }\n \n@@ -1004,7 +1005,7 @@ add_method (tree type, tree method, tree using_decl)\n       insert_p = true;\n       /* See if we already have an entry with this name.  */\n       for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   VEC_iterate (tree, method_vec, slot, m);\n+\t   vec_safe_iterate (method_vec, slot, &m);\n \t   ++slot)\n \t{\n \t  m = OVL_CURRENT (m);\n@@ -1028,7 +1029,7 @@ add_method (tree type, tree method, tree using_decl)\n \t    break;\n \t}\n     }\n-  current_fns = insert_p ? NULL_TREE : VEC_index (tree, method_vec, slot);\n+  current_fns = insert_p ? NULL_TREE : (*method_vec)[slot];\n \n   /* Check to see if we've already got this method.  */\n   for (fns = current_fns; fns; fns = OVL_NEXT (fns))\n@@ -1175,19 +1176,19 @@ add_method (tree type, tree method, tree using_decl)\n       /* We only expect to add few methods in the COMPLETE_P case, so\n \t just make room for one more method in that case.  */\n       if (complete_p)\n-\treallocated = VEC_reserve_exact (tree, gc, method_vec, 1);\n+\treallocated = vec_safe_reserve_exact (method_vec, 1);\n       else\n-\treallocated = VEC_reserve (tree, gc, method_vec, 1);\n+\treallocated = vec_safe_reserve (method_vec, 1);\n       if (reallocated)\n \tCLASSTYPE_METHOD_VEC (type) = method_vec;\n-      if (slot == VEC_length (tree, method_vec))\n-\tVEC_quick_push (tree, method_vec, overload);\n+      if (slot == method_vec->length ())\n+\tmethod_vec->quick_push (overload);\n       else\n-\tVEC_quick_insert (tree, method_vec, slot, overload);\n+\tmethod_vec->quick_insert (slot, overload);\n     }\n   else\n     /* Replace the current slot.  */\n-    VEC_replace (tree, method_vec, slot, overload);\n+    (*method_vec)[slot] = overload;\n   return true;\n }\n \n@@ -1953,15 +1954,15 @@ resort_type_method_vec (void* obj,\n \t\t\tgt_pointer_operator new_value,\n \t\t\tvoid* cookie)\n {\n-  VEC(tree,gc) *method_vec = (VEC(tree,gc) *) obj;\n-  int len = VEC_length (tree, method_vec);\n+  vec<tree, va_gc> *method_vec = (vec<tree, va_gc> *) obj;\n+  int len = vec_safe_length (method_vec);\n   size_t slot;\n   tree fn;\n \n   /* The type conversion ops have to live at the front of the vec, so we\n      can't sort them.  */\n   for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       VEC_iterate (tree, method_vec, slot, fn);\n+       vec_safe_iterate (method_vec, slot, &fn);\n        ++slot)\n     if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n       break;\n@@ -1970,7 +1971,7 @@ resort_type_method_vec (void* obj,\n     {\n       resort_data.new_value = new_value;\n       resort_data.cookie = cookie;\n-      qsort (VEC_address (tree, method_vec) + slot, len - slot, sizeof (tree),\n+      qsort (method_vec->address () + slot, len - slot, sizeof (tree),\n \t     resort_method_name_cmp);\n     }\n }\n@@ -1985,14 +1986,14 @@ static void\n finish_struct_methods (tree t)\n {\n   tree fn_fields;\n-  VEC(tree,gc) *method_vec;\n+  vec<tree, va_gc> *method_vec;\n   int slot, len;\n \n   method_vec = CLASSTYPE_METHOD_VEC (t);\n   if (!method_vec)\n     return;\n \n-  len = VEC_length (tree, method_vec);\n+  len = method_vec->length ();\n \n   /* Clear DECL_IN_AGGR_P for all functions.  */\n   for (fn_fields = TYPE_METHODS (t); fn_fields;\n@@ -2006,12 +2007,12 @@ finish_struct_methods (tree t)\n   /* The type conversion ops have to live at the front of the vec, so we\n      can't sort them.  */\n   for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       VEC_iterate (tree, method_vec, slot, fn_fields);\n+       method_vec->iterate (slot, &fn_fields);\n        ++slot)\n     if (!DECL_CONV_FN_P (OVL_CURRENT (fn_fields)))\n       break;\n   if (len - slot > 1)\n-    qsort (VEC_address (tree, method_vec) + slot,\n+    qsort (method_vec->address () + slot,\n \t   len-slot, sizeof (tree), method_name_cmp);\n }\n \n@@ -2103,7 +2104,7 @@ typedef struct find_final_overrider_data_s {\n   /* The candidate overriders.  */\n   tree candidates;\n   /* Path to most derived.  */\n-  VEC(tree,heap) *path;\n+  vec<tree> path;\n } find_final_overrider_data;\n \n /* Add the overrider along the current path to FFOD->CANDIDATES.\n@@ -2122,7 +2123,7 @@ dfs_find_final_overrider_1 (tree binfo,\n     {\n       depth--;\n       if (dfs_find_final_overrider_1\n-\t  (VEC_index (tree, ffod->path, depth), ffod, depth))\n+\t  (ffod->path[depth], ffod, depth))\n \treturn true;\n     }\n \n@@ -2161,8 +2162,8 @@ dfs_find_final_overrider_pre (tree binfo, void *data)\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n   if (binfo == ffod->declaring_base)\n-    dfs_find_final_overrider_1 (binfo, ffod, VEC_length (tree, ffod->path));\n-  VEC_safe_push (tree, heap, ffod->path, binfo);\n+    dfs_find_final_overrider_1 (binfo, ffod, ffod->path.length ());\n+  ffod->path.safe_push (binfo);\n \n   return NULL_TREE;\n }\n@@ -2171,7 +2172,7 @@ static tree\n dfs_find_final_overrider_post (tree /*binfo*/, void *data)\n {\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n-  VEC_pop (tree, ffod->path);\n+  ffod->path.pop ();\n \n   return NULL_TREE;\n }\n@@ -2211,12 +2212,12 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n   ffod.fn = fn;\n   ffod.declaring_base = binfo;\n   ffod.candidates = NULL_TREE;\n-  ffod.path = VEC_alloc (tree, heap, 30);\n+  ffod.path.create (30);\n \n   dfs_walk_all (derived, dfs_find_final_overrider_pre,\n \t\tdfs_find_final_overrider_post, &ffod);\n \n-  VEC_free (tree, heap, ffod.path);\n+  ffod.path.release ();\n \n   /* If there was no winner, issue an error message.  */\n   if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n@@ -2231,11 +2232,11 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n static tree\n get_vcall_index (tree fn, tree type)\n {\n-  VEC(tree_pair_s,gc) *indices = CLASSTYPE_VCALL_INDICES (type);\n+  vec<tree_pair_s, va_gc> *indices = CLASSTYPE_VCALL_INDICES (type);\n   tree_pair_p p;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (tree_pair_s, indices, ix, p)\n+  FOR_EACH_VEC_SAFE_ELT (indices, ix, p)\n     if ((DECL_DESTRUCTOR_P (fn) && DECL_DESTRUCTOR_P (p->purpose))\n \t|| same_signature_p (fn, p->purpose))\n       return p->value;\n@@ -2589,7 +2590,7 @@ get_basefndecls (tree name, tree t)\n   /* Find virtual functions in T with the indicated NAME.  */\n   i = lookup_fnfields_1 (t, name);\n   if (i != -1)\n-    for (methods = VEC_index (tree, CLASSTYPE_METHOD_VEC (t), i);\n+    for (methods = (*CLASSTYPE_METHOD_VEC (t))[i];\n \t methods;\n \t methods = OVL_NEXT (methods))\n       {\n@@ -2660,13 +2661,13 @@ check_for_override (tree decl, tree ctype)\n static void\n warn_hidden (tree t)\n {\n-  VEC(tree,gc) *method_vec = CLASSTYPE_METHOD_VEC (t);\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (t);\n   tree fns;\n   size_t i;\n \n   /* We go through each separately named virtual function.  */\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       VEC_iterate (tree, method_vec, i, fns);\n+       vec_safe_iterate (method_vec, i, &fns);\n        ++i)\n     {\n       tree fn;\n@@ -3704,7 +3705,7 @@ walk_subobject_offsets (tree type,\n       if (abi_version_at_least (2) && CLASSTYPE_VBASECLASSES (type))\n \t{\n \t  unsigned ix;\n-\t  VEC(tree,gc) *vbases;\n+\t  vec<tree, va_gc> *vbases;\n \n \t  /* Iterate through the virtual base classes of TYPE.  In G++\n \t     3.2, we included virtual bases in the direct base class\n@@ -3713,7 +3714,7 @@ walk_subobject_offsets (tree type,\n \t     working with the most derived type.  */\n \t  if (vbases_p)\n \t    for (vbases = CLASSTYPE_VBASECLASSES (type), ix = 0;\n-\t\t VEC_iterate (tree, vbases, ix, binfo); ix++)\n+\t\t vec_safe_iterate (vbases, ix, &binfo); ix++)\n \t      {\n \t\tr = walk_subobject_offsets (binfo,\n \t\t\t\t\t    f,\n@@ -4221,7 +4222,7 @@ check_methods (tree t)\n \t{\n \t  TYPE_POLYMORPHIC_P (t) = 1;\n \t  if (DECL_PURE_VIRTUAL_P (x))\n-\t    VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (t), x);\n+\t    vec_safe_push (CLASSTYPE_PURE_VIRTUALS (t), x);\n \t}\n       /* All user-provided destructors are non-trivial.\n          Constructors and assignment ops are handled in\n@@ -5620,7 +5621,7 @@ static tree\n end_of_class (tree t, int include_virtuals_p)\n {\n   tree result = size_zero_node;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n   tree binfo;\n   tree base_binfo;\n   tree offset;\n@@ -5643,7 +5644,7 @@ end_of_class (tree t, int include_virtuals_p)\n   /* G++ 3.2 did not check indirect virtual bases.  */\n   if (abi_version_at_least (2) && include_virtuals_p)\n     for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n-\t VEC_iterate (tree, vbases, i, base_binfo); i++)\n+\t vec_safe_iterate (vbases, i, &base_binfo); i++)\n       {\n \toffset = end_of_base (base_binfo);\n \tif (INT_CST_LT_UNSIGNED (result, offset))\n@@ -5667,7 +5668,7 @@ static void\n warn_about_ambiguous_bases (tree t)\n {\n   int i;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n   tree basetype;\n   tree binfo;\n   tree base_binfo;\n@@ -5690,7 +5691,7 @@ warn_about_ambiguous_bases (tree t)\n   /* Check for ambiguous virtual bases.  */\n   if (extra_warnings)\n     for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n-\t VEC_iterate (tree, vbases, i, binfo); i++)\n+\t vec_safe_iterate (vbases, i, &binfo); i++)\n       {\n \tbasetype = BINFO_TYPE (binfo);\n \n@@ -6520,7 +6521,7 @@ finish_struct (tree t, tree attributes)\n       CLASSTYPE_PURE_VIRTUALS (t) = NULL;\n       for (x = TYPE_METHODS (t); x; x = DECL_CHAIN (x))\n \tif (DECL_PURE_VIRTUAL_P (x))\n-\t  VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (t), x);\n+\t  vec_safe_push (CLASSTYPE_PURE_VIRTUALS (t), x);\n       complete_vars (t);\n       /* We need to add the target functions to the CLASSTYPE_METHOD_VEC if\n \t an enclosing scope is a template class, so that this function be\n@@ -6766,7 +6767,7 @@ init_class_processing (void)\n   current_class_stack_size = 10;\n   current_class_stack\n     = XNEWVEC (struct class_stack_node, current_class_stack_size);\n-  local_classes = VEC_alloc (tree, gc, 8);\n+  vec_alloc (local_classes, 8);\n   sizeof_biggest_empty_class = size_zero_node;\n \n   ridpointers[(int) RID_PUBLIC] = access_public_node;\n@@ -7028,7 +7029,7 @@ pop_nested_class (void)\n int\n current_lang_depth (void)\n {\n-  return VEC_length (tree, current_lang_base);\n+  return vec_safe_length (current_lang_base);\n }\n \n /* Set global variables CURRENT_LANG_NAME to appropriate value\n@@ -7037,7 +7038,7 @@ current_lang_depth (void)\n void\n push_lang_context (tree name)\n {\n-  VEC_safe_push (tree, gc, current_lang_base, current_lang_name);\n+  vec_safe_push (current_lang_base, current_lang_name);\n \n   if (name == lang_name_cplusplus)\n     {\n@@ -7072,7 +7073,7 @@ push_lang_context (tree name)\n void\n pop_lang_context (void)\n {\n-  current_lang_name = VEC_pop (tree, current_lang_base);\n+  current_lang_name = current_lang_base->pop ();\n }\n \f\n /* Type instantiation routines.  */\n@@ -8051,7 +8052,7 @@ static void\n finish_vtbls (tree t)\n {\n   tree vbase;\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n   tree vtable = BINFO_VTABLE (TYPE_BINFO (t));\n \n   /* We lay out the primary and secondary vtables in one contiguous\n@@ -8075,11 +8076,11 @@ finish_vtbls (tree t)\n /* Initialize the vtable for BINFO with the INITS.  */\n \n static void\n-initialize_vtable (tree binfo, VEC(constructor_elt,gc) *inits)\n+initialize_vtable (tree binfo, vec<constructor_elt, va_gc> *inits)\n {\n   tree decl;\n \n-  layout_vtable_decl (binfo, VEC_length (constructor_elt, inits));\n+  layout_vtable_decl (binfo, vec_safe_length (inits));\n   decl = get_vtbl_decl_for_binfo (binfo);\n   initialize_artificial_var (decl, inits);\n   dump_vtable (BINFO_TYPE (binfo), binfo, decl);\n@@ -8104,7 +8105,7 @@ build_vtt (tree t)\n   tree type;\n   tree vtt;\n   tree index;\n-  VEC(constructor_elt,gc) *inits;\n+  vec<constructor_elt, va_gc> *inits;\n \n   /* Build up the initializers for the VTT.  */\n   inits = NULL;\n@@ -8117,7 +8118,7 @@ build_vtt (tree t)\n \n   /* Figure out the type of the VTT.  */\n   type = build_array_of_n_type (const_ptr_type_node,\n-\t\t\t\tVEC_length (constructor_elt, inits));\n+                                inits->length ());\n \n   /* Now, build the VTT object itself.  */\n   vtt = build_vtable (t, mangle_vtt_for_type (t), type);\n@@ -8163,7 +8164,7 @@ typedef struct secondary_vptr_vtt_init_data_s\n   tree index;\n \n   /* Vector of initializers built up.  */\n-  VEC(constructor_elt,gc) *inits;\n+  vec<constructor_elt, va_gc> *inits;\n \n   /* The type being constructed by this secondary VTT.  */\n   tree type_being_constructed;\n@@ -8178,7 +8179,8 @@ typedef struct secondary_vptr_vtt_init_data_s\n    vtables for the BINFO-in-T variant.  */\n \n static void\n-build_vtt_inits (tree binfo, tree t, VEC(constructor_elt,gc) **inits, tree *index)\n+build_vtt_inits (tree binfo, tree t, vec<constructor_elt, va_gc> **inits,\n+\t\t tree *index)\n {\n   int i;\n   tree b;\n@@ -8338,7 +8340,7 @@ build_ctor_vtbl_group (tree binfo, tree t)\n   tree vtbl;\n   tree id;\n   tree vbase;\n-  VEC(constructor_elt,gc) *v;\n+  vec<constructor_elt, va_gc> *v;\n \n   /* See if we've already created this construction vtable group.  */\n   id = mangle_ctor_vtbl_for_type (t, binfo);\n@@ -8372,8 +8374,7 @@ build_ctor_vtbl_group (tree binfo, tree t)\n     }\n \n   /* Figure out the type of the construction vtable.  */\n-  type = build_array_of_n_type (vtable_entry_type,\n-\t\t\t\tVEC_length (constructor_elt, v));\n+  type = build_array_of_n_type (vtable_entry_type, v->length ());\n   layout_type (type);\n   TREE_TYPE (vtbl) = type;\n   DECL_SIZE (vtbl) = DECL_SIZE_UNIT (vtbl) = NULL_TREE;\n@@ -8401,7 +8402,7 @@ accumulate_vtbl_inits (tree binfo,\n \t\t       tree rtti_binfo,\n \t\t       tree vtbl,\n \t\t       tree t,\n-\t\t       VEC(constructor_elt,gc) **inits)\n+\t\t       vec<constructor_elt, va_gc> **inits)\n {\n   int i;\n   tree base_binfo;\n@@ -8449,7 +8450,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n \t\t\t   tree rtti_binfo,\n \t\t\t   tree orig_vtbl,\n \t\t\t   tree t,\n-\t\t\t   VEC(constructor_elt,gc) **l)\n+\t\t\t   vec<constructor_elt, va_gc> **l)\n {\n   tree vtbl = NULL_TREE;\n   int ctor_vtbl_p = !SAME_BINFO_TYPE_P (BINFO_TYPE (rtti_binfo), t);\n@@ -8509,7 +8510,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n   else if (!BINFO_NEW_VTABLE_MARKED (orig_binfo))\n     return;\n \n-  n_inits = VEC_length (constructor_elt, *l);\n+  n_inits = vec_safe_length (*l);\n \n   if (!vtbl)\n     {\n@@ -8535,7 +8536,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n     BINFO_VTABLE (binfo) = tree_cons (rtti_binfo, vtbl, BINFO_VTABLE (binfo));\n   else if (BINFO_PRIMARY_P (binfo) && BINFO_VIRTUAL_P (binfo))\n     /* Throw away any unneeded intializers.  */\n-    VEC_truncate (constructor_elt, *l, n_inits);\n+    (*l)->truncate (n_inits);\n   else\n      /* For an ordinary vtable, set BINFO_VTABLE.  */\n     BINFO_VTABLE (binfo) = vtbl;\n@@ -8572,13 +8573,13 @@ build_vtbl_initializer (tree binfo,\n \t\t\ttree t,\n \t\t\ttree rtti_binfo,\n \t\t\tint* non_fn_entries_p,\n-\t\t\tVEC(constructor_elt,gc) **inits)\n+\t\t\tvec<constructor_elt, va_gc> **inits)\n {\n   tree v;\n   vtbl_init_data vid;\n   unsigned ix, jx;\n   tree vbinfo;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n   constructor_elt *e;\n \n   /* Initialize VID.  */\n@@ -8598,41 +8599,39 @@ build_vtbl_initializer (tree binfo,\n   /* Create an array for keeping track of the functions we've\n      processed.  When we see multiple functions with the same\n      signature, we share the vcall offsets.  */\n-  vid.fns = VEC_alloc (tree, gc, 32);\n+  vec_alloc (vid.fns, 32);\n   /* Add the vcall and vbase offset entries.  */\n   build_vcall_and_vbase_vtbl_entries (binfo, &vid);\n \n   /* Clear BINFO_VTABLE_PATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n   for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n-       VEC_iterate (tree, vbases, ix, vbinfo); ix++)\n+       vec_safe_iterate (vbases, ix, &vbinfo); ix++)\n     BINFO_VTABLE_PATH_MARKED (vbinfo) = 0;\n \n   /* If the target requires padding between data entries, add that now.  */\n   if (TARGET_VTABLE_DATA_ENTRY_DISTANCE > 1)\n     {\n-      int n_entries = VEC_length (constructor_elt, vid.inits);\n+      int n_entries = vec_safe_length (vid.inits);\n \n-      VEC_safe_grow (constructor_elt, gc, vid.inits,\n-\t\t     TARGET_VTABLE_DATA_ENTRY_DISTANCE * n_entries);\n+      vec_safe_grow (vid.inits, TARGET_VTABLE_DATA_ENTRY_DISTANCE * n_entries);\n \n       /* Move data entries into their new positions and add padding\n \t after the new positions.  Iterate backwards so we don't\n \t overwrite entries that we would need to process later.  */\n       for (ix = n_entries - 1;\n-\t   VEC_iterate (constructor_elt, vid.inits, ix, e);\n+\t   vid.inits->iterate (ix, &e);\n \t   ix--)\n \t{\n \t  int j;\n \t  int new_position = (TARGET_VTABLE_DATA_ENTRY_DISTANCE * ix\n \t\t\t      + (TARGET_VTABLE_DATA_ENTRY_DISTANCE - 1));\n \n-\t  VEC_replace (constructor_elt, vid.inits, new_position, *e);\n+\t  (*vid.inits)[new_position] = *e;\n \n \t  for (j = 1; j < TARGET_VTABLE_DATA_ENTRY_DISTANCE; ++j)\n \t    {\n-\t      constructor_elt *f = &VEC_index (constructor_elt, vid.inits,\n-\t\t\t\t\t       new_position - j);\n+\t      constructor_elt *f = &(*vid.inits)[new_position - j];\n \t      f->index = NULL_TREE;\n \t      f->value = build1 (NOP_EXPR, vtable_entry_type,\n \t\t\t\t null_pointer_node);\n@@ -8641,19 +8640,18 @@ build_vtbl_initializer (tree binfo,\n     }\n \n   if (non_fn_entries_p)\n-    *non_fn_entries_p = VEC_length (constructor_elt, vid.inits);\n+    *non_fn_entries_p = vec_safe_length (vid.inits);\n \n   /* The initializers for virtual functions were built up in reverse\n      order.  Straighten them out and add them to the running list in one\n      step.  */\n-  jx = VEC_length (constructor_elt, *inits);\n-  VEC_safe_grow (constructor_elt, gc, *inits,\n-\t\t (jx + VEC_length (constructor_elt, vid.inits)));\n+  jx = vec_safe_length (*inits);\n+  vec_safe_grow (*inits, jx + vid.inits->length ());\n \n-  for (ix = VEC_length (constructor_elt, vid.inits) - 1;\n-       VEC_iterate (constructor_elt, vid.inits, ix, e);\n+  for (ix = vid.inits->length () - 1;\n+       vid.inits->iterate (ix, &e);\n        ix--, jx++)\n-    VEC_replace (constructor_elt, *inits, jx, *e);\n+    (**inits)[jx] = *e;\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n@@ -9053,7 +9051,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n      signature as FN, then we do not need a second vcall offset.\n      Check the list of functions already present in the derived\n      class vtable.  */\n-  FOR_EACH_VEC_ELT (tree, vid->fns, i, derived_entry)\n+  FOR_EACH_VEC_SAFE_ELT (vid->fns, i, derived_entry)\n     {\n       if (same_signature_p (derived_entry, orig_fn)\n \t  /* We only use one vcall offset for virtual destructors,\n@@ -9069,8 +9067,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n   if (vid->binfo == TYPE_BINFO (vid->derived))\n     {\n       tree_pair_s elt = {orig_fn, vid->index};\n-      VEC_safe_push (tree_pair_s, gc, CLASSTYPE_VCALL_INDICES (vid->derived),\n-\t\t     elt);\n+      vec_safe_push (CLASSTYPE_VCALL_INDICES (vid->derived), elt);\n     }\n \n   /* The next vcall offset will be found at a more negative\n@@ -9079,7 +9076,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n \t\t\t   ssize_int (TARGET_VTABLE_DATA_ENTRY_DISTANCE));\n \n   /* Keep track of this function.  */\n-  VEC_safe_push (tree, gc, vid->fns, orig_fn);\n+  vec_safe_push (vid->fns, orig_fn);\n \n   if (vid->generate_vcall_entries)\n     {"}, {"sha": "cde480d3548115a08ca0de3d774c16c45ed943f4", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -824,7 +824,7 @@ omp_cxx_notice_variable (struct cp_genericize_omp_taskreg *omp_ctx, tree decl)\n struct cp_genericize_data\n {\n   struct pointer_set_t *p_set;\n-  VEC (tree, heap) *bind_expr_stack;\n+  vec<tree> bind_expr_stack;\n   struct cp_genericize_omp_taskreg *omp_ctx;\n };\n \n@@ -1015,10 +1015,10 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t\t\t\t     : OMP_CLAUSE_DEFAULT_PRIVATE);\n \t      }\n \t}\n-      VEC_safe_push (tree, heap, wtd->bind_expr_stack, stmt);\n+      wtd->bind_expr_stack.safe_push (stmt);\n       cp_walk_tree (&BIND_EXPR_BODY (stmt),\n \t\t    cp_genericize_r, data, NULL);\n-      VEC_pop (tree, wtd->bind_expr_stack);\n+      wtd->bind_expr_stack.pop ();\n     }\n \n   else if (TREE_CODE (stmt) == USING_STMT)\n@@ -1028,12 +1028,11 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       /* Get the innermost inclosing GIMPLE_BIND that has a non NULL\n          BLOCK, and append an IMPORTED_DECL to its\n \t BLOCK_VARS chained list.  */\n-      if (wtd->bind_expr_stack)\n+      if (wtd->bind_expr_stack.exists ())\n \t{\n \t  int i;\n-\t  for (i = VEC_length (tree, wtd->bind_expr_stack) - 1; i >= 0; i--)\n-\t    if ((block = BIND_EXPR_BLOCK (VEC_index (tree,\n-\t\t\t\t\t\t     wtd->bind_expr_stack, i))))\n+\t  for (i = wtd->bind_expr_stack.length () - 1; i >= 0; i--)\n+\t    if ((block = BIND_EXPR_BLOCK (wtd->bind_expr_stack[i])))\n \t      break;\n \t}\n       if (block)\n@@ -1151,11 +1150,11 @@ cp_genericize_tree (tree* t_p)\n   struct cp_genericize_data wtd;\n \n   wtd.p_set = pointer_set_create ();\n-  wtd.bind_expr_stack = NULL;\n+  wtd.bind_expr_stack.create (0);\n   wtd.omp_ctx = NULL;\n   cp_walk_tree (t_p, cp_genericize_r, &wtd, NULL);\n   pointer_set_destroy (wtd.p_set);\n-  VEC_free (tree, heap, wtd.bind_expr_stack);\n+  wtd.bind_expr_stack.release ();\n }\n \n void"}, {"sha": "8592125e4cf76231d7b1181815bfa66d6ea46ac5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -535,7 +535,7 @@ typedef enum impl_conv_void {\n struct GTY (()) tree_default_arg {\n   struct tree_common common;\n   struct cp_token_cache *tokens;\n-  VEC(tree,gc) *instantiations;\n+  vec<tree, va_gc> *instantiations;\n };\n \n \n@@ -709,7 +709,7 @@ struct GTY (()) tree_lambda_expr\n   tree return_type;\n   tree extra_scope;\n   tree closure;\n-  VEC(tree,gc)* pending_proxies;\n+  vec<tree, va_gc> *pending_proxies;\n   location_t locus;\n   enum cp_lambda_default_capture_mode_type default_capture_mode;\n   int discriminator;\n@@ -735,8 +735,6 @@ struct GTY(()) qualified_typedef_usage_s {\n   location_t locus;\n };\n typedef struct qualified_typedef_usage_s qualified_typedef_usage_t;\n-DEF_VEC_O (qualified_typedef_usage_t);\n-DEF_VEC_ALLOC_O (qualified_typedef_usage_t,gc);\n \n /* Non-zero if this template specialization has access violations that\n    should be rechecked when the function is instantiated outside argument\n@@ -748,7 +746,7 @@ DEF_VEC_ALLOC_O (qualified_typedef_usage_t,gc);\n \n struct GTY(()) tree_template_info {\n   struct tree_common common;\n-  VEC(qualified_typedef_usage_t,gc) *typedefs_needing_access_checking;\n+  vec<qualified_typedef_usage_t, va_gc> *typedefs_needing_access_checking;\n };\n \n enum cp_tree_node_structure_enum {\n@@ -986,14 +984,14 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n /* Global state.  */\n \n struct GTY(()) saved_scope {\n-  VEC(cxx_saved_binding,gc) *old_bindings;\n+  vec<cxx_saved_binding, va_gc> *old_bindings;\n   tree old_namespace;\n-  VEC(tree,gc) *decl_ns_list;\n+  vec<tree, va_gc> *decl_ns_list;\n   tree class_name;\n   tree class_type;\n   tree access_specifier;\n   tree function_decl;\n-  VEC(tree,gc) *lang_base;\n+  vec<tree, va_gc> *lang_base;\n   tree lang_name;\n   tree template_parms;\n   cp_binding_level *x_previous_class_level;\n@@ -1102,7 +1100,7 @@ struct GTY(()) language_function {\n \n   htab_t GTY((param_is(struct named_label_entry))) x_named_labels;\n   cp_binding_level *bindings;\n-  VEC(tree,gc) *x_local_names;\n+  vec<tree, va_gc> *x_local_names;\n   htab_t GTY((param_is (struct cxx_int_tree_map))) extern_decl_map;\n };\n \n@@ -1304,8 +1302,6 @@ typedef struct GTY (()) tree_pair_s {\n   tree value;\n } tree_pair_s;\n typedef tree_pair_s *tree_pair_p;\n-DEF_VEC_O (tree_pair_s);\n-DEF_VEC_ALLOC_O (tree_pair_s,gc);\n \n /* This is a few header flags for 'struct lang_type'.  Actually,\n    all but the first are used only for lang_type_class; they\n@@ -1401,15 +1397,15 @@ struct GTY(()) lang_type_class {\n   unsigned dummy : 2;\n \n   tree primary_base;\n-  VEC(tree_pair_s,gc) *vcall_indices;\n+  vec<tree_pair_s, va_gc> *vcall_indices;\n   tree vtables;\n   tree typeinfo_var;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n   binding_table nested_udts;\n   tree as_base;\n-  VEC(tree,gc) *pure_virtuals;\n+  vec<tree, va_gc> *pure_virtuals;\n   tree friend_classes;\n-  VEC(tree,gc) * GTY((reorder (\"resort_type_method_vec\"))) methods;\n+  vec<tree, va_gc> * GTY((reorder (\"resort_type_method_vec\"))) methods;\n   tree key_method;\n   tree decl_list;\n   tree template_info;\n@@ -1603,15 +1599,15 @@ struct GTY((variable_size)) lang_type {\n /* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n    are the constructors that take an in-charge parameter.  */\n #define CLASSTYPE_CONSTRUCTORS(NODE) \\\n-  (VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_CONSTRUCTOR_SLOT))\n+  ((*CLASSTYPE_METHOD_VEC (NODE))[CLASSTYPE_CONSTRUCTOR_SLOT])\n \n /* A FUNCTION_DECL for the destructor for NODE.  These are the\n    destructors that take an in-charge parameter.  If\n    CLASSTYPE_LAZY_DESTRUCTOR is true, then this entry will be NULL\n    until the destructor is created with lazily_declare_fn.  */\n #define CLASSTYPE_DESTRUCTORS(NODE) \\\n   (CLASSTYPE_METHOD_VEC (NODE)\t\t\t\t\t\t      \\\n-   ? VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT) \\\n+   ? (*CLASSTYPE_METHOD_VEC (NODE))[CLASSTYPE_DESTRUCTOR_SLOT]\t\t      \\\n    : NULL_TREE)\n \n /* A dictionary of the nested user-defined-types (class-types, or enums)\n@@ -1665,7 +1661,7 @@ struct GTY((variable_size)) lang_type {\n #define TYPE_JAVA_INTERFACE(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->java_interface)\n \n-/* A VEC(tree) of virtual functions which cannot be inherited by\n+/* A vec<tree> of virtual functions which cannot be inherited by\n    derived classes.  When deriving from this type, the derived\n    class must provide its own definition for each of these functions.  */\n #define CLASSTYPE_PURE_VIRTUALS(NODE) \\\n@@ -1815,7 +1811,7 @@ struct GTY((variable_size)) lang_type {\n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n-/* A VEC(tree_pair_s) of the vcall indices associated with the class\n+/* A vec<tree_pair_s> of the vcall indices associated with the class\n    NODE.  The PURPOSE of each element is a FUNCTION_DECL for a virtual\n    function.  The VALUE is the index into the virtual table where the\n    vcall offset for that function is stored, when NODE is a virtual\n@@ -3345,8 +3341,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (TREE_CODE (NODE) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (NODE))\n \n #define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR \\\n-\t\t\t\t   && VEC_empty (constructor_elt, \\\n-\t\t\t\t\t\t CONSTRUCTOR_ELTS (NODE)) \\\n+\t\t\t\t   && vec_safe_is_empty(CONSTRUCTOR_ELTS(NODE))\\\n \t\t\t\t   && !TREE_HAS_CONSTRUCTOR (NODE))\n \n /* True if NODE is a init-list used as a direct-initializer, i.e.\n@@ -4281,7 +4276,7 @@ extern int current_class_depth;\n \n /* An array of all local classes present in this translation unit, in\n    declaration order.  */\n-extern GTY(()) VEC(tree,gc) *local_classes;\n+extern GTY(()) vec<tree, va_gc> *local_classes;\n \f\n /* Here's where we control how name mangling takes place.  */\n \n@@ -4917,20 +4912,20 @@ extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_new_function_call\t\t(tree, VEC(tree,gc) **, bool, \n+extern tree build_new_function_call\t\t(tree, vec<tree, va_gc> **, bool, \n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_operator_new_call\t\t(tree, VEC(tree,gc) **, tree *,\n+extern tree build_operator_new_call\t\t(tree, vec<tree, va_gc> **, tree *,\n \t\t\t\t\t\t tree *, tree, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_new_method_call\t\t(tree, tree, VEC(tree,gc) **,\n+extern tree build_new_method_call\t\t(tree, tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tree, int, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_special_member_call\t\t(tree, tree, VEC(tree,gc) **,\n+extern tree build_special_member_call\t\t(tree, tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tree, int, tsubst_flags_t);\n extern tree build_new_op\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t int, tree, tree, tree, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_op_call\t\t\t(tree, VEC(tree,gc) **,\n+extern tree build_op_call\t\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_delete_call\t\t(enum tree_code, tree, tree,\n \t\t\t\t\t\t bool, tree, tree,\n@@ -4954,7 +4949,7 @@ extern tree convert_for_arg_passing\t\t(tree, tree, tsubst_flags_t);\n extern bool is_properly_derived_from\t\t(tree, tree);\n extern tree initialize_reference\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree extend_ref_init_temps\t\t(tree, tree, VEC(tree,gc)**);\n+extern tree extend_ref_init_temps\t\t(tree, tree, vec<tree, va_gc>**);\n extern tree make_temporary_var_for_ref_to_temp\t(tree, tree);\n extern tree strip_top_quals\t\t\t(tree);\n extern bool reference_related_p\t\t\t(tree, tree);\n@@ -5161,13 +5156,13 @@ extern tree check_elaborated_type_specifier\t(enum tag_types, tree, bool);\n extern void warn_extern_redeclared_static\t(tree, tree);\n extern tree cxx_comdat_group\t\t\t(tree);\n extern bool cp_missing_noreturn_ok_p\t\t(tree);\n-extern void initialize_artificial_var\t\t(tree, VEC(constructor_elt,gc) *);\n+extern void initialize_artificial_var\t\t(tree, vec<constructor_elt, va_gc> *);\n extern tree check_var_type\t\t\t(tree, tree);\n extern tree reshape_init                        (tree, tree, tsubst_flags_t);\n extern tree next_initializable_field (tree);\n \n extern bool defer_mark_used_calls;\n-extern GTY(()) VEC(tree, gc) *deferred_mark_used_calls;\n+extern GTY(()) vec<tree, va_gc> *deferred_mark_used_calls;\n extern tree finish_case_label\t\t\t(location_t, tree, tree);\n extern tree cxx_maybe_build_cleanup\t\t(tree, tsubst_flags_t);\n \n@@ -5199,7 +5194,7 @@ extern void determine_visibility\t\t(tree);\n extern void constrain_class_visibility\t\t(tree);\n extern void import_export_decl\t\t\t(tree);\n extern tree build_cleanup\t\t\t(tree);\n-extern tree build_offset_ref_call_from_tree\t(tree, VEC(tree,gc) **,\n+extern tree build_offset_ref_call_from_tree\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern bool decl_constant_var_p\t\t\t(tree);\n extern bool decl_maybe_constant_var_p\t\t(tree);\n@@ -5285,8 +5280,8 @@ extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree, tsubst_flags_t);\n extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);\n extern tree build_offset_ref\t\t\t(tree, tree, bool);\n-extern tree build_new\t\t\t\t(VEC(tree,gc) **, tree, tree,\n-\t\t\t\t\t\t VEC(tree,gc) **, int,\n+extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n+\t\t\t\t\t\t vec<tree, va_gc> **, int,\n                                                  tsubst_flags_t);\n extern tree get_temp_regvar\t\t\t(tree, tree);\n extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int,\n@@ -5408,7 +5403,7 @@ extern tree make_pack_expansion                 (tree);\n extern bool check_for_bare_parameter_packs      (tree);\n extern tree build_template_info\t\t\t(tree, tree);\n extern tree get_template_info\t\t\t(const_tree);\n-extern VEC(qualified_typedef_usage_t,gc)* get_types_needing_access_check (tree);\n+extern vec<qualified_typedef_usage_t, va_gc> *get_types_needing_access_check (tree);\n extern int template_class_depth\t\t\t(tree);\n extern int is_specialization_of\t\t\t(tree, tree);\n extern bool is_specialization_of_friend\t\t(tree, tree);\n@@ -5435,7 +5430,7 @@ extern bool any_dependent_template_arguments_p  (const_tree);\n extern bool dependent_template_p\t\t(tree);\n extern bool dependent_template_id_p\t\t(tree, tree);\n extern bool type_dependent_expression_p\t\t(tree);\n-extern bool any_type_dependent_arguments_p      (const VEC(tree,gc) *);\n+extern bool any_type_dependent_arguments_p      (const vec<tree, va_gc> *);\n extern bool any_type_dependent_elements_p       (const_tree);\n extern bool type_dependent_expression_p_push\t(tree);\n extern bool value_dependent_expression_p\t(tree);\n@@ -5445,7 +5440,7 @@ extern bool dependent_omp_for_p\t\t\t(tree, tree, tree, tree);\n extern tree resolve_typename_type\t\t(tree, bool);\n extern tree template_for_substitution\t\t(tree);\n extern tree build_non_dependent_expr\t\t(tree);\n-extern void make_args_non_dependent\t\t(VEC(tree,gc) *);\n+extern void make_args_non_dependent\t\t(vec<tree, va_gc> *);\n extern bool reregister_specialization\t\t(tree, tree, tree);\n extern tree fold_non_dependent_expr\t\t(tree);\n extern tree fold_non_dependent_expr_sfinae\t(tree, tsubst_flags_t);\n@@ -5476,7 +5471,7 @@ extern void finish_repo\t\t\t\t(void);\n \n /* in rtti.c */\n /* A vector of all tinfo decls that haven't been emitted yet.  */\n-extern GTY(()) VEC(tree,gc) *unemitted_tinfo_decls;\n+extern GTY(()) vec<tree, va_gc> *unemitted_tinfo_decls;\n \n extern void init_rtti_processing\t\t(void);\n extern tree build_typeid\t\t\t(tree);\n@@ -5543,17 +5538,15 @@ typedef struct GTY(()) deferred_access_check {\n   /* The location of this access.  */\n   location_t loc;\n } deferred_access_check;\n-DEF_VEC_O(deferred_access_check);\n-DEF_VEC_ALLOC_O(deferred_access_check,gc);\n \n /* in semantics.c */\n extern void push_deferring_access_checks\t(deferring_kind);\n extern void resume_deferring_access_checks\t(void);\n extern void stop_deferring_access_checks\t(void);\n extern void pop_deferring_access_checks\t\t(void);\n-extern VEC (deferred_access_check,gc)* get_deferred_access_checks\t\t(void);\n+extern vec<deferred_access_check, va_gc> *get_deferred_access_checks (void);\n extern void pop_to_parent_deferring_access_checks (void);\n-extern bool perform_access_checks (VEC (deferred_access_check,gc)*,\n+extern bool perform_access_checks (vec<deferred_access_check, va_gc> *,\n \t\t\t\t   tsubst_flags_t);\n extern bool perform_deferred_access_checks\t(tsubst_flags_t);\n extern bool perform_or_defer_access_check\t(tree, tree, tree,\n@@ -5617,7 +5610,7 @@ extern tree maybe_constant_init (tree);\n extern bool is_sub_constant_expr (tree);\n extern bool reduced_constant_expression_p (tree);\n extern void explain_invalid_constexpr_fn (tree);\n-extern VEC(tree,heap)* cx_error_context (void);\n+extern vec<tree> cx_error_context (void);\n \n enum {\n   BCS_NO_SCOPE = 1,\n@@ -5638,9 +5631,9 @@ extern tree finish_stmt_expr_expr\t\t(tree, tree);\n extern tree finish_stmt_expr\t\t\t(tree, bool);\n extern tree stmt_expr_value_expr\t\t(tree);\n bool empty_expr_stmt_p\t\t\t\t(tree);\n-extern tree perform_koenig_lookup\t\t(tree, VEC(tree,gc) *, bool,\n+extern tree perform_koenig_lookup\t\t(tree, vec<tree, va_gc> *, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree finish_call_expr\t\t\t(tree, VEC(tree,gc) **, bool,\n+extern tree finish_call_expr\t\t\t(tree, vec<tree, va_gc> **, bool,\n \t\t\t\t\t\t bool, tsubst_flags_t);\n extern tree finish_increment_expr\t\t(tree, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n@@ -5766,7 +5759,7 @@ extern tree build_min\t\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_nt_loc\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t ...);\n extern tree build_min_non_dep\t\t\t(enum tree_code, tree, ...);\n-extern tree build_min_non_dep_call_vec\t\t(tree, tree, VEC(tree,gc) *);\n+extern tree build_min_non_dep_call_vec\t\t(tree, tree, vec<tree, va_gc> *);\n extern tree build_cplus_new\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_aggr_init_expr\t\t(tree, tree, tsubst_flags_t);\n extern tree get_target_expr\t\t\t(tree);\n@@ -5887,7 +5880,7 @@ extern tree get_member_function_from_ptrfunc\t(tree *, tree, tsubst_flags_t);\n extern tree cp_build_function_call              (tree, tree, tsubst_flags_t);\n extern tree cp_build_function_call_nary         (tree, tsubst_flags_t, ...)\n \t\t\t\t\t\tATTRIBUTE_SENTINEL;\n-extern tree cp_build_function_call_vec\t\t(tree, VEC(tree,gc) **,\n+extern tree cp_build_function_call_vec\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_binary_op\t\t\t(location_t,\n \t\t\t\t\t\t enum tree_code, tree,\n@@ -5908,8 +5901,8 @@ extern tree build_x_conditional_expr\t\t(location_t, tree, tree, tree,\n                                                  tsubst_flags_t);\n extern tree build_x_compound_expr_from_list\t(tree, expr_list_kind,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_x_compound_expr_from_vec\t(VEC(tree,gc) *, const char *,\n-\t\t\t\t\t\t tsubst_flags_t);\n+extern tree build_x_compound_expr_from_vec\t(vec<tree, va_gc> *,\n+\t\t\t\t\t\t const char *, tsubst_flags_t);\n extern tree build_x_compound_expr\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_compound_expr                 (location_t, tree, tree);\n@@ -5985,7 +5978,7 @@ extern void complete_type_check_abstract\t(tree);\n extern int abstract_virtuals_error\t\t(tree, tree);\n extern int abstract_virtuals_error_sfinae\t(tree, tree, tsubst_flags_t);\n \n-extern tree store_init_value\t\t\t(tree, tree, VEC(tree,gc)**, int);\n+extern tree store_init_value\t\t\t(tree, tree, vec<tree, va_gc>**, int);\n extern void check_narrowing\t\t\t(tree, tree);\n extern tree digest_init\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree digest_init_flags\t\t\t(tree, tree, int);"}, {"sha": "1dc789855cc6583c40c2e42eb6df31bd0dd69e5d", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -561,7 +561,7 @@ force_rvalue (tree expr, tsubst_flags_t complain)\n   tree type = TREE_TYPE (expr);\n   if (MAYBE_CLASS_TYPE_P (type) && TREE_CODE (expr) != TARGET_EXPR)\n     {\n-      VEC(tree,gc) *args = make_tree_vector_single (expr);\n+      vec<tree, va_gc> *args = make_tree_vector_single (expr);\n       expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t\t&args, type, LOOKUP_NORMAL, complain);\n       release_tree_vector (args);\n@@ -855,7 +855,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \tctor = build_user_type_conversion (type, ctor, flags, complain);\n       else\n \t{\n-\t  VEC(tree,gc) *ctor_vec = make_tree_vector_single (ctor);\n+\t  vec<tree, va_gc> *ctor_vec = make_tree_vector_single (ctor);\n \t  ctor = build_special_member_call (NULL_TREE,\n \t\t\t\t\t    complete_ctor_identifier,\n \t\t\t\t\t    &ctor_vec,"}, {"sha": "bae48cefdf483bb8e98690de1a9aaddfc9e2f6f1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -91,7 +91,7 @@ static tree lookup_and_check_tag (enum tag_types, tree, tag_scope, bool);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n static void maybe_deduce_size_from_array_init (tree, tree);\n static void layout_var_decl (tree);\n-static tree check_initializer (tree, tree, int, VEC(tree,gc) **);\n+static tree check_initializer (tree, tree, int, vec<tree, va_gc> **);\n static void make_rtl_for_nonlocal_decl (tree, tree, const char *);\n static void save_function_data (tree);\n static void copy_type_enum (tree , tree);\n@@ -218,7 +218,7 @@ struct GTY(()) named_label_entry {\n   tree names_in_scope;\n   /* A vector of all decls from all binding levels that would be\n      crossed by a backward branch to the label.  */\n-  VEC(tree,gc) *bad_decls;\n+  vec<tree, va_gc> *bad_decls;\n \n   /* A list of uses of the label, before the label is defined.  */\n   struct named_label_use_entry *uses;\n@@ -241,7 +241,7 @@ int function_depth;\n /* To avoid unwanted recursion, finish_function defers all mark_used calls\n    encountered during its execution until it finishes.  */\n bool defer_mark_used_calls;\n-VEC(tree, gc) *deferred_mark_used_calls;\n+vec<tree, va_gc> *deferred_mark_used_calls;\n \n /* States indicating how grokdeclarator() should handle declspecs marked\n    with __attribute__((deprecated)).  An object declared as\n@@ -258,10 +258,8 @@ typedef struct GTY(()) incomplete_var_d {\n   tree incomplete_type;\n } incomplete_var;\n \n-DEF_VEC_O(incomplete_var);\n-DEF_VEC_ALLOC_O(incomplete_var,gc);\n \n-static GTY(()) VEC(incomplete_var,gc) *incomplete_vars;\n+static GTY(()) vec<incomplete_var, va_gc> *incomplete_vars;\n \f\n /* Returns the kind of template specialization we are currently\n    processing, given that it's declaration contained N_CLASS_SCOPES\n@@ -486,7 +484,7 @@ poplevel_named_label_1 (void **slot, void *data)\n \t\t\t\t\t\t     ? DECL_CHAIN (decl)\n \t\t\t\t\t\t     : TREE_CHAIN (decl)))\n \tif (decl_jump_unsafe (decl))\n-\t  VEC_safe_push (tree, gc, ent->bad_decls, decl);\n+\t  vec_safe_push (ent->bad_decls, decl);\n \n       ent->binding_level = obl;\n       ent->names_in_scope = obl->names;\n@@ -567,8 +565,7 @@ poplevel (int keep, int reverse, int functionbody)\n     functionbody = 0;\n   subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n \n-  gcc_assert (!VEC_length(cp_class_binding,\n-\t\t\t  current_binding_level->class_shadowed));\n+  gcc_assert (!vec_safe_length (current_binding_level->class_shadowed));\n \n   /* We used to use KEEP == 2 to indicate that the new block should go\n      at the beginning of the list of blocks at this binding level,\n@@ -708,9 +705,9 @@ poplevel (int keep, int reverse, int functionbody)\n \t      /* Add it to the list of dead variables in the next\n \t\t outermost binding to that we can remove these when we\n \t\t leave that binding.  */\n-\t      VEC_safe_push (tree, gc,\n-\t\t\t     current_binding_level->level_chain->dead_vars_from_for,\n-\t\t\t     link);\n+\t      vec_safe_push (\n+\t\t  current_binding_level->level_chain->dead_vars_from_for,\n+\t\t  link);\n \n \t      /* Although we don't pop the cxx_binding, we do clear\n \t\t its SCOPE since the scope is going away now.  */\n@@ -739,8 +736,8 @@ poplevel (int keep, int reverse, int functionbody)\n \n   /* Remove declarations for any `for' variables from inner scopes\n      that we kept around.  */\n-  FOR_EACH_VEC_ELT_REVERSE (tree, current_binding_level->dead_vars_from_for,\n-\t\t\t    ix, decl)\n+  FOR_EACH_VEC_SAFE_ELT_REVERSE (current_binding_level->dead_vars_from_for,\n+\t\t\t         ix, decl)\n     pop_binding (DECL_NAME (decl), decl);\n \n   /* Restore the IDENTIFIER_TYPE_VALUEs.  */\n@@ -749,9 +746,8 @@ poplevel (int keep, int reverse, int functionbody)\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n \n   /* Restore the IDENTIFIER_LABEL_VALUEs for local labels.  */\n-  FOR_EACH_VEC_ELT_REVERSE (cp_label_binding,\n-\t\t\t    current_binding_level->shadowed_labels,\n-\t\t\t    ix, label_bind)\n+  FOR_EACH_VEC_SAFE_ELT_REVERSE (current_binding_level->shadowed_labels,\n+\t\t\t         ix, label_bind)\n     pop_local_label (label_bind->label, label_bind->prev_value);\n \n   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n@@ -866,9 +862,9 @@ int\n wrapup_globals_for_namespace (tree name_space, void* data)\n {\n   cp_binding_level *level = NAMESPACE_LEVEL (name_space);\n-  VEC(tree,gc) *statics = level->static_decls;\n-  tree *vec = VEC_address (tree, statics);\n-  int len = VEC_length (tree, statics);\n+  vec<tree, va_gc> *statics = level->static_decls;\n+  tree *vec = statics->address ();\n+  int len = statics->length ();\n   int last_time = (data != 0);\n \n   if (last_time)\n@@ -917,10 +913,10 @@ push_local_name (tree decl)\n \n   name = DECL_NAME (decl);\n \n-  nelts = VEC_length (tree, local_names);\n+  nelts = vec_safe_length (local_names);\n   for (i = 0; i < nelts; i++)\n     {\n-      t = VEC_index (tree, local_names, i);\n+      t = (*local_names)[i];\n       if (DECL_NAME (t) == name)\n \t{\n \t  if (!DECL_LANG_SPECIFIC (decl))\n@@ -931,13 +927,13 @@ push_local_name (tree decl)\n \t  else\n \t    DECL_DISCRIMINATOR (decl) = 1;\n \n-\t  VEC_replace (tree, local_names, i, decl);\n+\t  (*local_names)[i] = decl;\n \t  timevar_stop (TV_NAME_LOOKUP);\n \t  return;\n \t}\n     }\n \n-  VEC_safe_push (tree, gc, local_names, decl);\n+  vec_safe_push (local_names, decl);\n   timevar_stop (TV_NAME_LOOKUP);\n }\n \f\n@@ -2706,8 +2702,7 @@ declare_local_label (tree id)\n \n   decl = make_label_decl (id, /*local_p=*/1);\n   bind.label = decl;\n-  VEC_safe_push (cp_label_binding, gc, current_binding_level->shadowed_labels,\n-\t\t bind);\n+  vec_safe_push (current_binding_level->shadowed_labels, bind);\n \n   return decl;\n }\n@@ -2890,14 +2885,14 @@ check_goto (tree decl)\n     }\n \n   if (ent->in_try_scope || ent->in_catch_scope\n-      || ent->in_omp_scope || !VEC_empty (tree, ent->bad_decls))\n+      || ent->in_omp_scope || !vec_safe_is_empty (ent->bad_decls))\n     {\n       permerror (input_location, \"jump to label %q+D\", decl);\n       permerror (input_location, \"  from here\");\n       identified = true;\n     }\n \n-  FOR_EACH_VEC_ELT (tree, ent->bad_decls, ix, bad)\n+  FOR_EACH_VEC_SAFE_ELT (ent->bad_decls, ix, bad)\n     {\n       int u = decl_jump_unsafe (bad);\n \n@@ -4824,10 +4819,10 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n \t initializer.  */\n       if (initializer && TREE_CODE (initializer) == CONSTRUCTOR)\n \t{\n-\t  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (initializer);\n+\t  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (initializer);\n \t  constructor_elt *ce;\n \t  HOST_WIDE_INT i;\n-\t  FOR_EACH_VEC_ELT (constructor_elt, v, i, ce)\n+\t  FOR_EACH_VEC_SAFE_ELT (v, i, ce)\n \t    if (!check_array_designated_initializer (ce, i))\n \t      failure = 1;\n \t}\n@@ -5308,7 +5303,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n \t}\n       else if (first_initializer_p && d->cur != d->end)\n \t{\n-\t  VEC(constructor_elt, gc) *v = 0;\n+\t  vec<constructor_elt, va_gc> *v = 0;\n \t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n \t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, d->cur->value);\n \t  if (has_designator_problem (d, complain))\n@@ -5382,10 +5377,9 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n \t element (as allowed by [dcl.init.string]).  */\n       if (!first_initializer_p\n \t  && TREE_CODE (str_init) == CONSTRUCTOR\n-\t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (str_init)) == 1)\n+\t  && vec_safe_length (CONSTRUCTOR_ELTS (str_init)) == 1)\n \t{\n-\t  str_init = VEC_index (constructor_elt,\n-\t\t\t\tCONSTRUCTOR_ELTS (str_init), 0).value;\n+\t  str_init = (*CONSTRUCTOR_ELTS (str_init))[0].value;\n \t}\n \n       /* If it's a string literal, then it's the initializer for the array\n@@ -5453,15 +5447,15 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n      struct S { int a; int b; };\n      struct S a[] = { 1, 2, 3, 4 };\n \n-   Here INIT will hold a VEC of four elements, rather than a\n-   VEC of two elements, each itself a VEC of two elements.  This\n+   Here INIT will hold a vector of four elements, rather than a\n+   vector of two elements, each itself a vector of two elements.  This\n    routine transforms INIT from the former form into the latter.  The\n    revised CONSTRUCTOR node is returned.  */\n \n tree\n reshape_init (tree type, tree init, tsubst_flags_t complain)\n {\n-  VEC(constructor_elt, gc) *v;\n+  vec<constructor_elt, va_gc> *v;\n   reshape_iter d;\n   tree new_init;\n \n@@ -5471,12 +5465,12 @@ reshape_init (tree type, tree init, tsubst_flags_t complain)\n \n   /* An empty constructor does not need reshaping, and it is always a valid\n      initializer.  */\n-  if (VEC_empty (constructor_elt, v))\n+  if (vec_safe_is_empty (v))\n     return init;\n \n   /* Recurse on this CONSTRUCTOR.  */\n-  d.cur = &VEC_index (constructor_elt, v, 0);\n-  d.end = d.cur + VEC_length (constructor_elt, v);\n+  d.cur = &(*v)[0];\n+  d.end = d.cur + v->length ();\n \n   new_init = reshape_init_r (type, &d, true, complain);\n   if (new_init == error_mark_node)\n@@ -5546,7 +5540,7 @@ build_aggr_init_full_exprs (tree decl, tree init, int flags)\n    evaluated dynamically to initialize DECL.  */\n \n static tree\n-check_initializer (tree decl, tree init, int flags, VEC(tree,gc) **cleanups)\n+check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n {\n   tree type = TREE_TYPE (decl);\n   tree init_code = NULL;\n@@ -5586,7 +5580,7 @@ check_initializer (tree decl, tree init, int flags, VEC(tree,gc) **cleanups)\n \n   if (init && BRACE_ENCLOSED_INITIALIZER_P (init))\n     {\n-      int init_len = VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init));\n+      int init_len = vec_safe_length (CONSTRUCTOR_ELTS (init));\n       if (SCALAR_TYPE_P (type))\n \t{\n \t  if (init_len == 0)\n@@ -5991,7 +5985,7 @@ initialize_local_var (tree decl, tree init)\n    back end.  */\n \n void\n-initialize_artificial_var (tree decl, VEC(constructor_elt,gc) *v)\n+initialize_artificial_var (tree decl, vec<constructor_elt, va_gc> *v)\n {\n   tree init;\n   gcc_assert (DECL_ARTIFICIAL (decl));\n@@ -6017,15 +6011,14 @@ type_dependent_init_p (tree init)\n   else if (TREE_CODE (init) == CONSTRUCTOR)\n   /* A brace-enclosed initializer, e.g.: int i = { 3 }; ? */\n     {\n-      VEC(constructor_elt, gc) *elts;\n+      vec<constructor_elt, va_gc> *elts;\n       size_t nelts;\n       size_t i;\n \n       elts = CONSTRUCTOR_ELTS (init);\n-      nelts = VEC_length (constructor_elt, elts);\n+      nelts = vec_safe_length (elts);\n       for (i = 0; i < nelts; ++i)\n-\tif (type_dependent_init_p (VEC_index (constructor_elt,\n-\t\t\t\t\t      elts, i).value))\n+\tif (type_dependent_init_p ((*elts)[i].value))\n \t  return true;\n     }\n   else\n@@ -6047,15 +6040,14 @@ value_dependent_init_p (tree init)\n   else if (TREE_CODE (init) == CONSTRUCTOR)\n   /* A brace-enclosed initializer, e.g.: int i = { 3 }; ? */\n     {\n-      VEC(constructor_elt, gc) *elts;\n+      vec<constructor_elt, va_gc> *elts;\n       size_t nelts;\n       size_t i;\n \n       elts = CONSTRUCTOR_ELTS (init);\n-      nelts = VEC_length (constructor_elt, elts);\n+      nelts = vec_safe_length (elts);\n       for (i = 0; i < nelts; ++i)\n-\tif (value_dependent_init_p (VEC_index (constructor_elt,\n-\t\t\t\t\t       elts, i).value))\n+\tif (value_dependent_init_p ((*elts)[i].value))\n \t  return true;\n     }\n   else\n@@ -6081,7 +6073,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\ttree asmspec_tree, int flags)\n {\n   tree type;\n-  VEC(tree,gc) *cleanups = NULL;\n+  vec<tree, va_gc> *cleanups = NULL;\n   const char *asmspec = NULL;\n   int was_readonly = 0;\n   bool var_definition_p = false;\n@@ -6489,7 +6481,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   if (cleanups)\n     {\n       unsigned i; tree t;\n-      FOR_EACH_VEC_ELT (tree, cleanups, i, t)\n+      FOR_EACH_VEC_ELT (*cleanups, i, t)\n \tpush_cleanup (decl, t, false);\n       release_tree_vector (cleanups);\n     }\n@@ -6769,7 +6761,7 @@ register_dtor_fn (tree decl)\n       /* Find the destructor.  */\n       idx = lookup_fnfields_1 (type, complete_dtor_identifier);\n       gcc_assert (idx >= 0);\n-      cleanup = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), idx);\n+      cleanup = (*CLASSTYPE_METHOD_VEC (type))[idx];\n       /* Make sure it is accessible.  */\n       perform_or_defer_access_check (TYPE_BINFO (type), cleanup, cleanup,\n \t\t\t\t     tf_warning_or_error);\n@@ -7053,13 +7045,13 @@ cp_complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t we should just call reshape_init here?  */\n       if (char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (*ptype)))\n \t  && TREE_CODE (initial_value) == CONSTRUCTOR\n-\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (initial_value)))\n+\t  && !vec_safe_is_empty (CONSTRUCTOR_ELTS (initial_value)))\n \t{\n-\t  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (initial_value);\n-\t  tree value = VEC_index (constructor_elt, v, 0).value;\n+\t  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (initial_value);\n+\t  tree value = (*v)[0].value;\n \n \t  if (TREE_CODE (value) == STRING_CST\n-\t      && VEC_length (constructor_elt, v) == 1)\n+\t      && v->length () == 1)\n \t    initial_value = value;\n \t}\n \n@@ -12108,7 +12100,7 @@ xref_basetypes (tree ref, tree base_list)\n \t  if (TREE_TYPE (*basep))\n \t    max_vbases++;\n \t  if (CLASS_TYPE_P (basetype))\n-\t    max_vbases += VEC_length (tree, CLASSTYPE_VBASECLASSES (basetype));\n+\t    max_vbases += vec_safe_length (CLASSTYPE_VBASECLASSES (basetype));\n \t  basep = &TREE_CHAIN (*basep);\n \t}\n     }\n@@ -12136,7 +12128,7 @@ xref_basetypes (tree ref, tree base_list)\n \n   if (max_bases)\n     {\n-      BINFO_BASE_ACCESSES (binfo) = VEC_alloc (tree, gc, max_bases);\n+      vec_alloc (BINFO_BASE_ACCESSES (binfo), max_bases);\n       /* An aggregate cannot have baseclasses.  */\n       CLASSTYPE_NON_AGGREGATE (ref) = 1;\n \n@@ -12158,7 +12150,7 @@ xref_basetypes (tree ref, tree base_list)\n \n   if (max_vbases)\n     {\n-      CLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, gc, max_vbases);\n+      vec_alloc (CLASSTYPE_VBASECLASSES (ref), max_vbases);\n \n       if (TYPE_FOR_JAVA (ref))\n         {\n@@ -12236,7 +12228,7 @@ xref_basetypes (tree ref, tree base_list)\n       BINFO_BASE_ACCESS_APPEND (binfo, access);\n     }\n \n-  if (VEC_length (tree, CLASSTYPE_VBASECLASSES (ref)) < max_vbases)\n+  if (vec_safe_length (CLASSTYPE_VBASECLASSES (ref)) < max_vbases)\n     /* If we didn't get max_vbases vbases, we must have shared at\n        least one of them, and are therefore diamond shaped.  */\n     CLASSTYPE_DIAMOND_SHAPED_P (ref) = 1;\n@@ -13919,9 +13911,9 @@ finish_function (int flags)\n       unsigned int i;\n       tree decl;\n \n-      FOR_EACH_VEC_ELT (tree, deferred_mark_used_calls, i, decl)\n+      FOR_EACH_VEC_SAFE_ELT (deferred_mark_used_calls, i, decl)\n \tmark_used (decl);\n-      VEC_free (tree, gc, deferred_mark_used_calls);\n+      vec_free (deferred_mark_used_calls);\n     }\n \n   return fndecl;\n@@ -14032,7 +14024,7 @@ maybe_register_incomplete_var (tree var)\n \t      && TYPE_BEING_DEFINED (inner_type)))\n \t{\n \t  incomplete_var iv = {var, inner_type};\n-\t  VEC_safe_push (incomplete_var, gc, incomplete_vars, iv);\n+\t  vec_safe_push (incomplete_vars, iv);\n \t}\n     }\n }\n@@ -14047,7 +14039,7 @@ complete_vars (tree type)\n   unsigned ix;\n   incomplete_var *iv;\n \n-  for (ix = 0; VEC_iterate (incomplete_var, incomplete_vars, ix, iv); )\n+  for (ix = 0; vec_safe_iterate (incomplete_vars, ix, &iv); )\n     {\n       if (same_type_p (type, iv->incomplete_type))\n \t{\n@@ -14058,7 +14050,7 @@ complete_vars (tree type)\n \t  complete_type (type);\n \t  cp_apply_type_quals_to_decl (cp_type_quals (type), var);\n \t  /* Remove this entry from the list.  */\n-\t  VEC_unordered_remove (incomplete_var, incomplete_vars, ix);\n+\t  incomplete_vars->unordered_remove (ix);\n \t}\n       else\n \tix++;"}, {"sha": "9ed53b819fce9130a0b144c08a211251414787a6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -90,15 +90,15 @@ static bool decl_defined_p (tree);\n /* A list of static class variables.  This is needed, because a\n    static class variable can be declared inside the class without\n    an initializer, and then initialized, statically, outside the class.  */\n-static GTY(()) VEC(tree,gc) *pending_statics;\n+static GTY(()) vec<tree, va_gc> *pending_statics;\n \n /* A list of functions which were declared inline, but which we\n    may need to emit outline anyway.  */\n-static GTY(()) VEC(tree,gc) *deferred_fns;\n+static GTY(()) vec<tree, va_gc> *deferred_fns;\n \n /* A list of decls that use types with no linkage, which we need to make\n    sure are defined.  */\n-static GTY(()) VEC(tree,gc) *no_linkage_decls;\n+static GTY(()) vec<tree, va_gc> *no_linkage_decls;\n \n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n@@ -644,12 +644,12 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   ix = class_method_index_for_fn (complete_type (ctype), function);\n   if (ix >= 0)\n     {\n-      VEC(tree,gc) *methods = CLASSTYPE_METHOD_VEC (ctype);\n+      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (ctype);\n       tree fndecls, fndecl = 0;\n       bool is_conv_op;\n       const char *format = NULL;\n \n-      for (fndecls = VEC_index (tree, methods, ix);\n+      for (fndecls = (*methods)[ix];\n \t   fndecls; fndecls = OVL_NEXT (fndecls))\n \t{\n \t  tree p1, p2;\n@@ -705,17 +705,17 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \n       if (is_conv_op)\n \tix = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-      fndecls = VEC_index (tree, methods, ix);\n+      fndecls = (*methods)[ix];\n       while (fndecls)\n \t{\n \t  fndecl = OVL_CURRENT (fndecls);\n \t  fndecls = OVL_NEXT (fndecls);\n \n \t  if (!fndecls && is_conv_op)\n \t    {\n-\t      if (VEC_length (tree, methods) > (size_t) ++ix)\n+\t      if (methods->length () > (size_t) ++ix)\n \t\t{\n-\t\t  fndecls = VEC_index (tree, methods, ix);\n+\t\t  fndecls = (*methods)[ix];\n \t\t  if (!DECL_CONV_FN_P (OVL_CURRENT (fndecls)))\n \t\t    {\n \t\t      fndecls = NULL_TREE;\n@@ -753,7 +753,7 @@ void\n note_vague_linkage_fn (tree decl)\n {\n   DECL_DEFER_OUTPUT (decl) = 1;\n-  VEC_safe_push (tree, gc, deferred_fns, decl);\n+  vec_safe_push (deferred_fns, decl);\n }\n \n /* We have just processed the DECL, which is a static data member.\n@@ -772,7 +772,7 @@ finish_static_data_member_decl (tree decl,\n      the right thing, namely, to put this decl out straight away.  */\n \n   if (! processing_template_decl)\n-    VEC_safe_push (tree, gc, pending_statics, decl);\n+    vec_safe_push (pending_statics, decl);\n \n   if (LOCAL_CLASS_P (current_class_type)\n       /* We already complained about the template definition.  */\n@@ -1879,7 +1879,7 @@ maybe_emit_vtables (tree ctype)\n \n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n \t{\n-\t  VEC(tree,gc)* cleanups = NULL;\n+\t  vec<tree, va_gc> *cleanups = NULL;\n \t  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl), &cleanups,\n \t\t\t\t\tLOOKUP_NORMAL);\n \n@@ -3063,7 +3063,7 @@ static GTY(()) tree ssdf_decl;\n \n /* All the static storage duration functions created in this\n    translation unit.  */\n-static GTY(()) VEC(tree,gc) *ssdf_decls;\n+static GTY(()) vec<tree, va_gc> *ssdf_decls;\n \n /* A map from priority levels to information about that priority\n    level.  There may be many such levels, so efficient lookup is\n@@ -3108,7 +3108,7 @@ start_static_storage_duration_function (unsigned count)\n      static constructors and destructors.  */\n   if (!ssdf_decls)\n     {\n-      ssdf_decls = VEC_alloc (tree, gc, 32);\n+      vec_alloc (ssdf_decls, 32);\n \n       /* Take this opportunity to initialize the map from priority\n \t numbers to information about that priority level.  */\n@@ -3124,7 +3124,7 @@ start_static_storage_duration_function (unsigned count)\n       get_priority_info (DEFAULT_INIT_PRIORITY);\n     }\n \n-  VEC_safe_push (tree, gc, ssdf_decls, ssdf_decl);\n+  vec_safe_push (ssdf_decls, ssdf_decl);\n \n   /* Create the argument list.  */\n   initialize_p_decl = cp_build_parm_decl\n@@ -3568,7 +3568,7 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n \n   /* Call the static storage duration function with appropriate\n      arguments.  */\n-  FOR_EACH_VEC_ELT (tree, ssdf_decls, i, fndecl)\n+  FOR_EACH_VEC_SAFE_ELT (ssdf_decls, i, fndecl)\n     {\n       /* Calls to pure or const functions will expand to nothing.  */\n       if (! (flags_from_decl_or_type (fndecl) & (ECF_CONST | ECF_PURE)))\n@@ -3941,7 +3941,7 @@ cp_write_global_declarations (void)\n \n   /* Bad parse errors.  Just forget about it.  */\n   if (! global_bindings_p () || current_class_type\n-      || !VEC_empty (tree,decl_namespace_list))\n+      || !vec_safe_is_empty (decl_namespace_list))\n     return;\n \n   if (pch_file)\n@@ -4031,12 +4031,12 @@ cp_write_global_declarations (void)\n \t cause other variables to be needed. New elements will be\n \t appended, and we remove from the vector those that actually\n \t get emitted.  */\n-      for (i = VEC_length (tree, unemitted_tinfo_decls);\n-\t   VEC_iterate (tree, unemitted_tinfo_decls, --i, t);)\n+      for (i = unemitted_tinfo_decls->length ();\n+\t   unemitted_tinfo_decls->iterate (--i, &t);)\n \tif (emit_tinfo_decl (t))\n \t  {\n \t    reconsider = true;\n-\t    VEC_unordered_remove (tree, unemitted_tinfo_decls, i);\n+\t    unemitted_tinfo_decls->unordered_remove (i);\n \t  }\n \n       /* The list of objects with static storage duration is built up\n@@ -4102,7 +4102,7 @@ cp_write_global_declarations (void)\n       /* Go through the set of inline functions whose bodies have not\n \t been emitted yet.  If out-of-line copies of these functions\n \t are required, emit them.  */\n-      FOR_EACH_VEC_ELT (tree, deferred_fns, i, decl)\n+      FOR_EACH_VEC_SAFE_ELT (deferred_fns, i, decl)\n \t{\n \t  /* Does it need synthesizing?  */\n \t  if (DECL_DEFAULTED_FN (decl) && ! DECL_INITIAL (decl)\n@@ -4196,7 +4196,7 @@ cp_write_global_declarations (void)\n \treconsider = true;\n \n       /* Static data members are just like namespace-scope globals.  */\n-      FOR_EACH_VEC_ELT (tree, pending_statics, i, decl)\n+      FOR_EACH_VEC_SAFE_ELT (pending_statics, i, decl)\n \t{\n \t  if (var_finalized_p (decl) || DECL_REALLY_EXTERN (decl)\n \t      /* Don't write it out if we haven't seen a definition.  */\n@@ -4208,17 +4208,17 @@ cp_write_global_declarations (void)\n \t  if (DECL_NOT_REALLY_EXTERN (decl) && decl_needed_p (decl))\n \t    DECL_EXTERNAL (decl) = 0;\n \t}\n-      if (VEC_length (tree, pending_statics) != 0\n-\t  && wrapup_global_declarations (VEC_address (tree, pending_statics),\n-\t\t\t\t\t VEC_length (tree, pending_statics)))\n+      if (vec_safe_length (pending_statics) != 0\n+\t  && wrapup_global_declarations (pending_statics->address (),\n+\t\t\t\t\t pending_statics->length ()))\n \treconsider = true;\n \n       retries++;\n     }\n   while (reconsider);\n \n   /* All used inline functions must have a definition at this point.  */\n-  FOR_EACH_VEC_ELT (tree, deferred_fns, i, decl)\n+  FOR_EACH_VEC_SAFE_ELT (deferred_fns, i, decl)\n     {\n       if (/* Check online inline functions that were actually used.  */\n \t  DECL_ODR_USED (decl) && DECL_DECLARED_INLINE_P (decl)\n@@ -4240,7 +4240,7 @@ cp_write_global_declarations (void)\n     }\n \n   /* So must decls that use a type with no linkage.  */\n-  FOR_EACH_VEC_ELT (tree, no_linkage_decls, i, decl)\n+  FOR_EACH_VEC_SAFE_ELT (no_linkage_decls, i, decl)\n     if (!decl_defined_p (decl))\n       no_linkage_error (decl);\n \n@@ -4292,12 +4292,12 @@ cp_write_global_declarations (void)\n   /* Now, issue warnings about static, but not defined, functions,\n      etc., and emit debugging information.  */\n   walk_namespaces (wrapup_globals_for_namespace, /*data=*/&reconsider);\n-  if (VEC_length (tree, pending_statics) != 0)\n+  if (vec_safe_length (pending_statics) != 0)\n     {\n-      check_global_declarations (VEC_address (tree, pending_statics),\n-\t\t\t\t VEC_length (tree, pending_statics));\n-      emit_debug_global_declarations (VEC_address (tree, pending_statics),\n-\t\t\t\t      VEC_length (tree, pending_statics));\n+      check_global_declarations (pending_statics->address (),\n+\t\t\t\t pending_statics->length ());\n+      emit_debug_global_declarations (pending_statics->address (),\n+\t\t\t\t      pending_statics->length ());\n     }\n \n   perform_deferred_noexcept_checks ();\n@@ -4345,11 +4345,11 @@ cp_write_global_declarations (void)\n    ARGS.  */\n \n tree\n-build_offset_ref_call_from_tree (tree fn, VEC(tree,gc) **args,\n+build_offset_ref_call_from_tree (tree fn, vec<tree, va_gc> **args,\n \t\t\t\t tsubst_flags_t complain)\n {\n   tree orig_fn;\n-  VEC(tree,gc) *orig_args = NULL;\n+  vec<tree, va_gc> *orig_args = NULL;\n   tree expr;\n   tree object;\n \n@@ -4375,7 +4375,7 @@ build_offset_ref_call_from_tree (tree fn, VEC(tree,gc) **args,\n \t{\n \t  if (TREE_CODE (fn) == DOTSTAR_EXPR)\n \t    object = cp_build_addr_expr (object, complain);\n-\t  VEC_safe_insert (tree, gc, *args, 0, object);\n+\t  vec_safe_insert (*args, 0, object);\n \t}\n       /* Now that the arguments are done, transform FN.  */\n       fn = build_non_dependent_expr (fn);\n@@ -4393,7 +4393,7 @@ build_offset_ref_call_from_tree (tree fn, VEC(tree,gc) **args,\n       fn = TREE_OPERAND (fn, 1);\n       fn = get_member_function_from_ptrfunc (&object_addr, fn,\n \t\t\t\t\t     complain);\n-      VEC_safe_insert (tree, gc, *args, 0, object_addr);\n+      vec_safe_insert (*args, 0, object_addr);\n     }\n \n   if (CLASS_TYPE_P (TREE_TYPE (fn)))\n@@ -4519,7 +4519,7 @@ mark_used (tree decl)\n      finishes, otherwise it might recurse.  */\n   if (defer_mark_used_calls)\n     {\n-      VEC_safe_push (tree, gc, deferred_mark_used_calls, decl);\n+      vec_safe_push (deferred_mark_used_calls, decl);\n       return true;\n     }\n \n@@ -4589,7 +4589,7 @@ mark_used (tree decl)\n \t   the vector interferes with GC, so give an error now.  */\n \tno_linkage_error (decl);\n       else\n-\tVEC_safe_push (tree, gc, no_linkage_decls, decl);\n+\tvec_safe_push (no_linkage_decls, decl);\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl)"}, {"sha": "1980cd34bd73954a2cafdf1cb69fd5acc12bd5df", "filename": "gcc/cp/error.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -84,7 +84,7 @@ static void dump_exception_spec (tree, int);\n static void dump_template_argument (tree, int);\n static void dump_template_argument_list (tree, int);\n static void dump_template_parameter (tree, int);\n-static void dump_template_bindings (tree, tree, VEC(tree,gc) *);\n+static void dump_template_bindings (tree, tree, vec<tree, va_gc> *);\n static void dump_scope (tree, int);\n static void dump_template_parms (tree, int, int);\n static int get_non_default_template_args_count (tree, int);\n@@ -259,7 +259,7 @@ dump_template_parameter (tree parm, int flags)\n    TREE_VEC.  */\n \n static void\n-dump_template_bindings (tree parms, tree args, VEC(tree,gc)* typenames)\n+dump_template_bindings (tree parms, tree args, vec<tree, va_gc> *typenames)\n {\n   bool need_semicolon = false;\n   int i;\n@@ -310,10 +310,10 @@ dump_template_bindings (tree parms, tree args, VEC(tree,gc)* typenames)\n     }\n \n   /* Don't bother with typenames for a partial instantiation.  */\n-  if (VEC_empty (tree, typenames) || uses_template_parms (args))\n+  if (vec_safe_is_empty (typenames) || uses_template_parms (args))\n     return;\n \n-  FOR_EACH_VEC_ELT (tree, typenames, i, t)\n+  FOR_EACH_VEC_SAFE_ELT (typenames, i, t)\n     {\n       if (need_semicolon)\n \tpp_separate_with_semicolon (cxx_pp);\n@@ -1275,13 +1275,13 @@ dump_template_decl (tree t, int flags)\n }\n \n /* find_typenames looks through the type of the function template T\n-   and returns a VEC containing any typedefs, decltypes or TYPENAME_TYPEs\n+   and returns a vec containing any typedefs, decltypes or TYPENAME_TYPEs\n    it finds.  */\n \n struct find_typenames_t\n {\n   struct pointer_set_t *p_set;\n-  VEC (tree,gc) *typenames;\n+  vec<tree, va_gc> *typenames;\n };\n \n static tree\n@@ -1299,7 +1299,7 @@ find_typenames_r (tree *tp, int * /*walk_subtrees*/, void *data)\n     mv = TYPE_MAIN_VARIANT (*tp);\n \n   if (mv && (mv == *tp || !pointer_set_insert (d->p_set, mv)))\n-    VEC_safe_push (tree, gc, d->typenames, mv);\n+    vec_safe_push (d->typenames, mv);\n \n   /* Search into class template arguments, which cp_walk_subtrees\n      doesn't do.  */\n@@ -1310,7 +1310,7 @@ find_typenames_r (tree *tp, int * /*walk_subtrees*/, void *data)\n   return NULL_TREE;\n }\n \n-static VEC(tree,gc) *\n+static vec<tree, va_gc> *\n find_typenames (tree t)\n {\n   struct find_typenames_t ft;\n@@ -1338,7 +1338,7 @@ dump_function_decl (tree t, int flags)\n   int show_return = flags & TFF_RETURN_TYPE || flags & TFF_DECL_SPECIFIERS;\n   int do_outer_scope = ! (flags & TFF_UNQUALIFIED_NAME);\n   tree exceptions;\n-  VEC(tree,gc) *typenames = NULL;\n+  vec<tree, va_gc> *typenames = NULL;\n \n   if (DECL_NAME (t) && LAMBDA_FUNCTION_P (t))\n     {\n@@ -1737,15 +1737,15 @@ dump_expr_list (tree l, int flags)\n /* Print out a vector of initializers (subr of dump_expr).  */\n \n static void\n-dump_expr_init_vec (VEC(constructor_elt,gc) *v, int flags)\n+dump_expr_init_vec (vec<constructor_elt, va_gc> *v, int flags)\n {\n   unsigned HOST_WIDE_INT idx;\n   tree value;\n \n   FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n     {\n       dump_expr (value, flags | TFF_EXPR_IN_PARENS);\n-      if (idx != VEC_length (constructor_elt, v) - 1)\n+      if (idx != v->length () - 1)\n \tpp_separate_with_comma (cxx_pp);\n     }\n }\n@@ -3208,11 +3208,11 @@ print_instantiation_context (void)\n void\n maybe_print_constexpr_context (diagnostic_context *context)\n {\n-  VEC(tree,heap) *call_stack = cx_error_context ();\n+  vec<tree> call_stack = cx_error_context ();\n   unsigned ix;\n   tree t;\n \n-  FOR_EACH_VEC_ELT (tree, call_stack, ix, t)\n+  FOR_EACH_VEC_ELT (call_stack, ix, t)\n     {\n       expanded_location xloc = expand_location (EXPR_LOCATION (t));\n       const char *s = expr_as_string (t, 0);"}, {"sha": "cbb0235937b9056c09eb7fe7b8ffad01445ad984", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -824,7 +824,7 @@ build_throw (tree exp)\n       if (CLASS_TYPE_P (temp_type))\n \t{\n \t  int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n-\t  VEC(tree,gc) *exp_vec;\n+\t  vec<tree, va_gc> *exp_vec;\n \n \t  /* Under C++0x [12.8/16 class.copy], a thrown lvalue is sometimes\n \t     treated as an rvalue for the purposes of overload resolution\n@@ -1176,9 +1176,7 @@ typedef struct GTY(()) pending_noexcept {\n   tree fn;\n   location_t loc;\n } pending_noexcept;\n-DEF_VEC_O(pending_noexcept);\n-DEF_VEC_ALLOC_O(pending_noexcept,gc);\n-static GTY(()) VEC(pending_noexcept,gc) *pending_noexcept_checks;\n+static GTY(()) vec<pending_noexcept, va_gc> *pending_noexcept_checks;\n \n /* FN is a FUNCTION_DECL that caused a noexcept-expr to be false.  Warn if\n    it can't throw.  */\n@@ -1204,7 +1202,7 @@ perform_deferred_noexcept_checks (void)\n   int i;\n   pending_noexcept *p;\n   location_t saved_loc = input_location;\n-  FOR_EACH_VEC_ELT (pending_noexcept, pending_noexcept_checks, i, p)\n+  FOR_EACH_VEC_SAFE_ELT (pending_noexcept_checks, i, p)\n     {\n       input_location = p->loc;\n       maybe_noexcept_warning (p->fn);\n@@ -1248,7 +1246,7 @@ expr_noexcept_p (tree expr, tsubst_flags_t complain)\n \t    {\n \t      /* Not defined yet; check again at EOF.  */\n \t      pending_noexcept p = {fn, input_location};\n-\t      VEC_safe_push (pending_noexcept, gc, pending_noexcept_checks, p);\n+\t      vec_safe_push (pending_noexcept_checks, p);\n \t    }\n \t  else\n \t    maybe_noexcept_warning (fn);"}, {"sha": "fea50b5b0eaf87aa020e6954634f85ad9266fb1e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -184,7 +184,7 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n   else if (CLASS_TYPE_P (type))\n     {\n       tree field;\n-      VEC(constructor_elt,gc) *v = NULL;\n+      vec<constructor_elt, va_gc> *v = NULL;\n \n       /* Iterate over the fields, building initializations.  */\n       for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n@@ -233,7 +233,7 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree max_index;\n-      VEC(constructor_elt,gc) *v = NULL;\n+      vec<constructor_elt, va_gc> *v = NULL;\n \n       /* Iterate over the array elements, building initializations.  */\n       if (nelts)\n@@ -255,7 +255,7 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n \t{\n \t  constructor_elt ce;\n \n-\t  v = VEC_alloc (constructor_elt, gc, 1);\n+\t  vec_alloc (v, 1);\n \n \t  /* If this is a one element array, we just use a regular init.  */\n \t  if (tree_int_cst_equal (size_zero_node, max_index))\n@@ -267,7 +267,7 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n \t  ce.value = build_zero_init_1 (TREE_TYPE (type),\n \t\t\t\t\t /*nelts=*/NULL_TREE,\n \t\t\t\t\t static_storage_p, NULL_TREE);\n-\t  VEC_quick_push (constructor_elt, v, ce);\n+\t  v->quick_push (ce);\n \t}\n \n       /* Build a constructor to contain the initializations.  */\n@@ -391,7 +391,7 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n       if (TREE_CODE (type) != UNION_TYPE)\n \t{\n \t  tree field;\n-\t  VEC(constructor_elt,gc) *v = NULL;\n+\t  vec<constructor_elt, va_gc> *v = NULL;\n \n \t  /* Iterate over the fields, building initializations.  */\n \t  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n@@ -428,7 +428,7 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      VEC(constructor_elt,gc) *v = NULL;\n+      vec<constructor_elt, va_gc> *v = NULL;\n \n       /* Iterate over the array elements, building initializations.  */\n       tree max_index = array_type_nelts (type);\n@@ -450,7 +450,7 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n \t{\n \t  constructor_elt ce;\n \n-\t  v = VEC_alloc (constructor_elt, gc, 1);\n+\t  vec_alloc (v, 1);\n \n \t  /* If this is a one element array, we just use a regular init.  */\n \t  if (tree_int_cst_equal (size_zero_node, max_index))\n@@ -459,7 +459,7 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n \t    ce.index = build2 (RANGE_EXPR, sizetype, size_zero_node, max_index);\n \n \t  ce.value = build_value_init (TREE_TYPE (type), complain);\n-\t  VEC_quick_push (constructor_elt, v, ce);\n+\t  v->quick_push (ce);\n \n \t  if (ce.value == error_mark_node)\n \t    return error_mark_node;\n@@ -628,7 +628,7 @@ perform_member_init (tree member, tree init)\n \t reference member in a constructor\u2019s ctor-initializer (12.6.2)\n \t persists until the constructor exits.\"  */\n       unsigned i; tree t;\n-      VEC(tree,gc) *cleanups = make_tree_vector ();\n+      vec<tree, va_gc> *cleanups = make_tree_vector ();\n       if (TREE_CODE (init) == TREE_LIST)\n \tinit = build_x_compound_expr_from_list (init, ELK_MEM_INIT,\n \t\t\t\t\t\ttf_warning_or_error);\n@@ -645,7 +645,7 @@ perform_member_init (tree member, tree init)\n \tinit = build_vec_init_expr (type, init, tf_warning_or_error);\n       init = build2 (INIT_EXPR, type, decl, init);\n       finish_expr_stmt (init);\n-      FOR_EACH_VEC_ELT (tree, cleanups, i, t)\n+      FOR_EACH_VEC_ELT (*cleanups, i, t)\n \tpush_cleanup (decl, t, false);\n       release_tree_vector (cleanups);\n     }\n@@ -802,7 +802,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n   tree base, binfo, base_binfo;\n   tree sorted_inits;\n   tree next_subobject;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n   int i;\n   int uses_unions_p = 0;\n \n@@ -814,7 +814,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n \n   /* Process the virtual bases.  */\n   for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n-       VEC_iterate (tree, vbases, i, base); i++)\n+       vec_safe_iterate (vbases, i, &base); i++)\n     sorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n \n   /* Process the direct bases.  */\n@@ -1545,7 +1545,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n      followed by initialization by X.  If neither of these work\n      out, then look hard.  */\n   tree rval;\n-  VEC(tree,gc) *parms;\n+  vec<tree, va_gc> *parms;\n \n   /* If we have direct-initialization from an initializer list, pull\n      it out of the TREE_LIST so the code below can see it.  */\n@@ -1627,7 +1627,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n     {\n       parms = make_tree_vector ();\n       for (; init != NULL_TREE; init = TREE_CHAIN (init))\n-\tVEC_safe_push (tree, gc, parms, TREE_VALUE (init));\n+\tvec_safe_push (parms, TREE_VALUE (init));\n     }\n   else\n     parms = make_tree_vector_single (init);\n@@ -1641,11 +1641,11 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n       tree elt; unsigned i;\n \n       /* Unshare the arguments for the second call.  */\n-      VEC(tree,gc) *parms2 = make_tree_vector ();\n-      FOR_EACH_VEC_ELT (tree, parms, i, elt)\n+      vec<tree, va_gc> *parms2 = make_tree_vector ();\n+      FOR_EACH_VEC_SAFE_ELT (parms, i, elt)\n \t{\n \t  elt = break_out_target_exprs (elt);\n-\t  VEC_safe_push (tree, gc, parms2, elt);\n+\t  vec_safe_push (parms2, elt);\n \t}\n       complete = build_special_member_call (exp, complete_ctor_identifier,\n \t\t\t\t\t    &parms2, binfo, flags,\n@@ -1730,7 +1730,7 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags,\n   if (init && TREE_CODE (exp) == VAR_DECL\n       && COMPOUND_LITERAL_P (init))\n     {\n-      VEC(tree,gc)* cleanups = NULL;\n+      vec<tree, va_gc> *cleanups = NULL;\n       /* If store_init_value returns NULL_TREE, the INIT has been\n \t recorded as the DECL_INITIAL for EXP.  That means there's\n \t nothing more we have to do.  */\n@@ -2062,8 +2062,8 @@ build_builtin_delete_call (tree addr)\n    creates and returns a NEW_EXPR.  */\n \n static tree\n-build_raw_new_expr (VEC(tree,gc) *placement, tree type, tree nelts,\n-\t\t    VEC(tree,gc) *init, int use_global_new)\n+build_raw_new_expr (vec<tree, va_gc> *placement, tree type, tree nelts,\n+\t\t    vec<tree, va_gc> *init, int use_global_new)\n {\n   tree init_list;\n   tree new_expr;\n@@ -2074,7 +2074,7 @@ build_raw_new_expr (VEC(tree,gc) *placement, tree type, tree nelts,\n      int\" from an empty initializer \"new int()\".  */\n   if (init == NULL)\n     init_list = NULL_TREE;\n-  else if (VEC_empty (tree, init))\n+  else if (init->is_empty ())\n     init_list = void_zero_node;\n   else\n     init_list = build_tree_list_vec (init);\n@@ -2165,8 +2165,8 @@ diagnose_uninitialized_cst_or_ref_member (tree type, bool using_new, bool compla\n    build_raw_new_expr.  This may change PLACEMENT and INIT.  */\n \n static tree\n-build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n-\t     VEC(tree,gc) **init, bool globally_qualified_p,\n+build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n+\t     vec<tree, va_gc> **init, bool globally_qualified_p,\n \t     tsubst_flags_t complain)\n {\n   tree size, rval;\n@@ -2397,13 +2397,12 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n      reference, prepare to capture it in a temporary variable.  Do\n      this now, since PLACEMENT will change in the calls below.  */\n   placement_first = NULL_TREE;\n-  if (VEC_length (tree, *placement) == 1\n-      && (TREE_CODE (TREE_TYPE (VEC_index (tree, *placement, 0)))\n-\t  == POINTER_TYPE))\n-    placement_first = VEC_index (tree, *placement, 0);\n+  if (vec_safe_length (*placement) == 1\n+      && (TREE_CODE (TREE_TYPE ((**placement)[0])) == POINTER_TYPE))\n+    placement_first = (**placement)[0];\n \n   /* Allocate the object.  */\n-  if (VEC_empty (tree, *placement) && TYPE_FOR_JAVA (elt_type))\n+  if (vec_safe_is_empty (*placement) && TYPE_FOR_JAVA (elt_type))\n     {\n       tree class_addr;\n       tree class_decl = build_java_class_ref (elt_type);\n@@ -2466,7 +2465,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n             size = fold_build3 (COND_EXPR, sizetype, outer_nelts_check,\n                                 size, TYPE_MAX_VALUE (sizetype));\n \t  /* Create the argument list.  */\n-\t  VEC_safe_insert (tree, gc, *placement, 0, size);\n+\t  vec_safe_insert (*placement, 0, size);\n \t  /* Do name-lookup to find the appropriate operator.  */\n \t  fns = lookup_fnfields (elt_type, fnname, /*protect=*/2);\n \t  if (fns == NULL_TREE)\n@@ -2651,7 +2650,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n       bool stable;\n       bool explicit_value_init_p = false;\n \n-      if (*init != NULL && VEC_empty (tree, *init))\n+      if (*init != NULL && (*init)->is_empty ())\n \t{\n \t  *init = NULL;\n \t  explicit_value_init_p = true;\n@@ -2675,11 +2674,11 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n       else if (array_p)\n \t{\n \t  tree vecinit = NULL_TREE;\n-\t  if (*init && VEC_length (tree, *init) == 1\n-\t      && BRACE_ENCLOSED_INITIALIZER_P (VEC_index (tree, *init, 0))\n-\t      && CONSTRUCTOR_IS_DIRECT_INIT (VEC_index (tree, *init, 0)))\n+\t  if (vec_safe_length (*init) == 1\n+\t      && BRACE_ENCLOSED_INITIALIZER_P ((**init)[0])\n+\t      && CONSTRUCTOR_IS_DIRECT_INIT ((**init)[0]))\n \t    {\n-\t      vecinit = VEC_index (tree, *init, 0);\n+\t      vecinit = (**init)[0];\n \t      if (CONSTRUCTOR_NELTS (vecinit) == 0)\n \t\t/* List-value-initialization, leave it alone.  */;\n \t      else\n@@ -2891,25 +2890,25 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n    rather than just \"new\".  This may change PLACEMENT and INIT.  */\n \n tree\n-build_new (VEC(tree,gc) **placement, tree type, tree nelts,\n-\t   VEC(tree,gc) **init, int use_global_new, tsubst_flags_t complain)\n+build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n+\t   vec<tree, va_gc> **init, int use_global_new, tsubst_flags_t complain)\n {\n   tree rval;\n-  VEC(tree,gc) *orig_placement = NULL;\n+  vec<tree, va_gc> *orig_placement = NULL;\n   tree orig_nelts = NULL_TREE;\n-  VEC(tree,gc) *orig_init = NULL;\n+  vec<tree, va_gc> *orig_init = NULL;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (nelts == NULL_TREE && VEC_length (tree, *init) == 1\n+  if (nelts == NULL_TREE && vec_safe_length (*init) == 1\n       /* Don't do auto deduction where it might affect mangling.  */\n       && (!processing_template_decl || at_function_scope_p ()))\n     {\n       tree auto_node = type_uses_auto (type);\n       if (auto_node)\n \t{\n-\t  tree d_init = VEC_index (tree, *init, 0);\n+\t  tree d_init = (**init)[0];\n \t  d_init = resolve_nondeduced_context (d_init);\n \t  type = do_auto_deduction (type, d_init, auto_node);\n \t}\n@@ -3308,7 +3307,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n       && ((TREE_CODE (init) == CONSTRUCTOR\n \t   /* Don't do this if the CONSTRUCTOR might contain something\n \t      that might throw and require us to clean up.  */\n-\t   && (VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (init))\n+\t   && (vec_safe_is_empty (CONSTRUCTOR_ELTS (init))\n \t       || ! TYPE_HAS_NONTRIVIAL_DESTRUCTOR (inner_elt_type)))\n \t  || from_array))\n     {\n@@ -3428,11 +3427,11 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t initialization of any elements with constant initializers even if\n \t some are non-constant.  */\n       bool do_static_init = (DECL_P (obase) && TREE_STATIC (obase));\n-      VEC(constructor_elt,gc) *new_vec;\n+      vec<constructor_elt, va_gc> *new_vec;\n       from_array = 0;\n \n       if (try_const)\n-\tnew_vec = VEC_alloc (constructor_elt, gc, CONSTRUCTOR_NELTS (init));\n+\tvec_alloc (new_vec, CONSTRUCTOR_NELTS (init));\n       else\n \tnew_vec = NULL;\n \n@@ -3506,7 +3505,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  else if (do_static_init && saw_const)\n \t    DECL_INITIAL (obase) = build_constructor (atype, new_vec);\n \t  else\n-\t    VEC_free (constructor_elt, gc, new_vec);\n+\t    vec_free (new_vec);\n \t}\n \n       /* Clear out INIT so that we don't get confused below.  */\n@@ -3937,7 +3936,7 @@ push_base_cleanups (void)\n   int i;\n   tree member;\n   tree expr;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n \n   /* Run destructors for all virtual baseclasses.  */\n   if (CLASSTYPE_VBASECLASSES (current_class_type))\n@@ -3950,7 +3949,7 @@ push_base_cleanups (void)\n       /* The CLASSTYPE_VBASECLASSES vector is in initialization\n \t order, which is also the right order for pushing cleanups.  */\n       for (vbases = CLASSTYPE_VBASECLASSES (current_class_type), i = 0;\n-\t   VEC_iterate (tree, vbases, i, base_binfo); i++)\n+\t   vec_safe_iterate (vbases, i, &base_binfo); i++)\n \t{\n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t    {"}, {"sha": "2b1d397d5a3d1de60b0e110048b882b13ecb7ffa", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -91,7 +91,7 @@ along with GCC; see the file COPYING3.  If not see\n typedef struct GTY(()) globals {\n   /* An array of the current substitution candidates, in the order\n      we've seen them.  */\n-  VEC(tree,gc) *substitutions;\n+  vec<tree, va_gc> *substitutions;\n \n   /* The entity that is being mangled.  */\n   tree GTY ((skip)) entity;\n@@ -311,7 +311,7 @@ dump_substitution_candidates (void)\n   tree el;\n \n   fprintf (stderr, \"  ++ substitutions  \");\n-  FOR_EACH_VEC_ELT (tree, G.substitutions, i, el)\n+  FOR_EACH_VEC_ELT (*G.substitutions, i, el)\n     {\n       const char *name = \"???\";\n \n@@ -391,7 +391,7 @@ add_substitution (tree node)\n     int i;\n     tree candidate;\n \n-    FOR_EACH_VEC_ELT (tree, G.substitutions, i, candidate)\n+    FOR_EACH_VEC_SAFE_ELT (G.substitutions, i, candidate)\n       {\n \tgcc_assert (!(DECL_P (node) && node == candidate));\n \tgcc_assert (!(TYPE_P (node) && TYPE_P (candidate)\n@@ -401,7 +401,7 @@ add_substitution (tree node)\n #endif /* ENABLE_CHECKING */\n \n   /* Put the decl onto the varray of substitution candidates.  */\n-  VEC_safe_push (tree, gc, G.substitutions, node);\n+  vec_safe_push (G.substitutions, node);\n \n   if (DEBUG_MANGLE)\n     dump_substitution_candidates ();\n@@ -504,7 +504,7 @@ static int\n find_substitution (tree node)\n {\n   int i;\n-  const int size = VEC_length (tree, G.substitutions);\n+  const int size = vec_safe_length (G.substitutions);\n   tree decl;\n   tree type;\n \n@@ -612,7 +612,7 @@ find_substitution (tree node)\n      operation.  */\n   for (i = 0; i < size; ++i)\n     {\n-      tree candidate = VEC_index (tree, G.substitutions, i);\n+      tree candidate = (*G.substitutions)[i];\n       /* NODE is a matched to a candidate if it's the same decl node or\n \t if it's the same type.  */\n       if (decl == candidate\n@@ -1322,18 +1322,18 @@ write_abi_tags (tree tags)\n \n   tags = TREE_VALUE (tags);\n \n-  VEC(tree,gc)* vec = make_tree_vector();\n+  vec<tree, va_gc> * vec = make_tree_vector();\n \n   for (tree t = tags; t; t = TREE_CHAIN (t))\n     {\n       tree str = TREE_VALUE (t);\n-      VEC_safe_push (tree, gc, vec, str);\n+      vec_safe_push (vec, str);\n     }\n \n-  VEC_qsort (tree, vec, tree_string_cmp);\n+  vec->qsort (tree_string_cmp);\n \n   unsigned i; tree str;\n-  FOR_EACH_VEC_ELT (tree, vec, i, str)\n+  FOR_EACH_VEC_ELT (*vec, i, str)\n     {\n       write_string (\"B\");\n       write_unsigned_number (TREE_STRING_LENGTH (str) - 1);\n@@ -1699,7 +1699,7 @@ local_class_index (tree entity)\n   tree ctx = TYPE_CONTEXT (entity);\n   for (ix = 0; ; ix++)\n     {\n-      tree type = VEC_index (tree, local_classes, ix);\n+      tree type = (*local_classes)[ix];\n       if (type == entity)\n \treturn discriminator;\n       if (TYPE_CONTEXT (type) == ctx\n@@ -2801,7 +2801,7 @@ write_expression (tree expr)\n     }\n   else if (code == CONSTRUCTOR)\n     {\n-      VEC(constructor_elt,gc)* elts = CONSTRUCTOR_ELTS (expr);\n+      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (expr);\n       unsigned i; tree val;\n \n       if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n@@ -3320,7 +3320,7 @@ finish_mangling_internal (const bool warn)\n \t     G.entity);\n \n   /* Clear all the substitutions.  */\n-  VEC_truncate (tree, G.substitutions, 0);\n+  vec_safe_truncate (G.substitutions, 0);\n \n   /* Null-terminate the string.  */\n   write_char ('\\0');\n@@ -3354,7 +3354,7 @@ init_mangle (void)\n {\n   gcc_obstack_init (&name_obstack);\n   name_base = obstack_alloc (&name_obstack, 0);\n-  G.substitutions = NULL;\n+  vec_alloc (G.substitutions, 0);\n \n   /* Cache these identifiers for quick comparison when checking for\n      standard substitutions.  */"}, {"sha": "64580324909b1f262977e24fdebb5dfa7dee5c5e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -550,15 +550,15 @@ do_build_copy_constructor (tree fndecl)\n       int i;\n       tree binfo, base_binfo;\n       tree init;\n-      VEC(tree,gc) *vbases;\n+      vec<tree, va_gc> *vbases;\n \n       /* Initialize all the base-classes with the parameter converted\n \t to their type so that we get their copy constructor and not\n \t another constructor that takes current_class_type.  We must\n \t deal with the binfo's directly as a direct base might be\n \t inaccessible due to ambiguity.  */\n       for (vbases = CLASSTYPE_VBASECLASSES (current_class_type), i = 0;\n-\t   VEC_iterate (tree, vbases, i, binfo); i++)\n+\t   vec_safe_iterate (vbases, i, &binfo); i++)\n \t{\n \t  member_init_list = add_one_base_init (binfo, parm, move_p, inh,\n \t\t\t\t\t\tmember_init_list);\n@@ -655,7 +655,7 @@ do_build_copy_assign (tree fndecl)\n \t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n \t  tree converted_parm;\n-\t  VEC(tree,gc) *parmvec;\n+\t  vec<tree, va_gc> *parmvec;\n \n \t  /* We must convert PARM directly to the base class\n \t     explicitly since the base class may be ambiguous.  */\n@@ -852,7 +852,7 @@ locate_fn_flags (tree type, tree name, tree argtype, int flags,\n \t\t tsubst_flags_t complain)\n {\n   tree ob, fn, fns, binfo, rval;\n-  VEC(tree,gc) *args;\n+  vec<tree, va_gc> *args;\n \n   if (TYPE_P (type))\n     binfo = TYPE_BINFO (type);\n@@ -875,13 +875,13 @@ locate_fn_flags (tree type, tree name, tree argtype, int flags,\n \t      if (TREE_CODE (type) != REFERENCE_TYPE)\n \t\ttype = cp_build_reference_type (type, /*rval*/true);\n \t      tree arg = build_stub_object (type);\n-\t      VEC_safe_push (tree, gc, args, arg);\n+\t      vec_safe_push (args, arg);\n \t    }\n \t}\n       else\n \t{\n \t  tree arg = build_stub_object (argtype);\n-\t  VEC_quick_push (tree, args, arg);\n+\t  args->quick_push (arg);\n \t}\n     }\n \n@@ -1157,7 +1157,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n {\n   tree binfo, base_binfo, scope, fnname, rval, argtype;\n   bool move_p, copy_arg_p, assign_p, expected_trivial, check_vdtor;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n   int i, quals, flags;\n   tsubst_flags_t complain;\n   bool ctor_p;\n@@ -1351,7 +1351,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     {\n       if (constexpr_p)\n \t*constexpr_p = false;\n-      FOR_EACH_VEC_ELT (tree, vbases, i, base_binfo)\n+      FOR_EACH_VEC_ELT (*vbases, i, base_binfo)\n \t{\n \t  tree basetype = BINFO_TYPE (base_binfo);\n \t  if (copy_arg_p)"}, {"sha": "5abebe32197ebbcc0b37e50b8dec5b3d0b1e8977", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 91, "deletions": 95, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -320,7 +320,7 @@ new_class_binding (tree name, tree value, tree type, cp_binding_level *scope)\n {\n   cp_class_binding cb = {cxx_binding_make (value, type), name};\n   cxx_binding *binding = cb.base;\n-  VEC_safe_push (cp_class_binding, gc, scope->class_shadowed, cb);\n+  vec_safe_push (scope->class_shadowed, cb);\n   binding->scope = scope;\n   return binding;\n }\n@@ -597,7 +597,7 @@ add_decl_to_level (tree decl, cp_binding_level *b)\n \t     && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t    || (TREE_CODE (decl) == FUNCTION_DECL\n \t\t&& (!TREE_PUBLIC (decl) || DECL_DECLARED_INLINE_P (decl))))\n-\t  VEC_safe_push (tree, gc, b->static_decls, decl);\n+\t  vec_safe_push (b->static_decls, decl);\n     }\n }\n \n@@ -1506,11 +1506,9 @@ begin_scope (scope_kind kind, tree entity)\n \n     case sk_namespace:\n       NAMESPACE_LEVEL (entity) = scope;\n-      scope->static_decls =\n-\tVEC_alloc (tree, gc,\n-\t\t   DECL_NAME (entity) == std_identifier\n-\t\t   || DECL_NAME (entity) == global_scope_name\n-\t\t   ? 200 : 10);\n+      vec_alloc (scope->static_decls,\n+\t\t (DECL_NAME (entity) == std_identifier\n+\t\t  || DECL_NAME (entity) == global_scope_name) ? 200 : 10);\n       break;\n \n     default:\n@@ -1781,12 +1779,12 @@ print_binding_level (cp_binding_level* lvl)\n       if (i)\n \tfprintf (stderr, \"\\n\");\n     }\n-  if (VEC_length (cp_class_binding, lvl->class_shadowed))\n+  if (vec_safe_length (lvl->class_shadowed))\n     {\n       size_t i;\n       cp_class_binding *b;\n       fprintf (stderr, \" class-shadowed:\");\n-      FOR_EACH_VEC_ELT (cp_class_binding, lvl->class_shadowed, i, b)\n+      FOR_EACH_VEC_ELT (*lvl->class_shadowed, i, b)\n \tfprintf (stderr, \" %s \", IDENTIFIER_POINTER (b->identifier));\n       fprintf (stderr, \"\\n\");\n     }\n@@ -2836,7 +2834,7 @@ poplevel_class (void)\n   /* Remove the bindings for all of the class-level declarations.  */\n   if (level->class_shadowed)\n     {\n-      FOR_EACH_VEC_ELT (cp_class_binding, level->class_shadowed, i, cb)\n+      FOR_EACH_VEC_ELT (*level->class_shadowed, i, cb)\n \t{\n \t  IDENTIFIER_BINDING (cb->identifier) = cb->base->previous;\n \t  cxx_binding_free (cb->base);\n@@ -3468,8 +3466,8 @@ current_decl_namespace (void)\n {\n   tree result;\n   /* If we have been pushed into a different namespace, use it.  */\n-  if (!VEC_empty (tree, decl_namespace_list))\n-    return VEC_last (tree, decl_namespace_list);\n+  if (!vec_safe_is_empty (decl_namespace_list))\n+    return decl_namespace_list->last ();\n \n   if (current_class_type)\n     result = decl_namespace_context (current_class_type);\n@@ -3674,15 +3672,15 @@ push_decl_namespace (tree decl)\n {\n   if (TREE_CODE (decl) != NAMESPACE_DECL)\n     decl = decl_namespace_context (decl);\n-  VEC_safe_push (tree, gc, decl_namespace_list, ORIGINAL_NAMESPACE (decl));\n+  vec_safe_push (decl_namespace_list, ORIGINAL_NAMESPACE (decl));\n }\n \n /* [namespace.memdef]/2 */\n \n void\n pop_decl_namespace (void)\n {\n-  VEC_pop (tree, decl_namespace_list);\n+  decl_namespace_list->pop ();\n }\n \n /* Return the namespace that is the common ancestor\n@@ -4224,19 +4222,19 @@ remove_hidden_names (tree fns)\n void\n suggest_alternatives_for (location_t location, tree name)\n {\n-  VEC(tree,heap) *candidates = NULL;\n-  VEC(tree,heap) *namespaces_to_search = NULL;\n+  vec<tree> candidates = vec<tree>();\n+  vec<tree> namespaces_to_search = vec<tree>();\n   int max_to_search = PARAM_VALUE (CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP);\n   int n_searched = 0;\n   tree t;\n   unsigned ix;\n \n-  VEC_safe_push (tree, heap, namespaces_to_search, global_namespace);\n+  namespaces_to_search.safe_push (global_namespace);\n \n-  while (!VEC_empty (tree, namespaces_to_search)\n+  while (!namespaces_to_search.is_empty ()\n \t && n_searched < max_to_search)\n     {\n-      tree scope = VEC_pop (tree, namespaces_to_search);\n+      tree scope = namespaces_to_search.pop ();\n       struct scope_binding binding = EMPTY_SCOPE_BINDING;\n       cp_binding_level *level = NAMESPACE_LEVEL (scope);\n \n@@ -4246,37 +4244,37 @@ suggest_alternatives_for (location_t location, tree name)\n       n_searched++;\n \n       if (binding.value)\n-\tVEC_safe_push (tree, heap, candidates, binding.value);\n+\tcandidates.safe_push (binding.value);\n \n       /* Add child namespaces.  */\n       for (t = level->namespaces; t; t = DECL_CHAIN (t))\n-\tVEC_safe_push (tree, heap, namespaces_to_search, t);\n+\tnamespaces_to_search.safe_push (t);\n     }\n \n   /* If we stopped before we could examine all namespaces, inform the\n      user.  Do this even if we don't have any candidates, since there\n      might be more candidates further down that we weren't able to\n      find.  */\n   if (n_searched >= max_to_search\n-      && !VEC_empty (tree, namespaces_to_search))\n+      && !namespaces_to_search.is_empty ())\n     inform (location,\n \t    \"maximum limit of %d namespaces searched for %qE\",\n \t    max_to_search, name);\n \n-  VEC_free (tree, heap, namespaces_to_search);\n+  namespaces_to_search.release ();\n \n   /* Nothing useful to report.  */\n-  if (VEC_empty (tree, candidates))\n+  if (candidates.is_empty ())\n     return;\n \n-  inform_n (location, VEC_length (tree, candidates),\n+  inform_n (location, candidates.length (),\n \t    \"suggested alternative:\",\n \t    \"suggested alternatives:\");\n \n-  FOR_EACH_VEC_ELT (tree, candidates, ix, t)\n+  FOR_EACH_VEC_ELT (candidates, ix, t)\n     inform (location_of (t), \"  %qE\", t);\n \n-  VEC_free (tree, heap, candidates);\n+  candidates.release ();\n }\n \n /* Unscoped lookup of a global: iterate over current namespaces,\n@@ -4408,11 +4406,11 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n /* Returns true iff VEC contains TARGET.  */\n \n static bool\n-tree_vec_contains (VEC(tree,gc)* vec, tree target)\n+tree_vec_contains (vec<tree, va_gc> *vec, tree target)\n {\n   unsigned int i;\n   tree elt;\n-  FOR_EACH_VEC_ELT (tree,vec,i,elt)\n+  FOR_EACH_VEC_SAFE_ELT (vec,i,elt)\n     if (elt == target)\n       return true;\n   return false;\n@@ -4428,12 +4426,12 @@ qualified_lookup_using_namespace (tree name, tree scope,\n \t\t\t\t  struct scope_binding *result, int flags)\n {\n   /* Maintain a list of namespaces visited...  */\n-  VEC(tree,gc) *seen = NULL;\n-  VEC(tree,gc) *seen_inline = NULL;\n+  vec<tree, va_gc> *seen = NULL;\n+  vec<tree, va_gc> *seen_inline = NULL;\n   /* ... and a list of namespace yet to see.  */\n-  VEC(tree,gc) *todo = NULL;\n-  VEC(tree,gc) *todo_maybe = NULL;\n-  VEC(tree,gc) *todo_inline = NULL;\n+  vec<tree, va_gc> *todo = NULL;\n+  vec<tree, va_gc> *todo_maybe = NULL;\n+  vec<tree, va_gc> *todo_inline = NULL;\n   tree usings;\n   timevar_start (TV_NAME_LOOKUP);\n   /* Look through namespace aliases.  */\n@@ -4443,26 +4441,26 @@ qualified_lookup_using_namespace (tree name, tree scope,\n      namespaces.  For each used namespace, look through its inline\n      namespace set for any bindings and usings.  If no bindings are\n      found, add any usings seen to the set of used namespaces.  */\n-  VEC_safe_push (tree, gc, todo, scope);\n+  vec_safe_push (todo, scope);\n \n-  while (VEC_length (tree, todo))\n+  while (todo->length ())\n     {\n       bool found_here;\n-      scope = VEC_pop (tree, todo);\n+      scope = todo->pop ();\n       if (tree_vec_contains (seen, scope))\n \tcontinue;\n-      VEC_safe_push (tree, gc, seen, scope);\n-      VEC_safe_push (tree, gc, todo_inline, scope);\n+      vec_safe_push (seen, scope);\n+      vec_safe_push (todo_inline, scope);\n \n       found_here = false;\n-      while (VEC_length (tree, todo_inline))\n+      while (todo_inline->length ())\n \t{\n \t  cxx_binding *binding;\n \n-\t  scope = VEC_pop (tree, todo_inline);\n+\t  scope = todo_inline->pop ();\n \t  if (tree_vec_contains (seen_inline, scope))\n \t    continue;\n-\t  VEC_safe_push (tree, gc, seen_inline, scope);\n+\t  vec_safe_push (seen_inline, scope);\n \n \t  binding =\n \t    cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n@@ -4477,23 +4475,23 @@ qualified_lookup_using_namespace (tree name, tree scope,\n \t    if (!TREE_INDIRECT_USING (usings))\n \t      {\n \t\tif (is_associated_namespace (scope, TREE_PURPOSE (usings)))\n-\t\t  VEC_safe_push (tree, gc, todo_inline, TREE_PURPOSE (usings));\n+\t\t  vec_safe_push (todo_inline, TREE_PURPOSE (usings));\n \t\telse\n-\t\t  VEC_safe_push (tree, gc, todo_maybe, TREE_PURPOSE (usings));\n+\t\t  vec_safe_push (todo_maybe, TREE_PURPOSE (usings));\n \t      }\n \t}\n \n       if (found_here)\n-\tVEC_truncate (tree, todo_maybe, 0);\n+\tvec_safe_truncate (todo_maybe, 0);\n       else\n-\twhile (VEC_length (tree, todo_maybe))\n-\t  VEC_safe_push (tree, gc, todo, VEC_pop (tree, todo_maybe));\n-    }\n-  VEC_free (tree,gc,todo);\n-  VEC_free (tree,gc,todo_maybe);\n-  VEC_free (tree,gc,todo_inline);\n-  VEC_free (tree,gc,seen);\n-  VEC_free (tree,gc,seen_inline);\n+\twhile (vec_safe_length (todo_maybe))\n+\t  vec_safe_push (todo, todo_maybe->pop ());\n+    }\n+  vec_free (todo);\n+  vec_free (todo_maybe);\n+  vec_free (todo_inline);\n+  vec_free (seen);\n+  vec_free (seen_inline);\n   timevar_stop (TV_NAME_LOOKUP);\n   return result->value != error_mark_node;\n }\n@@ -4791,7 +4789,7 @@ lookup_name_nonclass (tree name)\n }\n \n tree\n-lookup_function_nonclass (tree name, VEC(tree,gc) *args, bool block_p)\n+lookup_function_nonclass (tree name, vec<tree, va_gc> *args, bool block_p)\n {\n   return\n     lookup_arg_dependent (name,\n@@ -5035,16 +5033,16 @@ lookup_type_current_level (tree name)\n struct arg_lookup\n {\n   tree name;\n-  VEC(tree,gc) *args;\n-  VEC(tree,gc) *namespaces;\n-  VEC(tree,gc) *classes;\n+  vec<tree, va_gc> *args;\n+  vec<tree, va_gc> *namespaces;\n+  vec<tree, va_gc> *classes;\n   tree functions;\n   struct pointer_set_t *fn_set;\n };\n \n static bool arg_assoc (struct arg_lookup*, tree);\n static bool arg_assoc_args (struct arg_lookup*, tree);\n-static bool arg_assoc_args_vec (struct arg_lookup*, VEC(tree,gc) *);\n+static bool arg_assoc_args_vec (struct arg_lookup*, vec<tree, va_gc> *);\n static bool arg_assoc_type (struct arg_lookup*, tree);\n static bool add_function (struct arg_lookup *, tree);\n static bool arg_assoc_namespace (struct arg_lookup *, tree);\n@@ -5085,8 +5083,8 @@ add_function (struct arg_lookup *k, tree fn)\n bool\n is_associated_namespace (tree current, tree scope)\n {\n-  VEC(tree,gc) *seen = make_tree_vector ();\n-  VEC(tree,gc) *todo = make_tree_vector ();\n+  vec<tree, va_gc> *seen = make_tree_vector ();\n+  vec<tree, va_gc> *todo = make_tree_vector ();\n   tree t;\n   bool ret;\n \n@@ -5097,14 +5095,14 @@ is_associated_namespace (tree current, tree scope)\n \t  ret = true;\n \t  break;\n \t}\n-      VEC_safe_push (tree, gc, seen, scope);\n+      vec_safe_push (seen, scope);\n       for (t = DECL_NAMESPACE_ASSOCIATIONS (scope); t; t = TREE_CHAIN (t))\n \tif (!vec_member (TREE_PURPOSE (t), seen))\n-\t  VEC_safe_push (tree, gc, todo, TREE_PURPOSE (t));\n-      if (!VEC_empty (tree, todo))\n+\t  vec_safe_push (todo, TREE_PURPOSE (t));\n+      if (!todo->is_empty ())\n \t{\n-\t  scope = VEC_last (tree, todo);\n-\t  VEC_pop (tree, todo);\n+\t  scope = todo->last ();\n+\t  todo->pop ();\n \t}\n       else\n \t{\n@@ -5129,7 +5127,7 @@ arg_assoc_namespace (struct arg_lookup *k, tree scope)\n \n   if (vec_member (scope, k->namespaces))\n     return false;\n-  VEC_safe_push (tree, gc, k->namespaces, scope);\n+  vec_safe_push (k->namespaces, scope);\n \n   /* Check out our super-users.  */\n   for (value = DECL_NAMESPACE_ASSOCIATIONS (scope); value;\n@@ -5312,7 +5310,7 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n \n   if (vec_member (type, k->classes))\n     return false;\n-  VEC_safe_push (tree, gc, k->classes, type);\n+  vec_safe_push (k->classes, type);\n \n   if (TYPE_CLASS_SCOPE_P (type)\n       && arg_assoc_class_only (k, TYPE_CONTEXT (type)))\n@@ -5422,12 +5420,12 @@ arg_assoc_args (struct arg_lookup *k, tree args)\n    on error.  */\n \n static bool\n-arg_assoc_args_vec (struct arg_lookup *k, VEC(tree,gc) *args)\n+arg_assoc_args_vec (struct arg_lookup *k, vec<tree, va_gc> *args)\n {\n   unsigned int ix;\n   tree arg;\n \n-  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n+  FOR_EACH_VEC_SAFE_ELT (args, ix, arg)\n     if (arg_assoc (k, arg))\n       return true;\n   return false;\n@@ -5495,7 +5493,7 @@ arg_assoc (struct arg_lookup *k, tree n)\n    are the functions found in normal lookup.  */\n \n static tree\n-lookup_arg_dependent_1 (tree name, tree fns, VEC(tree,gc) *args,\n+lookup_arg_dependent_1 (tree name, tree fns, vec<tree, va_gc> *args,\n \t\t\tbool include_std)\n {\n   struct arg_lookup k;\n@@ -5560,7 +5558,7 @@ lookup_arg_dependent_1 (tree name, tree fns, VEC(tree,gc) *args,\n /* Wrapper for lookup_arg_dependent_1.  */\n \n tree\n-lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args,\n+lookup_arg_dependent (tree name, tree fns, vec<tree, va_gc> *args,\n                       bool include_std)\n {\n   tree ret;\n@@ -5820,7 +5818,7 @@ pushtag_1 (tree name, tree type, tag_scope scope)\n \t      add_decl_expr (decl);\n \t    }\n \t  else\n-\t    VEC_safe_push (tree, gc, local_classes, type);\n+\t    vec_safe_push (local_classes, type);\n \t}\n     }\n   if (b->kind == sk_class\n@@ -5884,7 +5882,7 @@ store_binding_p (tree id)\n    have enough space reserved.  */\n \n static void\n-store_binding (tree id, VEC(cxx_saved_binding,gc) **old_bindings)\n+store_binding (tree id, vec<cxx_saved_binding, va_gc> **old_bindings)\n {\n   cxx_saved_binding saved;\n \n@@ -5895,14 +5893,14 @@ store_binding (tree id, VEC(cxx_saved_binding,gc) **old_bindings)\n   saved.identifier = id;\n   saved.binding = IDENTIFIER_BINDING (id);\n   saved.real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n-  VEC_quick_push (cxx_saved_binding, *old_bindings, saved);\n+  (*old_bindings)->quick_push (saved);\n   IDENTIFIER_BINDING (id) = NULL;\n }\n \n static void\n-store_bindings (tree names, VEC(cxx_saved_binding,gc) **old_bindings)\n+store_bindings (tree names, vec<cxx_saved_binding, va_gc> **old_bindings)\n {\n-  static VEC(tree,heap) *bindings_need_stored = NULL;\n+  static vec<tree> bindings_need_stored = vec<tree>();\n   tree t, id;\n   size_t i;\n \n@@ -5915,19 +5913,18 @@ store_bindings (tree names, VEC(cxx_saved_binding,gc) **old_bindings)\n \tid = DECL_NAME (t);\n \n       if (store_binding_p (id))\n-\tVEC_safe_push(tree, heap, bindings_need_stored, id);\n+\tbindings_need_stored.safe_push (id);\n     }\n-  if (!VEC_empty (tree, bindings_need_stored))\n+  if (!bindings_need_stored.is_empty ())\n     {\n-      VEC_reserve_exact (cxx_saved_binding, gc, *old_bindings,\n-\t\t\t VEC_length (tree, bindings_need_stored));\n-      for (i = 0; VEC_iterate(tree, bindings_need_stored, i, id); ++i)\n+      vec_safe_reserve_exact (*old_bindings, bindings_need_stored.length ());\n+      for (i = 0; bindings_need_stored.iterate (i, &id); ++i)\n \t{\n \t  /* We can appearantly have duplicates in NAMES.  */\n \t  if (store_binding_p (id))\n \t    store_binding (id, old_bindings);\n \t}\n-      VEC_truncate (tree, bindings_need_stored, 0);\n+      bindings_need_stored.truncate (0);\n     }\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n@@ -5936,25 +5933,24 @@ store_bindings (tree names, VEC(cxx_saved_binding,gc) **old_bindings)\n    objects, rather than a TREE_LIST.  */\n \n static void\n-store_class_bindings (VEC(cp_class_binding,gc) *names,\n-\t\t      VEC(cxx_saved_binding,gc) **old_bindings)\n+store_class_bindings (vec<cp_class_binding, va_gc> *names,\n+\t\t      vec<cxx_saved_binding, va_gc> **old_bindings)\n {\n-  static VEC(tree,heap) *bindings_need_stored = NULL;\n+  static vec<tree> bindings_need_stored = vec<tree>();\n   size_t i;\n   cp_class_binding *cb;\n \n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  for (i = 0; VEC_iterate(cp_class_binding, names, i, cb); ++i)\n+  for (i = 0; vec_safe_iterate (names, i, &cb); ++i)\n     if (store_binding_p (cb->identifier))\n-      VEC_safe_push (tree, heap, bindings_need_stored, cb->identifier);\n-  if (!VEC_empty (tree, bindings_need_stored))\n+      bindings_need_stored.safe_push (cb->identifier);\n+  if (!bindings_need_stored.is_empty ())\n     {\n       tree id;\n-      VEC_reserve_exact (cxx_saved_binding, gc, *old_bindings,\n-\t\t\t VEC_length (tree, bindings_need_stored));\n-      for (i = 0; VEC_iterate(tree, bindings_need_stored, i, id); ++i)\n+      vec_safe_reserve_exact (*old_bindings, bindings_need_stored.length ());\n+      for (i = 0; bindings_need_stored.iterate (i, &id); ++i)\n \tstore_binding (id, old_bindings);\n-      VEC_truncate (tree, bindings_need_stored, 0);\n+      bindings_need_stored.truncate (0);\n     }\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n@@ -6010,7 +6006,7 @@ push_to_top_level (void)\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n     }\n \n-  FOR_EACH_VEC_ELT (cxx_saved_binding, s->old_bindings, i, sb)\n+  FOR_EACH_VEC_SAFE_ELT (s->old_bindings, i, sb)\n     IDENTIFIER_MARKED (sb->identifier) = 0;\n \n   s->prev = scope_chain;\n@@ -6023,7 +6019,7 @@ push_to_top_level (void)\n \n   scope_chain = s;\n   current_function_decl = NULL_TREE;\n-  current_lang_base = VEC_alloc (tree, gc, 10);\n+  vec_alloc (current_lang_base, 10);\n   current_lang_name = lang_name_cplusplus;\n   current_namespace = global_namespace;\n   push_class_stack ();\n@@ -6047,7 +6043,7 @@ pop_from_top_level_1 (void)\n   current_lang_base = 0;\n \n   scope_chain = s->prev;\n-  FOR_EACH_VEC_ELT (cxx_saved_binding, s->old_bindings, i, saved)\n+  FOR_EACH_VEC_SAFE_ELT (s->old_bindings, i, saved)\n     {\n       tree id = saved->identifier;\n "}, {"sha": "540e20033026feeb210da66b49d3173092362e8e", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -86,8 +86,6 @@ typedef struct GTY(()) cxx_saved_binding {\n   tree real_type_value;\n } cxx_saved_binding;\n \n-DEF_VEC_O(cxx_saved_binding);\n-DEF_VEC_ALLOC_O(cxx_saved_binding,gc);\n \n extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n@@ -147,8 +145,6 @@ typedef struct GTY(()) cp_class_binding {\n   tree identifier;\n } cp_class_binding;\n \n-DEF_VEC_O(cp_class_binding);\n-DEF_VEC_ALLOC_O(cp_class_binding,gc);\n \n typedef struct GTY(()) cp_label_binding {\n   /* The bound LABEL_DECL.  */\n@@ -157,8 +153,6 @@ typedef struct GTY(()) cp_label_binding {\n   tree prev_value;\n } cp_label_binding;\n \n-DEF_VEC_O(cp_label_binding);\n-DEF_VEC_ALLOC_O(cp_label_binding,gc);\n \n /* For each binding contour we allocate a binding_level structure\n    which records the names defined in that contour.\n@@ -195,7 +189,7 @@ struct GTY(()) cp_binding_level {\n   tree namespaces;\n \n   /* An array of static functions and variables (for namespaces only) */\n-  VEC(tree,gc) *static_decls;\n+  vec<tree, va_gc> *static_decls;\n \n   /* A list of USING_DECL nodes.  */\n   tree usings;\n@@ -206,7 +200,7 @@ struct GTY(()) cp_binding_level {\n \n   /* For the binding level corresponding to a class, the entities\n       declared in the class or its base classes.  */\n-  VEC(cp_class_binding,gc) *class_shadowed;\n+  vec<cp_class_binding, va_gc> *class_shadowed;\n \n   /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n       is used for all binding levels. The TREE_PURPOSE is the name of\n@@ -217,7 +211,7 @@ struct GTY(()) cp_binding_level {\n \n   /* Similar to class_shadowed, but for IDENTIFIER_LABEL_VALUE, and\n       used for all binding levels.  */\n-  VEC(cp_label_binding,gc) *shadowed_labels;\n+  vec<cp_label_binding, va_gc> *shadowed_labels;\n \n   /* For each level (except not the global one),\n       a chain of BLOCK nodes for all the levels\n@@ -234,7 +228,7 @@ struct GTY(()) cp_binding_level {\n   /* List of VAR_DECLS saved from a previous for statement.\n       These would be dead in ISO-conforming code, but might\n       be referenced in ARM-era code.  */\n-  VEC(tree,gc) *dead_vars_from_for;\n+  vec<tree, va_gc> *dead_vars_from_for;\n \n   /* STATEMENT_LIST for statements in this binding contour.\n       Only used at present for SK_CLEANUP temporary bindings.  */\n@@ -327,7 +321,7 @@ extern tree lookup_qualified_name (tree, tree, bool, bool);\n extern tree lookup_name_nonclass (tree);\n extern tree lookup_name_innermost_nonclass_level (tree);\n extern bool is_local_extern (tree);\n-extern tree lookup_function_nonclass (tree, VEC(tree,gc) *, bool);\n+extern tree lookup_function_nonclass (tree, vec<tree, va_gc> *, bool);\n extern void push_local_binding (tree, tree, int);\n extern bool pushdecl_class_level (tree);\n extern tree pushdecl_namespace_level (tree, bool);\n@@ -343,7 +337,7 @@ extern void do_toplevel_using_decl (tree, tree, tree);\n extern void do_local_using_decl (tree, tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern void do_using_directive (tree);\n-extern tree lookup_arg_dependent (tree, tree, VEC(tree,gc) *, bool);\n+extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *, bool);\n extern bool is_associated_namespace (tree, tree);\n extern void parse_using_directive (tree, tree);\n extern tree innermost_non_namespace_value (tree);"}, {"sha": "9650351580a58a261f66d1e3abc56b68c739a5f8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 115, "deletions": 131, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -252,34 +252,34 @@ int cp_unevaluated_operand;\n    highlighted by surrounding it in [[ ]].  */\n \n static void\n-cp_lexer_dump_tokens (FILE *file, VEC(cp_token,gc) *buffer,\n+cp_lexer_dump_tokens (FILE *file, vec<cp_token, va_gc> *buffer,\n \t\t      cp_token *start_token, unsigned num,\n \t\t      cp_token *curr_token)\n {\n   unsigned i, nprinted;\n   cp_token *token;\n   bool do_print;\n \n-  fprintf (file, \"%u tokens\\n\", VEC_length (cp_token, buffer));\n+  fprintf (file, \"%u tokens\\n\", vec_safe_length (buffer));\n \n   if (buffer == NULL)\n     return;\n \n   if (num == 0)\n-    num = VEC_length (cp_token, buffer);\n+    num = buffer->length ();\n \n   if (start_token == NULL)\n-    start_token = VEC_address (cp_token, buffer);\n+    start_token = buffer->address ();\n \n-  if (start_token > VEC_address (cp_token, buffer))\n+  if (start_token > buffer->address ())\n     {\n-      cp_lexer_print_token (file, &VEC_index (cp_token, buffer, 0));\n+      cp_lexer_print_token (file, &(*buffer)[0]);\n       fprintf (file, \" ... \");\n     }\n \n   do_print = false;\n   nprinted = 0;\n-  for (i = 0; VEC_iterate (cp_token, buffer, i, token) && nprinted < num; i++)\n+  for (i = 0; buffer->iterate (i, &token) && nprinted < num; i++)\n     {\n       if (token == start_token)\n \tdo_print = true;\n@@ -310,10 +310,10 @@ cp_lexer_dump_tokens (FILE *file, VEC(cp_token,gc) *buffer,\n \t}\n     }\n \n-  if (i == num && i < VEC_length (cp_token, buffer))\n+  if (i == num && i < buffer->length ())\n     {\n       fprintf (file, \" ... \");\n-      cp_lexer_print_token (file, &VEC_last (cp_token, buffer));\n+      cp_lexer_print_token (file, &buffer->last ());\n     }\n \n   fprintf (file, \"\\n\");\n@@ -323,7 +323,7 @@ cp_lexer_dump_tokens (FILE *file, VEC(cp_token,gc) *buffer,\n /* Dump all tokens in BUFFER to stderr.  */\n \n void\n-cp_lexer_debug_tokens (VEC(cp_token,gc) *buffer)\n+cp_lexer_debug_tokens (vec<cp_token, va_gc> *buffer)\n {\n   cp_lexer_dump_tokens (stderr, buffer, NULL, 0, NULL);\n }\n@@ -393,8 +393,7 @@ cp_debug_print_unparsed_function (FILE *file, cp_unparsed_functions_entry *uf)\n \n   fprintf (file, \"\\tFunctions with default args:\\n\");\n   for (i = 0;\n-       VEC_iterate (cp_default_arg_entry, uf->funs_with_default_args, i,\n-\t\t    default_arg_fn);\n+       vec_safe_iterate (uf->funs_with_default_args, i, &default_arg_fn);\n        i++)\n     {\n       fprintf (file, \"\\t\\tClass type: \");\n@@ -406,7 +405,7 @@ cp_debug_print_unparsed_function (FILE *file, cp_unparsed_functions_entry *uf)\n \n   fprintf (file, \"\\n\\tFunctions with definitions that require \"\n \t   \"post-processing\\n\\t\\t\");\n-  for (i = 0; VEC_iterate (tree, uf->funs_with_definitions, i, fn); i++)\n+  for (i = 0; vec_safe_iterate (uf->funs_with_definitions, i, &fn); i++)\n     {\n       print_node_brief (file, \"\", fn, 0);\n       fprintf (file, \" \");\n@@ -415,7 +414,7 @@ cp_debug_print_unparsed_function (FILE *file, cp_unparsed_functions_entry *uf)\n \n   fprintf (file, \"\\n\\tNon-static data members with initializers that require \"\n            \"post-processing\\n\\t\\t\");\n-  for (i = 0; VEC_iterate (tree, uf->nsdmis, i, fn); i++)\n+  for (i = 0; vec_safe_iterate (uf->nsdmis, i, &fn); i++)\n     {\n       print_node_brief (file, \"\", fn, 0);\n       fprintf (file, \" \");\n@@ -428,13 +427,13 @@ cp_debug_print_unparsed_function (FILE *file, cp_unparsed_functions_entry *uf)\n \n static void\n cp_debug_print_unparsed_queues (FILE *file,\n-\t\t\t\tVEC(cp_unparsed_functions_entry, gc) *s)\n+\t\t\t\tvec<cp_unparsed_functions_entry, va_gc> *s)\n {\n   unsigned i;\n   cp_unparsed_functions_entry *uf;\n \n   fprintf (file, \"Unparsed functions\\n\");\n-  for (i = 0; VEC_iterate (cp_unparsed_functions_entry, s, i, uf); i++)\n+  for (i = 0; vec_safe_iterate (s, i, &uf); i++)\n     {\n       fprintf (file, \"#%u:\\n\", i);\n       cp_debug_print_unparsed_function (file, uf);\n@@ -454,7 +453,7 @@ cp_debug_parser_tokens (FILE *file, cp_parser *parser, int window_size)\n     file = stderr;\n \n   next_token = parser->lexer->next_token;\n-  first_token = VEC_address (cp_token, parser->lexer->buffer);\n+  first_token = parser->lexer->buffer->address ();\n   start_token = (next_token > first_token + window_size / 2)\n \t\t? next_token - window_size / 2\n \t\t: first_token;\n@@ -478,7 +477,7 @@ cp_debug_parser (FILE *file, cp_parser *parser)\n \n   fprintf (file, \"Parser state\\n\\n\");\n   fprintf (file, \"Number of tokens: %u\\n\",\n-\t   VEC_length (cp_token, parser->lexer->buffer));\n+\t   vec_safe_length (parser->lexer->buffer));\n   cp_debug_print_tree_if_set (file, \"Lookup scope\", parser->scope);\n   cp_debug_print_tree_if_set (file, \"Object scope\",\n \t\t\t\t     parser->object_scope);\n@@ -563,11 +562,10 @@ cp_lexer_alloc (void)\n   /* Initially we are not debugging.  */\n   lexer->debugging_p = false;\n \n-  lexer->saved_tokens = VEC_alloc (cp_token_position, heap,\n-\t\t\t\t   CP_SAVED_TOKEN_STACK);\n+  lexer->saved_tokens.create (CP_SAVED_TOKEN_STACK);\n \n   /* Create the buffer.  */\n-  lexer->buffer = VEC_alloc (cp_token, gc, CP_LEXER_BUFFER_SIZE);\n+  vec_alloc (lexer->buffer, CP_LEXER_BUFFER_SIZE);\n \n   return lexer;\n }\n@@ -590,20 +588,20 @@ cp_lexer_new_main (void)\n   lexer = cp_lexer_alloc ();\n \n   /* Put the first token in the buffer.  */\n-  VEC_quick_push (cp_token, lexer->buffer, token);\n+  lexer->buffer->quick_push (token);\n \n   /* Get the remaining tokens from the preprocessor.  */\n   while (token.type != CPP_EOF)\n     {\n       cp_lexer_get_preprocessor_token (lexer, &token);\n-      VEC_safe_push (cp_token, gc, lexer->buffer, token);\n+      vec_safe_push (lexer->buffer, token);\n     }\n \n-  lexer->last_token = VEC_address (cp_token, lexer->buffer)\n-                      + VEC_length (cp_token, lexer->buffer)\n+  lexer->last_token = lexer->buffer->address ()\n+                      + lexer->buffer->length ()\n \t\t      - 1;\n-  lexer->next_token = VEC_length (cp_token, lexer->buffer)\n-\t\t      ? VEC_address (cp_token, lexer->buffer)\n+  lexer->next_token = lexer->buffer->length ()\n+\t\t      ? lexer->buffer->address ()\n \t\t      : &eof_token;\n \n   /* Subsequent preprocessor diagnostics should use compiler\n@@ -629,8 +627,7 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n   lexer->next_token = first == last ? &eof_token : first;\n   lexer->last_token = last;\n \n-  lexer->saved_tokens = VEC_alloc (cp_token_position, heap,\n-\t\t\t\t   CP_SAVED_TOKEN_STACK);\n+  lexer->saved_tokens.create (CP_SAVED_TOKEN_STACK);\n \n   /* Initially we are not debugging.  */\n   lexer->debugging_p = false;\n@@ -644,8 +641,8 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n static void\n cp_lexer_destroy (cp_lexer *lexer)\n {\n-  VEC_free (cp_token, gc, lexer->buffer);\n-  VEC_free (cp_token_position, heap, lexer->saved_tokens);\n+  vec_free (lexer->buffer);\n+  lexer->saved_tokens.release ();\n   ggc_free (lexer);\n }\n \n@@ -700,7 +697,7 @@ cp_lexer_previous_token (cp_lexer *lexer)\n static inline int\n cp_lexer_saving_tokens (const cp_lexer* lexer)\n {\n-  return VEC_length (cp_token_position, lexer->saved_tokens) != 0;\n+  return lexer->saved_tokens.length () != 0;\n }\n \n /* Store the next token from the preprocessor in *TOKEN.  Return true\n@@ -1060,8 +1057,7 @@ cp_lexer_save_tokens (cp_lexer* lexer)\n   if (cp_lexer_debugging_p (lexer))\n     fprintf (cp_lexer_debug_stream, \"cp_lexer: saving tokens\\n\");\n \n-  VEC_safe_push (cp_token_position, heap,\n-\t\t lexer->saved_tokens, lexer->next_token);\n+  lexer->saved_tokens.safe_push (lexer->next_token);\n }\n \n /* Commit to the portion of the token stream most recently saved.  */\n@@ -1073,7 +1069,7 @@ cp_lexer_commit_tokens (cp_lexer* lexer)\n   if (cp_lexer_debugging_p (lexer))\n     fprintf (cp_lexer_debug_stream, \"cp_lexer: committing tokens\\n\");\n \n-  VEC_pop (cp_token_position, lexer->saved_tokens);\n+  lexer->saved_tokens.pop ();\n }\n \n /* Return all tokens saved since the last call to cp_lexer_save_tokens\n@@ -1086,7 +1082,7 @@ cp_lexer_rollback_tokens (cp_lexer* lexer)\n   if (cp_lexer_debugging_p (lexer))\n     fprintf (cp_lexer_debug_stream, \"cp_lexer: restoring tokens\\n\");\n \n-  lexer->next_token = VEC_pop (cp_token_position, lexer->saved_tokens);\n+  lexer->next_token = lexer->saved_tokens.pop ();\n }\n \n /* Print a representation of the TOKEN on the STREAM.  */\n@@ -1735,24 +1731,24 @@ cp_parser_context_new (cp_parser_context* next)\n /* Managing the unparsed function queues.  */\n \n #define unparsed_funs_with_default_args \\\n-  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues).funs_with_default_args\n+  parser->unparsed_queues->last ().funs_with_default_args\n #define unparsed_funs_with_definitions \\\n-  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues).funs_with_definitions\n+  parser->unparsed_queues->last ().funs_with_definitions\n #define unparsed_nsdmis \\\n-  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues).nsdmis\n+  parser->unparsed_queues->last ().nsdmis\n \n static void\n push_unparsed_function_queues (cp_parser *parser)\n {\n   cp_unparsed_functions_entry e = {NULL, make_tree_vector (), NULL};\n-  VEC_safe_push (cp_unparsed_functions_entry, gc, parser->unparsed_queues, e);\n+  vec_safe_push (parser->unparsed_queues, e);\n }\n \n static void\n pop_unparsed_function_queues (cp_parser *parser)\n {\n   release_tree_vector (unparsed_funs_with_definitions);\n-  VEC_pop (cp_unparsed_functions_entry, parser->unparsed_queues);\n+  parser->unparsed_queues->pop ();\n }\n \n /* Prototypes.  */\n@@ -1812,7 +1808,7 @@ static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool);\n static tree cp_parser_postfix_dot_deref_expression\n   (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *, location_t);\n-static VEC(tree,gc) *cp_parser_parenthesized_expression_list\n+static vec<tree, va_gc> *cp_parser_parenthesized_expression_list\n   (cp_parser *, int, bool, bool, bool *);\n /* Values for the second parameter of cp_parser_parenthesized_expression_list.  */\n enum { non_attr = 0, normal_attr = 1, id_attr = 2 };\n@@ -1824,15 +1820,15 @@ static enum tree_code cp_parser_unary_operator\n   (cp_token *);\n static tree cp_parser_new_expression\n   (cp_parser *);\n-static VEC(tree,gc) *cp_parser_new_placement\n+static vec<tree, va_gc> *cp_parser_new_placement\n   (cp_parser *);\n static tree cp_parser_new_type_id\n   (cp_parser *, tree *);\n static cp_declarator *cp_parser_new_declarator_opt\n   (cp_parser *);\n static cp_declarator *cp_parser_direct_new_declarator\n   (cp_parser *);\n-static VEC(tree,gc) *cp_parser_new_initializer\n+static vec<tree, va_gc> *cp_parser_new_initializer\n   (cp_parser *);\n static tree cp_parser_delete_expression\n   (cp_parser *);\n@@ -1964,7 +1960,7 @@ static tree cp_parser_decltype\n /* Declarators [gram.dcl.decl] */\n \n static tree cp_parser_init_declarator\n-  (cp_parser *, cp_decl_specifier_seq *, VEC (deferred_access_check,gc)*, bool, bool, int, bool *, tree *);\n+  (cp_parser *, cp_decl_specifier_seq *, vec<deferred_access_check, va_gc> *, bool, bool, int, bool *, tree *);\n static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool *, bool);\n static cp_declarator *cp_parser_direct_declarator\n@@ -2004,7 +2000,7 @@ static tree cp_parser_initializer_clause\n   (cp_parser *, bool *);\n static tree cp_parser_braced_list\n   (cp_parser*, bool*);\n-static VEC(constructor_elt,gc) *cp_parser_initializer_list\n+static vec<constructor_elt, va_gc> *cp_parser_initializer_list\n   (cp_parser *, bool *);\n \n static bool cp_parser_ctor_initializer_opt_and_function_body\n@@ -2220,9 +2216,9 @@ static tree cp_parser_function_definition_after_declarator\n static void cp_parser_template_declaration_after_export\n   (cp_parser *, bool);\n static void cp_parser_perform_template_parameter_access_checks\n-  (VEC (deferred_access_check,gc)*);\n+  (vec<deferred_access_check, va_gc> *);\n static tree cp_parser_single_declaration\n-  (cp_parser *, VEC (deferred_access_check,gc)*, bool, bool, bool *);\n+  (cp_parser *, vec<deferred_access_check, va_gc> *, bool, bool, bool *);\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n@@ -3551,7 +3547,7 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n /* Look up a literal operator with the name and the exact arguments.  */\n \n static tree\n-lookup_literal_operator (tree name, VEC(tree,gc) *args)\n+lookup_literal_operator (tree name, vec<tree, va_gc> *args)\n {\n   tree decl, fns;\n   decl = lookup_name (name);\n@@ -3567,11 +3563,11 @@ lookup_literal_operator (tree name, VEC(tree,gc) *args)\n       argtypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n       if (argtypes != NULL_TREE)\n \t{\n-\t  for (ix = 0; ix < VEC_length (tree, args) && argtypes != NULL_TREE;\n+\t  for (ix = 0; ix < vec_safe_length (args) && argtypes != NULL_TREE;\n \t       ++ix, argtypes = TREE_CHAIN (argtypes))\n \t    {\n \t      tree targ = TREE_VALUE (argtypes);\n-\t      tree tparm = TREE_TYPE (VEC_index (tree, args, ix));\n+\t      tree tparm = TREE_TYPE ((*args)[ix]);\n \t      bool ptr = TREE_CODE (targ) == POINTER_TYPE;\n \t      bool arr = TREE_CODE (tparm) == ARRAY_TYPE;\n \t      if ((ptr || arr || !same_type_p (targ, tparm))\n@@ -3581,7 +3577,7 @@ lookup_literal_operator (tree name, VEC(tree,gc) *args)\n \t\tfound = false;\n \t    }\n \t  if (found\n-\t      && ix == VEC_length (tree, args)\n+\t      && ix == vec_safe_length (args)\n \t      /* May be this should be sufficient_parms_p instead,\n \t\t depending on how exactly should user-defined literals\n \t\t work in presence of default arguments on the literal\n@@ -3609,8 +3605,8 @@ cp_parser_userdef_char_literal (cp_parser *parser)\n \n   /* Build up a call to the user-defined operator  */\n   /* Lookup the name we got back from the id-expression.  */\n-  VEC(tree,gc) *args = make_tree_vector ();\n-  VEC_safe_push (tree, gc, args, value);\n+  vec<tree, va_gc> *args = make_tree_vector ();\n+  vec_safe_push (args, value);\n   decl = lookup_literal_operator (name, args);\n   if (!decl || decl == error_mark_node)\n     {\n@@ -3668,12 +3664,12 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n   tree num_string = USERDEF_LITERAL_NUM_STRING (literal);\n   tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n   tree decl, result;\n-  VEC(tree,gc) *args;\n+  vec<tree, va_gc> *args;\n \n   /* Look for a literal operator taking the exact type of numeric argument\n      as the literal value.  */\n   args = make_tree_vector ();\n-  VEC_safe_push (tree, gc, args, value);\n+  vec_safe_push (args, value);\n   decl = lookup_literal_operator (name, args);\n   if (decl && decl != error_mark_node)\n     {\n@@ -3690,7 +3686,7 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n      operator taking a const char* argument consisting of the number\n      in string format.  */\n   args = make_tree_vector ();\n-  VEC_safe_push (tree, gc, args, num_string);\n+  vec_safe_push (args, num_string);\n   decl = lookup_literal_operator (name, args);\n   if (decl && decl != error_mark_node)\n     {\n@@ -3742,9 +3738,9 @@ cp_parser_userdef_string_literal (cp_token *token)\n \n   /* Build up a call to the user-defined operator  */\n   /* Lookup the name we got back from the id-expression.  */\n-  VEC(tree,gc) *args = make_tree_vector ();\n-  VEC_safe_push (tree, gc, args, value);\n-  VEC_safe_push (tree, gc, args, build_int_cst (size_type_node, len));\n+  vec<tree, va_gc> *args = make_tree_vector ();\n+  vec_safe_push (args, value);\n+  vec_safe_push (args, build_int_cst (size_type_node, len));\n   decl = lookup_name (name);\n   if (!decl || decl == error_mark_node)\n     {\n@@ -5496,7 +5492,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n     case RID_BUILTIN_SHUFFLE:\n       {\n-\tVEC(tree,gc)* vec;\n+\tvec<tree, va_gc> *vec;\n \tunsigned int i;\n \ttree p;\n \tlocation_t loc = token->location;\n@@ -5508,21 +5504,13 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tif (vec == NULL)\n \t  return error_mark_node;\n \n-\tFOR_EACH_VEC_ELT (tree, vec, i, p)\n+\tFOR_EACH_VEC_ELT (*vec, i, p)\n \t  mark_exp_read (p);\n \n-\tif (VEC_length (tree, vec) == 2)\n-\t  return\n-\t    c_build_vec_perm_expr\n-\t    (loc, VEC_index (tree, vec, 0),\n-\t     NULL_TREE, VEC_index (tree, vec, 1));\n-\n-\telse if (VEC_length (tree, vec) == 3)\n-\t  return\n-\t    c_build_vec_perm_expr\n-\t    (loc, VEC_index (tree, vec, 0),\n-\t     VEC_index (tree, vec, 1),\n-\t     VEC_index (tree, vec, 2));\n+\tif (vec->length () == 2)\n+\t  return c_build_vec_perm_expr (loc, (*vec)[0], NULL_TREE, (*vec)[1]); \n+\telse if (vec->length () == 3)\n+\t  return c_build_vec_perm_expr (loc, (*vec)[0], (*vec)[1], (*vec)[2]);\n \telse\n \t{\n \t  error_at (loc, \"wrong number of arguments to \"\n@@ -5558,7 +5546,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tif (cp_parser_allow_gnu_extensions_p (parser)\n \t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n \t  {\n-\t    VEC(constructor_elt,gc) *initializer_list = NULL;\n+\t    vec<constructor_elt, va_gc> *initializer_list = NULL;\n \t    bool saved_in_type_id_in_expr_p;\n \n \t    cp_parser_parse_tentatively (parser);\n@@ -5666,7 +5654,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    bool is_builtin_constant_p;\n \t    bool saved_integral_constant_expression_p = false;\n \t    bool saved_non_integral_constant_expression_p = false;\n-\t    VEC(tree,gc) *args;\n+\t    vec<tree, va_gc> *args;\n \n             is_member_access = false;\n \n@@ -5717,7 +5705,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t      {\n \t\tif (TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n \t\t  {\n-\t\t    if (!VEC_empty (tree, args))\n+\t\t    if (!args->is_empty ())\n \t\t      {\n \t\t\tkoenig_p = true;\n \t\t\tif (!any_type_dependent_arguments_p (args))\n@@ -5733,7 +5721,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t/* We do not perform argument-dependent lookup if\n \t\t   normal lookup finds a non-function, in accordance\n \t\t   with the expected resolution of DR 218.  */\n-\t\telse if (!VEC_empty (tree, args)\n+\t\telse if (!args->is_empty ()\n \t\t\t && is_overloaded_fn (postfix_expression))\n \t\t  {\n \t\t    tree fn = get_first_fn (postfix_expression);\n@@ -6154,14 +6142,14 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n    NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P indicates whether or\n    not all of the expressions in the list were constant.  */\n \n-static VEC(tree,gc) *\n+static vec<tree, va_gc> *\n cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t int is_attribute_list,\n \t\t\t\t\t bool cast_p,\n                                          bool allow_expansion_p,\n \t\t\t\t\t bool *non_constant_p)\n {\n-  VEC(tree,gc) *expression_list;\n+  vec<tree, va_gc> *expression_list;\n   bool fold_expr_p = is_attribute_list != non_attr;\n   tree identifier = NULL_TREE;\n   bool saved_greater_than_is_operator_p;\n@@ -6242,7 +6230,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\texpressions to the list, so that we can still tell if\n \t\tthe correct form for a parenthesized expression-list\n \t\tis found. That gives better errors.  */\n-\t    VEC_safe_push (tree, gc, expression_list, expr);\n+\t    vec_safe_push (expression_list, expr);\n \n \t    if (expr == error_mark_node)\n \t      goto skip_comma;\n@@ -6286,7 +6274,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n     = saved_greater_than_is_operator_p;\n \n   if (identifier)\n-    VEC_safe_insert (tree, gc, expression_list, 0, identifier);\n+    vec_safe_insert (expression_list, 0, identifier);\n \n   return expression_list;\n }\n@@ -6725,9 +6713,9 @@ static tree\n cp_parser_new_expression (cp_parser* parser)\n {\n   bool global_scope_p;\n-  VEC(tree,gc) *placement;\n+  vec<tree, va_gc> *placement;\n   tree type;\n-  VEC(tree,gc) *initializer;\n+  vec<tree, va_gc> *initializer;\n   tree nelts = NULL_TREE;\n   tree ret;\n \n@@ -6819,10 +6807,10 @@ cp_parser_new_expression (cp_parser* parser)\n \n    Returns the same representation as for an expression-list.  */\n \n-static VEC(tree,gc) *\n+static vec<tree, va_gc> *\n cp_parser_new_placement (cp_parser* parser)\n {\n-  VEC(tree,gc) *expression_list;\n+  vec<tree, va_gc> *expression_list;\n \n   /* Parse the expression-list.  */\n   expression_list = (cp_parser_parenthesized_expression_list\n@@ -7014,10 +7002,10 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \n    Returns a representation of the expression-list.  */\n \n-static VEC(tree,gc) *\n+static vec<tree, va_gc> *\n cp_parser_new_initializer (cp_parser* parser)\n {\n-  VEC(tree,gc) *expression_list;\n+  vec<tree, va_gc> *expression_list;\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n@@ -8084,9 +8072,7 @@ typedef struct GTY(()) tree_int\n   tree t;\n   int i;\n } tree_int;\n-DEF_VEC_O(tree_int);\n-DEF_VEC_ALLOC_O(tree_int,gc);\n-static GTY(()) VEC(tree_int,gc) *lambda_scope_stack;\n+static GTY(()) vec<tree_int, va_gc> *lambda_scope_stack;\n \n static void\n start_lambda_scope (tree decl)\n@@ -8099,7 +8085,7 @@ start_lambda_scope (tree decl)\n     decl = current_function_decl;\n   ti.t = lambda_scope;\n   ti.i = lambda_count;\n-  VEC_safe_push (tree_int, gc, lambda_scope_stack, ti);\n+  vec_safe_push (lambda_scope_stack, ti);\n   if (lambda_scope != decl)\n     {\n       /* Don't reset the count if we're still in the same function.  */\n@@ -8118,13 +8104,13 @@ record_lambda_scope (tree lambda)\n static void\n finish_lambda_scope (void)\n {\n-  tree_int *p = &VEC_last (tree_int, lambda_scope_stack);\n+  tree_int *p = &lambda_scope_stack->last ();\n   if (lambda_scope != p->t)\n     {\n       lambda_scope = p->t;\n       lambda_count = p->i;\n     }\n-  VEC_pop (tree_int, lambda_scope_stack);\n+  lambda_scope_stack->pop ();\n }\n \n /* Parse a lambda expression.\n@@ -9716,10 +9702,10 @@ cp_parser_perform_range_for_lookup (tree range, tree *begin, tree *end)\n       else\n \t{\n \t  /* Use global functions with ADL.  */\n-\t  VEC(tree,gc) *vec;\n+\t  vec<tree, va_gc> *vec;\n \t  vec = make_tree_vector ();\n \n-\t  VEC_safe_push (tree, gc, vec, range);\n+\t  vec_safe_push (vec, range);\n \n \t  member_begin = perform_koenig_lookup (id_begin, vec,\n \t\t\t\t\t\t/*include_std=*/true,\n@@ -9763,7 +9749,7 @@ static tree\n cp_parser_range_for_member_function (tree range, tree identifier)\n {\n   tree member, res;\n-  VEC(tree,gc) *vec;\n+  vec<tree, va_gc> *vec;\n \n   member = finish_class_member_access_expr (range, identifier,\n \t\t\t\t\t    false, tf_warning_or_error);\n@@ -11671,7 +11657,7 @@ cp_parser_mem_initializer (cp_parser* parser)\n     }\n   else\n     {\n-      VEC(tree,gc)* vec;\n+      vec<tree, va_gc> *vec;\n       vec = cp_parser_parenthesized_expression_list (parser, non_attr,\n \t\t\t\t\t\t     /*cast_p=*/false,\n \t\t\t\t\t\t     /*allow_expansion_p=*/true,\n@@ -12566,7 +12552,7 @@ cp_parser_template_id (cp_parser *parser,\n   tree template_id;\n   cp_token_position start_of_id = 0;\n   deferred_access_check *chk;\n-  VEC (deferred_access_check,gc) *access_check;\n+  vec<deferred_access_check, va_gc> *access_check;\n   cp_token *next_token = NULL, *next_token_2 = NULL;\n   bool is_identifier;\n \n@@ -12583,7 +12569,7 @@ cp_parser_template_id (cp_parser *parser,\n       access_check = check_value->checks;\n       if (access_check)\n \t{\n-\t  FOR_EACH_VEC_ELT (deferred_access_check, access_check, i, chk)\n+\t  FOR_EACH_VEC_ELT (*access_check, i, chk)\n \t    perform_or_defer_access_check (chk->binfo,\n \t\t\t\t\t   chk->decl,\n \t\t\t\t\t   chk->diag_decl,\n@@ -15664,7 +15650,7 @@ cp_parser_asm_definition (cp_parser* parser)\n static tree\n cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   cp_decl_specifier_seq *decl_specifiers,\n-\t\t\t   VEC (deferred_access_check,gc)* checks,\n+\t\t\t   vec<deferred_access_check, va_gc> *checks,\n \t\t\t   bool function_definition_allowed_p,\n \t\t\t   bool member_p,\n \t\t\t   int declares_class_or_enum,\n@@ -17744,7 +17730,7 @@ cp_parser_initializer (cp_parser* parser, bool* is_direct_init,\n     }\n   else if (token->type == CPP_OPEN_PAREN)\n     {\n-      VEC(tree,gc) *vec;\n+      vec<tree, va_gc> *vec;\n       vec = cp_parser_parenthesized_expression_list (parser, non_attr,\n \t\t\t\t\t\t     /*cast_p=*/false,\n \t\t\t\t\t\t     /*allow_expansion_p=*/true,\n@@ -17861,15 +17847,15 @@ cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n      identifier :\n      [ constant-expression ] =\n \n-   Returns a VEC of constructor_elt.  The VALUE of each elt is an expression\n+   Returns a vec of constructor_elt.  The VALUE of each elt is an expression\n    for the initializer.  If the INDEX of the elt is non-NULL, it is the\n    IDENTIFIER_NODE naming the field to initialize.  NON_CONSTANT_P is\n    as for cp_parser_initializer.  */\n \n-static VEC(constructor_elt,gc) *\n+static vec<constructor_elt, va_gc> *\n cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n {\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n \n   /* Assume all of the expressions are constant.  */\n   *non_constant_p = false;\n@@ -18370,8 +18356,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t    };\n \n \t */\n-      FOR_EACH_VEC_ELT (cp_default_arg_entry, unparsed_funs_with_default_args,\n-\t\t\tix, e)\n+      FOR_EACH_VEC_SAFE_ELT (unparsed_funs_with_default_args, ix, e)\n \t{\n \t  decl = e->decl;\n \t  /* If there are default arguments that have not yet been processed,\n@@ -18390,11 +18375,11 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t  /* Remove any template parameters from the symbol table.  */\n \t  maybe_end_member_template_processing ();\n \t}\n-      VEC_truncate (cp_default_arg_entry, unparsed_funs_with_default_args, 0);\n+      vec_safe_truncate (unparsed_funs_with_default_args, 0);\n       /* Now parse any NSDMIs.  */\n       save_ccp = current_class_ptr;\n       save_ccr = current_class_ref;\n-      FOR_EACH_VEC_ELT (tree, unparsed_nsdmis, ix, decl)\n+      FOR_EACH_VEC_SAFE_ELT (unparsed_nsdmis, ix, decl)\n \t{\n \t  if (class_type != DECL_CONTEXT (decl))\n \t    {\n@@ -18406,15 +18391,15 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t  inject_this_parameter (class_type, TYPE_UNQUALIFIED);\n \t  cp_parser_late_parsing_nsdmi (parser, decl);\n \t}\n-      VEC_truncate (tree, unparsed_nsdmis, 0);\n+      vec_safe_truncate (unparsed_nsdmis, 0);\n       current_class_ptr = save_ccp;\n       current_class_ref = save_ccr;\n       if (pushed_scope)\n \tpop_scope (pushed_scope);\n       /* Now parse the body of the functions.  */\n-      FOR_EACH_VEC_ELT (tree, unparsed_funs_with_definitions, ix, decl)\n+      FOR_EACH_VEC_SAFE_ELT (unparsed_funs_with_definitions, ix, decl)\n \tcp_parser_late_parsing_for_member (parser, decl);\n-      VEC_truncate (tree, unparsed_funs_with_definitions, 0);\n+      vec_safe_truncate (unparsed_funs_with_definitions, 0);\n     }\n \n   /* Put back any saved access checks.  */\n@@ -19453,7 +19438,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t       && !DECL_C_BIT_FIELD (decl)\n \t\t       && DECL_INITIAL (decl))\n \t\t/* Add DECL to the queue of NSDMI to be parsed later.  */\n-\t\tVEC_safe_push (tree, gc, unparsed_nsdmis, decl);\n+\t\tvec_safe_push (unparsed_nsdmis, decl);\n \t    }\n \n \t  if (assume_semicolon)\n@@ -20503,7 +20488,7 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \t  /* If it's an `(', then parse the attribute arguments.  */\n \t  if (token->type == CPP_OPEN_PAREN)\n \t    {\n-\t      VEC(tree,gc) *vec;\n+\t      vec<tree, va_gc> *vec;\n \t      int attr_flag = (attribute_takes_identifier_p (identifier)\n \t\t\t       ? id_attr : normal_attr);\n \t      vec = cp_parser_parenthesized_expression_list\n@@ -20640,7 +20625,7 @@ cp_parser_std_attribute (cp_parser *parser)\n     return attribute;\n \n   {\n-    VEC(tree, gc) *vec;\n+    vec<tree, va_gc> *vec;\n     int attr_flag = normal_attr;\n \n     if (attr_ns == get_identifier (\"gnu\")\n@@ -21672,7 +21657,7 @@ static void\n cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n {\n   tree decl = NULL_TREE;\n-  VEC (deferred_access_check,gc) *checks;\n+  vec<deferred_access_check, va_gc> *checks;\n   tree parameter_list;\n   bool friend_p = false;\n   bool need_lang_pop;\n@@ -21824,15 +21809,15 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   if (member_p && decl\n       && (TREE_CODE (decl) == FUNCTION_DECL\n \t  || DECL_FUNCTION_TEMPLATE_P (decl)))\n-    VEC_safe_push (tree, gc, unparsed_funs_with_definitions, decl);\n+    vec_safe_push (unparsed_funs_with_definitions, decl);\n }\n \n /* Perform the deferred access checks from a template-parameter-list.\n    CHECKS is a TREE_LIST of access checks, as returned by\n    get_deferred_access_checks.  */\n \n static void\n-cp_parser_perform_template_parameter_access_checks (VEC (deferred_access_check,gc)* checks)\n+cp_parser_perform_template_parameter_access_checks (vec<deferred_access_check, va_gc> *checks)\n {\n   ++processing_template_parmlist;\n   perform_access_checks (checks, tf_warning_or_error);\n@@ -21848,7 +21833,7 @@ cp_parser_perform_template_parameter_access_checks (VEC (deferred_access_check,g\n \n static tree\n cp_parser_single_declaration (cp_parser* parser,\n-\t\t\t      VEC (deferred_access_check,gc)* checks,\n+\t\t\t      vec<deferred_access_check, va_gc> *checks,\n \t\t\t      bool member_p,\n                               bool explicit_specialization_p,\n \t\t\t      bool* friend_p)\n@@ -21999,7 +21984,7 @@ cp_parser_simple_cast_expression (cp_parser *parser)\n static tree\n cp_parser_functional_cast (cp_parser* parser, tree type)\n {\n-  VEC(tree,gc) *vec;\n+  vec<tree, va_gc> *vec;\n   tree expression_list;\n   tree cast;\n   bool nonconst_p;\n@@ -22108,7 +22093,7 @@ cp_parser_save_member_function_body (cp_parser* parser,\n   DECL_INITIALIZED_IN_CLASS_P (fn) = 1;\n \n   /* Add FN to the queue of functions to be parsed later.  */\n-  VEC_safe_push (tree, gc, unparsed_funs_with_definitions, fn);\n+  vec_safe_push (unparsed_funs_with_definitions, fn);\n \n   return fn;\n }\n@@ -22319,8 +22304,7 @@ cp_parser_save_default_args (cp_parser* parser, tree decl)\n     if (TREE_PURPOSE (probe))\n       {\n \tcp_default_arg_entry entry = {current_class_type, decl};\n-\tVEC_safe_push (cp_default_arg_entry, gc,\n-\t\t       unparsed_funs_with_default_args, entry);\n+\tvec_safe_push (unparsed_funs_with_default_args, entry);\n \tbreak;\n       }\n }\n@@ -22440,7 +22424,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n     {\n       tree default_arg = TREE_PURPOSE (parm);\n       tree parsed_arg;\n-      VEC(tree,gc) *insts;\n+      vec<tree, va_gc> *insts;\n       tree copy;\n       unsigned ix;\n \n@@ -22465,7 +22449,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n \n       /* Update any instantiations we've already created.  */\n       for (insts = DEFARG_INSTANTIATIONS (default_arg), ix = 0;\n-\t   VEC_iterate (tree, insts, ix, copy); ix++)\n+\t   vec_safe_iterate (insts, ix, &copy); ix++)\n \tTREE_PURPOSE (copy) = parsed_arg;\n     }\n \n@@ -23298,15 +23282,15 @@ cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n   int i;\n   struct tree_check *check_value;\n   deferred_access_check *chk;\n-  VEC (deferred_access_check,gc) *checks;\n+  vec<deferred_access_check, va_gc> *checks;\n \n   /* Get the stored value.  */\n   check_value = cp_lexer_consume_token (parser->lexer)->u.tree_check_value;\n   /* Perform any access checks that were deferred.  */\n   checks = check_value->checks;\n   if (checks)\n     {\n-      FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n+      FOR_EACH_VEC_SAFE_ELT (checks, i, chk)\n \tperform_or_defer_access_check (chk->binfo,\n \t\t\t\t       chk->decl,\n \t\t\t\t       chk->diag_decl, tf_warning_or_error);\n@@ -26875,7 +26859,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n   location_t loc_first;\n   bool collapse_err = false;\n   int i, collapse = 1, nbraces = 0;\n-  VEC(tree,gc) *for_block = make_tree_vector ();\n+  vec<tree, va_gc> *for_block = make_tree_vector ();\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n@@ -26994,7 +26978,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t\t\t      LOOKUP_ONLYCONVERTING);\n \t\t      if (CLASS_TYPE_P (TREE_TYPE (decl)))\n \t\t\t{\n-\t\t\t  VEC_safe_push (tree, gc, for_block, this_pre_body);\n+\t\t\t  vec_safe_push (for_block, this_pre_body);\n \t\t\t  init = NULL_TREE;\n \t\t\t}\n \t\t      else\n@@ -27252,8 +27236,8 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t}\n     }\n \n-  while (!VEC_empty (tree, for_block))\n-    add_stmt (pop_stmt_list (VEC_pop (tree, for_block)));\n+  while (!for_block->is_empty ())\n+    add_stmt (pop_stmt_list (for_block->pop ()));\n   release_tree_vector (for_block);\n \n   return ret;"}, {"sha": "cf281c4b18768cfb57b38232a18f2036e788e062", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -30,7 +30,7 @@ struct GTY(()) tree_check {\n   /* The value associated with the token.  */\n   tree value;\n   /* The checks that have been associated with value.  */\n-  VEC (deferred_access_check, gc)* checks;\n+  vec<deferred_access_check, va_gc> *checks;\n   /* The token's qualifying scope (used when it is a\n      CPP_NESTED_NAME_SPECIFIER).  */\n   tree qualifying_scope;\n@@ -69,14 +69,9 @@ typedef struct GTY (()) cp_token {\n   } GTY((desc (\"(%1.type == CPP_TEMPLATE_ID) || (%1.type == CPP_NESTED_NAME_SPECIFIER)\"))) u;\n } cp_token;\n \n-DEF_VEC_O (cp_token);\n-DEF_VEC_ALLOC_O (cp_token,gc);\n-DEF_VEC_ALLOC_O (cp_token,heap);\n \n /* We use a stack of token pointer for saving token sets.  */\n typedef struct cp_token *cp_token_position;\n-DEF_VEC_P (cp_token_position);\n-DEF_VEC_ALLOC_P (cp_token_position,heap);\n \n /* The cp_lexer structure represents the C++ lexer.  It is responsible\n    for managing the token stream from the preprocessor and supplying\n@@ -86,7 +81,7 @@ DEF_VEC_ALLOC_P (cp_token_position,heap);\n typedef struct GTY (()) cp_lexer {\n   /* The memory allocated for the buffer.  NULL if this lexer does not\n      own the token buffer.  */\n-  VEC(cp_token,gc) *buffer;\n+  vec<cp_token, va_gc> *buffer;\n \n   /* A pointer just past the last available token.  The tokens\n      in this lexer are [buffer, last_token).  */\n@@ -100,7 +95,7 @@ typedef struct GTY (()) cp_lexer {\n      called.  The top entry is the most recent position at which we\n      began saving tokens.  If the stack is non-empty, we are saving\n      tokens.  */\n-  VEC(cp_token_position,heap) *GTY ((skip)) saved_tokens;\n+  vec<cp_token_position> GTY ((skip)) saved_tokens;\n \n   /* The next lexer in a linked list of lexers.  */\n   struct cp_lexer *next;\n@@ -113,8 +108,6 @@ typedef struct GTY (()) cp_lexer {\n   bool in_pragma;\n } cp_lexer;\n \n-DEF_VEC_O (cp_lexer);\n-DEF_VEC_ALLOC_O (cp_lexer,heap);\n \n /* cp_token_cache is a range of tokens.  There is no need to represent\n    allocate heap memory for it, since tokens are never removed from the\n@@ -131,8 +124,6 @@ typedef struct GTY(()) cp_token_cache {\n } cp_token_cache;\n \n typedef cp_token_cache *cp_token_cache_ptr;\n-DEF_VEC_P (cp_token_cache_ptr);\n-DEF_VEC_ALLOC_P (cp_token_cache_ptr,gc);\n \n struct cp_token_ident_d\n {\n@@ -156,27 +147,23 @@ typedef struct GTY(()) cp_default_arg_entry_d {\n   tree decl;\n } cp_default_arg_entry;\n \n-DEF_VEC_O(cp_default_arg_entry);\n-DEF_VEC_ALLOC_O(cp_default_arg_entry,gc);\n \n /* An entry in a stack for member functions of local classes.  */\n \n typedef struct GTY(()) cp_unparsed_functions_entry_d {\n   /* Functions with default arguments that require post-processing.\n      Functions appear in this list in declaration order.  */\n-  VEC(cp_default_arg_entry,gc) *funs_with_default_args;\n+  vec<cp_default_arg_entry, va_gc> *funs_with_default_args;\n \n   /* Functions with defintions that require post-processing.  Functions\n      appear in this list in declaration order.  */\n-  VEC(tree,gc) *funs_with_definitions;\n+  vec<tree, va_gc> *funs_with_definitions;\n \n   /* Non-static data members with initializers that require post-processing.\n      FIELD_DECLs appear in this list in declaration order.  */\n-  VEC(tree,gc) *nsdmis;\n+  vec<tree, va_gc> *nsdmis;\n } cp_unparsed_functions_entry;\n \n-DEF_VEC_O(cp_unparsed_functions_entry);\n-DEF_VEC_ALLOC_O(cp_unparsed_functions_entry,gc);\n \n /* The status of a tentative parse.  */\n \n@@ -344,7 +331,7 @@ typedef struct GTY(()) cp_parser {\n   /* A stack used for member functions of local classes.  The lists\n      contained in an individual entry can only be processed once the\n      outermost class being defined is complete.  */\n-  VEC(cp_unparsed_functions_entry,gc) *unparsed_queues;\n+  vec<cp_unparsed_functions_entry, va_gc> *unparsed_queues;\n \n   /* The number of classes whose definitions are currently in\n      progress.  */\n@@ -356,7 +343,7 @@ typedef struct GTY(()) cp_parser {\n } cp_parser;\n \n /* In parser.c  */\n-extern void cp_lexer_debug_tokens (VEC(cp_token,gc) *);\n+extern void cp_lexer_debug_tokens (vec<cp_token, va_gc> *);\n extern void cp_debug_parser (FILE *, cp_parser *);\n \n #endif  /* GCC_CP_PARSER_H  */"}, {"sha": "ecb013ecaee5dab46c76f81ec44b9facb63397d3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 45, "deletions": 54, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"timevar.h\"\n #include \"tree-iterator.h\"\n-#include \"vecprim.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -64,7 +63,7 @@ int processing_template_parmlist;\n static int template_header_count;\n \n static GTY(()) tree saved_trees;\n-static VEC(int,heap) *inline_parm_levels;\n+static vec<int> inline_parm_levels;\n \n static GTY(()) struct tinst_level *current_tinst_level;\n \n@@ -100,7 +99,7 @@ static GTY ((param_is (spec_entry)))\n    the TEMPLATE_TYPE_IDX of the template parameter. Each element is a\n    TREE_LIST, whose TREE_VALUEs contain the canonical template\n    parameters of various types and levels.  */\n-static GTY(()) VEC(tree,gc) *canonical_template_parms;\n+static GTY(()) vec<tree, va_gc> *canonical_template_parms;\n \n #define UNIFY_ALLOW_NONE 0\n #define UNIFY_ALLOW_MORE_CV_QUAL 1\n@@ -473,7 +472,7 @@ maybe_begin_member_template_processing (tree decl)\n \n   /* Remember how many levels of template parameters we pushed so that\n      we can pop them later.  */\n-  VEC_safe_push (int, heap, inline_parm_levels, levels);\n+  inline_parm_levels.safe_push (levels);\n }\n \n /* Undo the effects of maybe_begin_member_template_processing.  */\n@@ -484,10 +483,10 @@ maybe_end_member_template_processing (void)\n   int i;\n   int last;\n \n-  if (VEC_length (int, inline_parm_levels) == 0)\n+  if (inline_parm_levels.length () == 0)\n     return;\n \n-  last = VEC_pop (int, inline_parm_levels);\n+  last = inline_parm_levels.pop ();\n   for (i = 0; i < last; ++i)\n     {\n       --processing_template_decl;\n@@ -1018,7 +1017,7 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n     {\n       tree class_template;\n       tree class_specialization;\n-      VEC(tree,gc) *methods;\n+      vec<tree, va_gc> *methods;\n       tree fns;\n       int idx;\n \n@@ -1038,7 +1037,7 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n       /* Iterate through the methods with the indicated name, looking\n \t for the one that has an instance of TMPL.  */\n       methods = CLASSTYPE_METHOD_VEC (class_specialization);\n-      for (fns = VEC_index (tree, methods, idx); fns; fns = OVL_NEXT (fns))\n+      for (fns = (*methods)[idx]; fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  if (DECL_TEMPLATE_INFO (fn) && DECL_TI_TEMPLATE (fn) == tmpl\n@@ -2548,11 +2547,11 @@ check_explicit_specialization (tree declarator,\n \t    {\n \t      idx = lookup_fnfields_1 (ctype, name);\n \t      if (idx >= 0)\n-\t\tfns = VEC_index (tree, CLASSTYPE_METHOD_VEC (ctype), idx);\n+\t\tfns = (*CLASSTYPE_METHOD_VEC (ctype))[idx];\n \t    }\n \t  else\n \t    {\n-\t      VEC(tree,gc) *methods;\n+\t      vec<tree, va_gc> *methods;\n \t      tree ovl;\n \n \t      /* For a type-conversion operator, we cannot do a\n@@ -2565,7 +2564,7 @@ check_explicit_specialization (tree declarator,\n \t      methods = CLASSTYPE_METHOD_VEC (ctype);\n \t      if (methods)\n \t\tfor (idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t\t     VEC_iterate (tree, methods, idx, ovl);\n+\t\t     methods->iterate (idx, &ovl);\n \t\t     ++idx)\n \t\t  {\n \t\t    if (!DECL_CONV_FN_P (OVL_CURRENT (ovl)))\n@@ -3513,22 +3512,22 @@ canonical_type_parameter (tree type)\n   tree list;\n   int idx = TEMPLATE_TYPE_IDX (type);\n   if (!canonical_template_parms)\n-    canonical_template_parms = VEC_alloc (tree, gc, idx+1);\n+    vec_alloc (canonical_template_parms, idx+1);\n \n-  while (VEC_length (tree, canonical_template_parms) <= (unsigned)idx)\n-    VEC_safe_push (tree, gc, canonical_template_parms, NULL_TREE);\n+  while (canonical_template_parms->length () <= (unsigned)idx)\n+    vec_safe_push (canonical_template_parms, NULL_TREE);\n \n-  list = VEC_index (tree, canonical_template_parms, idx);\n+  list = (*canonical_template_parms)[idx];\n   while (list && !comptypes (type, TREE_VALUE (list), COMPARE_STRUCTURAL))\n     list = TREE_CHAIN (list);\n \n   if (list)\n     return TREE_VALUE (list);\n   else\n     {\n-      VEC_replace(tree, canonical_template_parms, idx,\n-\t\t  tree_cons (NULL_TREE, type, \n-\t\t\t     VEC_index (tree, canonical_template_parms, idx)));\n+      (*canonical_template_parms)[idx]\n+\t\t= tree_cons (NULL_TREE, type,\n+\t\t\t     (*canonical_template_parms)[idx]);\n       return type;\n     }\n }\n@@ -8457,7 +8456,7 @@ static void\n perform_typedefs_access_check (tree tmpl, tree targs)\n {\n   location_t saved_location;\n-  int i;\n+  unsigned i;\n   qualified_typedef_usage_t *iter;\n \n   if (!tmpl\n@@ -8466,9 +8465,7 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n     return;\n \n   saved_location = input_location;\n-  FOR_EACH_VEC_ELT (qualified_typedef_usage_t,\n-\t\t    get_types_needing_access_check (tmpl),\n-\t\t    i, iter)\n+  FOR_EACH_VEC_SAFE_ELT (get_types_needing_access_check (tmpl), i, iter)\n     {\n       tree type_decl = iter->typedef_decl;\n       tree type_scope = iter->context;\n@@ -10729,8 +10726,7 @@ tsubst_arg_types (tree arg_types,\n            argument in a call of this function.  */\n         remaining_arg_types = \n           tree_cons (default_arg, type, remaining_arg_types);\n-        VEC_safe_push (tree, gc, DEFARG_INSTANTIATIONS (default_arg), \n-                       remaining_arg_types);\n+        vec_safe_push (DEFARG_INSTANTIATIONS(default_arg), remaining_arg_types);\n       }\n     else\n       remaining_arg_types = \n@@ -13626,8 +13622,8 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree placement = RECUR (TREE_OPERAND (t, 0));\n \ttree init = RECUR (TREE_OPERAND (t, 3));\n-\tVEC(tree,gc) *placement_vec;\n-\tVEC(tree,gc) *init_vec;\n+\tvec<tree, va_gc> *placement_vec;\n+\tvec<tree, va_gc> *init_vec;\n \ttree ret;\n \n \tif (placement == NULL_TREE)\n@@ -13636,7 +13632,7 @@ tsubst_copy_and_build (tree t,\n \t  {\n \t    placement_vec = make_tree_vector ();\n \t    for (; placement != NULL_TREE; placement = TREE_CHAIN (placement))\n-\t      VEC_safe_push (tree, gc, placement_vec, TREE_VALUE (placement));\n+\t      vec_safe_push (placement_vec, TREE_VALUE (placement));\n \t  }\n \n \t/* If there was an initializer in the original tree, but it\n@@ -13655,7 +13651,7 @@ tsubst_copy_and_build (tree t,\n \t    else\n \t      {\n \t\tfor (; init != NULL_TREE; init = TREE_CHAIN (init))\n-\t\t  VEC_safe_push (tree, gc, init_vec, TREE_VALUE (init));\n+\t\t  vec_safe_push (init_vec, TREE_VALUE (init));\n \t      }\n \t  }\n \n@@ -13691,7 +13687,7 @@ tsubst_copy_and_build (tree t,\n     case CALL_EXPR:\n       {\n \ttree function;\n-\tVEC(tree,gc) *call_args;\n+\tvec<tree, va_gc> *call_args;\n \tunsigned int nargs, i;\n \tbool qualified_p;\n \tbool koenig_p;\n@@ -13751,8 +13747,7 @@ tsubst_copy_and_build (tree t,\n \t    tree arg = CALL_EXPR_ARG (t, i);\n \n \t    if (!PACK_EXPANSION_P (arg))\n-\t      VEC_safe_push (tree, gc, call_args,\n-\t\t\t     RECUR (CALL_EXPR_ARG (t, i)));\n+\t      vec_safe_push (call_args, RECUR (CALL_EXPR_ARG (t, i)));\n \t    else\n \t      {\n \t\t/* Expand the pack expansion and push each entry onto\n@@ -13768,13 +13763,13 @@ tsubst_copy_and_build (tree t,\n \t\t\ttree value = TREE_VEC_ELT (arg, j);\n \t\t\tif (value != NULL_TREE)\n \t\t\t  value = convert_from_reference (value);\n-\t\t\tVEC_safe_push (tree, gc, call_args, value);\n+\t\t\tvec_safe_push (call_args, value);\n \t\t      }\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    /* A partial substitution.  Add one entry.  */\n-\t\t    VEC_safe_push (tree, gc, call_args, arg);\n+\t\t    vec_safe_push (call_args, arg);\n \t\t  }\n \t      }\n \t  }\n@@ -14123,7 +14118,7 @@ tsubst_copy_and_build (tree t,\n \n     case CONSTRUCTOR:\n       {\n-\tVEC(constructor_elt,gc) *n;\n+\tvec<constructor_elt, va_gc> *n;\n \tconstructor_elt *ce;\n \tunsigned HOST_WIDE_INT idx;\n \ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n@@ -14144,9 +14139,9 @@ tsubst_copy_and_build (tree t,\n \t   looked up by digest_init.  */\n \tprocess_index_p = !(type && MAYBE_CLASS_TYPE_P (type));\n \n-\tn = VEC_copy (constructor_elt, gc, CONSTRUCTOR_ELTS (t));\n-        newlen = VEC_length (constructor_elt, n);\n-\tFOR_EACH_VEC_ELT (constructor_elt, n, idx, ce)\n+\tn = vec_safe_copy (CONSTRUCTOR_ELTS (t));\n+        newlen = vec_safe_length (n);\n+\tFOR_EACH_VEC_SAFE_ELT (n, idx, ce)\n \t  {\n \t    if (ce->index && process_index_p)\n \t      ce->index = RECUR (ce->index);\n@@ -14178,10 +14173,10 @@ tsubst_copy_and_build (tree t,\n \n         if (need_copy_p)\n           {\n-            VEC(constructor_elt,gc) *old_n = n;\n+            vec<constructor_elt, va_gc> *old_n = n;\n \n-            n = VEC_alloc (constructor_elt, gc, newlen);\n-            FOR_EACH_VEC_ELT (constructor_elt, old_n, idx, ce)\n+            vec_alloc (n, newlen);\n+            FOR_EACH_VEC_ELT (*old_n, idx, ce)\n               {\n                 if (TREE_CODE (ce->value) == TREE_VEC)\n                   {\n@@ -19791,12 +19786,12 @@ type_dependent_expression_p_push (tree expr)\n /* Returns TRUE if ARGS contains a type-dependent expression.  */\n \n bool\n-any_type_dependent_arguments_p (const VEC(tree,gc) *args)\n+any_type_dependent_arguments_p (const vec<tree, va_gc> *args)\n {\n   unsigned int i;\n   tree arg;\n \n-  FOR_EACH_VEC_ELT (tree, args, i, arg)\n+  FOR_EACH_VEC_SAFE_ELT (args, i, arg)\n     {\n       if (type_dependent_expression_p (arg))\n \treturn true;\n@@ -20249,16 +20244,16 @@ build_non_dependent_expr (tree expr)\n    This modifies ARGS in place.  */\n \n void\n-make_args_non_dependent (VEC(tree,gc) *args)\n+make_args_non_dependent (vec<tree, va_gc> *args)\n {\n   unsigned int ix;\n   tree arg;\n \n-  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n+  FOR_EACH_VEC_SAFE_ELT (args, ix, arg)\n     {\n       tree newarg = build_non_dependent_expr (arg);\n       if (newarg != arg)\n-\tVEC_replace (tree, args, ix, newarg);\n+\t(*args)[ix] = newarg;\n     }\n }\n \n@@ -20459,11 +20454,11 @@ type_uses_auto (tree type)\n    Those typedefs were added to T by the function\n    append_type_to_template_for_access_check.  */\n \n-VEC(qualified_typedef_usage_t,gc)*\n+vec<qualified_typedef_usage_t, va_gc> *\n get_types_needing_access_check (tree t)\n {\n   tree ti;\n-  VEC(qualified_typedef_usage_t,gc) *result = NULL;\n+  vec<qualified_typedef_usage_t, va_gc> *result = NULL;\n \n   if (!t || t == error_mark_node)\n     return NULL;\n@@ -20521,9 +20516,7 @@ append_type_to_template_for_access_check_1 (tree t,\n   typedef_usage.context = scope;\n   typedef_usage.locus = location;\n \n-  VEC_safe_push (qualified_typedef_usage_t, gc,\n-\t\t TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti),\n-\t\t typedef_usage);\n+  vec_safe_push (TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti), typedef_usage);\n }\n \n /* Append TYPE_DECL to the template TEMPL.\n@@ -20562,14 +20555,12 @@ append_type_to_template_for_access_check (tree templ,\n \t\t\t\t\t  location_t location)\n {\n   qualified_typedef_usage_t *iter;\n-  int i;\n+  unsigned i;\n \n   gcc_assert (type_decl && (TREE_CODE (type_decl) == TYPE_DECL));\n \n   /* Make sure we don't append the type to the template twice.  */\n-  FOR_EACH_VEC_ELT (qualified_typedef_usage_t,\n-\t\t    get_types_needing_access_check (templ),\n-\t\t    i, iter)\n+  FOR_EACH_VEC_SAFE_ELT (get_types_needing_access_check (templ), i, iter)\n     if (iter->typedef_decl == type_decl && scope == iter->context)\n       return;\n "}, {"sha": "06e26937fbd9061b979008057c3192ebfa00f14a", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -43,7 +43,7 @@ static FILE *open_repo_file (const char *);\n static char *afgets (FILE *);\n static FILE *reopen_repo_file_for_write (void);\n \n-static GTY(()) VEC(tree,gc) *pending_repo;\n+static GTY(()) vec<tree, va_gc> *pending_repo;\n static char *repo_name;\n \n static const char *old_args, *old_dir, *old_main;\n@@ -268,7 +268,7 @@ finish_repo (void)\n       fprintf (repo_file, \"\\n\");\n     }\n \n-  FOR_EACH_VEC_ELT_REVERSE (tree, pending_repo, ix, val)\n+  FOR_EACH_VEC_SAFE_ELT_REVERSE (pending_repo, ix, val)\n     {\n       tree name = DECL_ASSEMBLER_NAME (val);\n       char type = IDENTIFIER_REPO_CHOSEN (name) ? 'C' : 'O';\n@@ -353,7 +353,7 @@ repo_emit_p (tree decl)\n   if (!DECL_REPO_AVAILABLE_P (decl))\n     {\n       DECL_REPO_AVAILABLE_P (decl) = 1;\n-      VEC_safe_push (tree, gc, pending_repo, decl);\n+      vec_safe_push (pending_repo, decl);\n     }\n \n   return IDENTIFIER_REPO_CHOSEN (DECL_ASSEMBLER_NAME (decl)) ? 1 : ret;"}, {"sha": "b13ec171bbb230161afce90fe5c6d47440742c2b", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -72,8 +72,6 @@ typedef struct GTY (()) tinfo_s {\n \t\t the type_info derived type.  */\n } tinfo_s;\n \n-DEF_VEC_O(tinfo_s);\n-DEF_VEC_ALLOC_O(tinfo_s,gc);\n \n typedef enum tinfo_kind\n {\n@@ -92,12 +90,12 @@ typedef enum tinfo_kind\n } tinfo_kind;\n \n /* A vector of all tinfo decls that haven't yet been emitted.  */\n-VEC(tree,gc) *unemitted_tinfo_decls;\n+vec<tree, va_gc> *unemitted_tinfo_decls;\n \n /* A vector of all type_info derived types we need.  The first few are\n    fixed and created early. The remainder are for multiple inheritance\n    and are generated as needed. */\n-static GTY (()) VEC(tinfo_s,gc) *tinfo_descs;\n+static GTY (()) vec<tinfo_s, va_gc> *tinfo_descs;\n \n static tree ifnonnull (tree, tree, tsubst_flags_t);\n static tree tinfo_name (tree, bool);\n@@ -155,7 +153,7 @@ init_rtti_processing (void)\n     = cp_build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n   type_info_ptr_type = build_pointer_type (const_type_info_type_node);\n \n-  unemitted_tinfo_decls = VEC_alloc (tree, gc, 124);\n+  vec_alloc (unemitted_tinfo_decls, 124);\n \n   create_tinfo_types ();\n }\n@@ -294,8 +292,7 @@ typeid_ok_p (void)\n       return false;\n     }\n \n-  pseudo_type_info\n-    = VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE).type;\n+  pseudo_type_info = (*tinfo_descs)[TK_TYPE_INFO_TYPE].type;\n   type_info_type = TYPE_MAIN_VARIANT (const_type_info_type_node);\n \n   /* Make sure abi::__type_info_pseudo has the same alias set\n@@ -422,7 +419,7 @@ get_tinfo_decl (tree type)\n   if (!d)\n     {\n       int ix = get_pseudo_ti_index (type);\n-      tinfo_s *ti = &VEC_index (tinfo_s, tinfo_descs, ix);\n+      tinfo_s *ti = &(*tinfo_descs)[ix];\n \n       d = build_lang_decl (VAR_DECL, name, ti->type);\n       SET_DECL_ASSEMBLER_NAME (d, name);\n@@ -444,7 +441,7 @@ get_tinfo_decl (tree type)\n \tCLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (type)) = d;\n \n       /* Add decl to the global array of tinfo decls.  */\n-      VEC_safe_push (tree, gc, unemitted_tinfo_decls, d);\n+      vec_safe_push (unemitted_tinfo_decls, d);\n     }\n \n   return d;\n@@ -873,7 +870,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n   tree init;\n   tree name_decl;\n   tree vtable_ptr;\n-  VEC(constructor_elt,gc) *v;\n+  vec<constructor_elt, va_gc> *v;\n \n   {\n     tree name_name, name_string;\n@@ -935,7 +932,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n       ti->vtable = vtable_ptr;\n     }\n \n-  v = VEC_alloc (constructor_elt, gc, 2);\n+  vec_alloc (v, 2);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, vtable_ptr);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  decay_conversion (name_decl, tf_warning_or_error));\n@@ -973,7 +970,8 @@ ptr_initializer (tinfo_s *ti, tree target)\n   tree to = TREE_TYPE (target);\n   int flags = qualifier_flags (to);\n   bool incomplete = target_incomplete_p (to);\n-  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 3);\n+  vec<constructor_elt, va_gc> *v;\n+  vec_alloc (v, 3);\n \n   if (incomplete)\n     flags |= 8;\n@@ -1001,7 +999,8 @@ ptm_initializer (tinfo_s *ti, tree target)\n   tree klass = TYPE_PTRMEM_CLASS_TYPE (target);\n   int flags = qualifier_flags (to);\n   bool incomplete = target_incomplete_p (to);\n-  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);\n+  vec<constructor_elt, va_gc> *v;\n+  vec_alloc (v, 4);\n \n   if (incomplete)\n     flags |= 0x8;\n@@ -1029,7 +1028,8 @@ class_initializer (tinfo_s *ti, tree target, unsigned n, ...)\n   tree init = tinfo_base_init (ti, target);\n   va_list extra_inits;\n   unsigned i;\n-  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, n+1);\n+  vec<constructor_elt, va_gc> *v;\n+  vec_alloc (v, n+1);\n \n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n   va_start (extra_inits, n);\n@@ -1079,7 +1079,7 @@ typeinfo_in_lib_p (tree type)\n static tree\n get_pseudo_ti_init (tree type, unsigned tk_index)\n {\n-  tinfo_s *ti = &VEC_index (tinfo_s, tinfo_descs, tk_index);\n+  tinfo_s *ti = &(*tinfo_descs)[tk_index];\n \n   gcc_assert (at_eof);\n   switch (tk_index)\n@@ -1105,7 +1105,7 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \ttree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \n \t/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */\n-\tti = &VEC_index (tinfo_s, tinfo_descs, tk_index);\n+\tti = &(*tinfo_descs)[tk_index];\n \treturn class_initializer (ti, type, 1, tinfo);\n       }\n \n@@ -1115,16 +1115,16 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t\t    | (CLASSTYPE_DIAMOND_SHAPED_P (type) << 1));\n \ttree binfo = TYPE_BINFO (type);\n \tint nbases = BINFO_N_BASE_BINFOS (binfo);\n-\tVEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n+\tvec<tree, va_gc> *base_accesses = BINFO_BASE_ACCESSES (binfo);\n \ttree offset_type = integer_types[itk_long];\n \ttree base_inits = NULL_TREE;\n \tint ix;\n-\tVEC(constructor_elt,gc) *init_vec = NULL;\n+\tvec<constructor_elt, va_gc> *init_vec = NULL;\n \tconstructor_elt *e;\n \n \tgcc_assert (tk_index >= TK_FIXED);\n \n-\tVEC_safe_grow (constructor_elt, gc, init_vec, nbases);\n+\tvec_safe_grow (init_vec, nbases);\n \t/* Generate the base information initializer.  */\n \tfor (ix = nbases; ix--;)\n \t  {\n@@ -1133,9 +1133,9 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t    int flags = 0;\n \t    tree tinfo;\n \t    tree offset;\n-\t    VEC(constructor_elt,gc) *v;\n+\t    vec<constructor_elt, va_gc> *v;\n \n-\t    if (VEC_index (tree, base_accesses, ix) == access_public_node)\n+\t    if ((*base_accesses)[ix] == access_public_node)\n \t      flags |= 2;\n \t    tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t    if (BINFO_VIRTUAL_P (base_binfo))\n@@ -1156,18 +1156,18 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t    offset = fold_build2_loc (input_location,\n \t\t\t\t  BIT_IOR_EXPR, offset_type, offset,\n \t\t\t\t  build_int_cst (offset_type, flags));\n-\t    v = VEC_alloc (constructor_elt, gc, 2);\n+\t    vec_alloc (v, 2);\n \t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, tinfo);\n \t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, offset);\n \t    base_init = build_constructor (init_list_type_node, v);\n-\t    e = &VEC_index (constructor_elt, init_vec, ix);\n+\t    e = &(*init_vec)[ix];\n \t    e->index = NULL_TREE;\n \t    e->value = base_init;\n \t  }\n \tbase_inits = build_constructor (init_list_type_node, init_vec);\n \n \t/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */\n-\tti = &VEC_index (tinfo_s, tinfo_descs, tk_index);\n+\tti = &(*tinfo_descs)[tk_index];\n \treturn class_initializer (ti, type, 3,\n \t\t\t\t  build_int_cst (NULL_TREE, hint),\n \t\t\t\t  build_int_cst (NULL_TREE, nbases),\n@@ -1213,8 +1213,7 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n   /* First field is the pseudo type_info base class.  */\n   fields = build_decl (input_location,\n \t\t       FIELD_DECL, NULL_TREE,\n-\t\t       VEC_index (tinfo_s, tinfo_descs,\n-\t\t\t\t  TK_TYPE_INFO_TYPE).type);\n+\t\t       (*tinfo_descs)[TK_TYPE_INFO_TYPE].type);\n \n   /* Now add the derived fields.  */\n   while ((field_decl = va_arg (ap, tree)))\n@@ -1228,7 +1227,7 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n   finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n   CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n \n-  ti = &VEC_index (tinfo_s, tinfo_descs, tk);\n+  ti = &(*tinfo_descs)[tk];\n   ti->type = cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n   ti->name = get_identifier (real_name);\n   ti->vtable = NULL_TREE;\n@@ -1293,12 +1292,12 @@ get_pseudo_ti_index (tree type)\n       else\n \t{\n \t  tree binfo = TYPE_BINFO (type);\n-\t  VEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n+\t  vec<tree, va_gc> *base_accesses = BINFO_BASE_ACCESSES (binfo);\n \t  tree base_binfo = BINFO_BASE_BINFO (binfo, 0);\n \t  int num_bases = BINFO_N_BASE_BINFOS (binfo);\n \n \t  if (num_bases == 1\n-\t      && VEC_index (tree, base_accesses, 0) == access_public_node\n+\t      && (*base_accesses)[0] == access_public_node\n \t      && !BINFO_VIRTUAL_P (base_binfo)\n \t      && integer_zerop (BINFO_OFFSET (base_binfo)))\n \t    {\n@@ -1312,16 +1311,16 @@ get_pseudo_ti_index (tree type)\n \t      tree array_domain, base_array;\n \n \t      ix = TK_FIXED + num_bases;\n-\t      if (VEC_length (tinfo_s, tinfo_descs) <= ix)\n+\t      if (vec_safe_length (tinfo_descs) <= ix)\n \t\t{\n \t\t  /* too short, extend.  */\n-\t\t  unsigned len = VEC_length (tinfo_s, tinfo_descs);\n+\t\t  unsigned len = vec_safe_length (tinfo_descs);\n \n-\t\t  VEC_safe_grow (tinfo_s, gc, tinfo_descs, ix + 1);\n-\t\t  while (VEC_iterate (tinfo_s, tinfo_descs, len++, ti))\n+\t\t  vec_safe_grow (tinfo_descs, ix + 1);\n+\t\t  while (tinfo_descs->iterate (len++, &ti))\n \t\t    ti->type = ti->vtable = ti->name = NULL_TREE;\n \t\t}\n-\t      else if (VEC_index (tinfo_s, tinfo_descs, ix).type)\n+\t      else if ((*tinfo_descs)[ix].type)\n \t\t/* already created.  */\n \t\tbreak;\n \n@@ -1333,10 +1332,8 @@ get_pseudo_ti_index (tree type)\n \t\tarray_domain = build_index_type (size_int (num_bases - 1));\n \t      else\n \t\tarray_domain = build_index_type (size_int (num_bases));\n-\t      base_array =\n-\t\tbuild_array_type (VEC_index (tinfo_s, tinfo_descs,\n-\t\t\t\t\t     TK_BASE_TYPE).type,\n-\t\t\t\t  array_domain);\n+\t      base_array = build_array_type ((*tinfo_descs)[TK_BASE_TYPE].type,\n+\t\t\t\t\t     array_domain);\n \n \t      push_abi_namespace ();\n \t      create_pseudo_type_info\n@@ -1369,7 +1366,7 @@ create_tinfo_types (void)\n \n   gcc_assert (!tinfo_descs);\n \n-  VEC_safe_grow (tinfo_s, gc, tinfo_descs, TK_FIXED);\n+  vec_safe_grow (tinfo_descs, TK_FIXED);\n \n   push_abi_namespace ();\n \n@@ -1387,7 +1384,7 @@ create_tinfo_types (void)\n     DECL_CHAIN (field) = fields;\n     fields = field;\n \n-    ti = &VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE);\n+    ti = &(*tinfo_descs)[TK_TYPE_INFO_TYPE];\n     ti->type = make_class_type (RECORD_TYPE);\n     ti->vtable = NULL_TREE;\n     ti->name = NULL_TREE;\n@@ -1427,7 +1424,7 @@ create_tinfo_types (void)\n     DECL_CHAIN (field) = fields;\n     fields = field;\n \n-    ti = &VEC_index (tinfo_s, tinfo_descs, TK_BASE_TYPE);\n+    ti = &(*tinfo_descs)[TK_BASE_TYPE];\n \n     ti->type = make_class_type (RECORD_TYPE);\n     ti->vtable = NULL_TREE;"}, {"sha": "92234a52be5974fb18b10757b851b1ea9ceca75c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -639,14 +639,14 @@ dfs_access_in_type (tree binfo, void *data)\n \t{\n \t  int i;\n \t  tree base_binfo;\n-\t  VEC(tree,gc) *accesses;\n+\t  vec<tree, va_gc> *accesses;\n \n \t  /* Otherwise, scan our baseclasses, and pick the most favorable\n \t     access.  */\n \t  accesses = BINFO_BASE_ACCESSES (binfo);\n \t  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t    {\n-\t      tree base_access = VEC_index (tree, accesses, i);\n+\t      tree base_access = (*accesses)[i];\n \t      access_kind base_access_now = BINFO_ACCESS (base_binfo);\n \n \t      if (base_access_now == ak_none || base_access_now == ak_private)\n@@ -1316,10 +1316,10 @@ lookup_conversion_operator (tree class_type, tree type)\n     {\n       int i;\n       tree fn;\n-      VEC(tree,gc) *methods = CLASSTYPE_METHOD_VEC (class_type);\n+      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_type);\n \n       for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   VEC_iterate (tree, methods, i, fn); ++i)\n+\t   vec_safe_iterate (methods, i, &fn); ++i)\n \t{\n \t  /* All the conversion operators come near the beginning of\n \t     the class.  Therefore, if FN is not a conversion\n@@ -1348,7 +1348,7 @@ lookup_conversion_operator (tree class_type, tree type)\n static int\n lookup_fnfields_idx_nolazy (tree type, tree name)\n {\n-  VEC(tree,gc) *method_vec;\n+  vec<tree, va_gc> *method_vec;\n   tree fn;\n   tree tmp;\n   size_t i;\n@@ -1380,7 +1380,7 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n \n   /* Skip the conversion operators.  */\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       VEC_iterate (tree, method_vec, i, fn);\n+       vec_safe_iterate (method_vec, i, &fn);\n        ++i)\n     if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n       break;\n@@ -1392,15 +1392,15 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n       int hi;\n \n       lo = i;\n-      hi = VEC_length (tree, method_vec);\n+      hi = method_vec->length ();\n       while (lo < hi)\n \t{\n \t  i = (lo + hi) / 2;\n \n \t  if (GATHER_STATISTICS)\n \t    n_outer_fields_searched++;\n \n-\t  tmp = VEC_index (tree, method_vec, i);\n+\t  tmp = (*method_vec)[i];\n \t  tmp = DECL_NAME (OVL_CURRENT (tmp));\n \t  if (tmp > name)\n \t    hi = i;\n@@ -1411,7 +1411,7 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n \t}\n     }\n   else\n-    for (; VEC_iterate (tree, method_vec, i, fn); ++i)\n+    for (; vec_safe_iterate (method_vec, i, &fn); ++i)\n       {\n \tif (GATHER_STATISTICS)\n \t  n_outer_fields_searched++;\n@@ -1471,7 +1471,7 @@ lookup_fnfields_slot (tree type, tree name)\n   int ix = lookup_fnfields_1 (complete_type (type), name);\n   if (ix < 0)\n     return NULL_TREE;\n-  return VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n+  return (*CLASSTYPE_METHOD_VEC (type))[ix];\n }\n \n /* As above, but avoid lazily declaring functions.  */\n@@ -1482,7 +1482,7 @@ lookup_fnfields_slot_nolazy (tree type, tree name)\n   int ix = lookup_fnfields_idx_nolazy (complete_type (type), name);\n   if (ix < 0)\n     return NULL_TREE;\n-  return VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n+  return (*CLASSTYPE_METHOD_VEC (type))[ix];\n }\n \n /* Like lookup_fnfields_1, except that the name is extracted from\n@@ -1701,12 +1701,12 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n \t  /* We are at the top of the hierarchy, and can use the\n \t     CLASSTYPE_VBASECLASSES list for unmarking the virtual\n \t     bases.  */\n-\t  VEC(tree,gc) *vbases;\n+\t  vec<tree, va_gc> *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n \n \t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n-\t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n+\t       vec_safe_iterate (vbases, ix, &base_binfo); ix++)\n \t    BINFO_MARKED (base_binfo) = 0;\n \t}\n       else\n@@ -1809,12 +1809,12 @@ dfs_walk_once_accessible (tree binfo, bool friends_p,\n \t  /* We are at the top of the hierarchy, and can use the\n \t     CLASSTYPE_VBASECLASSES list for unmarking the virtual\n \t     bases.  */\n-\t  VEC(tree,gc) *vbases;\n+\t  vec<tree, va_gc> *vbases;\n \t  unsigned ix;\n \t  tree base_binfo;\n \n \t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n-\t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n+\t       vec_safe_iterate (vbases, ix, &base_binfo); ix++)\n \t    BINFO_MARKED (base_binfo) = 0;\n \t}\n       else\n@@ -2019,7 +2019,7 @@ look_for_overrides_here (tree type, tree fndecl)\n     ix = lookup_fnfields_1 (type, DECL_NAME (fndecl));\n   if (ix >= 0)\n     {\n-      tree fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n+      tree fns = (*CLASSTYPE_METHOD_VEC (type))[ix];\n \n       for (; fns; fns = OVL_NEXT (fns))\n \t{\n@@ -2090,8 +2090,7 @@ dfs_get_pure_virtuals (tree binfo, void *data)\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n \tif (DECL_PURE_VIRTUAL_P (BV_FN (virtuals)))\n-\t  VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (type),\n-\t\t\t BV_FN (virtuals));\n+\t  vec_safe_push (CLASSTYPE_PURE_VIRTUALS (type), BV_FN (virtuals));\n     }\n \n   return NULL_TREE;\n@@ -2364,7 +2363,7 @@ lookup_conversions_r (tree binfo,\n   tree child_tpl_convs = NULL_TREE;\n   unsigned i;\n   tree base_binfo;\n-  VEC(tree,gc) *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n   tree conv;\n \n   /* If we have no conversion operators, then don't look.  */\n@@ -2380,7 +2379,7 @@ lookup_conversions_r (tree binfo,\n \n   /* First, locate the unhidden ones at this level.  */\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       VEC_iterate (tree, method_vec, i, conv);\n+       vec_safe_iterate (method_vec, i, &conv);\n        ++i)\n     {\n       tree cur = OVL_CURRENT (conv);\n@@ -2622,10 +2621,10 @@ binfo_for_vbase (tree base, tree t)\n {\n   unsigned ix;\n   tree binfo;\n-  VEC(tree,gc) *vbases;\n+  vec<tree, va_gc> *vbases;\n \n   for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n-       VEC_iterate (tree, vbases, ix, binfo); ix++)\n+       vec_safe_iterate (vbases, ix, &binfo); ix++)\n     if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), base))\n       return binfo;\n   return NULL;"}, {"sha": "bbafa3aa3595259c2f74a58d38ce7ac5abf48768", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 108, "deletions": 118, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -92,22 +92,22 @@ static tree capture_decltype (tree);\n \n    2. When a declaration such as a type, or a variable, is encountered,\n       the function `perform_or_defer_access_check' is called.  It\n-      maintains a VEC of all deferred checks.\n+      maintains a vector of all deferred checks.\n \n    3. The global `current_class_type' or `current_function_decl' is then\n       setup by the parser.  `enforce_access' relies on these information\n       to check access.\n \n    4. Upon exiting the context mentioned in step 1,\n       `perform_deferred_access_checks' is called to check all declaration\n-      stored in the VEC. `pop_deferring_access_checks' is then\n+      stored in the vector. `pop_deferring_access_checks' is then\n       called to restore the previous access checking mode.\n \n       In case of parsing error, we simply call `pop_deferring_access_checks'\n       without `perform_deferred_access_checks'.  */\n \n typedef struct GTY(()) deferred_access {\n-  /* A VEC representing name-lookups for which we have deferred\n+  /* A vector representing name-lookups for which we have deferred\n      checking access controls.  We cannot check the accessibility of\n      names used in a decl-specifier-seq until we know what is being\n      declared because code like:\n@@ -120,17 +120,15 @@ typedef struct GTY(()) deferred_access {\n        A::B* A::f() { return 0; }\n \n      is valid, even though `A::B' is not generally accessible.  */\n-  VEC (deferred_access_check,gc)* GTY(()) deferred_access_checks;\n+  vec<deferred_access_check, va_gc> * GTY(()) deferred_access_checks;\n \n   /* The current mode of access checks.  */\n   enum deferring_kind deferring_access_checks_kind;\n \n } deferred_access;\n-DEF_VEC_O (deferred_access);\n-DEF_VEC_ALLOC_O (deferred_access,gc);\n \n /* Data for deferred access checking.  */\n-static GTY(()) VEC(deferred_access,gc) *deferred_access_stack;\n+static GTY(()) vec<deferred_access, va_gc> *deferred_access_stack;\n static GTY(()) unsigned deferred_access_no_check;\n \n /* Save the current deferred access states and start deferred\n@@ -146,7 +144,7 @@ push_deferring_access_checks (deferring_kind deferring)\n   else\n     {\n       deferred_access e = {NULL, deferring};\n-      VEC_safe_push (deferred_access, gc, deferred_access_stack, e);\n+      vec_safe_push (deferred_access_stack, e);\n     }\n }\n \n@@ -157,8 +155,7 @@ void\n resume_deferring_access_checks (void)\n {\n   if (!deferred_access_no_check)\n-    VEC_last (deferred_access, deferred_access_stack)\n-      .deferring_access_checks_kind = dk_deferred;\n+    deferred_access_stack->last().deferring_access_checks_kind = dk_deferred;\n }\n \n /* Stop deferring access checks.  */\n@@ -167,8 +164,7 @@ void\n stop_deferring_access_checks (void)\n {\n   if (!deferred_access_no_check)\n-    VEC_last (deferred_access, deferred_access_stack)\n-      .deferring_access_checks_kind = dk_no_deferred;\n+    deferred_access_stack->last().deferring_access_checks_kind = dk_no_deferred;\n }\n \n /* Discard the current deferred access checks and restore the\n@@ -180,22 +176,21 @@ pop_deferring_access_checks (void)\n   if (deferred_access_no_check)\n     deferred_access_no_check--;\n   else\n-    VEC_pop (deferred_access, deferred_access_stack);\n+    deferred_access_stack->pop ();\n }\n \n /* Returns a TREE_LIST representing the deferred checks.\n    The TREE_PURPOSE of each node is the type through which the\n    access occurred; the TREE_VALUE is the declaration named.\n    */\n \n-VEC (deferred_access_check,gc)*\n+vec<deferred_access_check, va_gc> *\n get_deferred_access_checks (void)\n {\n   if (deferred_access_no_check)\n     return NULL;\n   else\n-    return (VEC_last (deferred_access, deferred_access_stack)\n-\t    .deferred_access_checks);\n+    return (deferred_access_stack->last().deferred_access_checks);\n }\n \n /* Take current deferred checks and combine with the\n@@ -209,14 +204,13 @@ pop_to_parent_deferring_access_checks (void)\n     deferred_access_no_check--;\n   else\n     {\n-      VEC (deferred_access_check,gc) *checks;\n+      vec<deferred_access_check, va_gc> *checks;\n       deferred_access *ptr;\n \n-      checks = (VEC_last (deferred_access, deferred_access_stack)\n-\t\t.deferred_access_checks);\n+      checks = (deferred_access_stack->last ().deferred_access_checks);\n \n-      VEC_pop (deferred_access, deferred_access_stack);\n-      ptr = &VEC_last (deferred_access, deferred_access_stack);\n+      deferred_access_stack->pop ();\n+      ptr = &deferred_access_stack->last ();\n       if (ptr->deferring_access_checks_kind == dk_no_deferred)\n \t{\n \t  /* Check access.  */\n@@ -228,19 +222,17 @@ pop_to_parent_deferring_access_checks (void)\n \t  int i, j;\n \t  deferred_access_check *chk, *probe;\n \n-\t  FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n+\t  FOR_EACH_VEC_SAFE_ELT (checks, i, chk)\n \t    {\n-\t      FOR_EACH_VEC_ELT (deferred_access_check,\n-\t\t\t\tptr->deferred_access_checks, j, probe)\n+\t      FOR_EACH_VEC_SAFE_ELT (ptr->deferred_access_checks, j, probe)\n \t\t{\n \t\t  if (probe->binfo == chk->binfo &&\n \t\t      probe->decl == chk->decl &&\n \t\t      probe->diag_decl == chk->diag_decl)\n \t\t    goto found;\n \t\t}\n \t      /* Insert into parent's checks.  */\n-\t      VEC_safe_push (deferred_access_check, gc,\n-\t\t\t     ptr->deferred_access_checks, *chk);\n+\t      vec_safe_push (ptr->deferred_access_checks, *chk);\n \t    found:;\n \t    }\n \t}\n@@ -254,7 +246,7 @@ pop_to_parent_deferring_access_checks (void)\n    otherwise FALSE.  */\n \n bool\n-perform_access_checks (VEC (deferred_access_check,gc)* checks,\n+perform_access_checks (vec<deferred_access_check, va_gc> *checks,\n \t\t       tsubst_flags_t complain)\n {\n   int i;\n@@ -265,7 +257,7 @@ perform_access_checks (VEC (deferred_access_check,gc)* checks,\n   if (!checks)\n     return true;\n \n-  FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n+  FOR_EACH_VEC_SAFE_ELT (checks, i, chk)\n     {\n       input_location = chk->loc;\n       ok &= enforce_access (chk->binfo, chk->decl, chk->diag_decl, complain);\n@@ -317,7 +309,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n \n   gcc_assert (TREE_CODE (binfo) == TREE_BINFO);\n \n-  ptr = &VEC_last (deferred_access, deferred_access_stack);\n+  ptr = &deferred_access_stack->last ();\n \n   /* If we are not supposed to defer access checks, just check now.  */\n   if (ptr->deferring_access_checks_kind == dk_no_deferred)\n@@ -327,8 +319,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n     }\n \n   /* See if we are already going to perform this check.  */\n-  FOR_EACH_VEC_ELT  (deferred_access_check,\n-\t\t     ptr->deferred_access_checks, i, chk)\n+  FOR_EACH_VEC_SAFE_ELT (ptr->deferred_access_checks, i, chk)\n     {\n       if (chk->decl == decl && chk->binfo == binfo &&\n \t  chk->diag_decl == diag_decl)\n@@ -338,8 +329,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n     }\n   /* If not, record the check.  */\n   deferred_access_check new_access = {binfo, decl, diag_decl, input_location};\n-  VEC_safe_push (deferred_access_check, gc, ptr->deferred_access_checks,\n-\t\t new_access);\n+  vec_safe_push (ptr->deferred_access_checks, new_access);\n \n   return true;\n }\n@@ -375,7 +365,7 @@ add_stmt (tree t)\n \n   /* Add T to the statement-tree.  Non-side-effect statements need to be\n      recorded during statement expressions.  */\n-  gcc_checking_assert (!VEC_empty (tree, stmt_list_stack));\n+  gcc_checking_assert (!stmt_list_stack->is_empty ());\n   append_to_statement_list_force (t, &cur_stmt_list);\n \n   return t;\n@@ -1972,7 +1962,7 @@ empty_expr_stmt_p (tree expr_stmt)\n    Returns the functions to be considered by overload resolution.  */\n \n tree\n-perform_koenig_lookup (tree fn, VEC(tree,gc) *args, bool include_std,\n+perform_koenig_lookup (tree fn, vec<tree, va_gc> *args, bool include_std,\n \t\t       tsubst_flags_t complain)\n {\n   tree identifier = NULL_TREE;\n@@ -2038,12 +2028,12 @@ perform_koenig_lookup (tree fn, VEC(tree,gc) *args, bool include_std,\n    Returns code for the call.  */\n \n tree\n-finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n+finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t\t  bool koenig_p, tsubst_flags_t complain)\n {\n   tree result;\n   tree orig_fn;\n-  VEC(tree,gc) *orig_args = NULL;\n+  vec<tree, va_gc> *orig_args = NULL;\n \n   if (fn == error_mark_node)\n     return error_mark_node;\n@@ -2172,7 +2162,7 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n       if (!result)\n \t{\n \t  if (warn_sizeof_pointer_memaccess\n-\t      && !VEC_empty(tree, *args)\n+\t      && !vec_safe_is_empty (*args)\n \t      && !processing_template_decl)\n \t    {\n \t      location_t sizeof_arg_loc[3];\n@@ -2184,9 +2174,9 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n \n \t\t  sizeof_arg_loc[i] = UNKNOWN_LOCATION;\n \t\t  sizeof_arg[i] = NULL_TREE;\n-\t\t  if (i >= VEC_length (tree, *args))\n+\t\t  if (i >= (*args)->length ())\n \t\t    continue;\n-\t\t  t = VEC_index (tree, *args, i);\n+\t\t  t = (**args)[i];\n \t\t  if (TREE_CODE (t) != SIZEOF_EXPR)\n \t\t    continue;\n \t\t  if (SIZEOF_EXPR_TYPE_P (t))\n@@ -2206,7 +2196,7 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n     }\n   else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)\n     {\n-      if (!VEC_empty (tree, *args))\n+      if (!vec_safe_is_empty (*args))\n \terror (\"arguments to destructor are not allowed\");\n       /* Mark the pseudo-destructor call as having side-effects so\n \t that we do not issue warnings about its use.  */\n@@ -3448,9 +3438,9 @@ finish_underlying_type (tree type)\n tree\n calculate_direct_bases (tree type)\n {\n-  VEC(tree, gc) *vector = make_tree_vector();\n+  vec<tree, va_gc> *vector = make_tree_vector();\n   tree bases_vec = NULL_TREE;\n-  VEC(tree, none) *base_binfos;\n+  vec<tree, va_gc> *base_binfos;\n   tree binfo;\n   unsigned i;\n \n@@ -3462,29 +3452,29 @@ calculate_direct_bases (tree type)\n   base_binfos = BINFO_BASE_BINFOS (TYPE_BINFO (type));\n \n   /* Virtual bases are initialized first */\n-  for (i = 0; VEC_iterate (tree, base_binfos, i, binfo); i++)\n+  for (i = 0; base_binfos->iterate (i, &binfo); i++)\n     {\n       if (BINFO_VIRTUAL_P (binfo))\n        {\n-         VEC_safe_push (tree, gc, vector, binfo);\n+         vec_safe_push (vector, binfo);\n        }\n     }\n \n   /* Now non-virtuals */\n-  for (i = 0; VEC_iterate (tree, base_binfos, i, binfo); i++)\n+  for (i = 0; base_binfos->iterate (i, &binfo); i++)\n     {\n       if (!BINFO_VIRTUAL_P (binfo))\n        {\n-         VEC_safe_push (tree, gc, vector, binfo);\n+         vec_safe_push (vector, binfo);\n        }\n     }\n \n \n-  bases_vec = make_tree_vec (VEC_length (tree, vector));\n+  bases_vec = make_tree_vec (vector->length ());\n \n-  for (i = 0; i < VEC_length (tree, vector); ++i)\n+  for (i = 0; i < vector->length (); ++i)\n     {\n-      TREE_VEC_ELT (bases_vec, i) = BINFO_TYPE (VEC_index (tree, vector, i));\n+      TREE_VEC_ELT (bases_vec, i) = BINFO_TYPE ((*vector)[i]);\n     }\n   return bases_vec;\n }\n@@ -3505,19 +3495,19 @@ dfs_calculate_bases_pre (tree binfo, void * /*data_*/)\n static tree\n dfs_calculate_bases_post (tree binfo, void *data_)\n {\n-  VEC(tree, gc) **data = (VEC(tree, gc) **) data_;\n+  vec<tree, va_gc> **data = ((vec<tree, va_gc> **) data_);\n   if (!BINFO_VIRTUAL_P (binfo))\n     {\n-      VEC_safe_push (tree, gc, *data, BINFO_TYPE (binfo));\n+      vec_safe_push (*data, BINFO_TYPE (binfo));\n     }\n   return NULL_TREE;\n }\n \n /* Calculates the morally non-virtual base classes of a class */\n-static VEC(tree, gc) *\n+static vec<tree, va_gc> *\n calculate_bases_helper (tree type)\n {\n-  VEC(tree, gc) *vector = make_tree_vector();\n+  vec<tree, va_gc> *vector = make_tree_vector();\n \n   /* Now add non-virtual base classes in order of construction */\n   dfs_walk_all (TYPE_BINFO (type),\n@@ -3528,11 +3518,11 @@ calculate_bases_helper (tree type)\n tree\n calculate_bases (tree type)\n {\n-  VEC(tree, gc) *vector = make_tree_vector();\n+  vec<tree, va_gc> *vector = make_tree_vector();\n   tree bases_vec = NULL_TREE;\n   unsigned i;\n-  VEC(tree, gc) *vbases;\n-  VEC(tree, gc) *nonvbases;\n+  vec<tree, va_gc> *vbases;\n+  vec<tree, va_gc> *nonvbases;\n   tree binfo;\n \n   complete_type (type);\n@@ -3542,24 +3532,25 @@ calculate_bases (tree type)\n \n   /* First go through virtual base classes */\n   for (vbases = CLASSTYPE_VBASECLASSES (type), i = 0;\n-       VEC_iterate (tree, vbases, i, binfo); i++)\n+       vec_safe_iterate (vbases, i, &binfo); i++)\n     {\n-      VEC(tree, gc) *vbase_bases = calculate_bases_helper (BINFO_TYPE (binfo));\n-      VEC_safe_splice (tree, gc, vector, vbase_bases);\n+      vec<tree, va_gc> *vbase_bases;\n+      vbase_bases = calculate_bases_helper (BINFO_TYPE (binfo));\n+      vec_safe_splice (vector, vbase_bases);\n       release_tree_vector (vbase_bases);\n     }\n \n   /* Now for the non-virtual bases */\n   nonvbases = calculate_bases_helper (type);\n-  VEC_safe_splice (tree, gc, vector, nonvbases);\n+  vec_safe_splice (vector, nonvbases);\n   release_tree_vector (nonvbases);\n \n   /* Last element is entire class, so don't copy */\n-  bases_vec = make_tree_vec (VEC_length (tree, vector) - 1);\n+  bases_vec = make_tree_vec (vector->length () - 1);\n \n-  for (i = 0; i < VEC_length (tree, vector) - 1; ++i)\n+  for (i = 0; i < vector->length () - 1; ++i)\n     {\n-      TREE_VEC_ELT (bases_vec, i) = VEC_index (tree, vector, i);\n+      TREE_VEC_ELT (bases_vec, i) = (*vector)[i];\n     }\n   release_tree_vector (vector);\n   return bases_vec;\n@@ -5010,7 +5001,7 @@ void\n finish_omp_barrier (void)\n {\n   tree fn = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);\n-  VEC(tree,gc) *vec = make_tree_vector ();\n+  vec<tree, va_gc> *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n@@ -5020,7 +5011,7 @@ void\n finish_omp_flush (void)\n {\n   tree fn = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n-  VEC(tree,gc) *vec = make_tree_vector ();\n+  vec<tree, va_gc> *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n@@ -5030,7 +5021,7 @@ void\n finish_omp_taskwait (void)\n {\n   tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);\n-  VEC(tree,gc) *vec = make_tree_vector ();\n+  vec<tree, va_gc> *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n@@ -5040,7 +5031,7 @@ void\n finish_omp_taskyield (void)\n {\n   tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);\n-  VEC(tree,gc) *vec = make_tree_vector ();\n+  vec<tree, va_gc> *vec = make_tree_vector ();\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n@@ -5380,7 +5371,7 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n       ix = lookup_fnfields_1 (type, ansi_assopname (NOP_EXPR));\n       if (ix < 0)\n \treturn false;\n-      fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n+      fns = (*CLASSTYPE_METHOD_VEC (type))[ix];\n     } \n   else if (TYPE_HAS_COPY_CTOR (type))\n     {\n@@ -5806,7 +5797,7 @@ is_valid_constexpr_fn (tree fun, bool complain)\n    to the existing initialization pair INITS.  */\n \n static bool\n-build_data_member_initialization (tree t, VEC(constructor_elt,gc) **vec)\n+build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n {\n   tree member, init;\n   if (TREE_CODE (t) == CLEANUP_POINT_EXPR)\n@@ -5933,35 +5924,35 @@ check_constexpr_ctor_body (tree last, tree list)\n   return ok;\n }\n \n-/* VEC is a vector of constructor elements built up for the base and member\n+/* V is a vector of constructor elements built up for the base and member\n    initializers of a constructor for TYPE.  They need to be in increasing\n    offset order, which they might not be yet if TYPE has a primary base\n    which is not first in the base-clause.  */\n \n-static VEC(constructor_elt,gc) *\n-sort_constexpr_mem_initializers (tree type, VEC(constructor_elt,gc) *vec)\n+static vec<constructor_elt, va_gc> *\n+sort_constexpr_mem_initializers (tree type, vec<constructor_elt, va_gc> *v)\n {\n   tree pri = CLASSTYPE_PRIMARY_BINFO (type);\n   constructor_elt elt;\n   int i;\n \n   if (pri == NULL_TREE\n       || pri == BINFO_BASE_BINFO (TYPE_BINFO (type), 0))\n-    return vec;\n+    return v;\n \n   /* Find the element for the primary base and move it to the beginning of\n      the vec.  */\n-  VEC(constructor_elt,gc) &v = *vec;\n+  vec<constructor_elt, va_gc> &vref = *v;\n   pri = BINFO_TYPE (pri);\n   for (i = 1; ; ++i)\n-    if (TREE_TYPE (v[i].index) == pri)\n+    if (TREE_TYPE (vref[i].index) == pri)\n       break;\n \n-  elt = v[i];\n+  elt = vref[i];\n   for (; i > 0; --i)\n-    v[i] = v[i-1];\n-  v[0] = elt;\n-  return vec;\n+    vref[i] = vref[i-1];\n+  vref[0] = elt;\n+  return v;\n }\n \n /* Build compile-time evalable representations of member-initializer list\n@@ -5970,7 +5961,7 @@ sort_constexpr_mem_initializers (tree type, VEC(constructor_elt,gc) *vec)\n static tree\n build_constexpr_constructor_member_initializers (tree type, tree body)\n {\n-  VEC(constructor_elt,gc) *vec = NULL;\n+  vec<constructor_elt, va_gc> *vec = NULL;\n   bool ok = true;\n   if (TREE_CODE (body) == MUST_NOT_THROW_EXPR\n       || TREE_CODE (body) == EH_SPEC_BLOCK)\n@@ -6015,14 +6006,14 @@ build_constexpr_constructor_member_initializers (tree type, tree body)\n     gcc_assert (errorcount > 0);\n   if (ok)\n     {\n-      if (VEC_length (constructor_elt, vec) > 0)\n+      if (vec_safe_length (vec) > 0)\n \t{\n \t  /* In a delegating constructor, return the target.  */\n-\t  constructor_elt *ce = &VEC_index (constructor_elt, vec, 0);\n+\t  constructor_elt *ce = &(*vec)[0];\n \t  if (ce->index == current_class_ptr)\n \t    {\n \t      body = ce->value;\n-\t      VEC_free (constructor_elt, gc, vec);\n+\t      vec_free (vec);\n \t      return body;\n \t    }\n \t}\n@@ -6519,7 +6510,7 @@ cxx_bind_parameters_in_call (const constexpr_call *old_call, tree t,\n    These do not need to be marked for PCH or GC.  */\n \n /* FIXME remember and print actual constant arguments.  */\n-static VEC(tree,heap) *call_stack = NULL;\n+static vec<tree> call_stack = vec<tree>();\n static int call_stack_tick;\n static int last_cx_error_tick;\n \n@@ -6529,8 +6520,8 @@ push_cx_call_context (tree call)\n   ++call_stack_tick;\n   if (!EXPR_HAS_LOCATION (call))\n     SET_EXPR_LOCATION (call, input_location);\n-  VEC_safe_push (tree, heap, call_stack, call);\n-  if (VEC_length (tree, call_stack) > (unsigned) max_constexpr_depth)\n+  call_stack.safe_push (call);\n+  if (call_stack.length () > (unsigned) max_constexpr_depth)\n     return false;\n   return true;\n }\n@@ -6539,15 +6530,15 @@ static void\n pop_cx_call_context (void)\n {\n   ++call_stack_tick;\n-  VEC_pop (tree, call_stack);\n+  call_stack.pop ();\n }\n \n-VEC(tree,heap) *\n+vec<tree> \n cx_error_context (void)\n {\n-  VEC(tree,heap) *r = NULL;\n+  vec<tree> r = vec<tree>();\n   if (call_stack_tick != last_cx_error_tick\n-      && !VEC_empty (tree, call_stack))\n+      && !call_stack.is_empty ())\n     r = call_stack;\n   last_cx_error_tick = call_stack_tick;\n   return r;\n@@ -6893,7 +6884,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n     }\n   i = tree_low_cst (index, 0);\n   if (TREE_CODE (ary) == CONSTRUCTOR)\n-    return VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ary), i).value;\n+    return (*CONSTRUCTOR_ELTS (ary))[i].value;\n   else if (elem_nchars == 1)\n     return build_int_cst (cv_unqualified (TREE_TYPE (TREE_TYPE (ary))),\n \t\t\t  TREE_STRING_POINTER (ary)[i]);\n@@ -7076,7 +7067,7 @@ cxx_eval_logical_expression (const constexpr_call *call, tree t,\n    initialization of the field.  */\n \n static constructor_elt *\n-base_field_constructor_elt (VEC(constructor_elt,gc) *v, tree ref)\n+base_field_constructor_elt (vec<constructor_elt, va_gc> *v, tree ref)\n {\n   tree aggr = TREE_OPERAND (ref, 0);\n   tree field = TREE_OPERAND (ref, 1);\n@@ -7092,7 +7083,7 @@ base_field_constructor_elt (VEC(constructor_elt,gc) *v, tree ref)\n       v = CONSTRUCTOR_ELTS (base_ce->value);\n     }\n \n-  for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n+  for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n     if (ce->index == field)\n       return ce;\n \n@@ -7109,14 +7100,14 @@ cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n \t\t\t bool allow_non_constant, bool addr,\n \t\t\t bool *non_constant_p)\n {\n-  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (t);\n-  VEC(constructor_elt,gc) *n = VEC_alloc (constructor_elt, gc,\n-\t\t\t\t\t  VEC_length (constructor_elt, v));\n+  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n+  vec<constructor_elt, va_gc> *n;\n+  vec_alloc (n, vec_safe_length (v));\n   constructor_elt *ce;\n   HOST_WIDE_INT i;\n   bool changed = false;\n   gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (t));\n-  for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n+  for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n     {\n       tree elt = cxx_eval_constant_expression (call, ce->value,\n \t\t\t\t\t       allow_non_constant, addr,\n@@ -7146,7 +7137,7 @@ cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n   if (*non_constant_p || !changed)\n     {\n     fail:\n-      VEC_free (constructor_elt, gc, n);\n+      vec_free (n);\n       return t;\n     }\n   t = build_constructor (TREE_TYPE (t), n);\n@@ -7173,7 +7164,8 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n {\n   tree elttype = TREE_TYPE (atype);\n   int max = tree_low_cst (array_type_nelts (atype), 0);\n-  VEC(constructor_elt,gc) *n = VEC_alloc (constructor_elt, gc, max + 1);\n+  vec<constructor_elt, va_gc> *n;\n+  vec_alloc (n, max + 1);\n   bool pre_init = false;\n   int i;\n \n@@ -7193,7 +7185,7 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n     }\n   else if (!init)\n     {\n-      VEC(tree,gc) *argvec = make_tree_vector ();\n+      vec<tree, va_gc> *argvec = make_tree_vector ();\n       init = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t\t&argvec, elttype, LOOKUP_NORMAL,\n \t\t\t\t\ttf_warning_or_error);\n@@ -7234,15 +7226,15 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n       else\n \t{\n \t  /* Copying an element.  */\n-\t  VEC(tree,gc) *argvec;\n+\t  vec<tree, va_gc> *argvec;\n \t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n \t\t      (atype, TREE_TYPE (init)));\n \t  eltinit = cp_build_array_ref (input_location, init, idx,\n \t\t\t\t\ttf_warning_or_error);\n \t  if (!real_lvalue_p (init))\n \t    eltinit = move (eltinit);\n \t  argvec = make_tree_vector ();\n-\t  VEC_quick_push (tree, argvec, eltinit);\n+\t  argvec->quick_push (eltinit);\n \t  eltinit = (build_special_member_call\n \t\t     (NULL_TREE, complete_ctor_identifier, &argvec,\n \t\t      elttype, LOOKUP_NORMAL, tf_warning_or_error));\n@@ -7263,7 +7255,7 @@ cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n     }\n \n  fail:\n-  VEC_free (constructor_elt, gc, n);\n+  vec_free (n);\n   return init;\n }\n \n@@ -8517,9 +8509,9 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \n     case CONSTRUCTOR:\n       {\n-        VEC(constructor_elt, gc) *v = CONSTRUCTOR_ELTS (t);\n+        vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n         constructor_elt *ce;\n-        for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n+        for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n \t  if (!potential_constant_expression_1 (ce->value, want_rval, flags))\n \t    return false;\n \treturn true;\n@@ -8747,7 +8739,7 @@ build_lambda_object (tree lambda_expr)\n   /* Build aggregate constructor call.\n      - cp_parser_braced_list\n      - cp_parser_functional_cast  */\n-  VEC(constructor_elt,gc) *elts = NULL;\n+  vec<constructor_elt, va_gc> *elts = NULL;\n   tree node, expr, type;\n   location_t saved_loc;\n \n@@ -9067,8 +9059,7 @@ insert_capture_proxy (tree var)\n \n   /* And put a DECL_EXPR in the STATEMENT_LIST for the same block.  */\n   var = build_stmt (DECL_SOURCE_LOCATION (var), DECL_EXPR, var);\n-  stmt_list = VEC_index (tree, stmt_list_stack,\n-\t\t\t VEC_length (tree, stmt_list_stack) - 1 - skip);\n+  stmt_list = (*stmt_list_stack)[stmt_list_stack->length () - 1 - skip];\n   gcc_assert (stmt_list);\n   append_to_statement_list_force (var, &stmt_list);\n }\n@@ -9081,17 +9072,17 @@ void\n insert_pending_capture_proxies (void)\n {\n   tree lam;\n-  VEC(tree,gc) *proxies;\n+  vec<tree, va_gc> *proxies;\n   unsigned i;\n \n   if (!current_function_decl || !LAMBDA_FUNCTION_P (current_function_decl))\n     return;\n \n   lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n   proxies = LAMBDA_EXPR_PENDING_PROXIES (lam);\n-  for (i = 0; i < VEC_length (tree, proxies); ++i)\n+  for (i = 0; i < vec_safe_length (proxies); ++i)\n     {\n-      tree var = VEC_index (tree, proxies, i);\n+      tree var = (*proxies)[i];\n       insert_capture_proxy (var);\n     }\n   release_tree_vector (LAMBDA_EXPR_PENDING_PROXIES (lam));\n@@ -9158,7 +9149,7 @@ build_capture_proxy (tree member)\n   if (fn == current_function_decl)\n     insert_capture_proxy (var);\n   else\n-    VEC_safe_push (tree, gc, LAMBDA_EXPR_PENDING_PROXIES (lam), var);\n+    vec_safe_push (LAMBDA_EXPR_PENDING_PROXIES (lam), var);\n \n   return var;\n }\n@@ -9405,7 +9396,7 @@ maybe_add_lambda_conv_op (tree type)\n   tree callop = lambda_function (type);\n   tree rettype, name, fntype, fn, body, compound_stmt;\n   tree thistype, stattype, statfn, convfn, call, arg;\n-  VEC (tree, gc) *argvec;\n+  vec<tree, va_gc> *argvec;\n \n   if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)\n     return;\n@@ -9495,14 +9486,13 @@ maybe_add_lambda_conv_op (tree type)\n   arg = build1 (NOP_EXPR, TREE_TYPE (DECL_ARGUMENTS (callop)),\n \t\tnull_pointer_node);\n   argvec = make_tree_vector ();\n-  VEC_quick_push (tree, argvec, arg);\n+  argvec->quick_push (arg);\n   for (arg = DECL_ARGUMENTS (statfn); arg; arg = DECL_CHAIN (arg))\n     {\n       mark_exp_read (arg);\n-      VEC_safe_push (tree, gc, argvec, arg);\n+      vec_safe_push (argvec, arg);\n     }\n-  call = build_call_a (callop, VEC_length (tree, argvec),\n-\t\t       VEC_address (tree, argvec));\n+  call = build_call_a (callop, argvec->length (), argvec->address ());\n   CALL_FROM_THUNK_P (call) = 1;\n   if (MAYBE_CLASS_TYPE_P (TREE_TYPE (call)))\n     call = build_cplus_new (TREE_TYPE (call), call, tf_warning_or_error);"}, {"sha": "58725f3bd58af37f7bb5497fa548ade9ec60599b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -508,7 +508,7 @@ static tree\n build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n {\n   tree inner_type = strip_array_types (type);\n-  VEC(tree,gc) *argvec;\n+  vec<tree, va_gc> *argvec;\n \n   if (integer_zerop (array_type_nelts_total (type))\n       || !CLASS_TYPE_P (inner_type))\n@@ -527,7 +527,7 @@ build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n       tree dummy = build_dummy_object (inner_type);\n       if (!real_lvalue_p (init))\n \tdummy = move (dummy);\n-      VEC_quick_push (tree, argvec, dummy);\n+      argvec->quick_push (dummy);\n     }\n   init = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t    &argvec, inner_type, LOOKUP_NORMAL,\n@@ -1286,21 +1286,21 @@ strip_typedefs_expr (tree t)\n \n     case TREE_LIST:\n       {\n-\tVEC(tree,gc) *vec = make_tree_vector ();\n+\tvec<tree, va_gc> *vec = make_tree_vector ();\n \tbool changed = false;\n \ttree it;\n \tfor (it = t; it; it = TREE_CHAIN (it))\n \t  {\n \t    tree val = strip_typedefs_expr (TREE_VALUE (t));\n-\t    VEC_safe_push (tree, gc, vec, val);\n+\t    vec_safe_push (vec, val);\n \t    if (val != TREE_VALUE (t))\n \t      changed = true;\n \t    gcc_assert (TREE_PURPOSE (it) == NULL_TREE);\n \t  }\n \tif (changed)\n \t  {\n \t    r = NULL_TREE;\n-\t    FOR_EACH_VEC_ELT_REVERSE (tree, vec, i, it)\n+\t    FOR_EACH_VEC_ELT_REVERSE (*vec, i, it)\n \t      r = tree_cons (NULL_TREE, it, r);\n \t  }\n \telse\n@@ -1312,21 +1312,21 @@ strip_typedefs_expr (tree t)\n     case TREE_VEC:\n       {\n \tbool changed = false;\n-\tVEC(tree,gc)* vec = make_tree_vector ();\n+\tvec<tree, va_gc> *vec = make_tree_vector ();\n \tn = TREE_VEC_LENGTH (t);\n-\tVEC_reserve (tree, gc, vec, n);\n+\tvec_safe_reserve (vec, n);\n \tfor (i = 0; i < n; ++i)\n \t  {\n \t    tree op = strip_typedefs_expr (TREE_VEC_ELT (t, i));\n-\t    VEC_quick_push (tree, vec, op);\n+\t    vec->quick_push (op);\n \t    if (op != TREE_VEC_ELT (t, i))\n \t      changed = true;\n \t  }\n \tif (changed)\n \t  {\n \t    r = copy_node (t);\n \t    for (i = 0; i < n; ++i)\n-\t      TREE_VEC_ELT (r, i) = VEC_index (tree, vec, i);\n+\t      TREE_VEC_ELT (r, i) = (*vec)[i];\n \t  }\n \telse\n \t  r = t;\n@@ -1337,13 +1337,13 @@ strip_typedefs_expr (tree t)\n     case CONSTRUCTOR:\n       {\n \tbool changed = false;\n-\tVEC(constructor_elt,gc) *vec\n-\t  = VEC_copy (constructor_elt, gc, CONSTRUCTOR_ELTS (t));\n+\tvec<constructor_elt, va_gc> *vec\n+\t  = vec_safe_copy (CONSTRUCTOR_ELTS (t));\n \tn = CONSTRUCTOR_NELTS (t);\n \ttype = strip_typedefs (TREE_TYPE (t));\n \tfor (i = 0; i < n; ++i)\n \t  {\n-\t    constructor_elt *e = &VEC_index (constructor_elt, vec, i);\n+\t    constructor_elt *e = &(*vec)[i];\n \t    tree op = strip_typedefs_expr (e->value);\n \t    if (op != e->value)\n \t      {\n@@ -1355,7 +1355,7 @@ strip_typedefs_expr (tree t)\n \n \tif (!changed && type == TREE_TYPE (t))\n \t  {\n-\t    VEC_free (constructor_elt, gc, vec);\n+\t    vec_free (vec);\n \t    return t;\n \t  }\n \telse\n@@ -1484,7 +1484,7 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n     {\n       /* Push it onto the list after any virtual bases it contains\n \t will have been pushed.  */\n-      VEC_quick_push (tree, CLASSTYPE_VBASECLASSES (t), new_binfo);\n+      CLASSTYPE_VBASECLASSES (t)->quick_push (new_binfo);\n       BINFO_VIRTUAL_P (new_binfo) = 1;\n       BINFO_INHERITANCE_CHAIN (new_binfo) = TYPE_BINFO (t);\n     }\n@@ -2184,9 +2184,9 @@ bot_replace (tree* t, int* /*walk_subtrees*/, void* data)\n       /* In an NSDMI build_base_path defers building conversions to virtual\n \t bases, and we handle it here.  */\n       tree basetype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (*t)));\n-      VEC(tree,gc) *vbases = CLASSTYPE_VBASECLASSES (current_class_type);\n+      vec<tree, va_gc> *vbases = CLASSTYPE_VBASECLASSES (current_class_type);\n       int i; tree binfo;\n-      FOR_EACH_VEC_ELT (tree, vbases, i, binfo)\n+      FOR_EACH_VEC_SAFE_ELT (vbases, i, binfo)\n \tif (BINFO_TYPE (binfo) == basetype)\n \t  break;\n       *t = build_base_path (PLUS_EXPR, TREE_OPERAND (*t, 0), binfo, true,\n@@ -2327,7 +2327,7 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n    that has been built.  */\n \n tree\n-build_min_non_dep_call_vec (tree non_dep, tree fn, VEC(tree,gc) *argvec)\n+build_min_non_dep_call_vec (tree non_dep, tree fn, vec<tree, va_gc> *argvec)\n {\n   tree t = build_nt_call_vec (fn, argvec);\n   if (REFERENCE_REF_P (non_dep))\n@@ -3742,8 +3742,8 @@ stabilize_init (tree init, tree *initp)\n       unsigned i;\n       constructor_elt *ce;\n       bool good = true;\n-      VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (t);\n-      for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n+      vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n+      for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n \t{\n \t  tree type = TREE_TYPE (ce->value);\n \t  tree subinit;\n@@ -3827,7 +3827,7 @@ cp_fix_function_decl_p (tree decl)\n       /* Don't fix same_body aliases.  Although they don't have their own\n \t CFG, they share it with what they alias to.  */\n       if (!node || !node->alias\n-\t  || !VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n+\t  || !vec_safe_length (node->symbol.ref_list.references))\n \treturn true;\n     }\n "}, {"sha": "1cbab61716703478a24d59f4653c12897a6a6b08", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -59,7 +59,7 @@ static bool casts_away_constness (tree, tree, tsubst_flags_t);\n static void maybe_warn_about_returning_address_of_local (tree);\n static tree lookup_destructor (tree, tree, tree);\n static void warn_args_num (location_t, tree, bool);\n-static int convert_arguments (tree, VEC(tree,gc) **, tree, int,\n+static int convert_arguments (tree, vec<tree, va_gc> **, tree, int,\n                               tsubst_flags_t);\n \n /* Do `exp = require_complete_type (exp);' to make sure exp\n@@ -3270,10 +3270,10 @@ build_function_call (location_t /*loc*/,\n /* Used by the C-common bits.  */\n tree\n build_function_call_vec (location_t /*loc*/,\n-\t\t\t tree function, VEC(tree,gc) *params,\n-\t\t\t VEC(tree,gc) * /*origtypes*/)\n+\t\t\t tree function, vec<tree, va_gc> *params,\n+\t\t\t vec<tree, va_gc> * /*origtypes*/)\n {\n-  VEC(tree,gc) *orig_params = params;\n+  vec<tree, va_gc> *orig_params = params;\n   tree ret = cp_build_function_call_vec (function, &params,\n \t\t\t\t\t tf_warning_or_error);\n \n@@ -3290,12 +3290,12 @@ build_function_call_vec (location_t /*loc*/,\n tree\n cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n {\n-  VEC(tree,gc) *vec;\n+  vec<tree, va_gc> *vec;\n   tree ret;\n \n   vec = make_tree_vector ();\n   for (; params != NULL_TREE; params = TREE_CHAIN (params))\n-    VEC_safe_push (tree, gc, vec, TREE_VALUE (params));\n+    vec_safe_push (vec, TREE_VALUE (params));\n   ret = cp_build_function_call_vec (function, &vec, complain);\n   release_tree_vector (vec);\n   return ret;\n@@ -3306,14 +3306,14 @@ cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n tree\n cp_build_function_call_nary (tree function, tsubst_flags_t complain, ...)\n {\n-  VEC(tree,gc) *vec;\n+  vec<tree, va_gc> *vec;\n   va_list args;\n   tree ret, t;\n \n   vec = make_tree_vector ();\n   va_start (args, complain);\n   for (t = va_arg (args, tree); t != NULL_TREE; t = va_arg (args, tree))\n-    VEC_safe_push (tree, gc, vec, t);\n+    vec_safe_push (vec, t);\n   va_end (args);\n   ret = cp_build_function_call_vec (function, &vec, complain);\n   release_tree_vector (vec);\n@@ -3325,7 +3325,7 @@ cp_build_function_call_nary (tree function, tsubst_flags_t complain, ...)\n    PARAMS.  */\n \n tree\n-cp_build_function_call_vec (tree function, VEC(tree,gc) **params,\n+cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,\n \t\t\t    tsubst_flags_t complain)\n {\n   tree fntype, fndecl;\n@@ -3334,14 +3334,13 @@ cp_build_function_call_vec (tree function, VEC(tree,gc) **params,\n   int nargs;\n   tree *argarray;\n   tree parm_types;\n-  VEC(tree,gc) *allocated = NULL;\n+  vec<tree, va_gc> *allocated = NULL;\n   tree ret;\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n-  if (params != NULL && !VEC_empty (tree, *params))\n-    function = objc_rewrite_function_call (function,\n-\t\t\t\t\t   VEC_index (tree, *params, 0));\n+  if (params != NULL && !vec_safe_is_empty (*params))\n+    function = objc_rewrite_function_call (function, (**params)[0]);\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */\n@@ -3421,7 +3420,7 @@ cp_build_function_call_vec (tree function, VEC(tree,gc) **params,\n   if (nargs < 0)\n     return error_mark_node;\n \n-  argarray = VEC_address (tree, *params);\n+  argarray = (*params)->address ();\n \n   /* Check for errors in format strings and inappropriately\n      null parameters.  */\n@@ -3499,7 +3498,7 @@ warn_args_num (location_t loc, tree fndecl, bool too_many_p)\n    default arguments, if such were specified.  Do so here.  */\n \n static int\n-convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n+convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n \t\t   int flags, tsubst_flags_t complain)\n {\n   tree typetail;\n@@ -3509,11 +3508,11 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n   flags |= LOOKUP_ONLYCONVERTING;\n \n   for (i = 0, typetail = typelist;\n-       i < VEC_length (tree, *values);\n+       i < vec_safe_length (*values);\n        i++)\n     {\n       tree type = typetail ? TREE_VALUE (typetail) : 0;\n-      tree val = VEC_index (tree, *values, i);\n+      tree val = (**values)[i];\n \n       if (val == error_mark_node || type == error_mark_node)\n \treturn -1;\n@@ -3575,7 +3574,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t  if (parmval == error_mark_node)\n \t    return -1;\n \n-\t  VEC_replace (tree, *values, i, parmval);\n+\t  (**values)[i] = parmval;\n \t}\n       else\n \t{\n@@ -3588,7 +3587,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t  else\n \t    val = convert_arg_to_ellipsis (val, complain);\n \n-\t  VEC_replace (tree, *values, i, val);\n+\t  (**values)[i] = val;\n \t}\n \n       if (typetail)\n@@ -3617,7 +3616,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t      if (parmval == error_mark_node)\n \t\treturn -1;\n \n-\t      VEC_safe_push (tree, gc, *values, parmval);\n+\t      vec_safe_push (*values, parmval);\n \t      typetail = TREE_CHAIN (typetail);\n \t      /* ends with `...'.  */\n \t      if (typetail == NULL_TREE)\n@@ -5880,13 +5879,13 @@ build_x_compound_expr_from_list (tree list, expr_list_kind exp,\n /* Like build_x_compound_expr_from_list, but using a VEC.  */\n \n tree\n-build_x_compound_expr_from_vec (VEC(tree,gc) *vec, const char *msg,\n+build_x_compound_expr_from_vec (vec<tree, va_gc> *vec, const char *msg,\n \t\t\t\ttsubst_flags_t complain)\n {\n-  if (VEC_empty (tree, vec))\n+  if (vec_safe_is_empty (vec))\n     return NULL_TREE;\n-  else if (VEC_length (tree, vec) == 1)\n-    return VEC_index (tree, vec, 0);\n+  else if (vec->length () == 1)\n+    return (*vec)[0];\n   else\n     {\n       tree expr;\n@@ -5903,8 +5902,8 @@ build_x_compound_expr_from_vec (VEC(tree,gc) *vec, const char *msg,\n \t    return error_mark_node;\n \t}\n \n-      expr = VEC_index (tree, vec, 0);\n-      for (ix = 1; VEC_iterate (tree, vec, ix, t); ++ix)\n+      expr = (*vec)[0];\n+      for (ix = 1; vec->iterate (ix, &t); ++ix)\n \texpr = build_x_compound_expr (EXPR_LOCATION (t), expr,\n \t\t\t\t      t, complain);\n \n@@ -7090,7 +7089,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t/* Do the default thing.  */;\n       else\n \t{\n-\t  VEC(tree,gc) *rhs_vec = make_tree_vector_single (rhs);\n+\t  vec<tree, va_gc> *rhs_vec = make_tree_vector_single (rhs);\n \t  result = build_special_member_call (lhs, complete_ctor_identifier,\n \t\t\t\t\t      &rhs_vec, lhstype, LOOKUP_NORMAL,\n                                               complain);\n@@ -7457,7 +7456,7 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n   tree u = NULL_TREE;\n   tree delta_field;\n   tree pfn_field;\n-  VEC(constructor_elt, gc) *v;\n+  vec<constructor_elt, va_gc> *v;\n \n   /* Pull the FIELD_DECLs out of the type.  */\n   pfn_field = TYPE_FIELDS (type);\n@@ -7470,7 +7469,7 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n   pfn = fold_convert (TREE_TYPE (pfn_field), pfn);\n \n   /* Finish creating the initializer.  */\n-  v = VEC_alloc(constructor_elt, gc, 2);\n+  vec_alloc (v, 2);\n   CONSTRUCTOR_APPEND_ELT(v, pfn_field, pfn);\n   CONSTRUCTOR_APPEND_ELT(v, delta_field, delta);\n   u = build_constructor (type, v);"}, {"sha": "c7262f427cd0a543eaa0165d4e1eaa3ee72e32ef", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -253,7 +253,7 @@ complete_type_check_abstract (tree type)\n int\n abstract_virtuals_error_sfinae (tree decl, tree type, tsubst_flags_t complain)\n {\n-  VEC(tree,gc) *pure;\n+  vec<tree, va_gc> *pure;\n \n   /* This function applies only to classes. Any other entity can never\n      be abstract.  */\n@@ -331,7 +331,7 @@ abstract_virtuals_error_sfinae (tree decl, tree type, tsubst_flags_t complain)\n     error (\"cannot allocate an object of abstract type %qT\", type);\n \n   /* Only go through this once.  */\n-  if (VEC_length (tree, pure))\n+  if (pure->length ())\n     {\n       unsigned ix;\n       tree fn;\n@@ -340,15 +340,15 @@ abstract_virtuals_error_sfinae (tree decl, tree type, tsubst_flags_t complain)\n \t      \"  because the following virtual functions are pure within %qT:\",\n \t      type);\n \n-      FOR_EACH_VEC_ELT (tree, pure, ix, fn)\n+      FOR_EACH_VEC_ELT (*pure, ix, fn)\n \tif (! DECL_CLONED_FUNCTION_P (fn)\n \t    || DECL_COMPLETE_DESTRUCTOR_P (fn))\n \t  inform (input_location, \"\\t%+#D\", fn);\n \n       /* Now truncate the vector.  This leaves it non-null, so we know\n \t there are pure virtuals, but empty so we don't list them out\n \t again.  */\n-      VEC_truncate (tree, pure, 0);\n+      pure->truncate (0);\n     }\n   else\n     inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)),\n@@ -566,8 +566,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t\t split_non_constant_init into process_init_constructor_array,\n \t\t that is separating constants from non-constants while building\n \t\t the vector.  */\n-\t      VEC_ordered_remove (constructor_elt, CONSTRUCTOR_ELTS (init),\n-\t\t\t\t  idx);\n+\t      CONSTRUCTOR_ELTS (init)->ordered_remove (idx);\n \t      --idx;\n \n \t      if (array_type_p)\n@@ -661,7 +660,7 @@ split_nonconstant_init (tree dest, tree init)\n    for static variable.  In that case, caller must emit the code.  */\n \n tree\n-store_init_value (tree decl, tree init, VEC(tree,gc)** cleanups, int flags)\n+store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n {\n   tree value, type;\n \n@@ -1047,7 +1046,7 @@ process_init_constructor_array (tree type, tree init,\n   int flags = 0;\n   bool unbounded = false;\n   constructor_elt *ce;\n-  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (init);\n+  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (init);\n \n   gcc_assert (TREE_CODE (type) == ARRAY_TYPE\n \t      || TREE_CODE (type) == VECTOR_TYPE);\n@@ -1070,15 +1069,15 @@ process_init_constructor_array (tree type, tree init,\n     len = TYPE_VECTOR_SUBPARTS (type);\n \n   /* There must not be more initializers than needed.  */\n-  if (!unbounded && VEC_length (constructor_elt, v)  > len)\n+  if (!unbounded && vec_safe_length (v) > len)\n     {\n       if (complain & tf_error)\n \terror (\"too many initializers for %qT\", type);\n       else\n \treturn PICFLAG_ERRONEOUS;\n     }\n \n-  FOR_EACH_VEC_ELT (constructor_elt, v, i, ce)\n+  FOR_EACH_VEC_SAFE_ELT (v, i, ce)\n     {\n       if (ce->index)\n \t{\n@@ -1142,7 +1141,7 @@ static int\n process_init_constructor_record (tree type, tree init,\n \t\t\t\t tsubst_flags_t complain)\n {\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n   int flags = 0;\n   tree field;\n   unsigned HOST_WIDE_INT idx = 0;\n@@ -1176,10 +1175,9 @@ process_init_constructor_record (tree type, tree init,\n       if (DECL_BIT_FIELD_TYPE (field))\n \ttype = DECL_BIT_FIELD_TYPE (field);\n \n-      if (idx < VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)))\n+      if (idx < vec_safe_length (CONSTRUCTOR_ELTS (init)))\n \t{\n-\t  constructor_elt *ce = &VEC_index (constructor_elt,\n-\t\t\t\t\t   CONSTRUCTOR_ELTS (init), idx);\n+\t  constructor_elt *ce = &(*CONSTRUCTOR_ELTS (init))[idx];\n \t  if (ce->index)\n \t    {\n \t      /* We can have either a FIELD_DECL or an IDENTIFIER_NODE. The\n@@ -1269,7 +1267,7 @@ process_init_constructor_record (tree type, tree init,\n       CONSTRUCTOR_APPEND_ELT (v, field, next);\n     }\n \n-  if (idx < VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)))\n+  if (idx < vec_safe_length (CONSTRUCTOR_ELTS (init)))\n     {\n       if (complain & tf_error)\n \terror (\"too many initializers for %qT\", type);\n@@ -1293,19 +1291,19 @@ process_init_constructor_union (tree type, tree init,\n   int len;\n \n   /* If the initializer was empty, use default zero initialization.  */\n-  if (VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (init)))\n+  if (vec_safe_is_empty (CONSTRUCTOR_ELTS (init)))\n     return 0;\n \n-  len = VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init));\n+  len = CONSTRUCTOR_ELTS (init)->length ();\n   if (len > 1)\n     {\n       if (!(complain & tf_error))\n \treturn PICFLAG_ERRONEOUS;\n       error (\"too many initializers for %qT\", type);\n-      VEC_block_remove (constructor_elt, CONSTRUCTOR_ELTS (init), 1, len-1);\n+      CONSTRUCTOR_ELTS (init)->block_remove (1, len-1);\n     }\n \n-  ce = &VEC_index (constructor_elt, CONSTRUCTOR_ELTS (init), 0);\n+  ce = &(*CONSTRUCTOR_ELTS (init))[0];\n \n   /* If this element specifies a field, initialize via that field.  */\n   if (ce->index)\n@@ -1476,7 +1474,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n   tree orig_expr = expr;\n   tree type = TREE_TYPE (expr);\n   tree last_rval = NULL_TREE;\n-  VEC(tree,gc) *types_memoized = NULL;\n+  vec<tree, va_gc> *types_memoized = NULL;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n@@ -1511,7 +1509,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \t      return error_mark_node;\n \t    }\n \n-\t  VEC_safe_push (tree, gc, types_memoized, TREE_TYPE (expr));\n+\t  vec_safe_push (types_memoized, TREE_TYPE (expr));\n \t  last_rval = expr;\n \t}\n \n@@ -1665,7 +1663,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n \n   /* The type to which we are casting.  */\n   tree type;\n-  VEC(tree,gc) *parmvec;\n+  vec<tree, va_gc> *parmvec;\n \n   if (exp == error_mark_node || parms == error_mark_node)\n     return error_mark_node;\n@@ -1762,7 +1760,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n   /* Call the constructor.  */\n   parmvec = make_tree_vector ();\n   for (; parms != NULL_TREE; parms = TREE_CHAIN (parms))\n-    VEC_safe_push (tree, gc, parmvec, TREE_VALUE (parms));\n+    vec_safe_push (parmvec, TREE_VALUE (parms));\n   exp = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t   &parmvec, type, LOOKUP_NORMAL, complain);\n   release_tree_vector (parmvec);"}, {"sha": "94852508be440d25b99aa6fe866abcbb511ec790", "filename": "gcc/cprop.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -65,8 +65,6 @@ struct occr\n };\n \n typedef struct occr *occr_t;\n-DEF_VEC_P (occr_t);\n-DEF_VEC_ALLOC_P (occr_t, heap);\n \n /* Hash table entry for assignment expressions.  */\n "}, {"sha": "2a5929272533dc7ceeee9d6246bdd599ed2c746a", "filename": "gcc/data-streamer.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -31,8 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n static unsigned const BITS_PER_BITPACK_WORD = HOST_BITS_PER_WIDE_INT;\n \n typedef unsigned HOST_WIDE_INT bitpack_word_t;\n-DEF_VEC_I(bitpack_word_t);\n-DEF_VEC_ALLOC_I(bitpack_word_t, heap);\n \n struct bitpack_d\n {"}, {"sha": "1d6d71c847891dd5b35ad88921eea2e5deec297b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -2184,7 +2184,7 @@ dbxout_type (tree type, int full)\n \t  {\n \t    int i;\n \t    tree child;\n-\t    VEC(tree,gc) *accesses = BINFO_BASE_ACCESSES (binfo);\n+\t    vec<tree, va_gc> *accesses = BINFO_BASE_ACCESSES (binfo);\n \n \t    if (use_gnu_debug_info_extensions)\n \t      {\n@@ -2197,8 +2197,7 @@ dbxout_type (tree type, int full)\n \t      }\n \t    for (i = 0; BINFO_BASE_ITERATE (binfo, i, child); i++)\n \t      {\n-\t\ttree access = (accesses ? VEC_index (tree, accesses, i)\n-\t\t\t       : access_public_node);\n+\t\ttree access = (accesses ? (*accesses)[i] : access_public_node);\n \n \t\tif (use_gnu_debug_info_extensions)\n \t\t  {\n@@ -2541,7 +2540,7 @@ static int\n output_used_types_helper (void **slot, void *data)\n {\n   tree type = (tree) *slot;\n-  VEC(tree, heap) **types_p = (VEC(tree, heap) **) data;\n+  vec<tree> *types_p = (vec<tree> *) data;\n \n   if ((TREE_CODE (type) == RECORD_TYPE\n        || TREE_CODE (type) == UNION_TYPE\n@@ -2550,10 +2549,10 @@ output_used_types_helper (void **slot, void *data)\n       && TYPE_STUB_DECL (type)\n       && DECL_P (TYPE_STUB_DECL (type))\n       && ! DECL_IGNORED_P (TYPE_STUB_DECL (type)))\n-    VEC_quick_push (tree, *types_p, TYPE_STUB_DECL (type));\n+    types_p->quick_push (TYPE_STUB_DECL (type));\n   else if (TYPE_NAME (type)\n \t   && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n-    VEC_quick_push (tree, *types_p, TYPE_NAME (type));\n+    types_p->quick_push (TYPE_NAME (type));\n \n   return 1;\n }\n@@ -2593,20 +2592,20 @@ output_used_types (void)\n {\n   if (cfun && cfun->used_types_hash)\n     {\n-      VEC(tree, heap) *types;\n+      vec<tree> types;\n       int i;\n       tree type;\n \n-      types = VEC_alloc (tree, heap, htab_elements (cfun->used_types_hash));\n+      types.create (htab_elements (cfun->used_types_hash));\n       htab_traverse (cfun->used_types_hash, output_used_types_helper, &types);\n \n       /* Sort by UID to prevent dependence on hash table ordering.  */\n-      VEC_qsort (tree, types, output_types_sort);\n+      types.qsort (output_types_sort);\n \n-      FOR_EACH_VEC_ELT (tree, types, i, type)\n+      FOR_EACH_VEC_ELT (types, i, type)\n \tdebug_queue_symbol (type);\n \n-      VEC_free (tree, heap, types);\n+      types.release ();\n     }\n }\n "}, {"sha": "c9ac8b219a9701b38c6b5aba14684fced1602fb1", "filename": "gcc/dce.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -52,7 +52,7 @@ static bool can_alter_cfg = false;\n \n /* Instructions that have been marked but whose dependencies have not\n    yet been processed.  */\n-static VEC(rtx,heap) *worklist;\n+static vec<rtx> worklist;\n \n /* Bitmap of instructions marked as needed indexed by INSN_UID.  */\n static sbitmap marked;\n@@ -182,7 +182,7 @@ mark_insn (rtx insn, bool fast)\n   if (!marked_insn_p (insn))\n     {\n       if (!fast)\n-\tVEC_safe_push (rtx, heap, worklist, insn);\n+\tworklist.safe_push (insn);\n       bitmap_set_bit (marked, INSN_UID (insn));\n       if (dump_file)\n \tfprintf (dump_file, \"  Adding insn %d to worklist\\n\", INSN_UID (insn));\n@@ -760,12 +760,12 @@ rest_of_handle_ud_dce (void)\n \n   prescan_insns_for_dce (false);\n   mark_artificial_uses ();\n-  while (VEC_length (rtx, worklist) > 0)\n+  while (worklist.length () > 0)\n     {\n-      insn = VEC_pop (rtx, worklist);\n+      insn = worklist.pop ();\n       mark_reg_dependencies (insn);\n     }\n-  VEC_free (rtx, heap, worklist);\n+  worklist.release ();\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     reset_unmarked_insns_debug_uses ();"}, {"sha": "94b10d3069efd05efb73bcbcdfbf11dbfc10b2bb", "filename": "gcc/df-core.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -991,12 +991,12 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n   bitmap worklist = BITMAP_ALLOC (&df_bitmap_obstack);\n   int age = 0;\n   bool changed;\n-  VEC(int, heap) *last_visit_age = NULL;\n+  vec<int> last_visit_age = vec<int>();\n   int prev_age;\n   basic_block bb;\n   int i;\n \n-  VEC_safe_grow_cleared (int, heap, last_visit_age, n_blocks);\n+  last_visit_age.safe_grow_cleared (n_blocks);\n \n   /* Double-queueing. Worklist is for the current iteration,\n      and pending is for the next. */\n@@ -1018,7 +1018,7 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \t  bitmap_clear_bit (pending, index);\n \t  bb_index = blocks_in_postorder[index];\n \t  bb = BASIC_BLOCK (bb_index);\n-\t  prev_age = VEC_index (int, last_visit_age, index);\n+\t  prev_age = last_visit_age[index];\n \t  if (dir == DF_FORWARD)\n \t    changed = df_worklist_propagate_forward (dataflow, bb_index,\n \t\t\t\t\t\t     bbindex_to_postorder,\n@@ -1029,7 +1029,7 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \t\t\t\t\t\t      bbindex_to_postorder,\n \t\t\t\t\t\t      pending, considered,\n \t\t\t\t\t\t      prev_age);\n-\t  VEC_replace (int, last_visit_age, index, ++age);\n+\t  last_visit_age[index] = ++age;\n \t  if (changed)\n \t    bb->aux = (void *)(ptrdiff_t)age;\n \t}\n@@ -1040,7 +1040,7 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \n   BITMAP_FREE (worklist);\n   BITMAP_FREE (pending);\n-  VEC_free (int, heap, last_visit_age);\n+  last_visit_age.release ();\n \n   /* Dump statistics. */\n   if (dump_file)"}, {"sha": "89a6189325f36821290bd809387f5949a930296f", "filename": "gcc/df-problems.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"except.h\"\n #include \"dce.h\"\n-#include \"vecprim.h\"\n #include \"valtrack.h\"\n #include \"dumpfile.h\"\n "}, {"sha": "93a06379b17bf086fdb638b3d406925918f9236f", "filename": "gcc/df-scan.c", "status": "modified", "additions": 99, "deletions": 116, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -45,18 +45,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n \n-DEF_VEC_P(df_ref);\n-DEF_VEC_ALLOC_P_STACK(df_ref);\n-\n-#define VEC_df_ref_stack_alloc(alloc) VEC_stack_alloc (df_ref, alloc)\n \n typedef struct df_mw_hardreg *df_mw_hardreg_ptr;\n \n-DEF_VEC_P(df_mw_hardreg_ptr);\n-DEF_VEC_ALLOC_P_STACK(df_mw_hardreg_ptr);\n-\n-#define VEC_df_mw_hardreg_ptr_stack_alloc(alloc) \\\n-  VEC_stack_alloc (df_mw_hardreg_ptr, alloc)\n \n #ifndef HAVE_epilogue\n #define HAVE_epilogue 0\n@@ -96,10 +87,10 @@ static HARD_REG_SET elim_reg_set;\n \n struct df_collection_rec\n {\n-  VEC(df_ref,stack) *def_vec;\n-  VEC(df_ref,stack) *use_vec;\n-  VEC(df_ref,stack) *eq_use_vec;\n-  VEC(df_mw_hardreg_ptr,stack) *mw_vec;\n+  vec<df_ref, va_stack> def_vec;\n+  vec<df_ref, va_stack> use_vec;\n+  vec<df_ref, va_stack> eq_use_vec;\n+  vec<df_mw_hardreg_ptr, va_stack> mw_vec;\n };\n \n static df_ref df_null_ref_rec[1];\n@@ -1181,19 +1172,19 @@ df_free_collection_rec (struct df_collection_rec *collection_rec)\n   df_ref ref;\n   struct df_mw_hardreg *mw;\n \n-  FOR_EACH_VEC_ELT (df_ref, collection_rec->def_vec, ix, ref)\n+  FOR_EACH_VEC_ELT (collection_rec->def_vec, ix, ref)\n     df_free_ref (ref);\n-  FOR_EACH_VEC_ELT (df_ref, collection_rec->use_vec, ix, ref)\n+  FOR_EACH_VEC_ELT (collection_rec->use_vec, ix, ref)\n     df_free_ref (ref);\n-  FOR_EACH_VEC_ELT (df_ref, collection_rec->eq_use_vec, ix, ref)\n+  FOR_EACH_VEC_ELT (collection_rec->eq_use_vec, ix, ref)\n     df_free_ref (ref);\n-  FOR_EACH_VEC_ELT (df_mw_hardreg_ptr, collection_rec->mw_vec, ix, mw)\n+  FOR_EACH_VEC_ELT (collection_rec->mw_vec, ix, mw)\n     pool_free (problem_data->mw_reg_pool, mw);\n \n-  VEC_free (df_ref, stack, collection_rec->def_vec);\n-  VEC_free (df_ref, stack, collection_rec->use_vec);\n-  VEC_free (df_ref, stack, collection_rec->eq_use_vec);\n-  VEC_free (df_mw_hardreg_ptr, stack, collection_rec->mw_vec);\n+  collection_rec->def_vec.release ();\n+  collection_rec->use_vec.release ();\n+  collection_rec->eq_use_vec.release ();\n+  collection_rec->mw_vec.release ();\n }\n \n /* Rescan INSN.  Return TRUE if the rescanning produced any changes.  */\n@@ -1245,10 +1236,10 @@ df_insn_rescan (rtx insn)\n       return false;\n     }\n \n-  collection_rec.def_vec = VEC_alloc (df_ref, stack, 128);\n-  collection_rec.use_vec = VEC_alloc (df_ref, stack, 32);\n-  collection_rec.eq_use_vec = VEC_alloc (df_ref, stack, 32);\n-  collection_rec.mw_vec = VEC_alloc (df_mw_hardreg_ptr, stack, 32);\n+  vec_stack_alloc (df_ref, collection_rec.def_vec, 128);\n+  vec_stack_alloc (df_ref, collection_rec.use_vec, 32);\n+  vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n+  vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n \n   bitmap_clear_bit (&df->insns_to_delete, uid);\n   bitmap_clear_bit (&df->insns_to_rescan, uid);\n@@ -1287,10 +1278,10 @@ df_insn_rescan (rtx insn)\n   if (!DEBUG_INSN_P (insn))\n     df_set_bb_dirty (bb);\n \n-  VEC_free (df_ref, stack, collection_rec.def_vec);\n-  VEC_free (df_ref, stack, collection_rec.use_vec);\n-  VEC_free (df_ref, stack, collection_rec.eq_use_vec);\n-  VEC_free (df_mw_hardreg_ptr, stack, collection_rec.mw_vec);\n+  collection_rec.def_vec.release ();\n+  collection_rec.use_vec.release ();\n+  collection_rec.eq_use_vec.release ();\n+  collection_rec.mw_vec.release ();\n \n   return true;\n }\n@@ -2198,8 +2189,8 @@ df_notes_rescan (rtx insn)\n       unsigned int mw_len;\n \n       memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-      collection_rec.eq_use_vec = VEC_alloc (df_ref, stack, 32);\n-      collection_rec.mw_vec = VEC_alloc (df_mw_hardreg_ptr, stack, 32);\n+      vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n+      vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n \n       num_deleted = df_mw_hardreg_chain_delete_eq_uses (insn_info);\n       df_ref_chain_delete (insn_info->eq_uses);\n@@ -2223,7 +2214,7 @@ df_notes_rescan (rtx insn)\n \n       /* Find some place to put any new mw_hardregs.  */\n       df_canonize_collection_rec (&collection_rec);\n-      mw_len = VEC_length (df_mw_hardreg_ptr, collection_rec.mw_vec);\n+      mw_len = collection_rec.mw_vec.length ();\n       if (mw_len)\n \t{\n \t  unsigned int count = 0;\n@@ -2246,7 +2237,7 @@ df_notes_rescan (rtx insn)\n \t\t\t\tcount + 1 + mw_len);\n \t\t}\n \t      memcpy (&insn_info->mw_hardregs[count],\n-\t\t      VEC_address (df_mw_hardreg_ptr, collection_rec.mw_vec),\n+\t\t      collection_rec.mw_vec.address (),\n \t\t      mw_len * sizeof (struct df_mw_hardreg *));\n \t      insn_info->mw_hardregs[count + mw_len] = NULL;\n \t      qsort (insn_info->mw_hardregs, count + mw_len,\n@@ -2258,16 +2249,16 @@ df_notes_rescan (rtx insn)\n \t      insn_info->mw_hardregs\n \t\t= XNEWVEC (struct df_mw_hardreg*, 1 + mw_len);\n \t      memcpy (insn_info->mw_hardregs,\n-\t\t      VEC_address (df_mw_hardreg_ptr, collection_rec.mw_vec),\n+\t\t      collection_rec.mw_vec.address (),\n \t\t      mw_len * sizeof (struct df_mw_hardreg *));\n \t      insn_info->mw_hardregs[mw_len] = NULL;\n \t    }\n \t}\n       /* Get rid of the mw_rec so that df_refs_add_to_chains will\n \t ignore it.  */\n-      VEC_free (df_mw_hardreg_ptr, stack, collection_rec.mw_vec);\n+      collection_rec.mw_vec.release ();\n       df_refs_add_to_chains (&collection_rec, bb, insn);\n-      VEC_free (df_ref, stack, collection_rec.eq_use_vec);\n+      collection_rec.eq_use_vec.release ();\n     }\n   else\n     df_insn_rescan (insn);\n@@ -2367,40 +2358,40 @@ df_ref_compare (const void *r1, const void *r2)\n }\n \n static void\n-df_swap_refs (VEC(df_ref,stack) **ref_vec, int i, int j)\n+df_swap_refs (vec<df_ref, va_stack> *ref_vec, int i, int j)\n {\n-  df_ref tmp = VEC_index (df_ref, *ref_vec, i);\n-  VEC_replace (df_ref, *ref_vec, i, VEC_index (df_ref, *ref_vec, j));\n-  VEC_replace (df_ref, *ref_vec, j, tmp);\n+  df_ref tmp = (*ref_vec)[i];\n+  (*ref_vec)[i] = (*ref_vec)[j];\n+  (*ref_vec)[j] = tmp;\n }\n \n /* Sort and compress a set of refs.  */\n \n static void\n-df_sort_and_compress_refs (VEC(df_ref,stack) **ref_vec)\n+df_sort_and_compress_refs (vec<df_ref, va_stack> *ref_vec)\n {\n   unsigned int count;\n   unsigned int i;\n   unsigned int dist = 0;\n \n-  count = VEC_length (df_ref, *ref_vec);\n+  count = ref_vec->length ();\n \n   /* If there are 1 or 0 elements, there is nothing to do.  */\n   if (count < 2)\n     return;\n   else if (count == 2)\n     {\n-      df_ref r0 = VEC_index (df_ref, *ref_vec, 0);\n-      df_ref r1 = VEC_index (df_ref, *ref_vec, 1);\n+      df_ref r0 = (*ref_vec)[0];\n+      df_ref r1 = (*ref_vec)[1];\n       if (df_ref_compare (&r0, &r1) > 0)\n         df_swap_refs (ref_vec, 0, 1);\n     }\n   else\n     {\n       for (i = 0; i < count - 1; i++)\n \t{\n-\t  df_ref r0 = VEC_index (df_ref, *ref_vec, i);\n-\t  df_ref r1 = VEC_index (df_ref, *ref_vec, i + 1);\n+\t  df_ref r0 = (*ref_vec)[i];\n+\t  df_ref r1 = (*ref_vec)[i + 1];\n \t  if (df_ref_compare (&r0, &r1) >= 0)\n \t    break;\n \t}\n@@ -2413,27 +2404,26 @@ df_sort_and_compress_refs (VEC(df_ref,stack) **ref_vec)\n          of DF_REF_COMPARE.  */\n       if (i == count - 1)\n         return;\n-      VEC_qsort (df_ref, *ref_vec, df_ref_compare);\n+      ref_vec->qsort (df_ref_compare);\n     }\n \n   for (i=0; i<count-dist; i++)\n     {\n       /* Find the next ref that is not equal to the current ref.  */\n       while (i + dist + 1 < count\n-\t     && df_ref_equal_p (VEC_index (df_ref, *ref_vec, i),\n-\t\t\t\tVEC_index (df_ref, *ref_vec, i + dist + 1)))\n+\t     && df_ref_equal_p ((*ref_vec)[i],\n+\t\t\t\t(*ref_vec)[i + dist + 1]))\n \t{\n-\t  df_free_ref (VEC_index (df_ref, *ref_vec, i + dist + 1));\n+\t  df_free_ref ((*ref_vec)[i + dist + 1]);\n \t  dist++;\n \t}\n       /* Copy it down to the next position.  */\n       if (dist && i + dist + 1 < count)\n-\tVEC_replace (df_ref, *ref_vec, i + 1,\n-\t\t     VEC_index (df_ref, *ref_vec, i + dist + 1));\n+\t(*ref_vec)[i + 1] = (*ref_vec)[i + dist + 1];\n     }\n \n   count -= dist;\n-  VEC_truncate (df_ref, *ref_vec, count);\n+  ref_vec->truncate (count);\n }\n \n \n@@ -2487,53 +2477,48 @@ df_mw_compare (const void *m1, const void *m2)\n /* Sort and compress a set of refs.  */\n \n static void\n-df_sort_and_compress_mws (VEC(df_mw_hardreg_ptr,stack) **mw_vec)\n+df_sort_and_compress_mws (vec<df_mw_hardreg_ptr, va_stack> *mw_vec)\n {\n   unsigned int count;\n   struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n   unsigned int i;\n   unsigned int dist = 0;\n \n-  count = VEC_length (df_mw_hardreg_ptr, *mw_vec);\n+  count = mw_vec->length ();\n   if (count < 2)\n     return;\n   else if (count == 2)\n     {\n-      struct df_mw_hardreg *m0 = VEC_index (df_mw_hardreg_ptr, *mw_vec, 0);\n-      struct df_mw_hardreg *m1 = VEC_index (df_mw_hardreg_ptr, *mw_vec, 1);\n+      struct df_mw_hardreg *m0 = (*mw_vec)[0];\n+      struct df_mw_hardreg *m1 = (*mw_vec)[1];\n       if (df_mw_compare (&m0, &m1) > 0)\n         {\n-          struct df_mw_hardreg *tmp = VEC_index (df_mw_hardreg_ptr,\n-\t\t\t\t\t\t *mw_vec, 0);\n-\t  VEC_replace (df_mw_hardreg_ptr, *mw_vec, 0,\n-\t\t       VEC_index (df_mw_hardreg_ptr, *mw_vec, 1));\n-\t  VEC_replace (df_mw_hardreg_ptr, *mw_vec, 1, tmp);\n+          struct df_mw_hardreg *tmp = (*mw_vec)[0];\n+\t  (*mw_vec)[0] = (*mw_vec)[1];\n+\t  (*mw_vec)[1] = tmp;\n         }\n     }\n   else\n-    VEC_qsort (df_mw_hardreg_ptr, *mw_vec, df_mw_compare);\n+    mw_vec->qsort (df_mw_compare);\n \n   for (i=0; i<count-dist; i++)\n     {\n       /* Find the next ref that is not equal to the current ref.  */\n       while (i + dist + 1 < count\n-\t     && df_mw_equal_p (VEC_index (df_mw_hardreg_ptr, *mw_vec, i),\n-\t\t\t       VEC_index (df_mw_hardreg_ptr, *mw_vec,\n-\t\t\t\t\t  i + dist + 1)))\n+\t     && df_mw_equal_p ((*mw_vec)[i], (*mw_vec)[i + dist + 1]))\n \t{\n \t  pool_free (problem_data->mw_reg_pool,\n-\t\t     VEC_index (df_mw_hardreg_ptr, *mw_vec, i + dist + 1));\n+\t\t     (*mw_vec)[i + dist + 1]);\n \t  dist++;\n \t}\n       /* Copy it down to the next position.  */\n       if (dist && i + dist + 1 < count)\n-\tVEC_replace (df_mw_hardreg_ptr, *mw_vec, i + 1,\n-\t\t     VEC_index (df_mw_hardreg_ptr, *mw_vec, i + dist + 1));\n+\t(*mw_vec)[i + 1] = (*mw_vec)[i + dist + 1];\n     }\n \n   count -= dist;\n-  VEC_truncate (df_mw_hardreg_ptr, *mw_vec, count);\n+  mw_vec->truncate (count);\n }\n \n \n@@ -2603,14 +2588,14 @@ df_install_ref (df_ref this_ref,\n \n static df_ref *\n df_install_refs (basic_block bb,\n-\t\t VEC(df_ref,stack)* old_vec,\n+\t\t vec<df_ref, va_stack> old_vec,\n \t\t struct df_reg_info **reg_info,\n \t\t struct df_ref_info *ref_info,\n \t\t bool is_notes)\n {\n   unsigned int count;\n \n-  count = VEC_length (df_ref, old_vec);\n+  count = old_vec.length ();\n   if (count)\n     {\n       df_ref *new_vec = XNEWVEC (df_ref, count + 1);\n@@ -2641,7 +2626,7 @@ df_install_refs (basic_block bb,\n       if (add_to_table && df->analyze_subset)\n \tadd_to_table = bitmap_bit_p (df->blocks_to_analyze, bb->index);\n \n-      FOR_EACH_VEC_ELT (df_ref, old_vec, ix, this_ref)\n+      FOR_EACH_VEC_ELT (old_vec, ix, this_ref)\n \t{\n \t  new_vec[ix] = this_ref;\n \t  df_install_ref (this_ref, reg_info[DF_REF_REGNO (this_ref)],\n@@ -2660,16 +2645,16 @@ df_install_refs (basic_block bb,\n    insn.  */\n \n static struct df_mw_hardreg **\n-df_install_mws (VEC(df_mw_hardreg_ptr,stack) *old_vec)\n+df_install_mws (vec<df_mw_hardreg_ptr, va_stack> old_vec)\n {\n   unsigned int count;\n \n-  count = VEC_length (df_mw_hardreg_ptr, old_vec);\n+  count = old_vec.length ();\n   if (count)\n     {\n       struct df_mw_hardreg **new_vec\n \t= XNEWVEC (struct df_mw_hardreg*, count + 1);\n-      memcpy (new_vec, VEC_address (df_mw_hardreg_ptr, old_vec),\n+      memcpy (new_vec, old_vec.address (),\n \t      sizeof (struct df_mw_hardreg*) * count);\n       new_vec[count] = NULL;\n       return new_vec;\n@@ -2692,31 +2677,31 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n       /* If there is a vector in the collection rec, add it to the\n \t insn.  A null rec is a signal that the caller will handle the\n \t chain specially.  */\n-      if (collection_rec->def_vec)\n+      if (collection_rec->def_vec.exists ())\n \t{\n \t  df_scan_free_ref_vec (insn_rec->defs);\n \t  insn_rec->defs\n \t    = df_install_refs (bb, collection_rec->def_vec,\n \t\t\t       df->def_regs,\n \t\t\t       &df->def_info, false);\n \t}\n-      if (collection_rec->use_vec)\n+      if (collection_rec->use_vec.exists ())\n \t{\n \t  df_scan_free_ref_vec (insn_rec->uses);\n \t  insn_rec->uses\n \t    = df_install_refs (bb, collection_rec->use_vec,\n \t\t\t       df->use_regs,\n \t\t\t       &df->use_info, false);\n \t}\n-      if (collection_rec->eq_use_vec)\n+      if (collection_rec->eq_use_vec.exists ())\n \t{\n \t  df_scan_free_ref_vec (insn_rec->eq_uses);\n \t  insn_rec->eq_uses\n \t    = df_install_refs (bb, collection_rec->eq_use_vec,\n \t\t\t       df->eq_use_regs,\n \t\t\t       &df->use_info, true);\n \t}\n-      if (collection_rec->mw_vec)\n+      if (collection_rec->mw_vec.exists ())\n \t{\n \t  df_scan_free_mws_vec (insn_rec->mw_hardregs);\n \t  insn_rec->mw_hardregs\n@@ -2812,11 +2797,11 @@ df_ref_create_structure (enum df_ref_class cl,\n   if (collection_rec)\n     {\n       if (DF_REF_REG_DEF_P (this_ref))\n-\tVEC_safe_push (df_ref, stack, collection_rec->def_vec, this_ref);\n+\tcollection_rec->def_vec.safe_push (this_ref);\n       else if (DF_REF_FLAGS (this_ref) & DF_REF_IN_NOTE)\n-\tVEC_safe_push (df_ref, stack, collection_rec->eq_use_vec, this_ref);\n+\tcollection_rec->eq_use_vec.safe_push (this_ref);\n       else\n-\tVEC_safe_push (df_ref, stack, collection_rec->use_vec, this_ref);\n+\tcollection_rec->use_vec.safe_push (this_ref);\n     }\n   else\n     df_install_ref_incremental (this_ref);\n@@ -2879,8 +2864,7 @@ df_ref_record (enum df_ref_class cl,\n \t  hardreg->start_regno = regno;\n \t  hardreg->end_regno = endregno - 1;\n \t  hardreg->mw_order = df->ref_order++;\n-\t  VEC_safe_push (df_mw_hardreg_ptr, stack, collection_rec->mw_vec,\n-\t\t\t hardreg);\n+\t  collection_rec->mw_vec.safe_push (hardreg);\n \t}\n \n       for (i = regno; i < endregno; i++)\n@@ -3352,7 +3336,7 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n   unsigned int ix;\n   df_ref ref;\n \n-  FOR_EACH_VEC_ELT (df_ref, collection_rec->def_vec, ix, ref)\n+  FOR_EACH_VEC_ELT (collection_rec->def_vec, ix, ref)\n     {\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_CONDITIONAL))\n         {\n@@ -3458,10 +3442,10 @@ df_insn_refs_collect (struct df_collection_rec *collection_rec,\n   bool is_cond_exec = (GET_CODE (PATTERN (insn_info->insn)) == COND_EXEC);\n \n   /* Clear out the collection record.  */\n-  VEC_truncate (df_ref, collection_rec->def_vec, 0);\n-  VEC_truncate (df_ref, collection_rec->use_vec, 0);\n-  VEC_truncate (df_ref, collection_rec->eq_use_vec, 0);\n-  VEC_truncate (df_mw_hardreg_ptr, collection_rec->mw_vec, 0);\n+  collection_rec->def_vec.truncate (0);\n+  collection_rec->use_vec.truncate (0);\n+  collection_rec->eq_use_vec.truncate (0);\n+  collection_rec->mw_vec.truncate (0);\n \n   /* Process REG_EQUIV/REG_EQUAL notes.  */\n   for (note = REG_NOTES (insn_info->insn); note;\n@@ -3550,10 +3534,10 @@ df_recompute_luids (basic_block bb)\n static void\n df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n {\n-  VEC_truncate (df_ref, collection_rec->def_vec, 0);\n-  VEC_truncate (df_ref, collection_rec->use_vec, 0);\n-  VEC_truncate (df_ref, collection_rec->eq_use_vec, 0);\n-  VEC_truncate (df_mw_hardreg_ptr, collection_rec->mw_vec, 0);\n+  collection_rec->def_vec.truncate (0);\n+  collection_rec->use_vec.truncate (0);\n+  collection_rec->eq_use_vec.truncate (0);\n+  collection_rec->mw_vec.truncate (0);\n \n   if (bb->index == ENTRY_BLOCK)\n     {\n@@ -3622,10 +3606,10 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n     return;\n \n   df_grow_bb_info (df_scan);\n-  collection_rec.def_vec = VEC_alloc (df_ref, stack, 128);\n-  collection_rec.use_vec = VEC_alloc (df_ref, stack, 32);\n-  collection_rec.eq_use_vec = VEC_alloc (df_ref, stack, 32);\n-  collection_rec.mw_vec = VEC_alloc (df_mw_hardreg_ptr, stack, 32);\n+  vec_stack_alloc (df_ref, collection_rec.def_vec, 128);\n+  vec_stack_alloc (df_ref, collection_rec.use_vec, 32);\n+  vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n+  vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n \n   if (scan_insns)\n     /* Scan the block an insn at a time from beginning to end.  */\n@@ -3649,10 +3633,10 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n   df_bb_refs_collect (&collection_rec, bb);\n   df_refs_add_to_chains (&collection_rec, bb, NULL);\n \n-  VEC_free (df_ref, stack, collection_rec.def_vec);\n-  VEC_free (df_ref, stack, collection_rec.use_vec);\n-  VEC_free (df_ref, stack, collection_rec.eq_use_vec);\n-  VEC_free (df_mw_hardreg_ptr, stack, collection_rec.mw_vec);\n+  collection_rec.def_vec.release ();\n+  collection_rec.use_vec.release ();\n+  collection_rec.eq_use_vec.release ();\n+  collection_rec.mw_vec.release ();\n \n   /* Now that the block has been processed, set the block as dirty so\n      LR and LIVE will get it processed.  */\n@@ -3895,12 +3879,12 @@ df_record_entry_block_defs (bitmap entry_block_defs)\n {\n   struct df_collection_rec collection_rec;\n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.def_vec = VEC_alloc (df_ref, stack, FIRST_PSEUDO_REGISTER);\n+  vec_stack_alloc (df_ref, collection_rec.def_vec, FIRST_PSEUDO_REGISTER);\n   df_entry_block_defs_collect (&collection_rec, entry_block_defs);\n \n   /* Process bb_refs chain */\n   df_refs_add_to_chains (&collection_rec, BASIC_BLOCK (ENTRY_BLOCK), NULL);\n-  VEC_free (df_ref, stack, collection_rec.def_vec);\n+  collection_rec.def_vec.release ();\n }\n \n \n@@ -4068,13 +4052,12 @@ df_record_exit_block_uses (bitmap exit_block_uses)\n {\n   struct df_collection_rec collection_rec;\n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.use_vec = VEC_alloc (df_ref, stack, FIRST_PSEUDO_REGISTER);\n-\n+  vec_stack_alloc (df_ref, collection_rec.use_vec, FIRST_PSEUDO_REGISTER);\n   df_exit_block_uses_collect (&collection_rec, exit_block_uses);\n \n   /* Process bb_refs chain */\n   df_refs_add_to_chains (&collection_rec, BASIC_BLOCK (EXIT_BLOCK), NULL);\n-  VEC_free (df_ref, stack, collection_rec.use_vec);\n+  collection_rec.use_vec.release ();\n }\n \n \n@@ -4251,7 +4234,7 @@ df_compute_regs_ever_live (bool reset)\n \n   df_reg_chain_mark (refs, regno, is_def, is_eq_use)\n   df_reg_chain_verify_unmarked (refs)\n-  df_refs_verify (VEC(stack,df_ref)*, ref*, bool)\n+  df_refs_verify (vec<stack, va_df_ref>, ref*, bool)\n   df_mws_verify (mw*, mw*, bool)\n   df_insn_refs_verify (collection_rec, bb, insn, bool)\n   df_bb_refs_verify (bb, refs, bool)\n@@ -4315,13 +4298,13 @@ df_reg_chain_verify_unmarked (df_ref refs)\n /* Verify that NEW_REC and OLD_REC have exactly the same members. */\n \n static bool\n-df_refs_verify (VEC(df_ref,stack) *new_rec, df_ref *old_rec,\n+df_refs_verify (vec<df_ref, va_stack> new_rec, df_ref *old_rec,\n \t\tbool abort_if_fail)\n {\n   unsigned int ix;\n   df_ref new_ref;\n \n-  FOR_EACH_VEC_ELT (df_ref, new_rec, ix, new_ref)\n+  FOR_EACH_VEC_ELT (new_rec, ix, new_ref)\n     {\n       if (*old_rec == NULL || !df_ref_equal_p (new_ref, *old_rec))\n \t{\n@@ -4353,14 +4336,14 @@ df_refs_verify (VEC(df_ref,stack) *new_rec, df_ref *old_rec,\n /* Verify that NEW_REC and OLD_REC have exactly the same members. */\n \n static bool\n-df_mws_verify (VEC(df_mw_hardreg_ptr,stack) *new_rec,\n+df_mws_verify (vec<df_mw_hardreg_ptr, va_stack> new_rec,\n \t       struct df_mw_hardreg **old_rec,\n \t       bool abort_if_fail)\n {\n   unsigned int ix;\n   struct df_mw_hardreg *new_reg;\n \n-  FOR_EACH_VEC_ELT (df_mw_hardreg_ptr, new_rec, ix, new_reg)\n+  FOR_EACH_VEC_ELT (new_rec, ix, new_reg)\n     {\n       if (*old_rec == NULL || !df_mw_equal_p (new_reg, *old_rec))\n \t{\n@@ -4438,10 +4421,10 @@ df_bb_verify (basic_block bb)\n   struct df_collection_rec collection_rec;\n \n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.def_vec = VEC_alloc (df_ref, stack, 128);\n-  collection_rec.use_vec = VEC_alloc (df_ref, stack, 32);\n-  collection_rec.eq_use_vec = VEC_alloc (df_ref, stack, 32);\n-  collection_rec.mw_vec = VEC_alloc (df_mw_hardreg_ptr, stack, 32);\n+  vec_stack_alloc (df_ref, collection_rec.def_vec, 128);\n+  vec_stack_alloc (df_ref, collection_rec.use_vec, 32);\n+  vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n+  vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n \n   gcc_assert (bb_info);\n "}, {"sha": "4168fdea4a5c44f4ccad4fd89be7c91ca8e577c9", "filename": "gcc/dominance.c", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -44,7 +44,6 @@\n #include \"diagnostic-core.h\"\n #include \"et-forest.h\"\n #include \"timevar.h\"\n-#include \"vecprim.h\"\n #include \"pointer-set.h\"\n #include \"graphds.h\"\n #include \"bitmap.h\"\n@@ -741,21 +740,21 @@ set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n \n /* Returns the list of basic blocks immediately dominated by BB, in the\n    direction DIR.  */\n-VEC (basic_block, heap) *\n+vec<basic_block> \n get_dominated_by (enum cdi_direction dir, basic_block bb)\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *node = bb->dom[dir_index], *son = node->son, *ason;\n-  VEC (basic_block, heap) *bbs = NULL;\n+  vec<basic_block> bbs = vec<basic_block>();\n \n   gcc_checking_assert (dom_computed[dir_index]);\n \n   if (!son)\n-    return NULL;\n+    return vec<basic_block>();\n \n-  VEC_safe_push (basic_block, heap, bbs, (basic_block) son->data);\n+  bbs.safe_push ((basic_block) son->data);\n   for (ason = son->right; ason != son; ason = ason->right)\n-    VEC_safe_push (basic_block, heap, bbs, (basic_block) ason->data);\n+    bbs.safe_push ((basic_block) ason->data);\n \n   return bbs;\n }\n@@ -764,13 +763,13 @@ get_dominated_by (enum cdi_direction dir, basic_block bb)\n    direction DIR) by some block between N_REGION ones stored in REGION,\n    except for blocks in the REGION itself.  */\n \n-VEC (basic_block, heap) *\n+vec<basic_block> \n get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n \t\t\t unsigned n_region)\n {\n   unsigned i;\n   basic_block dom;\n-  VEC (basic_block, heap) *doms = NULL;\n+  vec<basic_block> doms = vec<basic_block>();\n \n   for (i = 0; i < n_region; i++)\n     region[i]->flags |= BB_DUPLICATED;\n@@ -779,7 +778,7 @@ get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n \t dom;\n \t dom = next_dom_son (dir, dom))\n       if (!(dom->flags & BB_DUPLICATED))\n-\tVEC_safe_push (basic_block, heap, doms, dom);\n+\tdoms.safe_push (dom);\n   for (i = 0; i < n_region; i++)\n     region[i]->flags &= ~BB_DUPLICATED;\n \n@@ -791,29 +790,29 @@ get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n    produce a vector containing all dominated blocks.  The vector will be sorted\n    in preorder.  */\n \n-VEC (basic_block, heap) *\n+vec<basic_block> \n get_dominated_to_depth (enum cdi_direction dir, basic_block bb, int depth)\n {\n-  VEC(basic_block, heap) *bbs = NULL;\n+  vec<basic_block> bbs = vec<basic_block>();\n   unsigned i;\n   unsigned next_level_start;\n \n   i = 0;\n-  VEC_safe_push (basic_block, heap, bbs, bb);\n-  next_level_start = 1; /* = VEC_length (basic_block, bbs); */\n+  bbs.safe_push (bb);\n+  next_level_start = 1; /* = bbs.length (); */\n \n   do\n     {\n       basic_block son;\n \n-      bb = VEC_index (basic_block, bbs, i++);\n+      bb = bbs[i++];\n       for (son = first_dom_son (dir, bb);\n \t   son;\n \t   son = next_dom_son (dir, son))\n-\tVEC_safe_push (basic_block, heap, bbs, son);\n+\tbbs.safe_push (son);\n \n       if (i == next_level_start && --depth)\n-\tnext_level_start = VEC_length (basic_block, bbs);\n+\tnext_level_start = bbs.length ();\n     }\n   while (i < next_level_start);\n \n@@ -823,7 +822,7 @@ get_dominated_to_depth (enum cdi_direction dir, basic_block bb, int depth)\n /* Returns the list of basic blocks including BB dominated by BB, in the\n    direction DIR.  The vector will be sorted in preorder.  */\n \n-VEC (basic_block, heap) *\n+vec<basic_block> \n get_all_dominated_blocks (enum cdi_direction dir, basic_block bb)\n {\n   return get_dominated_to_depth (dir, bb, 0);\n@@ -1088,7 +1087,7 @@ recompute_dominator (enum cdi_direction dir, basic_block bb)\n    from BBS.  */\n \n static void\n-prune_bbs_to_update_dominators (VEC (basic_block, heap) *bbs,\n+prune_bbs_to_update_dominators (vec<basic_block> bbs,\n \t\t\t\tbool conservative)\n {\n   unsigned i;\n@@ -1097,7 +1096,7 @@ prune_bbs_to_update_dominators (VEC (basic_block, heap) *bbs,\n   edge_iterator ei;\n   edge e;\n \n-  for (i = 0; VEC_iterate (basic_block, bbs, i, bb);)\n+  for (i = 0; bbs.iterate (i, &bb);)\n     {\n       if (bb == ENTRY_BLOCK_PTR)\n \tgoto succeed;\n@@ -1140,7 +1139,7 @@ prune_bbs_to_update_dominators (VEC (basic_block, heap) *bbs,\n       continue;\n \n succeed:\n-      VEC_unordered_remove (basic_block, bbs, i);\n+      bbs.unordered_remove (i);\n     }\n }\n \n@@ -1159,28 +1158,28 @@ root_of_dom_tree (enum cdi_direction dir, basic_block bb)\n    blocks.  */\n \n static void\n-determine_dominators_for_sons (struct graph *g, VEC (basic_block, heap) *bbs,\n+determine_dominators_for_sons (struct graph *g, vec<basic_block> bbs,\n \t\t\t       int y, int *son, int *brother)\n {\n   bitmap gprime;\n   int i, a, nc;\n-  VEC (int, heap) **sccs;\n+  vec<int> *sccs;\n   basic_block bb, dom, ybb;\n   unsigned si;\n   edge e;\n   edge_iterator ei;\n \n   if (son[y] == -1)\n     return;\n-  if (y == (int) VEC_length (basic_block, bbs))\n+  if (y == (int) bbs.length ())\n     ybb = ENTRY_BLOCK_PTR;\n   else\n-    ybb = VEC_index (basic_block, bbs, y);\n+    ybb = bbs[y];\n \n   if (brother[son[y]] == -1)\n     {\n       /* Handle the common case Y has just one son specially.  */\n-      bb = VEC_index (basic_block, bbs, son[y]);\n+      bb = bbs[son[y]];\n       set_immediate_dominator (CDI_DOMINATORS, bb,\n \t\t\t       recompute_dominator (CDI_DOMINATORS, bb));\n       identify_vertices (g, y, son[y]);\n@@ -1194,16 +1193,19 @@ determine_dominators_for_sons (struct graph *g, VEC (basic_block, heap) *bbs,\n   nc = graphds_scc (g, gprime);\n   BITMAP_FREE (gprime);\n \n-  sccs = XCNEWVEC (VEC (int, heap) *, nc);\n+  /* ???  Needed to work around the pre-processor confusion with\n+     using a multi-argument template type as macro argument.  */\n+  typedef vec<int> vec_int_heap;\n+  sccs = XCNEWVEC (vec_int_heap, nc);\n   for (a = son[y]; a != -1; a = brother[a])\n-    VEC_safe_push (int, heap, sccs[g->vertices[a].component], a);\n+    sccs[g->vertices[a].component].safe_push (a);\n \n   for (i = nc - 1; i >= 0; i--)\n     {\n       dom = NULL;\n-      FOR_EACH_VEC_ELT (int, sccs[i], si, a)\n+      FOR_EACH_VEC_ELT (sccs[i], si, a)\n \t{\n-\t  bb = VEC_index (basic_block, bbs, a);\n+\t  bb = bbs[a];\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n \t      if (root_of_dom_tree (CDI_DOMINATORS, e->src) != ybb)\n@@ -1214,15 +1216,15 @@ determine_dominators_for_sons (struct graph *g, VEC (basic_block, heap) *bbs,\n \t}\n \n       gcc_assert (dom != NULL);\n-      FOR_EACH_VEC_ELT (int, sccs[i], si, a)\n+      FOR_EACH_VEC_ELT (sccs[i], si, a)\n \t{\n-\t  bb = VEC_index (basic_block, bbs, a);\n+\t  bb = bbs[a];\n \t  set_immediate_dominator (CDI_DOMINATORS, bb, dom);\n \t}\n     }\n \n   for (i = 0; i < nc; i++)\n-    VEC_free (int, heap, sccs[i]);\n+    sccs[i].release ();\n   free (sccs);\n \n   for (a = son[y]; a != -1; a = brother[a])\n@@ -1237,7 +1239,7 @@ determine_dominators_for_sons (struct graph *g, VEC (basic_block, heap) *bbs,\n    a block of BBS in the current dominance tree dominate it.  */\n \n void\n-iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n+iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n \t\t\tbool conservative)\n {\n   unsigned i;\n@@ -1316,27 +1318,27 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n \t conservatively correct, setting the dominators using the\n \t heuristics in prune_bbs_to_update_dominators could\n \t create cycles in the dominance \"tree\", and cause ICE.  */\n-      FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n+      FOR_EACH_VEC_ELT (bbs, i, bb)\n \tset_immediate_dominator (CDI_DOMINATORS, bb, NULL);\n     }\n \n   prune_bbs_to_update_dominators (bbs, conservative);\n-  n = VEC_length (basic_block, bbs);\n+  n = bbs.length ();\n \n   if (n == 0)\n     return;\n \n   if (n == 1)\n     {\n-      bb = VEC_index (basic_block, bbs, 0);\n+      bb = bbs[0];\n       set_immediate_dominator (CDI_DOMINATORS, bb,\n \t\t\t       recompute_dominator (CDI_DOMINATORS, bb));\n       return;\n     }\n \n   /* Construct the graph G.  */\n   map = pointer_map_create ();\n-  FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n+  FOR_EACH_VEC_ELT (bbs, i, bb)\n     {\n       /* If the dominance tree is conservatively correct, split it now.  */\n       if (conservative)\n@@ -1348,7 +1350,7 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n   g = new_graph (n + 1);\n   for (y = 0; y < g->n_vertices; y++)\n     g->vertices[y].data = BITMAP_ALLOC (NULL);\n-  FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n+  FOR_EACH_VEC_ELT (bbs, i, bb)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{"}, {"sha": "c81d58da32fabd54a265279c83cd30a62d4022fb", "filename": "gcc/domwalk.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -162,9 +162,9 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \n \t      /* First get some local data, reusing any local data\n \t\t pointer we may have saved.  */\n-\t      if (VEC_length (void_p, walk_data->free_block_data) > 0)\n+\t      if (walk_data->free_block_data.length () > 0)\n \t\t{\n-\t\t  bd = VEC_pop (void_p, walk_data->free_block_data);\n+\t\t  bd = walk_data->free_block_data.pop ();\n \t\t  recycled = 1;\n \t\t}\n \t      else\n@@ -174,7 +174,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t\t}\n \n \t      /* Push the local data into the local data stack.  */\n-\t      VEC_safe_push (void_p, heap, walk_data->block_data_stack, bd);\n+\t      walk_data->block_data_stack.safe_push (bd);\n \n \t      /* Call the initializer.  */\n \t      walk_data->initialize_block_local_data (walk_data, bb,\n@@ -212,9 +212,9 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  if (walk_data->initialize_block_local_data)\n \t    {\n \t      /* And finally pop the record off the block local data stack.  */\n-\t      bd = VEC_pop (void_p, walk_data->block_data_stack);\n+\t      bd = walk_data->block_data_stack.pop ();\n \t      /* And save the block data so that we can re-use it.  */\n-\t      VEC_safe_push (void_p, heap, walk_data->free_block_data, bd);\n+\t      walk_data->free_block_data.safe_push (bd);\n \t    }\n \t}\n       if (sp)\n@@ -261,19 +261,19 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n void\n init_walk_dominator_tree (struct dom_walk_data *walk_data)\n {\n-  walk_data->free_block_data = NULL;\n-  walk_data->block_data_stack = NULL;\n+  walk_data->free_block_data.create (0);\n+  walk_data->block_data_stack.create (0);\n }\n \n void\n fini_walk_dominator_tree (struct dom_walk_data *walk_data)\n {\n   if (walk_data->initialize_block_local_data)\n     {\n-      while (VEC_length (void_p, walk_data->free_block_data) > 0)\n-\tfree (VEC_pop (void_p, walk_data->free_block_data));\n+      while (walk_data->free_block_data.length () > 0)\n+\tfree (walk_data->free_block_data.pop ());\n     }\n \n-  VEC_free (void_p, heap, walk_data->free_block_data);\n-  VEC_free (void_p, heap, walk_data->block_data_stack);\n+  walk_data->free_block_data.release ();\n+  walk_data->block_data_stack.release ();\n }"}, {"sha": "e0c11f65d727665500b19a44390a5b468c5d9e33", "filename": "gcc/domwalk.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -19,8 +19,6 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n typedef void *void_p;\n-DEF_VEC_P(void_p);\n-DEF_VEC_ALLOC_P(void_p,heap);\n \n /* This is the main data structure for the dominator walker.  It provides\n    the callback hooks as well as a convenient place to hang block local\n@@ -58,7 +56,7 @@ struct dom_walk_data\n   /* Stack of any data we need to keep on a per-block basis.\n \n      If you have no local data, then BLOCK_DATA_STACK will be NULL.  */\n-  VEC(void_p,heap) *block_data_stack;\n+  vec<void_p> block_data_stack;\n \n   /* Size of the block local data.   If this is zero, then it is assumed\n      you have no local data and thus no BLOCK_DATA_STACK as well.  */\n@@ -68,7 +66,7 @@ struct dom_walk_data\n      information/data outside domwalk.c.  */\n \n   /* Stack of available block local structures.  */\n-  VEC(void_p,heap) *free_block_data;\n+  vec<void_p> free_block_data;\n };\n \n void walk_dominator_tree (struct dom_walk_data *, basic_block);"}, {"sha": "c7883f0138b6f3e2685747cff5e1bd8f44047073", "filename": "gcc/dse.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -550,10 +550,8 @@ static alloc_pool rtx_group_info_pool;\n /* Index into the rtx_group_vec.  */\n static int rtx_group_next_id;\n \n-DEF_VEC_P(group_info_t);\n-DEF_VEC_ALLOC_P(group_info_t,heap);\n \n-static VEC(group_info_t,heap) *rtx_group_vec;\n+static vec<group_info_t> rtx_group_vec;\n \n \n /* This structure holds the set of changes that are being deferred\n@@ -715,7 +713,7 @@ get_group_info (rtx base)\n \t  gi->offset_map_size_p = 0;\n \t  gi->offset_map_n = NULL;\n \t  gi->offset_map_p = NULL;\n-\t  VEC_safe_push (group_info_t, heap, rtx_group_vec, gi);\n+\t  rtx_group_vec.safe_push (gi);\n \t}\n       return clear_alias_group;\n     }\n@@ -741,7 +739,7 @@ get_group_info (rtx base)\n       gi->offset_map_size_p = 0;\n       gi->offset_map_n = NULL;\n       gi->offset_map_p = NULL;\n-      VEC_safe_push (group_info_t, heap, rtx_group_vec, gi);\n+      rtx_group_vec.safe_push (gi);\n     }\n \n   return gi;\n@@ -1527,7 +1525,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t frame pointer we can do global analysis.  */\n \n       group_info_t group\n-\t= VEC_index (group_info_t, rtx_group_vec, group_id);\n+\t= rtx_group_vec[group_id];\n       tree expr = MEM_EXPR (mem);\n \n       store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n@@ -1597,7 +1595,7 @@ record_store (rtx body, bb_info_t bb_info)\n       else\n \t{\n \t  group_info_t group\n-\t    = VEC_index (group_info_t, rtx_group_vec, group_id);\n+\t    = rtx_group_vec[group_id];\n \t  mem_addr = group->canon_base_addr;\n \t}\n       if (offset)\n@@ -2214,7 +2212,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n       else\n \t{\n \t  group_info_t group\n-\t    = VEC_index (group_info_t, rtx_group_vec, group_id);\n+\t    = rtx_group_vec[group_id];\n \t  mem_addr = group->canon_base_addr;\n \t}\n       if (offset)\n@@ -2598,8 +2596,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n \t\t    store_info = store_info->next;\n \n \t\t  if (store_info->group_id >= 0\n-\t\t      && VEC_index (group_info_t, rtx_group_vec,\n-\t\t\t\t    store_info->group_id)->frame_related)\n+\t\t      && rtx_group_vec[store_info->group_id]->frame_related)\n \t\t    remove_store = true;\n \t\t}\n \n@@ -2826,7 +2823,7 @@ dse_step1 (void)\n \t\t    if (store_info->group_id >= 0)\n \t\t      {\n \t\t\tgroup_info_t group\n-\t\t\t  = VEC_index (group_info_t, rtx_group_vec, store_info->group_id);\n+\t\t\t  = rtx_group_vec[store_info->group_id];\n \t\t\tif (group->frame_related && !i_ptr->cannot_delete)\n \t\t\t  delete_dead_store_insn (i_ptr);\n \t\t      }\n@@ -2917,7 +2914,7 @@ dse_step2_init (void)\n   unsigned int i;\n   group_info_t group;\n \n-  FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n+  FOR_EACH_VEC_ELT (rtx_group_vec, i, group)\n     {\n       /* For all non stack related bases, we only consider a store to\n \t be deletable if there are two or more stores for that\n@@ -2970,7 +2967,7 @@ dse_step2_nospill (void)\n   /* Position 0 is unused because 0 is used in the maps to mean\n      unused.  */\n   current_position = 1;\n-  FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n+  FOR_EACH_VEC_ELT (rtx_group_vec, i, group)\n     {\n       bitmap_iterator bi;\n       unsigned int j;\n@@ -3084,7 +3081,7 @@ scan_stores_nospill (store_info_t store_info, bitmap gen, bitmap kill)\n     {\n       HOST_WIDE_INT i;\n       group_info_t group_info\n-\t= VEC_index (group_info_t, rtx_group_vec, store_info->group_id);\n+\t= rtx_group_vec[store_info->group_id];\n       if (group_info->process_globally)\n \tfor (i = store_info->begin; i < store_info->end; i++)\n \t  {\n@@ -3138,7 +3135,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n   /* If this insn reads the frame, kill all the frame related stores.  */\n   if (insn_info->frame_read)\n     {\n-      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n+      FOR_EACH_VEC_ELT (rtx_group_vec, i, group)\n \tif (group->process_globally && group->frame_related)\n \t  {\n \t    if (kill)\n@@ -3153,7 +3150,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n       if (kill)\n         bitmap_ior_into (kill, kill_on_calls);\n       bitmap_and_compl_into (gen, kill_on_calls);\n-      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n+      FOR_EACH_VEC_ELT (rtx_group_vec, i, group)\n \tif (group->process_globally && !group->frame_related)\n \t  {\n \t    if (kill)\n@@ -3163,7 +3160,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n     }\n   while (read_info)\n     {\n-      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n+      FOR_EACH_VEC_ELT (rtx_group_vec, i, group)\n \t{\n \t  if (group->process_globally)\n \t    {\n@@ -3343,7 +3340,7 @@ dse_step3_exit_block_scan (bb_info_t bb_info)\n       unsigned int i;\n       group_info_t group;\n \n-      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n+      FOR_EACH_VEC_ELT (rtx_group_vec, i, group)\n \t{\n \t  if (group->process_globally && group->frame_related)\n \t    bitmap_ior_into (bb_info->gen, group->group_kill);\n@@ -3425,7 +3422,7 @@ dse_step3 (bool for_spills)\n \t      group_info_t group;\n \n \t      all_ones = BITMAP_ALLOC (&dse_bitmap_obstack);\n-\t      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, j, group)\n+\t      FOR_EACH_VEC_ELT (rtx_group_vec, j, group)\n \t\tbitmap_ior_into (all_ones, group->group_kill);\n \t    }\n \t  if (!bb_info->out)\n@@ -3641,7 +3638,7 @@ dse_step5_nospill (void)\n \t\t{\n \t\t  HOST_WIDE_INT i;\n \t\t  group_info_t group_info\n-\t\t    = VEC_index (group_info_t, rtx_group_vec, store_info->group_id);\n+\t\t    = rtx_group_vec[store_info->group_id];\n \n \t\t  for (i = store_info->begin; i < store_info->end; i++)\n \t\t    {\n@@ -3840,7 +3837,7 @@ dse_step7 (void)\n   end_alias_analysis ();\n   free (bb_table);\n   rtx_group_table.dispose ();\n-  VEC_free (group_info_t, heap, rtx_group_vec);\n+  rtx_group_vec.release ();\n   BITMAP_FREE (all_blocks);\n   BITMAP_FREE (scratch);\n "}, {"sha": "3454b1da10ac2a4c7d7bf848e5d288689e6be824", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 64, "deletions": 80, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -78,8 +78,6 @@ typedef struct GTY(()) reg_saved_in_data_struct {\n   rtx saved_in_reg;\n } reg_saved_in_data;\n \n-DEF_VEC_O (reg_saved_in_data);\n-DEF_VEC_ALLOC_O (reg_saved_in_data, heap);\n \n /* Since we no longer have a proper CFG, we're going to create a facsimile\n    of one on the fly while processing the frame-related insns.\n@@ -141,7 +139,7 @@ typedef struct\n      implemented as a flat array because it normally contains zero or 1\n      entry, depending on the target.  IA-64 is the big spender here, using\n      a maximum of 5 entries.  */\n-  VEC(reg_saved_in_data, heap) *regs_saved_in_regs;\n+  vec<reg_saved_in_data> regs_saved_in_regs;\n \n   /* An identifier for this trace.  Used only for debugging dumps.  */\n   unsigned id;\n@@ -153,17 +151,13 @@ typedef struct\n   bool args_size_undefined;\n } dw_trace_info;\n \n-DEF_VEC_O (dw_trace_info);\n-DEF_VEC_ALLOC_O (dw_trace_info, heap);\n \n typedef dw_trace_info *dw_trace_info_ref;\n \n-DEF_VEC_P (dw_trace_info_ref);\n-DEF_VEC_ALLOC_P (dw_trace_info_ref, heap);\n \n /* The variables making up the pseudo-cfg, as described above.  */\n-static VEC (dw_trace_info, heap) *trace_info;\n-static VEC (dw_trace_info_ref, heap) *trace_work_list;\n+static vec<dw_trace_info> trace_info;\n+static vec<dw_trace_info_ref> trace_work_list;\n static htab_t trace_index;\n \n /* A vector of call frame insns for the CIE.  */\n@@ -203,10 +197,8 @@ typedef struct {\n   HOST_WIDE_INT cfa_offset;\n } queued_reg_save;\n \n-DEF_VEC_O (queued_reg_save);\n-DEF_VEC_ALLOC_O (queued_reg_save, heap);\n \n-static VEC(queued_reg_save, heap) *queued_reg_saves;\n+static vec<queued_reg_save> queued_reg_saves;\n \n /* True if any CFI directives were emitted at the current insn.  */\n static bool any_cfis_emitted;\n@@ -383,7 +375,7 @@ copy_cfi_row (dw_cfi_row *src)\n   dw_cfi_row *dst = ggc_alloc_dw_cfi_row ();\n \n   *dst = *src;\n-  dst->reg_save = VEC_copy (dw_cfi_ref, gc, src->reg_save);\n+  dst->reg_save = vec_safe_copy (src->reg_save);\n \n   return dst;\n }\n@@ -415,7 +407,7 @@ add_cfi (dw_cfi_ref cfi)\n     }\n \n   if (add_cfi_vec != NULL)\n-    VEC_safe_push (dw_cfi_ref, gc, *add_cfi_vec, cfi);\n+    vec_safe_push (*add_cfi_vec, cfi);\n }\n \n static void\n@@ -450,9 +442,9 @@ add_cfi_restore (unsigned reg)\n static void\n update_row_reg_save (dw_cfi_row *row, unsigned column, dw_cfi_ref cfi)\n {\n-  if (VEC_length (dw_cfi_ref, row->reg_save) <= column)\n-    VEC_safe_grow_cleared (dw_cfi_ref, gc, row->reg_save, column + 1);\n-  VEC_replace (dw_cfi_ref, row->reg_save, column, cfi);\n+  if (vec_safe_length (row->reg_save) <= column)\n+    vec_safe_grow_cleared (row->reg_save, column + 1);\n+  (*row->reg_save)[column] = cfi;\n }\n \n /* This function fills in aa dw_cfa_location structure from a dwarf location\n@@ -677,18 +669,18 @@ cfi_row_equal_p (dw_cfi_row *a, dw_cfi_row *b)\n   else if (!cfa_equal_p (&a->cfa, &b->cfa))\n     return false;\n \n-  n_a = VEC_length (dw_cfi_ref, a->reg_save);\n-  n_b = VEC_length (dw_cfi_ref, b->reg_save);\n+  n_a = vec_safe_length (a->reg_save);\n+  n_b = vec_safe_length (b->reg_save);\n   n_max = MAX (n_a, n_b);\n \n   for (i = 0; i < n_max; ++i)\n     {\n       dw_cfi_ref r_a = NULL, r_b = NULL;\n \n       if (i < n_a)\n-\tr_a = VEC_index (dw_cfi_ref, a->reg_save, i);\n+\tr_a = (*a->reg_save)[i];\n       if (i < n_b)\n-\tr_b = VEC_index (dw_cfi_ref, b->reg_save, i);\n+\tr_b = (*b->reg_save)[i];\n \n       if (!cfi_equal_p (r_a, r_b))\n         return false;\n@@ -927,12 +919,11 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n   reg_saved_in_data *elt;\n   size_t i;\n \n-  FOR_EACH_VEC_ELT (reg_saved_in_data, cur_trace->regs_saved_in_regs, i, elt)\n+  FOR_EACH_VEC_ELT (cur_trace->regs_saved_in_regs, i, elt)\n     if (compare_reg_or_pc (elt->orig_reg, src))\n       {\n \tif (dest == NULL)\n-\t  VEC_unordered_remove (reg_saved_in_data,\n-\t\t\t        cur_trace->regs_saved_in_regs, i);\n+\t  cur_trace->regs_saved_in_regs.unordered_remove (i);\n \telse\n \t  elt->saved_in_reg = dest;\n \treturn;\n@@ -942,7 +933,7 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n     return;\n \n   reg_saved_in_data e = {src, dest};\n-  VEC_safe_push (reg_saved_in_data, heap, cur_trace->regs_saved_in_regs, e);\n+  cur_trace->regs_saved_in_regs.safe_push (e);\n }\n \n /* Add an entry to QUEUED_REG_SAVES saying that REG is now saved at\n@@ -957,14 +948,14 @@ queue_reg_save (rtx reg, rtx sreg, HOST_WIDE_INT offset)\n \n   /* Duplicates waste space, but it's also necessary to remove them\n      for correctness, since the queue gets output in reverse order.  */\n-  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, i, q)\n+  FOR_EACH_VEC_ELT (queued_reg_saves, i, q)\n     if (compare_reg_or_pc (q->reg, reg))\n       {\n \t*q = e;\n \treturn;\n       }\n \n-  VEC_safe_push (queued_reg_save, heap, queued_reg_saves, e);\n+  queued_reg_saves.safe_push (e);\n }\n \n /* Output all the entries in QUEUED_REG_SAVES.  */\n@@ -975,7 +966,7 @@ dwarf2out_flush_queued_reg_saves (void)\n   queued_reg_save *q;\n   size_t i;\n \n-  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, i, q)\n+  FOR_EACH_VEC_ELT (queued_reg_saves, i, q)\n     {\n       unsigned int reg, sreg;\n \n@@ -992,7 +983,7 @@ dwarf2out_flush_queued_reg_saves (void)\n       reg_save (reg, sreg, q->cfa_offset);\n     }\n \n-  VEC_truncate (queued_reg_save, queued_reg_saves, 0);\n+  queued_reg_saves.truncate (0);\n }\n \n /* Does INSN clobber any register which QUEUED_REG_SAVES lists a saved\n@@ -1006,16 +997,15 @@ clobbers_queued_reg_save (const_rtx insn)\n   queued_reg_save *q;\n   size_t iq;\n \n-  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, iq, q)\n+  FOR_EACH_VEC_ELT (queued_reg_saves, iq, q)\n     {\n       size_t ir;\n       reg_saved_in_data *rir;\n \n       if (modified_in_p (q->reg, insn))\n \treturn true;\n \n-      FOR_EACH_VEC_ELT (reg_saved_in_data,\n-\t\t\tcur_trace->regs_saved_in_regs, ir, rir)\n+      FOR_EACH_VEC_ELT (cur_trace->regs_saved_in_regs, ir, rir)\n \tif (compare_reg_or_pc (q->reg, rir->orig_reg)\n \t    && modified_in_p (rir->saved_in_reg, insn))\n \t  return true;\n@@ -1034,11 +1024,11 @@ reg_saved_in (rtx reg)\n   reg_saved_in_data *rir;\n   size_t i;\n \n-  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, i, q)\n+  FOR_EACH_VEC_ELT (queued_reg_saves, i, q)\n     if (q->saved_reg && regn == REGNO (q->saved_reg))\n       return q->reg;\n \n-  FOR_EACH_VEC_ELT (reg_saved_in_data, cur_trace->regs_saved_in_regs, i, rir)\n+  FOR_EACH_VEC_ELT (cur_trace->regs_saved_in_regs, i, rir)\n     if (regn == REGNO (rir->saved_in_reg))\n       return rir->orig_reg;\n \n@@ -2049,18 +2039,18 @@ change_cfi_row (dw_cfi_row *old_row, dw_cfi_row *new_row)\n \tadd_cfi (cfi);\n     }\n \n-  n_old = VEC_length (dw_cfi_ref, old_row->reg_save);\n-  n_new = VEC_length (dw_cfi_ref, new_row->reg_save);\n+  n_old = vec_safe_length (old_row->reg_save);\n+  n_new = vec_safe_length (new_row->reg_save);\n   n_max = MAX (n_old, n_new);\n \n   for (i = 0; i < n_max; ++i)\n     {\n       dw_cfi_ref r_old = NULL, r_new = NULL;\n \n       if (i < n_old)\n-\tr_old = VEC_index (dw_cfi_ref, old_row->reg_save, i);\n+\tr_old = (*old_row->reg_save)[i];\n       if (i < n_new)\n-\tr_new = VEC_index (dw_cfi_ref, new_row->reg_save, i);\n+\tr_new = (*new_row->reg_save)[i];\n \n       if (r_old == r_new)\n \t;\n@@ -2124,8 +2114,7 @@ add_cfis_to_fde (void)\n \n       if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n \t{\n-\t  fde->dw_fde_switch_cfi_index\n-\t    = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n+\t  fde->dw_fde_switch_cfi_index = vec_safe_length (fde->dw_fde_cfi);\n \t  /* Don't attempt to advance_loc4 between labels\n \t     in different sections.  */\n \t  first = true;\n@@ -2158,7 +2147,7 @@ add_cfis_to_fde (void)\n \t      xcfi->dw_cfi_opc = (first ? DW_CFA_set_loc\n \t\t\t\t  : DW_CFA_advance_loc4);\n \t      xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n-\t      VEC_safe_push (dw_cfi_ref, gc, fde->dw_fde_cfi, xcfi);\n+\t      vec_safe_push (fde->dw_fde_cfi, xcfi);\n \n \t      tmp = emit_note_before (NOTE_INSN_CFI_LABEL, insn);\n \t      NOTE_LABEL_NUMBER (tmp) = num;\n@@ -2167,8 +2156,7 @@ add_cfis_to_fde (void)\n \t  do\n \t    {\n \t      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_CFI)\n-\t\tVEC_safe_push (dw_cfi_ref, gc, fde->dw_fde_cfi,\n-\t\t\t       NOTE_CFI (insn));\n+\t\tvec_safe_push (fde->dw_fde_cfi, NOTE_CFI (insn));\n \t      insn = NEXT_INSN (insn);\n \t    }\n \t  while (insn != next);\n@@ -2207,10 +2195,9 @@ maybe_record_trace_start (rtx start, rtx origin)\n \n       ti->cfa_store = cur_trace->cfa_store;\n       ti->cfa_temp = cur_trace->cfa_temp;\n-      ti->regs_saved_in_regs = VEC_copy (reg_saved_in_data, heap,\n-\t\t\t\t\t cur_trace->regs_saved_in_regs);\n+      ti->regs_saved_in_regs = cur_trace->regs_saved_in_regs.copy ();\n \n-      VEC_safe_push (dw_trace_info_ref, heap, trace_work_list, ti);\n+      trace_work_list.safe_push (ti);\n \n       if (dump_file)\n \tfprintf (dump_file, \"\\tpush trace %u to worklist\\n\", ti->id);\n@@ -2391,7 +2378,7 @@ scan_trace (dw_trace_info *trace)\n       if (BARRIER_P (insn))\n \t{\n \t  /* Don't bother saving the unneeded queued registers at all.  */\n-\t  VEC_truncate (queued_reg_save, queued_reg_saves, 0);\n+\t  queued_reg_saves.truncate (0);\n \t  break;\n \t}\n       if (save_point_p (insn))\n@@ -2438,13 +2425,12 @@ scan_trace (dw_trace_info *trace)\n \t\t  add_cfi_insn = NULL;\n \t\t  restore_args_size = cur_trace->end_true_args_size;\n \t\t  cur_cfa = &cur_row->cfa;\n-\t\t  save_row_reg_save\n-\t\t    = VEC_copy (dw_cfi_ref, gc, cur_row->reg_save);\n+\t\t  save_row_reg_save = vec_safe_copy (cur_row->reg_save);\n \n \t\t  scan_insn_after (elt);\n \n \t\t  /* ??? Should we instead save the entire row state?  */\n-\t\t  gcc_assert (!VEC_length (queued_reg_save, queued_reg_saves));\n+\t\t  gcc_assert (!queued_reg_saves.length ());\n \n \t\t  create_trace_edges (control);\n \n@@ -2543,21 +2529,21 @@ create_cfi_notes (void)\n {\n   dw_trace_info *ti;\n \n-  gcc_checking_assert (queued_reg_saves == NULL);\n-  gcc_checking_assert (trace_work_list == NULL);\n+  gcc_checking_assert (!queued_reg_saves.exists ());\n+  gcc_checking_assert (!trace_work_list.exists ());\n \n   /* Always begin at the entry trace.  */\n-  ti = &VEC_index (dw_trace_info, trace_info, 0);\n+  ti = &trace_info[0];\n   scan_trace (ti);\n \n-  while (!VEC_empty (dw_trace_info_ref, trace_work_list))\n+  while (!trace_work_list.is_empty ())\n     {\n-      ti = VEC_pop (dw_trace_info_ref, trace_work_list);\n+      ti = trace_work_list.pop ();\n       scan_trace (ti);\n     }\n \n-  VEC_free (queued_reg_save, heap, queued_reg_saves);\n-  VEC_free (dw_trace_info_ref, heap, trace_work_list);\n+  queued_reg_saves.release ();\n+  trace_work_list.release ();\n }\n \n /* Return the insn before the first NOTE_INSN_CFI after START.  */\n@@ -2581,7 +2567,7 @@ before_next_cfi_note (rtx start)\n static void\n connect_traces (void)\n {\n-  unsigned i, n = VEC_length (dw_trace_info, trace_info);\n+  unsigned i, n = trace_info.length ();\n   dw_trace_info *prev_ti, *ti;\n \n   /* ??? Ideally, we should have both queued and processed every trace.\n@@ -2594,10 +2580,10 @@ connect_traces (void)\n   /* Remove all unprocessed traces from the list.  */\n   for (i = n - 1; i > 0; --i)\n     {\n-      ti = &VEC_index (dw_trace_info, trace_info, i);\n+      ti = &trace_info[i];\n       if (ti->beg_row == NULL)\n \t{\n-\t  VEC_ordered_remove (dw_trace_info, trace_info, i);\n+\t  trace_info.ordered_remove (i);\n \t  n -= 1;\n \t}\n       else\n@@ -2606,13 +2592,13 @@ connect_traces (void)\n \n   /* Work from the end back to the beginning.  This lets us easily insert\n      remember/restore_state notes in the correct order wrt other notes.  */\n-  prev_ti = &VEC_index (dw_trace_info, trace_info, n - 1);\n+  prev_ti = &trace_info[n - 1];\n   for (i = n - 1; i > 0; --i)\n     {\n       dw_cfi_row *old_row;\n \n       ti = prev_ti;\n-      prev_ti = &VEC_index (dw_trace_info, trace_info, i - 1);\n+      prev_ti = &trace_info[i - 1];\n \n       add_cfi_insn = ti->head;\n \n@@ -2677,13 +2663,13 @@ connect_traces (void)\n     }\n \n   /* Connect args_size between traces that have can_throw_internal insns.  */\n-  if (cfun->eh->lp_array != NULL)\n+  if (cfun->eh->lp_array)\n     {\n       HOST_WIDE_INT prev_args_size = 0;\n \n       for (i = 0; i < n; ++i)\n \t{\n-\t  ti = &VEC_index (dw_trace_info, trace_info, i);\n+\t  ti = &trace_info[i];\n \n \t  if (ti->switch_sections)\n \t    prev_args_size = 0;\n@@ -2716,17 +2702,16 @@ create_pseudo_cfg (void)\n \n   /* The first trace begins at the start of the function,\n      and begins with the CIE row state.  */\n-  trace_info = VEC_alloc (dw_trace_info, heap, 16);\n+  trace_info.create (16);\n   memset (&ti, 0, sizeof (ti));\n   ti.head = get_insns ();\n   ti.beg_row = cie_cfi_row;\n   ti.cfa_store = cie_cfi_row->cfa;\n   ti.cfa_temp.reg = INVALID_REGNUM;\n-  VEC_quick_push (dw_trace_info, trace_info, ti);\n+  trace_info.quick_push (ti);\n \n   if (cie_return_save)\n-    VEC_safe_push (reg_saved_in_data, heap,\n-\t\t   ti.regs_saved_in_regs, *cie_return_save);\n+    ti.regs_saved_in_regs.safe_push (*cie_return_save);\n \n   /* Walk all the insns, collecting start of trace locations.  */\n   saw_barrier = false;\n@@ -2751,8 +2736,8 @@ create_pseudo_cfg (void)\n \t  memset (&ti, 0, sizeof (ti));\n \t  ti.head = insn;\n \t  ti.switch_sections = switch_sections;\n-\t  ti.id = VEC_length (dw_trace_info, trace_info) - 1;\n-\t  VEC_safe_push (dw_trace_info, heap, trace_info, ti);\n+\t  ti.id = trace_info.length () - 1;\n+\t  trace_info.safe_push (ti);\n \n \t  saw_barrier = false;\n \t  switch_sections = false;\n@@ -2761,10 +2746,10 @@ create_pseudo_cfg (void)\n \n   /* Create the trace index after we've finished building trace_info,\n      avoiding stale pointer problems due to reallocation.  */\n-  trace_index = htab_create (VEC_length (dw_trace_info, trace_info),\n+  trace_index = htab_create (trace_info.length (),\n \t\t\t     dw_trace_info_hash, dw_trace_info_eq, NULL);\n   dw_trace_info *tp;\n-  FOR_EACH_VEC_ELT (dw_trace_info, trace_info, i, tp)\n+  FOR_EACH_VEC_ELT (trace_info, i, tp)\n     {\n       void **slot;\n \n@@ -2876,15 +2861,14 @@ create_cie_data (void)\n \t the DW_CFA_offset against the return column, not the intermediate\n \t save register.  Save the contents of regs_saved_in_regs so that\n \t we can re-initialize it at the start of each function.  */\n-      switch (VEC_length (reg_saved_in_data, cie_trace.regs_saved_in_regs))\n+      switch (cie_trace.regs_saved_in_regs.length ())\n \t{\n \tcase 0:\n \t  break;\n \tcase 1:\n \t  cie_return_save = ggc_alloc_reg_saved_in_data ();\n-\t  *cie_return_save = VEC_index (reg_saved_in_data,\n-\t\t\t\t\tcie_trace.regs_saved_in_regs, 0);\n-\t  VEC_free (reg_saved_in_data, heap, cie_trace.regs_saved_in_regs);\n+\t  *cie_return_save = cie_trace.regs_saved_in_regs[0];\n+\t  cie_trace.regs_saved_in_regs.release ();\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -2921,10 +2905,10 @@ execute_dwarf2_frame (void)\n     size_t i;\n     dw_trace_info *ti;\n \n-    FOR_EACH_VEC_ELT (dw_trace_info, trace_info, i, ti)\n-      VEC_free (reg_saved_in_data, heap, ti->regs_saved_in_regs);\n+    FOR_EACH_VEC_ELT (trace_info, i, ti)\n+      ti->regs_saved_in_regs.release ();\n   }\n-  VEC_free (dw_trace_info, heap, trace_info);\n+  trace_info.release ();\n \n   htab_delete (trace_index);\n   trace_index = NULL;\n@@ -3286,7 +3270,7 @@ dump_cfi_row (FILE *f, dw_cfi_row *row)\n     }\n   output_cfi_directive (f, cfi);\n \n-  FOR_EACH_VEC_ELT (dw_cfi_ref, row->reg_save, i, cfi)\n+  FOR_EACH_VEC_SAFE_ELT (row->reg_save, i, cfi)\n     if (cfi)\n       output_cfi_directive (f, cfi);\n }"}, {"sha": "c25b7b74c05aa9a4619be36279f6748a515f0661", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 172, "deletions": 205, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -130,20 +130,20 @@ int vms_file_stats_name (const char *, long long *, long *, char *, int *);\n \n /* Array of RTXes referenced by the debugging information, which therefore\n    must be kept around forever.  */\n-static GTY(()) VEC(rtx,gc) *used_rtx_array;\n+static GTY(()) vec<rtx, va_gc> *used_rtx_array;\n \n /* A pointer to the base of a list of incomplete types which might be\n    completed at some later time.  incomplete_types_list needs to be a\n-   VEC(tree,gc) because we want to tell the garbage collector about\n+   vec<tree, va_gc> *because we want to tell the garbage collector about\n    it.  */\n-static GTY(()) VEC(tree,gc) *incomplete_types;\n+static GTY(()) vec<tree, va_gc> *incomplete_types;\n \n /* A pointer to the base of a table of references to declaration\n    scopes.  This table is a display which tracks the nesting\n    of declaration scopes at the current scope and containing\n    scopes.  This table is used to find the proper place to\n    define type declaration DIE's.  */\n-static GTY(()) VEC(tree,gc) *decl_scope_table;\n+static GTY(()) vec<tree, va_gc> *decl_scope_table;\n \n /* Pointers to various DWARF2 sections.  */\n static GTY(()) section *debug_info_section;\n@@ -190,15 +190,13 @@ static GTY(()) section *debug_frame_section;\n #define DWARF_CIE_ID DW_CIE_ID\n #endif\n \n-DEF_VEC_P (dw_fde_ref);\n-DEF_VEC_ALLOC_P (dw_fde_ref, gc);\n \n /* A vector for a table that contains frame description\n    information for each routine.  */\n #define NOT_INDEXED (-1U)\n #define NO_INDEX_ASSIGNED (-2U)\n \n-static GTY(()) VEC(dw_fde_ref, gc) *fde_vec;\n+static GTY(()) vec<dw_fde_ref, va_gc> *fde_vec;\n \n struct GTY(()) indirect_string_node {\n   const char *str;\n@@ -616,7 +614,7 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n     size_t from, until, i;\n \n     from = 0;\n-    until = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n+    until = vec_safe_length (fde->dw_fde_cfi);\n \n     if (fde->dw_fde_second_begin == NULL)\n       ;\n@@ -626,7 +624,7 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n       from = fde->dw_fde_switch_cfi_index;\n \n     for (i = from; i < until; i++)\n-      output_cfi (VEC_index (dw_cfi_ref, fde->dw_fde_cfi, i), fde, for_eh);\n+      output_cfi ((*fde->dw_fde_cfi)[i], fde, for_eh);\n   }\n \n   /* If we are to emit a ref/link from function bodies to their frame tables,\n@@ -694,7 +692,7 @@ output_call_frame_info (int for_eh)\n   int dw_cie_version;\n \n   /* Don't emit a CIE if there won't be any FDEs.  */\n-  if (fde_vec == NULL)\n+  if (!fde_vec)\n     return;\n \n   /* Nothing to do if the assembler's doing it all.  */\n@@ -711,7 +709,7 @@ output_call_frame_info (int for_eh)\n     {\n       bool any_eh_needed = false;\n \n-      FOR_EACH_VEC_ELT (dw_fde_ref, fde_vec, i, fde)\n+      FOR_EACH_VEC_ELT (*fde_vec, i, fde)\n \t{\n \t  if (fde->uses_eh_lsda)\n \t    any_eh_needed = any_lsda_needed = true;\n@@ -863,7 +861,7 @@ output_call_frame_info (int for_eh)\n \t\t\t     eh_data_format_name (fde_encoding));\n     }\n \n-  FOR_EACH_VEC_ELT (dw_cfi_ref, cie_cfi_vec, i, cfi)\n+  FOR_EACH_VEC_ELT (*cie_cfi_vec, i, cfi)\n     output_cfi (cfi, NULL, for_eh);\n \n   /* Pad the CIE out to an address sized boundary.  */\n@@ -872,7 +870,7 @@ output_call_frame_info (int for_eh)\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n \n   /* Loop through all of the FDE's.  */\n-  FOR_EACH_VEC_ELT (dw_fde_ref, fde_vec, i, fde)\n+  FOR_EACH_VEC_ELT (*fde_vec, i, fde)\n     {\n       unsigned int k;\n \n@@ -951,7 +949,7 @@ dwarf2out_alloc_current_fde (void)\n   fde = ggc_alloc_cleared_dw_fde_node ();\n   fde->decl = current_function_decl;\n   fde->funcdef_number = current_function_funcdef_no;\n-  fde->fde_index = VEC_length (dw_fde_ref, fde_vec);\n+  fde->fde_index = vec_safe_length (fde_vec);\n   fde->all_throwers_are_sibcalls = crtl->all_throwers_are_sibcalls;\n   fde->uses_eh_lsda = crtl->uses_eh_lsda;\n   fde->nothrow = crtl->nothrow;\n@@ -960,7 +958,7 @@ dwarf2out_alloc_current_fde (void)\n \n   /* Record the FDE associated with this function.  */\n   cfun->fde = fde;\n-  VEC_safe_push (dw_fde_ref, gc, fde_vec, fde);\n+  vec_safe_push (fde_vec, fde);\n \n   return fde;\n }\n@@ -1199,13 +1197,9 @@ typedef struct GTY(()) deferred_locations_struct\n   dw_die_ref die;\n } deferred_locations;\n \n-DEF_VEC_O(deferred_locations);\n-DEF_VEC_ALLOC_O(deferred_locations,gc);\n \n-static GTY(()) VEC(deferred_locations, gc) *deferred_locations_list;\n+static GTY(()) vec<deferred_locations, va_gc> *deferred_locations_list;\n \n-DEF_VEC_P(dw_die_ref);\n-DEF_VEC_ALLOC_P(dw_die_ref,heap);\n \n /* Describe an entry into the .debug_addr section.  */\n \n@@ -2474,8 +2468,6 @@ typedef struct GTY(()) dw_line_info_struct {\n   unsigned int val;\n } dw_line_info_entry;\n \n-DEF_VEC_O(dw_line_info_entry);\n-DEF_VEC_ALLOC_O(dw_line_info_entry, gc);\n \n typedef struct GTY(()) dw_line_info_table_struct {\n   /* The label that marks the end of this section.  */\n@@ -2490,13 +2482,11 @@ typedef struct GTY(()) dw_line_info_table_struct {\n   bool is_stmt;\n   bool in_use;\n \n-  VEC(dw_line_info_entry, gc) *entries;\n+  vec<dw_line_info_entry, va_gc> *entries;\n } dw_line_info_table;\n \n typedef dw_line_info_table *dw_line_info_table_p;\n \n-DEF_VEC_P(dw_line_info_table_p);\n-DEF_VEC_ALLOC_P(dw_line_info_table_p, gc);\n \n /* Each DIE attribute has a field specifying the attribute kind,\n    a link to the next attribute in the chain, and an attribute value.\n@@ -2508,8 +2498,6 @@ typedef struct GTY(()) dw_attr_struct {\n }\n dw_attr_node;\n \n-DEF_VEC_O(dw_attr_node);\n-DEF_VEC_ALLOC_O(dw_attr_node,gc);\n \n /* The Debugging Information Entry (DIE) structure.  DIEs form a tree.\n    The children of each node form a circular list linked by\n@@ -2522,7 +2510,7 @@ typedef struct GTY((chain_circular (\"%h.die_sib\"))) die_struct {\n       comdat_type_node_ref GTY ((tag (\"1\"))) die_type_node;\n     }\n   GTY ((desc (\"%0.comdat_type_p\"))) die_id;\n-  VEC(dw_attr_node,gc) * die_attr;\n+  vec<dw_attr_node, va_gc> *die_attr;\n   dw_die_ref die_parent;\n   dw_die_ref die_child;\n   dw_die_ref die_sib;\n@@ -2556,8 +2544,6 @@ typedef struct GTY(()) pubname_struct {\n }\n pubname_entry;\n \n-DEF_VEC_O(pubname_entry);\n-DEF_VEC_ALLOC_O(pubname_entry, gc);\n \n struct GTY(()) dw_ranges_struct {\n   /* If this is positive, it's a block number, otherwise it's a\n@@ -2574,8 +2560,6 @@ typedef struct GTY(()) macinfo_struct {\n }\n macinfo_entry;\n \n-DEF_VEC_O(macinfo_entry);\n-DEF_VEC_ALLOC_O(macinfo_entry, gc);\n \n struct GTY(()) dw_ranges_by_label_struct {\n   const char *begin;\n@@ -2721,8 +2705,6 @@ typedef struct GTY(()) die_arg_entry_struct {\n     tree arg;\n } die_arg_entry;\n \n-DEF_VEC_O(die_arg_entry);\n-DEF_VEC_ALLOC_O(die_arg_entry,gc);\n \n /* Node of the variable location list.  */\n struct GTY ((chain_next (\"%h.next\"))) var_loc_node {\n@@ -2786,7 +2768,7 @@ static int tail_call_site_count = -1;\n \n /* Vector mapping block numbers to DW_TAG_{lexical_block,inlined_subroutine}\n    DIEs.  */\n-static VEC (dw_die_ref, heap) *block_map;\n+static vec<dw_die_ref> block_map;\n \n /* A cached location list.  */\n struct GTY (()) cached_dw_loc_list_def {\n@@ -2830,29 +2812,29 @@ static GTY(()) dw_line_info_table *text_section_line_info;\n static GTY(()) dw_line_info_table *cold_text_section_line_info;\n \n /* The set of all non-default tables of line number info.  */\n-static GTY(()) VEC (dw_line_info_table_p, gc) *separate_line_info;\n+static GTY(()) vec<dw_line_info_table_p, va_gc> *separate_line_info;\n \n /* A flag to tell pubnames/types export if there is an info section to\n    refer to.  */\n static bool info_section_emitted;\n \n /* A pointer to the base of a table that contains a list of publicly\n    accessible names.  */\n-static GTY (()) VEC (pubname_entry, gc) *  pubname_table;\n+static GTY (()) vec<pubname_entry, va_gc> *pubname_table;\n \n /* A pointer to the base of a table that contains a list of publicly\n    accessible types.  */\n-static GTY (()) VEC (pubname_entry, gc) * pubtype_table;\n+static GTY (()) vec<pubname_entry, va_gc> *pubtype_table;\n \n /* A pointer to the base of a table that contains a list of macro\n    defines/undefines (and file start/end markers).  */\n-static GTY (()) VEC (macinfo_entry, gc) * macinfo_table;\n+static GTY (()) vec<macinfo_entry, va_gc> *macinfo_table;\n \n /* True if .debug_macinfo or .debug_macros section is going to be\n    emitted.  */\n #define have_macinfo \\\n   (debug_info_level >= DINFO_LEVEL_VERBOSE \\\n-   && !VEC_empty (macinfo_entry, macinfo_table))\n+   && !macinfo_table->is_empty ())\n \n /* Array of dies for which we should generate .debug_ranges info.  */\n static GTY ((length (\"ranges_table_allocated\"))) dw_ranges_ref ranges_table;\n@@ -2898,20 +2880,20 @@ static GTY(()) int label_num;\n /* Cached result of previous call to lookup_filename.  */\n static GTY(()) struct dwarf_file_data * file_table_last_lookup;\n \n-static GTY(()) VEC(die_arg_entry,gc) *tmpl_value_parm_die_table;\n+static GTY(()) vec<die_arg_entry, va_gc> *tmpl_value_parm_die_table;\n \n /* Instances of generic types for which we need to generate debug\n    info that describe their generic parameters and arguments. That\n    generation needs to happen once all types are properly laid out so\n    we do it at the end of compilation.  */\n-static GTY(()) VEC(tree,gc) *generic_type_instances;\n+static GTY(()) vec<tree, va_gc> *generic_type_instances;\n \n /* Offset from the \"steady-state frame pointer\" to the frame base,\n    within the current function.  */\n static HOST_WIDE_INT frame_pointer_fb_offset;\n static bool frame_pointer_fb_offset_valid;\n \n-static VEC (dw_die_ref, heap) *base_types;\n+static vec<dw_die_ref> base_types;\n \n /* Forward declarations for functions defined in this file.  */\n \n@@ -3053,7 +3035,7 @@ static void calc_base_type_die_sizes (void);\n static void mark_dies (dw_die_ref);\n static void unmark_dies (dw_die_ref);\n static void unmark_all_dies (dw_die_ref);\n-static unsigned long size_of_pubnames (VEC (pubname_entry,gc) *);\n+static unsigned long size_of_pubnames (vec<pubname_entry, va_gc> *);\n static unsigned long size_of_aranges (void);\n static enum dwarf_form value_format (dw_attr_ref);\n static void output_value_format (dw_attr_ref);\n@@ -3069,7 +3051,7 @@ static void add_pubname (tree, dw_die_ref);\n static void add_enumerator_pubname (const char *, dw_die_ref);\n static void add_pubname_string (const char *, dw_die_ref);\n static void add_pubtype (tree, dw_die_ref);\n-static void output_pubnames (VEC (pubname_entry,gc) *);\n+static void output_pubnames (vec<pubname_entry, va_gc> *);\n static void output_aranges (unsigned long);\n static unsigned int add_ranges_num (int);\n static unsigned int add_ranges (const_tree);\n@@ -3647,9 +3629,8 @@ add_dwarf_attr (dw_die_ref die, dw_attr_ref attr)\n   if (die == NULL)\n     return;\n \n-  if (die->die_attr == NULL)\n-    die->die_attr = VEC_alloc (dw_attr_node, gc, 1);\n-  VEC_safe_push (dw_attr_node, gc, die->die_attr, *attr);\n+  vec_safe_reserve (die->die_attr, 1);\n+  vec_safe_push (die->die_attr, *attr);\n }\n \n static inline enum dw_val_class\n@@ -4442,7 +4423,7 @@ get_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n   if (! die)\n     return NULL;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (a->dw_attr == attr_kind)\n       return a;\n     else if (a->dw_attr == DW_AT_specification\n@@ -4588,16 +4569,16 @@ remove_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n   if (! die)\n     return;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (a->dw_attr == attr_kind)\n       {\n \tif (AT_class (a) == dw_val_class_str)\n \t  if (a->dw_attr_val.v.val_str->refcount)\n \t    a->dw_attr_val.v.val_str->refcount--;\n \n-\t/* VEC_ordered_remove should help reduce the number of abbrevs\n+\t/* vec::ordered_remove should help reduce the number of abbrevs\n \t   that are needed.  */\n-\tVEC_ordered_remove (dw_attr_node, die->die_attr, ix);\n+\tdie->die_attr->ordered_remove (ix);\n \treturn;\n       }\n }\n@@ -5258,7 +5239,7 @@ print_die (dw_die_ref die, FILE *outfile)\n       fprintf (outfile, \"\\n\");\n     }\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n       print_spaces (outfile);\n       fprintf (outfile, \"  %s: \", dwarf_attr_name (a->dw_attr));\n@@ -5517,7 +5498,7 @@ die_checksum (dw_die_ref die, struct md5_ctx *ctx, int *mark)\n \n   CHECKSUM (die->die_tag);\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     attr_checksum (a, ctx, mark);\n \n   FOR_EACH_CHILD (die, c, die_checksum (c, ctx, mark));\n@@ -5831,7 +5812,7 @@ collect_checksum_attributes (struct checksum_attributes *attrs, dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n       switch (a->dw_attr)\n         {\n@@ -6268,12 +6249,11 @@ same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)\n   if (die1->die_tag != die2->die_tag)\n     return 0;\n \n-  if (VEC_length (dw_attr_node, die1->die_attr)\n-      != VEC_length (dw_attr_node, die2->die_attr))\n+  if (vec_safe_length (die1->die_attr) != vec_safe_length (die2->die_attr))\n     return 0;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die1->die_attr, ix, a1)\n-    if (!same_attr_p (a1, &VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n+  FOR_EACH_VEC_SAFE_ELT (die1->die_attr, ix, a1)\n+    if (!same_attr_p (a1, &(*die2->die_attr)[ix], mark))\n       return 0;\n \n   c1 = die1->die_child;\n@@ -6668,7 +6648,7 @@ is_declaration_die (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (a->dw_attr == DW_AT_declaration)\n       return 1;\n \n@@ -6755,7 +6735,7 @@ clone_die (dw_die_ref die)\n   clone = ggc_alloc_cleared_die_node ();\n   clone->die_tag = die->die_tag;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     add_dwarf_attr (clone, a);\n \n   return clone;\n@@ -6801,7 +6781,7 @@ clone_as_declaration (dw_die_ref die)\n   clone = ggc_alloc_cleared_die_node ();\n   clone->die_tag = die->die_tag;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n       /* We don't want to copy over all attributes.\n          For example we don't want DW_AT_byte_size because otherwise we will no\n@@ -6865,7 +6845,7 @@ copy_declaration_context (dw_die_ref unit, dw_die_ref die)\n \n       remove_AT (die, DW_AT_specification);\n \n-      FOR_EACH_VEC_ELT (dw_attr_node, decl->die_attr, ix, a)\n+      FOR_EACH_VEC_SAFE_ELT (decl->die_attr, ix, a)\n         {\n           if (a->dw_attr != DW_AT_name\n               && a->dw_attr != DW_AT_declaration\n@@ -7205,7 +7185,7 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n       if (AT_class (a) == dw_val_class_die_ref)\n         {\n@@ -7326,7 +7306,7 @@ output_location_lists (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_loc_list)\n       output_loc_list (AT_loc_list (a));\n \n@@ -7411,7 +7391,7 @@ optimize_external_refs_1 (dw_die_ref die, htab_t map)\n \n   /* Scan the DIE references, and remember any that refer to DIEs from\n      other CUs (i.e. those which are not marked).  */\n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_die_ref\n \t&& (c = AT_ref (a))->die_mark == 0\n \t&& is_type_die (c))\n@@ -7491,7 +7471,7 @@ build_abbrev_table (dw_die_ref die, htab_t extern_map)\n   /* Scan the DIE references, and replace any that refer to\n      DIEs from other CUs (i.e. those which are not marked) with\n      the local stubs we built in optimize_external_refs.  */\n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_die_ref\n \t&& (c = AT_ref (a))->die_mark == 0)\n       {\n@@ -7518,13 +7498,12 @@ build_abbrev_table (dw_die_ref die, htab_t extern_map)\n       if ((abbrev->die_child != NULL) != (die->die_child != NULL))\n \tcontinue;\n \n-      if (VEC_length (dw_attr_node, abbrev->die_attr)\n-\t  != VEC_length (dw_attr_node, die->die_attr))\n+      if (vec_safe_length (abbrev->die_attr) != vec_safe_length (die->die_attr))\n \tcontinue;\n \n-      FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, die_a)\n+      FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, die_a)\n \t{\n-\t  abbrev_a = &VEC_index (dw_attr_node, abbrev->die_attr, ix);\n+\t  abbrev_a = &(*abbrev->die_attr)[ix];\n \t  if ((abbrev_a->dw_attr != die_a->dw_attr)\n \t      || (value_format (abbrev_a) != value_format (die_a)))\n \t    {\n@@ -7587,7 +7566,7 @@ size_of_die (dw_die_ref die)\n   enum dwarf_form form;\n \n   size += size_of_uleb128 (die->die_abbrev);\n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n       switch (AT_class (a))\n \t{\n@@ -7764,7 +7743,7 @@ calc_base_type_die_sizes (void)\n #endif\n \n   die_offset += size_of_die (comp_unit_die ());\n-  for (i = 0; VEC_iterate (dw_die_ref, base_types, i, base_type); i++)\n+  for (i = 0; base_types.iterate (i, &base_type); i++)\n     {\n #if ENABLE_ASSERT_CHECKING\n       gcc_assert (base_type->die_offset == 0\n@@ -7823,7 +7802,7 @@ unmark_all_dies (dw_die_ref die)\n \n   FOR_EACH_CHILD (die, c, unmark_all_dies (c));\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_die_ref)\n       unmark_all_dies (AT_ref (a));\n }\n@@ -7832,14 +7811,14 @@ unmark_all_dies (dw_die_ref die)\n    generated for the compilation unit.  */\n \n static unsigned long\n-size_of_pubnames (VEC (pubname_entry, gc) * names)\n+size_of_pubnames (vec<pubname_entry, va_gc> *names)\n {\n   unsigned long size;\n   unsigned i;\n   pubname_ref p;\n \n   size = DWARF_PUBNAMES_HEADER_SIZE;\n-  FOR_EACH_VEC_ELT (pubname_entry, names, i, p)\n+  FOR_EACH_VEC_ELT (*names, i, p)\n     if (names != pubtype_table\n \t|| p->die->die_offset != 0\n \t|| !flag_eliminate_unused_debug_types)\n@@ -7868,7 +7847,7 @@ size_of_aranges (void)\n       unsigned fde_idx;\n       dw_fde_ref fde;\n \n-      FOR_EACH_VEC_ELT (dw_fde_ref, fde_vec, fde_idx, fde)\n+      FOR_EACH_VEC_ELT (*fde_vec, fde_idx, fde)\n \t{\n \t  if (!fde->in_std_section)\n \t    size += 2 * DWARF2_ADDR_SIZE;\n@@ -8086,8 +8065,7 @@ output_die_abbrevs (unsigned long abbrev_id, dw_die_ref abbrev)\n   else\n     dw2_asm_output_data (1, DW_children_no, \"DW_children_no\");\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, abbrev->die_attr, ix, a_attr);\n-       ix++)\n+  for (ix = 0; vec_safe_iterate (abbrev->die_attr, ix, &a_attr); ix++)\n     {\n       dw2_asm_output_data_uleb128 (a_attr->dw_attr, \"(%s)\",\n                                    dwarf_attr_name (a_attr->dw_attr));\n@@ -8344,7 +8322,7 @@ output_die (dw_die_ref die)\n \t\t\t       (unsigned long)die->die_offset,\n \t\t\t       dwarf_tag_name (die->die_tag));\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n       const char *name = dwarf_attr_name (a->dw_attr);\n \n@@ -8885,7 +8863,7 @@ add_pubname_string (const char *str, dw_die_ref die)\n \n   e.die = die;\n   e.name = xstrdup (str);\n-  VEC_safe_push (pubname_entry, gc, pubname_table, e);\n+  vec_safe_push (pubname_table, e);\n }\n \n static void\n@@ -8919,7 +8897,7 @@ add_enumerator_pubname (const char *scope_name, dw_die_ref die)\n   gcc_assert (scope_name);\n   e.name = concat (scope_name, get_AT_string (die, DW_AT_name), NULL);\n   e.die = die;\n-  VEC_safe_push (pubname_entry, gc, pubname_table, e);\n+  vec_safe_push (pubname_table, e);\n }\n \n /* Add a new entry to .debug_pubtypes if appropriate.  */\n@@ -8962,7 +8940,7 @@ add_pubtype (tree decl, dw_die_ref die)\n         {\n           e.die = die;\n           e.name = concat (scope_name, name, NULL);\n-          VEC_safe_push (pubname_entry, gc, pubtype_table, e);\n+          vec_safe_push (pubtype_table, e);\n         }\n \n       /* Although it might be more consistent to add the pubinfo for the\n@@ -8984,7 +8962,7 @@ add_pubtype (tree decl, dw_die_ref die)\n    visible names; or the public types table used to find type definitions.  */\n \n static void\n-output_pubnames (VEC (pubname_entry, gc) * names)\n+output_pubnames (vec<pubname_entry, va_gc> *names)\n {\n   unsigned i;\n   unsigned long pubnames_length = size_of_pubnames (names);\n@@ -9018,7 +8996,7 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n   dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset,\n \t\t       \"Compilation Unit Length\");\n \n-  FOR_EACH_VEC_ELT (pubname_entry, names, i, pub)\n+  FOR_EACH_VEC_ELT (*names, i, pub)\n     {\n       /* Enumerator names are part of the pubname table, but the parent\n          DW_TAG_enumeration_type die may have been pruned.  Don't output\n@@ -9121,7 +9099,7 @@ output_aranges (unsigned long aranges_length)\n       unsigned fde_idx;\n       dw_fde_ref fde;\n \n-      FOR_EACH_VEC_ELT (dw_fde_ref, fde_vec, fde_idx, fde)\n+      FOR_EACH_VEC_ELT (*fde_vec, fde_idx, fde)\n \t{\n \t  if (DECL_IGNORED_P (fde->decl))\n \t    continue;\n@@ -9642,7 +9620,7 @@ output_one_line_info_table (dw_line_info_table *table)\n   dw_line_info_entry *ent;\n   size_t i;\n \n-  FOR_EACH_VEC_ELT (dw_line_info_entry, table->entries, i, ent)\n+  FOR_EACH_VEC_SAFE_ELT (table->entries, i, ent)\n     {\n       switch (ent->opcode)\n \t{\n@@ -9828,7 +9806,7 @@ output_line_info (bool prologue_only)\n       dw_line_info_table *table;\n       size_t i;\n \n-      FOR_EACH_VEC_ELT (dw_line_info_table_p, separate_line_info, i, table)\n+      FOR_EACH_VEC_ELT (*separate_line_info, i, table)\n \tif (table->in_use)\n \t  {\n \t    output_one_line_info_table (table);\n@@ -12139,7 +12117,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \n     symref:\n       mem_loc_result = new_addr_loc_descr (rtl, dtprel_false);\n-      VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n+      vec_safe_push (used_rtx_array, rtl);\n       break;\n \n     case CONCAT:\n@@ -13044,7 +13022,7 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \t{\n          loc_result = new_addr_loc_descr (rtl, dtprel_false);\n \t  add_loc_descr (&loc_result, new_loc_descr (DW_OP_stack_value, 0, 0));\n-\t  VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n+\t  vec_safe_push (used_rtx_array, rtl);\n \t}\n       break;\n \n@@ -14760,7 +14738,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n           loc_result = new_addr_loc_descr (rtl, dtprel_false);\n \t  add_loc_descr (&loc_result, new_loc_descr (DW_OP_stack_value, 0, 0));\n \t  add_AT_loc (die, DW_AT_location, loc_result);\n-\t  VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n+\t  vec_safe_push (used_rtx_array, rtl);\n \t  return true;\n \t}\n       return false;\n@@ -14913,7 +14891,7 @@ rtl_for_decl_init (tree init, tree type)\n \t  case CONSTRUCTOR:\n \t    if (TREE_CONSTANT (init))\n \t      {\n-\t\tVEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (init);\n+\t\tvec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (init);\n \t\tbool constant_p = true;\n \t\ttree value;\n \t\tunsigned HOST_WIDE_INT ix;\n@@ -15334,7 +15312,7 @@ defer_location (tree variable, dw_die_ref die)\n   deferred_locations entry;\n   entry.variable = variable;\n   entry.die = die;\n-  VEC_safe_push (deferred_locations, gc, deferred_locations_list, entry);\n+  vec_safe_push (deferred_locations_list, entry);\n }\n \n /* Helper function for tree_add_const_value_attribute.  Natively encode\n@@ -15395,7 +15373,7 @@ native_encode_initializer (tree init, unsigned char *array, int size)\n \n \t  min_index = tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0);\n \t  memset (array, '\\0', size);\n-\t  FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce)\n+\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n \t    {\n \t      tree val = ce->value;\n \t      tree index = ce->index;\n@@ -15441,7 +15419,7 @@ native_encode_initializer (tree init, unsigned char *array, int size)\n \t  if (TREE_CODE (type) == RECORD_TYPE)\n \t    field = TYPE_FIELDS (type);\n \n-\t  FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce)\n+\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n \t    {\n \t      tree val = ce->value;\n \t      int pos, fieldsize;\n@@ -15581,7 +15559,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n \n   /* ??? Bald assumption that the CIE opcode list does not contain\n      advance opcodes.  */\n-  FOR_EACH_VEC_ELT (dw_cfi_ref, cie_cfi_vec, ix, cfi)\n+  FOR_EACH_VEC_ELT (*cie_cfi_vec, ix, cfi)\n     lookup_cfa_1 (cfi, &next_cfa, &remember);\n \n   last_cfa = next_cfa;\n@@ -15597,7 +15575,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n       start_label = last_label = fde->dw_fde_second_begin;\n     }\n \n-  FOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n+  FOR_EACH_VEC_SAFE_ELT (fde->dw_fde_cfi, ix, cfi)\n     {\n       switch (cfi->dw_cfi_opc)\n \t{\n@@ -16278,7 +16256,7 @@ add_name_and_src_coords_attributes (dw_die_ref die, tree decl)\n     {\n       add_AT_addr (die, DW_AT_VMS_rtnbeg_pd_address,\n                   XEXP (DECL_RTL (decl), 0), false);\n-      VEC_safe_push (rtx, gc, used_rtx_array, XEXP (DECL_RTL (decl), 0));\n+      vec_safe_push (used_rtx_array, XEXP (DECL_RTL (decl), 0));\n     }\n #endif /* VMS_DEBUGGING_INFO */\n }\n@@ -16320,15 +16298,15 @@ dwarf2out_vms_debug_main_pointer (void)\n static void\n push_decl_scope (tree scope)\n {\n-  VEC_safe_push (tree, gc, decl_scope_table, scope);\n+  vec_safe_push (decl_scope_table, scope);\n }\n \n /* Pop a declaration scope.  */\n \n static inline void\n pop_decl_scope (void)\n {\n-  VEC_pop (tree, decl_scope_table);\n+  decl_scope_table->pop ();\n }\n \n /* walk_tree helper function for uses_local_type, below.  */\n@@ -16901,10 +16879,9 @@ retry_incomplete_types (void)\n {\n   int i;\n \n-  for (i = VEC_length (tree, incomplete_types) - 1; i >= 0; i--)\n-    if (should_emit_struct_debug (VEC_index (tree, incomplete_types, i),\n-\t\t\t\t  DINFO_USAGE_DIR_USE))\n-      gen_type_die (VEC_index (tree, incomplete_types, i), comp_unit_die ());\n+  for (i = vec_safe_length (incomplete_types) - 1; i >= 0; i--)\n+    if (should_emit_struct_debug ((*incomplete_types)[i], DINFO_USAGE_DIR_USE))\n+      gen_type_die ((*incomplete_types)[i], comp_unit_die ());\n }\n \n /* Determine what tag to use for a record type.  */\n@@ -17528,8 +17505,8 @@ gen_call_site_die (tree decl, dw_die_ref subr_die,\n \t && block != DECL_INITIAL (decl)\n \t && TREE_CODE (block) == BLOCK)\n     {\n-      if (VEC_length (dw_die_ref, block_map) > BLOCK_NUMBER (block))\n-\tstmt_die = VEC_index (dw_die_ref, block_map, BLOCK_NUMBER (block));\n+      if (block_map.length () > BLOCK_NUMBER (block))\n+\tstmt_die = block_map[BLOCK_NUMBER (block)];\n       if (stmt_die)\n \tbreak;\n       block = BLOCK_SUPERCONTEXT (block);\n@@ -18613,10 +18590,9 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die, int depth)\n \n   if (call_arg_locations)\n     {\n-      if (VEC_length (dw_die_ref, block_map) <= BLOCK_NUMBER (stmt))\n-\tVEC_safe_grow_cleared (dw_die_ref, heap, block_map,\n-\t\t\t       BLOCK_NUMBER (stmt) + 1);\n-      VEC_replace (dw_die_ref, block_map, BLOCK_NUMBER (stmt), stmt_die);\n+      if (block_map.length () <= BLOCK_NUMBER (stmt))\n+\tblock_map.safe_grow_cleared (BLOCK_NUMBER (stmt) + 1);\n+      block_map[BLOCK_NUMBER (stmt)] = stmt_die;\n     }\n \n   if (! BLOCK_ABSTRACT (stmt) && TREE_ASM_WRITTEN (stmt))\n@@ -18651,10 +18627,9 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)\n \n       if (call_arg_locations)\n \t{\n-\t  if (VEC_length (dw_die_ref, block_map) <= BLOCK_NUMBER (stmt))\n-\t    VEC_safe_grow_cleared (dw_die_ref, heap, block_map,\n-\t\t\t\t   BLOCK_NUMBER (stmt) + 1);\n-\t  VEC_replace (dw_die_ref, block_map, BLOCK_NUMBER (stmt), subr_die);\n+\t  if (block_map.length () <= BLOCK_NUMBER (stmt))\n+\t    block_map.safe_grow_cleared (BLOCK_NUMBER (stmt) + 1);\n+\t  block_map[BLOCK_NUMBER (stmt)] = subr_die;\n \t}\n       add_abstract_origin_attribute (subr_die, decl);\n       if (TREE_ASM_WRITTEN (stmt))\n@@ -18755,8 +18730,6 @@ gen_ptr_to_mbr_type_die (tree type, dw_die_ref context_die)\n }\n \n typedef const char *dchar_p; /* For DEF_VEC_P.  */\n-DEF_VEC_P(dchar_p);\n-DEF_VEC_ALLOC_P(dchar_p,heap);\n \n static char *producer_string;\n \n@@ -18767,7 +18740,7 @@ static char *\n gen_producer_string (void)\n {\n   size_t j;\n-  VEC(dchar_p, heap) *switches = NULL;\n+  vec<dchar_p> switches = vec<dchar_p>();\n   const char *language_string = lang_hooks.name;\n   char *producer, *tail;\n   const char *p;\n@@ -18828,8 +18801,7 @@ gen_producer_string (void)\n \t  default:\n \t    break;\n \t  }\n-\tVEC_safe_push (dchar_p, heap, switches,\n-\t\t       save_decoded_options[j].orig_option_with_args_text);\n+\tswitches.safe_push (save_decoded_options[j].orig_option_with_args_text);\n \tlen += strlen (save_decoded_options[j].orig_option_with_args_text) + 1;\n \tbreak;\n       }\n@@ -18839,7 +18811,7 @@ gen_producer_string (void)\n   sprintf (tail, \"%s %s\", language_string, version_string);\n   tail += plen;\n \n-  FOR_EACH_VEC_ELT (dchar_p, switches, j, p)\n+  FOR_EACH_VEC_ELT (switches, j, p)\n     {\n       len = strlen (p);\n       *tail = ' ';\n@@ -18848,7 +18820,7 @@ gen_producer_string (void)\n     }\n \n   *tail = '\\0';\n-  VEC_free (dchar_p, heap, switches);\n+  switches.release ();\n   return producer;\n }\n \n@@ -18881,7 +18853,7 @@ gen_compile_unit_die (const char *filename)\n       tree t;\n       const char *common_lang = NULL;\n \n-      FOR_EACH_VEC_ELT (tree, all_translation_units, i, t)\n+      FOR_EACH_VEC_SAFE_ELT (all_translation_units, i, t)\n \t{\n \t  if (!TRANSLATION_UNIT_LANGUAGE (t))\n \t    continue;\n@@ -18890,7 +18862,7 @@ gen_compile_unit_die (const char *filename)\n \t  else if (strcmp (common_lang, TRANSLATION_UNIT_LANGUAGE (t)) == 0)\n \t    ;\n \t  else if (strncmp (common_lang, \"GNU C\", 5) == 0\n-\t\t   && strncmp (TRANSLATION_UNIT_LANGUAGE (t), \"GNU C\", 5) == 0)\n+\t\t    && strncmp(TRANSLATION_UNIT_LANGUAGE (t), \"GNU C\", 5) == 0)\n \t    /* Mixing C and C++ is ok, use C++ in that case.  */\n \t    common_lang = \"GNU C++\";\n \t  else\n@@ -19005,14 +18977,14 @@ gen_member_die (tree type, dw_die_ref context_die)\n   /* First output info about the base classes.  */\n   if (binfo)\n     {\n-      VEC(tree,gc) *accesses = BINFO_BASE_ACCESSES (binfo);\n+      vec<tree, va_gc> *accesses = BINFO_BASE_ACCESSES (binfo);\n       int i;\n       tree base;\n \n       for (i = 0; BINFO_BASE_ITERATE (binfo, i, base); i++)\n \tgen_inheritance_die (base,\n-\t\t\t     (accesses ? VEC_index (tree, accesses, i)\n-\t\t\t      : access_public_node), context_die);\n+\t\t\t     (accesses ? (*accesses)[i] : access_public_node),\n+\t\t\t     context_die);\n     }\n \n   /* Now output info about the data members and type members.  */\n@@ -19138,7 +19110,7 @@ gen_struct_or_union_type_die (tree type, dw_die_ref context_die,\n       /* We don't need to do this for function-local types.  */\n       if (TYPE_STUB_DECL (type)\n \t  && ! decl_function_context (TYPE_STUB_DECL (type)))\n-\tVEC_safe_push (tree, gc, incomplete_types, type);\n+\tvec_safe_push (incomplete_types, type);\n     }\n \n   if (get_AT (type_die, DW_AT_name))\n@@ -20386,7 +20358,7 @@ dwarf2out_function_decl (tree decl)\n   call_arg_loc_last = NULL;\n   call_site_count = -1;\n   tail_call_site_count = -1;\n-  VEC_free (dw_die_ref, heap, block_map);\n+  block_map.release ();\n   htab_empty (decl_loc_table);\n   htab_empty (cached_dw_loc_list_table);\n }\n@@ -20537,14 +20509,11 @@ append_entry_to_tmpl_value_parm_die_table (dw_die_ref die, tree arg)\n     return;\n \n   if (!tmpl_value_parm_die_table)\n-    tmpl_value_parm_die_table\n-      = VEC_alloc (die_arg_entry, gc, 32);\n+    vec_alloc (tmpl_value_parm_die_table, 32);\n \n   entry.die = die;\n   entry.arg = arg;\n-  VEC_safe_push (die_arg_entry, gc,\n-\t\t tmpl_value_parm_die_table,\n-\t\t entry);\n+  vec_safe_push (tmpl_value_parm_die_table, entry);\n }\n \n /* Return TRUE if T is an instance of generic type, FALSE\n@@ -20568,10 +20537,10 @@ schedule_generic_params_dies_gen (tree t)\n   if (!generic_type_p (t))\n     return;\n \n-  if (generic_type_instances == NULL)\n-    generic_type_instances = VEC_alloc (tree, gc, 256);\n+  if (!generic_type_instances)\n+    vec_alloc (generic_type_instances, 256);\n \n-  VEC_safe_push (tree, gc, generic_type_instances, t);\n+  vec_safe_push (generic_type_instances, t);\n }\n \n /* Add a DW_AT_const_value attribute to DIEs that were scheduled\n@@ -20586,7 +20555,7 @@ gen_remaining_tmpl_value_param_die_attribute (void)\n       unsigned i;\n       die_arg_entry *e;\n \n-      FOR_EACH_VEC_ELT (die_arg_entry, tmpl_value_parm_die_table, i, e)\n+      FOR_EACH_VEC_ELT (*tmpl_value_parm_die_table, i, e)\n \ttree_add_const_value_attribute (e->die, e->arg);\n     }\n }\n@@ -20602,10 +20571,10 @@ gen_scheduled_generic_parms_dies (void)\n   unsigned i;\n   tree t;\n \n-  if (generic_type_instances == NULL)\n+  if (!generic_type_instances)\n     return;\n   \n-  FOR_EACH_VEC_ELT (tree, generic_type_instances, i, t)\n+  FOR_EACH_VEC_ELT (*generic_type_instances, i, t)\n     gen_generic_params_dies (t);\n }\n \n@@ -20877,7 +20846,7 @@ set_cur_line_info_table (section *sec)\n       table = new_line_info_table ();\n       table->end_label = end_label;\n \n-      VEC_safe_push (dw_line_info_table_p, gc, separate_line_info, table);\n+      vec_safe_push (separate_line_info, table);\n     }\n \n   if (DWARF2_ASM_LINE_DEBUG_INFO)\n@@ -20926,7 +20895,7 @@ push_dw_line_info_entry (dw_line_info_table *table,\n   dw_line_info_entry e;\n   e.opcode = opcode;\n   e.val = val;\n-  VEC_safe_push (dw_line_info_entry, gc, table->entries, e);\n+  vec_safe_push (table->entries, e);\n }\n \n /* Output a label to mark the beginning of a source code line entry\n@@ -21046,7 +21015,7 @@ dwarf2out_start_source_file (unsigned int lineno, const char *filename)\n       e.code = DW_MACINFO_start_file;\n       e.lineno = lineno;\n       e.info = ggc_strdup (filename);\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n+      vec_safe_push (macinfo_table, e);\n     }\n }\n \n@@ -21065,7 +21034,7 @@ dwarf2out_end_source_file (unsigned int lineno ATTRIBUTE_UNUSED)\n       e.code = DW_MACINFO_end_file;\n       e.lineno = lineno;\n       e.info = NULL;\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n+      vec_safe_push (macinfo_table, e);\n     }\n }\n \n@@ -21082,17 +21051,17 @@ dwarf2out_define (unsigned int lineno ATTRIBUTE_UNUSED,\n       macinfo_entry e;\n       /* Insert a dummy first entry to be able to optimize the whole\n \t predefined macro block using DW_MACRO_GNU_transparent_include.  */\n-      if (VEC_empty (macinfo_entry, macinfo_table) && lineno <= 1)\n+      if (macinfo_table->is_empty () && lineno <= 1)\n \t{\n \t  e.code = 0;\n \t  e.lineno = 0;\n \t  e.info = NULL;\n-\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n+\t  vec_safe_push (macinfo_table, e);\n \t}\n       e.code = DW_MACINFO_define;\n       e.lineno = lineno;\n       e.info = ggc_strdup (buffer);\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n+      vec_safe_push (macinfo_table, e);\n     }\n }\n \n@@ -21109,17 +21078,17 @@ dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,\n       macinfo_entry e;\n       /* Insert a dummy first entry to be able to optimize the whole\n \t predefined macro block using DW_MACRO_GNU_transparent_include.  */\n-      if (VEC_empty (macinfo_entry, macinfo_table) && lineno <= 1)\n+      if (macinfo_table->is_empty () && lineno <= 1)\n \t{\n \t  e.code = 0;\n \t  e.lineno = 0;\n \t  e.info = NULL;\n-\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n+\t  vec_safe_push (macinfo_table, e);\n \t}\n       e.code = DW_MACINFO_undef;\n       e.lineno = lineno;\n       e.info = ggc_strdup (buffer);\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n+      vec_safe_push (macinfo_table, e);\n     }\n }\n \n@@ -21230,7 +21199,7 @@ output_macinfo_op (macinfo_entry *ref)\n    If the define/undef entry should be emitted normally, return 0.  */\n \n static unsigned\n-optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n+optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n \t\t\thtab_t *macinfo_htab)\n {\n   macinfo_entry *first, *second, *cur, *inc;\n@@ -21242,16 +21211,16 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n   unsigned int i, count, encoded_filename_len, linebuf_len;\n   void **slot;\n \n-  first = &VEC_index (macinfo_entry, macinfo_table, idx);\n-  second = &VEC_index (macinfo_entry, macinfo_table, idx + 1);\n+  first = &(*macinfo_table)[idx];\n+  second = &(*macinfo_table)[idx + 1];\n \n   /* Optimize only if there are at least two consecutive define/undef ops,\n      and either all of them are before first DW_MACINFO_start_file\n      with lineno {0,1} (i.e. predefined macro block), or all of them are\n      in some included header file.  */\n   if (second->code != DW_MACINFO_define && second->code != DW_MACINFO_undef)\n     return 0;\n-  if (VEC_empty (macinfo_entry, files))\n+  if (vec_safe_is_empty (files))\n     {\n       if (first->lineno > 1 || second->lineno > 1)\n \treturn 0;\n@@ -21263,10 +21232,10 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n      with first and at the same time compute md5 checksum of their\n      codes, linenumbers and strings.  */\n   md5_init_ctx (&ctx);\n-  for (i = idx; VEC_iterate (macinfo_entry, macinfo_table, i, cur); i++)\n+  for (i = idx; macinfo_table->iterate (i, &cur); i++)\n     if (cur->code != DW_MACINFO_define && cur->code != DW_MACINFO_undef)\n       break;\n-    else if (VEC_empty (macinfo_entry, files) && cur->lineno > 1)\n+    else if (vec_safe_is_empty (files) && cur->lineno > 1)\n       break;\n     else\n       {\n@@ -21280,10 +21249,10 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n \n   /* From the containing include filename (if any) pick up just\n      usable characters from its basename.  */\n-  if (VEC_empty (macinfo_entry, files))\n+  if (vec_safe_is_empty (files))\n     base = \"\";\n   else\n-    base = lbasename (VEC_last (macinfo_entry, files).info);\n+    base = lbasename (files->last ().info);\n   for (encoded_filename_len = 0, i = 0; base[i]; i++)\n     if (ISIDNUM (base[i]) || base[i] == '.')\n       encoded_filename_len++;\n@@ -21314,7 +21283,7 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n \n   /* Construct a macinfo_entry for DW_MACRO_GNU_transparent_include\n      in the empty vector entry before the first define/undef.  */\n-  inc = &VEC_index (macinfo_entry, macinfo_table, idx - 1);\n+  inc = &(*macinfo_table)[idx - 1];\n   inc->code = DW_MACRO_GNU_transparent_include;\n   inc->lineno = 0;\n   inc->info = ggc_strdup (grp_name);\n@@ -21332,10 +21301,7 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n       output_macinfo_op (inc);\n       /* And clear all macinfo_entry in the range to avoid emitting them\n \t in the second pass.  */\n-      for (i = idx;\n-\t   VEC_iterate (macinfo_entry, macinfo_table, i, cur)\n-\t   && i < idx + count;\n-\t   i++)\n+      for (i = idx; macinfo_table->iterate (i, &cur) && i < idx + count; i++)\n \t{\n \t  cur->code = 0;\n \t  cur->info = NULL;\n@@ -21361,7 +21327,7 @@ save_macinfo_strings (void)\n   unsigned i;\n   macinfo_entry *ref;\n \n-  for (i = 0; VEC_iterate (macinfo_entry, macinfo_table, i, ref); i++)\n+  for (i = 0; macinfo_table && macinfo_table->iterate (i, &ref); i++)\n     {\n       switch (ref->code)\n         {\n@@ -21392,9 +21358,9 @@ static void\n output_macinfo (void)\n {\n   unsigned i;\n-  unsigned long length = VEC_length (macinfo_entry, macinfo_table);\n+  unsigned long length = vec_safe_length (macinfo_table);\n   macinfo_entry *ref;\n-  VEC (macinfo_entry, gc) *files = NULL;\n+  vec<macinfo_entry, va_gc> *files = NULL;\n   htab_t macinfo_htab = NULL;\n \n   if (! length)\n@@ -21427,25 +21393,25 @@ output_macinfo (void)\n      DW_MACRO_GNU_transparent_include op is emitted and kept in\n      the vector before the first define/undef in the range and the\n      whole range of define/undef ops is not emitted and kept.  */\n-  for (i = 0; VEC_iterate (macinfo_entry, macinfo_table, i, ref); i++)\n+  for (i = 0; macinfo_table->iterate (i, &ref); i++)\n     {\n       switch (ref->code)\n \t{\n \tcase DW_MACINFO_start_file:\n-\t  VEC_safe_push (macinfo_entry, gc, files, *ref);\n+\t  vec_safe_push (files, *ref);\n \t  break;\n \tcase DW_MACINFO_end_file:\n-\t  if (!VEC_empty (macinfo_entry, files))\n-\t    VEC_pop (macinfo_entry, files);\n+\t  if (!vec_safe_is_empty (files))\n+\t    files->pop ();\n \t  break;\n \tcase DW_MACINFO_define:\n \tcase DW_MACINFO_undef:\n \t  if (!dwarf_strict\n \t      && HAVE_COMDAT_GROUP\n-\t      && VEC_length (macinfo_entry, files) != 1\n+\t      && vec_safe_length (files) != 1\n \t      && i > 0\n \t      && i + 1 < length\n-\t      && VEC_index (macinfo_entry, macinfo_table, i - 1).code == 0)\n+\t      && (*macinfo_table)[i - 1].code == 0)\n \t    {\n \t      unsigned count = optimize_macinfo_range (i, files, &macinfo_htab);\n \t      if (count)\n@@ -21477,7 +21443,7 @@ output_macinfo (void)\n      DW_MACRO_GNU_transparent_include entries terminate the\n      current chain and switch to a new comdat .debug_macinfo\n      section and emit the define/undef entries within it.  */\n-  for (i = 0; VEC_iterate (macinfo_entry, macinfo_table, i, ref); i++)\n+  for (i = 0; macinfo_table->iterate (i, &ref); i++)\n     switch (ref->code)\n       {\n       case 0:\n@@ -21539,7 +21505,7 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \t\t       cached_dw_loc_list_table_eq, NULL);\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n-  decl_scope_table = VEC_alloc (tree, gc, 256);\n+  vec_alloc (decl_scope_table, 256);\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n   abbrev_die_table = ggc_alloc_cleared_vec_dw_die_ref\n@@ -21549,12 +21515,12 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   abbrev_die_table_in_use = 1;\n \n   /* Allocate the pubtypes and pubnames vectors.  */\n-  pubname_table = VEC_alloc (pubname_entry, gc, 32);\n-  pubtype_table = VEC_alloc (pubname_entry, gc, 32);\n+  vec_alloc (pubname_table, 32);\n+  vec_alloc (pubtype_table, 32);\n \n-  incomplete_types = VEC_alloc (tree, gc, 64);\n+  vec_alloc (incomplete_types, 64);\n \n-  used_rtx_array = VEC_alloc (rtx, gc, 32);\n+  vec_alloc (used_rtx_array, 32);\n \n   if (!dwarf_split_debug_info)\n     {\n@@ -21638,7 +21604,7 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   ASM_GENERATE_INTERNAL_LABEL (loc_section_label, DEBUG_LOC_SECTION_LABEL, 0);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-    macinfo_table = VEC_alloc (macinfo_entry, gc, 64);\n+    vec_alloc (macinfo_table, 64);\n \n   switch_to_section (text_section);\n   ASM_OUTPUT_LABEL (asm_out_file, text_section_label);\n@@ -21859,7 +21825,7 @@ prune_unused_types_walk_attribs (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n       if (a->dw_attr_val.val_class == dw_val_class_die_ref)\n \t{\n@@ -22073,7 +22039,7 @@ prune_unused_types_update_strings (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_str)\n       {\n \tstruct indirect_string_node *s = a->dw_attr_val.v.val_str;\n@@ -22180,10 +22146,10 @@ prune_unused_types (void)\n      are unusual in that they are pubnames that are the children of pubtypes.\n      They should only be marked via their parent DW_TAG_enumeration_type die,\n      not as roots in themselves.  */\n-  FOR_EACH_VEC_ELT (pubname_entry, pubname_table, i, pub)\n+  FOR_EACH_VEC_ELT (*pubname_table, i, pub)\n     if (pub->die->die_tag != DW_TAG_enumerator)\n       prune_unused_types_mark (pub->die, 1);\n-  for (i = 0; VEC_iterate (dw_die_ref, base_types, i, base_type); i++)\n+  for (i = 0; base_types.iterate (i, &base_type); i++)\n     prune_unused_types_mark (base_type, 1);\n \n   if (debug_str_hash)\n@@ -22249,24 +22215,24 @@ htab_ct_eq (const void *of1, const void *of2)\n static inline void\n move_linkage_attr (dw_die_ref die)\n {\n-  unsigned ix = VEC_length (dw_attr_node, die->die_attr);\n-  dw_attr_node linkage = VEC_index (dw_attr_node, die->die_attr, ix - 1);\n+  unsigned ix = vec_safe_length (die->die_attr);\n+  dw_attr_node linkage = (*die->die_attr)[ix - 1];\n \n   gcc_assert (linkage.dw_attr == DW_AT_linkage_name\n \t      || linkage.dw_attr == DW_AT_MIPS_linkage_name);\n \n   while (--ix > 0)\n     {\n-      dw_attr_node *prev = &VEC_index (dw_attr_node, die->die_attr, ix - 1);\n+      dw_attr_node *prev = &(*die->die_attr)[ix - 1];\n \n       if (prev->dw_attr == DW_AT_decl_line || prev->dw_attr == DW_AT_name)\n \tbreak;\n     }\n \n-  if (ix != VEC_length (dw_attr_node, die->die_attr) - 1)\n+  if (ix != vec_safe_length (die->die_attr) - 1)\n     {\n-      VEC_pop (dw_attr_node, die->die_attr);\n-      VEC_quick_insert (dw_attr_node, die->die_attr, ix, linkage);\n+      die->die_attr->pop ();\n+      die->die_attr->quick_insert (ix, linkage);\n     }\n }\n \n@@ -22305,7 +22271,7 @@ mark_base_types (dw_loc_descr_ref loc)\n \tbase_type->die_mark++;\n       else\n \t{\n-\t  VEC_safe_push (dw_die_ref, heap, base_types, base_type);\n+\t  base_types.safe_push (base_type);\n \t  base_type->die_mark = 1;\n \t}\n     }\n@@ -22351,12 +22317,12 @@ move_marked_base_types (void)\n   unsigned int i;\n   dw_die_ref base_type, die, c;\n \n-  if (VEC_empty (dw_die_ref, base_types))\n+  if (base_types.is_empty ())\n     return;\n \n   /* Sort by decreasing usage count, they will be added again in that\n      order later on.  */\n-  VEC_qsort (dw_die_ref, base_types, base_type_cmp);\n+  base_types.qsort (base_type_cmp);\n   die = comp_unit_die ();\n   c = die->die_child;\n   do\n@@ -22375,7 +22341,7 @@ move_marked_base_types (void)\n   while (c != die->die_child);\n   gcc_assert (die->die_child);\n   c = die->die_child;\n-  for (i = 0; VEC_iterate (dw_die_ref, base_types, i, base_type); i++)\n+  for (i = 0; base_types.iterate (i, &base_type); i++)\n     {\n       base_type->die_mark = 0;\n       base_type->die_sib = c->die_sib;\n@@ -22404,7 +22370,7 @@ resolve_one_addr (rtx *addr, void *data ATTRIBUTE_UNUSED)\n       if (!rtl || !MEM_P (rtl))\n \treturn 1;\n       rtl = XEXP (rtl, 0);\n-      VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n+      vec_safe_push (used_rtx_array, rtl);\n       *addr = rtl;\n       return 0;\n     }\n@@ -22562,7 +22528,7 @@ resolve_addr (dw_die_ref die)\n   dw_loc_list_ref *curr, *start, loc;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     switch (AT_class (a))\n       {\n       case dw_val_class_loc_list:\n@@ -23144,7 +23110,7 @@ optimize_location_lists_1 (dw_die_ref die, htab_t htab)\n   unsigned ix;\n   void **slot;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_loc_list)\n       {\n \tdw_loc_list_ref list = AT_loc_list (a);\n@@ -23173,7 +23139,7 @@ index_location_lists (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_loc_list)\n       {\n         dw_loc_list_ref list = AT_loc_list (a);\n@@ -23242,14 +23208,15 @@ dwarf2out_finish (const char *filename)\n \tadd_comp_dir_attribute (comp_unit_die ());\n     }\n \n-  for (i = 0; i < VEC_length (deferred_locations, deferred_locations_list); i++)\n-    {\n-      add_location_or_const_value_attribute (\n-        VEC_index (deferred_locations, deferred_locations_list, i).die,\n-        VEC_index (deferred_locations, deferred_locations_list, i).variable,\n-\tfalse,\n-\tDW_AT_location);\n-    }\n+  if (deferred_locations_list)\n+    for (i = 0; i < deferred_locations_list->length (); i++)\n+      {\n+\tadd_location_or_const_value_attribute (\n+\t    (*deferred_locations_list)[i].die,\n+\t    (*deferred_locations_list)[i].variable,\n+\t    false,\n+\t    DW_AT_location);\n+      }\n \n   /* Traverse the limbo die list, and add parent/child links.  The only\n      dies without parents that should be here are concrete instances of\n@@ -23408,7 +23375,7 @@ dwarf2out_finish (const char *filename)\n         add_ranges_by_labels (main_comp_unit_die, cold_text_section_label,\n                               cold_end_label, &range_list_added, true);\n \n-      FOR_EACH_VEC_ELT (dw_fde_ref, fde_vec, fde_idx, fde)\n+      FOR_EACH_VEC_ELT (*fde_vec, fde_idx, fde)\n \t{\n \t  if (DECL_IGNORED_P (fde->decl))\n \t    continue;"}, {"sha": "8027c1e788f2595bb537ef95d114cfb150f6b8fb", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -62,11 +62,8 @@ typedef struct GTY(()) dw_cfi_struct {\n }\n dw_cfi_node;\n \n-DEF_VEC_P (dw_cfi_ref);\n-DEF_VEC_ALLOC_P (dw_cfi_ref, heap);\n-DEF_VEC_ALLOC_P (dw_cfi_ref, gc);\n \n-typedef VEC(dw_cfi_ref, gc) *cfi_vec;\n+typedef vec<dw_cfi_ref, va_gc> *cfi_vec;\n \n typedef struct dw_fde_struct *dw_fde_ref;\n "}, {"sha": "aac9b671f348454237b9df60ea2fe4b52501b2ff", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -42,7 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"function.h\"\n #include \"expr.h\"\n-#include \"vecprim.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"hashtab.h\""}, {"sha": "c0ac835062b22556b936e183b2331640b97861f3", "filename": "gcc/except.c", "status": "modified", "additions": 79, "deletions": 85, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -189,8 +189,8 @@ static int add_action_record (htab_t, int, int);\n static int collect_one_action_chain (htab_t, eh_region);\n static int add_call_site (rtx, int, int);\n \n-static void push_uleb128 (VEC (uchar, gc) **, unsigned int);\n-static void push_sleb128 (VEC (uchar, gc) **, int);\n+static void push_uleb128 (vec<uchar, va_gc> **, unsigned int);\n+static void push_sleb128 (vec<uchar, va_gc> **, int);\n #ifndef HAVE_AS_LEB128\n static int dw2_size_of_call_site_table (int);\n static int sjlj_size_of_call_site_table (void);\n@@ -304,8 +304,8 @@ init_eh_for_function (void)\n   cfun->eh = ggc_alloc_cleared_eh_status ();\n \n   /* Make sure zero'th entries are used.  */\n-  VEC_safe_push (eh_region, gc, cfun->eh->region_array, NULL);\n-  VEC_safe_push (eh_landing_pad, gc, cfun->eh->lp_array, NULL);\n+  vec_safe_push (cfun->eh->region_array, (eh_region)0);\n+  vec_safe_push (cfun->eh->lp_array, (eh_landing_pad)0);\n }\n \f\n /* Routines to generate the exception tree somewhat directly.\n@@ -332,8 +332,8 @@ gen_eh_region (enum eh_region_type type, eh_region outer)\n       cfun->eh->region_tree = new_eh;\n     }\n \n-  new_eh->index = VEC_length (eh_region, cfun->eh->region_array);\n-  VEC_safe_push (eh_region, gc, cfun->eh->region_array, new_eh);\n+  new_eh->index = vec_safe_length (cfun->eh->region_array);\n+  vec_safe_push (cfun->eh->region_array, new_eh);\n \n   /* Copy the language's notion of whether to use __cxa_end_cleanup.  */\n   if (targetm.arm_eabi_unwinder && lang_hooks.eh_use_cxa_end_cleanup)\n@@ -413,18 +413,18 @@ gen_eh_landing_pad (eh_region region)\n \n   lp->next_lp = region->landing_pads;\n   lp->region = region;\n-  lp->index = VEC_length (eh_landing_pad, cfun->eh->lp_array);\n+  lp->index = vec_safe_length (cfun->eh->lp_array);\n   region->landing_pads = lp;\n \n-  VEC_safe_push (eh_landing_pad, gc, cfun->eh->lp_array, lp);\n+  vec_safe_push (cfun->eh->lp_array, lp);\n \n   return lp;\n }\n \n eh_region\n get_eh_region_from_number_fn (struct function *ifun, int i)\n {\n-  return VEC_index (eh_region, ifun->eh->region_array, i);\n+  return (*ifun->eh->region_array)[i];\n }\n \n eh_region\n@@ -436,7 +436,7 @@ get_eh_region_from_number (int i)\n eh_landing_pad\n get_eh_landing_pad_from_number_fn (struct function *ifun, int i)\n {\n-  return VEC_index (eh_landing_pad, ifun->eh->lp_array, i);\n+  return (*ifun->eh->lp_array)[i];\n }\n \n eh_landing_pad\n@@ -449,13 +449,13 @@ eh_region\n get_eh_region_from_lp_number_fn (struct function *ifun, int i)\n {\n   if (i < 0)\n-    return VEC_index (eh_region, ifun->eh->region_array, -i);\n+    return (*ifun->eh->region_array)[-i];\n   else if (i == 0)\n     return NULL;\n   else\n     {\n       eh_landing_pad lp;\n-      lp = VEC_index (eh_landing_pad, ifun->eh->lp_array, i);\n+      lp = (*ifun->eh->lp_array)[i];\n       return lp->region;\n     }\n }\n@@ -609,7 +609,7 @@ eh_region_outermost (struct function *ifun, eh_region region_a,\n   gcc_assert (ifun->eh->region_array);\n   gcc_assert (ifun->eh->region_tree);\n \n-  b_outer = sbitmap_alloc (VEC_length (eh_region, ifun->eh->region_array));\n+  b_outer = sbitmap_alloc (ifun->eh->region_array->length());\n   bitmap_clear (b_outer);\n \n   do\n@@ -754,10 +754,10 @@ add_ttypes_entry (htab_t ttypes_hash, tree type)\n \n       n = XNEW (struct ttypes_filter);\n       n->t = type;\n-      n->filter = VEC_length (tree, cfun->eh->ttype_data) + 1;\n+      n->filter = vec_safe_length (cfun->eh->ttype_data) + 1;\n       *slot = n;\n \n-      VEC_safe_push (tree, gc, cfun->eh->ttype_data, type);\n+      vec_safe_push (cfun->eh->ttype_data, type);\n     }\n \n   return n->filter;\n@@ -781,9 +781,9 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n       int len;\n \n       if (targetm.arm_eabi_unwinder)\n-\tlen = VEC_length (tree, cfun->eh->ehspec_data.arm_eabi);\n+\tlen = vec_safe_length (cfun->eh->ehspec_data.arm_eabi);\n       else\n-\tlen = VEC_length (uchar, cfun->eh->ehspec_data.other);\n+\tlen = vec_safe_length (cfun->eh->ehspec_data.other);\n \n       /* Filter value is a -1 based byte index into a uleb128 buffer.  */\n \n@@ -796,8 +796,7 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n       for (; list ; list = TREE_CHAIN (list))\n \t{\n \t  if (targetm.arm_eabi_unwinder)\n-\t    VEC_safe_push (tree, gc, cfun->eh->ehspec_data.arm_eabi,\n-\t\t\t   TREE_VALUE (list));\n+\t    vec_safe_push (cfun->eh->ehspec_data.arm_eabi, TREE_VALUE (list));\n \t  else\n \t    {\n \t      /* Look up each type in the list and encode its filter\n@@ -807,9 +806,9 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n \t    }\n \t}\n       if (targetm.arm_eabi_unwinder)\n-\tVEC_safe_push (tree, gc, cfun->eh->ehspec_data.arm_eabi, NULL_TREE);\n+\tvec_safe_push (cfun->eh->ehspec_data.arm_eabi, NULL_TREE);\n       else\n-\tVEC_safe_push (uchar, gc, cfun->eh->ehspec_data.other, 0);\n+\tvec_safe_push (cfun->eh->ehspec_data.other, (uchar)0);\n     }\n \n   return n->filter;\n@@ -828,16 +827,16 @@ assign_filter_values (void)\n   eh_region r;\n   eh_catch c;\n \n-  cfun->eh->ttype_data = VEC_alloc (tree, gc, 16);\n+  vec_alloc (cfun->eh->ttype_data, 16);\n   if (targetm.arm_eabi_unwinder)\n-    cfun->eh->ehspec_data.arm_eabi = VEC_alloc (tree, gc, 64);\n+    vec_alloc (cfun->eh->ehspec_data.arm_eabi, 64);\n   else\n-    cfun->eh->ehspec_data.other = VEC_alloc (uchar, gc, 64);\n+    vec_alloc (cfun->eh->ehspec_data.other, 64);\n \n   ttypes = htab_create (31, ttypes_filter_hash, ttypes_filter_eq, free);\n   ehspec = htab_create (31, ehspec_filter_hash, ehspec_filter_eq, free);\n \n-  for (i = 1; VEC_iterate (eh_region, cfun->eh->region_array, i, r); ++i)\n+  for (i = 1; vec_safe_iterate (cfun->eh->region_array, i, &r); ++i)\n     {\n       if (r == NULL)\n \tcontinue;\n@@ -966,7 +965,7 @@ dw2_build_landing_pads (void)\n   if (flag_reorder_blocks_and_partition)\n     e_flags |= EDGE_PRESERVE;\n \n-  for (i = 1; VEC_iterate (eh_landing_pad, cfun->eh->lp_array, i, lp); ++i)\n+  for (i = 1; vec_safe_iterate (cfun->eh->lp_array, i, &lp); ++i)\n     {\n       basic_block bb;\n       rtx seq;\n@@ -1004,7 +1003,7 @@ dw2_build_landing_pads (void)\n }\n \n \f\n-static VEC (int, heap) *sjlj_lp_call_site_index;\n+static vec<int> sjlj_lp_call_site_index;\n \n /* Process all active landing pads.  Assign each one a compact dispatch\n    index, and a call-site index.  */\n@@ -1016,12 +1015,12 @@ sjlj_assign_call_site_values (void)\n   int i, disp_index;\n   eh_landing_pad lp;\n \n-  crtl->eh.action_record_data = VEC_alloc (uchar, gc, 64);\n+  vec_alloc (crtl->eh.action_record_data, 64);\n   ar_hash = htab_create (31, action_record_hash, action_record_eq, free);\n \n   disp_index = 0;\n   call_site_base = 1;\n-  for (i = 1; VEC_iterate (eh_landing_pad, cfun->eh->lp_array, i, lp); ++i)\n+  for (i = 1; vec_safe_iterate (cfun->eh->lp_array, i, &lp); ++i)\n     if (lp && lp->post_landing_pad)\n       {\n \tint action, call_site;\n@@ -1041,7 +1040,7 @@ sjlj_assign_call_site_values (void)\n \t/* Otherwise, look it up in the table.  */\n \telse\n \t  call_site = add_call_site (GEN_INT (disp_index), action, 0);\n-\tVEC_replace (int, sjlj_lp_call_site_index, i, call_site);\n+\tsjlj_lp_call_site_index[i] = call_site;\n \n \tdisp_index++;\n       }\n@@ -1079,7 +1078,7 @@ sjlj_mark_call_sites (void)\n       if (nothrow)\n \tcontinue;\n       if (lp)\n-\tthis_call_site = VEC_index (int, sjlj_lp_call_site_index, lp->index);\n+\tthis_call_site = sjlj_lp_call_site_index[lp->index];\n       else if (r == NULL)\n \t{\n \t  /* Calls (and trapping insns) without notes are outside any\n@@ -1240,7 +1239,7 @@ sjlj_emit_dispatch_table (rtx dispatch_label, int num_dispatch)\n   eh_region r;\n   edge e;\n   int i, disp_index;\n-  VEC(tree, heap) *dispatch_labels = NULL;\n+  vec<tree> dispatch_labels = vec<tree>();\n \n   fc = crtl->eh.sjlj_fc;\n \n@@ -1287,9 +1286,9 @@ sjlj_emit_dispatch_table (rtx dispatch_label, int num_dispatch)\n   /* If there's exactly one call site in the function, don't bother\n      generating a switch statement.  */\n   if (num_dispatch > 1)\n-    dispatch_labels = VEC_alloc (tree, heap, num_dispatch);\n+    dispatch_labels.create (num_dispatch);\n \n-  for (i = 1; VEC_iterate (eh_landing_pad, cfun->eh->lp_array, i, lp); ++i)\n+  for (i = 1; vec_safe_iterate (cfun->eh->lp_array, i, &lp); ++i)\n     if (lp && lp->post_landing_pad)\n       {\n \trtx seq2, label;\n@@ -1305,7 +1304,7 @@ sjlj_emit_dispatch_table (rtx dispatch_label, int num_dispatch)\n \t    t_label = create_artificial_label (UNKNOWN_LOCATION);\n \t    t = build_int_cst (integer_type_node, disp_index);\n \t    case_elt = build_case_label (t, NULL, t_label);\n-\t    VEC_quick_push (tree, dispatch_labels, case_elt);\n+\t    dispatch_labels.quick_push (case_elt);\n \t    label = label_rtx (t_label);\n \t  }\n \telse\n@@ -1398,10 +1397,10 @@ sjlj_build_landing_pads (void)\n {\n   int num_dispatch;\n \n-  num_dispatch = VEC_length (eh_landing_pad, cfun->eh->lp_array);\n+  num_dispatch = vec_safe_length (cfun->eh->lp_array);\n   if (num_dispatch == 0)\n     return;\n-  VEC_safe_grow (int, heap, sjlj_lp_call_site_index, num_dispatch);\n+  sjlj_lp_call_site_index.safe_grow_cleared (num_dispatch);\n \n   num_dispatch = sjlj_assign_call_site_values ();\n   if (num_dispatch > 0)\n@@ -1438,7 +1437,7 @@ sjlj_build_landing_pads (void)\n       sjlj_emit_function_exit ();\n     }\n \n-  VEC_free (int, heap, sjlj_lp_call_site_index);\n+  sjlj_lp_call_site_index.release ();\n }\n \n /* After initial rtl generation, call back to finish generating\n@@ -1505,7 +1504,7 @@ remove_eh_landing_pad (eh_landing_pad lp)\n \n   if (lp->post_landing_pad)\n     EH_LANDING_PAD_NR (lp->post_landing_pad) = 0;\n-  VEC_replace (eh_landing_pad, cfun->eh->lp_array, lp->index, NULL);\n+  (*cfun->eh->lp_array)[lp->index] = NULL;\n }\n \n /* Splice REGION from the region tree.  */\n@@ -1520,7 +1519,7 @@ remove_eh_handler (eh_region region)\n     {\n       if (lp->post_landing_pad)\n \tEH_LANDING_PAD_NR (lp->post_landing_pad) = 0;\n-      VEC_replace (eh_landing_pad, cfun->eh->lp_array, lp->index, NULL);\n+      (*cfun->eh->lp_array)[lp->index] = NULL;\n     }\n \n   outer = region->outer;\n@@ -1543,7 +1542,7 @@ remove_eh_handler (eh_region region)\n     }\n   *pp = region->next_peer;\n \n-  VEC_replace (eh_region, cfun->eh->region_array, region->index, NULL);\n+  (*cfun->eh->region_array)[region->index] = NULL;\n }\n \n /* Invokes CALLBACK for every exception handler landing pad label.\n@@ -1555,7 +1554,7 @@ for_each_eh_label (void (*callback) (rtx))\n   eh_landing_pad lp;\n   int i;\n \n-  for (i = 1; VEC_iterate (eh_landing_pad, cfun->eh->lp_array, i, lp); ++i)\n+  for (i = 1; vec_safe_iterate (cfun->eh->lp_array, i, &lp); ++i)\n     {\n       if (lp)\n \t{\n@@ -1713,10 +1712,10 @@ get_eh_region_and_lp_from_rtx (const_rtx insn, eh_region *pr,\n     }\n \n   if (lp_nr < 0)\n-    r = VEC_index (eh_region, cfun->eh->region_array, -lp_nr);\n+    r = (*cfun->eh->region_array)[-lp_nr];\n   else\n     {\n-      lp = VEC_index (eh_landing_pad, cfun->eh->lp_array, lp_nr);\n+      lp = (*cfun->eh->lp_array)[lp_nr];\n       r = lp->region;\n     }\n \n@@ -1950,7 +1949,7 @@ expand_builtin_eh_common (tree region_nr_t)\n   gcc_assert (host_integerp (region_nr_t, 0));\n   region_nr = tree_low_cst (region_nr_t, 0);\n \n-  region = VEC_index (eh_region, cfun->eh->region_array, region_nr);\n+  region = (*cfun->eh->region_array)[region_nr];\n \n   /* ??? We shouldn't have been able to delete a eh region without\n      deleting all the code that depended on it.  */\n@@ -2247,7 +2246,7 @@ add_action_record (htab_t ar_hash, int filter, int next)\n   if ((new_ar = *slot) == NULL)\n     {\n       new_ar = XNEW (struct action_record);\n-      new_ar->offset = VEC_length (uchar, crtl->eh.action_record_data) + 1;\n+      new_ar->offset = crtl->eh.action_record_data->length () + 1;\n       new_ar->filter = filter;\n       new_ar->next = next;\n       *slot = new_ar;\n@@ -2259,7 +2258,7 @@ add_action_record (htab_t ar_hash, int filter, int next)\n \n       push_sleb128 (&crtl->eh.action_record_data, filter);\n       if (next)\n-\tnext -= VEC_length (uchar, crtl->eh.action_record_data) + 1;\n+\tnext -= crtl->eh.action_record_data->length () + 1;\n       push_sleb128 (&crtl->eh.action_record_data, next);\n     }\n \n@@ -2383,11 +2382,9 @@ add_call_site (rtx landing_pad, int action, int section)\n   record->landing_pad = landing_pad;\n   record->action = action;\n \n-  VEC_safe_push (call_site_record, gc,\n-\t\t crtl->eh.call_site_record_v[section], record);\n+  vec_safe_push (crtl->eh.call_site_record_v[section], record);\n \n-  return call_site_base + VEC_length (call_site_record,\n-\t\t\t\t      crtl->eh.call_site_record_v[section]) - 1;\n+  return call_site_base + crtl->eh.call_site_record_v[section]->length () - 1;\n }\n \n /* Turn REG_EH_REGION notes back into NOTE_INSN_EH_REGION notes.\n@@ -2410,7 +2407,7 @@ convert_to_eh_region_ranges (void)\n   rtx last_no_action_insn_before_switch = NULL_RTX;\n   int saved_call_site_base = call_site_base;\n \n-  crtl->eh.action_record_data = VEC_alloc (uchar, gc, 64);\n+  vec_alloc (crtl->eh.action_record_data, 64);\n \n   ar_hash = htab_create (31, action_record_hash, action_record_eq, free);\n \n@@ -2534,12 +2531,11 @@ convert_to_eh_region_ranges (void)\n \t   opening a new one afterwards.  */\n \telse if (last_action != -3)\n \t  last_landing_pad = pc_rtx;\n-\tcall_site_base += VEC_length (call_site_record,\n-\t\t\t\t      crtl->eh.call_site_record_v[cur_sec]);\n+\tif (crtl->eh.call_site_record_v[cur_sec])\n+\t  call_site_base += crtl->eh.call_site_record_v[cur_sec]->length ();\n \tcur_sec++;\n \tgcc_assert (crtl->eh.call_site_record_v[cur_sec] == NULL);\n-\tcrtl->eh.call_site_record_v[cur_sec]\n-\t  = VEC_alloc (call_site_record, gc, 10);\n+\tvec_alloc (crtl->eh.call_site_record_v[cur_sec], 10);\n       }\n \n   if (last_action >= -1 && ! first_no_action_insn)\n@@ -2586,21 +2582,21 @@ struct rtl_opt_pass pass_convert_to_eh_region_ranges =\n };\n \f\n static void\n-push_uleb128 (VEC (uchar, gc) **data_area, unsigned int value)\n+push_uleb128 (vec<uchar, va_gc> **data_area, unsigned int value)\n {\n   do\n     {\n       unsigned char byte = value & 0x7f;\n       value >>= 7;\n       if (value)\n \tbyte |= 0x80;\n-      VEC_safe_push (uchar, gc, *data_area, byte);\n+      vec_safe_push (*data_area, byte);\n     }\n   while (value);\n }\n \n static void\n-push_sleb128 (VEC (uchar, gc) **data_area, int value)\n+push_sleb128 (vec<uchar, va_gc> **data_area, int value)\n {\n   unsigned char byte;\n   int more;\n@@ -2613,7 +2609,7 @@ push_sleb128 (VEC (uchar, gc) **data_area, int value)\n \t\t|| (value == -1 && (byte & 0x40) != 0));\n       if (more)\n \tbyte |= 0x80;\n-      VEC_safe_push (uchar, gc, *data_area, byte);\n+      vec_safe_push (*data_area, byte);\n     }\n   while (more);\n }\n@@ -2623,14 +2619,14 @@ push_sleb128 (VEC (uchar, gc) **data_area, int value)\n static int\n dw2_size_of_call_site_table (int section)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[section]);\n+  int n = vec_safe_length (crtl->eh.call_site_record_v[section]);\n   int size = n * (4 + 4 + 4);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record_v[section], i);\n+\t(*crtl->eh.call_site_record_v[section])[i];\n       size += size_of_uleb128 (cs->action);\n     }\n \n@@ -2640,14 +2636,14 @@ dw2_size_of_call_site_table (int section)\n static int\n sjlj_size_of_call_site_table (void)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[0]);\n+  int n = vec_safe_length (crtl->eh.call_site_record_v[0]);\n   int size = 0;\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record_v[0], i);\n+\t(*crtl->eh.call_site_record_v[0])[i];\n       size += size_of_uleb128 (INTVAL (cs->landing_pad));\n       size += size_of_uleb128 (cs->action);\n     }\n@@ -2659,7 +2655,7 @@ sjlj_size_of_call_site_table (void)\n static void\n dw2_output_call_site_table (int cs_format, int section)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[section]);\n+  int n = vec_safe_length (crtl->eh.call_site_record_v[section]);\n   int i;\n   const char *begin;\n \n@@ -2672,8 +2668,7 @@ dw2_output_call_site_table (int cs_format, int section)\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record_v[section], i);\n+      struct call_site_record_d *cs = (*crtl->eh.call_site_record_v[section])[i];\n       char reg_start_lab[32];\n       char reg_end_lab[32];\n       char landing_pad_lab[32];\n@@ -2721,13 +2716,12 @@ dw2_output_call_site_table (int cs_format, int section)\n static void\n sjlj_output_call_site_table (void)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[0]);\n+  int n = vec_safe_length (crtl->eh.call_site_record_v[0]);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record_v[0], i);\n+      struct call_site_record_d *cs = (*crtl->eh.call_site_record_v[0])[i];\n \n       dw2_asm_output_data_uleb128 (INTVAL (cs->landing_pad),\n \t\t\t\t   \"region %d landing pad\", i);\n@@ -2856,10 +2850,10 @@ output_one_function_exception_table (int section)\n   int have_tt_data;\n   int tt_format_size = 0;\n \n-  have_tt_data = (VEC_length (tree, cfun->eh->ttype_data)\n+  have_tt_data = (vec_safe_length (cfun->eh->ttype_data)\n \t\t  || (targetm.arm_eabi_unwinder\n-\t\t      ? VEC_length (tree, cfun->eh->ehspec_data.arm_eabi)\n-\t\t      : VEC_length (uchar, cfun->eh->ehspec_data.other)));\n+\t\t      ? vec_safe_length (cfun->eh->ehspec_data.arm_eabi)\n+\t\t      : vec_safe_length (cfun->eh->ehspec_data.other)));\n \n   /* Indicate the format of the @TType entries.  */\n   if (! have_tt_data)\n@@ -2922,8 +2916,8 @@ output_one_function_exception_table (int section)\n       before_disp = 1 + 1;\n       after_disp = (1 + size_of_uleb128 (call_site_len)\n \t\t    + call_site_len\n-\t\t    + VEC_length (uchar, crtl->eh.action_record_data)\n-\t\t    + (VEC_length (tree, cfun->eh->ttype_data)\n+\t\t    + vec_safe_length (crtl->eh.action_record_data)\n+\t\t    + (vec_safe_length (cfun->eh->ttype_data)\n \t\t       * tt_format_size));\n \n       disp = after_disp;\n@@ -2981,17 +2975,17 @@ output_one_function_exception_table (int section)\n   /* ??? Decode and interpret the data for flag_debug_asm.  */\n   {\n     uchar uc;\n-    FOR_EACH_VEC_ELT (uchar, crtl->eh.action_record_data, i, uc)\n+    FOR_EACH_VEC_ELT (*crtl->eh.action_record_data, i, uc)\n       dw2_asm_output_data (1, uc, i ? NULL : \"Action record table\");\n   }\n \n   if (have_tt_data)\n     assemble_align (tt_format_size * BITS_PER_UNIT);\n \n-  i = VEC_length (tree, cfun->eh->ttype_data);\n+  i = vec_safe_length (cfun->eh->ttype_data);\n   while (i-- > 0)\n     {\n-      tree type = VEC_index (tree, cfun->eh->ttype_data, i);\n+      tree type = (*cfun->eh->ttype_data)[i];\n       output_ttype (type, tt_format, tt_format_size);\n     }\n \n@@ -3005,14 +2999,14 @@ output_one_function_exception_table (int section)\n     {\n       tree type;\n       for (i = 0;\n-\t   VEC_iterate (tree, cfun->eh->ehspec_data.arm_eabi, i, type); ++i)\n+\t   vec_safe_iterate (cfun->eh->ehspec_data.arm_eabi, i, &type); ++i)\n \toutput_ttype (type, tt_format, tt_format_size);\n     }\n   else\n     {\n       uchar uc;\n       for (i = 0;\n-\t   VEC_iterate (uchar, cfun->eh->ehspec_data.other, i, uc); ++i)\n+\t   vec_safe_iterate (cfun->eh->ehspec_data.other, i, &uc); ++i)\n \tdw2_asm_output_data (1, uc,\n \t\t\t     i ? NULL : \"Exception specification table\");\n     }\n@@ -3041,7 +3035,7 @@ output_function_exception_table (const char *fnname)\n   targetm.asm_out.emit_except_table_label (asm_out_file);\n \n   output_one_function_exception_table (0);\n-  if (crtl->eh.call_site_record_v[1] != NULL)\n+  if (crtl->eh.call_site_record_v[1])\n     output_one_function_exception_table (1);\n \n   switch_to_section (current_function_section ());\n@@ -3232,7 +3226,7 @@ verify_eh_tree (struct function *fun)\n     return;\n \n   count_r = 0;\n-  for (i = 1; VEC_iterate (eh_region, fun->eh->region_array, i, r); ++i)\n+  for (i = 1; vec_safe_iterate (fun->eh->region_array, i, &r); ++i)\n     if (r)\n       {\n \tif (r->index == i)\n@@ -3245,7 +3239,7 @@ verify_eh_tree (struct function *fun)\n       }\n \n   count_lp = 0;\n-  for (i = 1; VEC_iterate (eh_landing_pad, fun->eh->lp_array, i, lp); ++i)\n+  for (i = 1; vec_safe_iterate (fun->eh->lp_array, i, &lp); ++i)\n     if (lp)\n       {\n \tif (lp->index == i)\n@@ -3262,7 +3256,7 @@ verify_eh_tree (struct function *fun)\n   r = fun->eh->region_tree;\n   while (1)\n     {\n-      if (VEC_index (eh_region, fun->eh->region_array, r->index) != r)\n+      if ((*fun->eh->region_array)[r->index] != r)\n \t{\n \t  error (\"region_array is corrupted for region %i\", r->index);\n \t  err = true;\n@@ -3281,7 +3275,7 @@ verify_eh_tree (struct function *fun)\n \n       for (lp = r->landing_pads; lp ; lp = lp->next_lp)\n \t{\n-\t  if (VEC_index (eh_landing_pad, fun->eh->lp_array, lp->index) != lp)\n+\t  if ((*fun->eh->lp_array)[lp->index] != lp)\n \t    {\n \t      error (\"lp_array is corrupted for lp %i\", lp->index);\n \t      err = true;"}, {"sha": "473bbfceda843107730317601bf192acbae664fb", "filename": "gcc/except.h", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -27,8 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n #include \"hashtab.h\"\n-#include \"vecprim.h\"\n-#include \"vecir.h\"\n \n struct function;\n struct eh_region_d;\n@@ -189,12 +187,7 @@ typedef struct eh_landing_pad_d *eh_landing_pad;\n typedef struct eh_catch_d *eh_catch;\n typedef struct eh_region_d *eh_region;\n \n-DEF_VEC_P(eh_region);\n-DEF_VEC_ALLOC_P(eh_region, gc);\n-DEF_VEC_ALLOC_P(eh_region, heap);\n \n-DEF_VEC_P(eh_landing_pad);\n-DEF_VEC_ALLOC_P(eh_landing_pad, gc);\n \n \n /* The exception status for each function.  */\n@@ -205,26 +198,26 @@ struct GTY(()) eh_status\n   eh_region region_tree;\n \n   /* The same information as an indexable array.  */\n-  VEC(eh_region,gc) *region_array;\n+  vec<eh_region, va_gc> *region_array;\n \n   /* The landing pads as an indexable array.  */\n-  VEC(eh_landing_pad,gc) *lp_array;\n+  vec<eh_landing_pad, va_gc> *lp_array;\n \n   /* At the gimple level, a mapping from gimple statement to landing pad\n      or must-not-throw region.  See record_stmt_eh_region.  */\n   htab_t GTY((param_is (struct throw_stmt_node))) throw_stmt_table;\n \n   /* All of the runtime type data used by the function.  These objects\n      are emitted to the lang-specific-data-area for the function.  */\n-  VEC(tree,gc) *ttype_data;\n+  vec<tree, va_gc> *ttype_data;\n \n   /* The table of all action chains.  These encode the eh_region tree in\n      a compact form for use by the runtime, and is also emitted to the\n      lang-specific-data-area.  Note that the ARM EABI uses a different\n      format for the encoding than all other ports.  */\n   union eh_status_u {\n-    VEC(tree,gc) * GTY((tag (\"1\"))) arm_eabi;\n-    VEC(uchar,gc) * GTY((tag (\"0\"))) other;\n+    vec<tree, va_gc> *GTY((tag (\"1\"))) arm_eabi;\n+    vec<uchar, va_gc> *GTY((tag (\"0\"))) other;\n   } GTY ((desc (\"targetm.arm_eabi_unwinder\"))) ehspec_data;\n };\n "}, {"sha": "d1da390e2827ddc79e0fff33c55d58d8b51b73be", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -5779,7 +5779,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t   register whose mode size isn't equal to SIZE since\n \t   clear_storage can't handle this case.  */\n \telse if (size > 0\n-\t\t && (((int)VEC_length (constructor_elt, CONSTRUCTOR_ELTS (exp))\n+\t\t && (((int)vec_safe_length (CONSTRUCTOR_ELTS (exp))\n \t\t      != fields_length (type))\n \t\t     || mostly_zeros_p (exp))\n \t\t && (!REG_P (target)\n@@ -6241,7 +6241,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n         /* Store each element of the constructor into the corresponding\n \t   element of TARGET, determined by counting the elements.  */\n \tfor (idx = 0, i = 0;\n-\t     VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), idx, ce);\n+\t     vec_safe_iterate (CONSTRUCTOR_ELTS (exp), idx, &ce);\n \t     idx++, i += bitsize / elt_size)\n \t  {\n \t    HOST_WIDE_INT eltpos;\n@@ -7131,7 +7131,7 @@ safe_from_p (const_rtx x, tree exp, int top_p)\n \t  constructor_elt *ce;\n \t  unsigned HOST_WIDE_INT idx;\n \n-\t  FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (exp), idx, ce)\n+\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (exp), idx, ce)\n \t    if ((ce->index != NULL_TREE && !safe_from_p (x, ce->index, 0))\n \t\t|| !safe_from_p (x, ce->value, 0))\n \t      return 0;\n@@ -9325,9 +9325,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  }\n \tif (!tmp)\n \t  {\n-\t    VEC(constructor_elt,gc) *v;\n+\t    vec<constructor_elt, va_gc> *v;\n \t    unsigned i;\n-\t    v = VEC_alloc (constructor_elt, gc, VECTOR_CST_NELTS (exp));\n+\t    vec_alloc (v, VECTOR_CST_NELTS (exp));\n \t    for (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n \t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, VECTOR_CST_ELT (exp, i));\n \t    tmp = build_constructor (type, v);"}, {"sha": "7ad5f8192e4a75790ed73026c1f475a86923a003", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -740,6 +740,6 @@ rtx get_personality_function (tree);\n extern void expand_case (gimple);\n \n /* Like expand_case but special-case for SJLJ exception dispatching.  */\n-extern void expand_sjlj_dispatch_table (rtx, VEC(tree,heap) *);\n+extern void expand_sjlj_dispatch_table (rtx, vec<tree> );\n \n #endif /* GCC_EXPR_H */"}, {"sha": "2bd6aebe4bc9463be19bdbc6b84d70cd65f96014", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -77,7 +77,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"coverage.h\"\n #include \"df.h\"\n-#include \"vecprim.h\"\n #include \"ggc.h\"\n #include \"cfgloop.h\"\n #include \"params.h\"\n@@ -309,7 +308,7 @@ dbr_sequence_length (void)\n \n static int *insn_lengths;\n \n-VEC(int,heap) *insn_addresses_;\n+vec<int> insn_addresses_;\n \n /* Max uid for which the above arrays are valid.  */\n static int insn_lengths_max_uid;"}, {"sha": "4dcd3220390e335a4c1a5f34f5b85356d0f3ad53", "filename": "gcc/fold-const.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -9612,7 +9612,7 @@ vec_cst_ctor_to_array (tree arg, tree *elts)\n     {\n       constructor_elt *elt;\n \n-      FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (arg), i, elt)\n+      FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (arg), i, elt)\n \tif (i >= nelts || TREE_CODE (TREE_TYPE (elt->value)) == VECTOR_TYPE)\n \t  return false;\n \telse\n@@ -9657,7 +9657,8 @@ fold_vec_perm (tree type, tree arg0, tree arg1, const unsigned char *sel)\n \n   if (need_ctor)\n     {\n-      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, nelts);\n+      vec<constructor_elt, va_gc> *v;\n+      vec_alloc (v, nelts);\n       for (i = 0; i < nelts; i++)\n \tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[2 * nelts + i]);\n       return build_constructor (type, v);\n@@ -14094,15 +14095,16 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      VEC(constructor_elt, gc) *vals;\n+\t\t      vec<constructor_elt, va_gc> *vals;\n \t\t      unsigned i;\n \t\t      if (CONSTRUCTOR_NELTS (arg0) == 0)\n-\t\t\treturn build_constructor (type, NULL);\n+\t\t\treturn build_constructor (type,\n+\t\t\t\t\t      NULL);\n \t\t      if (TREE_CODE (TREE_TYPE (CONSTRUCTOR_ELT (arg0,\n \t\t\t\t\t\t\t\t 0)->value))\n \t\t\t  != VECTOR_TYPE)\n \t\t\t{\n-\t\t\t  vals = VEC_alloc (constructor_elt, gc, n);\n+\t\t\t  vec_alloc (vals, n);\n \t\t\t  for (i = 0;\n \t\t\t       i < n && idx + i < CONSTRUCTOR_NELTS (arg0);\n \t\t\t       ++i)\n@@ -14347,15 +14349,15 @@ fold (tree expr)\n \t    && TREE_CODE (op0) == CONSTRUCTOR\n \t    && ! type_contains_placeholder_p (TREE_TYPE (op0)))\n \t  {\n-\t    VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (op0);\n-\t    unsigned HOST_WIDE_INT end = VEC_length (constructor_elt, elts);\n+\t    vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (op0);\n+\t    unsigned HOST_WIDE_INT end = vec_safe_length (elts);\n \t    unsigned HOST_WIDE_INT begin = 0;\n \n \t    /* Find a matching index by means of a binary search.  */\n \t    while (begin != end)\n \t      {\n \t\tunsigned HOST_WIDE_INT middle = (begin + end) / 2;\n-\t\ttree index = VEC_index (constructor_elt, elts, middle).index;\n+\t\ttree index = (*elts)[middle].index;\n \n \t\tif (TREE_CODE (index) == INTEGER_CST\n \t\t    && tree_int_cst_lt (index, op1))\n@@ -14370,7 +14372,7 @@ fold (tree expr)\n \t\t\t && tree_int_cst_lt (op1, TREE_OPERAND (index, 0)))\n \t\t  end = middle;\n \t\telse\n-\t\t  return VEC_index (constructor_elt, elts, middle).value;\n+\t\t  return (*elts)[middle].value;\n \t      }\n \t  }\n "}, {"sha": "c704838b723ff731f7433b5a2e1f93bc3d157e68", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1,3 +1,18 @@\n+2012-11-17  Diego Novillo  <dnovillo@google.com>\n+\n+\tAdjust for new vec API (http://gcc.gnu.org/wiki/cxx-conversion/cxx-vec)\n+\n+\t* frontend-passes.c: Use new vec API in vec.h.\n+\t* trans-array.c: Likewise.\n+\t* trans-common.c: Likewise.\n+\t* trans-decl.c: Likewise.\n+\t* trans-expr.c: Likewise.\n+\t* trans-intrinsic.c: Likewise.\n+\t* trans-openmp.c: Likewise.\n+\t* trans-stmt.c: Likewise.\n+\t* trans-types.c: Likewise.\n+\t* trans.h: Likewise.\n+\n 2012-11-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/55341\n@@ -12,6 +27,7 @@\n \t* resolve.c (resolve_typebound_intrinsic_op): Only add typebound\n \toperators to the operator list in the namespace of the derived type.\n \n+\n 2012-11-12  Jan Hubicka  <jh@suse.cz>\n \n \t* f95-lang.c (ATTR_NOTHROW_LEAF_MALLOC_LIST): New macro."}, {"sha": "287807efbc340d7c67e6caea641996824dd8eee1", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -38,7 +38,7 @@ static bool optimize_comparison (gfc_expr *, gfc_intrinsic_op);\n static bool optimize_trim (gfc_expr *);\n static bool optimize_lexical_comparison (gfc_expr *);\n static void optimize_minmaxloc (gfc_expr **);\n-static bool empty_string (gfc_expr *e);\n+static bool is_empty_string (gfc_expr *e);\n \n /* How deep we are inside an argument list.  */\n \n@@ -742,7 +742,7 @@ optimize_assignment (gfc_code * c)\n       remove_trim (rhs);\n \n       /* Replace a = '   ' by a = '' to optimize away a memcpy.  */\n-      if (empty_string(rhs))\n+      if (is_empty_string(rhs))\n \trhs->value.character.length = 0;\n     }\n \n@@ -865,7 +865,7 @@ optimize_op (gfc_expr *e)\n /* Return true if a constant string contains only blanks.  */\n \n static bool\n-empty_string (gfc_expr *e)\n+is_empty_string (gfc_expr *e)\n {\n   int i;\n \n@@ -967,8 +967,8 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n       && (op == INTRINSIC_EQ || op == INTRINSIC_NE))\n     {\n       bool empty_op1, empty_op2;\n-      empty_op1 = empty_string (op1);\n-      empty_op2 = empty_string (op2);\n+      empty_op1 = is_empty_string (op1);\n+      empty_op2 = is_empty_string (op2);\n \n       if (empty_op1 || empty_op2)\n \t{"}, {"sha": "24adfdeafbe71bb0726d4a5b1d5b327a6220265c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1626,7 +1626,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  else\n \t    {\n \t      /* Collect multiple scalar constants into a constructor.  */\n-\t      VEC(constructor_elt,gc) *v = NULL;\n+\t      vec<constructor_elt, va_gc> *v = NULL;\n \t      tree init;\n \t      tree bound;\n \t      tree tmptype;\n@@ -1985,7 +1985,7 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n   gfc_array_spec as;\n   gfc_se se;\n   int i;\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n \n   /* First traverse the constructor list, converting the constants\n      to tree to build an initializer.  */\n@@ -5317,7 +5317,7 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n   HOST_WIDE_INT hi;\n   unsigned HOST_WIDE_INT lo;\n   tree index, range;\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n \n   if (expr->expr_type == EXPR_VARIABLE\n       && expr->symtree->n.sym->attr.flavor == FL_PARAMETER"}, {"sha": "474774fe8f6eb061c8f0b0588fdd9e812f263396", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -487,7 +487,7 @@ get_init_field (segment_info *head, tree union_type, tree *field_init,\n   tree tmp, field;\n   tree init;\n   unsigned char *data, *chk;\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n \n   tree type = unsigned_char_type_node;\n   int i;\n@@ -644,7 +644,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n   if (is_init)\n     {\n       tree ctor, tmp;\n-      VEC(constructor_elt,gc) *v = NULL;\n+      vec<constructor_elt, va_gc> *v = NULL;\n \n       if (field != NULL_TREE && field_init != NULL_TREE)\n \tCONSTRUCTOR_APPEND_ELT (v, field, field_init);\n@@ -664,7 +664,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n \t      }\n \t  }\n \n-      gcc_assert (!VEC_empty (constructor_elt, v));\n+      gcc_assert (!v->is_empty ());\n       ctor = build_constructor (union_type, v);\n       TREE_CONSTANT (ctor) = 1;\n       TREE_STATIC (ctor) = 1;"}, {"sha": "c661fb358ac56eb72c796c4e81c812e8914fc942", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -2284,8 +2284,8 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n   gfc_save_backend_locus (&old_loc);\n   for (el = ns->entries; el; el = el->next)\n     {\n-      VEC(tree,gc) *args = NULL;\n-      VEC(tree,gc) *string_args = NULL;\n+      vec<tree, va_gc> *args = NULL;\n+      vec<tree, va_gc> *string_args = NULL;\n \n       thunk_sym = el->sym;\n       \n@@ -2300,16 +2300,16 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n \n       /* Pass extra parameter identifying this entry point.  */\n       tmp = build_int_cst (gfc_array_index_type, el->id);\n-      VEC_safe_push (tree, gc, args, tmp);\n+      vec_safe_push (args, tmp);\n \n       if (thunk_sym->attr.function)\n \t{\n \t  if (gfc_return_by_reference (ns->proc_name))\n \t    {\n \t      tree ref = DECL_ARGUMENTS (current_function_decl);\n-\t      VEC_safe_push (tree, gc, args, ref);\n+\t      vec_safe_push (args, ref);\n \t      if (ns->proc_name->ts.type == BT_CHARACTER)\n-\t\tVEC_safe_push (tree, gc, args, DECL_CHAIN (ref));\n+\t\tvec_safe_push (args, DECL_CHAIN (ref));\n \t    }\n \t}\n \n@@ -2333,27 +2333,27 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n \t    {\n \t      /* Pass the argument.  */\n \t      DECL_ARTIFICIAL (thunk_formal->sym->backend_decl) = 1;\n-\t      VEC_safe_push (tree, gc, args, thunk_formal->sym->backend_decl);\n+\t      vec_safe_push (args, thunk_formal->sym->backend_decl);\n \t      if (formal->sym->ts.type == BT_CHARACTER)\n \t\t{\n \t\t  tmp = thunk_formal->sym->ts.u.cl->backend_decl;\n-\t\t  VEC_safe_push (tree, gc, string_args, tmp);\n+\t\t  vec_safe_push (string_args, tmp);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      /* Pass NULL for a missing argument.  */\n-\t      VEC_safe_push (tree, gc, args, null_pointer_node);\n+\t      vec_safe_push (args, null_pointer_node);\n \t      if (formal->sym->ts.type == BT_CHARACTER)\n \t\t{\n \t\t  tmp = build_int_cst (gfc_charlen_type_node, 0);\n-\t\t  VEC_safe_push (tree, gc, string_args, tmp);\n+\t\t  vec_safe_push (string_args, tmp);\n \t\t}\n \t    }\n \t}\n \n       /* Call the master function.  */\n-      VEC_safe_splice (tree, gc, args, string_args);\n+      vec_safe_splice (args, string_args);\n       tmp = ns->proc_name->backend_decl;\n       tmp = build_call_expr_loc_vec (input_location, tmp, args);\n       if (ns->proc_name->attr.mixed_entry_master)\n@@ -2616,7 +2616,7 @@ static tree\n build_library_function_decl_1 (tree name, const char *spec,\n \t\t\t       tree rettype, int nargs, va_list p)\n {\n-  VEC(tree,gc) *arglist;\n+  vec<tree, va_gc> *arglist;\n   tree fntype;\n   tree fndecl;\n   int n;\n@@ -2625,11 +2625,11 @@ build_library_function_decl_1 (tree name, const char *spec,\n   gcc_assert (current_function_decl == NULL_TREE);\n \n   /* Create a list of the argument types.  */\n-  arglist = VEC_alloc (tree, gc, abs (nargs));\n+  vec_alloc (arglist, abs (nargs));\n   for (n = abs (nargs); n > 0; n--)\n     {\n       tree argtype = va_arg (p, tree);\n-      VEC_quick_push (tree, arglist, argtype);\n+      arglist->quick_push (argtype);\n     }\n \n   /* Build the function type and decl.  */\n@@ -5005,7 +5005,7 @@ create_main_function (tree fndecl)\n      language standard parameters.  */\n   {\n     tree array_type, array, var;\n-    VEC(constructor_elt,gc) *v = NULL;\n+    vec<constructor_elt, va_gc> *v = NULL;\n \n     /* Passing a new option to the library requires four modifications:\n      + add it to the tree_cons list below"}, {"sha": "d6410d3ac493aa89e479179685a2c94c5d2b9aa5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -661,7 +661,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems)\n   tree to_data;\n   tree to_ref;\n   tree from_ref;\n-  VEC(tree,gc) *args;\n+  vec<tree, va_gc> *args;\n   tree tmp;\n   tree index;\n   stmtblock_t loopbody;\n@@ -696,13 +696,13 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems)\n       if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data)))\n \t{\n \t  from_ref = gfc_get_class_array_ref (index, from);\n-\t  VEC_safe_push (tree, gc, args, from_ref);\n+\t  vec_safe_push (args, from_ref);\n \t}\n       else\n-        VEC_safe_push (tree, gc, args, from_data);\n+        vec_safe_push (args, from_data);\n \n       to_ref = gfc_get_class_array_ref (index, to);\n-      VEC_safe_push (tree, gc, args, to_ref);\n+      vec_safe_push (args, to_ref);\n \n       tmp = build_call_vec (fcn_type, fcn, args);\n \n@@ -724,8 +724,8 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems)\n   else\n     {\n       gcc_assert (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data)));\n-      VEC_safe_push (tree, gc, args, from_data);\n-      VEC_safe_push (tree, gc, args, to_data);\n+      vec_safe_push (args, from_data);\n+      vec_safe_push (args, to_data);\n       tmp = build_call_vec (fcn_type, fcn, args);\n     }\n \n@@ -3822,11 +3822,11 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n int\n gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t gfc_actual_arglist * args, gfc_expr * expr,\n-\t\t\t VEC(tree,gc) *append_args)\n+\t\t\t vec<tree, va_gc> *append_args)\n {\n   gfc_interface_mapping mapping;\n-  VEC(tree,gc) *arglist;\n-  VEC(tree,gc) *retargs;\n+  vec<tree, va_gc> *arglist;\n+  vec<tree, va_gc> *retargs;\n   tree tmp;\n   tree fntype;\n   gfc_se parmse;\n@@ -3837,7 +3837,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   tree var;\n   tree len;\n   tree base_object;\n-  VEC(tree,gc) *stringargs;\n+  vec<tree, va_gc> *stringargs;\n   tree result = NULL;\n   gfc_formal_arglist *formal;\n   gfc_actual_arglist *arg;\n@@ -4608,7 +4608,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       /* Character strings are passed as two parameters, a length and a\n          pointer - except for Bind(c) which only passes the pointer.  */\n       if (parmse.string_length != NULL_TREE && !sym->attr.is_bind_c)\n-\tVEC_safe_push (tree, gc, stringargs, parmse.string_length);\n+\tvec_safe_push (stringargs, parmse.string_length);\n \n       /* For descriptorless coarrays and assumed-shape coarray dummies, we\n \t pass the token and the offset as additional arguments.  */\n@@ -4618,9 +4618,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  && e == NULL)\n \t{\n \t  /* Token and offset. */\n-\t  VEC_safe_push (tree, gc, stringargs, null_pointer_node);\n-\t  VEC_safe_push (tree, gc, stringargs,\n-\t\t\t build_int_cst (gfc_array_index_type, 0));\n+\t  vec_safe_push (stringargs, null_pointer_node);\n+\t  vec_safe_push (stringargs, build_int_cst (gfc_array_index_type, 0));\n \t  gcc_assert (fsym->attr.optional);\n \t}\n       else if (fsym && fsym->attr.codimension\n@@ -4646,7 +4645,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      tmp = GFC_TYPE_ARRAY_CAF_TOKEN (caf_type);\n \t    }\n \t  \n-\t  VEC_safe_push (tree, gc, stringargs, tmp);\n+\t  vec_safe_push (stringargs, tmp);\n \n \t  if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n \t      && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n@@ -4692,10 +4691,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  offset = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t    gfc_array_index_type, offset, tmp);\n \n-\t  VEC_safe_push (tree, gc, stringargs, offset);\n+\t  vec_safe_push (stringargs, offset);\n \t}\n \n-      VEC_safe_push (tree, gc, arglist, parmse.expr);\n+      vec_safe_push (arglist, parmse.expr);\n     }\n   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);\n \n@@ -4719,7 +4718,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  if (ts.deferred)\n \t    cl.backend_decl = gfc_create_var (gfc_charlen_type_node, \"slen\");\n \t  else if (!sym->attr.dummy)\n-\t    cl.backend_decl = VEC_index (tree, stringargs, 0);\n+\t    cl.backend_decl = (*stringargs)[0];\n \t  else\n \t    {\n \t      formal = sym->ns->proc_name->formal;\n@@ -4796,7 +4795,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    result = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t  se->expr);\n-\t  VEC_safe_push (tree, gc, retargs, se->expr);\n+\t  vec_safe_push (retargs, se->expr);\n \t}\n       else if (comp && comp->attr.dimension)\n \t{\n@@ -4832,7 +4831,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Pass the temporary as the first argument.  */\n \t  result = info->descriptor;\n \t  tmp = gfc_build_addr_expr (NULL_TREE, result);\n-\t  VEC_safe_push (tree, gc, retargs, tmp);\n+\t  vec_safe_push (retargs, tmp);\n \t}\n       else if (!comp && sym->result->attr.dimension)\n \t{\n@@ -4868,7 +4867,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Pass the temporary as the first argument.  */\n \t  result = info->descriptor;\n \t  tmp = gfc_build_addr_expr (NULL_TREE, result);\n-\t  VEC_safe_push (tree, gc, retargs, tmp);\n+\t  vec_safe_push (retargs, tmp);\n \t}\n       else if (ts.type == BT_CHARACTER)\n \t{\n@@ -4899,15 +4898,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    var = gfc_conv_string_tmp (se, type, len);\n \n-\t  VEC_safe_push (tree, gc, retargs, var);\n+\t  vec_safe_push (retargs, var);\n \t}\n       else\n \t{\n \t  gcc_assert (gfc_option.flag_f2c && ts.type == BT_COMPLEX);\n \n \t  type = gfc_get_complex_type (ts.kind);\n \t  var = gfc_build_addr_expr (NULL_TREE, gfc_create_var (type, \"cmplx\"));\n-\t  VEC_safe_push (tree, gc, retargs, var);\n+\t  vec_safe_push (retargs, var);\n \t}\n \n       /* Add the string length to the argument list.  */\n@@ -4917,28 +4916,28 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  if (TREE_CODE (tmp) != VAR_DECL)\n \t    tmp = gfc_evaluate_now (len, &se->pre);\n \t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n-\t  VEC_safe_push (tree, gc, retargs, tmp);\n+\t  vec_safe_push (retargs, tmp);\n \t}\n       else if (ts.type == BT_CHARACTER)\n-\tVEC_safe_push (tree, gc, retargs, len);\n+\tvec_safe_push (retargs, len);\n     }\n   gfc_free_interface_mapping (&mapping);\n \n   /* We need to glom RETARGS + ARGLIST + STRINGARGS + APPEND_ARGS.  */\n-  arglen = (VEC_length (tree, arglist)\n-\t    + VEC_length (tree, stringargs) + VEC_length (tree, append_args));\n-  VEC_reserve_exact (tree, gc, retargs, arglen);\n+  arglen = (vec_safe_length (arglist) + vec_safe_length (stringargs)\n+\t    + vec_safe_length (append_args));\n+  vec_safe_reserve (retargs, arglen);\n \n   /* Add the return arguments.  */\n-  VEC_splice (tree, retargs, arglist);\n+  retargs->splice (arglist);\n \n   /* Add the hidden string length parameters to the arguments.  */\n-  VEC_splice (tree, retargs, stringargs);\n+  retargs->splice (stringargs);\n \n   /* We may want to append extra arguments here.  This is used e.g. for\n      calls to libgfortran_matmul_??, which need extra information.  */\n-  if (!VEC_empty (tree, append_args))\n-    VEC_splice (tree, retargs, append_args);\n+  if (!vec_safe_is_empty (append_args))\n+    retargs->splice (append_args);\n   arglist = retargs;\n \n   /* Generate the actual call.  */\n@@ -5423,7 +5422,8 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n   if (!sym)\n     sym = expr->symtree->n.sym;\n \n-  gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr, NULL);\n+  gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr,\n+\t\t\t   NULL);\n }\n \n \n@@ -5965,7 +5965,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n   tree val;\n   tree type;\n   tree tmp;\n-  VEC(constructor_elt,gc) *v = NULL;\n+  vec<constructor_elt, va_gc> *v = NULL;\n \n   gcc_assert (se->ss == NULL);\n   gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n@@ -7139,7 +7139,8 @@ gfc_trans_zero_assign (gfc_expr * expr)\n      a = {} instead.  */\n   if (!POINTER_TYPE_P (TREE_TYPE (dest)))\n     return build2_loc (input_location, MODIFY_EXPR, void_type_node,\n-\t\t       dest, build_constructor (TREE_TYPE (dest), NULL));\n+\t\t       dest, build_constructor (TREE_TYPE (dest),\n+\t\t\t\t\t      NULL));\n \n   /* Convert arguments to the correct types.  */\n   dest = fold_convert (pvoid_type_node, dest);"}, {"sha": "5d9ce5c4f6902cea0ab7629bb2f9d414734dc39d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -724,7 +724,7 @@ static tree\n gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n {\n   tree type;\n-  VEC(tree,gc) *argtypes;\n+  vec<tree, va_gc> *argtypes;\n   tree fndecl;\n   gfc_actual_arglist *actual;\n   tree *pdecl;\n@@ -809,7 +809,7 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n   for (actual = expr->value.function.actual; actual; actual = actual->next)\n     {\n       type = gfc_typenode_for_spec (&actual->expr->ts);\n-      VEC_safe_push (tree, gc, argtypes, type);\n+      vec_safe_push (argtypes, type);\n     }\n   type = build_function_type_vec (gfc_typenode_for_spec (ts), argtypes);\n   fndecl = build_decl (input_location,\n@@ -2341,7 +2341,7 @@ static void\n gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n {\n   gfc_symbol *sym;\n-  VEC(tree,gc) *append_args;\n+  vec<tree, va_gc> *append_args;\n \n   gcc_assert (!se->ss || se->ss->info->expr == expr);\n \n@@ -2381,19 +2381,19 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n \t\tgemm_fndecl = gfor_fndecl_zgemm;\n \t    }\n \n-\t  append_args = VEC_alloc (tree, gc, 3);\n-\t  VEC_quick_push (tree, append_args, build_int_cst (cint, 1));\n-\t  VEC_quick_push (tree, append_args,\n-\t\t\t  build_int_cst (cint, gfc_option.blas_matmul_limit));\n-\t  VEC_quick_push (tree, append_args,\n-\t\t\t  gfc_build_addr_expr (NULL_TREE, gemm_fndecl));\n+\t  vec_alloc (append_args, 3);\n+\t  append_args->quick_push (build_int_cst (cint, 1));\n+\t  append_args->quick_push (build_int_cst (cint,\n+\t\t                                 gfc_option.blas_matmul_limit));\n+\t  append_args->quick_push (gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t\t\tgemm_fndecl));\n \t}\n       else\n \t{\n-\t  append_args = VEC_alloc (tree, gc, 3);\n-\t  VEC_quick_push (tree, append_args, build_int_cst (cint, 0));\n-\t  VEC_quick_push (tree, append_args, build_int_cst (cint, 0));\n-\t  VEC_quick_push (tree, append_args, null_pointer_node);\n+\t  vec_alloc (append_args, 3);\n+\t  append_args->quick_push (build_int_cst (cint, 0));\n+\t  append_args->quick_push (build_int_cst (cint, 0));\n+\t  append_args->quick_push (null_pointer_node);\n \t}\n     }\n \n@@ -4486,7 +4486,7 @@ conv_generic_with_optional_char_arg (gfc_se* se, gfc_expr* expr,\n   unsigned cur_pos;\n   gfc_actual_arglist* arg;\n   gfc_symbol* sym;\n-  VEC(tree,gc) *append_args;\n+  vec<tree, va_gc> *append_args;\n \n   /* Find the two arguments given as position.  */\n   cur_pos = 0;\n@@ -4516,8 +4516,8 @@ conv_generic_with_optional_char_arg (gfc_se* se, gfc_expr* expr,\n       tree dummy;\n \n       dummy = build_int_cst (gfc_charlen_type_node, 0);\n-      append_args = VEC_alloc (tree, gc, 1);\n-      VEC_quick_push (tree, append_args, dummy);\n+      vec_alloc (append_args, 1);\n+      append_args->quick_push (dummy);\n     }\n \n   /* Build the call itself.  */\n@@ -5985,7 +5985,7 @@ gfc_conv_intrinsic_sr_kind (gfc_se *se, gfc_expr *expr)\n   gfc_actual_arglist *actual;\n   tree type;\n   gfc_se argse;\n-  VEC(tree,gc) *args = NULL;\n+  vec<tree, va_gc> *args = NULL;\n \n   for (actual = expr->value.function.actual; actual; actual = actual->next)\n     {\n@@ -6011,7 +6011,7 @@ gfc_conv_intrinsic_sr_kind (gfc_se *se, gfc_expr *expr)\n \n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);\n-      VEC_safe_push (tree, gc, args, argse.expr);\n+      vec_safe_push (args, argse.expr);\n     }\n \n   /* Convert it to the required type.  */"}, {"sha": "a844b08a31719f15bf857f37d813422555645f8d", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -1293,8 +1293,6 @@ typedef struct dovar_init_d {\n   tree init;\n } dovar_init;\n \n-DEF_VEC_O(dovar_init);\n-DEF_VEC_ALLOC_O(dovar_init,heap);\n \n static tree\n gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n@@ -1307,7 +1305,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n   stmtblock_t body;\n   gfc_omp_clauses *clauses = code->ext.omp_clauses;\n   int i, collapse = clauses->collapse;\n-  VEC(dovar_init,heap) *inits = NULL;\n+  vec<dovar_init> inits = vec<dovar_init>();\n   dovar_init *di;\n   unsigned ix;\n \n@@ -1435,7 +1433,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t  tmp = fold_build2_loc (input_location, MULT_EXPR, type, count, step);\n \t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, from, tmp);\n \t  dovar_init e = {dovar, tmp};\n-\t  VEC_safe_push (dovar_init, heap, inits, e);\n+\t  inits.safe_push (e);\n \t}\n \n       if (!dovar_found)\n@@ -1506,9 +1504,9 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \n   gfc_start_block (&body);\n \n-  FOR_EACH_VEC_ELT (dovar_init, inits, ix, di)\n+  FOR_EACH_VEC_ELT (inits, ix, di)\n     gfc_add_modify (&body, di->var, di->init);\n-  VEC_free (dovar_init, heap, inits);\n+  inits.release ();\n \n   /* Cycle statement is implemented with a goto.  Exit statement must not be\n      present for this loop.  */"}, {"sha": "bdc559b4274c6150883d4dd4b7d8e62c0dc560fb", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -489,7 +489,8 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \n       /* Add the subroutine call to the block.  */\n       gfc_conv_procedure_call (&loopse, code->resolved_sym,\n-\t\t\t       code->ext.actual, code->expr1, NULL);\n+\t\t\t       code->ext.actual, code->expr1,\n+\t\t\t       NULL);\n \n       if (mask && count1)\n \t{\n@@ -2094,7 +2095,7 @@ gfc_trans_character_select (gfc_code *code)\n   gfc_code *c;\n   gfc_se se, expr1se;\n   int n, k;\n-  VEC(constructor_elt,gc) *inits = NULL;\n+  vec<constructor_elt, va_gc> *inits = NULL;\n \n   tree pchartype = gfc_get_pchar_type (code->expr1->ts.kind);\n \n@@ -2322,7 +2323,7 @@ gfc_trans_character_select (gfc_code *code)\n   /* Generate the structure describing the branches */\n   for (d = cp; d; d = d->right)\n     {\n-      VEC(constructor_elt,gc) *node = NULL;\n+      vec<constructor_elt, va_gc> *node = NULL;\n \n       gfc_init_se (&se, NULL);\n "}, {"sha": "35a39c5785954c3b478326bd241c0d65bbaa36ae", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -2690,7 +2690,7 @@ tree\n gfc_get_function_type (gfc_symbol * sym)\n {\n   tree type;\n-  VEC(tree,gc) *typelist;\n+  vec<tree, va_gc> *typelist;\n   gfc_formal_arglist *f;\n   gfc_symbol *arg;\n   int alternate_return;\n@@ -2713,7 +2713,7 @@ gfc_get_function_type (gfc_symbol * sym)\n \n   if (sym->attr.entry_master)\n     /* Additional parameter for selecting an entry point.  */\n-    VEC_safe_push (tree, gc, typelist, gfc_array_index_type);\n+    vec_safe_push (typelist, gfc_array_index_type);\n \n   if (sym->result)\n     arg = sym->result;\n@@ -2732,17 +2732,16 @@ gfc_get_function_type (gfc_symbol * sym)\n \t  || arg->ts.type == BT_CHARACTER)\n \ttype = build_reference_type (type);\n \n-      VEC_safe_push (tree, gc, typelist, type);\n+      vec_safe_push (typelist, type);\n       if (arg->ts.type == BT_CHARACTER)\n \t{\n \t  if (!arg->ts.deferred)\n \t    /* Transfer by value.  */\n-\t    VEC_safe_push (tree, gc, typelist, gfc_charlen_type_node);\n+\t    vec_safe_push (typelist, gfc_charlen_type_node);\n \t  else\n \t    /* Deferred character lengths are transferred by reference\n \t       so that the value can be returned.  */\n-\t    VEC_safe_push (tree, gc, typelist,\n-\t\t\t   build_pointer_type (gfc_charlen_type_node));\n+\t    vec_safe_push (typelist, build_pointer_type(gfc_charlen_type_node));\n \t}\n     }\n \n@@ -2780,7 +2779,7 @@ gfc_get_function_type (gfc_symbol * sym)\n \t     used without an explicit interface, and cannot be passed as\n \t     actual parameters for a dummy procedure.  */\n \n-\t  VEC_safe_push (tree, gc, typelist, type);\n+\t  vec_safe_push (typelist, type);\n \t}\n       else\n         {\n@@ -2803,11 +2802,11 @@ gfc_get_function_type (gfc_symbol * sym)\n \t       so that the value can be returned.  */\n \t    type = build_pointer_type (gfc_charlen_type_node);\n \n-\t  VEC_safe_push (tree, gc, typelist, type);\n+\t  vec_safe_push (typelist, type);\n \t}\n     }\n \n-  if (!VEC_empty (tree, typelist)\n+  if (!vec_safe_is_empty (typelist)\n       || sym->attr.is_main_program\n       || sym->attr.if_source != IFSRC_UNKNOWN)\n     is_varargs = false;"}, {"sha": "954dcd3400fd321b77e1814bee9cb82bd89bc674", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -427,7 +427,7 @@ int gfc_is_intrinsic_libcall (gfc_expr *);\n /* Used to call ordinary functions/subroutines\n    and procedure pointer components.  */\n int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n-\t\t\t     gfc_expr *, VEC(tree,gc) *);\n+\t\t\t     gfc_expr *, vec<tree, va_gc> *);\n \n void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool);\n "}, {"sha": "876e1c6297cc3f9eb1869e4afff5bd0f592103dd", "filename": "gcc/function.c", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -61,7 +61,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"predict.h\"\n #include \"df.h\"\n-#include \"vecprim.h\"\n #include \"params.h\"\n #include \"bb-reorder.h\"\n \n@@ -115,14 +114,14 @@ static GTY((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n \f\n \n htab_t types_used_by_vars_hash = NULL;\n-VEC(tree,gc) *types_used_by_cur_var_decl;\n+vec<tree, va_gc> *types_used_by_cur_var_decl;\n \n /* Forward declarations.  */\n \n static struct temp_slot *find_temp_slot_from_address (rtx);\n static void pad_to_arg_alignment (struct args_size *, int, struct args_size *);\n static void pad_below (struct args_size *, enum machine_mode, tree);\n-static void reorder_blocks_1 (rtx, tree, VEC(tree,heap) **);\n+static void reorder_blocks_1 (rtx, tree, vec<tree> *);\n static int all_blocks (tree, tree *);\n static tree *get_block_vector (tree, int *);\n extern tree debug_find_var_in_block_tree (tree, tree);\n@@ -140,9 +139,7 @@ static void set_insn_locations (rtx, int) ATTRIBUTE_UNUSED;\n \n typedef struct function *function_p;\n \n-DEF_VEC_P(function_p);\n-DEF_VEC_ALLOC_P(function_p,heap);\n-static VEC(function_p,heap) *function_context_stack;\n+static vec<function_p> function_context_stack;\n \n /* Save the current context for compilation of a nested function.\n    This is called from language-specific code.  */\n@@ -153,7 +150,7 @@ push_function_context (void)\n   if (cfun == 0)\n     allocate_struct_function (NULL, false);\n \n-  VEC_safe_push (function_p, heap, function_context_stack, cfun);\n+  function_context_stack.safe_push (cfun);\n   set_cfun (NULL);\n }\n \n@@ -163,7 +160,7 @@ push_function_context (void)\n void\n pop_function_context (void)\n {\n-  struct function *p = VEC_pop (function_p, function_context_stack);\n+  struct function *p = function_context_stack.pop ();\n   set_cfun (p);\n   current_function_decl = p->decl;\n \n@@ -593,10 +590,10 @@ insert_slot_to_list (struct temp_slot *temp, struct temp_slot **list)\n static struct temp_slot **\n temp_slots_at_level (int level)\n {\n-  if (level >= (int) VEC_length (temp_slot_p, used_temp_slots))\n-    VEC_safe_grow_cleared (temp_slot_p, gc, used_temp_slots, level + 1);\n+  if (level >= (int) vec_safe_length (used_temp_slots))\n+    vec_safe_grow_cleared (used_temp_slots, level + 1);\n \n-  return &(VEC_address (temp_slot_p, used_temp_slots)[level]);\n+  return &(*used_temp_slots)[level];\n }\n \n /* Returns the maximal temporary slot level.  */\n@@ -607,7 +604,7 @@ max_slot_level (void)\n   if (!used_temp_slots)\n     return -1;\n \n-  return VEC_length (temp_slot_p, used_temp_slots) - 1;\n+  return used_temp_slots->length () - 1;\n }\n \n /* Moves temporary slot TEMP to LEVEL.  */\n@@ -1198,7 +1195,7 @@ init_temp_slots (void)\n {\n   /* We have not allocated any temporaries yet.  */\n   avail_temp_slots = 0;\n-  used_temp_slots = 0;\n+  vec_alloc (used_temp_slots, 0);\n   temp_slot_level = 0;\n   n_temp_slots_in_use = 0;\n \n@@ -1877,7 +1874,7 @@ instantiate_decls (tree fndecl)\n   FOR_EACH_LOCAL_DECL (cfun, ix, decl)\n     if (DECL_RTL_SET_P (decl))\n       instantiate_decl_rtl (DECL_RTL (decl));\n-  VEC_free (tree, gc, cfun->local_decls);\n+  vec_free (cfun->local_decls);\n }\n \n /* Pass through the INSNS of function FNDECL and convert virtual register\n@@ -2215,12 +2212,12 @@ assign_parms_initialize_all (struct assign_parm_data_all *all)\n    needed, else the old list.  */\n \n static void\n-split_complex_args (VEC(tree, heap) **args)\n+split_complex_args (vec<tree> *args)\n {\n   unsigned i;\n   tree p;\n \n-  FOR_EACH_VEC_ELT (tree, *args, i, p)\n+  FOR_EACH_VEC_ELT (*args, i, p)\n     {\n       tree type = TREE_TYPE (p);\n       if (TREE_CODE (type) == COMPLEX_TYPE\n@@ -2245,7 +2242,7 @@ split_complex_args (VEC(tree, heap) **args)\n \t  DECL_IGNORED_P (p) = addressable;\n \t  TREE_ADDRESSABLE (p) = 0;\n \t  layout_decl (p, 0);\n-\t  VEC_replace (tree, *args, i, p);\n+\t  (*args)[i] = p;\n \n \t  /* Build a second synthetic decl.  */\n \t  decl = build_decl (EXPR_LOCATION (p),\n@@ -2254,7 +2251,7 @@ split_complex_args (VEC(tree, heap) **args)\n \t  DECL_ARTIFICIAL (decl) = addressable;\n \t  DECL_IGNORED_P (decl) = addressable;\n \t  layout_decl (decl, 0);\n-\t  VEC_safe_insert (tree, heap, *args, ++i, decl);\n+\t  args->safe_insert (++i, decl);\n \t}\n     }\n }\n@@ -2263,16 +2260,16 @@ split_complex_args (VEC(tree, heap) **args)\n    the hidden struct return argument, and (abi willing) complex args.\n    Return the new parameter list.  */\n \n-static VEC(tree, heap) *\n+static vec<tree> \n assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n {\n   tree fndecl = current_function_decl;\n   tree fntype = TREE_TYPE (fndecl);\n-  VEC(tree, heap) *fnargs = NULL;\n+  vec<tree> fnargs = vec<tree>();\n   tree arg;\n \n   for (arg = DECL_ARGUMENTS (fndecl); arg; arg = DECL_CHAIN (arg))\n-    VEC_safe_push (tree, heap, fnargs, arg);\n+    fnargs.safe_push (arg);\n \n   all->orig_fnargs = DECL_ARGUMENTS (fndecl);\n \n@@ -2293,7 +2290,7 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n \n       DECL_CHAIN (decl) = all->orig_fnargs;\n       all->orig_fnargs = decl;\n-      VEC_safe_insert (tree, heap, fnargs, 0, decl);\n+      fnargs.safe_insert (0, decl);\n \n       all->function_result_decl = decl;\n     }\n@@ -3259,7 +3256,7 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \n static void\n assign_parms_unsplit_complex (struct assign_parm_data_all *all,\n-\t\t\t      VEC(tree, heap) *fnargs)\n+\t\t\t      vec<tree> fnargs)\n {\n   tree parm;\n   tree orig_fnargs = all->orig_fnargs;\n@@ -3273,8 +3270,8 @@ assign_parms_unsplit_complex (struct assign_parm_data_all *all,\n \t  rtx tmp, real, imag;\n \t  enum machine_mode inner = GET_MODE_INNER (DECL_MODE (parm));\n \n-\t  real = DECL_RTL (VEC_index (tree, fnargs, i));\n-\t  imag = DECL_RTL (VEC_index (tree, fnargs, i + 1));\n+\t  real = DECL_RTL (fnargs[i]);\n+\t  imag = DECL_RTL (fnargs[i + 1]);\n \t  if (inner != GET_MODE (real))\n \t    {\n \t      real = gen_lowpart_SUBREG (inner, real);\n@@ -3307,8 +3304,8 @@ assign_parms_unsplit_complex (struct assign_parm_data_all *all,\n \t    tmp = gen_rtx_CONCAT (DECL_MODE (parm), real, imag);\n \t  SET_DECL_RTL (parm, tmp);\n \n-\t  real = DECL_INCOMING_RTL (VEC_index (tree, fnargs, i));\n-\t  imag = DECL_INCOMING_RTL (VEC_index (tree, fnargs, i + 1));\n+\t  real = DECL_INCOMING_RTL (fnargs[i]);\n+\t  imag = DECL_INCOMING_RTL (fnargs[i + 1]);\n \t  if (inner != GET_MODE (real))\n \t    {\n \t      real = gen_lowpart_SUBREG (inner, real);\n@@ -3329,7 +3326,7 @@ assign_parms (tree fndecl)\n {\n   struct assign_parm_data_all all;\n   tree parm;\n-  VEC(tree, heap) *fnargs;\n+  vec<tree> fnargs;\n   unsigned i;\n \n   crtl->args.internal_arg_pointer\n@@ -3338,7 +3335,7 @@ assign_parms (tree fndecl)\n   assign_parms_initialize_all (&all);\n   fnargs = assign_parms_augmented_arg_list (&all);\n \n-  FOR_EACH_VEC_ELT (tree, fnargs, i, parm)\n+  FOR_EACH_VEC_ELT (fnargs, i, parm)\n     {\n       struct assign_parm_data_one data;\n \n@@ -3413,7 +3410,7 @@ assign_parms (tree fndecl)\n   if (targetm.calls.split_complex_arg)\n     assign_parms_unsplit_complex (&all, fnargs);\n \n-  VEC_free (tree, heap, fnargs);\n+  fnargs.release ();\n \n   /* Output all parameter conversion instructions (possibly including calls)\n      now that all parameters have been copied out of hard registers.  */\n@@ -3578,13 +3575,13 @@ gimplify_parameters (void)\n   struct assign_parm_data_all all;\n   tree parm;\n   gimple_seq stmts = NULL;\n-  VEC(tree, heap) *fnargs;\n+  vec<tree> fnargs;\n   unsigned i;\n \n   assign_parms_initialize_all (&all);\n   fnargs = assign_parms_augmented_arg_list (&all);\n \n-  FOR_EACH_VEC_ELT (tree, fnargs, i, parm)\n+  FOR_EACH_VEC_ELT (fnargs, i, parm)\n     {\n       struct assign_parm_data_one data;\n \n@@ -3667,7 +3664,7 @@ gimplify_parameters (void)\n \t}\n     }\n \n-  VEC_free (tree, heap, fnargs);\n+  fnargs.release ();\n \n   return stmts;\n }\n@@ -4095,12 +4092,12 @@ void\n reorder_blocks (void)\n {\n   tree block = DECL_INITIAL (current_function_decl);\n-  VEC(tree,heap) *block_stack;\n+  vec<tree> block_stack;\n \n   if (block == NULL_TREE)\n     return;\n \n-  block_stack = VEC_alloc (tree, heap, 10);\n+  block_stack.create (10);\n \n   /* Reset the TREE_ASM_WRITTEN bit for all blocks.  */\n   clear_block_marks (block);\n@@ -4113,7 +4110,7 @@ reorder_blocks (void)\n   reorder_blocks_1 (get_insns (), block, &block_stack);\n   BLOCK_SUBBLOCKS (block) = blocks_nreverse_all (BLOCK_SUBBLOCKS (block));\n \n-  VEC_free (tree, heap, block_stack);\n+  block_stack.release ();\n }\n \n /* Helper function for reorder_blocks.  Reset TREE_ASM_WRITTEN.  */\n@@ -4130,7 +4127,7 @@ clear_block_marks (tree block)\n }\n \n static void\n-reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n+reorder_blocks_1 (rtx insns, tree current_block, vec<tree> *p_block_stack)\n {\n   rtx insn;\n   tree prev_beg = NULL_TREE, prev_end = NULL_TREE;\n@@ -4185,11 +4182,11 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t\t\t\t|| BLOCK_FRAGMENT_ORIGIN (BLOCK_SUPERCONTEXT\n \t\t\t\t\t\t\t\t      (origin))\n \t\t\t\t   == current_block);\n-\t\t  if (VEC_empty (tree, *p_block_stack))\n+\t\t  if (p_block_stack->is_empty ())\n \t\t    super = current_block;\n \t\t  else\n \t\t    {\n-\t\t      super = VEC_last (tree, *p_block_stack);\n+\t\t      super = p_block_stack->last ();\n \t\t      gcc_assert (super == current_block\n \t\t\t\t  || BLOCK_FRAGMENT_ORIGIN (super)\n \t\t\t\t     == current_block);\n@@ -4199,11 +4196,11 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t\t  BLOCK_SUBBLOCKS (current_block) = block;\n \t\t  current_block = origin;\n \t\t}\n-\t      VEC_safe_push (tree, heap, *p_block_stack, block);\n+\t      p_block_stack->safe_push (block);\n \t    }\n \t  else if (NOTE_KIND (insn) == NOTE_INSN_BLOCK_END)\n \t    {\n-\t      NOTE_BLOCK (insn) = VEC_pop (tree, *p_block_stack);\n+\t      NOTE_BLOCK (insn) = p_block_stack->pop ();\n \t      current_block = BLOCK_SUPERCONTEXT (current_block);\n \t      if (BLOCK_FRAGMENT_ORIGIN (current_block))\n \t\tcurrent_block = BLOCK_FRAGMENT_ORIGIN (current_block);\n@@ -4411,7 +4408,7 @@ set_cfun (struct function *new_cfun)\n \n /* Initialized with NOGC, making this poisonous to the garbage collector.  */\n \n-static VEC(function_p,heap) *cfun_stack;\n+static vec<function_p> cfun_stack;\n \n /* Push the current cfun onto the stack, and set cfun to new_cfun.  Also set\n    current_function_decl accordingly.  */\n@@ -4421,7 +4418,7 @@ push_cfun (struct function *new_cfun)\n {\n   gcc_assert ((!cfun && !current_function_decl)\n \t      || (cfun && current_function_decl == cfun->decl));\n-  VEC_safe_push (function_p, heap, cfun_stack, cfun);\n+  cfun_stack.safe_push (cfun);\n   current_function_decl = new_cfun ? new_cfun->decl : NULL_TREE;\n   set_cfun (new_cfun);\n }\n@@ -4431,7 +4428,7 @@ push_cfun (struct function *new_cfun)\n void\n pop_cfun (void)\n {\n-  struct function *new_cfun = VEC_pop (function_p, cfun_stack);\n+  struct function *new_cfun = cfun_stack.pop ();\n   /* When in_dummy_function, we do have a cfun but current_function_decl is\n      NULL.  We also allow pushing NULL cfun and subsequently changing\n      current_function_decl to something else and have both restored by\n@@ -4527,7 +4524,7 @@ push_struct_function (tree fndecl)\n   gcc_assert (in_dummy_function\n \t      || (!cfun && !current_function_decl)\n \t      || (cfun && current_function_decl == cfun->decl));\n-  VEC_safe_push (function_p, heap, cfun_stack, cfun);\n+  cfun_stack.safe_push (cfun);\n   current_function_decl = fndecl;\n   allocate_struct_function (fndecl, false);\n }\n@@ -5705,25 +5702,25 @@ active_insn_between (rtx head, rtx tail)\n /* LAST_BB is a block that exits, and empty of active instructions.\n    Examine its predecessors for jumps that can be converted to\n    (conditional) returns.  */\n-static VEC (edge, heap) *\n+static vec<edge> \n convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n-\t\t\t  VEC (edge, heap) *unconverted ATTRIBUTE_UNUSED)\n+\t\t\t  vec<edge> unconverted ATTRIBUTE_UNUSED)\n {\n   int i;\n   basic_block bb;\n   rtx label;\n   edge_iterator ei;\n   edge e;\n-  VEC(basic_block,heap) *src_bbs;\n+  vec<basic_block> src_bbs;\n \n-  src_bbs = VEC_alloc (basic_block, heap, EDGE_COUNT (last_bb->preds));\n+  src_bbs.create (EDGE_COUNT (last_bb->preds));\n   FOR_EACH_EDGE (e, ei, last_bb->preds)\n     if (e->src != ENTRY_BLOCK_PTR)\n-      VEC_quick_push (basic_block, src_bbs, e->src);\n+      src_bbs.quick_push (e->src);\n \n   label = BB_HEAD (last_bb);\n \n-  FOR_EACH_VEC_ELT (basic_block, src_bbs, i, bb)\n+  FOR_EACH_VEC_ELT (src_bbs, i, bb)\n     {\n       rtx jump = BB_END (bb);\n \n@@ -5768,7 +5765,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Failed to redirect bb %d branch.\\n\", bb->index);\n-\t\t  VEC_safe_push (edge, heap, unconverted, e);\n+\t\t  unconverted.safe_push (e);\n \t\t}\n #endif\n \t      continue;\n@@ -5791,7 +5788,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"Failed to redirect bb %d branch.\\n\", bb->index);\n-\t      VEC_safe_push (edge, heap, unconverted, e);\n+\t      unconverted.safe_push (e);\n \t    }\n #endif\n \t  continue;\n@@ -5801,7 +5798,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n       redirect_edge_succ (e, EXIT_BLOCK_PTR);\n       e->flags &= ~EDGE_CROSSING;\n     }\n-  VEC_free (basic_block, heap, src_bbs);\n+  src_bbs.release ();\n   return unconverted;\n }\n \n@@ -5877,7 +5874,7 @@ thread_prologue_and_epilogue_insns (void)\n {\n   bool inserted;\n #ifdef HAVE_simple_return\n-  VEC (edge, heap) *unconverted_simple_returns = NULL;\n+  vec<edge> unconverted_simple_returns = vec<edge>();\n   bool nonempty_prologue;\n   bitmap_head bb_flags;\n   unsigned max_grow_size;\n@@ -5975,7 +5972,7 @@ thread_prologue_and_epilogue_insns (void)\n       HARD_REG_SET prologue_clobbered, prologue_used, live_on_edge;\n       struct hard_reg_set_container set_up_by_prologue;\n       rtx p_insn;\n-      VEC(basic_block, heap) *vec;\n+      vec<basic_block> vec;\n       basic_block bb;\n       bitmap_head bb_antic_flags;\n       bitmap_head bb_on_list;\n@@ -6011,7 +6008,7 @@ thread_prologue_and_epilogue_insns (void)\n       /* Find the set of basic blocks that require a stack frame,\n \t and blocks that are too big to be duplicated.  */\n \n-      vec = VEC_alloc (basic_block, heap, n_basic_blocks);\n+      vec.create (n_basic_blocks);\n \n       CLEAR_HARD_REG_SET (set_up_by_prologue.set);\n       add_to_hard_reg_set (&set_up_by_prologue.set, Pmode,\n@@ -6051,7 +6048,7 @@ thread_prologue_and_epilogue_insns (void)\n \t\t    if (bb == entry_edge->dest)\n \t\t      goto fail_shrinkwrap;\n \t\t    bitmap_set_bit (&bb_flags, bb->index);\n-\t\t    VEC_quick_push (basic_block, vec, bb);\n+\t\t    vec.quick_push (bb);\n \t\t    break;\n \t\t  }\n \t\telse if (size <= max_grow_size)\n@@ -6069,23 +6066,23 @@ thread_prologue_and_epilogue_insns (void)\n       /* For every basic block that needs a prologue, mark all blocks\n \t reachable from it, so as to ensure they are also seen as\n \t requiring a prologue.  */\n-      while (!VEC_empty (basic_block, vec))\n+      while (!vec.is_empty ())\n \t{\n-\t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n+\t  basic_block tmp_bb = vec.pop ();\n \n \t  FOR_EACH_EDGE (e, ei, tmp_bb->succs)\n \t    if (e->dest != EXIT_BLOCK_PTR\n \t\t&& bitmap_set_bit (&bb_flags, e->dest->index))\n-\t      VEC_quick_push (basic_block, vec, e->dest);\n+\t      vec.quick_push (e->dest);\n \t}\n \n       /* Find the set of basic blocks that need no prologue, have a\n \t single successor, can be duplicated, meet a max size\n \t requirement, and go to the exit via like blocks.  */\n-      VEC_quick_push (basic_block, vec, EXIT_BLOCK_PTR);\n-      while (!VEC_empty (basic_block, vec))\n+      vec.quick_push (EXIT_BLOCK_PTR);\n+      while (!vec.is_empty ())\n \t{\n-\t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n+\t  basic_block tmp_bb = vec.pop ();\n \n \t  FOR_EACH_EDGE (e, ei, tmp_bb->preds)\n \t    if (single_succ_p (e->src)\n@@ -6104,7 +6101,7 @@ thread_prologue_and_epilogue_insns (void)\n \t\t      && !bitmap_bit_p (&bb_flags, pe->src->index))\n \t\t    break;\n \t\tif (pe == NULL && bitmap_set_bit (&bb_tail, e->src->index))\n-\t\t  VEC_quick_push (basic_block, vec, e->src);\n+\t\t  vec.quick_push (e->src);\n \t      }\n \t}\n \n@@ -6121,11 +6118,11 @@ thread_prologue_and_epilogue_insns (void)\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (!bitmap_bit_p (&bb_antic_flags, e->src->index)\n \t\t&& bitmap_set_bit (&bb_on_list, e->src->index))\n-\t      VEC_quick_push (basic_block, vec, e->src);\n+\t      vec.quick_push (e->src);\n \t}\n-      while (!VEC_empty (basic_block, vec))\n+      while (!vec.is_empty ())\n \t{\n-\t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n+\t  basic_block tmp_bb = vec.pop ();\n \t  bool all_set = true;\n \n \t  bitmap_clear_bit (&bb_on_list, tmp_bb->index);\n@@ -6142,7 +6139,7 @@ thread_prologue_and_epilogue_insns (void)\n \t      FOR_EACH_EDGE (e, ei, tmp_bb->preds)\n \t\tif (!bitmap_bit_p (&bb_antic_flags, e->src->index)\n \t\t    && bitmap_set_bit (&bb_on_list, e->src->index))\n-\t\t  VEC_quick_push (basic_block, vec, e->src);\n+\t\t  vec.quick_push (e->src);\n \t    }\n \t}\n       /* Find exactly one edge that leads to a block in ANTIC from\n@@ -6210,14 +6207,14 @@ thread_prologue_and_epilogue_insns (void)\n \t\t      some_no_pro = true;\n \t\t  }\n \t\tif (some_pro && some_no_pro)\n-\t\t  VEC_quick_push (basic_block, vec, bb);\n+\t\t  vec.quick_push (bb);\n \t\telse\n \t\t  bitmap_clear_bit (&bb_tail, bb->index);\n \t      }\n \t  /* Find the head of each tail.  */\n-\t  while (!VEC_empty (basic_block, vec))\n+\t  while (!vec.is_empty ())\n \t    {\n-\t      basic_block tbb = VEC_pop (basic_block, vec);\n+\t      basic_block tbb = vec.pop ();\n \n \t      if (!bitmap_bit_p (&bb_tail, tbb->index))\n \t\tcontinue;\n@@ -6299,7 +6296,7 @@ thread_prologue_and_epilogue_insns (void)\n       bitmap_clear (&bb_tail);\n       bitmap_clear (&bb_antic_flags);\n       bitmap_clear (&bb_on_list);\n-      VEC_free (basic_block, heap, vec);\n+      vec.release ();\n     }\n #endif\n \n@@ -6377,7 +6374,7 @@ thread_prologue_and_epilogue_insns (void)\n \n \t  if (LABEL_P (BB_HEAD (last_bb))\n \t      && !active_insn_between (BB_HEAD (last_bb), BB_END (last_bb)))\n-\t    convert_jumps_to_returns (last_bb, false, NULL);\n+\t    convert_jumps_to_returns (last_bb, false, vec<edge>());\n \n \t  if (EDGE_COUNT (last_bb->preds) != 0\n \t      && single_succ_p (last_bb))\n@@ -6511,7 +6508,7 @@ thread_prologue_and_epilogue_insns (void)\n      convert to conditional simple_returns, but couldn't for some\n      reason, create a block to hold a simple_return insn and redirect\n      those remaining edges.  */\n-  if (!VEC_empty (edge, unconverted_simple_returns))\n+  if (!unconverted_simple_returns.is_empty ())\n     {\n       basic_block simple_return_block_hot = NULL;\n       basic_block simple_return_block_cold = NULL;\n@@ -6546,7 +6543,7 @@ thread_prologue_and_epilogue_insns (void)\n \t      pending_edge_cold = e;\n \t  }\n \n-      FOR_EACH_VEC_ELT (edge, unconverted_simple_returns, i, e)\n+      FOR_EACH_VEC_ELT (unconverted_simple_returns, i, e)\n \t{\n \t  basic_block *pdest_bb;\n \t  edge pending;\n@@ -6585,7 +6582,7 @@ thread_prologue_and_epilogue_insns (void)\n \t    }\n \t  redirect_edge_and_branch_force (e, *pdest_bb);\n \t}\n-      VEC_free (edge, heap, unconverted_simple_returns);\n+      unconverted_simple_returns.release ();\n     }\n \n   if (entry_edge != orig_entry_edge)\n@@ -6851,10 +6848,12 @@ used_types_insert (tree t)\n       if (cfun)\n \tused_types_insert_helper (t, cfun);\n       else\n-\t/* So this might be a type referenced by a global variable.\n-\t   Record that type so that we can later decide to emit its debug\n-\t   information.  */\n-        VEC_safe_push (tree, gc, types_used_by_cur_var_decl, t);\n+\t{\n+\t  /* So this might be a type referenced by a global variable.\n+\t     Record that type so that we can later decide to emit its\n+\t     debug information.  */\n+\t  vec_safe_push (types_used_by_cur_var_decl, t);\n+\t}\n     }\n }\n "}, {"sha": "63704d4fb09e1aa2a5ab1fe704974e723c4eed44", "filename": "gcc/function.h", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -24,8 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"hashtab.h\"\n #include \"vec.h\"\n-#include \"vecprim.h\"\n-#include \"vecir.h\"\n #include \"machmode.h\"\n #include \"tm.h\"\t\t\t/* For CUMULATIVE_ARGS.  */\n #include \"hard-reg-set.h\"\t/* For HARD_REG_SET in struct rtl_data. */\n@@ -143,8 +141,6 @@ struct GTY(()) expr_status {\n };\n \n typedef struct call_site_record_d *call_site_record;\n-DEF_VEC_P(call_site_record);\n-DEF_VEC_ALLOC_P(call_site_record, gc);\n \n /* RTL representation of exception handling.  */\n struct GTY(()) rtl_eh {\n@@ -155,9 +151,9 @@ struct GTY(()) rtl_eh {\n   rtx sjlj_fc;\n   rtx sjlj_exit_after;\n \n-  VEC(uchar,gc) *action_record_data;\n+  vec<uchar, va_gc> *action_record_data;\n \n-  VEC(call_site_record,gc) *call_site_record_v[2];\n+  vec<call_site_record, va_gc> *call_site_record_v[2];\n };\n \n #define pending_stack_adjust (crtl->expr.x_pending_stack_adjust)\n@@ -173,13 +169,9 @@ typedef struct temp_slot *temp_slot_p;\n struct call_site_record_d;\n struct dw_fde_struct;\n \n-DEF_VEC_P(temp_slot_p);\n-DEF_VEC_ALLOC_P(temp_slot_p,gc);\n struct ipa_opt_pass_d;\n typedef struct ipa_opt_pass_d *ipa_opt_pass;\n \n-DEF_VEC_P(ipa_opt_pass);\n-DEF_VEC_ALLOC_P(ipa_opt_pass,heap);\n \n struct GTY(()) varasm_status {\n   /* If we're using a per-function constant pool, this is it.  */\n@@ -316,7 +308,7 @@ struct GTY(()) rtl_data {\n   rtx x_parm_birth_insn;\n \n   /* List of all used temporaries allocated, by level.  */\n-  VEC(temp_slot_p,gc) *x_used_temp_slots;\n+  vec<temp_slot_p, va_gc> *x_used_temp_slots;\n \n   /* List of available temp slots.  */\n   struct temp_slot *x_avail_temp_slots;\n@@ -554,7 +546,7 @@ struct GTY(()) function {\n   tree nonlocal_goto_save_area;\n \n   /* Vector of function local variables, functions, types and constants.  */\n-  VEC(tree,gc) *local_decls;\n+  vec<tree, va_gc> *local_decls;\n \n   /* For md files.  */\n \n@@ -661,11 +653,11 @@ struct GTY(()) function {\n static inline void\n add_local_decl (struct function *fun, tree d)\n {\n-  VEC_safe_push (tree, gc, fun->local_decls, d);\n+  vec_safe_push (fun->local_decls, d);\n }\n \n #define FOR_EACH_LOCAL_DECL(FUN, I, D)\t\t\\\n-  FOR_EACH_VEC_ELT_REVERSE (tree, (FUN)->local_decls, I, D)\n+  FOR_EACH_VEC_SAFE_ELT_REVERSE ((FUN)->local_decls, I, D)\n \n /* If va_list_[gf]pr_size is set to this, it means we don't know how\n    many units need to be saved.  */\n@@ -705,7 +697,7 @@ void types_used_by_var_decl_insert (tree type, tree var_decl);\n \n /* During parsing of a global variable, this vector contains the types\n    referenced by the global variable.  */\n-extern GTY(()) VEC(tree,gc) *types_used_by_cur_var_decl;\n+extern GTY(()) vec<tree, va_gc> *types_used_by_cur_var_decl;\n \n /* cfun shouldn't be set directly; use one of these functions instead.  */\n extern void set_cfun (struct function *new_cfun);"}, {"sha": "0f2ee49ac144772cba9a7b933feed63c43249d50", "filename": "gcc/fwprop.c", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6", "patch": "@@ -116,11 +116,9 @@ along with GCC; see the file COPYING3.  If not see\n \n static int num_changes;\n \n-DEF_VEC_P(df_ref);\n-DEF_VEC_ALLOC_P(df_ref,heap);\n-static VEC(df_ref,heap) *use_def_ref;\n-static VEC(df_ref,heap) *reg_defs;\n-static VEC(df_ref,heap) *reg_defs_stack;\n+static vec<df_ref> use_def_ref;\n+static vec<df_ref> reg_defs;\n+static vec<df_ref> reg_defs_stack;\n \n /* The MD bitmaps are trimmed to include only live registers to cut\n    memory usage on testcases like insn-recog.c.  Track live registers\n@@ -135,7 +133,7 @@ static bitmap local_lr;\n static inline df_ref\n get_def_for_use (df_ref use)\n {\n-  return VEC_index (df_ref, use_def_ref, DF_REF_ID (use));\n+  return use_def_ref[DF_REF_ID (use)];\n }\n \n \n@@ -154,15 +152,15 @@ process_defs (df_ref *def_rec, int top_flag)\n   df_ref def;\n   while ((def = *def_rec++) != NULL)\n     {\n-      df_ref curr_def = VEC_index (df_ref, reg_defs, DF_REF_REGNO (def));\n+      df_ref curr_def = reg_defs[DF_REF_REGNO (def)];\n       unsigned int dregno;\n \n       if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) != top_flag)\n \tcontinue;\n \n       dregno = DF_REF_REGNO (def);\n       if (curr_def)\n-\tVEC_safe_push (df_ref, heap, reg_defs_stack, curr_def);\n+\treg_defs_stack.safe_push (curr_def);\n       else\n \t{\n \t  /* Do not store anything if \"transitioning\" from NULL to NULL.  But\n@@ -171,18 +169,18 @@ process_defs (df_ref *def_rec, int top_flag)\n \t  if (DF_REF_FLAGS (def) & DF_MD_GEN_FLAGS)\n \t    ;\n \t  else\n-\t    VEC_safe_push (df_ref, heap, reg_defs_stack, def);\n+\t    reg_defs_stack.safe_push (def);\n \t}\n \n       if (DF_REF_FLAGS (def) & DF_MD_GEN_FLAGS)\n \t{\n \t  bitmap_set_bit (local_md, dregno);\n-\t  VEC_replace (df_ref, reg_defs, dregno, NULL);\n+\t  reg_defs[dregno] = NULL;\n \t}\n       else\n \t{\n \t  bitmap_clear_bit (local_md, dregno);\n-\t  VEC_replace (df_ref, reg_defs, dregno, def);\n+\t  reg_defs[dregno] = def;\n \t}\n     }\n }\n@@ -201,11 +199,10 @@ process_uses (df_ref *use_rec, int top_flag)\n     if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == top_flag)\n       {\n         unsigned int uregno = DF_REF_REGNO (use);\n-        if (VEC_index (df_ref, reg_defs, uregno)\n+        if (reg_defs[uregno]\n \t    && !bitmap_bit_p (local_md, uregno)\n \t    && bitmap_bit_p (local_lr, uregno))\n-\t  VEC_replace (df_ref, use_def_ref, DF_REF_ID (use),\n-\t\t       VEC_index (df_ref, reg_defs, uregno));\n+\t  use_def_ref[DF_REF_ID (use)] = reg_defs[uregno];\n       }\n }\n \n@@ -223,7 +220,7 @@ single_def_use_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   bitmap_copy (local_lr, &lr_bb_info->in);\n \n   /* Push a marker for the leave_block callback.  */\n-  VEC_safe_push (df_ref, heap, reg_defs_stack, NULL);\n+  reg_defs_stack.safe_push (NULL);\n \n   process_uses (df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n   process_defs (df_get_artificial_defs (bb_index), DF_REF_AT_TOP);\n@@ -254,15 +251,15 @@ single_def_use_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n {\n   df_ref saved_def;\n-  while ((saved_def = VEC_pop (df_ref, reg_defs_stack)) != NULL)\n+  while ((saved_def = reg_defs_stack.pop ()) != NULL)\n     {\n       unsigned int dregno = DF_REF_REGNO (saved_def);\n \n       /* See also process_defs.  */\n-      if (saved_def == VEC_index (df_ref, reg_defs, dregno))\n-\tVEC_replace (df_ref, reg_defs, dregno, NULL);\n+      if (saved_def == reg_defs[dregno])\n+\treg_defs[dregno] = NULL;\n       else\n-\tVEC_replace (df_ref, reg_defs, dregno, saved_def);\n+\treg_defs[dregno] = saved_def;\n     }\n }\n \n@@ -283,13 +280,13 @@ build_single_def_use_links (void)\n   df_analyze ();\n   df_maybe_reorganize_use_refs (DF_REF_ORDER_BY_INSN_WITH_NOTES);\n \n-  use_def_ref = VEC_alloc (df_ref, heap, DF_USES_TABLE_SIZE ());\n-  VEC_safe_grow_cleared (df_ref, heap, use_def_ref, DF_USES_TABLE_SIZE ());\n+  use_def_ref.create (DF_USES_TABLE_SIZE ());\n+  use_def_ref.safe_grow_cleared (DF_USES_TABLE_SIZE ());\n \n-  reg_defs = VEC_alloc (df_ref, heap, max_reg_num ());\n-  VEC_safe_grow_cleared (df_ref, heap, reg_defs, max_reg_num ());\n+  reg_defs.create (max_reg_num ());\n+  reg_defs.safe_grow_cleared (max_reg_num ());\n \n-  reg_defs_stack = VEC_alloc (df_ref, heap, n_basic_blocks * 10);\n+  reg_defs_stack.create (n_basic_blocks * 10);\n   local_md = BITMAP_ALLOC (NULL);\n   local_lr = BITMAP_ALLOC (NULL);\n \n@@ -306,8 +303,8 @@ build_single_def_use_links (void)\n \n   BITMAP_FREE (local_lr);\n   BITMAP_FREE (local_md);\n-  VEC_free (df_ref, heap, reg_defs);\n-  VEC_free (df_ref, heap, reg_defs_stack);\n+  reg_defs.release ();\n+  reg_defs_stack.release ();\n }\n \n \f\n@@ -912,14 +909,13 @@ update_uses (df_ref *use_rec)\n       int regno = DF_REF_REGNO (use);\n \n       /* Set up the use-def chain.  */\n-      if (DF_REF_ID (use) >= (int) VEC_length (df_ref, use_def_ref))\n-        VEC_safe_grow_cleared (df_ref, heap, use_def_ref,\n-                               DF_REF_ID (use) + 1);\n+      if (DF_REF_ID (use) >= (int) use_def_ref.length ())\n+        use_def_ref.safe_grow_cleared (DF_REF_ID (use) + 1);\n \n #ifdef ENABLE_CHECKING\n       gcc_assert (sparseset_bit_p (active_defs_check, regno));\n #endif\n-      VEC_replace (df_ref, use_def_ref, DF_REF_ID (use), active_defs[regno]);\n+      use_def_ref[DF_REF_ID (use)] = active_defs[regno];\n     }\n }\n \n@@ -1425,7 +1421,7 @@ fwprop_done (void)\n {\n   loop_optimizer_finalize ();\n \n-  VEC_free (df_ref, heap, use_def_ref);\n+  use_def_ref.release ();\n   free (active_defs);\n #ifdef ENABLE_CHECKING\n   sparseset_free (active_defs_check);"}, {"sha": "3d515665f7ac8533c4a0613c446451d7c05f6f64", "filename": "gcc/gcc.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "4be7cdc616b3a78cdb6257789129e2abaadbb610", "filename": "gcc/gcse.c", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "ade8c52cfb1857beed93ee98bb9c757aed81c8dc", "filename": "gcc/genattr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "7143fc45075d8b88ac06d3db7c188381e6a235ef", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "faa9bf8bcc5f921816e04acb9314ca7d0b4c27ed", "filename": "gcc/genautomata.c", "status": "modified", "additions": 239, "deletions": 282, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "063c2211152d48c2a43754a56cc50d6e5bd09715", "filename": "gcc/genextract.c", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "4c316a3e2ea49e6f447fad61f7ddcc8d07ca0172", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0b466615e23564c6f6774a737e6246a774f67ba8", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "8607ceb11184028e5299e911dd5c28edacb807c7", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b3f73fe924b0d3539eea1c4a295a5039aee631e3", "filename": "gcc/gengtype.c", "status": "modified", "additions": 123, "deletions": 24, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "57a67fbfecbf890a94b5a1597a1fcd7d59b66311", "filename": "gcc/gengtype.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "077a721b2ea1b2d148968aa30b8eaad00a22ef7d", "filename": "gcc/genopinit.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "a006909ef93f855b302bfea512631875c3cb6d3f", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "37bbbd19a8bb9c37c951ab01b6778f42ccedf10c", "filename": "gcc/ggc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e26d91ef4b4bb131568760225e6e92aa8e22e257", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "8e2a24758ddc3cf8ef3763c1de364a9b012a73c6", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "6736defcec514005b406debb931b9a913956c50c", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "5a53e0082c05483b4b8ccb87e3c509825f78900a", "filename": "gcc/gimple.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2d6cef4f4d6e88623ca4f2795d6dfd81f07593ff", "filename": "gcc/gimple.h", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "8d555f833b9b60ce746508a5a99612da48a9891b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 78, "deletions": 75, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "9a902475148991dd12d95e10e8d4cfcbc9ec0181", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "8e7b8ba09d4946bf60de6bb5e832f64bfe207e16", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "22995fe5d918a5bcc2b3a431afa2c68e0751fdb3", "filename": "gcc/godump.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "847aac2dc1a5af430748de1629338126ab0db513", "filename": "gcc/graph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "1614b15265c2931ad7cc1d50c170258a42e8cae6", "filename": "gcc/graphds.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "a2afc29c406497e73c981af691b26f909b28e123", "filename": "gcc/graphds.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "61e6c76af486b5c0ff05a7eaddd13db47fee773c", "filename": "gcc/graphite-blocking.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-blocking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-blocking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-blocking.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "43cddd540301b60367df9825a1c2ffa539f3ff1c", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "947eb40199b24ad36cd101bd460b226ea87e1e09", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "eb1a8b5bc29ce8c92e1b15c90df74dec3a72c310", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "5e15a7c148f1371584fbb76eaf2fb2af48d7344b", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "21bab940f3efdb7eb709330a2869165505e0684a", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "85980eb2e617d9a3512a185921ec4e03ccd2b41b", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 56, "deletions": 63, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "c6413589e0d4399a2208cb449edf8c9c15d0c55c", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f888464073a7bf4d386f32cd9440d2497f453f5b", "filename": "gcc/graphite-scop-detection.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-scop-detection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-scop-detection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "4e95f78bbfab454547947949f823a6f5c3e457f1", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 150, "deletions": 141, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "beb94a773a9376616086f954dbf61031dcdde0f1", "filename": "gcc/graphite.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "48e15f8875ba869913d078fea80e4b04cde88257", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 88, "deletions": 94, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "c4681ad75241be0bd98b6c39686c01a6be366b76", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "59695405c4820e7ef31bf030f5928632781d2ee3", "filename": "gcc/hw-doloop.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fhw-doloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fhw-doloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f9ddfd6b8d3df14a4ab3c9ae4a108701664256e8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "1ef9a93749af4a2f0c6fd14ff39963e6e0902b9f", "filename": "gcc/insn-addr.h", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Finsn-addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Finsn-addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-addr.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "57382b5a3380ff4e87b1ad8698876f4c69143729", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 138, "deletions": 151, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "61fb48dccb00bc01a24d21a56654fc9a7442a84e", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 227, "deletions": 285, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "19b2c855c7549e465e75f16a177f0e49d1273d27", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "14e825609b21494431e8b47c2ebe72b8e88c9cd9", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "729ea5698d7791c3504022315c89213b623bfcf9", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "3150bd6db15ca5684dff7c1d595893f53f0f4d75", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 115, "deletions": 139, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "1d0a9927fd03d64fe71fd9294f63fdcdddd5bd60", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 30, "deletions": 63, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "341501ea172e73e86e42c2b61d4eb2939757d44c", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "d793b5ea12718b3074ed7878e18d151075fa6ad5", "filename": "gcc/ipa-ref-inline.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "75887d293e6ccb006b4e2553977ac31ada70ddcb", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2333cbe91e3c23d55e1d0814e83276fa4c575c8a", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "ca05a3988419bab4c7abd7712ffc2244954cdaea", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "ceed8d26624421c686986b5b7b4375c3c03a9f04", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "d133f79c0a63a6d327e375537a76c4ccd7fc6cb8", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "7f045b245bd2191f3772352d667fd66f16ef6e69", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0fb0eb5eb7fbf4cf0bf89c9f4b047603121d6ed5", "filename": "gcc/ipa.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e0b9c1b20cd655254d2b5b0761a04cb495bec84f", "filename": "gcc/ira-build.c", "status": "modified", "additions": 77, "deletions": 89, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "33f9d24b00b52cab8e99c118fa9eff1b2968301f", "filename": "gcc/ira-color.c", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "291c9a0e0b82c7a9d874f868569e5ad9728810eb", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "69db4411b478d294114440d0f22f70de2a55ba4d", "filename": "gcc/ira-int.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2f629338c09a8d65face877a5089483c35b15b40", "filename": "gcc/ira.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "97aef463673a8eb83d4fb8228d24151d9edb304f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e125883d4430b6a0e1a4ca315d19e3967da6d793", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "fb8cd8b444b0ca2ce6bc772ae319a9dcfb34ab68", "filename": "gcc/java/class.c", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "653c3c266dd67c1cf4afc89125c51d8f4fba141d", "filename": "gcc/java/constants.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "c1ddd57303c25defe39c11bb291cb54c1b5cd46d", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0f6e465b9a1b7ded93ae926bf71a3b79da25daa8", "filename": "gcc/java/expr.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "11b780b998d1b0c3d61efd7bb40f972a51211910", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "c97b12f88e3e4097c756bf6b1e13fe7c4d01a043", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "52e99c4906c6a74a5e0bb908e06c21feb9f9e6f1", "filename": "gcc/java/resource.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "86cd28945c90f0a6125f2d50163d347196845a0a", "filename": "gcc/java/verify-glue.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fverify-glue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fjava%2Fverify-glue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-glue.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0c54a9ec09a10bd186e0e2acfff60b11edfd9890", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "58bd9f23cf346c91aad694cce2c26530e6050a29", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b331273d942799b65c4e6d42594d909c7ac435d5", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f2dc359c18bc3a32bca601dd32ca4e9014b48fda", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "35b53eccaa519865e6a5fa6e6efc63517eb17f4c", "filename": "gcc/lra.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "7d936efa2c57c17f84f103eb4c0fdd17d5f35a96", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 52, "deletions": 57, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e4e8a594062eec38f867ae4a819be2ab1307a36d", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2c5a760880aa6390321642418d5bf50a77a6d667", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0bddb3dfcbbf578068033015cddcf8ab22228e11", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "befebcabd8e764b347a1b170c2b1c65bf6809e9a", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "bee26f1d944ec41cc7ff0643a4dbc446c0f2e3f0", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "841d250056178431614158cd9eda98423bab52de", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "04664371e20549ccae922e0d843478e94fc7e370", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "363d2ffbee504f15100d0d936a1524a2b2961af7", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "86b21a0d3471e5807e1d2fcd42f11ac6708ed596", "filename": "gcc/lto/lto-partition.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto-partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto-partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "da55b7efbbe6630e1ddb177476fefa94761e1f1e", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "99454965fdae11598c7bb8396a98dbe09cd1ff79", "filename": "gcc/mcf.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "04d297d579d655a865338e5190f08d225f098da5", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "965ed0e427c50d8a908d6fbde6805eafb7ed6260", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "3ef84cd36878a91eb02d7de2194fe0876a770cf2", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b0c3d0a48fddda828f8c4aac14b22b81da82b288", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "5cd39ef9307cc0d552f87bc26ca244a2aae98567", "filename": "gcc/objc/objc-gnu-runtime-abi-01.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "598141c68adb0235348b13ae0db047f5e58fbaac", "filename": "gcc/objc/objc-next-runtime-abi-01.c", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "636c3cf029ed8f529d57695505a12c9687e08a31", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 105, "deletions": 115, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "8f307cfb78ed30df89fc1b6afdfb0825c5834aa5", "filename": "gcc/objc/objc-runtime-hooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-runtime-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-runtime-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-hooks.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "594b66bb1fc42ec672609663d4b64efb378f9707", "filename": "gcc/objc/objc-runtime-shared-support.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e5dc644e36600077078bbd28f7b6e9fc055976b7", "filename": "gcc/objc/objc-runtime-shared-support.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "54997072df4bbe3faa17bb286136b593bb5226b6", "filename": "gcc/omp-low.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "356d941761e5a391cc6a0da47c75f99516535e7e", "filename": "gcc/opts-common.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "38cd62bc361852bb6423bba31a14603d032bd8dc", "filename": "gcc/opts-global.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-global.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "26a0bb878c53ea994a648eaccb688f6af915dacc", "filename": "gcc/opts.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b6a43612935abfa6bc5b11ac03fdee66044d33e0", "filename": "gcc/opts.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "7e224fb7a4cea213ee0a459e775aaed794c2c482", "filename": "gcc/passes.c", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "aceca1dc3c9162195d4617f00850e8b9bde4a84b", "filename": "gcc/predict.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b12d1f38637f87d85b7f84d2561f815b34a75f87", "filename": "gcc/print-tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "194ef91f24f028e088f5b88572e73c56800daf18", "filename": "gcc/profile.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "c97d8efee5442e53a4495a70e3c3edd4ad15ff1c", "filename": "gcc/profile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "027ad91acc89d7c0e5e87c7fe0cde84053c134d7", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0279b3d3d616df2a7fe18958cd7408fedc87ea7f", "filename": "gcc/ree.c", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0f48000b5e148ef95a49ee440552a5252d4f3a13", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b15deee9b7a4f9d490487191224156a33d43314d", "filename": "gcc/regrename.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0048d78fb1d6680c50ed58d49019e8c471657c30", "filename": "gcc/regrename.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fregrename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fregrename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "5fd43a3dc13405d394292303ab795b64adb5e6cb", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "05ee881bcf9e79b6c155dfd3d62bd864338a1f66", "filename": "gcc/reload.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0c9468f541b0033ad4e89212493d282656d684d1", "filename": "gcc/reload1.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "5617dc145d1347e333a91e2c21e1c5e891f3dc20", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "52e154132fa93d062f2e2914544a92111d2bc3f1", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "1a80f5272f8cd1a39e03eef1c27a9903d3bfaa2c", "filename": "gcc/sched-int.h", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "a1f4845ec88979dd704436e323105f3cc1de8583", "filename": "gcc/sdbout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "9d9accb96b7567a89c33b28898534202ad13d292", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e5929299c110231b2c7b0b7c92562bdf8d4c2556", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 133, "deletions": 140, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "04714230cb014b0b728c0eb40580fafde989a77a", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 36, "deletions": 48, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f1d1a771f017372477fd0dda1356c906c59d9218", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 59, "deletions": 73, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "47578e82a6ed365f1ee1ccd3e9b662d96c70b969", "filename": "gcc/sese.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2f4a7cbe4ce42a7e8bf3c2d4995bac3f10e60c75", "filename": "gcc/sese.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "add37a47a17012371e96c91269b92fd66d2d027a", "filename": "gcc/statistics.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstatistics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstatistics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "700dbb508ceaaac0a80bb434f73fc51b330c6767", "filename": "gcc/stmt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "20c49f97041abd361710e6bc51e622caab5b2710", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "57793f209e755b3e1af72477963ab9db070b5749", "filename": "gcc/store-motion.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2ec0f8761318b361d76d16187aa608dd5abb22de", "filename": "gcc/tlink.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f7e20998069caf7a2d5162045aee990ad4eaec16", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "4edb98598ec71029d185e0447f040017219a4538", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 132, "deletions": 133, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f05cbf736291632a0886199a917989058658428e", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "42f47523e25ac026c20ed216fb6e4fbe8685f71d", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "eaf59eae800c929b6418ac3fd7fece56d4c9ec02", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 54, "deletions": 63, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f838e809982ce9b14145c22eff9934bf26d6517e", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "c9c3f7f0275e265cdd1b0b94c0112d70352226fa", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "6d61d5fa8ea48827fef7c2be81f99d416f9f9207", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "4b278a728ce6ce7d55bf9f57dd4570871ed11bee", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "458362c5d0a50cb6397dd17dfa0225df390acdf6", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 185, "deletions": 194, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "83929f402cd01042697802380d90db372786fe48", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "3bba8d3f8e28aac6b9213ca3e3df4b9aa33bdedb", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "788b118c3e8d83a072ddbe6166948a63ed42b2b1", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f06ff68f5dac3e3cafc2c595dc5e0de793c30053", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "922fcfe454bfc479feaa65c8c4a713ec899af4c3", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "93270b861c2729dac9bba9daa93d2dea81f55826", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "81c5bb3377ba0c128de4218411b0f30f97490314", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b7e280483986475bdb59c46996ec2f676a2369ae", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "a06d7b92a3ca0f1fe05da7434d775db978e5103f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f6585fbf2b5b38d1998354c24f30a376f9368ec2", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2a389895d3d2e7a69b1b3320e2c42bd77f0a4c6a", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 66, "deletions": 74, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "7de885a10cd9357da4face433b53f9fe3fbaeef6", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "a0a766b810070228b65e4aa2ff8a7aa26fa2b430", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 108, "deletions": 102, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "9b9c549a19ba8286b1e4a65993fb1bc4ceee2330", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e44756d120c505607c19f4cf74021728605419cd", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "5119b1d6fcfd21529b2bb56294511588576f402b", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 59, "deletions": 63, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "4a691acdd185f95b5a367dae56c8389212f71b70", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2c269647ddfd553389be73616250ca49d2a40cb9", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b1dce08e017e77fe442044be9d5556b6df832587", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 132, "deletions": 136, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "755e3639ed3612d4bfeed8a3819010782751c316", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "d19154265e392a21671a0f5bf5f525cfbd223b69", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "b5606482629ba4520df16db82575a0a2a6f35b4d", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 87, "deletions": 92, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "3b1e068515a5b9a144ca73fb44878b85d3ae3934", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0b9b090a37cce646dccf0eb82ab30c3dfa9c52e7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "4e565448d5b7c03be116ffaa043a5f889452d60a", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "35774a7b5b206049d251fb565aeffa26f50cbd77", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "2cfe95395682fa7ae44e3efab52eca11354a867f", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "0c2158c6e5eb4e252745ac9fe5f597563dde13ee", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 33, "deletions": 44, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "5c612d075db5042ff3c1b2b0fbeb23dc7ba673e3", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "878caeb823bee5d7ad3daebfabac478610ca489a", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "f1ee1f421f3d3e0a96445223070df23376350655", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "7f4d045d275ffc94a63bfd3db8f3e69f77fc8548", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 68, "deletions": 89, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "108c338d3c70ad2c32c52eae54c9a3becfde455c", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "ed1317080ea9e6f85a14530ed14c302380a425ee", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}, {"sha": "e3d2f9c16141b3adea458b80b4a205b3ee039650", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9771b26396c39dfaecd5a76dd359fb65d3be4cb6/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=9771b26396c39dfaecd5a76dd359fb65d3be4cb6"}]}