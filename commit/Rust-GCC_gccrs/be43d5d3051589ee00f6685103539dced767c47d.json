{"sha": "be43d5d3051589ee00f6685103539dced767c47d", "node_id": "C_kwDOANBUbNoAKGJlNDNkNWQzMDUxNTg5ZWUwMGY2Njg1MTAzNTM5ZGNlZDc2N2M0N2Q", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-19T17:28:09Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-20T14:09:18Z"}, "message": "Replace finite_operands_p with maybe_isnan.\n\nThe finite_operands_p function was incorrectly named, as it only\nreturned TRUE when !NAN.  This was leftover from the initial\nimplementation of frange.  Using the maybe_isnan() nomenclature is\nmore consistent and easier to understand.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (finite_operand_p): Remove.\n\t(finite_operands_p): Rename to...\n\t(maybe_isnan): ...this.\n\t(frelop_early_resolve): Use maybe_isnan instead of finite_operands_p.\n\t(foperator_equal::fold_range): Same.\n\t(foperator_equal::op1_range): Same.\n\t(foperator_not_equal::fold_range): Same.\n\t(foperator_lt::fold_range): Same.\n\t(foperator_le::fold_range): Same.\n\t(foperator_gt::fold_range): Same.\n\t(foperator_ge::fold_range): Same.", "tree": {"sha": "ff7e1334ff43d035359b93a468ebc6a2087dd283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7e1334ff43d035359b93a468ebc6a2087dd283"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be43d5d3051589ee00f6685103539dced767c47d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be43d5d3051589ee00f6685103539dced767c47d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be43d5d3051589ee00f6685103539dced767c47d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be43d5d3051589ee00f6685103539dced767c47d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c75ee0bffabfd6056e29e7a421ae8e9615639a8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75ee0bffabfd6056e29e7a421ae8e9615639a8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75ee0bffabfd6056e29e7a421ae8e9615639a8f"}], "stats": {"total": 41, "additions": 18, "deletions": 23}, "files": [{"sha": "2a4a99ba4678ec23cf807467c3d4ed1ff0d72860", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be43d5d3051589ee00f6685103539dced767c47d/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be43d5d3051589ee00f6685103539dced767c47d/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=be43d5d3051589ee00f6685103539dced767c47d", "patch": "@@ -166,20 +166,15 @@ range_operator_float::op1_op2_relation (const frange &lhs ATTRIBUTE_UNUSED) cons\n   return VREL_VARYING;\n }\n \n-// Return TRUE if OP1 is known to be free of NANs.\n+// Return TRUE if OP1 and OP2 may be a NAN.\n \n static inline bool\n-finite_operand_p (const frange &op1)\n+maybe_isnan (const frange &op1, const frange &op2)\n {\n-  return flag_finite_math_only || !op1.maybe_isnan ();\n-}\n-\n-// Return TRUE if OP1 and OP2 are known to be free of NANs.\n+  if (flag_finite_math_only)\n+    return false;\n \n-static inline bool\n-finite_operands_p (const frange &op1, const frange &op2)\n-{\n-  return flag_finite_math_only || (!op1.maybe_isnan () && !op2.maybe_isnan ());\n+  return op1.maybe_isnan () || op2.maybe_isnan ();\n }\n \n // Floating version of relop_early_resolve that takes into account NAN\n@@ -196,7 +191,7 @@ frelop_early_resolve (irange &r, tree type,\n \n   // We can fold relations from the oracle when we know both operands\n   // are free of NANs, or when -ffinite-math-only.\n-  return (finite_operands_p (op1, op2)\n+  return (!maybe_isnan (op1, op2)\n \t  && relop_early_resolve (r, type, op1, op2, rel, my_rel));\n }\n \n@@ -391,7 +386,7 @@ foperator_equal::fold_range (irange &r, tree type,\n       else\n \tr = range_false (type);\n     }\n-  else if (finite_operands_p (op1, op2))\n+  else if (!maybe_isnan (op1, op2))\n     {\n       // If ranges do not intersect, we know the range is not equal,\n       // otherwise we don't know anything for sure.\n@@ -441,7 +436,7 @@ foperator_equal::op1_range (frange &r, tree type,\n       // If the result is false, the only time we know anything is\n       // if OP2 is a constant.\n       else if (op2.singleton_p ()\n-\t       || (finite_operand_p (op2) && op2.zero_p ()))\n+\t       || (!op2.maybe_isnan () && op2.zero_p ()))\n \t{\n \t  REAL_VALUE_TYPE tmp = op2.lower_bound ();\n \t  r.set (type, tmp, tmp, VR_ANTI_RANGE);\n@@ -494,7 +489,7 @@ foperator_not_equal::fold_range (irange &r, tree type,\n       else\n \tr = range_false (type);\n     }\n-  else if (finite_operands_p (op1, op2))\n+  else if (!maybe_isnan (op1, op2))\n     {\n       // If ranges do not intersect, we know the range is not equal,\n       // otherwise we don't know anything for sure.\n@@ -590,7 +585,7 @@ foperator_lt::fold_range (irange &r, tree type,\n \n   if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n-  else if (finite_operands_p (op1, op2))\n+  else if (!maybe_isnan (op1, op2))\n     {\n       if (real_less (&op1.upper_bound (), &op2.lower_bound ()))\n \tr = range_true (type);\n@@ -706,7 +701,7 @@ foperator_le::fold_range (irange &r, tree type,\n \n   if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n-  else if (finite_operands_p (op1, op2))\n+  else if (!maybe_isnan (op1, op2))\n     {\n       if (real_compare (LE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n \tr = range_true (type);\n@@ -814,7 +809,7 @@ foperator_gt::fold_range (irange &r, tree type,\n \n   if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n-  else if (finite_operands_p (op1, op2))\n+  else if (!maybe_isnan (op1, op2))\n     {\n       if (real_compare (GT_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n \tr = range_true (type);\n@@ -930,7 +925,7 @@ foperator_ge::fold_range (irange &r, tree type,\n \n   if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n-  else if (finite_operands_p (op1, op2))\n+  else if (!maybe_isnan (op1, op2))\n     {\n       if (real_compare (GE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n \tr = range_true (type);\n@@ -1302,7 +1297,7 @@ class foperator_unordered_lt : public range_operator_float\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n-    if (finite_operands_p (op1, op2) || r == range_true (type))\n+    if (!maybe_isnan (op1, op2) || r == range_true (type))\n       return true;\n     else\n       {\n@@ -1331,7 +1326,7 @@ class foperator_unordered_le : public range_operator_float\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n-    if (finite_operands_p (op1, op2) || r == range_true (type))\n+    if (!maybe_isnan (op1, op2) || r == range_true (type))\n       return true;\n     else\n       {\n@@ -1412,7 +1407,7 @@ class foperator_unordered_gt : public range_operator_float\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n-    if (finite_operands_p (op1, op2) || r == range_true (type))\n+    if (!maybe_isnan (op1, op2) || r == range_true (type))\n       return true;\n     else\n       {\n@@ -1495,7 +1490,7 @@ class foperator_unordered_ge : public range_operator_float\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n-    if (finite_operands_p (op1, op2) || r == range_true (type))\n+    if (!maybe_isnan (op1, op2) || r == range_true (type))\n       return true;\n     else\n       {\n@@ -1577,7 +1572,7 @@ class foperator_unordered_equal : public range_operator_float\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n-    if (finite_operands_p (op1, op2) || r == range_true (type))\n+    if (!maybe_isnan (op1, op2) || r == range_true (type))\n       return true;\n     else\n       {"}]}