{"sha": "7d3eecca8d4cb8d11667a3998820200a439a899a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzZWVjY2E4ZDRjYjhkMTE2NjdhMzk5ODgyMDIwMGE0MzlhODk5YQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-08-01T17:10:38Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-08-01T17:10:38Z"}, "message": "Revert r250771\n\n2017-08-01  Martin Liska  <mliska@suse.cz>\n\n\tRevert r250771\n\tMake mempcpy more optimal (PR middle-end/70140).\n2017-08-01  Martin Liska  <mliska@suse.cz>\n\n\tRevert r250771\n\tMake mempcpy more optimal (PR middle-end/70140).\n\nFrom-SVN: r250788", "tree": {"sha": "ed73b5dd4f6c755566a7308b29172ebce2e4cf31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed73b5dd4f6c755566a7308b29172ebce2e4cf31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d3eecca8d4cb8d11667a3998820200a439a899a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3eecca8d4cb8d11667a3998820200a439a899a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3eecca8d4cb8d11667a3998820200a439a899a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3eecca8d4cb8d11667a3998820200a439a899a/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32341663e1ead3f8884add1d09c705d1aa8465ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32341663e1ead3f8884add1d09c705d1aa8465ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32341663e1ead3f8884add1d09c705d1aa8465ce"}], "stats": {"total": 287, "additions": 177, "deletions": 110}, "files": [{"sha": "0b9b6e04fb44f261221666fefb4eb0c5a8ec00fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d3eecca8d4cb8d11667a3998820200a439a899a", "patch": "@@ -1,3 +1,8 @@\n+2017-08-01  Martin Liska  <mliska@suse.cz>\n+\n+\tRevert r250771\n+\tMake mempcpy more optimal (PR middle-end/70140).\n+\n 2017-08-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/81622"}, {"sha": "2deef725620b69ae855f21037e0dfb5fbf0336cc", "filename": "gcc/builtins.c", "status": "modified", "additions": 165, "deletions": 107, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=7d3eecca8d4cb8d11667a3998820200a439a899a", "patch": "@@ -121,12 +121,12 @@ static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n static rtx expand_builtin_memchr (tree, rtx);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_memcpy_with_bounds (tree, rtx);\n-static rtx expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n-\t\t\t\t\t    rtx target, tree exp, int endp);\n+static rtx expand_builtin_memcpy_args (tree, tree, tree, rtx, tree);\n static rtx expand_builtin_memmove (tree, rtx);\n-static rtx expand_builtin_mempcpy (tree, rtx);\n-static rtx expand_builtin_mempcpy_with_bounds (tree, rtx);\n-static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, int);\n+static rtx expand_builtin_mempcpy (tree, rtx, machine_mode);\n+static rtx expand_builtin_mempcpy_with_bounds (tree, rtx, machine_mode);\n+static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx,\n+\t\t\t\t\tmachine_mode, int, tree);\n static rtx expand_builtin_strcat (tree, rtx);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n@@ -2961,6 +2961,81 @@ determine_block_size (tree len, rtx len_rtx,\n \t\t\t  GET_MODE_MASK (GET_MODE (len_rtx)));\n }\n \n+/* Helper function to do the actual work for expand_builtin_memcpy.  */\n+\n+static rtx\n+expand_builtin_memcpy_args (tree dest, tree src, tree len, rtx target, tree exp)\n+{\n+  const char *src_str;\n+  unsigned int src_align = get_pointer_alignment (src);\n+  unsigned int dest_align = get_pointer_alignment (dest);\n+  rtx dest_mem, src_mem, dest_addr, len_rtx;\n+  HOST_WIDE_INT expected_size = -1;\n+  unsigned int expected_align = 0;\n+  unsigned HOST_WIDE_INT min_size;\n+  unsigned HOST_WIDE_INT max_size;\n+  unsigned HOST_WIDE_INT probable_max_size;\n+\n+  /* If DEST is not a pointer type, call the normal function.  */\n+  if (dest_align == 0)\n+    return NULL_RTX;\n+\n+  /* If either SRC is not a pointer type, don't do this\n+     operation in-line.  */\n+  if (src_align == 0)\n+    return NULL_RTX;\n+\n+  if (currently_expanding_gimple_stmt)\n+    stringop_block_profile (currently_expanding_gimple_stmt,\n+\t\t\t    &expected_align, &expected_size);\n+\n+  if (expected_align < dest_align)\n+    expected_align = dest_align;\n+  dest_mem = get_memory_rtx (dest, len);\n+  set_mem_align (dest_mem, dest_align);\n+  len_rtx = expand_normal (len);\n+  determine_block_size (len, len_rtx, &min_size, &max_size,\n+\t\t\t&probable_max_size);\n+  src_str = c_getstr (src);\n+\n+  /* If SRC is a string constant and block move would be done\n+     by pieces, we can avoid loading the string from memory\n+     and only stored the computed constants.  */\n+  if (src_str\n+      && CONST_INT_P (len_rtx)\n+      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n+      && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n+\t\t\t      CONST_CAST (char *, src_str),\n+\t\t\t      dest_align, false))\n+    {\n+      dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n+\t\t\t\t  builtin_memcpy_read_str,\n+\t\t\t\t  CONST_CAST (char *, src_str),\n+\t\t\t\t  dest_align, false, 0);\n+      dest_mem = force_operand (XEXP (dest_mem, 0), target);\n+      dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+      return dest_mem;\n+    }\n+\n+  src_mem = get_memory_rtx (src, len);\n+  set_mem_align (src_mem, src_align);\n+\n+  /* Copy word part most expediently.  */\n+  dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n+\t\t\t\t     CALL_EXPR_TAILCALL (exp)\n+\t\t\t\t     ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n+\t\t\t\t     expected_align, expected_size,\n+\t\t\t\t     min_size, max_size, probable_max_size);\n+\n+  if (dest_addr == 0)\n+    {\n+      dest_addr = force_operand (XEXP (dest_mem, 0), target);\n+      dest_addr = convert_memory_address (ptr_mode, dest_addr);\n+    }\n+\n+  return dest_addr;\n+}\n+\n /* Try to verify that the sizes and lengths of the arguments to a string\n    manipulation function given by EXP are within valid bounds and that\n    the operation does not lead to buffer overflow.  Arguments other than\n@@ -3303,8 +3378,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n \n   check_memop_sizes (exp, dest, src, len);\n \n-  return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n-\t\t\t\t\t  /*endp=*/ 0);\n+  return expand_builtin_memcpy_args (dest, src, len, target, exp);\n }\n \n /* Check a call EXP to the memmove built-in for validity.\n@@ -3344,8 +3418,7 @@ expand_builtin_memcpy_with_bounds (tree exp, rtx target)\n       tree dest = CALL_EXPR_ARG (exp, 0);\n       tree src = CALL_EXPR_ARG (exp, 2);\n       tree len = CALL_EXPR_ARG (exp, 4);\n-      rtx res = expand_builtin_memory_copy_args (dest, src, len, target, exp,\n-\t\t\t\t\t\t /*end_p=*/ 0);\n+      rtx res = expand_builtin_memcpy_args (dest, src, len, target, exp);\n \n       /* Return src bounds with the result.  */\n       if (res)\n@@ -3367,7 +3440,7 @@ expand_builtin_memcpy_with_bounds (tree exp, rtx target)\n    stpcpy.  */\n \n static rtx\n-expand_builtin_mempcpy (tree exp, rtx target)\n+expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n {\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -3384,7 +3457,8 @@ expand_builtin_mempcpy (tree exp, rtx target)\n     return NULL_RTX;\n \n   return expand_builtin_mempcpy_args (dest, src, len,\n-\t\t\t\t      target, exp, /*endp=*/ 1);\n+\t\t\t\t      target, mode, /*endp=*/ 1,\n+\t\t\t\t      exp);\n }\n \n /* Expand an instrumented call EXP to the mempcpy builtin.\n@@ -3393,7 +3467,7 @@ expand_builtin_mempcpy (tree exp, rtx target)\n    mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_mempcpy_with_bounds (tree exp, rtx target)\n+expand_builtin_mempcpy_with_bounds (tree exp, rtx target, machine_mode mode)\n {\n   if (!validate_arglist (exp,\n \t\t\t POINTER_TYPE, POINTER_BOUNDS_TYPE,\n@@ -3406,7 +3480,7 @@ expand_builtin_mempcpy_with_bounds (tree exp, rtx target)\n       tree src = CALL_EXPR_ARG (exp, 2);\n       tree len = CALL_EXPR_ARG (exp, 4);\n       rtx res = expand_builtin_mempcpy_args (dest, src, len, target,\n-\t\t\t\t\t     exp, 1);\n+\t\t\t\t\t     mode, 1, exp);\n \n       /* Return src bounds with the result.  */\n       if (res)\n@@ -3419,111 +3493,94 @@ expand_builtin_mempcpy_with_bounds (tree exp, rtx target)\n     }\n }\n \n-/* Helper function to do the actual work for expand of memory copy family\n-   functions (memcpy, mempcpy, stpcpy).  Expansing should assign LEN bytes\n-   of memory from SRC to DEST and assign to TARGET if convenient.\n-   If ENDP is 0 return the\n-   destination pointer, if ENDP is 1 return the end pointer ala\n-   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n-   stpcpy.  */\n+/* Helper function to do the actual work for expand_builtin_mempcpy.  The\n+   arguments to the builtin_mempcpy call DEST, SRC, and LEN are broken out\n+   so that this can also be called without constructing an actual CALL_EXPR.\n+   The other arguments and return value are the same as for\n+   expand_builtin_mempcpy.  */\n \n static rtx\n-expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n-\t\t\t\t rtx target, tree exp, int endp)\n+expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n+\t\t\t     rtx target, machine_mode mode, int endp,\n+\t\t\t     tree orig_exp)\n {\n-  const char *src_str;\n-  unsigned int src_align = get_pointer_alignment (src);\n-  unsigned int dest_align = get_pointer_alignment (dest);\n-  rtx dest_mem, src_mem, dest_addr, len_rtx;\n-  HOST_WIDE_INT expected_size = -1;\n-  unsigned int expected_align = 0;\n-  unsigned HOST_WIDE_INT min_size;\n-  unsigned HOST_WIDE_INT max_size;\n-  unsigned HOST_WIDE_INT probable_max_size;\n-\n-  /* If DEST is not a pointer type, call the normal function.  */\n-  if (dest_align == 0)\n-    return NULL_RTX;\n-\n-  /* If either SRC is not a pointer type, don't do this\n-     operation in-line.  */\n-  if (src_align == 0)\n-    return NULL_RTX;\n-\n-  if (currently_expanding_gimple_stmt)\n-    stringop_block_profile (currently_expanding_gimple_stmt,\n-\t\t\t    &expected_align, &expected_size);\n-\n-  if (expected_align < dest_align)\n-    expected_align = dest_align;\n-  dest_mem = get_memory_rtx (dest, len);\n-  set_mem_align (dest_mem, dest_align);\n-  len_rtx = expand_normal (len);\n-  determine_block_size (len, len_rtx, &min_size, &max_size,\n-\t\t\t&probable_max_size);\n-  src_str = c_getstr (src);\n+  tree fndecl = get_callee_fndecl (orig_exp);\n \n-  /* If SRC is a string constant and block move would be done\n-     by pieces, we can avoid loading the string from memory\n-     and only stored the computed constants.  */\n-  if (src_str\n-      && CONST_INT_P (len_rtx)\n-      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n-      && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t      CONST_CAST (char *, src_str),\n-\t\t\t      dest_align, false))\n+    /* If return value is ignored, transform mempcpy into memcpy.  */\n+  if (target == const0_rtx\n+      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK_CHKP\n+      && builtin_decl_implicit_p (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK_CHKP))\n     {\n-      dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n-\t\t\t\t  builtin_memcpy_read_str,\n-\t\t\t\t  CONST_CAST (char *, src_str),\n-\t\t\t\t  dest_align, false, endp);\n-      dest_mem = force_operand (XEXP (dest_mem, 0), target);\n-      dest_mem = convert_memory_address (ptr_mode, dest_mem);\n-      return dest_mem;\n+      tree fn = builtin_decl_implicit (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK_CHKP);\n+      tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n+\t\t\t\t\t   dest, src, len);\n+      return expand_expr (result, target, mode, EXPAND_NORMAL);\n+    }\n+  else if (target == const0_rtx\n+\t   && builtin_decl_implicit_p (BUILT_IN_MEMCPY))\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+      tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n+\t\t\t\t\t   dest, src, len);\n+      return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n+  else\n+    {\n+      const char *src_str;\n+      unsigned int src_align = get_pointer_alignment (src);\n+      unsigned int dest_align = get_pointer_alignment (dest);\n+      rtx dest_mem, src_mem, len_rtx;\n \n-  src_mem = get_memory_rtx (src, len);\n-  set_mem_align (src_mem, src_align);\n+      /* If either SRC or DEST is not a pointer type, don't do this\n+\t operation in-line.  */\n+      if (dest_align == 0 || src_align == 0)\n+\treturn NULL_RTX;\n \n-  /* Copy word part most expediently.  */\n-  dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n-\t\t\t\t     CALL_EXPR_TAILCALL (exp)\n-\t\t\t\t     ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n-\t\t\t\t     expected_align, expected_size,\n-\t\t\t\t     min_size, max_size, probable_max_size);\n+      /* If LEN is not constant, call the normal function.  */\n+      if (! tree_fits_uhwi_p (len))\n+\treturn NULL_RTX;\n \n-  if (dest_addr == 0)\n-    {\n-      dest_addr = force_operand (XEXP (dest_mem, 0), target);\n-      dest_addr = convert_memory_address (ptr_mode, dest_addr);\n-      return dest_addr;\n-    }\n+      len_rtx = expand_normal (len);\n+      src_str = c_getstr (src);\n \n-  if (endp)\n-    {\n-      rtx tmp1 = gen_reg_rtx (ptr_mode);\n-      dest_addr = emit_move_insn (tmp1, gen_rtx_PLUS (ptr_mode, dest_addr,\n-\t\t\t\t\t\t      len_rtx));\n-      /* stpcpy pointer to last byte.  */\n-      if (endp == 2)\n+      /* If SRC is a string constant and block move would be done\n+\t by pieces, we can avoid loading the string from memory\n+\t and only stored the computed constants.  */\n+      if (src_str\n+\t  && CONST_INT_P (len_rtx)\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n+\t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n+\t\t\t\t  CONST_CAST (char *, src_str),\n+\t\t\t\t  dest_align, false))\n \t{\n-\t  rtx tmp2 = emit_move_insn (tmp1, gen_rtx_MINUS (ptr_mode, dest_addr,\n-\t\t\t\t\t\t\t  const1_rtx));\n-\t  tmp1 = tmp2;\n+\t  dest_mem = get_memory_rtx (dest, len);\n+\t  set_mem_align (dest_mem, dest_align);\n+\t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n+\t\t\t\t      builtin_memcpy_read_str,\n+\t\t\t\t      CONST_CAST (char *, src_str),\n+\t\t\t\t      dest_align, false, endp);\n+\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+\t  return dest_mem;\n \t}\n-      emit_move_insn (target, force_operand (tmp1, NULL_RTX));\n-      return target;\n-    }\n \n-  return dest_addr;\n-}\n+      if (CONST_INT_P (len_rtx)\n+\t  && can_move_by_pieces (INTVAL (len_rtx),\n+\t\t\t\t MIN (dest_align, src_align)))\n+\t{\n+\t  dest_mem = get_memory_rtx (dest, len);\n+\t  set_mem_align (dest_mem, dest_align);\n+\t  src_mem = get_memory_rtx (src, len);\n+\t  set_mem_align (src_mem, src_align);\n+\t  dest_mem = move_by_pieces (dest_mem, src_mem, INTVAL (len_rtx),\n+\t\t\t\t     MIN (dest_align, src_align), endp);\n+\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+\t  return dest_mem;\n+\t}\n \n-static rtx\n-expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n-\t\t\t     rtx target, tree orig_exp, int endp)\n-{\n-  return expand_builtin_memory_copy_args (dest, src, len, target, orig_exp,\n-\t\t\t\t\t  endp);\n+      return NULL_RTX;\n+    }\n }\n \n /* Expand into a movstr instruction, if one is available.  Return NULL_RTX if\n@@ -3681,7 +3738,8 @@ expand_builtin_stpcpy (tree exp, rtx target, machine_mode mode)\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n-\t\t\t\t\t target, exp, /*endp=*/2);\n+\t\t\t\t\t target, mode, /*endp=*/2,\n+\t\t\t\t\t exp);\n \n       if (ret)\n \treturn ret;\n@@ -6844,7 +6902,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       break;\n \n     case BUILT_IN_MEMPCPY:\n-      target = expand_builtin_mempcpy (exp, target);\n+      target = expand_builtin_mempcpy (exp, target, mode);\n       if (target)\n \treturn target;\n       break;\n@@ -7623,7 +7681,7 @@ expand_builtin_with_bounds (tree exp, rtx target,\n       break;\n \n     case BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK_CHKP:\n-      target = expand_builtin_mempcpy_with_bounds (exp, target);\n+      target = expand_builtin_mempcpy_with_bounds (exp, target, mode);\n       if (target)\n \treturn target;\n       break;"}, {"sha": "0f0a39c4ec17654e4adfef643e1194ff0f0daff6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d3eecca8d4cb8d11667a3998820200a439a899a", "patch": "@@ -1,3 +1,8 @@\n+2017-08-01  Martin Liska  <mliska@suse.cz>\n+\n+\tRevert r250771\n+\tMake mempcpy more optimal (PR middle-end/70140).\n+\n 2017-08-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/81622"}, {"sha": "bc0f30098fa1fc4225d0bb3230f5e59f7a8fa738", "filename": "gcc/testsuite/gcc.dg/string-opt-1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3eecca8d4cb8d11667a3998820200a439a899a/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c?ref=7d3eecca8d4cb8d11667a3998820200a439a899a", "patch": "@@ -1,4 +1,4 @@\n-/* Ensure mempcpy is \"optimized\" into memcpy followed by addition.  */\n+/* Ensure mempcpy is not \"optimized\" into memcpy followed by addition.  */\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n \n@@ -8,5 +8,4 @@ fn (char *x, char *y, int z)\n   return __builtin_mempcpy (x, y, z);\n }\n \n-/* { dg-final { scan-assembler-not \"mempcpy\" } } */\n-/* { dg-final { scan-assembler \"memcpy\" } } */\n+/* { dg-final { scan-assembler-not \"memcpy\" } } */"}]}