{"sha": "a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e", "node_id": "C_kwDOANBUbNoAKGEwZGI1OWJjNWZjZmRiOWZhN2I3Yjk0YWYzMGZmOWFmZmRlOGFiNWU", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-11-01T17:01:16Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-11-04T16:53:02Z"}, "message": "Fortran manual: Update section on Interoperability with C\n\n2021-11-01  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/fortran/\n\t* gfortran.texi (Interoperability with C): Copy-editing.  Add\n\tmore index entries.\n\t(Intrinsic Types): Likewise.\n\t(Derived Types and struct): Likewise.\n\t(Interoperable Global Variables): Likewise.\n\t(Interoperable Subroutines and Functions): Likewise.\n\t(Working with C Pointers): Likewise.\n\t(Further Interoperability of Fortran with C): Likewise.  Rewrite\n\tto reflect that this is now fully supported by gfortran.", "tree": {"sha": "a17147daea294e39dec14df14da3278559f9c215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a17147daea294e39dec14df14da3278559f9c215"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "227e0100360b83e7981ef9b2ce85435bbc16ee82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227e0100360b83e7981ef9b2ce85435bbc16ee82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/227e0100360b83e7981ef9b2ce85435bbc16ee82"}], "stats": {"total": 170, "additions": 69, "deletions": 101}, "files": [{"sha": "e231e74126515f049acb3320696fb937a3418af2", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 69, "deletions": 101, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=a0db59bc5fcfdb9fa7b7b94af30ff9affde8ab5e", "patch": "@@ -2726,20 +2726,22 @@ and their use is highly recommended.\n \n @node Interoperability with C\n @section Interoperability with C\n+@cindex interoperability with C\n+@cindex C interoperability\n \n @menu\n * Intrinsic Types::\n * Derived Types and struct::\n * Interoperable Global Variables::\n * Interoperable Subroutines and Functions::\n-* Working with Pointers::\n+* Working with C Pointers::\n * Further Interoperability of Fortran with C::\n @end menu\n \n Since Fortran 2003 (ISO/IEC 1539-1:2004(E)) there is a\n standardized way to generate procedure and derived-type\n-declarations and global variables which are interoperable with C\n-(ISO/IEC 9899:1999).  The @code{bind(C)} attribute has been added\n+declarations and global variables that are interoperable with C\n+(ISO/IEC 9899:1999).  The @code{BIND(C)} attribute has been added\n to inform the compiler that a symbol shall be interoperable with C;\n also, some constraints are added.  Note, however, that not\n all C features have a Fortran equivalent or vice versa.  For instance,\n@@ -2755,12 +2757,16 @@ assuming @math{i < n}) in memory is @code{A(i+1,j)} (C: @code{A[j-1][i]}).\n \n @node Intrinsic Types\n @subsection Intrinsic Types\n+@cindex C intrinsic type interoperability\n+@cindex intrinsic type interoperability with C\n+@cindex interoperability, intrinsic type\n \n In order to ensure that exactly the same variable type and kind is used\n-in C and Fortran, the named constants shall be used which are defined in the\n-@code{ISO_C_BINDING} intrinsic module.  That module contains named constants\n-for kind parameters and character named constants for the escape sequences\n-in C.  For a list of the constants, see @ref{ISO_C_BINDING}.\n+in C and Fortran, you should use the named constants for kind parameters\n+that are defined in the @code{ISO_C_BINDING} intrinsic module.\n+That module contains named constants of character type representing\n+the escaped special characters in C, such as newline.\n+For a list of the constants, see @ref{ISO_C_BINDING}.\n \n For logical types, please note that the Fortran standard only guarantees\n interoperability between C99's @code{_Bool} and Fortran's @code{C_Bool}-kind\n@@ -2770,12 +2776,13 @@ the value 0.  Using any other integer value with GNU Fortran's @code{LOGICAL}\n values than 0 and 1 to GCC's @code{_Bool} is also undefined, unless the\n integer is explicitly or implicitly casted to @code{_Bool}.)\n \n-\n-\n @node Derived Types and struct\n @subsection Derived Types and struct\n+@cindex C derived type and struct interoperability\n+@cindex derived type interoperability with C\n+@cindex interoperability, derived type and struct\n \n-For compatibility of derived types with @code{struct}, one needs to use\n+For compatibility of derived types with @code{struct}, use\n the @code{BIND(C)} attribute in the type declaration.  For instance, the\n following type declaration\n \n@@ -2790,6 +2797,7 @@ following type declaration\n  END TYPE\n @end smallexample\n \n+@noindent\n matches the following @code{struct} declaration in C\n \n @smallexample\n@@ -2814,6 +2822,9 @@ with bit field or variable-length array members are interoperable.\n \n @node Interoperable Global Variables\n @subsection Interoperable Global Variables\n+@cindex C variable interoperability\n+@cindex variable interoperability with C\n+@cindex interoperability, variable\n \n Variables can be made accessible from C using the C binding attribute,\n optionally together with specifying a binding name.  Those variables\n@@ -2841,17 +2852,18 @@ a macro.  Use the @code{IERRNO} intrinsic (GNU extension) instead.\n \n @node Interoperable Subroutines and Functions\n @subsection Interoperable Subroutines and Functions\n+@cindex C procedure interoperability\n+@cindex procedure interoperability with C\n+@cindex function interoperability with C\n+@cindex subroutine interoperability with C\n+@cindex interoperability, subroutine and function\n \n Subroutines and functions have to have the @code{BIND(C)} attribute to\n be compatible with C.  The dummy argument declaration is relatively\n straightforward.  However, one needs to be careful because C uses\n call-by-value by default while Fortran behaves usually similar to\n call-by-reference.  Furthermore, strings and pointers are handled\n-differently.  Note that in Fortran 2003 and 2008 only explicit size\n-and assumed-size arrays are supported but not assumed-shape or\n-deferred-shape (i.e. allocatable or pointer) arrays.  However, those\n-are allowed since the Technical Specification 29113, see\n-@ref{Further Interoperability of Fortran with C}\n+differently.\n \n To pass a variable by value, use the @code{VALUE} attribute.\n Thus, the following C prototype\n@@ -2860,6 +2872,7 @@ Thus, the following C prototype\n @code{int func(int i, int *j)}\n @end smallexample\n \n+@noindent\n matches the Fortran declaration\n \n @smallexample\n@@ -2870,12 +2883,12 @@ matches the Fortran declaration\n @end smallexample\n \n Note that pointer arguments also frequently need the @code{VALUE} attribute,\n-see @ref{Working with Pointers}.\n+see @ref{Working with C Pointers}.\n \n Strings are handled quite differently in C and Fortran.  In C a string\n is a @code{NUL}-terminated array of characters while in Fortran each string\n has a length associated with it and is thus not terminated (by e.g.\n-@code{NUL}).  For example, if one wants to use the following C function,\n+@code{NUL}).  For example, if you want to use the following C function,\n \n @smallexample\n   #include <stdio.h>\n@@ -2885,7 +2898,8 @@ has a length associated with it and is thus not terminated (by e.g.\n   @}\n @end smallexample\n \n-to print ``Hello World'' from Fortran, one can call it using\n+@noindent\n+to print ``Hello World'' from Fortran, you can call it using\n \n @smallexample\n   use iso_c_binding, only: C_CHAR, C_NULL_CHAR\n@@ -2898,7 +2912,7 @@ to print ``Hello World'' from Fortran, one can call it using\n   call print_c(C_CHAR_\"Hello World\"//C_NULL_CHAR)\n @end smallexample\n \n-As the example shows, one needs to ensure that the\n+As the example shows, you need to ensure that the\n string is @code{NUL} terminated.  Additionally, the dummy argument\n @var{string} of @code{print_C} is a length-one assumed-size\n array; using @code{character(len=*)} is not allowed.  The example\n@@ -2914,6 +2928,7 @@ function @code{strncpy}, whose prototype is\n   char *strncpy(char *restrict s1, const char *restrict s2, size_t n);\n @end smallexample\n \n+@noindent\n The function @code{strncpy} copies at most @var{n} characters from\n string @var{s2} to @var{s1} and returns @var{s1}.  In the following\n example, we ignore the return value:\n@@ -2941,18 +2956,21 @@ example, we ignore the return value:\n \n The intrinsic procedures are described in @ref{Intrinsic Procedures}.\n \n-@node Working with Pointers\n-@subsection Working with Pointers\n+@node Working with C Pointers\n+@subsection Working with C Pointers\n+@cindex C pointers\n+@cindex pointers, C\n \n-C pointers are represented in Fortran via the special opaque derived type\n-@code{type(c_ptr)} (with private components).  Thus one needs to\n+C pointers are represented in Fortran via the special opaque derived\n+type @code{type(c_ptr)} (with private components).  C pointers are distinct\n+from Fortran objects with the @code{POINTER} attribute.  Thus one needs to\n use intrinsic conversion procedures to convert from or to C pointers.\n+For some applications, using an assumed type (@code{TYPE(*)}) can be\n+an alternative to a C pointer, and you can also use library routines\n+to access Fortran pointers from C.  See @ref{Further Interoperability\n+of Fortran with C}.\n \n-For some applications, using an assumed type (@code{TYPE(*)}) can be an\n-alternative to a C pointer; see\n-@ref{Further Interoperability of Fortran with C}.\n-\n-For example,\n+Here is an example of using C pointers in Fortran:\n \n @smallexample\n   use iso_c_binding\n@@ -2970,7 +2988,7 @@ For example,\n When converting C to Fortran arrays, the one-dimensional @code{SHAPE} argument\n has to be passed.\n \n-If a pointer is a dummy-argument of an interoperable procedure, it usually\n+If a pointer is a dummy argument of an interoperable procedure, it usually\n has to be declared using the @code{VALUE} attribute.  @code{void*}\n matches @code{TYPE(C_PTR), VALUE}, while @code{TYPE(C_PTR)} alone\n matches @code{void**}.\n@@ -3096,81 +3114,31 @@ END MODULE m\n \n @node Further Interoperability of Fortran with C\n @subsection Further Interoperability of Fortran with C\n-\n-The Technical Specification ISO/IEC TS 29113:2012 on further\n-interoperability of Fortran with C extends the interoperability support\n-of Fortran 2003 and Fortran 2008. Besides removing some restrictions\n-and constraints, it adds assumed-type (@code{TYPE(*)}) and assumed-rank\n-(@code{dimension}) variables and allows for interoperability of\n-assumed-shape, assumed-rank and deferred-shape arrays, including\n-allocatables and pointers.\n+@cindex Further Interoperability of Fortran with C\n+@cindex TS 29113\n+@cindex array descriptor\n+@cindex dope vector\n+@cindex assumed-type\n+@cindex assumed-rank\n+\n+GNU Fortran implements the Technical Specification ISO/IEC TS\n+29113:2012, which extends the interoperability support of Fortran 2003\n+and Fortran 2008 and is now part of the 2018 Fortran standard.\n+Besides removing some restrictions and constraints, the Technical\n+Specification adds assumed-type (@code{TYPE(*)}) and assumed-rank\n+(@code{DIMENSION(..)}) variables and allows for interoperability of\n+assumed-shape, assumed-rank, and deferred-shape arrays, as well as\n+allocatables and pointers.  Objects of these types are passed to\n+@code{BIND(C)} functions as descriptors with a standard interface,\n+declared in the header file @code{<ISO_Fortran_binding.h>}.\n \n Note: Currently, GNU Fortran does not use internally the array descriptor\n (dope vector) as specified in the Technical Specification, but uses\n-an array descriptor with different fields. Assumed type and assumed rank\n-formal arguments are converted in the library to the specified form. The\n-ISO_Fortran_binding API functions (also Fortran 2018 18.4) are implemented\n-in libgfortran. Alternatively, the Chasm Language Interoperability Tools,\n-@url{http://chasm-interop.sourceforge.net/}, provide an interface to GNU\n-Fortran's array descriptor.\n-\n-The Technical Specification adds the following new features, which\n-are supported by GNU Fortran:\n-\n-@itemize @bullet\n-\n-@item The @code{ASYNCHRONOUS} attribute has been clarified and\n-extended to allow its use with asynchronous communication in\n-user-provided libraries such as in implementations of the\n-Message Passing Interface specification.\n-\n-@item Many constraints have been relaxed, in particular for\n-the @code{C_LOC} and @code{C_F_POINTER} intrinsics.\n-\n-@item The @code{OPTIONAL} attribute is now allowed for dummy\n-arguments; an absent argument matches a @code{NULL} pointer.\n-\n-@item Assumed types (@code{TYPE(*)}) have been added, which may\n-only be used for dummy arguments.  They are unlimited polymorphic\n-but contrary to @code{CLASS(*)} they do not contain any type\n-information, similar to C's @code{void *} pointers.  Expressions\n-of any type and kind can be passed; thus, it can be used as\n-replacement for @code{TYPE(C_PTR)}, avoiding the use of\n-@code{C_LOC} in the caller.\n-\n-Note, however, that @code{TYPE(*)} only accepts scalar arguments,\n-unless the @code{DIMENSION} is explicitly specified.  As\n-@code{DIMENSION(*)} only supports array (including array elements) but\n-no scalars, it is not a full replacement for @code{C_LOC}.  On the\n-other hand, assumed-type assumed-rank dummy arguments\n-(@code{TYPE(*), DIMENSION(..)}) allow for both scalars and arrays, but\n-require special code on the callee side to handle the array descriptor.\n-\n-@item Assumed-rank arrays (@code{DIMENSION(..)}) as dummy argument\n-allow that scalars and arrays of any rank can be passed as actual\n-argument. As the Technical Specification does not provide for direct\n-means to operate with them, they have to be used either from the C side\n-or be converted using @code{C_LOC} and @code{C_F_POINTER} to scalars\n-or arrays of a specific rank. The rank can be determined using the\n-@code{RANK} intrinisic.\n-@end itemize\n-\n-\n-Currently unimplemented:\n-\n-@itemize @bullet\n-\n-@item GNU Fortran always uses an array descriptor, which does not\n-match the one of the Technical Specification. The\n-@code{ISO_Fortran_binding.h} header file and the C functions it\n-specifies are not available.\n-\n-@item Using assumed-shape, assumed-rank and deferred-shape arrays in\n-@code{BIND(C)} procedures is not fully supported. In particular,\n-C interoperable strings of other length than one are not supported\n-as this requires the new array descriptor.\n-@end itemize\n-\n+an array descriptor with different fields in functions without the\n+@code{BIND(C)} attribute.  Arguments to functions marked @code{BIND(C)}\n+are converted to the specified form.  If you need to access GNU Fortran's\n+internal array descriptor, you can use the Chasm Language Interoperability\n+Tools, @url{http://chasm-interop.sourceforge.net/}.\n \n @node GNU Fortran Compiler Directives\n @section GNU Fortran Compiler Directives"}]}