{"sha": "c5e74d9d4ebeb29fab731464c206296ec651e9a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlNzRkOWQ0ZWJlYjI5ZmFiNzMxNDY0YzIwNjI5NmVjNjUxZTlhNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-06-29T23:54:12Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-06-29T23:54:12Z"}, "message": "predicates.md (const_0_to_7_operand): New predicate, recognize 0..7.\n\n[gcc]\n2016-06-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/predicates.md (const_0_to_7_operand): New\n\tpredicate, recognize 0..7.\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add\n\tsupport for doing extracts from V16QImode, V8HImode, V4SImode\n\tunder ISA 3.0.\n\t* config/rs6000/vsx.md (VSX_EXTRACT_I): Mode iterator for ISA 3.0\n\tvector extract support.\n\t(VSX_EXTRACT_PREDICATE): Mode attribute to validate element number\n\tfor ISA 3.0 vector extract.\n\t(VSX_EX): Constraints to use for ISA 3.0 vector extract.\n\t(vsx_extract_<mode>, VSX_EXTRACT_I): Add support for doing\n\textracts of a constant element number from small integer vectors\n\ton 64-bit ISA 3.0 systems.\n\t(vsx_extract_<mode>_di): Likewise.\n\t* config/rs6000/rs6000.h (TARGET_VEXTRACTUB): New target macro to\n\tsay when we can do ISA 3.0 vector extracts.\n\t* config/rs6000/rs6000.md (stfiwx): Allow DImode in Altivec\n\tregisters, using the stxsiwx instruction.\n\n[gcc/testsuite]\n2016-06-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p9-extract-1.c: New file to test ISA 3.0\n\tvector extract instructions.\n\t* gcc.target/powerpc/p9-extract-2.c: Likewise.\n\nFrom-SVN: r237864", "tree": {"sha": "c8f3aa2d947baf993d1bf23e77219924e9a4c969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8f3aa2d947baf993d1bf23e77219924e9a4c969"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5e74d9d4ebeb29fab731464c206296ec651e9a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e74d9d4ebeb29fab731464c206296ec651e9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e74d9d4ebeb29fab731464c206296ec651e9a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e74d9d4ebeb29fab731464c206296ec651e9a6/comments", "author": null, "committer": null, "parents": [{"sha": "e44ecbfd9fde1d4d715c30f584f7cc8e535c749f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e44ecbfd9fde1d4d715c30f584f7cc8e535c749f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e44ecbfd9fde1d4d715c30f584f7cc8e535c749f"}], "stats": {"total": 207, "additions": 204, "deletions": 3}, "files": [{"sha": "8df7f3c4b82c148ea41a4d11c8c82c1efe0cc7d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -1,3 +1,24 @@\n+2016-06-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/predicates.md (const_0_to_7_operand): New\n+\tpredicate, recognize 0..7.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add\n+\tsupport for doing extracts from V16QImode, V8HImode, V4SImode\n+\tunder ISA 3.0.\n+\t* config/rs6000/vsx.md (VSX_EXTRACT_I): Mode iterator for ISA 3.0\n+\tvector extract support.\n+\t(VSX_EXTRACT_PREDICATE): Mode attribute to validate element number\n+\tfor ISA 3.0 vector extract.\n+\t(VSX_EX): Constraints to use for ISA 3.0 vector extract.\n+\t(vsx_extract_<mode>, VSX_EXTRACT_I): Add support for doing\n+\textracts of a constant element number from small integer vectors\n+\ton 64-bit ISA 3.0 systems.\n+\t(vsx_extract_<mode>_di): Likewise.\n+\t* config/rs6000/rs6000.h (TARGET_VEXTRACTUB): New target macro to\n+\tsay when we can do ISA 3.0 vector extracts.\n+\t* config/rs6000/rs6000.md (stfiwx): Allow DImode in Altivec\n+\tregisters, using the stxsiwx instruction.\n+\n 2016-06-29  Jim Wilson  <jim.wilson@linaro.org>\n \n \t* config/aarch64/aarch64-cores.def (qdf24xx): Use qdf24xx tuning."}, {"sha": "6436d5eb3a1ef536c78b76adf1028dfc8eef204c", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -200,6 +200,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 2, 3)\")))\n \n+;; Match op = 0..7.\n+(define_predicate \"const_0_to_7_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 7)\")))\n+\n ;; Match op = 0..15\n (define_predicate \"const_0_to_15_operand\"\n   (and (match_code \"const_int\")"}, {"sha": "b6e4df05077e3816d2d864d431cb2e2bdffb7618", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -6916,6 +6916,30 @@ rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n \tcase V4SFmode:\n \t  emit_insn (gen_vsx_extract_v4sf (target, vec, GEN_INT (elt)));\n \t  return;\n+\tcase V16QImode:\n+\t  if (TARGET_VEXTRACTUB)\n+\t    {\n+\t      emit_insn (gen_vsx_extract_v16qi (target, vec, GEN_INT (elt)));\n+\t      return;\n+\t    }\n+\t  else\n+\t    break;\n+\tcase V8HImode:\n+\t  if (TARGET_VEXTRACTUB)\n+\t    {\n+\t      emit_insn (gen_vsx_extract_v8hi (target, vec, GEN_INT (elt)));\n+\t      return;\n+\t    }\n+\t  else\n+\t    break;\n+\tcase V4SImode:\n+\t  if (TARGET_VEXTRACTUB)\n+\t    {\n+\t      emit_insn (gen_vsx_extract_v4si (target, vec, GEN_INT (elt)));\n+\t      return;\n+\t    }\n+\t  else\n+\t    break;\n \t}\n     }\n "}, {"sha": "f835f439416f10428183a349f4d36a9a8b0aab8c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -599,6 +599,9 @@ extern int rs6000_vector_align[];\n #define TARGET_VADDUQM\t\t(TARGET_P8_VECTOR && TARGET_POWERPC64)\n #define TARGET_DIRECT_MOVE_128\t(TARGET_P9_VECTOR && TARGET_DIRECT_MOVE \\\n \t\t\t\t && TARGET_POWERPC64)\n+#define TARGET_VEXTRACTUB\t(TARGET_P9_VECTOR && TARGET_DIRECT_MOVE \\\n+\t\t\t\t && TARGET_UPPER_REGS_DF \\\n+\t\t\t\t && TARGET_UPPER_REGS_DI && TARGET_POWERPC64)\n \n /* Byte/char syncs were added as phased in for ISA 2.06B, but are not present\n    in power7, so conditionalize them on p8 features.  TImode syncs need quad"}, {"sha": "81d189be1667cb071877f30dadafda72005ab6c9", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -5696,11 +5696,13 @@\n \n ; An UNSPEC is used so we don't have to support SImode in FP registers.\n (define_insn \"stfiwx\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n-\t(unspec:SI [(match_operand:DI 1 \"gpc_reg_operand\" \"d\")]\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=Z,Z\")\n+\t(unspec:SI [(match_operand:DI 1 \"gpc_reg_operand\" \"d,wv\")]\n \t\t   UNSPEC_STFIWX))]\n   \"TARGET_PPC_GFXOPT\"\n-  \"stfiwx %1,%y0\"\n+  \"@\n+   stfiwx %1,%y0\n+   stxsiwx %x1,%y0\"\n   [(set_attr \"type\" \"fpstore\")])\n \n ;; If we don't have a direct conversion to single precision, don't enable this"}, {"sha": "2e1d41d61431b9cd8bd02a8e92eb3c5aec22c7e0", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -263,6 +263,21 @@\n (define_mode_iterator VSINT_84  [V4SI V2DI DI])\n (define_mode_iterator VSINT_842 [V8HI V4SI V2DI])\n \n+;; Iterator for ISA 3.0 vector extract/insert of integer vectors\n+(define_mode_iterator VSX_EXTRACT_I [V16QI V8HI V4SI])\n+\n+;; Mode attribute to give the correct predicate for ISA 3.0 vector extract and\n+;; insert to validate the operand number.\n+(define_mode_attr VSX_EXTRACT_PREDICATE [(V16QI \"const_0_to_15_operand\")\n+\t\t\t\t\t (V8HI  \"const_0_to_7_operand\")\n+\t\t\t\t\t (V4SI  \"const_0_to_3_operand\")])\n+\n+;; Mode attribute to give the constraint for vector extract and insert\n+;; operations.\n+(define_mode_attr VSX_EX [(V16QI \"v\")\n+\t\t\t  (V8HI  \"v\")\n+\t\t\t  (V4SI  \"wa\")])\n+\n ;; Constants for creating unspecs\n (define_c_enum \"unspec\"\n   [UNSPEC_VSX_CONCAT\n@@ -2322,6 +2337,78 @@\n     FAIL;\n })\n \n+;; Extraction of a single element in a small integer vector.  None of the small\n+;; types are currently allowed in a vector register, so we extract to a DImode\n+;; and either do a direct move or store.\n+(define_insn_and_split  \"vsx_extract_<mode>\"\n+  [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\" \"=r,Z\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>,<VSX_EX>\")\n+\t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n,n\")])))\n+   (clobber (match_scratch:DI 3 \"=<VSX_EX>,<VSX_EX>\"))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\"\n+  \"#\"\n+  \"&& (reload_completed || MEM_P (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx element = operands[2];\n+  rtx di_tmp = operands[3];\n+\n+  if (GET_CODE (di_tmp) == SCRATCH)\n+    di_tmp = gen_reg_rtx (DImode);\n+\n+  emit_insn (gen_vsx_extract_<mode>_di (di_tmp, src, element));\n+\n+  if (REG_P (dest))\n+    emit_move_insn (gen_rtx_REG (DImode, REGNO (dest)), di_tmp);\n+  else if (SUBREG_P (dest))\n+    emit_move_insn (gen_rtx_REG (DImode, subreg_regno (dest)), di_tmp);\n+  else if (MEM_P (operands[0]))\n+    {\n+      if (can_create_pseudo_p ())\n+\tdest = rs6000_address_for_fpconvert (dest);\n+\n+      if (<MODE>mode == V16QImode)\n+\temit_insn (gen_p9_stxsibx (dest, di_tmp));\n+      else if (<MODE>mode == V8HImode)\n+\temit_insn (gen_p9_stxsihx (dest, di_tmp));\n+      else if (<MODE>mode == V4SImode)\n+\temit_insn (gen_stfiwx (dest, di_tmp));\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  DONE;\n+}\n+  [(set_attr \"type\" \"vecsimple,fpstore\")])\n+\n+(define_insn  \"vsx_extract_<mode>_di\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=<VSX_EX>\")\n+\t(zero_extend:DI\n+\t (vec_select:<VS_scalar>\n+\t  (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>\")\n+\t  (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")]))))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_VEXTRACTUB\"\n+{\n+  int element = INTVAL (operands[2]);\n+  int unit_size = GET_MODE_UNIT_SIZE (<MODE>mode);\n+  int offset = ((VECTOR_ELT_ORDER_BIG)\n+\t\t? unit_size * element\n+\t\t: unit_size * (GET_MODE_NUNITS (<MODE>mode) - 1 - element));\n+\n+  operands[2] = GEN_INT (offset);\n+  if (unit_size == 4)\n+    return \"xxextractuw %x0,%x1,%2\";\n+  else\n+    return \"vextractu<wd> %0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+\n ;; Expanders for builtins\n (define_expand \"vsx_mergel_<mode>\"\n   [(use (match_operand:VSX_D 0 \"vsx_register_operand\" \"\"))"}, {"sha": "9763bacb9d30e71cedb44a8d1ac78aa36d7cc143", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -1,3 +1,9 @@\n+2016-06-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p9-extract-1.c: New file to test ISA 3.0\n+\tvector extract instructions.\n+\t* gcc.target/powerpc/p9-extract-2.c: Likewise.\n+\n 2016-06-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/71686"}, {"sha": "1aefc8f3bf1492f72d4e3482480ab3c0e31c7514", "filename": "gcc/testsuite/gcc.target/powerpc/p9-extract-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-1.c?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+int extract_int_0 (vector int a) { return vec_extract (a, 0); }\n+int extract_int_3 (vector int a) { return vec_extract (a, 3); }\n+\n+int extract_short_0 (vector short a) { return vec_extract (a, 0); }\n+int extract_short_3 (vector short a) { return vec_extract (a, 7); }\n+\n+int extract_schar_0 (vector signed char a) { return vec_extract (a, 0); }\n+int extract_schar_3 (vector signed char a) { return vec_extract (a, 15); }\n+\n+/* { dg-final { scan-assembler     \"vextractub\"  } } */\n+/* { dg-final { scan-assembler     \"vextractuh\"  } } */\n+/* { dg-final { scan-assembler     \"xxextractuw\" } } */\n+/* { dg-final { scan-assembler     \"mfvsrd\"      } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\"     } } */\n+/* { dg-final { scan-assembler-not \"stxv\"        } } */\n+/* { dg-final { scan-assembler-not \"lwa\"         } } */\n+/* { dg-final { scan-assembler-not \"lwz\"         } } */\n+/* { dg-final { scan-assembler-not \"lha\"         } } */\n+/* { dg-final { scan-assembler-not \"lhz\"         } } */"}, {"sha": "34f9bdd142eae480379522e94687ecadd17a55f8", "filename": "gcc/testsuite/gcc.target/powerpc/p9-extract-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e74d9d4ebeb29fab731464c206296ec651e9a6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-extract-2.c?ref=c5e74d9d4ebeb29fab731464c206296ec651e9a6", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+#include <altivec.h>\n+\n+void extract_int_0 (int *p, vector int a) { *p = vec_extract (a, 0); }\n+void extract_int_3 (int *p, vector int a) { *p = vec_extract (a, 3); }\n+\n+void extract_short_0 (short *p, vector short a) { *p = vec_extract (a, 0); }\n+void extract_short_3 (short *p, vector short a) { *p = vec_extract (a, 7); }\n+\n+void extract_schar_0 (signed char *p, vector signed char a) { *p = vec_extract (a, 0); }\n+void extract_schar_3 (signed char *p, vector signed char a) { *p = vec_extract (a, 15); }\n+\n+/* { dg-final { scan-assembler     \"vextractub\"      } } */\n+/* { dg-final { scan-assembler     \"vextractuh\"      } } */\n+/* { dg-final { scan-assembler     \"xxextractuw\"     } } */\n+/* { dg-final { scan-assembler     \"stxsibx\"         } } */\n+/* { dg-final { scan-assembler     \"stxsihx\"         } } */\n+/* { dg-final { scan-assembler     \"stfiwx\\|stxsiwx\" } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd\"          } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\"         } } */\n+/* { dg-final { scan-assembler-not \"stxv\"            } } */\n+/* { dg-final { scan-assembler-not \"lwa\"             } } */\n+/* { dg-final { scan-assembler-not \"stw\"             } } */"}]}