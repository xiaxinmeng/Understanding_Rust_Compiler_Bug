{"sha": "17f52a1c725948befcc3dd3c90d1abad77b6f6fe", "node_id": "C_kwDOANBUbNoAKDE3ZjUyYTFjNzI1OTQ4YmVmY2MzZGQzYzkwZDFhYmFkNzdiNmY2ZmU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-09T08:14:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-09T08:14:42Z"}, "message": "openmp: Add support for HBW or large capacity or interleaved memory through the libmemkind.so library\n\nThis patch adds support for dlopening libmemkind.so on Linux and uses it\nfor some kinds of allocations (but not yet e.g. pinned memory).\n\n2022-06-09  Jakub Jelinek  <jakub@redhat.com>\n\n\t* allocator.c: Include dlfcn.h if LIBGOMP_USE_MEMKIND is defined.\n\t(enum gomp_memkind_kind): New type.\n\t(struct omp_allocator_data): Add memkind field if LIBGOMP_USE_MEMKIND\n\tis defined.\n\t(struct gomp_memkind_data): New type.\n\t(memkind_data, memkind_data_once): New variables.\n\t(gomp_init_memkind, gomp_get_memkind): New functions.\n\t(omp_init_allocator): Initialize data.memkind, don't fail for\n\tomp_high_bw_mem_space if libmemkind supports it.\n\t(omp_aligned_alloc, omp_free, omp_aligned_calloc, omp_realloc): Add\n\tmemkind support of LIBGOMP_USE_MEMKIND is defined.\n\t* config/linux/allocator.c: New file.", "tree": {"sha": "4b63c1bca261493511c7e806b60f289edfd738c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b63c1bca261493511c7e806b60f289edfd738c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17f52a1c725948befcc3dd3c90d1abad77b6f6fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f52a1c725948befcc3dd3c90d1abad77b6f6fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f52a1c725948befcc3dd3c90d1abad77b6f6fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f52a1c725948befcc3dd3c90d1abad77b6f6fe/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "269edf4e5e6ab489730038f7e3495550623179fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269edf4e5e6ab489730038f7e3495550623179fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269edf4e5e6ab489730038f7e3495550623179fe"}], "stats": {"total": 401, "additions": 389, "deletions": 12}, "files": [{"sha": "c96d37891a4b8537801edb229521d171e6b9b16a", "filename": "libgomp/allocator.c", "status": "modified", "additions": 353, "deletions": 12, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f52a1c725948befcc3dd3c90d1abad77b6f6fe/libgomp%2Fallocator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f52a1c725948befcc3dd3c90d1abad77b6f6fe/libgomp%2Fallocator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fallocator.c?ref=17f52a1c725948befcc3dd3c90d1abad77b6f6fe", "patch": "@@ -31,9 +31,28 @@\n #include \"libgomp.h\"\n #include <stdlib.h>\n #include <string.h>\n+#ifdef LIBGOMP_USE_MEMKIND\n+#include <dlfcn.h>\n+#endif\n \n #define omp_max_predefined_alloc omp_thread_mem_alloc\n \n+enum gomp_memkind_kind\n+{\n+  GOMP_MEMKIND_NONE = 0,\n+#define GOMP_MEMKIND_KINDS \\\n+  GOMP_MEMKIND_KIND (HBW_INTERLEAVE),\t\t\\\n+  GOMP_MEMKIND_KIND (HBW_PREFERRED),\t\t\\\n+  GOMP_MEMKIND_KIND (DAX_KMEM_ALL),\t\t\\\n+  GOMP_MEMKIND_KIND (DAX_KMEM),\t\t\t\\\n+  GOMP_MEMKIND_KIND (INTERLEAVE),\t\t\\\n+  GOMP_MEMKIND_KIND (DEFAULT)\n+#define GOMP_MEMKIND_KIND(kind) GOMP_MEMKIND_##kind\n+  GOMP_MEMKIND_KINDS,\n+#undef GOMP_MEMKIND_KIND\n+  GOMP_MEMKIND_COUNT\n+};\n+\n struct omp_allocator_data\n {\n   omp_memspace_handle_t memspace;\n@@ -46,6 +65,9 @@ struct omp_allocator_data\n   unsigned int fallback : 8;\n   unsigned int pinned : 1;\n   unsigned int partition : 7;\n+#ifdef LIBGOMP_USE_MEMKIND\n+  unsigned int memkind : 8;\n+#endif\n #ifndef HAVE_SYNC_BUILTINS\n   gomp_mutex_t lock;\n #endif\n@@ -59,13 +81,95 @@ struct omp_mem_header\n   void *pad;\n };\n \n+struct gomp_memkind_data\n+{\n+  void *memkind_handle;\n+  void *(*memkind_malloc) (void *, size_t);\n+  void *(*memkind_calloc) (void *, size_t, size_t);\n+  void *(*memkind_realloc) (void *, void *, size_t);\n+  void (*memkind_free) (void *, void *);\n+  int (*memkind_check_available) (void *);\n+  void **kinds[GOMP_MEMKIND_COUNT];\n+};\n+\n+#ifdef LIBGOMP_USE_MEMKIND\n+static struct gomp_memkind_data *memkind_data;\n+static pthread_once_t memkind_data_once = PTHREAD_ONCE_INIT;\n+\n+static void\n+gomp_init_memkind (void)\n+{\n+  void *handle = dlopen (\"libmemkind.so\", RTLD_LAZY);\n+  struct gomp_memkind_data *data;\n+  int i;\n+  static const char *kinds[] = {\n+    NULL,\n+#define GOMP_MEMKIND_KIND(kind) \"MEMKIND_\" #kind\n+    GOMP_MEMKIND_KINDS\n+#undef GOMP_MEMKIND_KIND\n+  };\n+\n+  data = calloc (1, sizeof (struct gomp_memkind_data));\n+  if (data == NULL)\n+    {\n+      if (handle)\n+\tdlclose (handle);\n+      return;\n+    }\n+  if (!handle)\n+    {\n+      __atomic_store_n (&memkind_data, data, MEMMODEL_RELEASE);\n+      return;\n+    }\n+  data->memkind_handle = handle;\n+  data->memkind_malloc\n+    = (__typeof (data->memkind_malloc)) dlsym (handle, \"memkind_malloc\");\n+  data->memkind_calloc\n+    = (__typeof (data->memkind_calloc)) dlsym (handle, \"memkind_calloc\");\n+  data->memkind_realloc\n+    = (__typeof (data->memkind_realloc)) dlsym (handle, \"memkind_realloc\");\n+  data->memkind_free\n+    = (__typeof (data->memkind_free)) dlsym (handle, \"memkind_free\");\n+  data->memkind_check_available\n+    = (__typeof (data->memkind_check_available))\n+      dlsym (handle, \"memkind_check_available\");\n+  if (data->memkind_malloc\n+      && data->memkind_calloc\n+      && data->memkind_realloc\n+      && data->memkind_free\n+      && data->memkind_check_available)\n+    for (i = 1; i < GOMP_MEMKIND_COUNT; ++i)\n+      {\n+\tdata->kinds[i] = (void **) dlsym (handle, kinds[i]);\n+\tif (data->kinds[i] && data->memkind_check_available (*data->kinds[i]))\n+\t  data->kinds[i] = NULL;\n+      }\n+  __atomic_store_n (&memkind_data, data, MEMMODEL_RELEASE);\n+}\n+\n+static struct gomp_memkind_data *\n+gomp_get_memkind (void)\n+{\n+  struct gomp_memkind_data *data\n+    = __atomic_load_n (&memkind_data, MEMMODEL_ACQUIRE);\n+  if (data)\n+    return data;\n+  pthread_once (&memkind_data_once, gomp_init_memkind);\n+  return __atomic_load_n (&memkind_data, MEMMODEL_ACQUIRE);\n+}\n+#endif\n+\n omp_allocator_handle_t\n omp_init_allocator (omp_memspace_handle_t memspace, int ntraits,\n \t\t    const omp_alloctrait_t traits[])\n {\n   struct omp_allocator_data data\n     = { memspace, 1, ~(uintptr_t) 0, 0, 0, omp_atv_contended, omp_atv_all,\n-\tomp_atv_default_mem_fb, omp_atv_false, omp_atv_environment };\n+\tomp_atv_default_mem_fb, omp_atv_false, omp_atv_environment,\n+#ifdef LIBGOMP_USE_MEMKIND\n+\tGOMP_MEMKIND_NONE\n+#endif\n+      };\n   struct omp_allocator_data *ret;\n   int i;\n \n@@ -179,8 +283,48 @@ omp_init_allocator (omp_memspace_handle_t memspace, int ntraits,\n   if (data.alignment < sizeof (void *))\n     data.alignment = sizeof (void *);\n \n-  /* No support for these so far (for hbw will use memkind).  */\n-  if (data.pinned || data.memspace == omp_high_bw_mem_space)\n+  switch (memspace)\n+    {\n+    case omp_high_bw_mem_space:\n+#ifdef LIBGOMP_USE_MEMKIND\n+      struct gomp_memkind_data *memkind_data;\n+      memkind_data = gomp_get_memkind ();\n+      if (data.partition == omp_atv_interleaved\n+\t  && memkind_data->kinds[GOMP_MEMKIND_HBW_INTERLEAVE])\n+\t{\n+\t  data.memkind = GOMP_MEMKIND_HBW_INTERLEAVE;\n+\t  break;\n+\t}\n+      else if (memkind_data->kinds[GOMP_MEMKIND_HBW_PREFERRED])\n+\t{\n+\t  data.memkind = GOMP_MEMKIND_HBW_PREFERRED;\n+\t  break;\n+\t}\n+#endif\n+      return omp_null_allocator;\n+    case omp_large_cap_mem_space:\n+#ifdef LIBGOMP_USE_MEMKIND\n+      memkind_data = gomp_get_memkind ();\n+      if (memkind_data->kinds[GOMP_MEMKIND_DAX_KMEM_ALL])\n+\tdata.memkind = GOMP_MEMKIND_DAX_KMEM_ALL;\n+      else if (memkind_data->kinds[GOMP_MEMKIND_DAX_KMEM])\n+\tdata.memkind = GOMP_MEMKIND_DAX_KMEM;\n+#endif\n+      break;\n+    default:\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (data.partition == omp_atv_interleaved)\n+\t{\n+\t  memkind_data = gomp_get_memkind ();\n+\t  if (memkind_data->kinds[GOMP_MEMKIND_INTERLEAVE])\n+\t    data.memkind = GOMP_MEMKIND_INTERLEAVE;\n+\t}\n+#endif\n+      break;\n+    }\n+\n+  /* No support for this so far.  */\n+  if (data.pinned)\n     return omp_null_allocator;\n \n   ret = gomp_malloc (sizeof (struct omp_allocator_data));\n@@ -213,6 +357,9 @@ omp_aligned_alloc (size_t alignment, size_t size,\n   struct omp_allocator_data *allocator_data;\n   size_t new_size, new_alignment;\n   void *ptr, *ret;\n+#ifdef LIBGOMP_USE_MEMKIND\n+  enum gomp_memkind_kind memkind;\n+#endif\n \n   if (__builtin_expect (size == 0, 0))\n     return NULL;\n@@ -232,12 +379,28 @@ omp_aligned_alloc (size_t alignment, size_t size,\n       allocator_data = (struct omp_allocator_data *) allocator;\n       if (new_alignment < allocator_data->alignment)\n \tnew_alignment = allocator_data->alignment;\n+#ifdef LIBGOMP_USE_MEMKIND\n+      memkind = allocator_data->memkind;\n+#endif\n     }\n   else\n     {\n       allocator_data = NULL;\n       if (new_alignment < sizeof (void *))\n \tnew_alignment = sizeof (void *);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      memkind = GOMP_MEMKIND_NONE;\n+      if (allocator == omp_high_bw_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_HBW_PREFERRED;\n+      else if (allocator == omp_large_cap_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_DAX_KMEM_ALL;\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  if (!memkind_data->kinds[memkind])\n+\t    memkind = GOMP_MEMKIND_NONE;\n+\t}\n+#endif\n     }\n \n   new_size = sizeof (struct omp_mem_header);\n@@ -281,7 +444,16 @@ omp_aligned_alloc (size_t alignment, size_t size,\n       allocator_data->used_pool_size = used_pool_size;\n       gomp_mutex_unlock (&allocator_data->lock);\n #endif\n-      ptr = malloc (new_size);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[memkind];\n+\t  ptr = memkind_data->memkind_malloc (kind, new_size);\n+\t}\n+      else\n+#endif\n+\tptr = malloc (new_size);\n       if (ptr == NULL)\n \t{\n #ifdef HAVE_SYNC_BUILTINS\n@@ -297,7 +469,16 @@ omp_aligned_alloc (size_t alignment, size_t size,\n     }\n   else\n     {\n-      ptr = malloc (new_size);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[memkind];\n+\t  ptr = memkind_data->memkind_malloc (kind, new_size);\n+\t}\n+      else\n+#endif\n+\tptr = malloc (new_size);\n       if (ptr == NULL)\n \tgoto fail;\n     }\n@@ -321,6 +502,9 @@ omp_aligned_alloc (size_t alignment, size_t size,\n \t{\n \tcase omp_atv_default_mem_fb:\n \t  if ((new_alignment > sizeof (void *) && new_alignment > alignment)\n+#ifdef LIBGOMP_USE_MEMKIND\n+\t      || memkind\n+#endif\n \t      || (allocator_data\n \t\t  && allocator_data->pool_size < ~(uintptr_t) 0))\n \t    {\n@@ -393,7 +577,36 @@ omp_free (void *ptr, omp_allocator_handle_t allocator)\n \t  gomp_mutex_unlock (&allocator_data->lock);\n #endif\n \t}\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (allocator_data->memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[allocator_data->memkind];\n+\t  memkind_data->memkind_free (kind, data->ptr);\n+\t  return;\n+\t}\n+#endif\n     }\n+#ifdef LIBGOMP_USE_MEMKIND\n+  else\n+    {\n+      enum gomp_memkind_kind memkind = GOMP_MEMKIND_NONE;\n+      if (data->allocator == omp_high_bw_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_HBW_PREFERRED;\n+      else if (data->allocator == omp_large_cap_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_DAX_KMEM_ALL;\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  if (memkind_data->kinds[memkind])\n+\t    {\n+\t      void *kind = *memkind_data->kinds[memkind];\n+\t      memkind_data->memkind_free (kind, data->ptr);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+#endif\n   free (data->ptr);\n }\n \n@@ -412,6 +625,9 @@ omp_aligned_calloc (size_t alignment, size_t nmemb, size_t size,\n   struct omp_allocator_data *allocator_data;\n   size_t new_size, size_temp, new_alignment;\n   void *ptr, *ret;\n+#ifdef LIBGOMP_USE_MEMKIND\n+  enum gomp_memkind_kind memkind;\n+#endif\n \n   if (__builtin_expect (size == 0 || nmemb == 0, 0))\n     return NULL;\n@@ -431,12 +647,28 @@ omp_aligned_calloc (size_t alignment, size_t nmemb, size_t size,\n       allocator_data = (struct omp_allocator_data *) allocator;\n       if (new_alignment < allocator_data->alignment)\n \tnew_alignment = allocator_data->alignment;\n+#ifdef LIBGOMP_USE_MEMKIND\n+      memkind = allocator_data->memkind;\n+#endif\n     }\n   else\n     {\n       allocator_data = NULL;\n       if (new_alignment < sizeof (void *))\n \tnew_alignment = sizeof (void *);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      memkind = GOMP_MEMKIND_NONE;\n+      if (allocator == omp_high_bw_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_HBW_PREFERRED;\n+      else if (allocator == omp_large_cap_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_DAX_KMEM_ALL;\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  if (!memkind_data->kinds[memkind])\n+\t    memkind = GOMP_MEMKIND_NONE;\n+\t}\n+#endif\n     }\n \n   new_size = sizeof (struct omp_mem_header);\n@@ -482,7 +714,16 @@ omp_aligned_calloc (size_t alignment, size_t nmemb, size_t size,\n       allocator_data->used_pool_size = used_pool_size;\n       gomp_mutex_unlock (&allocator_data->lock);\n #endif\n-      ptr = calloc (1, new_size);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[memkind];\n+\t  ptr = memkind_data->memkind_calloc (kind, 1, new_size);\n+\t}\n+      else\n+#endif\n+\tptr = calloc (1, new_size);\n       if (ptr == NULL)\n \t{\n #ifdef HAVE_SYNC_BUILTINS\n@@ -498,7 +739,16 @@ omp_aligned_calloc (size_t alignment, size_t nmemb, size_t size,\n     }\n   else\n     {\n-      ptr = calloc (1, new_size);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[memkind];\n+\t  ptr = memkind_data->memkind_calloc (kind, 1, new_size);\n+\t}\n+      else\n+#endif\n+\tptr = calloc (1, new_size);\n       if (ptr == NULL)\n \tgoto fail;\n     }\n@@ -522,6 +772,9 @@ omp_aligned_calloc (size_t alignment, size_t nmemb, size_t size,\n \t{\n \tcase omp_atv_default_mem_fb:\n \t  if ((new_alignment > sizeof (void *) && new_alignment > alignment)\n+#ifdef LIBGOMP_USE_MEMKIND\n+\t      || memkind\n+#endif\n \t      || (allocator_data\n \t\t  && allocator_data->pool_size < ~(uintptr_t) 0))\n \t    {\n@@ -562,6 +815,9 @@ omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n   size_t new_size, old_size, new_alignment, old_alignment;\n   void *new_ptr, *ret;\n   struct omp_mem_header *data;\n+#ifdef LIBGOMP_USE_MEMKIND\n+  enum gomp_memkind_kind memkind, free_memkind;\n+#endif\n \n   if (__builtin_expect (ptr == NULL, 0))\n     return ialias_call (omp_aligned_alloc) (1, size, allocator);\n@@ -585,13 +841,51 @@ omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n       allocator_data = (struct omp_allocator_data *) allocator;\n       if (new_alignment < allocator_data->alignment)\n \tnew_alignment = allocator_data->alignment;\n+#ifdef LIBGOMP_USE_MEMKIND\n+      memkind = allocator_data->memkind;\n+#endif\n     }\n   else\n-    allocator_data = NULL;\n+    {\n+      allocator_data = NULL;\n+#ifdef LIBGOMP_USE_MEMKIND\n+      memkind = GOMP_MEMKIND_NONE;\n+      if (allocator == omp_high_bw_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_HBW_PREFERRED;\n+      else if (allocator == omp_large_cap_mem_alloc)\n+\tmemkind = GOMP_MEMKIND_DAX_KMEM_ALL;\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  if (!memkind_data->kinds[memkind])\n+\t    memkind = GOMP_MEMKIND_NONE;\n+\t}\n+#endif\n+    }\n   if (free_allocator > omp_max_predefined_alloc)\n-    free_allocator_data = (struct omp_allocator_data *) free_allocator;\n+    {\n+      free_allocator_data = (struct omp_allocator_data *) free_allocator;\n+#ifdef LIBGOMP_USE_MEMKIND\n+      free_memkind = free_allocator_data->memkind;\n+#endif\n+    }\n   else\n-    free_allocator_data = NULL;\n+    {\n+      free_allocator_data = NULL;\n+#ifdef LIBGOMP_USE_MEMKIND\n+      free_memkind = GOMP_MEMKIND_NONE;\n+      if (free_allocator == omp_high_bw_mem_alloc)\n+\tfree_memkind = GOMP_MEMKIND_HBW_PREFERRED;\n+      else if (free_allocator == omp_large_cap_mem_alloc)\n+\tfree_memkind = GOMP_MEMKIND_DAX_KMEM_ALL;\n+      if (free_memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  if (!memkind_data->kinds[free_memkind])\n+\t    free_memkind = GOMP_MEMKIND_NONE;\n+\t}\n+#endif\n+    }\n   old_alignment = (uintptr_t) ptr - (uintptr_t) (data->ptr);\n \n   new_size = sizeof (struct omp_mem_header);\n@@ -658,6 +952,19 @@ omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n \t\t\t  + new_size - prev_size);\n       allocator_data->used_pool_size = used_pool_size;\n       gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[memkind];\n+\t  if (prev_size)\n+\t    new_ptr = memkind_data->memkind_realloc (kind, data->ptr,\n+\t\t\t\t\t\t     new_size);\n+\t  else\n+\t    new_ptr = memkind_data->memkind_malloc (kind, new_size);\n+\t}\n+      else\n #endif\n       if (prev_size)\n \tnew_ptr = realloc (data->ptr, new_size);\n@@ -687,10 +994,23 @@ omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n     }\n   else if (new_alignment == sizeof (void *)\n \t   && old_alignment == sizeof (struct omp_mem_header)\n+#ifdef LIBGOMP_USE_MEMKIND\n+\t   && memkind == free_memkind\n+#endif\n \t   && (free_allocator_data == NULL\n \t       || free_allocator_data->pool_size == ~(uintptr_t) 0))\n     {\n-      new_ptr = realloc (data->ptr, new_size);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[memkind];\n+\t  new_ptr = memkind_data->memkind_realloc (kind, data->ptr,\n+\t\t\t\t\t\t   new_size);\n+\t}\n+      else\n+#endif\n+\tnew_ptr = realloc (data->ptr, new_size);\n       if (new_ptr == NULL)\n \tgoto fail;\n       ret = (char *) new_ptr + sizeof (struct omp_mem_header);\n@@ -701,7 +1021,16 @@ omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n     }\n   else\n     {\n-      new_ptr = malloc (new_size);\n+#ifdef LIBGOMP_USE_MEMKIND\n+      if (memkind)\n+\t{\n+\t  struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+\t  void *kind = *memkind_data->kinds[memkind];\n+\t  new_ptr = memkind_data->memkind_malloc (kind, new_size);\n+\t}\n+      else\n+#endif\n+\tnew_ptr = malloc (new_size);\n       if (new_ptr == NULL)\n \tgoto fail;\n     }\n@@ -731,6 +1060,15 @@ omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n       gomp_mutex_unlock (&free_allocator_data->lock);\n #endif\n     }\n+#ifdef LIBGOMP_USE_MEMKIND\n+  if (free_memkind)\n+    {\n+      struct gomp_memkind_data *memkind_data = gomp_get_memkind ();\n+      void *kind = *memkind_data->kinds[free_memkind];\n+      memkind_data->memkind_free (kind, data->ptr);\n+      return ret;\n+    }\n+#endif\n   free (data->ptr);\n   return ret;\n \n@@ -741,6 +1079,9 @@ omp_realloc (void *ptr, size_t size, omp_allocator_handle_t allocator,\n \t{\n \tcase omp_atv_default_mem_fb:\n \t  if (new_alignment > sizeof (void *)\n+#ifdef LIBGOMP_USE_MEMKIND\n+\t      || memkind\n+#endif\n \t      || (allocator_data\n \t\t  && allocator_data->pool_size < ~(uintptr_t) 0))\n \t    {"}, {"sha": "bef4e48e7491922673ef01efea07d619ce6045de", "filename": "libgomp/config/linux/allocator.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f52a1c725948befcc3dd3c90d1abad77b6f6fe/libgomp%2Fconfig%2Flinux%2Fallocator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f52a1c725948befcc3dd3c90d1abad77b6f6fe/libgomp%2Fconfig%2Flinux%2Fallocator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fallocator.c?ref=17f52a1c725948befcc3dd3c90d1abad77b6f6fe", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains wrappers for the system allocation routines.  Most\n+   places in the OpenMP API do not make any provision for failure, so in\n+   general we cannot allow memory allocation to fail.  */\n+\n+#define _GNU_SOURCE\n+#include \"libgomp.h\"\n+#if defined(PLUGIN_SUPPORT) && defined(LIBGOMP_USE_PTHREADS)\n+#define LIBGOMP_USE_MEMKIND\n+#endif\n+\n+#include \"../../../allocator.c\""}]}