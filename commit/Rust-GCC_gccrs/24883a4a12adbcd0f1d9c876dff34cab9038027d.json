{"sha": "24883a4a12adbcd0f1d9c876dff34cab9038027d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ4ODNhNGExMmFkYmNkMGYxZDljODc2ZGZmMzRjYWI5MDM4MDI3ZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-08T23:31:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-08T23:31:28Z"}, "message": "i386.md (ashlsi3): Revise comments.\n\n        * i386.md (ashlsi3): Revise comments.  Provide new anonymous\n        pattern for Pentium and PPro/PII.  Reverse constraints in\n        generic ashlsi3 anonymous pattern.\n\nFrom-SVN: r25647", "tree": {"sha": "cf4a1c0a7218aec84c78e108d55f0d7ca026c5bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf4a1c0a7218aec84c78e108d55f0d7ca026c5bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24883a4a12adbcd0f1d9c876dff34cab9038027d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24883a4a12adbcd0f1d9c876dff34cab9038027d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24883a4a12adbcd0f1d9c876dff34cab9038027d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24883a4a12adbcd0f1d9c876dff34cab9038027d/comments", "author": null, "committer": null, "parents": [{"sha": "959f3a066790b1fdf98dd1b93214929a45706c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/959f3a066790b1fdf98dd1b93214929a45706c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/959f3a066790b1fdf98dd1b93214929a45706c99"}], "stats": {"total": 170, "additions": 152, "deletions": 18}, "files": [{"sha": "e61d29362ba0362601326eb0f81d56de164324e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24883a4a12adbcd0f1d9c876dff34cab9038027d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24883a4a12adbcd0f1d9c876dff34cab9038027d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24883a4a12adbcd0f1d9c876dff34cab9038027d", "patch": "@@ -12,6 +12,10 @@ Mon Mar  8 16:04:44 1999  Jim Wilson  <wilson@cygnus.com>\n \n Mon Mar  8 15:27:42 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* i386.md (ashlsi3): Revise comments.  Provide new anonymous\n+\tpattern for Pentium and PPro/PII.  Reverse constraints in \n+\tgeneric ashlsi3 anonymous pattern.\n+\n \t* calls.c (initialize_argument_info): Accept a pointer to \n \tCUMULATIVE_ARGS.\n \t(expand_call): Pass the address of CUMULATIVE_ARGS."}, {"sha": "8ae917c1801b4ccb2d45901525286512b105fa14", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 148, "deletions": 18, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24883a4a12adbcd0f1d9c876dff34cab9038027d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24883a4a12adbcd0f1d9c876dff34cab9038027d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=24883a4a12adbcd0f1d9c876dff34cab9038027d", "patch": "@@ -4709,30 +4709,27 @@ byte_xor_operation:\n   RET;\n }\")\n \n-;; On i386 and i486, \"addl reg,reg\" is faster than \"sall $1,reg\"\n-;; On i486, movl/sall appears slightly faster than leal, but the leal\n-;; is smaller - use leal for now unless the shift count is 1.\n-\n (define_expand \"ashlsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-;; For register destinations:\n-;;   add == 2 bytes, move == 2 bytes, shift == 3 bytes, lea == 7 bytes\n+;; Optimizing for code size:\n+;;   For regsiter destinations:\n+;;     add == 2 bytes, move == 2 bytes, shift == 3 bytes, lea == 7 bytes\n ;;\n-;;   lea loses when optimizing for size\n+;;     lea loses when optimizing for size\n ;;\n-;; Do the math.  If the count is 1, using add, else using sal will\n-;; produce the smallest possible code, even when the source and\n-;; dest do not match.  For a memory destination, sal is the only\n-;; choice.\n+;;   Do the math.  If the count is 1, using add, else using sal will\n+;;   produce the smallest possible code, even when the source and\n+;;   dest do not match.  For a memory destination, sal is the only\n+;;   choice.\n ;;\n-;; Do not try to handle case where src and dest do not match.  Let regmove\n-;; and reload handle them.  A mov followed by this insn will generate the\n-;; desired size optimized results.\n+;;   Do not try to handle case where src and dest do not match.  Let regmove\n+;;   and reload handle them.  A mov followed by this insn will generate the\n+;;   desired size optimized results.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n@@ -4748,11 +4745,144 @@ byte_xor_operation:\n   return AS2 (sal%L0,%2,%0);\n }\")\n \n+;; For Pentium/Pentium MMX:\n+;;\n+;;   We want to optimize for pairability, but avoid generating AGI stalls.\n+;;\n+;;   If this insn is expected to issue in the U pipe, then prefer sal,\n+;;   else prefer lea for small shifts when srcreg == dstreg.\n+;;\n+;; For PPro/PII\n+;;\n+;;   There's more than one approach to optimizing for this family; it is\n+;;   unclear which approach is best.  For now, we will try to minimize\n+;;   uops.  Note that sal and lea have the same characteristics, so we\n+;;   prefer sal as it takes less space.\n+;;\n+;; We can actually share code for these two cases since the basic techniques\n+;; for generating good code on these chips is the same, even if the final\n+;; code sequences are different.\n+;;\n+;; I do not know what is most appropriate for the AMD or Cyrix chips.\n+;;\n+;;   srcreg == dstreg, constant shift count:\n+;;\n+;;     For a shift count of one, use \"add\".\n+;;     For a shift count of two or three, use \"sal\"/\"lea\" for Pentium and\n+;;     Pentium MMX depending on which pipe the insn will execute.\n+;;     All others use \"sar\".\n+;;\n+;;   srcreg != dstreg, constant shift count:\n+;;\n+;;     For shift counts of one to three, use \"lea\".\n+;;     All others use \"lea\" for the first shift into the destination reg,\n+;;     then fall back on the srcreg == dstreg for the residual shifts.\n+;;\n+;;   memory destinations or nonconstant shift count:\n+;;\n+;;     Use \"sal\".\n+;;\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"r,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"M,cI\")))]\n-  \"! optimize_size\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,r\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI,I\")))]\n+  \"! optimize_size\n+   && ((int)ix86_cpu == (int)PROCESSOR_PENTIUM\n+       || (int)ix86_cpu == (int)PROCESSOR_PENTIUMPRO)\"\n+  \"*\n+{\n+  /* This should be extremely rare (impossible?).  We can not encode a shift\n+     of the stack pointer using an lea instruction.  So copy the stack pointer\n+     into the destination register and fall into the srcreg == dstreg shifting\n+     support.  */\n+  if (operands[1] == stack_pointer_rtx)\n+    {\n+      output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n+      operands[1] = operands[0];\n+    }\n+\n+  /* Handle case where srcreg != dstreg.  */\n+  if (REG_P (operands[0]) && REGNO (operands[0]) != REGNO (operands[1]))\n+    {\n+      /* For counts > 3, it is easiest to split into component insns.  */\n+      if (INTVAL (operands[2]) > 3)\n+\treturn \\\"#\\\";\n+    \n+      /* For shifts up to and including 3 bits, use lea.  */\n+      operands[1] = gen_rtx_MULT (SImode, operands[1],\n+\t\t\t\t  GEN_INT (1 << INTVAL (operands[2])));\n+      return AS2 (lea%L0,%a1,%0);\n+    }\n+\n+  /* Source and destination match.  */\n+\n+  /* Handle variable shift.  */\n+  if (REG_P (operands[2]))\n+    return AS2 (sal%L0,%b2,%0);\n+\n+  /* Always perform shift by 1 using an add instruction.  */\n+  if (REG_P (operands[0]) && operands[2] == const1_rtx)\n+    return AS2 (add%L0,%0,%0);\n+\n+#if 0\n+  /* ??? Currently disabled.  reg-stack currently stomps on the mode of\n+     each insn.  Thus, we can not easily detect when we should use lea to\n+     improve issue characteristics.  Until reg-stack is fixed, fall back to\n+     sal instruction for Pentiums to avoid AGI stall.  */\n+  /* Shift reg by 2 or 3 use an lea instruction for Pentium if this is\n+     insn is expected to issue into the V pipe (the insn's mode will be\n+     TImode for a U pipe, and !TImode for a V pipe instruction).  */\n+  if (REG_P (operands[0])\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) <= 3\n+      && (int)ix86_cpu == (int)PROCESSOR_PENTIUM\n+      && GET_MODE (insn) != TImode)\n+    {\n+      operands[1] = gen_rtx_MULT (SImode, operands[1],\n+\t\t\t\t  GEN_INT (1 << INTVAL (operands[2])));\n+      return AS2 (lea%L0,%a1,%0);\n+    }\n+#endif\n+\n+  /* Otherwise use a shift instruction.  */\n+  return AS2 (sal%L0,%2,%0);\n+}\")\n+\n+;; Pentium/PPro/PII Splitter used when srcreg != destreg and shift\n+;; count is > 3.  In each case we use lea to perform the first three\n+;; shifts into the destination register, then we fall back to the\n+;; normal shifting code for the residual shifts.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"reload_completed\n+   && ! optimize_size\n+   && ((int)ix86_cpu == (int)PROCESSOR_PENTIUM\n+       || (int)ix86_cpu == (int)PROCESSOR_PENTIUMPRO)\n+   && GET_CODE (operands[2]) == CONST_INT\n+   && INTVAL (operands[2]) > 3\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+  operands[3] = GEN_INT (INTVAL (operands[2] - 3));\n+  operands[2] = GEN_INT (3);\n+}\")\n+\n+\n+;; On i386 and i486, \"addl reg,reg\" is faster than \"sall $1,reg\"\n+;; On i486, movl/sall appears slightly faster than leal, but the leal\n+;; is smaller - use leal for now unless the shift count is 1.\n+;;\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,r\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI,M\")))]\n+  \"! optimize_size\n+   && ! ((int)ix86_cpu == (int)PROCESSOR_PENTIUM\n+         || (int)ix86_cpu == (int)PROCESSOR_PENTIUMPRO)\"\n   \"*\n {\n   if (REG_P (operands[0]) && REGNO (operands[0]) != REGNO (operands[1]))"}]}