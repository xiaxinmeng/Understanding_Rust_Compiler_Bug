{"sha": "6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIxNTBjZTk1ZDJiOTg3YzMzYmJjM2U2ZThiYzU5M2YxYjJmNjM2Yg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-07-01T10:54:45Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-07-01T10:54:45Z"}, "message": "Allow jump threading of multiple paths that start from the same BB.\n\nFrom-SVN: r262283", "tree": {"sha": "a953c487c64197152c4cdd4df0cb37651efa6065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a953c487c64197152c4cdd4df0cb37651efa6065"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19792aa02317320c8eff1a86a8bc8da54f17ec3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19792aa02317320c8eff1a86a8bc8da54f17ec3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19792aa02317320c8eff1a86a8bc8da54f17ec3c"}], "stats": {"total": 200, "additions": 195, "deletions": 5}, "files": [{"sha": "49febc1b22a77986adb95fee2bd74798dc0dc11a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b", "patch": "@@ -1,3 +1,16 @@\n+2018-07-01  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Avoid\n+\tdereferencing path[] beyond its length.\n+\t(debug_path): New.\n+\t(debug_all_paths): New.\n+\t(rewire_first_differing_edge): New.\n+\t(adjust_paths_after_duplication): New.\n+\t(duplicate_thread_path): Call adjust_paths_after_duplication.\n+\tAdd new argument.\n+\t(thread_through_all_blocks): Add new argument to\n+\tduplicate_thread_path.\n+\n 2018-06-30  Jim Wilson  <jimw@sifive.com>\n \n \t* config/riscv/predicates.md (p2m1_shift_operand): New."}, {"sha": "17f9b89d6a79df4ef3e22ebcfcc8118b852ef59e", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 182, "deletions": 5, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=6b150ce95d2b987c33bbc3e6e8bc593f1b2f636b", "patch": "@@ -1805,7 +1805,8 @@ mark_threaded_blocks (bitmap threaded_blocks)\n     {\n       vec<jump_thread_edge *> *path = paths[i];\n \n-      if ((*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)\n+      if (path->length () > 1\n+\t  && (*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)\n \t{\n \t  edge e = (*path)[0]->e;\n \t  e->aux = (void *)path;\n@@ -1825,7 +1826,8 @@ mark_threaded_blocks (bitmap threaded_blocks)\n     {\n       vec<jump_thread_edge *> *path = paths[i];\n \n-      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+      if (path->length () > 1\n+\t  && (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n \t{\n \t  /* Attach the path to the starting edge if none is yet recorded.  */\n \t  if ((*path)[0]->e->aux == NULL)\n@@ -1854,7 +1856,8 @@ mark_threaded_blocks (bitmap threaded_blocks)\n       vec<jump_thread_edge *> *path = paths[i];\n       edge e = (*path)[0]->e;\n \n-      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK && e->aux == path)\n+      if (path->length () > 1\n+\t  && (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK && e->aux == path)\n \t{\n \t  unsigned int j;\n \t  for (j = 1; j < path->length (); j++)\n@@ -2043,18 +2046,184 @@ bb_in_bbs (basic_block bb, basic_block *bbs, int n)\n   return false;\n }\n \n+DEBUG_FUNCTION void\n+debug_path (FILE *dump_file, int pathno)\n+{\n+  vec<jump_thread_edge *> *p = paths[pathno];\n+  fprintf (dump_file, \"path: \");\n+  for (unsigned i = 0; i < p->length (); ++i)\n+    fprintf (dump_file, \"%d -> %d, \",\n+\t     (*p)[i]->e->src->index, (*p)[i]->e->dest->index);\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+DEBUG_FUNCTION void\n+debug_all_paths ()\n+{\n+  for (unsigned i = 0; i < paths.length (); ++i)\n+    debug_path (stderr, i);\n+}\n+\n+/* Rewire a jump_thread_edge so that the source block is now a\n+   threaded source block.\n+\n+   PATH_NUM is an index into the global path table PATHS.\n+   EDGE_NUM is the jump thread edge number into said path.\n+\n+   Returns TRUE if we were able to successfully rewire the edge.  */\n+\n+static bool\n+rewire_first_differing_edge (unsigned path_num, unsigned edge_num)\n+{\n+  vec<jump_thread_edge *> *path = paths[path_num];\n+  edge &e = (*path)[edge_num]->e;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"rewiring edge candidate: %d -> %d\\n\",\n+\t     e->src->index, e->dest->index);\n+  basic_block src_copy = get_bb_copy (e->src);\n+  if (src_copy == NULL)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"ignoring candidate: there is no src COPY\\n\");\n+      return false;\n+    }\n+  edge new_edge = find_edge (src_copy, e->dest);\n+  /* If the previously threaded paths created a flow graph where we\n+     can no longer figure out where to go, give up.  */\n+  if (new_edge == NULL)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"ignoring candidate: we lost our way\\n\");\n+      return false;\n+    }\n+  e = new_edge;\n+  return true;\n+}\n+\n+/* After an FSM path has been jump threaded, adjust the remaining FSM\n+   paths that are subsets of this path, so these paths can be safely\n+   threaded within the context of the new threaded path.\n+\n+   For example, suppose we have just threaded:\n+\n+   5 -> 6 -> 7 -> 8 -> 12\t=>\t5 -> 6' -> 7' -> 8' -> 12'\n+\n+   And we have an upcoming threading candidate:\n+   5 -> 6 -> 7 -> 8 -> 15 -> 20\n+\n+   This function adjusts the upcoming path into:\n+   8' -> 15 -> 20\n+\n+   CURR_PATH_NUM is an index into the global paths table.  It\n+   specifies the path that was just threaded.  */\n+\n+static void\n+adjust_paths_after_duplication (unsigned curr_path_num)\n+{\n+  vec<jump_thread_edge *> *curr_path = paths[curr_path_num];\n+  gcc_assert ((*curr_path)[0]->type == EDGE_FSM_THREAD);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"just threaded: \");\n+      debug_path (dump_file, curr_path_num);\n+    }\n+\n+  /* Iterate through all the other paths and adjust them.  */\n+  for (unsigned cand_path_num = 0; cand_path_num < paths.length (); )\n+    {\n+      if (cand_path_num == curr_path_num)\n+\t{\n+\t  ++cand_path_num;\n+\t  continue;\n+\t}\n+      /* Make sure the candidate to adjust starts with the same path\n+\t as the recently threaded path and is an FSM thread.  */\n+      vec<jump_thread_edge *> *cand_path = paths[cand_path_num];\n+      if ((*cand_path)[0]->type != EDGE_FSM_THREAD\n+\t  || (*cand_path)[0]->e != (*curr_path)[0]->e)\n+\t{\n+\t  ++cand_path_num;\n+\t  continue;\n+\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"adjusting candidate: \");\n+\t  debug_path (dump_file, cand_path_num);\n+\t}\n+\n+      /* Chop off from the candidate path any prefix it shares with\n+\t the recently threaded path.  */\n+      unsigned minlength = MIN (curr_path->length (), cand_path->length ());\n+      unsigned j;\n+      for (j = 0; j < minlength; ++j)\n+\t{\n+\t  edge cand_edge = (*cand_path)[j]->e;\n+\t  edge curr_edge = (*curr_path)[j]->e;\n+\n+\t  /* Once the prefix no longer matches, adjust the first\n+\t     non-matching edge to point from an adjusted edge to\n+\t     wherever it was going.  */\n+\t  if (cand_edge != curr_edge)\n+\t    {\n+\t      gcc_assert (cand_edge->src == curr_edge->src);\n+\t      if (!rewire_first_differing_edge (cand_path_num, j))\n+\t\tgoto remove_candidate_from_list;\n+\t      break;\n+\t    }\n+\t}\n+      if (j == minlength)\n+\t{\n+\t  /* If we consumed the max subgraph we could look at, and\n+\t     still didn't find any different edges, it's the\n+\t     last edge after MINLENGTH.  */\n+\t  if (cand_path->length () > minlength)\n+\t    {\n+\t      if (!rewire_first_differing_edge (cand_path_num, j))\n+\t\tgoto remove_candidate_from_list;\n+\t    }\n+\t  else if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"adjusting first edge after MINLENGTH.\\n\");\n+\t}\n+      if (j > 0)\n+\t{\n+\t  /* If we are removing everything, delete the entire candidate.  */\n+\t  if (j == cand_path->length ())\n+\t    {\n+\t    remove_candidate_from_list:\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"adjusted candidate: [EMPTY]\\n\");\n+\t      delete_jump_thread_path (cand_path);\n+\t      paths.unordered_remove (cand_path_num);\n+\t      continue;\n+\t    }\n+\t  /* Otherwise, just remove the redundant sub-path.  */\n+\t  cand_path->block_remove (0, j);\n+\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"adjusted candidate: \");\n+\t  debug_path (dump_file, cand_path_num);\n+\t}\n+      ++cand_path_num;\n+    }\n+}\n+\n /* Duplicates a jump-thread path of N_REGION basic blocks.\n    The ENTRY edge is redirected to the duplicate of the region.\n \n    Remove the last conditional statement in the last basic block in the REGION,\n    and create a single fallthru edge pointing to the same destination as the\n    EXIT edge.\n \n+   CURRENT_PATH_NO is an index into the global paths[] table\n+   specifying the jump-thread path.\n+\n    Returns false if it is unable to copy the region, true otherwise.  */\n \n static bool\n duplicate_thread_path (edge entry, edge exit, basic_block *region,\n-\t\t       unsigned n_region)\n+\t\t       unsigned n_region, unsigned current_path_no)\n {\n   unsigned i;\n   struct loop *loop = entry->dest->loop_father;\n@@ -2065,6 +2234,12 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nabout to thread: \");\n+      debug_path (dump_file, current_path_no);\n+    }\n+\n   /* Some sanity checking.  Note that we do not check for all possible\n      missuses of the functions.  I.e. if you ask to copy something weird,\n      it will work, but the state of structures probably will not be\n@@ -2193,6 +2368,8 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n \n   free (region_copy);\n \n+  adjust_paths_after_duplication (current_path_no);\n+\n   free_original_copy_tables ();\n   return true;\n }\n@@ -2315,7 +2492,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n       for (unsigned int j = 0; j < len - 1; j++)\n \tregion[j] = (*path)[j]->e->dest;\n \n-      if (duplicate_thread_path (entry, exit, region, len - 1))\n+      if (duplicate_thread_path (entry, exit, region, len - 1, i))\n \t{\n \t  /* We do not update dominance info.  */\n \t  free_dominance_info (CDI_DOMINATORS);"}]}