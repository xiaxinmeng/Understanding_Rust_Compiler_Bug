{"sha": "34487bf85731112fd68f579b0cb1c888c71ebfef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ0ODdiZjg1NzMxMTEyZmQ2OGY1NzliMGNiMWM4ODhjNzFlYmZlZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-04-06T22:10:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-04-06T22:10:53Z"}, "message": "flow.c (verify_flow_info): New function.\n\n        * flow.c (verify_flow_info): New function.\n        (find_basic_blocks): Call it if ENABLE_CHECKING.\n        (merge_blocks): Don't merge if there are non-deletable labels.\n        * toplev.c (fatal_insn): Allow a printf-style arg list.\n        * toplev.h (fatal_insn): Update prototype.\n\nFrom-SVN: r26226", "tree": {"sha": "90a39e1a592c285664eb3df641380a889308f933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90a39e1a592c285664eb3df641380a889308f933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34487bf85731112fd68f579b0cb1c888c71ebfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34487bf85731112fd68f579b0cb1c888c71ebfef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34487bf85731112fd68f579b0cb1c888c71ebfef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34487bf85731112fd68f579b0cb1c888c71ebfef/comments", "author": null, "committer": null, "parents": [{"sha": "89c846727b4f86ef2592842cd1ac5ef09d82b037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c846727b4f86ef2592842cd1ac5ef09d82b037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c846727b4f86ef2592842cd1ac5ef09d82b037"}], "stats": {"total": 287, "additions": 263, "deletions": 24}, "files": [{"sha": "443a62835eaca1e4d8b5cb2045c2bef1845111c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34487bf85731112fd68f579b0cb1c888c71ebfef", "patch": "@@ -1,3 +1,17 @@\n+Tue Apr  6 22:09:40 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* expr.c (expand_builtin_setjmp): Put setjmp return label on\n+\tnonlocal_goto_handler_labels for flow.\n+\n+Tue Apr  6 22:05:21 1999  Jan Hubicka  <hubicka@paru.cas.cz>\n+\t\t\t  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (verify_flow_info): New function.\n+\t(find_basic_blocks): Call it if ENABLE_CHECKING.\n+\t(merge_blocks): Don't merge if there are non-deletable labels.\n+\t* toplev.c (fatal_insn): Allow a printf-style arg list.\n+\t* toplev.h (fatal_insn): Update prototype.\n+\n Tue Apr  6 16:18:58 1999  Jan Hubicka  <hubicka@paru.cas.cz>\n \n \t* flow.c (split_edge) update correctly flow graph, disable"}, {"sha": "072d2089c79b32342b9eba6cb78dac75f3801919", "filename": "gcc/flow.c", "status": "modified", "additions": 230, "deletions": 9, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=34487bf85731112fd68f579b0cb1c888c71ebfef", "patch": "@@ -335,6 +335,7 @@ static void count_reg_sets\t\tPROTO ((rtx));\n static void count_reg_references\tPROTO ((rtx));\n static void notice_stack_pointer_modification PROTO ((rtx, rtx));\n static void invalidate_mems_from_autoinc\tPROTO ((rtx));\n+void verify_flow_info\t\t\tPROTO ((void));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -418,6 +419,10 @@ find_basic_blocks (f, nregs, file, do_cleanup)\n \n   /* Kill the data we won't maintain.  */\n   label_value_list = 0;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n }\n \n /* Count the basic blocks of the function.  */\n@@ -1945,15 +1950,14 @@ merge_blocks (e, b, c)\n \t jump must go in a new basic block D.  */\n     }\n \n-  /* If a label still appears somewhere, we cannot delete the label, which\n-     means we cannot merge the blocks.  We have still won a tad by tidying\n-     the interface between the two blocks.  */\n-  if (GET_CODE (c->head) == CODE_LABEL\n-      && ! can_delete_label_p (c->head))\n-    {\n-      tidy_fallthru_edge (e, b, c);\n-      return 0;\n-    }\n+  /* If a label still appears somewhere and we cannot delete the label,\n+     then we cannot merge the blocks.  The edge was tidied already.  */\n+  {\n+    rtx insn, stop = NEXT_INSN (c->head);\n+    for (insn = NEXT_INSN (b->end); insn != stop; insn = NEXT_INSN (insn))\n+      if (GET_CODE (insn) == CODE_LABEL && !can_delete_label_p (insn))\n+\treturn 0;\n+  }\n \n   merge_blocks_nomove (b, c);\n   return 1;\n@@ -5001,3 +5005,220 @@ set_block_num (insn, bb)\n {\n   set_block_for_insn (insn, BASIC_BLOCK (bb));\n }\n+\f\n+/* Verify the CFG consistency.  This function check some CFG invariants and\n+   aborts when something is wrong.  Hope that this function will help to\n+   convert many optimization passes to preserve CFG consistent.\n+\n+   Currently it does following checks: \n+\n+   - test head/end pointers\n+   - overlapping of basic blocks\n+   - edge list corectness\n+   - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n+   - tails of basic blocks (ensure that boundary is necesary)\n+   - scans body of the basic block for JUMP_INSN, CODE_LABEL\n+     and NOTE_INSN_BASIC_BLOCK\n+   - check that all insns are in the basic blocks \n+   (except the switch handling code, barriers and notes)\n+\n+   In future it can be extended check a lot of other stuff as well\n+   (reachability of basic blocks, life information, etc. etc.).  */\n+\n+void\n+verify_flow_info ()\n+{\n+  const int max_uid = get_max_uid ();\n+  const rtx rtx_first = get_insns ();\n+  basic_block *bb_info;\n+  rtx x;\n+  int i;\n+\n+  bb_info = (basic_block *) alloca (max_uid * sizeof (basic_block));\n+  memset (bb_info, 0, max_uid * sizeof (basic_block));\n+\n+  /* First pass check head/end pointers and set bb_info array used by\n+     later passes.  */\n+  for (i = n_basic_blocks - 1; i >= 0; i--)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+\n+      /* Check the head pointer and make sure that it is pointing into\n+         insn list.  */\n+      for (x = rtx_first; x != NULL_RTX; x = NEXT_INSN (x))\n+\tif (x == bb->head)\n+\t  break;\n+      if (!x)\n+\t{\n+\t  fatal (\"verify_flow_info: Head insn %d for block %d not found in the insn stream.\\n\",\n+\t\t INSN_UID (bb->head), bb->index);\n+\t}\n+\n+      /* Check the end pointer and make sure that it is pointing into\n+         insn list.  */\n+      for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n+\t{\n+\t  if (bb_info[INSN_UID (x)] != NULL)\n+\t    {\n+\t      fatal (\"verify_flow_info: Insn %d is in multiple basic blocks (%d and %d)\",\n+\t\t     INSN_UID (x), bb->index, bb_info[INSN_UID (x)]->index);\n+\t    }\n+\t  bb_info[INSN_UID (x)] = bb;\n+\n+\t  if (x == bb->end)\n+\t    break;\n+\t}\n+      if (!x)\n+\t{\n+\t  fatal (\"verify_flow_info: End insn %d for block %d not found in the insn stream.\\n\",\n+\t\t INSN_UID (bb->end), bb->index);\n+\t}\n+    }\n+\n+  /* Now check the basic blocks (boundaries etc.) */\n+  for (i = n_basic_blocks - 1; i >= 0; i--)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      /* Check corectness of edge lists */\n+      edge e;\n+\n+      e = bb->succ;\n+      while (e)\n+\t{\n+\t  if (e->src != bb)\n+\t    {\n+\t      fprintf (stderr, \"verify_flow_info: Basic block %d succ edge is corrupted\\n\",\n+\t\t       bb->index);\n+\t      fprintf (stderr, \"Predecessor: \");\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fprintf (stderr, \"\\nSuccessor: \");\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fflush (stderr);\n+\t      abort ();\n+\t    }\n+\t  if (e->dest != EXIT_BLOCK_PTR)\n+\t    {\n+\t      edge e2 = e->dest->pred;\n+\t      while (e2 && e2 != e)\n+\t\te2 = e2->pred_next;\n+\t      if (!e2)\n+\t\t{\n+\t\t  fatal (\"verify_flow_info: Basic block %i edge lists are corrupted\\n\",\n+\t\t\t bb->index);\n+\t\t}\n+\t    }\n+\t  e = e->succ_next;\n+\t}\n+\n+      e = bb->pred;\n+      while (e)\n+\t{\n+\t  if (e->dest != bb)\n+\t    {\n+\t      fprintf (stderr, \"verify_flow_info: Basic block %d pred edge is corrupted\\n\",\n+\t\t       bb->index);\n+\t      fprintf (stderr, \"Predecessor: \");\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fprintf (stderr, \"\\nSuccessor: \");\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fflush (stderr);\n+\t      abort ();\n+\t    }\n+\t  if (e->src != ENTRY_BLOCK_PTR)\n+\t    {\n+\t      edge e2 = e->src->succ;\n+\t      while (e2 && e2 != e)\n+\t\te2 = e2->succ_next;\n+\t      if (!e2)\n+\t\t{\n+\t\t  fatal (\"verify_flow_info: Basic block %i edge lists are corrupted\\n\",\n+\t\t\t bb->index);\n+\t\t}\n+\t    }\n+\t  e = e->pred_next;\n+\t}\n+\n+      /* OK pointers are correct.  Now check the header of basic\n+         block.  It ought to contain optional CODE_LABEL followed\n+\t by NOTE_BASIC_BLOCK.  */\n+      x = bb->head;\n+      if (GET_CODE (x) == CODE_LABEL)\n+\t{\n+\t  if (bb->end == x)\n+\t    {\n+\t      fatal (\"verify_flow_info: Basic block contains only CODE_LABEL and no NOTE_INSN_BASIC_BLOCK note\\n\");\n+\t    }\n+\t  x = NEXT_INSN (x);\n+\t}\n+      if (GET_CODE (x) != NOTE\n+\t  || NOTE_LINE_NUMBER (x) != NOTE_INSN_BASIC_BLOCK\n+\t  || NOTE_BASIC_BLOCK (x) != bb)\n+\t{\n+\t  fatal (\"verify_flow_info: NOTE_INSN_BASIC_BLOCK is missing for block %d\\n\",\n+\t\t bb->index);\n+\t}\n+\n+      if (bb->end == x)\n+\t{\n+\t  /* Do checks for empty blocks here */\n+\t}\n+      else\n+\t{\n+\t  x = NEXT_INSN (x);\n+\t  while (x)\n+\t    {\n+\t      if (GET_CODE (x) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (x) == NOTE_INSN_BASIC_BLOCK)\n+\t\t{\n+\t\t  fatal (\"verify_flow_info: NOTE_INSN_BASIC_BLOCK %d in the middle of basic block %d\\n\",\n+\t\t\t INSN_UID (x), bb->index);\n+\t\t}\n+\n+\t      if (x == bb->end)\n+\t\tbreak;\n+\n+\t      if (GET_CODE (x) == JUMP_INSN\n+\t\t  || GET_CODE (x) == CODE_LABEL\n+\t\t  || GET_CODE (x) == BARRIER)\n+\t\t{\n+\t\t  fatal_insn (\"verify_flow_info: Incorrect insn in the middle of basic block %d\\n\",\n+\t\t\t      x, bb->index);\n+\t\t}\n+\n+\t      x = NEXT_INSN (x);\n+\t    }\n+\t}\n+    }\n+\n+  x = rtx_first;\n+  while (x)\n+    {\n+      if (!bb_info[INSN_UID (x)])\n+\t{\n+\t  switch (GET_CODE (x))\n+\t    {\n+\t    case BARRIER:\n+\t    case NOTE:\n+\t      break;\n+\n+\t    case CODE_LABEL:\n+\t      /* An addr_vec is placed outside any block block.  */\n+\t      if (NEXT_INSN (x)\n+\t\t  && GET_CODE (NEXT_INSN (x)) == JUMP_INSN\n+\t\t  && (GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_DIFF_VEC\n+\t\t      || GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_VEC))\n+\t\t{\n+\t\t  x = NEXT_INSN (x);\n+\t\t}\n+\n+\t      /* But in any case, non-deletable labels can appear anywhere.  */\n+\t      break;\n+\n+\t    default:\n+\t      fatal_insn (\"verify_flow_info: Insn outside basic block\\n\", x);\n+\t    }\n+\t}\n+\n+      x = NEXT_INSN (x);\n+    }\n+}"}, {"sha": "5da95455555bc2b159cce0459f3fcdac35ec66df", "filename": "gcc/toplev.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=34487bf85731112fd68f579b0cb1c888c71ebfef", "patch": "@@ -1436,21 +1436,24 @@ fatal_io_error (name)\n    just calling abort().  */\n \n void\n-fatal_insn (msgid, insn)\n-     const char *msgid;\n-     rtx insn;\n+fatal_insn VPROTO((const char *msgid, rtx insn, ...))\n {\n-  error (msgid);\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+  rtx insn;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, insn);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+  insn = va_arg (ap, rtx);\n+#endif\n+\n+  verror (msgid, ap);\n   debug_rtx (insn);\n-  if (asm_out_file)\n-    fflush (asm_out_file);\n-  if (aux_info_file)\n-    fflush (aux_info_file);\n-  if (rtl_dump_file != NULL)\n-    fflush (rtl_dump_file);\n-  fflush (stdout);\n-  fflush (stderr);\n-  abort ();\n+  exit (FATAL_EXIT_CODE);\n }\n \n /* Called to give a better error message when we don't have an insn to match"}, {"sha": "1f4086377197ded23fcb386540c93311f7490382", "filename": "gcc/toplev.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34487bf85731112fd68f579b0cb1c888c71ebfef/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=34487bf85731112fd68f579b0cb1c888c71ebfef", "patch": "@@ -43,8 +43,9 @@ extern void pfatal_with_name\t\tPROTO ((const char *))\n   ATTRIBUTE_NORETURN;\n extern void fatal_insn_not_found\tPROTO ((struct rtx_def *))\n   ATTRIBUTE_NORETURN;\n-extern void fatal_insn\t\t\tPROTO ((const char *, struct rtx_def *))\n-  ATTRIBUTE_NORETURN;\n+extern void fatal_insn\t\t\tPVPROTO ((const char *,\n+\t\t\t\t\t\t  struct rtx_def *, ...))\n+  ATTRIBUTE_PRINTF(1, 3) ATTRIBUTE_NORETURN;\n extern void warning\t\t\tPVPROTO ((const char *, ...))\n \t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n extern void error\t\t\tPVPROTO ((const char *, ...))"}]}