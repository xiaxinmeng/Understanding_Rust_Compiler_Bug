{"sha": "2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRjZjI1ODRkYmNlZmI0YzMxNDhhMmM0ZWM3NzY1OThkMjAwNGMxYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-04-08T06:49:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:49:13Z"}, "message": "errout.ads: Update comments for new handling of info: messages\n\n2008-04-08  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.ads: Update comments for new handling of info: messages\n\n\t* erroutc.adb (Matches): New procedure\n\t(Warning_Specifically_Suppressed): Modified to handle multiple * chars\n\t(Is_Style_Or_Info_Msg): New name for Is_Style_Msg, now set for\n\t info messages as well as style messages.\n\n\t* erroutc.ads: Remove unneeded fields from Specific_Warning_Entry\n\n\t* sem_elab.adb (Supply_Bodies): Create actual bodies for stubbed\n\tsubprograms.\n\t(Check_A_Call): Special \"info: \" warnings now have ? in the text\n\t(Elab_Warning): Use info message in static case\n\nFrom-SVN: r134024", "tree": {"sha": "0bd146c5189863d5579772c6bbaeeca6003fc44b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bd146c5189863d5579772c6bbaeeca6003fc44b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/comments", "author": null, "committer": null, "parents": [{"sha": "68c3f02a687ec4e6dd51392f1154da5690cd7963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68c3f02a687ec4e6dd51392f1154da5690cd7963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68c3f02a687ec4e6dd51392f1154da5690cd7963"}], "stats": {"total": 711, "additions": 351, "deletions": 360}, "files": [{"sha": "83b50953010930d38fbb8ae7c0322ec26581a63e", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -275,14 +275,21 @@ package Errout is\n    --    Insertion character ? (Question: warning message)\n    --      The character ? appearing anywhere in a message makes the message\n    --      warning instead of a normal error message, and the text of the\n-   --      message will be preceded by \"Warning:\" instead of \"Error:\" in the\n-   --      normal case. The handling of warnings if further controlled by the\n-   --      Warning_Mode option (-w switch), see package Opt for further\n-   --      details, and also by the current setting from pragma Warnings. This\n-   --      pragma applies only to warnings issued from the semantic phase (not\n-   --      the parser), but currently all relevant warnings are posted by the\n-   --      semantic phase anyway. Messages starting with (style) are also\n-   --      treated as warning messages.\n+   --      message will be preceded by \"warning:\" in the normal case. The\n+   --      handling of warnings if further controlled by the Warning_Mode\n+   --      option (-w switch), see package Opt for further details, and also by\n+   --      the current setting from pragma Warnings. This pragma applies only\n+   --      to warnings issued from the semantic phase (not the parser), but\n+   --      currently all relevant warnings are posted by the semantic phase\n+   --      anyway. Messages starting with (style) are also treated as warning\n+   --      messages.\n+   --\n+   --      Note: when a warning message is output, the text of the message is\n+   --      preceded by \"warning: \" in the normal case. An exception to this\n+   --      rule occurs when the text of the message starts with \"info: \" in\n+   --      which case this string is not prepended. This allows callers to\n+   --      label certain warnings as informational messages, rather than as\n+   --      warning messages requiring some action.\n    --\n    --      Note: the presence of ? is ignored in continuation messages (i.e.\n    --      messages starting with the \\ insertion character). The warning"}, {"sha": "604fd5409e3b16c14e288660ef838d5c4d209087", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 126, "deletions": 165, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -117,6 +117,7 @@ package body Erroutc is\n \n             if Errors.Table (D).Warn or Errors.Table (D).Style then\n                Warnings_Detected := Warnings_Detected - 1;\n+\n             else\n                Total_Errors_Detected := Total_Errors_Detected - 1;\n \n@@ -441,6 +442,12 @@ package body Erroutc is\n       Length : Nat;\n       --  Maximum total length of lines\n \n+      Txt   : constant String_Ptr := Errors.Table (E).Text;\n+      Len   : constant Natural    := Txt'Length;\n+      Ptr   : Natural;\n+      Split : Natural;\n+      Start : Natural;\n+\n    begin\n       if Error_Msg_Line_Length = 0 then\n          Length := Nat'Last;\n@@ -450,88 +457,87 @@ package body Erroutc is\n \n       Max := Integer (Length - Column + 1);\n \n+      --  For warning message, add \"warning: \" unless msg starts with \"info: \"\n+\n       if Errors.Table (E).Warn then\n-         Write_Str (\"warning: \");\n-         Max := Max - 9;\n+         if Len < 6 or else Txt (Txt'First .. Txt'First + 5) /= \"info: \" then\n+            Write_Str (\"warning: \");\n+            Max := Max - 9;\n+         end if;\n+\n+      --  No prefix needed for style message, since \"(style)\" is there already\n \n       elsif Errors.Table (E).Style then\n          null;\n \n+      --  All other cases, add \"error: \"\n+\n       elsif Opt.Unique_Error_Tag then\n          Write_Str (\"error: \");\n          Max := Max - 7;\n       end if;\n \n       --  Here we have to split the message up into multiple lines\n \n-      declare\n-         Txt   : constant String_Ptr := Errors.Table (E).Text;\n-         Len   : constant Natural    := Txt'Length;\n-         Ptr   : Natural;\n-         Split : Natural;\n-         Start : Natural;\n-\n-      begin\n-         Ptr := 1;\n-         loop\n-            --  Make sure we do not have ludicrously small line\n+      Ptr := 1;\n+      loop\n+         --  Make sure we do not have ludicrously small line\n \n-            Max := Integer'Max (Max, 20);\n+         Max := Integer'Max (Max, 20);\n \n-            --  If remaining text fits, output it respecting LF and we are done\n+         --  If remaining text fits, output it respecting LF and we are done\n \n-            if Len - Ptr < Max then\n-               for J in Ptr .. Len loop\n-                  if Txt (J) = ASCII.LF then\n-                     Write_Eol;\n-                     Write_Spaces (Offs);\n-                  else\n-                     Write_Char (Txt (J));\n-                  end if;\n-               end loop;\n+         if Len - Ptr < Max then\n+            for J in Ptr .. Len loop\n+               if Txt (J) = ASCII.LF then\n+                  Write_Eol;\n+                  Write_Spaces (Offs);\n+               else\n+                  Write_Char (Txt (J));\n+               end if;\n+            end loop;\n \n-               return;\n+            return;\n \n             --  Line does not fit\n \n-            else\n-               Start := Ptr;\n+         else\n+            Start := Ptr;\n \n-               --  First scan forward looing for a hard end of line\n+            --  First scan forward looing for a hard end of line\n \n-               for Scan in Ptr .. Ptr + Max - 1 loop\n-                  if Txt (Scan) = ASCII.LF then\n-                     Split := Scan - 1;\n-                     Ptr := Scan + 1;\n-                     goto Continue;\n-                  end if;\n-               end loop;\n+            for Scan in Ptr .. Ptr + Max - 1 loop\n+               if Txt (Scan) = ASCII.LF then\n+                  Split := Scan - 1;\n+                  Ptr := Scan + 1;\n+                  goto Continue;\n+               end if;\n+            end loop;\n \n-               --  Otherwise scan backwards looking for a space\n+            --  Otherwise scan backwards looking for a space\n \n-               for Scan in reverse Ptr .. Ptr + Max - 1 loop\n-                  if Txt (Scan) = ' ' then\n-                     Split := Scan - 1;\n-                     Ptr := Scan + 1;\n-                     goto Continue;\n-                  end if;\n-               end loop;\n+            for Scan in reverse Ptr .. Ptr + Max - 1 loop\n+               if Txt (Scan) = ' ' then\n+                  Split := Scan - 1;\n+                  Ptr := Scan + 1;\n+                  goto Continue;\n+               end if;\n+            end loop;\n \n-               --  If we fall through, no space, so split line arbitrarily\n+            --  If we fall through, no space, so split line arbitrarily\n \n-               Split := Ptr + Max - 1;\n-               Ptr := Split + 1;\n-            end if;\n+            Split := Ptr + Max - 1;\n+            Ptr := Split + 1;\n+         end if;\n \n          <<Continue>>\n-            if Start <= Split then\n-               Write_Line (Txt (Start .. Split));\n-               Write_Spaces (Offs);\n-            end if;\n+         if Start <= Split then\n+            Write_Line (Txt (Start .. Split));\n+            Write_Spaces (Offs);\n+         end if;\n \n-            Max := Integer (Length - Column + 1);\n-         end loop;\n-      end;\n+         Max := Integer (Length - Column + 1);\n+      end loop;\n    end Output_Msg_Text;\n \n    --------------------\n@@ -557,6 +563,7 @@ package body Erroutc is\n          then\n             if Errors.Table (E).Warn or Errors.Table (E).Style then\n                Warnings_Detected := Warnings_Detected - 1;\n+\n             else\n                Total_Errors_Detected := Total_Errors_Detected - 1;\n \n@@ -1052,40 +1059,13 @@ package body Erroutc is\n       Msg    : String;\n       Config : Boolean)\n    is\n-      pragma Assert (Msg'First = 1);\n-\n-      Pattern : String  := Msg;\n-      Patlen  : Natural := Msg'Length;\n-\n-      Star_Start : Boolean;\n-      Star_End   : Boolean;\n-\n    begin\n-      if Pattern (1) = '*' then\n-         Star_Start := True;\n-         Pattern (1 .. Patlen - 1) := Pattern (2 .. Patlen);\n-         Patlen := Patlen - 1;\n-      else\n-         Star_Start := False;\n-      end if;\n-\n-      if Pattern (Patlen) = '*' then\n-         Star_End := True;\n-         Patlen := Patlen - 1;\n-      else\n-         Star_End := False;\n-      end if;\n-\n       Specific_Warnings.Append\n         ((Start      => Loc,\n           Msg        => new String'(Msg),\n-          Pattern    => new String'(Pattern (1 .. Patlen)),\n-          Patlen     => Patlen,\n           Stop       => Source_Last (Current_Source_File),\n           Open       => True,\n           Used       => False,\n-          Star_Start => Star_Start,\n-          Star_End   => Star_End,\n           Config     => Config));\n    end Set_Specific_Warning_Off;\n \n@@ -1200,8 +1180,7 @@ package body Erroutc is\n       Is_Warning_Msg   := False;\n \n       Is_Style_Msg :=\n-        (Msg'Length > 7\n-         and then Msg (Msg'First .. Msg'First + 6) = \"(style)\");\n+        (Msg'Length > 7 and then Msg (Msg'First .. Msg'First + 6) = \"(style)\");\n \n       if Is_Style_Msg then\n          Is_Serious_Error := False;\n@@ -1225,7 +1204,7 @@ package body Erroutc is\n          end if;\n       end loop;\n \n-      if Is_Warning_Msg or else Is_Style_Msg then\n+      if Is_Warning_Msg or Is_Style_Msg then\n          Is_Serious_Error := False;\n       end if;\n    end Test_Style_Warning_Serious_Msg;\n@@ -1262,110 +1241,92 @@ package body Erroutc is\n      (Loc : Source_Ptr;\n       Msg : String_Ptr) return Boolean\n    is\n-      pragma Assert (Msg'First = 1);\n+      function Matches (S : String; P : String) return Boolean;\n+      --  Returns true if the String S patches the pattern P, which can contain\n+      --  wild card chars (*). The entire pattern must match the entire string.\n \n-      Msglen : constant Natural := Msg'Length;\n-      Patlen : Natural;\n-      --  Length of message\n-\n-      Pattern : String_Ptr;\n-      --  Pattern itself, excluding initial and final *\n-\n-      Star_Start : Boolean;\n-      Star_End   : Boolean;\n-      --  Indications of * at start and end of original pattern\n-\n-      Msgp : Natural;\n-      Patp : Natural;\n-      --  Scan pointers for message and pattern\n-\n-   begin\n-      --  Loop through specific warning suppression entries\n+      -------------\n+      -- Matches --\n+      -------------\n \n-      for J in Specific_Warnings.First .. Specific_Warnings.Last loop\n-         declare\n-            SWE : Specific_Warning_Entry renames Specific_Warnings.Table (J);\n+      function Matches (S : String; P : String) return Boolean is\n+         Slast : constant Natural := S'Last;\n+         PLast : constant Natural := P'Last;\n \n-         begin\n-            --  Pragma applies if it is a configuration pragma, or if the\n-            --  location is in range of a specific non-configuration pragma.\n+         SPtr : Natural := S'First;\n+         PPtr : Natural := P'First;\n \n-            if SWE.Config\n-              or else (SWE.Start <= Loc and then Loc <= SWE.Stop)\n-            then\n-               --  Check if message matches, dealing with * patterns\n+      begin\n+         --  Loop advancing through characters of string and pattern\n \n-               Patlen     := SWE.Patlen;\n-               Pattern    := SWE.Pattern;\n-               Star_Start := SWE.Star_Start;\n-               Star_End   := SWE.Star_End;\n+         SPtr := S'First;\n+         PPtr := P'First;\n+         loop\n+            --  Return True if pattern is a single asterisk\n \n-               --  Loop through possible starting positions in Msg\n+            if PPtr = PLast and then P (PPtr) = '*' then\n+               return True;\n \n-               Outer : for M in 1 .. 1 + (Msglen - Patlen) loop\n+            --  Return True if both pattern and string exhausted\n \n-                  --  See if pattern matches string starting at Msg (J)\n+            elsif PPtr > PLast and then SPtr > Slast then\n+               return True;\n \n-                  Msgp := M;\n-                  Patp := 1;\n-                  Inner : loop\n+            --  Return False, if one exhausted and not the other\n \n-                     --  If pattern exhausted, then match if we are at end\n-                     --  of message, or if pattern ended with an asterisk,\n-                     --  otherwise match failure at this position.\n+            elsif PPtr > PLast or else SPtr > Slast then\n+               return False;\n \n-                     if Patp > Patlen then\n-                        if Msgp > Msglen or else Star_End then\n-                           SWE.Used := True;\n-                           return True;\n-                        else\n-                           exit Inner;\n-                        end if;\n+            --  Case where pattern starts with asterisk\n \n-                        --  Otherwise if message exhausted (and we still have\n-                        --  pattern characters left), then match failure here.\n+            elsif P (PPtr) = '*' then\n \n-                     elsif Msgp > Msglen then\n-                        exit Inner;\n-                     end if;\n+               --  Try all possible starting positions in S for match with\n+               --  the remaining characters of the pattern. This is the\n+               --  recursive call that implements the scanner backup.\n \n-                     --  Here we have pattern and message characters left\n+               for J in SPtr .. Slast loop\n+                  if Matches (S (J .. Slast), P (PPtr + 1 .. PLast)) then\n+                     return True;\n+                  end if;\n+               end loop;\n \n-                     --  Handle \"*\" pattern match\n+               return False;\n \n-                     if Patp < Patlen - 1 and then\n-                       Pattern (Patp .. Patp + 2) = \"\"\"*\"\"\"\n-                     then\n-                        Patp := Patp + 3;\n+            --  Dealt with end of string and *, advance if we have a match\n \n-                        --  Must have \" and at least three chars in msg or we\n-                        --  have no match at this position.\n+            elsif S (SPtr) = P (PPtr) then\n+               SPtr := SPtr + 1;\n+               PPtr := PPtr + 1;\n \n-                        exit Inner when Msg (Msgp) /= '\"';\n-                        Msgp := Msgp + 1;\n+            --  If first characters do not match, that's decisive\n \n-                        --  Scan out \" string \" in message\n+            else\n+               return False;\n+            end if;\n+         end loop;\n+      end Matches;\n \n-                        Scan : loop\n-                           exit Inner when Msgp = Msglen;\n-                           Msgp := Msgp + 1;\n-                           exit Scan when Msg (Msgp - 1) = '\"';\n-                        end loop Scan;\n+   --  Start of processing for Warning_Specifically_Suppressed\n \n-                     --  If not \"*\" case, just compare character\n+   begin\n+      --  Loop through specific warning suppression entries\n \n-                     else\n-                        exit Inner when Pattern (Patp) /= Msg (Msgp);\n-                        Patp := Patp + 1;\n-                        Msgp := Msgp + 1;\n-                     end if;\n-                  end loop Inner;\n+      for J in Specific_Warnings.First .. Specific_Warnings.Last loop\n+         declare\n+            SWE : Specific_Warning_Entry renames Specific_Warnings.Table (J);\n \n-                  --  Advance to next position if star at end of original\n-                  --  pattern, otherwise no more match attempts are possible\n+         begin\n+            --  Pragma applies if it is a configuration pragma, or if the\n+            --  location is in range of a specific non-configuration pragma.\n \n-                  exit Outer when not Star_Start;\n-               end loop Outer;\n+            if SWE.Config\n+              or else (SWE.Start <= Loc and then Loc <= SWE.Stop)\n+            then\n+               if Matches (Msg.all, SWE.Msg.all) then\n+                  SWE.Used := True;\n+                  return True;\n+               end if;\n             end if;\n          end;\n       end loop;"}, {"sha": "edc1140fbef69934220f405c607bbff0c23f9665", "filename": "gcc/ada/erroutc.ads", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Ferroutc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Ferroutc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.ads?ref=2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,6 +52,7 @@ package Erroutc is\n \n    Is_Style_Msg : Boolean := False;\n    --  Set True to indicate if the current message is a style message\n+   --  (i.e. a message whose text starts with the cahracters \"(style)\").\n \n    Is_Serious_Error : Boolean := False;\n    --  Set by Set_Msg_Text to indicate if current message is serious error\n@@ -267,25 +268,12 @@ package Erroutc is\n       Msg : String_Ptr;\n       --  Message from pragma Warnings (Off, string)\n \n-      Pattern : String_Ptr;\n-      --  Same as Msg, excluding initial and final asterisks if present. The\n-      --  lower bound of this string is always one.\n-\n-      Patlen : Natural;\n-      --  Length of pattern string (excluding initial/final asterisks)\n-\n       Open : Boolean;\n       --  Set to True if OFF has been encountered with no matching ON\n \n       Used : Boolean;\n       --  Set to True if entry has been used to suppress a warning\n \n-      Star_Start : Boolean;\n-      --  True if given pattern had * at start\n-\n-      Star_End : Boolean;\n-      --  True if given pattern had * at end\n-\n       Config : Boolean;\n       --  True if pragma is configuration pragma (in which case no matching\n       --  Off pragma is required, and it is not required that a specific\n@@ -482,12 +470,12 @@ package Erroutc is\n \n    procedure Test_Style_Warning_Serious_Msg (Msg : String);\n    --  Sets Is_Warning_Msg true if Msg is a warning message (contains a\n-   --  question mark character), and False otherwise. Sets Is_Style_Msg\n-   --  true if Msg is a style message (starts with \"(style)\"). Sets\n-   --  Is_Serious_Error True unless the message is a warning or style\n-   --  message or contains the character | indicating a non-serious\n-   --  error message. Note that the call has no effect for continuation\n-   --  messages (those whose first character is \\).\n+   --  question mark character), and False otherwise. Is_Style_Msg is set true\n+   --  if Msg is a style message (starts with \"(style)\". Sets Is_Serious_Error\n+   --  True unless the message is a warning or style/info message or contains\n+   --  the character | indicating a non-serious error message. Note that the\n+   --  call has no effect for continuation messages (those whose first\n+   --  character is '\\').\n \n    function Warnings_Suppressed (Loc : Source_Ptr) return Boolean;\n    --  Determines if given location is covered by a warnings off suppression"}, {"sha": "d61ebb09a4674f48d8b3c1cd42d35b6103003240", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 201, "deletions": 166, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcf2584dbcefb4c3148a2c4ec776598d2004c1c/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=2dcf2584dbcefb4c3148a2c4ec776598d2004c1c", "patch": "@@ -58,11 +58,11 @@ with Uname;    use Uname;\n \n package body Sem_Elab is\n \n-   --  The following table records the recursive call chain for output\n-   --  in the Output routine. Each entry records the call node and the\n-   --  entity of the called routine. The number of entries in the table\n-   --  (i.e. the value of Elab_Call.Last) indicates the current depth\n-   --  of recursion and is used to identify the outer level.\n+   --  The following table records the recursive call chain for output in the\n+   --  Output routine. Each entry records the call node and the entity of the\n+   --  called routine. The number of entries in the table (i.e. the value of\n+   --  Elab_Call.Last) indicates the current depth of recursion and is used to\n+   --  identify the outer level.\n \n    type Elab_Call_Entry is record\n       Cloc : Source_Ptr;\n@@ -77,10 +77,10 @@ package body Sem_Elab is\n      Table_Increment      => 100,\n      Table_Name           => \"Elab_Call\");\n \n-   --  This table is initialized at the start of each outer level call.\n-   --  It holds the entities for all subprograms that have been examined\n-   --  for this particular outer level call, and is used to prevent both\n-   --  infinite recursion, and useless reanalysis of bodies already seen\n+   --  This table is initialized at the start of each outer level call. It\n+   --  holds the entities for all subprograms that have been examined for this\n+   --  particular outer level call, and is used to prevent both infinite\n+   --  recursion, and useless reanalysis of bodies already seen\n \n    package Elab_Visited is new Table.Table (\n      Table_Component_Type => Entity_Id,\n@@ -127,9 +127,8 @@ package body Sem_Elab is\n      Table_Name           => \"Delay_Check\");\n \n    C_Scope : Entity_Id;\n-   --  Top level scope of current scope. We need to compute this only\n-   --  once at the outer level, i.e. for a call to Check_Elab_Call from\n-   --  outside this unit.\n+   --  Top level scope of current scope. Compute this only once at the outer\n+   --  level, i.e. for a call to Check_Elab_Call from outside this unit.\n \n    Outer_Level_Sloc : Source_Ptr;\n    --  Save Sloc value for outer level call node for comparisons of source\n@@ -149,9 +148,9 @@ package body Sem_Elab is\n \n    Delaying_Elab_Checks : Boolean := True;\n    --  This is set True till the compilation is complete, including the\n-   --  insertion of all instance bodies. Then when Check_Elab_Calls is\n-   --  called, the delay table is used to make the delayed calls and\n-   --  this flag is reset to False, so that the calls are processed\n+   --  insertion of all instance bodies. Then when Check_Elab_Calls is called,\n+   --  the delay table is used to make the delayed calls and this flag is reset\n+   --  to False, so that the calls are processed\n \n    -----------------------\n    -- Local Subprograms --\n@@ -177,16 +176,15 @@ package body Sem_Elab is\n       Outer_Scope       : Entity_Id;\n       Inter_Unit_Only   : Boolean;\n       Generate_Warnings : Boolean := True);\n-   --  This is the internal recursive routine that is called to check for\n-   --  a possible elaboration error. The argument N is a subprogram call\n-   --  or generic instantiation to be checked, and E is the entity of\n-   --  the called subprogram, or instantiated generic unit. The flag\n-   --  Outer_Scope is the outer level scope for the original call.\n-   --  Inter_Unit_Only is set if the call is only to be checked in the\n-   --  case where it is to another unit (and skipped if within a unit).\n-   --  Generate_Warnings is set to False to suppress warning messages\n-   --  about missing pragma Elaborate_All's. These messages are not\n-   --  wanted for inner calls in the dynamic model.\n+   --  This is the internal recursive routine that is called to check for a\n+   --  possible elaboration error. The argument N is a subprogram call or\n+   --  generic instantiation to be checked, and E is the entity of the called\n+   --  subprogram, or instantiated generic unit. The flag Outer_Scope is the\n+   --  outer level scope for the original call. Inter_Unit_Only is set if the\n+   --  call is only to be checked in the case where it is to another unit (and\n+   --  skipped if within a unit). Generate_Warnings is set to False to suppress\n+   --  warning messages about missing pragma Elaborate_All's. These messages\n+   --  are not wanted for inner calls in the dynamic model.\n \n    procedure Check_Bad_Instantiation (N : Node_Id);\n    --  N is a node for an instantiation (if called with any other node kind,\n@@ -207,14 +205,14 @@ package body Sem_Elab is\n       E           : Entity_Id;\n       Outer_Scope : Entity_Id;\n       Orig_Ent    : Entity_Id);\n-   --  N is a function call or procedure statement call node and E is\n-   --  the entity of the called function, which is within the current\n-   --  compilation unit (where subunits count as part of the parent).\n-   --  This call checks if this call, or any call within any accessed\n-   --  body could cause an ABE, and if so, outputs a warning. Orig_Ent\n-   --  differs from E only in the case of renamings, and points to the\n-   --  original name of the entity. This is used for error messages.\n-   --  Outer_Scope is the outer level scope for the original call.\n+   --  N is a function call or procedure statement call node and E is the\n+   --  entity of the called function, which is within the current compilation\n+   --  unit (where subunits count as part of the parent). This call checks if\n+   --  this call, or any call within any accessed body could cause an ABE, and\n+   --  if so, outputs a warning. Orig_Ent differs from E only in the case of\n+   --  renamings, and points to the original name of the entity. This is used\n+   --  for error messages. Outer_Scope is the outer level scope for the\n+   --  original call.\n \n    procedure Check_Internal_Call_Continue\n      (N           : Node_Id;\n@@ -224,10 +222,10 @@ package body Sem_Elab is\n    --  The processing for Check_Internal_Call is divided up into two phases,\n    --  and this represents the second phase. The second phase is delayed if\n    --  Delaying_Elab_Calls is set to True. In this delayed case, the first\n-   --  phase makes an entry in the Delay_Check table, which is processed\n-   --  when Check_Elab_Calls is called. N, E and Orig_Ent are as for the call\n-   --  to Check_Internal_Call. Outer_Scope is the outer level scope for\n-   --  the original call.\n+   --  phase makes an entry in the Delay_Check table, which is processed when\n+   --  Check_Elab_Calls is called. N, E and Orig_Ent are as for the call to\n+   --  Check_Internal_Call. Outer_Scope is the outer level scope for the\n+   --  original call.\n \n    procedure Set_Elaboration_Constraint\n     (Call : Node_Id;\n@@ -268,16 +266,16 @@ package body Sem_Elab is\n    --  inevitable, given the optional body semantics of Ada).\n \n    procedure Insert_Elab_Check (N : Node_Id; C : Node_Id := Empty);\n-   --  Given code for an elaboration check (or unconditional raise if\n-   --  the check is not needed), inserts the code in the appropriate\n-   --  place. N is the call or instantiation node for which the check\n-   --  code is required. C is the test whose failure triggers the raise.\n+   --  Given code for an elaboration check (or unconditional raise if the check\n+   --  is not needed), inserts the code in the appropriate place. N is the call\n+   --  or instantiation node for which the check code is required. C is the\n+   --  test whose failure triggers the raise.\n \n    procedure Output_Calls (N : Node_Id);\n-   --  Outputs chain of calls stored in the Elab_Call table. The caller\n-   --  has already generated the main warning message, so the warnings\n-   --  generated are all continuation messages. The argument is the\n-   --  call node at which the messages are to be placed.\n+   --  Outputs chain of calls stored in the Elab_Call table. The caller has\n+   --  already generated the main warning message, so the warnings generated\n+   --  are all continuation messages. The argument is the call node at which\n+   --  the messages are to be placed.\n \n    function Same_Elaboration_Scope (Scop1, Scop2 : Entity_Id) return Boolean;\n    --  Given two scopes, determine whether they are the same scope from an\n@@ -288,17 +286,16 @@ package body Sem_Elab is\n    --  to be the enclosing compilation unit of this scope.\n \n    function Spec_Entity (E : Entity_Id) return Entity_Id;\n-   --  Given a compilation unit entity, if it is a spec entity, it is\n-   --  returned unchanged. If it is a body entity, then the spec for\n-   --  the corresponding spec is returned\n+   --  Given a compilation unit entity, if it is a spec entity, it is returned\n+   --  unchanged. If it is a body entity, then the spec for the corresponding\n+   --  spec is returned\n \n    procedure Supply_Bodies (N : Node_Id);\n    --  Given a node, N, that is either a subprogram declaration or a package\n    --  declaration, this procedure supplies dummy bodies for the subprogram\n    --  or for all subprograms in the package. If the given node is not one\n    --  of these two possibilities, then Supply_Bodies does nothing. The\n-   --  dummy body is supplied by setting the subprogram to be Imported with\n-   --  convention Stubbed.\n+   --  dummy body contains a single Raise statement.\n \n    procedure Supply_Bodies (L : List_Id);\n    --  Calls Supply_Bodies for all elements of the given list L\n@@ -480,11 +477,10 @@ package body Sem_Elab is\n       Decl : Node_Id;\n \n       E_Scope : Entity_Id;\n-      --  Top level scope of entity for called subprogram. This\n-      --  value includes following renamings and derivations, so\n-      --  this scope can be in a non-visible unit. This is the\n-      --  scope that is to be investigated to see whether an\n-      --  elaboration check is required.\n+      --  Top level scope of entity for called subprogram. This value includes\n+      --  following renamings and derivations, so this scope can be in a\n+      --  non-visible unit. This is the scope that is to be investigated to\n+      --  see whether an elaboration check is required.\n \n       W_Scope : Entity_Id;\n       --  Top level scope of directly called entity for subprogram. This\n@@ -531,8 +527,8 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Go to parent for derived subprogram, or to original subprogram\n-      --  in the case of a renaming (Alias covers both these cases)\n+      --  Go to parent for derived subprogram, or to original subprogram in the\n+      --  case of a renaming (Alias covers both these cases).\n \n       Ent := E;\n       loop\n@@ -646,16 +642,16 @@ package body Sem_Elab is\n             return;\n          end if;\n \n-         --  Nothing to do for a generic instance, because in this case\n-         --  the checking was at the point of instantiation of the generic\n-         --  However, this shortcut is only applicable in static mode.\n+         --  Nothing to do for a generic instance, because in this case the\n+         --  checking was at the point of instantiation of the generic However,\n+         --  this shortcut is only applicable in static mode.\n \n          if Is_Generic_Instance (Ent) and not Dynamic_Elaboration_Checks then\n             return;\n          end if;\n \n-         --  Nothing to do if subprogram with no separate spec. However,\n-         --  a call to Deep_Initialize may result in a call to a user-defined\n+         --  Nothing to do if subprogram with no separate spec. However, a\n+         --  call to Deep_Initialize may result in a call to a user-defined\n          --  Initialize procedure, which imposes a body dependency. This\n          --  happens only if the type is controlled and the Initialize\n          --  procedure is not inherited.\n@@ -762,8 +758,8 @@ package body Sem_Elab is\n          then\n             E_Scope := Spec_Entity (Cunit_Entity (Unit_Caller));\n \n-            --  If we don't get a spec entity, just ignore call. Not\n-            --  quite clear why this check is necessary.\n+            --  If we don't get a spec entity, just ignore call. Not quite\n+            --  clear why this check is necessary. ???\n \n             if No (E_Scope) then\n                return;\n@@ -775,16 +771,15 @@ package body Sem_Elab is\n                E_Scope := Scope (E_Scope);\n             end loop;\n \n-         --  For the case N is not an instance, or a call within instance\n-         --  We recompute E_Scope for the error message, since we\n-         --  do NOT want to go to the unit which has the ultimate\n-         --  declaration in the case of renaming and derivation and\n-         --  we also want to go to the generic unit in the case of\n-         --  an instance, and no further.\n+         --  For the case N is not an instance, or a call within instance, we\n+         --  recompute E_Scope for the error message, since we do NOT want to\n+         --  go to the unit which has the ultimate declaration in the case of\n+         --  renaming and derivation and we also want to go to the generic unit\n+         --  in the case of an instance, and no further.\n \n          else\n-            --  Loop to carefully follow renamings and derivations\n-            --  one step outside the current unit, but not further.\n+            --  Loop to carefully follow renamings and derivations one step\n+            --  outside the current unit, but not further.\n \n             if not Inst_Case\n               and then Present (Alias (Ent))\n@@ -879,7 +874,7 @@ package body Sem_Elab is\n                if Inst_Case then\n                   Elab_Warning\n                     (\"instantiation of& may raise Program_Error?\",\n-                     \"instantiation of& during elaboration?\", Ent);\n+                     \"info: instantiation of& during elaboration?\", Ent);\n \n                else\n                   if Nkind (Name (N)) in N_Has_Entity\n@@ -888,13 +883,13 @@ package body Sem_Elab is\n                   then\n                      Elab_Warning\n                        (\"implicit call to & may raise Program_Error?\",\n-                        \"implicit call to & during elaboration?\",\n+                        \"info: implicit call to & during elaboration?\",\n                         Ent);\n \n                   else\n                      Elab_Warning\n                        (\"call to & may raise Program_Error?\",\n-                        \"call to & during elaboration?\",\n+                        \"info: call to & during elaboration?\",\n                         Ent);\n                   end if;\n                end if;\n@@ -904,12 +899,12 @@ package body Sem_Elab is\n                if Nkind (N) in N_Subprogram_Instantiation then\n                   Elab_Warning\n                     (\"\\missing pragma Elaborate for&?\",\n-                     \"\\implicit pragma Elaborate for& generated?\",\n+                     \"\\info: implicit pragma Elaborate for& generated?\",\n                      W_Scope);\n                else\n                   Elab_Warning\n                     (\"\\missing pragma Elaborate_All for&?\",\n-                     \"\\implicit pragma Elaborate_All for & generated?\",\n+                     \"\\info: implicit pragma Elaborate_All for & generated?\",\n                      W_Scope);\n                end if;\n             end Generate_Elab_Warnings;\n@@ -936,8 +931,8 @@ package body Sem_Elab is\n                --  Runtime elaboration check required. Generate check of the\n                --  elaboration Boolean for the unit containing the entity.\n \n-               --  Note that for this case, we do check the real unit (the\n-               --  one from following renamings, since that is the issue!)\n+               --  Note that for this case, we do check the real unit (the one\n+               --  from following renamings, since that is the issue!)\n \n                --  Could this possibly miss a useless but required PE???\n \n@@ -952,10 +947,10 @@ package body Sem_Elab is\n          --  Case of static elaboration model\n \n          else\n-            --  Do not do anything if elaboration checks suppressed. Note\n-            --  that we check Ent here, not E, since we want the real entity\n-            --  for the body to see if checks are suppressed for it, not the\n-            --  dummy entry for renamings or derivations.\n+            --  Do not do anything if elaboration checks suppressed. Note that\n+            --  we check Ent here, not E, since we want the real entity for the\n+            --  body to see if checks are suppressed for it, not the dummy\n+            --  entry for renamings or derivations.\n \n             if Elaboration_Checks_Suppressed (Ent)\n               or else Elaboration_Checks_Suppressed (E_Scope)\n@@ -1111,7 +1106,7 @@ package body Sem_Elab is\n       function Get_Called_Ent return Entity_Id;\n       --  Retrieve called entity. If this is a call to a protected subprogram,\n       --  entity is a selected component. The callable entity may be absent,\n-      --  in which case there is no check to perform.  This happens with\n+      --  in which case there is no check to perform. This happens with\n       --  non-analyzed calls in nested generics.\n \n       --------------------\n@@ -1201,8 +1196,8 @@ package body Sem_Elab is\n       --  is at the time of the actual call (statically speaking) that we must\n       --  do our static check, not at the time of its initial analysis).\n \n-      --  However, we have to check calls within component definitions (e.g., a\n-      --  function call that determines an array component bound), so we\n+      --  However, we have to check calls within component definitions (e.g.\n+      --  a function call that determines an array component bound), so we\n       --  terminate the loop in that case.\n \n       P := Parent (N);\n@@ -1229,8 +1224,8 @@ package body Sem_Elab is\n       if No (Outer_Scope) then\n          Elab_Visited.Set_Last (0);\n \n-         --  Nothing to do if current scope is Standard (this is a bit\n-         --  odd, but it happens in the case of generic instantiations).\n+         --  Nothing to do if current scope is Standard (this is a bit odd, but\n+         --  it happens in the case of generic instantiations).\n \n          C_Scope := Current_Scope;\n \n@@ -1243,9 +1238,8 @@ package body Sem_Elab is\n          From_Elab_Code := not In_Subprogram_Or_Concurrent_Unit;\n          if From_Elab_Code then\n \n-            --  Complain if call that comes from source in preelaborated\n-            --  unit and we are not inside a subprogram (i.e. we are in\n-            --  elab code)\n+            --  Complain if call that comes from source in preelaborated unit\n+            --  and we are not inside a subprogram (i.e. we are in elab code).\n \n             if Comes_From_Source (N)\n               and then In_Preelaborated_Unit\n@@ -1456,9 +1450,9 @@ package body Sem_Elab is\n \n       --  A call to an Init_Proc in elaboration code may bring additional\n       --  dependencies, if some of the record components thereof have\n-      --  initializations that are function calls that come from source.\n-      --  We treat the current node as a call to each of these functions,\n-      --  to check their elaboration impact.\n+      --  initializations that are function calls that come from source. We\n+      --  treat the current node as a call to each of these functions, to check\n+      --  their elaboration impact.\n \n       if Is_Init_Proc (Ent)\n         and then From_Elab_Code\n@@ -1521,9 +1515,9 @@ package body Sem_Elab is\n       Pkg_Body : Entity_Id;\n \n    begin\n-      --  For record or array component, check prefix. If it is an access\n-      --  type, then there is nothing to do (we do not know what is being\n-      --  assigned), but otherwise this is an assignment to the prefix.\n+      --  For record or array component, check prefix. If it is an access type,\n+      --  then there is nothing to do (we do not know what is being assigned),\n+      --  but otherwise this is an assignment to the prefix.\n \n       if Nkind (N) = N_Indexed_Component\n            or else\n@@ -1712,10 +1706,10 @@ package body Sem_Elab is\n \n    procedure Check_Elab_Calls is\n    begin\n-      --  If expansion is disabled, do not generate any checks. Also\n-      --  skip checks if any subunits are missing because in either\n-      --  case we lack the full information that we need, and no object\n-      --  file will be created in any case.\n+      --  If expansion is disabled, do not generate any checks. Also skip\n+      --  checks if any subunits are missing because in either case we lack the\n+      --  full information that we need, and no object file will be created in\n+      --  any case.\n \n       if not Expander_Active\n         or else Is_Generic_Unit (Cunit_Entity (Main_Unit))\n@@ -1822,11 +1816,11 @@ package body Sem_Elab is\n          Set_C_Scope;\n          Check_A_Call (N, Ent, Scope (Ent), Inter_Unit_Only => False);\n \n-      --  If none of those cases holds, but Dynamic_Elaboration_Checks mode\n-      --  is set, then we will do the check, but only in the inter-unit case\n-      --  (this is to accommodate unguarded elaboration calls from other units\n-      --  in which this same mode is set). We inhibit warnings in this case,\n-      --  since this instantiation is not occurring in elaboration code.\n+      --  If none of those cases holds, but Dynamic_Elaboration_Checks mode is\n+      --  set, then we will do the check, but only in the inter-unit case (this\n+      --  is to accommodate unguarded elaboration calls from other units in\n+      --  which this same mode is set). We inhibit warnings in this case, since\n+      --  this instantiation is not occurring in elaboration code.\n \n       elsif Dynamic_Elaboration_Checks then\n          Set_C_Scope;\n@@ -1882,10 +1876,10 @@ package body Sem_Elab is\n       elsif not Full_Analysis then\n          return;\n \n-      --  Nothing to do if within a default expression, since the call\n-      --  is not actualy being made at this time.\n+      --  Nothing to do if analyzing in special spec-expression mode, since the\n+      --  call is not actualy being made at this time.\n \n-      elsif In_Default_Expression then\n+      elsif In_Spec_Expression then\n          return;\n \n       --  Nothing to do for call to intrinsic subprogram\n@@ -1991,16 +1985,16 @@ package body Sem_Elab is\n             Check_Elab_Instantiation (N, Outer_Scope);\n             return OK;\n \n-         --  Skip subprogram bodies that come from source (wait for\n-         --  call to analyze these). The reason for the come from\n-         --  source test is to avoid catching task bodies.\n+         --  Skip subprogram bodies that come from source (wait for call to\n+         --  analyze these). The reason for the come from source test is to\n+         --  avoid catching task bodies.\n \n-         --  For task bodies, we should really avoid these too, waiting\n-         --  for the task activation, but that's too much trouble to\n-         --  catch for now, so we go in unconditionally. This is not\n-         --  so terrible, it means the error backtrace is not quite\n-         --  complete, and we are too eager to scan bodies of tasks\n-         --  that are unused, but this is hardly very significant!\n+         --  For task bodies, we should really avoid these too, waiting for the\n+         --  task activation, but that's too much trouble to catch for now, so\n+         --  we go in unconditionally. This is not so terrible, it means the\n+         --  error backtrace is not quite complete, and we are too eager to\n+         --  scan bodies of tasks that are unused, but this is hardly very\n+         --  significant!\n \n          elsif Nkind (N) = N_Subprogram_Body\n            and then Comes_From_Source (N)\n@@ -2051,8 +2045,8 @@ package body Sem_Elab is\n          end if;\n       end if;\n \n-      --  If the body appears after the outer level call or\n-      --  instantiation then we have an error case handled below.\n+      --  If the body appears after the outer level call or instantiation then\n+      --  we have an error case handled below.\n \n       if Earlier_In_Extended_Unit (Outer_Level_Sloc, Sloc (Sbody))\n         and then not In_Task_Activation\n@@ -2065,8 +2059,8 @@ package body Sem_Elab is\n       elsif Inst_Case then\n          return;\n \n-      --  Otherwise we have a call, so we trace through the called\n-      --  body to see if it has any problems ..\n+      --  Otherwise we have a call, so we trace through the called body to see\n+      --  if it has any problems.\n \n       else\n          pragma Assert (Nkind (Sbody) = N_Subprogram_Body);\n@@ -2083,9 +2077,9 @@ package body Sem_Elab is\n             Write_Eol;\n          end if;\n \n-         --  Now traverse declarations and statements of subprogram body.\n-         --  Note that we cannot simply Traverse (Sbody), since traverse\n-         --  does not normally visit subprogram bodies.\n+         --  Now traverse declarations and statements of subprogram body. Note\n+         --  that we cannot simply Traverse (Sbody), since traverse does not\n+         --  normally visit subprogram bodies.\n \n          declare\n             Decl : Node_Id;\n@@ -2103,11 +2097,11 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Here is the case of calling a subprogram where the body has\n-      --  not yet been encountered, a warning message is needed.\n+      --  Here is the case of calling a subprogram where the body has not yet\n+      --  been encountered, a warning message is needed.\n \n-      --  If we have nothing in the call stack, then this is at the\n-      --  outer level, and the ABE is bound to occur.\n+      --  If we have nothing in the call stack, then this is at the outer\n+      --  level, and the ABE is bound to occur.\n \n       if Elab_Call.Last = 0 then\n          if Inst_Case then\n@@ -2477,8 +2471,8 @@ package body Sem_Elab is\n                        and then Present (Parameter_Associations (Call))\n                        and then Is_Controlled (Etype (First_Actual (Call)));\n    begin\n-      --  If the unit is mentioned in a with_clause of the current\n-      --  unit, it is visible, and we can set the elaboration flag.\n+      --  If the unit is mentioned in a with_clause of the current unit, it is\n+      --  visible, and we can set the elaboration flag.\n \n       if Is_Immediately_Visible (Scop)\n         or else (Is_Child_Unit (Scop) and then Is_Visible_Child_Unit (Scop))\n@@ -2505,9 +2499,9 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  If the unit is not in the context, there must be an intermediate\n-      --  unit that is, on which we need to place to elaboration flag. This\n-      --  happens with init proc calls.\n+      --  If the unit is not in the context, there must be an intermediate unit\n+      --  that is, on which we need to place to elaboration flag. This happens\n+      --  with init proc calls.\n \n       if Is_Init_Proc (Subp)\n         or else Init_Call\n@@ -2561,30 +2555,29 @@ package body Sem_Elab is\n \n       function Find_Body_In (E : Entity_Id; N : Node_Id) return Node_Id;\n       --  Determine if the list of nodes headed by N and linked by Next\n-      --  contains a package body for the package spec entity E, and if\n-      --  so return the package body. If not, then returns Empty.\n+      --  contains a package body for the package spec entity E, and if so\n+      --  return the package body. If not, then returns Empty.\n \n       function Load_Package_Body (Nam : Unit_Name_Type) return Node_Id;\n       --  This procedure is called load the unit whose name is given by Nam.\n       --  This unit is being loaded to see whether it contains an optional\n-      --  generic body. The returned value is the loaded unit, which is\n-      --  always a package body (only package bodies can contain other\n-      --  entities in the sense in which Has_Generic_Body is interested).\n-      --  We only attempt to load bodies if we are generating code. If we\n-      --  are in semantics check only mode, then it would be wrong to load\n-      --  bodies that are not required from a semantic point of view, so\n-      --  in this case we return Empty. The result is that the caller may\n-      --  incorrectly decide that a generic spec does not have a body when\n-      --  in fact it does, but the only harm in this is that some warnings\n-      --  on elaboration problems may be lost in semantic checks only mode,\n-      --  which is not big loss. We also return Empty if we go for a body\n-      --  and it is not there.\n+      --  generic body. The returned value is the loaded unit, which is always\n+      --  a package body (only package bodies can contain other entities in the\n+      --  sense in which Has_Generic_Body is interested). We only attempt to\n+      --  load bodies if we are generating code. If we are in semantics check\n+      --  only mode, then it would be wrong to load bodies that are not\n+      --  required from a semantic point of view, so in this case we return\n+      --  Empty. The result is that the caller may incorrectly decide that a\n+      --  generic spec does not have a body when in fact it does, but the only\n+      --  harm in this is that some warnings on elaboration problems may be\n+      --  lost in semantic checks only mode, which is not big loss. We also\n+      --  return Empty if we go for a body and it is not there.\n \n       function Locate_Corresponding_Body (PE : Entity_Id) return Node_Id;\n       --  PE is the entity for a package spec. This function locates the\n-      --  corresponding package body, returning Empty if none is found.\n-      --  The package body returned is fully parsed but may not yet be\n-      --  analyzed, so only syntactic fields should be referenced.\n+      --  corresponding package body, returning Empty if none is found. The\n+      --  package body returned is fully parsed but may not yet be analyzed,\n+      --  so only syntactic fields should be referenced.\n \n       ------------------\n       -- Find_Body_In --\n@@ -2666,17 +2659,17 @@ package body Sem_Elab is\n       begin\n          if Is_Library_Level_Entity (PE) then\n \n-            --  If package is a library unit that requires a body, we have\n-            --  no choice but to go after that body because it might contain\n-            --  an optional body for the original generic package.\n+            --  If package is a library unit that requires a body, we have no\n+            --  choice but to go after that body because it might contain an\n+            --  optional body for the original generic package.\n \n             if Unit_Requires_Body (PE) then\n \n-               --  Load the body. Note that we are a little careful here to\n-               --  use Spec to get the unit number, rather than PE or Decl,\n-               --  since in the case where the package is itself a library\n-               --  level instantiation, Spec will properly reference the\n-               --  generic template, which is what we really want.\n+               --  Load the body. Note that we are a little careful here to use\n+               --  Spec to get the unit number, rather than PE or Decl, since\n+               --  in the case where the package is itself a library level\n+               --  instantiation, Spec will properly reference the generic\n+               --  template, which is what we really want.\n \n                return\n                  Load_Package_Body\n@@ -3041,8 +3034,55 @@ package body Sem_Elab is\n          declare\n             Ent : constant Entity_Id := Defining_Unit_Name (Specification (N));\n          begin\n-            Set_Is_Imported (Ent);\n-            Set_Convention  (Ent, Convention_Stubbed);\n+\n+            --  Internal subprograms will already have a generated body, so\n+            --  there is no need to provide a stub for them.\n+\n+            if No (Corresponding_Body (N)) then\n+               declare\n+                  Loc : constant Source_Ptr := Sloc (N);\n+                  B : Node_Id;\n+                  Formals : constant List_Id :=\n+                     Copy_Parameter_List (Ent);\n+                  Nam  : constant Entity_Id :=\n+                    Make_Defining_Identifier (Loc, Chars (Ent));\n+                  Spec : Node_Id;\n+                  Stats : constant List_Id :=\n+                    New_List\n+                      (Make_Raise_Program_Error (Loc,\n+                         Reason => PE_Access_Before_Elaboration));\n+               begin\n+                  if Ekind (Ent) = E_Function then\n+                     Spec :=\n+                        Make_Function_Specification (Loc,\n+                          Defining_Unit_Name => Nam,\n+                          Parameter_Specifications => Formals,\n+                          Result_Definition =>\n+                            New_Copy_Tree\n+                              (Result_Definition (Specification (N))));\n+\n+                     --  We cannot reliably make a return statement for this\n+                     --  body, but none is needed because the call raises\n+                     --  program error.\n+\n+                     Set_Return_Present (Ent);\n+\n+                  else\n+                     Spec :=\n+                        Make_Procedure_Specification (Loc,\n+                          Defining_Unit_Name => Nam,\n+                          Parameter_Specifications => Formals);\n+                  end if;\n+\n+                  B := Make_Subprogram_Body (Loc,\n+                          Specification => Spec,\n+                          Declarations => New_List,\n+                          Handled_Statement_Sequence =>\n+                            Make_Handled_Sequence_Of_Statements (Loc,  Stats));\n+                  Insert_After (N, B);\n+                  Analyze (B);\n+               end;\n+            end if;\n          end;\n \n       elsif Nkind (N) = N_Package_Declaration then\n@@ -3075,22 +3115,17 @@ package body Sem_Elab is\n \n    function Within (E1, E2 : Entity_Id) return Boolean is\n       Scop : Entity_Id;\n-\n    begin\n       Scop := E1;\n       loop\n          if Scop = E2 then\n             return True;\n-\n          elsif Scop = Standard_Standard then\n             return False;\n-\n          else\n             Scop := Scope (Scop);\n          end if;\n       end loop;\n-\n-      raise Program_Error;\n    end Within;\n \n    --------------------------"}]}