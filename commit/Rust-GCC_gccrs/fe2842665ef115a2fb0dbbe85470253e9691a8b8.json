{"sha": "fe2842665ef115a2fb0dbbe85470253e9691a8b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUyODQyNjY1ZWYxMTVhMmZiMGRiYmU4NTQ3MDI1M2U5NjkxYThiOA==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2006-08-26T17:13:42Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2006-08-26T17:13:42Z"}, "message": "intrinsic.texi: Update Copyright date.\n\n2006-08-26  Daniel Franke <franke.daniel@gmail.com>\n\n        * intrinsic.texi: Update Copyright date.  Added documentation\n        for ACOSH, AND, ASINH, ATANH, CHDIR, FGET, FGETC, FPUT, FPUTC,\n        GETCWD, OR and XOR intrinsics, removed inadvertently introduced\n        doc-stubs for EQV and NEQV, corrected some typographical errors.\n\nFrom-SVN: r116470", "tree": {"sha": "a5c63b3737f8f7923a0fa2790140ea2e5305b9bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5c63b3737f8f7923a0fa2790140ea2e5305b9bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe2842665ef115a2fb0dbbe85470253e9691a8b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2842665ef115a2fb0dbbe85470253e9691a8b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe2842665ef115a2fb0dbbe85470253e9691a8b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2842665ef115a2fb0dbbe85470253e9691a8b8/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d23489859804f78a4d631badcf7f1a71b03594e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d23489859804f78a4d631badcf7f1a71b03594e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d23489859804f78a4d631badcf7f1a71b03594e9"}], "stats": {"total": 542, "additions": 407, "deletions": 135}, "files": [{"sha": "ba6a3f18927ddd1a1049aba3d942b849f4a40f30", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2842665ef115a2fb0dbbe85470253e9691a8b8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2842665ef115a2fb0dbbe85470253e9691a8b8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fe2842665ef115a2fb0dbbe85470253e9691a8b8", "patch": "@@ -1,3 +1,10 @@\n+2006-08-26  Daniel Franke <franke.daniel@gmail.com>\n+\n+\t* intrinsic.texi: Update Copyright date.  Added documentation\n+\tfor ACOSH, AND, ASINH, ATANH, CHDIR, FGET, FGETC, FPUT, FPUTC,\n+\tGETCWD, OR and XOR intrinsics, removed inadvertently introduced\n+\tdoc-stubs for EQV and NEQV, corrected some typographical errors.\n+\n 2006-08-24  Daniel Franke <franke.daniel@gmail.com>,\n \t    Brooks Moses <bmoses@stanford.edu>\n "}, {"sha": "89b8a394fd5f011a2ce3b3cdcd9f4def4ab9e107", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 400, "deletions": 135, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2842665ef115a2fb0dbbe85470253e9691a8b8/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2842665ef115a2fb0dbbe85470253e9691a8b8/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=fe2842665ef115a2fb0dbbe85470253e9691a8b8", "patch": "@@ -1,5 +1,5 @@\n @ignore\n-Copyright (C) 2005\n+Copyright (C) 2005, 2006\n Free Software Foundation, Inc.\n This is part of the GFORTRAN manual.   \n For copying conditions, see the file gfortran.texi.\n@@ -24,6 +24,16 @@ Some basic guidelines for editing this document:\n \n @end ignore\n \n+@tex\n+\\gdef\\acos{\\mathop{\\rm acos}\\nolimits}\n+\\gdef\\asin{\\mathop{\\rm asin}\\nolimits}\n+\\gdef\\atan{\\mathop{\\rm atan}\\nolimits}\n+\\gdef\\acosh{\\mathop{\\rm acosh}\\nolimits}\n+\\gdef\\asinh{\\mathop{\\rm asinh}\\nolimits}\n+\\gdef\\atanh{\\mathop{\\rm atanh}\\nolimits}\n+@end tex\n+\n+\n @node Intrinsic Procedures\n @chapter Intrinsic Procedures\n @cindex Intrinsic Procedures\n@@ -49,7 +59,7 @@ Some intrinsics have documentation yet to be completed as indicated by 'document\n * @code{ALARM}:         ALARM,     Set an alarm clock\n * @code{ALL}:           ALL,       Determine if all values are true\n * @code{ALLOCATED}:     ALLOCATED, Status of allocatable entity\n-* @code{AND}:           AND,       Logical and\n+* @code{AND}:           AND,       Bitwise logical AND\n * @code{ANINT}:         ANINT,     Nearest whole number\n * @code{ANY}:           ANY,       Determine if any values are true\n * @code{ASIN}:          ASIN,      Arcsine function\n@@ -75,7 +85,7 @@ Some intrinsics have documentation yet to be completed as indicated by 'document\n * @code{CONJG}:         CONJG,     Complex conjugate function\n * @code{COS}:           COS,       Cosine function\n * @code{COSH}:          COSH,      Hyperbolic cosine function\n-* @code{COUNT}:         COUNT,     Count occurrences of .TRUE. in an array\n+* @code{COUNT}:         COUNT,     Count occurrences of TRUE in an array\n * @code{CPU_TIME}:      CPU_TIME,  CPU time subroutine\n * @code{CSHIFT}:        CSHIFT,    Circular array shift function\n * @code{CTIME}:         CTIME,     Subroutine (or function) to convert a time into a string\n@@ -91,21 +101,20 @@ Some intrinsics have documentation yet to be completed as indicated by 'document\n * @code{DTIME}:         DTIME,     Execution time subroutine (or function)\n * @code{EOSHIFT}:       EOSHIFT,   End-off shift function\n * @code{EPSILON}:       EPSILON,   Epsilon function\n-* @code{EQV}:           EQV,       Logical equivalence\n * @code{ERF}:           ERF,       Error function\n * @code{ERFC}:          ERFC,      Complementary error function\n * @code{ETIME}:         ETIME,     Execution time subroutine (or function)\n * @code{EXIT}:          EXIT,      Exit the program with status.\n * @code{EXP}:           EXP,       Exponential function\n * @code{EXPONENT}:      EXPONENT,  Exponent function\n * @code{FDATE}:         FDATE,     Subroutine (or function) to get the current time as a string\n-* @code{FGET}:          FGET,      Read a single character from stdin in stream mode\n+* @code{FGET}:          FGET,      Read a single character in stream mode from stdin\n * @code{FGETC}:         FGETC,     Read a single character in stream mode\n * @code{FLOAT}:         FLOAT,     Convert integer to default real\n * @code{FLOOR}:         FLOOR,     Integer floor function\n * @code{FLUSH}:         FLUSH,     Flush I/O unit(s)\n * @code{FNUM}:          FNUM,      File number function\n-* @code{FPUT}:          FPUT,      Write a single character to stdout in stream mode\n+* @code{FPUT}:          FPUT,      Write a single character in stream mode to stdout\n * @code{FPUTC}:         FPUTC,     Write a single character in stream mode\n * @code{FRACTION}:      FRACTION,  Fractional part of the model representation\n * @code{FREE}:          FREE,      Memory de-allocation subroutine\n@@ -174,11 +183,10 @@ Some intrinsics have documentation yet to be completed as indicated by 'document\n * @code{MODULO}:        MODULO,    Modulo function\n * @code{MVBITS}:        MVBITS,    Move bits from one integer to another\n * @code{NEAREST}:       NEAREST,   Nearest representable number\n-* @code{NEQV}:          NEQV,      Logical non-equivalence\n * @code{NINT}:          NINT,      Nearest whole number\n * @code{NOT}:           NOT,       Logical negation\n-* @code{NULL}:          NULL,      Function that returns an dissassociated pointer\n-* @code{OR}:            OR,        Logical inclusive disjunction\n+* @code{NULL}:          NULL,      Function that returns an disassociated pointer\n+* @code{OR}:            OR,        Bitwise logical OR\n * @code{PACK}:          PACK,      Pack an array into an array of rank one\n * @code{PERROR}:        PERROR,    Print system error message\n * @code{PRECISION}:     PRECISION, Decimal precision of a real kind\n@@ -233,7 +241,7 @@ Some intrinsics have documentation yet to be completed as indicated by 'document\n * @code{UNMASK}:        UNMASK,    (?)\n * @code{UNPACK}:        UNPACK,    Unpack an array of rank one into an array\n * @code{VERIFY}:        VERIFY,    Scan a string for the absence of a set of characters\n-* @code{XOR}:           XOR,       Logical exclusive or\n+* @code{XOR}:           XOR,       Bitwise logical exclusive or\n @end menu\n \n @node Introduction\n@@ -445,7 +453,7 @@ end program test_achar\n \n @table @asis\n @item @emph{Description}:\n-@code{ACOS(X)} computes the arccosine of @var{X} (inverse of @code{COS(X)}.\n+@code{ACOS(X)} computes the arccosine of @var{X} (inverse of @code{COS(X)}).\n \n @item @emph{Standard}:\n F77 and later\n@@ -464,8 +472,8 @@ less than one.\n \n @item @emph{Return value}:\n The return value is of type @code{REAL(*)} and it lies in the\n-range @math{ 0 \\leq \\arccos (x) \\leq \\pi}.  The kind type\n-parameter is the same as @var{X}.\n+range @math{ 0 \\leq \\acos(x) \\leq \\pi}. The kind type parameter \n+is the same as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -493,17 +501,37 @@ Inverse function: @ref{COS}\n @cindex hyperbolic arccosine\n @cindex hyperbolic cosine (inverse)\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{ACOSH(X)} computes the area hyperbolic cosine of @var{X} (inverse of @code{COSH(X)}).\n+\n @item @emph{Standard}:\n+GNU extension\n+\n @item @emph{Class}:\n+Elemental function\n+\n @item @emph{Syntax}:\n+@code{X = ACOSH(X)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{REAL(*)} with a magnitude that is\n+greater or equal to one.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return value is of type @code{REAL(*)} and it lies in the\n+range @math{0 \\leq \\acosh (x) \\leq \\infty}.\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_acosh\n+  REAL(8), DIMENSION(3) :: x = (/ 1.0, 2.0, 3.0 /)\n+  WRITE (*,*) ACOSH(x)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n Inverse function: @ref{COSH}\n @end table\n@@ -861,22 +889,51 @@ end program test_allocated\n \n \n @node AND\n-@section @code{AND} --- Logical and\n+@section @code{AND} --- Bitwise logical AND\n @findex @code{AND} intrinsic\n-@cindex logical operations\n-\n-Intrinsic implemented, documentation pending.\n+@cindex bit operations\n \n @table @asis\n @item @emph{Description}:\n+Bitwise logical @code{AND}.\n+\n+This intrinsic routine is provided for backwards compatibility with \n+GNU Fortran 77.  For integer arguments, programmers should consider\n+the use of the @ref{IAND} intrinsic defined by the Fortran standard.\n+\n @item @emph{Standard}:\n+GNU extension\n+\n @item @emph{Class}:\n+Non-elemental function\n+\n @item @emph{Syntax}:\n+@code{RESULT = AND(X, Y)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@item @var{Y} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return type is either @code{INTEGER(*)} or @code{LOGICAL} after\n+cross-promotion of the arguments. \n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_and\n+  LOGICAL :: T = .TRUE., F = ..FALSE.\n+  INTEGER :: a, b\n+  DATA a / Z'F' /, b / Z'3' /\n+\n+  WRITE (*,*) AND(T, T), AND(T, F), AND(F, T), AND(F, F)\n+  WRITE (*,*) AND(a, b)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+F95 elemental function: @ref{IAND}\n @end table\n \n \n@@ -1011,7 +1068,7 @@ end program test_any\n \n @table @asis\n @item @emph{Description}:\n-@code{ASIN(X)} computes the arcsine of its @var{X}.\n+@code{ASIN(X)} computes the arcsine of its @var{X} (inverse of @code{SIN(X)}).\n \n @item @emph{Standard}:\n F77 and later\n@@ -1030,7 +1087,7 @@ less than one.\n \n @item @emph{Return value}:\n The return value is of type @code{REAL(*)} and it lies in the\n-range @math{-\\pi / 2 \\leq \\arcsin (x) \\leq \\pi / 2}.  The kind type\n+range @math{-\\pi / 2 \\leq \\asin (x) \\leq \\pi / 2}.  The kind type\n parameter is the same as @var{X}.\n \n @item @emph{Example}:\n@@ -1059,18 +1116,38 @@ Inverse function: @ref{SIN}\n @cindex hyperbolic arcsine\n @cindex hyperbolic sine (inverse)\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{ASINH(X)} computes the area hyperbolic sine of @var{X} (inverse of @code{SINH(X)}).\n+\n @item @emph{Standard}:\n+GNU extension\n+\n @item @emph{Class}:\n+Elemental function\n+\n @item @emph{Syntax}:\n+@code{X = ASINH(X)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{REAL(*)}, with @var{X} a real number.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return value is of type @code{REAL(*)} and it lies in the\n+range @math{-\\infty \\leq \\asinh (x) \\leq \\infty}.\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_asinh\n+  REAL(8), DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)\n+  WRITE (*,*) ASINH(x)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+Inverse function: @ref{SINH}\n @end table\n \n \n@@ -1177,7 +1254,7 @@ Elemental function\n \n @item @emph{Return value}:\n The return value is of type @code{REAL(*)} and it lies in the\n-range @math{ - \\pi / 2 \\leq \\arcsin (x) \\leq \\pi / 2}.\n+range @math{ - \\pi / 2 \\leq \\atan (x) \\leq \\pi / 2}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1229,7 +1306,7 @@ If @var{Y} is zero, then @var{X} must be nonzero.\n @item @emph{Return value}:\n The return value has the same type and kind type parameter as @var{Y}.\n It is the principal value of the complex number @math{X + i Y}.  If\n-@var{X} is nonzero, then it lies in the range @math{-\\pi \\le \\arccos (x) \\leq \\pi}.\n+@var{X} is nonzero, then it lies in the range @math{-\\pi \\le \\atan (x) \\leq \\pi}.\n The sign is positive if @var{Y} is positive.  If @var{Y} is zero, then\n the return value is zero if @var{X} is positive and @math{\\pi} if @var{X}\n is negative.  Finally, if @var{X} is zero, then the magnitude of the result\n@@ -1258,18 +1335,38 @@ end program test_atan2\n @cindex hyperbolic arctangent\n @cindex hyperbolic tangent (inverse)\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{ATANH(X)} computes the area hyperbolic sine of @var{X} (inverse of @code{TANH(X)}).\n+\n @item @emph{Standard}:\n+GNU extension\n+\n @item @emph{Class}:\n+Elemental function\n+\n @item @emph{Syntax}:\n+@code{X = ATANH(X)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{REAL(*)} with a magnitude that is less than or equal to one.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return value is of type @code{REAL(*)} and it lies in the\n+range @math{-\\infty \\leq \\atanh(x) \\leq \\infty}.\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_atanh\n+  REAL, DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)\n+  WRITE (*,*) ATANH(x)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+Inverse function: @ref{TANH}\n @end table\n \n \n@@ -1727,21 +1824,44 @@ end program test_char\n @findex @code{CHDIR} intrinsic\n @cindex file system functions\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Change current working directory to a specified @var{PATH}.\n+\n @item @emph{Standard}:\n+GNU extension\n+\n @item @emph{Class}:\n+Non-elemental subroutine\n+\n @item @emph{Syntax}:\n+@code{CALL chdir(PATH[,STATUS])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n+@multitable @columnfractions .15 .80\n+@item @var{PATH}   @tab The type shall be @code{CHARACTER(*)} and shall specify a valid path within the file system.\n+@item @var{STATUS} @tab (Optional) status flag. Returns 0 on success, \n+                        a system specific and non-zero error code otherwise.\n+@end multitable\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_chdir\n+  CHARACTER(len=255) :: path\n+  CALL getcwd(path)\n+  WRITE(*,*) TRIM(path)\n+  CALL chdir(\"/tmp\")\n+  CALL getcwd(path)\n+  WRITE(*,*) TRIM(path)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{GETCWD}\n @end table\n \n \n+\n @node CHMOD\n @section @code{CHMOD} --- Change access permissions of files\n @findex @code{CHMOD} \n@@ -2232,7 +2352,7 @@ Unavailable time and date parameters return blanks.\n @item @tab @code{VALUE(1)}: @tab The year\n @item @tab @code{VALUE(2)}: @tab The month\n @item @tab @code{VALUE(3)}: @tab The day of the month\n-@item @tab @code{VAlUE(4)}: @tab Time difference with UTC in minutes\n+@item @tab @code{VALUE(4)}: @tab Time difference with UTC in minutes\n @item @tab @code{VALUE(5)}: @tab The hour of the day\n @item @tab @code{VALUE(6)}: @tab The minutes of the hour\n @item @tab @code{VALUE(7)}: @tab The seconds of the minute\n@@ -2655,7 +2775,7 @@ Subsequent invocations of @code{DTIME} return values accumulated since the\n previous invocation.\n \n On some systems, the underlying timings are represented using types with\n-sufficiently small limits that overflows (wraparounds) are possible, such as\n+sufficiently small limits that overflows (wrap around) are possible, such as\n 32-bit types. Therefore, the values returned by this intrinsic might be, or\n become, negative, or numerically less than previous values, during a single\n run of the compiled program.\n@@ -2819,30 +2939,6 @@ end program test_epsilon\n \n \n \n-@node EQV\n-@section @code{EQV} --- Logical equivalence\n-@findex @code{EQV} intrinsic\n-@cindex logical operations\n-\n-Intrinsic implemented, documentation pending.\n-\n-@table @asis\n-@item @emph{Description}:\n-@item @emph{Standard}:\n-F77 and later\n-\n-@item @emph{Class}:\n-@item @emph{Syntax}:\n-@item @emph{Arguments}:\n-@item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n-@item @emph{See also}:\n-@ref{NEQV}\n-@end table\n-\n-\n-\n @node ERF\n @section @code{ERF} --- Error function \n @findex @code{ERF} intrinsic\n@@ -2944,7 +3040,7 @@ returns the user and system components of this time in @code{TARRAY(1)} and\n @code{TARRAY(2)} respectively. @var{RESULT} is equal to @code{TARRAY(1) + TARRAY(2)}.\n \n On some systems, the underlying timings are represented using types with\n-sufficiently small limits that overflows (wraparounds) are possible, such as\n+sufficiently small limits that overflows (wrap around) are possible, such as\n 32-bit types. Therefore, the values returned by this intrinsic might be, or\n become, negative, or numerically less than previous values, during a single\n run of the compiled program.\n@@ -3234,51 +3330,117 @@ end program test_float\n \n \n \n-@node FGETC\n-@section @code{FGETC} --- Read a single character in stream mode\n-@findex @code{FGETC} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@node FGET\n+@section @code{FGET} --- Read a single character in stream mode from stdin \n+@findex @code{FGET} intrinsic\n+@cindex file operations\n+@cindex stream operations\n \n @table @asis\n @item @emph{Description}:\n+Read a single character in stream mode from stdin by bypassing normal \n+formatted output. Stream I/O should not be mixed with normal record-oriented \n+(formatted or unformatted) I/O on the same unit; the results are unpredictable.\n+\n+This intrinsic routine is provided for backwards compatibility with \n+GNU Fortran 77.  @command{Gfortran} provides the Fortran 2003 Stream facility.\n+Programmers should consider the use of new stream IO feature in new code \n+for future portability. See also @ref{Fortran 2003 status}.\n+\n @item @emph{Standard}:\n GNU extension\n \n @item @emph{Class}:\n+Non-elemental subroutine\n+\n @item @emph{Syntax}:\n+@code{CALL fget(C[,STATUS])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n+@multitable @columnfractions .15 .80\n+@item @var{C}      @tab The type shall be @code{CHARACTER}.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}. Returns 0 on success,\n+                        -1 on end-of-file and a system specific positive error code otherwise.\n+@end multitable\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_fget\n+  INTEGER, PARAMETER :: strlen = 100\n+  INTEGER :: status, i = 1\n+  CHARACTER(len=strlen) :: str = \"\"\n+\n+  WRITE (*,*) 'Enter text:'\n+  DO\n+    CALL fget(str(i:i), status)\n+    if (status /= 0 .OR. i > strlen) exit\n+    i = i + 1\n+  END DO\n+  WRITE (*,*) TRIM(str)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{FGETC}, @ref{FPUT}, @ref{FPUTC}\n @end table\n \n \n-\n-@node FGET\n-@section @code{FGET} --- Read a single character from stdin in stream mode\n-@findex @code{FGET} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@node FGETC\n+@section @code{FGETC} --- Read a single character in stream mode\n+@findex @code{FGETC} intrinsic\n+@cindex file operations\n+@cindex stream operations\n \n @table @asis\n @item @emph{Description}:\n+Read a single character in stream mode by bypassing normal formatted output. \n+Stream I/O should not be mixed with normal record-oriented (formatted or \n+unformatted) I/O on the same unit; the results are unpredictable.\n+\n+This intrinsic routine is provided for backwards compatibility with \n+GNU Fortran 77.  @command{Gfortran} provides the Fortran 2003 Stream facility.\n+Programmers should consider the use of new stream IO feature in new code \n+for future portability. See also @ref{Fortran 2003 status}.\n+\n @item @emph{Standard}:\n GNU extension\n \n @item @emph{Class}:\n+Non-elemental subroutine\n+\n @item @emph{Syntax}:\n+@code{CALL fgetc(UNIT,C[,STATUS])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n+@multitable @columnfractions .15 .80\n+@item @var{UNIT}   @tab The type shall be @code{INTEGER}.\n+@item @var{C}      @tab The type shall be @code{CHARACTER}.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}. Returns 0 on success,\n+                        -1 on end-of-file and a system specific positive error code otherwise.\n+@end multitable\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_fgetc\n+  INTEGER :: fd = 42, status\n+  CHARACTER :: c\n+\n+  OPEN(UNIT=fd, FILE=\"/etc/passwd\", ACTION=\"READ\", STATUS = \"OLD\")\n+  DO\n+    CALL fgetc(fd, c, status)\n+    IF (status /= 0) EXIT\n+    call fput(c)\n+  END DO\n+  CLOSE(UNIT=fd)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{FGET}, @ref{FPUT}, @ref{FPUTC}\n @end table\n \n \n+\n @node FLOOR\n @section @code{FLOOR} --- Integer floor function\n @findex @code{FLOOR} intrinsic\n@@ -3362,7 +3524,7 @@ statement that should be preferred over the @code{FLUSH} intrinsic.\n \n @table @asis\n @item @emph{Description}:\n-@code{FNUM(UNIT)} returns the Posix file descriptor number corresponding to the\n+@code{FNUM(UNIT)} returns the POSIX file descriptor number corresponding to the\n open Fortran I/O unit @code{UNIT}.\n \n @item @emph{Standard}:\n@@ -3397,47 +3559,105 @@ end program test_fnum\n \n \n @node FPUT\n-@section @code{FPUT} --- Write a single character to stdout in stream mode\n+@section @code{FPUT} --- Write a single character in stream mode to stdout \n @findex @code{FPUT} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@cindex file operations\n+@cindex stream operations\n \n @table @asis\n @item @emph{Description}:\n+Write a single character in stream mode to stdout by bypassing normal \n+formatted output. Stream I/O should not be mixed with normal record-oriented \n+(formatted or unformatted) I/O on the same unit; the results are unpredictable.\n+\n+This intrinsic routine is provided for backwards compatibility with \n+GNU Fortran 77.  @command{Gfortran} provides the Fortran 2003 Stream facility.\n+Programmers should consider the use of new stream IO feature in new code \n+for future portability. See also @ref{Fortran 2003 status}.\n+\n @item @emph{Standard}:\n GNU extension\n \n @item @emph{Class}:\n+Non-elemental subroutine\n+\n @item @emph{Syntax}:\n+@code{CALL fput(C[,STATUS])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n+@multitable @columnfractions .15 .80\n+@item @var{C}      @tab The type shall be @code{CHARACTER}.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}. Returns 0 on success,\n+                        -1 on end-of-file and a system specific positive error code otherwise.\n+@end multitable\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_fput\n+  CHARACTER(len=*) :: str = \"gfortran\"\n+  INTEGER :: i\n+  DO i = 1, len_trim(str)\n+    CALL fput(str(i:i))\n+  END DO\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{FPUTC}, @ref{FGET}, @ref{FGETC}\n @end table\n \n \n \n @node FPUTC\n @section @code{FPUTC} --- Write a single character in stream mode\n @findex @code{FPUTC} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@cindex file operations\n+@cindex stream operations\n \n @table @asis\n @item @emph{Description}:\n+Write a single character in stream mode by bypassing normal formatted \n+output. Stream I/O should not be mixed with normal record-oriented \n+(formatted or unformatted) I/O on the same unit; the results are unpredictable.\n+\n+This intrinsic routine is provided for backwards compatibility with \n+GNU Fortran 77.  @command{Gfortran} provides the Fortran 2003 Stream facility.\n+Programmers should consider the use of new stream IO feature in new code \n+for future portability. See also @ref{Fortran 2003 status}.\n+\n @item @emph{Standard}:\n GNU extension\n \n @item @emph{Class}:\n+Non-elemental subroutine\n+\n @item @emph{Syntax}:\n+@code{CALL fputc(UNIT,C[,STATUS])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n+@multitable @columnfractions .15 .80\n+@item @var{UNIT}   @tab The type shall be @code{INTEGER}.\n+@item @var{C}      @tab The type shall be @code{CHARACTER}.\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER}. Returns 0 on success,\n+                        -1 on end-of-file and a system specific positive error code otherwise.\n+@end multitable\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_fputc\n+  CHARACTER(len=*) :: str = \"gfortran\"\n+  INTEGER :: fd = 42, i\n+\n+  OPEN(UNIT = fd, FILE = \"out\", ACTION = \"WRITE\", STATUS=\"NEW\")\n+  DO i = 1, len_trim(str)\n+    CALL fputc(fd, str(i:i))\n+  END DO\n+  CLOSE(fd)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{FPUT}, @ref{FGET}, @ref{FGETC}\n @end table\n \n \n@@ -3674,22 +3894,39 @@ F2003\n @node GETCWD\n @section @code{GETCWD} --- Get current working directory\n @findex @code{GETCWD} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@cindex file system functions\n \n @table @asis\n @item @emph{Description}:\n+Get current working directory.\n+\n @item @emph{Standard}:\n GNU extension\n \n @item @emph{Class}:\n+Non-elemental subroutine.\n+\n @item @emph{Syntax}:\n+@code{CALL getcwd(CWD[,STATUS])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n+@multitable @columnfractions .15 .80\n+@item @var{CWD}    @tab The type shall be @code{CHARACTER(*)}.\n+@item @var{STATUS} @tab (Optional) status flag. Returns 0 on success, \n+                        a system specific and non-zero error code otherwise.\n+@end multitable\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_getcwd\n+  CHARACTER(len=255) :: cwd\n+  CALL getcwd(cwd)\n+  WRITE(*,*) TRIM(cwd)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{CHDIR}\n @end table\n \n \n@@ -5642,31 +5879,6 @@ end program test_nearest\n \n \n \n-@node NEQV\n-@section @code{NEQV} --- Logical non-equivalence\n-@findex @code{NEQV} intrinsic\n-@cindex logical operations\n-\n-Intrinsic implemented, documentation pending.\n-\n-@table @asis\n-@item @emph{Description}:\n-@item @emph{Standard}:\n-F77 and later\n-\n-@item @emph{Class}:\n-@item @emph{Syntax}:\n-@item @emph{Arguments}:\n-@item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n-@item @emph{See also}:\n-@ref{EQV}\n-@end table\n-\n-\n-\n-\n @node NINT\n @section @code{NINT} --- Nearest whole number\n @findex @code{NINT} intrinsic\n@@ -5745,7 +5957,7 @@ Elemental function\n \n \n @node NULL\n-@section @code{NULL} --- Function that returns an dissassociated pointer\n+@section @code{NULL} --- Function that returns an disassociated pointer\n @findex @code{NULL} intrinsic\n @cindex undocumented intrinsic \n \n@@ -5771,23 +5983,51 @@ Transformational function\n \n \n @node OR\n-@section @code{OR} --- Logical inclusive disjunction\n+@section @code{OR} --- Bitwise logical OR\n @findex @code{OR} intrinsic\n-@cindex logical operations\n-\n-Intrinsic implemented, documentation pending.\n+@cindex bit operations\n \n @table @asis\n @item @emph{Description}:\n+Bitwise logical @code{OR}.\n+\n+This intrinsic routine is provided for backwards compatibility with \n+GNU Fortran 77.  For integer arguments, programmers should consider\n+the use of the @ref{IOR} intrinsic defined by the Fortran standard.\n+\n @item @emph{Standard}:\n-F77 and later\n+GNU extension\n \n @item @emph{Class}:\n+Non-elemental function\n+\n @item @emph{Syntax}:\n+@code{RESULT = OR(X, Y)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@item @var{Y} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return type is either @code{INTEGER(*)} or @code{LOGICAL} \n+after cross-promotion of the arguments.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_or\n+  LOGICAL :: T = .TRUE., F = ..FALSE.\n+  INTEGER :: a, b\n+  DATA a / Z'F' /, b / Z'3' /\n+\n+  WRITE (*,*) OR(T, T), OR(T, F), OR(F, T), OR(F, F)\n+  WRITE (*,*) OR(a, b)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+F95 elemental function: @ref{IOR}\n @end table\n \n \n@@ -7549,27 +7789,52 @@ Elemental function\n @end table\n \n \n-\n-\n @node XOR\n-@section @code{XOR} --- Logical exclusive or\n+@section @code{XOR} --- Bitwise logical exclusive OR\n @findex @code{XOR} intrinsic\n-@cindex logical operations\n-\n-Intrinsic implemented, documentation pending.\n+@cindex bit operations\n \n @table @asis\n @item @emph{Description}:\n+Bitwise logical exclusive or. \n+\n+This intrinsic routine is provided for backwards compatibility with \n+GNU Fortran 77.  For integer arguments, programmers should consider\n+the use of the @ref{IEOR} intrinsic defined by the Fortran standard.\n+\n @item @emph{Standard}:\n-F77 and later\n+GNU extension\n \n @item @emph{Class}:\n+Non-elemental function\n+\n @item @emph{Syntax}:\n+@code{RESULT = XOR(X, Y)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@item @var{Y} @tab The type shall be either @code{INTEGER(*)} or @code{LOGICAL}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return type is either @code{INTEGER(*)} or @code{LOGICAL}\n+after cross-promotion of the arguments.\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_xor\n+  LOGICAL :: T = .TRUE., F = .FALSE.\n+  INTEGER :: a, b\n+  DATA a / Z,'F' /, b / Z'3' /\n+\n+  WRITE (*,*) XOR(T, T), XOR(T, F), XOR(F, T), XOR(F, F)\n+  WRITE (*,*) XOR(a, b)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+F95 elemental function: @ref{IEOR}\n @end table\n \n "}]}