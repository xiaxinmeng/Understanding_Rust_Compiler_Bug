{"sha": "f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlkMGNhNDA0M2U0YzQzMDMyNGE2NTVmZGNlM2Y4ZTRhY2VmZTVlMw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2019-08-05T20:04:22Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2019-08-05T20:04:22Z"}, "message": "cp-tree.h (cp_expr_loc_or_input_loc): New.\n\n2019-08-05  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* cp-tree.h (cp_expr_loc_or_input_loc): New.\n\t(cxx_incomplete_type_diagnostic): Use it.\n\t* call.c (build_converted_constant_expr_internal, convert_like_real,\n\tconvert_arg_to_ellipsis, convert_for_arg_passing, build_over_call,\n\tbuild_cxx_call, perform_implicit_conversion_flags,\n\tinitialize_reference): Likewise.\n\t* constexpr.c (cxx_eval_internal_function, cxx_eval_call_expression,\n\teval_and_check_array_index, cxx_eval_store_expression,\n\tcxx_eval_statement_list, cxx_eval_loop_expr,\n\tcxx_eval_constant_expression, potential_constant_expression_1):\n\tLikewise.\n\t* constraint.cc (check_for_logical_overloads,\n\tsatisfy_predicate_constraint): Likewise.\n\t* cp-gimplify.c (cp_gimplify_expr): Likewise.\n\t* cvt.c (cp_convert_to_pointer, convert_to_reference,\n\tcp_convert_and_check, ocp_convert, maybe_warn_nodiscard): Likewise.\n\t* decl.c (pop_switch): Likewise.\n\t* decl2.c (delete_sanity): Likewise.\n\t* error.c (location_of): Likewise.\n\t* init.c (maybe_warn_list_ctor, build_aggr_init,\n\twarn_placement_new_too_small, build_new_1, build_vec_init): Likewise.\n\t* lex.c (unqualified_name_lookup_error): Likewise.\n\t* parser.c (cp_parser_initializer_list, cp_parser_omp_for_cond):\n\tLikewise.\n\t* pt.c (check_for_bare_parameter_packs, check_valid_ptrmem_cst_expr,\n\tunify_arg_conversion, convert_nontype_argument,\n\ttsubst_copy_and_build, resolve_typename_type): Likewise.\n\t* semantics.c (maybe_convert_cond, finish_call_expr,\n\tcp_build_vec_convert): Likewise.\n\t* typeck.c (decay_conversion, rationalize_conditional_expr,\n\tcp_build_unary_op, build_x_compound_expr_from_list,\n\tmaybe_warn_about_returning_address_of_local,\n\tmaybe_warn_pessimizing_move): Likewise.\n\t* typeck2.c (check_narrowing, digest_init_r,\n\tprocess_init_constructor_array): Likewise.\n\nFrom-SVN: r274124", "tree": {"sha": "0541c9ce78b9a30a4cdc2e9ec7218804de09b9aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0541c9ce78b9a30a4cdc2e9ec7218804de09b9aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/comments", "author": null, "committer": null, "parents": [{"sha": "8744c37d540324b96e055e467b4967032b269c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8744c37d540324b96e055e467b4967032b269c16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8744c37d540324b96e055e467b4967032b269c16"}], "stats": {"total": 189, "additions": 115, "deletions": 74}, "files": [{"sha": "6427c2dac86d6e8ca7a615ef7d7191c73fc1d526", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -1,3 +1,41 @@\n+2019-08-05  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* cp-tree.h (cp_expr_loc_or_input_loc): New.\n+\t(cxx_incomplete_type_diagnostic): Use it.\n+\t* call.c (build_converted_constant_expr_internal, convert_like_real,\n+\tconvert_arg_to_ellipsis, convert_for_arg_passing, build_over_call,\n+\tbuild_cxx_call, perform_implicit_conversion_flags,\n+\tinitialize_reference): Likewise.\n+\t* constexpr.c (cxx_eval_internal_function, cxx_eval_call_expression,\n+\teval_and_check_array_index, cxx_eval_store_expression,\n+\tcxx_eval_statement_list, cxx_eval_loop_expr,\n+\tcxx_eval_constant_expression, potential_constant_expression_1):\n+\tLikewise.\n+\t* constraint.cc (check_for_logical_overloads,\n+\tsatisfy_predicate_constraint): Likewise.\n+\t* cp-gimplify.c (cp_gimplify_expr): Likewise.\n+\t* cvt.c (cp_convert_to_pointer, convert_to_reference,\n+\tcp_convert_and_check, ocp_convert, maybe_warn_nodiscard): Likewise.\n+\t* decl.c (pop_switch): Likewise.\n+\t* decl2.c (delete_sanity): Likewise.\n+\t* error.c (location_of): Likewise.\n+\t* init.c (maybe_warn_list_ctor, build_aggr_init,\n+\twarn_placement_new_too_small, build_new_1, build_vec_init): Likewise.\n+\t* lex.c (unqualified_name_lookup_error): Likewise.\n+\t* parser.c (cp_parser_initializer_list, cp_parser_omp_for_cond):\n+\tLikewise.\n+\t* pt.c (check_for_bare_parameter_packs, check_valid_ptrmem_cst_expr,\n+\tunify_arg_conversion, convert_nontype_argument,\n+\ttsubst_copy_and_build, resolve_typename_type): Likewise.\n+\t* semantics.c (maybe_convert_cond, finish_call_expr,\n+\tcp_build_vec_convert): Likewise.\n+\t* typeck.c (decay_conversion, rationalize_conditional_expr,\n+\tcp_build_unary_op, build_x_compound_expr_from_list,\n+\tmaybe_warn_about_returning_address_of_local,\n+\tmaybe_warn_pessimizing_move): Likewise.\n+\t* typeck2.c (check_narrowing, digest_init_r,\n+\tprocess_init_constructor_array): Likewise.\n+\n 2019-08-05  Tom Honermann  <tom@honermann.net>\n \n \t* parser.c (cp_parser_template_declaration_after_parameters): Enable"}, {"sha": "61334a16248b2f26302781302ab19ae9eb1bb125", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -4184,7 +4184,7 @@ build_converted_constant_expr_internal (tree type, tree expr,\n   conversion *conv;\n   void *p;\n   tree t;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   if (error_operand_p (expr))\n     return error_mark_node;\n@@ -6961,7 +6961,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n   tree totype = convs->type;\n   diagnostic_t diag_kind;\n   int flags;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   if (convs->bad_p && !(complain & tf_error))\n     return error_mark_node;\n@@ -7481,7 +7481,7 @@ tree\n convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n {\n   tree arg_type;\n-  location_t loc = cp_expr_loc_or_loc (arg, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (arg);\n \n   /* [expr.call]\n \n@@ -7789,7 +7789,7 @@ convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n \t\t     \"argument of function call might be a candidate \"\n \t\t     \"for a format attribute\");\n \t}\n-      maybe_warn_parm_abi (type, cp_expr_loc_or_loc (val, input_location));\n+      maybe_warn_parm_abi (type, cp_expr_loc_or_input_loc (val));\n     }\n \n   if (complain & tf_warning)\n@@ -8595,7 +8595,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       tree type = TREE_TYPE (to);\n       tree as_base = CLASSTYPE_AS_BASE (type);\n       tree arg = argarray[1];\n-      location_t loc = cp_expr_loc_or_loc (arg, input_location);\n+      location_t loc = cp_expr_loc_or_input_loc (arg);\n \n       if (is_really_empty_class (type, /*ignore_vptr*/true))\n \t{\n@@ -9143,7 +9143,7 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n   tree fndecl;\n \n   /* Remember roughly where this call is.  */\n-  location_t loc = cp_expr_loc_or_loc (fn, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (fn);\n   fn = build_call_a (fn, nargs, argarray);\n   SET_EXPR_LOCATION (fn, loc);\n \n@@ -11183,7 +11183,7 @@ perform_implicit_conversion_flags (tree type, tree expr,\n {\n   conversion *conv;\n   void *p;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   if (TYPE_REF_P (type))\n     expr = mark_lvalue_use (expr);\n@@ -11532,7 +11532,7 @@ initialize_reference (tree type, tree expr,\n {\n   conversion *conv;\n   void *p;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;"}, {"sha": "75df9844dc6cee3469ac03328399636deabea23d", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -1527,7 +1527,7 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n \n     default:\n       if (!ctx->quiet)\n-\terror_at (cp_expr_loc_or_loc (t, input_location),\n+\terror_at (cp_expr_loc_or_input_loc (t),\n \t\t  \"call to internal function %qE\", t);\n       *non_constant_p = true;\n       return t;\n@@ -1542,7 +1542,7 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n \n   if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n     {\n-      location_t loc = cp_expr_loc_or_loc (t, input_location);\n+      location_t loc = cp_expr_loc_or_input_loc (t);\n       tree type = TREE_TYPE (TREE_TYPE (t));\n       tree result = fold_binary_loc (loc, opcode, type,\n \t\t\t\t     fold_convert_loc (loc, type, arg0),\n@@ -1584,7 +1584,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t  bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n-  location_t loc = cp_expr_loc_or_loc (t, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (t);\n   tree fun = get_function_named_in_call (t);\n   constexpr_call new_call\n     = { NULL, NULL, NULL, 0, ctx->manifestly_const_eval };\n@@ -2580,7 +2580,7 @@ eval_and_check_array_index (const constexpr_ctx *ctx,\n \t\t\t    tree t, bool allow_one_past,\n \t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n-  location_t loc = cp_expr_loc_or_loc (t, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (t);\n   tree ary = TREE_OPERAND (t, 0);\n   t = TREE_OPERAND (t, 1);\n   tree index = cxx_eval_constant_expression (ctx, t, false,\n@@ -3909,7 +3909,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t      if (cxx_dialect < cxx2a)\n \t\t{\n \t\t  if (!ctx->quiet)\n-\t\t    error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t    error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t      \"change of the active member of a union \"\n \t\t\t      \"from %qD to %qD\",\n \t\t\t      CONSTRUCTOR_ELT (*valp, 0)->index,\n@@ -4220,7 +4220,7 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n       /* We aren't communicating the jump to our caller, so give up.  We don't\n \t need to support evaluation of jumps out of statement-exprs.  */\n       if (!ctx->quiet)\n-\terror_at (cp_expr_loc_or_loc (r, input_location),\n+\terror_at (cp_expr_loc_or_input_loc (r),\n \t\t  \"statement is not a constant expression\");\n       *non_constant_p = true;\n     }\n@@ -4320,7 +4320,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n       if (++count >= constexpr_loop_limit)\n \t{\n \t  if (!ctx->quiet)\n-\t    error_at (cp_expr_loc_or_loc (t, input_location),\n+\t    error_at (cp_expr_loc_or_input_loc (t),\n \t\t      \"%<constexpr%> loop iteration count exceeds limit of %d \"\n \t\t      \"(use %<-fconstexpr-loop-limit=%> to increase the limit)\",\n \t\t      constexpr_loop_limit);\n@@ -4482,7 +4482,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n   if (++*ctx->constexpr_ops_count >= constexpr_ops_limit)\n     {\n       if (!ctx->quiet)\n-\terror_at (cp_expr_loc_or_loc (t, input_location),\n+\terror_at (cp_expr_loc_or_input_loc (t),\n \t\t  \"%<constexpr%> evaluation operation count exceeds limit of \"\n \t\t  \"%wd (use %<-fconstexpr-ops-limit=%> to increase the limit)\",\n \t\t  constexpr_ops_limit);\n@@ -5036,7 +5036,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       if (REINTERPRET_CAST_P (t))\n \t{\n \t  if (!ctx->quiet)\n-\t    error_at (cp_expr_loc_or_loc (t, input_location),\n+\t    error_at (cp_expr_loc_or_input_loc (t),\n \t\t      \"%<reinterpret_cast%> is not a constant expression\");\n \t  *non_constant_p = true;\n \t  return t;\n@@ -5077,7 +5077,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\tif (TYPE_REF_P (type))\n \t\t  {\n \t\t    if (!ctx->quiet)\n-\t\t      error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t      error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t\t\"dereferencing a null pointer\");\n \t\t    *non_constant_p = true;\n \t\t    return t;\n@@ -5089,7 +5089,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t    if (!can_convert (type, from, tf_none))\n \t\t      {\n \t\t\tif (!ctx->quiet)\n-\t\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t\t  error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t\t    \"conversion of %qT null pointer to %qT \"\n \t\t\t\t    \"is not a constant expression\",\n \t\t\t\t    from, type);\n@@ -5104,7 +5104,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t     reinterpret_cast<void*>(sizeof 0)\n \t\t*/\n \t\tif (!ctx->quiet)\n-\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t  error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t    \"%<reinterpret_cast<%T>(%E)%> is not \"\n \t\t\t    \"a constant expression\",\n \t\t\t    type, op);\n@@ -5178,7 +5178,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case BASELINK:\n     case OFFSET_REF:\n       if (!ctx->quiet)\n-        error_at (cp_expr_loc_or_loc (t, input_location),\n+        error_at (cp_expr_loc_or_input_loc (t),\n \t\t  \"expression %qE is not a constant expression\", t);\n       *non_constant_p = true;\n       break;\n@@ -5196,7 +5196,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    || !DECL_P (get_base_address (TREE_OPERAND (obj, 0))))\n \t  {\n \t    if (!ctx->quiet)\n-\t      error_at (cp_expr_loc_or_loc (t, input_location),\n+\t      error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t\"expression %qE is not a constant expression\", t);\n \t    *non_constant_p = true;\n \t    return t;\n@@ -5960,7 +5960,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     return false;\n   if (t == NULL_TREE)\n     return true;\n-  location_t loc = cp_expr_loc_or_loc (t, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (t);\n \n   if (*jump_target)\n     /* If we are jumping, ignore everything.  This is simpler than the"}, {"sha": "48ecb766507ac7658e86717c61b5abcbfa1cfe08", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -805,7 +805,7 @@ check_for_logical_overloads (tree t)\n \n   if (DECL_OVERLOADED_OPERATOR_P (fn))\n     {\n-      location_t loc = cp_expr_loc_or_loc (t, input_location);\n+      location_t loc = cp_expr_loc_or_input_loc (t);\n       error_at (loc, \"constraint %qE, uses overloaded operator\", t);\n       return true;\n     }\n@@ -2016,7 +2016,7 @@ satisfy_predicate_constraint (tree t, tree args,\n   tree type = cv_unqualified (TREE_TYPE (expr));\n   if (!same_type_p (type, boolean_type_node))\n     {\n-      error_at (cp_expr_loc_or_loc (expr, input_location),\n+      error_at (cp_expr_loc_or_input_loc (expr),\n                 \"constraint %qE does not have type %qT\",\n                 expr, boolean_type_node);\n       return boolean_false_node;"}, {"sha": "b4863e2d592aeba91a8a9f614dc1850cd58aa564", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -644,7 +644,7 @@ int\n cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   int saved_stmts_are_full_exprs_p = 0;\n-  location_t loc = cp_expr_loc_or_loc (*expr_p, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (*expr_p);\n   enum tree_code code = TREE_CODE (*expr_p);\n   enum gimplify_status ret;\n "}, {"sha": "d4e67cdfd96f7e8bc224de1d0ceac87d0bf13f25", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -7509,11 +7509,17 @@ cp_expr_loc_or_loc (const_tree t, location_t or_loc)\n   return loc;\n }\n \n+inline location_t\n+cp_expr_loc_or_input_loc (const_tree t)\n+{\n+  return cp_expr_loc_or_loc (t, input_location);\n+}\n+\n inline void\n cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n \t\t\t\tdiagnostic_t diag_kind)\n {\n-  cxx_incomplete_type_diagnostic (cp_expr_loc_or_loc (value, input_location),\n+  cxx_incomplete_type_diagnostic (cp_expr_loc_or_input_loc (value),\n \t\t\t\t  value, type, diag_kind);\n }\n "}, {"sha": "364af72e68d46d540858a643c504b884b1b999ce", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -77,7 +77,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n   tree intype = TREE_TYPE (expr);\n   enum tree_code form;\n   tree rval;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   if (intype == error_mark_node)\n     return error_mark_node;\n@@ -419,7 +419,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   tree rval = NULL_TREE;\n   tree rval_as_conversion = NULL_TREE;\n   bool can_convert_intype_to_type;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       && TREE_TYPE (expr) == unknown_type_node)\n@@ -671,7 +671,7 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n       folded_result = fold_simple (folded_result);\n       if (!TREE_OVERFLOW_P (folded)\n \t  && folded_result != error_mark_node)\n-\twarnings_for_convert_and_check (cp_expr_loc_or_loc (expr, input_location),\n+\twarnings_for_convert_and_check (cp_expr_loc_or_input_loc (expr),\n \t\t\t\t\ttype, folded, folded_result);\n     }\n \n@@ -690,7 +690,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n   enum tree_code code = TREE_CODE (type);\n   const char *invalid_conv_diag;\n   tree e1;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n   bool dofold = (convtype & CONV_FOLD);\n \n   if (error_operand_p (e) || type == error_mark_node)\n@@ -1013,7 +1013,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n   tree call = expr;\n   if (TREE_CODE (expr) == TARGET_EXPR)\n     call = TARGET_EXPR_INITIAL (expr);\n-  location_t loc = cp_expr_loc_or_loc (call, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (call);\n   tree callee = cp_get_callee (call);\n   if (!callee)\n     return;\n@@ -1093,7 +1093,7 @@ maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n tree\n convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n {\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   if (expr == error_mark_node\n       || TREE_TYPE (expr) == error_mark_node)"}, {"sha": "5dda2e8e33d6c33cf7f8292a5f9b65b25aa747a0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -3560,7 +3560,7 @@ pop_switch (void)\n   location_t switch_location;\n \n   /* Emit warnings as needed.  */\n-  switch_location = cp_expr_loc_or_loc (cs->switch_stmt, input_location);\n+  switch_location = cp_expr_loc_or_input_loc (cs->switch_stmt);\n   const bool bool_cond_p\n     = (SWITCH_STMT_TYPE (cs->switch_stmt)\n        && TREE_CODE (SWITCH_STMT_TYPE (cs->switch_stmt)) == BOOLEAN_TYPE);"}, {"sha": "ad2459236b804a7508738f64b30f2066f4831880", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -489,15 +489,15 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete,\n   /* An array can't have been allocated by new, so complain.  */\n   if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n       && (complain & tf_warning))\n-    warning_at (cp_expr_loc_or_loc (exp, input_location), 0,\n+    warning_at (cp_expr_loc_or_input_loc (exp), 0,\n \t\t\"deleting array %q#E\", exp);\n \n   t = build_expr_type_conversion (WANT_POINTER, exp, true);\n \n   if (t == NULL_TREE || t == error_mark_node)\n     {\n       if (complain & tf_error)\n-\terror_at (cp_expr_loc_or_loc (exp, input_location),\n+\terror_at (cp_expr_loc_or_input_loc (exp),\n \t\t  \"type %q#T argument given to %<delete%>, expected pointer\",\n \t\t  TREE_TYPE (exp));\n       return error_mark_node;\n@@ -511,7 +511,7 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete,\n   if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n       if (complain & tf_error)\n-\terror_at (cp_expr_loc_or_loc (exp, input_location),\n+\terror_at (cp_expr_loc_or_input_loc (exp),\n \t\t  \"cannot delete a function.  Only pointer-to-objects are \"\n \t\t  \"valid arguments to %<delete%>\");\n       return error_mark_node;\n@@ -521,8 +521,7 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete,\n   if (VOID_TYPE_P (TREE_TYPE (type)))\n     {\n       if (complain & tf_warning)\n-\twarning_at (cp_expr_loc_or_loc (exp, input_location),\n-\t\t    OPT_Wdelete_incomplete,\n+\twarning_at (cp_expr_loc_or_input_loc (exp), OPT_Wdelete_incomplete,\n \t\t    \"deleting %qT is undefined\", type);\n       doing_vec = 0;\n     }"}, {"sha": "56201345429c902cc272c4bf1891b1f188a9b37e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -3053,7 +3053,7 @@ location_of (tree t)\n     return DECL_SOURCE_LOCATION (t);\n   if (TREE_CODE (t) == DEFERRED_PARSE)\n     return defparse_location (t);\n-  return cp_expr_loc_or_loc (t, input_location);\n+  return cp_expr_loc_or_input_loc (t);\n }\n \n /* Now the interfaces from error et al to dump_type et al. Each takes an"}, {"sha": "67e06568b2f3fcdfc7f3978f43c7accda2c36e1e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -749,7 +749,7 @@ maybe_warn_list_ctor (tree member, tree init)\n   if (!begin)\n     return;\n \n-  location_t loc = cp_expr_loc_or_loc (init, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (init);\n   warning_at (loc, OPT_Winit_list_lifetime,\n \t     \"initializing %qD from %qE does not extend the lifetime \"\n \t     \"of the underlying array\", member, begin);\n@@ -1749,7 +1749,7 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n     return error_mark_node;\n \n   location_t init_loc = (init\n-\t\t\t ? cp_expr_loc_or_loc (init, input_location)\n+\t\t\t ? cp_expr_loc_or_input_loc (init)\n \t\t\t : location_of (exp));\n \n   TREE_READONLY (exp) = 0;\n@@ -2578,7 +2578,7 @@ find_flexarray_init (tree t, tree init)\n static void\n warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n {\n-  location_t loc = cp_expr_loc_or_loc (oper, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (oper);\n \n   /* The number of bytes to add to or subtract from the size of the provided\n      buffer based on an offset into an array or an array element reference.\n@@ -2975,7 +2975,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t{\n \t  if (complain & tf_error)\n \t    {\n-\t      error_at (cp_expr_loc_or_loc (inner_nelts, input_location),\n+\t      error_at (cp_expr_loc_or_input_loc (inner_nelts),\n \t\t\t\"array size in new-expression must be constant\");\n \t      cxx_constant_value(inner_nelts);\n \t    }\n@@ -3004,7 +3004,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n     {\n       if (complain & tf_warning_or_error)\n \t{\n-\t  pedwarn (cp_expr_loc_or_loc (outer_nelts, input_location), OPT_Wvla,\n+\t  pedwarn (cp_expr_loc_or_input_loc (outer_nelts), OPT_Wvla,\n \t\t   typedef_variant_p (orig_type)\n \t\t   ? G_(\"non-constant array new length must be specified \"\n \t\t\t\"directly, not by %<typedef%>\")\n@@ -4140,7 +4140,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   tree obase = base;\n   bool xvalue = false;\n   bool errors = false;\n-  location_t loc = (init ? cp_expr_loc_or_loc (init, input_location)\n+  location_t loc = (init ? cp_expr_loc_or_input_loc (init)\n \t\t    : location_of (base));\n \n   if (TREE_CODE (atype) == ARRAY_TYPE && TYPE_DOMAIN (atype))"}, {"sha": "12567da39c4fb454606a7e6f0726e4a2753b4371", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -502,7 +502,7 @@ tree\n unqualified_name_lookup_error (tree name, location_t loc)\n {\n   if (loc == UNKNOWN_LOCATION)\n-    loc = cp_expr_loc_or_loc (name, input_location);\n+    loc = cp_expr_loc_or_input_loc (name);\n \n   if (IDENTIFIER_ANY_OP_P (name))\n     error_at (loc, \"%qD not defined\", name);"}, {"sha": "86857e7d46821fa209e172d9013b47e4461fca3d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -23186,7 +23186,7 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p,\n \t  {\n \t    if (IDENTIFIER_MARKED (designator))\n \t      {\n-\t\terror_at (cp_expr_loc_or_loc (val, input_location),\n+\t\terror_at (cp_expr_loc_or_input_loc (val),\n \t\t\t  \"%<.%s%> designator used multiple times in \"\n \t\t\t  \"the same initializer list\",\n \t\t\t  IDENTIFIER_POINTER (designator));\n@@ -36699,7 +36699,7 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n \t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n     return cond;\n \n-  return build_x_binary_op (cp_expr_loc_or_loc (cond, input_location),\n+  return build_x_binary_op (cp_expr_loc_or_input_loc (cond),\n \t\t\t    TREE_CODE (cond),\n \t\t\t    TREE_OPERAND (cond, 0), ERROR_MARK,\n \t\t\t    TREE_OPERAND (cond, 1), ERROR_MARK,"}, {"sha": "e671fe1a91d514b034e572bf926f0d50d7412516", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -4059,7 +4059,7 @@ check_for_bare_parameter_packs (tree t, location_t loc /* = UNKNOWN_LOCATION */)\n   if (parameter_packs)\n     {\n       if (loc == UNKNOWN_LOCATION)\n-\tloc = cp_expr_loc_or_loc (t, input_location);\n+\tloc = cp_expr_loc_or_input_loc (t);\n       error_at (loc, \"parameter packs not expanded with %<...%>:\");\n       while (parameter_packs)\n         {\n@@ -6306,7 +6306,7 @@ static bool\n check_valid_ptrmem_cst_expr (tree type, tree expr,\n \t\t\t     tsubst_flags_t complain)\n {\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n   tree orig_expr = expr;\n   STRIP_NOPS (expr);\n   if (null_ptr_cst_p (expr))\n@@ -6525,7 +6525,7 @@ unify_arg_conversion (bool explain_p, tree to_type,\n \t\t      tree from_type, tree arg)\n {\n   if (explain_p)\n-    inform (cp_expr_loc_or_loc (arg, input_location),\n+    inform (cp_expr_loc_or_input_loc (arg),\n \t    \"  cannot convert %qE (type %qT) to type %qT\",\n \t    arg, from_type, to_type);\n   return unify_invalid (explain_p);\n@@ -6765,7 +6765,7 @@ static tree\n convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree expr_type;\n-  location_t loc = cp_expr_loc_or_loc (expr, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (expr);\n \n   /* Detect immediately string literals as invalid non-type argument.\n      This special-case is not needed for correctness (we would easily\n@@ -18965,10 +18965,10 @@ tsubst_copy_and_build (tree t,\n \n \t\t    bool diag = true;\n \t\t    if (in_lambda)\n-\t\t      error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t      error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t\tmsg, function);\n \t\t    else\n-\t\t      diag = permerror (cp_expr_loc_or_loc (t, input_location),\n+\t\t      diag = permerror (cp_expr_loc_or_input_loc (t),\n \t\t\t\t\tmsg, function);\n \t\t    if (diag)\n \t\t      {\n@@ -18983,8 +18983,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t  /* Can't say anything more.  */;\n \t\t\telse if (DECL_CLASS_SCOPE_P (fn))\n \t\t\t  {\n-\t\t\t    location_t loc = cp_expr_loc_or_loc (t,\n-\t\t\t\t\t\t\t      input_location);\n+\t\t\t    location_t loc = cp_expr_loc_or_input_loc (t);\n \t\t\t    inform (loc,\n \t\t\t\t    \"declarations in dependent base %qT are \"\n \t\t\t\t    \"not found by unqualified lookup\",\n@@ -19032,22 +19031,21 @@ tsubst_copy_and_build (tree t,\n \t      gcc_assert (nargs == 1);\n \t      if (vec_safe_length (call_args) != 1)\n \t\t{\n-\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t  error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t    \"wrong number of arguments to \"\n \t\t\t    \"%<__builtin_launder%>\");\n \t\t  ret = error_mark_node;\n \t\t}\n \t      else\n-\t\tret = finish_builtin_launder (cp_expr_loc_or_loc (t,\n-\t\t\t\t\t\t\t       input_location),\n+\t\tret = finish_builtin_launder (cp_expr_loc_or_input_loc (t),\n \t\t\t\t\t      (*call_args)[0], complain);\n \t      break;\n \n \t    case IFN_VEC_CONVERT:\n \t      gcc_assert (nargs == 1);\n \t      if (vec_safe_length (call_args) != 1)\n \t\t{\n-\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t  error_at (cp_expr_loc_or_input_loc (t),\n \t\t\t    \"wrong number of arguments to \"\n \t\t\t    \"%<__builtin_convertvector%>\");\n \t\t  ret = error_mark_node;\n@@ -26602,7 +26600,7 @@ resolve_typename_type (tree type, bool only_current_p)\n \n \t     [temp.names]: In a qualified-id of a declarator-id, the keyword\n \t     template shall not appear at the top level.  */\n-\t  pedwarn (cp_expr_loc_or_loc (fullname, input_location), OPT_Wpedantic,\n+\t  pedwarn (cp_expr_loc_or_input_loc (fullname), OPT_Wpedantic,\n \t\t   \"keyword %<template%> not allowed in declarator-id\");\n \t  tmpl = decl;\n \t}"}, {"sha": "d151d3d47986111b4a58cffcc87ad1ed245cb11f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -658,7 +658,7 @@ maybe_convert_cond (tree cond)\n   if (TREE_CODE (cond) == MODIFY_EXPR\n       && !TREE_NO_WARNING (cond)\n       && warn_parentheses\n-      && warning_at (cp_expr_loc_or_loc (cond, input_location),\n+      && warning_at (cp_expr_loc_or_input_loc (cond),\n \t\t     OPT_Wparentheses, \"suggest parentheses around \"\n \t\t\t\t       \"assignment used as truth value\"))\n     TREE_NO_WARNING (cond) = 1;\n@@ -2428,7 +2428,7 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t  || any_type_dependent_arguments_p (*args))\n \t{\n \t  result = build_min_nt_call_vec (orig_fn, *args);\n-\t  SET_EXPR_LOCATION (result, cp_expr_loc_or_loc (fn, input_location));\n+\t  SET_EXPR_LOCATION (result, cp_expr_loc_or_input_loc (fn));\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n \t  if (is_overloaded_fn (fn))\n \t    fn = get_fns (fn);\n@@ -10104,7 +10104,7 @@ cp_build_vec_convert (tree arg, location_t loc, tree type,\n \n   tree ret = NULL_TREE;\n   if (!type_dependent_expression_p (arg) && !dependent_type_p (type))\n-    ret = c_build_vec_convert (cp_expr_loc_or_loc (arg, input_location), arg,\n+    ret = c_build_vec_convert (cp_expr_loc_or_input_loc (arg), arg,\n \t\t\t       loc, type, (complain & tf_error) != 0);\n \n   if (!processing_template_decl)"}, {"sha": "7e4ea3bee75bed9666bfe0fc329ae400be069710", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -2020,7 +2020,7 @@ decay_conversion (tree exp,\n {\n   tree type;\n   enum tree_code code;\n-  location_t loc = cp_expr_loc_or_loc (exp, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (exp);\n \n   type = TREE_TYPE (exp);\n   if (type == error_mark_node)\n@@ -2281,7 +2281,7 @@ static tree\n rationalize_conditional_expr (enum tree_code code, tree t,\n                               tsubst_flags_t complain)\n {\n-  location_t loc = cp_expr_loc_or_loc (t, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (t);\n \n   /* For MIN_EXPR or MAX_EXPR, fold-const.c has arranged things so that\n      the first operand is always the one to be used if both operands\n@@ -6206,7 +6206,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   tree arg = xarg;\n-  location_t location = cp_expr_loc_or_loc (arg, input_location);\n+  location_t location = cp_expr_loc_or_input_loc (arg);\n   tree argtype = 0;\n   const char *errstring = NULL;\n   tree val;\n@@ -6760,7 +6760,7 @@ build_x_compound_expr_from_list (tree list, expr_list_kind exp,\n       && !CONSTRUCTOR_IS_DIRECT_INIT (expr))\n     {\n       if (complain & tf_error)\n-\tpedwarn (cp_expr_loc_or_loc (expr, input_location), 0,\n+\tpedwarn (cp_expr_loc_or_input_loc (expr), 0,\n \t\t \"list-initializer for non-class type must not \"\n \t\t \"be parenthesized\");\n       else\n@@ -9210,7 +9210,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n {\n   tree valtype = TREE_TYPE (DECL_RESULT (current_function_decl));\n   tree whats_returned = fold_for_warn (retval);\n-  location_t loc = cp_expr_loc_or_loc (retval, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (retval);\n \n   for (;;)\n     {\n@@ -9420,7 +9420,7 @@ maybe_warn_pessimizing_move (tree retval, tree functype)\n   if (!(warn_pessimizing_move || warn_redundant_move))\n     return;\n \n-  location_t loc = cp_expr_loc_or_loc (retval, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (retval);\n \n   /* C++98 doesn't know move.  */\n   if (cxx_dialect < cxx11)"}, {"sha": "02c3ad5efb096bed95522fd9fb596bd48ed752a4", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d0ca4043e4c430324a655fdce3f8e4acefe5e3/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f9d0ca4043e4c430324a655fdce3f8e4acefe5e3", "patch": "@@ -1006,7 +1006,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain, bool const_only)\n \n   if (!ok)\n     {\n-      location_t loc = cp_expr_loc_or_loc (init, input_location);\n+      location_t loc = cp_expr_loc_or_input_loc (init);\n       if (cxx_dialect == cxx98)\n \t{\n \t  if (complain & tf_warning)\n@@ -1085,7 +1085,7 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \t\t\t\t\tcomplain))\n     return error_mark_node;\n \n-  location_t loc = cp_expr_loc_or_loc (init, input_location);\n+  location_t loc = cp_expr_loc_or_input_loc (init);\n \n   tree stripped_init = init;\n \n@@ -1402,7 +1402,7 @@ process_init_constructor_array (tree type, tree init, int nested, int flags,\n       if (nested == 2 && !domain && !vec_safe_is_empty (v))\n \t{\n \t  if (complain & tf_error)\n-\t    error_at (cp_expr_loc_or_loc (init, input_location),\n+\t    error_at (cp_expr_loc_or_input_loc (init),\n \t\t      \"initialization of flexible array member \"\n \t\t      \"in a nested context\");\n \t  return PICFLAG_ERRONEOUS;"}]}