{"sha": "47a37ce45e4feb8cd84a315353a2077c9fbda747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhMzdjZTQ1ZTRmZWI4Y2Q4NGEzMTUzNTNhMjA3N2M5ZmJkYTc0Nw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2006-11-15T16:21:58Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2006-11-15T16:21:58Z"}, "message": "i386.opt: New target option -mx87regparm.\n\n\t* config/i386/i386.opt: New target option -mx87regparm.\n\n\t* config/i386/i386.h (struct ix86_args): Add x87_nregs, x87_regno,\n\tfloat_in_x87: Add new variables. mmx_words, sse_words: Remove.\n\t(X87_REGPARM_MAX): Define.\n\n\t* config/i386/i386.c (override_options): Error out for\n\t-mx87regparm but no 80387 support.\n\t(ix86_attribute_table): Add x87regparm.\n\t(ix86_handle_cconv_attribute): Update comments for x87regparm.\n\t(ix86_comp_type_attributes): Check for mismatched x87regparm types.\n\t(ix86_function_x87regparm): New function.\n\t(ix86_function_arg_regno_p): Add X87_REGPARM_MAX 80387 floating\n\tpoint registers.\n\t(init_cumulative_args): Initialize x87_nregs and float_in_x87\n\tvariables.\n\t(function_arg_advance): Process x87_nregs and x87_regno when\n\tfloating point argument is to be passed in 80387 register.\n\t(function_arg): Pass XFmode arguments in 80387 registers for local\n\tfunctions.  Pass SFmode and DFmode arguments to local functions\n\tin 80387 registers when flag_unsafe_math_optimizations is set.\n\n\t* reg-stack.c (convert_regs_entry): Disable NaN load for\n\tstack registers that are used for argument passing.\n\n\t* doc/extend.texi: Document x87regparm function attribute.\n\t* doc/invoke.texi: Document -mx87regparm.\n\ntestsuite/ChangeLog:\n\n\t* gcc.target/i386/x87regparm-1.c: New test.\n\t* gcc.target/i386/x87regparm-2.c: New test.\n\t* gcc.target/i386/x87regparm-3.c: New test.\n\t* gcc.target/i386/x87regparm-4.c: New test.\n\nFrom-SVN: r118859", "tree": {"sha": "764fb41a529e8c99e2fdcd06f12aed4fa7003f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/764fb41a529e8c99e2fdcd06f12aed4fa7003f09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47a37ce45e4feb8cd84a315353a2077c9fbda747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a37ce45e4feb8cd84a315353a2077c9fbda747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a37ce45e4feb8cd84a315353a2077c9fbda747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a37ce45e4feb8cd84a315353a2077c9fbda747/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ab25c2d92002803f424e096520a945d67f12616f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab25c2d92002803f424e096520a945d67f12616f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab25c2d92002803f424e096520a945d67f12616f"}], "stats": {"total": 344, "additions": 315, "deletions": 29}, "files": [{"sha": "eb0dd2e39c8f347405f05a0adecf541aec336dc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -1,3 +1,33 @@\n+2006-11-15  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.opt: New target option -mx87regparm.\n+\n+\t* config/i386/i386.h (struct ix86_args): Add x87_nregs, x87_regno,\n+\tfloat_in_x87: Add new variables. mmx_words, sse_words: Remove.\n+\t(X87_REGPARM_MAX): Define.\n+\n+\t* config/i386/i386.c (override_options): Error out for\n+\t-mx87regparm but no 80387 support.\n+\t(ix86_attribute_table): Add x87regparm.\n+\t(ix86_handle_cconv_attribute): Update comments for x87regparm.\n+\t(ix86_comp_type_attributes): Check for mismatched x87regparm types.\n+\t(ix86_function_x87regparm): New function.\n+\t(ix86_function_arg_regno_p): Add X87_REGPARM_MAX 80387 floating\n+\tpoint registers.\n+\t(init_cumulative_args): Initialize x87_nregs and float_in_x87\n+\tvariables.\n+\t(function_arg_advance): Process x87_nregs and x87_regno when\n+\tfloating point argument is to be passed in 80387 register.\n+\t(function_arg): Pass XFmode arguments in 80387 registers for local\n+\tfunctions.  Pass SFmode and DFmode arguments to local functions\n+\tin 80387 registers when flag_unsafe_math_optimizations is set.\n+\n+\t* reg-stack.c (convert_regs_entry): Disable NaN load for\n+\tstack registers that are used for argument passing.\n+\n+\t* doc/extend.texi: Document x87regparm function attribute.\n+\t* doc/invoke.texi: Document -mx87regparm.\n+\n 2006-11-15  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* tree-flow.h (multiplier_allowed_in_address_p): Adjust prototype."}, {"sha": "2583fc0c1b215ec68e3c4b324d73c985e92befbf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 134, "deletions": 21, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -1991,6 +1991,11 @@ override_options (void)\n \tix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n     }\n \n+  /* Accept -mx87regparm only if 80387 support is enabled.  */\n+  if (TARGET_X87REGPARM\n+      && ! TARGET_80387)\n+    error (\"-mx87regparm used without 80387 enabled\");\n+\n   /* Accept -msseregparm only if at least SSE support is enabled.  */\n   if (TARGET_SSEREGPARM\n       && ! TARGET_SSE)\n@@ -2298,6 +2303,9 @@ const struct attribute_spec ix86_attribute_table[] =\n   /* Regparm attribute specifies how many integer arguments are to be\n      passed in registers.  */\n   { \"regparm\",   1, 1, false, true,  true,  ix86_handle_cconv_attribute },\n+  /* X87regparm attribute says we are passing floating point arguments\n+     in 80387 registers.  */\n+  { \"x87regparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute },\n   /* Sseregparm attribute says we are using x86_64 calling conventions\n      for FP arguments.  */\n   { \"sseregparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute },\n@@ -2400,8 +2408,8 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n   return true;\n }\n \n-/* Handle \"cdecl\", \"stdcall\", \"fastcall\", \"regparm\" and \"sseregparm\"\n-   calling convention attributes;\n+/* Handle \"cdecl\", \"stdcall\", \"fastcall\", \"regparm\", \"x87regparm\"\n+   and \"sseregparm\" calling convention attributes;\n    arguments as in struct attribute_spec.handler.  */\n \n static tree\n@@ -2466,7 +2474,8 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n       return NULL_TREE;\n     }\n \n-  /* Can combine fastcall with stdcall (redundant) and sseregparm.  */\n+  /* Can combine fastcall with stdcall (redundant), x87regparm\n+     and sseregparm.  */\n   if (is_attribute_p (\"fastcall\", name))\n     {\n       if (lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (*node)))\n@@ -2483,8 +2492,8 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n \t}\n     }\n \n-  /* Can combine stdcall with fastcall (redundant), regparm and\n-     sseregparm.  */\n+  /* Can combine stdcall with fastcall (redundant), regparm,\n+     x87regparm and sseregparm.  */\n   else if (is_attribute_p (\"stdcall\", name))\n     {\n       if (lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (*node)))\n@@ -2497,7 +2506,7 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n \t}\n     }\n \n-  /* Can combine cdecl with regparm and sseregparm.  */\n+  /* Can combine cdecl with regparm, x87regparm and sseregparm.  */\n   else if (is_attribute_p (\"cdecl\", name))\n     {\n       if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (*node)))\n@@ -2510,7 +2519,7 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n \t}\n     }\n \n-  /* Can combine sseregparm with all attributes.  */\n+  /* Can combine x87regparm or sseregparm with all attributes.  */\n \n   return NULL_TREE;\n }\n@@ -2535,6 +2544,11 @@ ix86_comp_type_attributes (tree type1, tree type2)\n \t  != ix86_function_regparm (type2, NULL)))\n     return 0;\n \n+  /* Check for mismatched x87regparm types.  */\n+  if (!lookup_attribute (\"x87regparm\", TYPE_ATTRIBUTES (type1))\n+      != !lookup_attribute (\"x87regparm\", TYPE_ATTRIBUTES (type2)))\n+    return 0;\n+\n   /* Check for mismatched sseregparm types.  */\n   if (!lookup_attribute (\"sseregparm\", TYPE_ATTRIBUTES (type1))\n       != !lookup_attribute (\"sseregparm\", TYPE_ATTRIBUTES (type2)))\n@@ -2623,6 +2637,48 @@ ix86_function_regparm (tree type, tree decl)\n   return regparm;\n }\n \n+/* Return 1 if we can pass up to X87_REGPARM_MAX floating point\n+   arguments in x87 registers for a function with the indicated\n+   TYPE and DECL.  DECL may be NULL when calling function indirectly\n+   or considering a libcall.  For local functions, return 2.\n+   Otherwise return 0.  */\n+\n+static int\n+ix86_function_x87regparm (tree type, tree decl)\n+{\n+  /* Use x87 registers to pass floating point arguments if requested\n+     by the x87regparm attribute.  */\n+  if (TARGET_X87REGPARM\n+      || (type\n+\t  && lookup_attribute (\"x87regparm\", TYPE_ATTRIBUTES (type))))\n+    {\n+      if (!TARGET_80387)\n+\t{\n+\t  if (decl)\n+\t    error (\"Calling %qD with attribute x87regparm without \"\n+\t\t   \"80387 enabled\", decl);\n+\t  else\n+\t    error (\"Calling %qT with attribute x87regparm without \"\n+\t\t   \"80387 enabled\", type);\n+\t  return 0;\n+\t}\n+\n+      return 1;\n+    }\n+\n+  /* For local functions, pass up to X87_REGPARM_MAX floating point\n+     arguments in x87 registers.  */\n+  if (!TARGET_64BIT && decl\n+      && flag_unit_at_a_time && !profile_flag)\n+    {\n+      struct cgraph_local_info *i = cgraph_local_info (decl);\n+      if (i && i->local)\n+\treturn 2;\n+    }\n+\n+  return 0;\n+}\n+\n /* Return 1 or 2, if we can pass up to 8 SFmode (1) and DFmode (2) arguments\n    in SSE registers for a function with the indicated TYPE and DECL.\n    DECL may be NULL when calling function indirectly\n@@ -2742,6 +2798,8 @@ ix86_function_arg_regno_p (int regno)\n   int i;\n   if (!TARGET_64BIT)\n     return (regno < REGPARM_MAX\n+\t    || (TARGET_80387 && FP_REGNO_P (regno)\n+\t\t&& (regno < FIRST_FLOAT_REG + X87_REGPARM_MAX))\n \t    || (TARGET_MMX && MMX_REGNO_P (regno)\n \t\t&& (regno < FIRST_MMX_REG + MMX_REGPARM_MAX))\n \t    || (TARGET_SSE && SSE_REGNO_P (regno)\n@@ -2805,6 +2863,8 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \n   /* Set up the number of registers to use for passing arguments.  */\n   cum->nregs = ix86_regparm;\n+  if (TARGET_80387)\n+    cum->x87_nregs = X87_REGPARM_MAX;\n   if (TARGET_SSE)\n     cum->sse_nregs = SSE_REGPARM_MAX;\n   if (TARGET_MMX)\n@@ -2826,6 +2886,10 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \tcum->nregs = ix86_function_regparm (fntype, fndecl);\n     }\n \n+  /* Set up the number of 80387 registers used for passing\n+     floating point arguments.  Warn for mismatching ABI.  */\n+  cum->float_in_x87 = ix86_function_x87regparm (fntype, fndecl);\n+\n   /* Set up the number of SSE registers used for passing SFmode\n      and DFmode arguments.  Warn for mismatching ABI.  */\n   cum->float_in_sse = ix86_function_sseregparm (fntype, fndecl);\n@@ -2835,7 +2899,8 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n      are no variable arguments.  If there are variable arguments, then\n      we won't pass anything in registers in 32-bit mode. */\n \n-  if (cum->nregs || cum->mmx_nregs || cum->sse_nregs)\n+  if (cum->nregs || cum->mmx_nregs\n+      || cum->x87_nregs || cum->sse_nregs)\n     {\n       for (param = (fntype) ? TYPE_ARG_TYPES (fntype) : 0;\n \t   param != 0; param = next_param)\n@@ -2846,11 +2911,13 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t      if (!TARGET_64BIT)\n \t\t{\n \t\t  cum->nregs = 0;\n+\t\t  cum->x87_nregs = 0;\n \t\t  cum->sse_nregs = 0;\n \t\t  cum->mmx_nregs = 0;\n \t\t  cum->warn_sse = 0;\n \t\t  cum->warn_mmx = 0;\n \t\t  cum->fastcall = 0;\n+\t\t  cum->float_in_x87 = 0;\n \t\t  cum->float_in_sse = 0;\n \t\t}\n \t      cum->maybe_vaarg = true;\n@@ -3547,13 +3614,40 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    }\n \t  break;\n \n+\tcase SFmode:\n+\t  if (cum->float_in_sse > 0)\n+\t    goto skip_80387;\n+\n \tcase DFmode:\n-\t  if (cum->float_in_sse < 2)\n+\t  if (cum->float_in_sse > 1)\n+\t    goto skip_80387;\n+\n+\t  /* Because no inherent XFmode->DFmode and XFmode->SFmode\n+\t     rounding takes place when values are passed in x87\n+\t     registers, pass DFmode and SFmode types to local functions\n+\t     only when flag_unsafe_math_optimizations is set.  */\n+\t  if (!cum->float_in_x87\n+\t      || (cum->float_in_x87 == 2\n+\t\t  && !flag_unsafe_math_optimizations))\n \t    break;\n-\tcase SFmode:\n-\t  if (cum->float_in_sse < 1)\n+\n+\tcase XFmode:\n+\t  if (!cum->float_in_x87)\n \t    break;\n-\t  /* FALLTHRU */\n+\n+\t  if (!type || !AGGREGATE_TYPE_P (type))\n+\t    {\n+\t      cum->x87_nregs -= 1;\n+\t      cum->x87_regno += 1;\n+\t      if (cum->x87_nregs <= 0)\n+\t\t{\n+\t\t  cum->x87_nregs = 0;\n+\t\t  cum->x87_regno = 0;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+ skip_80387:\n \n \tcase TImode:\n \tcase V16QImode:\n@@ -3564,7 +3658,6 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \tcase V2DFmode:\n \t  if (!type || !AGGREGATE_TYPE_P (type))\n \t    {\n-\t      cum->sse_words += words;\n \t      cum->sse_nregs -= 1;\n \t      cum->sse_regno += 1;\n \t      if (cum->sse_nregs <= 0)\n@@ -3581,7 +3674,6 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \tcase V2SFmode:\n \t  if (!type || !AGGREGATE_TYPE_P (type))\n \t    {\n-\t      cum->mmx_words += words;\n \t      cum->mmx_nregs -= 1;\n \t      cum->mmx_regno += 1;\n \t      if (cum->mmx_nregs <= 0)\n@@ -3646,7 +3738,6 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode orig_mode,\n   else\n     switch (mode)\n       {\n-\t/* For now, pass fp/complex values on the stack.  */\n       default:\n \tbreak;\n \n@@ -3676,13 +3767,35 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode orig_mode,\n \t    ret = gen_rtx_REG (mode, regno);\n \t  }\n \tbreak;\n-      case DFmode:\n-\tif (cum->float_in_sse < 2)\n-\t  break;\n-      case SFmode:\n-\tif (cum->float_in_sse < 1)\n+\n+\tcase SFmode:\n+\t  if (cum->float_in_sse > 0)\n+\t    goto skip_80387;\n+\n+\tcase DFmode:\n+\t  if (cum->float_in_sse > 1)\n+\t    goto skip_80387;\n+\n+\t  /* Because no inherent XFmode->DFmode and XFmode->SFmode\n+\t     rounding takes place when values are passed in x87\n+\t     registers, pass DFmode and SFmode types to local functions\n+\t     only when flag_unsafe_math_optimizations is set.  */\n+\t  if (!cum->float_in_x87\n+\t      || (cum->float_in_x87 == 2\n+\t\t  && !flag_unsafe_math_optimizations))\n+\t    break;\n+\n+\tcase XFmode:\n+\t  if (!cum->float_in_x87)\n+\t    break;\n+\n+\t  if (!type || !AGGREGATE_TYPE_P (type))\n+\t    if (cum->x87_nregs)\n+\t      ret = gen_rtx_REG (mode, cum->x87_regno + FIRST_FLOAT_REG);\n \t  break;\n-\t/* FALLTHRU */\n+\n+ skip_80387:\n+\n       case TImode:\n       case V16QImode:\n       case V8HImode:"}, {"sha": "920662d80aa7112747a4616b3c01ad7b1a78de7a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -1428,19 +1428,21 @@ enum reg_class\n    such as FUNCTION_ARG to determine where the next arg should go.  */\n \n typedef struct ix86_args {\n-  int words;\t\t\t/* # words passed so far */\n   int nregs;\t\t\t/* # registers available for passing */\n   int regno;\t\t\t/* next available register number */\n+  int words;\t\t\t/* # words passed so far */\n   int fastcall;\t\t\t/* fastcall calling convention is used */\n-  int sse_words;\t\t/* # sse words passed so far */\n+  int x87_nregs;\t\t/* # x87 registers available for passing */\n+  int x87_regno;\t\t/* # next available x87 register number */\n   int sse_nregs;\t\t/* # sse registers available for passing */\n-  int warn_sse;\t\t\t/* True when we want to warn about SSE ABI.  */\n-  int warn_mmx;\t\t\t/* True when we want to warn about MMX ABI.  */\n   int sse_regno;\t\t/* next available sse register number */\n-  int mmx_words;\t\t/* # mmx words passed so far */\n+  int warn_sse;\t\t\t/* True when we want to warn about SSE ABI.  */\n   int mmx_nregs;\t\t/* # mmx registers available for passing */\n   int mmx_regno;\t\t/* next available mmx register number */\n+  int warn_mmx;\t\t\t/* True when we want to warn about MMX ABI.  */\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n+  int float_in_x87;\t\t/* 1 if floating point arguments should\n+\t\t\t\t   be passed in 80387 registere.  */\n   int float_in_sse;\t\t/* 1 if in 32-bit mode SFmode (2 for DFmode) should\n \t\t\t\t   be passed in SSE registers.  Otherwise 0.  */\n } CUMULATIVE_ARGS;\n@@ -1727,6 +1729,8 @@ do {\t\t\t\t\t\t\t\\\n \n #define REGPARM_MAX (TARGET_64BIT ? 6 : 3)\n \n+#define X87_REGPARM_MAX 3\n+\n #define SSE_REGPARM_MAX (TARGET_64BIT ? 8 : (TARGET_SSE ? 3 : 0))\n \n #define MMX_REGPARM_MAX (TARGET_64BIT ? 0 : (TARGET_MMX ? 3 : 0))"}, {"sha": "36e09446114ff9838043470fdc30d8d6d786be25", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -201,6 +201,10 @@ mssse3\n Target Report Mask(SSSE3)\n Support MMX, SSE, SSE2, SSE3 and SSSE3 built-in functions and code generation\n \n+mx87regparm\n+Target RejectNegative Mask(X87REGPARM)\n+Use x87 register passing conventions to pass floating point arguments\n+\n msseregparm\n Target RejectNegative Mask(SSEREGPARM)\n Use SSE register passing conventions for SF and DF mode"}, {"sha": "099e4dd802c7f920dcecee7f10505f54561d79c9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -2221,6 +2221,14 @@ safe since the loaders there save all registers.  (Lazy binding can be\n disabled with the linker or the loader if desired, to avoid the\n problem.)\n \n+@item x87regparm\n+@cindex @code{x87regparm} attribute\n+On the Intel x86 with 80387 @code{x87regparm} attribute causes the\n+compiler to pass up to 3 floating point arguments in 80387 registers\n+instead of on the stack.  Functions that take a variable number of\n+arguments will continue to pass all of their floating point arguments\n+on the stack.\n+\n @item sseregparm\n @cindex @code{sseregparm} attribute\n On the Intel 386 with SSE support, the @code{sseregparm} attribute"}, {"sha": "1a62289d9715d1692deae2a979befb6246ec8d82", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -535,8 +535,8 @@ Objective-C and Objective-C++ Dialects}.\n -mmmx  -msse  -msse2 -msse3 -mssse3 -m3dnow @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n--m96bit-long-double  -mregparm=@var{num}  -msseregparm @gol\n--mstackrealign @gol\n+-m96bit-long-double  -mregparm=@var{num}  -mx87regparm @gol\n+-msseregparm @gol  -mstackrealign @gol\n -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol\n -mcmodel=@var{code-model} @gol\n -m32  -m64 -mlarge-data-threshold=@var{num}}\n@@ -9542,6 +9542,17 @@ function by using the function attribute @samp{regparm}.\n value, including any libraries.  This includes the system libraries and\n startup modules.\n \n+@item -mx87regparm\n+@opindex mx87regparm\n+Use 80387 register passing conventions for floating point arguments.\n+You can control this behavior for a specific function by using the\n+function attribute @samp{x87regparm}.\n+@xref{Function Attributes}.\n+\n+@strong{Warning:} if you use this switch then you must build all\n+modules with the same value, including any libraries.  This includes\n+the system libraries and startup modules.\n+\n @item -msseregparm\n @opindex msseregparm\n Use SSE register passing conventions for float and double arguments"}, {"sha": "a96b6ef57fcf8e98f786383dc4c5cc9745b318ef", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -2553,11 +2553,28 @@ print_stack (FILE *file, stack s)\n static int\n convert_regs_entry (void)\n {\n+  tree params = DECL_ARGUMENTS (current_function_decl);\n+  tree p;\n+  HARD_REG_SET incoming_regs;\n+  rtx inc_rtx;\n+\n   int inserted = 0;\n   edge e;\n   edge_iterator ei;\n \n-  /* Load something into each stack register live at function entry.\n+  /* Find out which registers were used as argument passing registers.  */\n+\n+  CLEAR_HARD_REG_SET (incoming_regs);\n+  for (p = params; p; p = TREE_CHAIN (p))\n+    {\n+      inc_rtx = DECL_INCOMING_RTL (p);\n+\n+      if (REG_P (inc_rtx)\n+          && IN_RANGE (REGNO (inc_rtx), FIRST_STACK_REG, LAST_STACK_REG))\n+\tSET_HARD_REG_BIT (incoming_regs, REGNO (inc_rtx));\n+    }\n+\n+  /* Load something into remaining stack register live at function entry.\n      Such live registers can be caused by uninitialized variables or\n      functions not returning values on all paths.  In order to keep\n      the push/pop code happy, and to not scrog the register stack, we\n@@ -2579,6 +2596,10 @@ convert_regs_entry (void)\n \n \t    bi->stack_in.reg[++top] = reg;\n \n+\t    /* Skip argument passing registers.  */\n+\t    if (TEST_HARD_REG_BIT (incoming_regs, reg))\n+\t      continue;\n+\n \t    init = gen_rtx_SET (VOIDmode,\n \t\t\t\tFP_MODE_REG (FIRST_STACK_REG, SFmode),\n \t\t\t\tnot_a_num);"}, {"sha": "d5f56ee244706f7ad9fb9eec1a92e32d7d4c11d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -1,3 +1,10 @@\n+2006-11-15  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/i386/x87regparm-1.c: New test.\n+\t* gcc.target/i386/x87regparm-2.c: New test.\n+\t* gcc.target/i386/x87regparm-3.c: New test.\n+\t* gcc.target/i386/x87regparm-4.c: New test.\n+\n 2006-11-15  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/27546"}, {"sha": "fa93401cd905d465f1586c7f168cd84c5440bede", "filename": "gcc/testsuite/gcc.target/i386/x87regparm-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-1.c?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+float foo_f(float) __attribute__((x87regparm));\n+double foo_d(double) __attribute__((x87regparm));\n+long double foo_ld(long double) __attribute__((x87regparm));\n+\n+volatile float f;\n+volatile double d;\n+volatile long double ld;\n+\n+void test() \n+{\n+  f = foo_f(f);\n+  d = foo_d(d);\n+  ld = foo_ld(ld);\n+}\n+\n+/* Check that no memory is used to pass arguments.  */\n+\n+/* { dg-final { scan-assembler-not \"\\\\(%esp\\\\)\" } } */"}, {"sha": "b28dbc1cc77d811af297383b95bf038b426dd1d8", "filename": "gcc/testsuite/gcc.target/i386/x87regparm-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-2.c?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer -mx87regparm\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+float efoo_f(float);\n+double efoo_d(double);\n+long double efoo_ld(long double);\n+\n+volatile float f;\n+volatile double d;\n+volatile long double ld;\n+\n+void test() \n+{\n+  f = efoo_f(f);\n+  d = efoo_d(d);\n+  ld = efoo_ld(ld);\n+}\n+\n+/* Check that no memory is used to pass arguments.  */\n+\n+/* { dg-final { scan-assembler-not \"\\\\(%esp\\\\)\" } } */"}, {"sha": "b90ff858a09c87672e71d96b37b48383a7ac2eb2", "filename": "gcc/testsuite/gcc.target/i386/x87regparm-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-3.c?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+static float __attribute__((noinline)) foo_f(float f) { return f; }\n+static double __attribute__((noinline)) foo_d(double d) { return d; }\n+static long double __attribute__((noinline)) foo_ld(long double ld) { return ld; }\n+\n+volatile float f;\n+volatile double d;\n+volatile long double ld;\n+\n+void test() \n+{\n+  f = foo_f(f);\n+  d = foo_d(d);\n+  ld = foo_ld(ld);\n+}\n+\n+/* Check that float and double arguments are passed through memory.  */\n+\n+/* { dg-final { scan-assembler-times \"\\\\(%esp\\\\)\" 4 } } */"}, {"sha": "78a6cddedd4bb3d91c19e1c82675194641674f0a", "filename": "gcc/testsuite/gcc.target/i386/x87regparm-4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a37ce45e4feb8cd84a315353a2077c9fbda747/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fx87regparm-4.c?ref=47a37ce45e4feb8cd84a315353a2077c9fbda747", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer -ffast-math\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+static float __attribute__((noinline)) foo_f(float f) { return f; }\n+static double __attribute__((noinline)) foo_d(double d) { return d; }\n+static long double __attribute__((noinline)) foo_ld(long double ld) { return ld; }\n+\n+volatile float f;\n+volatile double d;\n+volatile long double ld;\n+\n+void test() \n+{\n+  f = foo_f(f);\n+  d = foo_d(d);\n+  ld = foo_ld(ld);\n+}\n+\n+/* Check that no memory is used to pass arguments.  */\n+\n+/* { dg-final { scan-assembler-not \"\\\\(%esp\\\\)\" } } */"}]}