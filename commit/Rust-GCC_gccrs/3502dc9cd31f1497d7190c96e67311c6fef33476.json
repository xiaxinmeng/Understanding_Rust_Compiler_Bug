{"sha": "3502dc9cd31f1497d7190c96e67311c6fef33476", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwMmRjOWNkMzFmMTQ5N2Q3MTkwYzk2ZTY3MzExYzZmZWYzMzQ3Ng==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2000-11-30T06:31:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-11-30T06:31:19Z"}, "message": "function.h (emit_status): Delete member regno_pointer_flag and rename regno_pointer_flag_length to...\n\n\t* function.h (emit_status): Delete member regno_pointer_flag and\n\trename regno_pointer_flag_length to regno_pointer_align_length.\n\tDelete define for REGNO_POINTER_FLAG.\n\t* integrate.h (inline_remap): Delete member regno_pointer_flag.\n\tAdd member x_regno_reg_rtx.\n\t* rtl.h (rtx_def): Use frame_related bit to indicate register is\n\ta pointer in REG expressions.  Define REG_POINTER macro.\n\t* alias.c (find_base_value, find_base_term): Use REG_POINTER\n\tinstead of REGNO_POINTER_FLAG.\n\t* combine.c (nonzero_bits, num_sign_bit_copies): Likewise.\n\t* emit-rtl.c (gen_reg_rtx): Use regno_pointer_align_length instead\n\tof regno_pointer_flag_length.  Remove code which refers to\n\tregno_pointer_flag.\n\t(mark_reg_pointer): Use REG_POINTER.\n\t(free_emit_status): Remove code which refers to regno_pointer_flag.\n\t(init_emit, mark_emit_status): Likewise.\n\t* flow.c (dump_flow_info): Likewise.\n\t* function.c (preserve_temp_slots): Likewise.\n\t* integrate.c (expand_inline_function, copy_rtx_and_substitute):\n\tUse x_regno_reg_rtx instead of regno_pointer_flag for function\n\tpointer determination in map.\n\t* loop.c (strength_reduce, maybe_eliminate_biv_1): Use REG_POINTER.\n\t* predict.c (estimate_probability): Likewise.\n\t* regclass.c (record_address_regs, reg_scan_mark_refs): Likewise.\n\t* unroll.c (unroll_loop): Use x_regno_reg_rtx instead of\n\tregno_pointer_flag for function pointer determination in map.\n\t* convex.h (RTX_COSTS): Don't test regno_pointer_flag and use\n\tREG_POINTER.\n\t* pa.c (hppa_legitimize_address, emit_move_sequence, basereg_operand):\n\tUse REG_POINTER.\n\t(restore_unscaled_index_insn_codes): Revise comment.\n\nFrom-SVN: r37863", "tree": {"sha": "57bdfffd7bcfb818e479c3703a8cea6288458407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57bdfffd7bcfb818e479c3703a8cea6288458407"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3502dc9cd31f1497d7190c96e67311c6fef33476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3502dc9cd31f1497d7190c96e67311c6fef33476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3502dc9cd31f1497d7190c96e67311c6fef33476", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3502dc9cd31f1497d7190c96e67311c6fef33476/comments", "author": null, "committer": null, "parents": [{"sha": "31a7659bfda8246f1ac518cab9fe920842de292f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a7659bfda8246f1ac518cab9fe920842de292f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31a7659bfda8246f1ac518cab9fe920842de292f"}], "stats": {"total": 228, "additions": 128, "deletions": 100}, "files": [{"sha": "c808b51ffd9cfc3bd03311fdb52b077c603b4138", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -1,5 +1,37 @@\n 2000-11-29  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n+\t* function.h (emit_status): Delete member regno_pointer_flag and\n+\trename regno_pointer_flag_length to regno_pointer_align_length.\n+\tDelete define for REGNO_POINTER_FLAG.\n+\t* integrate.h (inline_remap): Delete member regno_pointer_flag.\n+\tAdd member x_regno_reg_rtx.\n+\t* rtl.h (rtx_def): Use frame_related bit to indicate register is\n+\ta pointer in REG expressions.  Define REG_POINTER macro.\n+\t* alias.c (find_base_value, find_base_term): Use REG_POINTER\n+\tinstead of REGNO_POINTER_FLAG.\n+\t* combine.c (nonzero_bits, num_sign_bit_copies): Likewise.\n+\t* emit-rtl.c (gen_reg_rtx): Use regno_pointer_align_length instead\n+\tof regno_pointer_flag_length.  Remove code which refers to\n+\tregno_pointer_flag.\n+\t(mark_reg_pointer): Use REG_POINTER.\n+\t(free_emit_status): Remove code which refers to regno_pointer_flag.\n+\t(init_emit, mark_emit_status): Likewise.\n+\t* flow.c (dump_flow_info): Likewise.\n+\t* function.c (preserve_temp_slots): Likewise.\n+\t* integrate.c (expand_inline_function, copy_rtx_and_substitute):\n+\tUse x_regno_reg_rtx instead of regno_pointer_flag for function\n+\tpointer determination in map.\n+\t* loop.c (strength_reduce, maybe_eliminate_biv_1): Use REG_POINTER.\n+\t* predict.c (estimate_probability): Likewise.\n+\t* regclass.c (record_address_regs, reg_scan_mark_refs): Likewise.\n+\t* unroll.c (unroll_loop): Use x_regno_reg_rtx instead of\n+\tregno_pointer_flag for function pointer determination in map.\n+\t* convex.h (RTX_COSTS): Don't test regno_pointer_flag and use\n+\tREG_POINTER.\n+\t* pa.c (hppa_legitimize_address, emit_move_sequence, basereg_operand):\n+\tUse REG_POINTER.\n+\t(restore_unscaled_index_insn_codes): Revise comment.\n+\n \t* expr.c (do_compare_and_jump): Add missing TYPE_MODE in statement.\n \n 2000-11-30  Joseph S. Myers  <jsm28@cam.ac.uk>"}, {"sha": "08d6f4362bca4cb48090a63a1fe0df835a798588", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -671,9 +671,9 @@ find_base_value (src)\n \t/* This might not be necessary anymore:\n \t   If either operand is a REG that is a known pointer, then it\n \t   is the base.  */\n-\telse if (GET_CODE (src_0) == REG && REGNO_POINTER_FLAG (REGNO (src_0)))\n+\telse if (GET_CODE (src_0) == REG && REG_POINTER (src_0))\n \t  return find_base_value (src_0);\n-\telse if (GET_CODE (src_1) == REG && REGNO_POINTER_FLAG (REGNO (src_1)))\n+\telse if (GET_CODE (src_1) == REG && REG_POINTER (src_1))\n \t  return find_base_value (src_1);\n \n \treturn 0;\n@@ -1082,10 +1082,10 @@ find_base_term (x)\n \n \t/* If either operand is known to be a pointer, then use it\n \t   to determine the base term.  */\n-\tif (REG_P (tmp1) && REGNO_POINTER_FLAG (REGNO (tmp1)))\n+\tif (REG_P (tmp1) && REG_POINTER (tmp1))\n \t  return find_base_term (tmp1);\n \n-\tif (REG_P (tmp2) && REGNO_POINTER_FLAG (REGNO (tmp2)))\n+\tif (REG_P (tmp2) && REG_POINTER (tmp2))\n \t  return find_base_term (tmp2);\n \n \t/* Neither operand was known to be a pointer.  Go ahead and find the"}, {"sha": "df773aacdd6e19fa89eb0f048caa6b25f67e2f7c", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -8033,7 +8033,7 @@ nonzero_bits (x, mode)\n       /* If pointers extend unsigned and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be zero.  */\n       if (POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n-\t  && REGNO_POINTER_FLAG (REGNO (x)))\n+\t  && REG_POINTER (x))\n \tnonzero &= GET_MODE_MASK (ptr_mode);\n #endif\n \n@@ -8471,7 +8471,7 @@ num_sign_bit_copies (x, mode)\n       /* If pointers extend signed and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be sign bit copies.  */\n       if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode && mode == Pmode\n-\t  && REGNO_POINTER_FLAG (REGNO (x)))\n+\t  && REG_POINTER (x))\n \treturn GET_MODE_BITSIZE (Pmode) - GET_MODE_BITSIZE (ptr_mode) + 1;\n #endif\n "}, {"sha": "eb4d9363ce9e9b42a556da5f078564bf60ced67e", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -1112,9 +1112,8 @@ enum reg_class {\n \n #define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n   case PLUS:\t\t\t\t\t\t\t\t\\\n-    if (cfun->emit->regno_pointer_flag != 0\t\t\t\t\\\n-\t&& GET_CODE (XEXP (RTX, 0)) == REG\t\t\t\t\\\n-\t&& REGNO_POINTER_FLAG (REGNO (XEXP (RTX, 0)))\t\t\t\\\n+    if (GET_CODE (XEXP (RTX, 0)) == REG\t\t\t\t\t\\\n+\t&& REG_POINTER (XEXP (RTX, 0))\t\t\t\t\t\\\n \t&& GET_CODE (XEXP (RTX, 1)) == CONST_INT)\t\t\t\\\n       return 0;\t\t\t\t\t\t\t\t\\\n     else break;\t\t\t\t\t\t\t\t\\"}, {"sha": "e2453b70495a1dee69775abb8587ff72e4631fe9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -912,8 +912,8 @@ hppa_legitimize_address (x, oldx, mode)\n       idx = NULL_RTX;\n \n       /* Make sure they're both regs.  If one was a SYMBOL_REF [+ const],\n-\t then emit_move_sequence will turn on REGNO_POINTER_FLAG so we'll\n-\t know it's a base register below.  */\n+\t then emit_move_sequence will turn on REG_POINTER so we'll know\n+\t it's a base register below.  */\n       if (GET_CODE (reg1) != REG)\n \treg1 = force_reg (Pmode, force_operand (reg1, 0));\n \n@@ -923,7 +923,7 @@ hppa_legitimize_address (x, oldx, mode)\n       /* Figure out what the base and index are.  */\n \t \n       if (GET_CODE (reg1) == REG\n-\t  && REGNO_POINTER_FLAG (REGNO (reg1)))\n+\t  && REG_POINTER (reg1))\n \t{\n \t  base = reg1;\n \t  orig_base = XEXP (XEXP (x, 0), 1);\n@@ -934,7 +934,7 @@ hppa_legitimize_address (x, oldx, mode)\n \t\t\t      XEXP (x, 1));\n \t}\n       else if (GET_CODE (reg2) == REG\n-\t       && REGNO_POINTER_FLAG (REGNO (reg2)))\n+\t       && REG_POINTER (reg2))\n \t{\n \t  base = reg2;\n \t  orig_base = XEXP (x, 1);\n@@ -1544,9 +1544,9 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t Don't mark hard registers though.  That loses.  */\n \t      if (GET_CODE (operand0) == REG\n \t\t  && REGNO (operand0) >= FIRST_PSEUDO_REGISTER)\n-\t\tREGNO_POINTER_FLAG (REGNO (operand0)) = 1;\n+\t\tREG_POINTER (operand0) = 1;\n \t      if (REGNO (temp) >= FIRST_PSEUDO_REGISTER)\n-\t\tREGNO_POINTER_FLAG (REGNO (temp)) = 1;\n+\t\tREG_POINTER (temp) = 1;\n \t      if (ishighonly)\n \t\tset = gen_rtx_SET (mode, operand0, temp);\n \t      else\n@@ -6146,17 +6146,19 @@ basereg_operand (op, mode)\n   if (!cse_not_expected)\n     return 0;\n \n-  /* Once reload has started everything is considered valid.  Reload should\n-     only create indexed addresses using the stack/frame pointer, and any\n-     others were checked for validity when created by the combine pass. \n-\n-     Also allow any register when TARGET_NO_SPACE_REGS is in effect since\n-     we don't have to worry about the braindamaged implicit space register\n-     selection using the basereg only (rather than effective address)\n-     screwing us over.  */\n-  if (TARGET_NO_SPACE_REGS || reload_in_progress || reload_completed)\n+  /* Allow any register when TARGET_NO_SPACE_REGS is in effect since\n+     we don't have to worry about the braindamaged implicit space\n+     register selection from the basereg.  */\n+  if (TARGET_NO_SPACE_REGS)\n     return (GET_CODE (op) == REG);\n \n+  /* Once reload has started any register with REG_POINTER set\n+     is considered valid.  Reload should only create indexed addresses\n+     using the stack/frame pointer.  All others are checked for\n+     validity when they are created by the combine pass.  */\n+  if (reload_in_progress || reload_completed)\n+    return (GET_CODE (op) == REG && REG_POINTER (op));\n+\n   /* Stack is always OK for indexing.  */\n   if (op == stack_pointer_rtx)\n     return 1;\n@@ -6168,13 +6170,11 @@ basereg_operand (op, mode)\n     return 1;\n \n   /* The only other valid OPs are pseudo registers with\n-     REGNO_POINTER_FLAG set.  */\n-  if (GET_CODE (op) != REG\n-      || REGNO (op) < FIRST_PSEUDO_REGISTER\n-      || ! register_operand (op, mode))\n-    return 0;\n-    \n-  return REGNO_POINTER_FLAG (REGNO (op));\n+     REG_POINTER set.  */\n+  return (GET_CODE (op) == REG\n+          && REGNO (op) >= FIRST_PSEUDO_REGISTER\n+          && register_operand (op, mode)\n+          && REG_POINTER (op));\n }\n \n /* Return 1 if this operand is anything other than a hard register.  */\n@@ -6372,7 +6372,7 @@ restore_unscaled_index_insn_codes (insns)\n    Because of this mis-feature we have to know which register in a reg+reg\n    address is the base and which is the index.\n \n-   Before reload, the base can be identified by REGNO_POINTER_FLAG.  We use\n+   Before reload, the base can be identified by REG_POINTER.  We use\n    this to force base + index addresses to match a different insn than\n    index + base addresses.\n \n@@ -6392,8 +6392,12 @@ restore_unscaled_index_insn_codes (insns)\n    using unscaled indexed addresses have the same INSN_CODE as they did\n    immediately before delay slot scheduling.\n \n-   This is extremely gross.  Long term, I'd like to be able to look at\n-   REG_POINTER_FLAG to handle these kinds of problems.  */\n+   This is extremely gross.  Long term, I'd like to use REG_POINTER to\n+   handle these kinds of problems.\n+\n+   FIXME: Is this still necessary now that the pointer flag is stored\n+   in REG rtx's and basereg_operand properly checks for the flag after\n+   reload?  */\n  \n static void\n record_unscaled_index_insn_codes (insns)"}, {"sha": "5d60100050c99d781a2ab16d95e109563373bf45", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -549,18 +549,14 @@ gen_reg_rtx (mode)\n       return gen_rtx_CONCAT (mode, realpart, imagpart);\n     }\n \n-  /* Make sure regno_pointer_flag and regno_reg_rtx are large\n-     enough to have an element for this pseudo reg number.  */\n+  /* Make sure regno_pointer_align and regno_reg_rtx are large enough\n+     to have an element for this pseudo reg number.  */\n \n-  if (reg_rtx_no == f->emit->regno_pointer_flag_length)\n+  if (reg_rtx_no == f->emit->regno_pointer_align_length)\n     {\n-      int old_size = f->emit->regno_pointer_flag_length;\n+      int old_size = f->emit->regno_pointer_align_length;\n       rtx *new1;\n       char *new;\n-      new = xrealloc (f->emit->regno_pointer_flag, old_size * 2);\n-      memset (new + old_size, 0, old_size);\n-      f->emit->regno_pointer_flag = new;\n-\n       new = xrealloc (f->emit->regno_pointer_align, old_size * 2);\n       memset (new + old_size, 0, old_size);\n       f->emit->regno_pointer_align = (unsigned char *) new;\n@@ -570,7 +566,7 @@ gen_reg_rtx (mode)\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n-      f->emit->regno_pointer_flag_length = old_size * 2;\n+      f->emit->regno_pointer_align_length = old_size * 2;\n     }\n \n   val = gen_rtx_raw_REG (mode, reg_rtx_no);\n@@ -603,9 +599,9 @@ mark_reg_pointer (reg, align)\n      rtx reg;\n      int align;\n {\n-  if (! REGNO_POINTER_FLAG (REGNO (reg)))\n+  if (! REG_POINTER (reg))\n     {\n-      REGNO_POINTER_FLAG (REGNO (reg)) = 1;\n+      REG_POINTER (reg) = 1;\n \n       if (align)\n \tREGNO_POINTER_ALIGN (REGNO (reg)) = align;\n@@ -1713,7 +1709,6 @@ free_emit_status (f)\n      struct function *f;\n {\n   free (f->emit->x_regno_reg_rtx);\n-  free (f->emit->regno_pointer_flag);\n   free (f->emit->regno_pointer_align);\n   free (f->emit);\n   f->emit = NULL;\n@@ -3926,34 +3921,31 @@ init_emit ()\n \n   /* Init the tables that describe all the pseudo regs.  */\n \n-  f->emit->regno_pointer_flag_length = LAST_VIRTUAL_REGISTER + 101;\n-\n-  f->emit->regno_pointer_flag \n-    = (char *) xcalloc (f->emit->regno_pointer_flag_length, sizeof (char));\n+  f->emit->regno_pointer_align_length = LAST_VIRTUAL_REGISTER + 101;\n \n   f->emit->regno_pointer_align\n-    = (unsigned char *) xcalloc (f->emit->regno_pointer_flag_length,\n+    = (unsigned char *) xcalloc (f->emit->regno_pointer_align_length,\n \t\t\t\t sizeof (unsigned char));\n \n   regno_reg_rtx \n-    = (rtx *) xcalloc (f->emit->regno_pointer_flag_length * sizeof (rtx),\n+    = (rtx *) xcalloc (f->emit->regno_pointer_align_length * sizeof (rtx),\n \t\t       sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n   init_virtual_regs (f->emit);\n \n   /* Indicate that the virtual registers and stack locations are\n      all pointers.  */\n-  REGNO_POINTER_FLAG (STACK_POINTER_REGNUM) = 1;\n-  REGNO_POINTER_FLAG (FRAME_POINTER_REGNUM) = 1;\n-  REGNO_POINTER_FLAG (HARD_FRAME_POINTER_REGNUM) = 1;\n-  REGNO_POINTER_FLAG (ARG_POINTER_REGNUM) = 1;\n+  REG_POINTER (stack_pointer_rtx) = 1;\n+  REG_POINTER (frame_pointer_rtx) = 1;\n+  REG_POINTER (hard_frame_pointer_rtx) = 1;\n+  REG_POINTER (arg_pointer_rtx) = 1;\n \n-  REGNO_POINTER_FLAG (VIRTUAL_INCOMING_ARGS_REGNUM) = 1;\n-  REGNO_POINTER_FLAG (VIRTUAL_STACK_VARS_REGNUM) = 1;\n-  REGNO_POINTER_FLAG (VIRTUAL_STACK_DYNAMIC_REGNUM) = 1;\n-  REGNO_POINTER_FLAG (VIRTUAL_OUTGOING_ARGS_REGNUM) = 1;\n-  REGNO_POINTER_FLAG (VIRTUAL_CFA_REGNUM) = 1;\n+  REG_POINTER (virtual_incoming_args_rtx) = 1;\n+  REG_POINTER (virtual_stack_vars_rtx) = 1;\n+  REG_POINTER (virtual_stack_dynamic_rtx) = 1;\n+  REG_POINTER (virtual_outgoing_args_rtx) = 1;\n+  REG_POINTER (virtual_cfa_rtx) = 1;\n \n #ifdef STACK_BOUNDARY\n   REGNO_POINTER_ALIGN (STACK_POINTER_REGNUM) = STACK_BOUNDARY;\n@@ -3999,7 +3991,7 @@ mark_emit_status (es)\n   if (es == 0)\n     return;\n \n-  for (i = es->regno_pointer_flag_length, r = es->x_regno_reg_rtx;\n+  for (i = es->regno_pointer_align_length, r = es->x_regno_reg_rtx;\n        i > 0; --i, ++r)\n     ggc_mark_rtx (*r);\n "}, {"sha": "1e3708274868d6045ba6e8627c2e9022eb444781", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -6078,7 +6078,7 @@ dump_flow_info (file)\n \t\t       reg_class_names[(int) class],\n \t\t       reg_class_names[(int) altclass]);\n \t  }\n-\tif (REGNO_POINTER_FLAG (i))\n+\tif (REG_POINTER (regno_reg_rtx[i]))\n \t  fprintf (file, \"; pointer\");\n \tfprintf (file, \".\\n\");\n       }"}, {"sha": "5e01c65f5d1fd5b719d0e7cef7dc283eda4caf46", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -1111,7 +1111,7 @@ preserve_temp_slots (x)\n      a temporary slot we know it points to.  To be consistent with\n      the code below, we really should preserve all non-kept slots\n      if we can't find a match, but that seems to be much too costly.  */\n-  if (GET_CODE (x) == REG && REGNO_POINTER_FLAG (REGNO (x)))\n+  if (GET_CODE (x) == REG && REG_POINTER (x))\n     p = find_temp_slot_from_address (x);\n \n   /* If X is not in memory or is at a constant address, it cannot be in"}, {"sha": "9f2f42a502a8cdbb8a14f0ed71b0da81fd0a4a61", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -97,21 +97,19 @@ struct emit_status\n   int x_last_linenum;\n   const char *x_last_filename;\n \n-  /* A vector indexed by pseudo reg number.  The allocated length\n-     of this vector is regno_pointer_flag_length.  Since this\n-     vector is needed during the expansion phase when the total\n-     number of registers in the function is not yet known,\n-     it is copied and made bigger when necessary.  */\n-  char *regno_pointer_flag;\n-  int regno_pointer_flag_length;\n+  /* The length of the regno_pointer_align and x_regno_reg_rtx vectors.\n+     Since these vectors are needed during the expansion phase when\n+     the total number of registers in the function is not yet known,\n+     the vectors are copied and made bigger when necessary.  */\n+  int regno_pointer_align_length;\n \n   /* Indexed by pseudo register number, if nonzero gives the known alignment\n-     for that pseudo (if regno_pointer_flag is set).\n-     Allocated in parallel with regno_pointer_flag.  */\n+     for that pseudo (if REG_POINTER is set in x_regno_reg_rtx).\n+     Allocated in parallel with x_regno_reg_rtx.  */\n   unsigned char *regno_pointer_align;\n \n   /* Indexed by pseudo register number, gives the rtx for that pseudo.\n-     Allocated in parallel with regno_pointer_flag.  */\n+     Allocated in parallel with regno_pointer_align.  */\n   rtx *x_regno_reg_rtx;\n };\n \n@@ -122,7 +120,6 @@ struct emit_status\n #define seq_stack (cfun->emit->sequence_stack)\n \n #define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align[REGNO])\n-#define REGNO_POINTER_FLAG(REGNO) (cfun->emit->regno_pointer_flag[REGNO])\n \n struct expr_status\n {"}, {"sha": "b991fef0a6c9d1c9d7a68e7f629455295aca6d28", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -822,8 +822,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   if (map->insns_at_start == 0)\n     map->insns_at_start = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \n-  map->regno_pointer_flag = inl_f->emit->regno_pointer_flag;\n   map->regno_pointer_align = inl_f->emit->regno_pointer_align;\n+  map->x_regno_reg_rtx = inl_f->emit->x_regno_reg_rtx;\n \n   /* Update the outgoing argument size to allow for those in the inlined\n      function.  */\n@@ -1878,7 +1878,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t  RTX_UNCHANGING_P (map->reg_map[regno]) = RTX_UNCHANGING_P (orig);\n \t  /* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */\n \n-\t  if (map->regno_pointer_flag[regno])\n+\t  if (REG_POINTER (map->x_regno_reg_rtx[regno]))\n \t    mark_reg_pointer (map->reg_map[regno],\n \t\t\t      map->regno_pointer_align[regno]);\n \t}\n@@ -1923,7 +1923,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t  RTX_UNCHANGING_P (map->reg_map[regno]) = RTX_UNCHANGING_P (temp);\n \t  /* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */\n \n-\t  if (map->regno_pointer_flag[regno])\n+\t  if (REG_POINTER (map->x_regno_reg_rtx[regno]))\n \t    mark_reg_pointer (map->reg_map[regno],\n \t\t\t      map->regno_pointer_align[regno]);\n \t  regno = REGNO (map->reg_map[regno]);"}, {"sha": "794276bd60edeaade040d4172c9249a70ef92992", "filename": "gcc/integrate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -94,8 +94,8 @@ struct inline_remap\n   rtvec copy_asm_constraints_vector;\n \n   /* Indications for regs being pointers and their alignment.  */\n-  char *regno_pointer_flag;\n   unsigned char *regno_pointer_align;\n+  rtx *x_regno_reg_rtx;\n \n   /* The next few fields are used for subst_constants to record the SETs\n      that it saw.  */"}, {"sha": "271e36c508c625e13458e87ad798d42284dde851", "filename": "gcc/loop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -4182,11 +4182,11 @@ strength_reduce (loop, insn_count, flags)\n \t     the alignment.  */\n \t  if (GET_CODE (v->new_reg) == REG\n \t      && v->giv_type == DEST_REG\n-\t      && REGNO_POINTER_FLAG (REGNO (v->dest_reg)))\n+\t      && REG_POINTER (v->dest_reg))\n \t    mark_reg_pointer (v->new_reg,\n \t\t\t      REGNO_POINTER_ALIGN (REGNO (v->dest_reg)));\n \t  else if (GET_CODE (v->new_reg) == REG\n-\t\t   && REGNO_POINTER_FLAG (REGNO (v->src_reg)))\n+\t\t   && REG_POINTER (v->src_reg))\n \t    {\n \t      unsigned int align = REGNO_POINTER_ALIGN (REGNO (v->src_reg));\n \n@@ -4199,7 +4199,7 @@ strength_reduce (loop, insn_count, flags)\n \t    }\n \t  else if (GET_CODE (v->new_reg) == REG\n \t\t   && GET_CODE (v->add_val) == REG\n-\t\t   && REGNO_POINTER_FLAG (REGNO (v->add_val)))\n+\t\t   && REG_POINTER (v->add_val))\n \t    {\n \t      unsigned int align = REGNO_POINTER_ALIGN (REGNO (v->add_val));\n \n@@ -7884,7 +7884,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\t    || GET_CODE (v->add_val) == LABEL_REF\n \t\t    || GET_CODE (v->add_val) == CONST\n \t\t    || (GET_CODE (v->add_val) == REG\n-\t\t\t&& REGNO_POINTER_FLAG (REGNO (v->add_val)))))\n+\t\t\t&& REG_POINTER (v->add_val))))\n \t      {\n \t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t  continue;\n@@ -7948,7 +7948,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\t    || GET_CODE (v->add_val) == LABEL_REF\n \t\t    || GET_CODE (v->add_val) == CONST\n \t\t    || (GET_CODE (v->add_val) == REG\n-\t\t\t&& REGNO_POINTER_FLAG (REGNO (v->add_val))))\n+\t\t\t&& REG_POINTER (v->add_val)))\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode)\n \t      {"}, {"sha": "57595ed9488d31396715897d205d1ca00b59663b", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -146,21 +146,21 @@ estimate_probability (loops_info)\n \t{\n \tcase EQ:\n \t  if (GET_CODE (XEXP (cond, 0)) == REG\n-\t      && REGNO_POINTER_FLAG (REGNO (XEXP (cond, 0)))\n+\t      && REG_POINTER (XEXP (cond, 0))\n \t      && (XEXP (cond, 1) == const0_rtx\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n-\t\t      && REGNO_POINTER_FLAG (REGNO (XEXP (cond, 1))))))\n+\t\t      && REG_POINTER (XEXP (cond, 1)))))\n \t    {\n \t      prob = PROB_UNLIKELY;\n \t      goto emitnote;\n \t    }\n \t  break;\n \tcase NE:\n \t  if (GET_CODE (XEXP (cond, 0)) == REG\n-\t      && REGNO_POINTER_FLAG (REGNO (XEXP (cond, 0)))\n+\t      && REG_POINTER (XEXP (cond, 0))\n \t      && (XEXP (cond, 1) == const0_rtx\n \t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n-\t\t      && REGNO_POINTER_FLAG (REGNO (XEXP (cond, 1))))))\n+\t\t      && REG_POINTER (XEXP (cond, 1)))))\n \t    {\n \t      prob = PROB_LIKELY;\n \t      goto emitnote;"}, {"sha": "078bf9ecf56458e52e8f73086c35bc34f29419ba", "filename": "gcc/regclass.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -1847,10 +1847,10 @@ record_address_regs (x, class, scale)\n       /* When we have an address that is a sum,\n \t we must determine whether registers are \"base\" or \"index\" regs.\n \t If there is a sum of two registers, we must choose one to be\n-\t the \"base\".  Luckily, we can use the REGNO_POINTER_FLAG\n-\t to make a good choice most of the time.  We only need to do this\n-\t on machines that can have two registers in an address and where\n-\t the base and index register classes are different.\n+\t the \"base\".  Luckily, we can use the REG_POINTER to make a good\n+\t choice most of the time.  We only need to do this on machines\n+\t that can have two registers in an address and where the base\n+\t and index register classes are different.\n \n \t ??? This code used to set REGNO_POINTER_FLAG in some cases, but\n \t that seems bogus since it should only be set when we are sure\n@@ -1923,13 +1923,13 @@ record_address_regs (x, class, scale)\n \t   with the other operand the index.  Likewise if the other operand\n \t   is a MULT.  */\n \n-\telse if ((code0 == REG && REGNO_POINTER_FLAG (REGNO (arg0)))\n+\telse if ((code0 == REG && REG_POINTER (arg0))\n \t\t || code1 == MULT)\n \t  {\n \t    record_address_regs (arg0, BASE_REG_CLASS, scale);\n \t    record_address_regs (arg1, INDEX_REG_CLASS, scale);\n \t  }\n-\telse if ((code1 == REG && REGNO_POINTER_FLAG (REGNO (arg1)))\n+\telse if ((code1 == REG && REG_POINTER (arg1))\n \t\t || code0 == MULT)\n \t  {\n \t    record_address_regs (arg0, INDEX_REG_CLASS, scale);\n@@ -2331,18 +2331,18 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \t  /* If the destination pseudo is set more than once, then other\n \t     sets might not be to a pointer value (consider access to a\n \t     union in two threads of control in the presense of global\n-\t     optimizations).  So only set REGNO_POINTER_FLAG on the destination\n+\t     optimizations).  So only set REG_POINTER on the destination\n \t     pseudo if this is the only set of that pseudo.  */\n \t  && REG_N_SETS (REGNO (SET_DEST (x))) == 1\n \t  && ! REG_USERVAR_P (SET_DEST (x))\n-\t  && ! REGNO_POINTER_FLAG (REGNO (SET_DEST (x)))\n+\t  && ! REG_POINTER (SET_DEST (x))\n \t  && ((GET_CODE (SET_SRC (x)) == REG\n-\t       && REGNO_POINTER_FLAG (REGNO (SET_SRC (x))))\n+\t       && REG_POINTER (SET_SRC (x)))\n \t      || ((GET_CODE (SET_SRC (x)) == PLUS\n \t\t   || GET_CODE (SET_SRC (x)) == LO_SUM)\n \t\t  && GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n \t\t  && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n-\t\t  && REGNO_POINTER_FLAG (REGNO (XEXP (SET_SRC (x), 0))))\n+\t\t  && REG_POINTER (XEXP (SET_SRC (x), 0)))\n \t      || GET_CODE (SET_SRC (x)) == CONST\n \t      || GET_CODE (SET_SRC (x)) == SYMBOL_REF\n \t      || GET_CODE (SET_SRC (x)) == LABEL_REF\n@@ -2359,7 +2359,7 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \t\t  && (GET_CODE (XEXP (note, 0)) == CONST\n \t\t      || GET_CODE (XEXP (note, 0)) == SYMBOL_REF\n \t\t      || GET_CODE (XEXP (note, 0)) == LABEL_REF))))\n-\tREGNO_POINTER_FLAG (REGNO (SET_DEST (x))) = 1;\n+\tREG_POINTER (SET_DEST (x)) = 1;\n \n       /* ... fall through ...  */\n "}, {"sha": "79dd1062176e63bd05fa42378c3fb0e6d3ede73a", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -169,6 +169,7 @@ typedef struct rtx_def\n      restoring registers in the prologue and epilogue.\n      1 in a MEM if the MEM refers to a scalar, rather than a member of\n      an aggregate.\n+     1 in a REG if the register is a pointer.\n      1 in a SYMBOL_REF if it addresses something in the per-function\n      constant string pool.  */\n   unsigned frame_related : 1;\n@@ -749,6 +750,9 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* 1 in a REG rtx if it corresponds to a variable declared by the user.  */\n #define REG_USERVAR_P(RTX) ((RTX)->volatil)\n \n+/* 1 in a REG rtx if the register is a pointer.  */\n+#define REG_POINTER(RTX) ((RTX)->frame_related)\n+\n /* 1 if the given register REG corresponds to a hard register.  */\n #define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n "}, {"sha": "6e545b06926500e7895416c5c8e4cd91771d9b4e", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3502dc9cd31f1497d7190c96e67311c6fef33476/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=3502dc9cd31f1497d7190c96e67311c6fef33476", "patch": "@@ -1197,8 +1197,8 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n     }\n \n   /* Use our current register alignment and pointer flags.  */\n-  map->regno_pointer_flag = cfun->emit->regno_pointer_flag;\n   map->regno_pointer_align = cfun->emit->regno_pointer_align;\n+  map->x_regno_reg_rtx = cfun->emit->x_regno_reg_rtx;\n \n   /* If the loop is being partially unrolled, and the iteration variables\n      are being split, and are being renamed for the split, then must fix up"}]}