{"sha": "9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwMWM5YjA2MWVhNmFjNzI5NzMwYWM5ZDQ5OTllNGQ2MGM0ZGYzZA==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2004-01-07T05:22:37Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-01-07T05:22:37Z"}, "message": "locale_facets.h: Document public classes and functions.\n\n2003-01-06  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* include/bits/locale_facets.h: Document public classes and\n\tfunctions.\n\t* include/bits/locale_facets.tcc (time_get::_M_extract_via_format):\n\tAdd comment.\n\nFrom-SVN: r75498", "tree": {"sha": "c80ff7bb6b91c5cb0652898b2f14f9f84ae6fde5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c80ff7bb6b91c5cb0652898b2f14f9f84ae6fde5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93c9d1bae65fbd6727217cd6532d54e5a5f5049f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c9d1bae65fbd6727217cd6532d54e5a5f5049f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c9d1bae65fbd6727217cd6532d54e5a5f5049f"}], "stats": {"total": 1446, "additions": 1440, "deletions": 6}, "files": [{"sha": "3902d54cc09aabd20f5b92094d3158883a0cee84", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "patch": "@@ -1,3 +1,10 @@\n+2003-01-06  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* include/bits/locale_facets.h: Document public classes and\n+\tfunctions.\n+\t* include/bits/locale_facets.tcc (time_get::_M_extract_via_format):\n+\tAdd comment.\n+\n 2004-01-06  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/27_io/basic_istream/extractors_other/char/1.cc:"}, {"sha": "292657312df1dbd27fd8fa2c035db64176a30dc6", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 1429, "deletions": 6, "changes": 1435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "patch": "@@ -1683,76 +1683,221 @@ namespace std\n \t}\n     }\n \n+  /**\n+   *  @brief  Numpunct facet.\n+   *\n+   *  This facet stores several pieces of information related to printing and\n+   *  scanning numbers, such as the decimal point character.  It takes a\n+   *  template parameter specifying the char type.  The numpunct facet is\n+   *  used by streams for many I/O operations involving numbers.\n+   *\n+   *  The numpunct template uses protected virtual functions to provide the\n+   *  actual results.  The public accessors forward the call to the virtual\n+   *  functions.  These virtual functions are hooks for developers to\n+   *  implement the behavior they require from a numpunct facet.\n+  */\n   template<typename _CharT>\n     class numpunct : public locale::facet\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT          \t\tchar_type;\n       typedef basic_string<_CharT> \tstring_type;\n+      //@}\n       typedef __numpunct_cache<_CharT>  __cache_type;\n \n     protected:\n       __cache_type*\t\t\t_M_data;\n \n     public:\n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Numpunct constructor.\n+       *\n+       *  @param  refs  Refcount to pass to the base class.\n+       */\n       explicit \n       numpunct(size_t __refs = 0) : facet(__refs), _M_data(NULL)\n       { _M_initialize_numpunct(); }\n \n+      /**\n+       *  @brief  Internal constructor.  Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up the\n+       *  predefined locale facets.\n+       *\n+       *  @param  cache  __numpunct_cache object.\n+       *  @param  refs  Refcount to pass to the base class.\n+       */\n       explicit \n       numpunct(__cache_type* __cache, size_t __refs = 0) \n       : facet(__refs), _M_data(__cache)\n       { _M_initialize_numpunct(); }\n \n+      /**\n+       *  @brief  Internal constructor.  Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param  cloc  The \"C\" locale.\n+       *  @param  refs  Refcount to pass to the base class.\n+       */\n       explicit \n       numpunct(__c_locale __cloc, size_t __refs = 0) \n       : facet(__refs), _M_data(NULL)\n       { _M_initialize_numpunct(__cloc); }\n \n+      /**\n+       *  @brief  Return decimal point character.\n+       *\n+       *  This function returns a char_type to use as a decimal point.  It\n+       *  does so by returning returning\n+       *  numpunct<char_type>::do_decimal_point().\n+       *\n+       *  @return  @a char_type representing a decimal point.\n+      */\n       char_type    \n       decimal_point() const\n       { return this->do_decimal_point(); }\n \n+      /**\n+       *  @brief  Return thousands separator character.\n+       *\n+       *  This function returns a char_type to use as a thousands separator.  It\n+       *  does so by returning returning\n+       *  numpunct<char_type>::do_thousands_sep().\n+       *\n+       *  @return  char_type representing a thousands separator.\n+      */\n       char_type    \n       thousands_sep() const\n       { return this->do_thousands_sep(); }\n \n+      /**\n+       *  @brief  Return grouping specification.\n+       *\n+       *  This function returns a string representing groupings for the\n+       *  integer part of a number.  Groupings indicate where thousands\n+       *  separators should be inserted in the integer part of a number.\n+       *\n+       *  Each char in the return string is interpret as an integer rather\n+       *  than a character.  These numbers represent the number of digits in a\n+       *  group.  The first char in the string represents the number of digits\n+       *  in the least significant group.  If a char is negative, it indicates\n+       *  an unlimited number of digits for the group.  If more chars from the\n+       *  string are required to group a number, the last char is used\n+       *  repeatedly.\n+       *\n+       *  For example, if the grouping() returns \"\\003\\002\" and is applied to\n+       *  the number 123456789, this corresponds to 12,34,56,789.  Note that\n+       *  if the string was \"32\", this would put more than 50 digits into the\n+       *  least significant group if the character set is ASCII.\n+       *\n+       *  The string is returned by calling\n+       *  numpunct<char_type>::do_grouping().\n+       *\n+       *  @return  string representing grouping specification.\n+      */\n       string       \n       grouping() const\n       { return this->do_grouping(); }\n \n+      /**\n+       *  @brief  Return string representation of bool true.\n+       *\n+       *  This function returns a string_type containing the text\n+       *  representation for true bool variables.  It does so by calling\n+       *  numpunct<char_type>::do_truename().\n+       *\n+       *  @return  string_type representing printed form of true.\n+      */\n       string_type  \n       truename() const\n       { return this->do_truename(); }\n \n+      /**\n+       *  @brief  Return string representation of bool false.\n+       *\n+       *  This function returns a string_type containing the text\n+       *  representation for false bool variables.  It does so by calling\n+       *  numpunct<char_type>::do_falsename().\n+       *\n+       *  @return  string_type representing printed form of false.\n+      */\n       string_type  \n       falsename() const\n       { return this->do_falsename(); }\n \n     protected:\n+      /// Destructor.\n       virtual \n       ~numpunct();\n \n+      /**\n+       *  @brief  Return decimal point character.\n+       *\n+       *  Returns a char_type to use as a decimal point.  This function is a\n+       *  hook for derived classes to change the value returned.\n+       *\n+       *  @return  @a char_type representing a decimal point.\n+      */\n       virtual char_type    \n       do_decimal_point() const\n       { return _M_data->_M_decimal_point; }\n \n+      /**\n+       *  @brief  Return thousands separator character.\n+       *\n+       *  Returns a char_type to use as a thousands separator.  This function\n+       *  is a hook for derived classes to change the value returned.\n+       *\n+       *  @return  @a char_type representing a thousands separator.\n+      */\n       virtual char_type    \n       do_thousands_sep() const\n       { return _M_data->_M_thousands_sep; }\n \n+      /**\n+       *  @brief  Return grouping specification.\n+       *\n+       *  Returns a string representing groupings for the integer part of a\n+       *  number.  This function is a hook for derived classes to change the\n+       *  value returned.  @see grouping() for details.\n+       *\n+       *  @return  String representing grouping specification.\n+      */\n       virtual string\n       do_grouping() const\n       { return _M_data->_M_grouping; }\n \n-      virtual string_type  \n+      /**\n+       *  @brief  Return string representation of bool true.\n+       *\n+       *  Returns a string_type containing the text representation for true\n+       *  bool variables.  This function is a hook for derived classes to\n+       *  change the value returned.\n+       *\n+       *  @return  string_type representing printed form of true.\n+      */\n+      virtual string_type\n       do_truename() const\n       { return _M_data->_M_truename; }\n \n-      virtual string_type  \n+      /**\n+       *  @brief  Return string representation of bool false.\n+       *\n+       *  Returns a string_type containing the text representation for false\n+       *  bool variables.  This function is a hook for derived classes to\n+       *  change the value returned.\n+       *\n+       *  @return  string_type representing printed form of false.\n+      */\n+      virtual string_type\n       do_falsename() const\n       { return _M_data->_M_falsename; }\n \n@@ -1805,24 +1950,100 @@ namespace std\n       ~numpunct_byname() { }\t\n     };\n \n+  /**\n+   *  @brief  Facet for parsing number strings.\n+   *\n+   *  This facet encapsulates the code to parse and return a number\n+   *  from a string.  It is used by the istream numeric extraction\n+   *  operators.\n+   *\n+   *  The num_get template uses protected virtual functions to provide the\n+   *  actual results.  The public accessors forward the call to the virtual\n+   *  functions.  These virtual functions are hooks for developers to\n+   *  implement the behavior they require from the num_get facet.\n+  */\n   template<typename _CharT, typename _InIter>\n     class num_get : public locale::facet, public __num_base\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT   \t\t\tchar_type;\n       typedef _InIter  \t\t\titer_type;\n+      //@}\n \n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       num_get(size_t __refs = 0) : facet(__refs) { }\n \n+      /**\n+       *  @brief  Numeric parsing.\n+       *\n+       *  Parses the input stream into the bool @a v.  It does so by calling\n+       *  num_put::do_put().\n+       *\n+       *  If ios_base::boolalpha is set, attempts to read ctype<CharT>::truename() or\n+       *  ctype<CharT>::falsename().  Sets @a v to true or false if\n+       *  successful.  Sets err to ios_base::failbit if reading the string\n+       *  fails.  Sets err to ios_base::eofbit if the stream is emptied.\n+       *\n+       *  If ios_base::boolalpha is not set, proceeds as with reading a long,\n+       *  except if the value is 1, sets @a v to true, if the value is 0, sets\n+       *  @a v to false, and otherwise set err to ios_base::failbit.\n+       *\n+       *  @param  in  Start of input stream.\n+       *  @param  end  End of input stream.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  err  Error flags to set.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after reading.\n+      */\n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, bool& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n+      //@{\n+      /**\n+       *  @brief  Numeric parsing.\n+       *\n+       *  Parses the input stream into the integral variable @a v.  It does so\n+       *  by calling num_put::do_put().\n+       *\n+       *  Parsing is affected by the flag settings in @a io.\n+       *\n+       *  The basic parse is affected by the value of io.flags() &\n+       *  ios_base::basefield.  If equal to ios_base::oct, parses like the\n+       *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X\n+       *  specifier.  Else if basefield equal to 0, parses like the %i\n+       *  specifier.  Otherwise, parses like %d for signed and %u for unsigned\n+       *  types.  The matching type length modifier is also used.\n+       *\n+       *  Digit grouping is intrepreted according to numpunct::grouping() and\n+       *  numpunct::thousands_sep().  If the pattern of digit groups isn't\n+       *  consistent, sets err to ios_base::failbit.\n+       *\n+       *  If parsing the string yields a valid value for @a v, @a v is set.\n+       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.\n+       *  Sets err to ios_base::eofbit if the stream is emptied.\n+       *\n+       *  @param  in  Start of input stream.\n+       *  @param  end  End of input stream.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  err  Error flags to set.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after reading.\n+      */\n       iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io, \n \t  ios_base::iostate& __err, long& __v) const\n@@ -1854,7 +2075,34 @@ namespace std\n \t  ios_base::iostate& __err, unsigned long long& __v)  const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n #endif\n+      //@}\n \n+      //@{\n+      /**\n+       *  @brief  Numeric parsing.\n+       *\n+       *  Parses the input stream into the integral variable @a v.  It does so\n+       *  by calling num_put::do_put().\n+       *\n+       *  The input characters are parsed like the scanf %g specifier.  The\n+       *  matching type length modifier is also used.\n+       *\n+       *  The decimal point character used is numpunct::decimal_point().\n+       *  Digit grouping is intrepreted according to numpunct::grouping() and\n+       *  numpunct::thousands_sep().  If the pattern of digit groups isn't\n+       *  consistent, sets err to ios_base::failbit.\n+       *\n+       *  If parsing the string yields a valid value for @a v, @a v is set.\n+       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.\n+       *  Sets err to ios_base::eofbit if the stream is emptied.\n+       *\n+       *  @param  in  Start of input stream.\n+       *  @param  end  End of input stream.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  err  Error flags to set.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after reading.\n+      */\n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, float& __v) const\n@@ -1869,13 +2117,41 @@ namespace std\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, long double& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n+      //@}\n \n+      /**\n+       *  @brief  Numeric parsing.\n+       *\n+       *  Parses the input stream into the pointer variable @a v.  It does so\n+       *  by calling num_put::do_put().\n+       *\n+       *  The input characters are parsed like the scanf %p specifier.\n+       *\n+       *  Digit grouping is intrepreted according to numpunct::grouping() and\n+       *  numpunct::thousands_sep().  If the pattern of digit groups isn't\n+       *  consistent, sets err to ios_base::failbit.\n+       *\n+       *  Note that the digit grouping effect for pointers is a bit ambiguous\n+       *  in the standard and shouldn't be relied on.  See DR 344.\n+       *\n+       *  If parsing the string yields a valid value for @a v, @a v is set.\n+       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.\n+       *  Sets err to ios_base::eofbit if the stream is emptied.\n+       *\n+       *  @param  in  Start of input stream.\n+       *  @param  end  End of input stream.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  err  Error flags to set.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after reading.\n+      */\n       iter_type \n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, void*& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }      \n \n     protected:\n+      /// Destructor.\n       virtual ~num_get() { }\n \n       iter_type \n@@ -1887,6 +2163,21 @@ namespace std\n         _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&, \n \t\t       _ValueT& __v) const;\n \n+      //@{\n+      /**\n+       *  @brief  Numeric parsing.\n+       *\n+       *  Parses the input stream into the variable @a v.  This function is a\n+       *  hook for derived classes to change the value returned.  @see get()\n+       *  for more details.\n+       *\n+       *  @param  in  Start of input stream.\n+       *  @param  end  End of input stream.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  err  Error flags to set.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after reading.\n+      */\n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n \n@@ -1931,28 +2222,105 @@ namespace std\n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n \t     void*&) const;\n+      //@}\n     };\n \n   template<typename _CharT, typename _InIter>\n     locale::id num_get<_CharT, _InIter>::id;\n \n \n+  /**\n+   *  @brief  Facet for converting numbers to strings.\n+   *\n+   *  This facet encapsulates the code to convert a number to a string.  It is\n+   *  used by the ostream numeric insertion operators.\n+   *\n+   *  The num_put template uses protected virtual functions to provide the\n+   *  actual results.  The public accessors forward the call to the virtual\n+   *  functions.  These virtual functions are hooks for developers to\n+   *  implement the behavior they require from the num_put facet.\n+  */\n   template<typename _CharT, typename _OutIter>\n     class num_put : public locale::facet, public __num_base\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT       \tchar_type;\n       typedef _OutIter     \titer_type;\n+      //@}\n+\n+      /// Numpunct facet id.\n       static locale::id\t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       num_put(size_t __refs = 0) : facet(__refs) { }\n \n+      /**\n+       *  @brief  Numeric formatting.\n+       *\n+       *  Formats the boolean @a v and inserts it into a stream.  It does so\n+       *  by calling num_put::do_put().\n+       *\n+       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or\n+       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.\n+       *\n+       *  @param  s  Stream to write to.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  fill  Char_type to use for filling.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after writing.\n+      */\n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n \n+      //@{\n+      /**\n+       *  @brief  Numeric formatting.\n+       *\n+       *  Formats the integral value @a v and inserts it into a stream.  It does so\n+       *  by calling num_put::do_put().\n+       *\n+       *  Formatting is affected by the flag settings in @a io.\n+       *\n+       *  The basic format is affected by the value of io.flags() &\n+       *  ios_base::basefield.  If equal to ios_base::oct, formats like the\n+       *  printf %o specifier.  Else if equal to ios_base::hex, formats like\n+       *  %x or %X with ios_base::uppercase unset or set respectively.\n+       *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu\n+       *  for unsigned values.  Note that if both oct and hex are set, neither\n+       *  will take effect.\n+       *\n+       *  If ios_base::showpos is set, '+' is output before positive values.\n+       *  If ios_base::showbase is set, '0' precedes octal values (except 0)\n+       *  and '0[xX]' precedes hex values.\n+       *\n+       *  Thousands separators are inserted according to numpunct::grouping()\n+       *  and numpunct::thousands_sep().  The decimal point character used is\n+       *  numpunct::decimal_point().\n+       *\n+       *  If io.width() is non-zero, enough @a fill characters are inserted to\n+       *  make the result at least that wide.  If\n+       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is\n+       *  padded at the end.  If ios_base::internal, then padding occurs\n+       *  immediately after either a '+' or '-' or after '0x' or '0X'.\n+       *  Otherwise, padding occurs at the beginning.\n+       *\n+       *  @param  s  Stream to write to.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  fill  Char_type to use for filling.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after writing.\n+      */\n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, long __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n@@ -1972,7 +2340,50 @@ namespace std\n \t  unsigned long long __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n #endif\n+      //@}\n \n+      //@{\n+      /**\n+       *  @brief  Numeric formatting.\n+       *\n+       *  Formats the floating point value @a v and inserts it into a stream.\n+       *  It does so by calling num_put::do_put().\n+       *\n+       *  Formatting is affected by the flag settings in @a io.\n+       *\n+       *  The basic format is affected by the value of io.flags() &\n+       *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the\n+       *  printf %f specifier.  Else if equal to ios_base::scientific, formats\n+       *  like %e or %E with ios_base::uppercase unset or set respectively.\n+       *  Otherwise, formats like %g or %G depending on uppercase.  Note that\n+       *  if both fixed and scientific are set, the effect will also be like\n+       *  %g or %G.\n+       *\n+       *  The output precision is given by io.precision().  This precision is\n+       *  capped at numeric_limits::digits10 + 2 (different for double and\n+       *  long double).  The default precision is 6.\n+       *\n+       *  If ios_base::showpos is set, '+' is output before positive values.\n+       *  If ios_base::showpoint is set, a decimal point will always be\n+       *  output.\n+       *\n+       *  Thousands separators are inserted according to numpunct::grouping()\n+       *  and numpunct::thousands_sep().  The decimal point character used is\n+       *  numpunct::decimal_point().\n+       *\n+       *  If io.width() is non-zero, enough @a fill characters are inserted to\n+       *  make the result at least that wide.  If\n+       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is\n+       *  padded at the end.  If ios_base::internal, then padding occurs\n+       *  immediately after either a '+' or '-' or after '0x' or '0X'.\n+       *  Otherwise, padding occurs at the beginning.\n+       *\n+       *  @param  s  Stream to write to.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  fill  Char_type to use for filling.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after writing.\n+      */\n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, double __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n@@ -1981,7 +2392,23 @@ namespace std\n       put(iter_type __s, ios_base& __f, char_type __fill, \n \t  long double __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n+      //@}\n \n+      /**\n+       *  @brief  Numeric formatting.\n+       *\n+       *  Formats the pointer value @a v and inserts it into a stream.  It\n+       *  does so by calling num_put::do_put().\n+       *\n+       *  This function formats @a v as an unsigned long with ios_base::hex\n+       *  and ios_base::showbase set.\n+       *\n+       *  @param  s  Stream to write to.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  fill  Char_type to use for filling.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after writing.\n+      */\n       iter_type \n       put(iter_type __s, ios_base& __f, char_type __fill, \n \t  const void* __v) const\n@@ -2012,9 +2439,24 @@ namespace std\n       _M_pad(char_type __fill, streamsize __w, ios_base& __io, \n \t     char_type* __new, const char_type* __cs, int& __len) const;\n \n+      /// Destructor.\n       virtual \n       ~num_put() { };\n \n+      //@{\n+      /**\n+       *  @brief  Numeric formatting.\n+       *\n+       *  These functions do the work of formatting numeric values and\n+       *  inserting them into a stream. This function is a hook for derived\n+       *  classes to change the value returned.\n+       *\n+       *  @param  s  Stream to write to.\n+       *  @param  io  Source of locale and flags.\n+       *  @param  fill  Char_type to use for filling.\n+       *  @param  v  Value to format and insert.\n+       *  @return  Iterator after writing.\n+      */\n       virtual iter_type \n       do_put(iter_type, ios_base&, char_type __fill, bool __v) const;\n \n@@ -2040,47 +2482,116 @@ namespace std\n \n       virtual iter_type \n       do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;\n+      //@}\n     };\n \n   template <typename _CharT, typename _OutIter>\n     locale::id num_put<_CharT, _OutIter>::id;\n \n \n+  /**\n+   *  @brief  Facet for localized string comparison.\n+   *\n+   *  This facet encapsulates the code to compare strings in a localized\n+   *  manner.\n+   *\n+   *  The collate template uses protected virtual functions to provide\n+   *  the actual results.  The public accessors forward the call to\n+   *  the virtual functions.  These virtual functions are hooks for\n+   *  developers to implement the behavior they require from the\n+   *  collate facet.\n+  */\n   template<typename _CharT>\n     class collate : public locale::facet\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT               \tchar_type;\n       typedef basic_string<_CharT> \tstring_type;\n+      //@}\n \n     protected:\n       // Underlying \"C\" library locale information saved from\n       // initialization, needed by collate_byname as well.\n       __c_locale\t\t\t_M_c_locale_collate;\n  \n     public:\n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       collate(size_t __refs = 0)\n       : facet(__refs)\n       { _M_c_locale_collate = _S_get_c_locale(); }\n \n+      /**\n+       *  @brief  Internal constructor. Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param cloc  The \"C\" locale.\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       collate(__c_locale __cloc, size_t __refs = 0) \n       : facet(__refs)\n       { _M_c_locale_collate = _S_clone_c_locale(__cloc); }\n \n+      /**\n+       *  @brief  Compare two strings.\n+       *\n+       *  This function compares two strings and returns the result by calling\n+       *  collate::do_compare().\n+       *\n+       *  @param lo1  Start of string 1.\n+       *  @param hi1  End of string 1.\n+       *  @param lo2  Start of string 2.\n+       *  @param hi2  End of string 2.\n+       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n+      */\n       int \n       compare(const _CharT* __lo1, const _CharT* __hi1,\n \t      const _CharT* __lo2, const _CharT* __hi2) const\n       { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }\n \n+      /**\n+       *  @brief  Transform string to comparable form.\n+       *\n+       *  This function is a wrapper for strxfrm functionality.  It takes the\n+       *  input string and returns a modified string that can be directly\n+       *  compared to other transformed strings.  In the \"C\" locale, this\n+       *  function just returns a copy of the input string.  In some other\n+       *  locales, it may replace two chars with one, change a char for\n+       *  another, etc.  It does so by returning collate::do_transform().\n+       *\n+       *  @param lo  Start of string.\n+       *  @param hi  End of string.\n+       *  @return  Transformed string_type.\n+      */\n       string_type \n       transform(const _CharT* __lo, const _CharT* __hi) const\n       { return this->do_transform(__lo, __hi); }\n \n+      /**\n+       *  @brief  Return hash of a string.\n+       *\n+       *  This function computes and returns a hash on the input string.  It\n+       *  does so by returning collate::do_hash().\n+       *\n+       *  @param lo  Start of string.\n+       *  @param hi  End of string.\n+       *  @return  Hash value.\n+      */\n       long \n       hash(const _CharT* __lo, const _CharT* __hi) const\n       { return this->do_hash(__lo, __hi); }\n@@ -2093,17 +2604,52 @@ namespace std\n       _M_transform(_CharT*, const _CharT*, size_t) const;\n \n   protected:\n+      /// Destructor.\n       virtual\n       ~collate() \n       { _S_destroy_c_locale(_M_c_locale_collate); }\n \n+      /**\n+       *  @brief  Compare two strings.\n+       *\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.  @see compare().\n+       *\n+       *  @param lo1  Start of string 1.\n+       *  @param hi1  End of string 1.\n+       *  @param lo2  Start of string 2.\n+       *  @param hi2  End of string 2.\n+       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n+      */\n       virtual int  \n       do_compare(const _CharT* __lo1, const _CharT* __hi1,\n \t\t const _CharT* __lo2, const _CharT* __hi2) const;\n \n+      /**\n+       *  @brief  Transform string to comparable form.\n+       *\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.\n+       *\n+       *  @param lo1  Start of string 1.\n+       *  @param hi1  End of string 1.\n+       *  @param lo2  Start of string 2.\n+       *  @param hi2  End of string 2.\n+       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n+      */\n       virtual string_type \n       do_transform(const _CharT* __lo, const _CharT* __hi) const;\n \n+      /**\n+       *  @brief  Return hash of a string.\n+       *\n+       *  This function computes and returns a hash on the input string.  This\n+       *  function is a hook for derived classes to change the value returned.\n+       *\n+       *  @param lo  Start of string.\n+       *  @param hi  End of string.\n+       *  @return  Hash value.\n+      */\n       virtual long   \n       do_hash(const _CharT* __lo, const _CharT* __hi) const;\n     };\n@@ -2134,8 +2680,11 @@ namespace std\n     class collate_byname : public collate<_CharT>\n     {\n     public:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT               char_type;\n       typedef basic_string<_CharT> string_type;\n+      //@}\n \n       explicit \n       collate_byname(const char* __s, size_t __refs = 0)\n@@ -2154,6 +2703,12 @@ namespace std\n     };\n \n \n+  /**\n+   *  @brief  Time format ordering data.\n+   *\n+   *  This class provides an enum representing different orderings of day,\n+   *  month, and year.\n+  */\n   class time_base\n   {\n   public:\n@@ -2286,6 +2841,7 @@ namespace std\n       const char*\t\t\t_M_name_timepunct;\n \n     public:\n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n       explicit \n@@ -2294,6 +2850,16 @@ namespace std\n       explicit \n       __timepunct(__cache_type* __cache, size_t __refs = 0);\n \n+      /**\n+       *  @brief  Internal constructor. Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param cloc  The \"C\" locale.\n+       *  @param s  The name of a locale.\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);\n \n@@ -2425,73 +2991,303 @@ namespace std\n   // Include host and configuration specific timepunct functions.\n   #include <bits/time_members.h>\n \n+  /**\n+   *  @brief  Facet for parsing dates and times.\n+   *\n+   *  This facet encapsulates the code to parse and return a date or\n+   *  time from a string.  It is used by the istream numeric\n+   *  extraction operators.\n+   *\n+   *  The time_get template uses protected virtual functions to provide the\n+   *  actual results.  The public accessors forward the call to the virtual\n+   *  functions.  These virtual functions are hooks for developers to\n+   *  implement the behavior they require from the time_get facet.\n+  */\n   template<typename _CharT, typename _InIter>\n     class time_get : public locale::facet, public time_base\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT     \t\tchar_type;\n       typedef _InIter    \t\titer_type;\n+      //@}\n       typedef basic_string<_CharT> \t__string_type;\n \n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       time_get(size_t __refs = 0) \n       : facet (__refs) { }\n \n+      /**\n+       *  @brief  Return preferred order of month, day, and year.\n+       *\n+       *  This function returns an enum from timebase::dateorder giving the\n+       *  preferred ordering if the format \"x\" given to time_put::put() only\n+       *  uses month, day, and year.  If the format \"x\" for the associated\n+       *  locale uses other fields, this function returns\n+       *  timebase::dateorder::noorder.  \n+       *\n+       *  NOTE: The library always returns noorder at the moment.\n+       *\n+       *  @return  A member of timebase::dateorder.\n+      */\n       dateorder \n       date_order()  const\n       { return this->do_date_order(); }\n \n+      /**\n+       *  @brief  Parse input time string.\n+       *\n+       *  This function parses a time according to the format \"x\" and puts the\n+       *  results into a user-supplied struct tm.  The result is returned by\n+       *  calling time_get::do_get_time().\n+       *\n+       *  If there is a valid time string according to format \"x\", @a tm will\n+       *  be filled in accordingly and the returned iterator will point to the\n+       *  first character beyond the time string.  If an error occurs before\n+       *  the end, err |= ios_base::failbit.  If parsing reads all the\n+       *  characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond time string.\n+      */\n       iter_type \n       get_time(iter_type __beg, iter_type __end, ios_base& __io, \n \t       ios_base::iostate& __err, tm* __tm)  const\n       { return this->do_get_time(__beg, __end, __io, __err, __tm); }\n \n+      /**\n+       *  @brief  Parse input date string.\n+       *\n+       *  This function parses a date according to the format \"X\" and puts the\n+       *  results into a user-supplied struct tm.  The result is returned by\n+       *  calling time_get::do_get_date().\n+       *\n+       *  If there is a valid date string according to format \"X\", @a tm will\n+       *  be filled in accordingly and the returned iterator will point to the\n+       *  first character beyond the date string.  If an error occurs before\n+       *  the end, err |= ios_base::failbit.  If parsing reads all the\n+       *  characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond date string.\n+      */\n       iter_type \n       get_date(iter_type __beg, iter_type __end, ios_base& __io,\n \t       ios_base::iostate& __err, tm* __tm)  const\n       { return this->do_get_date(__beg, __end, __io, __err, __tm); }\n \n+      /**\n+       *  @brief  Parse input weekday string.\n+       *\n+       *  This function parses a weekday name and puts the results into a\n+       *  user-supplied struct tm.  The result is returned by calling\n+       *  time_get::do_get_weekday().\n+       *\n+       *  Parsing starts by parsing an abbreviated weekday name.  If a valid\n+       *  abbreviation is followed by a character that would lead to the full\n+       *  weekday name, parsing continues until the full name is found or an\n+       *  error occurs.  Otherwise parsing finishes at the end of the\n+       *  abbreviated name.\n+       *\n+       *  If an error occurs before the end, err |= ios_base::failbit.  If\n+       *  parsing reads all the characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond weekday name.\n+      */\n       iter_type \n       get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const\n       { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }\n \n+      /**\n+       *  @brief  Parse input month string.\n+       *\n+       *  This function parses a month name and puts the results into a\n+       *  user-supplied struct tm.  The result is returned by calling\n+       *  time_get::do_get_monthname().\n+       *\n+       *  Parsing starts by parsing an abbreviated month name.  If a valid\n+       *  abbreviation is followed by a character that would lead to the full\n+       *  month name, parsing continues until the full name is found or an\n+       *  error occurs.  Otherwise parsing finishes at the end of the\n+       *  abbreviated name.\n+       *\n+       *  If an error occurs before the end, err |= ios_base::failbit.  If\n+       *  parsing reads all the characters, err |=\n+       *  ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond month name.\n+      */\n       iter_type \n       get_monthname(iter_type __beg, iter_type __end, ios_base& __io, \n \t\t    ios_base::iostate& __err, tm* __tm) const\n       { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }\n \n+      /**\n+       *  @brief  Parse input year string.\n+       *\n+       *  This function reads up to 4 characters to parse a year string and\n+       *  puts the results into a user-supplied struct tm.  The result is\n+       *  returned by calling time_get::do_get_year().\n+       *\n+       *  4 consecutive digits are interpreted as a full year.  If there are\n+       *  exactly 2 consecutive digits, the library interprets this as the\n+       *  number of years since 1900.\n+       *\n+       *  If an error occurs before the end, err |= ios_base::failbit.  If\n+       *  parsing reads all the characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond year.\n+      */\n       iter_type \n       get_year(iter_type __beg, iter_type __end, ios_base& __io,\n \t       ios_base::iostate& __err, tm* __tm) const\n       { return this->do_get_year(__beg, __end, __io, __err, __tm); }\n \n     protected:\n+      /// Destructor.\n       virtual \n       ~time_get() { }\n \n+      /**\n+       *  @brief  Return preferred order of month, day, and year.\n+       *\n+       *  This function returns an enum from timebase::dateorder giving the\n+       *  preferred ordering if the format \"x\" given to time_put::put() only\n+       *  uses month, day, and year.  This function is a hook for derived\n+       *  classes to change the value returned.\n+       *\n+       *  @return  A member of timebase::dateorder.\n+      */\n       virtual dateorder \n       do_date_order() const;\n \n+      /**\n+       *  @brief  Parse input time string.\n+       *\n+       *  This function parses a time according to the format \"x\" and puts the\n+       *  results into a user-supplied struct tm.  This function is a hook for\n+       *  derived classes to change the value returned.  @see get_time() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond time string.\n+      */\n       virtual iter_type \n       do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const;\n \n+      /**\n+       *  @brief  Parse input date string.\n+       *\n+       *  This function parses a date according to the format \"X\" and puts the\n+       *  results into a user-supplied struct tm.  This function is a hook for\n+       *  derived classes to change the value returned.  @see get_date() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond date string.\n+      */\n       virtual iter_type \n       do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const;\n \n+      /**\n+       *  @brief  Parse input weekday string.\n+       *\n+       *  This function parses a weekday name and puts the results into a\n+       *  user-supplied struct tm.  This function is a hook for derived\n+       *  classes to change the value returned.  @see get_weekday() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond weekday name.\n+      */\n       virtual iter_type \n       do_get_weekday(iter_type __beg, iter_type __end, ios_base&,\n \t\t     ios_base::iostate& __err, tm* __tm) const;\n \n+      /**\n+       *  @brief  Parse input month string.\n+       *\n+       *  This function parses a month name and puts the results into a\n+       *  user-supplied struct tm.  This function is a hook for derived\n+       *  classes to change the value returned.  @see get_monthname() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond month name.\n+      */\n       virtual iter_type \n       do_get_monthname(iter_type __beg, iter_type __end, ios_base&, \n \t\t       ios_base::iostate& __err, tm* __tm) const;\n \n+      /**\n+       *  @brief  Parse input year string.\n+       *\n+       *  This function reads up to 4 characters to parse a year string and\n+       *  puts the results into a user-supplied struct tm.  This function is a\n+       *  hook for derived classes to change the value returned.  @see\n+       *  get_year() for details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond year.\n+      */\n       virtual iter_type \n       do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const;\n@@ -2538,34 +3334,104 @@ namespace std\n       ~time_get_byname() { }\n     };\n \n+  /**\n+   *  @brief  Facet for outputting dates and times.\n+   *\n+   *  This facet encapsulates the code to format and output dates and times\n+   *  according to formats used by strftime().\n+   *\n+   *  The time_put template uses protected virtual functions to provide the\n+   *  actual results.  The public accessors forward the call to the virtual\n+   *  functions.  These virtual functions are hooks for developers to\n+   *  implement the behavior they require from the time_put facet.\n+  */\n   template<typename _CharT, typename _OutIter>\n     class time_put : public locale::facet, public time_base\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT     \t\tchar_type;\n       typedef _OutIter   \t\titer_type;\n+      //@}\n \n+      /// Numpunct facet id.\n       static locale::id \t     \tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       time_put(size_t __refs = 0) \n       : facet(__refs) { }\n \n+      /**\n+       *  @brief  Format and output a time or date.\n+       *\n+       *  This function formats the data in struct tm according to the\n+       *  provided format string.  The format string is interpreted as by\n+       *  strftime().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  io  Source of locale.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  tm  Struct tm with date and time info to format.\n+       *  @param  beg  Start of format string.\n+       *  @param  end  End of format string.\n+       *  @return  Iterator after writing.\n+       */\n       iter_type \n       put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm, \n \t  const _CharT* __beg, const _CharT* __end) const;\n \n+      /**\n+       *  @brief  Format and output a time or date.\n+       *\n+       *  This function formats the data in struct tm according to the\n+       *  provided format char and optional modifier.  The format and modifier\n+       *  are interpreted as by strftime().  It does so by returning\n+       *  time_put::do_put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  io  Source of locale.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  tm  Struct tm with date and time info to format.\n+       *  @param  format  Format char.\n+       *  @param  mod  Optional modifier char.\n+       *  @return  Iterator after writing.\n+       */\n       iter_type \n       put(iter_type __s, ios_base& __io, char_type __fill,\n \t  const tm* __tm, char __format, char __mod = 0) const\n       { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }\n \n     protected:\n+      /// Destructor.\n       virtual \n       ~time_put()\n       { }\n \n+      /**\n+       *  @brief  Format and output a time or date.\n+       *\n+       *  This function formats the data in struct tm according to the\n+       *  provided format char and optional modifier.  This function is a hook\n+       *  for derived classes to change the value returned.  @see put() for\n+       *  more details.\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  io  Source of locale.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  tm  Struct tm with date and time info to format.\n+       *  @param  format  Format char.\n+       *  @param  mod  Optional modifier char.\n+       *  @return  Iterator after writing.\n+       */\n       virtual iter_type \n       do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm, \n \t     char __format, char __mod) const;\n@@ -2593,6 +3459,16 @@ namespace std\n     };\n \n \n+  /**\n+   *  @brief  Money format ordering data.\n+   *\n+   *  This class contains an ordered array of 4 fields to represent the\n+   *  pattern for formatting a money amount.  Each field may contain one entry\n+   *  from the part enum.  symbol, sign, and value must be present and the\n+   *  remaining field must contain either none or space.  @see\n+   *  moneypunct::pos_format() and moneypunct::neg_format() for details of how\n+   *  these fields are interpreted.\n+  */\n   class money_base\n   {\n   public:\n@@ -2646,108 +3522,350 @@ namespace std\n \t}\n     }\n \n+  /**\n+   *  @brief  Facet for formatting data for money amounts.\n+   *\n+   *  This facet encapsulates the punctuation, grouping and other formatting\n+   *  features of money amount string representations.\n+  */\n   template<typename _CharT, bool _Intl>\n     class moneypunct : public locale::facet, public money_base\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT \t\t       \tchar_type;\n       typedef basic_string<_CharT> \tstring_type;\n+      //@}\n       typedef __moneypunct_cache<_CharT>\t__cache_type;\n \n     private:\n       __cache_type*\t\t\t_M_data;\n \n     public:\n+      /// This value is provided by the standard, but no reason for its\n+      /// existence.\n       static const bool \t\tintl = _Intl;\n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       moneypunct(size_t __refs = 0) : facet(__refs), _M_data(NULL)\n       { _M_initialize_moneypunct(); }\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is an internal constructor.\n+       *\n+       *  @param cache  Cache for optimization.\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       moneypunct(__cache_type* __cache, size_t __refs = 0) \n       : facet(__refs), _M_data(__cache)\n       { _M_initialize_moneypunct(); }\n \n+      /**\n+       *  @brief  Internal constructor. Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param cloc  The \"C\" locale.\n+       *  @param s  The name of a locale.\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0) \n       : facet(__refs), _M_data(NULL)\n       { _M_initialize_moneypunct(__cloc, __s); }\n \n+      /**\n+       *  @brief  Return decimal point character.\n+       *\n+       *  This function returns a char_type to use as a decimal point.  It\n+       *  does so by returning returning\n+       *  moneypunct<char_type>::do_decimal_point().\n+       *\n+       *  @return  @a char_type representing a decimal point.\n+      */\n       char_type\n       decimal_point() const\n       { return this->do_decimal_point(); }\n       \n+      /**\n+       *  @brief  Return thousands separator character.\n+       *\n+       *  This function returns a char_type to use as a thousands separator.  It\n+       *  does so by returning returning\n+       *  moneypunct<char_type>::do_thousands_sep().\n+       *\n+       *  @return  char_type representing a thousands separator.\n+      */\n       char_type\n       thousands_sep() const\n       { return this->do_thousands_sep(); }\n       \n+      /**\n+       *  @brief  Return grouping specification.\n+       *\n+       *  This function returns a string representing groupings for the\n+       *  integer part of an amount.  Groupings indicate where thousands\n+       *  separators should be inserted.\n+       *\n+       *  Each char in the return string is interpret as an integer rather\n+       *  than a character.  These numbers represent the number of digits in a\n+       *  group.  The first char in the string represents the number of digits\n+       *  in the least significant group.  If a char is negative, it indicates\n+       *  an unlimited number of digits for the group.  If more chars from the\n+       *  string are required to group a number, the last char is used\n+       *  repeatedly.\n+       *\n+       *  For example, if the grouping() returns \"\\003\\002\" and is applied to\n+       *  the number 123456789, this corresponds to 12,34,56,789.  Note that\n+       *  if the string was \"32\", this would put more than 50 digits into the\n+       *  least significant group if the character set is ASCII.\n+       *\n+       *  The string is returned by calling\n+       *  moneypunct<char_type>::do_grouping().\n+       *\n+       *  @return  string representing grouping specification.\n+      */\n       string \n       grouping() const\n       { return this->do_grouping(); }\n \n+      /**\n+       *  @brief  Return currency symbol string.\n+       *\n+       *  This function returns a string_type to use as a currency symbol.  It\n+       *  does so by returning returning\n+       *  moneypunct<char_type>::do_curr_symbol().\n+       *\n+       *  @return  @a string_type representing a currency symbol.\n+      */\n       string_type  \n       curr_symbol() const\n       { return this->do_curr_symbol(); }\n \n+      /**\n+       *  @brief  Return positive sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for positive\n+       *  amounts.  It does so by returning returning\n+       *  moneypunct<char_type>::do_positive_sign().\n+       *\n+       *  If the return value contains more than one character, the first\n+       *  character appears in the position indicated by pos_format() and the\n+       *  remainder appear at the end of the formatted string.\n+       *\n+       *  @return  @a string_type representing a positive sign.\n+      */\n       string_type  \n       positive_sign() const\n       { return this->do_positive_sign(); }\n \n+      /**\n+       *  @brief  Return negative sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for negative\n+       *  amounts.  It does so by returning returning\n+       *  moneypunct<char_type>::do_negative_sign().\n+       *\n+       *  If the return value contains more than one character, the first\n+       *  character appears in the position indicated by neg_format() and the\n+       *  remainder appear at the end of the formatted string.\n+       *\n+       *  @return  @a string_type representing a negative sign.\n+      */\n       string_type  \n       negative_sign() const\n       { return this->do_negative_sign(); }\n \n-      int          \n+      /**\n+       *  @brief  Return number of digits in fraction.\n+       *\n+       *  This function returns the exact number of digits that make up the\n+       *  fractional part of a money amount.  It does so by returning\n+       *  returning moneypunct<char_type>::do_frac_digits().\n+       *\n+       *  The fractional part of a money amount is optional.  But if it is\n+       *  present, there must be frac_digits() digits.\n+       *\n+       *  @return  Number of digits in amount fraction.\n+      */\n+      int\n       frac_digits() const\n       { return this->do_frac_digits(); }\n \n-      pattern      \n+      //@{\n+      /**\n+       *  @brief  Return pattern for money values.\n+       *\n+       *  This function returns a pattern describing the formatting of a\n+       *  positive or negative valued money amount.  It does so by returning\n+       *  returning moneypunct<char_type>::do_pos_format() or\n+       *  moneypunct<char_type>::do_neg_format().\n+       *\n+       *  The pattern has 4 fields describing the ordering of symbol, sign,\n+       *  value, and none or space.  There must be one of each in the pattern.\n+       *  The none and space enums may not appear in the first field and space\n+       *  may not appear in the final field.\n+       *\n+       *  The parts of a money string must appear in the order indicated by\n+       *  the fields of the pattern.  The symbol field indicates that the\n+       *  value of curr_symbol() may be present.  The sign field indicates\n+       *  that the value of positive_sign() or negative_sign() must be\n+       *  present.  The value field indicates that the absolute value of the\n+       *  money amount is present.  none indicates 0 or more whitespace\n+       *  characters, except at the end, where it permits no whitespace.\n+       *  space indicates that 1 or more whitespace characters must be\n+       *  present.\n+       *\n+       *  For example, for the US locale and pos_format() pattern\n+       *  {symbol,sign,value,none}, curr_symbol() == '$' positive_sign() ==\n+       *  '+', and value 10.01, and options set to force the symbol, the\n+       *  corresponding string is \"$+10.01\".\n+       *\n+       *  @return  Pattern for money values.\n+      */\n+      pattern\n       pos_format() const\n       { return this->do_pos_format(); }\n \n       pattern      \n       neg_format() const\n       { return this->do_neg_format(); }\n+      //@}\n \n     protected:\n+      /// Destructor.\n       virtual \n       ~moneypunct();\n \n+      /**\n+       *  @brief  Return decimal point character.\n+       *\n+       *  Returns a char_type to use as a decimal point.  This function is a\n+       *  hook for derived classes to change the value returned.\n+       *\n+       *  @return  @a char_type representing a decimal point.\n+      */\n       virtual char_type\n       do_decimal_point() const\n       { return _M_data->_M_decimal_point; }\n       \n+      /**\n+       *  @brief  Return thousands separator character.\n+       *\n+       *  Returns a char_type to use as a thousands separator.  This function\n+       *  is a hook for derived classes to change the value returned.\n+       *\n+       *  @return  @a char_type representing a thousands separator.\n+      */\n       virtual char_type\n       do_thousands_sep() const\n       { return _M_data->_M_thousands_sep; }\n       \n+      /**\n+       *  @brief  Return grouping specification.\n+       *\n+       *  Returns a string representing groupings for the integer part of a\n+       *  number.  This function is a hook for derived classes to change the\n+       *  value returned.  @see grouping() for details.\n+       *\n+       *  @return  String representing grouping specification.\n+      */\n       virtual string \n       do_grouping() const\n       { return _M_data->_M_grouping; }\n \n+      /**\n+       *  @brief  Return currency symbol string.\n+       *\n+       *  This function returns a string_type to use as a currency symbol.\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.  @see curr_symbol() for details.\n+       *\n+       *  @return  @a string_type representing a currency symbol.\n+      */\n       virtual string_type  \n       do_curr_symbol()   const\n       { return _M_data->_M_curr_symbol; }\n \n+      /**\n+       *  @brief  Return positive sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for positive\n+       *  amounts.  This function is a hook for derived classes to change the\n+       *  value returned.  @see positive_sign() for details.\n+       *\n+       *  @return  @a string_type representing a positive sign.\n+      */\n       virtual string_type  \n       do_positive_sign() const\n       { return _M_data->_M_positive_sign; }\n \n+      /**\n+       *  @brief  Return negative sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for negative\n+       *  amounts.  This function is a hook for derived classes to change the\n+       *  value returned.  @see negative_sign() for details.\n+       *\n+       *  @return  @a string_type representing a negative sign.\n+      */\n       virtual string_type  \n       do_negative_sign() const\n       { return _M_data->_M_negative_sign; }\n \n+      /**\n+       *  @brief  Return number of digits in fraction.\n+       *\n+       *  This function returns the exact number of digits that make up the\n+       *  fractional part of a money amount.  This function is a hook for\n+       *  derived classes to change the value returned.  @see frac_digits()\n+       *  for details.\n+       *\n+       *  @return  Number of digits in amount fraction.\n+      */\n       virtual int          \n       do_frac_digits() const\n       { return _M_data->_M_frac_digits; }\n \n+      /**\n+       *  @brief  Return pattern for money values.\n+       *\n+       *  This function returns a pattern describing the formatting of a\n+       *  positive valued money amount.  This function is a hook for derived\n+       *  classes to change the value returned.  @see pos_format() for\n+       *  details.\n+       *\n+       *  @return  Pattern for money values.\n+      */\n       virtual pattern      \n       do_pos_format() const\n       { return _M_data->_M_pos_format; }\n \n+      /**\n+       *  @brief  Return pattern for money values.\n+       *\n+       *  This function returns a pattern describing the formatting of a\n+       *  negative valued money amount.  This function is a hook for derived\n+       *  classes to change the value returned.  @see neg_format() for\n+       *  details.\n+       *\n+       *  @return  Pattern for money values.\n+      */\n       virtual pattern      \n       do_neg_format() const\n       { return _M_data->_M_neg_format; }\n@@ -2826,38 +3944,128 @@ namespace std\n   template<typename _CharT, bool _Intl>\n     const bool moneypunct_byname<_CharT, _Intl>::intl;\n \n+  /**\n+   *  @brief  Facet for parsing monetary amounts.\n+   *\n+   *  This facet encapsulates the code to parse and return a monetary\n+   *  amount from a string.\n+   *\n+   *  The money_get template uses protected virtual functions to\n+   *  provide the actual results.  The public accessors forward the\n+   *  call to the virtual functions.  These virtual functions are\n+   *  hooks for developers to implement the behavior they require from\n+   *  the money_get facet.\n+  */\n   template<typename _CharT, typename _InIter>\n     class money_get : public locale::facet\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT        \t\tchar_type;\n       typedef _InIter       \t\titer_type;\n       typedef basic_string<_CharT> \tstring_type;\n+      //@}\n \n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       money_get(size_t __refs = 0) : facet(__refs) { }\n \n-      iter_type \n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads characters from @a s, interprets them as a\n+       *  monetary value according to moneypunct and ctype facets retrieved\n+       *  from io.getloc(), and returns the result in @a units as an integral\n+       *  value moneypunct::frac_digits() * the actual amount.  For example,\n+       *  the string $10.01 in a US locale would store 1001 in @a units.\n+       *\n+       *  Any characters not part of a valid money amount are not consumed.\n+       *\n+       *  If a money value cannot be parsed from the input stream, sets\n+       *  err=(err|io.failbit).  If the stream is consumed before finishing\n+       *  parsing,  sets err=(err|io.failbit|io.eofbit).  @a units is\n+       *  unchanged if parsing fails.\n+       *\n+       *  This function works by returning the result of do_get().\n+       *\n+       *  @param  s  Start of characters to parse.\n+       *  @param  end  End of characters to parse.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  err  Error field to set if parsing fails.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator referencing first character beyond valid money\n+       *  \t   amount. \n+       */\n+      iter_type\n       get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n \t  ios_base::iostate& __err, long double& __units) const\n       { return this->do_get(__s, __end, __intl, __io, __err, __units); }\n \n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads characters from @a s, interprets them as a\n+       *  monetary value according to moneypunct and ctype facets retrieved\n+       *  from io.getloc(), and returns the result in @a digits.  For example,\n+       *  the string $10.01 in a US locale would store \"1001\" in @a digits.\n+       *\n+       *  Any characters not part of a valid money amount are not consumed.\n+       *\n+       *  If a money value cannot be parsed from the input stream, sets\n+       *  err=(err|io.failbit).  If the stream is consumed before finishing\n+       *  parsing,  sets err=(err|io.failbit|io.eofbit).\n+       *\n+       *  This function works by returning the result of do_get().\n+       *\n+       *  @param  s  Start of characters to parse.\n+       *  @param  end  End of characters to parse.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  err  Error field to set if parsing fails.\n+       *  @param  digits  Place to store result of parsing.\n+       *  @return  Iterator referencing first character beyond valid money\n+       *  \t   amount. \n+       */\n       iter_type \n       get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n \t  ios_base::iostate& __err, string_type& __digits) const\n       { return this->do_get(__s, __end, __intl, __io, __err, __digits); }\n \n     protected:\n+      /// Destructor.\n       virtual \n       ~money_get() { }\n \n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads and parses characters representing a monetary\n+       *  value.  This function is a hook for derived classes to change the\n+       *  value returned.  @see get() for details.\n+       */\n       virtual iter_type \n       do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n \t     ios_base::iostate& __err, long double& __units) const;\n \n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads and parses characters representing a monetary\n+       *  value.  This function is a hook for derived classes to change the\n+       *  value returned.  @see get() for details.\n+       */\n       virtual iter_type \n       do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n \t     ios_base::iostate& __err, string_type& __digits) const;\n@@ -2866,37 +4074,131 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     locale::id money_get<_CharT, _InIter>::id;\n \n+  /**\n+   *  @brief  Facet for outputting monetary amounts.\n+   *\n+   *  This facet encapsulates the code to format and output a monetary\n+   *  amount.\n+   *\n+   *  The money_put template uses protected virtual functions to\n+   *  provide the actual results.  The public accessors forward the\n+   *  call to the virtual functions.  These virtual functions are\n+   *  hooks for developers to implement the behavior they require from\n+   *  the money_put facet.\n+  */\n   template<typename _CharT, typename _OutIter>\n     class money_put : public locale::facet\n     {\n     public:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT              \tchar_type;\n       typedef _OutIter            \titer_type;\n       typedef basic_string<_CharT>\tstring_type;\n+      //@}\n \n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       money_put(size_t __refs = 0) : facet(__refs) { }\n \n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a units as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the value 1001 in a\n+       *  US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function works by returning the result of do_put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n       iter_type \n       put(iter_type __s, bool __intl, ios_base& __io,\n \t  char_type __fill, long double __units) const\n       { return this->do_put(__s, __intl, __io, __fill, __units); }\n \n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a digits as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the string \"1001\" in\n+       *  a US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function works by returning the result of do_put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n       iter_type \n       put(iter_type __s, bool __intl, ios_base& __io,\n \t  char_type __fill, const string_type& __digits) const\n       { return this->do_put(__s, __intl, __io, __fill, __digits); }\n \n     protected:\n+      /// Destructor.\n       virtual \n       ~money_put() { }\n \n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a units as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the value 1001 in a\n+       *  US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.  @see put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n       virtual iter_type\n       do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n \t     long double __units) const;\n \n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a digits as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the string \"1001\" in\n+       *  a US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.  @see put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n       virtual iter_type\n       do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n \t     const string_type& __digits) const;\n@@ -2905,19 +4207,44 @@ namespace std\n   template<typename _CharT, typename _OutIter>\n     locale::id money_put<_CharT, _OutIter>::id;\n \n-\n+  /**\n+   *  @brief  Messages facet base class providing catalog typedef.\n+   */\n   struct messages_base\n   {\n     typedef int catalog;\n   };\n \n+  /**\n+   *  @brief  Facet for handling message catalogs\n+   *\n+   *  This facet encapsulates the code to retrieve messages from\n+   *  message catalogs.  The only thing defined by the standard for this facet\n+   *  is the interface.  All underlying functionality is\n+   *  implementation-defined.\n+   *\n+   *  This library currently implements 3 versions of the message facet.  The\n+   *  first version (gnu) is a wrapper around gettext, provided by libintl.\n+   *  The second version (ieee) is a wrapper around catgets.  The final\n+   *  version (default) does no actual translation.  These implementations are\n+   *  only provided for char and wchar_t instantiations.\n+   *\n+   *  The messages template uses protected virtual functions to\n+   *  provide the actual results.  The public accessors forward the\n+   *  call to the virtual functions.  These virtual functions are\n+   *  hooks for developers to implement the behavior they require from\n+   *  the messages facet.\n+  */\n   template<typename _CharT>\n     class messages : public locale::facet, public messages_base\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT \t\t\tchar_type;\n       typedef basic_string<_CharT> \tstring_type;\n+      //@}\n \n     protected:\n       // Underlying \"C\" library locale information saved from\n@@ -2926,41 +4253,137 @@ namespace std\n       const char*\t\t\t_M_name_messages;\n \n     public:\n+      /// Numpunct facet id.\n       static locale::id \t\tid;\n \n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n       explicit \n       messages(size_t __refs = 0);\n \n       // Non-standard.\n+      /**\n+       *  @brief  Internal constructor.  Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param  cloc  The \"C\" locale.\n+       *  @param  s  The name of a locale.\n+       *  @param  refs  Refcount to pass to the base class.\n+       */\n       explicit \n       messages(__c_locale __cloc, const char* __s, size_t __refs = 0);\n \n+      /*\n+       *  @brief  Open a message catalog.\n+       *\n+       *  This function opens and returns a handle to a message catalog by\n+       *  returning do_open(s, loc).\n+       *\n+       *  @param  s  The catalog to open.\n+       *  @param  loc  Locale to use for character set conversions.\n+       *  @return  Handle to the catalog or value < 0 if open fails.\n+      */\n       catalog \n       open(const basic_string<char>& __s, const locale& __loc) const\n       { return this->do_open(__s, __loc); }\n \n       // Non-standard and unorthodox, yet effective.\n+      /*\n+       *  @brief  Open a message catalog.\n+       *\n+       *  This non-standard function opens and returns a handle to a message\n+       *  catalog by returning do_open(s, loc).  The third argument provides a\n+       *  message catalog root directory for gnu gettext and is ignored\n+       *  otherwise.\n+       *\n+       *  @param  s  The catalog to open.\n+       *  @param  loc  Locale to use for character set conversions.\n+       *  @param  dir  Message catalog root directory.\n+       *  @return  Handle to the catalog or value < 0 if open fails.\n+      */\n       catalog \n       open(const basic_string<char>&, const locale&, const char*) const;\n \n+      /*\n+       *  @brief  Look up a string in a message catalog.\n+       *\n+       *  This function retrieves and returns a message from a catalog by\n+       *  returning do_get(c, set, msgid, s).\n+       *\n+       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).\n+       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).\n+       *\n+       *  @param  c  The catalog to access.\n+       *  @param  set  Implementation-defined.\n+       *  @param  msgid  Implementation-defined.\n+       *  @param  s  Default return value if retrieval fails.\n+       *  @return  Retrieved message or @a s if get fails.\n+      */\n       string_type  \n       get(catalog __c, int __set, int __msgid, const string_type& __s) const\n       { return this->do_get(__c, __set, __msgid, __s); }\n \n+      /*\n+       *  @brief  Close a message catalog.\n+       *\n+       *  Closes catalog @a c by calling do_close(c).\n+       *\n+       *  @param  c  The catalog to close.\n+      */\n       void \n       close(catalog __c) const\n       { return this->do_close(__c); }\n \n     protected:\n+      /// Destructor.\n       virtual \n       ~messages();\n \n+      /*\n+       *  @brief  Open a message catalog.\n+       *\n+       *  This function opens and returns a handle to a message catalog in an\n+       *  implementation-defined manner.  This function is a hook for derived\n+       *  classes to change the value returned.\n+       *\n+       *  @param  s  The catalog to open.\n+       *  @param  loc  Locale to use for character set conversions.\n+       *  @return  Handle to the opened catalog, value < 0 if open failed.\n+      */\n       virtual catalog \n       do_open(const basic_string<char>&, const locale&) const;\n \n+      /*\n+       *  @brief  Look up a string in a message catalog.\n+       *\n+       *  This function retrieves and returns a message from a catalog in an\n+       *  implementation-defined manner.  This function is a hook for derived\n+       *  classes to change the value returned.\n+       *\n+       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).\n+       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).\n+       *\n+       *  @param  c  The catalog to access.\n+       *  @param  set  Implementation-defined.\n+       *  @param  msgid  Implementation-defined.\n+       *  @param  s  Default return value if retrieval fails.\n+       *  @return  Retrieved message or @a s if get fails.\n+      */\n       virtual string_type  \n       do_get(catalog, int, int, const string_type& __dfault) const;\n \n+      /*\n+       *  @brief  Close a message catalog.\n+       *\n+       *  @param  c  The catalog to close.\n+      */\n       virtual void    \n       do_close(catalog) const;\n "}, {"sha": "4a6d532b01d1d92f9f24791e3b26e18b877717a0", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a01c9b061ea6ac729730ac9d4999e4d60c4df3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=9a01c9b061ea6ac729730ac9d4999e4d60c4df3d", "patch": "@@ -1551,6 +1551,10 @@ namespace std\n     time_get<_CharT, _InIter>::do_date_order() const\n     { return time_base::no_order; }\n \n+  // Recursively expand a strftime format string and parse it.  Starts w/ %x\n+  // and %X from do_get_time() and do_get_date(), which translate to a more\n+  // specific string, which may contain yet more strings.  I.e. %x => %r =>\n+  // %H:%M:%S => extracted characters.\n   template<typename _CharT, typename _InIter>\n     void\n     time_get<_CharT, _InIter>::"}]}