{"sha": "41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFlZmRhOGY1M2U0YThlZGQyYmZmZjZjY2MzZjJkMWVlN2I5YzIyYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-06-11T00:07:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-06-11T00:07:24Z"}, "message": "call.c (convert_default_arg): Make global, not static.\n\n\t* call.c (convert_default_arg): Make global, not static.\n\t(convert_arg_for_ellipsis): Split out from ...\n\t(build_over_call): Here.\n\t* cp-tree.h (convert_default_arg); Declare.\n\t(convert_arg_to_ellipsis): Likewise.\n\t(do_member_init): Remove.\n\t* init.c (do_member_init): Remove; this code is dead.\n\t(expand_member_init): Remove much of this code; it is dead.\n\t* typeck.c (convert_arguments): Use convert_default_arg and\n\tconvert_arg_for_ellipsis, rather than duplicating here.\n\t* call.c (convert_like): Don't fail silently if\n\tbuild_user_type_conversion fails.  Always return error_mark_node\n\tfor failure.\n\nFrom-SVN: r20424", "tree": {"sha": "c1189af495a1437dc230d7b58fe49140aa3d3e1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1189af495a1437dc230d7b58fe49140aa3d3e1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/comments", "author": null, "committer": null, "parents": [{"sha": "8358a974b5f51600a204192c91407ac6355c0ca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8358a974b5f51600a204192c91407ac6355c0ca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8358a974b5f51600a204192c91407ac6355c0ca5"}], "stats": {"total": 372, "additions": 149, "deletions": 223}, "files": [{"sha": "f37a3e481895d70f3a6b637fc6c5a816914a8745", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "patch": "@@ -1,3 +1,20 @@\n+1998-06-10  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* call.c (convert_default_arg): Make global, not static.\n+\t(convert_arg_for_ellipsis): Split out from ...\n+\t(build_over_call): Here.\n+\t* cp-tree.h (convert_default_arg); Declare.\n+\t(convert_arg_to_ellipsis): Likewise.\n+\t(do_member_init): Remove.\n+\t* init.c (do_member_init): Remove; this code is dead.\n+\t(expand_member_init): Remove much of this code; it is dead.\n+\t* typeck.c (convert_arguments): Use convert_default_arg and\n+\tconvert_arg_for_ellipsis, rather than duplicating here.\n+\t\n+\t* call.c (convert_like): Don't fail silently if \n+\tbuild_user_type_conversion fails.  Always return error_mark_node \n+\tfor failure.\n+\n 1998-06-10  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* search.c (covariant_return_p): Complain about ambiguous base."}, {"sha": "429b4cf4758e91d468d5dd816706de19449025c5", "filename": "gcc/cp/call.c", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "patch": "@@ -47,7 +47,6 @@ static struct z_candidate * tourney PROTO((struct z_candidate *));\n static int joust PROTO((struct z_candidate *, struct z_candidate *, int));\n static int compare_ics PROTO((tree, tree));\n static tree build_over_call PROTO((struct z_candidate *, tree, int));\n-static tree convert_default_arg PROTO((tree, tree));\n static tree convert_like PROTO((tree, tree));\n static void op_error PROTO((enum tree_code, enum tree_code, tree, tree,\n \t\t\t    tree, char *));\n@@ -3155,8 +3154,32 @@ convert_like (convs, expr)\n \treturn expr;\n       /* else fall through */\n     case BASE_CONV:\n-      return build_user_type_conversion\n-\t(TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n+      {\n+\ttree cvt_expr = build_user_type_conversion\n+\t  (TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n+\tif (!cvt_expr) \n+\t  {\n+\t    /* This can occur if, for example, the EXPR has incomplete\n+\t       type.  We can't check for that before attempting the\n+\t       conversion because the type might be an incomplete\n+\t       array type, which is OK if some constructor for the\n+\t       destination type takes a pointer argument.  */\n+\t    if (TYPE_SIZE (TREE_TYPE (expr)) == 0)\n+\t      {\n+\t\tif (comptypes (TREE_TYPE (expr), TREE_TYPE (convs), 1))\n+\t\t  incomplete_type_error (expr, TREE_TYPE (expr));\n+\t\telse\n+\t\t  cp_error (\"could not convert `%E' (with incomplete type `%T') to `%T'\",\n+\t\t\t    expr, TREE_TYPE (expr), TREE_TYPE (convs));\n+\t      }\n+\t    else\n+\t      cp_error (\"could not convert `%E' to `%T'\",\n+\t\t\texpr, TREE_TYPE (convs));\n+\t    return error_mark_node;\n+\t  }\n+\treturn cvt_expr;\n+      }\n+\n     case REF_BIND:\n       return convert_to_reference\n \t(TREE_TYPE (convs), expr,\n@@ -3172,7 +3195,34 @@ convert_like (convs, expr)\n \t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n }\n \n-static tree\n+/* ARG is being passed to a varargs function.  Perform any conversions\n+   required.  Return the converted value.  */\n+\n+tree\n+convert_arg_to_ellipsis (arg)\n+     tree arg;\n+{\n+  if (TREE_CODE (TREE_TYPE (arg)) == REAL_TYPE\n+      && (TYPE_PRECISION (TREE_TYPE (arg))\n+\t  < TYPE_PRECISION (double_type_node)))\n+    /* Convert `float' to `double'.  */\n+    arg = cp_convert (double_type_node, arg);\n+  else if (IS_AGGR_TYPE (TREE_TYPE (arg))\n+\t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (arg)))\n+    cp_warning (\"cannot pass objects of type `%T' through `...'\",\n+\t\tTREE_TYPE (arg));\n+  else\n+    /* Convert `short' and `char' to full-size `int'.  */\n+    arg = default_conversion (arg);\n+\n+  return arg;\n+}\n+\n+/* ARG is a default argument expression being passed to a parameter of\n+   the indicated TYPE.  Do any required conversions.  Return the\n+   converted value.  */\n+\n+tree\n convert_default_arg (type, arg)\n      tree type, arg;\n {\n@@ -3341,24 +3391,10 @@ build_over_call (cand, args, flags)\n \n   /* Ellipsis */\n   for (; arg; arg = TREE_CHAIN (arg))\n-    {\n-      val = TREE_VALUE (arg);\n-\n-      if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (val))\n-\t      < TYPE_PRECISION (double_type_node)))\n-\t/* Convert `float' to `double'.  */\n-\tval = cp_convert (double_type_node, val);\n-      else if (IS_AGGR_TYPE (TREE_TYPE (val))\n-\t       && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n-\tcp_warning (\"cannot pass objects of type `%T' through `...'\",\n-\t\t    TREE_TYPE (val));\n-      else\n-\t/* Convert `short' and `char' to full-size `int'.  */\n-\tval = default_conversion (val);\n-\n-      converted_args = expr_tree_cons (NULL_TREE, val, converted_args);\n-    }\n+    converted_args \n+      = expr_tree_cons (NULL_TREE,\n+\t\t\tconvert_arg_to_ellipsis (TREE_VALUE (arg)),\n+\t\t\tconverted_args);\n \n   converted_args = nreverse (converted_args);\n "}, {"sha": "f0e59fd4322a153dd8cc271f48c0067fbb536ddc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "patch": "@@ -2254,6 +2254,8 @@ extern tree build_op_delete_call\t\tPROTO((enum tree_code, tree, tree, int));\n extern int can_convert\t\t\t\tPROTO((tree, tree));\n extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n extern void enforce_access                      PROTO((tree, tree));\n+extern tree convert_default_arg                 PROTO((tree, tree));\n+extern tree convert_arg_to_ellipsis             PROTO((tree));\n \n /* in class.c */\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n@@ -2532,7 +2534,6 @@ extern void init_init_processing\t\tPROTO((void));\n extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n extern void emit_base_init\t\t\tPROTO((tree, int));\n extern void check_base_init\t\t\tPROTO((tree));\n-extern void do_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_aggr_init\t\t\tPROTO((tree, tree, int, int));\n extern int is_aggr_typedef\t\t\tPROTO((tree, int));"}, {"sha": "59491a718b47b201fe5d712e307176b1cf1b9b99", "filename": "gcc/cp/init.c", "status": "modified", "additions": 56, "deletions": 151, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "patch": "@@ -832,34 +832,6 @@ expand_aggr_vbase_init (binfo, exp, addr, init_list)\n     }\n }\n \n-/* Subroutine to perform parser actions for member initialization.\n-   S_ID is the scoped identifier.\n-   NAME is the name of the member.\n-   INIT is the initializer, or `void_type_node' if none.  */\n-\n-void\n-do_member_init (s_id, name, init)\n-     tree s_id, name, init;\n-{\n-  tree binfo, base;\n-\n-  if (current_class_type == NULL_TREE\n-      || ! is_aggr_typedef (s_id, 1))\n-    return;\n-  binfo = get_binfo (IDENTIFIER_TYPE_VALUE (s_id),\n-\t\t\t  current_class_type, 1);\n-  if (binfo == error_mark_node)\n-    return;\n-  if (binfo == 0)\n-    {\n-      error_not_base_type (IDENTIFIER_TYPE_VALUE (s_id), current_class_type);\n-      return;\n-    }\n-\n-  base = convert_pointer_to (binfo, current_class_ptr);\n-  expand_member_init (build_indirect_ref (base, NULL_PTR), name, init);\n-}\n-\n /* Find the context in which this FIELD can be initialized.  */\n \n static tree\n@@ -958,151 +930,84 @@ expand_member_init (exp, name, init)\n \treturn;\n       }\n \n-  if (init)\n-    {\n-      /* The grammar should not allow fields which have names\n-\t that are TYPENAMEs.  Therefore, if the field has\n-\t a non-NULL TREE_TYPE, we may assume that this is an\n-\t attempt to initialize a base class member of the current\n-\t type.  Otherwise, it is an attempt to initialize a\n-\t member field.  */\n+  my_friendly_assert (init != NULL_TREE, 0);\n \n-      if (init == void_type_node)\n-\tinit = NULL_TREE;\n+  /* The grammar should not allow fields which have names that are\n+     TYPENAMEs.  Therefore, if the field has a non-NULL TREE_TYPE, we\n+     may assume that this is an attempt to initialize a base class\n+     member of the current type.  Otherwise, it is an attempt to\n+     initialize a member field.  */\n \n-      if (name == NULL_TREE || basetype)\n-\t{\n-\t  tree base_init;\n+  if (init == void_type_node)\n+    init = NULL_TREE;\n \n-\t  if (name == NULL_TREE)\n-\t    {\n-#if 0\n-\t      if (basetype)\n-\t\tname = TYPE_IDENTIFIER (basetype);\n-\t      else\n-\t\t{\n-\t\t  error (\"no base class to initialize\");\n-\t\t  return;\n-\t\t}\n-#endif\n-\t    }\n-\t  else if (basetype != type\n-\t\t   && ! current_template_parms\n-\t\t   && ! vec_binfo_member (basetype,\n-\t\t\t\t\t  TYPE_BINFO_BASETYPES (type))\n-\t\t   && ! binfo_member (basetype, CLASSTYPE_VBASECLASSES (type)))\n-\t    {\n-\t      if (IDENTIFIER_CLASS_VALUE (name))\n-\t\tgoto try_member;\n-\t      if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-\t\tcp_error (\"type `%T' is not an immediate or virtual basetype for `%T'\",\n-\t\t\t  basetype, type);\n-\t      else\n-\t\tcp_error (\"type `%T' is not an immediate basetype for `%T'\",\n-\t\t\t  basetype, type);\n-\t      return;\n-\t    }\n+  if (name == NULL_TREE || basetype)\n+    {\n+      tree base_init;\n \n-\t  if (purpose_member (basetype, current_base_init_list))\n+      if (name == NULL_TREE)\n+\t{\n+#if 0\n+\t  if (basetype)\n+\t    name = TYPE_IDENTIFIER (basetype);\n+\t  else\n \t    {\n-\t      cp_error (\"base class `%T' already initialized\", basetype);\n+\t      error (\"no base class to initialize\");\n \t      return;\n \t    }\n-\n-\t  if (warn_reorder && current_member_init_list)\n-\t    {\n-\t      cp_warning (\"base initializer for `%T'\", basetype);\n-\t      warning (\"   will be re-ordered to precede member initializations\");\n-\t    }\n-\n-\t  base_init = build_tree_list (basetype, init);\n-\t  current_base_init_list = chainon (current_base_init_list, base_init);\n+#endif\n \t}\n-      else\n+      else if (basetype != type\n+\t       && ! current_template_parms\n+\t       && ! vec_binfo_member (basetype,\n+\t\t\t\t      TYPE_BINFO_BASETYPES (type))\n+\t       && ! binfo_member (basetype, CLASSTYPE_VBASECLASSES (type)))\n \t{\n-\t  tree member_init;\n-\n-\ttry_member:\n-\t  field = lookup_field (type, name, 1, 0);\n-\n-\t  if (! member_init_ok_or_else (field, type, IDENTIFIER_POINTER (name)))\n-\t    return;\n-\n-\t  if (purpose_member (name, current_member_init_list))\n-\t    {\n-\t      cp_error (\"field `%D' already initialized\", field);\n-\t      return;\n-\t    }\n-\n-\t  member_init = build_tree_list (name, init);\n-\t  current_member_init_list = chainon (current_member_init_list, member_init);\n+\t  if (IDENTIFIER_CLASS_VALUE (name))\n+\t    goto try_member;\n+\t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n+\t    cp_error (\"type `%T' is not an immediate or virtual basetype for `%T'\",\n+\t\t      basetype, type);\n+\t  else\n+\t    cp_error (\"type `%T' is not an immediate basetype for `%T'\",\n+\t\t      basetype, type);\n+\t  return;\n \t}\n-      return;\n-    }\n-  else if (name == NULL_TREE)\n-    {\n-      compiler_error (\"expand_member_init: name == NULL_TREE\");\n-      return;\n-    }\n \n-  basetype = type;\n-  field = lookup_field (basetype, name, 0, 0);\n-\n-  if (! member_init_ok_or_else (field, basetype, IDENTIFIER_POINTER (name)))\n-    return;\n-\n-  /* now see if there is a constructor for this type\n-     which will take these args.  */\n-\n-  if (TYPE_HAS_CONSTRUCTOR (TREE_TYPE (field)))\n-    {\n-      tree parmtypes, fndecl;\n-\n-      if (TREE_CODE (exp) == VAR_DECL || TREE_CODE (exp) == PARM_DECL)\n+      if (purpose_member (basetype, current_base_init_list))\n \t{\n-\t  /* just know that we've seen something for this node */\n-\t  DECL_INITIAL (exp) = error_mark_node;\n-\t  TREE_USED (exp) = 1;\n+\t  cp_error (\"base class `%T' already initialized\", basetype);\n+\t  return;\n \t}\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (field));\n-      parm = build_component_ref (exp, name, NULL_TREE, 0);\n \n-      /* Now get to the constructors.  */\n-      fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 0);\n+      if (warn_reorder && current_member_init_list)\n+\t{\n+\t  cp_warning (\"base initializer for `%T'\", basetype);\n+\t  warning (\"   will be re-ordered to precede member initializations\");\n+\t}\n \n-      if (fndecl)\n-\tmy_friendly_assert (TREE_CODE (fndecl) == FUNCTION_DECL, 209);\n+      base_init = build_tree_list (basetype, init);\n+      current_base_init_list = chainon (current_base_init_list, base_init);\n+    }\n+  else\n+    {\n+      tree member_init;\n \n-      parmtypes = NULL_TREE;\n-      fndecl = NULL_TREE;\n+    try_member:\n+      field = lookup_field (type, name, 1, 0);\n \n-      init = convert_arguments (parm, parmtypes, NULL_TREE, fndecl, LOOKUP_NORMAL);\n-      if (init == NULL_TREE || TREE_TYPE (init) != error_mark_node)\n-\trval = build_method_call (NULL_TREE, ctor_identifier, init,\n-\t\t\t\t  TYPE_BINFO (type), LOOKUP_NORMAL);\n-      else\n+      if (! member_init_ok_or_else (field, type, IDENTIFIER_POINTER (name)))\n \treturn;\n \n-      if (rval != error_mark_node)\n+      if (purpose_member (name, current_member_init_list))\n \t{\n-\t  /* Now, fill in the first parm with our guy */\n-\t  TREE_VALUE (TREE_OPERAND (rval, 1))\n-\t    = build_unary_op (ADDR_EXPR, parm, 0);\n-\t  TREE_TYPE (rval) = ptr_type_node;\n-\t  TREE_SIDE_EFFECTS (rval) = 1;\n+\t  cp_error (\"field `%D' already initialized\", field);\n+\t  return;\n \t}\n-    }\n-  else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n-    {\n-      parm = build_component_ref (exp, name, NULL_TREE, 0);\n-      expand_aggr_init (parm, NULL_TREE, 0, 0);\n-      rval = error_mark_node;\n-    }\n \n-  /* Now initialize the member.  It does not have to\n-     be of aggregate type to receive initialization.  */\n-  if (rval != error_mark_node)\n-    expand_expr_stmt (rval);\n+      member_init = build_tree_list (name, init);\n+      current_member_init_list = chainon (current_member_init_list, member_init);\n+    }\n }\n \n /* This is like `expand_member_init', only it stores one aggregate"}, {"sha": "d417afbed6d3278ee404ce4d9969694c09d31c0e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 49, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "patch": "@@ -3037,24 +3037,9 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t  if (TREE_CODE (TREE_TYPE (val)) == REFERENCE_TYPE)\n \t    val = convert_from_reference (val);\n \n-\t  if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n-\t      && (TYPE_PRECISION (TREE_TYPE (val))\n-\t\t  < TYPE_PRECISION (double_type_node)))\n-\t    /* Convert `float' to `double'.  */\n-\t    result = expr_tree_cons (NULL_TREE,\n-\t\t\t\t     cp_convert (double_type_node, val),\n-\t\t\t\t     result);\n-\t  else if (IS_AGGR_TYPE (TREE_TYPE (val))\n-\t\t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n-\t    {\n-\t      cp_warning (\"cannot pass objects of type `%T' through `...'\",\n-\t\t\t  TREE_TYPE (val));\n-\t      result = expr_tree_cons (NULL_TREE, val, result);\n-\t    }\n-\t  else\n-\t    /* Convert `short' and `char' to full-size `int'.  */\n-\t    result = expr_tree_cons (NULL_TREE, default_conversion (val),\n-\t\t\t\t     result);\n+\t  result = expr_tree_cons (NULL_TREE,\n+\t\t\t\t   convert_arg_to_ellipsis (val),\n+\t\t\t\t   result);\n \t}\n \n       if (typetail)\n@@ -3069,37 +3054,8 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t  for (; typetail != void_list_node; ++i)\n \t    {\n \t      tree type = TREE_VALUE (typetail);\n-\t      tree val = break_out_target_exprs (TREE_PURPOSE (typetail));\n-\t      tree parmval;\n-\n-\t      if (val == NULL_TREE)\n-\t\tparmval = error_mark_node;\n-\t      else if (TREE_CODE (val) == CONSTRUCTOR)\n-\t\t{\n-\t\t  parmval = digest_init (type, val, (tree *)0);\n-\t\t  parmval = convert_for_initialization (return_loc, type,\n-\t\t\t\t\t\t\tparmval, flags,\n-\t\t\t\t\t\t\t\"default constructor\",\n-\t\t\t\t\t\t\tfndecl, i);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* This could get clobbered by the following call.  */\n-\t\t  if (TREE_HAS_CONSTRUCTOR (val))\n-\t\t    val = copy_node (val);\n-\n-\t\t  parmval = convert_for_initialization (return_loc, type,\n-\t\t\t\t\t\t\tval, flags,\n-\t\t\t\t\t\t\t\"default argument\",\n-\t\t\t\t\t\t\tfndecl, i);\n-#ifdef PROMOTE_PROTOTYPES\n-\t\t  if ((TREE_CODE (type) == INTEGER_TYPE\n-\t\t       || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t      && (TYPE_PRECISION (type)\n-\t\t\t  < TYPE_PRECISION (integer_type_node)))\n-\t\t    parmval = default_conversion (parmval);\n-#endif\n-\t\t}\n+\t      tree val = TREE_PURPOSE (typetail);\n+\t      tree parmval = convert_default_arg (type, val);\n \n \t      if (parmval == error_mark_node)\n \t\treturn error_mark_node;"}, {"sha": "297b8accaad8c9e9a4c299fba38ba71a7a641a8d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash9.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash9.C?ref=41efda8f53e4a8edd2bfff6ccc3f2d1ee7b9c22a", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+\n+template <class T>\n+void f(T) {} // ERROR - parameter has incomplete type\n+\n+class C;\n+\n+void g(const C& c)\n+{\n+  f(c); // ERROR - invalid use of undefined type\n+}"}]}