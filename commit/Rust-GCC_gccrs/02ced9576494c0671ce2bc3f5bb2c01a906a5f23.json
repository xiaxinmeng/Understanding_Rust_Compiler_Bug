{"sha": "02ced9576494c0671ce2bc3f5bb2c01a906a5f23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJjZWQ5NTc2NDk0YzA2NzFjZTJiYzNmNWJiMmMwMWE5MDZhNWYyMw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-09-13T16:53:08Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-09-13T16:53:08Z"}, "message": "don't typedef alias_set_entry and unhide pointerness\n\ngcc/ChangeLog:\n\n2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* alias.c (alias_set_entry_d): Rename to alias_set_entry.\n\t(alias_set_entry): Remove typedef.\n\t(alias_set_subset_of): Adjust.\n\t(alias_sets_conflict_p): Likewise.\n\t(init_alias_set_entry): Likewise.\n\t(get_alias_set): Likewise.\n\t(new_alias_set): Likewise.\n\t(record_alias_subset): Likewise.\n\nFrom-SVN: r227718", "tree": {"sha": "0df7143132f5dd89db3a665ed901e53a41de4cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0df7143132f5dd89db3a665ed901e53a41de4cbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02ced9576494c0671ce2bc3f5bb2c01a906a5f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ced9576494c0671ce2bc3f5bb2c01a906a5f23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ced9576494c0671ce2bc3f5bb2c01a906a5f23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ced9576494c0671ce2bc3f5bb2c01a906a5f23/comments", "author": null, "committer": null, "parents": [{"sha": "7a84bf7192780875adc0faab6df1b49bbaa926cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a84bf7192780875adc0faab6df1b49bbaa926cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a84bf7192780875adc0faab6df1b49bbaa926cb"}], "stats": {"total": 42, "additions": 26, "deletions": 16}, "files": [{"sha": "66e1a6c702bfb5f7303209cadf62653585de61a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ced9576494c0671ce2bc3f5bb2c01a906a5f23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ced9576494c0671ce2bc3f5bb2c01a906a5f23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02ced9576494c0671ce2bc3f5bb2c01a906a5f23", "patch": "@@ -1,3 +1,14 @@\n+2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* alias.c (alias_set_entry_d): Rename to alias_set_entry.\n+\t(alias_set_entry): Remove typedef.\n+\t(alias_set_subset_of): Adjust.\n+\t(alias_sets_conflict_p): Likewise.\n+\t(init_alias_set_entry): Likewise.\n+\t(get_alias_set): Likewise.\n+\t(new_alias_set): Likewise.\n+\t(record_alias_subset): Likewise.\n+\n 2015-09-13  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/install.texi (Downloading the source): Mark up"}, {"sha": "1c58547df72372caa3f69b46f21367aff7a20c31", "filename": "gcc/alias.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ced9576494c0671ce2bc3f5bb2c01a906a5f23/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ced9576494c0671ce2bc3f5bb2c01a906a5f23/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=02ced9576494c0671ce2bc3f5bb2c01a906a5f23", "patch": "@@ -134,7 +134,7 @@ along with GCC; see the file COPYING3.  If not see\n \n struct alias_set_hash : int_hash <int, INT_MIN, INT_MIN + 1> {};\n \n-struct GTY(()) alias_set_entry_d {\n+struct GTY(()) alias_set_entry {\n   /* The alias set number, as stored in MEM_ALIAS_SET.  */\n   alias_set_type alias_set;\n \n@@ -158,7 +158,6 @@ struct GTY(()) alias_set_entry_d {\n   /* Nonzero if is_pointer or if one of childs have has_pointer set.  */\n   bool has_pointer;\n };\n-typedef struct alias_set_entry_d *alias_set_entry;\n \n static int rtx_equal_for_memref_p (const_rtx, const_rtx);\n static int memrefs_conflict_p (int, rtx, int, rtx, HOST_WIDE_INT);\n@@ -167,7 +166,7 @@ static int base_alias_check (rtx, rtx, rtx, rtx, machine_mode,\n \t\t\t     machine_mode);\n static rtx find_base_value (rtx);\n static int mems_in_disjoint_alias_sets_p (const_rtx, const_rtx);\n-static alias_set_entry get_alias_set_entry (alias_set_type);\n+static alias_set_entry *get_alias_set_entry (alias_set_type);\n static tree decl_for_component_ref (tree);\n static int write_dependence_p (const_rtx,\n \t\t\t       const_rtx, machine_mode, rtx,\n@@ -288,7 +287,7 @@ static bool copying_arguments;\n \n \n /* The splay-tree used to store the various alias set entries.  */\n-static GTY (()) vec<alias_set_entry, va_gc> *alias_sets;\n+static GTY (()) vec<alias_set_entry *, va_gc> *alias_sets;\n \f\n /* Build a decomposed reference object for querying the alias-oracle\n    from the MEM rtx and store it in *REF.\n@@ -395,7 +394,7 @@ rtx_refs_may_alias_p (const_rtx x, const_rtx mem, bool tbaa_p)\n /* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n    such an entry, or NULL otherwise.  */\n \n-static inline alias_set_entry\n+static inline alias_set_entry *\n get_alias_set_entry (alias_set_type alias_set)\n {\n   return (*alias_sets)[alias_set];\n@@ -417,7 +416,7 @@ mems_in_disjoint_alias_sets_p (const_rtx mem1, const_rtx mem2)\n bool\n alias_set_subset_of (alias_set_type set1, alias_set_type set2)\n {\n-  alias_set_entry ase2;\n+  alias_set_entry *ase2;\n \n   /* Everything is a subset of the \"aliases everything\" set.  */\n   if (set2 == 0)\n@@ -453,7 +452,7 @@ alias_set_subset_of (alias_set_type set1, alias_set_type set2)\n      get_alias_set for more details.  */\n   if (ase2 && ase2->has_pointer)\n     {\n-      alias_set_entry ase1 = get_alias_set_entry (set1);\n+      alias_set_entry *ase1 = get_alias_set_entry (set1);\n \n       if (ase1 && ase1->is_pointer)\n \t{\n@@ -477,8 +476,8 @@ alias_set_subset_of (alias_set_type set1, alias_set_type set2)\n int\n alias_sets_conflict_p (alias_set_type set1, alias_set_type set2)\n {\n-  alias_set_entry ase1;\n-  alias_set_entry ase2;\n+  alias_set_entry *ase1;\n+  alias_set_entry *ase2;\n \n   /* The easy case.  */\n   if (alias_sets_must_conflict_p (set1, set2))\n@@ -808,10 +807,10 @@ alias_ptr_types_compatible_p (tree t1, tree t2)\n \n /* Create emptry alias set entry.  */\n \n-alias_set_entry\n+alias_set_entry *\n init_alias_set_entry (alias_set_type set)\n {\n-  alias_set_entry ase = ggc_alloc<alias_set_entry_d> ();\n+  alias_set_entry *ase = ggc_alloc<alias_set_entry> ();\n   ase->alias_set = set;\n   ase->children = NULL;\n   ase->has_zero_child = false;\n@@ -1057,7 +1056,7 @@ get_alias_set (tree t)\n   /* We treat pointer types specially in alias_set_subset_of.  */\n   if (POINTER_TYPE_P (t) && set)\n     {\n-      alias_set_entry ase = get_alias_set_entry (set);\n+      alias_set_entry *ase = get_alias_set_entry (set);\n       if (!ase)\n \tase = init_alias_set_entry (set);\n       ase->is_pointer = true;\n@@ -1075,8 +1074,8 @@ new_alias_set (void)\n   if (flag_strict_aliasing)\n     {\n       if (alias_sets == 0)\n-\tvec_safe_push (alias_sets, (alias_set_entry) 0);\n-      vec_safe_push (alias_sets, (alias_set_entry) 0);\n+\tvec_safe_push (alias_sets, (alias_set_entry *) NULL);\n+      vec_safe_push (alias_sets, (alias_set_entry *) NULL);\n       return alias_sets->length () - 1;\n     }\n   else\n@@ -1099,8 +1098,8 @@ new_alias_set (void)\n void\n record_alias_subset (alias_set_type superset, alias_set_type subset)\n {\n-  alias_set_entry superset_entry;\n-  alias_set_entry subset_entry;\n+  alias_set_entry *superset_entry;\n+  alias_set_entry *subset_entry;\n \n   /* It is possible in complex type situations for both sets to be the same,\n      in which case we can ignore this operation.  */"}]}