{"sha": "dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiZTFiMmYxZjJmMjk4M2NmOGQxNTUzMjhmYTgwZDFjMmQ4NjY2Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-06T23:32:19Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-06T23:32:19Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r405", "tree": {"sha": "f109b058297b8abc1f224b69fb5b50f4c5e7c8a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f109b058297b8abc1f224b69fb5b50f4c5e7c8a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/comments", "author": null, "committer": null, "parents": [{"sha": "ac266247ced57232013a3093785db30e253a432a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac266247ced57232013a3093785db30e253a432a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac266247ced57232013a3093785db30e253a432a"}], "stats": {"total": 355, "additions": 252, "deletions": 103}, "files": [{"sha": "a01193214200f97eebc2050e0946c5d6e845c548", "filename": "gcc/combine.c", "status": "modified", "additions": 241, "deletions": 97, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "patch": "@@ -900,10 +900,15 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n       if ((inner_dest != dest\n \t   && (reg_overlap_mentioned_p (i2dest, inner_dest)\n \t       || (i1dest && reg_overlap_mentioned_p (i1dest, inner_dest))))\n-#ifdef SMALL_REGISTER_CLASSES\t  \n+\t  /* This is the same test done in can_combine_p.  */\n \t  || (GET_CODE (inner_dest) == REG\n-\t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER)\n+\t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER\n+#ifndef SMALL_REGISTER_CLASSES\n+\t      && ! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n+\t\t\t\t       GET_MODE (inner_dest))\n #endif\n+\t      )\n+\n \t  || (i1_not_in_src && reg_overlap_mentioned_p (i1dest, src)))\n \treturn 0;\n \n@@ -3788,11 +3793,9 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t       || (movstrict_optab->handlers[(int) tmode].insn_code\n \t\t   != CODE_FOR_nothing)))\n \t  || (GET_CODE (inner) == MEM && pos >= 0\n-#ifdef STRICT_ALIGNMENT\n-\t      && (pos % GET_MODE_ALIGNMENT (tmode)) == 0\n-#else\n-\t      && (pos % BITS_PER_UNIT) == 0\n-#endif\n+\t      && (pos\n+\t\t  % (STRICT_ALIGNMENT ? GET_MODE_ALIGNMENT (tmode)\n+\t\t     : BITS_PER_UNIT)) == 0\n \t      /* We can't do this if we are widening INNER_MODE (it\n \t\t may not be aligned, for one thing).  */\n \t      && GET_MODE_BITSIZE (inner_mode) >= GET_MODE_BITSIZE (tmode)\n@@ -4053,7 +4056,7 @@ make_compound_operation (x, in_code)\n \tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0), -1,\n \t\t\t       XEXP (XEXP (x, 0), 1), i, 1,\n \t\t\t       0, in_code == COMPARE);\n-#if 0\n+\n       /* Same as previous, but for (subreg (lshiftrt ...)) in first op.  */\n       else if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t       && subreg_lowpart_p (XEXP (x, 0))\n@@ -4063,7 +4066,6 @@ make_compound_operation (x, in_code)\n \t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 0), -1,\n \t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 1), i, 1,\n \t\t\t       0, in_code == COMPARE);\n-#endif\n \n       /* One machines without logical shifts, if the operand of the AND is\n \t a logical shift and our mask turns off all the propagated sign\n@@ -4195,6 +4197,142 @@ get_pos_from_mask (m, plen)\n   return pos;\n }\n \f\n+/* Rewrite X so that it is an expression in MODE.  We only care about the\n+   low-order BITS bits so we can ignore AND operations that just clear\n+   higher-order bits.\n+\n+   Also, if REG is non-zero and X is a register equal in value to REG, \n+   replace X with REG.  */\n+\n+static rtx\n+force_to_mode (x, mode, bits, reg)\n+     rtx x;\n+     enum machine_mode mode;\n+     int bits;\n+     rtx reg;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+\n+  /* If X is narrower than MODE or if BITS is larger than the size of MODE,\n+     just get X in the proper mode.  */\n+\n+  if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode)\n+      || bits > GET_MODE_BITSIZE (mode))\n+    return gen_lowpart_for_combine (mode, x);\n+\n+  switch (code)\n+    {\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+      x = expand_compound_operation (x);\n+      if (GET_CODE (x) != code)\n+\treturn force_to_mode (x, mode, bits, reg);\n+      break;\n+\n+    case REG:\n+      if (reg != 0 && (rtx_equal_p (get_last_value (reg), x)\n+\t\t       || rtx_equal_p (reg, get_last_value (x))))\n+\tx = reg;\n+      break;\n+\n+    case CONST_INT:\n+      if (bits < HOST_BITS_PER_INT)\n+\tx = gen_rtx (CONST_INT, VOIDmode,\n+\t\t     INTVAL (x) & ((1 << (bits + 1)) - 1));\n+      return x;\n+\n+    case SUBREG:\n+      /* Ignore low-order SUBREGs. */\n+      if (subreg_lowpart_p (x))\n+\treturn force_to_mode (SUBREG_REG (x), mode, bits, reg);\n+      break;\n+\n+    case AND:\n+      /* If this is an AND with a constant.  Otherwise, we fall through to\n+\t do the general binary case.  */\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  int mask = INTVAL (XEXP (x, 1));\n+\t  int len = exact_log2 (mask + 1);\n+\t  rtx op = XEXP (x, 0);\n+\n+\t  /* If this is masking some low-order bits, we may be able to\n+\t     impose a stricter constraint on what bits of the operand are\n+\t     required.  */\n+\n+\t  op = force_to_mode (op, mode, len > 0 ? MIN (len, bits) : bits,\n+\t\t\t      reg);\n+\n+\t  if (bits < HOST_BITS_PER_INT)\n+\t    mask &= (1 << (bits + 1)) - 1;\n+\n+\t  x = simplify_and_const_int (x, mode, op, mask);\n+\n+\t  /* If X is still an AND, see if it is an AND with a mask that\n+\t     is just some low-order bits.  If so, and it is BITS wide (it\n+\t     can't be wider), we don't need it.  */\n+\n+\t  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t      && bits < HOST_BITS_PER_INT\n+\t      && INTVAL (XEXP (x, 1)) == (1 << (bits + 1)) - 1)\n+\t    x = XEXP (x, 0);\n+\t  return x;\n+\t}\n+\n+      /* ... fall through ... */\n+\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case IOR:\n+    case XOR:\n+      /* For most binary operations, just propagate into the operation and\n+\t change the mode.  */\n+\n+      return gen_binary (code, mode,\n+\t\t\t force_to_mode (XEXP (x, 0), mode, bits, reg),\n+\t\t\t force_to_mode (XEXP (x, 1), mode, bits, reg));\n+\n+    case ASHIFT:\n+    case LSHIFT:\n+      /* For left shifts, do the same, but just for the first operand.\n+\t If the shift count is a constant, we need even fewer bits of the\n+\t first operand.  */\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) < bits)\n+\tbits -= INTVAL (XEXP (x, 1));\n+\n+      return gen_binary (code, mode,\n+\t\t\t force_to_mode (XEXP (x, 0), mode, bits, reg),\n+\t\t\t XEXP (x, 1));\n+\n+    case LSHIFTRT:\n+      /* Here we can only do something if the shift count is a constant and\n+\t the count plus BITS is no larger than the width of MODE, we can do\n+\t the shift in MODE.  */\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) + bits <= GET_MODE_BITSIZE (mode))\n+\treturn gen_binary (LSHIFTRT, mode,\n+\t\t\t   force_to_mode (XEXP (x, 0), mode,\n+\t\t\t\t\t  bits + INTVAL (XEXP (x, 1)), reg),\n+\t\t\t   XEXP (x, 1));\n+      break;\n+\n+    case NEG:\n+    case NOT:\n+      /* Handle these similarly to the way we handle most binary operations. */\n+      return gen_unary (code, mode,\n+\t\t\tforce_to_mode (XEXP (x, 0), mode, bits, reg));\n+    }\n+\n+  /* Otherwise, just do the operation canonically.  */\n+  return gen_lowpart_for_combine (mode, x);\n+}\n+\f\n /* See if X, a SET operation, can be rewritten as a bit-field assignment.\n    Return that assignment if so.\n \n@@ -4206,7 +4344,11 @@ make_field_assignment (x)\n {\n   rtx dest = SET_DEST (x);\n   rtx src = SET_SRC (x);\n-  rtx assign = 0;\n+  rtx ourdest;\n+  rtx assign;\n+  int c1, pos, len;\n+  rtx other;\n+  enum machine_mode mode;\n \n   /* If SRC was (and (not (ashift (const_int 1) POS)) DEST), this is\n      a clear of a one-bit field.  We will have changed it to\n@@ -4216,11 +4358,13 @@ make_field_assignment (x)\n   if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == ROTATE\n       && GET_CODE (XEXP (XEXP (src, 0), 0)) == CONST_INT\n       && INTVAL (XEXP (XEXP (src, 0), 0)) == -2\n-      && rtx_equal_p (dest, XEXP (src, 1)))\n+      && (rtx_equal_p (dest, XEXP (src, 1))\n+\t  || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n+\t  || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n     {\n       assign = make_extraction (VOIDmode, dest, -1, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n-      src = const0_rtx;\n+      return gen_rtx (SET, VOIDmode, assign, const0_rtx);\n     }\n \n   else if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == SUBREG\n@@ -4229,94 +4373,72 @@ make_field_assignment (x)\n \t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (src, 0)))))\n \t   && GET_CODE (SUBREG_REG (XEXP (src, 0))) == ROTATE\n \t   && INTVAL (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == -2\n-\t   && rtx_equal_p (dest, XEXP (src, 1)))\n+\t   && (rtx_equal_p (dest, XEXP (src, 1))\n+\t       || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n+\t       || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n     {\n       assign = make_extraction (VOIDmode, dest, -1,\n \t\t\t\tXEXP (SUBREG_REG (XEXP (src, 0)), 1),\n \t\t\t\t1, 1, 1, 0);\n-      src = const0_rtx;\n+      return gen_rtx (SET, VOIDmode, assign, const0_rtx);\n     }\n \n   /* If SRC is (ior (ashift (const_int 1) POS DEST)), this is a set of a\n      one-bit field.  */\n   else if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 0)) == ASHIFT\n \t   && XEXP (XEXP (src, 0), 0) == const1_rtx\n-\t   && rtx_equal_p (dest, XEXP (src, 1)))\n+\t   && (rtx_equal_p (dest, XEXP (src, 1))\n+\t       || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n+\t       || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n     {\n       assign = make_extraction (VOIDmode, dest, -1, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n-      src = const1_rtx;\n+      return gen_rtx (SET, VOIDmode, assign, const1_rtx);\n     }\n \n-  /* The common case of a constant assignment into a constant-position \n-     field looks like (ior (and DEST C1) C2).  We clear the bits in C1\n-     that are present in C2 and C1 must then be the complement of a mask\n-     that selects a field.  */\n-\n-  else if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 1)) == CONST_INT\n-\t   && GET_CODE (XEXP (src, 0)) == AND\n-\t   && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT\n-\t   && GET_MODE_BITSIZE (GET_MODE (dest)) <= HOST_BITS_PER_INT\n-\t   && rtx_equal_p (XEXP (XEXP (src, 0), 0), dest))\n-    {\n-      unsigned c1 = INTVAL (XEXP (XEXP (src, 0), 1));\n-      unsigned c2 = INTVAL (XEXP (src, 1));\n-      int pos, len;\n-\n-      c1 &= ~ c2;\n-\n-      c1 = (~ c1) & GET_MODE_MASK (GET_MODE (dest));\n-      if ((pos = get_pos_from_mask (c1, &len)) >= 0)\n-\t{\n-\t  assign = make_extraction (VOIDmode, dest, pos, 0, len, 1, 1, 0);\n-\t  src = gen_rtx (CONST_INT, VOIDmode, c2 >> pos);\n-\t}\n-    }\n+  /* The other case we handle is assignments into a constant-position\n+     field.  They look like (ior (and DEST C1) OTHER).  If C1 represents\n+     a mask that has all one bits except for a group of zero bits and\n+     OTHER is known to have zeros where C1 has ones, this is such an\n+     assignment.  Compute the position and length from C1.  Shift OTHER\n+     to the appropriate position, force it to the required mode, and\n+     make the extraction.  Check for the AND in both operands.  */\n+\n+  if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 0)) == AND\n+      && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT\n+      && (rtx_equal_p (XEXP (XEXP (src, 0), 0), dest)\n+\t  || rtx_equal_p (XEXP (XEXP (src, 0), 0), get_last_value (dest))\n+\t  || rtx_equal_p (get_last_value (XEXP (XEXP (src, 0), 1)), dest)))\n+    c1 = INTVAL (XEXP (XEXP (src, 0), 1)), other = XEXP (src, 1);\n+  else if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 1)) == AND\n+\t   && GET_CODE (XEXP (XEXP (src, 1), 1)) == CONST_INT\n+\t   && (rtx_equal_p (XEXP (XEXP (src, 1), 0), dest)\n+\t       || rtx_equal_p (XEXP (XEXP (src, 1), 0), get_last_value (dest))\n+\t       || rtx_equal_p (get_last_value (XEXP (XEXP (src, 1), 0)),\n+\t\t\t       dest)))\n+    c1 = INTVAL (XEXP (XEXP (src, 1), 1)), other = XEXP (src, 0);\n+  else\n+    return x;\n \n-  /* Finally, see if this is an assignment of a varying item into a fixed\n-     field.  This looks like (ior (and DEST C1) (and (ashift SRC POS) C2)),\n-     but we have to allow for the operands to be in either order.  */\n+  pos = get_pos_from_mask (~c1, &len);\n+  if (pos < 0 || pos + len > GET_MODE_BITSIZE (GET_MODE (dest))\n+      || (c1 & significant_bits (other, GET_MODE (other))) != 0)\n+    return x;\n \n-  else if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 0)) == AND\n-\t   && GET_CODE (XEXP (src, 1)) == AND\n-\t   && GET_MODE_BITSIZE (GET_MODE (dest)) <= HOST_BITS_PER_INT)\n-    {\n-      rtx mask, other;\n+  assign = make_extraction (VOIDmode, dest, pos, 0, len, 1, 1, 0);\n \n-      /* Set MASK to the (and DEST C1) and OTHER to the mask of the shift.  */\n-      if (GET_CODE (XEXP (XEXP (src, 0), 0)) == ASHIFT)\n-\tmask = XEXP (src, 1), other = XEXP (src, 0);\n-      else if (GET_CODE (XEXP (XEXP (src, 1), 0)) == ASHIFT)\n-\tmask = XEXP (src, 0), other = XEXP (src, 1);\n-      else\n-\treturn x;\n+  /* The mode to use for the source is the mode of the assignment, or of\n+     what is inside a possible STRICT_LOW_PART.  */\n+  mode = (GET_CODE (assign) == STRICT_LOW_PART \n+\t  ? GET_MODE (XEXP (assign, 0)) : GET_MODE (assign));\n \n-      if (rtx_equal_p (XEXP (mask, 0), dest)\n-\t  && GET_CODE (XEXP (mask, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (other, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (XEXP (other, 0), 1)) == CONST_INT)\n-\t{\n-\t  unsigned c1 = INTVAL (XEXP (mask, 1));\n-\t  unsigned c2 = INTVAL (XEXP (other, 1));\n-\t  int pos, len;\n-\n-\t  /* The two masks must be complements within the relevant mode,\n-\t     C2 must select a field, and the shift must move to that\n-\t     position.  */\n-\t  if (((c1 % ~c2) & GET_MODE_MASK (GET_MODE (dest))) == 0\n-\t      && (pos = get_pos_from_mask (c2, &len)) >= 0\n-\t      && pos == INTVAL (XEXP (XEXP (other, 0), 1)))\n-\t    {\n-\t      assign = make_extraction (VOIDmode, dest, pos, 0, len, 1, 1, 0);\n-\t      src = XEXP (XEXP (other, 0), 0);\n-\t    }\n-\t}\n-    }\n+  /* Shift OTHER right POS places and make it the source, restricting it\n+     to the proper length and mode.  */\n \n-  if (assign)\n-    return gen_rtx_combine (SET, VOIDmode, assign, src);\n+  src = force_to_mode (simplify_shift_const (0, LSHIFTRT, mode, other, pos),\n+\t\t       mode, len, dest);\n \n-  return x;\n+  return gen_rtx_combine (SET, VOIDmode, assign, src);\n }\n \f\n /* See if X is of the form (+ (* a c) (* b c)) and convert to (* (+ a b) c)\n@@ -4338,18 +4460,9 @@ apply_distributive_law (x)\n \n   lhs = XEXP (x, 0), rhs = XEXP (x, 1);\n \n-  /* If either operand is a primitive or a complex SUBREG,\n-     we can't do anything. */\n+  /* If either operand is a primitive we can't do anything, so get out fast. */\n   if (GET_RTX_CLASS (GET_CODE (lhs)) == 'o'\n-      || GET_RTX_CLASS (GET_CODE (rhs)) == 'o'\n-      || (GET_CODE (lhs) == SUBREG\n-\t  && (! subreg_lowpart_p (lhs)\n-\t      || (GET_MODE_SIZE (GET_MODE (lhs))\n-\t\t  >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))))))\n-      || (GET_CODE (rhs) == SUBREG\n-\t  && (! subreg_lowpart_p (rhs)\n-\t      || (GET_MODE_SIZE (GET_MODE (rhs))\n-\t\t  >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (rhs)))))))\n+      || GET_RTX_CLASS (GET_CODE (rhs)) == 'o')\n     return x;\n \n   lhs = expand_compound_operation (lhs);\n@@ -4381,9 +4494,22 @@ apply_distributive_law (x)\n       break;\n \n     case SUBREG:\n-      /* This distributes over all operations, provided the inner modes\n-\t are the same, but we produce the result slightly differently.  */\n-      if (GET_MODE (SUBREG_REG (lhs)) != GET_MODE (SUBREG_REG (rhs)))\n+      /* Non-paradoxical SUBREGs distributes over all operations, provided\n+\t the inner modes and word numbers are the same, this is an extraction\n+\t of a low-order part, and we would not be converting a single-word\n+\t operation into a multi-word operation.  The latter test is not\n+\t required, but we prevents generating unneeded multi-word operations.\n+\t Some of the previous tests are redundant given the latter test, but\n+\t are retained because they are required for correctness.\n+\n+\t We produce the result slightly differently in this case.  */\n+\n+      if (GET_MODE (SUBREG_REG (lhs)) != GET_MODE (SUBREG_REG (rhs))\n+\t  || SUBREG_WORD (lhs) != SUBREG_WORD (rhs)\n+\t  || ! subreg_lowpart_p (lhs)\n+\t  || (GET_MODE_SIZE (GET_MODE (lhs))\n+\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))))\n+\t  || GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))) > UNITS_PER_WORD)\n \treturn x;\n \n       tem = gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n@@ -5988,7 +6114,15 @@ gen_lowpart_for_combine (mode, x)\n      SUBREG.  Normally, this SUBREG won't match, but some patterns may\n      include and explicit SUBREG or we may simplify it further in combine.  */\n   else\n-    return gen_rtx (SUBREG, mode, x, 0);\n+    {\n+      int word = 0;\n+\n+      if (WORDS_BIG_ENDIAN && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+\tword = ((GET_MODE_SIZE (GET_MODE (x))\n+\t\t - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n+\t\t/ UNITS_PER_WORD);\n+      return gen_rtx (SUBREG, mode, x, word);\n+    }\n }\n \f\n /* Make an rtx expression.  This is a subset of gen_rtx and only supports\n@@ -6741,10 +6875,9 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \n-\t  /* If we are doing an LT or GE comparison, it means we are testing\n+\t  /* If we are doing a sign bit comparison, it means we are testing\n \t     a particular bit.  Convert it to the appropriate AND.  */\n-\t  if (const_op == 0 && sign_bit_comparison_p\n-\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t  if (sign_bit_comparison_p && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && mode_width <= HOST_BITS_PER_INT)\n \t    {\n \t      op0 = simplify_and_const_int (0, mode, XEXP (op0, 0),\n@@ -6753,6 +6886,17 @@ simplify_comparison (code, pop0, pop1)\n \t      code = (code == LT ? NE : EQ);\n \t      continue;\n \t    }\n+\n+\t  /* If this an equality comparison with zero and we are shifting\n+\t     the low bit to the sign bit, we can convert this to an AND of the\n+\t     low-order bit.  */\n+\t  if (const_op == 0 && equality_comparison_p\n+\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && INTVAL (XEXP (op0, 1)) == mode_width - 1)\n+\t    {\n+\t      op0 = simplify_and_const_int (0, mode, XEXP (op0, 0), 1);\n+\t      continue;\n+\t    }\n \t  break;\n \n \tcase ASHIFTRT:"}, {"sha": "be45772cb95dc3f20501d9ccd1bae90cb70f5123", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "patch": "@@ -186,14 +186,14 @@ extern int target_flags;\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n-/* #define STRICT_ALIGNMENT */\n+#define STRICT_ALIGNMENT 0\n \n-/* Define this if unaligned move instructions are extremely slow.\n+/* Set this non-zero if unaligned move instructions are extremely slow.\n \n    On the 29k, they trap.  */\n-#define SLOW_UNALIGNED_ACCESS\n+#define SLOW_UNALIGNED_ACCESS 1\n \f\n /* Standard register usage.  */\n "}, {"sha": "0af8af1788fbca1ce29bab94c3b79e6570aee8ef", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "patch": "@@ -61,6 +61,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define TARGET_MEM_FUNCTIONS\n \n+/ * size_t is unsigned int.  */\n+\n+#define SIZE_TYPE \"unsigned int\"\n+\n /* Every structure or union's size must be a multiple of 2 bytes.  */\n \n #define STRUCTURE_SIZE_BOUNDARY 16"}, {"sha": "897b1fb2bf69c37d00aa50f1ad538005ff79085e", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "patch": "@@ -153,11 +153,11 @@ extern int target_flags;\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 32\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  National claims that the NS32032\n    works without strict alignment, but rumor has it that operands\n    crossing a page boundary cause unpredictable results.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \n /* If bit field type is int, dont let it cross an int,\n    and give entire struct the alignment of an int.  */"}, {"sha": "02462c14991a192f139d265ecdbfed50e9c9c70c", "filename": "gcc/config/ns32k/pc532.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fns32k%2Fpc532.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666/gcc%2Fconfig%2Fns32k%2Fpc532.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fpc532.h?ref=dfbe1b2f1f2f2983cf8d155328fa80d1c2d86666", "patch": "@@ -49,6 +49,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    if the bug still exists. */\n \n #undef STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 0\n \n /* Maybe someone needs to know which processor we're running on */\n "}]}