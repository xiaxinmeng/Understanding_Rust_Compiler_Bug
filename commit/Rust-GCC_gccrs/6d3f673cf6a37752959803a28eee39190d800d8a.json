{"sha": "6d3f673cf6a37752959803a28eee39190d800d8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQzZjY3M2NmNmEzNzc1Mjk1OTgwM2EyOGVlZTM5MTkwZDgwMGQ4YQ==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kirill.yukhin@intel.com", "date": "2013-11-18T12:44:59Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2013-11-18T12:44:59Z"}, "message": "ia64.c (ia64_split_tmode_move): Mark load with `dead' flag if it kills address, not its post-increment.\n\n        * gcc/config/ia64/ia64.c (ia64_split_tmode_move): Mark\n        load with `dead' flag if it kills address, not its\n        post-increment.\n\nFrom-SVN: r204948", "tree": {"sha": "b959aabe5489cc75d58e22377bf1515c97998bab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b959aabe5489cc75d58e22377bf1515c97998bab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d3f673cf6a37752959803a28eee39190d800d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3f673cf6a37752959803a28eee39190d800d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d3f673cf6a37752959803a28eee39190d800d8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3f673cf6a37752959803a28eee39190d800d8a/comments", "author": null, "committer": null, "parents": [{"sha": "01156003a987af28c1432f247471b2192566612a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01156003a987af28c1432f247471b2192566612a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01156003a987af28c1432f247471b2192566612a"}], "stats": {"total": 21, "additions": 13, "deletions": 8}, "files": [{"sha": "2ed1b63f989ed4f293072b20d531077acab3d84a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3f673cf6a37752959803a28eee39190d800d8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3f673cf6a37752959803a28eee39190d800d8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d3f673cf6a37752959803a28eee39190d800d8a", "patch": "@@ -1,3 +1,9 @@\n+2013-11-18  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\t* gcc/config/ia64/ia64.c (ia64_split_tmode_move): Mark\n+\tload with `dead' flag if it kills address, not its\n+\tpost-increment.\n+\n 2013-11-18  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* builtin-types.def (BT_FN_PTR_CONST_PTR_VAR): New."}, {"sha": "4fde7aab43e50df84ebf0b1be66115bbdcb5e864", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3f673cf6a37752959803a28eee39190d800d8a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3f673cf6a37752959803a28eee39190d800d8a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6d3f673cf6a37752959803a28eee39190d800d8a", "patch": "@@ -1525,23 +1525,22 @@ ia64_split_tmode_move (rtx operands[])\n      the value it points to.  In that case we have to do the loads in\n      the appropriate order so that the pointer is not destroyed too\n      early.  Also we must not generate a postmodify for that second\n-     load, or rws_access_regno will die.  */\n+     load, or rws_access_regno will die.  And we must not generate a\n+     postmodify for the second load if the destination register \n+     overlaps with the base register.  */\n   if (GET_CODE (operands[1]) == MEM\n       && reg_overlap_mentioned_p (operands[0], operands[1]))\n     {\n       rtx base = XEXP (operands[1], 0);\n-      rtx first_write = gen_rtx_REG (DImode, REGNO (operands[0]));\n       while (GET_CODE (base) != REG)\n \tbase = XEXP (base, 0);\n \n       if (REGNO (base) == REGNO (operands[0]))\n-\t{\n-\t  reversed = true;\n-\t  first_write = gen_rtx_REG (DImode, REGNO (operands[0]) + 1);\n-\t}\n+\treversed = true;\n \n-      if (GET_CODE (operands[0]) == REG\n-\t  && reg_overlap_mentioned_p (first_write, operands[1]))\n+      if (refers_to_regno_p (REGNO (operands[0]),\n+\t\t\t     REGNO (operands[0])+2,\n+\t\t\t     base, 0))\n \tdead = true;\n     }\n   /* Another reason to do the moves in reversed order is if the first"}]}