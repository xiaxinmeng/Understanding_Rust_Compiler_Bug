{"sha": "b78b513e41b3d491efa0bd639cedbad8622a09bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4YjUxM2U0MWIzZDQ5MWVmYTBiZDYzOWNlZGJhZDg2MjJhMDliZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-03-07T15:54:59Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-03-07T15:54:59Z"}, "message": "re PR target/84277 (A lot of new acats testsuite failures)\n\n\tPR target/84277\n\t* except.h (output_function_exception_table): Adjust prototype.\n\t* except.c (output_function_exception_table): Remove FNNAME parameter\n\tand add SECTION parameter.  Ouput one part of the table at a time.\n\t* final.c (final_scan_insn_1) <NOTE_INSN_SWITCH_TEXT_SECTIONS>: Output\n\tthe first part of the exception table and emit unwind directives.\n\t* config/i386/i386-protos.h (i386_pe_end_cold_function): Declare.\n\t(i386_pe_seh_cold_init): Likewise.\n\t* config/i386/cygming.h (ASM_DECLARE_COLD_FUNCTION_NAME): New macro.\n\t(ASM_DECLARE_COLD_FUNCTION_SIZE): Likewise.\n\t* config/i386/i386.c (x86_expand_epilogue): Fix wording in comment.\n\t(ix86_output_call_insn): Emit a nop in one more case for SEH.\n\t* config/i386/winnt.c: Include except.h.\n\t(struct seh_frame_state): Add reg_offset, after_prologue and\n\tin_cold_section fields.\n\t(i386_pe_seh_end_prologue): Set seh->after_prologue.\n\t(i386_pe_seh_cold_init): New function.\n\t(i386_pe_seh_fini): Add COLD parameter and bail out if it is not equal\n\tto seh->in_cold_section.\n\t(seh_emit_push): Record the offset of the push.\n\t(seh_emit_save): Record the offet of the save.\n\t(i386_pe_seh_unwind_emit): Deal with NOTE_INSN_SWITCH_TEXT_SECTIONS.\n\tTest seh->after_prologue to disregard the epilogue.\n\t(i386_pe_end_function): Pass FALSE to i386_pe_seh_fini.\n\t(i386_pe_end_cold_function): New function.\n\nFrom-SVN: r258338", "tree": {"sha": "5043355c1914fa0a327adcad08751d898419f92f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5043355c1914fa0a327adcad08751d898419f92f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b78b513e41b3d491efa0bd639cedbad8622a09bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78b513e41b3d491efa0bd639cedbad8622a09bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78b513e41b3d491efa0bd639cedbad8622a09bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78b513e41b3d491efa0bd639cedbad8622a09bd/comments", "author": null, "committer": null, "parents": [{"sha": "123ba0918c9ba27eeba43c885854a553e2b8b6f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/123ba0918c9ba27eeba43c885854a553e2b8b6f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/123ba0918c9ba27eeba43c885854a553e2b8b6f7"}], "stats": {"total": 197, "additions": 176, "deletions": 21}, "files": [{"sha": "00b79a553c9d73e52a1f523a2630167788ceb889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -1,3 +1,31 @@\n+2018-03-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/84277\n+\t* except.h (output_function_exception_table): Adjust prototype.\n+\t* except.c (output_function_exception_table): Remove FNNAME parameter\n+\tand add SECTION parameter.  Ouput one part of the table at a time.\n+\t* final.c (final_scan_insn_1) <NOTE_INSN_SWITCH_TEXT_SECTIONS>: Output\n+\tthe first part of the exception table and emit unwind directives.\n+\t* config/i386/i386-protos.h (i386_pe_end_cold_function): Declare.\n+\t(i386_pe_seh_cold_init): Likewise.\n+\t* config/i386/cygming.h (ASM_DECLARE_COLD_FUNCTION_NAME): New macro.\n+\t(ASM_DECLARE_COLD_FUNCTION_SIZE): Likewise.\n+\t* config/i386/i386.c (x86_expand_epilogue): Fix wording in comment.\n+\t(ix86_output_call_insn): Emit a nop in one more case for SEH.\n+\t* config/i386/winnt.c: Include except.h.\n+\t(struct seh_frame_state): Add reg_offset, after_prologue and\n+\tin_cold_section fields.\n+\t(i386_pe_seh_end_prologue): Set seh->after_prologue.\n+\t(i386_pe_seh_cold_init): New function.\n+\t(i386_pe_seh_fini): Add COLD parameter and bail out if it is not equal\n+\tto seh->in_cold_section.\n+\t(seh_emit_push): Record the offset of the push.\n+\t(seh_emit_save): Record the offet of the save.\n+\t(i386_pe_seh_unwind_emit): Deal with NOTE_INSN_SWITCH_TEXT_SECTIONS.\n+\tTest seh->after_prologue to disregard the epilogue.\n+\t(i386_pe_end_function): Pass FALSE to i386_pe_seh_fini.\n+\t(i386_pe_end_cold_function): New function.\n+\n 2018-03-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/84565"}, {"sha": "21b0f438a9a0a3ff2544391a639b498fcdda1d2b", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -312,10 +312,27 @@ do {\t\t\t\t\t\t\\\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n   i386_pe_start_function (FILE, NAME, DECL)\n \n+/* Write the extra assembler code needed to declare the name of a\n+   cold function partition properly.  */\n+\n+#undef ASM_DECLARE_COLD_FUNCTION_NAME\n+#define ASM_DECLARE_COLD_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      i386_pe_declare_function_type (FILE, NAME, 0);\t\t\\\n+      i386_pe_seh_cold_init (FILE, NAME);\t\t\t\\\n+      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n #undef ASM_DECLARE_FUNCTION_SIZE\n #define ASM_DECLARE_FUNCTION_SIZE(FILE,NAME,DECL) \\\n   i386_pe_end_function (FILE, NAME, DECL)\n \n+#undef ASM_DECLARE_COLD_FUNCTION_SIZE\n+#define ASM_DECLARE_COLD_FUNCTION_SIZE(FILE,NAME,DECL) \\\n+  i386_pe_end_cold_function (FILE, NAME, DECL)\n+\n /* Add an external function to the list of functions to be declared at\n    the end of the file.  */\n #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\"}, {"sha": "ef7c818986f08c35b371adc178421b6b9c4ce8f8", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -256,13 +256,15 @@ extern void i386_pe_asm_output_aligned_decl_common (FILE *, tree,\n extern void i386_pe_file_end (void);\n extern void i386_pe_start_function (FILE *, const char *, tree);\n extern void i386_pe_end_function (FILE *, const char *, tree);\n+extern void i386_pe_end_cold_function (FILE *, const char *, tree);\n extern void i386_pe_assemble_visibility (tree, int);\n extern tree i386_pe_mangle_decl_assembler_name (tree, tree);\n extern tree i386_pe_mangle_assembler_name (const char *);\n extern void i386_pe_record_stub (const char *);\n \n extern void i386_pe_seh_init (FILE *);\n extern void i386_pe_seh_end_prologue (FILE *);\n+extern void i386_pe_seh_cold_init (FILE *, const char *);\n extern void i386_pe_seh_unwind_emit (FILE *, rtx_insn *);\n extern void i386_pe_seh_emit_except_personality (rtx);\n extern void i386_pe_seh_init_sections (void);"}, {"sha": "af24c6ec5ba3bfd825539a4bcaf071d1ceecaabc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -14707,9 +14707,9 @@ ix86_expand_epilogue (int style)\n       if (TARGET_SEH)\n \t{\n \t  /* Prevent a catch region from being adjacent to the standard\n-\t     epilogue sequence.  Unfortuantely crtl->uses_eh_lsda nor\n-\t     several other flags that would be interesting to test are\n-\t     not yet set up.  */\n+\t     epilogue sequence.  Unfortunately neither crtl->uses_eh_lsda\n+\t     nor several other flags that would be interesting to test are\n+\t     set up yet.  */\n \t  if (flag_non_call_exceptions)\n \t    emit_insn (gen_nops (const1_rtx));\n \t  else\n@@ -29211,6 +29211,14 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)\n \n       for (i = NEXT_INSN (insn); i ; i = NEXT_INSN (i))\n \t{\n+\t  /* Prevent a catch region from being adjacent to a jump that would\n+\t     be interpreted as an epilogue sequence by the unwinder.  */\n+\t  if (JUMP_P(i) && CROSSING_JUMP_P (i))\n+\t    {\n+\t      seh_nop_p = true;\n+\t      break;\n+\t    }\n+\t    \n \t  /* If we get to another real insn, we don't need the nop.  */\n \t  if (INSN_P (i))\n \t    break;"}, {"sha": "9b406f490944cde67c8981a853be66f0fa6c5d3b", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 87, "deletions": 10, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"emit-rtl.h\"\n #include \"cgraph.h\"\n #include \"lto-streamer.h\"\n+#include \"except.h\"\n #include \"output.h\"\n #include \"varasm.h\"\n #include \"lto-section-names.h\"\n@@ -820,6 +821,15 @@ struct seh_frame_state\n   /* The CFA is located at CFA_REG + CFA_OFFSET.  */\n   HOST_WIDE_INT cfa_offset;\n   rtx cfa_reg;\n+\n+  /* The offset wrt the CFA where register N has been saved.  */\n+  HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n+\n+  /* True if we are past the end of the epilogue.  */\n+  bool after_prologue;\n+\n+  /* True if we are in the cold section.  */\n+  bool in_cold_section;\n };\n \n /* Set up data structures beginning output for SEH.  */\n@@ -850,30 +860,83 @@ i386_pe_seh_init (FILE *f)\n   fputc ('\\n', f);\n }\n \n+/* Emit an assembler directive for the end of the prologue.  */\n+\n void\n i386_pe_seh_end_prologue (FILE *f)\n+{\n+  if (!TARGET_SEH)\n+    return;\n+  if (cfun->is_thunk)\n+    return;\n+  cfun->machine->seh->after_prologue = true;\n+  fputs (\"\\t.seh_endprologue\\n\", f);\n+}\n+\n+/* Emit assembler directives to reconstruct the SEH state.  */\n+\n+void\n+i386_pe_seh_cold_init (FILE *f, const char *name)\n {\n   struct seh_frame_state *seh;\n+  HOST_WIDE_INT offset;\n \n   if (!TARGET_SEH)\n     return;\n   if (cfun->is_thunk)\n     return;\n   seh = cfun->machine->seh;\n \n-  XDELETE (seh);\n-  cfun->machine->seh = NULL;\n+  fputs (\"\\t.seh_proc\\t\", f);\n+  assemble_name (f, name);\n+  fputc ('\\n', f);\n+\n+  offset = seh->sp_offset - INCOMING_FRAME_SP_OFFSET;\n+  if (offset > 0 && offset < SEH_MAX_FRAME_SIZE)\n+    fprintf (f, \"\\t.seh_stackalloc\\t\" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n+\n+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (seh->reg_offset[regno] > 0)\n+      {\n+\tfputs ((SSE_REGNO_P (regno) ? \"\\t.seh_savexmm\\t\"\n+\t       : GENERAL_REGNO_P (regno) ?  \"\\t.seh_savereg\\t\"\n+\t\t : (gcc_unreachable (), \"\")), f);\n+\tprint_reg (gen_rtx_REG (DImode, regno), 0, f);\n+\tfprintf (f, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t seh->sp_offset - seh->reg_offset[regno]);\n+      }\n+\n+  if (seh->cfa_reg != stack_pointer_rtx)\n+    {\n+      offset = seh->sp_offset - seh->cfa_offset;\n+\n+      gcc_assert ((offset & 15) == 0);\n+      gcc_assert (IN_RANGE (offset, 0, 240));\n+\n+      fputs (\"\\t.seh_setframe\\t\", f);\n+      print_reg (seh->cfa_reg, 0, f);\n+      fprintf (f, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n+    }\n \n   fputs (\"\\t.seh_endprologue\\n\", f);\n }\n \n+/* Emit an assembler directive for the end of the function.  */\n+\n static void\n-i386_pe_seh_fini (FILE *f)\n+i386_pe_seh_fini (FILE *f, bool cold)\n {\n+  struct seh_frame_state *seh;\n+\n   if (!TARGET_SEH)\n     return;\n   if (cfun->is_thunk)\n     return;\n+  seh = cfun->machine->seh;\n+  if (cold != seh->in_cold_section)\n+    return;\n+  XDELETE (seh);\n+  cfun->machine->seh = NULL;\n   fputs (\"\\t.seh_endproc\\n\", f);\n }\n \n@@ -882,11 +945,12 @@ i386_pe_seh_fini (FILE *f)\n static void\n seh_emit_push (FILE *f, struct seh_frame_state *seh, rtx reg)\n {\n-  unsigned int regno = REGNO (reg);\n+  const unsigned int regno = REGNO (reg);\n \n   gcc_checking_assert (GENERAL_REGNO_P (regno));\n \n   seh->sp_offset += UNITS_PER_WORD;\n+  seh->reg_offset[regno] = seh->sp_offset;\n   if (seh->cfa_reg == stack_pointer_rtx)\n     seh->cfa_offset += UNITS_PER_WORD;\n \n@@ -901,9 +965,11 @@ static void\n seh_emit_save (FILE *f, struct seh_frame_state *seh,\n \t       rtx reg, HOST_WIDE_INT cfa_offset)\n {\n-  unsigned int regno = REGNO (reg);\n+  const unsigned int regno = REGNO (reg);\n   HOST_WIDE_INT offset;\n \n+  seh->reg_offset[regno] = cfa_offset;\n+\n   /* Negative save offsets are of course not supported, since that\n      would be a store below the stack pointer and thus clobberable.  */\n   gcc_assert (seh->sp_offset >= cfa_offset);\n@@ -1112,15 +1178,21 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n   if (!TARGET_SEH)\n     return;\n \n-  /* We free the SEH data once done with the prologue.  Ignore those\n-     RTX_FRAME_RELATED_P insns that are associated with the epilogue.  */\n   seh = cfun->machine->seh;\n-  if (seh == NULL)\n-    return;\n+  if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n+    {\n+      fputs (\"\\t.seh_endproc\\n\", asm_out_file);\n+      seh->in_cold_section = true;\n+      return;\n+    }\n \n   if (NOTE_P (insn) || !RTX_FRAME_RELATED_P (insn))\n     return;\n \n+  /* Skip RTX_FRAME_RELATED_P insns that are associated with the epilogue.  */\n+  if (seh->after_prologue)\n+    return;\n+\n   for (note = REG_NOTES (insn); note ; note = XEXP (note, 1))\n     {\n       switch (REG_NOTE_KIND (note))\n@@ -1227,8 +1299,13 @@ i386_pe_start_function (FILE *f, const char *name, tree decl)\n void\n i386_pe_end_function (FILE *f, const char *, tree)\n {\n-  i386_pe_seh_fini (f);\n+  i386_pe_seh_fini (f, false);\n }\n \f\n+void\n+i386_pe_end_cold_function (FILE *f, const char *, tree)\n+{\n+  i386_pe_seh_fini (f, true);\n+}\n \n #include \"gt-winnt.h\""}, {"sha": "53e57732ea85bad245714bb60c82eec7cd610df9", "filename": "gcc/except.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -2939,7 +2939,6 @@ switch_to_exception_section (const char * ARG_UNUSED (fnname))\n   switch_to_section (s);\n }\n \n-\n /* Output a reference from an exception table to the type_info object TYPE.\n    TT_FORMAT and TT_FORMAT_SIZE describe the DWARF encoding method used for\n    the value.  */\n@@ -2989,6 +2988,13 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n     dw2_asm_output_encoded_addr_rtx (tt_format, value, is_public, NULL);\n }\n \n+/* Output an exception table for the current function according to SECTION.\n+\n+   If the function has been partitioned into hot and cold parts, value 0 for\n+   SECTION refers to the table associated with the hot part while value 1\n+   refers to the table associated with the cold part.  If the function has\n+   not been partitioned, value 0 refers to the single exception table.  */\n+ \n static void\n output_one_function_exception_table (int section)\n {\n@@ -3167,13 +3173,26 @@ output_one_function_exception_table (int section)\n     }\n }\n \n+/* Output an exception table for the current function according to SECTION,\n+   switching back and forth from the function section appropriately.\n+\n+   If the function has been partitioned into hot and cold parts, value 0 for\n+   SECTION refers to the table associated with the hot part while value 1\n+   refers to the table associated with the cold part.  If the function has\n+   not been partitioned, value 0 refers to the single exception table.  */\n+\n void\n-output_function_exception_table (const char *fnname)\n+output_function_exception_table (int section)\n {\n+  const char *fnname = get_fnname_from_decl (current_function_decl);\n   rtx personality = get_personality_function (current_function_decl);\n \n   /* Not all functions need anything.  */\n-  if (! crtl->uses_eh_lsda)\n+  if (!crtl->uses_eh_lsda)\n+    return;\n+\n+  /* No need to emit any boilerplate stuff for the cold part.  */\n+  if (section == 1 && !crtl->eh.call_site_record_v[1])\n     return;\n \n   if (personality)\n@@ -3189,9 +3208,8 @@ output_function_exception_table (const char *fnname)\n   /* If the target wants a label to begin the table, emit it here.  */\n   targetm.asm_out.emit_except_table_label (asm_out_file);\n \n-  output_one_function_exception_table (0);\n-  if (crtl->eh.call_site_record_v[1])\n-    output_one_function_exception_table (1);\n+  /* Do the real work.  */\n+  output_one_function_exception_table (section);\n \n   switch_to_section (current_function_section ());\n }"}, {"sha": "229e446cb655499fb4024a07aa6b098f07126c67", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -229,7 +229,7 @@ extern void remove_eh_handler (eh_region);\n extern void remove_unreachable_eh_regions (sbitmap);\n \n extern bool current_function_has_exception_handlers (void);\n-extern void output_function_exception_table (const char *);\n+extern void output_function_exception_table (int);\n \n extern rtx expand_builtin_eh_pointer (tree);\n extern rtx expand_builtin_eh_filter (tree);"}, {"sha": "87a3067f3b1e3ccb65373e825d896152742c3636", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78b513e41b3d491efa0bd639cedbad8622a09bd/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b78b513e41b3d491efa0bd639cedbad8622a09bd", "patch": "@@ -2265,6 +2265,11 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t  maybe_output_next_view (seen);\n \n+\t  output_function_exception_table (0);\n+\n+\t  if (targetm.asm_out.unwind_emit)\n+\t    targetm.asm_out.unwind_emit (asm_out_file, insn);\n+\n \t  in_cold_section_p = !in_cold_section_p;\n \n \t  if (in_cold_section_p)\n@@ -4672,7 +4677,7 @@ rest_of_handle_final (void)\n   /* The IA-64 \".handlerdata\" directive must be issued before the \".endp\"\n      directive that closes the procedure descriptor.  Similarly, for x64 SEH.\n      Otherwise it's not strictly necessary, but it doesn't hurt either.  */\n-  output_function_exception_table (fnname);\n+  output_function_exception_table (crtl->has_bb_partition ? 1 : 0);\n \n   assemble_end_function (current_function_decl, fnname);\n "}]}