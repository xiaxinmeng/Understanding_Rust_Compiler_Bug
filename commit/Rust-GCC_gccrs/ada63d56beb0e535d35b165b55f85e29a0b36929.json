{"sha": "ada63d56beb0e535d35b165b55f85e29a0b36929", "node_id": "C_kwDOANBUbNoAKGFkYTYzZDU2YmViMGU1MzVkMzViMTY1YjU1Zjg1ZTI5YTBiMzY5Mjk", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-19T17:09:13Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-19T17:09:13Z"}, "message": "Use modref even for nested functions in ref_maybe_used_by_call_p_1\n\nRemove test for function not having call chain guarding modref use in\nref_maybe_used_by_call_p_1.  It never made sense since modref treats call chain\naccesses explicitly. It was however copied from earlier check for ECF_CONST\n(which seems dubious too, but I would like to discuss it independelty).\n\nThis enables us to detect that memory pointed to static chain (or parts of it)\nare unused by the function.\n\nlto-bootstrapped-regtested all lanugages on x86_64-linux.\n\ngcc/ChangeLog:\n\n2021-11-19  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Do not guard modref\n\tby !gimple_call_chain.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-19  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/tree-ssa/modref-dse-6.c: New test.", "tree": {"sha": "b809bfa4f6a962e625f2c437130a2eb60e0ba7d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b809bfa4f6a962e625f2c437130a2eb60e0ba7d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ada63d56beb0e535d35b165b55f85e29a0b36929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada63d56beb0e535d35b165b55f85e29a0b36929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ada63d56beb0e535d35b165b55f85e29a0b36929", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada63d56beb0e535d35b165b55f85e29a0b36929/comments", "author": null, "committer": null, "parents": [{"sha": "16137fbb9256ef365dd498d39024eb33de1a4cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16137fbb9256ef365dd498d39024eb33de1a4cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16137fbb9256ef365dd498d39024eb33de1a4cd8"}], "stats": {"total": 25, "additions": 24, "deletions": 1}, "files": [{"sha": "d1e45a893adb6ee99792d373e497f062c42902e6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-dse-6.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada63d56beb0e535d35b165b55f85e29a0b36929/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada63d56beb0e535d35b165b55f85e29a0b36929/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-6.c?ref=ada63d56beb0e535d35b165b55f85e29a0b36929", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\"  } */\n+int\n+main()\n+{\n+  int a,b;\n+  __attribute__ ((noinline))\n+  void kill_me()\n+  {\n+    a=1234;\n+    b=2234;\n+  }\n+  a=0;\n+  b=1234;\n+  __attribute__ ((noinline))\n+  int reta()\n+  {\n+    return a;\n+  }\n+  return reta();\n+}\n+/* { dg-final { scan-tree-dump-not \"kill_me\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"1234\" \"optimized\" } } */"}, {"sha": "cd6a0b2f67ba5c7343ca0369629d03f8f5625f5e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada63d56beb0e535d35b165b55f85e29a0b36929/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada63d56beb0e535d35b165b55f85e29a0b36929/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=ada63d56beb0e535d35b165b55f85e29a0b36929", "patch": "@@ -2755,7 +2755,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n \n   callee = gimple_call_fndecl (call);\n \n-  if (!gimple_call_chain (call) && callee != NULL_TREE)\n+  if (callee != NULL_TREE)\n     {\n       struct cgraph_node *node = cgraph_node::get (callee);\n       /* We can not safely optimize based on summary of calle if it does"}]}