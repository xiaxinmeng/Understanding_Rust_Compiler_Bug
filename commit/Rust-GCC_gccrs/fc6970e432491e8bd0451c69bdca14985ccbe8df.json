{"sha": "fc6970e432491e8bd0451c69bdca14985ccbe8df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM2OTcwZTQzMjQ5MWU4YmQwNDUxYzY5YmRjYTE0OTg1Y2NiZThkZg==", "commit": {"author": {"name": "Revital Eres", "email": "revital.eres@linaro.org", "date": "2011-05-11T12:38:12Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2011-05-11T12:38:12Z"}, "message": "Support closing_branch_deps\n\nFrom-SVN: r173654", "tree": {"sha": "caa6a3161983772e0f84987896fcbdc97b5fd4f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caa6a3161983772e0f84987896fcbdc97b5fd4f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc6970e432491e8bd0451c69bdca14985ccbe8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6970e432491e8bd0451c69bdca14985ccbe8df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc6970e432491e8bd0451c69bdca14985ccbe8df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6970e432491e8bd0451c69bdca14985ccbe8df/comments", "author": null, "committer": null, "parents": [{"sha": "41a58a92c3be093fd963d1fdea1231631e06fc32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a58a92c3be093fd963d1fdea1231631e06fc32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41a58a92c3be093fd963d1fdea1231631e06fc32"}], "stats": {"total": 208, "additions": 152, "deletions": 56}, "files": [{"sha": "74a6e7cb2024b8bd537b70753f1852b5d858ef59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6970e432491e8bd0451c69bdca14985ccbe8df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6970e432491e8bd0451c69bdca14985ccbe8df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc6970e432491e8bd0451c69bdca14985ccbe8df", "patch": "@@ -1,3 +1,24 @@\n+2011-05-11  Revital Eres  <revital.eres@linaro.org>\n+\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link): If a true dep edge\n+\tenters the branch create an anti edge in the opposite direction\n+\tto prevent the creation of reg-moves.\n+\t* modulo-sched.c: Adjust comment to reflect the fact we are\n+\tscheduling closing branch.\n+\t(PS_STAGE_COUNT): Rename to CALC_STAGE_COUNT and redefine.\n+\t(stage_count): New field in struct partial_schedule.\n+\t(calculate_stage_count): New function.\n+\t(normalize_sched_times): Rename to reset_sched_times and handle\n+\tincrementing the sched time of the nodes by a constant value\n+\tpassed as parameter.\n+\t(duplicate_insns_of_cycles): Skip closing branch.\n+\t(sms_schedule_by_order): Schedule closing branch.\n+\t(ps_insn_find_column): Handle closing branch.\n+\t(sms_schedule): Call reset_sched_times and adjust the code to\n+\tsupport scheduling of the closing branch.\n+\t(ps_insert_empty_row): Update calls to normalize_sched_times\n+\tand rotate_partial_schedule functions.\n+\n 2011-05-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/48953"}, {"sha": "b8ae375f153465107bce6760d203ae53595a4280", "filename": "gcc/ddg.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6970e432491e8bd0451c69bdca14985ccbe8df/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6970e432491e8bd0451c69bdca14985ccbe8df/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=fc6970e432491e8bd0451c69bdca14985ccbe8df", "patch": "@@ -197,6 +197,11 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n         }\n     }\n \n+  /* If a true dep edge enters the branch create an anti edge in the\n+     opposite direction to prevent the creation of reg-moves.  */\n+  if ((DEP_TYPE (link) == REG_DEP_TRUE) && JUMP_P (dest_node->insn))\n+    create_ddg_dep_no_link (g, dest_node, src_node, ANTI_DEP, REG_DEP, 1);\n+\n    latency = dep_cost (link);\n    e = create_ddg_edge (src_node, dest_node, t, dt, latency, distance);\n    add_edge_to_ddg (g, e);"}, {"sha": "4937a56a7c4121beb20bda578ec8baaedb9e8c93", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 126, "deletions": 56, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc6970e432491e8bd0451c69bdca14985ccbe8df/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc6970e432491e8bd0451c69bdca14985ccbe8df/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=fc6970e432491e8bd0451c69bdca14985ccbe8df", "patch": "@@ -84,14 +84,13 @@ along with GCC; see the file COPYING3.  If not see\n       II cycles (i.e. use register copies to prevent a def from overwriting\n       itself before reaching the use).\n \n-    SMS works with countable loops (1) whose control part can be easily\n-    decoupled from the rest of the loop and (2) whose loop count can\n-    be easily adjusted.  This is because we peel a constant number of\n-    iterations into a prologue and epilogue for which we want to avoid\n-    emitting the control part, and a kernel which is to iterate that\n-    constant number of iterations less than the original loop.  So the\n-    control part should be a set of insns clearly identified and having\n-    its own iv, not otherwise used in the loop (at-least for now), which\n+    SMS works with countable loops whose loop count can be easily\n+    adjusted.  This is because we peel a constant number of iterations\n+    into a prologue and epilogue for which we want to avoid emitting\n+    the control part, and a kernel which is to iterate that constant\n+    number of iterations less than the original loop.  So the control\n+    part should be a set of insns clearly identified and having its\n+    own iv, not otherwise used in the loop (at-least for now), which\n     initializes a register before the loop to the number of iterations.\n     Currently SMS relies on the do-loop pattern to recognize such loops,\n     where (1) the control part comprises of all insns defining and/or\n@@ -116,8 +115,10 @@ typedef struct ps_insn *ps_insn_ptr;\n \n /* The number of different iterations the nodes in ps span, assuming\n    the stage boundaries are placed efficiently.  */\n-#define PS_STAGE_COUNT(ps) ((PS_MAX_CYCLE (ps) - PS_MIN_CYCLE (ps) \\\n-\t\t\t     + 1 + (ps)->ii - 1) / (ps)->ii)\n+#define CALC_STAGE_COUNT(max_cycle,min_cycle,ii) ((max_cycle - min_cycle \\\n+                         + 1 + ii - 1) / ii)\n+/* The stage count of ps.  */\n+#define PS_STAGE_COUNT(ps) (((partial_schedule_ptr)(ps))->stage_count)\n \n /* A single instruction in the partial schedule.  */\n struct ps_insn\n@@ -155,6 +156,8 @@ struct partial_schedule\n   int max_cycle;\n \n   ddg_ptr g;\t/* The DDG of the insns in the partial schedule.  */\n+\n+  int stage_count;  /* The stage count of the partial schedule.  */\n };\n \n /* We use this to record all the register replacements we do in\n@@ -195,7 +198,7 @@ static void generate_prolog_epilog (partial_schedule_ptr, struct loop *,\n                                     rtx, rtx);\n static void duplicate_insns_of_cycles (partial_schedule_ptr,\n \t\t\t\t       int, int, int, rtx);\n-\n+static int calculate_stage_count (partial_schedule_ptr ps);\n #define SCHED_ASAP(x) (((node_sched_params_ptr)(x)->aux.info)->asap)\n #define SCHED_TIME(x) (((node_sched_params_ptr)(x)->aux.info)->time)\n #define SCHED_FIRST_REG_MOVE(x) \\\n@@ -569,13 +572,13 @@ free_undo_replace_buff (struct undo_replace_buff_elem *reg_move_replaces)\n     }\n }\n \n-/* Bump the SCHED_TIMEs of all nodes to start from zero.  Set the values\n-   of SCHED_ROW and SCHED_STAGE.  */\n+/* Bump the SCHED_TIMEs of all nodes by AMOUNT.  Set the values of\n+   SCHED_ROW and SCHED_STAGE.  Instruction scheduled on cycle AMOUNT\n+   will move to cycle zero.  */\n static void\n-normalize_sched_times (partial_schedule_ptr ps)\n+reset_sched_times (partial_schedule_ptr ps, int amount)\n {\n   int row;\n-  int amount = PS_MIN_CYCLE (ps);\n   int ii = ps->ii;\n   ps_insn_ptr crr_insn;\n \n@@ -584,19 +587,43 @@ normalize_sched_times (partial_schedule_ptr ps)\n       {\n \tddg_node_ptr u = crr_insn->node;\n \tint normalized_time = SCHED_TIME (u) - amount;\n+\tint new_min_cycle = PS_MIN_CYCLE (ps) - amount;\n+        int sc_until_cycle_zero, stage;\n \n-\tif (dump_file)\n-\t  fprintf (dump_file, \"crr_insn->node=%d, crr_insn->cycle=%d,\\\n-\t\t   min_cycle=%d\\n\", crr_insn->node->cuid, SCHED_TIME\n-\t\t   (u), ps->min_cycle);\n+        if (dump_file)\n+          {\n+            /* Print the scheduling times after the rotation.  */\n+            fprintf (dump_file, \"crr_insn->node=%d (insn id %d), \"\n+                     \"crr_insn->cycle=%d, min_cycle=%d\", crr_insn->node->cuid,\n+                     INSN_UID (crr_insn->node->insn), SCHED_TIME (u),\n+                     normalized_time);\n+            if (JUMP_P (crr_insn->node->insn))\n+              fprintf (dump_file, \" (branch)\");\n+            fprintf (dump_file, \"\\n\");\n+          }\n+\t\n \tgcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n \tgcc_assert (SCHED_TIME (u) <= ps->max_cycle);\n \tSCHED_TIME (u) = normalized_time;\n-\tSCHED_ROW (u) = normalized_time % ii;\n-\tSCHED_STAGE (u) = normalized_time / ii;\n+\tSCHED_ROW (u) = SMODULO (normalized_time, ii);\n+      \n+        /* The calculation of stage count is done adding the number\n+           of stages before cycle zero and after cycle zero.  */\n+\tsc_until_cycle_zero = CALC_STAGE_COUNT (-1, new_min_cycle, ii);\n+\t\n+\tif (SCHED_TIME (u) < 0)\n+\t  {\n+\t    stage = CALC_STAGE_COUNT (-1, SCHED_TIME (u), ii);\n+\t    SCHED_STAGE (u) = sc_until_cycle_zero - stage;\n+\t  }\n+\telse\n+\t  {\n+\t    stage = CALC_STAGE_COUNT (SCHED_TIME (u), 0, ii);\n+\t    SCHED_STAGE (u) = sc_until_cycle_zero + stage - 1;\n+\t  }\n       }\n }\n-\n+ \n /* Set SCHED_COLUMN of each node according to its position in PS.  */\n static void\n set_columns_for_ps (partial_schedule_ptr ps)\n@@ -646,9 +673,12 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \n         /* Do not duplicate any insn which refers to count_reg as it\n            belongs to the control part.\n+           The closing branch is scheduled as well and thus should\n+           be ignored.\n            TODO: This should be done by analyzing the control part of\n            the loop.  */\n-        if (reg_mentioned_p (count_reg, u_node->insn))\n+        if (reg_mentioned_p (count_reg, u_node->insn)\n+            || JUMP_P (ps_ij->node->insn))\n           continue;\n \n \tif (for_prolog)\n@@ -1052,7 +1082,11 @@ sms_schedule (void)\n \t  continue;\n \t}\n \n-      if (! (g = create_ddg (bb, 0)))\n+      /* Always schedule the closing branch with the rest of the\n+         instructions. The branch is rotated to be in row ii-1 at the\n+         end of the scheduling procedure to make sure it's the last\n+         instruction in the iteration.  */\n+      if (! (g = create_ddg (bb, 1)))\n         {\n           if (dump_file)\n \t    fprintf (dump_file, \"SMS create_ddg failed\\n\");\n@@ -1160,10 +1194,12 @@ sms_schedule (void)\n \n       ps = sms_schedule_by_order (g, mii, maxii, node_order);\n \n-      if (ps){\n-\tstage_count = PS_STAGE_COUNT (ps);\n-        gcc_assert(stage_count >= 1);\n-      }\n+       if (ps)\n+       {\n+         stage_count = calculate_stage_count (ps);\n+         gcc_assert(stage_count >= 1);\n+         PS_STAGE_COUNT(ps) = stage_count;\n+       }\n \n       /* The default value of PARAM_SMS_MIN_SC is 2 as stage count of\n \t 1 means that there is no interleaving between iterations thus\n@@ -1185,32 +1221,24 @@ sms_schedule (void)\n       else\n \t{\n \t  struct undo_replace_buff_elem *reg_move_replaces;\n+          int amount = SCHED_TIME (g->closing_branch) + 1;\n+\t  \n+\t  /* Set the stage boundaries.\tThe closing_branch was scheduled\n+\t     and should appear in the last (ii-1) row.  */\n+\t  reset_sched_times (ps, amount);\n+\t  rotate_partial_schedule (ps, amount);\n+\t  set_columns_for_ps (ps);\n \n-\t  if (dump_file)\n-\t    {\n+\t  canon_loop (loop);\n+\n+          if (dump_file)\n+            {\n \t      fprintf (dump_file,\n \t\t       \"SMS succeeded %d %d (with ii, sc)\\n\", ps->ii,\n \t\t       stage_count);\n \t      print_partial_schedule (ps, dump_file);\n-\t      fprintf (dump_file,\n-\t\t       \"SMS Branch (%d) will later be scheduled at cycle %d.\\n\",\n-\t\t       g->closing_branch->cuid, PS_MIN_CYCLE (ps) - 1);\n \t    }\n-\n-\t  /* Set the stage boundaries.  If the DDG is built with closing_branch_deps,\n-\t     the closing_branch was scheduled and should appear in the last (ii-1)\n-\t     row.  Otherwise, we are free to schedule the branch, and we let nodes\n-\t     that were scheduled at the first PS_MIN_CYCLE cycle appear in the first\n-\t     row; this should reduce stage_count to minimum.\n-             TODO: Revisit the issue of scheduling the insns of the\n-             control part relative to the branch when the control part\n-             has more than one insn.  */\n-\t  normalize_sched_times (ps);\n-\t  rotate_partial_schedule (ps, PS_MIN_CYCLE (ps));\n-\t  set_columns_for_ps (ps);\n-\n-\t  canon_loop (loop);\n-\n+ \n           /* case the BCT count is not known , Do loop-versioning */\n \t  if (count_reg && ! count_init)\n             {\n@@ -1763,12 +1791,6 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \t      continue;\n \t    }\n \n-\t  if (JUMP_P (insn)) /* Closing branch handled later.  */\n-\t    {\n-\t      RESET_BIT (tobe_scheduled, u);\n-\t      continue;\n-\t    }\n-\n \t  if (TEST_BIT (sched_nodes, u))\n \t    continue;\n \n@@ -1896,8 +1918,8 @@ ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n   if (dump_file)\n     fprintf (dump_file, \"split_row=%d\\n\", split_row);\n \n-  normalize_sched_times (ps);\n-  rotate_partial_schedule (ps, ps->min_cycle);\n+  reset_sched_times (ps, PS_MIN_CYCLE (ps));\n+  rotate_partial_schedule (ps, PS_MIN_CYCLE (ps));\n \n   rows_new = (ps_insn_ptr *) xcalloc (new_ii, sizeof (ps_insn_ptr));\n   for (row = 0; row < split_row; row++)\n@@ -2574,6 +2596,7 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n   ps_insn_ptr next_ps_i;\n   ps_insn_ptr first_must_follow = NULL;\n   ps_insn_ptr last_must_precede = NULL;\n+  ps_insn_ptr last_in_row = NULL;\n   int row;\n \n   if (! ps_i)\n@@ -2600,8 +2623,37 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n \t  else\n             last_must_precede = next_ps_i;\n         }\n+      /* The closing branch must be the last in the row.  */\n+      if (must_precede \n+\t  && TEST_BIT (must_precede, next_ps_i->node->cuid) \n+\t  && JUMP_P (next_ps_i->node->insn))     \n+\treturn false;\n+             \n+       last_in_row = next_ps_i;\n     }\n \n+  /* The closing branch is scheduled as well.  Make sure there is no\n+     dependent instruction after it as the branch should be the last\n+     instruction in the row.  */\n+  if (JUMP_P (ps_i->node->insn)) \n+    {\n+      if (first_must_follow)\n+\treturn false;\n+      if (last_in_row)\n+\t{\n+\t  /* Make the branch the last in the row.  New instructions\n+\t     will be inserted at the beginning of the row or after the\n+\t     last must_precede instruction thus the branch is guaranteed\n+\t     to remain the last instruction in the row.  */\n+\t  last_in_row->next_in_row = ps_i;\n+\t  ps_i->prev_in_row = last_in_row;\n+\t  ps_i->next_in_row = NULL;\n+\t}\n+      else\n+\tps->rows[row] = ps_i;\n+      return true;\n+    }\n+  \n   /* Now insert the node after INSERT_AFTER_PSI.  */\n \n   if (! last_must_precede)\n@@ -2823,6 +2875,24 @@ ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n,\n   return ps_i;\n }\n \n+/* Calculate the stage count of the partial schedule PS.  The calculation\n+   takes into account the rotation to bring the closing branch to row\n+   ii-1.  */\n+int\n+calculate_stage_count (partial_schedule_ptr ps)\n+{\n+  int rotation_amount = (SCHED_TIME (ps->g->closing_branch)) + 1;\n+  int new_min_cycle = PS_MIN_CYCLE (ps) - rotation_amount;\n+  int new_max_cycle = PS_MAX_CYCLE (ps) - rotation_amount;\n+  int stage_count = CALC_STAGE_COUNT (-1, new_min_cycle, ps->ii);\n+\n+  /* The calculation of stage count is done adding the number of stages\n+     before cycle zero and after cycle zero.  */ \n+  stage_count += CALC_STAGE_COUNT (new_max_cycle, 0, ps->ii);\n+\n+  return stage_count;\n+}\n+\n /* Rotate the rows of PS such that insns scheduled at time\n    START_CYCLE will appear in row 0.  Updates max/min_cycles.  */\n void"}]}