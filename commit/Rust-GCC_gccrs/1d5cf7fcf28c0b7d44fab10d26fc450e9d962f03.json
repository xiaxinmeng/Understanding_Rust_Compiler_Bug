{"sha": "1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ1Y2Y3ZmNmMjhjMGI3ZDQ0ZmFiMTBkMjZmYzQ1MGU5ZDk2MmYwMw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-05-25T21:51:27Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-05-25T21:51:27Z"}, "message": "re PR libfortran/78379 (Processor-specific versions for matmul)\n\n2017-05-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/78379\n\t* Makefile.am: Add generated/matmulavx128_*.c files.\n\tHandle them for compiling and setting the right flags.\n\t* acinclude.m4: Add tests for FMA3, FMA4 and AVX128.\n\t* configure.ac: Call them.\n\t* Makefile.in: Regenerated.\n\t* config.h.in: Regenerated.\n\t* configure: Regenerated.\n\t* m4/matmul.m4:  Handle AMD chips by calling 128-bit AVX\n\tversions which use FMA3 or FMA4.\n\t* m4/matmulavx128.m4: New file.\n        * generated/matmul_c10.c: Regenerated.\n        * generated/matmul_c16.c: Regenerated.\n        * generated/matmul_c4.c: Regenerated.\n        * generated/matmul_c8.c: Regenerated.\n        * generated/matmul_i1.c: Regenerated.\n        * generated/matmul_i16.c: Regenerated.\n        * generated/matmul_i2.c: Regenerated.\n        * generated/matmul_i4.c: Regenerated.\n        * generated/matmul_i8.c: Regenerated.\n        * generated/matmul_r10.c: Regenerated.\n        * generated/matmul_r16.c: Regenerated.\n        * generated/matmul_r4.c: Regenerated.\n        * generated/matmul_r8.c: Regenerated.\n        * generated/matmulavx128_c10.c: New file.\n        * generated/matmulavx128_c16.c: New file.\n        * generated/matmulavx128_c4.c: New file.\n        * generated/matmulavx128_c8.c: New file.\n        * generated/matmulavx128_i1.c: New file.\n        * generated/matmulavx128_i16.c: New file.\n        * generated/matmulavx128_i2.c: New file.\n        * generated/matmulavx128_i4.c: New file.\n        * generated/matmulavx128_i8.c: New file.\n        * generated/matmulavx128_r10.c: New file.\n        * generated/matmulavx128_r16.c: New file.\n        * generated/matmulavx128_r4.c: New file.\n        * generated/matmulavx128_r8.c: New file.\n\nFrom-SVN: r248472", "tree": {"sha": "3cd241e469094809d6ceb3aa1a14f6841627e681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cd241e469094809d6ceb3aa1a14f6841627e681"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/comments", "author": null, "committer": null, "parents": [{"sha": "87e1e6036ef93b18b1450357488ee907db880f37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e1e6036ef93b18b1450357488ee907db880f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e1e6036ef93b18b1450357488ee907db880f37"}], "stats": {"total": 15991, "additions": 15964, "deletions": 27}, "files": [{"sha": "3e6c0ad2a61e0bc51d1835679cf6ce4075ce9f59", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1,3 +1,43 @@\n+2017-05-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/78379\n+\t* Makefile.am: Add generated/matmulavx128_*.c files.\n+\tHandle them for compiling and setting the right flags.\n+\t* acinclude.m4: Add tests for FMA3, FMA4 and AVX128.\n+\t* configure.ac: Call them.\n+\t* Makefile.in: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* m4/matmul.m4:  Handle AMD chips by calling 128-bit AVX\n+\tversions which use FMA3 or FMA4.\n+\t* m4/matmulavx128.m4: New file.\n+        * generated/matmul_c10.c: Regenerated.\n+        * generated/matmul_c16.c: Regenerated.\n+        * generated/matmul_c4.c: Regenerated.\n+        * generated/matmul_c8.c: Regenerated.\n+        * generated/matmul_i1.c: Regenerated.\n+        * generated/matmul_i16.c: Regenerated.\n+        * generated/matmul_i2.c: Regenerated.\n+        * generated/matmul_i4.c: Regenerated.\n+        * generated/matmul_i8.c: Regenerated.\n+        * generated/matmul_r10.c: Regenerated.\n+        * generated/matmul_r16.c: Regenerated.\n+        * generated/matmul_r4.c: Regenerated.\n+        * generated/matmul_r8.c: Regenerated.\n+        * generated/matmulavx128_c10.c: New file.\n+        * generated/matmulavx128_c16.c: New file.\n+        * generated/matmulavx128_c4.c: New file.\n+        * generated/matmulavx128_c8.c: New file.\n+        * generated/matmulavx128_i1.c: New file.\n+        * generated/matmulavx128_i16.c: New file.\n+        * generated/matmulavx128_i2.c: New file.\n+        * generated/matmulavx128_i4.c: New file.\n+        * generated/matmulavx128_i8.c: New file.\n+        * generated/matmulavx128_r10.c: New file.\n+        * generated/matmulavx128_r16.c: New file.\n+        * generated/matmulavx128_r4.c: New file.\n+        * generated/matmulavx128_r8.c: New file.\n+\n 2017-05-19  Paul Thomas  <pault@gcc.gnu.org>\n \t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n@@ -14,7 +54,7 @@\n \t(st_endfile): Likewise.\n \t(st_rewind): Likewise.\n \t(st_flush): Likewise.\n-\t\n+\n 2017-05-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/80727"}, {"sha": "908881293037bf34aba7a09e3905b7f3f776d8fd", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -460,6 +460,21 @@ $(srcdir)/generated/matmul_c8.c \\\n $(srcdir)/generated/matmul_c10.c \\\n $(srcdir)/generated/matmul_c16.c\n \n+i_matmulavx128_c= \\\n+$(srcdir)/generated/matmulavx128_i1.c \\\n+$(srcdir)/generated/matmulavx128_i2.c \\\n+$(srcdir)/generated/matmulavx128_i4.c \\\n+$(srcdir)/generated/matmulavx128_i8.c \\\n+$(srcdir)/generated/matmulavx128_i16.c \\\n+$(srcdir)/generated/matmulavx128_r4.c \\\n+$(srcdir)/generated/matmulavx128_r8.c \\\n+$(srcdir)/generated/matmulavx128_r10.c \\\n+$(srcdir)/generated/matmulavx128_r16.c \\\n+$(srcdir)/generated/matmulavx128_c4.c \\\n+$(srcdir)/generated/matmulavx128_c8.c \\\n+$(srcdir)/generated/matmulavx128_c10.c \\\n+$(srcdir)/generated/matmulavx128_c16.c\n+\n i_matmull_c= \\\n $(srcdir)/generated/matmul_l4.c \\\n $(srcdir)/generated/matmul_l8.c \\\n@@ -641,7 +656,7 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_iparity_c) $(i_norm2_c) $(i_parity_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n-    $(i_pow_c) $(i_pack_c) $(i_unpack_c) \\\n+    $(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc\n \n@@ -796,7 +811,12 @@ intrinsics/dprod_r8.f90 \\\n intrinsics/f2c_specifics.F90\n \n # Turn on vectorization and loop unrolling for matmul.\n-$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ffast-math -ftree-vectorize -funroll-loops --param max-unroll-times=4 \n+$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ffast-math -ftree-vectorize -funroll-loops --param max-unroll-times=4\n+\n+if HAVE_AVX128\n+# Turn on AVX128 for AMD-specific matmul, but only if the compiler understands -mprefer-avx128\n+$(patsubst %.c,%.lo,$(notdir $(i_matmulavx128_c))): AM_CFLAGS += -ffast-math -ftree-vectorize -funroll-loops --param max-unroll-times=4 -mprefer-avx128\n+endif\n # Logical matmul doesn't vectorize.\n $(patsubst %.c,%.lo,$(notdir $(i_matmull_c))): AM_CFLAGS += -funroll-loops\n \n@@ -936,6 +956,9 @@ $(i_sum_c): m4/sum.m4 $(I_M4_DEPS1)\n $(i_matmul_c): m4/matmul.m4 m4/matmul_internal.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmul.m4 > $@\n \n+$(i_matmulavx128_c): m4/matmulavx128.m4 m4/matmul_internal.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmulavx128.m4 > $@\n+\n $(i_matmull_c): m4/matmull.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmull.m4 > $@\n "}, {"sha": "e47d6ebc5930b0c0a3a04b7df2f84facbc67123c", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 152, "deletions": 22, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -289,15 +289,20 @@ am__objects_32 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \\\n \tunpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \\\n \tunpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \\\n \tunpack_c16.lo\n-am__objects_33 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n+am__objects_33 = matmulavx128_i1.lo matmulavx128_i2.lo \\\n+\tmatmulavx128_i4.lo matmulavx128_i8.lo matmulavx128_i16.lo \\\n+\tmatmulavx128_r4.lo matmulavx128_r8.lo matmulavx128_r10.lo \\\n+\tmatmulavx128_r16.lo matmulavx128_c4.lo matmulavx128_c8.lo \\\n+\tmatmulavx128_c10.lo matmulavx128_c16.lo\n+am__objects_34 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n \tspread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \\\n \tspread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \\\n \tspread_c16.lo\n-am__objects_34 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n+am__objects_35 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n \tcshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \\\n \tcshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \\\n \tcshift0_c10.lo cshift0_c16.lo\n-am__objects_35 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n+am__objects_36 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n@@ -307,14 +312,14 @@ am__objects_35 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_25) $(am__objects_26) $(am__objects_27) \\\n \t$(am__objects_28) $(am__objects_29) $(am__objects_30) \\\n \t$(am__objects_31) $(am__objects_32) $(am__objects_33) \\\n-\t$(am__objects_34)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_36 = close.lo file_pos.lo format.lo \\\n+\t$(am__objects_34) $(am__objects_35)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_37 = close.lo file_pos.lo format.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tfbuf.lo\n-am__objects_37 = size_from_kind.lo $(am__objects_36)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_38 = access.lo c99_functions.lo \\\n+am__objects_38 = size_from_kind.lo $(am__objects_37)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_39 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tctime.lo date_and_time.lo dtime.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tenv.lo etime.lo execute_command_line.lo \\\n@@ -324,19 +329,19 @@ am__objects_37 = size_from_kind.lo $(am__objects_36)\n @LIBGFOR_MINIMAL_FALSE@\trename.lo stat.lo symlnk.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tsystem_clock.lo time.lo umask.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tunlink.lo\n-@IEEE_SUPPORT_TRUE@am__objects_39 = ieee_helper.lo\n-am__objects_40 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n+@IEEE_SUPPORT_TRUE@am__objects_40 = ieee_helper.lo\n+am__objects_41 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n \teoshift2.lo erfc_scaled.lo extends_type_of.lo fnum.lo \\\n \tierrno.lo ishftc.lo mvbits.lo move_alloc.lo pack_generic.lo \\\n \tselected_char_kind.lo size.lo spread_generic.lo \\\n \tstring_intrinsics.lo rand.lo random.lo reshape_generic.lo \\\n \treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n \tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\t$(am__objects_38) $(am__objects_39)\n-@IEEE_SUPPORT_TRUE@am__objects_41 = ieee_arithmetic.lo \\\n+\t$(am__objects_39) $(am__objects_40)\n+@IEEE_SUPPORT_TRUE@am__objects_42 = ieee_arithmetic.lo \\\n @IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n-am__objects_42 =\n-am__objects_43 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_43 =\n+am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -360,19 +365,19 @@ am__objects_43 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_44 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_45 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_45 = misc_specifics.lo\n-am__objects_46 = $(am__objects_43) $(am__objects_44) $(am__objects_45) \\\n+am__objects_46 = misc_specifics.lo\n+am__objects_47 = $(am__objects_44) $(am__objects_45) $(am__objects_46) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_47 = $(am__objects_3) $(am__objects_35) $(am__objects_37) \\\n-\t$(am__objects_40) $(am__objects_41) $(am__objects_42) \\\n-\t$(am__objects_46)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_47)\n+am__objects_48 = $(am__objects_3) $(am__objects_36) $(am__objects_38) \\\n+\t$(am__objects_41) $(am__objects_42) $(am__objects_43) \\\n+\t$(am__objects_47)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_48)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -879,6 +884,21 @@ $(srcdir)/generated/matmul_c8.c \\\n $(srcdir)/generated/matmul_c10.c \\\n $(srcdir)/generated/matmul_c16.c\n \n+i_matmulavx128_c = \\\n+$(srcdir)/generated/matmulavx128_i1.c \\\n+$(srcdir)/generated/matmulavx128_i2.c \\\n+$(srcdir)/generated/matmulavx128_i4.c \\\n+$(srcdir)/generated/matmulavx128_i8.c \\\n+$(srcdir)/generated/matmulavx128_i16.c \\\n+$(srcdir)/generated/matmulavx128_r4.c \\\n+$(srcdir)/generated/matmulavx128_r8.c \\\n+$(srcdir)/generated/matmulavx128_r10.c \\\n+$(srcdir)/generated/matmulavx128_r16.c \\\n+$(srcdir)/generated/matmulavx128_c4.c \\\n+$(srcdir)/generated/matmulavx128_c8.c \\\n+$(srcdir)/generated/matmulavx128_c10.c \\\n+$(srcdir)/generated/matmulavx128_c16.c\n+\n i_matmull_c = \\\n $(srcdir)/generated/matmul_l4.c \\\n $(srcdir)/generated/matmul_l8.c \\\n@@ -1059,7 +1079,7 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_iparity_c) $(i_norm2_c) $(i_parity_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n-    $(i_pow_c) $(i_pack_c) $(i_unpack_c) \\\n+    $(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc\n \n@@ -1518,6 +1538,19 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmul_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmul_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmul_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_c8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/matmulavx128_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc0_16_i2.Plo@am__quote@\n@@ -4584,6 +4617,97 @@ unpack_c16.lo: $(srcdir)/generated/unpack_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_c16.lo `test -f '$(srcdir)/generated/unpack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c16.c\n \n+matmulavx128_i1.lo: $(srcdir)/generated/matmulavx128_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_i1.lo -MD -MP -MF $(DEPDIR)/matmulavx128_i1.Tpo -c -o matmulavx128_i1.lo `test -f '$(srcdir)/generated/matmulavx128_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_i1.Tpo $(DEPDIR)/matmulavx128_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_i1.c' object='matmulavx128_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_i1.lo `test -f '$(srcdir)/generated/matmulavx128_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i1.c\n+\n+matmulavx128_i2.lo: $(srcdir)/generated/matmulavx128_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_i2.lo -MD -MP -MF $(DEPDIR)/matmulavx128_i2.Tpo -c -o matmulavx128_i2.lo `test -f '$(srcdir)/generated/matmulavx128_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_i2.Tpo $(DEPDIR)/matmulavx128_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_i2.c' object='matmulavx128_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_i2.lo `test -f '$(srcdir)/generated/matmulavx128_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i2.c\n+\n+matmulavx128_i4.lo: $(srcdir)/generated/matmulavx128_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_i4.lo -MD -MP -MF $(DEPDIR)/matmulavx128_i4.Tpo -c -o matmulavx128_i4.lo `test -f '$(srcdir)/generated/matmulavx128_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_i4.Tpo $(DEPDIR)/matmulavx128_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_i4.c' object='matmulavx128_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_i4.lo `test -f '$(srcdir)/generated/matmulavx128_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i4.c\n+\n+matmulavx128_i8.lo: $(srcdir)/generated/matmulavx128_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_i8.lo -MD -MP -MF $(DEPDIR)/matmulavx128_i8.Tpo -c -o matmulavx128_i8.lo `test -f '$(srcdir)/generated/matmulavx128_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_i8.Tpo $(DEPDIR)/matmulavx128_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_i8.c' object='matmulavx128_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_i8.lo `test -f '$(srcdir)/generated/matmulavx128_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i8.c\n+\n+matmulavx128_i16.lo: $(srcdir)/generated/matmulavx128_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_i16.lo -MD -MP -MF $(DEPDIR)/matmulavx128_i16.Tpo -c -o matmulavx128_i16.lo `test -f '$(srcdir)/generated/matmulavx128_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_i16.Tpo $(DEPDIR)/matmulavx128_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_i16.c' object='matmulavx128_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_i16.lo `test -f '$(srcdir)/generated/matmulavx128_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_i16.c\n+\n+matmulavx128_r4.lo: $(srcdir)/generated/matmulavx128_r4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_r4.lo -MD -MP -MF $(DEPDIR)/matmulavx128_r4.Tpo -c -o matmulavx128_r4.lo `test -f '$(srcdir)/generated/matmulavx128_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_r4.Tpo $(DEPDIR)/matmulavx128_r4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_r4.c' object='matmulavx128_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_r4.lo `test -f '$(srcdir)/generated/matmulavx128_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r4.c\n+\n+matmulavx128_r8.lo: $(srcdir)/generated/matmulavx128_r8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_r8.lo -MD -MP -MF $(DEPDIR)/matmulavx128_r8.Tpo -c -o matmulavx128_r8.lo `test -f '$(srcdir)/generated/matmulavx128_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_r8.Tpo $(DEPDIR)/matmulavx128_r8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_r8.c' object='matmulavx128_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_r8.lo `test -f '$(srcdir)/generated/matmulavx128_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r8.c\n+\n+matmulavx128_r10.lo: $(srcdir)/generated/matmulavx128_r10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_r10.lo -MD -MP -MF $(DEPDIR)/matmulavx128_r10.Tpo -c -o matmulavx128_r10.lo `test -f '$(srcdir)/generated/matmulavx128_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_r10.Tpo $(DEPDIR)/matmulavx128_r10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_r10.c' object='matmulavx128_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_r10.lo `test -f '$(srcdir)/generated/matmulavx128_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r10.c\n+\n+matmulavx128_r16.lo: $(srcdir)/generated/matmulavx128_r16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_r16.lo -MD -MP -MF $(DEPDIR)/matmulavx128_r16.Tpo -c -o matmulavx128_r16.lo `test -f '$(srcdir)/generated/matmulavx128_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_r16.Tpo $(DEPDIR)/matmulavx128_r16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_r16.c' object='matmulavx128_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_r16.lo `test -f '$(srcdir)/generated/matmulavx128_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_r16.c\n+\n+matmulavx128_c4.lo: $(srcdir)/generated/matmulavx128_c4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_c4.lo -MD -MP -MF $(DEPDIR)/matmulavx128_c4.Tpo -c -o matmulavx128_c4.lo `test -f '$(srcdir)/generated/matmulavx128_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_c4.Tpo $(DEPDIR)/matmulavx128_c4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_c4.c' object='matmulavx128_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_c4.lo `test -f '$(srcdir)/generated/matmulavx128_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c4.c\n+\n+matmulavx128_c8.lo: $(srcdir)/generated/matmulavx128_c8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_c8.lo -MD -MP -MF $(DEPDIR)/matmulavx128_c8.Tpo -c -o matmulavx128_c8.lo `test -f '$(srcdir)/generated/matmulavx128_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_c8.Tpo $(DEPDIR)/matmulavx128_c8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_c8.c' object='matmulavx128_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_c8.lo `test -f '$(srcdir)/generated/matmulavx128_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c8.c\n+\n+matmulavx128_c10.lo: $(srcdir)/generated/matmulavx128_c10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_c10.lo -MD -MP -MF $(DEPDIR)/matmulavx128_c10.Tpo -c -o matmulavx128_c10.lo `test -f '$(srcdir)/generated/matmulavx128_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_c10.Tpo $(DEPDIR)/matmulavx128_c10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_c10.c' object='matmulavx128_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_c10.lo `test -f '$(srcdir)/generated/matmulavx128_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c10.c\n+\n+matmulavx128_c16.lo: $(srcdir)/generated/matmulavx128_c16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmulavx128_c16.lo -MD -MP -MF $(DEPDIR)/matmulavx128_c16.Tpo -c -o matmulavx128_c16.lo `test -f '$(srcdir)/generated/matmulavx128_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmulavx128_c16.Tpo $(DEPDIR)/matmulavx128_c16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/matmulavx128_c16.c' object='matmulavx128_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o matmulavx128_c16.lo `test -f '$(srcdir)/generated/matmulavx128_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmulavx128_c16.c\n+\n spread_i1.lo: $(srcdir)/generated/spread_i1.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_i1.lo -MD -MP -MF $(DEPDIR)/spread_i1.Tpo -c -o spread_i1.lo `test -f '$(srcdir)/generated/spread_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i1.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/spread_i1.Tpo $(DEPDIR)/spread_i1.Plo\n@@ -5567,7 +5691,10 @@ uninstall-am: uninstall-cafexeclibLTLIBRARIES \\\n @LIBGFOR_USE_SYMVER_SUN_TRUE@@LIBGFOR_USE_SYMVER_TRUE@\t > $@ || (rm -f $@ ; exit 1)\n \n # Turn on vectorization and loop unrolling for matmul.\n-$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ffast-math -ftree-vectorize -funroll-loops --param max-unroll-times=4 \n+$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ffast-math -ftree-vectorize -funroll-loops --param max-unroll-times=4\n+\n+# Turn on AVX128 for AMD-specific matmul, but only if the compiler understands -mprefer-avx128\n+@HAVE_AVX128_TRUE@$(patsubst %.c,%.lo,$(notdir $(i_matmulavx128_c))): AM_CFLAGS += -ffast-math -ftree-vectorize -funroll-loops --param max-unroll-times=4 -mprefer-avx128\n # Logical matmul doesn't vectorize.\n $(patsubst %.c,%.lo,$(notdir $(i_matmull_c))): AM_CFLAGS += -funroll-loops\n \n@@ -5667,6 +5794,9 @@ fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n @MAINTAINER_MODE_TRUE@$(i_matmul_c): m4/matmul.m4 m4/matmul_internal.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmul.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_matmulavx128_c): m4/matmulavx128.m4 m4/matmul_internal.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmulavx128.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_matmull_c): m4/matmull.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmull.m4 > $@\n "}, {"sha": "cd8dfabffe93a0d995fc28fde3d2858e1616eb56", "filename": "libgfortran/acinclude.m4", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Facinclude.m4?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -452,3 +452,53 @@ AC_DEFUN([LIBGFOR_CHECK_AVX512F], [\n \t[])\n   CFLAGS=\"$ac_save_CFLAGS\"\n ])\n+\n+dnl Check for FMA3\n+dnl\n+AC_DEFUN([LIBGFOR_CHECK_FMA3], [\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mfma -mno-fma4\"\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+\tfloat\n+\tflt_mul_add (float a, float b, float c)\n+\t{\n+\t\treturn __builtin_fmaf (a, b, c);\n+        }]], [[]])],\n+\tAC_DEFINE(HAVE_FMA3, 1,\n+\t[Define if FMA3 instructions can be compiled.]),\n+\t[])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+])\n+\n+dnl Check for FMA4\n+dnl\n+AC_DEFUN([LIBGFOR_CHECK_FMA4], [\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mfma4 -mno-fma\"\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+\tfloat\n+\tflt_mul_add (float a, float b, float c)\n+\t{\n+\t\treturn __builtin_fmaf (a, b, c);\n+        }]], [[]])],\n+\tAC_DEFINE(HAVE_FMA4, 1,\n+\t[Define if FMA4 instructions can be compiled.]),\n+\t[])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+])\n+\n+dnl Check for -mprefer-avx128\n+dnl This also defines an automake conditional.\n+AC_DEFUN([LIBGFOR_CHECK_AVX128], [\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx -mprefer-avx128\"\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+        void foo()\n+\t{\n+        }]], [[]])],\n+\tAC_DEFINE(HAVE_AVX128, 1,\n+\t[Define if -mprefer-avx128 is supported.])\n+\tAM_CONDITIONAL([HAVE_AVX128],true),\n+\t[])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+])"}, {"sha": "0274e5d9c4ca7adcf6b3ee765a9abe0f2714b996", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -81,6 +81,9 @@\n /* Define if AVX instructions can be compiled. */\n #undef HAVE_AVX\n \n+/* Define if -mprefer-avx128 is supported. */\n+#undef HAVE_AVX128\n+\n /* Define if AVX2 instructions can be compiled. */\n #undef HAVE_AVX2\n \n@@ -375,6 +378,12 @@\n /* Define to 1 if you have the `floorl' function. */\n #undef HAVE_FLOORL\n \n+/* Define if FMA3 instructions can be compiled. */\n+#undef HAVE_FMA3\n+\n+/* Define if FMA4 instructions can be compiled. */\n+#undef HAVE_FMA4\n+\n /* Define to 1 if you have the `fmod' function. */\n #undef HAVE_FMOD\n "}, {"sha": "36e015594bac919df8df2cedad6d66d25be179a2", "filename": "libgfortran/configure", "status": "modified", "additions": 101, "deletions": 2, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -606,6 +606,8 @@ am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n get_gcc_base_ver\n+HAVE_AVX128_FALSE\n+HAVE_AVX128_TRUE\n IEEE_FLAGS\n IEEE_SUPPORT\n IEEE_SUPPORT_FALSE\n@@ -12421,7 +12423,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12424 \"configure\"\n+#line 12426 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12527,7 +12529,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12530 \"configure\"\n+#line 12532 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -26363,6 +26365,99 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n   CFLAGS=\"$ac_save_CFLAGS\"\n \n \n+# Check for FMA3 extensions\n+\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mfma -mno-fma4\"\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\tfloat\n+\tflt_mul_add (float a, float b, float c)\n+\t{\n+\t\treturn __builtin_fmaf (a, b, c);\n+        }\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_FMA3 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+\n+\n+# Check for FMA4 extensions\n+\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mfma4 -mno-fma\"\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\tfloat\n+\tflt_mul_add (float a, float b, float c)\n+\t{\n+\t\treturn __builtin_fmaf (a, b, c);\n+        }\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_FMA4 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+\n+\n+# Check if AVX128 works\n+\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx -mprefer-avx128\"\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+        void foo()\n+\t{\n+        }\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_AVX128 1\" >>confdefs.h\n+\n+\t if true; then\n+  HAVE_AVX128_TRUE=\n+  HAVE_AVX128_FALSE='#'\n+else\n+  HAVE_AVX128_TRUE='#'\n+  HAVE_AVX128_FALSE=\n+fi\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+\n+\n # Determine what GCC version number to use in filesystem paths.\n \n   get_gcc_base_ver=\"cat\"\n@@ -26615,6 +26710,10 @@ if test -z \"${IEEE_SUPPORT_TRUE}\" && test -z \"${IEEE_SUPPORT_FALSE}\"; then\n   as_fn_error \"conditional \\\"IEEE_SUPPORT\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_AVX128_TRUE}\" && test -z \"${HAVE_AVX128_FALSE}\"; then\n+  as_fn_error \"conditional \\\"HAVE_AVX128\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n \n : ${CONFIG_STATUS=./config.status}\n ac_write_fail=0"}, {"sha": "78214ac13c8038c81497c804f5ad03bc55b45561", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -624,6 +624,15 @@ LIBGFOR_CHECK_AVX2\n # Check wether we support AVX512f extensions\n LIBGFOR_CHECK_AVX512F\n \n+# Check for FMA3 extensions\n+LIBGFOR_CHECK_FMA3\n+\n+# Check for FMA4 extensions\n+LIBGFOR_CHECK_FMA4\n+\n+# Check if AVX128 works\n+LIBGFOR_CHECK_AVX128\n+\n # Determine what GCC version number to use in filesystem paths.\n GCC_BASE_VER\n "}, {"sha": "54e2714668d5a889ef48a2e60f8b422843fd3453", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_c10_avx512f (gfc_array_c10 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c10_avx128_fma3 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c10_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c10_avx128_fma4 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c10_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_c10_vanilla (gfc_array_c10 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_c10 (gfc_array_c10 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_c10_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_c10_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "cd8aacd9c68ac1cabb8cc5fcd15c243238718c82", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_c16_avx512f (gfc_array_c16 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c16_avx128_fma3 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c16_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c16_avx128_fma4 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c16_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_c16_vanilla (gfc_array_c16 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_c16 (gfc_array_c16 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_c16_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_c16_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "ead22efabb2e3a29b3b6557ad9a63d89cff5fb71", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_c4_avx512f (gfc_array_c4 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c4_avx128_fma3 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c4_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c4_avx128_fma4 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c4_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_c4_vanilla (gfc_array_c4 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_c4 (gfc_array_c4 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_c4_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_c4_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "a52e4bd7f0a387e18f1361ef594b148aa47dda6d", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_c8_avx512f (gfc_array_c8 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c8_avx128_fma3 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c8_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c8_avx128_fma4 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c8_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_c8_vanilla (gfc_array_c8 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_c8 (gfc_array_c8 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_c8_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_c8_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "dfd47e176e4b0fb79209731cf2d678b2a7bb3ba5", "filename": "libgfortran/generated/matmul_i1.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_i1_avx512f (gfc_array_i1 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i1_avx128_fma3 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i1_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i1_avx128_fma4 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i1_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_i1_vanilla (gfc_array_i1 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_i1 (gfc_array_i1 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_i1_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_i1_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "a7bdcb5c67dc43553f5fec5451d5a6a51fbb065d", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_i16_avx512f (gfc_array_i16 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i16_avx128_fma3 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i16_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i16_avx128_fma4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i16_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_i16_vanilla (gfc_array_i16 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_i16 (gfc_array_i16 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_i16_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_i16_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "d541fa3fe737682778d1ce24f20f888a828fd336", "filename": "libgfortran/generated/matmul_i2.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_i2_avx512f (gfc_array_i2 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i2_avx128_fma3 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i2_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i2_avx128_fma4 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i2_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_i2_vanilla (gfc_array_i2 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_i2 (gfc_array_i2 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_i2_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_i2_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "f8f0cdb96cc7ffbd119cfb97b2ae6a84aa434987", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_i4_avx512f (gfc_array_i4 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i4_avx128_fma3 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i4_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i4_avx128_fma4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i4_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_i4_vanilla (gfc_array_i4 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_i4 (gfc_array_i4 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_i4_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_i4_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "2aac1d768223310b4f23ece7d31ea4e1e857657c", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_i8_avx512f (gfc_array_i8 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i8_avx128_fma3 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i8_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i8_avx128_fma4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i8_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_i8_vanilla (gfc_array_i8 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_i8 (gfc_array_i8 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_i8_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_i8_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "448c96bb99f851d3a585c314c3b9feeb5345b8f1", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_r10_avx512f (gfc_array_r10 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r10_avx128_fma3 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r10_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r10_avx128_fma4 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r10_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_r10_vanilla (gfc_array_r10 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_r10 (gfc_array_r10 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_r10_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_r10_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "57a47dcd846537a99dfef3a40c3be78e8afa92b2", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_r16_avx512f (gfc_array_r16 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r16_avx128_fma3 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r16_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r16_avx128_fma4 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r16_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_r16_vanilla (gfc_array_r16 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_r16 (gfc_array_r16 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_r16_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_r16_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "52eea532a9b507ef5bc746385a6c70f84ebee50c", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_r4_avx512f (gfc_array_r4 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r4_avx128_fma3 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r4_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r4_avx128_fma4 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r4_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_r4_vanilla (gfc_array_r4 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_r4 (gfc_array_r4 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_r4_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_r4_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "074697dbf8b69feb9550780733d8664a77896f47", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -1734,6 +1734,24 @@ matmul_r8_avx512f (gfc_array_r8 * const restrict retarray,\n \n #endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r8_avx128_fma3 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r8_avx128_fma3);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r8_avx128_fma4 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r8_avx128_fma4);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n static void\n matmul_r8_vanilla (gfc_array_r8 * const restrict retarray, \n@@ -2332,6 +2350,26 @@ void matmul_r8 (gfc_array_r8 * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_r8_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_r8_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "53cdecbd4e8fc141716fdfa4177aa2a07fa48fb5", "filename": "libgfortran/generated/matmulavx128_c10.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_c10.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_10 *, const GFC_COMPLEX_10 *,\n+                          const int *, const GFC_COMPLEX_10 *, const int *,\n+                          const GFC_COMPLEX_10 *, GFC_COMPLEX_10 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c10_avx128_fma3 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c10_avx128_fma3);\n+void\n+matmul_c10_avx128_fma3 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_10 * restrict abase;\n+  const GFC_COMPLEX_10 * restrict bbase;\n+  GFC_COMPLEX_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_10 *a, *b;\n+      GFC_COMPLEX_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_10 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_10 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_10));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict abase_x;\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 *restrict dest_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c10_avx128_fma4 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c10_avx128_fma4);\n+void\n+matmul_c10_avx128_fma4 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_10 * restrict abase;\n+  const GFC_COMPLEX_10 * restrict bbase;\n+  GFC_COMPLEX_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_10 *a, *b;\n+      GFC_COMPLEX_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_10 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_10 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_10));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict abase_x;\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 *restrict dest_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "e7657a098a54a6632b5cb8de9c43b95ca9b5480d", "filename": "libgfortran/generated/matmulavx128_c16.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_c16.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_16 *, const GFC_COMPLEX_16 *,\n+                          const int *, const GFC_COMPLEX_16 *, const int *,\n+                          const GFC_COMPLEX_16 *, GFC_COMPLEX_16 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c16_avx128_fma3 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c16_avx128_fma3);\n+void\n+matmul_c16_avx128_fma3 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_16 * restrict abase;\n+  const GFC_COMPLEX_16 * restrict bbase;\n+  GFC_COMPLEX_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_16 *a, *b;\n+      GFC_COMPLEX_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_16 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_16 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_16));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict abase_x;\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 *restrict dest_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c16_avx128_fma4 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c16_avx128_fma4);\n+void\n+matmul_c16_avx128_fma4 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_16 * restrict abase;\n+  const GFC_COMPLEX_16 * restrict bbase;\n+  GFC_COMPLEX_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_16 *a, *b;\n+      GFC_COMPLEX_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_16 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_16 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_16));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict abase_x;\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 *restrict dest_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "950f1eb49de54fa40dd77201d387b4143b945bf0", "filename": "libgfortran/generated/matmulavx128_c4.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_c4.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_4 *, const GFC_COMPLEX_4 *,\n+                          const int *, const GFC_COMPLEX_4 *, const int *,\n+                          const GFC_COMPLEX_4 *, GFC_COMPLEX_4 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c4_avx128_fma3 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c4_avx128_fma3);\n+void\n+matmul_c4_avx128_fma3 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_4 * restrict abase;\n+  const GFC_COMPLEX_4 * restrict bbase;\n+  GFC_COMPLEX_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_4 *a, *b;\n+      GFC_COMPLEX_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_4 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_4 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_4));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict abase_x;\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 *restrict dest_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c4_avx128_fma4 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c4_avx128_fma4);\n+void\n+matmul_c4_avx128_fma4 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_4 * restrict abase;\n+  const GFC_COMPLEX_4 * restrict bbase;\n+  GFC_COMPLEX_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_4 *a, *b;\n+      GFC_COMPLEX_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_4 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_4 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_4));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict abase_x;\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 *restrict dest_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "a41c160c99325d37d393819454fdf686bc260bb2", "filename": "libgfortran/generated/matmulavx128_c8.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_c8.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_8 *, const GFC_COMPLEX_8 *,\n+                          const int *, const GFC_COMPLEX_8 *, const int *,\n+                          const GFC_COMPLEX_8 *, GFC_COMPLEX_8 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c8_avx128_fma3 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c8_avx128_fma3);\n+void\n+matmul_c8_avx128_fma3 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_8 * restrict abase;\n+  const GFC_COMPLEX_8 * restrict bbase;\n+  GFC_COMPLEX_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_8 *a, *b;\n+      GFC_COMPLEX_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_8 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_8 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_8));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict abase_x;\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 *restrict dest_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c8_avx128_fma4 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c8_avx128_fma4);\n+void\n+matmul_c8_avx128_fma4 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_8 * restrict abase;\n+  const GFC_COMPLEX_8 * restrict bbase;\n+  GFC_COMPLEX_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_8 *a, *b;\n+      GFC_COMPLEX_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_8 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_8 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_8));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict abase_x;\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 *restrict dest_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "e1871578ea2be58b57d809beff4f4f5d4be3ab9c", "filename": "libgfortran/generated/matmulavx128_i1.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_i1.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_1 *, const GFC_INTEGER_1 *,\n+                          const int *, const GFC_INTEGER_1 *, const int *,\n+                          const GFC_INTEGER_1 *, GFC_INTEGER_1 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i1_avx128_fma3 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i1_avx128_fma3);\n+void\n+matmul_i1_avx128_fma3 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_1 * restrict abase;\n+  const GFC_INTEGER_1 * restrict bbase;\n+  GFC_INTEGER_1 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_1 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_1 *a, *b;\n+      GFC_INTEGER_1 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_1 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_1 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_1));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_1)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_1 *restrict abase_x;\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 *restrict dest_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_1) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_1) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_1 *restrict abase_x;\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 *restrict dest_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i1_avx128_fma4 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i1_avx128_fma4);\n+void\n+matmul_i1_avx128_fma4 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_1 * restrict abase;\n+  const GFC_INTEGER_1 * restrict bbase;\n+  GFC_INTEGER_1 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_1 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_1 *a, *b;\n+      GFC_INTEGER_1 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_1 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_1 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_1));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_1)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_1 *restrict abase_x;\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 *restrict dest_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_1) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_1) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_1 *restrict abase_x;\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 *restrict dest_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "1a7b733181a7c2a631c1605b9f08746841ca343b", "filename": "libgfortran/generated/matmulavx128_i16.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_i16.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_16 *, const GFC_INTEGER_16 *,\n+                          const int *, const GFC_INTEGER_16 *, const int *,\n+                          const GFC_INTEGER_16 *, GFC_INTEGER_16 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i16_avx128_fma3 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i16_avx128_fma3);\n+void\n+matmul_i16_avx128_fma3 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_16 * restrict abase;\n+  const GFC_INTEGER_16 * restrict bbase;\n+  GFC_INTEGER_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_16 *a, *b;\n+      GFC_INTEGER_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_16 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_16 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_16));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_16 *restrict abase_x;\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 *restrict dest_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i16_avx128_fma4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i16_avx128_fma4);\n+void\n+matmul_i16_avx128_fma4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_16 * restrict abase;\n+  const GFC_INTEGER_16 * restrict bbase;\n+  GFC_INTEGER_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_16 *a, *b;\n+      GFC_INTEGER_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_16 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_16 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_16));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_16 *restrict abase_x;\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 *restrict dest_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "a095c5872eb0a038944f181905168738b015c825", "filename": "libgfortran/generated/matmulavx128_i2.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_i2.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_2 *, const GFC_INTEGER_2 *,\n+                          const int *, const GFC_INTEGER_2 *, const int *,\n+                          const GFC_INTEGER_2 *, GFC_INTEGER_2 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i2_avx128_fma3 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i2_avx128_fma3);\n+void\n+matmul_i2_avx128_fma3 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_2 * restrict abase;\n+  const GFC_INTEGER_2 * restrict bbase;\n+  GFC_INTEGER_2 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_2 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_2 *a, *b;\n+      GFC_INTEGER_2 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_2 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_2 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_2));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_2)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_2 *restrict abase_x;\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 *restrict dest_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_2) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_2) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_2 *restrict abase_x;\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 *restrict dest_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i2_avx128_fma4 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i2_avx128_fma4);\n+void\n+matmul_i2_avx128_fma4 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_2 * restrict abase;\n+  const GFC_INTEGER_2 * restrict bbase;\n+  GFC_INTEGER_2 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_2 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_2 *a, *b;\n+      GFC_INTEGER_2 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_2 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_2 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_2));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_2)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_2 *restrict abase_x;\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 *restrict dest_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_2) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_2) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_2 *restrict abase_x;\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 *restrict dest_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "a01c56f71389e0d0cdb3ebe4e1b6f225bde13a3e", "filename": "libgfortran/generated/matmulavx128_i4.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_i4.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_4 *, const GFC_INTEGER_4 *,\n+                          const int *, const GFC_INTEGER_4 *, const int *,\n+                          const GFC_INTEGER_4 *, GFC_INTEGER_4 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i4_avx128_fma3 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i4_avx128_fma3);\n+void\n+matmul_i4_avx128_fma3 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_4 * restrict abase;\n+  const GFC_INTEGER_4 * restrict bbase;\n+  GFC_INTEGER_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_4 *a, *b;\n+      GFC_INTEGER_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_4 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_4 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_4));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_4 *restrict abase_x;\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 *restrict dest_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i4_avx128_fma4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i4_avx128_fma4);\n+void\n+matmul_i4_avx128_fma4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_4 * restrict abase;\n+  const GFC_INTEGER_4 * restrict bbase;\n+  GFC_INTEGER_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_4 *a, *b;\n+      GFC_INTEGER_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_4 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_4 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_4));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_4 *restrict abase_x;\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 *restrict dest_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "bc78ffe27798eb198515380fe316f61b898adf6d", "filename": "libgfortran/generated/matmulavx128_i8.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_i8.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_8 *, const GFC_INTEGER_8 *,\n+                          const int *, const GFC_INTEGER_8 *, const int *,\n+                          const GFC_INTEGER_8 *, GFC_INTEGER_8 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_i8_avx128_fma3 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_i8_avx128_fma3);\n+void\n+matmul_i8_avx128_fma3 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_8 * restrict abase;\n+  const GFC_INTEGER_8 * restrict bbase;\n+  GFC_INTEGER_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_8 *a, *b;\n+      GFC_INTEGER_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_8 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_8 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_8));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_8 *restrict abase_x;\n+\t  const GFC_INTEGER_8 *restrict bbase_y;\n+\t  GFC_INTEGER_8 *restrict dest_y;\n+\t  GFC_INTEGER_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_8 *restrict bbase_y;\n+\t  GFC_INTEGER_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_8 *restrict bbase_y;\n+      GFC_INTEGER_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_8 *restrict abase_x;\n+      const GFC_INTEGER_8 *restrict bbase_y;\n+      GFC_INTEGER_8 *restrict dest_y;\n+      GFC_INTEGER_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_i8_avx128_fma4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_i8_avx128_fma4);\n+void\n+matmul_i8_avx128_fma4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_8 * restrict abase;\n+  const GFC_INTEGER_8 * restrict bbase;\n+  GFC_INTEGER_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_8 *a, *b;\n+      GFC_INTEGER_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_8 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_INTEGER_8 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_INTEGER_8));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_8 *restrict abase_x;\n+\t  const GFC_INTEGER_8 *restrict bbase_y;\n+\t  GFC_INTEGER_8 *restrict dest_y;\n+\t  GFC_INTEGER_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_8 *restrict bbase_y;\n+\t  GFC_INTEGER_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_8 *restrict bbase_y;\n+      GFC_INTEGER_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_8 *restrict abase_x;\n+      const GFC_INTEGER_8 *restrict bbase_y;\n+      GFC_INTEGER_8 *restrict dest_y;\n+      GFC_INTEGER_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "943678d1b51f6cbd00b5ace79821786fd5f09110", "filename": "libgfortran/generated/matmulavx128_r10.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_r10.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_10 *, const GFC_REAL_10 *,\n+                          const int *, const GFC_REAL_10 *, const int *,\n+                          const GFC_REAL_10 *, GFC_REAL_10 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r10_avx128_fma3 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r10_avx128_fma3);\n+void\n+matmul_r10_avx128_fma3 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_10 * restrict abase;\n+  const GFC_REAL_10 * restrict bbase;\n+  GFC_REAL_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_10 *a, *b;\n+      GFC_REAL_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_10 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_10 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_10));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_10 *restrict abase_x;\n+\t  const GFC_REAL_10 *restrict bbase_y;\n+\t  GFC_REAL_10 *restrict dest_y;\n+\t  GFC_REAL_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_10 *restrict bbase_y;\n+\t  GFC_REAL_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_10 *restrict bbase_y;\n+      GFC_REAL_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_10 *restrict abase_x;\n+      const GFC_REAL_10 *restrict bbase_y;\n+      GFC_REAL_10 *restrict dest_y;\n+      GFC_REAL_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r10_avx128_fma4 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r10_avx128_fma4);\n+void\n+matmul_r10_avx128_fma4 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_10 * restrict abase;\n+  const GFC_REAL_10 * restrict bbase;\n+  GFC_REAL_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_10 *a, *b;\n+      GFC_REAL_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_10 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_10 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_10));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_10 *restrict abase_x;\n+\t  const GFC_REAL_10 *restrict bbase_y;\n+\t  GFC_REAL_10 *restrict dest_y;\n+\t  GFC_REAL_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_10 *restrict bbase_y;\n+\t  GFC_REAL_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_10 *restrict bbase_y;\n+      GFC_REAL_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_10 *restrict abase_x;\n+      const GFC_REAL_10 *restrict bbase_y;\n+      GFC_REAL_10 *restrict dest_y;\n+      GFC_REAL_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "3d5738bb6f524c48d0bbe97c40b9779aeb4ac901", "filename": "libgfortran/generated/matmulavx128_r16.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_r16.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_16 *, const GFC_REAL_16 *,\n+                          const int *, const GFC_REAL_16 *, const int *,\n+                          const GFC_REAL_16 *, GFC_REAL_16 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r16_avx128_fma3 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r16_avx128_fma3);\n+void\n+matmul_r16_avx128_fma3 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_16 * restrict abase;\n+  const GFC_REAL_16 * restrict bbase;\n+  GFC_REAL_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_16 *a, *b;\n+      GFC_REAL_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_16 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_16 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_16));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_16 *restrict abase_x;\n+\t  const GFC_REAL_16 *restrict bbase_y;\n+\t  GFC_REAL_16 *restrict dest_y;\n+\t  GFC_REAL_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_16 *restrict bbase_y;\n+\t  GFC_REAL_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_16 *restrict bbase_y;\n+      GFC_REAL_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_16 *restrict abase_x;\n+      const GFC_REAL_16 *restrict bbase_y;\n+      GFC_REAL_16 *restrict dest_y;\n+      GFC_REAL_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r16_avx128_fma4 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r16_avx128_fma4);\n+void\n+matmul_r16_avx128_fma4 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_16 * restrict abase;\n+  const GFC_REAL_16 * restrict bbase;\n+  GFC_REAL_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_16 *a, *b;\n+      GFC_REAL_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_16 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_16 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_16));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_16 *restrict abase_x;\n+\t  const GFC_REAL_16 *restrict bbase_y;\n+\t  GFC_REAL_16 *restrict dest_y;\n+\t  GFC_REAL_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_16 *restrict bbase_y;\n+\t  GFC_REAL_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_16 *restrict bbase_y;\n+      GFC_REAL_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_16 *restrict abase_x;\n+      const GFC_REAL_16 *restrict bbase_y;\n+      GFC_REAL_16 *restrict dest_y;\n+      GFC_REAL_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "6c6da3994c9ddd6e1521792a380f2629abe4475b", "filename": "libgfortran/generated/matmulavx128_r4.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_r4.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_4 *, const GFC_REAL_4 *,\n+                          const int *, const GFC_REAL_4 *, const int *,\n+                          const GFC_REAL_4 *, GFC_REAL_4 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r4_avx128_fma3 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r4_avx128_fma3);\n+void\n+matmul_r4_avx128_fma3 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_4 * restrict abase;\n+  const GFC_REAL_4 * restrict bbase;\n+  GFC_REAL_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_4 *a, *b;\n+      GFC_REAL_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_4 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_4 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_4));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_4 *restrict abase_x;\n+\t  const GFC_REAL_4 *restrict bbase_y;\n+\t  GFC_REAL_4 *restrict dest_y;\n+\t  GFC_REAL_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_4 *restrict bbase_y;\n+\t  GFC_REAL_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_4 *restrict bbase_y;\n+      GFC_REAL_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_4 *restrict abase_x;\n+      const GFC_REAL_4 *restrict bbase_y;\n+      GFC_REAL_4 *restrict dest_y;\n+      GFC_REAL_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r4_avx128_fma4 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r4_avx128_fma4);\n+void\n+matmul_r4_avx128_fma4 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_4 * restrict abase;\n+  const GFC_REAL_4 * restrict bbase;\n+  GFC_REAL_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_4 *a, *b;\n+      GFC_REAL_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_4 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_4 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_4));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_4 *restrict abase_x;\n+\t  const GFC_REAL_4 *restrict bbase_y;\n+\t  GFC_REAL_4 *restrict dest_y;\n+\t  GFC_REAL_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_4 *restrict bbase_y;\n+\t  GFC_REAL_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_4 *restrict bbase_y;\n+      GFC_REAL_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_4 *restrict abase_x;\n+      const GFC_REAL_4 *restrict bbase_y;\n+      GFC_REAL_4 *restrict dest_y;\n+      GFC_REAL_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "d628200e8e3664855ff9bedd95c6af792fdf73e6", "filename": "libgfortran/generated/matmulavx128_r8.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fgenerated%2Fmatmulavx128_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_r8.c?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,1152 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_8 *, const GFC_REAL_8 *,\n+                          const int *, const GFC_REAL_8 *, const int *,\n+                          const GFC_REAL_8 *, GFC_REAL_8 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r8_avx128_fma3 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r8_avx128_fma3);\n+void\n+matmul_r8_avx128_fma3 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_8 * restrict abase;\n+  const GFC_REAL_8 * restrict bbase;\n+  GFC_REAL_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_8 *a, *b;\n+      GFC_REAL_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_8 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_8 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_8));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_8 *restrict abase_x;\n+\t  const GFC_REAL_8 *restrict bbase_y;\n+\t  GFC_REAL_8 *restrict dest_y;\n+\t  GFC_REAL_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_8 *restrict bbase_y;\n+\t  GFC_REAL_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_8 *restrict bbase_y;\n+      GFC_REAL_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_8 *restrict abase_x;\n+      const GFC_REAL_8 *restrict bbase_y;\n+      GFC_REAL_8 *restrict dest_y;\n+      GFC_REAL_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r8_avx128_fma4 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r8_avx128_fma4);\n+void\n+matmul_r8_avx128_fma4 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_8 * restrict abase;\n+  const GFC_REAL_8 * restrict bbase;\n+  GFC_REAL_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_8 *a, *b;\n+      GFC_REAL_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_8 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_8 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim;\n+      t1_dim = (a_dim1-1) * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_8));\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_8 *restrict abase_x;\n+\t  const GFC_REAL_8 *restrict bbase_y;\n+\t  GFC_REAL_8 *restrict dest_y;\n+\t  GFC_REAL_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_8 *restrict bbase_y;\n+\t  GFC_REAL_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_8 *restrict bbase_y;\n+      GFC_REAL_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_REAL_8 *restrict abase_x;\n+      const GFC_REAL_8 *restrict bbase_y;\n+      GFC_REAL_8 *restrict dest_y;\n+      GFC_REAL_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "c2f641542bf3c54485fe2317b591553661b211f6", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -106,6 +106,26 @@ static' include(matmul_internal.m4)dnl\n static' include(matmul_internal.m4)dnl\n `#endif  /* HAVE_AVX512F */\n \n+/* AMD-specifix funtions with AVX128 and FMA3/FMA4.  */\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+'define(`matmul_name',`matmul_'rtype_code`_avx128_fma3')dnl\n+`void\n+'matmul_name` ('rtype` * const restrict retarray, \n+\t'rtype` * const restrict a, 'rtype` * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto('matmul_name`);\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+'define(`matmul_name',`matmul_'rtype_code`_avx128_fma4')dnl\n+`void\n+'matmul_name` ('rtype` * const restrict retarray, \n+\t'rtype` * const restrict a, 'rtype` * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto('matmul_name`);\n+#endif\n+\n /* Function to fall back to if there is no special processor-specific version.  */\n 'define(`matmul_name',`matmul_'rtype_code`_vanilla')dnl\n `static' include(matmul_internal.m4)dnl\n@@ -161,6 +181,26 @@ void matmul_'rtype_code` ('rtype` * const restrict retarray,\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+    else if (__cpu_model.__cpu_vendor == VENDOR_AMD)\n+      {\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t    && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n+\t  {\n+            matmul_fn = matmul_'rtype_code`_avx128_fma3;\n+\t    goto store;\n+\t  }\n+#endif\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+        if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA4)))\n+\t  {\n+            matmul_fn = matmul_'rtype_code`_avx128_fma4;\n+\t    goto store;\n+\t  }\n+#endif\n+\n+      }\n    store:\n       __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }"}, {"sha": "14172843579d708459f9522724ee14994667864d", "filename": "libgfortran/m4/matmulavx128.m4", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fm4%2Fmatmulavx128.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03/libgfortran%2Fm4%2Fmatmulavx128.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmulavx128.m4?ref=1d5cf7fcf28c0b7d44fab10d26fc450e9d962f03", "patch": "@@ -0,0 +1,67 @@\n+`/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>'\n+\n+include(iparm.m4)dnl\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+`#if defined (HAVE_'rtype_name`)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const 'rtype_name` *, const 'rtype_name` *,\n+                          const int *, const 'rtype_name` *, const int *,\n+                          const 'rtype_name` *, 'rtype_name` *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+'define(`matmul_name',`matmul_'rtype_code`_avx128_fma3')dnl\n+`void\n+'matmul_name` ('rtype` * const restrict retarray, \n+\t'rtype` * const restrict a, 'rtype` * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto('matmul_name`);\n+'include(matmul_internal.m4)dnl\n+`#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+'define(`matmul_name',`matmul_'rtype_code`_avx128_fma4')dnl\n+`void\n+'matmul_name` ('rtype` * const restrict retarray, \n+\t'rtype` * const restrict a, 'rtype` * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto('matmul_name`);\n+'include(matmul_internal.m4)dnl\n+`#endif\n+\n+#endif\n+'"}]}