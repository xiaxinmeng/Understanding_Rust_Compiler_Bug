{"sha": "adac3a685da705d6811d4069f57e1bc73a95a957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRhYzNhNjg1ZGE3MDVkNjgxMWQ0MDY5ZjU3ZTFiYzczYTk1YTk1Nw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-06-18T18:49:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-06-18T18:49:40Z"}, "message": "Introduce DUMP_VECT_SCOPE macro\n\ngcc/ChangeLog:\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):\n\tReplace dump_printf_loc call with DUMP_VECT_SCOPE.\n\t(vect_slp_analyze_instance_dependence): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_analyze_data_refs_alignment): Likewise.\n\t(vect_slp_analyze_and_verify_instance_alignment\n\t(vect_analyze_data_ref_accesses): Likewise.\n\t(vect_prune_runtime_alias_test_list): Likewise.\n\t(vect_analyze_data_refs): Likewise.\n\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): Likewise.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n\t(vect_analyze_scalar_cycles_1): Likewise.\n\t(vect_get_loop_niters): Likewise.\n\t(vect_analyze_loop_form_1): Likewise.\n\t(vect_update_vf_for_slp): Likewise.\n\t(vect_analyze_loop_operations): Likewise.\n\t(vect_analyze_loop): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(vect_transform_loop): Likewise.\n\t* tree-vect-patterns.c (vect_pattern_recog): Likewise.\n\t* tree-vect-slp.c (vect_analyze_slp): Likewise.\n\t(vect_make_slp_decision): Likewise.\n\t(vect_detect_hybrid_slp): Likewise.\n\t(vect_slp_analyze_operations): Likewise.\n\t(vect_slp_bb): Likewise.\n\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Likewise.\n\t(vectorizable_bswap): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_simd_clone_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t* tree-vectorizer.h (DUMP_VECT_SCOPE): New macro.\n\nFrom-SVN: r261710", "tree": {"sha": "f879862d9680331773611f82a26598111371d459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f879862d9680331773611f82a26598111371d459"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adac3a685da705d6811d4069f57e1bc73a95a957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adac3a685da705d6811d4069f57e1bc73a95a957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adac3a685da705d6811d4069f57e1bc73a95a957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adac3a685da705d6811d4069f57e1bc73a95a957/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d4d0be8132cb837ce075e28f14d7ef8dcc02767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d4d0be8132cb837ce075e28f14d7ef8dcc02767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d4d0be8132cb837ce075e28f14d7ef8dcc02767"}], "stats": {"total": 176, "additions": 80, "deletions": 96}, "files": [{"sha": "914e075afce1b136541e028a8b8e9a15d920e7d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -1,3 +1,40 @@\n+2018-06-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):\n+\tReplace dump_printf_loc call with DUMP_VECT_SCOPE.\n+\t(vect_slp_analyze_instance_dependence): Likewise.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_analyze_data_refs_alignment): Likewise.\n+\t(vect_slp_analyze_and_verify_instance_alignment\n+\t(vect_analyze_data_ref_accesses): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Likewise.\n+\t(vect_analyze_data_refs): Likewise.\n+\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): Likewise.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n+\t(vect_analyze_scalar_cycles_1): Likewise.\n+\t(vect_get_loop_niters): Likewise.\n+\t(vect_analyze_loop_form_1): Likewise.\n+\t(vect_update_vf_for_slp): Likewise.\n+\t(vect_analyze_loop_operations): Likewise.\n+\t(vect_analyze_loop): Likewise.\n+\t(vectorizable_induction): Likewise.\n+\t(vect_transform_loop): Likewise.\n+\t* tree-vect-patterns.c (vect_pattern_recog): Likewise.\n+\t* tree-vect-slp.c (vect_analyze_slp): Likewise.\n+\t(vect_make_slp_decision): Likewise.\n+\t(vect_detect_hybrid_slp): Likewise.\n+\t(vect_slp_analyze_operations): Likewise.\n+\t(vect_slp_bb): Likewise.\n+\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Likewise.\n+\t(vectorizable_bswap): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_simd_clone_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t* tree-vectorizer.h (DUMP_VECT_SCOPE): New macro.\n+\n 2018-06-18  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/81384"}, {"sha": "3e66e25e9cf56b42cfbae4f0ff3bcc6da63fd0f3", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -562,9 +562,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n   unsigned int i;\n   struct data_dependence_relation *ddr;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_data_ref_dependences ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_data_ref_dependences\");\n \n   LOOP_VINFO_DDRS (loop_vinfo)\n     .create (LOOP_VINFO_DATAREFS (loop_vinfo).length ()\n@@ -741,9 +739,7 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n bool\n vect_slp_analyze_instance_dependence (slp_instance instance)\n {\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_slp_analyze_instance_dependence ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_slp_analyze_instance_dependence\");\n \n   /* The stores of this instance are at the root of the SLP tree.  */\n   slp_tree store = SLP_INSTANCE_TREE (instance);\n@@ -1685,9 +1681,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned int mis, same_align_drs_max = 0;\n   hash_table<peel_info_hasher> peeling_htab (1);\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_enhance_data_refs_alignment ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_enhance_data_refs_alignment\");\n \n   /* Reset data so we can safely be called multiple times.  */\n   LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).truncate (0);\n@@ -2345,9 +2339,7 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr)\n bool\n vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n {\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_data_refs_alignment ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_data_refs_alignment\");\n \n   /* Mark groups of data references with same alignment using\n      data dependence information.  */\n@@ -2426,9 +2418,7 @@ vect_slp_analyze_and_verify_node_alignment (slp_tree node)\n bool\n vect_slp_analyze_and_verify_instance_alignment (slp_instance instance)\n {\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_slp_analyze_and_verify_instance_alignment ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_slp_analyze_and_verify_instance_alignment\");\n \n   slp_tree node;\n   unsigned i;\n@@ -2931,9 +2921,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n   vec<data_reference_p> datarefs = vinfo->datarefs;\n   struct data_reference *dr;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_data_ref_accesses ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_data_ref_accesses\");\n \n   if (datarefs.is_empty ())\n     return true;\n@@ -3379,9 +3367,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   unsigned int i;\n   tree length_factor;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_prune_runtime_alias_test_list ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_prune_runtime_alias_test_list\");\n \n   /* Step values are irrelevant for aliasing if the number of vector\n      iterations is equal to the number of scalar iterations (which can\n@@ -4075,9 +4061,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n   struct data_reference *dr;\n   tree scalar_type;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_analyze_data_refs ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_data_refs\");\n \n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     loop = LOOP_VINFO_LOOP (loop_vinfo);"}, {"sha": "3eab650c4e6e3c6de173f6081b5db04aa21478b2", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -1733,9 +1733,7 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_update_inits_of_dr ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_update_inits_of_dr\");\n \n   /* Adjust niters to sizetype and insert stmts on loop preheader edge.  */\n   if (!types_compatible_p (sizetype, TREE_TYPE (niters)))"}, {"sha": "8e45aecfc761512d1fe333370b9383442cfb1c76", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 29, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -296,9 +296,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   unsigned i;\n   auto_vec<stmt_vec_info> mask_producers;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_determine_vectorization_factor ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_determine_vectorization_factor\");\n \n   for (i = 0; i < nbbs; i++)\n     {\n@@ -479,9 +477,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n   gphi_iterator gsi;\n   bool double_reduc;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_scalar_cycles ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_scalar_cycles\");\n \n   /* First - identify all inductions.  Reduction detection assumes that all the\n      inductions have been identified, therefore, this order must not be\n@@ -727,9 +723,7 @@ vect_get_loop_niters (struct loop *loop, tree *assumptions,\n   *assumptions = boolean_true_node;\n   *number_of_iterationsm1 = chrec_dont_know;\n   *number_of_iterations = chrec_dont_know;\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== get_loop_niters ===\\n\");\n+  DUMP_VECT_SCOPE (\"get_loop_niters\");\n \n   if (!exit)\n     return cond;\n@@ -1170,9 +1164,7 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n \t\t\t  tree *assumptions, tree *number_of_iterationsm1,\n \t\t\t  tree *number_of_iterations, gcond **inner_loop_cond)\n {\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_analyze_loop_form ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_loop_form\");\n \n   /* Different restrictions apply when we are considering an inner-most loop,\n      vs. an outer (nested) loop.\n@@ -1422,9 +1414,7 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n   poly_uint64 vectorization_factor;\n   int i;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_update_vf_for_slp ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_update_vf_for_slp\");\n \n   vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   gcc_assert (known_ne (vectorization_factor, 0U));\n@@ -1527,9 +1517,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n   bool need_to_vectorize = false;\n   bool ok;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_analyze_loop_operations ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_loop_operations\");\n \n   stmt_vector_for_cost cost_vec;\n   cost_vec.create (2);\n@@ -2308,9 +2296,7 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n   targetm.vectorize.autovectorize_vector_sizes (&vector_sizes);\n   unsigned int next_size = 0;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"===== analyze_loop_nest =====\\n\");\n+  DUMP_VECT_SCOPE (\"analyze_loop_nest\");\n \n   if (loop_outer (loop)\n       && loop_vec_info_for_loop (loop_outer (loop))\n@@ -7460,9 +7446,7 @@ vectorizable_induction (gimple *phi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_induction ===\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_induction\");\n       vect_model_induction_cost (stmt_info, ncopies, cost_vec);\n       return true;\n     }\n@@ -8335,8 +8319,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   bool check_profitability = false;\n   unsigned int th;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vec_transform_loop ===\\n\");\n+  DUMP_VECT_SCOPE (\"vec_transform_loop\");\n \n   /* Use the more conservative vectorization threshold.  If the number\n      of iterations is constant assume the cost check has been performed\n@@ -8618,9 +8601,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t{\n \t\t  slp_scheduled = true;\n \n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t     \"=== scheduling SLP instances ===\\n\");\n+\t\t  DUMP_VECT_SCOPE (\"scheduling SLP instances\");\n \n \t\t  vect_schedule_slp (loop_vinfo);\n \t\t}"}, {"sha": "c530810aa3e5a92c19453c494a2db8d1c15aeefd", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -4670,9 +4670,7 @@ vect_pattern_recog (vec_info *vinfo)\n   auto_vec<gimple *, 1> stmts_to_replace;\n   gimple *stmt;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_pattern_recog ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_pattern_recog\");\n \n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     {"}, {"sha": "74abf5f552367de3c68f9ab814e67a31e3ef1900", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -2177,8 +2177,7 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n   unsigned int i;\n   gimple *first_element;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_analyze_slp ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_analyze_slp\");\n \n   /* Find SLP sequences starting from groups of grouped stores.  */\n   FOR_EACH_VEC_ELT (vinfo->grouped_stores, i, first_element)\n@@ -2231,9 +2230,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   slp_instance instance;\n   int decided_to_slp = 0;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_make_slp_decision ===\"\n-                     \"\\n\");\n+  DUMP_VECT_SCOPE (\"vect_make_slp_decision\");\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n@@ -2399,9 +2396,7 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n   vec<slp_instance> slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   slp_instance instance;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_detect_hybrid_slp ===\"\n-                     \"\\n\");\n+  DUMP_VECT_SCOPE (\"vect_detect_hybrid_slp\");\n \n   /* First walk all pattern stmt in the loop and mark defs of uses as\n      hybrid because immediate uses in them are not recorded.  */\n@@ -2622,9 +2617,7 @@ vect_slp_analyze_operations (vec_info *vinfo)\n   slp_instance instance;\n   int i;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_slp_analyze_operations ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_slp_analyze_operations\");\n \n   scalar_stmts_to_slp_tree_map_t *visited\n     = new scalar_stmts_to_slp_tree_map_t ();\n@@ -2981,8 +2974,7 @@ vect_slp_bb (basic_block bb)\n   bool any_vectorized = false;\n   auto_vector_sizes vector_sizes;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"===vect_slp_analyze_bb===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_slp_analyze_bb\");\n \n   /* Autodetect first vector size we try.  */\n   current_vector_size = 0;"}, {"sha": "f2f91df935ce86a95889fc991f42c104f2d1c639", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -640,9 +640,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   bool live_p;\n   enum vect_relevant relevant;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_mark_stmts_to_be_vectorized ===\\n\");\n+  DUMP_VECT_SCOPE (\"vect_mark_stmts_to_be_vectorized\");\n \n   auto_vec<gimple *, 64> worklist;\n \n@@ -3027,9 +3025,7 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (! vec_stmt)\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_bswap ===\"\n-                         \"\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_bswap\");\n       if (! slp_node)\n \t{\n \t  record_stmt_cost (cost_vec,\n@@ -3346,9 +3342,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\"\n-                         \"\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_call\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n       if (ifn != IFN_LAST && modifier == NARROW && !slp_node)\n \trecord_stmt_cost (cost_vec, ncopies / 2,\n@@ -4023,9 +4017,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_push (sll);\n \t  }\n       STMT_VINFO_TYPE (stmt_info) = call_simd_clone_vec_info_type;\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"=== vectorizable_simd_clone_call ===\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_simd_clone_call\");\n /*      vect_model_simple_cost (stmt_info, ncopies, dt, slp_node, cost_vec); */\n       return true;\n     }\n@@ -4865,9 +4857,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt)\t\t/* transformation not required.  */\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_conversion ===\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_conversion\");\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n         {\n \t  STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n@@ -5279,9 +5269,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_assignment ===\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_assignment\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n       return true;\n     }\n@@ -5644,9 +5632,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = shift_vec_info_type;\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_shift ===\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_shift\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n       return true;\n     }\n@@ -5968,9 +5954,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_operation ===\\n\");\n+      DUMP_VECT_SCOPE (\"vectorizable_operation\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n       return true;\n     }"}, {"sha": "8bb9e3e6e8896c2538105d443941ab76589d3ffd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adac3a685da705d6811d4069f57e1bc73a95a957/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=adac3a685da705d6811d4069f57e1bc73a95a957", "patch": "@@ -1425,6 +1425,16 @@ vect_get_scalar_dr_size (struct data_reference *dr)\n /* Source location */\n extern source_location vect_location;\n \n+/* If dumping is enabled, emit a MSG_NOTE at vect_location about\n+   entering MSG within the vectorizer.  MSG should be a string literal. */\n+\n+#define DUMP_VECT_SCOPE(MSG) \\\n+  do {\t\t\t\t\t\t\\\n+    if (dump_enabled_p ())\t\t\t\\\n+      dump_printf_loc (MSG_NOTE, vect_location, \\\n+\t\t       \"=== \" MSG \" ===\\n\");\t\\\n+  } while (0)\n+\n /*-----------------------------------------------------------------*/\n /* Function prototypes.                                            */\n /*-----------------------------------------------------------------*/"}]}