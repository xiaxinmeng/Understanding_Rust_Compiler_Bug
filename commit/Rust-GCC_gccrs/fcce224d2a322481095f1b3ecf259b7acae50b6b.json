{"sha": "fcce224d2a322481095f1b3ecf259b7acae50b6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNjZTIyNGQyYTMyMjQ4MTA5NWYxYjNlY2YyNTliN2FjYWU1MGI2Yg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2002-10-07T19:12:04Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2002-10-07T19:12:04Z"}, "message": "rs6000.c (rs6000_override_options): Set real_format_for_mode for IBM extended format, if enabled.\n\n        * config/rs6000/rs6000.c (rs6000_override_options): Set\n        real_format_for_mode for IBM extended format, if enabled.\n        (easy_fp_constant): Add TFmode.\n        (rs6000_legitimize_address): Add TFmode.\n        (rs6000_legitimate_address): Same.\n        (function_arg_advance): TFmode uses two FPRs.\n        (rs6000_emit_prologue): Fix warning.\n        (rs6000_output_function_epilogue): Add TFmode.\n        (output_toc): Add TFmode.\n        * rs6000.h (SLOW_UNALIGNED_ACCESS): Add TFmode.\n        (LEGITIMATE_OFFSET_ADDRESS_P): Add TFmode.\n        * rs6000.md (movtf splitter): Load TFmode constant.\n\nFrom-SVN: r57904", "tree": {"sha": "f45c997e7d1a4d62438c9f24145dbaaca8d687a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f45c997e7d1a4d62438c9f24145dbaaca8d687a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcce224d2a322481095f1b3ecf259b7acae50b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcce224d2a322481095f1b3ecf259b7acae50b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcce224d2a322481095f1b3ecf259b7acae50b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcce224d2a322481095f1b3ecf259b7acae50b6b/comments", "author": null, "committer": null, "parents": [{"sha": "ba43f4ebc40955029d75d4afd09466106b674437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba43f4ebc40955029d75d4afd09466106b674437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba43f4ebc40955029d75d4afd09466106b674437"}], "stats": {"total": 152, "additions": 133, "deletions": 19}, "files": [{"sha": "558eaa7506cf4d0cfb3a048c27984125854cbd18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcce224d2a322481095f1b3ecf259b7acae50b6b", "patch": "@@ -1,4 +1,20 @@\n+2002-10-07  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.c (rs6000_override_options): Set\n+\treal_format_for_mode for IBM extended format, if enabled.\n+\t(easy_fp_constant): Add TFmode.\n+\t(rs6000_legitimize_address): Add TFmode.\n+\t(rs6000_legitimate_address): Same.\n+\t(function_arg_advance): TFmode uses two FPRs.\n+\t(rs6000_emit_prologue): Fix warning.\n+\t(rs6000_output_function_epilogue): Add TFmode.\n+\t(output_toc): Add TFmode.\n+\t* rs6000.h (SLOW_UNALIGNED_ACCESS): Add TFmode.\n+\t(LEGITIMATE_OFFSET_ADDRESS_P): Add TFmode.\n+\t* rs6000.md (movtf splitter): Load TFmode constant.\n+\n 2002-10-07  Dale Johannesen  <dalej@apple.com>\n+\n \t* rtl.h:  Add NOTE_PRECONDITIONED.\n \t* unroll.c:  Set it.\n \t* loop.c:  Set loop_info->preconditioned from it."}, {"sha": "53b7a9b5e3c936f2986f180d3ef21630fd171a8f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fcce224d2a322481095f1b3ecf259b7acae50b6b", "patch": "@@ -683,6 +683,10 @@ rs6000_override_options (default_cpu)\n \ttarget_flags |= MASK_AIX_STRUCT_RET;\n     }\n \n+  if (TARGET_LONG_DOUBLE_128\n+      && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN))\n+    real_format_for_mode[TFmode - QFmode] = &ibm_extended_format;\n+\n   /* Register global variables with the garbage collector.  */\n   rs6000_add_gc_roots ();\n \n@@ -1306,7 +1310,21 @@ easy_fp_constant (op, mode)\n     return 0;\n #endif\n \n-  if (mode == DFmode)\n+  if (mode == TFmode)\n+    {\n+      long k[4];\n+      REAL_VALUE_TYPE rv;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n+\n+      return (num_insns_constant_wide ((HOST_WIDE_INT) k[0]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[2]) == 1\n+\t      && num_insns_constant_wide ((HOST_WIDE_INT) k[3]) == 1);\n+    }\n+\n+  else if (mode == DFmode)\n     {\n       long k[2];\n       REAL_VALUE_TYPE rv;\n@@ -2095,7 +2113,7 @@ rs6000_legitimize_address (x, oldx, mode)\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t       || TARGET_POWERPC64\n-\t       || mode != DFmode)\n+\t       || (mode != DFmode && mode != TFmode))\n \t   && (TARGET_POWERPC64 || mode != DImode)\n \t   && mode != TImode)\n     {\n@@ -2348,7 +2366,7 @@ rs6000_legitimate_address (mode, x, reg_ok_strict)\n   if (mode != TImode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t  || TARGET_POWERPC64\n-\t  || mode != DFmode)\n+\t  || (mode != DFmode && mode != TFmode))\n       && (TARGET_POWERPC64 || mode != DImode)\n       && LEGITIMATE_INDEXED_ADDRESS_P (x, reg_ok_strict))\n     return 1;\n@@ -3026,7 +3044,7 @@ function_arg_advance (cum, mode, type, named)\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n-\tcum->fregno++;\n+\tcum->fregno += (mode == TFmode ? 2 : 1);\n \n       if (TARGET_DEBUG_ARG)\n \t{\n@@ -10453,21 +10471,21 @@ rs6000_emit_prologue ()\n \t\t      gen_rtx_REG (Pmode, 11));\n   }\n \n+#if TARGET_MACHO\n   if (DEFAULT_ABI == ABI_DARWIN\n       && flag_pic && current_function_uses_pic_offset_table)\n     {\n       rtx dest = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n-#if TARGET_MACHO\n       char *picbase = machopic_function_base_name ();\n       rtx src = gen_rtx_SYMBOL_REF (Pmode, ggc_alloc_string (picbase, -1));\n \n       rs6000_maybe_dead (emit_insn (gen_load_macho_picbase (dest, src)));\n-#endif\n \n       rs6000_maybe_dead (\n \temit_move_insn (gen_rtx_REG (Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM),\n \t\t\tgen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)));\n     }\n+#endif\n }\n \n /* Write function prologue.  */\n@@ -11085,7 +11103,7 @@ rs6000_output_function_epilogue (file, size)\n \n \t\t      if (mode == SFmode)\n \t\t\tbits = 0x2;\n-\t\t      else if (mode == DFmode)\n+\t\t      else if (mode == DFmode || mode == TFmode)\n \t\t\tbits = 0x3;\n \t\t      else\n \t\t\tabort ();\n@@ -11639,7 +11657,42 @@ output_toc (file, x, labelno, mode)\n   /* Handle FP constants specially.  Note that if we have a minimal\n      TOC, things we put here aren't actually in the TOC, so we can allow\n      FP constants.  */\n-  if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+  if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == TFmode)\n+    {\n+      REAL_VALUE_TYPE rv;\n+      long k[4];\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n+\n+      if (TARGET_64BIT)\n+\t{\n+\t  if (TARGET_MINIMAL_TOC)\n+\t    fputs (DOUBLE_INT_ASM_OP, file);\n+\t  else\n+\t    fprintf (file, \"\\t.tc FT_%lx_%lx_%lx_%lx[TC],\",\n+\t\t     k[0] & 0xffffffff, k[1] & 0xffffffff,\n+\t\t     k[2] & 0xffffffff, k[3] & 0xffffffff);\n+\t  fprintf (file, \"0x%lx%08lx,0x%lx%08lx\\n\",\n+\t\t   k[0] & 0xffffffff, k[1] & 0xffffffff,\n+\t\t   k[2] & 0xffffffff, k[3] & 0xffffffff);\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_MINIMAL_TOC)\n+\t    fputs (\"\\t.long \", file);\n+\t  else\n+\t    fprintf (file, \"\\t.tc FT_%lx_%lx_%lx_%lx[TC],\",\n+\t\t     k[0] & 0xffffffff, k[1] & 0xffffffff,\n+\t\t     k[2] & 0xffffffff, k[3] & 0xffffffff);\n+\t  fprintf (file, \"0x%lx,0x%lx,0x%lx,0x%lx\\n\",\n+\t\t   k[0] & 0xffffffff, k[1] & 0xffffffff,\n+\t\t   k[2] & 0xffffffff, k[3] & 0xffffffff);\n+\t  return;\n+\t}\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n     {\n       REAL_VALUE_TYPE rv;\n       long k[2];"}, {"sha": "7f4139be88d0803302b261a595cbc7878e524c8b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=fcce224d2a322481095f1b3ecf259b7acae50b6b", "patch": "@@ -660,7 +660,8 @@ extern int rs6000_default_long_calls;\n    emulated in a trap handler.  */\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN)\t\t\t\t\\\n   (STRICT_ALIGNMENT\t\t\t\t\t\t\t\\\n-   || (((MODE) == SFmode || (MODE) == DFmode || (MODE) == DImode)\t\\\n+   || (((MODE) == SFmode || (MODE) == DFmode || (MODE) == TFmode\t\\\n+\t|| (MODE) == DImode)\t\t\t\t\t\t\\\n        && (ALIGN) < 32))\n \f\n /* Standard register usage.  */\n@@ -2073,7 +2074,7 @@ typedef struct rs6000_args\n       || (TARGET_32BIT\t\t\t\t\t\t\\\n \t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4) \t\\\n \t  : ! (INTVAL (XEXP (X, 1)) & 3)))\t\t\t\\\n-  && ((MODE) != TImode\t\t\t\t\t\t\\\n+  && (((MODE) != TFmode && (MODE) != TImode)\t\t\t\\\n       || (TARGET_32BIT\t\t\t\t\t\t\\\n \t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 12) \t\\\n \t  : (LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 8) \t\\"}, {"sha": "13adeca14b0787eaa162e1396921a7aa5d609f87", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcce224d2a322481095f1b3ecf259b7acae50b6b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=fcce224d2a322481095f1b3ecf259b7acae50b6b", "patch": "@@ -3615,7 +3615,7 @@\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n-\f\n+\n (define_split\n   [(set (match_operand:CC 4 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC\n@@ -3635,7 +3635,7 @@\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n-\n+\f\n ;; Rotate and shift insns, in all their variants.  These support shifts,\n ;; field inserts and extracts, and various combinations thereof.\n (define_expand \"insv\"\n@@ -8744,15 +8744,59 @@\n (define_split\n   [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:TF 1 \"const_double_operand\" \"\"))]\n-  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_FPRS\n-   && TARGET_LONG_DOUBLE_128\"\n-  [(set (match_dup 3) (match_dup 1))\n-   (set (match_dup 0)\n-\t(float_extend:TF (match_dup 3)))]\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n+   && TARGET_HARD_FLOAT && TARGET_FPRS && ! TARGET_POWERPC64\n+   && TARGET_LONG_DOUBLE_128 && reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (match_dup 6))\n+   (set (match_dup 3) (match_dup 7))\n+   (set (match_dup 4) (match_dup 8))\n+   (set (match_dup 5) (match_dup 9))]\n+  \"\n+{\n+  long l[4];\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, l);\n+\n+  operands[2] = operand_subword (operands[0], 0, 0, TFmode);\n+  operands[3] = operand_subword (operands[0], 1, 0, TFmode);\n+  operands[4] = operand_subword (operands[0], 2, 0, TFmode);\n+  operands[5] = operand_subword (operands[0], 3, 0, TFmode);\n+  operands[6] = gen_int_mode (l[0], SImode);\n+  operands[7] = gen_int_mode (l[1], SImode);\n+  operands[8] = gen_int_mode (l[2], SImode);\n+  operands[9] = gen_int_mode (l[3], SImode);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:TF 1 \"easy_fp_constant\" \"\"))]\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n+   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64\n+   && TARGET_LONG_DOUBLE_128 && reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n   \"\n {\n-  operands[2] = operand_subword (operands[1], 0, 0, DFmode);\n-  operands[3] = gen_reg_rtx (DFmode);\n+  long l[4];\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, l);\n+\n+  operands[2] = operand_subword (operands[0], 0, 0, TFmode);\n+  operands[3] = operand_subword (operands[0], 1, 0, TFmode);\n+  operands[4] = gen_int_mode (l[0], DImode);\n+  operands[5] = gen_int_mode (l[1], DImode);\n }\")\n \n (define_insn_and_split \"extenddftf2\""}]}