{"sha": "6a184afa5830e6caccbcc3ef9e4f39d52a095901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExODRhZmE1ODMwZTZjYWNjYmNjM2VmOWU0ZjM5ZDUyYTA5NTkwMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-04-13T15:55:52Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-04-13T15:55:52Z"}, "message": "re PR debug/51570 (FAIL: gcc.dg/guality/pr45003-[23].c)\n\nPR debug/51570\n* var-tracking.c (expand_depth): New type.\n(onepart_aux, expand_loc_callback_data): Change depth type to it.\n(loc_exp_dep_alloc): Adjust initializer.\n(update_depth): Use new type.  Add entryvals.\n(vt_expand_var_loc_chain): Take note of expansions with\nENTRY_VALUEs, but don't accept them right away.  Run an optional\nsecond pass accepting the minimum ENTRY_VALUE count found in the\nfirst pass.\n(vt_expand_loc_callback, INIT_ELCD): Adjust.\n\nFrom-SVN: r186420", "tree": {"sha": "eb26e7096120704d9b8b7d8c18d412e029db4cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb26e7096120704d9b8b7d8c18d412e029db4cf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a184afa5830e6caccbcc3ef9e4f39d52a095901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a184afa5830e6caccbcc3ef9e4f39d52a095901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a184afa5830e6caccbcc3ef9e4f39d52a095901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a184afa5830e6caccbcc3ef9e4f39d52a095901/comments", "author": null, "committer": null, "parents": [{"sha": "f164e49a3fff54c54055b3be88db64f2ee411a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f164e49a3fff54c54055b3be88db64f2ee411a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f164e49a3fff54c54055b3be88db64f2ee411a26"}], "stats": {"total": 99, "additions": 80, "deletions": 19}, "files": [{"sha": "1559b9af7d577f92699a6fdab29d7e0726f6399d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a184afa5830e6caccbcc3ef9e4f39d52a095901/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a184afa5830e6caccbcc3ef9e4f39d52a095901/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a184afa5830e6caccbcc3ef9e4f39d52a095901", "patch": "@@ -1,3 +1,16 @@\n+2012-04-13  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/51570\n+\t* var-tracking.c (expand_depth): New type.\n+\t(onepart_aux, expand_loc_callback_data): Change depth type to it.\n+\t(loc_exp_dep_alloc): Adjust initializer.\n+\t(update_depth): Use new type.  Add entryvals.\n+\t(vt_expand_var_loc_chain): Take note of expansions with\n+\tENTRY_VALUEs, but don't accept them right away.  Run an optional\n+\tsecond pass accepting the minimum ENTRY_VALUE count found in the\n+\tfirst pass.\n+\t(vt_expand_loc_callback, INIT_ELCD): Adjust.\n+\n 2012-04-13  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-tail-merge.c (gsi_advance_bw_nondebug_nonlocal): Add"}, {"sha": "c3fe428ab90288f2dcd416a6164b9bb4f8a0425e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 67, "deletions": 19, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a184afa5830e6caccbcc3ef9e4f39d52a095901/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a184afa5830e6caccbcc3ef9e4f39d52a095901/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=6a184afa5830e6caccbcc3ef9e4f39d52a095901", "patch": "@@ -320,6 +320,19 @@ typedef struct loc_exp_dep_s\n \n DEF_VEC_O (loc_exp_dep);\n \n+/* This data structure holds information about the depth of a variable\n+   expansion.  */\n+typedef struct expand_depth_struct\n+{\n+  /* This measures the complexity of the expanded expression.  It\n+     grows by one for each level of expansion that adds more than one\n+     operand.  */\n+  int complexity;\n+  /* This counts the number of ENTRY_VALUE expressions in an\n+     expansion.  We want to minimize their use.  */\n+  int entryvals;\n+} expand_depth;\n+\n /* This data structure is allocated for one-part variables at the time\n    of emitting notes.  */\n struct onepart_aux\n@@ -338,7 +351,7 @@ struct onepart_aux\n      a change notification from any of its active dependencies.  */\n   rtx from;\n   /* The depth of the cur_loc expression.  */\n-  int depth;\n+  expand_depth depth;\n   /* Dependencies actively used when expand FROM into cur_loc.  */\n   VEC (loc_exp_dep, none) deps;\n };\n@@ -7491,7 +7504,7 @@ struct expand_loc_callback_data\n \n   /* The maximum depth among the sub-expressions under expansion.\n      Zero indicates no expansion so far.  */\n-  int depth;\n+  expand_depth depth;\n };\n \n /* Allocate the one-part auxiliary data structure for VAR, with enough\n@@ -7536,7 +7549,8 @@ loc_exp_dep_alloc (variable var, int count)\n       VAR_LOC_1PAUX (var) = XNEWVAR (struct onepart_aux, allocsize);\n       *VAR_LOC_DEP_LSTP (var) = NULL;\n       VAR_LOC_FROM (var) = NULL;\n-      VAR_LOC_DEPTH (var) = 0;\n+      VAR_LOC_DEPTH (var).complexity = 0;\n+      VAR_LOC_DEPTH (var).entryvals = 0;\n     }\n   VEC_embedded_init (loc_exp_dep, VAR_LOC_DEP_VEC (var), count);\n }\n@@ -7691,21 +7705,26 @@ static rtx vt_expand_loc_callback (rtx x, bitmap regs,\n /* Return the combined depth, when one sub-expression evaluated to\n    BEST_DEPTH and the previous known depth was SAVED_DEPTH.  */\n \n-static inline int\n-update_depth (int saved_depth, int best_depth)\n+static inline expand_depth\n+update_depth (expand_depth saved_depth, expand_depth best_depth)\n {\n   /* If we didn't find anything, stick with what we had.  */\n-  if (!best_depth)\n+  if (!best_depth.complexity)\n     return saved_depth;\n \n   /* If we found hadn't found anything, use the depth of the current\n      expression.  Do NOT add one extra level, we want to compute the\n      maximum depth among sub-expressions.  We'll increment it later,\n      if appropriate.  */\n-  if (!saved_depth)\n+  if (!saved_depth.complexity)\n     return best_depth;\n \n-  if (saved_depth < best_depth)\n+  /* Combine the entryval count so that regardless of which one we\n+     return, the entryval count is accurate.  */\n+  best_depth.entryvals = saved_depth.entryvals\n+    = best_depth.entryvals + saved_depth.entryvals;\n+\n+  if (saved_depth.complexity < best_depth.complexity)\n     return best_depth;\n   else\n     return saved_depth;\n@@ -7727,12 +7746,14 @@ vt_expand_var_loc_chain (variable var, bitmap regs, void *data, bool *pendrecp)\n   bool pending_recursion;\n   rtx loc_from = NULL;\n   struct elt_loc_list *cloc = NULL;\n-  int depth = 0, saved_depth = elcd->depth;\n+  expand_depth depth = { 0, 0 }, saved_depth = elcd->depth;\n+  int wanted_entryvals, found_entryvals = 0;\n \n   /* Clear all backlinks pointing at this, so that we're not notified\n      while we're active.  */\n   loc_exp_dep_clear (var);\n \n+ retry:\n   if (var->onepart == ONEPART_VALUE)\n     {\n       cselib_val *val = CSELIB_VAL_PTR (dv_as_value (var->dv));\n@@ -7745,13 +7766,15 @@ vt_expand_var_loc_chain (variable var, bitmap regs, void *data, bool *pendrecp)\n   first_child = result_first_child = last_child\n     = VEC_length (rtx, elcd->expanding);\n \n+  wanted_entryvals = found_entryvals;\n+\n   /* Attempt to expand each available location in turn.  */\n   for (next = loc = var->n_var_parts ? var->var_part[0].loc_chain : NULL;\n        loc || cloc; loc = next)\n     {\n       result_first_child = last_child;\n \n-      if (!loc || (GET_CODE (loc->loc) == ENTRY_VALUE && cloc))\n+      if (!loc)\n \t{\n \t  loc_from = cloc->loc;\n \t  next = loc;\n@@ -7767,7 +7790,7 @@ vt_expand_var_loc_chain (variable var, bitmap regs, void *data, bool *pendrecp)\n \n       gcc_checking_assert (!unsuitable_loc (loc_from));\n \n-      elcd->depth = 0;\n+      elcd->depth.complexity = elcd->depth.entryvals = 0;\n       result = cselib_expand_value_rtx_cb (loc_from, regs, EXPR_DEPTH,\n \t\t\t\t\t   vt_expand_loc_callback, data);\n       last_child = VEC_length (rtx, elcd->expanding);\n@@ -7776,23 +7799,48 @@ vt_expand_var_loc_chain (variable var, bitmap regs, void *data, bool *pendrecp)\n \t{\n \t  depth = elcd->depth;\n \n-\t  gcc_checking_assert (depth || result_first_child == last_child);\n+\t  gcc_checking_assert (depth.complexity\n+\t\t\t       || result_first_child == last_child);\n \n \t  if (last_child - result_first_child != 1)\n-\t    depth++;\n+\t    {\n+\t      if (!depth.complexity && GET_CODE (result) == ENTRY_VALUE)\n+\t\tdepth.entryvals++;\n+\t      depth.complexity++;\n+\t    }\n \n-\t  if (depth <= EXPR_USE_DEPTH)\n-\t    break;\n+\t  if (depth.complexity <= EXPR_USE_DEPTH)\n+\t    {\n+\t      if (depth.entryvals <= wanted_entryvals)\n+\t\tbreak;\n+\t      else if (!found_entryvals || depth.entryvals < found_entryvals)\n+\t\tfound_entryvals = depth.entryvals;\n+\t    }\n \n \t  result = NULL;\n \t}\n \n       /* Set it up in case we leave the loop.  */\n-      depth = 0;\n+      depth.complexity = depth.entryvals = 0;\n       loc_from = NULL;\n       result_first_child = first_child;\n     }\n \n+  if (!loc_from && wanted_entryvals < found_entryvals)\n+    {\n+      /* We found entries with ENTRY_VALUEs and skipped them.  Since\n+\t we could not find any expansions without ENTRY_VALUEs, but we\n+\t found at least one with them, go back and get an entry with\n+\t the minimum number ENTRY_VALUE count that we found.  We could\n+\t avoid looping, but since each sub-loc is already resolved,\n+\t the re-expansion should be trivial.  ??? Should we record all\n+\t attempted locs as dependencies, so that we retry the\n+\t expansion should any of them change, in the hope it can give\n+\t us a new entry without an ENTRY_VALUE?  */\n+      VEC_truncate (rtx, elcd->expanding, first_child);\n+      goto retry;\n+    }\n+\n   /* Register all encountered dependencies as active.  */\n   pending_recursion = loc_exp_dep_set\n     (var, result, VEC_address (rtx, elcd->expanding) + result_first_child,\n@@ -7805,7 +7853,7 @@ vt_expand_var_loc_chain (variable var, bitmap regs, void *data, bool *pendrecp)\n   VAR_LOC_FROM (var) = loc_from;\n   VAR_LOC_DEPTH (var) = depth;\n \n-  gcc_checking_assert (!depth == !result);\n+  gcc_checking_assert (!depth.complexity == !result);\n \n   elcd->depth = update_depth (saved_depth, depth);\n \n@@ -7893,7 +7941,7 @@ vt_expand_loc_callback (rtx x, bitmap regs,\n       gcc_checking_assert (!NO_LOC_P (x));\n       gcc_checking_assert (var->var_part[0].cur_loc);\n       gcc_checking_assert (VAR_LOC_1PAUX (var));\n-      gcc_checking_assert (VAR_LOC_1PAUX (var)->depth);\n+      gcc_checking_assert (VAR_LOC_1PAUX (var)->depth.complexity);\n \n       elcd->depth = update_depth (elcd->depth, VAR_LOC_1PAUX (var)->depth);\n \n@@ -7967,7 +8015,7 @@ resolve_expansions_pending_recursion (VEC (rtx, stack) *pending)\n       (d).vars = (v);\t\t\t\t\t\t\\\n       (d).expanding = VEC_alloc (rtx, stack, 4);\t\t\\\n       (d).pending = VEC_alloc (rtx, stack, 4);\t\t\t\\\n-      (d).depth = 0;\t\t\t\t\t\t\\\n+      (d).depth.complexity = (d).depth.entryvals = 0;\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n /* Finalize expand_loc_callback_data D, resolved to location L.  */"}]}