{"sha": "7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2YTdlZjhhZDBlMTgwYjJmMTJiMmExNTM1YjMxZDBhY2M4M2YxYw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-04-12T14:34:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-17T08:14:09Z"}, "message": "[Ada] Ada_2020 AI12-0220 Pre/Postconditions on Access_To_Subprogram types\n\n2020-06-17  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration): For an\n\taccess_to_subprogram declaration that has aspect specifications,\n\tcall Build_Access_ Subprogram_Wrapper at once, so that pre- and\n\tpostcondition aspects are analyzed in the context of a\n\tsubprogram declaration.\n\t(Build_Access_Subprogram_Wrapper): Examine aspect specifications\n\tof an Access_To_Subprogram declaration. If pre- or\n\tpostconditions are declared for it, create declaration for\n\tsubprogram wrapper and add the corresponding aspect\n\tspecifications to it. Replace occurrences of the type name by\n\tthat of the generated subprogram, so that attributes 'Old and\n\t'Result can appear in a postcondition.\n\t* exp_ch3.adb (Build_Access_Subprogram_Wrapper_Body): Moved\n\there from sem_prag.adb.\n\t* exp_ch3.ads (Build_Access_Subprogram_Wrapper_Body): Visible\n\tsubprogram.\n\t* sem_prag.adb (Build_Access_Subprogram_Wrapper / _Body): Moved\n\tto sem_ch3.adb and exp_ch3.adb.", "tree": {"sha": "85a56e34522c2694fee91201b799a611ac506a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a56e34522c2694fee91201b799a611ac506a5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73642e6899a36de223ea07292e8e7236fb22aee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73642e6899a36de223ea07292e8e7236fb22aee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73642e6899a36de223ea07292e8e7236fb22aee7"}], "stats": {"total": 432, "additions": 243, "deletions": 189}, "files": [{"sha": "6e1e6251d108cc3f9f6f618df9000601155e5413", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "patch": "@@ -515,6 +515,78 @@ package body Exp_Ch3 is\n       end loop;\n    end Adjust_Discriminants;\n \n+   ------------------------------------------\n+   -- Build_Access_Subprogram_Wrapper_Body --\n+   ------------------------------------------\n+\n+   procedure Build_Access_Subprogram_Wrapper_Body\n+     (Decl : Node_Id;\n+      New_Decl : Node_Id)\n+   is\n+      Loc       : constant Source_Ptr := Sloc (Decl);\n+      Actuals   : constant List_Id := New_List;\n+      Type_Def  : constant Node_Id := Type_Definition (Decl);\n+      Type_Id   : constant Entity_Id := Defining_Identifier (Decl);\n+      Spec_Node : constant Node_Id :=\n+        New_Copy_Tree (Specification (New_Decl));\n+\n+      Act       : Node_Id;\n+      Body_Node : Node_Id;\n+      Call_Stmt : Node_Id;\n+      Ptr       : Entity_Id;\n+   begin\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n+      Set_Defining_Unit_Name (Spec_Node,\n+        Make_Defining_Identifier\n+          (Loc, Chars (Defining_Unit_Name (Spec_Node))));\n+\n+      --  Create List of actuals for indirect call. The last\n+      --  parameter of the subprogram is the access value itself.\n+\n+      Act := First (Parameter_Specifications (Spec_Node));\n+\n+      while Present (Act) loop\n+         Append_To (Actuals,\n+           Make_Identifier (Loc, Chars (Defining_Identifier (Act))));\n+         Next (Act);\n+         exit when Act = Last (Parameter_Specifications (Spec_Node));\n+      end loop;\n+\n+      Ptr :=\n+        Defining_Identifier\n+          (Last (Parameter_Specifications (Spec_Node)));\n+\n+      if Nkind (Type_Def) = N_Access_Procedure_Definition then\n+         Call_Stmt := Make_Procedure_Call_Statement (Loc,\n+           Name =>\n+              Make_Explicit_Dereference\n+                (Loc, New_Occurrence_Of (Ptr, Loc)),\n+           Parameter_Associations => Actuals);\n+      else\n+         Call_Stmt := Make_Simple_Return_Statement (Loc,\n+           Expression =>\n+             Make_Function_Call (Loc,\n+           Name => Make_Explicit_Dereference\n+                    (Loc, New_Occurrence_Of (Ptr, Loc)),\n+           Parameter_Associations => Actuals));\n+      end if;\n+\n+      Body_Node := Make_Subprogram_Body (Loc,\n+        Specification => Spec_Node,\n+        Declarations  => New_List,\n+        Handled_Statement_Sequence =>\n+          Make_Handled_Sequence_Of_Statements (Loc,\n+            Statements    => New_List (Call_Stmt)));\n+\n+      --  Place body in list of freeze actions for the type.\n+\n+      Ensure_Freeze_Node (Type_Id);\n+      Append_Freeze_Actions (Type_Id, New_List (Body_Node));\n+   end Build_Access_Subprogram_Wrapper_Body;\n+\n    ---------------------------\n    -- Build_Array_Init_Proc --\n    ---------------------------"}, {"sha": "12387cfcca4a2dd1f36aa6658eb937ec9f385684", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "patch": "@@ -46,6 +46,17 @@ package Exp_Ch3 is\n    procedure Expand_Record_Extension (T : Entity_Id; Def : Node_Id);\n    --  Add a field _parent in the extension part of the record\n \n+   procedure Build_Access_Subprogram_Wrapper_Body\n+     (Decl : Node_Id;\n+      New_Decl : Node_Id);\n+   --  Build the wrapper body, which holds the indirect call through\n+   --  an access_to_subprogram, and whose expansion incorporates the\n+   --  contracts of the access type declaration. Called from Build_\n+   --  Access_Subprogram_Wrapper.\n+   --  Building the wrapper is done during analysis to perform proper\n+   --  semantic checks on the relevant aspects. The wrapper body could\n+   --  be simplified to a null body when expansion is disabled ???\n+\n    procedure Build_Discr_Checking_Funcs (N : Node_Id);\n    --  Builds function which checks whether the component name is consistent\n    --  with the current discriminants. N is the full type declaration node,"}, {"sha": "2e97516cd3e0befe4360c0ec2f4a89b22eed1ff5", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "patch": "@@ -92,6 +92,11 @@ package body Sem_Ch3 is\n    --  abstract interface types implemented by a record type or a derived\n    --  record type.\n \n+   procedure Build_Access_Subprogram_Wrapper (Decl : Node_Id);\n+   --  When an access_to_subprogram type has pre/postconditions, we\n+   --  build a subprogram that includes these contracts and is invoked\n+   --  by any indirect call through the corresponding access type.\n+\n    procedure Build_Derived_Type\n      (N             : Node_Id;\n       Parent_Type   : Entity_Id;\n@@ -3136,6 +3141,17 @@ package body Sem_Ch3 is\n \n                Validate_Access_Type_Declaration (T, N);\n \n+               --  If the type has contracts, we create the corresponding\n+               --  wrapper at once, before analyzing the aspect\n+               --  specifications, so that pre/postconditions can be\n+               --  handled directly on the generated wrapper.\n+\n+               if Ada_Version >= Ada_2020\n+                 and then Present (Aspect_Specifications (N))\n+               then\n+                  Build_Access_Subprogram_Wrapper (N);\n+               end if;\n+\n             when N_Access_To_Object_Definition =>\n                Access_Type_Declaration (T, Def);\n \n@@ -6447,6 +6463,146 @@ package body Sem_Ch3 is\n       return Anon;\n    end Replace_Anonymous_Access_To_Protected_Subprogram;\n \n+   -------------------------------------\n+   -- Build_Access_Subprogram_Wrapper --\n+   -------------------------------------\n+\n+   procedure Build_Access_Subprogram_Wrapper (Decl : Node_Id) is\n+      Loc      : constant Source_Ptr := Sloc (Decl);\n+      Id       : constant Entity_Id  := Defining_Identifier (Decl);\n+      Type_Def : constant Node_Id    := Type_Definition (Decl);\n+      Specs   :  constant List_Id    :=\n+                              Parameter_Specifications (Type_Def);\n+      Profile : constant List_Id     := New_List;\n+      Subp    : constant Entity_Id   := Make_Temporary (Loc, 'A');\n+\n+      Contracts : constant List_Id := New_List;\n+      Form_P    : Node_Id;\n+      New_P     : Node_Id;\n+      New_Decl  : Node_Id;\n+      Spec      : Node_Id;\n+\n+      procedure Replace_Type_Name (Expr : Node_Id);\n+      --  In the expressions for contract aspects, replace\n+      --  occurrences of the access type with the name of the\n+      --  subprogram entity, as needed, e.g. for 'Result.\n+      --  Apects that are not contracts 9e.g. Size or Aligment)\n+      --  remain on the originsl access type declaration.\n+      --  What about expanded names denoting formals, whose prefix\n+      --  in the source is the type name ???\n+\n+      -----------------------\n+      -- Replace_Type_Name --\n+      -----------------------\n+\n+      procedure Replace_Type_Name (Expr : Node_Id) is\n+         function Process (N : Node_Id) return Traverse_Result;\n+         function Process (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Attribute_Reference\n+              and then Is_Entity_Name (Prefix (N))\n+              and then Chars (Prefix (N)) = Chars (Id)\n+            then\n+               Set_Prefix (N, Make_Identifier (Sloc (N), Chars (Subp)));\n+            end if;\n+\n+            return OK;\n+         end Process;\n+\n+         procedure Traverse is new Traverse_Proc (Process);\n+      begin\n+         Traverse (Expr);\n+      end Replace_Type_Name;\n+\n+   begin\n+      if Ekind_In (Id, E_Access_Subprogram_Type,\n+         E_Access_Protected_Subprogram_Type,\n+         E_Anonymous_Access_Protected_Subprogram_Type,\n+         E_Anonymous_Access_Subprogram_Type)\n+      then\n+         null;\n+\n+      else\n+         Error_Msg_N\n+           (\"illegal pre/postcondition on access type\", Decl);\n+         return;\n+      end if;\n+\n+      declare\n+         Asp  : Node_Id;\n+         A_Id : Aspect_Id;\n+         Cond : Node_Id;\n+         Expr : Node_Id;\n+\n+      begin\n+         Asp := First (Aspect_Specifications (Decl));\n+         while Present (Asp) loop\n+            A_Id := Get_Aspect_Id (Chars (Identifier (Asp)));\n+            if A_Id = Aspect_Pre or else A_Id = Aspect_Post then\n+               Cond := Asp;\n+               Expr := Expression (Cond);\n+               Replace_Type_Name (Expr);\n+               Next (Asp);\n+\n+               Remove (Cond);\n+               Append (Cond, Contracts);\n+\n+            else\n+               Next (Asp);\n+            end if;\n+         end loop;\n+      end;\n+\n+      --  If there are no contract aspects, no need for a wrapper.\n+\n+      if Is_Empty_List (Contracts) then\n+         return;\n+      end if;\n+\n+      Form_P := First (Specs);\n+\n+      while Present (Form_P) loop\n+         New_P := New_Copy_Tree (Form_P);\n+         Set_Defining_Identifier (New_P,\n+           Make_Defining_Identifier\n+            (Loc, Chars (Defining_Identifier (Form_P))));\n+         Append (New_P, Profile);\n+         Next (Form_P);\n+      end loop;\n+\n+      --  Add to parameter specifications the access parameter that\n+      --  is passed in from an indirect call.\n+\n+      Append (\n+         Make_Parameter_Specification (Loc,\n+           Defining_Identifier => Make_Temporary (Loc, 'P'),\n+           Parameter_Type  =>  New_Occurrence_Of (Id, Loc)),\n+         Profile);\n+\n+      if Nkind (Type_Def) = N_Access_Procedure_Definition then\n+         Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name       => Subp,\n+             Parameter_Specifications => Profile);\n+      else\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => Subp,\n+             Parameter_Specifications => Profile,\n+             Result_Definition        =>\n+               New_Copy_Tree\n+                 (Result_Definition (Type_Definition (Decl))));\n+      end if;\n+\n+      New_Decl :=\n+        Make_Subprogram_Declaration (Loc, Specification => Spec);\n+      Set_Aspect_Specifications (New_Decl, Contracts);\n+\n+      Insert_After (Decl, New_Decl);\n+      Set_Access_Subprogram_Wrapper (Designated_Type (Id), Subp);\n+      Build_Access_Subprogram_Wrapper_Body (Decl, New_Decl);\n+   end Build_Access_Subprogram_Wrapper;\n+\n    -------------------------------\n    -- Build_Derived_Access_Type --\n    -------------------------------"}, {"sha": "9e7f4c89d8cb99c35dfce682ea383acbf515c13f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 189, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7b6a7ef8ad0e180b2f12b2a1535b31d0acc83f1c", "patch": "@@ -4533,185 +4533,6 @@ package body Sem_Prag is\n          --  a class-wide precondition only if one of its ancestors has an\n          --  explicit class-wide precondition.\n \n-         procedure Build_Access_Subprogram_Wrapper\n-           (Decl : Node_Id;\n-            Prag : Node_Id);\n-         --  When an access_to_subprogram type has pre/postconditions, we\n-         --  build a subprogram that includes these contracts and is invoked\n-         --  by any indirect call through the corresponding access type.\n-\n-         procedure Build_Access_Subprogram_Wrapper_Body\n-           (Decl : Node_Id;\n-            New_Decl : Node_Id);\n-         --  Build the wrapper body, which holds the indirect call through\n-         --  an access_to_subprogram, and whose expansion incorporates the\n-         --  contracts of the access type declaration.\n-\n-         -------------------------------------\n-         -- Build_Access_Subprogram_Wrapper --\n-         -------------------------------------\n-\n-         procedure Build_Access_Subprogram_Wrapper\n-           (Decl : Node_Id;\n-            Prag : Node_Id)\n-         is\n-            Loc      : constant Source_Ptr := Sloc (Decl);\n-            Id       : constant Entity_Id  := Defining_Identifier (Decl);\n-            Type_Def : constant Node_Id := Type_Definition (Decl);\n-            Specs   :  constant List_Id := Parameter_Specifications (Type_Def);\n-            Profile : constant List_Id  := New_List;\n-\n-            Form_P   : Node_Id;\n-            New_P    : Node_Id;\n-            New_Decl : Node_Id;\n-            Spec     : Node_Id;\n-            Subp     : Entity_Id;\n-\n-         begin\n-            if Ekind_In (Id, E_Access_Subprogram_Type,\n-               E_Access_Protected_Subprogram_Type,\n-               E_Anonymous_Access_Protected_Subprogram_Type,\n-               E_Anonymous_Access_Subprogram_Type)\n-            then\n-               null;\n-\n-            else\n-               Error_Msg_N\n-                 (\"illegal pre/postcondition on access type\", N);\n-               return;\n-            end if;\n-\n-            Subp := Make_Temporary (Loc, 'A');\n-            Form_P := First (Specs);\n-\n-            while Present (Form_P) loop\n-               New_P := New_Copy_Tree (Form_P);\n-               Set_Defining_Identifier (New_P,\n-                 Make_Defining_Identifier\n-                  (Loc, Chars (Defining_Identifier (Form_P))));\n-               Append (New_P, Profile);\n-               Next (Form_P);\n-            end loop;\n-\n-            --  Add to parameter specifications the access parameter that\n-            --  is passed from an indirect call.\n-\n-            Append (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier => Make_Temporary (Loc, 'P'),\n-                 Parameter_Type  =>  New_Occurrence_Of (Id, Loc)),\n-               Profile);\n-\n-            if Nkind (Type_Def) = N_Access_Procedure_Definition then\n-               Spec :=\n-                 Make_Procedure_Specification (Loc,\n-                   Defining_Unit_Name       => Subp,\n-                   Parameter_Specifications => Profile);\n-            else\n-               Spec :=\n-                 Make_Function_Specification (Loc,\n-                   Defining_Unit_Name       => Subp,\n-                   Parameter_Specifications => Profile,\n-                   Result_Definition        =>\n-                     New_Copy_Tree\n-                       (Result_Definition (Type_Definition (Decl))));\n-            end if;\n-\n-            New_Decl :=\n-              Make_Subprogram_Declaration (Loc, Specification => Spec);\n-            Set_Aspect_Specifications (New_Decl,\n-              New_Copy_List_Tree (Aspect_Specifications (Decl)));\n-\n-            declare\n-               Asp : Node_Id;\n-\n-            begin\n-               Asp := First (Aspect_Specifications (New_Decl));\n-               while Present (Asp) loop\n-                  Set_Aspect_Rep_Item (Asp, Empty);\n-                  Set_Entity (Asp, Empty);\n-                  Set_Analyzed (Asp, False);\n-                  Next (Asp);\n-               end loop;\n-            end;\n-\n-            Insert_After (Prag, New_Decl);\n-            Set_Access_Subprogram_Wrapper (Designated_Type (Id), Subp);\n-            Build_Access_Subprogram_Wrapper_Body (Decl, New_Decl);\n-         end Build_Access_Subprogram_Wrapper;\n-\n-         ------------------------------------------\n-         -- Build_Access_Subprogram_Wrapper_Body --\n-         ------------------------------------------\n-\n-         procedure Build_Access_Subprogram_Wrapper_Body\n-           (Decl : Node_Id;\n-            New_Decl : Node_Id)\n-         is\n-            Loc       : constant Source_Ptr := Sloc (Decl);\n-            Actuals   : constant List_Id := New_List;\n-            Type_Def  : constant Node_Id := Type_Definition (Decl);\n-            Type_Id   : constant Entity_Id := Defining_Identifier (Decl);\n-            Spec_Node : constant Node_Id :=\n-              New_Copy_Tree (Specification (New_Decl));\n-\n-            Act       : Node_Id;\n-            Body_Node : Node_Id;\n-            Call_Stmt : Node_Id;\n-            Ptr       : Entity_Id;\n-         begin\n-            if not Expander_Active then\n-               return;\n-            end if;\n-\n-            Set_Defining_Unit_Name (Spec_Node,\n-              Make_Defining_Identifier\n-                (Loc, Chars (Defining_Unit_Name (Spec_Node))));\n-\n-            --  Create List of actuals for indirect call. The last\n-            --  parameter of the subprogram is the access value itself.\n-\n-            Act := First (Parameter_Specifications (Spec_Node));\n-\n-            while Present (Act) loop\n-               Append_To (Actuals,\n-                 Make_Identifier (Loc, Chars (Defining_Identifier (Act))));\n-               Next (Act);\n-               exit when Act = Last (Parameter_Specifications (Spec_Node));\n-            end loop;\n-\n-            Ptr :=\n-              Defining_Identifier\n-                (Last (Parameter_Specifications (Spec_Node)));\n-\n-            if Nkind (Type_Def) = N_Access_Procedure_Definition then\n-               Call_Stmt := Make_Procedure_Call_Statement (Loc,\n-                 Name =>\n-                    Make_Explicit_Dereference\n-                      (Loc, New_Occurrence_Of (Ptr, Loc)),\n-                 Parameter_Associations => Actuals);\n-            else\n-               Call_Stmt := Make_Simple_Return_Statement (Loc,\n-                 Expression =>\n-                   Make_Function_Call (Loc,\n-                 Name => Make_Explicit_Dereference\n-                          (Loc, New_Occurrence_Of (Ptr, Loc)),\n-                 Parameter_Associations => Actuals));\n-            end if;\n-\n-            Body_Node := Make_Subprogram_Body (Loc,\n-              Specification => Spec_Node,\n-              Declarations  => New_List,\n-              Handled_Statement_Sequence =>\n-                Make_Handled_Sequence_Of_Statements (Loc,\n-                  Statements    => New_List (Call_Stmt)));\n-\n-            --  Place body in list of freeze actions for the type.\n-\n-            Ensure_Freeze_Node (Type_Id);\n-            Append_Freeze_Actions (Type_Id, New_List (Body_Node));\n-         end Build_Access_Subprogram_Wrapper_Body;\n-\n          -----------------------------\n          -- Inherits_Class_Wide_Pre --\n          -----------------------------\n@@ -4953,17 +4774,11 @@ package body Sem_Prag is\n          then\n             null;\n \n-         elsif Ada_Version >= Ada_2020\n-           and then Nkind (Subp_Decl) = N_Full_Type_Declaration\n-         then\n-\n-            --  Access_To_Subprogram type has pre/postconditions.\n-            --  Build wrapper subprogram to carry the contract items.\n-\n-            Build_Access_Subprogram_Wrapper (Subp_Decl, N);\n-            return;\n+         --  Access_To_Subprogram type can have pre/postconditions, but\n+         --  these are trasnfered to the generated subprogram wrapper and\n+         --  analyzed there.\n \n-         --  Otherwise the placement is illegal\n+         --  Otherwise the placement of the pragma is illegal\n \n          else\n             Pragma_Misplaced;"}]}