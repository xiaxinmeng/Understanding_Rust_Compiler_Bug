{"sha": "bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "node_id": "C_kwDOANBUbNoAKGJkMzFjNjNmZTE1YzRlMzlkMzAzNmZmN2FkY2QyMmVhZGQ2YjUzZWE", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-08T11:09:44Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:27Z"}, "message": "rust-constexpr.cc: port over more cases to eval_constant_expression", "tree": {"sha": "94b8456931257c82bc75a91c5292f856e12b0e1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94b8456931257c82bc75a91c5292f856e12b0e1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a38ad0b614ff5d601e5425824ad760235710eee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38ad0b614ff5d601e5425824ad760235710eee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38ad0b614ff5d601e5425824ad760235710eee5"}], "stats": {"total": 137, "additions": 122, "deletions": 15}, "files": [{"sha": "df4ceba4f7ad43290bc731811eabf40df7715b47", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 117, "deletions": 15, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "patch": "@@ -1514,6 +1514,21 @@ reduced_constant_expression_p (tree t)\n     }\n }\n \n+/* TEMP is the constant value of a temporary object of type TYPE.  Adjust\n+   the type of the value to match.  */\n+\n+static tree\n+adjust_temp_type (tree type, tree temp)\n+{\n+  if (same_type_p (TREE_TYPE (temp), type))\n+    return temp;\n+\n+  gcc_assert (scalarish_type_p (type));\n+  /* Now we know we're dealing with a scalar, and a prvalue of non-class\n+     type is cv-unqualified.  */\n+  return fold_convert (cv_unqualified (type), temp);\n+}\n+\n static tree\n eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p,\n@@ -1544,6 +1559,7 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       return t;\n     }\n \n+  constexpr_ctx new_ctx;\n   tree r = t;\n   tree_code tcode = TREE_CODE (t);\n   switch (tcode)\n@@ -1561,6 +1577,14 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       }\n       break;\n \n+    case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (t))\n+\t{\n+\t  r = DECL_VALUE_EXPR (t);\n+\t  return eval_constant_expression (ctx, r, lval, non_constant_p,\n+\t\t\t\t\t   overflow_p);\n+\t}\n+\n     case PARM_DECL:\n       if (lval && !TYPE_REF_P (TREE_TYPE (t)))\n \t/* glvalue use.  */;\n@@ -1643,6 +1667,67 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t\t   overflow_p);\n       break;\n \n+      case TARGET_EXPR: {\n+\ttree type = TREE_TYPE (t);\n+\n+\tif (!literal_type_p (type))\n+\t  {\n+\t    if (!ctx->quiet)\n+\t      {\n+\t\tauto_diagnostic_group d;\n+\t\terror (\"temporary of non-literal type %qT in a \"\n+\t\t       \"constant expression\",\n+\t\t       type);\n+\t\t// explain_non_literal_class (type);\n+\t      }\n+\t    *non_constant_p = true;\n+\t    break;\n+\t  }\n+\tgcc_checking_assert (!TARGET_EXPR_DIRECT_INIT_P (t));\n+\t/* Avoid evaluating a TARGET_EXPR more than once.  */\n+\ttree slot = TARGET_EXPR_SLOT (t);\n+\tif (tree *p = ctx->global->values.get (slot))\n+\t  {\n+\t    if (lval)\n+\t      return slot;\n+\t    r = *p;\n+\t    break;\n+\t  }\n+\tif ((AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type)))\n+\t  {\n+\t    /* We're being expanded without an explicit target, so start\n+\t       initializing a new object; expansion with an explicit target\n+\t       strips the TARGET_EXPR before we get here.  */\n+\t    new_ctx = *ctx;\n+\t    /* Link CTX to NEW_CTX so that lookup_placeholder can resolve\n+\t       any PLACEHOLDER_EXPR within the initializer that refers to the\n+\t       former object under construction.  */\n+\t    new_ctx.parent = ctx;\n+\t    new_ctx.ctor = build_constructor (type, NULL);\n+\t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n+\t    new_ctx.object = slot;\n+\t    ctx->global->values.put (new_ctx.object, new_ctx.ctor);\n+\t    ctx = &new_ctx;\n+\t  }\n+\t/* Pass false for 'lval' because this indicates\n+\t   initialization of a temporary.  */\n+\tr = eval_constant_expression (ctx, TREE_OPERAND (t, 1), false,\n+\t\t\t\t      non_constant_p, overflow_p);\n+\tif (*non_constant_p)\n+\t  break;\n+\t/* Adjust the type of the result to the type of the temporary.  */\n+\tr = adjust_temp_type (type, r);\n+\tif (TARGET_EXPR_CLEANUP (t) && !CLEANUP_EH_ONLY (t))\n+\t  ctx->global->cleanups->safe_push (TARGET_EXPR_CLEANUP (t));\n+\tr = unshare_constructor (r);\n+\tctx->global->values.put (slot, r);\n+\tif (ctx->save_exprs)\n+\t  ctx->save_exprs->safe_push (slot);\n+\tif (lval)\n+\t  return slot;\n+      }\n+      break;\n+\n     case CALL_EXPR:\n       r = eval_call_expression (ctx, t, false, non_constant_p, overflow_p);\n       break;\n@@ -1667,6 +1752,38 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t}\n       break;\n \n+      case DECL_EXPR: {\n+\tr = DECL_EXPR_DECL (t);\n+\n+\tif (AGGREGATE_TYPE_P (TREE_TYPE (r)) || VECTOR_TYPE_P (TREE_TYPE (r)))\n+\t  {\n+\t    new_ctx = *ctx;\n+\t    new_ctx.object = r;\n+\t    new_ctx.ctor = build_constructor (TREE_TYPE (r), NULL);\n+\t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n+\t    ctx->global->values.put (r, new_ctx.ctor);\n+\t    ctx = &new_ctx;\n+\t  }\n+\n+\tif (tree init = DECL_INITIAL (r))\n+\t  {\n+\t    init = eval_constant_expression (ctx, init, false, non_constant_p,\n+\t\t\t\t\t     overflow_p);\n+\t    /* Don't share a CONSTRUCTOR that might be changed.  */\n+\t    init = unshare_constructor (init);\n+\t    /* Remember that a constant object's constructor has already\n+\t       run.  */\n+\t    if (CLASS_TYPE_P (TREE_TYPE (r)) && RS_TYPE_CONST_P (TREE_TYPE (r)))\n+\t      TREE_READONLY (init) = true;\n+\t    ctx->global->values.put (r, init);\n+\t  }\n+\telse if (ctx == &new_ctx)\n+\t  /* We gave it a CONSTRUCTOR above.  */;\n+\telse\n+\t  ctx->global->values.put (r, NULL_TREE);\n+      }\n+      break;\n+\n     /* These differ from cxx_eval_unary_expression in that this doesn't\n \t check for a constant operand or result; an address can be\n \t constant without its operand being, and vice versa.  */\n@@ -2526,21 +2643,6 @@ eval_binary_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   return fold_binary_loc (loc, code, type, lhs, rhs);\n }\n \n-/* TEMP is the constant value of a temporary object of type TYPE.  Adjust\n-   the type of the value to match.  */\n-\n-static tree\n-adjust_temp_type (tree type, tree temp)\n-{\n-  if (same_type_p (TREE_TYPE (temp), type))\n-    return temp;\n-\n-  gcc_assert (scalarish_type_p (type));\n-  /* Now we know we're dealing with a scalar, and a prvalue of non-class\n-     type is cv-unqualified.  */\n-  return fold_convert (cv_unqualified (type), temp);\n-}\n-\n /* Helper function of cxx_bind_parameters_in_call.  Return non-NULL\n    if *TP is address of a static variable (or part of it) currently being\n    constructed or of a heap artificial variable.  */"}, {"sha": "9efa4096bf6c2b3023ef927a4cd253b7641c480d", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "patch": "@@ -1274,6 +1274,11 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n #define AGGR_INIT_EXPR_SLOT(NODE) TREE_OPERAND (AGGR_INIT_EXPR_CHECK (NODE), 2)\n \n+/* True if this TARGET_EXPR expresses direct-initialization of an object\n+   to be named later.  */\n+#define TARGET_EXPR_DIRECT_INIT_P(NODE)                                        \\\n+  TREE_LANG_FLAG_2 (TARGET_EXPR_CHECK (NODE))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\"}]}