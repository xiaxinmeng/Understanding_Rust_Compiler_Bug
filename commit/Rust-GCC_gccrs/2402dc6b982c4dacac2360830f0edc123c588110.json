{"sha": "2402dc6b982c4dacac2360830f0edc123c588110", "node_id": "C_kwDOANBUbNoAKDI0MDJkYzZiOTgyYzRkYWNhYzIzNjA4MzBmMGVkYzEyM2M1ODgxMTA", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-05-16T19:32:11Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-05-16T19:34:09Z"}, "message": "analyzer: implement four new warnings for <stdarg.h> misuses [PR105103]\n\nThis patch adds support to the analyzer for checking usage of <stdarg.h>,\nwith four new warnings.\n\nIt adds:\n(a) a state-machine for tracking \"started\" and \"ended\" states on va_list\ninstances, implementing two new warnings:\n  -Wanalyzer-va-list-leak\n    for complaining about missing va_end after a va_start or va_copy\n  -Wanalyzer-va-list-use-after-va-end:\n    for complaining about va_arg or va_copy used on a va_list that's had\n    va_end called on it\n\n(b) interprocedural tracking of variadic parameters, tracking symbolic\nvalues, implementing two new warnings:\n  -Wanalyzer-va-arg-type-mismatch\n     for type-checking va_arg usage against the types of the parameters\n     that were actually passed to the variadic call\n  -Wanalyzer-va-list-exhausted\n     for complaining if va_arg is used too many times on a va_list\n\nHere's an LTO example of a type mismatch in a variadic call that\nstraddles two source files:\n\nstdarg-lto-1-a.c: In function 'called_by_test_type_mismatch_1':\nstdarg-lto-1-a.c:19:7: warning: 'va_arg' expected 'const char *' but\n received 'int' for variadic argument 1 of 'ap' [-Wanalyzer-va-arg-type-mismatch]\n   19 |   str = va_arg (ap, const char *);\n      |       ^\n  'test_type_mismatch_1': events 1-2\n    |\n    |stdarg-lto-1-b.c:3:6:\n    |    3 | void test_type_mismatch_1 (void)\n    |      |      ^\n    |      |      |\n    |      |      (1) entry to 'test_type_mismatch_1'\n    |    4 | {\n    |    5 |   called_by_test_type_mismatch_1 (42, 1066);\n    |      |   ~\n    |      |   |\n    |      |   (2) calling 'called_by_test_type_mismatch_1' from 'test_type_mismatch_1' with 1 variadic argument\n    |\n    +--> 'called_by_test_type_mismatch_1': events 3-4\n           |\n           |stdarg-lto-1-a.c:12:1:\n           |   12 | called_by_test_type_mismatch_1 (int placeholder, ...)\n           |      | ^\n           |      | |\n           |      | (3) entry to 'called_by_test_type_mismatch_1'\n           |......\n           |   19 |   str = va_arg (ap, const char *);\n           |      |       ~\n           |      |       |\n           |      |       (4) 'va_arg' expected 'const char *' but received 'int' for variadic argument 1 of 'ap'\n           |\n\ngcc/ChangeLog:\n\tPR analyzer/105103\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/varargs.o.\n\t* doc/invoke.texi: Add -Wanalyzer-va-arg-type-mismatch,\n\t-Wanalyzer-va-list-exhausted, -Wanalyzer-va-list-leak, and\n\t-Wanalyzer-va-list-use-after-va-end.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/105103\n\t* analyzer.cc (make_label_text_n): New.\n\t* analyzer.h (class var_arg_region): New forward decl.\n\t(make_label_text_n): New decl.\n\t* analyzer.opt (Wanalyzer-va-arg-type-mismatch): New option.\n\t(Wanalyzer-va-list-exhausted): New option.\n\t(Wanalyzer-va-list-leak): New option.\n\t(Wanalyzer-va-list-use-after-va-end): New option.\n\t* checker-path.cc (call_event::get_desc): Split out decl access\n\tinto..\n\t(call_event::get_caller_fndecl): ...this new function and...\n\t(call_event::get_callee_fndecl): ...this new function.\n\t* checker-path.h (call_event::get_desc): Drop \"FINAL\".\n\t(call_event::get_caller_fndecl): New decl.\n\t(call_event::get_callee_fndecl): New decl.\n\t(class call_event): Make fields protected.\n\t* diagnostic-manager.cc (null_assignment_sm_context::warn): New\n\toverload.\n\t(null_assignment_sm_context::get_new_program_state): New.\n\t(diagnostic_manager::add_events_for_superedge): Move case\n\tSUPEREDGE_CALL to a new pending_diagnostic::add_call_event vfunc.\n\t* engine.cc (impl_sm_context::warn): Implement new override.\n\t(impl_sm_context::get_new_program_state): New.\n\t* pending-diagnostic.cc: Include \"analyzer/diagnostic-manager.h\",\n\t\"cpplib.h\", \"digraph.h\", \"ordered-hash-map.h\", \"cfg.h\",\n\t\"basic-block.h\", \"gimple.h\", \"gimple-iterator.h\", \"cgraph.h\"\n\t\"analyzer/supergraph.h\", \"analyzer/program-state.h\",\n\t\"alloc-pool.h\", \"fibonacci_heap.h\", \"shortest-paths.h\",\n\t\"sbitmap.h\", \"analyzer/exploded-graph.h\", \"diagnostic-path.h\",\n\tand \"analyzer/checker-path.h\".\n\t(ht_ident_eq): New.\n\t(fixup_location_in_macro_p): New.\n\t(pending_diagnostic::fixup_location): New.\n\t(pending_diagnostic::add_call_event): New.\n\t* pending-diagnostic.h (pending_diagnostic::fixup_location): Drop\n\tno-op inline implementation in favor of the more complex\n\timplementation above.\n\t(pending_diagnostic::add_call_event): New vfunc.\n\t* region-model-impl-calls.cc: Include \"analyzer/sm.h\",\n\t\"diagnostic-path.h\", and \"analyzer/pending-diagnostic.h\".\n\t* region-model-manager.cc\n\t(region_model_manager::get_var_arg_region): New.\n\t(region_model_manager::log_stats): Log m_var_arg_regions.\n\t* region-model.cc (region_model::on_call_pre): Handle IFN_VA_ARG,\n\tBUILT_IN_VA_START, and BUILT_IN_VA_COPY.\n\t(region_model::on_call_post): Handle BUILT_IN_VA_END.\n\t(region_model::get_representative_path_var_1): Handle RK_VAR_ARG.\n\t(region_model::push_frame): Push variadic arguments.\n\t* region-model.h (region_model_manager::get_var_arg_region): New\n\tdecl.\n\t(region_model_manager::m_var_arg_regions): New field.\n\t(region_model::impl_call_va_start): New decl.\n\t(region_model::impl_call_va_copy): New decl.\n\t(region_model::impl_call_va_arg): New decl.\n\t(region_model::impl_call_va_end): New decl.\n\t* region.cc (alloca_region::dump_to_pp): Dump the id.\n\t(var_arg_region::dump_to_pp): New.\n\t(var_arg_region::get_frame_region): New.\n\t* region.h (enum region_kind): Add RK_VAR_ARG.\n\t(region::dyn_cast_var_arg_region): New.\n\t(class var_arg_region): New.\n\t(is_a_helper <const var_arg_region *>::test): New.\n\t(struct default_hash_traits<var_arg_region::key_t>): New.\n\t* sm.cc (make_checkers): Call make_va_list_state_machine.\n\t* sm.h (sm_context::warn): New vfunc.\n\t(sm_context::get_old_svalue): Drop unused decl.\n\t(sm_context::get_new_program_state): New vfunc.\n\t(make_va_list_state_machine): New decl.\n\t* varargs.cc: New file.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/105103\n\t* gcc.dg/analyzer/stdarg-1.c: New test.\n\t* gcc.dg/analyzer/stdarg-2.c: New test.\n\t* gcc.dg/analyzer/stdarg-fmtstring-1.c: New test.\n\t* gcc.dg/analyzer/stdarg-lto-1-a.c: New test.\n\t* gcc.dg/analyzer/stdarg-lto-1-b.c: New test.\n\t* gcc.dg/analyzer/stdarg-lto-1.h: New test.\n\t* gcc.dg/analyzer/stdarg-sentinel-1.c: New test.\n\t* gcc.dg/analyzer/stdarg-types-1.c: New test.\n\t* gcc.dg/analyzer/stdarg-types-2.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "95f38ecf7b3a91c1c413e2b782f1a54eb3b4b894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95f38ecf7b3a91c1c413e2b782f1a54eb3b4b894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2402dc6b982c4dacac2360830f0edc123c588110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2402dc6b982c4dacac2360830f0edc123c588110", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2402dc6b982c4dacac2360830f0edc123c588110", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2402dc6b982c4dacac2360830f0edc123c588110/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5eb9927aae076200bb7ba3f22c33b0a7c97c5643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eb9927aae076200bb7ba3f22c33b0a7c97c5643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eb9927aae076200bb7ba3f22c33b0a7c97c5643"}], "stats": {"total": 2589, "additions": 2567, "deletions": 22}, "files": [{"sha": "70f7d2191f1fa6f9a82b12dd04ca160b14590fd8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -1278,7 +1278,8 @@ ANALYZER_OBJS = \\\n \tanalyzer/store.o \\\n \tanalyzer/supergraph.o \\\n \tanalyzer/svalue.o \\\n-\tanalyzer/trimmed-graph.o\n+\tanalyzer/trimmed-graph.o \\\n+\tanalyzer/varargs.o\n \n # Language-independent object files.\n # We put the *-match.o and insn-*.o files first so that a parallel make"}, {"sha": "c85dbf331d502016d9d86702d1781411a288c3bc", "filename": "gcc/analyzer/analyzer.cc", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -446,4 +446,42 @@ make_label_text (bool can_colorize, const char *fmt, ...)\n   return result;\n }\n \n+/* As above, but with singular vs plural.  */\n+\n+label_text\n+make_label_text_n (bool can_colorize, int n,\n+\t\t   const char *singular_fmt,\n+\t\t   const char *plural_fmt, ...)\n+{\n+  pretty_printer *pp = global_dc->printer->clone ();\n+  pp_clear_output_area (pp);\n+\n+  if (!can_colorize)\n+    pp_show_color (pp) = false;\n+\n+  text_info ti;\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n+\n+  va_list ap;\n+\n+  va_start (ap, plural_fmt);\n+\n+  const char *fmt = ngettext (singular_fmt, plural_fmt, n);\n+\n+  ti.format_spec = fmt;\n+  ti.args_ptr = &ap;\n+  ti.err_no = 0;\n+  ti.x_data = NULL;\n+  ti.m_richloc = &rich_loc;\n+\n+  pp_format (pp, &ti);\n+  pp_output_formatted_text (pp);\n+\n+  va_end (ap);\n+\n+  label_text result = label_text::take (xstrdup (pp_formatted_text (pp)));\n+  delete pp;\n+  return result;\n+}\n+\n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "dcefc13a54681f71541fcd216c02abe34419e502", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -69,6 +69,7 @@ class region;\n   class field_region;\n   class string_region;\n   class bit_range_region;\n+  class var_arg_region;\n class region_model_manager;\n class conjured_purge;\n struct model_merger;\n@@ -296,6 +297,9 @@ extern const char *get_user_facing_name (const gcall *call);\n extern void register_analyzer_pass ();\n \n extern label_text make_label_text (bool can_colorize, const char *fmt, ...);\n+extern label_text make_label_text_n (bool can_colorize, int n,\n+\t\t\t\t     const char *singular_fmt,\n+\t\t\t\t     const char *plural_fmt, ...);\n \n extern bool fndecl_has_gimple_body_p (tree fndecl);\n "}, {"sha": "23dfc797cea034eb0b7c30e6cfeeb18d9f71fa8b", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -142,6 +142,22 @@ Wanalyzer-use-of-pointer-in-stale-stack-frame\n Common Var(warn_analyzer_use_of_pointer_in_stale_stack_frame) Init(1) Warning\n Warn about code paths in which a pointer to a stale stack frame is used.\n \n+Wanalyzer-va-arg-type-mismatch\n+Common Var(warn_analyzer_va_arg_type_mismatch) Init(1) Warning\n+Warn about code paths in which va_arg uses the wrong type.\n+\n+Wanalyzer-va-list-exhausted\n+Common Var(warn_analyzer_va_list_exhausted) Init(1) Warning\n+Warn about code paths in which va_arg is used too many times on a va_list.\n+\n+Wanalyzer-va-list-leak\n+Common Var(warn_analyzer_va_list_leak) Init(1) Warning\n+Warn about code paths in which va_start or va_copy is used without a corresponding va_end.\n+\n+Wanalyzer-va-list-use-after-va-end\n+Common Var(warn_analyzer_va_list_use_after_va_end) Init(1) Warning\n+Warn about code paths in which a va_list is used after va_end.\n+\n Wanalyzer-write-to-const\n Common Var(warn_analyzer_write_to_const) Init(1) Warning\n Warn about code paths which attempt to write to a const object."}, {"sha": "5fdbc3883909fdeb12b12d93431aecec0a2db0bb", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -686,8 +686,8 @@ call_event::get_desc (bool can_colorize) const\n \n   return make_label_text (can_colorize,\n \t\t\t  \"calling %qE from %qE\",\n-\t\t\t  m_dest_snode->m_fun->decl,\n-\t\t\t  m_src_snode->m_fun->decl);\n+\t\t\t  get_callee_fndecl (),\n+\t\t\t  get_caller_fndecl ());\n }\n \n /* Override of checker_event::is_call_p for calls.  */\n@@ -698,6 +698,18 @@ call_event::is_call_p () const\n   return true;\n }\n \n+tree\n+call_event::get_caller_fndecl () const\n+{\n+  return m_src_snode->m_fun->decl;\n+}\n+\n+tree\n+call_event::get_callee_fndecl () const\n+{\n+  return m_dest_snode->m_fun->decl;\n+}\n+\n /* class return_event : public superedge_event.  */\n \n /* return_event's ctor.  */"}, {"sha": "545d7db06a22ec7c9af81ef83be5cec52dfa3683", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -352,10 +352,14 @@ class call_event : public superedge_event\n   call_event (const exploded_edge &eedge,\n \t      location_t loc, tree fndecl, int depth);\n \n-  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+  label_text get_desc (bool can_colorize) const OVERRIDE;\n \n   bool is_call_p () const FINAL OVERRIDE;\n \n+protected:\n+  tree get_caller_fndecl () const;\n+  tree get_callee_fndecl () const;\n+\n   const supernode *m_src_snode;\n   const supernode *m_dest_snode;\n };"}, {"sha": "e8a828d748dc79516a407c32dd5b92006622cc87", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -1665,6 +1665,11 @@ struct null_assignment_sm_context : public sm_context\n   {\n     delete d;\n   }\n+  void warn (const supernode *, const gimple *,\n+\t     const svalue *, pending_diagnostic *d) FINAL OVERRIDE\n+  {\n+    delete d;\n+  }\n \n   tree get_diagnostic_tree (tree expr) FINAL OVERRIDE\n   {\n@@ -1707,6 +1712,10 @@ struct null_assignment_sm_context : public sm_context\n   {\n     return m_old_state;\n   }\n+  const program_state *get_new_program_state () const FINAL OVERRIDE\n+  {\n+    return m_new_state;\n+  }\n \n   const program_state *m_old_state;\n   const program_state *m_new_state;\n@@ -2048,15 +2057,7 @@ diagnostic_manager::add_events_for_superedge (const path_builder &pb,\n       break;\n \n     case SUPEREDGE_CALL:\n-      {\n-\temission_path->add_event\n-\t  (new call_event (eedge,\n-\t\t\t   (last_stmt\n-\t\t\t    ? last_stmt->location\n-\t\t\t    : UNKNOWN_LOCATION),\n-\t\t\t   src_point.get_fndecl (),\n-\t\t\t   src_stack_depth));\n-      }\n+      pd->add_call_event (eedge, emission_path);\n       break;\n \n     case SUPEREDGE_INTRAPROCEDURAL_CALL:"}, {"sha": "163866229b01f6337728ca1bb3e51a74eceff7b5", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -435,6 +435,23 @@ class impl_sm_context : public sm_context\n        var, var_old_sval, current, d);\n   }\n \n+  void warn (const supernode *snode, const gimple *stmt,\n+\t     const svalue *sval, pending_diagnostic *d) FINAL OVERRIDE\n+  {\n+    LOG_FUNC (get_logger ());\n+    gcc_assert (d); // take ownership\n+    impl_region_model_context old_ctxt\n+      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, NULL, NULL);\n+\n+    state_machine::state_t current\n+      = (sval\n+\t ? m_old_smap->get_state (sval, m_eg.get_ext_state ())\n+\t : m_old_smap->get_global_state ());\n+    m_eg.get_diagnostic_manager ().add_diagnostic\n+      (&m_sm, m_enode_for_diag, snode, stmt, m_stmt_finder,\n+       NULL_TREE, sval, current, d);\n+  }\n+\n   /* Hook for picking more readable trees for SSA names of temporaries,\n      so that rather than e.g.\n        \"double-free of '<unknown>'\"\n@@ -512,6 +529,11 @@ class impl_sm_context : public sm_context\n     return m_old_state;\n   }\n \n+  const program_state *get_new_program_state () const FINAL OVERRIDE\n+  {\n+    return m_new_state;\n+  }\n+\n   log_user m_logger;\n   exploded_graph &m_eg;\n   exploded_node *m_enode_for_diag;"}, {"sha": "eff050f675774bf454d742ff1bbb6a8f65d96231", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -33,12 +33,30 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n #include \"selftest.h\"\n #include \"tristate.h\"\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"cpplib.h\"\n+#include \"digraph.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"diagnostic-path.h\"\n+#include \"analyzer/checker-path.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -111,6 +129,70 @@ pending_diagnostic::same_tree_p (tree t1, tree t2)\n   return simple_cst_equal (t1, t2) == 1;\n }\n \n+/* Return true iff IDENT is STR.  */\n+\n+static bool\n+ht_ident_eq (ht_identifier ident, const char *str)\n+{\n+  return (strlen (str) == ident.len\n+\t  && 0 == strcmp (str, (const char *)ident.str));\n+}\n+\n+/* Return true if we should show the expansion location rather than unwind\n+   within MACRO.  */\n+\n+static bool\n+fixup_location_in_macro_p (cpp_hashnode *macro)\n+{\n+  ht_identifier ident = macro->ident;\n+  /* Don't unwind inside <stdarg.h> macros, so that we don't suppress warnings\n+     from them (due to being in system headers).  */\n+  if (ht_ident_eq (ident, \"va_start\")\n+      || ht_ident_eq (ident, \"va_copy\")\n+      || ht_ident_eq (ident, \"va_arg\")\n+      || ht_ident_eq (ident, \"va_end\"))\n+    return true;\n+  return false;\n+}\n+\n+/* Base implementation of pending_diagnostic::fixup_location.\n+   Don't unwind inside macros for which fixup_location_in_macro_p is true.  */\n+\n+location_t\n+pending_diagnostic::fixup_location (location_t loc) const\n+{\n+  if (linemap_location_from_macro_expansion_p (line_table, loc))\n+    {\n+      line_map *map\n+\t= const_cast <line_map *> (linemap_lookup (line_table, loc));\n+      const line_map_macro *macro_map = linemap_check_macro (map);\n+      if (fixup_location_in_macro_p (macro_map->macro))\n+\tloc = linemap_resolve_location (line_table, loc,\n+\t\t\t\t\tLRK_MACRO_EXPANSION_POINT, NULL);\n+    }\n+  return loc;\n+}\n+\n+/* Base implementation of pending_diagnostic::add_call_event.\n+   Add a call_event to EMISSION_PATH.  */\n+\n+void\n+pending_diagnostic::add_call_event (const exploded_edge &eedge,\n+\t\t\t\t    checker_path *emission_path)\n+{\n+  const exploded_node *src_node = eedge.m_src;\n+  const program_point &src_point = src_node->get_point ();\n+  const int src_stack_depth = src_point.get_stack_depth ();\n+  const gimple *last_stmt = src_point.get_supernode ()->get_last_stmt ();\n+  emission_path->add_event\n+    (new call_event (eedge,\n+\t\t     (last_stmt\n+\t\t      ? last_stmt->location\n+\t\t      : UNKNOWN_LOCATION),\n+\t\t     src_point.get_fndecl (),\n+\t\t     src_stack_depth));\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "17db9fede95ad8b1c7c43d180e1b0392b5be7454", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -203,10 +203,7 @@ class pending_diagnostic\n   /* A vfunc for fixing up locations (both the primary location for the\n      diagnostic, and for events in their paths), e.g. to avoid unwinding\n      inside specific macros.  */\n-  virtual location_t fixup_location (location_t loc) const\n-  {\n-    return loc;\n-  }\n+  virtual location_t fixup_location (location_t loc) const;\n \n   /* For greatest precision-of-wording, the various following \"describe_*\"\n      virtual functions give the pending diagnostic a way to describe events\n@@ -295,6 +292,12 @@ class pending_diagnostic\n     return false;\n   }\n \n+  /* Vfunc for adding a call_event to a checker_path, so that e.g.\n+     the varargs diagnostics can add a custom event subclass that annotates\n+     the variadic arguments.  */\n+  virtual void add_call_event (const exploded_edge &,\n+\t\t\t       checker_path *);\n+\n   /* Vfunc for determining that this pending_diagnostic supercedes OTHER,\n      and that OTHER should therefore not be emitted.\n      They have already been tested for being at the same stmt.  */"}, {"sha": "a76caf73133556838e99a53cae508a1e62c31f75", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -57,6 +57,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/call-info.h\"\n+#include \"analyzer/sm.h\"\n+#include \"diagnostic-path.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n #include \"gimple-pretty-print.h\"\n \n #if ENABLE_ANALYZER"}, {"sha": "3377f15feac94f39d235e334f2f59ab25d7fbc91", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -1601,6 +1601,25 @@ region_model_manager::get_bit_range (const region *parent, tree type,\n   return bit_range_reg;\n }\n \n+/* Return the region that describes accessing the IDX-th variadic argument\n+   within PARENT_FRAME, creating it if necessary.  */\n+\n+const var_arg_region *\n+region_model_manager::get_var_arg_region (const frame_region *parent_frame,\n+\t\t\t\t\t  unsigned idx)\n+{\n+  gcc_assert (parent_frame);\n+\n+  var_arg_region::key_t key (parent_frame, idx);\n+  if (var_arg_region *reg = m_var_arg_regions.get (key))\n+    return reg;\n+\n+  var_arg_region *var_arg_reg\n+    = new var_arg_region (alloc_region_id (), parent_frame, idx);\n+  m_var_arg_regions.put (key, var_arg_reg);\n+  return var_arg_reg;\n+}\n+\n /* If we see a tree code we don't know how to handle, rather than\n    ICE or generate bogus results, create a dummy region, and notify\n    CTXT so that it can mark the new state as being not properly\n@@ -1773,6 +1792,7 @@ region_model_manager::log_stats (logger *logger, bool show_objs) const\n   log_uniq_map (logger, show_objs, \"symbolic_region\", m_symbolic_regions);\n   log_uniq_map (logger, show_objs, \"string_region\", m_string_map);\n   log_uniq_map (logger, show_objs, \"bit_range_region\", m_bit_range_regions);\n+  log_uniq_map (logger, show_objs, \"var_arg_region\", m_var_arg_regions);\n   logger->log (\"  # managed dynamic regions: %i\",\n \t       m_managed_dynamic_regions.length ());\n   m_store_mgr.log_stats (logger, show_objs);"}, {"sha": "de221c3014c5ca4abfe02a9673ddf5051986d5d7", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -1342,6 +1342,9 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t return false;\n        case IFN_UBSAN_BOUNDS:\n \t return false;\n+       case IFN_VA_ARG:\n+\t impl_call_va_arg (cd);\n+\t return false;\n        }\n     }\n \n@@ -1428,6 +1431,13 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t       on the return value.  */\n \t    check_call_args (cd);\n \t    break;\n+\n+\t  case BUILT_IN_VA_START:\n+\t    impl_call_va_start (cd);\n+\t    return false;\n+\t  case BUILT_IN_VA_COPY:\n+\t    impl_call_va_copy (cd);\n+\t    return false;\n \t  }\n       else if (is_named_call_p (callee_fndecl, \"malloc\", call, 1))\n \t{\n@@ -1570,6 +1580,10 @@ region_model::on_call_post (const gcall *call,\n \t  case BUILT_IN_REALLOC:\n \t    impl_call_realloc (cd);\n \t    return;\n+\n+\t  case BUILT_IN_VA_END:\n+\t    impl_call_va_end (cd);\n+\t    return;\n \t  }\n     }\n \n@@ -3520,6 +3534,7 @@ region_model::get_representative_path_var_1 (const region *reg,\n \treturn path_var (string_reg->get_string_cst (), 0);\n       }\n \n+    case RK_VAR_ARG:\n     case RK_UNKNOWN:\n       return path_var (NULL_TREE, 0);\n     }\n@@ -3888,6 +3903,17 @@ region_model::push_frame (function *fun, const vec<const svalue *> *arg_svals,\n \t  const svalue *arg_sval = (*arg_svals)[idx];\n \t  set_value (parm_reg, arg_sval, ctxt);\n \t}\n+\n+      /* Handle any variadic args.  */\n+      unsigned va_arg_idx = 0;\n+      for (; idx < arg_svals->length (); idx++, va_arg_idx++)\n+\t{\n+\t  const svalue *arg_sval = (*arg_svals)[idx];\n+\t  const region *var_arg_reg\n+\t    = m_mgr->get_var_arg_region (m_current_frame,\n+\t\t\t\t\t va_arg_idx);\n+\t  set_value (var_arg_reg, arg_sval, ctxt);\n+\t}\n     }\n   else\n     {"}, {"sha": "4e5cb46a649d4ead5baffdce2cc7b5a342da7f3f", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -326,6 +326,8 @@ class region_model_manager\n   const string_region *get_region_for_string (tree string_cst);\n   const region *get_bit_range (const region *parent, tree type,\n \t\t\t       const bit_range &bits);\n+  const var_arg_region *get_var_arg_region (const frame_region *parent,\n+\t\t\t\t\t    unsigned idx);\n \n   const region *get_unknown_symbolic_region (tree region_type);\n \n@@ -488,6 +490,7 @@ class region_model_manager\n   string_map_t m_string_map;\n \n   consolidation_map<bit_range_region> m_bit_range_regions;\n+  consolidation_map<var_arg_region> m_var_arg_regions;\n \n   store_manager m_store_mgr;\n \n@@ -627,6 +630,12 @@ class region_model\n   void impl_call_operator_delete (const call_details &cd);\n   void impl_deallocation_call (const call_details &cd);\n \n+  /* Implemented in varargs.cc.  */\n+  void impl_call_va_start (const call_details &cd);\n+  void impl_call_va_copy (const call_details &cd);\n+  void impl_call_va_arg (const call_details &cd);\n+  void impl_call_va_end (const call_details &cd);\n+\n   void handle_unrecognized_call (const gcall *call,\n \t\t\t\t region_model_context *ctxt);\n   void get_reachable_svalues (svalue_set *out,"}, {"sha": "a8286231d30e0098d042fd229620cabe1fa83e29", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -1541,9 +1541,9 @@ void\n alloca_region::dump_to_pp (pretty_printer *pp, bool simple) const\n {\n   if (simple)\n-    pp_string (pp, \"ALLOCA_REGION\");\n+    pp_printf (pp, \"ALLOCA_REGION(%i)\", get_id ());\n   else\n-    pp_string (pp, \"alloca_region()\");\n+    pp_printf (pp, \"alloca_region(%i)\", get_id ());\n }\n \n /* class string_region : public region.  */\n@@ -1637,6 +1637,34 @@ bit_range_region::get_relative_concrete_offset (bit_offset_t *out) const\n   return true;\n }\n \n+/* class var_arg_region : public region.  */\n+\n+void\n+var_arg_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"VAR_ARG_REG(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_printf (pp, \", arg_idx: %d)\", m_idx);\n+    }\n+  else\n+    {\n+      pp_string (pp, \"var_arg_region(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_printf (pp, \", arg_idx: %d)\", m_idx);\n+    }\n+}\n+\n+/* Get the frame_region for this var_arg_region.  */\n+\n+const frame_region *\n+var_arg_region::get_frame_region () const\n+{\n+  gcc_assert (get_parent_region ());\n+  return as_a <const frame_region *> (get_parent_region ());\n+}\n+\n /* class unknown_region : public region.  */\n \n /* Implementation of region::dump_to_pp vfunc for unknown_region.  */"}, {"sha": "d32110bf8e34a04be71ad94b40cbf42733ca397e", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -61,7 +61,8 @@ enum region_kind\n   RK_ALLOCA,\n   RK_STRING,\n   RK_BIT_RANGE,\n-  RK_UNKNOWN\n+  RK_VAR_ARG,\n+  RK_UNKNOWN,\n };\n \n /* Region and its subclasses.\n@@ -90,6 +91,7 @@ enum region_kind\n      alloca_region (RK_ALLOCA)\n      string_region (RK_STRING)\n      bit_range_region (RK_BIT_RANGE)\n+     var_arg_region (RK_VAR_ARG)\n      unknown_region (RK_UNKNOWN).  */\n \n /* Abstract base class for representing ways of accessing chunks of memory.\n@@ -131,6 +133,8 @@ class region\n   dyn_cast_string_region () const { return NULL; }\n   virtual const bit_range_region *\n   dyn_cast_bit_range_region () const { return NULL; }\n+  virtual const var_arg_region *\n+  dyn_cast_var_arg_region () const { return NULL; }\n \n   virtual void accept (visitor *v) const;\n \n@@ -1251,6 +1255,87 @@ template <> struct default_hash_traits<bit_range_region::key_t>\n \n namespace ana {\n \n+/* A region for the N-th vararg within a frame_region for a variadic call.  */\n+\n+class var_arg_region : public region\n+{\n+public:\n+  /* A support class for uniquifying instances of var_arg_region.  */\n+  struct key_t\n+  {\n+    key_t (const frame_region *parent, unsigned idx)\n+    : m_parent (parent), m_idx (idx)\n+    {\n+      gcc_assert (parent);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_parent);\n+      hstate.add_int (m_idx);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_parent == other.m_parent\n+\t      && m_idx == other.m_idx);\n+    }\n+\n+    void mark_deleted ()\n+    {\n+      m_parent = reinterpret_cast<const frame_region *> (1);\n+    }\n+    void mark_empty () { m_parent = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_parent == reinterpret_cast<const frame_region *> (1);\n+    }\n+    bool is_empty () const { return m_parent == NULL; }\n+\n+    const frame_region *m_parent;\n+    unsigned m_idx;\n+  };\n+\n+  var_arg_region (unsigned id, const frame_region *parent,\n+\t\t  unsigned idx)\n+  : region (complexity (parent), id, parent, NULL_TREE),\n+    m_idx (idx)\n+  {}\n+\n+  const var_arg_region *\n+  dyn_cast_var_arg_region () const FINAL OVERRIDE { return this; }\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_VAR_ARG; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const frame_region *get_frame_region () const;\n+  unsigned get_index () const { return m_idx; }\n+\n+private:\n+  unsigned m_idx;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const var_arg_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_VAR_ARG;\n+}\n+\n+template <> struct default_hash_traits<var_arg_region::key_t>\n+: public member_function_hash_traits<var_arg_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n /* An unknown region, for handling unimplemented tree codes.  */\n \n class unknown_region : public region"}, {"sha": "622cb0b7ab34c5116380f35c126746f73f5d27bc", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -173,6 +173,7 @@ make_checkers (auto_delete_vec <state_machine> &out, logger *logger)\n     out.safe_push (make_taint_state_machine (logger));\n   out.safe_push (make_sensitive_state_machine (logger));\n   out.safe_push (make_signal_state_machine (logger));\n+  out.safe_push (make_va_list_state_machine (logger));\n \n   /* We only attempt to run the pattern tests if it might have been manually\n      enabled (for DejaGnu purposes).  */"}, {"sha": "4cc54531c56194cdc41732ecb98d7964a369ffed", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -242,6 +242,8 @@ class sm_context\n      issue a diagnostic D using NODE and STMT for location information.  */\n   virtual void warn (const supernode *node, const gimple *stmt,\n \t\t     tree var, pending_diagnostic *d) = 0;\n+  virtual void warn (const supernode *node, const gimple *stmt,\n+\t\t     const svalue *var, pending_diagnostic *d) = 0;\n \n   /* For use when generating trees when creating pending_diagnostics, so that\n      rather than e.g.\n@@ -275,8 +277,7 @@ class sm_context\n   virtual bool unknown_side_effects_p () const { return false; }\n \n   virtual const program_state *get_old_program_state () const = 0;\n-\n-  const svalue *get_old_svalue (tree expr) const;\n+  virtual const program_state *get_new_program_state () const = 0;\n \n protected:\n   sm_context (int sm_idx, const state_machine &sm)\n@@ -299,6 +300,7 @@ extern state_machine *make_taint_state_machine (logger *logger);\n extern state_machine *make_sensitive_state_machine (logger *logger);\n extern state_machine *make_signal_state_machine (logger *logger);\n extern state_machine *make_pattern_test_state_machine (logger *logger);\n+extern state_machine *make_va_list_state_machine (logger *logger);\n \n } // namespace ana\n "}, {"sha": "de77fe5d3ede11a8b2f8d4c5f7e729e5201406b6", "filename": "gcc/analyzer/varargs.cc", "status": "added", "additions": 1025, "deletions": 0, "changes": 1025, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,1025 @@\n+/* Implementation of <stdarg.h> within analyzer.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"diagnostic-path.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/checker-path.h\"\n+#include \"digraph.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"cfg.h\"\n+#include \"gimple-iterator.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/exploded-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Implementation of <stdarg.h> within analyzer.\n+\n+   Objectives:\n+   - detection of interprocedural type errors involving va_arg\n+   - tracking of symbolic values interprocedurally from variadic call\n+     through to va_arg unpacking\n+   - detection of missing va_end\n+   - detection of va_arg outside of a va_start/va_end pair\n+   - detection of uses of a va_list after the frame in containing the\n+     va_start has returned\n+\n+   The analyzer runs *before* the \"stdarg\" and \"lower_vaarg\" gimple\n+   passes, which have target-dependent effects.\n+\n+   This file implements a state machine on svalues for tracking when\n+   va_start has been called, so that we can detect missing va_end,\n+   and misplaced va_arg, etc.\n+   To do this requires an svalue that can have state, so we implement va_start\n+   by creating a stack-allocated region, and use a pointer to that region\n+   as the svalue that has state.\n+\n+   We call this stack-allocated region the \"impl_reg\".  Allocating it on\n+   the stack ensures that it is invalidated when the frame containing\n+   the va_start returns, leading to\n+   -Wanalyzer-use-of-pointer-in-stale-stack-frame on attempts to use such\n+   a va_list.\n+\n+   To track svalues from variadic calls interprocedurally, we implement\n+   variadic arguments via new child regions of the callee's frame_region,\n+   var_arg_region, each one representing a storage slot for one of the\n+   variadic arguments, accessed by index.\n+\n+   We have:\n+\n+    stack frame:\n+      va_list: &impl_reg\n+      'impl_reg': pointer to next var_arg_region\n+      var_arg_region for arg 0\n+      ...\n+      var_arg_region for arg N-1\n+\n+   Hence given test_1 in stdarg-1.c, at the call to:\n+\n+     __analyzer_called_by_test_1 (int placeholder, ...);\n+\n+   here:\n+\n+     __analyzer_called_by_test_1 (42, \"foo\", 1066, '@');\n+\n+   we push this frame for the called function:\n+     clusters within frame: \u2018__analyzer_called_by_test_1\u2019@2\n+       cluster for: placeholder: (int)42\n+       cluster for: VAR_ARG_REG(frame: \u2018__analyzer_called_by_test_1\u2019@2, arg_idx: 0): &\"foo\" (TOUCHED)\n+       cluster for: VAR_ARG_REG(frame: \u2018__analyzer_called_by_test_1\u2019@2, arg_idx: 1): (int)1066 (TOUCHED)\n+       cluster for: VAR_ARG_REG(frame: \u2018__analyzer_called_by_test_1\u2019@2, arg_idx: 2): (int)64 (TOUCHED)\n+   where the called function's frame has been populated with both the value\n+   of the regular argument \"placeholder\", and with values for 3 variadic\n+   arguments.\n+\n+   At the call to\n+      va_start (ap, placeholder);\n+   we allocate a region ALLOCA_REGION for ap to point to, populate that\n+   region with the address of variadic argument 0, and set sm-state of\n+   &ALLOCA_REGION to \"started\":\n+    clusters within frame: \u2018__analyzer_called_by_test_1\u2019@2\n+      cluster for: placeholder: (int)42\n+      cluster for: VAR_ARG_REG(frame: \u2018__analyzer_called_by_test_1\u2019@2, arg_idx: 0): &\"foo\" (TOUCHED)\n+      cluster for: VAR_ARG_REG(frame: \u2018__analyzer_called_by_test_1\u2019@2, arg_idx: 1): (int)1066 (TOUCHED)\n+      cluster for: VAR_ARG_REG(frame: \u2018__analyzer_called_by_test_1\u2019@2, arg_idx: 2): (int)64 (TOUCHED)\n+      cluster for: ap: &ALLOCA_REGION\n+      cluster for: ALLOCA_REGION: &VAR_ARG_REG(frame: \u2018__analyzer_called_by_test_1\u2019@2, arg_idx: 0) (TOUCHED)\n+    va_list:\n+      0x4c83700: &ALLOCA_REGION: started\n+\n+   At each call to\n+     va_arg (ap, TYPE);\n+   we can look within *ap, locate the region holding the next variadic\n+   argument to be extracted, extract the svalue, and advance the index\n+   by effectively updating *ap.\n+\n+   At the va_end, we can set &ALLOCA_REGION's state to \"ended\".\n+\n+   The various __builtin_va_* accept ap by pointer, so we have e.g.:\n+\n+     __builtin_va_start (&ap, [...]);\n+\n+   except for the 2nd param of __builtin_va_copy, where the type\n+   is already target-dependent (see the discussion of BT_VALIST_ARG\n+   below).  */\n+\n+/* Get a tree for diagnostics.\n+   Typically we have \"&ap\", but it will make more sense to\n+   the user as just \"ap\", so strip off the ADDR_EXPR.  */\n+\n+static tree\n+get_va_list_diag_arg (tree va_list_tree)\n+{\n+  if (TREE_CODE (va_list_tree) == ADDR_EXPR)\n+    va_list_tree = TREE_OPERAND (va_list_tree, 0);\n+  return va_list_tree;\n+}\n+\n+/* Get argument ARG_IDX of type BT_VALIST_ARG (for use by va_copy).\n+\n+   builtin-types.def has:\n+     DEF_PRIMITIVE_TYPE (BT_VALIST_ARG, va_list_arg_type_node)\n+\n+   and c_common_nodes_and_builtins initializes va_list_arg_type_node\n+   based on whether TREE_CODE (va_list_type_node) is of ARRAY_TYPE or\n+   not, giving either one or zero levels of indirection.  */\n+\n+static const svalue *\n+get_BT_VALIST_ARG (const region_model *model,\n+\t\t   region_model_context *ctxt,\n+\t\t   const gcall *call,\n+\t\t   unsigned arg_idx)\n+{\n+  tree arg = gimple_call_arg (call, arg_idx);\n+  const svalue *arg_sval = model->get_rvalue (arg, ctxt);\n+  if (const svalue *cast = arg_sval->maybe_undo_cast ())\n+    arg_sval = cast;\n+  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n+    {\n+      /* va_list_arg_type_node is a pointer to a va_list;\n+\t return *ARG_SVAL.  */\n+      const region *src_reg = model->deref_rvalue (arg_sval, arg, ctxt);\n+      const svalue *src_reg_sval = model->get_store_value (src_reg, ctxt);\n+      if (const svalue *cast = src_reg_sval->maybe_undo_cast ())\n+\tsrc_reg_sval = cast;\n+      return src_reg_sval;\n+    }\n+  else\n+    {\n+      /* va_list_arg_type_node is a va_list; return ARG_SVAL.  */\n+      return arg_sval;\n+    }\n+}\n+\n+namespace {\n+\n+/* A state machine for tracking the state of a va_list, so that\n+   we can enforce that each va_start is paired with a va_end,\n+   and va_arg only happens within a va_start/va_end pair.\n+   Specifically, this tracks the state of the &ALLOCA_BUFFER\n+   that va_start/va_copy allocate.  */\n+\n+class va_list_state_machine : public state_machine\n+{\n+public:\n+  va_list_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return false; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE\n+  {\n+    return s != m_started;\n+  }\n+  pending_diagnostic *on_leak (tree var) const FINAL OVERRIDE;\n+\n+  /* State for a va_list that the result of a va_start or va_copy.  */\n+  state_t m_started;\n+\n+  /* State for a va_list that has had va_end called on it.  */\n+  state_t m_ended;\n+\n+private:\n+  void on_va_start (sm_context *sm_ctxt, const supernode *node,\n+\t\t    const gcall *call) const;\n+  void on_va_copy (sm_context *sm_ctxt, const supernode *node,\n+\t\t   const gcall *call) const;\n+  void on_va_arg (sm_context *sm_ctxt, const supernode *node,\n+\t\t  const gcall *call) const;\n+  void on_va_end (sm_context *sm_ctxt, const supernode *node,\n+\t\t  const gcall *call) const;\n+  void check_for_ended_va_list (sm_context *sm_ctxt,\n+\t\t\t\tconst supernode *node,\n+\t\t\t\tconst gcall *call,\n+\t\t\t\tconst svalue *arg,\n+\t\t\t\tconst char *usage_fnname) const;\n+};\n+\n+/* va_list_state_machine's ctor.  */\n+\n+va_list_state_machine::va_list_state_machine (logger *logger)\n+: state_machine (\"va_list\", logger)\n+{\n+  m_started = add_state (\"started\");\n+  m_ended = add_state (\"ended\");\n+}\n+\n+/* Implementation of the various \"va_*\" functions for\n+   va_list_state_machine.  */\n+\n+bool\n+va_list_state_machine::on_stmt (sm_context *sm_ctxt,\n+\t\t\t\tconst supernode *node,\n+\t\t\t\tconst gimple *stmt) const\n+{\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    {\n+      if (gimple_call_internal_p (call)\n+\t  && gimple_call_internal_fn (call) == IFN_VA_ARG)\n+\t{\n+\t  on_va_arg (sm_ctxt, node, call);\n+\t  return false;\n+\t}\n+\n+      if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+\tif (fndecl_built_in_p (callee_fndecl, BUILT_IN_NORMAL)\n+\t    && gimple_builtin_call_types_compatible_p (call, callee_fndecl))\n+\t  switch (DECL_UNCHECKED_FUNCTION_CODE (callee_fndecl))\n+\t    {\n+\t    default:\n+\t      break;\n+\n+\t    case BUILT_IN_VA_START:\n+\t      on_va_start (sm_ctxt, node, call);\n+\t      break;\n+\n+\t    case BUILT_IN_VA_COPY:\n+\t      on_va_copy (sm_ctxt, node, call);\n+\t      break;\n+\n+\t    case BUILT_IN_VA_END:\n+\t      on_va_end (sm_ctxt, node, call);\n+\t      break;\n+\t    }\n+    }\n+  return false;\n+}\n+\n+/* Get the svalue for which va_list_state_machine holds state on argument ARG_\n+   IDX to CALL.  */\n+\n+static const svalue *\n+get_stateful_arg (sm_context *sm_ctxt, const gcall *call, unsigned arg_idx)\n+{\n+  tree ap = gimple_call_arg (call, arg_idx);\n+  if (ap\n+      && POINTER_TYPE_P (TREE_TYPE (ap)))\n+    {\n+      if (const program_state *new_state = sm_ctxt->get_new_program_state ())\n+\t{\n+\t  const region_model *new_model = new_state->m_region_model;\n+\t  const svalue *ptr_sval = new_model->get_rvalue (ap, NULL);\n+\t  const region *reg = new_model->deref_rvalue (ptr_sval, ap, NULL);\n+\t  const svalue *impl_sval = new_model->get_store_value (reg, NULL);\n+\t  if (const svalue *cast = impl_sval->maybe_undo_cast ())\n+\t    impl_sval = cast;\n+\t  return impl_sval;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+/* Abstract class for diagnostics relating to va_list_state_machine.  */\n+\n+class va_list_sm_diagnostic : public pending_diagnostic\n+{\n+public:\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    const va_list_sm_diagnostic &other\n+      = (const va_list_sm_diagnostic &)base_other;\n+    return (m_ap_sval == other.m_ap_sval\n+\t    && same_tree_p (m_ap_tree, other.m_ap_tree));\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    OVERRIDE\n+  {\n+    if (const char *fnname = maybe_get_fnname (change))\n+      return change.formatted_print (\"%qs called here\", fnname);\n+    return label_text ();\n+  }\n+\n+protected:\n+  va_list_sm_diagnostic (const va_list_state_machine &sm,\n+\t\t\t const svalue *ap_sval, tree ap_tree)\n+    : m_sm (sm), m_ap_sval (ap_sval), m_ap_tree (ap_tree)\n+  {}\n+\n+  static const char *maybe_get_fnname (const evdesc::state_change &change)\n+  {\n+    if (change.m_event.m_stmt)\n+      if (const gcall *call = as_a <const gcall *> (change.m_event.m_stmt))\n+\tif (tree callee_fndecl = gimple_call_fndecl (call))\n+\t  {\n+\t    if (fndecl_built_in_p (callee_fndecl, BUILT_IN_NORMAL))\n+\t      switch (DECL_UNCHECKED_FUNCTION_CODE (callee_fndecl))\n+\t\t{\n+\t\tcase BUILT_IN_VA_START:\n+\t\t  return \"va_start\";\n+\t\tcase BUILT_IN_VA_COPY:\n+\t\t  return \"va_copy\";\n+\t\tcase BUILT_IN_VA_END:\n+\t\t  return \"va_end\";\n+\t\t}\n+\t  }\n+    return NULL;\n+  }\n+\n+  const va_list_state_machine &m_sm;\n+  const svalue *m_ap_sval;\n+  tree m_ap_tree;\n+};\n+\n+/* Concrete class for -Wanalyzer-va-list-use-after-va-end:\n+   complain about use of a va_list after va_end has been called on it.  */\n+\n+class va_list_use_after_va_end : public va_list_sm_diagnostic\n+{\n+public:\n+  va_list_use_after_va_end (const va_list_state_machine &sm,\n+\t\t\t    const svalue *ap_sval, tree ap_tree,\n+\t\t\t    const char *usage_fnname)\n+  : va_list_sm_diagnostic (sm, ap_sval, ap_tree),\n+    m_usage_fnname (usage_fnname)\n+  {\n+  }\n+\n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_va_list_use_after_va_end;\n+  }\n+\n+  bool operator== (const va_list_use_after_va_end &other) const\n+  {\n+    return (va_list_sm_diagnostic::subclass_equal_p (other)\n+\t    && 0 == strcmp (m_usage_fnname, other.m_usage_fnname));\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    return warning_at (rich_loc, get_controlling_option (),\n+\t\t       \"%qs after %qs\", m_usage_fnname, \"va_end\");\n+  }\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"va_list_use_after_va_end\";\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_ended)\n+      m_va_end_event = change.m_event_id;\n+    return va_list_sm_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (ev.m_expr)\n+      {\n+\tif (m_va_end_event.known_p ())\n+\t  return ev.formatted_print\n+\t    (\"%qs on %qE after %qs at %@\",\n+\t     m_usage_fnname, ev.m_expr, \"va_end\", &m_va_end_event);\n+\telse\n+\t  return ev.formatted_print\n+\t    (\"%qs on %qE after %qs\",\n+\t     m_usage_fnname, ev.m_expr, \"va_end\");\n+      }\n+    else\n+      {\n+\tif (m_va_end_event.known_p ())\n+\t  return ev.formatted_print\n+\t    (\"%qs after %qs at %@\",\n+\t     m_usage_fnname, \"va_end\", &m_va_end_event);\n+\telse\n+\t  return ev.formatted_print\n+\t    (\"%qs after %qs\",\n+\t     m_usage_fnname, \"va_end\");\n+      }\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_va_end_event;\n+  const char *m_usage_fnname;\n+};\n+\n+/* Concrete class for -Wanalyzer-va-list-leak:\n+   complain about a va_list in the \"started\" state that doesn't get after\n+   va_end called on it.  */\n+\n+class va_list_leak : public va_list_sm_diagnostic\n+{\n+public:\n+  va_list_leak (const va_list_state_machine &sm,\n+\t\tconst svalue *ap_sval, tree ap_tree)\n+  : va_list_sm_diagnostic (sm, ap_sval, ap_tree),\n+    m_start_event_fnname (NULL)\n+  {\n+  }\n+\n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_va_list_leak;\n+  }\n+\n+  bool operator== (const va_list_leak &other) const\n+  {\n+    return va_list_sm_diagnostic::subclass_equal_p (other);\n+  }\n+\n+  bool emit (rich_location *rich_loc)\n+  {\n+    auto_diagnostic_group d;\n+    return warning_at (rich_loc, get_controlling_option (),\n+\t\t       \"missing call to %qs\", \"va_end\");\n+  }\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"va_list_leak\"; }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_started)\n+      {\n+\tm_start_event = change.m_event_id;\n+\tm_start_event_fnname = maybe_get_fnname (change);\n+      }\n+    return va_list_sm_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (ev.m_expr)\n+      {\n+\tif (m_start_event.known_p () && m_start_event_fnname)\n+\t  return ev.formatted_print\n+\t    (\"missing call to %qs on %qE to match %qs at %@\",\n+\t     \"va_end\", ev.m_expr, m_start_event_fnname, &m_start_event);\n+\telse\n+\t  return ev.formatted_print\n+\t    (\"missing call to %qs on %qE\",\n+\t     \"va_end\", ev.m_expr);\n+      }\n+    else\n+      {\n+\tif (m_start_event.known_p () && m_start_event_fnname)\n+\t  return ev.formatted_print\n+\t    (\"missing call to %qs to match %qs at %@\",\n+\t     \"va_end\", m_start_event_fnname, &m_start_event);\n+\telse\n+\t  return ev.formatted_print\n+\t    (\"missing call to %qs\",\n+\t     \"va_end\");\n+      }\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_start_event;\n+  const char *m_start_event_fnname;\n+};\n+\n+/* Update state machine for a \"va_start\" call.  */\n+\n+void\n+va_list_state_machine::on_va_start (sm_context *sm_ctxt,\n+\t\t\t\t    const supernode *,\n+\t\t\t\t    const gcall *call) const\n+{\n+  const svalue *arg = get_stateful_arg (sm_ctxt, call, 0);\n+  if (arg)\n+    {\n+      /* Transition from start state to \"started\".  */\n+      if (sm_ctxt->get_state (call, arg) == m_start)\n+\tsm_ctxt->set_next_state (call, arg, m_started);\n+    }\n+}\n+\n+/* Complain if ARG is in the \"ended\" state.  */\n+\n+void\n+va_list_state_machine::check_for_ended_va_list (sm_context *sm_ctxt,\n+\t\t\t\t\t\tconst supernode *node,\n+\t\t\t\t\t\tconst gcall *call,\n+\t\t\t\t\t\tconst svalue *arg,\n+\t\t\t\t\t\tconst char *usage_fnname) const\n+{\n+  if (sm_ctxt->get_state (call, arg) == m_ended)\n+    sm_ctxt->warn (node, call, arg,\n+\t\t   new va_list_use_after_va_end (*this, arg, NULL_TREE,\n+\t\t\t\t\t\t usage_fnname));\n+}\n+\n+/* Get the svalue with associated va_list_state_machine state for a\n+   BT_VALIST_ARG for ARG_IDX of CALL, if SM_CTXT supports this,\n+   or NULL otherwise.  */\n+\n+static const svalue *\n+get_stateful_BT_VALIST_ARG (sm_context *sm_ctxt,\n+\t\t\t    const gcall *call,\n+\t\t\t    unsigned arg_idx)\n+{\n+  if (const program_state *new_state = sm_ctxt->get_new_program_state ())\n+    {\n+      const region_model *new_model = new_state->m_region_model;\n+      const svalue *arg = get_BT_VALIST_ARG (new_model, NULL, call, arg_idx);\n+      return arg;\n+    }\n+  return NULL;\n+}\n+\n+/* Update state machine for a \"va_copy\" call.  */\n+\n+void\n+va_list_state_machine::on_va_copy (sm_context *sm_ctxt,\n+\t\t\t\t   const supernode *node,\n+\t\t\t\t   const gcall *call) const\n+{\n+  const svalue *src_arg = get_stateful_BT_VALIST_ARG (sm_ctxt, call, 1);\n+  if (src_arg)\n+    check_for_ended_va_list (sm_ctxt, node, call, src_arg, \"va_copy\");\n+\n+  const svalue *dst_arg = get_stateful_arg (sm_ctxt, call, 0);\n+  if (dst_arg)\n+    {\n+      /* Transition from start state to \"started\".  */\n+      if (sm_ctxt->get_state (call, dst_arg) == m_start)\n+\tsm_ctxt->set_next_state (call, dst_arg, m_started);\n+    }\n+}\n+\n+/* Update state machine for a \"va_arg\" call.  */\n+\n+void\n+va_list_state_machine::on_va_arg (sm_context *sm_ctxt,\n+\t\t\t\t  const supernode *node,\n+\t\t\t\t  const gcall *call) const\n+{\n+  const svalue *arg = get_stateful_arg (sm_ctxt, call, 0);\n+  if (arg)\n+    check_for_ended_va_list (sm_ctxt, node, call, arg, \"va_arg\");\n+}\n+\n+/* Update state machine for a \"va_end\" call.  */\n+\n+void\n+va_list_state_machine::on_va_end (sm_context *sm_ctxt,\n+\t\t\t\t  const supernode *node,\n+\t\t\t\t  const gcall *call) const\n+{\n+  const svalue *arg = get_stateful_arg (sm_ctxt, call, 0);\n+  if (arg)\n+    {\n+      state_t s = sm_ctxt->get_state (call, arg);\n+      /* Transition from \"started\" to \"ended\".  */\n+      if (s == m_started)\n+\tsm_ctxt->set_next_state (call, arg, m_ended);\n+      else if (s == m_ended)\n+\tcheck_for_ended_va_list (sm_ctxt, node, call, arg, \"va_end\");\n+    }\n+}\n+\n+/* Implementation of state_machine::on_leak vfunc for va_list_state_machine\n+   (for complaining about leaks of values in state 'started').  */\n+\n+pending_diagnostic *\n+va_list_state_machine::on_leak (tree var) const\n+{\n+  return new va_list_leak (*this, NULL, var);\n+}\n+\n+} // anonymous namespace\n+\n+/* Internal interface to this file. */\n+\n+state_machine *\n+make_va_list_state_machine (logger *logger)\n+{\n+  return new va_list_state_machine (logger);\n+}\n+\n+/* Handle the on_call_pre part of \"__builtin_va_start\".  */\n+\n+void\n+region_model::impl_call_va_start (const call_details &cd)\n+{\n+  const svalue *out_ptr = cd.get_arg_svalue (0);\n+  const region *out_reg\n+    = deref_rvalue (out_ptr, cd.get_arg_tree (0), cd.get_ctxt ());\n+\n+  /* \"*out_ptr = &IMPL_REGION;\".  */\n+  const region *impl_reg = m_mgr->create_region_for_alloca (m_current_frame);\n+\n+  /* We abuse the types here, since va_list_type isn't\n+     necessarily anything to do with a pointer.  */\n+  const svalue *ptr_to_impl_reg = m_mgr->get_ptr_svalue (NULL_TREE, impl_reg);\n+  set_value (out_reg, ptr_to_impl_reg, cd.get_ctxt ());\n+\n+  /* \"*(&IMPL_REGION) = VA_LIST_VAL (0);\".  */\n+  const region *init_var_arg_reg\n+    = m_mgr->get_var_arg_region (get_current_frame (), 0);\n+  const svalue *ap_sval = m_mgr->get_ptr_svalue (NULL_TREE, init_var_arg_reg);\n+  set_value (impl_reg, ap_sval, cd.get_ctxt ());\n+}\n+\n+/* Handle the on_call_pre part of \"__builtin_va_copy\".  */\n+\n+void\n+region_model::impl_call_va_copy (const call_details &cd)\n+{\n+  const svalue *out_dst_ptr = cd.get_arg_svalue (0);\n+  const svalue *in_va_list\n+    = get_BT_VALIST_ARG (this, cd.get_ctxt (), cd.get_call_stmt (), 1);\n+  in_va_list = check_for_poison (in_va_list,\n+\t\t\t\t get_va_list_diag_arg (cd.get_arg_tree (1)),\n+\t\t\t\t cd.get_ctxt ());\n+\n+  const region *out_dst_reg\n+    = deref_rvalue (out_dst_ptr, cd.get_arg_tree (0), cd.get_ctxt ());\n+\n+  /* \"*out_dst_ptr = &NEW_IMPL_REGION;\".  */\n+  const region *new_impl_reg\n+    = m_mgr->create_region_for_alloca (m_current_frame);\n+  const svalue *ptr_to_new_impl_reg\n+    = m_mgr->get_ptr_svalue (NULL_TREE, new_impl_reg);\n+  set_value (out_dst_reg, ptr_to_new_impl_reg, cd.get_ctxt ());\n+\n+  if (const region *old_impl_reg = in_va_list->maybe_get_region ())\n+    {\n+\n+      /* \"(NEW_IMPL_REGION) = (OLD_IMPL_REGION);\".  */\n+      const svalue *existing_sval\n+\t= get_store_value (old_impl_reg, cd.get_ctxt ());\n+      set_value (new_impl_reg, existing_sval, cd.get_ctxt ());\n+    }\n+}\n+\n+/* Get the number of variadic arguments to CALLEE_FNDECL at CALL_STMT.  */\n+\n+static int\n+get_num_variadic_arguments (tree callee_fndecl,\n+\t\t\t    const gcall *call_stmt)\n+{\n+  int num_positional = 0;\n+  for (tree iter_parm = DECL_ARGUMENTS (callee_fndecl); iter_parm;\n+       iter_parm = DECL_CHAIN (iter_parm))\n+    num_positional++;\n+  return gimple_call_num_args (call_stmt) - num_positional;\n+}\n+\n+/* An abstract subclass of pending_diagnostic for diagnostics relating\n+   to bad va_arg invocations.\n+\n+   This shows the number of variadic arguments at the call of interest.\n+   Ideally we'd also be able to highlight individual arguments, but\n+   that location information isn't generally available from the middle end.  */\n+\n+class va_arg_diagnostic : public pending_diagnostic\n+{\n+public:\n+  /* Override of pending_diagnostic::add_call_event,\n+     adding a custom call_event subclass.  */\n+  void add_call_event (const exploded_edge &eedge,\n+\t\t       checker_path *emission_path) OVERRIDE\n+  {\n+    /* As per call_event, but show the number of variadic arguments\n+       in the call.  */\n+    class va_arg_call_event : public call_event\n+    {\n+    public:\n+      va_arg_call_event (const exploded_edge &eedge,\n+\t\t\t location_t loc, tree fndecl, int depth,\n+\t\t\t int num_variadic_arguments)\n+      : call_event (eedge, loc, fndecl, depth),\n+\tm_num_variadic_arguments (num_variadic_arguments)\n+      {\n+      }\n+\n+      label_text get_desc (bool can_colorize) const OVERRIDE\n+      {\n+\treturn make_label_text_n\n+\t  (can_colorize, m_num_variadic_arguments,\n+\t   \"calling %qE from %qE with %i variadic argument\",\n+\t   \"calling %qE from %qE with %i variadic arguments\",\n+\t   get_callee_fndecl (),\n+\t   get_caller_fndecl (),\n+\t   m_num_variadic_arguments);\n+      }\n+    private:\n+      int m_num_variadic_arguments;\n+    };\n+\n+    const frame_region *frame_reg = m_var_arg_reg->get_frame_region ();\n+    const exploded_node *dst_node = eedge.m_dest;\n+    if (dst_node->get_state ().m_region_model->get_current_frame ()\n+\t== frame_reg)\n+      {\n+\tconst exploded_node *src_node = eedge.m_src;\n+\tconst program_point &src_point = src_node->get_point ();\n+\tconst int src_stack_depth = src_point.get_stack_depth ();\n+\tconst gimple *last_stmt = src_point.get_supernode ()->get_last_stmt ();\n+\tconst gcall *call_stmt = as_a <const gcall *> (last_stmt);\n+\tint num_variadic_arguments\n+\t  = get_num_variadic_arguments (dst_node->get_function ()->decl,\n+\t\t\t\t\tcall_stmt);\n+\temission_path->add_event\n+\t  (new va_arg_call_event (eedge,\n+\t\t\t\t  (last_stmt\n+\t\t\t\t   ? last_stmt->location\n+\t\t\t\t   : UNKNOWN_LOCATION),\n+\t\t\t\t  src_point.get_fndecl (),\n+\t\t\t\t  src_stack_depth,\n+\t\t\t\t  num_variadic_arguments));\n+      }\n+    else\n+      pending_diagnostic::add_call_event (eedge, emission_path);\n+  }\n+\n+protected:\n+  va_arg_diagnostic (tree va_list_tree, const var_arg_region *var_arg_reg)\n+  : m_va_list_tree (va_list_tree), m_var_arg_reg (var_arg_reg)\n+  {}\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    const va_arg_diagnostic &other = (const va_arg_diagnostic &)base_other;\n+    return (same_tree_p (m_va_list_tree, other.m_va_list_tree)\n+\t    && m_var_arg_reg == other.m_var_arg_reg);\n+  }\n+\n+  /* Get the number of arguments consumed so far from the va_list\n+     (*before* this va_arg call).  */\n+  unsigned get_num_consumed () const\n+  {\n+    return m_var_arg_reg->get_index ();\n+  }\n+\n+  /* Get a 1-based index of which variadic argument is being consumed.  */\n+  unsigned get_variadic_index_for_diagnostic () const\n+  {\n+    return get_num_consumed () + 1;\n+  }\n+\n+  /* User-readable expr for the va_list argument to va_arg.  */\n+  tree m_va_list_tree;\n+\n+  /* The region that the va_arg attempted to access.  */\n+  const var_arg_region *m_var_arg_reg;\n+};\n+\n+/* A subclass of pending_diagnostic for complaining about a type mismatch\n+   between the result of:\n+     va_arg (AP);\n+   and the type of the argument that was passed to the variadic call.  */\n+\n+class va_arg_type_mismatch : public va_arg_diagnostic\n+{\n+public:\n+  va_arg_type_mismatch (tree va_list_tree, const var_arg_region *var_arg_reg,\n+\t\t\ttree expected_type, tree actual_type)\n+  : va_arg_diagnostic (va_list_tree, var_arg_reg),\n+    m_expected_type (expected_type), m_actual_type (actual_type)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"va_arg_type_mismatch\";\n+  }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other)\n+    const FINAL OVERRIDE\n+  {\n+    if (!va_arg_diagnostic::subclass_equal_p (base_other))\n+      return false;\n+    const va_arg_type_mismatch &other\n+      = (const va_arg_type_mismatch &)base_other;\n+    return (same_tree_p (m_expected_type, other.m_expected_type)\n+\t    && same_tree_p (m_actual_type, other.m_actual_type));\n+  }\n+\n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_va_arg_type_mismatch;\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    bool warned\n+      = warning_at (rich_loc, get_controlling_option (),\n+\t\t    \"%<va_arg%> expected %qT but received %qT\"\n+\t\t    \" for variadic argument %i of %qE\",\n+\t\t    m_expected_type, m_actual_type,\n+\t\t    get_variadic_index_for_diagnostic (), m_va_list_tree);\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"%<va_arg%> expected %qT but received %qT\"\n+\t\t\t       \" for variadic argument %i of %qE\",\n+\t\t\t       m_expected_type, m_actual_type,\n+\t\t\t       get_variadic_index_for_diagnostic (),\n+\t\t\t       m_va_list_tree);\n+  }\n+\n+private:\n+  tree m_expected_type;\n+  tree m_actual_type;\n+};\n+\n+/* A subclass of pending_diagnostic for complaining about a\n+     va_arg (AP);\n+   after all of the args in AP have been consumed.  */\n+\n+class va_list_exhausted : public va_arg_diagnostic\n+{\n+public:\n+  va_list_exhausted (tree va_list_tree, const var_arg_region *var_arg_reg)\n+  : va_arg_diagnostic (va_list_tree, var_arg_reg)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"va_list_exhausted\";\n+  }\n+\n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_va_list_exhausted;\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    bool warned = warning_at (rich_loc, get_controlling_option (),\n+\t\t\t      \"%qE has no more arguments (%i consumed)\",\n+\t\t\t      m_va_list_tree, get_num_consumed ());\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"%qE has no more arguments (%i consumed)\",\n+\t\t\t       m_va_list_tree, get_num_consumed ());\n+  }\n+};\n+\n+/* Return true if it's OK to copy a value from ARG_TYPE to LHS_TYPE via\n+   va_arg (where argument promotion has already happened).  */\n+\n+static bool\n+va_arg_compatible_types_p (tree lhs_type, tree arg_type)\n+{\n+  return compat_types_p (arg_type, lhs_type);\n+}\n+\n+/* If AP_SVAL is a pointer to a var_arg_region, return that var_arg_region.\n+   Otherwise return NULL.  */\n+\n+static const var_arg_region *\n+maybe_get_var_arg_region (const svalue *ap_sval)\n+{\n+  if (const region *reg = ap_sval->maybe_get_region ())\n+    return reg->dyn_cast_var_arg_region ();\n+  return NULL;\n+}\n+\n+/* Handle the on_call_pre part of \"__builtin_va_arg\".  */\n+\n+void\n+region_model::impl_call_va_arg (const call_details &cd)\n+{\n+  region_model_context *ctxt = cd.get_ctxt ();\n+\n+  const svalue *in_ptr = cd.get_arg_svalue (0);\n+  const region *ap_reg = deref_rvalue (in_ptr, cd.get_arg_tree (0), ctxt);\n+\n+  const svalue *ap_sval = get_store_value (ap_reg, ctxt);\n+  if (const svalue *cast = ap_sval->maybe_undo_cast ())\n+    ap_sval = cast;\n+\n+  tree va_list_tree = get_va_list_diag_arg (cd.get_arg_tree (0));\n+  ap_sval = check_for_poison (ap_sval, va_list_tree, ctxt);\n+\n+  if (const region *impl_reg = ap_sval->maybe_get_region ())\n+    {\n+      const svalue *old_impl_sval = get_store_value (impl_reg, ctxt);\n+      if (const var_arg_region *arg_reg\n+\t  = maybe_get_var_arg_region (old_impl_sval))\n+\t{\n+\t  bool saw_problem = false;\n+\n+\t  const frame_region *frame_reg = arg_reg->get_frame_region ();\n+\t  unsigned next_arg_idx = arg_reg->get_index ();\n+\n+\t  if (get_stack_depth () > 1)\n+\t    {\n+\t      /* The interprocedural case: the called frame will have been\n+\t\t populated with any variadic aruguments.\n+\t\t Attempt to extract arg_reg to cd's return region (which already\n+\t\t has a conjured_svalue), or warn if there's a problem\n+\t\t (incompatible types, or if we've run out of args).  */\n+\t      if (const svalue *arg_sval\n+\t\t  = m_store.get_any_binding (m_mgr->get_store_manager (),\n+\t\t\t\t\t     arg_reg))\n+\t\t{\n+\t\t  tree lhs_type = cd.get_lhs_type ();\n+\t\t  tree arg_type = arg_sval->get_type ();\n+\t\t  if (va_arg_compatible_types_p (lhs_type, arg_type))\n+\t\t    cd.maybe_set_lhs (arg_sval);\n+\t\t  else\n+\t\t    {\n+\t\t      if (ctxt)\n+\t\t\tctxt->warn (new va_arg_type_mismatch (va_list_tree,\n+\t\t\t\t\t\t\t      arg_reg,\n+\t\t\t\t\t\t\t      lhs_type,\n+\t\t\t\t\t\t\t      arg_type));\n+\t\t      saw_problem = true;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (ctxt)\n+\t\t    ctxt->warn (new va_list_exhausted (va_list_tree, arg_reg));\n+\t\t  saw_problem = true;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This frame is an entry-point to the analysis, so there won't be\n+\t\t any specific var_arg_regions populated within it.\n+\t\t We already have a conjured_svalue for the result, so leave\n+\t\t it untouched.  */\n+\t      gcc_assert (get_stack_depth () == 1);\n+\t    }\n+\n+\t  if (saw_problem)\n+\t    {\n+\t      /* Set impl_reg to UNKNOWN to suppress further warnings.  */\n+\t      const svalue *new_ap_sval\n+\t\t= m_mgr->get_or_create_unknown_svalue (impl_reg->get_type ());\n+\t      set_value (impl_reg, new_ap_sval, ctxt);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Update impl_reg to advance to the next arg.  */\n+\t      const region *next_var_arg_region\n+\t\t= m_mgr->get_var_arg_region (frame_reg, next_arg_idx + 1);\n+\t      const svalue *new_ap_sval\n+\t\t= m_mgr->get_ptr_svalue (NULL_TREE, next_var_arg_region);\n+\t      set_value (impl_reg, new_ap_sval, ctxt);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Handle the on_call_post part of \"__builtin_va_end\".  */\n+\n+void\n+region_model::impl_call_va_end (const call_details &)\n+{\n+  /* No-op.  */\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "e8e6d4e039b39a93bd34bf7afdedd09e0ead3482", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -464,6 +464,10 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-analyzer-use-after-free @gol\n -Wno-analyzer-use-of-pointer-in-stale-stack-frame @gol\n -Wno-analyzer-use-of-uninitialized-value @gol\n+-Wno-analyzer-va-arg-type-mismatch @gol\n+-Wno-analyzer-va-list-exhausted @gol\n+-Wno-analyzer-va-list-leak @gol\n+-Wno-analyzer-va-list-use-after-va-end @gol\n -Wno-analyzer-write-to-const @gol\n -Wno-analyzer-write-to-string-literal @gol\n }\n@@ -9689,6 +9693,10 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-use-after-free @gol\n -Wanalyzer-use-of-pointer-in-stale-stack-frame @gol\n -Wanalyzer-use-of-uninitialized-value @gol\n+-Wanalyzer-va-arg-type-mismatch @gol\n+-Wanalyzer-va-list-exhausted @gol\n+-Wanalyzer-va-list-leak @gol\n+-Wanalyzer-va-list-use-after-va-end @gol\n -Wanalyzer-write-to-const @gol\n -Wanalyzer-write-to-string-literal @gol\n }\n@@ -9971,6 +9979,53 @@ to disable it.\n This diagnostic warns for paths through the code in which a pointer\n is dereferenced that points to a variable in a stale stack frame.\n \n+@item -Wno-analyzer-va-arg-type-mismatch\n+@opindex Wanalyzer-va-arg-type-mismatch\n+@opindex Wno-analyzer-va-arg-type-mismatch\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-va-arg-type-mismatch}\n+to disable it.\n+\n+This diagnostic warns for interprocedural paths through the code for which\n+the analyzer detects an attempt to use @code{va_arg} to extract a value\n+passed to a variadic call, but uses a type that does not match that of\n+the expression passed to the call.\n+\n+@item -Wno-analyzer-va-list-exhausted\n+@opindex Wanalyzer-va-list-exhausted\n+@opindex Wno-analyzer-va-list-exhausted\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-va-list-exhausted}\n+to disable it.\n+\n+This diagnostic warns for interprocedural paths through the code for which\n+the analyzer detects an attempt to use @code{va_arg} to access the next\n+value passed to a variadic call, but all of the values in the\n+@code{va_list} have already been consumed.\n+\n+@item -Wno-analyzer-va-list-leak\n+@opindex Wanalyzer-va-list-leak\n+@opindex Wno-analyzer-va-list-leak\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-va-list-leak}\n+to disable it.\n+\n+This diagnostic warns for interprocedural paths through the code for which\n+the analyzer detects that @code{va_start} or @code{va_copy} has been called\n+on a @code{va_list} without a corresponding call to @code{va_end}.\n+\n+@item -Wno-analyzer-va-list-use-after-va-end\n+@opindex Wanalyzer-va-list-use-after-va-end\n+@opindex Wno-analyzer-va-list-use-after-va-end\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-va-list-use-after-va-end}\n+to disable it.\n+\n+This diagnostic warns for interprocedural paths through the code for which\n+the analyzer detects an attempt to use a @code{va_list}  after\n+@code{va_end} has been called on it.\n+@code{va_list}.\n+\n @item -Wno-analyzer-write-to-const\n @opindex Wanalyzer-write-to-const\n @opindex Wno-analyzer-write-to-const"}, {"sha": "295f0efb74d497d6b84b39ed432d0e8f3372056e", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-1.c", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,433 @@\n+#include \"analyzer-decls.h\"\n+\n+/* Unpacking a va_list.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_1 (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+  \n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)__builtin_va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+\n+  __builtin_va_end (ap);\n+}\n+\n+void test_1 (void)\n+{\n+  __analyzer_called_by_test_1 (42, \"foo\", 1066, '@');\n+}\n+\n+/* Unpacking a va_list passed from an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_inner (__builtin_va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+  \n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)__builtin_va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_middle (int placeholder, ...)\n+{\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  __analyzer_test_2_inner (ap);\n+  __builtin_va_end (ap);\n+}\n+\n+void test_2 (void)\n+{\n+  __analyzer_test_2_middle (42, \"foo\", 1066, '@');\n+}\n+\n+/* Not enough args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_not_enough_args (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  \n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\)\" } */\n+\n+  __builtin_va_end (ap);\n+}\n+\n+void test_not_enough_args (void)\n+{\n+  __analyzer_called_by_test_not_enough_args (42, \"foo\");\n+}\n+\n+/* Not enough args, with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_inner (__builtin_va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  \n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\)\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_middle (int placeholder, ...)\n+{\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  __analyzer_test_not_enough_args_2_inner (ap);\n+  __builtin_va_end (ap);\n+}\n+\n+void test_not_enough_args_2 (void)\n+{\n+  __analyzer_test_not_enough_args_2_middle (42, \"foo\");\n+}\n+\n+/* Excess args (not a problem).  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_excess_args (int placeholder, ...)\n+{\n+  const char *s;\n+  \n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  __builtin_va_end (ap);\n+}\n+\n+void test_excess_args (void)\n+{\n+  __analyzer_called_by_test_excess_args (42, \"foo\", \"bar\");\n+}\n+\n+/* Missing va_start.  */\n+\n+void test_missing_va_start (int placeholder, ...)\n+{\n+  __builtin_va_list ap; /* { dg-message \"region created on stack here\" } */\n+  int i = __builtin_va_arg (ap, int); /* { dg-warning \"use of uninitialized value 'ap'\" } */\n+}\n+\n+/* Missing va_end.  */\n+\n+void test_missing_va_end (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = __builtin_va_arg (ap, int);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+/* { dg-message \"\\\\(2\\\\) missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* Missing va_end due to error-handling.  */\n+\n+int test_missing_va_end_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = __builtin_va_arg (ap, int);\n+  if (i == 42)\n+    {\n+      __builtin_va_end (ap);\n+      return -1;\n+    }\n+  j = __builtin_va_arg (ap, int);\n+  if (j == 1066) /* { dg-message \"branch\" } */\n+    return -1; /* { dg-message \"here\" } */\n+  __builtin_va_end (ap);\n+  return 0;\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+\n+/* va_arg after va_end.  */\n+\n+void test_va_arg_after_va_end (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  __builtin_va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'va_arg' after 'va_end'\" } */\n+}\n+\n+/* Type mismatch: expect int, but passed a char *.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_1 (int placeholder, ...)\n+{\n+  int i;\n+  \n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'va_arg' expected 'int' but received '\\[^\\n\\r\\]*' for variadic argument 1 of 'ap'\" } */\n+\n+  __builtin_va_end (ap);\n+}\n+\n+void test_type_mismatch_1 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_1 (42, \"foo\");\n+}\n+\n+/* Type mismatch: expect char *, but passed an int.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_2 (int placeholder, ...)\n+{\n+  const char *str;\n+  \n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+\n+  str = __builtin_va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1\" } */\n+\n+  __builtin_va_end (ap);\n+}\n+\n+void test_type_mismatch_2 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_2 (42, 1066);\n+}\n+\n+/* As above, but with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_inner (__builtin_va_list ap)\n+{\n+  const char *str;\n+  \n+  str = __builtin_va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1 of 'ap'\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_middle (int placeholder, ...)\n+{\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+\n+  __analyzer_test_type_mismatch_3_inner (ap);\n+\n+  __builtin_va_end (ap);\n+}\n+\n+void test_type_mismatch_3 (void)\n+{\n+  __analyzer_test_type_mismatch_3_middle (42, 1066);\n+}\n+\n+/* Multiple traversals of the args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals (int placeholder, ...)\n+{\n+  __builtin_va_list ap;\n+\n+  /* First traversal.  */\n+  {\n+    int i, j;\n+\n+    __builtin_va_start (ap, placeholder);\n+\n+    i = __builtin_va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = __builtin_va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    __builtin_va_end (ap);\n+  }\n+\n+  /* Second traversal.  */\n+  {\n+    int i, j;\n+\n+    __builtin_va_start (ap, placeholder);\n+\n+    i = __builtin_va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = __builtin_va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    __builtin_va_end (ap);\n+  }\n+}\n+\n+void test_multiple_traversals (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_va_list args1;\n+  __builtin_va_list args2;\n+\n+  __builtin_va_start (args1, placeholder);\n+  __builtin_va_copy (args2, args1);\n+\n+  /* First traversal.  */\n+  i = __builtin_va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = __builtin_va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  i = __builtin_va_arg (args2, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = __builtin_va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_va_end (args2);\n+}\n+\n+void test_multiple_traversals_2 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_2 (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy after a va_arg.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_3 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_va_list args1;\n+  __builtin_va_list args2;\n+\n+  __builtin_va_start (args1, placeholder);\n+\n+  /* First traversal.  */\n+  i = __builtin_va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  /* va_copy after the first va_arg. */\n+  __builtin_va_copy (args2, args1);\n+\n+  j = __builtin_va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  j = __builtin_va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_va_end (args2);\n+}\n+\n+void test_multiple_traversals_3 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_3 (0, 1066, 42);\n+}\n+\n+/* va_copy after va_end.  */\n+\n+void test_va_copy_after_va_end (int placeholder, ...)\n+{\n+  __builtin_va_list ap1, ap2;\n+  __builtin_va_start (ap1, placeholder);\n+  __builtin_va_end (ap1); /* { dg-message \"'va_end' called here\" } */\n+  __builtin_va_copy (ap2, ap1); /* { dg-warning \"'va_copy' after 'va_end'\" } */\n+  __builtin_va_end (ap2);\n+}\n+\n+/* leak of va_copy.  */\n+\n+void test_leak_of_va_copy (int placeholder, ...)\n+{\n+  __builtin_va_list ap1, ap2;\n+  __builtin_va_start (ap1, placeholder);\n+  __builtin_va_copy (ap2, ap1); /* { dg-message \"'va_copy' called here\" } */\n+  __builtin_va_end (ap1);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_copy' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* double va_end.  */\n+\n+void test_double_va_end (int placeholder, ...)\n+{\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  __builtin_va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  __builtin_va_end (ap); /* { dg-warning \"'va_end' after 'va_end'\" } */\n+}\n+\n+/* double va_start.  */\n+\n+void test_double_va_start (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder); /* { dg-message \"'va_start' called here\" } */\n+  __builtin_va_start (ap, placeholder);  /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+  __builtin_va_end (ap);\n+}\n+\n+/* va_copy before va_start.  */\n+\n+void test_va_copy_before_va_start (int placeholder, ...)\n+{\n+  __builtin_va_list ap1; /* { dg-message \"region created on stack here\" } */\n+  __builtin_va_list ap2;\n+  __builtin_va_copy (ap2, ap1); /* { dg-warning \"use of uninitialized value 'ap1'\" } */\n+  __builtin_va_end (ap2);\n+}\n+\n+/* Verify that we complain about uses of a va_list after the function \n+   in which va_start was called has returned.  */\n+\n+__builtin_va_list global_ap;\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_va_arg_after_return (int placeholder, ...)\n+{\n+  __builtin_va_start (global_ap, placeholder);\n+  __builtin_va_end (global_ap);\n+}\n+\n+void test_va_arg_after_return (void)\n+{\n+  int i;\n+  __analyzer_called_by_test_va_arg_after_return (42, 1066);\n+  i = __builtin_va_arg (global_ap, int); /* { dg-warning \"dereferencing pointer 'global_ap' to within stale stack frame\" } */\n+}"}, {"sha": "69a2acbc3fafa5e0d63af75f9b1dff3ec251c71f", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-2.c", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-2.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,436 @@\n+/* As per stdarg-1.c, but using <stdarg.h>, rather than hardcoded builtins.  */\n+\n+#include <stdarg.h>\n+#include \"analyzer-decls.h\"\n+\n+/* Unpacking a va_list.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_1 (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+  \n+  va_list ap;\n+  va_start (ap, placeholder);\n+\n+  s = va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+\n+  va_end (ap);\n+}\n+\n+void test_1 (void)\n+{\n+  __analyzer_called_by_test_1 (42, \"foo\", 1066, '@');\n+}\n+\n+/* Unpacking a va_list passed from an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_inner (va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+  \n+  s = va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_middle (int placeholder, ...)\n+{\n+  va_list ap;\n+  va_start (ap, placeholder);\n+  __analyzer_test_2_inner (ap);\n+  va_end (ap);\n+}\n+\n+void test_2 (void)\n+{\n+  __analyzer_test_2_middle (42, \"foo\", 1066, '@');\n+}\n+\n+/* Not enough args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_not_enough_args (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  \n+  va_list ap;\n+  va_start (ap, placeholder);\n+\n+  s = va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\)\" } */\n+\n+  va_end (ap);\n+}\n+\n+void test_not_enough_args (void)\n+{\n+  __analyzer_called_by_test_not_enough_args (42, \"foo\");\n+}\n+\n+/* Not enough args, with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_inner (va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  \n+  s = va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\)\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_middle (int placeholder, ...)\n+{\n+  va_list ap;\n+  va_start (ap, placeholder);\n+  __analyzer_test_not_enough_args_2_inner (ap);\n+  va_end (ap);\n+}\n+\n+void test_not_enough_args_2 (void)\n+{\n+  __analyzer_test_not_enough_args_2_middle (42, \"foo\");\n+}\n+\n+/* Excess args (not a problem).  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_excess_args (int placeholder, ...)\n+{\n+  const char *s;\n+  \n+  va_list ap;\n+  va_start (ap, placeholder);\n+\n+  s = va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  va_end (ap);\n+}\n+\n+void test_excess_args (void)\n+{\n+  __analyzer_called_by_test_excess_args (42, \"foo\", \"bar\");\n+}\n+\n+/* Missing va_start.  */\n+\n+void test_missing_va_start (int placeholder, ...)\n+{\n+  va_list ap; /* { dg-message \"region created on stack here\" } */\n+  int i = va_arg (ap, int); /* { dg-warning \"use of uninitialized value 'ap'\" } */\n+}\n+\n+/* Missing va_end.  */\n+\n+void test_missing_va_end (int placeholder, ...)\n+{\n+  int i;\n+  va_list ap;\n+  va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = va_arg (ap, int);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+/* { dg-message \"\\\\(2\\\\) missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* Missing va_end due to error-handling.  */\n+\n+int test_missing_va_end_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  va_list ap;\n+  va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = va_arg (ap, int);\n+  if (i == 42)\n+    {\n+      va_end (ap);\n+      return -1;\n+    }\n+  j = va_arg (ap, int);\n+  if (j == 1066) /* { dg-message \"branch\" } */\n+    return -1; /* { dg-message \"here\" } */\n+  va_end (ap);\n+  return 0;\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+\n+/* va_arg after va_end.  */\n+\n+void test_va_arg_after_va_end (int placeholder, ...)\n+{\n+  int i;\n+  va_list ap;\n+  va_start (ap, placeholder);\n+  va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  i = va_arg (ap, int); /* { dg-warning \"'va_arg' after 'va_end'\" } */\n+}\n+\n+/* Type mismatch: expect int, but passed a char *.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_1 (int placeholder, ...)\n+{\n+  int i;\n+  \n+  va_list ap;\n+  va_start (ap, placeholder);\n+\n+  i = va_arg (ap, int); /* { dg-warning \"'va_arg' expected 'int' but received '\\[^\\n\\r\\]*' for variadic argument 1 of 'ap'\" } */\n+\n+  va_end (ap);\n+}\n+\n+void test_type_mismatch_1 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_1 (42, \"foo\");\n+}\n+\n+/* Type mismatch: expect char *, but passed an int.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_2 (int placeholder, ...)\n+{\n+  const char *str;\n+  \n+  va_list ap;\n+  va_start (ap, placeholder);\n+\n+  str = va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1 of 'ap'\" } */\n+\n+  va_end (ap);\n+}\n+\n+void test_type_mismatch_2 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_2 (42, 1066);\n+}\n+\n+/* As above, but with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_inner (va_list ap)\n+{\n+  const char *str;\n+  \n+  str = va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1 of 'ap'\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_middle (int placeholder, ...)\n+{\n+  va_list ap;\n+  va_start (ap, placeholder);\n+\n+  __analyzer_test_type_mismatch_3_inner (ap);\n+\n+  va_end (ap);\n+}\n+\n+void test_type_mismatch_3 (void)\n+{\n+  __analyzer_test_type_mismatch_3_middle (42, 1066);\n+}\n+\n+/* Multiple traversals of the args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals (int placeholder, ...)\n+{\n+  va_list ap;\n+\n+  /* First traversal.  */\n+  {\n+    int i, j;\n+\n+    va_start (ap, placeholder);\n+\n+    i = va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    va_end (ap);\n+  }\n+\n+  /* Second traversal.  */\n+  {\n+    int i, j;\n+\n+    va_start (ap, placeholder);\n+\n+    i = va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    va_end (ap);\n+  }\n+}\n+\n+void test_multiple_traversals (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  va_list args1;\n+  va_list args2;\n+\n+  va_start (args1, placeholder);\n+  va_copy (args2, args1);\n+\n+  /* First traversal.  */\n+  i = va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  i = va_arg (args2, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  va_end (args2);\n+}\n+\n+void test_multiple_traversals_2 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_2 (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy after a va_arg.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_3 (int placeholder, ...)\n+{\n+  int i, j;\n+  va_list args1;\n+  va_list args2;\n+\n+  va_start (args1, placeholder);\n+\n+  /* First traversal.  */\n+  i = va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  /* va_copy after the first va_arg. */\n+  va_copy (args2, args1);\n+\n+  j = va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  j = va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  va_end (args2);\n+}\n+\n+void test_multiple_traversals_3 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_3 (0, 1066, 42);\n+}\n+\n+/* va_copy after va_end.  */\n+\n+void test_va_copy_after_va_end (int placeholder, ...)\n+{\n+  va_list ap1, ap2;\n+  va_start (ap1, placeholder);\n+  va_end (ap1); /* { dg-message \"'va_end' called here\" } */\n+  va_copy (ap2, ap1); /* { dg-warning \"'va_copy' after 'va_end'\" } */\n+  va_end (ap2);\n+}\n+\n+/* leak of va_copy.  */\n+\n+void test_leak_of_va_copy (int placeholder, ...)\n+{\n+  va_list ap1, ap2;\n+  va_start (ap1, placeholder); \n+  va_copy (ap2, ap1);  /* { dg-message \"'va_copy' called here\" } */\n+  va_end (ap1);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_copy' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* double va_end.  */\n+\n+void test_double_va_end (int placeholder, ...)\n+{\n+  va_list ap;\n+  va_start (ap, placeholder);\n+  va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  va_end (ap); /* { dg-warning \"'va_end' after 'va_end'\" } */\n+}\n+\n+/* double va_start.  */\n+\n+void test_double_va_start (int placeholder, ...)\n+{\n+  int i;\n+  va_list ap;\n+  va_start (ap, placeholder); /* { dg-message \"'va_start' called here\" } */\n+  va_start (ap, placeholder);  /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+  va_end (ap);\n+}\n+\n+/* va_copy before va_start.  */\n+\n+void test_va_copy_before_va_start (int placeholder, ...)\n+{\n+  va_list ap1; /* { dg-message \"region created on stack here\" } */\n+  va_list ap2;\n+  va_copy (ap2, ap1); /* { dg-warning \"use of uninitialized value 'ap1'\" } */\n+  va_end (ap2);\n+}\n+\n+/* Verify that we complain about uses of a va_list after the function \n+   in which va_start was called has returned.  */\n+\n+va_list global_ap;\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_va_arg_after_return (int placeholder, ...)\n+{\n+  va_start (global_ap, placeholder);\n+  va_end (global_ap);\n+}\n+\n+void test_va_arg_after_return (void)\n+{\n+  int i;\n+  __analyzer_called_by_test_va_arg_after_return (42, 1066);\n+  i = va_arg (global_ap, int); /* { dg-warning \"dereferencing pointer 'global_ap' to within stale stack frame\" } */\n+}"}, {"sha": "3892c3cdd1c5823d251563f1e09a9ccbf0875a07", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-fmtstring-1.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-fmtstring-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-fmtstring-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-fmtstring-1.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-additional-options \"-fno-analyzer-call-summaries -fno-analyzer-state-merge -Wno-analyzer-too-complex\" } */\n+\n+void test_format_string (const char *fmt, ...)\n+{\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, fmt);\n+  while (*fmt)\n+    switch (*fmt++)\n+      {\n+      case 's':\n+\t{\n+\t  const char *s = __builtin_va_arg (ap, char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1 of 'ap'\" } */\n+\t  __builtin_printf (\"string: %s\\n\", s);\n+\t}\n+\tbreak;\n+      case 'd':\n+\t{\n+\t  int i = __builtin_va_arg (ap, int); /* { dg-warning \"'va_arg' expected 'int' but received '\\[^\\n\\r\\]*' for variadic argument 1 of 'ap'\" \"type mismatch from wrong_type_for_percent_d\" } */\n+\t  /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\)\" \"not_enough_args\" { target *-*-* } .-1 } */\n+\t  __builtin_printf (\"int: %d\\n\", i);\n+\t}\n+\tbreak;\n+      case 'c':\n+\t{\n+\t  char c = (char)__builtin_va_arg (ap, int);\n+\t  __builtin_printf (\"char: %c\\n\", c);\n+\t}\n+\tbreak;      \n+      }\n+  __builtin_va_end (ap);\n+}\n+\n+void test_missing_va_start (const char *fmt, ...)\n+{\n+  __builtin_va_list ap;\n+\n+  while (*fmt)\n+    switch (*fmt++)\n+      {\n+      case 's':\n+\t{\n+\t  const char *s = __builtin_va_arg (ap, char *); /* { dg-warning \"use of uninitialized value 'ap'\" } */\n+\t  __builtin_printf (\"string: %s\\n\", s);\n+\t}\n+\tbreak;\n+      case 'd':\n+\t{\n+\t  int i = __builtin_va_arg (ap, int); /* { dg-warning \"use of uninitialized value 'ap'\" } */\n+\t  __builtin_printf (\"int: %d\\n\", i); \n+\t}\n+\tbreak;\n+      case 'c':\n+\t{\n+\t  char c = (char)__builtin_va_arg (ap, int); /* { dg-warning \"use of uninitialized value 'ap'\" } */\n+\t  __builtin_printf (\"char: %c\\n\", c);\n+\t}\n+\tbreak;      \n+      }\n+  __builtin_va_end (ap);\n+}\n+\n+void test_missing_va_end (const char *fmt, ...)\n+{\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, fmt);\n+  while (*fmt)\n+    switch (*fmt++)\n+      {\n+      case 's':\n+\t{\n+\t  const char *s = __builtin_va_arg (ap, char *);\n+\t  __builtin_printf (\"string: %s\\n\", s);\n+\t}\n+\tbreak;\n+      case 'd':\n+\t{\n+\t  int i = __builtin_va_arg (ap, int);\n+\t  __builtin_printf (\"int: %d\\n\", i);\n+\t}\n+\tbreak;\n+      case 'c':\n+\t{\n+\t  char c = (char)__builtin_va_arg (ap, int);\n+\t  __builtin_printf (\"char: %c\\n\", c);\n+\t}\n+\tbreak;      \n+      }\n+} /* { dg-warning \"missing call to 'va_end'\" } */\n+\n+void wrong_type_for_percent_s (void)\n+{\n+  test_format_string (\"%s\", 42);\n+}\n+\n+void wrong_type_for_percent_d (void)\n+{\n+  test_format_string (\"%d\", \"foo\");\n+}\n+\n+void not_enough_args (void)\n+{\n+  test_format_string (\"%s%d\", \"foo\");\n+}"}, {"sha": "f56ad88d990d0fb5886a05eef6ee229c56657a9a", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-lto-1-a.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1-a.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target lto } */\n+/* { dg-additional-options \"-flto\" } */\n+/* { dg-additional-sources stdarg-lto-1-b.c } */\n+\n+#include <stdarg.h>\n+#include \"stdarg-lto-1.h\"\n+\n+/* Type mismatch: expect const char *, but passed an int.  */\n+\n+void\n+called_by_test_type_mismatch_1 (int placeholder, ...)\n+{\n+  const char *str;\n+  \n+  va_list ap;\n+  va_start (ap, placeholder);\n+\n+  str = va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected '\\[^\\n\\r\\]*' but received 'int' for variadic argument 1 of 'ap'\" } */\n+\n+  va_end (ap);\n+}\n+\n+int main() { return 0; }"}, {"sha": "edd51f02497f82907545e256fe8b7af1bed7452b", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-lto-1-b.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1-b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1-b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1-b.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,6 @@\n+#include \"stdarg-lto-1.h\"\n+\n+void test_type_mismatch_1 (void)\n+{\n+  called_by_test_type_mismatch_1 (42, 1066);\n+}"}, {"sha": "698357473165f86530481900d0460893a25fab3a", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-lto-1.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-lto-1.h?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1 @@\n+extern void called_by_test_type_mismatch_1 (int placeholder, ...);"}, {"sha": "f8c1f0eb0f82b7205e61eab72dd6ca34a9b30708", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-sentinel-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-sentinel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-sentinel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-sentinel-1.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+#define NULL ((void *)0)\n+\n+void test_sentinel (int arg, ...)\n+{\n+  const char *s;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, arg);\n+  while (s = __builtin_va_arg (ap, char *)) /* { dg-warning \"'ap' has no more arguments \\\\(2 consumed\\\\)\" } */\n+    {\n+      (void)s;\n+    }\n+  __builtin_va_end (ap);\n+}\n+\n+void test_caller (void)\n+{\n+  test_sentinel (42, \"foo\", \"bar\", NULL);\n+}\n+\n+void missing_sentinel (void)\n+{\n+  test_sentinel (42, \"foo\", \"bar\");\n+}"}, {"sha": "dcea87e6050cb9fc3618775af6dbcb40cb489158", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-types-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-types-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-types-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-types-1.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-require-effective-target int32 } */\n+/* { dg-require-effective-target lp64 } */\n+\n+/* Type mismatch: expect long, but passed an int.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_consume_long (int placeholder, ...)\n+{\n+  long v;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  v = __builtin_va_arg (ap, long); /* { dg-warning \"'va_arg' expected 'long int' but received 'int' for variadic argument 1 of 'ap'\" } */\n+  __builtin_va_end (ap);\n+}\n+\n+void test_int_to_long (void)\n+{\n+  __analyzer_consume_long (42, 1066);\n+}\n+\n+void test_char_to_long (void)\n+{\n+  /* char promoted to int.  */\n+  __analyzer_consume_long (42, 'a');\n+}"}, {"sha": "39d5c6efb9e268fa995429ce9179b8320f3c0d9e", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-types-2.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-types-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402dc6b982c4dacac2360830f0edc123c588110/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-types-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-types-2.c?ref=2402dc6b982c4dacac2360830f0edc123c588110", "patch": "@@ -0,0 +1,55 @@\n+/* Should be OK to add a \"const\" qualifier to a ptr.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_consume_const_char_ptr (int placeholder, ...)\n+{\n+  const char *v;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  v = __builtin_va_arg (ap, const char *);\n+  __builtin_va_end (ap);\n+}\n+\n+void test_char_ptr_to_const_char_ptr (char *p)\n+{\n+  __analyzer_consume_const_char_ptr (42, p); /* { dg-bogus \"\" } */\n+}\n+\n+/* What about casting away const-ness?\n+   Currently we don't complain.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_consume_char_ptr (int placeholder, ...)\n+{\n+  char *v;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  v = __builtin_va_arg (ap, char *);\n+  __builtin_va_end (ap);\n+}\n+\n+void test_const_char_ptr_to_char_ptr (const char *p)\n+{\n+  __analyzer_consume_const_char_ptr (42, p);\n+}\n+\n+/* What about casting ptrs?\n+   Currently we don't complain.  */\n+\n+struct foo;\n+struct bar;\n+\n+static void __attribute__((noinline))\n+__analyzer_consume_bar_ptr (int placeholder, ...)\n+{\n+  struct bar *v;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  v = __builtin_va_arg (ap, struct bar *);\n+  __builtin_va_end (ap);\n+}\n+\n+void test_foo_ptr_to_bar_ptr (struct foo *p)\n+{\n+  __analyzer_consume_bar_ptr (42, p);\n+}"}]}