{"sha": "71e093897c94f864daa9b0f886be3d3aad374078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFlMDkzODk3Yzk0Zjg2NGRhYTliMGY4ODZiZTNkM2FhZDM3NDA3OA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-10-25T15:34:04Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-10-25T15:34:04Z"}, "message": "PR libstdc++/87749 fix (and optimize) string move construction\n\nThe move constructor for the SSO string uses assign(const basic_string&)\nwhen either:\n\n(1) the source string is \"local\" and so the contents of the small string\nbuffer need to be copied, or\n\n(2) the allocator does not propagate and is_always_equal is false.\n\nCase (1) is suboptimal, because the assign member is not noexcept and\nthe compiler isn't smart enough to see it won't actually throw in this\ncase. This causes extra code in the move assignment operator so that any\nexception will be turned into a call to std::terminate. This can be\nfixed by copying small strings inline instead of calling assign.\n\nCase (2) is a bug, because the specific instances of the allocators\ncould be equal even if is_always_equal is false. This can result in an\nunnecessary deep copy (and potentially-throwing allocation) when the\nstorage should be moved. This can be fixed by simply checking if the\nallocators are equal.\n\n\tPR libstdc++/87749\n\t* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI]\n\t(basic_string::operator=(basic_string&&)): For short strings copy the\n\tbuffer inline. Only fall back to using assign(const basic_string&) to\n\tdo a deep copy when reallocation is needed.\n\t* testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc:\n\tNew test.\n\t* testsuite/21_strings/basic_string/modifiers/assign/char/\n\tmove_assign_optim.cc: New test.\n\t* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc:\n\tNew test.\n\t* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/\n\tmove_assign_optim.cc: New test.\n\nFrom-SVN: r265493", "tree": {"sha": "423414dc0da676e005efee425e91d2b2c97e265d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/423414dc0da676e005efee425e91d2b2c97e265d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71e093897c94f864daa9b0f886be3d3aad374078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e093897c94f864daa9b0f886be3d3aad374078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71e093897c94f864daa9b0f886be3d3aad374078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e093897c94f864daa9b0f886be3d3aad374078/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1afca3f426b11bc4f6363824890395718c2a312f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afca3f426b11bc4f6363824890395718c2a312f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1afca3f426b11bc4f6363824890395718c2a312f"}], "stats": {"total": 264, "additions": 258, "deletions": 6}, "files": [{"sha": "fe43ed27f67d45d72e23bd3695520953420a3a9c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=71e093897c94f864daa9b0f886be3d3aad374078", "patch": "@@ -1,3 +1,19 @@\n+2018-10-25  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/87749\n+\t* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI]\n+\t(basic_string::operator=(basic_string&&)): For short strings copy the\n+\tbuffer inline. Only fall back to using assign(const basic_string&) to\n+\tdo a deep copy when reallocation is needed.\n+\t* testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc:\n+\tNew test.\n+\t* testsuite/21_strings/basic_string/modifiers/assign/char/\n+\tmove_assign_optim.cc: New test.\n+\t* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc:\n+\tNew test.\n+\t* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/\n+\tmove_assign_optim.cc: New test.\n+\n 2018-10-25  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR libstdc++/87106"}, {"sha": "ae6530fcdc9f801eedc938c508d236974fdd65c9", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=71e093897c94f864daa9b0f886be3d3aad374078", "patch": "@@ -744,20 +744,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t// Replace allocator if POCMA is true.\n \tstd::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());\n \n-\tif (!__str._M_is_local()\n-\t    && (_Alloc_traits::_S_propagate_on_move_assign()\n-\t      || _Alloc_traits::_S_always_equal()))\n+\tif (__str._M_is_local())\n+\t  {\n+\t    // We've always got room for a short string, just copy it.\n+\t    if (__str.size())\n+\t      this->_S_copy(_M_data(), __str._M_data(), __str.size());\n+\t    _M_set_length(__str.size());\n+\t  }\n+\telse if (_Alloc_traits::_S_propagate_on_move_assign()\n+\t    || _Alloc_traits::_S_always_equal()\n+\t    || _M_get_allocator() == __str._M_get_allocator())\n \t  {\n+\t    // Just move the allocated pointer, our allocator can free it.\n \t    pointer __data = nullptr;\n \t    size_type __capacity;\n \t    if (!_M_is_local())\n \t      {\n \t\tif (_Alloc_traits::_S_always_equal())\n \t\t  {\n+\t\t    // __str can reuse our existing storage.\n \t\t    __data = _M_data();\n \t\t    __capacity = _M_allocated_capacity;\n \t\t  }\n-\t\telse\n+\t\telse // __str can't use it, so free it.\n \t\t  _M_destroy(_M_allocated_capacity);\n \t      }\n \n@@ -772,8 +781,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t    else\n \t      __str._M_data(__str._M_local_buf);\n \t  }\n-\telse\n-\t    assign(__str);\n+\telse // Need to do a deep copy\n+\t  assign(__str);\n \t__str.clear();\n \treturn *this;\n       }"}, {"sha": "ef5f1e708ac2d933a5872b201c227986ac9cf732", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fchar%2F87749.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fchar%2F87749.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fchar%2F87749.cc?ref=71e093897c94f864daa9b0f886be3d3aad374078", "patch": "@@ -0,0 +1,78 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+// PR libstdc++/87749\n+\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+bool oom = false;\n+\n+template<typename T>\n+struct alloc\n+{\n+  using value_type = T;\n+\n+#if !_GLIBCXX_USE_CXX11_ABI\n+  using size_type = unsigned long;\n+  using difference_type = long;\n+  using reference = T&;\n+  using const_reference = T&;\n+  using pointer = T*;\n+  using const_pointer = const T*;\n+  template<typename U>\n+    struct rebind { using other = alloc<U>; };\n+#endif\n+\n+  int not_empty = 0; // this makes is_always_equal false\n+\n+  alloc() = default;\n+  template<typename U>\n+    alloc(const alloc<U>&) { }\n+\n+  T* allocate(unsigned long n)\n+  {\n+    if (oom)\n+      throw std::bad_alloc();\n+    return std::allocator<T>().allocate(n);\n+  }\n+\n+  void deallocate(T* p, unsigned long n)\n+  {\n+    std::allocator<T>().deallocate(p, n);\n+  }\n+};\n+\n+template<typename T, typename U>\n+bool operator==(const alloc<T>&, const alloc<U>&) { return true; }\n+\n+template<typename T, typename U>\n+bool operator!=(const alloc<T>&, const alloc<U>&) { return false; }\n+\n+int main()\n+{\n+  using string = std::basic_string<char, std::char_traits<char>, alloc<char>>;\n+\n+  string s = \"PR libstdc++/87749 a string that is longer than a short string\";\n+  const auto ptr = s.c_str();\n+  oom = true;\n+  string ss;\n+  ss = std::move(s); // allocators are equal, should not allocate new storage\n+  VERIFY( ss.c_str() == ptr );\n+}"}, {"sha": "b56bc50e1c1e2a9fc83bd11a507aa610b7abb214", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/move_assign_optim.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fchar%2Fmove_assign_optim.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fchar%2Fmove_assign_optim.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fchar%2Fmove_assign_optim.cc?ref=71e093897c94f864daa9b0f886be3d3aad374078", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-O1\" }\n+// { dg-do compile { target c++11 } }\n+// { dg-final { scan-assembler-not \"__throw_length_error\" } }\n+// { dg-final { scan-assembler-not \"__throw_bad_alloc\" } }\n+\n+#include <bits/c++config.h>\n+#undef _GLIBCXX_EXTERN_TEMPLATE\n+#include <string>\n+\n+void\n+test01(std::string& target, std::string&& source)\n+{\n+  // The move assignment operator should be simple enough that the compiler\n+  // can see that it never results in a length_error or bad_alloc exception\n+  // (which would be turned into std::terminate by the noexcept on the\n+  // assignment operator).\n+  target = std::move(source);\n+}"}, {"sha": "d4062a9e6376c3107f6ad0e39a5a8d25e360743b", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fwchar_t%2F87749.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fwchar_t%2F87749.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fwchar_t%2F87749.cc?ref=71e093897c94f864daa9b0f886be3d3aad374078", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+// PR libstdc++/87749\n+\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+bool oom = false;\n+\n+template<typename T>\n+struct alloc\n+{\n+  using value_type = T;\n+\n+#if !_GLIBCXX_USE_CXX11_ABI\n+  using size_type = unsigned long;\n+  using difference_type = long;\n+  using reference = T&;\n+  using const_reference = T&;\n+  using pointer = T*;\n+  using const_pointer = const T*;\n+  template<typename U>\n+    struct rebind { using other = alloc<U>; };\n+#endif\n+\n+  int not_empty = 0; // this makes is_always_equal false\n+\n+  alloc() = default;\n+  template<typename U>\n+    alloc(const alloc<U>&) { }\n+\n+  T* allocate(unsigned long n)\n+  {\n+    if (oom)\n+      throw std::bad_alloc();\n+    return std::allocator<T>().allocate(n);\n+  }\n+\n+  void deallocate(T* p, unsigned long n)\n+  {\n+    std::allocator<T>().deallocate(p, n);\n+  }\n+};\n+\n+template<typename T, typename U>\n+bool operator==(const alloc<T>&, const alloc<U>&) { return true; }\n+\n+template<typename T, typename U>\n+bool operator!=(const alloc<T>&, const alloc<U>&) { return false; }\n+\n+int main()\n+{\n+  using string\n+    = std::basic_string<wchar_t, std::char_traits<wchar_t>, alloc<wchar_t>>;\n+\n+  string s = L\"PR libstdc++/87749 a string that is longer than a short string\";\n+  const auto ptr = s.c_str();\n+  oom = true;\n+  string ss;\n+  ss = std::move(s); // allocators are equal, should not allocate new storage\n+  VERIFY( ss.c_str() == ptr );\n+}"}, {"sha": "f54ad36a5d0663284962ac938e67f83382f4d7be", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/move_assign_optim.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fwchar_t%2Fmove_assign_optim.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e093897c94f864daa9b0f886be3d3aad374078/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fwchar_t%2Fmove_assign_optim.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fmodifiers%2Fassign%2Fwchar_t%2Fmove_assign_optim.cc?ref=71e093897c94f864daa9b0f886be3d3aad374078", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-O1\" }\n+// { dg-do compile { target c++11 } }\n+// { dg-final { scan-assembler-not \"__throw_length_error\" } }\n+// { dg-final { scan-assembler-not \"__throw_bad_alloc\" } }\n+\n+#include <bits/c++config.h>\n+#undef _GLIBCXX_EXTERN_TEMPLATE\n+#include <string>\n+\n+void\n+test01(std::wstring& target, std::wstring&& source)\n+{\n+  // The move assignment operator should be simple enough that the compiler\n+  // can see that it never results in a length_error or bad_alloc exception\n+  // (which would be turned into std::terminate by the noexcept on the\n+  // assignment operator).\n+  target = std::move(source);\n+}"}]}