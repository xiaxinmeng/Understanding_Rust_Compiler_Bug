{"sha": "e09bbb25359c38da60026c18d174430e0daca699", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA5YmJiMjUzNTljMzhkYTYwMDI2YzE4ZDE3NDQzMGUwZGFjYTY5OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2000-07-24T17:52:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-07-24T17:52:37Z"}, "message": "dwarf2out.c: Complain if DWARF2_DEBUGGING_INFO is defined without UNALIGNED_INT_ASM_OP.\n\n        * dwarf2out.c: Complain if DWARF2_DEBUGGING_INFO is defined without\n        UNALIGNED_INT_ASM_OP.\n        (def_cfa_1): Don't emit def_cfa_register or def_cfa_offset to adjust\n        a location expression.\n        (dwarf2out_frame_debug_expr): Lose cfa_old_reg stuff.  Don't\n        assume indirect access if we're saving the CFA address exactly.\n\nFrom-SVN: r35232", "tree": {"sha": "197ecb5aa415dcbb67b72ae177c37920286e8cdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/197ecb5aa415dcbb67b72ae177c37920286e8cdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e09bbb25359c38da60026c18d174430e0daca699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09bbb25359c38da60026c18d174430e0daca699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09bbb25359c38da60026c18d174430e0daca699", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09bbb25359c38da60026c18d174430e0daca699/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d5f4b428474f3e0d9f16ec59defa7ef5d11066be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f4b428474f3e0d9f16ec59defa7ef5d11066be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5f4b428474f3e0d9f16ec59defa7ef5d11066be"}], "stats": {"total": 95, "additions": 52, "deletions": 43}, "files": [{"sha": "1796e087eabd8b5d7348df35fe7504f89e05298a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09bbb25359c38da60026c18d174430e0daca699/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09bbb25359c38da60026c18d174430e0daca699/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e09bbb25359c38da60026c18d174430e0daca699", "patch": "@@ -1,5 +1,12 @@\n 2000-07-24  Jason Merrill  <jason@redhat.com>\n \n+\t* dwarf2out.c: Complain if DWARF2_DEBUGGING_INFO is defined without\n+\tUNALIGNED_INT_ASM_OP.\n+\t(def_cfa_1): Don't emit def_cfa_register or def_cfa_offset to adjust\n+\ta location expression.\n+\t(dwarf2out_frame_debug_expr): Lose cfa_old_reg stuff.  Don't \n+\tassume indirect access if we're saving the CFA address exactly.\n+\n \t* Makefile.in (bootstrap): Move -BstageN/ to the end.\n \n 2000-07-24  Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "880afb120c54c9239cb68bd08346432d0d37082d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09bbb25359c38da60026c18d174430e0daca699/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09bbb25359c38da60026c18d174430e0daca699/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e09bbb25359c38da60026c18d174430e0daca699", "patch": "@@ -462,7 +462,11 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n #else /* UNALIGNED_INT_ASM_OP */\n \n /* We don't have unaligned support, let's hope the normal output works for\n-   .debug_frame.  */\n+   .debug_frame.  But we know it won't work for .debug_info.  */\n+\n+#ifdef DWARF2_DEBUGGING_INFO\n+#error DWARF2_DEBUGGING_INFO requires UNALIGNED_INT_ASM_OP.\n+#endif\n \n #ifndef ASM_OUTPUT_DWARF_ADDR\n #define ASM_OUTPUT_DWARF_ADDR(FILE,LABEL) \\\n@@ -888,24 +892,22 @@ def_cfa_1 (label, loc_p)\n   if (loc.reg == old_cfa.reg && loc.offset == old_cfa.offset &&\n       loc.indirect == old_cfa.indirect)\n     {\n-      if (loc.indirect == 0)\n+      if (loc.indirect == 0\n+\t  || loc.base_offset == old_cfa.base_offset)\n \treturn;\n-      else \n-        if (loc.base_offset == old_cfa.base_offset)\n-\t  return;\n     }\n \n   cfi = new_cfi ();\n \n-  if (loc.reg == old_cfa.reg && loc.indirect == old_cfa.indirect)\n+  if (loc.reg == old_cfa.reg && !loc.indirect)\n     {\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n       cfi->dw_cfi_oprnd1.dw_cfi_offset = loc.offset;\n     }\n \n #ifndef MIPS_DEBUGGING_INFO  /* SGI dbx thinks this means no offset.  */\n   else if (loc.offset == old_cfa.offset && old_cfa.reg != (unsigned long) -1\n-\t   && loc.indirect == old_cfa.indirect)\n+\t   && !loc.indirect)\n     {\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_register;\n       cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n@@ -1208,11 +1210,6 @@ static unsigned cfa_temp_reg;\n /* A temporary value used in adjusting SP or setting up the store_reg.  */\n static long cfa_temp_value;\n \n-/* If we see a store of the CFA register, remember it in case we later also\n-   copy it into another register.  The ARM saves the old SP in the stack,\n-   but it also has a usable FP.  */\n-static unsigned cfa_old_reg;\n-\n /* Record call frame debugging information for an expression, which either\n    sets SP or FP (adjusting how we calculate the frame address) or saves a\n    register to the stack. */\n@@ -1262,8 +1259,7 @@ dwarf2out_frame_debug_expr (expr, label)\n         {\n           /* Setting FP from SP.  */\n         case REG:\n-          if (cfa.reg == (unsigned) REGNO (src)\n-\t      || (cfa.indirect && cfa_old_reg == (unsigned) REGNO (src)))\n+          if (cfa.reg == (unsigned) REGNO (src))\n \t    /* OK */;\n \t  else\n             abort ();\n@@ -1273,7 +1269,6 @@ dwarf2out_frame_debug_expr (expr, label)\n \t     FP.  So we just rely on the backends to only set\n \t     RTX_FRAME_RELATED_P on appropriate insns.  */\n           cfa.reg = REGNO (dest);\n-\t  cfa.indirect = 0;\n           break;\n \n         case PLUS:\n@@ -1381,34 +1376,6 @@ dwarf2out_frame_debug_expr (expr, label)\n       if (GET_CODE (src) != REG)\n \tabort ();\n \n-      /* If the src is our current CFA, and it isn't the SP or FP, then we're\n-         going to have to use an indrect mechanism.  */\n-      if (REGNO (src) != STACK_POINTER_REGNUM \n-\t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM \n-\t  && (unsigned) REGNO (src) == cfa.reg\n-\t  /* Temporary KLUDGE to make ARM work.  */\n-\t  && GET_CODE (XEXP (dest, 0)) != PRE_DEC)\n-\t{\n-\t  /* We currently allow this to be ONLY a MEM or MEM + offset.  */\n-\t  rtx x = XEXP (dest, 0);\n-\t  int offset = 0;\n-\t  if (GET_CODE (x) == PLUS || GET_CODE (x) ==  MINUS)\n-\t    {\n-\t      offset = INTVAL (XEXP (x, 1));\n-\t      if (GET_CODE (x) == MINUS)\n-\t\toffset = -offset;\n-\t      x = XEXP (x, 0);\n-\t    }\n-\t  if (GET_CODE (x) != REG)\n-\t    abort ();\n-\t  cfa_old_reg = cfa.reg;\n-\t  cfa.reg = (unsigned) REGNO (x);\n-\t  cfa.base_offset = offset;\n-\t  cfa.indirect = 1;\n-\t  def_cfa_1 (label, &cfa);\n-\t  break;\n-\t}\n-\n       /* Saving a register to the stack.  Make sure dest is relative to the\n \t CFA register.  */\n       switch (GET_CODE (XEXP (dest, 0)))\n@@ -1452,6 +1419,41 @@ dwarf2out_frame_debug_expr (expr, label)\n \tdefault:\n \t  abort ();\n \t}\n+\n+      if (REGNO (src) != STACK_POINTER_REGNUM \n+\t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n+\t  && (unsigned) REGNO (src) == cfa.reg)\n+\t{\n+\t  /* We're storing the current CFA reg into the stack.  */\n+\n+\t  if (cfa.offset == 0)\n+\t    {\n+\t      /* If the source register is exactly the CFA, assume\n+\t\t we're saving SP like any other register; this happens\n+\t\t on the ARM.  */\n+\n+\t      def_cfa_1 (label, &cfa);\n+\t      dwarf2out_reg_save (label, STACK_POINTER_REGNUM, offset);\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, we'll need to look in the stack to\n+                 calculate the CFA.  */\n+\n+\t      rtx x = XEXP (dest, 0);\n+\t      if (GET_CODE (x) != REG)\n+\t\tx = XEXP (x, 0);\n+\t      if (GET_CODE (x) != REG)\n+\t\tabort ();\n+\t      cfa.reg = (unsigned) REGNO (x);\n+\t      cfa.base_offset = offset;\n+\t      cfa.indirect = 1;\n+\t      def_cfa_1 (label, &cfa);\n+\t      break;\n+\t    }\n+\t}\n+\n       def_cfa_1 (label, &cfa);\n       dwarf2out_reg_save (label, REGNO (src), offset);\n       break;"}]}