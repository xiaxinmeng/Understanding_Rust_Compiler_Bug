{"sha": "1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "node_id": "C_kwDOANBUbNoAKDFmZjRkYmRkY2Y3NDIwM2ExZTE2MzE2YjE4ZTEyZjllMWI1MDg1ZjA", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-10-26T20:40:33Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-10-26T22:53:54Z"}, "message": "Improve/correct detection of overlapping aggregates [PR102238, PR102919].\n\nResolves:\nPR tree-optimization/102238 - alias_offset in gimple-ssa-sprintf.c is broken\nPR tree-optimization/102919 - spurious -Wrestrict warning for sprintf into the same member array as argument plus offset\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/102238\n\tPR tree-optimization/102919\n\t* gimple-ssa-sprintf.c (get_string_length): Add an argument.\n\t(array_elt_at_offset): Move to pointer-query.\n\t(set_aggregate_size_and_offset): New function.\n\t(field_at_offset):  Move to pointer-query.\n\t(get_origin_and_offset): Rename...\n\t(get_origin_and_offset_r): this.  Add an argument.  Make aggregate\n\thandling more robust.\n\t(get_origin_and_offset): New.\n\t(alias_offset): Add an argument.\n\t(format_string): Use subobject size determined by get_origin_and_offset.\n\t* pointer-query.cc (field_at_offset): Move from gimple-ssa-sprintf.c.\n\tImprove/correct handling of aggregates.\n\t(array_elt_at_offset): Same.\n\t* pointer-query.h (field_at_offset): Declare.\n\t(array_elt_at_offset): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/102238\n\tPR tree-optimization/102919\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-23.c: Remove warnings.\n\t* gcc.dg/Wrestrict-23.c: New test.", "tree": {"sha": "5f6066e4ea74c6ac5a9a3e6e52ae5abb0a6cc95b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f6066e4ea74c6ac5a9a3e6e52ae5abb0a6cc95b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a27acc30a34b7854db32eac562306cebac6fa1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a27acc30a34b7854db32eac562306cebac6fa1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a27acc30a34b7854db32eac562306cebac6fa1e"}], "stats": {"total": 593, "additions": 468, "deletions": 125}, "files": [{"sha": "ec78090b382ef8060fda9326c48b39f3f07680e3", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 136, "deletions": 114, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "patch": "@@ -2024,8 +2024,8 @@ format_floating (const directive &dir, tree arg, range_query *)\n    Used by the format_string function below.  */\n \n static fmtresult\n-get_string_length (tree str, gimple *stmt, unsigned eltsize,\n-\t\t   range_query *query)\n+get_string_length (tree str, gimple *stmt, unsigned HOST_WIDE_INT max_size,\n+\t\t   unsigned eltsize, range_query *query)\n {\n   if (!str)\n     return fmtresult ();\n@@ -2065,6 +2065,20 @@ get_string_length (tree str, gimple *stmt, unsigned eltsize,\n       && (!lendata.maxbound || lenmax <= tree_to_uhwi (lendata.maxbound))\n       && lenmax <= tree_to_uhwi (lendata.maxlen))\n     {\n+      if (max_size > 0 && max_size < HOST_WIDE_INT_MAX)\n+\t{\n+\t  /* Adjust the conservative unknown/unbounded result if MAX_SIZE\n+\t     is valid.  Set UNLIKELY to maximum in case MAX_SIZE refers\n+\t     to a subobject.\n+\t     TODO: This is overly conservative.  Set UNLIKELY to the size\n+\t     of the outermost enclosing declared object.  */\n+\t  fmtresult res (0, max_size - 1);\n+\t  res.nonstr = lendata.decl;\n+\t  res.range.likely = res.range.max;\n+\t  res.range.unlikely = HOST_WIDE_INT_MAX;\n+\t  return res;\n+\t}\n+\n       fmtresult res;\n       res.nonstr = lendata.decl;\n       return res;\n@@ -2203,110 +2217,80 @@ format_character (const directive &dir, tree arg, range_query *query)\n   return res.adjust_for_width_or_precision (dir.width);\n }\n \n-/* Determine the offset *INDEX of the first byte of an array element of\n-   TYPE (possibly recursively) into which the byte offset OFF points.\n-   On success set *INDEX to the offset of the first byte and return type.\n-   Otherwise, if no such element can be found, return null.  */\n+/* If TYPE is an array or struct or union, increment *FLDOFF by the starting\n+   offset of the member that *OFF point into and set *FLDSIZE to its size\n+   in bytes and decrement *OFF by the same.  Otherwise do nothing.  */\n \n-static tree\n-array_elt_at_offset (tree type, HOST_WIDE_INT off, HOST_WIDE_INT *index)\n+static void\n+set_aggregate_size_and_offset (tree type, HOST_WIDE_INT *fldoff,\n+\t\t\t       HOST_WIDE_INT *fldsize, HOST_WIDE_INT *off)\n {\n-  gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n-\n-  tree eltype = type;\n-  while (TREE_CODE (TREE_TYPE (eltype)) == ARRAY_TYPE)\n-    eltype = TREE_TYPE (eltype);\n-\n-  if (TYPE_MODE (TREE_TYPE (eltype)) != TYPE_MODE (char_type_node))\n-    eltype = TREE_TYPE (eltype);\n-\n-  if (eltype == type)\n-    {\n-      *index = 0;\n-      return type;\n-    }\n-\n-  HOST_WIDE_INT typsz = int_size_in_bytes (type);\n-  HOST_WIDE_INT eltsz = int_size_in_bytes (eltype);\n-  if (off < typsz * eltsz)\n+  /* The byte offset of the most basic struct member the byte\n+     offset *OFF corresponds to, or for a (multidimensional)\n+     array member, the byte offset of the array element.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n     {\n-      *index = (off / eltsz) * eltsz;\n-      return TREE_CODE (eltype) == ARRAY_TYPE ? TREE_TYPE (eltype) : eltype;\n+      HOST_WIDE_INT index = 0, arrsize = 0;\n+      if (array_elt_at_offset (type, *off, &index, &arrsize))\n+\t{\n+\t  *fldoff += index;\n+\t  *off -= index;\n+\t  *fldsize = arrsize;\n+\t}\n     }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Determine the offset *INDEX of the first byte of a struct member of TYPE\n-   (possibly recursively) into which the byte offset OFF points.  On success\n-   set *INDEX to the offset of the first byte and return true.  Otherwise,\n-   if no such member can be found, return false.  */\n-\n-static bool\n-field_at_offset (tree type, HOST_WIDE_INT off, HOST_WIDE_INT *index)\n-{\n-  gcc_assert (RECORD_OR_UNION_TYPE_P (type));\n-\n-  for (tree fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+  else if (RECORD_OR_UNION_TYPE_P (type))\n     {\n-      if (TREE_CODE (fld) != FIELD_DECL || DECL_ARTIFICIAL (fld))\n-\tcontinue;\n-\n-      tree fldtype = TREE_TYPE (fld);\n-      HOST_WIDE_INT fldoff = int_byte_position (fld);\n-\n-      /* If the size is not available the field is a flexible array\n-\t member.  Treat this case as success.  */\n-      tree typesize = TYPE_SIZE_UNIT (fldtype);\n-      HOST_WIDE_INT fldsize = (tree_fits_uhwi_p (typesize)\n-\t\t\t       ? tree_to_uhwi (typesize)\n-\t\t\t       : off);\n-\n-      if (fldoff + fldsize < off)\n-\tcontinue;\n-\n-      if (TREE_CODE (fldtype) == ARRAY_TYPE)\n+      HOST_WIDE_INT index = 0;\n+      tree sub = field_at_offset (type, NULL_TREE, *off, &index);\n+      if (sub)\n \t{\n-\t  HOST_WIDE_INT idx = 0;\n-\t  if (tree ft = array_elt_at_offset (fldtype, off, &idx))\n-\t    fldtype = ft;\n+\t  tree subsize = DECL_SIZE_UNIT (sub);\n+\t  if (*fldsize < HOST_WIDE_INT_MAX\n+\t      && subsize\n+\t      && tree_fits_uhwi_p (subsize))\n+\t    *fldsize = tree_to_uhwi (subsize);\n \t  else\n-\t    break;\n-\n-\t  *index += idx;\n-\t  fldoff -= idx;\n-\t  off -= idx;\n-\t}\n-\n-      if (RECORD_OR_UNION_TYPE_P (fldtype))\n-\t{\n-\t  *index += fldoff;\n-\t  return field_at_offset (fldtype, off - fldoff, index);\n+\t    *fldsize = HOST_WIDE_INT_MAX;\n+\t  *fldoff += index;\n+\t  *off -= index;\n \t}\n-\n-      *index += fldoff;\n-      return true;\n     }\n-\n-  return false;\n }\n \n /* For an expression X of pointer type, recursively try to find the same\n-   origin (object or pointer) as Y it references and return such an X.\n-   When X refers to a struct member, set *FLDOFF to the offset of the\n-   member from the beginning of the \"most derived\" object.  */\n+   origin (object or pointer) as Y it references and return such a Y.\n+   When X refers to an array element or struct member, set *FLDOFF to\n+   the offset of the element or member from the beginning of the \"most\n+   derived\" object and *FLDSIZE to its size.  When nonnull, set *OFF to\n+   the overall offset from the beginning of the object so that\n+   *FLDOFF <= *OFF.  */\n \n static tree\n-get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off)\n+get_origin_and_offset_r (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *fldsize,\n+\t\t\t HOST_WIDE_INT *off)\n {\n   if (!x)\n     return NULL_TREE;\n \n+  HOST_WIDE_INT sizebuf = -1;\n+  if (!fldsize)\n+    fldsize = &sizebuf;\n+\n+  if (DECL_P (x))\n+    {\n+      /* Set the size if it hasn't been set yet.  */\n+      if (tree size = DECL_SIZE_UNIT (x))\n+\tif (*fldsize < 0 && tree_fits_shwi_p (size))\n+\t  *fldsize = tree_to_shwi (size);\n+      return x;\n+    }\n+\n   switch (TREE_CODE (x))\n     {\n     case ADDR_EXPR:\n       x = TREE_OPERAND (x, 0);\n-      return get_origin_and_offset (x, fldoff, off);\n+      return get_origin_and_offset_r (x, fldoff, fldsize, off);\n \n     case ARRAY_REF:\n       {\n@@ -2326,7 +2310,7 @@ get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off)\n \t  *fldoff = idx;\n \n \tx = TREE_OPERAND (x, 0);\n-\treturn get_origin_and_offset (x, fldoff, NULL);\n+\treturn get_origin_and_offset_r (x, fldoff, fldsize, nullptr);\n       }\n \n     case MEM_REF:\n@@ -2345,32 +2329,19 @@ get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off)\n \t    = (TREE_CODE (x) == ADDR_EXPR\n \t       ? TREE_TYPE (TREE_OPERAND (x, 0)) : TREE_TYPE (TREE_TYPE (x)));\n \n-\t  /* The byte offset of the most basic struct member the byte\n-\t     offset *OFF corresponds to, or for a (multidimensional)\n-\t     array member, the byte offset of the array element.  */\n-\t  HOST_WIDE_INT index = 0;\n-\n-\t  if ((RECORD_OR_UNION_TYPE_P (xtype)\n-\t       && field_at_offset (xtype, *off, &index))\n-\t      || (TREE_CODE (xtype) == ARRAY_TYPE\n-\t\t  && TREE_CODE (TREE_TYPE (xtype)) == ARRAY_TYPE\n-\t\t  && array_elt_at_offset (xtype, *off, &index)))\n-\t    {\n-\t      *fldoff += index;\n-\t      *off -= index;\n-\t    }\n+\t  set_aggregate_size_and_offset (xtype, fldoff, fldsize, off);\n \t}\n \n-      return get_origin_and_offset (x, fldoff, NULL);\n+      return get_origin_and_offset_r (x, fldoff, fldsize, nullptr);\n \n     case COMPONENT_REF:\n       {\n \ttree fld = TREE_OPERAND (x, 1);\n \t*fldoff += int_byte_position (fld);\n \n-\tget_origin_and_offset (fld, fldoff, off);\n+\tget_origin_and_offset_r (fld, fldoff, fldsize, off);\n \tx = TREE_OPERAND (x, 0);\n-\treturn get_origin_and_offset (x, fldoff, off);\n+\treturn get_origin_and_offset_r (x, fldoff, nullptr, off);\n       }\n \n     case SSA_NAME:\n@@ -2382,27 +2353,41 @@ get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off)\n \t    if (code == ADDR_EXPR)\n \t      {\n \t\tx = gimple_assign_rhs1 (def);\n-\t\treturn get_origin_and_offset (x, fldoff, off);\n+\t\treturn get_origin_and_offset_r (x, fldoff, fldsize, off);\n \t      }\n \n \t    if (code == POINTER_PLUS_EXPR)\n \t      {\n \t\ttree offset = gimple_assign_rhs2 (def);\n-\t\tif (off)\n-\t\t  *off = (tree_fits_uhwi_p (offset)\n-\t\t\t  ? tree_to_uhwi (offset) : HOST_WIDE_INT_MAX);\n+\t\tif (off && tree_fits_uhwi_p (offset))\n+\t\t  *off = tree_to_uhwi (offset);\n \n \t\tx = gimple_assign_rhs1 (def);\n-\t\treturn get_origin_and_offset (x, fldoff, NULL);\n+\t\tx = get_origin_and_offset_r (x, fldoff, fldsize, off);\n+\t\tif (off && !tree_fits_uhwi_p (offset))\n+\t\t  *off = HOST_WIDE_INT_MAX;\n+\t\tif (off)\n+\t\t  {\n+\t\t    tree xtype = TREE_TYPE (x);\n+\t\t    set_aggregate_size_and_offset (xtype, fldoff, fldsize, off);\n+\t\t  }\n+\t\treturn x;\n \t      }\n \t    else if (code == VAR_DECL)\n \t      {\n \t\tx = gimple_assign_rhs1 (def);\n-\t\treturn get_origin_and_offset (x, fldoff, off);\n+\t\treturn get_origin_and_offset_r (x, fldoff, fldsize, off);\n \t      }\n \t  }\n \telse if (gimple_nop_p (def) && SSA_NAME_VAR (x))\n \t  x = SSA_NAME_VAR (x);\n+\n+\ttree xtype = TREE_TYPE (x);\n+\tif (POINTER_TYPE_P (xtype))\n+\t  xtype = TREE_TYPE (xtype);\n+\n+\tif (off)\n+\t  set_aggregate_size_and_offset (xtype, fldoff, fldsize, off);\n       }\n \n     default:\n@@ -2412,13 +2397,41 @@ get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off)\n   return x;\n }\n \n+/* Nonrecursive version of the above.  */\n+\n+static tree\n+get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off,\n+\t\t       HOST_WIDE_INT *fldsize = nullptr)\n+{\n+  HOST_WIDE_INT sizebuf;\n+  if (!fldsize)\n+    fldsize = &sizebuf;\n+\n+  *fldsize = -1;\n+\n+  *fldoff = *off = *fldsize = 0;\n+  tree orig = get_origin_and_offset_r (x, fldoff, fldsize, off);\n+  if (!orig)\n+    return NULL_TREE;\n+\n+  if (!*fldoff && *off == *fldsize)\n+    {\n+      *fldoff = *off;\n+      *off = 0;\n+    }\n+\n+  return orig;\n+}\n+\n /* If ARG refers to the same (sub)object or array element as described\n    by DST and DST_FLD, return the byte offset into the struct member or\n-   array element referenced by ARG.  Otherwise return HOST_WIDE_INT_MIN\n-   to indicate that ARG and DST do not refer to the same object.  */\n+   array element referenced by ARG and set *ARG_SIZE to the size of\n+   the (sub)object.  Otherwise return HOST_WIDE_INT_MIN to indicate\n+   that ARG and DST do not refer to the same object.  */\n \n static HOST_WIDE_INT\n-alias_offset (tree arg, tree dst, HOST_WIDE_INT dst_fld)\n+alias_offset (tree arg, HOST_WIDE_INT *arg_size,\n+\t      tree dst, HOST_WIDE_INT dst_fld)\n {\n   /* See if the argument refers to the same base object as the destination\n      of the formatted function call, and if so, try to determine if they\n@@ -2430,7 +2443,7 @@ alias_offset (tree arg, tree dst, HOST_WIDE_INT dst_fld)\n      to a struct member, see if the members are one and the same.  */\n   HOST_WIDE_INT arg_off = 0, arg_fld = 0;\n \n-  tree arg_orig = get_origin_and_offset (arg, &arg_fld, &arg_off);\n+  tree arg_orig = get_origin_and_offset (arg, &arg_fld, &arg_off, arg_size);\n \n   if (arg_orig == dst && arg_fld == dst_fld)\n     return arg_off;\n@@ -2448,15 +2461,23 @@ format_string (const directive &dir, tree arg, range_query *query)\n {\n   fmtresult res;\n \n+  /* The size of the (sub)object ARG refers to.  Used to adjust\n+     the conservative get_string_length() result.  */\n+  HOST_WIDE_INT arg_size = 0;\n+\n   if (warn_restrict)\n     {\n       /* See if ARG might alias the destination of the call with\n \t DST_ORIGIN and DST_FIELD.  If so, store the starting offset\n \t so that the overlap can be determined for certain later,\n \t when the amount of output of the call (including subsequent\n \t directives) has been computed.  Otherwise, store HWI_MIN.  */\n-      res.dst_offset = alias_offset (arg, dir.info->dst_origin,\n+      res.dst_offset = alias_offset (arg, &arg_size, dir.info->dst_origin,\n \t\t\t\t     dir.info->dst_field);\n+      if (res.dst_offset >= 0 && res.dst_offset <= arg_size)\n+\targ_size -= res.dst_offset;\n+      else\n+\targ_size = 0;\n     }\n \n   /* Compute the range the argument's length can be in.  */\n@@ -2473,7 +2494,8 @@ format_string (const directive &dir, tree arg, range_query *query)\n       gcc_checking_assert (count_by == 2 || count_by == 4);\n     }\n \n-  fmtresult slen = get_string_length (arg, dir.info->callstmt, count_by, query);\n+  fmtresult slen =\n+    get_string_length (arg, dir.info->callstmt, arg_size, count_by, query);\n   if (slen.range.min == slen.range.max\n       && slen.range.min < HOST_WIDE_INT_MAX)\n     {"}, {"sha": "a0e4543d8a3e86575d01ced95afc64ebc73130c9", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "patch": "@@ -2194,3 +2194,167 @@ compute_objsize (tree ptr, int ostype, tree *pdecl /* = NULL */,\n \n   return size;\n }\n+\n+/* Determine the offset *FLDOFF of the first byte of a struct member\n+   of TYPE (possibly recursively) into which the byte offset OFF points,\n+   starting after the field START_AFTER if it's non-null.  On success,\n+   if nonnull, set *FLDOFF to the offset of the first byte, and return\n+   the field decl.  If nonnull, set *NEXTOFF to the offset of the next\n+   field (which reflects any padding between the returned field and\n+   the next).  Otherwise, if no such member can be found, return null.  */\n+\n+tree\n+field_at_offset (tree type, tree start_after, HOST_WIDE_INT off,\n+\t\t HOST_WIDE_INT *fldoff /* = nullptr */,\n+\t\t HOST_WIDE_INT *nextoff /* = nullptr */)\n+{\n+  tree first_fld = TYPE_FIELDS (type);\n+\n+  HOST_WIDE_INT offbuf = 0, nextbuf = 0;\n+  if (!fldoff)\n+    fldoff = &offbuf;\n+  if (!nextoff)\n+    nextoff = &nextbuf;\n+\n+  *nextoff = 0;\n+\n+  /* The field to return.  */\n+  tree last_fld = NULL_TREE;\n+  /* The next field to advance to.  */\n+  tree next_fld = NULL_TREE;\n+\n+  /* NEXT_FLD's cached offset.  */\n+  HOST_WIDE_INT next_pos = -1;\n+\n+  for (tree fld = first_fld; fld; fld = next_fld)\n+    {\n+      next_fld = fld;\n+      do\n+\t/* Advance to the next relevant data member.  */\n+\tnext_fld = TREE_CHAIN (next_fld);\n+      while (next_fld\n+\t     && (TREE_CODE (next_fld) != FIELD_DECL\n+\t\t || DECL_ARTIFICIAL (next_fld)));\n+\n+      if (TREE_CODE (fld) != FIELD_DECL || DECL_ARTIFICIAL (fld))\n+\tcontinue;\n+\n+      if (fld == start_after)\n+\tcontinue;\n+\n+      tree fldtype = TREE_TYPE (fld);\n+      /* The offset of FLD within its immediately enclosing structure.  */\n+      HOST_WIDE_INT fldpos = next_pos < 0 ? int_byte_position (fld) : next_pos;\n+\n+      /* If the size is not available the field is a flexible array\n+\t member.  Treat this case as success.  */\n+      tree typesize = TYPE_SIZE_UNIT (fldtype);\n+      HOST_WIDE_INT fldsize = (tree_fits_uhwi_p (typesize)\n+\t\t\t       ? tree_to_uhwi (typesize)\n+\t\t\t       : off);\n+\n+      /* If OFF is beyond the end of the current field continue.  */\n+      HOST_WIDE_INT fldend = fldpos + fldsize;\n+      if (fldend < off)\n+\tcontinue;\n+\n+      if (next_fld)\n+\t{\n+\t  /* If OFF is equal to the offset of the next field continue\n+\t     to it and skip the array/struct business below.  */\n+\t  next_pos = int_byte_position (next_fld);\n+\t  *nextoff = *fldoff + next_pos;\n+\t  if (*nextoff == off && TREE_CODE (type) != UNION_TYPE)\n+\t    continue;\n+\t}\n+      else\n+\t*nextoff = HOST_WIDE_INT_MAX;\n+\n+      /* OFF refers somewhere into the current field or just past its end,\n+\t which could mean it refers to the next field.  */\n+      if (TREE_CODE (fldtype) == ARRAY_TYPE)\n+\t{\n+\t  /* Will be set to the offset of the first byte of the array\n+\t     element (which may be an array) of FLDTYPE into which\n+\t     OFF - FLDPOS points (which may be past ELTOFF).  */\n+\t  HOST_WIDE_INT eltoff = 0;\n+\t  if (tree ft = array_elt_at_offset (fldtype, off - fldpos, &eltoff))\n+\t    fldtype = ft;\n+\t  else\n+\t    continue;\n+\n+\t  /* Advance the position to include the array element above.\n+\t     If OFF - FLPOS refers to a member of FLDTYPE, the member\n+\t     will be determined below.  */\n+\t  fldpos += eltoff;\n+\t}\n+\n+      *fldoff += fldpos;\n+\n+      if (TREE_CODE (fldtype) == RECORD_TYPE)\n+\t/* Drill down into the current field if it's a struct.  */\n+\tfld = field_at_offset (fldtype, start_after, off - fldpos,\n+\t\t\t       fldoff, nextoff);\n+\n+      last_fld = fld;\n+\n+      /* Unless the offset is just past the end of the field return it.\n+\t Otherwise save it and return it only if the offset of the next\n+\t next field is greater (i.e., there is padding between the two)\n+\t or if there is no next field.  */\n+      if (off < fldend)\n+\tbreak;\n+    }\n+\n+  if (*nextoff == HOST_WIDE_INT_MAX && next_fld)\n+    *nextoff = next_pos;\n+\n+  return last_fld;\n+}\n+\n+/* Determine the offset *ELTOFF of the first byte of the array element\n+   of array ARTYPE into which the byte offset OFF points.  On success\n+   set *ELTOFF to the offset of the first byte and return type.\n+   Otherwise, if no such element can be found, return null.  */\n+\n+tree\n+array_elt_at_offset (tree artype, HOST_WIDE_INT off,\n+\t\t     HOST_WIDE_INT *eltoff /* = nullptr */,\n+\t\t     HOST_WIDE_INT *subar_size /* = nullptr */)\n+{\n+  gcc_assert (TREE_CODE (artype) == ARRAY_TYPE);\n+\n+  HOST_WIDE_INT dummy;\n+  if (!eltoff)\n+    eltoff = &dummy;\n+  if (!subar_size)\n+    subar_size = &dummy;\n+\n+  tree eltype = artype;\n+  while (TREE_CODE (TREE_TYPE (eltype)) == ARRAY_TYPE)\n+    eltype = TREE_TYPE (eltype);\n+\n+  tree subartype = eltype;\n+  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (eltype))\n+      || TYPE_MODE (TREE_TYPE (eltype)) != TYPE_MODE (char_type_node))\n+    eltype = TREE_TYPE (eltype);\n+\n+  *subar_size = int_size_in_bytes (subartype);\n+\n+  if (eltype == artype)\n+    {\n+      *eltoff = 0;\n+      return artype;\n+    }\n+\n+  HOST_WIDE_INT artype_size = int_size_in_bytes (artype);\n+  HOST_WIDE_INT eltype_size = int_size_in_bytes (eltype);\n+\n+  if (off < artype_size)// * eltype_size)\n+    {\n+      *eltoff = (off / eltype_size) * eltype_size;\n+      return TREE_CODE (eltype) == ARRAY_TYPE ? TREE_TYPE (eltype) : eltype;\n+    }\n+\n+  return NULL_TREE;\n+}"}, {"sha": "c8215b681ef859442847af3d0a4d8408ebf070af", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "patch": "@@ -266,4 +266,13 @@ inline tree compute_objsize (tree ptr, int ostype, access_ref *pref)\n extern tree compute_objsize (tree, int, tree * = nullptr, tree * = nullptr,\n \t\t\t     range_query * = nullptr);\n \n+/* Return the field at the constant offset.  */\n+extern tree field_at_offset (tree, tree, HOST_WIDE_INT,\n+\t\t\t     HOST_WIDE_INT * = nullptr,\n+\t\t\t     HOST_WIDE_INT * = nullptr);\n+/* Return the array at the constant offset.  */\n+extern tree array_elt_at_offset (tree, HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT * = nullptr,\n+\t\t\t\t HOST_WIDE_INT * = nullptr);\n+\n #endif   // GCC_POINTER_QUERY_H"}, {"sha": "c7a828bb8ebf3598858919e57b5dd50bc1e6c54c", "filename": "gcc/testsuite/gcc.dg/Wrestrict-23.c", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-23.c?ref=1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "patch": "@@ -0,0 +1,146 @@\n+/* PR tree-optimization/102238 - missing -Wrestrict on sprintf formatting\n+   a struct member into enclosing object\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-format-overflow\" } */\n+\n+extern int sprintf (char*, const char*, ...);\n+\n+extern void sink (void*, ...);\n+\n+struct A\n+{\n+  char a[4];\n+};\n+\n+struct B\n+{\n+  struct A a1, a2;\n+};\n+\n+extern struct B eb;\n+\n+enum { B_a2_a_off = __builtin_offsetof (struct B, a2.a) };\n+\n+\n+void test_warn_src_decl_plus (void)\n+{\n+  {\n+    char *s = (char*)&eb + B_a2_a_off;\n+    char *d = eb.a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"overlaps\" }\n+  }\n+\n+  {\n+    // If strlen (s) > 0 there is overlap with a[1].\n+    char *s = (char*)&eb + B_a2_a_off + 1;\n+    char *d = eb.a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+\n+  {\n+    // strlen (s) must be at most 1 so there can be no overlap with a.\n+    char *s = (char*)&eb + B_a2_a_off + 2;\n+    char *d = eb.a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-bogus \"-Wrestrict\" }\n+  }\n+\n+  {\n+    // strlen (s) must be at most 0 so there can be no overlap with a.\n+    char *s = (char*)&eb + B_a2_a_off + 3;\n+    char *d = eb.a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-bogus \"-Wrestrict\" }\n+  }\n+}\n+\n+\n+void test_warn_src_ptr_plus (struct B *p)\n+{\n+  {\n+    char *s = (char*)p + B_a2_a_off;\n+    char *d = p->a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"overlaps\" }\n+  }\n+\n+  {\n+    // If strlen (s) > 0 there is overlap with a[1].\n+    char *s = (char*)p + B_a2_a_off + 1;\n+    char *d = p->a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+\n+  {\n+    // strlen (s) must be at most 1 so there can be no overlap with a.\n+    char *s = (char*)p + B_a2_a_off + 2;\n+    char *d = p->a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-bogus \"-Wrestrict\" }\n+  }\n+\n+  {\n+    // strlen (s) must be at most 0 so there can be no overlap with a.\n+    char *s = (char*)p + B_a2_a_off + 3;\n+    char *d = p->a2.a;\n+    sprintf (d, \"%s\", s);     // { dg-bogus \"-Wrestrict\" }\n+  }\n+}\n+\n+\n+void test_warn_dst_decl_plus (void)\n+{\n+  {\n+    char *s = eb.a2.a;\n+    char *d = (char*)&eb + B_a2_a_off;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"overlaps\" }\n+  }\n+\n+  {\n+    // If strlen (a) > 0 there is overlap with a[1].\n+    char *s = eb.a2.a;\n+    char *d = (char*)&eb + B_a2_a_off + 1;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+\n+  {\n+    // If strlen (a) > 1 there is overlap with a[2].\n+    char *s = eb.a2.a;\n+    char *d = (char*)&eb + B_a2_a_off + 2;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+\n+  {\n+    // If strlen (a) > 2 there is overlap with a[3].\n+    char *s = eb.a2.a;\n+    char *d = (char*)&eb + B_a2_a_off + 3;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+}\n+\n+\n+void test_warn_dst_ptr_plus (struct B *p)\n+{\n+  {\n+    char *s = p->a2.a;\n+    char *d = (char*)p + B_a2_a_off;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"overlaps\" }\n+  }\n+\n+  {\n+    // If strlen (a) > 0 there is overlap with a[1].\n+    char *s = p->a2.a;\n+    char *d = (char*)p + B_a2_a_off + 1;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+\n+  {\n+    // If strlen (a) > 1 there is overlap with a[2].\n+    char *s = p->a2.a;\n+    char *d = (char*)p + B_a2_a_off + 2;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+\n+  {\n+    // If strlen (a) > 2 there is overlap with a[3].\n+    char *s = p->a2.a;\n+    char *d = (char*)p + B_a2_a_off + 3;\n+    sprintf (d, \"%s\", s);     // { dg-warning \"may overlap\" }\n+  }\n+}"}, {"sha": "112b08afc44bef104b494061b015d1284a456b9d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-23.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff4dbddcf74203a1e16316b18e12f9e1b5085f0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c?ref=1ff4dbddcf74203a1e16316b18e12f9e1b5085f0", "patch": "@@ -214,12 +214,14 @@ void test_struct_member_array (struct S3 *s3, int i)\n   T (d, \"%s\", d);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", d + 0);   /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", d + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", d + 2);   /* { dg-warning \"may overlap\" } */\n+  /* Since d below points to char[4], strlen(d + 2) must be at most 1\n+     and so the call cannot overlap. */\n+  T (d, \"%s\", d + 2);\n   T (d, \"%s\", d + i);   /* { dg-warning \"may overlap\" } */\n \n   T (d, \"%s\", &d[0]);   /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", &d[1]);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", &d[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[2]);\n   T (d, \"%s\", &d[i]);   /* { dg-warning \"may overlap\" } */\n \n   T (d + 0, \"%s\", d);   /* { dg-warning \"overlaps\" } */\n@@ -236,7 +238,7 @@ void test_struct_member_array (struct S3 *s3, int i)\n \n   T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);\n   T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n \n   s = s3->s2_1.s_1.b;\n@@ -324,7 +326,7 @@ void test_struct_member_array (struct S3 *s3, int i)\n \n   T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);\n   T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n \n   s = s3->s2_2.s_2.a;\n@@ -368,7 +370,7 @@ void test_struct_member_array (struct S3 *s3, int i)\n \n   T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);\n   T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n \n   s = s3->s2_2.s_2.a;\n@@ -394,12 +396,12 @@ void test_struct_member_array_array (struct S3 *s3, int i)\n   T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", s + 0);   /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);\n   T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n \n   T (d, \"%s\", &s[0]);   /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", &s[1]);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", &s[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[2]);\n   T (d, \"%s\", &s[i]);   /* { dg-warning \"may overlap\" } */\n \n   T (d + 0, \"%s\", s);   /* { dg-warning \"overlaps\" } */\n@@ -566,12 +568,12 @@ void test_union_member_array (union U *un, int i)\n   T (d, \"%s\", d);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", d + 0);   /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", d + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", d + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", d + 2);\n   T (d, \"%s\", d + i);   /* { dg-warning \"may overlap\" } */\n \n   T (d, \"%s\", &d[0]);   /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", &d[1]);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", &d[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[2]);\n   T (d, \"%s\", &d[i]);   /* { dg-warning \"may overlap\" } */\n \n   T (d + 0, \"%s\", d);   /* { dg-warning \"overlaps\" } */\n@@ -588,7 +590,7 @@ void test_union_member_array (union U *un, int i)\n \n   T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);\n   T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n \n   s = un->s2_1.s_1.b;\n@@ -616,7 +618,7 @@ void test_union_member_array (union U *un, int i)\n \n   T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n   T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n-  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);\n   T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n \n   s = un->s2_2.s_1.b;"}]}