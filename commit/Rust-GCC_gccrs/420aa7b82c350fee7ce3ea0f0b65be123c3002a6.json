{"sha": "420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIwYWE3YjgyYzM1MGZlZTdjZTNlYTBmMGI2NWJlMTIzYzMwMDJhNg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2005-05-15T12:49:45Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2005-05-15T12:49:45Z"}, "message": "Remove extra whitespace.\n\nFrom-SVN: r99720", "tree": {"sha": "0a01e2ea549c9f0e67b07d2dfa92acd10dfd7e63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a01e2ea549c9f0e67b07d2dfa92acd10dfd7e63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/comments", "author": null, "committer": null, "parents": [{"sha": "4b6903ec2f37dc342e2a6dbf5507258a845e610f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6903ec2f37dc342e2a6dbf5507258a845e610f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6903ec2f37dc342e2a6dbf5507258a845e610f"}], "stats": {"total": 126, "additions": 62, "deletions": 64}, "files": [{"sha": "5eb8b44631ba9ea5b2e732d8d570743807206016", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -92,12 +92,12 @@ matmul_c4 (gfc_array_c4 * retarray, gfc_array_c4 * a, gfc_array_c4 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_COMPLEX_4) * size0 ((array_t *) retarray));\n       retarray->base = 0;\n@@ -157,7 +157,7 @@ matmul_c4 (gfc_array_c4 * retarray, gfc_array_c4 * a, gfc_array_c4 * b)\n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n \t an incorrect result. */\n-      bystride = 0xDEADBEEF; \n+      bystride = 0xDEADBEEF;\n       ycount = 1;\n     }\n   else"}, {"sha": "181f4c9cc4d14e08058e91902f56810729720689", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -92,12 +92,12 @@ matmul_c8 (gfc_array_c8 * retarray, gfc_array_c8 * a, gfc_array_c8 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_COMPLEX_8) * size0 ((array_t *) retarray));\n       retarray->base = 0;\n@@ -157,7 +157,7 @@ matmul_c8 (gfc_array_c8 * retarray, gfc_array_c8 * a, gfc_array_c8 * b)\n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n \t an incorrect result. */\n-      bystride = 0xDEADBEEF; \n+      bystride = 0xDEADBEEF;\n       ycount = 1;\n     }\n   else"}, {"sha": "f214ba5ec0c8108a1e0aa600adbd8a895a84ab9f", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -92,12 +92,12 @@ matmul_i4 (gfc_array_i4 * retarray, gfc_array_i4 * a, gfc_array_i4 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_INTEGER_4) * size0 ((array_t *) retarray));\n       retarray->base = 0;\n@@ -157,7 +157,7 @@ matmul_i4 (gfc_array_i4 * retarray, gfc_array_i4 * a, gfc_array_i4 * b)\n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n \t an incorrect result. */\n-      bystride = 0xDEADBEEF; \n+      bystride = 0xDEADBEEF;\n       ycount = 1;\n     }\n   else"}, {"sha": "5e0e6a792f969e254bd96f95d97b92502005121e", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -92,12 +92,12 @@ matmul_i8 (gfc_array_i8 * retarray, gfc_array_i8 * a, gfc_array_i8 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_INTEGER_8) * size0 ((array_t *) retarray));\n       retarray->base = 0;\n@@ -157,7 +157,7 @@ matmul_i8 (gfc_array_i8 * retarray, gfc_array_i8 * a, gfc_array_i8 * b)\n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n \t an incorrect result. */\n-      bystride = 0xDEADBEEF; \n+      bystride = 0xDEADBEEF;\n       ycount = 1;\n     }\n   else"}, {"sha": "ba43dda2856a13fb86b839e1258450d346eeafb3", "filename": "libgfortran/generated/matmul_l4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l4.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -83,12 +83,12 @@ matmul_l4 (gfc_array_l4 * retarray, gfc_array_l4 * a, gfc_array_l4 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_LOGICAL_4) * size0 ((array_t *) retarray));\n       retarray->base = 0;"}, {"sha": "75b483949995015f22ed68b5f2123379e7a3838b", "filename": "libgfortran/generated/matmul_l8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l8.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -83,12 +83,12 @@ matmul_l8 (gfc_array_l8 * retarray, gfc_array_l4 * a, gfc_array_l4 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_LOGICAL_8) * size0 ((array_t *) retarray));\n       retarray->base = 0;"}, {"sha": "b6014d0dbce52c2913ca709083d1088ac5211471", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -92,12 +92,12 @@ matmul_r4 (gfc_array_r4 * retarray, gfc_array_r4 * a, gfc_array_r4 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_REAL_4) * size0 ((array_t *) retarray));\n       retarray->base = 0;\n@@ -157,7 +157,7 @@ matmul_r4 (gfc_array_r4 * retarray, gfc_array_r4 * a, gfc_array_r4 * b)\n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n \t an incorrect result. */\n-      bystride = 0xDEADBEEF; \n+      bystride = 0xDEADBEEF;\n       ycount = 1;\n     }\n   else"}, {"sha": "5bf21f60404cedbb0b969308dece60f2156f2164", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -92,12 +92,12 @@ matmul_r8 (gfc_array_r8 * retarray, gfc_array_r8 * a, gfc_array_r8 * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (GFC_REAL_8) * size0 ((array_t *) retarray));\n       retarray->base = 0;\n@@ -157,7 +157,7 @@ matmul_r8 (gfc_array_r8 * retarray, gfc_array_r8 * a, gfc_array_r8 * b)\n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n \t an incorrect result. */\n-      bystride = 0xDEADBEEF; \n+      bystride = 0xDEADBEEF;\n       ycount = 1;\n     }\n   else"}, {"sha": "0cb74719f1b1ce1414324a84baa1a460b25e17b0", "filename": "libgfortran/intrinsics/etime.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fintrinsics%2Fetime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fintrinsics%2Fetime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fetime.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -94,7 +94,7 @@ etime (gfc_array_r4 *t)\n   return val;\n }\n \n-/* LAPACK's test programs declares ETIME external, therefore we \n+/* LAPACK's test programs declares ETIME external, therefore we\n    need this.  */\n \n extern GFC_REAL_4 etime_ (GFC_REAL_4 *t);"}, {"sha": "107eec19f78f3f6ed8912eea209fe313caae3147", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -621,7 +621,7 @@ arandom_r8 (gfc_array_r8 *x)\n }\n \n /* random_seed is used to seed the PRNG with either a default\n-   set of seeds or user specified set of seeds.  random_seed \n+   set of seeds or user specified set of seeds.  random_seed\n    must be called with no argument or exactly one argument.  */\n \n void"}, {"sha": "62000f1ba3d34938ecb812777e2635da7f7f9a21", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -230,7 +230,7 @@ typedef struct\n   GFC_INTEGER_4 rec;\n   GFC_INTEGER_4 *nextrec, *size;\n \n-  GFC_INTEGER_4 recl_in; \n+  GFC_INTEGER_4 recl_in;\n   GFC_INTEGER_4 *recl_out;\n \n   GFC_INTEGER_4 *iolength;\n@@ -343,7 +343,7 @@ typedef struct\n   unit_blank blank_status;\n   enum {SIGN_S, SIGN_SS, SIGN_SP} sign_status;\n   int scale_factor;\n-  jmp_buf eof_jump;  \n+  jmp_buf eof_jump;\n }\n global_t;\n "}, {"sha": "b6721557c6ea3e7ec8800d4851a1606f544f077e", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -1377,11 +1377,11 @@ list_formatted_read (bt type, void *p, int len)\n \n     case BT_CHARACTER:\n       if (saved_string)\n-       { \n+       {\n           m = (len < saved_used) ? len : saved_used;\n           memcpy (p, saved_string, m);\n        }\n-      else    \n+      else\n \t/* Just delimiters encountered, nothing to copy but SPACE.  */\n         m = 0;\n \n@@ -1600,7 +1600,7 @@ nml_parse_qualifier(descriptor_dimension * ad,\n \n       /*Check the values of the triplet indices.  */\n \n-      if ( (ls[dim].start > (ssize_t)ad[dim].ubound) \n+      if ( (ls[dim].start > (ssize_t)ad[dim].ubound)\n \t|| (ls[dim].start < (ssize_t)ad[dim].lbound)\n \t|| (ls[dim].end   > (ssize_t)ad[dim].ubound)\n \t|| (ls[dim].end   < (ssize_t)ad[dim].lbound))\n@@ -1646,7 +1646,7 @@ find_nml_node (char * var_name)\n \n /* Visits all the components of a derived type that have\n    not explicitly been identified in the namelist input.\n-   touched is set and the loop specification initialised \n+   touched is set and the loop specification initialised\n    to default values  */\n \n static void\n@@ -1854,7 +1854,7 @@ nml_read_obj (namelist_info * nl, index_type offset)\n \tpdata = (void*)(pdata + (nl->ls[dim].idx - nl->dim[dim].lbound) *\n \t\t nl->dim[dim].stride * nl->size);\n \n-      /* Reset the error flag and try to read next value, if \n+      /* Reset the error flag and try to read next value, if\n \t repeat_count=0  */\n \n       nml_read_error = 0;\n@@ -1873,7 +1873,7 @@ nml_read_obj (namelist_info * nl, index_type offset)\n \n \t  saved_type = GFC_DTYPE_UNKNOWN;\n \t  free_saved ();\n- \n+\n           switch (nl->type)\n \t  {\n \t  case GFC_DTYPE_INTEGER:\n@@ -1904,7 +1904,7 @@ nml_read_obj (namelist_info * nl, index_type offset)\n \n \t    /* Now loop over the components. Update the component pointer\n \t       with the return value from nml_write_obj.  This loop jumps\n-\t       past nested derived types by testing if the potential \n+\t       past nested derived types by testing if the potential\n \t       component name contains '%'.  */\n \n \t    for (cmp = nl->next;\n@@ -1940,7 +1940,7 @@ nml_read_obj (namelist_info * nl, index_type offset)\n \n       /* The standard permits array data to stop short of the number of\n \t elements specified in the loop specification.  In this case, we\n-\t should be here with nml_read_error != 0.  Control returns to \n+\t should be here with nml_read_error != 0.  Control returns to\n \t nml_get_obj_data and an attempt is made to read object name.  */\n \n       prev_nl = nl;"}, {"sha": "9981a9f1daadcb4fc2ff0aa2aa2593d4fb1648ec", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -168,7 +168,7 @@ read_sf (int *length)\n     {\n       if (is_internal_unit())\n         {\n-\t  /* readlen may be modified inside salloc_r if \n+\t  /* readlen may be modified inside salloc_r if\n \t     is_internal_unit() is true.  */\n           readlen = 1;\n         }\n@@ -226,7 +226,7 @@ read_sf (int *length)\n    file, advancing the current position.  We return a pointer to a\n    buffer containing the bytes.  We return NULL on end of record or\n    end of file.\n-  \n+\n    If the read is short, then it is because the current record does not\n    have enough data to satisfy the read request and the file was\n    opened with PAD=YES.  The caller must assume tailing spaces for\n@@ -683,7 +683,7 @@ formatted_transfer (bt type, void *p, int len)\n            else // FMT==T\n              {\n                 consume_data_flag = 0 ;\n-                pos = f->u.n - 1; \n+                pos = f->u.n - 1;\n              }\n \n            if (pos < 0 || pos >= current_unit->recl )\n@@ -1122,12 +1122,12 @@ data_transfer_init (int read_flag)\n \tgenerate_error (ERROR_OS, NULL);\n     }\n \n-  /* Overwriting an existing sequential file ? \n+  /* Overwriting an existing sequential file ?\n      it is always safe to truncate the file on the first write */\n-  if (g.mode == WRITING \n-      && current_unit->flags.access == ACCESS_SEQUENTIAL \n+  if (g.mode == WRITING\n+      && current_unit->flags.access == ACCESS_SEQUENTIAL\n       && current_unit->current_record == 0)\n-        struncate(current_unit->s); \n+        struncate(current_unit->s);\n \n   current_unit->mode = g.mode;\n \n@@ -1227,7 +1227,7 @@ next_record_r (int done)\n \t{\n \t  new = file_position (current_unit->s) + current_unit->bytes_left;\n \n-\t  /* Direct access files do not generate END conditions, \n+\t  /* Direct access files do not generate END conditions,\n \t     only I/O errors.  */\n \t  if (sseek (current_unit->s, new) == FAILURE)\n \t    generate_error (ERROR_OS, NULL);\n@@ -1255,7 +1255,7 @@ next_record_r (int done)\n     case FORMATTED_SEQUENTIAL:\n       length = 1;\n       /* sf_read has already terminated input because of an '\\n'  */\n-      if (sf_seen_eor) \n+      if (sf_seen_eor)\n \t{\n \t  sf_seen_eor=0;\n \t  break;\n@@ -1371,7 +1371,7 @@ next_record_w (int done)\n         }\n \n       if (sfree (current_unit->s) == FAILURE)\n- \tgoto io_error;\n+\tgoto io_error;\n \n       break;\n \n@@ -1698,4 +1698,3 @@ export_proto(st_set_nml_var);\n extern void st_set_nml_var_dim (GFC_INTEGER_4, GFC_INTEGER_4,\n \t\t\t\tGFC_INTEGER_4 ,GFC_INTEGER_4);\n export_proto(st_set_nml_var_dim);\n-"}, {"sha": "86ca40ffa4cc6b44ec9b8cebeb33003945eea3f1", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -273,7 +273,7 @@ calculate_G_format (fnode *f, double value, int len, int *num_blank)\n static void\n output_float (fnode *f, double value, int len)\n {\n-  /* This must be large enough to accurately hold any value.  */ \n+  /* This must be large enough to accurately hold any value.  */\n   char buffer[32];\n   char *out;\n   char *digits;\n@@ -324,7 +324,7 @@ output_float (fnode *f, double value, int len)\n       if (edigits < 2)\n \tedigits = 2;\n     }\n-  \n+\n   if (ft == FMT_F || ft == FMT_EN\n       || ((ft == FMT_D || ft == FMT_E) && g.scale_factor != 0))\n     {\n@@ -344,7 +344,7 @@ output_float (fnode *f, double value, int len)\n     }\n \n   sprintf (buffer, \"%+-#31.*e\", ndigits - 1, value);\n-  \n+\n   /* Check the resulting string has punctuation in the correct places.  */\n   if (buffer[2] != '.' || buffer[ndigits + 2] != 'e')\n       internal_error (\"printf is broken\");\n@@ -514,7 +514,7 @@ output_float (fnode *f, double value, int len)\n       edigits = 1;\n       for (i = abs (e); i >= 10; i /= 10)\n \tedigits++;\n-      \n+\n       if (f->u.real.e < 0)\n \t{\n \t  /* Width not specified.  Must be no more than 3 digits.  */\n@@ -562,7 +562,7 @@ output_float (fnode *f, double value, int len)\n   nblanks = w - (nbefore + nzero + nafter + edigits + 1);\n   if (sign != SIGN_NONE)\n     nblanks--;\n-  \n+\n   /* Check the value fits in the specified field width.  */\n   if (nblanks < 0 || edigits == -1)\n     {\n@@ -640,7 +640,7 @@ output_float (fnode *f, double value, int len)\n       ndigits -= i;\n       out += nafter;\n     }\n-  \n+\n   /* Output the exponent.  */\n   if (expchar)\n     {\n@@ -707,22 +707,22 @@ write_float (fnode *f, const char *source, int len)\n \t    }\n \n \t  memset(p, ' ', nb);\n-\t  res = !isnan (n); \n+\t  res = !isnan (n);\n \t  if (res != 0)\n \t    {\n-\t      if (signbit(n))   \n+\t      if (signbit(n))\n \t\tfin = '-';\n \t      else\n \t\tfin = '+';\n \n \t      if (nb > 7)\n-\t\tmemcpy(p + nb - 8, \"Infinity\", 8); \n+\t\tmemcpy(p + nb - 8, \"Infinity\", 8);\n \t      else\n \t\tmemcpy(p + nb - 3, \"Inf\", 3);\n \t      if (nb < 8 && nb > 3)\n \t\tp[nb - 4] = fin;\n \t      else if (nb > 8)\n-\t\tp[nb - 9] = fin; \n+\t\tp[nb - 9] = fin;\n \t    }\n \t  else\n \t    memcpy(p + nb - 3, \"NaN\", 3);\n@@ -1430,7 +1430,7 @@ nml_write_obj (namelist_info * obj, index_type offset,\n \t    }\n \t  num++;\n \n-\t  /* Output the data, if an intrinsic type, or recurse into this \n+\t  /* Output the data, if an intrinsic type, or recurse into this\n \t     routine to treat derived types.  */\n \n \t  switch (obj->type)\n@@ -1466,10 +1466,10 @@ nml_write_obj (namelist_info * obj, index_type offset,\n \n \t      /* To treat a derived type, we need to build two strings:\n \t\t ext_name = the name, including qualifiers that prepends\n-\t\t\t    component names in the output - passed to \n+\t\t\t    component names in the output - passed to\n \t\t\t    nml_write_obj.\n \t\t obj_name = the derived type name with no qualifiers but %\n-\t\t\t    appended.  This is used to identify the \n+\t\t\t    appended.  This is used to identify the\n \t\t\t    components.  */\n \n \t      /* First ext_name => get length of all possible components  */\n@@ -1558,8 +1558,8 @@ nml_write_obj (namelist_info * obj, index_type offset,\n }\n \n /* This is the entry function for namelist writes.  It outputs the name\n-   of the namelist and iterates through the namelist by calls to \n-   nml_write_obj.  The call below has dummys in the arguments used in \n+   of the namelist and iterates through the namelist by calls to\n+   nml_write_obj.  The call below has dummys in the arguments used in\n    the treatment of derived types.  */\n \n void\n@@ -1617,4 +1617,3 @@ namelist_write (void)\n }\n \n #undef NML_DIGITS\n-"}, {"sha": "dd75cf7b0738de495eb2b371d7655ba1f291b9a6", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/420aa7b82c350fee7ce3ea0f0b65be123c3002a6/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=420aa7b82c350fee7ce3ea0f0b65be123c3002a6", "patch": "@@ -93,12 +93,12 @@ matmul_`'rtype_code (rtype * retarray, rtype * a, rtype * b)\n           retarray->dim[0].lbound = 0;\n           retarray->dim[0].ubound = a->dim[0].ubound - a->dim[0].lbound;\n           retarray->dim[0].stride = 1;\n-          \n+\n           retarray->dim[1].lbound = 0;\n           retarray->dim[1].ubound = b->dim[1].ubound - b->dim[1].lbound;\n           retarray->dim[1].stride = retarray->dim[0].ubound+1;\n         }\n-          \n+\n       retarray->data\n \t= internal_malloc_size (sizeof (rtype_name) * size0 ((array_t *) retarray));\n       retarray->base = 0;\n@@ -159,7 +159,7 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n       /* bystride should never be used for 1-dimensional b.\n \t in case it is we want it to cause a segfault, rather than\n \t an incorrect result. */\n-      bystride = 0xDEADBEEF; \n+      bystride = 0xDEADBEEF;\n       ycount = 1;\n     }\n   else"}]}