{"sha": "c71f835b2549f6b787732b5e326c5c23dbb1f66b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcxZjgzNWIyNTQ5ZjZiNzg3NzMyYjVlMzI2YzVjMjNkYmIxZjY2Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-07-05T05:33:57Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-05T05:33:57Z"}, "message": "cpplex.c: Don't include sys/mman.h.\n\ntoplevel:\n\t* cpplex.c: Don't include sys/mman.h.\n\t(cpp_push_buffer, cpp_pop_buffer): Moved to cpplib.c.\n\n\t* cpplib.c: Include sys/mman.h and obstack.h.\n\t(cpp_push_buffer): Moved from cpplex.c; allocate buffers on an\n\tobstack.\n\t(cpp_pop_buffer): Moved from cpplex.c; free buffers from an obstack.\n\t(_cpp_unwind_if_stack): Now static, unwind_if_stack.  Don't\n\tbother freeing if stack entries (they will be freed with their buffer).\n\t(do_endif): Free if stack entries from the buffer obstack.\n\t(push_conditional): Allocate if stack entries from the buffer obstack.\n\n\t(find_answer): Rename to _cpp_find_answer.\n\t(do_assert, do_unassert): Update.\n\n\t* cpphash.h: Update prototypes.\n\t(xobnew): New convenience macro.\n\t* cpplib.h (struct cpp_reader): Add hash_ob and buffer_ob fields.\n\tUpdate comments.\n\t(struct cpp_hashnode): Remove disabled field.\n\n\t* cppinit.c: Don't include hashtab.h or splay-tree.h.\n\t(report_missing_guard): Moved to cppfiles.c.\n\t(cpp_reader_init): Call cpp_init_stacks, cpp_init_macros,\n\tcpp_init_includes.\n\t(cpp_cleanup): Call cpp_cleanup_stacks, cpp_cleanup_macros,\n\tcpp_cleanup_includes.  Don't destroy hashtab or\n\tall_include_files here.\n\t(cpp_finish): Use _cpp_report_missing_guards.\n\n\t* cppfiles.c (report_missing_guard): Moved from cppinit.c.\n\t(_cpp_init_include_table): Rename _cpp_init_includes.\n\t(_cpp_cleanup_includes, _cpp_report_missing_guards): New.\n\n\t* cppexp.c (parse_assertion): Update for new name of\n\tfind_answer.\n\n\t* Makefile.in (cpplib.o, cpphash.o, cppinit.o): Update deps.\n\n\t* cpplib.c (do_ident): s/VSPACE/EOF/\n\ntestsuite:\n\t* gcc.dg/cpp/ident.c: New test.\n\nFrom-SVN: r34870", "tree": {"sha": "0faabdcd2aa742b82e58d484b96722dd2b861e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0faabdcd2aa742b82e58d484b96722dd2b861e6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c71f835b2549f6b787732b5e326c5c23dbb1f66b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c71f835b2549f6b787732b5e326c5c23dbb1f66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c71f835b2549f6b787732b5e326c5c23dbb1f66b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c71f835b2549f6b787732b5e326c5c23dbb1f66b/comments", "author": null, "committer": null, "parents": [{"sha": "1bbee75bcc0d3948fb1e55da6a3547cddeb000a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbee75bcc0d3948fb1e55da6a3547cddeb000a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bbee75bcc0d3948fb1e55da6a3547cddeb000a0"}], "stats": {"total": 459, "additions": 276, "deletions": 183}, "files": [{"sha": "c157907c2aa1a01be30dc2c8cb2278b00a93e1ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -1,3 +1,48 @@\n+2000-07-04  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplex.c: Don't include sys/mman.h.\n+\t(cpp_push_buffer, cpp_pop_buffer): Moved to cpplib.c.\n+\n+\t* cpplib.c: Include sys/mman.h and obstack.h.\n+\t(cpp_push_buffer): Moved from cpplex.c; allocate buffers on an\n+\tobstack.\n+\t(cpp_pop_buffer): Moved from cpplex.c; free buffers from an obstack.\n+\t(_cpp_unwind_if_stack): Now static, unwind_if_stack.  Don't\n+\tbother freeing if stack entries (they will be freed with their buffer).\n+\t(do_endif): Free if stack entries from the buffer obstack.\n+\t(push_conditional): Allocate if stack entries from the buffer obstack.\n+\n+\t(find_answer): Rename to _cpp_find_answer.\n+\t(do_assert, do_unassert): Update.\n+\n+\t* cpphash.h: Update prototypes.\n+\t(xobnew): New convenience macro.\n+\t* cpplib.h (struct cpp_reader): Add hash_ob and buffer_ob fields.\n+\tUpdate comments.\n+\t(struct cpp_hashnode): Remove disabled field.\n+\n+\t* cppinit.c: Don't include hashtab.h or splay-tree.h.\n+\t(report_missing_guard): Moved to cppfiles.c.\n+\t(cpp_reader_init): Call cpp_init_stacks, cpp_init_macros,\n+\tcpp_init_includes.\n+\t(cpp_cleanup): Call cpp_cleanup_stacks, cpp_cleanup_macros,\n+\tcpp_cleanup_includes.  Don't destroy hashtab or\n+\tall_include_files here.\n+\t(cpp_finish): Use _cpp_report_missing_guards.\n+\n+\t* cppfiles.c (report_missing_guard): Moved from cppinit.c.\n+\t(_cpp_init_include_table): Rename _cpp_init_includes.\n+\t(_cpp_cleanup_includes, _cpp_report_missing_guards): New.\n+\n+\t* cppexp.c (parse_assertion): Update for new name of\n+\tfind_answer.\n+\n+\t* Makefile.in (cpplib.o, cpphash.o, cppinit.o): Update deps.\n+\n+2000-07-04  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.c (do_ident): s/VSPACE/EOF/\n+\n 2000-07-05  Neil Booth  <NeilB@earthling.net>\n \n \t* cpplex.c: Fix trigraph replacement within strings."}, {"sha": "6ec96dbd2ece1f4b38007693a5d2b5c7dce86c44", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -1801,11 +1801,11 @@ cppulp.o:   cppulp.c   $(CONFIG_H) system.h output.h\n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n-cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS)\n-cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n+cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n+cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H) $(HASHTAB_H)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h\n \n-cppinit.o: cppinit.c $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) $(SPLAY_TREE_H) \\\n+cppinit.o: cppinit.c $(CONFIG_H) $(LIBCPP_DEPS) \\\n \t\tmkdeps.h prefix.h output.h Makefile version.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  $(PREPROCESSOR_DEFINES) \\"}, {"sha": "1f031edcf432de91b42608405ef37bdbdf88f744", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -404,7 +404,7 @@ parse_assertion (pfile)\n       /* If we get here, the syntax is valid.  */\n       op.op = INT;\n       op.value = (hp->type == T_ASSERTION &&\n-\t\t  (answer == 0 || *find_answer (hp, &answer->list) != 0));\n+\t\t  (answer == 0 || *_cpp_find_answer (hp, &answer->list) != 0));\n \n       if (answer)\n \tFREE_ANSWER (answer);"}, {"sha": "41706411ee7bdca19811309f68480d552673b235", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -60,7 +60,8 @@ static ssize_t read_with_read\tPARAMS ((cpp_buffer *, int, ssize_t));\n static ssize_t read_file\tPARAMS ((cpp_buffer *, int, ssize_t));\n \n static void destroy_include_file_node\tPARAMS ((splay_tree_value));\n-static int close_cached_fd\tPARAMS ((splay_tree_node, void *));\n+static int close_cached_fd\t\tPARAMS ((splay_tree_node, void *));\n+static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n \n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n@@ -103,7 +104,7 @@ close_cached_fd (n, dummy)\n }\n \n void\n-_cpp_init_include_table (pfile)\n+_cpp_init_includes (pfile)\n      cpp_reader *pfile;\n {\n   pfile->all_include_files\n@@ -112,6 +113,13 @@ _cpp_init_include_table (pfile)\n \t\t      destroy_include_file_node);\n }\n \n+void\n+_cpp_cleanup_includes (pfile)\n+     cpp_reader *pfile;\n+{\n+  splay_tree_delete (pfile->all_include_files);\n+}\n+\n /* Given a filename, look it up and possibly open it.  If the file\n    does not exist, return NULL.  If the file does exist but doesn't\n    need to be reread, return an include_file entry with fd == -1.\n@@ -358,6 +366,38 @@ cpp_make_system_header (pfile, pbuf, flag)\n     pbuf->inc->sysp = flag;\n }\n \n+/* Report on all files that might benefit from a multiple include guard.\n+   Triggered by -H.  */\n+void\n+_cpp_report_missing_guards (pfile)\n+     cpp_reader *pfile;\n+{\n+  int banner = 0;\n+  splay_tree_foreach (pfile->all_include_files, report_missing_guard,\n+\t\t      (PTR) &banner);\n+}\n+\n+static int\n+report_missing_guard (n, b)\n+     splay_tree_node n;\n+     void *b;\n+{\n+  struct include_file *f = (struct include_file *) n->value;\n+  int *bannerp = (int *)b;\n+\n+  if (f && f->cmacro == 0 && f->include_count == 1)\n+    {\n+      if (*bannerp == 0)\n+\t{\n+\t  fputs (_(\"Multiple include guards may be useful for:\\n\"), stderr);\n+\t  *bannerp = 1;\n+\t}\n+      fputs (f->name, stderr);\n+      putc ('\\n', stderr);\n+    }\n+  return 0;\n+}\n+\n #define PRINT_THIS_DEP(p, b) (CPP_PRINT_DEPS(p) > (b||p->system_include_depth))\n void\n _cpp_execute_include (pfile, f, len, no_reinclude, search_start, angle_brackets)"}, {"sha": "2007c52d661cb935af72923d1b0218a5420f8721", "filename": "gcc/cpphash.c", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -26,10 +26,12 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n-#include \"hashtab.h\"\n #include \"cpphash.h\"\n+#include \"hashtab.h\"\n+#include \"obstack.h\"\n \n-#undef abort\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n \n /* This is the second argument to eq_HASHNODE.  */\n struct hashdummy\n@@ -43,9 +45,6 @@ struct hashdummy\n \n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n-static void del_HASHNODE\t  PARAMS ((void *));\n-static cpp_hashnode *make_HASHNODE\t  PARAMS ((const U_CHAR *, size_t,\n-\t\t\t\t\t   enum node_type, unsigned int));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n \n static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n@@ -105,41 +104,6 @@ eq_HASHNODE (x, y)\n \t  && !ustrncmp (a->name, b->name, a->length));\n }\n \n-/* Destroy a cpp_hashnode.  */\n-static void\n-del_HASHNODE (x)\n-     void *x;\n-{\n-  cpp_hashnode *h = (cpp_hashnode *)x;\n-\n-  _cpp_free_definition (h);\n-  free (h);\n-}\n-\n-/* Allocate and initialize a cpp_hashnode structure.\n-   Caller must fill in the value field.  */\n-\n-static cpp_hashnode *\n-make_HASHNODE (name, len, type, hash)\n-     const U_CHAR *name;\n-     size_t len;\n-     enum node_type type;\n-     unsigned int hash;\n-{\n-  cpp_hashnode *hp = (cpp_hashnode *) xmalloc (sizeof (cpp_hashnode) + len);\n-  U_CHAR *p = (U_CHAR *)hp + offsetof (cpp_hashnode, name);\n-\n-  hp->type = type;\n-  hp->length = len;\n-  hp->hash = hash;\n-  hp->disabled = 0;\n-\n-  memcpy (p, name, len);\n-  p[len] = 0;\n-\n-  return hp;\n-}\n-\n /* Find the hash node for name \"name\", of length LEN.  */\n \n cpp_hashnode *\n@@ -151,6 +115,7 @@ cpp_lookup (pfile, name, len)\n   struct hashdummy dummy;\n   cpp_hashnode *new, **slot;\n   unsigned int hash;\n+  U_CHAR *p;\n \n   dummy.name = name;\n   dummy.length = len;\n@@ -161,20 +126,42 @@ cpp_lookup (pfile, name, len)\n   if (*slot)\n     return *slot;\n \n-  new = make_HASHNODE (name, len, T_VOID, hash);\n+  /* Create a new hash node.  */\n+  p = obstack_alloc (pfile->hash_ob, sizeof (cpp_hashnode) + len);\n+  new = (cpp_hashnode *)p;\n+  p += offsetof (cpp_hashnode, name);\n+  \n+  new->type = T_VOID;\n+  new->length = len;\n+  new->hash = hash;\n+  new->fe_value = 0;\n   new->value.expansion = NULL;\n \n+  memcpy (p, name, len);\n+  p[len] = 0;\n+\n   *slot = new;\n   return new;\n }\n \n-/* Init the hash table.  In here so it can see the hash and eq functions.  */\n+/* Set up and tear down internal structures for macro expansion.  */\n void\n-_cpp_init_macro_hash (pfile)\n+_cpp_init_macros (pfile)\n      cpp_reader *pfile;\n {\n   pfile->hashtab = htab_create (HASHSIZE, hash_HASHNODE,\n-\t\t\t\teq_HASHNODE, del_HASHNODE);\n+\t\t\t\teq_HASHNODE, (htab_del) _cpp_free_definition);\n+  pfile->hash_ob = xnew (struct obstack);\n+  obstack_init (pfile->hash_ob);\n+}\n+\n+void\n+_cpp_cleanup_macros (pfile)\n+     cpp_reader *pfile;\n+{\n+  htab_delete (pfile->hashtab);\n+  obstack_free (pfile->hash_ob, 0);\n+  free (pfile->hash_ob);\n }\n \n /* Free the definition of macro H.  */"}, {"sha": "0fde6608d31bd442e4de60a8f7d2dfe1b5e43d28", "filename": "gcc/cpphash.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -188,7 +188,8 @@ extern unsigned int _cpp_calc_hash\tPARAMS ((const U_CHAR *, size_t));\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n-extern void _cpp_init_macro_hash\tPARAMS ((cpp_reader *));\n+extern void _cpp_init_macros\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_cleanup_macros\t\tPARAMS ((cpp_reader *));\n extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n@@ -199,7 +200,9 @@ extern void _cpp_execute_include\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t\t int));\n extern int _cpp_compare_file_date       PARAMS ((cpp_reader *, const U_CHAR *,\n                                                  unsigned int, int));\n-extern void _cpp_init_include_table\tPARAMS ((cpp_reader *));\n+extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\n+extern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));\n extern const char *_cpp_fake_include\tPARAMS ((cpp_reader *, const char *));\n \n /* In cppexp.c */\n@@ -241,15 +244,17 @@ extern const struct directive *_cpp_check_directive\n \t\t\tPARAMS ((cpp_reader *, const cpp_token *, int));\n extern const struct directive *_cpp_check_linemarker\n \t\t\tPARAMS ((cpp_reader *, const cpp_token *, int));\n-extern void _cpp_unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n-extern cpp_hashnode * _cpp_parse_assertion PARAMS ((cpp_reader *,\n+extern cpp_hashnode *_cpp_parse_assertion PARAMS ((cpp_reader *,\n \t\t\t\t\t\t    struct answer **));\n-extern struct answer** find_answer\tPARAMS ((cpp_hashnode *,\n+extern struct answer **_cpp_find_answer\tPARAMS ((cpp_hashnode *,\n \t\t\t\t\t\t const cpp_toklist *));\n+extern void _cpp_init_stacks\tPARAMS ((cpp_reader *));\n+extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n \n /* Utility routines and macros.  */\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n #define xnewvec(T, N)\t(T *) xmalloc (sizeof(T) * (N))\n+#define xobnew(O, T)\t(T *) obstack_alloc (O, sizeof(T))\n \n /* These are inline functions instead of macros so we can get type\n    checking.  */"}, {"sha": "c60db8b9cb451b4be14227ec11adafd0ac8d1195", "filename": "gcc/cppinit.c", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -21,8 +21,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include \"hashtab.h\"\n-#include \"splay-tree.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"output.h\"\n@@ -225,7 +223,6 @@ static int opt_comp\t\t\tPARAMS ((const void *, const void *));\n #endif\n static int parse_option\t\t\tPARAMS ((const char *));\n static int handle_option\t\tPARAMS ((cpp_reader *, int, char **));\n-static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n \n /* Fourth argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n@@ -533,8 +530,9 @@ cpp_reader_init (pfile)\n   CPP_OPTION (pfile, pending) =\n     (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n \n-  _cpp_init_macro_hash (pfile);\n-  _cpp_init_include_table (pfile);\n+  _cpp_init_stacks (pfile);\n+  _cpp_init_macros (pfile);\n+  _cpp_init_includes (pfile);\n }\n \n /* Initialize a cpp_printer structure.  As a side effect, open the\n@@ -580,8 +578,9 @@ cpp_cleanup (pfile)\n   if (pfile->deps)\n     deps_free (pfile->deps);\n \n-  htab_delete (pfile->hashtab);\n-  splay_tree_delete (pfile->all_include_files);\n+  _cpp_cleanup_stacks (pfile);\n+  _cpp_cleanup_macros (pfile);\n+  _cpp_cleanup_includes (pfile);\n   _cpp_free_temp_tokens (pfile);\n }\n \n@@ -1009,27 +1008,6 @@ cpp_start_read (pfile, print, fname)\n   return 1;\n }\n \n-static int\n-report_missing_guard (n, b)\n-     splay_tree_node n;\n-     void *b;\n-{\n-  struct include_file *f = (struct include_file *) n->value;\n-  int *bannerp = (int *)b;\n-\n-  if (f && f->cmacro == 0 && f->include_count == 1)\n-    {\n-      if (*bannerp == 0)\n-\t{\n-\t  fputs (_(\"Multiple include guards may be useful for:\\n\"), stderr);\n-\t  *bannerp = 1;\n-\t}\n-      fputs (f->name, stderr);\n-      putc ('\\n', stderr);\n-    }\n-  return 0;\n-}\n-\n /* This is called at the end of preprocessing.  It pops the\n    last buffer and writes dependency output.  It should also\n    clear macro definitions, such that you could call cpp_start_read\n@@ -1085,11 +1063,7 @@ cpp_finish (pfile, print)\n \n   /* Report on headers that could use multiple include guards.  */\n   if (CPP_OPTION (pfile, print_include_names))\n-    {\n-      int banner = 0;\n-      splay_tree_foreach (pfile->all_include_files, report_missing_guard,\n-\t\t\t  (void *) &banner);\n-    }\n+    _cpp_report_missing_guards (pfile);\n }\n \n static void"}, {"sha": "5f1707ad27e9fd834bf8349b82789e3977f6d51b", "filename": "gcc/cpplex.c", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -56,10 +56,6 @@ o Correct pastability test for CPP_NAME and CPP_NUMBER.\n #include \"cpphash.h\"\n #include \"symcat.h\"\n \n-#ifdef HAVE_MMAP_FILE\n-# include <sys/mman.h>\n-#endif\n-\n #define auto_expand_name_space(list) \\\n     _cpp_expand_name_space ((list), 1 + (list)->name_cap / 2)\n static void safe_fwrite\t\tPARAMS ((cpp_reader *, const U_CHAR *,\n@@ -227,78 +223,6 @@ _cpp_grow_token_buffer (pfile, n)\n   CPP_SET_WRITTEN (pfile, old_written);\n }\n \n-/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n-   If BUFFER != NULL, then use the LENGTH characters in BUFFER\n-   as the new input buffer.\n-   Return the new buffer, or NULL on failure.  */\n-\n-cpp_buffer *\n-cpp_push_buffer (pfile, buffer, length)\n-     cpp_reader *pfile;\n-     const U_CHAR *buffer;\n-     long length;\n-{\n-  cpp_buffer *buf = CPP_BUFFER (pfile);\n-  cpp_buffer *new;\n-  if (++pfile->buffer_stack_depth == CPP_STACK_MAX)\n-    {\n-      cpp_fatal (pfile, \"macro or #include recursion too deep\");\n-      return NULL;\n-    }\n-\n-  new = (cpp_buffer *) xcalloc (1, sizeof (cpp_buffer));\n-\n-  new->buf = new->cur = buffer;\n-  new->rlimit = buffer + length;\n-  new->prev = buf;\n-  new->line_base = NULL;\n-\n-  CPP_BUFFER (pfile) = new;\n-  return new;\n-}\n-\n-cpp_buffer *\n-cpp_pop_buffer (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *buf = CPP_BUFFER (pfile);\n-\n-  if (buf->inc)\n-    {\n-      _cpp_unwind_if_stack (pfile, buf);\n-      if (buf->buf)\n-\t{\n-#ifdef HAVE_MMAP_FILE\n-\t  if (buf->mapped)\n-\t    munmap ((caddr_t) buf->buf, buf->rlimit - buf->buf);\n-\t  else\n-#endif\n-\t    free ((PTR) buf->buf);\n-\t}\n-      if (pfile->system_include_depth)\n-\tpfile->system_include_depth--;\n-      if (pfile->include_depth)\n-\tpfile->include_depth--;\n-      if (pfile->potential_control_macro)\n-\t{\n-\t  if (buf->inc->cmacro != NEVER_REREAD)\n-\t    buf->inc->cmacro = pfile->potential_control_macro;\n-\t  pfile->potential_control_macro = 0;\n-\t}\n-      pfile->input_stack_listing_current = 0;\n-      /* If the file will not be included again, then close it.  */\n-      if (DO_NOT_REREAD (buf->inc))\n-\t{\n-\t  close (buf->inc->fd);\n-\t  buf->inc->fd = -1;\n-\t}\n-    }\n-  CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n-  free (buf);\n-  pfile->buffer_stack_depth--;\n-  return CPP_BUFFER (pfile);\n-}\n-\n /* Deal with the annoying semantics of fwrite.  */\n static void\n safe_fwrite (pfile, buf, len, fp)"}, {"sha": "2ee5849f0c0007162c967501205a97f0ffe6252d", "filename": "gcc/cpplib.c", "status": "modified", "additions": 115, "deletions": 17, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -25,8 +25,13 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"intl.h\"\n+#include \"obstack.h\"\n #include \"symcat.h\"\n \n+#ifdef HAVE_MMAP_FILE\n+# include <sys/mman.h>\n+#endif\n+\n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n \n@@ -43,21 +48,24 @@ struct if_stack\n /* Forward declarations.  */\n \n static void validate_else\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static int parse_include\tPARAMS ((cpp_reader *, const U_CHAR *, int,\n+static int  parse_include\tPARAMS ((cpp_reader *, const U_CHAR *, int,\n \t\t\t\t\t const U_CHAR **, unsigned int *,\n \t\t\t\t\t int *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t const cpp_hashnode *));\n static void pass_thru_directive\tPARAMS ((cpp_reader *));\n-static int read_line_number\tPARAMS ((cpp_reader *, int *));\n-static int strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n+static int  read_line_number\tPARAMS ((cpp_reader *, int *));\n+static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n \n-static const cpp_hashnode *parse_ifdef\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static const cpp_hashnode *detect_if_not_defined\n-\t\t\t\t\tPARAMS ((cpp_reader *));\n-static cpp_hashnode *get_define_node\tPARAMS ((cpp_reader *));\n-static void dump_macro_name PARAMS ((cpp_reader *, cpp_hashnode *));\n+static const cpp_hashnode *\n+\t    parse_ifdef\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n+static const cpp_hashnode *\n+\t    detect_if_not_defined PARAMS ((cpp_reader *));\n+static cpp_hashnode *\n+\t    get_define_node\tPARAMS ((cpp_reader *));\n+static void dump_macro_name \tPARAMS ((cpp_reader *, cpp_hashnode *));\n+static void unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n \n /* Utility.  */\n #define str_match(sym, len, str) \\\n@@ -644,7 +652,7 @@ do_ident (pfile)\n   /* Next token should be a string constant.  */\n   if (cpp_get_token (pfile)->type == CPP_STRING)\n     /* And then a newline.  */\n-    if (cpp_get_token (pfile)->type == CPP_VSPACE)\n+    if (cpp_get_token (pfile)->type == CPP_EOF)\n       {\n \t/* Good - ship it.  */\n \tpass_thru_directive (pfile);\n@@ -1150,7 +1158,7 @@ do_endif (pfile)\n       CPP_BUFFER (pfile)->if_stack = ifs->next;\n       pfile->skipping = ifs->was_skipping;\n       pfile->potential_control_macro = ifs->cmacro;\n-      free (ifs);\n+      obstack_free (pfile->buffer_ob, ifs);\n     }\n   return 0;\n }\n@@ -1169,7 +1177,7 @@ push_conditional (pfile, skip, type, cmacro)\n {\n   struct if_stack *ifs;\n \n-  ifs = (struct if_stack *) xmalloc (sizeof (struct if_stack));\n+  ifs = xobnew (pfile->buffer_ob, struct if_stack);\n   ifs->lineno = _cpp_get_line (pfile, &ifs->colno);\n   ifs->next = CPP_BUFFER (pfile)->if_stack;\n   ifs->cmacro = cmacro;\n@@ -1197,8 +1205,8 @@ validate_else (pfile, directive)\n /* Called when we reach the end of a file.  Walk back up the\n    conditional stack till we reach its level at entry to this file,\n    issuing error messages.  Then force skipping off.  */\n-void\n-_cpp_unwind_if_stack (pfile, pbuf)\n+static void\n+unwind_if_stack (pfile, pbuf)\n      cpp_reader *pfile;\n      cpp_buffer *pbuf;\n {\n@@ -1209,7 +1217,7 @@ _cpp_unwind_if_stack (pfile, pbuf)\n       cpp_error_with_line (pfile, ifs->lineno, ifs->colno, \"unterminated #%s\",\n \t\t\t   dtable[ifs->type].name);\n       nifs = ifs->next;\n-      free (ifs);\n+      /* No need to free - they'll all go away with the buffer.  */\n     }\n   pfile->skipping = 0;\n }\n@@ -1330,7 +1338,7 @@ _cpp_parse_assertion (pfile, answerp)\n /* Returns a pointer to the pointer to the answer in the answer chain,\n    or a pointer to NULL if the answer is not in the chain.  */\n struct answer **\n-find_answer (node, candidate)\n+_cpp_find_answer (node, candidate)\n      cpp_hashnode *node;\n      const cpp_toklist *candidate;\n {\n@@ -1362,7 +1370,7 @@ do_assert (pfile)\n \n       if (node->type == T_ASSERTION)\n \t{\n-\t  if (*find_answer (node, &new_answer->list))\n+\t  if (*_cpp_find_answer (node, &new_answer->list))\n \t    goto err;\n \t  new_answer->next = node->value.answers;\n \t}\n@@ -1393,7 +1401,7 @@ do_unassert (pfile)\n \t{\n \t  if (answer)\n \t    {\n-\t      struct answer **p = find_answer (node, &answer->list);\n+\t      struct answer **p = _cpp_find_answer (node, &answer->list);\n \n \t      temp = *p;\n \t      if (temp)\n@@ -1503,3 +1511,93 @@ cpp_defined (pfile, id, len)\n     }\n   return (hp->type != T_VOID);\n }\n+\n+/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n+   If BUFFER != NULL, then use the LENGTH characters in BUFFER\n+   as the new input buffer.\n+   Return the new buffer, or NULL on failure.  */\n+\n+cpp_buffer *\n+cpp_push_buffer (pfile, buffer, length)\n+     cpp_reader *pfile;\n+     const U_CHAR *buffer;\n+     long length;\n+{\n+  cpp_buffer *buf = CPP_BUFFER (pfile);\n+  cpp_buffer *new;\n+  if (++pfile->buffer_stack_depth == CPP_STACK_MAX)\n+    {\n+      cpp_fatal (pfile, \"#include recursion too deep\");\n+      return NULL;\n+    }\n+\n+  new = xobnew (pfile->buffer_ob, cpp_buffer);\n+  memset (new, 0, sizeof (cpp_buffer));\n+\n+  new->buf = new->cur = buffer;\n+  new->rlimit = buffer + length;\n+  new->prev = buf;\n+\n+  CPP_BUFFER (pfile) = new;\n+  return new;\n+}\n+\n+cpp_buffer *\n+cpp_pop_buffer (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buf = CPP_BUFFER (pfile);\n+\n+  unwind_if_stack (pfile, buf);\n+#ifdef HAVE_MMAP_FILE\n+  if (buf->mapped)\n+    munmap ((caddr_t) buf->buf, buf->rlimit - buf->buf);\n+  else\n+#endif\n+    if (buf->inc)\n+      free ((PTR) buf->buf);\n+\n+  if (buf->inc)\n+    {\n+      if (pfile->system_include_depth)\n+\tpfile->system_include_depth--;\n+      if (pfile->include_depth)\n+\tpfile->include_depth--;\n+      if (pfile->potential_control_macro)\n+\t{\n+\t  if (buf->inc->cmacro != NEVER_REREAD)\n+\t    buf->inc->cmacro = pfile->potential_control_macro;\n+\t  pfile->potential_control_macro = 0;\n+\t}\n+      pfile->input_stack_listing_current = 0;\n+      /* If the file will not be included again, then close it.  */\n+      if (DO_NOT_REREAD (buf->inc))\n+\t{\n+\t  close (buf->inc->fd);\n+\t  buf->inc->fd = -1;\n+\t}\n+    }\n+\n+  CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n+  obstack_free (pfile->buffer_ob, buf);\n+  pfile->buffer_stack_depth--;\n+  return CPP_BUFFER (pfile);\n+}\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+void\n+_cpp_init_stacks (pfile)\n+     cpp_reader *pfile;\n+{\n+  pfile->buffer_ob = xnew (struct obstack);\n+  obstack_init (pfile->buffer_ob);\n+}\n+\n+void\n+_cpp_cleanup_stacks (pfile)\n+     cpp_reader *pfile;\n+{\n+  obstack_free (pfile->buffer_ob, 0);\n+  free (pfile->buffer_ob);\n+}"}, {"sha": "1c516a6731296568a1d0846d2c6807fd388ead97", "filename": "gcc/cpplib.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -476,7 +476,7 @@ struct cpp_reader\n   /* Hash table of macros and assertions.  See cpphash.c */\n   struct htab *hashtab;\n \n-  /* Hash table of other included files.  See cppfiles.c */\n+  /* Tree of other included files.  See cppfiles.c */\n   struct splay_tree_s *all_include_files;\n \n   /* Chain of `actual directory' file_name_list entries,\n@@ -527,6 +527,14 @@ struct cpp_reader\n   /* Buffer of -M output.  */\n   struct deps *deps;\n \n+  /* Obstack holding all macro hash nodes.  This never shrinks.\n+     See cpphash.c */\n+  struct obstack *hash_ob;\n+\n+  /* Obstack holding buffer and conditional structures.  This is a\n+     real stack.  See cpplib.c */\n+  struct obstack *buffer_ob;\n+\n   /* User visible options.  */\n   struct cpp_options opts;\n \n@@ -625,7 +633,6 @@ struct cpp_hashnode\n   unsigned int hash;\t\t\t/* cached hash value */\n   unsigned short length;\t\t/* length of name */\n   ENUM_BITFIELD(node_type) type : 8;\t/* node type */\n-  char disabled;\t\t\t/* macro turned off for rescan? */\n \n   union\n   {"}, {"sha": "0efda2369fdf9d5ab978fd1b838cc4d82f88203c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -1,3 +1,7 @@\n+2000-07-04  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* gcc.dg/cpp/ident.c: New test.\n+\n 2000-07-05  Neil Booth  <NeilB@earthling.net>\n \n \t* gcc.dg/cpp/lexident.c, gcc.dg/cpp/lexnum.c,"}, {"sha": "f8621122fed1d668be74df3ca6e1860a476cf0bd", "filename": "gcc/testsuite/gcc.dg/cpp/ident.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fident.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f835b2549f6b787732b5e326c5c23dbb1f66b/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fident.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fident.c?ref=c71f835b2549f6b787732b5e326c5c23dbb1f66b", "patch": "@@ -0,0 +1,9 @@\n+/* Test #ident.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */ /* shut off -pedantic */\n+\n+#ident \"this is an ident\"\n+\n+int dummy(void) { return 12; }\n+\n+/* { dg-final { scan-assembler ident.c \"this is an ident\" } } */"}]}