{"sha": "eed8fcad820a0a7f50446d6a8b9eafe26b968c06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVkOGZjYWQ4MjBhMGE3ZjUwNDQ2ZDZhOGI5ZWFmZTI2Yjk2OGMwNg==", "commit": {"author": {"name": "Olga Golovanevsky", "email": "olga@il.ibm.com", "date": "2009-11-20T16:57:35Z"}, "committer": {"name": "Olga Golovanevsky", "email": "olga@gcc.gnu.org", "date": "2009-11-20T16:57:35Z"}, "message": "re PR tree-optimization/39960 (struct-reorg is broken)\n\n2009-11-17 Olga Golovanevsky <olga@il.ibm.com>\n\n\tPR middle-end/39960\n\t* ipa-struct-reorg.c (find_pos_in_stmt): New parameter.\n\t(ref_pos): New field in structure.\n\t(insert_new_var_in_stmt): New function.\n\nFrom-SVN: r154374", "tree": {"sha": "e6ccd08cacdf089b387b9ee04bd12d0dbcecc98c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6ccd08cacdf089b387b9ee04bd12d0dbcecc98c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eed8fcad820a0a7f50446d6a8b9eafe26b968c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed8fcad820a0a7f50446d6a8b9eafe26b968c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed8fcad820a0a7f50446d6a8b9eafe26b968c06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed8fcad820a0a7f50446d6a8b9eafe26b968c06/comments", "author": null, "committer": null, "parents": [{"sha": "25bcd7ea327b499be10398fc747dcc9856855e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25bcd7ea327b499be10398fc747dcc9856855e90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25bcd7ea327b499be10398fc747dcc9856855e90"}], "stats": {"total": 71, "additions": 50, "deletions": 21}, "files": [{"sha": "1d8f4a9650070ed1f740eab41c93cf0f9739b5a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eed8fcad820a0a7f50446d6a8b9eafe26b968c06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eed8fcad820a0a7f50446d6a8b9eafe26b968c06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eed8fcad820a0a7f50446d6a8b9eafe26b968c06", "patch": "@@ -1,3 +1,11 @@\n+2009-11-20 Olga Golovanevsky <olga@il.ibm.com>\n+\n+\tPR middle-end/39960\n+\t* ipa-struct-reorg.c (find_pos_in_stmt): New parameter.\n+\t(ref_pos): New field in structure.\n+\t(insert_new_var_in_stmt): New function.\n+\n+\n 2009-11-20  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config.gcc (alpha*-dec-osf[45]*): Set use_gcc_stdint."}, {"sha": "d2187b82b99db20cccd7552e2aa7e963582c3d03", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eed8fcad820a0a7f50446d6a8b9eafe26b968c06/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eed8fcad820a0a7f50446d6a8b9eafe26b968c06/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=eed8fcad820a0a7f50446d6a8b9eafe26b968c06", "patch": "@@ -868,6 +868,7 @@ struct ref_pos\n {\n   tree *pos;\n   tree ref;\n+  tree container;\n };\n \n \n@@ -890,6 +891,7 @@ find_pos_in_stmt_1 (tree *tp, int *walk_subtrees, void * data)\n       return t;\n     }\n \n+  r_pos->container = t;\n   *walk_subtrees = 1;      \n   return NULL_TREE;\n }\n@@ -899,18 +901,18 @@ find_pos_in_stmt_1 (tree *tp, int *walk_subtrees, void * data)\n    It returns it, if found, and NULL otherwise.  */\n \n static tree *\n-find_pos_in_stmt (gimple stmt, tree ref)\n+find_pos_in_stmt (gimple stmt, tree ref, struct ref_pos * r_pos)\n {\n-  struct ref_pos r_pos;\n   struct walk_stmt_info wi;\n \n-  r_pos.ref = ref;\n-  r_pos.pos = NULL;\n+  r_pos->ref = ref;\n+  r_pos->pos = NULL;\n+  r_pos->container = NULL_TREE;\n   memset (&wi, 0, sizeof (wi));\n-  wi.info = &r_pos;\n+  wi.info = r_pos;\n   walk_gimple_op (stmt, find_pos_in_stmt_1, &wi);\n \n-  return r_pos.pos;\n+  return r_pos->pos;\n }\n \n /* This structure is used to represent array \n@@ -948,6 +950,7 @@ replace_field_acc (struct field_access_site *acc, tree new_type)\n   tree field_id = DECL_NAME (acc->field_decl);\n   VEC (type_wrapper_t, heap) *wrapper = VEC_alloc (type_wrapper_t, heap, 10);\n   type_wrapper_t *wr_p = NULL;\n+  struct ref_pos r_pos;\n   \n   while (TREE_CODE (ref_var) == INDIRECT_REF\n \t || TREE_CODE (ref_var) == ARRAY_REF)\n@@ -999,14 +1002,14 @@ replace_field_acc (struct field_access_site *acc, tree new_type)\n \tgimple_assign_set_rhs1 (acc->stmt, new_acc);\n       else\n \t{\n-\t  pos = find_pos_in_stmt (acc->stmt, acc->comp_ref);\n+\t  pos = find_pos_in_stmt (acc->stmt, acc->comp_ref, &r_pos);\n \t  gcc_assert (pos);\n \t  *pos = new_acc;\n \t}\n     }\n   else\n     {\n-      pos = find_pos_in_stmt (acc->stmt, acc->comp_ref);\n+      pos = find_pos_in_stmt (acc->stmt, acc->comp_ref, &r_pos);\n       gcc_assert (pos);\n       *pos = new_acc;\n     }\n@@ -1244,6 +1247,35 @@ create_new_stmts_for_cond_expr (gimple stmt)\n     }\n }\n \n+/* This function looks for VAR in STMT, and replace it with NEW_VAR.\n+   If needed, it wraps NEW_VAR in pointers and indirect references \n+   before insertion.  */\n+\n+static void\n+insert_new_var_in_stmt (gimple stmt, tree var, tree new_var)\n+{\n+  struct ref_pos r_pos;\n+  tree *pos;\n+\n+  pos = find_pos_in_stmt (stmt, var, &r_pos);\n+  gcc_assert (pos);\n+\n+  while (r_pos.container && (TREE_CODE(r_pos.container) == INDIRECT_REF\n+\t\t\t     || TREE_CODE(r_pos.container) == ADDR_EXPR))\n+    {\n+      tree type = TREE_TYPE (TREE_TYPE (new_var));\n+\n+      if (TREE_CODE(r_pos.container) == INDIRECT_REF)\t\t    \n+\tnew_var = build1 (INDIRECT_REF, type, new_var);\n+      else\n+\tnew_var = build_fold_addr_expr (new_var);\n+      pos = find_pos_in_stmt (stmt, r_pos.container, &r_pos);\n+    }\n+\t      \n+  *pos = new_var;\n+}\n+\n+\n /* Create a new general access to replace original access ACC\n    for structure type NEW_TYPE.  */\n \n@@ -1264,7 +1296,6 @@ create_general_new_stmt (struct access_site *acc, tree new_type)\n \n   for (i = 0; VEC_iterate (tree, acc->vars, i, var); i++)\n     {\n-      tree *pos;\n       tree new_var = find_new_var_of_type (var, new_type);\n       tree lhs, rhs = NULL_TREE;\n \n@@ -1296,20 +1327,10 @@ create_general_new_stmt (struct access_site *acc, tree new_type)\n \t  else if (rhs == var)\n \t    gimple_assign_set_rhs1 (new_stmt, new_var);\n \t  else\n-\t    {\n-\t      pos = find_pos_in_stmt (new_stmt, var);\n-\t      gcc_assert (pos);\n-\t      /* ???  This misses adjustments to the type of the\n-\t         INDIRECT_REF we possibly replace the operand of.  */\n-\t      *pos = new_var;\n-\t    }      \n+\t    insert_new_var_in_stmt (new_stmt, var, new_var);\n \t}\n       else\n-\t{\n-\t  pos = find_pos_in_stmt (new_stmt, var);\n-\t  gcc_assert (pos);\n-\t  *pos = new_var;\n-\t}\n+\tinsert_new_var_in_stmt (new_stmt, var, new_var);\n     }\n \n   finalize_stmt (new_stmt);"}]}