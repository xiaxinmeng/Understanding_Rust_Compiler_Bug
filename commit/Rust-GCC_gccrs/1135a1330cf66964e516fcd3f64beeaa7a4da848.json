{"sha": "1135a1330cf66964e516fcd3f64beeaa7a4da848", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEzNWExMzMwY2Y2Njk2NGU1MTZmY2QzZjY0YmVlYWE3YTRkYTg0OA==", "commit": {"author": {"name": "Dominik Vogt", "email": "vogt@linux.vnet.ibm.com", "date": "2016-08-23T09:20:15Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-08-23T09:20:15Z"}, "message": "Drop excess size used for run time allocated stack variables.\n\n* get_dynamic_stack_size is passed a SIZE of a data block (which is\n  allocated elsewhere), the SIZE_ALIGN of the SIZE (i.e. the alignment\n  of the underlying memory units (e.g. 32 bytes split into 4 times 8\n  bytes = 64 bit alignment) and the REQUIRED_ALIGN of the data portion\n  of the allocated memory.\n\n* Assuming the function is called with SIZE = 2, SIZE_ALIGN = 8 and\n  REQUIRED_ALIGN = 64 it first adds 7 bytes to SIZE -> 9.  This is\n  what is needed to have two bytes 8-byte-aligned at some memory\n  location without any known alignment.\n\n* Finally round_push is called to round up SIZE to a multiple of the\n  stack slot size.\n\nThe key to understanding this is that the function assumes that\nSTACK_DYNMAIC_OFFSET is completely unknown at the time its called\nand therefore it does not make assumptions about the alignment of\nSTACKPOINTER + STACK_DYNMAIC_OFFSET.  The latest patch simply\nhard-codes that SP + SDO is supposed to be aligned to at least\nstack slot size (and does that in a very complicated way).  Since\nthere is no guarantee that this is the case on all targets, the\npatch is broken.  It may miscalculate a SIZE that is too small in\nsome cases.\n\nHowever, on many targets there is some guarantee about the\nalignment of SP + SDO even if the actual value of SDO is unknown.\nOn s390x it's always 8-byte-aligned (stack slot size).  So the\nright fix should be to add knowledge about the target's guaranteed\nalignment of SP + SDO to the function.  I'm right now testing a\nmuch simpler patch that uses\nREGNO_POINTER_ALIGN(VIRTUAL_STACK_DYNAMIC_REGNUM) as the\nalignment.\n\n\ngcc/ChangeLog:\n\n2016-08-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\t* explow.c (get_dynamic_stack_size): Take known alignment of stack\n\tpointer + STACK_DYNAMIC_OFFSET into account when calculating the\n\tsize needed.  Correct a typo in a comment.\n\nFrom-SVN: r239688", "tree": {"sha": "8248af4671a1540a4e443ee5ecadc07ef8a6240d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8248af4671a1540a4e443ee5ecadc07ef8a6240d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1135a1330cf66964e516fcd3f64beeaa7a4da848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1135a1330cf66964e516fcd3f64beeaa7a4da848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1135a1330cf66964e516fcd3f64beeaa7a4da848", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1135a1330cf66964e516fcd3f64beeaa7a4da848/comments", "author": {"login": "vogtd", "id": 9690100, "node_id": "MDQ6VXNlcjk2OTAxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/9690100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vogtd", "html_url": "https://github.com/vogtd", "followers_url": "https://api.github.com/users/vogtd/followers", "following_url": "https://api.github.com/users/vogtd/following{/other_user}", "gists_url": "https://api.github.com/users/vogtd/gists{/gist_id}", "starred_url": "https://api.github.com/users/vogtd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vogtd/subscriptions", "organizations_url": "https://api.github.com/users/vogtd/orgs", "repos_url": "https://api.github.com/users/vogtd/repos", "events_url": "https://api.github.com/users/vogtd/events{/privacy}", "received_events_url": "https://api.github.com/users/vogtd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e11f46f122a99fd12e589a74cf247feeec6e780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e11f46f122a99fd12e589a74cf247feeec6e780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e11f46f122a99fd12e589a74cf247feeec6e780"}], "stats": {"total": 21, "additions": 17, "deletions": 4}, "files": [{"sha": "23cf5bc33cf3ec322aface2bc4763968f14e8118", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1135a1330cf66964e516fcd3f64beeaa7a4da848/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1135a1330cf66964e516fcd3f64beeaa7a4da848/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1135a1330cf66964e516fcd3f64beeaa7a4da848", "patch": "@@ -1,3 +1,10 @@\n+2016-08-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\t* explow.c (get_dynamic_stack_size): Take known alignment of stack\n+\tpointer + STACK_DYNAMIC_OFFSET into account when calculating the size\n+\tneeded.\n+\tCorrect a typo in a comment.\n+\n 2016-08-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md (\"*andc_split\"): New splitter for and with"}, {"sha": "f97a214f655e483545f642c61cb74cfedc962a4b", "filename": "gcc/explow.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1135a1330cf66964e516fcd3f64beeaa7a4da848/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1135a1330cf66964e516fcd3f64beeaa7a4da848/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=1135a1330cf66964e516fcd3f64beeaa7a4da848", "patch": "@@ -1224,9 +1224,15 @@ get_dynamic_stack_size (rtx *psize, unsigned size_align,\n      example), so we must preventively align the value.  We leave space\n      in SIZE for the hole that might result from the alignment operation.  */\n \n-  extra = (required_align - BITS_PER_UNIT) / BITS_PER_UNIT;\n-  size = plus_constant (Pmode, size, extra);\n-  size = force_operand (size, NULL_RTX);\n+  unsigned known_align = REGNO_POINTER_ALIGN (VIRTUAL_STACK_DYNAMIC_REGNUM);\n+  if (known_align == 0)\n+    known_align = BITS_PER_UNIT;\n+  if (required_align > known_align)\n+    {\n+      extra = (required_align - known_align) / BITS_PER_UNIT;\n+      size = plus_constant (Pmode, size, extra);\n+      size = force_operand (size, NULL_RTX);\n+    }\n \n   if (flag_stack_usage_info && pstack_usage_size)\n     *pstack_usage_size += extra;\n@@ -1235,7 +1241,7 @@ get_dynamic_stack_size (rtx *psize, unsigned size_align,\n     size_align = BITS_PER_UNIT;\n \n   /* Round the size to a multiple of the required stack alignment.\n-     Since the stack if presumed to be rounded before this allocation,\n+     Since the stack is presumed to be rounded before this allocation,\n      this will maintain the required alignment.\n \n      If the stack grows downward, we could save an insn by subtracting"}]}