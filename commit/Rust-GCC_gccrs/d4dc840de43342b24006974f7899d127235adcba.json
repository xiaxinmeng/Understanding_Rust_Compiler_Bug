{"sha": "d4dc840de43342b24006974f7899d127235adcba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRkYzg0MGRlNDMzNDJiMjQwMDY5NzRmNzg5OWQxMjcyMzVhZGNiYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-25T21:51:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-25T21:51:39Z"}, "message": "runtime: More efficient implementation of trampolines.\n\nFrom-SVN: r187899", "tree": {"sha": "db3d0617f25e6dbc47dd206f2552a116b2d80814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db3d0617f25e6dbc47dd206f2552a116b2d80814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4dc840de43342b24006974f7899d127235adcba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4dc840de43342b24006974f7899d127235adcba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4dc840de43342b24006974f7899d127235adcba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4dc840de43342b24006974f7899d127235adcba/comments", "author": null, "committer": null, "parents": [{"sha": "40bb0243ec6f2831e6efb54e0f27f091075c6dac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bb0243ec6f2831e6efb54e0f27f091075c6dac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40bb0243ec6f2831e6efb54e0f27f091075c6dac"}], "stats": {"total": 114, "additions": 88, "deletions": 26}, "files": [{"sha": "292eff5c3f2bfef4f74cb56b95ba8adb0e5123ae", "filename": "libgo/runtime/go-trampoline.c", "status": "modified", "additions": 86, "deletions": 26, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dc840de43342b24006974f7899d127235adcba/libgo%2Fruntime%2Fgo-trampoline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dc840de43342b24006974f7899d127235adcba/libgo%2Fruntime%2Fgo-trampoline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-trampoline.c?ref=d4dc840de43342b24006974f7899d127235adcba", "patch": "@@ -14,40 +14,100 @@\n #include <sys/mman.h>\n #endif\n \n-#include \"go-alloc.h\"\n+#include \"runtime.h\"\n+#include \"arch.h\"\n+#include \"malloc.h\"\n #include \"go-assert.h\"\n \n-/* In order to build a trampoline we need space which is both writable\n-   and executable.  We currently just allocate a whole page.  This\n-   needs to be more system dependent.  */\n+/* Trampolines need to run in memory that is both writable and\n+   executable.  In order to implement them, we grab a page of memory\n+   and mprotect it.  We fill in the page with trampolines as they are\n+   required.  When we run out of space, we drop the pointer to the\n+   page and allocate a new one.  The page will be freed by the garbage\n+   collector when there are no more variables of type func pointing to\n+   it.  */\n+\n+/* A lock to control access to the page of closures.  */\n+\n+static Lock trampoline_lock;\n+\n+/* The page of closures.  */\n+\n+static unsigned char *trampoline_page;\n+\n+/* The size of trampoline_page.  */\n+\n+static uintptr_t trampoline_page_size;\n+\n+/* The number of bytes we have used on trampoline_page.  */\n+\n+static uintptr_t trampoline_page_used;\n+\n+/* Allocate a trampoline of SIZE bytes that will use the closure in\n+   CLOSURE.  */\n \n void *\n __go_allocate_trampoline (uintptr_t size, void *closure)\n {\n-  unsigned int page_size;\n-  void *ret;\n-  size_t off;\n-\n-  page_size = getpagesize ();\n-  __go_assert (page_size >= size);\n-  ret = __go_alloc (2 * page_size - 1);\n-  ret = (void *) (((uintptr_t) ret + page_size - 1)\n-\t\t  & ~ ((uintptr_t) page_size - 1));\n-\n-  /* Because the garbage collector only looks at correct address\n-     offsets, we need to ensure that it will see the closure\n-     address.  */\n-  off = ((size + sizeof (void *) - 1) / sizeof (void *)) * sizeof (void *);\n-  __go_assert (size + off + sizeof (void *) <= page_size);\n-  __builtin_memcpy (ret + off, &closure, sizeof (void *));\n+  uintptr_t ptr_size;\n+  uintptr_t full_size;\n+  unsigned char *ret;\n+\n+  /* Because the garbage collector only looks at aligned addresses, we\n+     need to store the closure at an aligned address to ensure that it\n+     sees it.  */\n+  ptr_size = sizeof (void *);\n+  full_size = (((size + ptr_size - 1) / ptr_size) * ptr_size);\n+  full_size += ptr_size;\n+\n+  runtime_lock (&trampoline_lock);\n+\n+  if (full_size < trampoline_page_size - trampoline_page_used)\n+    trampoline_page = NULL;\n+\n+  if (trampoline_page == NULL)\n+    {\n+      uintptr_t page_size;\n+      unsigned char *page;\n+\n+      page_size = getpagesize ();\n+      __go_assert (page_size >= full_size);\n+      page = (unsigned char *) runtime_mallocgc (2 * page_size - 1, 0, 0, 0);\n+      page = (unsigned char *) (((uintptr_t) page + page_size - 1)\n+\t\t\t\t& ~ (page_size - 1));\n \n #ifdef HAVE_SYS_MMAN_H\n-  {\n-    int i;\n-    i = mprotect (ret, size, PROT_READ | PROT_WRITE | PROT_EXEC);\n-    __go_assert (i == 0);\n-  }\n+      {\n+\tint i;\n+\n+\ti = mprotect (page, page_size, PROT_READ | PROT_WRITE | PROT_EXEC);\n+\t__go_assert (i == 0);\n+      }\n #endif\n \n-  return ret;\n+      trampoline_page = page;\n+      trampoline_page_size = page_size;\n+      trampoline_page_used = 0;\n+    }\n+\n+  ret = trampoline_page + trampoline_page_used;\n+  trampoline_page_used += full_size;\n+\n+  runtime_unlock (&trampoline_lock);\n+\n+  __builtin_memcpy (ret + full_size - ptr_size, &closure, ptr_size);\n+\n+  return (void *) ret;\n+}\n+\n+/* Scan the trampoline page when running the garbage collector.  This\n+   just makes sure that the garbage collector sees the pointer in\n+   trampoline_page, so that the page itself is not freed if there are\n+   no other references to it.  */\n+\n+void\n+runtime_trampoline_scan (void (*scan) (byte *, int64))\n+{\n+  if (trampoline_page != NULL)\n+    scan ((byte *) &trampoline_page, sizeof trampoline_page);\n }"}, {"sha": "bd5eedc5d8be896c7db2d63f85c5d94829dde07b", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dc840de43342b24006974f7899d127235adcba/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dc840de43342b24006974f7899d127235adcba/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=d4dc840de43342b24006974f7899d127235adcba", "patch": "@@ -703,6 +703,7 @@ mark(void (*scan)(byte*, int64))\n \tscan((byte*)&runtime_allm, sizeof runtime_allm);\n \truntime_MProf_Mark(scan);\n \truntime_time_scan(scan);\n+\truntime_trampoline_scan(scan);\n \n \t// mark stacks\n \tfor(gp=runtime_allg; gp!=nil; gp=gp->alllink) {"}, {"sha": "94f8911368963dc69716941293f1b79d0049d150", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dc840de43342b24006974f7899d127235adcba/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dc840de43342b24006974f7899d127235adcba/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=d4dc840de43342b24006974f7899d127235adcba", "patch": "@@ -490,6 +490,7 @@ uintptr\truntime_memlimit(void);\n void\truntime_setprof(bool);\n \n void\truntime_time_scan(void (*)(byte*, int64));\n+void\truntime_trampoline_scan(void (*)(byte *, int64));\n \n void\truntime_setsig(int32, bool, bool);\n #define runtime_setitimer setitimer"}]}