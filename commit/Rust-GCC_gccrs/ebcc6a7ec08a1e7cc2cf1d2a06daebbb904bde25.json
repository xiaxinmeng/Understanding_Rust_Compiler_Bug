{"sha": "ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjYzZhN2VjMDhhMWU3Y2MyY2YxZDJhMDZkYWViYmI5MDRiZGUyNQ==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2003-03-03T19:34:11Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2003-03-03T19:34:11Z"}, "message": "mark_rts.c (GC_cond_register_dynamic_libraries): add.\n\n2003-03-03  Hans Boehm  <Hans.Boehm@hp.com>\n\t* mark_rts.c (GC_cond_register_dynamic_libraries): add.\n\t(GC_push_roots): explicitly mark free list headers, register\n\tdynamic libraries only if !REGISTER_LIBRARIES_EARLY.\n\t* alloc.c (GC_stopped_mark): Conditionally call\n\tGC_cond_register_dynamic_libraries().\n\t(GC_collect_a_little_inner, GC_try_to_collect_inner): Check GC_dont_gc.\n\t* dyn_load.c (GC_register_main_static_data): define.\n\t(GC_register_dyn_libraries (Linux /proc, Linux ELF versions)):\n\tno longer skip main data.\n\t* misc.c (GC_REGISTER_MAIN_STATIC_DATA): define.\n\t(GC_init_inner): Make main data registration conditional.\n\t* include/private/gc_priv.h (GC_register_main_static_data): declare.\n\t* include/private/gcconfig.h (REGISTER_LIBRARIES_EARLY): define\n\tfor LINUX.\n\nFrom-SVN: r63727", "tree": {"sha": "0e084fa019f219c6affbd96447044ea359920119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e084fa019f219c6affbd96447044ea359920119"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/comments", "author": null, "committer": null, "parents": [{"sha": "b22b239e5a587d473731560ea5d05cba42bdd4a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b22b239e5a587d473731560ea5d05cba42bdd4a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b22b239e5a587d473731560ea5d05cba42bdd4a7"}], "stats": {"total": 141, "additions": 118, "deletions": 23}, "files": [{"sha": "a33943e8518e62655aaf17500eac242671aaee46", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "patch": "@@ -1,3 +1,19 @@\n+2003-03-03  Hans Boehm  <Hans.Boehm@hp.com>\n+\t* mark_rts.c (GC_cond_register_dynamic_libraries): add.\n+\t(GC_push_roots): explicitly mark free list headers, register\n+\tdynamic libraries only if !REGISTER_LIBRARIES_EARLY.\n+\t* alloc.c (GC_stopped_mark): Conditionally call\n+\tGC_cond_register_dynamic_libraries().\n+\t(GC_collect_a_little_inner, GC_try_to_collect_inner): Check GC_dont_gc.\n+\t* dyn_load.c (GC_register_main_static_data): define.\n+\t(GC_register_dyn_libraries (Linux /proc, Linux ELF versions)):\n+\tno longer skip main data.\n+\t* misc.c (GC_REGISTER_MAIN_STATIC_DATA): define.\n+\t(GC_init_inner): Make main data registration conditional.\n+\t* include/private/gc_priv.h (GC_register_main_static_data): declare.\n+\t* include/private/gcconfig.h (REGISTER_LIBRARIES_EARLY): define\n+\tfor LINUX.\n+\n 2003-02-20  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* configure.in: Propagate ORIGINAL_LD_FOR_MULTILIBS to"}, {"sha": "f2e5af057203960a768408a52ec447555614751d", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "patch": "@@ -306,6 +306,7 @@ void GC_maybe_gc()\n GC_bool GC_try_to_collect_inner(stop_func)\n GC_stop_func stop_func;\n {\n+    if (GC_dont_gc) return FALSE;\n     if (GC_incremental && GC_collection_in_progress()) {\n #   ifdef CONDPRINT\n       if (GC_print_stats) {\n@@ -386,6 +387,7 @@ int n;\n {\n     register int i;\n     \n+    if (GC_dont_gc) return;\n     if (GC_incremental && GC_collection_in_progress()) {\n     \tfor (i = GC_deficit; i < GC_RATE*n; i++) {\n     \t    if (GC_mark_some((ptr_t)0)) {\n@@ -446,6 +448,9 @@ GC_stop_func stop_func;\n \tCLOCK_TYPE start_time, current_time;\n #   endif\n \t\n+#   if defined(REGISTER_LIBRARIES_EARLY)\n+        GC_cond_register_dynamic_libraries();\n+#   endif\n     STOP_WORLD();\n #   ifdef PRINTTIMES\n \tGET_TIME(start_time);"}, {"sha": "f7b88f00dabd7b3bbd77f8dbaf5bdd238d05d851", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "patch": "@@ -355,10 +355,6 @@ void GC_register_dynamic_libraries()\n \t\t/* Stack mapping; discard\t*/\n \t\tcontinue;\n \t    }\n-\t    if (start <= datastart && end > datastart && maj_dev != 0) {\n-\t\t/* Main data segment; discard\t*/\n-\t\tcontinue;\n-\t    }\n #\t    ifdef THREADS\n \t      if (GC_segment_is_thread_stack(start, end)) continue;\n #\t    endif\n@@ -384,6 +380,13 @@ void GC_register_dynamic_libraries()\n      }\n }\n \n+/* We now take care of the main data segment ourselves: */\n+GC_bool GC_register_main_static_data()\n+{\n+  return FALSE;\n+}\n+  \n+# define HAVE_REGISTER_MAIN_STATIC_DATA\n //\n //  parse_map_entry parses an entry from /proc/self/maps so we can\n //  locate all writable data segments that belong to shared libraries.\n@@ -469,13 +472,6 @@ static int GC_register_dynlib_callback(info, size, ptr)\n       + sizeof (info->dlpi_phnum))\n     return -1;\n \n-  /* Skip the first object - it is the main program.  */\n-  if (*(int *)ptr == 0)\n-    {\n-      *(int *)ptr = 1;\n-      return 0;\n-    }\n-\n   p = info->dlpi_phdr;\n   for( i = 0; i < (int)(info->dlpi_phnum); ((i++),(p++)) ) {\n     switch( p->p_type ) {\n@@ -510,6 +506,14 @@ GC_bool GC_register_dynamic_libraries_dl_iterate_phdr()\n   }\n }\n \n+/* Do we need to separately register the main static data segment? */\n+GC_bool GC_register_main_static_data()\n+{\n+  return (dl_iterate_phdr == 0);\n+}\n+\n+#define HAVE_REGISTER_MAIN_STATIC_DATA\n+\n # else /* !LINUX || version(glibc) < 2.2.4 */\n \n /* Dynamic loading code for Linux running ELF. Somewhat tested on\n@@ -775,10 +779,23 @@ void GC_register_dynamic_libraries()\n     }\n # endif\n \n-# ifndef MSWINCE\n+# ifdef MSWINCE\n+  /* Do we need to separately register the main static data segment? */\n+  GC_bool GC_register_main_static_data()\n+  {\n+    return FALSE;\n+  }\n+# else /* win32 */\n   extern GC_bool GC_no_win32_dlls;\n-# endif\n+\n+  GC_bool GC_register_main_static_data()\n+  {\n+    return GC_no_win32_dlls;\n+  }\n+# endif /* win32 */\n   \n+# define HAVE_REGISTER_MAIN_STATIC_DATA\n+\n   void GC_register_dynamic_libraries()\n   {\n     MEMORY_BASIC_INFORMATION buf;\n@@ -1079,4 +1096,15 @@ void GC_register_dynamic_libraries(){}\n int GC_no_dynamic_loading;\n \n #endif /* !PCR */\n+\n #endif /* !DYNAMIC_LOADING */\n+\n+#ifndef HAVE_REGISTER_MAIN_STATIC_DATA\n+\n+/* Do we need to separately register the main static data segment? */\n+GC_bool GC_register_main_static_data()\n+{\n+  return TRUE;\n+}\n+#endif /* HAVE_REGISTER_MAIN_STATIC_DATA */\n+"}, {"sha": "dac604f2a117f59d543646cee73875e46cd11bfd", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "patch": "@@ -1462,6 +1462,11 @@ GC_bool GC_is_tmp_root GC_PROTO((ptr_t p));\n # endif\n void GC_register_dynamic_libraries GC_PROTO((void));\n   \t\t/* Add dynamic library data sections to the root set. */\n+\n+GC_bool GC_register_main_static_data GC_PROTO((void));\n+               /* We need to register the main data segment.  Returns  */\n+               /* TRUE unless this is done implicitly as part of       */\n+               /* dynamic library registration.                        */\n   \n /* Machine dependent startup routines */\n ptr_t GC_get_stack_base GC_PROTO((void));\t/* Cold end of stack */"}, {"sha": "af0d2e4ec49077b8ca29accdae81d8f2c30cd376", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "patch": "@@ -1801,6 +1801,15 @@\n #   define CACHE_LINE_SIZE 32\t/* Wild guess\t*/\n # endif\n \n+# ifdef LINUX\n+#   define REGISTER_LIBRARIES_EARLY\n+    /* We sometimes use dl_iterate_phdr, which may acquire an internal\t*/\n+    /* lock.  This isn't safe after the world has stopped.  So we must\t*/\n+    /* call GC_register_dynamic_libraries before stopping the world.\t*/\n+    /* For performance reasons, this may be beneficial on other\t\t*/\n+    /* platforms as well, though it should be avoided in win32.\t\t*/\n+# endif /* LINUX */\n+\n # ifndef CLEAR_DOUBLE\n #   define CLEAR_DOUBLE(x) \\\n \t((word*)x)[0] = 0; \\"}, {"sha": "f663dcd55c347b8232b6e641b690363dd9ec763b", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "patch": "@@ -506,6 +506,17 @@ void GC_push_gc_structures GC_PROTO((void))\n   void GC_mark_thread_local_free_lists();\n #endif\n \n+void GC_cond_register_dynamic_libraries()\n+{\n+# if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(MSWINCE) \\\n+     || defined(PCR)) && !defined(SRC_M3)\n+    GC_remove_tmp_roots();\n+    if (!GC_no_dls) GC_register_dynamic_libraries();\n+# else\n+    GC_no_dls = TRUE;\n+# endif\n+}\n+\n /*\n  * Call the mark routines (GC_tl_push for a single pointer, GC_push_conditional\n  * on groups of pointers) on every top level accessible pointer.\n@@ -519,19 +530,20 @@ void GC_push_roots(all, cold_gc_frame)\n GC_bool all;\n ptr_t cold_gc_frame;\n {\n-    register int i;\n+    int i;\n+    int kind;\n \n     /*\n      * Next push static data.  This must happen early on, since it's\n      * not robust against mark stack overflow.\n      */\n-     /* Reregister dynamic libraries, in case one got added.\t*/\n-#      if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(MSWINCE) \\\n-\t   || defined(PCR)) && !defined(SRC_M3)\n-         GC_remove_tmp_roots();\n-         if (!GC_no_dls) GC_register_dynamic_libraries();\n-#      else\n-\t GC_no_dls = TRUE;\n+     /* Reregister dynamic libraries, in case one got added.\t\t*/\n+     /* There is some argument for doing this as late as possible,\t*/\n+     /* especially on win32, where it can change asynchronously.\t*/\n+     /* In those cases, we do it here.  But on other platforms, it's\t*/\n+     /* not safe with the world stopped, so we do it earlier.\t\t*/\n+#      if !defined(REGISTER_LIBRARIES_EARLY)\n+         GC_cond_register_dynamic_libraries();\n #      endif\n \n      /* Mark everything in static data areas                             */\n@@ -541,6 +553,18 @@ ptr_t cold_gc_frame;\n \t\t\t     GC_static_roots[i].r_end, all);\n        }\n \n+     /* Mark all free list header blocks, if those were allocated from\t*/\n+     /* the garbage collected heap.  This makes sure they don't \t*/\n+     /* disappear if we are not marking from static data.  It also \t*/\n+     /* saves us the trouble of scanning them, and possibly that of\t*/\n+     /* marking the freelists.\t\t\t\t\t\t*/\n+       for (kind = 0; kind < GC_n_kinds; kind++) {\n+\t GC_PTR base = GC_base(GC_obj_kinds[kind].ok_freelist);\n+\t if (0 != base) {\n+\t   GC_set_mark_bit(base);\n+\t }\n+       }\n+       \n      /* Mark from GC internal roots if those might otherwise have\t*/\n      /* been excluded.\t\t\t\t\t\t\t*/\n        if (GC_no_dls || roots_were_cleared) {"}, {"sha": "891cdc722b750c3d09a1057e9c62de14fff7fc59", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "patch": "@@ -75,6 +75,14 @@\n #undef STACKBASE\n #endif\n \n+/* Dont unnecessarily call GC_register_main_static_data() in case      */\n+/* dyn_load.c isn't linked in.                                         */\n+#ifdef DYNAMIC_LOADING\n+# define GC_REGISTER_MAIN_STATIC_DATA() GC_register_main_static_data()\n+#else\n+# define GC_REGISTER_MAIN_STATIC_DATA() TRUE\n+#endif\n+\n GC_FAR struct _GC_arrays GC_arrays /* = { 0 } */;\n \n \n@@ -572,7 +580,7 @@ void GC_init_inner()\n  \tGC_init_win32();\n #   endif\n #   if defined(SEARCH_FOR_DATA_START)\n-\tGC_init_linux_data_start();\n+\tif (GC_REGISTER_MAIN_STATIC_DATA()) GC_init_linux_data_start();\n #   endif\n #   if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__)\n \tGC_init_netbsd_elf();\n@@ -619,7 +627,7 @@ void GC_init_inner()\n     \n     /* Add initial guess of root sets.  Do this first, since sbrk(0)\t*/\n     /* might be used.\t\t\t\t\t\t\t*/\n-      GC_register_data_segments();\n+      if (GC_REGISTER_MAIN_STATIC_DATA()) GC_register_data_segments();\n     GC_init_headers();\n     GC_bl_init();\n     GC_mark_init();"}]}