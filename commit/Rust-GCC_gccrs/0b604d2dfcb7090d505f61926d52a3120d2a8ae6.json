{"sha": "0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI2MDRkMmRmY2I3MDkwZDUwNWY2MTkyNmQ1MmEzMTIwZDJhOGFlNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-02-08T08:17:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-02-08T08:17:32Z"}, "message": "re PR tree-optimization/65917 (XFAIL: gcc.dg/tree-ssa/20030922-2.c scan-tree-dump-times dom1 \"if \" 2)\n\n\tPR tree-optimization/65917\n\t* tree-ssa-dom.c (record_temporary_equivalences): Record both\n\tequivalences from if (x == y) style conditionals.\n\t(loop_depth_of_name): Remove.\n\t(record_equality): Remove loop depth check.\n\t* tree-ssa-scopedtables.h (const_and_copies): Refine comments.\n\t(const_and_copies::record_const_or_copy_raw): New member function.\n\t* tree-ssa-scopedtables.c\n\t(const_and_copies::record_const_or_copy_raw): New, factored out of\n\t(const_and_copies::record_const_or_copy): Call new member function.\n\n        PR tree-optimization/65917\n\t* gcc.dg/tree-ssa/20030922-2.c: No longer xfailed.\n\nFrom-SVN: r233207", "tree": {"sha": "a0b8a7032a204ba54d4ba93707fd009cc159e7f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0b8a7032a204ba54d4ba93707fd009cc159e7f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/comments", "author": null, "committer": null, "parents": [{"sha": "0992653dafae6e1f1da30565549bf60a830d3514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0992653dafae6e1f1da30565549bf60a830d3514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0992653dafae6e1f1da30565549bf60a830d3514"}], "stats": {"total": 117, "additions": 65, "deletions": 52}, "files": [{"sha": "2c4a8b6096dfd3f474b323fd4ece1188cd2a6e88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "patch": "@@ -1,3 +1,17 @@\n+2016-02-08  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/65917\n+\t* tree-ssa-dom.c (record_temporary_equivalences): Record both\n+\tequivalences from if (x == y) style conditionals.\n+\t(loop_depth_of_name): Remove.\n+\t(record_equality): Remove loop depth check.\n+\t* tree-ssa-scopedtables.h (const_and_copies): Refine comments.\n+\t(const_and_copies::record_const_or_copy_raw): New member function.\n+\t* tree-ssa-scopedtables.c\n+\t(const_and_copies::record_const_or_copy_raw): New, factored out of\n+\t(const_and_copies::record_const_or_copy): Call new member function.\n+\t\n+\n 2016-02-05  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/68541"}, {"sha": "6940136a848d27d4bb54b3d75245cf4f76c4c290", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "patch": "@@ -1,3 +1,8 @@\n+2016-02-08  Jeff Law  <law@redhat.com>\n+\n+        PR tree-optimization/65917\n+\t* gcc.dg/tree-ssa/20030922-2.c: No longer xfailed.\n+\n 2016-02-07  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/50555"}, {"sha": "16c79da9521cec88426d1e48958c53a219307ce1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030922-2.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c?ref=0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "patch": "@@ -20,8 +20,4 @@ rgn_rank (rtx insn1, rtx insn2)\n }\n \n /* There should be two IF conditionals.  */\n-/* This now fails as it requires a very specific decision of DOM which\n-   SSA name to record as a copy of the other when DOM derives copies\n-   from temporary equivalences.  The heuristics there no longer do\n-   the correct thing.  VRP still optimizes this testcase.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 2 \"dom2\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 2 \"dom2\" } } */"}, {"sha": "f44ac135d792cc10e73dc3e78389c8f01555fc88", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "patch": "@@ -917,6 +917,15 @@ record_temporary_equivalences (edge e,\n       tree rhs = edge_info->rhs;\n       record_equality (lhs, rhs, const_and_copies);\n \n+      /* We already recorded that LHS = RHS, with canonicalization,\n+\t value chain following, etc.\n+\n+\t We also want to return RHS = LHS, but without any canonicalization\n+\t or value chain following.  */\n+      if (TREE_CODE (rhs) == SSA_NAME)\n+\tconst_and_copies->record_const_or_copy_raw (rhs, lhs,\n+\t\t\t\t\t\t    SSA_NAME_VALUE (rhs));\n+\n       /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n \t set via a widening type conversion, then we may be able to record\n \t additional equivalences.  */\n@@ -1161,33 +1170,6 @@ record_cond (cond_equivalence *p,\n     delete element;\n }\n \n-/* Return the loop depth of the basic block of the defining statement of X.\n-   This number should not be treated as absolutely correct because the loop\n-   information may not be completely up-to-date when dom runs.  However, it\n-   will be relatively correct, and as more passes are taught to keep loop info\n-   up to date, the result will become more and more accurate.  */\n-\n-static int\n-loop_depth_of_name (tree x)\n-{\n-  gimple *defstmt;\n-  basic_block defbb;\n-\n-  /* If it's not an SSA_NAME, we have no clue where the definition is.  */\n-  if (TREE_CODE (x) != SSA_NAME)\n-    return 0;\n-\n-  /* Otherwise return the loop depth of the defining statement's bb.\n-     Note that there may not actually be a bb for this statement, if the\n-     ssa_name is live on entry.  */\n-  defstmt = SSA_NAME_DEF_STMT (x);\n-  defbb = gimple_bb (defstmt);\n-  if (!defbb)\n-    return 0;\n-\n-  return bb_loop_depth (defbb);\n-}\n-\n /* Similarly, but assume that X and Y are the two operands of an EQ_EXPR.\n    This constrains the cases in which we may treat this as assignment.  */\n \n@@ -1224,10 +1206,7 @@ record_equality (tree x, tree y, class const_and_copies *const_and_copies)\n      long as we canonicalize on one value.  */\n   if (is_gimple_min_invariant (y))\n     ;\n-  else if (is_gimple_min_invariant (x)\n-\t   /* ???  When threading over backedges the following is important\n-\t      for correctness.  See PR61757.  */\n-\t   || (loop_depth_of_name (x) < loop_depth_of_name (y)))\n+  else if (is_gimple_min_invariant (x))\n     prev_x = x, x = y, y = prev_x, prev_x = prev_y;\n   else if (prev_x && is_gimple_min_invariant (prev_x))\n     x = y, y = prev_x, prev_x = prev_y;"}, {"sha": "b18978e4ab78c172c9d8ec9ef0ae83283b0489f3", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "patch": "@@ -700,6 +700,28 @@ const_and_copies::pop_to_marker (void)\n     }\n }\n \n+/* Record that X has the value Y and that X's previous value is PREV_X. \n+\n+   This variant does not follow the value chain for Y.  */\n+\n+void\n+const_and_copies::record_const_or_copy_raw (tree x, tree y, tree prev_x)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"0>>> COPY \");\n+      print_generic_expr (dump_file, x, 0);\n+      fprintf (dump_file, \" = \");\n+      print_generic_expr (dump_file, y, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  set_ssa_name_value (x, y);\n+  m_stack.reserve (2);\n+  m_stack.quick_push (prev_x);\n+  m_stack.quick_push (x);\n+}\n+\n /* Record that X has the value Y.  */\n \n void\n@@ -708,7 +730,9 @@ const_and_copies::record_const_or_copy (tree x, tree y)\n   record_const_or_copy (x, y, SSA_NAME_VALUE (x));\n }\n \n-/* Record that X has the value Y and that X's previous value is PREV_X.  */\n+/* Record that X has the value Y and that X's previous value is PREV_X. \n+\n+   This variant follow's Y value chain.  */\n \n void\n const_and_copies::record_const_or_copy (tree x, tree y, tree prev_x)\n@@ -720,19 +744,7 @@ const_and_copies::record_const_or_copy (tree x, tree y, tree prev_x)\n       y = tmp ? tmp : y;\n     }\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"0>>> COPY \");\n-      print_generic_expr (dump_file, x, 0);\n-      fprintf (dump_file, \" = \");\n-      print_generic_expr (dump_file, y, 0);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  set_ssa_name_value (x, y);\n-  m_stack.reserve (2);\n-  m_stack.quick_push (prev_x);\n-  m_stack.quick_push (x);\n+  record_const_or_copy_raw (x, y, prev_x);\n }\n \n bool"}, {"sha": "c9338212c2e2e7b4290147064a5d9a98842b29c6", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b604d2dfcb7090d505f61926d52a3120d2a8ae6/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=0b604d2dfcb7090d505f61926d52a3120d2a8ae6", "patch": "@@ -161,11 +161,18 @@ class const_and_copies\n      was pushed.  */\n   void pop_to_marker (void);\n \n-  /* Record a single const/copy pair that can be unwound.  */\n+  /* Record a single const/copy pair that can be unwound.  This version\n+     may follow the value chain for the RHS.  */\n   void record_const_or_copy (tree, tree);\n \n+  /* Record a single const/copy pair that can be unwound.  This version\n+     does not follow the value chain for the RHS.  */\n+  void record_const_or_copy_raw (tree, tree, tree);\n+\n   /* Special entry point when we want to provide an explicit previous\n-     value for the first argument.  Try to get rid of this in the future.  */\n+     value for the first argument.  Try to get rid of this in the future. \n+\n+     This version may also follow the value chain for the RHS.  */\n   void record_const_or_copy (tree, tree, tree);\n \n  private:"}]}