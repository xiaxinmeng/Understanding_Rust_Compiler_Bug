{"sha": "973625a04b3d9351f2485e37f7d3382af2aed87e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczNjI1YTA0YjNkOTM1MWYyNDg1ZTM3ZjdkMzM4MmFmMmFlZDg3ZQ==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2016-09-20T23:23:55Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2016-09-20T23:23:55Z"}, "message": "Add Early VRP\n\ngcc/ChangeLog:\n\n2016-09-21  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* doc/invoke.texi: Document -fdump-tree-evrp.\n\t* passes.def: Define new pass_early_vrp.\n\t* timevar.def: Define new TV_TREE_EARLY_VRP.\n\t* tree-pass.h (make_pass_early_vrp): New.\n\t* tree-ssa-propagate.c: Make replace_uses_in non static.\n\t* tree-ssa-propagate.h: Export replace_uses_in.\n\t* tree-vrp.c (extract_range_for_var_from_comparison_expr): New.\n\t(extract_range_from_assert): Factor out\n\textract_range_for_var_from_comparison_expr.\n\t(vrp_initialize_lattice): New.\n\t(vrp_initialize): Factor out vrp_initialize_lattice.\n\t(vrp_valueize): Fix it to reject complex value ranges.\n\t(vrp_free_lattice): New.\n\t(evrp_dom_walker::before_dom_children): Likewise.\n\t(evrp_dom_walker::after_dom_children): Likewise.\n\t(evrp_dom_walker::push_value_range): Likewise.\n\t(evrp_dom_walker::pop_value_range): Likewise.\n\t(execute_early_vrp): Likewise.\n\t(execute_vrp): Call vrp_initialize_lattice and\n\tvrp_free_lattice.\n\t(make_pass_early_vrp): New.\n\n\ngcc/testsuite/ChangeLog:\n\n2016-09-21  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* g++.dg/tree-ssa/pr31146-2.C: Run with -fno-tree-evrp as evrp also\n\tdoes the same transformation.\n\t* g++.dg/warn/pr33738.C: XFAIL as optimization now happens in ccp.\n\t* gcc.dg/tree-ssa/evrp1.c: New test.\n\t* gcc.dg/tree-ssa/evrp2.c: New test.\n\t* gcc.dg/tree-ssa/evrp3.c: New test.\n\t* gcc.dg/tree-ssa/pr20657.c: Check for the pattern in evrp dump.\n\t* gcc.dg/tree-ssa/pr22117.c: Likewise.\n\t* gcc.dg/tree-ssa/pr61839_2.c: Likewise.\n\t* gcc.dg/tree-ssa/pr64130.c: Likewise.\n\t* gcc.dg/tree-ssa/pr37508.c: Change the pattern to be checked as\n\tfoling now happens early.\n\t* gcc.dg/tree-ssa/vrp04.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp06.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp16.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp25.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp67.c: Likewise.\n\nFrom-SVN: r240291", "tree": {"sha": "47734284907638beb972b85c7a451e86b5532778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47734284907638beb972b85c7a451e86b5532778"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/973625a04b3d9351f2485e37f7d3382af2aed87e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973625a04b3d9351f2485e37f7d3382af2aed87e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973625a04b3d9351f2485e37f7d3382af2aed87e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973625a04b3d9351f2485e37f7d3382af2aed87e/comments", "author": null, "committer": null, "parents": [{"sha": "aa9baacfc94e6147c84d5e0fbbd32dd948e7c8cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9baacfc94e6147c84d5e0fbbd32dd948e7c8cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa9baacfc94e6147c84d5e0fbbd32dd948e7c8cf"}], "stats": {"total": 612, "additions": 536, "deletions": 76}, "files": [{"sha": "fe7376ebf1be08c3bcb8726df027eb9a1bf58eb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -1,3 +1,27 @@\n+2016-09-21  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* doc/invoke.texi: Document -fdump-tree-evrp.\n+\t* passes.def: Define new pass_early_vrp.\n+\t* timevar.def: Define new TV_TREE_EARLY_VRP.\n+\t* tree-pass.h (make_pass_early_vrp): New.\n+\t* tree-ssa-propagate.c: Make replace_uses_in non static.\n+\t* tree-ssa-propagate.h: Export replace_uses_in.\n+\t* tree-vrp.c (extract_range_for_var_from_comparison_expr): New.\n+\t(extract_range_from_assert): Factor out\n+\textract_range_for_var_from_comparison_expr.\n+\t(vrp_initialize_lattice): New.\n+\t(vrp_initialize): Factor out vrp_initialize_lattice.\n+\t(vrp_valueize): Fix it to reject complex value ranges.\n+\t(vrp_free_lattice): New.\n+\t(evrp_dom_walker::before_dom_children): Likewise.\n+\t(evrp_dom_walker::after_dom_children): Likewise.\n+\t(evrp_dom_walker::push_value_range): Likewise.\n+\t(evrp_dom_walker::pop_value_range): Likewise.\n+\t(execute_early_vrp): Likewise.\n+\t(execute_vrp): Call vrp_initialize_lattice and\n+\tvrp_free_lattice.\n+\t(make_pass_early_vrp): New.\n+\n 2016-09-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (mult->ashift peephole2s): Use pow2p_hwi"}, {"sha": "05566ba62a0fa067cf006fb1fba04d1b291ad877", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -12523,6 +12523,11 @@ is made by appending @file{.slp} to the source file name.\n Dump each function after Value Range Propagation (VRP).  The file name\n is made by appending @file{.vrp} to the source file name.\n \n+@item early vrp\n+@opindex fdump-tree-evrp\n+Dump each function after Early Value Range Propagation (EVRP).  The file name\n+is made by appending @file{.evrp} to the source file name.\n+\n @item oaccdevlow\n @opindex fdump-tree-oaccdevlow\n Dump each function after applying device-specific OpenACC transformations."}, {"sha": "6a83371f8c23af3745d9a125ce2c7d8643be2a1b", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -90,6 +90,7 @@ along with GCC; see the file COPYING3.  If not see\n \t     execute TODO_rebuild_alias at this point.  */\n \t  NEXT_PASS (pass_build_ealias);\n \t  NEXT_PASS (pass_fre);\n+\t  NEXT_PASS (pass_early_vrp);\n \t  NEXT_PASS (pass_merge_phi);\n           NEXT_PASS (pass_dse);\n \t  NEXT_PASS (pass_cd_dce);"}, {"sha": "4efb5894b560e6a01a681e7130e3261b571f8755", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -1,3 +1,23 @@\n+2016-09-21  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* g++.dg/tree-ssa/pr31146-2.C: Run with -fno-tree-evrp as evrp also\n+\tdoes the same transformation.\n+\t* g++.dg/warn/pr33738.C: XFAIL as optimization now happens in ccp.\n+\t* gcc.dg/tree-ssa/evrp1.c: New test.\n+\t* gcc.dg/tree-ssa/evrp2.c: New test.\n+\t* gcc.dg/tree-ssa/evrp3.c: New test.\n+\t* gcc.dg/tree-ssa/pr20657.c: Check for the pattern in evrp dump.\n+\t* gcc.dg/tree-ssa/pr22117.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr61839_2.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr64130.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr37508.c: Change the pattern to be checked as\n+\tfoling now happens early.\n+\t* gcc.dg/tree-ssa/vrp04.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp06.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp16.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp25.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp67.c: Likewise.\n+\n 2016-09-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/77621"}, {"sha": "cf4ed33dd50db88e6319dbc24f2a586e247e4101", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr31146-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146-2.C?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-forwprop1\" } */\n+/* { dg-options \"-O -fno-tree-vrp -fdump-tree-forwprop1\" } */\n \n #include <new>\n "}, {"sha": "73e98d5e083c4e419e6df0ec651a0bdc0704eb2e", "filename": "gcc/testsuite/g++.dg/warn/pr33738.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr33738.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr33738.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr33738.C?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -15,11 +15,11 @@ int GetM1() {\n \n int main() {\n  a2 = static_cast<Alpha>(GetM1());\n- if (a2 == -1) {\t// { dg-warning \"always false due\" }\n+ if (a2 == -1) {\t// { dg-warning \"always false due\" \"\" { xfail *-*-* } } */\n     link_error ();\n  }\n  a2 = static_cast<Alpha>(GetM1());\n- if (-1 == a2) {\t// { dg-warning \"always false due\" }\n+ if (-1 == a2) {\t// { dg-warning \"always false due\" \"\" { xfail *-*-* } } */\n     link_error ();\n  }\n  return 0;"}, {"sha": "8c6e4e60a669094f839d962c38a04101c36d6a68", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp1.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+int foo (int i);\n+int bar (int j)\n+{\n+  if (j > 2)\n+    return foo (j + 2);\n+  else\n+    return j;\n+}\n+\n+/* { dg-final { scan-tree-dump \"\\\\\\[5, \\\\+INF\" \"evrp\" } } */"}, {"sha": "e6d423555c1fd5660588057cf1ab613cfcd888b4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp2.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+int foo (int i);\n+int bar2 (int j)\n+{\n+  if (j > 2)\n+    {\n+      if (j < 7)\n+\treturn foo (j + 1);\n+      else\n+\treturn foo (j + 2);\n+    }\n+  return j;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump \"\\\\\\[4, 7\\\\\\]\" \"evrp\" } } */"}, {"sha": "1a3bbd52aa070b278768e4e35b94b5b121cb7a64", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp3.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+int foo (int i);\n+void bar (int j)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 10; ++i)\n+    {\n+      bar (i + 1);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"\\\\\\[1, 10\\\\\\]\" \"evrp\" } } */\n+"}, {"sha": "e67823150dab50a1e971f5fc329f096fa064d260", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20657.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20657.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20657.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20657.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -3,7 +3,7 @@\n    statement, which was needed to eliminate the second \"if\" statement.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-dominator-opts -fno-tree-fre -fdump-tree-vrp1-details\" } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fno-tree-fre -fdump-tree-evrp\" } */\n \n int\n foo (int a)\n@@ -14,4 +14,4 @@ foo (int a)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 1 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"if\" 1 \"evrp\"} } */"}, {"sha": "01cd33e958179e6690f3acf712727b7810feb176", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22117.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22117.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22117.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22117.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -21,4 +21,4 @@ foo (int *p, int q)\n     }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate r_.* != 0B to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"vrp1\" } } */"}, {"sha": "2ba09afe4819e622e34798dcbe935a184fe39e77", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr37508.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr37508.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr37508.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr37508.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -46,4 +46,4 @@ int test4 (struct foo2 *x)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding\" 2 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 2 \"vrp1\" } } */"}, {"sha": "e44dc576c5143507d0ce134e1b44b275965844e1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr61839_2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61839_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61839_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr61839_2.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/61839.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n /* { dg-require-effective-target int32plus } */\n \n __attribute__ ((noinline))\n@@ -47,8 +47,8 @@ int bar2 ()\n \n \n /* Dont optimize 972195717 / 0 in function foo.  */\n-/* { dg-final { scan-tree-dump-times \"972195717 / _\" 1  \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"972195717 / _\" 1  \"evrp\" } } */\n /* Dont optimize 972195717 % 0 in function bar.  */\n-/* { dg-final { scan-tree-dump-times \"972195717 % _\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"972195717 % _\" 1 \"evrp\" } } */\n /* Optimize in function bar2.  */\n-/* { dg-final { scan-tree-dump-times \"972195715 % _\" 0 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"972195715 % _\" 0 \"evrp\" } } */"}, {"sha": "f39bd179a8c99e29b69610089ef7e80e4a63eebc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr64130.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64130.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64130.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64130.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -1,6 +1,6 @@\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n \n int funsigned (unsigned a)\n {\n@@ -13,6 +13,6 @@ int funsigned2 (unsigned a)\n   return (-1 * 0x1ffffffffL) / a == 0;\n }\n \n-/* { dg-final { scan-tree-dump \": \\\\\\[2, 8589934591\\\\\\]\" \"vrp1\" } } */\n-/* { dg-final { scan-tree-dump \": \\\\\\[-8589934591, -2\\\\\\]\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump \": \\\\\\[2, 8589934591\\\\\\]\" \"evrp\" } } */\n+/* { dg-final { scan-tree-dump \": \\\\\\[-8589934591, -2\\\\\\]\" \"evrp\" } } */\n "}, {"sha": "67f8f01139eff96a229d7ee86241566ea0f7ec78", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp04.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -10,4 +10,4 @@ foo (int a, int b)\n       return a + b;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate a_.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 1 \"vrp1\" } } */"}, {"sha": "c4ce1703f551a7a0d64fc14e0ce4c13f63b72f2d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp06.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -28,6 +28,6 @@ foo (int i, int j, int a)\n   return i + a + j;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate i_\\[0-9\\]+.*0 to 0\" 1 \"vrp1\" } } */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate j_\\[0-9\\]+.*0 to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate \\[i|j\\]_\\[0-9\\]+.*0 to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate \\[i|j\\]_\\[0-9\\]+.*0 to 1\" 1 \"vrp1\" } } */\n /* { dg-final { scan-tree-dump-times \"Folding predicate i_\\[0-9]+.*j_\\[0-9\\]+.* to 0\" 1 \"vrp1\" } } */"}, {"sha": "d09f3aea46aa3eb4c501e215b4f5d01aa7c211f5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-vrp1-details\" } */\n+/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-evrp\" } */\n \n \n extern void abort (void) __attribute__ ((__noreturn__));\n@@ -19,5 +19,5 @@ nonlocal_mentioned_p (rtx x)\n \tabort ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate .*to 0\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 0 \"evrp\" } } */\n "}, {"sha": "a49f0793f96299d061dc00293f5e05f75db98d9c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp25.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp25.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-vrp1-details\" } */\n+/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-vrp1\" } */\n \n extern void abort ();\n extern void arf ();\n@@ -49,5 +49,5 @@ blah (int code1)\n /* The second test of (code1 != 53) and the test (D18670 <= 2) are\n    both totally subsumed by earlier tests and thus should be folded\n    away using VRP.  */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 2 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 3 \"vrp1\" } } */\n "}, {"sha": "5155f7b6daf5c95f7d1b3a2f90f1f93892e25e4c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp67.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp67.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp67.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp67.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -36,4 +36,4 @@ unsigned baz (unsigned i)\n   return i;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Folding predicate\" 3 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 3 \"vrp1\" } } */"}, {"sha": "88378328a795e9d2c4a22d8a4ebc685913522b40", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -149,6 +149,7 @@ DEFTIMEVAR (TV_TREE_CFG\t\t     , \"tree CFG construction\")\n DEFTIMEVAR (TV_TREE_CLEANUP_CFG\t     , \"tree CFG cleanup\")\n DEFTIMEVAR (TV_TREE_TAIL_MERGE       , \"tree tail merge\")\n DEFTIMEVAR (TV_TREE_VRP              , \"tree VRP\")\n+DEFTIMEVAR (TV_TREE_EARLY_VRP        , \"tree Early VRP\")\n DEFTIMEVAR (TV_TREE_COPY_PROP        , \"tree copy propagation\")\n DEFTIMEVAR (TV_FIND_REFERENCED_VARS  , \"tree find ref. vars\")\n DEFTIMEVAR (TV_TREE_PTA\t\t     , \"tree PTA\")"}, {"sha": "251b30ffcdffb21a466cfed8eb2507dbda4f2a4b", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -441,6 +441,7 @@ extern gimple_opt_pass *make_pass_fre (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_check_data_deps (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_copy_prop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_isolate_erroneous_paths (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_early_vrp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_vrp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_uncprop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_return_slot (gcc::context *ctxt);"}, {"sha": "97cfde57c9d88053541c9d06148c71a9d179edb4", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -863,7 +863,7 @@ static struct prop_stats_d prop_stats;\n /* Replace USE references in statement STMT with the values stored in\n    PROP_VALUE. Return true if at least one reference was replaced.  */\n \n-static bool\n+bool\n replace_uses_in (gimple *stmt, ssa_prop_get_value_fn get_value)\n {\n   bool replaced = false;"}, {"sha": "1a969765f09283bdde73a00296084706c6dcb791", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -84,5 +84,6 @@ extern void propagate_value (use_operand_p, tree);\n extern void replace_exp (use_operand_p, tree);\n extern void propagate_tree_value (tree *, tree);\n extern void propagate_tree_value_into_stmt (gimple_stmt_iterator *, tree);\n+extern bool replace_uses_in (gimple *stmt, ssa_prop_get_value_fn get_value);\n \n #endif /* _TREE_SSA_PROPAGATE_H  */"}, {"sha": "e779759d3816b8f0cfffcd097d20163ab969a542", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 414, "deletions": 53, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973625a04b3d9351f2485e37f7d3382af2aed87e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=973625a04b3d9351f2485e37f7d3382af2aed87e", "patch": "@@ -60,6 +60,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"case-cfn-macros.h\"\n #include \"params.h\"\n #include \"alloc-pool.h\"\n+#include \"domwalk.h\"\n+#include \"tree-cfgcleanup.h\"\n \n #define VR_INITIALIZER { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL }\n \n@@ -1461,44 +1463,17 @@ op_with_boolean_value_range_p (tree op)\n \t  && integer_onep (vr->max));\n }\n \n-/* Extract value range information from an ASSERT_EXPR EXPR and store\n-   it in *VR_P.  */\n+/* Extract value range information for VAR when (OP COND_CODE LIMIT) is\n+   true and store it in *VR_P.  */\n \n static void\n-extract_range_from_assert (value_range *vr_p, tree expr)\n+extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n+\t\t\t\t\t    tree op, tree limit,\n+\t\t\t\t\t    value_range *vr_p)\n {\n-  tree var, cond, limit, min, max, type;\n+  tree  min, max, type;\n   value_range *limit_vr;\n-  enum tree_code cond_code;\n-\n-  var = ASSERT_EXPR_VAR (expr);\n-  cond = ASSERT_EXPR_COND (expr);\n-\n-  gcc_assert (COMPARISON_CLASS_P (cond));\n-\n-  /* Find VAR in the ASSERT_EXPR conditional.  */\n-  if (var == TREE_OPERAND (cond, 0)\n-      || TREE_CODE (TREE_OPERAND (cond, 0)) == PLUS_EXPR\n-      || TREE_CODE (TREE_OPERAND (cond, 0)) == NOP_EXPR)\n-    {\n-      /* If the predicate is of the form VAR COMP LIMIT, then we just\n-\t take LIMIT from the RHS and use the same comparison code.  */\n-      cond_code = TREE_CODE (cond);\n-      limit = TREE_OPERAND (cond, 1);\n-      cond = TREE_OPERAND (cond, 0);\n-    }\n-  else\n-    {\n-      /* If the predicate is of the form LIMIT COMP VAR, then we need\n-\t to flip around the comparison code to create the proper range\n-\t for VAR.  */\n-      cond_code = swap_tree_comparison (TREE_CODE (cond));\n-      limit = TREE_OPERAND (cond, 0);\n-      cond = TREE_OPERAND (cond, 1);\n-    }\n-\n   limit = avoid_overflow_infinity (limit);\n-\n   type = TREE_TYPE (var);\n   gcc_assert (limit != var);\n \n@@ -1544,15 +1519,15 @@ extract_range_from_assert (value_range *vr_p, tree expr)\n      as well build the range [b_4, +INF] for it.\n      One special case we handle is extracting a range from a\n      range test encoded as (unsigned)var + CST <= limit.  */\n-  if (TREE_CODE (cond) == NOP_EXPR\n-      || TREE_CODE (cond) == PLUS_EXPR)\n+  if (TREE_CODE (op) == NOP_EXPR\n+      || TREE_CODE (op) == PLUS_EXPR)\n     {\n-      if (TREE_CODE (cond) == PLUS_EXPR)\n+      if (TREE_CODE (op) == PLUS_EXPR)\n         {\n-          min = fold_build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (cond, 1)),\n-\t\t\t     TREE_OPERAND (cond, 1));\n+\t  min = fold_build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (op, 1)),\n+\t\t\t     TREE_OPERAND (op, 1));\n           max = int_const_binop (PLUS_EXPR, limit, min);\n-\t  cond = TREE_OPERAND (cond, 0);\n+\t  op = TREE_OPERAND (op, 0);\n \t}\n       else\n \t{\n@@ -1736,6 +1711,41 @@ extract_range_from_assert (value_range *vr_p, tree expr)\n   vrp_intersect_ranges (vr_p, get_value_range (var));\n }\n \n+/* Extract value range information from an ASSERT_EXPR EXPR and store\n+   it in *VR_P.  */\n+\n+static void\n+extract_range_from_assert (value_range *vr_p, tree expr)\n+{\n+  tree var = ASSERT_EXPR_VAR (expr);\n+  tree cond = ASSERT_EXPR_COND (expr);\n+  tree limit, op;\n+  enum tree_code cond_code;\n+  gcc_assert (COMPARISON_CLASS_P (cond));\n+\n+  /* Find VAR in the ASSERT_EXPR conditional.  */\n+  if (var == TREE_OPERAND (cond, 0)\n+      || TREE_CODE (TREE_OPERAND (cond, 0)) == PLUS_EXPR\n+      || TREE_CODE (TREE_OPERAND (cond, 0)) == NOP_EXPR)\n+    {\n+      /* If the predicate is of the form VAR COMP LIMIT, then we just\n+\t take LIMIT from the RHS and use the same comparison code.  */\n+      cond_code = TREE_CODE (cond);\n+      limit = TREE_OPERAND (cond, 1);\n+      op = TREE_OPERAND (cond, 0);\n+    }\n+  else\n+    {\n+      /* If the predicate is of the form LIMIT COMP VAR, then we need\n+\t to flip around the comparison code to create the proper range\n+\t for VAR.  */\n+      cond_code = swap_tree_comparison (TREE_CODE (cond));\n+      limit = TREE_OPERAND (cond, 0);\n+      op = TREE_OPERAND (cond, 1);\n+    }\n+  extract_range_for_var_from_comparison_expr (var, cond_code, op,\n+\t\t\t\t\t      limit, vr_p);\n+}\n \n /* Extract range information from SSA name VAR and store it in VR.  If\n    VAR has an interesting range, use it.  Otherwise, create the\n@@ -6953,19 +6963,24 @@ stmt_interesting_for_vrp (gimple *stmt)\n   return false;\n }\n \n-\n-/* Initialize local data structures for VRP.  */\n+/* Initialize VRP lattice.  */\n \n static void\n-vrp_initialize (void)\n+vrp_initialize_lattice ()\n {\n-  basic_block bb;\n-\n   values_propagated = false;\n   num_vr_values = num_ssa_names;\n   vr_value = XCNEWVEC (value_range *, num_vr_values);\n   vr_phi_edge_counts = XCNEWVEC (int, num_ssa_names);\n   bitmap_obstack_initialize (&vrp_equiv_obstack);\n+}\n+\n+/* Initialization required by ssa_propagate engine.  */\n+\n+static void\n+vrp_initialize ()\n+{\n+  basic_block bb;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -7016,6 +7031,8 @@ vrp_valueize (tree name)\n     {\n       value_range *vr = get_value_range (name);\n       if (vr->type == VR_RANGE\n+\t  && (TREE_CODE (vr->min) == SSA_NAME\n+\t      || is_gimple_min_invariant (vr->min))\n \t  && vrp_operand_equal_p (vr->min, vr->max))\n \treturn vr->min;\n     }\n@@ -10506,6 +10523,22 @@ finalize_jump_threads (void)\n   delete equiv_stack;\n }\n \n+/* Free VRP lattice.  */\n+\n+static void\n+vrp_free_lattice ()\n+{\n+  /* Free allocated memory.  */\n+  free (vr_value);\n+  free (vr_phi_edge_counts);\n+  bitmap_obstack_release (&vrp_equiv_obstack);\n+  vrp_value_range_pool.release ();\n+\n+  /* So that we can distinguish between VRP data being available\n+     and not available.  */\n+  vr_value = NULL;\n+  vr_phi_edge_counts = NULL;\n+}\n \n /* Traverse all the blocks folding conditionals with known ranges.  */\n \n@@ -10552,17 +10585,302 @@ vrp_finalize (bool warn_array_bounds_p)\n   /* We must identify jump threading opportunities before we release\n      the datastructures built by VRP.  */\n   identify_jump_threads ();\n+}\n \n-  /* Free allocated memory.  */\n-  free (vr_value);\n-  free (vr_phi_edge_counts);\n-  bitmap_obstack_release (&vrp_equiv_obstack);\n-  vrp_value_range_pool.release ();\n+/* evrp_dom_walker visits the basic blocks in the dominance order and set\n+   the Value Ranges (VR) for SSA_NAMEs in the scope.  Use this VR to\n+   discover more VRs.  */\n \n-  /* So that we can distinguish between VRP data being available\n-     and not available.  */\n-  vr_value = NULL;\n-  vr_phi_edge_counts = NULL;\n+class evrp_dom_walker : public dom_walker\n+{\n+public:\n+  evrp_dom_walker ()\n+    : dom_walker (CDI_DOMINATORS), stack (10)\n+    {\n+      stmts_to_fixup.create (0);\n+      need_eh_cleanup = BITMAP_ALLOC (NULL);\n+    }\n+  ~evrp_dom_walker ()\n+    {\n+      stmts_to_fixup.release ();\n+      BITMAP_FREE (need_eh_cleanup);\n+    }\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+  void push_value_range (const_tree var, value_range *vr);\n+  value_range *pop_value_range (const_tree var);\n+\n+  /* Cond_stack holds the old VR.  */\n+  auto_vec<std::pair <const_tree, value_range*> > stack;\n+  bitmap need_eh_cleanup;\n+  vec<gimple *> stmts_to_fixup;\n+};\n+\n+/* See if there is any new scope is entered with new VR and set that VR to\n+   ssa_name before visiting the statements in the scope.  */\n+\n+edge\n+evrp_dom_walker::before_dom_children (basic_block bb)\n+{\n+  value_range *new_vr = NULL;\n+  tree op0 = NULL_TREE;\n+\n+  push_value_range (NULL_TREE, NULL);\n+  if (single_pred_p (bb))\n+    {\n+      edge e = single_pred_edge (bb);\n+      value_range vr = VR_INITIALIZER;\n+      gimple *stmt = last_stmt (e->src);\n+      if (stmt\n+\t  && gimple_code (stmt) == GIMPLE_COND\n+\t  && (op0 = gimple_cond_lhs (stmt))\n+\t  && TREE_CODE (op0) == SSA_NAME\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt))))\n+\t{\n+\t  /* Entering a new scope.  Try to see if we can find a VR\n+\t     here.  */\n+\t  tree op1 = gimple_cond_rhs (stmt);\n+\t  tree_code code = gimple_cond_code (stmt);\n+\t  value_range *old_vr = get_value_range (op0);\n+\n+\t  if (TREE_OVERFLOW_P (op1))\n+\t    op1 = drop_tree_overflow (op1);\n+\n+\t  /* If condition is false, invert the cond.  */\n+\t  if (e->flags & EDGE_FALSE_VALUE)\n+\t    code = invert_tree_comparison (gimple_cond_code (stmt),\n+\t\t\t\t\t   HONOR_NANS (op0));\n+\t  /* Discover VR when condition is true.  */\n+\t  extract_range_for_var_from_comparison_expr (op0, code, op0, op1, &vr);\n+\t  if (old_vr->type == VR_RANGE || old_vr->type == VR_ANTI_RANGE)\n+\t    vrp_intersect_ranges (&vr, old_vr);\n+\n+\t  /* If we found any usable VR, set the VR to ssa_name and create a\n+\t     PUSH old value in the stack with the old VR.  */\n+\t  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+\t    {\n+\t      new_vr = vrp_value_range_pool.allocate ();\n+\t      *new_vr = vr;\n+\t      push_value_range (op0, new_vr);\n+\t    }\n+\t}\n+    }\n+\n+  /* Visit PHI stmts and discover any new VRs possible.  */\n+  gimple_stmt_iterator gsi;\n+  edge e;\n+  edge_iterator ei;\n+  bool has_unvisived_preds = false;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (!(e->src->flags & BB_VISITED))\n+      {\n+\thas_unvisived_preds = true;\n+\tbreak;\n+      }\n+\n+  for (gphi_iterator gpi = gsi_start_phis (bb);\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n+    {\n+      gphi *phi = gpi.phi ();\n+      tree lhs = PHI_RESULT (phi);\n+      value_range vr_result = VR_INITIALIZER;\n+      if (!has_unvisived_preds\n+\t  && stmt_interesting_for_vrp (phi))\n+\textract_range_from_phi_node (phi, &vr_result);\n+      else\n+\tset_value_range_to_varying (&vr_result);\n+      update_value_range (lhs, &vr_result);\n+    }\n+\n+  /* Visit all other stmts and discover any new VRs possible.  */\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      edge taken_edge;\n+      tree output = NULL_TREE;\n+      gimple *old_stmt = stmt;\n+      bool was_noreturn = (is_gimple_call (stmt)\n+\t\t\t   && gimple_call_noreturn_p (stmt));\n+\n+      /* TODO, if found taken_edge, we should visit (return it) and travel\n+\t again to improve VR as done in DOM/SCCVN optimizations.  It should\n+\t be done carefully as stmts might prematurely leave a BB like\n+\t in EH.  */\n+      if (stmt_interesting_for_vrp (stmt))\n+\t{\n+\t  value_range vr = VR_INITIALIZER;\n+\t  extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n+\t  if (output\n+\t      && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n+\t    update_value_range (output, &vr);\n+\t  else\n+\t    {\n+\t      tree def;\n+\t      ssa_op_iter iter;\n+\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+\t\tset_value_range_to_varying (get_value_range (def));\n+\t    }\n+\n+\t  /* Try folding stmts with the VR discovered.  */\n+\t  bool did_replace\n+\t    = replace_uses_in (stmt,\n+\t\t\t       op_with_constant_singleton_value_range);\n+\t  if (fold_stmt (&gsi, follow_single_use_edges)\n+\t      || did_replace)\n+\t    update_stmt (gsi_stmt (gsi));\n+\n+\t  if (did_replace)\n+\t    {\n+\t      /* If we cleaned up EH information from the statement,\n+\t\t remove EH edges.  */\n+\t      if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n+\t\tbitmap_set_bit (need_eh_cleanup, bb->index);\n+\n+\t      /* If we turned a not noreturn call into a noreturn one\n+\t\t schedule it for fixup.  */\n+\t      if (!was_noreturn\n+\t\t  && is_gimple_call (stmt)\n+\t\t  && gimple_call_noreturn_p (stmt))\n+\t\tstmts_to_fixup.safe_push (stmt);\n+\n+\t      if (gimple_assign_single_p (stmt))\n+\t\t{\n+\t\t  tree rhs = gimple_assign_rhs1 (stmt);\n+\t\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t\t    recompute_tree_invariant_for_addr_expr (rhs);\n+\t\t}\n+\t    }\n+\n+\t  def_operand_p def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);\n+\t  /* Set the SSA with the value range.  */\n+\t  if (def_p\n+\t      && TREE_CODE (DEF_FROM_PTR (def_p)) == SSA_NAME\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (DEF_FROM_PTR (def_p))))\n+\t    {\n+\t      tree def = DEF_FROM_PTR (def_p);\n+\t      value_range *vr = get_value_range (def);\n+\n+\t      if ((vr->type == VR_RANGE\n+\t\t   || vr->type == VR_ANTI_RANGE)\n+\t\t  && (TREE_CODE (vr->min) == INTEGER_CST)\n+\t\t  && (TREE_CODE (vr->max) == INTEGER_CST))\n+\t\tset_range_info (def, vr->type, vr->min, vr->max);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree def;\n+\t  ssa_op_iter iter;\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+\t    set_value_range_to_varying (get_value_range (def));\n+\t}\n+    }\n+  bb->flags |= BB_VISITED;\n+  return NULL;\n+}\n+\n+/* Restore/pop VRs valid only for BB when we leave BB.  */\n+\n+void\n+evrp_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  gcc_checking_assert (!stack.is_empty ());\n+  while (stack.last ().first != NULL_TREE)\n+    pop_value_range (stack.last ().first);\n+  pop_value_range (stack.last ().first);\n+}\n+\n+/* Push the Value Range of VAR to the stack and update it with new VR.  */\n+\n+void\n+evrp_dom_walker::push_value_range (const_tree var, value_range *vr)\n+{\n+  if (vr != NULL)\n+    {\n+      unsigned ver = SSA_NAME_VERSION (var);\n+      gcc_checking_assert (vr_value);\n+      stack.safe_push (std::make_pair (var, vr_value[ver]));\n+\n+      if (ver < num_vr_values)\n+\tvr_value[ver] = vr;\n+    }\n+  else\n+    stack.safe_push (std::make_pair (var, vr));\n+}\n+\n+/* Pop the Value Range from the vrp_stack and update VAR with it.  */\n+\n+value_range *\n+evrp_dom_walker::pop_value_range (const_tree var)\n+{\n+  value_range *vr = stack.last ().second;\n+  if (vr != NULL)\n+    {\n+      unsigned ver = SSA_NAME_VERSION (var);\n+      gcc_checking_assert (var == stack.last ().first);\n+      gcc_checking_assert (vr_value);\n+\n+      if (ver < num_vr_values)\n+\tvr_value[ver] = vr;\n+    }\n+  stack.pop ();\n+  return vr;\n+}\n+\n+\n+/* Main entry point for the early vrp pass which is a simplified non-iterative\n+   version of vrp where basic blocks are visited in dominance order.  Value\n+   ranges discovered in early vrp will also be used by ipa-vrp.  */\n+\n+static unsigned int\n+execute_early_vrp ()\n+{\n+  edge e;\n+  edge_iterator ei;\n+  basic_block bb;\n+\n+  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+  scev_initialize ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bb->flags &= ~BB_VISITED;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\te->flags |= EDGE_EXECUTABLE;\n+    }\n+  vrp_initialize_lattice ();\n+\n+  /* Walk stmts in dominance order and propagate VRP.  */\n+  evrp_dom_walker walker;\n+  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+  if (!bitmap_empty_p (walker.need_eh_cleanup))\n+    gimple_purge_all_dead_eh_edges (walker.need_eh_cleanup);\n+\n+  /* Fixup stmts that became noreturn calls.  This may require splitting\n+     blocks and thus isn't possible during the dominator walk.  Do this\n+     in reverse order so we don't inadvertedly remove a stmt we want to\n+     fixup by visiting a dominating now noreturn call first.  */\n+  while (!walker.stmts_to_fixup.is_empty ())\n+    {\n+      gimple *stmt = walker.stmts_to_fixup.pop ();\n+      fixup_noreturn_call (stmt);\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n+      dump_all_value_ranges (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  vrp_free_lattice ();\n+  scev_finalize ();\n+  loop_optimizer_finalize ();\n+  FOR_EACH_BB_FN (bb, cfun)\n+    bb->flags &= ~BB_VISITED;\n+  return 0;\n }\n \n \n@@ -10633,9 +10951,11 @@ execute_vrp (bool warn_array_bounds_p)\n   /* For visiting PHI nodes we need EDGE_DFS_BACK computed.  */\n   mark_dfs_back_edges ();\n \n+  vrp_initialize_lattice ();\n   vrp_initialize ();\n   ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);\n   vrp_finalize (warn_array_bounds_p);\n+  vrp_free_lattice ();\n \n   free_numbers_of_iterations_estimates (cfun);\n \n@@ -10733,3 +11053,44 @@ make_pass_vrp (gcc::context *ctxt)\n {\n   return new pass_vrp (ctxt);\n }\n+\n+namespace {\n+\n+const pass_data pass_data_early_vrp =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"evrp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_EARLY_VRP, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_update_ssa | TODO_verify_all ),\n+};\n+\n+class pass_early_vrp : public gimple_opt_pass\n+{\n+public:\n+  pass_early_vrp (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_early_vrp, ctxt)\n+    {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_early_vrp (m_ctxt); }\n+  virtual bool gate (function *)\n+    {\n+      return flag_tree_vrp != 0;\n+    }\n+  virtual unsigned int execute (function *)\n+    { return execute_early_vrp (); }\n+\n+}; // class pass_vrp\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_early_vrp (gcc::context *ctxt)\n+{\n+  return new pass_early_vrp (ctxt);\n+}\n+"}]}