{"sha": "10e168cdbe4fc6ca1d42b0d56936602feb2ef38b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlMTY4Y2RiZTRmYzZjYTFkNDJiMGQ1NjkzNjYwMmZlYjJlZjM4Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-01-08T23:04:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-03T10:01:34Z"}, "message": "[Ada] Get rid of more references to Universal_Integer in expanded code\n\n2020-06-03  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference) <Enum_Rep>:\n\tIn the case of an enumeration type, do an intermediate\n\tconversion to a small integer type.  Remove useless stuff.\n\t<Finalization_Size>: Do not hardcode Universal_Integer and\n\tfix a type mismatch in the assignment to the variable.\n\t<Max_Size_In_Storage_Elements>: Likewise.\n\t<From_Any>: Do not redefine the Ptyp local variable.\n\t<To_Any>: Likewise.\n\t<TypeCode>: Likewise.\n\t<Pos>: Small tweaks.\n\t<Val>: For an enumeration type with standard representation,\n\tapply the range check to the expression of a convertion to\n\tUniversal_Integer, if any.  For an integer type, expand to\n\ta mere conversion.", "tree": {"sha": "79e61cffd7f488c9e9101e25452b2713fdb596b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79e61cffd7f488c9e9101e25452b2713fdb596b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e168cdbe4fc6ca1d42b0d56936602feb2ef38b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e168cdbe4fc6ca1d42b0d56936602feb2ef38b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e168cdbe4fc6ca1d42b0d56936602feb2ef38b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e168cdbe4fc6ca1d42b0d56936602feb2ef38b/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eebcb5618002bcd30219203ce4c59b0ef809f236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eebcb5618002bcd30219203ce4c59b0ef809f236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eebcb5618002bcd30219203ce4c59b0ef809f236"}], "stats": {"total": 208, "additions": 128, "deletions": 80}, "files": [{"sha": "6c59ae0df50b44a5480b2d5f9a0763cc2a7427af", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 128, "deletions": 80, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e168cdbe4fc6ca1d42b0d56936602feb2ef38b/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e168cdbe4fc6ca1d42b0d56936602feb2ef38b/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=10e168cdbe4fc6ca1d42b0d56936602feb2ef38b", "patch": "@@ -2817,7 +2817,7 @@ package body Exp_Attr is\n          --  If the prefix is an access to object, the attribute applies to\n          --  the designated object, so rewrite with an explicit dereference.\n \n-         elsif Is_Access_Type (Etype (Pref))\n+         elsif Is_Access_Type (Ptyp)\n            and then\n              (not Is_Entity_Name (Pref) or else Is_Object (Entity (Pref)))\n          then\n@@ -3133,6 +3133,8 @@ package body Exp_Attr is\n \n       when Attribute_Enum_Rep => Enum_Rep : declare\n          Expr : Node_Id;\n+         Ityp : Entity_Id;\n+         Psiz : Uint;\n \n       begin\n          --  Get the expression, which is X for Enum_Type'Enum_Rep (X) or\n@@ -3180,11 +3182,34 @@ package body Exp_Attr is\n          --  make sure that the analyzer does not complain about what otherwise\n          --  might be an illegal conversion.\n \n+         --  However the target type is universal integer in most cases, which\n+         --  is a very large type, so in the case of an enumeration type, we\n+         --  first convert to a small signed integer type in order not to lose\n+         --  the size information.\n+\n+         elsif Is_Enumeration_Type (Ptyp) then\n+            Psiz := RM_Size (Base_Type (Ptyp));\n+\n+            if Psiz < 8 then\n+               Ityp := Standard_Integer_8;\n+\n+            elsif Psiz < 16 then\n+               Ityp := Standard_Integer_16;\n+\n+            elsif Psiz < 32 then\n+               Ityp := Standard_Integer_32;\n+\n+            else\n+               Ityp := Standard_Integer_64;\n+            end if;\n+\n+            Rewrite (N, OK_Convert_To (Ityp, Expr));\n+            Convert_To_And_Rewrite (Typ, N);\n+\n          else\n-            Rewrite (N, OK_Convert_To (Typ, Relocate_Node (Expr)));\n+            Rewrite (N, OK_Convert_To (Typ, Expr));\n          end if;\n \n-         Set_Etype (N, Typ);\n          Analyze_And_Resolve (N, Typ);\n       end Enum_Rep;\n \n@@ -3275,11 +3300,10 @@ package body Exp_Attr is\n          function Calculate_Header_Size return Node_Id is\n          begin\n             --  Generate:\n-            --    Universal_Integer\n-            --      (Header_Size_With_Padding (Pref'Alignment))\n+            --    Typ (Header_Size_With_Padding (Pref'Alignment))\n \n             return\n-              Convert_To (Universal_Integer,\n+              Convert_To (Typ,\n                 Make_Function_Call (Loc,\n                   Name                   =>\n                     New_Occurrence_Of (RTE (RE_Header_Size_With_Padding), Loc),\n@@ -3307,9 +3331,7 @@ package body Exp_Attr is\n          --    Size : Integer := 0;\n          --\n          --    if Needs_Finalization (Pref'Tag) then\n-         --       Size :=\n-         --         Universal_Integer\n-         --           (Header_Size_With_Padding (Pref'Alignment));\n+         --       Size := Integer (Header_Size_With_Padding (Pref'Alignment));\n          --    end if;\n          --\n          --  and the attribute reference is replaced with a reference to Size.\n@@ -3331,8 +3353,7 @@ package body Exp_Attr is\n               --  Generate:\n               --    if Needs_Finalization (Pref'Tag) then\n               --       Size :=\n-              --         Universal_Integer\n-              --           (Header_Size_With_Padding (Pref'Alignment));\n+              --         Integer (Header_Size_With_Padding (Pref'Alignment));\n               --    end if;\n \n               Make_If_Statement (Loc,\n@@ -3349,7 +3370,9 @@ package body Exp_Attr is\n                 Then_Statements        => New_List (\n                    Make_Assignment_Statement (Loc,\n                      Name       => New_Occurrence_Of (Size, Loc),\n-                     Expression => Calculate_Header_Size)))));\n+                     Expression =>\n+                       Convert_To\n+                         (Standard_Integer, Calculate_Header_Size))))));\n \n             Rewrite (N, New_Occurrence_Of (Size, Loc));\n \n@@ -3556,16 +3579,15 @@ package body Exp_Attr is\n       --------------\n \n       when Attribute_From_Any => From_Any : declare\n-         P_Type : constant Entity_Id := Etype (Pref);\n          Decls  : constant List_Id   := New_List;\n \n       begin\n          Rewrite (N,\n-           Build_From_Any_Call (P_Type,\n+           Build_From_Any_Call (Ptyp,\n              Relocate_Node (First (Exprs)),\n              Decls));\n          Insert_Actions (N, Decls);\n-         Analyze_And_Resolve (N, P_Type);\n+         Analyze_And_Resolve (N, Ptyp);\n       end From_Any;\n \n       ----------------------\n@@ -4417,6 +4439,7 @@ package body Exp_Attr is\n       when Attribute_Max_Size_In_Storage_Elements => declare\n          Typ  : constant Entity_Id := Etype (N);\n          Attr : Node_Id;\n+         Atyp : Entity_Id;\n \n          Conversion_Added : Boolean := False;\n          --  A flag which tracks whether the original attribute has been\n@@ -4457,16 +4480,17 @@ package body Exp_Attr is\n          then\n             Set_Header_Size_Added (Attr);\n \n+            Atyp := Etype (Attr);\n+\n             --  Generate:\n             --    P'Max_Size_In_Storage_Elements +\n-            --      Universal_Integer\n-            --        (Header_Size_With_Padding (Ptyp'Alignment))\n+            --      Atyp (Header_Size_With_Padding (Ptyp'Alignment))\n \n             Rewrite (Attr,\n               Make_Op_Add (Loc,\n                 Left_Opnd  => Relocate_Node (Attr),\n                 Right_Opnd =>\n-                  Convert_To (Universal_Integer,\n+                  Convert_To (Atyp,\n                     Make_Function_Call (Loc,\n                       Name                   =>\n                         New_Occurrence_Of\n@@ -4478,16 +4502,14 @@ package body Exp_Attr is\n                             New_Occurrence_Of (Ptyp, Loc),\n                           Attribute_Name => Name_Alignment))))));\n \n+            Analyze_And_Resolve (Attr, Atyp);\n+\n             --  Add a conversion to the target type\n \n             if not Conversion_Added then\n-               Rewrite (Attr,\n-                 Make_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n-                   Expression   => Relocate_Node (Attr)));\n+               Convert_To_And_Rewrite (Typ, Attr);\n             end if;\n \n-            Analyze (Attr);\n             return;\n          end if;\n       end;\n@@ -5097,24 +5119,24 @@ package body Exp_Attr is\n       -- Pos --\n       ---------\n \n-      --  For enumeration types with a standard representation, Pos is\n-      --  handled by the back end.\n+      --  For enumeration types with a standard representation, Pos is handled\n+      --  by the back end.\n \n       --  For enumeration types, with a non-standard representation we generate\n       --  a call to the _Rep_To_Pos function created when the type was frozen.\n-      --  The call has the form\n+      --  The call has the form:\n \n       --    _rep_to_pos (expr, flag)\n \n       --  The parameter flag is True if range checks are enabled, causing\n       --  Program_Error to be raised if the expression has an invalid\n       --  representation, and False if range checks are suppressed.\n \n-      --  For integer types, Pos is equivalent to a simple integer\n-      --  conversion and we rewrite it as such\n+      --  For integer types, Pos is equivalent to a simple integer conversion\n+      --  and we rewrite it as such.\n \n       when Attribute_Pos => Pos : declare\n-         Etyp : Entity_Id := Base_Type (Entity (Pref));\n+         Etyp : Entity_Id := Base_Type (Ptyp);\n \n       begin\n          --  Deal with zero/non-zero boolean values\n@@ -6420,13 +6442,12 @@ package body Exp_Attr is\n       ------------\n \n       when Attribute_To_Any => To_Any : declare\n-         P_Type : constant Entity_Id := Etype (Pref);\n          Decls  : constant List_Id   := New_List;\n       begin\n          Rewrite (N,\n            Build_To_Any_Call\n              (Loc,\n-              Convert_To (P_Type,\n+              Convert_To (Ptyp,\n               Relocate_Node (First (Exprs))), Decls));\n          Insert_Actions (N, Decls);\n          Analyze_And_Resolve (N, RTE (RE_Any));\n@@ -6450,10 +6471,9 @@ package body Exp_Attr is\n       --------------\n \n       when Attribute_TypeCode => TypeCode : declare\n-         P_Type : constant Entity_Id := Etype (Pref);\n          Decls  : constant List_Id   := New_List;\n       begin\n-         Rewrite (N, Build_TypeCode_Call (Loc, P_Type, Decls));\n+         Rewrite (N, Build_TypeCode_Call (Loc, Ptyp, Decls));\n          Insert_Actions (N, Decls);\n          Analyze_And_Resolve (N, RTE (RE_TypeCode));\n       end TypeCode;\n@@ -6489,63 +6509,91 @@ package body Exp_Attr is\n       -- Val --\n       ---------\n \n-      --  For enumeration types with a standard representation, and for all\n-      --  other types, Val is handled by the back end. For enumeration types\n-      --  with a non-standard representation we use the _Pos_To_Rep array that\n-      --  was created when the type was frozen.\n+      --  For enumeration types with a standard representation, Val is handled\n+      --  by the back end.\n+\n+      --  For enumeration types with a non-standard representation we use the\n+      --  _Pos_To_Rep array that was created when the type was frozen, unless\n+      --  the representation is contiguous in which case we use an addition.\n+\n+      --  For integer types, Val is equivalent to a simple integer conversion\n+      --  and we rewrite it as such.\n \n       when Attribute_Val => Val : declare\n-         Etyp : constant Entity_Id := Base_Type (Entity (Pref));\n+         Etyp : constant Entity_Id := Base_Type (Ptyp);\n+         Expr : constant Node_Id := First (Exprs);\n \n       begin\n-         if Is_Enumeration_Type (Etyp)\n-           and then Present (Enum_Pos_To_Rep (Etyp))\n-         then\n-            if Has_Contiguous_Rep (Etyp) then\n-               declare\n-                  Rep_Node : constant Node_Id :=\n-                    Unchecked_Convert_To (Etyp,\n-                       Make_Op_Add (Loc,\n-                         Left_Opnd =>\n-                            Make_Integer_Literal (Loc,\n-                              Enumeration_Rep (First_Literal (Etyp))),\n-                         Right_Opnd =>\n-                          (Convert_To (Standard_Integer,\n-                             Relocate_Node (First (Exprs))))));\n+         --  Case of enumeration type\n \n-               begin\n+         if Is_Enumeration_Type (Etyp) then\n+\n+            --  Non-standard enumeration type\n+\n+            if Present (Enum_Pos_To_Rep (Etyp)) then\n+               if Has_Contiguous_Rep (Etyp) then\n+                  declare\n+                     Rep_Node : constant Node_Id :=\n+                       Unchecked_Convert_To (Etyp,\n+                          Make_Op_Add (Loc,\n+                            Left_Opnd =>\n+                              Make_Integer_Literal (Loc,\n+                                Enumeration_Rep (First_Literal (Etyp))),\n+                            Right_Opnd =>\n+                               Convert_To (Standard_Integer, Expr)));\n+\n+                  begin\n+                     Rewrite (N,\n+                        Unchecked_Convert_To (Etyp,\n+                            Make_Op_Add (Loc,\n+                              Left_Opnd =>\n+                                Make_Integer_Literal (Loc,\n+                                  Enumeration_Rep (First_Literal (Etyp))),\n+                              Right_Opnd =>\n+                                Make_Function_Call (Loc,\n+                                  Name =>\n+                                    New_Occurrence_Of\n+                                      (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n+                                  Parameter_Associations => New_List (\n+                                    Rep_Node,\n+                                    Rep_To_Pos_Flag (Etyp, Loc))))));\n+                  end;\n+\n+               else\n                   Rewrite (N,\n-                     Unchecked_Convert_To (Etyp,\n-                         Make_Op_Add (Loc,\n-                           Left_Opnd =>\n-                             Make_Integer_Literal (Loc,\n-                               Enumeration_Rep (First_Literal (Etyp))),\n-                           Right_Opnd =>\n-                             Make_Function_Call (Loc,\n-                               Name =>\n-                                 New_Occurrence_Of\n-                                   (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n-                               Parameter_Associations => New_List (\n-                                 Rep_Node,\n-                                 Rep_To_Pos_Flag (Etyp, Loc))))));\n-               end;\n+                    Make_Indexed_Component (Loc,\n+                      Prefix =>\n+                        New_Occurrence_Of (Enum_Pos_To_Rep (Etyp), Loc),\n+                      Expressions => New_List (\n+                        Convert_To (Standard_Integer, Expr))));\n+               end if;\n \n-            else\n-               Rewrite (N,\n-                 Make_Indexed_Component (Loc,\n-                   Prefix => New_Occurrence_Of (Enum_Pos_To_Rep (Etyp), Loc),\n-                   Expressions => New_List (\n-                     Convert_To (Standard_Integer,\n-                       Relocate_Node (First (Exprs))))));\n-            end if;\n+               Analyze_And_Resolve (N, Typ);\n \n-            Analyze_And_Resolve (N, Typ);\n+            --  Standard enumeration type\n+\n+            --  If the argument is marked as requiring a range check then\n+            --  generate it here, after looking through a conversion to\n+            --  universal integer, if any.\n+\n+            elsif Do_Range_Check (Expr) then\n+               if Nkind (Expr) = N_Type_Conversion\n+                  and then Entity (Subtype_Mark (Expr)) = Universal_Integer\n+               then\n+                  Generate_Range_Check\n+                    (Expression (Expr), Etyp, CE_Range_Check_Failed);\n+                  Set_Do_Range_Check (Expr, False);\n \n-         --  If the argument is marked as requiring a range check then generate\n-         --  it here.\n+               else\n+                  Generate_Range_Check (Expr, Etyp, CE_Range_Check_Failed);\n+               end if;\n+            end if;\n \n-         elsif Do_Range_Check (First (Exprs)) then\n-            Generate_Range_Check (First (Exprs), Etyp, CE_Range_Check_Failed);\n+         --  Deal with integer types\n+\n+         elsif Is_Integer_Type (Etyp) then\n+            Rewrite (N, Convert_To (Typ, Expr));\n+            Analyze_And_Resolve (N, Typ);\n          end if;\n       end Val;\n "}]}