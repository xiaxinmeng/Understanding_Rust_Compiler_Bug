{"sha": "ff97910daf84acf7f3073b6b53660efcad9e6480", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5NzkxMGRhZjg0YWNmN2YzMDczYjZiNTM2NjBlZmNhZDllNjQ4MA==", "commit": {"author": {"name": "Vladimir Yakovlev", "email": "vladimir.b.yakovlev@intel.com", "date": "2012-11-06T10:29:23Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2012-11-06T10:29:23Z"}, "message": "i386-protos.h (emit_i387_cw_initialization): Deleted.\n\n        * config/i386/i386-protos.h (emit_i387_cw_initialization): Deleted.\n        (emit_vzero): Added prototype.\n        (ix86_mode_entry): Likewise.\n        (ix86_mode_exit): Likewise.\n        (ix86_emit_mode_set): Likewise.\n\n        * config/i386/i386.c (typedef struct block_info_def): Deleted.\n        (define BLOCK_INFO): Deleted.\n        (check_avx256_stores): Added checking for MEM_P.\n        (move_or_delete_vzeroupper_2): Deleted.\n        (move_or_delete_vzeroupper_1): Deleted.\n        (move_or_delete_vzeroupper): Deleted.\n        (ix86_maybe_emit_epilogue_vzeroupper): Deleted.\n        (function_pass_avx256_p): Deleted.\n        (ix86_function_ok_for_sibcall): Deleted disabling sibcall.\n        (nit_cumulative_args): Deleted initialization of of avx256 fields of\n        cfun->machine.\n        (ix86_emit_restore_sse_regs_using_mov): Deleted vzeroupper generation.\n        (ix86_expand_epilogue): Likewise.\n        (ix86_avx_u128_mode_needed): New.\n        (ix86_i387_mode_needed): Renamed ix86_mode_needed.\n        (ix86_mode_needed): New.\n        (ix86_avx_u128_mode_after): New.\n        (ix86_mode_after): New.\n        (ix86_avx_u128_mode_entry): New.\n        (ix86_mode_entry): New.\n        (ix86_avx_u128_mode_exit): New.\n        (ix86_mode_exit): New.\n        (ix86_emit_mode_set): New.\n        (ix86_expand_call): Deleted vzeroupper generation.\n        (ix86_split_call_vzeroupper): Deleted.\n        (ix86_init_machine_status): Initialzed optimize_mode_switching.\n        (ix86_expand_special_args_builtin): Changed.\n        (ix86_reorg): Deleted a call of move_or_delete_vzeroupper.\n\n        * config/i386/i386.h  (VALID_AVX256_REG_OR_OI_MODE): New.\n        (AVX_U128): New.\n        (avx_u128_state): New.\n        (NUM_MODES_FOR_MODE_SWITCHING): Added AVX_U128_ANY.\n        (MODE_AFTER): New.\n        (MODE_ENTRY): New.\n        (MODE_EXIT): New.\n        (EMIT_MODE_SET): Changed.\n        (machine_function): Deleted avx256 fields.\n\n        * config/i386/i386.md (UNSPEC_CALL_NEEDS_VZEROUPPER): Deleted.\n        (define_insn_and_split \"*call_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*call_rex64_ms_sysv_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*sibcall_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*call_pop_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*sibcall_pop_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*call_value_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*sibcall_value_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*call_value_rex64_ms_sysv_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*call_value_pop_vzeroupper\"): Deleted.\n        (define_insn_and_split \"*sibcall_value_pop_vzeroupper\"): Deleted.\n        (define_expand \"return\"): Deleted vzeroupper emitting.\n        (define_expand \"simple_return\"): Deleted.\n\n        * config/i386/predicates.md (vzeroupper_operation): New.\n\n        * config/i386/sse.md (avx_vzeroupper): Changed.\n\ntestsuite/ChangeLog:\n        * gcc.target/i386/avx-vzeroupper-5.c: Changed scan-assembler-times.\n        * gcc.target/i386/avx-vzeroupper-8.c: Likewise.\n        * gcc.target/i386/avx-vzeroupper-9.c: Likewise.\n        * gcc.target/i386/avx-vzeroupper-10.c: Likewise.\n        * gcc.target/i386/avx-vzeroupper-11.c: Likewise.\n        * gcc.target/i386/avx-vzeroupper-12.c: Likewise.\n        * gcc.target/i386/avx-vzeroupper-19.c: Likewis.\n        * gcc.target/i386/avx-vzeroupper-27.c: New.\n\nFrom-SVN: r193229", "tree": {"sha": "b652d03ac389bf17b8b0af12fa20b9e53713e080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b652d03ac389bf17b8b0af12fa20b9e53713e080"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff97910daf84acf7f3073b6b53660efcad9e6480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff97910daf84acf7f3073b6b53660efcad9e6480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff97910daf84acf7f3073b6b53660efcad9e6480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff97910daf84acf7f3073b6b53660efcad9e6480/comments", "author": null, "committer": null, "parents": [{"sha": "3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6db7f84dd4dd52ebc9436b462f599d9fb0564b"}], "stats": {"total": 1130, "additions": 382, "deletions": 748}, "files": [{"sha": "255ce39045269e6a18aeada3040e8aa77c1a13d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -1,3 +1,68 @@\n+2012-11-06  Vladimir Yakovlev  <vladimir.b.yakovlev@intel.com>\n+\n+\t* config/i386/i386-protos.h (emit_i387_cw_initialization): Deleted.\n+\t(emit_vzero): Added prototype.\n+\t(ix86_mode_entry): Likewise.\n+\t(ix86_mode_exit): Likewise.\n+\t(ix86_emit_mode_set): Likewise.\n+\n+\t* config/i386/i386.c (typedef struct block_info_def): Deleted.\n+\t(define BLOCK_INFO): Deleted.\n+\t(check_avx256_stores): Added checking for MEM_P.\n+\t(move_or_delete_vzeroupper_2): Deleted.\n+\t(move_or_delete_vzeroupper_1): Deleted.\n+\t(move_or_delete_vzeroupper): Deleted.\n+\t(ix86_maybe_emit_epilogue_vzeroupper): Deleted.\n+\t(function_pass_avx256_p): Deleted.\n+\t(ix86_function_ok_for_sibcall): Deleted disabling sibcall.\n+\t(nit_cumulative_args): Deleted initialization of of avx256 fields of\n+\tcfun->machine.\n+\t(ix86_emit_restore_sse_regs_using_mov): Deleted vzeroupper generation.\n+\t(ix86_expand_epilogue): Likewise.\n+\t(ix86_avx_u128_mode_needed): New.\n+\t(ix86_i387_mode_needed): Renamed ix86_mode_needed.\n+\t(ix86_mode_needed): New.\n+\t(ix86_avx_u128_mode_after): New.\n+\t(ix86_mode_after): New.\n+\t(ix86_avx_u128_mode_entry): New.\n+\t(ix86_mode_entry): New.\n+\t(ix86_avx_u128_mode_exit): New.\n+\t(ix86_mode_exit): New.\n+\t(ix86_emit_mode_set): New.\n+\t(ix86_expand_call): Deleted vzeroupper generation.\n+\t(ix86_split_call_vzeroupper): Deleted.\n+\t(ix86_init_machine_status): Initialzed optimize_mode_switching.\n+\t(ix86_expand_special_args_builtin): Changed.\n+\t(ix86_reorg): Deleted a call of move_or_delete_vzeroupper.\n+\n+\t* config/i386/i386.h  (VALID_AVX256_REG_OR_OI_MODE): New.\n+\t(AVX_U128): New.\n+\t(avx_u128_state): New.\n+\t(NUM_MODES_FOR_MODE_SWITCHING): Added AVX_U128_ANY.\n+\t(MODE_AFTER): New.\n+\t(MODE_ENTRY): New.\n+\t(MODE_EXIT): New.\n+\t(EMIT_MODE_SET): Changed.\n+\t(machine_function): Deleted avx256 fields.\n+\n+\t* config/i386/i386.md (UNSPEC_CALL_NEEDS_VZEROUPPER): Deleted.\n+\t(define_insn_and_split \"*call_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*call_rex64_ms_sysv_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*sibcall_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*call_pop_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*sibcall_pop_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*call_value_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*sibcall_value_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*call_value_rex64_ms_sysv_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*call_value_pop_vzeroupper\"): Deleted.\n+\t(define_insn_and_split \"*sibcall_value_pop_vzeroupper\"): Deleted.\n+\t(define_expand \"return\"): Deleted vzeroupper emitting.\n+\t(define_expand \"simple_return\"): Deleted.\n+\n+\t* config/i386/predicates.md (vzeroupper_operation): New.\n+\n+\t* config/i386/sse.md (avx_vzeroupper): Changed.\n+\n 2012-11-06  Uros Bizjak  <ubizjak@gmail.com>\n \t    Kaz Kojima  <kkojima@gcc.gnu.org>\n "}, {"sha": "0d643b139d6863600558e6ffb1e547d4d0beb478", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -167,8 +167,13 @@ extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n \t\t\t\t\t  enum machine_mode, int);\n extern bool ix86_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n+\n extern int ix86_mode_needed (int, rtx);\n-extern void emit_i387_cw_initialization (int);\n+extern int ix86_mode_after (int, int, rtx);\n+extern int ix86_mode_entry (int);\n+extern int ix86_mode_exit (int);\n+extern void ix86_emit_mode_set (int, int);\n+\n extern void x86_order_regs_for_local_alloc (void);\n extern void x86_function_profiler (FILE *, int);\n extern void x86_emit_floatuns (rtx [2]);"}, {"sha": "d747a5a938766f87bcbc66fd4bb97379aed0979b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 225, "deletions": 549, "changes": 774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -72,426 +72,23 @@ enum upper_128bits_state\n   used\n };\n \n-typedef struct block_info_def\n-{\n-  /* State of the upper 128bits of AVX registers at exit.  */\n-  enum upper_128bits_state state;\n-  /* TRUE if state of the upper 128bits of AVX registers is unchanged\n-     in this block.  */\n-  bool unchanged;\n-  /* TRUE if block has been processed.  */\n-  bool processed;\n-  /* TRUE if block has been scanned.  */\n-  bool scanned;\n-  /* Previous state of the upper 128bits of AVX registers at entry.  */\n-  enum upper_128bits_state prev;\n-} *block_info;\n-\n-#define BLOCK_INFO(B)   ((block_info) (B)->aux)\n-\n-enum call_avx256_state\n-{\n-  /* Callee returns 256bit AVX register.  */\n-  callee_return_avx256 = -1,\n-  /* Callee returns and passes 256bit AVX register.  */\n-  callee_return_pass_avx256,\n-  /* Callee passes 256bit AVX register.  */\n-  callee_pass_avx256,\n-  /* Callee doesn't return nor passe 256bit AVX register, or no\n-     256bit AVX register in function return.  */\n-  call_no_avx256,\n-  /* vzeroupper intrinsic.  */\n-  vzeroupper_intrinsic\n-};\n-\n /* Check if a 256bit AVX register is referenced in stores.   */\n \n static void\n check_avx256_stores (rtx dest, const_rtx set, void *data)\n {\n-  if ((REG_P (dest)\n-       && VALID_AVX256_REG_MODE (GET_MODE (dest)))\n+  if (((REG_P (dest) || MEM_P(dest))\n+       && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (dest)))\n       || (GET_CODE (set) == SET\n-\t  && REG_P (SET_SRC (set))\n-\t  && VALID_AVX256_REG_MODE (GET_MODE (SET_SRC (set)))))\n+\t  && (REG_P (SET_SRC (set)) || MEM_P (SET_SRC (set)))\n+\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (SET_SRC (set)))))\n     {\n       enum upper_128bits_state *state\n \t= (enum upper_128bits_state *) data;\n       *state = used;\n     }\n }\n \n-/* Helper function for move_or_delete_vzeroupper_1.  Look for vzeroupper\n-   in basic block BB.  Delete it if upper 128bit AVX registers are\n-   unused.  If it isn't deleted, move it to just before a jump insn.\n-\n-   STATE is state of the upper 128bits of AVX registers at entry.  */\n-\n-static void\n-move_or_delete_vzeroupper_2 (basic_block bb,\n-\t\t\t     enum upper_128bits_state state)\n-{\n-  rtx insn, bb_end;\n-  rtx vzeroupper_insn = NULL_RTX;\n-  rtx pat;\n-  int avx256;\n-  bool unchanged;\n-\n-  if (BLOCK_INFO (bb)->unchanged)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \" [bb %i] unchanged: upper 128bits: %d\\n\",\n-\t\t bb->index, state);\n-\n-      BLOCK_INFO (bb)->state = state;\n-      return;\n-    }\n-\n-  if (BLOCK_INFO (bb)->scanned && BLOCK_INFO (bb)->prev == state)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \" [bb %i] scanned: upper 128bits: %d\\n\",\n-\t\t bb->index, BLOCK_INFO (bb)->state);\n-      return;\n-    }\n-\n-  BLOCK_INFO (bb)->prev = state;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \" [bb %i] entry: upper 128bits: %d\\n\",\n-\t     bb->index, state);\n-\n-  unchanged = true;\n-\n-  /* BB_END changes when it is deleted.  */\n-  bb_end = BB_END (bb);\n-  insn = BB_HEAD (bb);\n-  while (insn != bb_end)\n-    {\n-      insn = NEXT_INSN (insn);\n-\n-      if (!NONDEBUG_INSN_P (insn))\n-\tcontinue;\n-\n-      /* Move vzeroupper before jump/call.  */\n-      if (JUMP_P (insn) || CALL_P (insn))\n-\t{\n-\t  if (!vzeroupper_insn)\n-\t    continue;\n-\n-\t  if (PREV_INSN (insn) != vzeroupper_insn)\n-\t    {\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file, \"Move vzeroupper after:\\n\");\n-\t\t  print_rtl_single (dump_file, PREV_INSN (insn));\n-\t\t  fprintf (dump_file, \"before:\\n\");\n-\t\t  print_rtl_single (dump_file, insn);\n-\t\t}\n-\t      reorder_insns_nobb (vzeroupper_insn, vzeroupper_insn,\n-\t\t\t\t  PREV_INSN (insn));\n-\t    }\n-\t  vzeroupper_insn = NULL_RTX;\n-\t  continue;\n-\t}\n-\n-      pat = PATTERN (insn);\n-\n-      /* Check insn for vzeroupper intrinsic.  */\n-      if (GET_CODE (pat) == UNSPEC_VOLATILE\n-\t  && XINT (pat, 1) == UNSPECV_VZEROUPPER)\n-\t{\n-\t  if (dump_file)\n-\t    {\n-\t      /* Found vzeroupper intrinsic.  */\n-\t      fprintf (dump_file, \"Found vzeroupper:\\n\");\n-\t      print_rtl_single (dump_file, insn);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Check insn for vzeroall intrinsic.  */\n-\t  if (GET_CODE (pat) == PARALLEL\n-\t      && GET_CODE (XVECEXP (pat, 0, 0)) == UNSPEC_VOLATILE\n-\t      && XINT (XVECEXP (pat, 0, 0), 1) == UNSPECV_VZEROALL)\n-\t    {\n-\t      state = unused;\n-\t      unchanged = false;\n-\n-\t      /* Delete pending vzeroupper insertion.  */\n-\t      if (vzeroupper_insn)\n-\t\t{\n-\t\t  delete_insn (vzeroupper_insn);\n-\t\t  vzeroupper_insn = NULL_RTX;\n-\t\t}\n-\t    }\n-\t  else if (state != used)\n-\t    {\n-\t      note_stores (pat, check_avx256_stores, &state);\n-\t      if (state == used)\n-\t\tunchanged = false;\n-\t    }\n-\t  continue;\n-\t}\n-\n-      /* Process vzeroupper intrinsic.  */\n-      avx256 = INTVAL (XVECEXP (pat, 0, 0));\n-\n-      if (state == unused)\n-\t{\n-\t  /* Since the upper 128bits are cleared, callee must not pass\n-\t     256bit AVX register.  We only need to check if callee\n-\t     returns 256bit AVX register.  */\n-\t  if (avx256 == callee_return_avx256)\n-\t    {\n-\t      state = used;\n-\t      unchanged = false;\n-\t    }\n-\n-\t  /* Remove unnecessary vzeroupper since upper 128bits are\n-\t     cleared.  */\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Delete redundant vzeroupper:\\n\");\n-\t      print_rtl_single (dump_file, insn);\n-\t    }\n-\t  delete_insn (insn);\n-\t}\n-      else\n-\t{\n-\t  /* Set state to UNUSED if callee doesn't return 256bit AVX\n-\t     register.  */\n-\t  if (avx256 != callee_return_pass_avx256)\n-\t    state = unused;\n-\n-\t  if (avx256 == callee_return_pass_avx256\n-\t      || avx256 == callee_pass_avx256)\n-\t    {\n-\t      /* Must remove vzeroupper since callee passes in 256bit\n-\t\t AVX register.  */\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file, \"Delete callee pass vzeroupper:\\n\");\n-\t\t  print_rtl_single (dump_file, insn);\n-\t\t}\n-\t      delete_insn (insn);\n-\t    }\n-\t  else\n-\t    {\n-\t      vzeroupper_insn = insn;\n-\t      unchanged = false;\n-\t    }\n-\t}\n-    }\n-\n-  BLOCK_INFO (bb)->state = state;\n-  BLOCK_INFO (bb)->unchanged = unchanged;\n-  BLOCK_INFO (bb)->scanned = true;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \" [bb %i] exit: %s: upper 128bits: %d\\n\",\n-\t     bb->index, unchanged ? \"unchanged\" : \"changed\",\n-\t     state);\n-}\n-\n-/* Helper function for move_or_delete_vzeroupper.  Process vzeroupper\n-   in BLOCK and check its predecessor blocks.  Treat UNKNOWN state\n-   as USED if UNKNOWN_IS_UNUSED is true.  Return TRUE if the exit\n-   state is changed.  */\n-\n-static bool\n-move_or_delete_vzeroupper_1 (basic_block block, bool unknown_is_unused)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  enum upper_128bits_state state, old_state, new_state;\n-  bool seen_unknown;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \" Process [bb %i]: status: %d\\n\",\n-\t     block->index, BLOCK_INFO (block)->processed);\n-\n-  if (BLOCK_INFO (block)->processed)\n-    return false;\n-\n-  state = unused;\n-\n-  /* Check all predecessor edges of this block.  */\n-  seen_unknown = false;\n-  FOR_EACH_EDGE (e, ei, block->preds)\n-    {\n-      if (e->src == block)\n-\tcontinue;\n-      switch (BLOCK_INFO (e->src)->state)\n-\t{\n-\tcase unknown:\n-\t  if (!unknown_is_unused)\n-\t    seen_unknown = true;\n-\tcase unused:\n-\t  break;\n-\tcase used:\n-\t  state = used;\n-\t  goto done;\n-\t}\n-    }\n-\n-  if (seen_unknown)\n-    state = unknown;\n-\n-done:\n-  old_state = BLOCK_INFO (block)->state;\n-  move_or_delete_vzeroupper_2 (block, state);\n-  new_state = BLOCK_INFO (block)->state;\n-\n-  if (state != unknown || new_state == used)\n-    BLOCK_INFO (block)->processed = true;\n-\n-  /* Need to rescan if the upper 128bits of AVX registers are changed\n-     to USED at exit.  */\n-  if (new_state != old_state)\n-    {\n-      if (new_state == used)\n-\tcfun->machine->rescan_vzeroupper_p = 1;\n-      return true;\n-    }\n-  else\n-    return false;\n-}\n-\n-/* Go through the instruction stream looking for vzeroupper.  Delete\n-   it if upper 128bit AVX registers are unused.  If it isn't deleted,\n-   move it to just before a jump insn.  */\n-\n-static void\n-move_or_delete_vzeroupper (void)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  basic_block bb;\n-  fibheap_t worklist, pending, fibheap_swap;\n-  sbitmap visited, in_worklist, in_pending, sbitmap_swap;\n-  int *bb_order;\n-  int *rc_order;\n-  int i;\n-\n-  /* Set up block info for each basic block.  */\n-  alloc_aux_for_blocks (sizeof (struct block_info_def));\n-\n-  /* Process outgoing edges of entry point.  */\n-  if (dump_file)\n-    fprintf (dump_file, \"Process outgoing edges of entry point\\n\");\n-\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    {\n-      move_or_delete_vzeroupper_2 (e->dest,\n-\t\t\t\t   cfun->machine->caller_pass_avx256_p\n-\t\t\t\t   ? used : unused);\n-      BLOCK_INFO (e->dest)->processed = true;\n-    }\n-\n-  /* Compute reverse completion order of depth first search of the CFG\n-     so that the data-flow runs faster.  */\n-  rc_order = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n-  bb_order = XNEWVEC (int, last_basic_block);\n-  pre_and_rev_post_order_compute (NULL, rc_order, false);\n-  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n-    bb_order[rc_order[i]] = i;\n-  free (rc_order);\n-\n-  worklist = fibheap_new ();\n-  pending = fibheap_new ();\n-  visited = sbitmap_alloc (last_basic_block);\n-  in_worklist = sbitmap_alloc (last_basic_block);\n-  in_pending = sbitmap_alloc (last_basic_block);\n-  bitmap_clear (in_worklist);\n-\n-  /* Don't check outgoing edges of entry point.  */\n-  bitmap_ones (in_pending);\n-  FOR_EACH_BB (bb)\n-    if (BLOCK_INFO (bb)->processed)\n-      bitmap_clear_bit (in_pending, bb->index);\n-    else\n-      {\n-\tmove_or_delete_vzeroupper_1 (bb, false);\n-\tfibheap_insert (pending, bb_order[bb->index], bb);\n-      }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Check remaining basic blocks\\n\");\n-\n-  while (!fibheap_empty (pending))\n-    {\n-      fibheap_swap = pending;\n-      pending = worklist;\n-      worklist = fibheap_swap;\n-      sbitmap_swap = in_pending;\n-      in_pending = in_worklist;\n-      in_worklist = sbitmap_swap;\n-\n-      bitmap_clear (visited);\n-\n-      cfun->machine->rescan_vzeroupper_p = 0;\n-\n-      while (!fibheap_empty (worklist))\n-\t{\n-\t  bb = (basic_block) fibheap_extract_min (worklist);\n-\t  bitmap_clear_bit (in_worklist, bb->index);\n-\t  gcc_assert (!bitmap_bit_p (visited, bb->index));\n-\t  if (!bitmap_bit_p (visited, bb->index))\n-\t    {\n-\t      edge_iterator ei;\n-\n-\t      bitmap_set_bit (visited, bb->index);\n-\n-\t      if (move_or_delete_vzeroupper_1 (bb, false))\n-\t\tFOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t  {\n-\t\t    if (e->dest == EXIT_BLOCK_PTR\n-\t\t\t|| BLOCK_INFO (e->dest)->processed)\n-\t\t      continue;\n-\n-\t\t    if (bitmap_bit_p (visited, e->dest->index))\n-\t\t      {\n-\t\t\tif (!bitmap_bit_p (in_pending, e->dest->index))\n-\t\t\t  {\n-\t\t\t    /* Send E->DEST to next round.  */\n-\t\t\t    bitmap_set_bit (in_pending, e->dest->index);\n-\t\t\t    fibheap_insert (pending,\n-\t\t\t\t\t    bb_order[e->dest->index],\n-\t\t\t\t\t    e->dest);\n-\t\t\t  }\n-\t\t      }\n-\t\t    else if (!bitmap_bit_p (in_worklist, e->dest->index))\n-\t\t      {\n-\t\t\t/* Add E->DEST to current round.  */\n-\t\t\tbitmap_set_bit (in_worklist, e->dest->index);\n-\t\t\tfibheap_insert (worklist, bb_order[e->dest->index],\n-\t\t\t\t\te->dest);\n-\t\t      }\n-\t\t  }\n-\t    }\n-\t}\n-\n-      if (!cfun->machine->rescan_vzeroupper_p)\n-\tbreak;\n-    }\n-\n-  free (bb_order);\n-  fibheap_delete (worklist);\n-  fibheap_delete (pending);\n-  sbitmap_free (visited);\n-  sbitmap_free (in_worklist);\n-  sbitmap_free (in_pending);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Process remaining basic blocks\\n\");\n-\n-  FOR_EACH_BB (bb)\n-    move_or_delete_vzeroupper_1 (bb, true);\n-\n-  free_aux_for_blocks ();\n-}\n-\n static rtx legitimize_dllimport_symbol (rtx, bool);\n \n #ifndef CHECK_STACK_LIMIT\n@@ -4125,37 +3722,6 @@ ix86_option_override_internal (bool main_args_p)\n       = build_target_option_node ();\n }\n \n-/* Return TRUE if VAL is passed in register with 256bit AVX modes.  */\n-\n-static bool\n-function_pass_avx256_p (const_rtx val)\n-{\n-  if (!val)\n-    return false;\n-\n-  if (REG_P (val) && VALID_AVX256_REG_MODE (GET_MODE (val)))\n-    return true;\n-\n-  if (GET_CODE (val) == PARALLEL)\n-    {\n-      int i;\n-      rtx r;\n-\n-      for (i = XVECLEN (val, 0) - 1; i >= 0; i--)\n-\t{\n-\t  r = XVECEXP (val, 0, i);\n-\t  if (GET_CODE (r) == EXPR_LIST\n-\t      && XEXP (r, 0)\n-\t      && REG_P (XEXP (r, 0))\n-\t      && (GET_MODE (XEXP (r, 0)) == OImode\n-\t\t  || VALID_AVX256_REG_MODE (GET_MODE (XEXP (r, 0)))))\n-\t    return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* Implement the TARGET_OPTION_OVERRIDE hook.  */\n \n static void\n@@ -5078,15 +4644,6 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n       if (!rtx_equal_p (a, b))\n \treturn false;\n     }\n-  else if (VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))\n-    {\n-      /* Disable sibcall if we need to generate vzeroupper after\n-\t callee returns.  */\n-      if (TARGET_VZEROUPPER\n-\t  && cfun->machine->callee_return_avx256_p\n-\t  && !cfun->machine->caller_return_avx256_p)\n-\treturn false;\n-    }\n   else if (!rtx_equal_p (a, b))\n     return false;\n \n@@ -5866,45 +5423,18 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t\t      int caller)\n {\n   struct cgraph_local_info *i;\n-  tree fnret_type;\n \n   memset (cum, 0, sizeof (*cum));\n \n-  /* Initialize for the current callee.  */\n-  if (caller)\n-    {\n-      cfun->machine->callee_pass_avx256_p = false;\n-      cfun->machine->callee_return_avx256_p = false;\n-    }\n-\n   if (fndecl)\n     {\n       i = cgraph_local_info (fndecl);\n       cum->call_abi = ix86_function_abi (fndecl);\n-      fnret_type = TREE_TYPE (TREE_TYPE (fndecl));\n     }\n   else\n     {\n       i = NULL;\n       cum->call_abi = ix86_function_type_abi (fntype);\n-      if (fntype)\n-\tfnret_type = TREE_TYPE (fntype);\n-      else\n-\tfnret_type = NULL;\n-    }\n-\n-  if (TARGET_VZEROUPPER && fnret_type)\n-    {\n-      rtx fnret_value = ix86_function_value (fnret_type, fntype,\n-\t\t\t\t\t     false);\n-      if (function_pass_avx256_p (fnret_value))\n-\t{\n-\t  /* The return value of this function uses 256bit AVX modes.  */\n-\t  if (caller)\n-\t    cfun->machine->callee_return_avx256_p = true;\n-\t  else\n-\t    cfun->machine->caller_return_avx256_p = true;\n-\t}\n     }\n \n   cum->caller = caller;\n@@ -7197,15 +6727,6 @@ ix86_function_arg (cumulative_args_t cum_v, enum machine_mode omode,\n   else\n     arg = function_arg_32 (cum, mode, omode, type, bytes, words);\n \n-  if (TARGET_VZEROUPPER && function_pass_avx256_p (arg))\n-    {\n-      /* This argument uses 256bit AVX modes.  */\n-      if (cum->caller)\n-\tcfun->machine->callee_pass_avx256_p = true;\n-      else\n-\tcfun->machine->caller_pass_avx256_p = true;\n-    }\n-\n   return arg;\n }\n \n@@ -11044,17 +10565,6 @@ ix86_emit_restore_sse_regs_using_mov (HOST_WIDE_INT cfa_offset,\n       }\n }\n \n-/* Emit vzeroupper if needed.  */\n-\n-void\n-ix86_maybe_emit_epilogue_vzeroupper (void)\n-{\n-  if (TARGET_VZEROUPPER\n-      && !TREE_THIS_VOLATILE (cfun->decl)\n-      && !cfun->machine->caller_return_avx256_p)\n-    emit_insn (gen_avx_vzeroupper (GEN_INT (call_no_avx256)));\n-}\n-\n /* Restore function stack, frame, and registers.  */\n \n void\n@@ -11356,9 +10866,6 @@ ix86_expand_epilogue (int style)\n       return;\n     }\n \n-  /* Emit vzeroupper if needed.  */\n-  ix86_maybe_emit_epilogue_vzeroupper ();\n-\n   if (crtl->args.pops_args && crtl->args.size)\n     {\n       rtx popc = GEN_INT (crtl->args.pops_args);\n@@ -15455,8 +14962,46 @@ output_387_binary_op (rtx insn, rtx *operands)\n \n /* Return needed mode for entity in optimize_mode_switching pass.  */\n \n-int\n-ix86_mode_needed (int entity, rtx insn)\n+static int\n+ix86_avx_u128_mode_needed (rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  rtx arg;\n+  enum upper_128bits_state state;\n+\n+  if (CALL_P (insn))\n+    {\n+      /* Needed mode is set to AVX_U128_CLEAN if there are\n+\t no 256bit modes used in function arguments.  */\n+      for (arg = CALL_INSN_FUNCTION_USAGE (insn); arg;\n+\t   arg = XEXP (arg, 1))\n+\t{\n+\t  if (GET_CODE (XEXP (arg, 0)) == USE)\n+\t    {\n+\t      rtx reg = XEXP (XEXP (arg, 0), 0);\n+\n+\t      if (reg && REG_P (reg)\n+\t\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n+\t\treturn AVX_U128_ANY;\n+\t    }\n+\t}\n+\n+      return AVX_U128_CLEAN;\n+    }\n+\n+  /* Check if a 256bit AVX register is referenced in stores.  */\n+  state = unused;\n+  note_stores (pat, check_avx256_stores, &state);\n+  if (state == used)\n+    return AVX_U128_DIRTY;\n+  return AVX_U128_ANY;\n+}\n+\n+/* Return mode that i387 must be switched into\n+   prior to the execution of insn.  */\n+\n+static int\n+ix86_i387_mode_needed (int entity, rtx insn)\n {\n   enum attr_i387_cw mode;\n \n@@ -15505,11 +15050,166 @@ ix86_mode_needed (int entity, rtx insn)\n   return I387_CW_ANY;\n }\n \n+/* Return mode that entity must be switched into\n+   prior to the execution of insn.  */\n+\n+int\n+ix86_mode_needed (int entity, rtx insn)\n+{\n+  switch (entity)\n+    {\n+    case AVX_U128:\n+      return ix86_avx_u128_mode_needed (insn);\n+    case I387_TRUNC:\n+    case I387_FLOOR:\n+    case I387_CEIL:\n+    case I387_MASK_PM:\n+      return ix86_i387_mode_needed (entity, insn);\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return 0;\n+}\n+\n+/* Calculate mode of upper 128bit AVX registers after the insn.  */\n+\n+static int\n+ix86_avx_u128_mode_after (int mode, rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  rtx reg = NULL;\n+  int i;\n+  enum upper_128bits_state state;\n+\n+  /* Check for CALL instruction.  */\n+  if (CALL_P (insn))\n+    {\n+      if (GET_CODE (pat) == SET || GET_CODE (pat) == CALL)\n+\treg = SET_DEST (pat);\n+      else if (GET_CODE (pat) ==  PARALLEL)\n+\tfor (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n+\t  {\n+\t    rtx x = XVECEXP (pat, 0, i);\n+\t    if (GET_CODE(x) == SET)\n+\t      reg = SET_DEST (x);\n+\t  }\n+      /* Mode after call is set to AVX_U128_DIRTY if there are\n+\t 256bit modes used in the function return register.  */\n+      if (reg && REG_P (reg) && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n+\treturn AVX_U128_DIRTY;\n+      else\n+\treturn AVX_U128_CLEAN;\n+    }\n+\n+  if (vzeroupper_operation (pat, VOIDmode)\n+      || vzeroall_operation (pat, VOIDmode))\n+    return AVX_U128_CLEAN;\n+\n+  /* Check if a 256bit AVX register is referenced in stores.  */\n+  state = unused;\n+  note_stores (pat, check_avx256_stores, &state);\n+  if (state == used)\n+    return AVX_U128_DIRTY;\n+\n+  return mode;\n+}\n+\n+/* Return the mode that an insn results in.  */\n+\n+int\n+ix86_mode_after (int entity, int mode, rtx insn)\n+{\n+  switch (entity)\n+    {\n+    case AVX_U128:\n+      return ix86_avx_u128_mode_after (mode, insn);\n+    case I387_TRUNC:\n+    case I387_FLOOR:\n+    case I387_CEIL:\n+    case I387_MASK_PM:\n+      return mode;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static int\n+ix86_avx_u128_mode_entry (void)\n+{\n+  tree arg;\n+\n+  /* Entry mode is set to AVX_U128_DIRTY if there are\n+     256bit modes used in function arguments.  */\n+  for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n+       arg = TREE_CHAIN (arg))\n+    {\n+      rtx reg = DECL_INCOMING_RTL (arg);\n+\n+      if (reg && REG_P (reg) && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n+\treturn AVX_U128_DIRTY;\n+    }\n+\n+  return AVX_U128_CLEAN;\n+}\n+\n+/* Return a mode that ENTITY is assumed to be\n+   switched to at function entry.  */\n+\n+int\n+ix86_mode_entry (int entity)\n+{\n+  switch (entity)\n+    {\n+    case AVX_U128:\n+      return ix86_avx_u128_mode_entry ();\n+    case I387_TRUNC:\n+    case I387_FLOOR:\n+    case I387_CEIL:\n+    case I387_MASK_PM:\n+      return I387_CW_ANY;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static int\n+ix86_avx_u128_mode_exit (void)\n+{\n+  rtx reg = crtl->return_rtx;\n+\n+  /* Exit mode is set to AVX_U128_DIRTY if there are\n+     256bit modes used in the function return register.  */\n+  if (reg && REG_P (reg) && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n+    return AVX_U128_DIRTY;\n+\n+  return AVX_U128_CLEAN;\n+}\n+\n+/* Return a mode that ENTITY is assumed to be\n+   switched to at function exit.  */\n+\n+int\n+ix86_mode_exit (int entity)\n+{\n+  switch (entity)\n+    {\n+    case AVX_U128:\n+      return ix86_avx_u128_mode_exit ();\n+    case I387_TRUNC:\n+    case I387_FLOOR:\n+    case I387_CEIL:\n+    case I387_MASK_PM:\n+      return I387_CW_ANY;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Output code to initialize control word copies used by trunc?f?i and\n    rounding patterns.  CURRENT_MODE is set to current control word,\n    while NEW_MODE is set to new control word.  */\n \n-void\n+static void\n emit_i387_cw_initialization (int mode)\n {\n   rtx stored_mode = assign_386_stack_local (HImode, SLOT_CW_STORED);\n@@ -15596,6 +15296,30 @@ emit_i387_cw_initialization (int mode)\n   emit_move_insn (new_mode, reg);\n }\n \n+/* Generate one or more insns to set ENTITY to MODE.  */\n+\n+void\n+ix86_emit_mode_set (int entity, int mode)\n+{\n+  switch (entity)\n+    {\n+    case AVX_U128:\n+      if (mode == AVX_U128_CLEAN)\n+\temit_insn (gen_avx_vzeroupper ());\n+      break;\n+    case I387_TRUNC:\n+    case I387_FLOOR:\n+    case I387_CEIL:\n+    case I387_MASK_PM:\n+      if (mode != I387_CW_ANY\n+\t  && mode != I387_CW_UNINITIALIZED)\n+\temit_i387_cw_initialization (mode);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Output code for INSN to convert a float to a signed int.  OPERANDS\n    are the insn operands.  The output may be [HSD]Imode and the input\n    operand may be [SDX]Fmode.  */\n@@ -23604,30 +23328,6 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t\t\t\t\t  clobbered_registers[i]));\n     }\n \n-  /* Add UNSPEC_CALL_NEEDS_VZEROUPPER decoration.  */\n-  if (TARGET_VZEROUPPER)\n-    {\n-      int avx256;\n-      if (cfun->machine->callee_pass_avx256_p)\n-\t{\n-\t  if (cfun->machine->callee_return_avx256_p)\n-\t    avx256 = callee_return_pass_avx256;\n-\t  else\n-\t    avx256 = callee_pass_avx256;\n-\t}\n-      else if (cfun->machine->callee_return_avx256_p)\n-\tavx256 = callee_return_avx256;\n-      else\n-\tavx256 = call_no_avx256;\n-\n-      if (reload_completed)\n-\temit_insn (gen_avx_vzeroupper (GEN_INT (avx256)));\n-      else\n-\tvec[vec_len++] = gen_rtx_UNSPEC (VOIDmode,\n-\t\t\t\t\t gen_rtvec (1, GEN_INT (avx256)),\n-\t\t\t\t\t UNSPEC_CALL_NEEDS_VZEROUPPER);\n-    }\n-\n   if (vec_len > 1)\n     call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (vec_len, vec));\n   call = emit_call_insn (call);\n@@ -23637,25 +23337,6 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   return call;\n }\n \n-void\n-ix86_split_call_vzeroupper (rtx insn, rtx vzeroupper)\n-{\n-  rtx pat = PATTERN (insn);\n-  rtvec vec = XVEC (pat, 0);\n-  int len = GET_NUM_ELEM (vec) - 1;\n-\n-  /* Strip off the last entry of the parallel.  */\n-  gcc_assert (GET_CODE (RTVEC_ELT (vec, len)) == UNSPEC);\n-  gcc_assert (XINT (RTVEC_ELT (vec, len), 1) == UNSPEC_CALL_NEEDS_VZEROUPPER);\n-  if (len == 1)\n-    pat = RTVEC_ELT (vec, 0);\n-  else\n-    pat = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (len, &RTVEC_ELT (vec, 0)));\n-\n-  emit_insn (gen_avx_vzeroupper (vzeroupper));\n-  emit_call_insn (pat);\n-}\n-\n /* Output the assembly for a call instruction.  */\n \n const char *\n@@ -23736,6 +23417,7 @@ ix86_init_machine_status (void)\n   f->use_fast_prologue_epilogue_nregs = -1;\n   f->tls_descriptor_call_expanded_p = 0;\n   f->call_abi = ix86_abi;\n+  f->optimize_mode_switching[AVX_U128] = TARGET_VZEROUPPER;\n \n   return f;\n }\n@@ -31137,8 +30819,6 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n   switch ((enum ix86_builtin_func_type) d->flag)\n     {\n     case VOID_FTYPE_VOID:\n-      if (icode == CODE_FOR_avx_vzeroupper)\n-\ttarget = GEN_INT (vzeroupper_intrinsic);\n       emit_insn (GEN_FCN (icode) (target));\n       return 0;\n     case VOID_FTYPE_UINT64:\n@@ -35372,10 +35052,6 @@ ix86_reorg (void)\n      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n   compute_bb_for_insn ();\n \n-  /* Run the vzeroupper optimization if needed.  */\n-  if (TARGET_VZEROUPPER)\n-    move_or_delete_vzeroupper ();\n-\n   if (optimize && optimize_function_for_speed_p (cfun))\n     {\n       if (TARGET_PAD_SHORT_FUNCTION)"}, {"sha": "67403c551a98a3f5f1ef85bb4cc8f875e7f9318e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -1035,6 +1035,9 @@ enum target_cpu_default\n    || (MODE) == V4DImode || (MODE) == V2TImode || (MODE) == V8SFmode\t\\\n    || (MODE) == V4DFmode)\n \n+#define VALID_AVX256_REG_OR_OI_MODE(MODE)\t\t\t\t\t\\\n+  (VALID_AVX256_REG_MODE (MODE) || (MODE) == OImode)\n+\n #define VALID_SSE2_REG_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode\t\\\n    || (MODE) == V2DImode || (MODE) == DFmode)\n@@ -2141,7 +2144,8 @@ enum ix86_fpcmp_strategy {\n \n enum ix86_entity\n {\n-  I387_TRUNC = 0,\n+  AVX_U128 = 0,\n+  I387_TRUNC,\n   I387_FLOOR,\n   I387_CEIL,\n   I387_MASK_PM,\n@@ -2160,6 +2164,13 @@ enum ix86_stack_slot\n   MAX_386_STACK_LOCALS\n };\n \n+enum avx_u128_state\n+{\n+  AVX_U128_CLEAN,\n+  AVX_U128_DIRTY,\n+  AVX_U128_ANY\n+};\n+\n /* Define this macro if the port needs extra instructions inserted\n    for mode switching in an optimizing compilation.  */\n \n@@ -2175,16 +2186,34 @@ enum ix86_stack_slot\n    refer to the mode-switched entity in question.  */\n \n #define NUM_MODES_FOR_MODE_SWITCHING \\\n-   { I387_CW_ANY, I387_CW_ANY, I387_CW_ANY, I387_CW_ANY }\n+  { AVX_U128_ANY, I387_CW_ANY, I387_CW_ANY, I387_CW_ANY, I387_CW_ANY }\n \n /* ENTITY is an integer specifying a mode-switched entity.  If\n    `OPTIMIZE_MODE_SWITCHING' is defined, you must define this macro to\n    return an integer value not larger than the corresponding element\n    in `NUM_MODES_FOR_MODE_SWITCHING', to denote the mode that ENTITY\n-   must be switched into prior to the execution of INSN. */\n+   must be switched into prior to the execution of INSN.  */\n \n #define MODE_NEEDED(ENTITY, I) ix86_mode_needed ((ENTITY), (I))\n \n+/* If this macro is defined, it is evaluated for every INSN during\n+   mode switching.  It determines the mode that an insn results in (if\n+   different from the incoming mode).  */\n+\n+#define MODE_AFTER(ENTITY, MODE, I) ix86_mode_after ((ENTITY), (MODE), (I))\n+\n+/* If this macro is defined, it is evaluated for every ENTITY that\n+   needs mode switching.  It should evaluate to an integer, which is\n+   a mode that ENTITY is assumed to be switched to at function entry.  */\n+\n+#define MODE_ENTRY(ENTITY) ix86_mode_entry (ENTITY)\n+\n+/* If this macro is defined, it is evaluated for every ENTITY that\n+   needs mode switching.  It should evaluate to an integer, which is\n+   a mode that ENTITY is assumed to be switched to at function exit.  */\n+\n+#define MODE_EXIT(ENTITY) ix86_mode_exit (ENTITY)\n+\n /* This macro specifies the order in which modes for ENTITY are\n    processed.  0 is the highest priority.  */\n \n@@ -2194,11 +2223,8 @@ enum ix86_stack_slot\n    is the set of hard registers live at the point where the insn(s)\n    are to be inserted.  */\n \n-#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \t\t\t\\\n-  ((MODE) != I387_CW_ANY && (MODE) != I387_CW_UNINITIALIZED\t\t\\\n-   ? emit_i387_cw_initialization (MODE), 0\t\t\t\t\\\n-   : 0)\n-\n+#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \\\n+  ix86_emit_mode_set ((ENTITY), (MODE))\n \f\n /* Avoid renaming of stack registers, as doing so in combination with\n    scheduling just increases amount of live registers at time and in\n@@ -2299,21 +2325,6 @@ struct GTY(()) machine_function {\n      stack below the return address.  */\n   BOOL_BITFIELD static_chain_on_stack : 1;\n \n-  /* Nonzero if caller passes 256bit AVX modes.  */\n-  BOOL_BITFIELD caller_pass_avx256_p : 1;\n-\n-  /* Nonzero if caller returns 256bit AVX modes.  */\n-  BOOL_BITFIELD caller_return_avx256_p : 1;\n-\n-  /* Nonzero if the current callee passes 256bit AVX modes.  */\n-  BOOL_BITFIELD callee_pass_avx256_p : 1;\n-\n-  /* Nonzero if the current callee returns 256bit AVX modes.  */\n-  BOOL_BITFIELD callee_return_avx256_p : 1;\n-\n-  /* Nonzero if rescan vzerouppers in the current function is needed.  */\n-  BOOL_BITFIELD rescan_vzeroupper_p : 1;\n-\n   /* During prologue/epilogue generation, the current frame state.\n      Otherwise, the frame state at the end of the prologue.  */\n   struct machine_frame_state fs;"}, {"sha": "f2d2cd608f31bb77e4a93a4aca9904d65ed326c0", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -109,7 +109,6 @@\n   UNSPEC_TRUNC_NOOP\n   UNSPEC_DIV_ALREADY_SPLIT\n   UNSPEC_MS_TO_SYSV_CALL\n-  UNSPEC_CALL_NEEDS_VZEROUPPER\n   UNSPEC_PAUSE\n   UNSPEC_LEA_ADDR\n   UNSPEC_XBEGIN_ABORT\n@@ -11503,50 +11502,13 @@\n   DONE;\n })\n \n-(define_insn_and_split \"*call_vzeroupper\"\n-  [(call (mem:QI (match_operand:W 0 \"call_insn_operand\" \"<c>zw\"))\n-\t (match_operand 1))\n-   (unspec [(match_operand 2 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && !SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n-  [(set_attr \"type\" \"call\")])\n-\n (define_insn \"*call\"\n   [(call (mem:QI (match_operand:W 0 \"call_insn_operand\" \"<c>zw\"))\n \t (match_operand 1))]\n   \"!SIBLING_CALL_P (insn)\"\n   \"* return ix86_output_call_insn (insn, operands[0]);\"\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn_and_split \"*call_rex64_ms_sysv_vzeroupper\"\n-  [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rzw\"))\n-\t (match_operand 1))\n-   (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n-   (clobber (reg:TI XMM6_REG))\n-   (clobber (reg:TI XMM7_REG))\n-   (clobber (reg:TI XMM8_REG))\n-   (clobber (reg:TI XMM9_REG))\n-   (clobber (reg:TI XMM10_REG))\n-   (clobber (reg:TI XMM11_REG))\n-   (clobber (reg:TI XMM12_REG))\n-   (clobber (reg:TI XMM13_REG))\n-   (clobber (reg:TI XMM14_REG))\n-   (clobber (reg:TI XMM15_REG))\n-   (clobber (reg:DI SI_REG))\n-   (clobber (reg:DI DI_REG))\n-   (unspec [(match_operand 2 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n-  [(set_attr \"type\" \"call\")])\n-\n (define_insn \"*call_rex64_ms_sysv\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rzw\"))\n \t (match_operand 1))\n@@ -11567,18 +11529,6 @@\n   \"* return ix86_output_call_insn (insn, operands[0]);\"\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn_and_split \"*sibcall_vzeroupper\"\n-  [(call (mem:QI (match_operand:W 0 \"sibcall_insn_operand\" \"Uz\"))\n-\t (match_operand 1))\n-   (unspec [(match_operand 2 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[2]); DONE;\"\n-  [(set_attr \"type\" \"call\")])\n-\n (define_insn \"*sibcall\"\n   [(call (mem:QI (match_operand:W 0 \"sibcall_insn_operand\" \"Uz\"))\n \t (match_operand 1))]\n@@ -11599,21 +11549,6 @@\n   DONE;\n })\n \n-(define_insn_and_split \"*call_pop_vzeroupper\"\n-  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lzm\"))\n-\t (match_operand 1))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))\n-   (unspec [(match_operand 3 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n-  [(set_attr \"type\" \"call\")])\n-\n (define_insn \"*call_pop\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lzm\"))\n \t (match_operand 1))\n@@ -11624,21 +11559,6 @@\n   \"* return ix86_output_call_insn (insn, operands[0]);\"\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn_and_split \"*sibcall_pop_vzeroupper\"\n-  [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"Uz\"))\n-\t (match_operand 1))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))\n-   (unspec [(match_operand 3 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n-  [(set_attr \"type\" \"call\")])\n-\n (define_insn \"*sibcall_pop\"\n   [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"Uz\"))\n \t (match_operand 1))\n@@ -11675,19 +11595,6 @@\n   DONE;\n })\n \n-(define_insn_and_split \"*call_value_vzeroupper\"\n-  [(set (match_operand 0)\n-\t(call (mem:QI (match_operand:W 1 \"call_insn_operand\" \"<c>zw\"))\n-\t      (match_operand 2)))\n-   (unspec [(match_operand 3 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && !SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*call_value\"\n   [(set (match_operand 0)\n \t(call (mem:QI (match_operand:W 1 \"call_insn_operand\" \"<c>zw\"))\n@@ -11696,19 +11603,6 @@\n   \"* return ix86_output_call_insn (insn, operands[1]);\"\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn_and_split \"*sibcall_value_vzeroupper\"\n-  [(set (match_operand 0)\n-\t(call (mem:QI (match_operand:W 1 \"sibcall_insn_operand\" \"Uz\"))\n-\t      (match_operand 2)))\n-   (unspec [(match_operand 3 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*sibcall_value\"\n   [(set (match_operand 0)\n \t(call (mem:QI (match_operand:W 1 \"sibcall_insn_operand\" \"Uz\"))\n@@ -11717,32 +11611,6 @@\n   \"* return ix86_output_call_insn (insn, operands[1]);\"\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn_and_split \"*call_value_rex64_ms_sysv_vzeroupper\"\n-  [(set (match_operand 0)\n-\t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rzw\"))\n-\t      (match_operand 2)))\n-   (unspec [(const_int 0)] UNSPEC_MS_TO_SYSV_CALL)\n-   (clobber (reg:TI XMM6_REG))\n-   (clobber (reg:TI XMM7_REG))\n-   (clobber (reg:TI XMM8_REG))\n-   (clobber (reg:TI XMM9_REG))\n-   (clobber (reg:TI XMM10_REG))\n-   (clobber (reg:TI XMM11_REG))\n-   (clobber (reg:TI XMM12_REG))\n-   (clobber (reg:TI XMM13_REG))\n-   (clobber (reg:TI XMM14_REG))\n-   (clobber (reg:TI XMM15_REG))\n-   (clobber (reg:DI SI_REG))\n-   (clobber (reg:DI DI_REG))\n-   (unspec [(match_operand 3 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[3]); DONE;\"\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*call_value_rex64_ms_sysv\"\n   [(set (match_operand 0)\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rzw\"))\n@@ -11778,22 +11646,6 @@\n   DONE;\n })\n \n-(define_insn_and_split \"*call_value_pop_vzeroupper\"\n-  [(set (match_operand 0)\n-\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lzm\"))\n-\t      (match_operand 2)))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))\n-   (unspec [(match_operand 4 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && !TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[4]); DONE;\"\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*call_value_pop\"\n   [(set (match_operand 0)\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lzm\"))\n@@ -11805,22 +11657,6 @@\n   \"* return ix86_output_call_insn (insn, operands[1]);\"\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn_and_split \"*sibcall_value_pop_vzeroupper\"\n-  [(set (match_operand 0)\n-\t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"Uz\"))\n-\t      (match_operand 2)))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))\n-   (unspec [(match_operand 4 \"const_int_operand\")]\n-   \t   UNSPEC_CALL_NEEDS_VZEROUPPER)]\n-  \"TARGET_VZEROUPPER && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_call_vzeroupper (curr_insn, operands[4]); DONE;\"\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*sibcall_value_pop\"\n   [(set (match_operand 0)\n \t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"Uz\"))\n@@ -11922,7 +11758,6 @@\n   [(simple_return)]\n   \"ix86_can_use_return_insn_p ()\"\n {\n-  ix86_maybe_emit_epilogue_vzeroupper ();\n   if (crtl->args.pops_args)\n     {\n       rtx popc = GEN_INT (crtl->args.pops_args);\n@@ -11939,7 +11774,6 @@\n   [(simple_return)]\n   \"!TARGET_SEH\"\n {\n-  ix86_maybe_emit_epilogue_vzeroupper ();\n   if (crtl->args.pops_args)\n     {\n       rtx popc = GEN_INT (crtl->args.pops_args);"}, {"sha": "e1085534b91133188c55d375c798f2c1308e53cd", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -1229,6 +1229,13 @@\n   return true;\n })\n \n+;; return true if OP is a vzeroupper operation.\n+(define_predicate \"vzeroupper_operation\"\n+  (match_code \"unspec_volatile\")\n+{\n+  return XINT (op, 1) == UNSPECV_VZEROUPPER;\n+})\n+\n ;; Return true if OP is a parallel for a vbroadcast permute.\n \n (define_predicate \"avx_vbroadcast_operand\""}, {"sha": "33d7b6bc0a9e9aa905c0726f136b8d2734a7280c", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -10452,8 +10452,7 @@\n ;; Clear the upper 128bits of AVX registers, equivalent to a NOP\n ;; if the upper 128bits are unused.\n (define_insn \"avx_vzeroupper\"\n-  [(unspec_volatile [(match_operand 0 \"const_int_operand\")]\n-\t\t    UNSPECV_VZEROUPPER)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)]\n   \"TARGET_AVX\"\n   \"vzeroupper\"\n   [(set_attr \"type\" \"sse\")"}, {"sha": "2108e77db530c4fb78801c480910ff0d8256dbca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -1,3 +1,14 @@\n+2012-11-06  Vladimir Yakovlev  <vladimir.b.yakovlev@intel.com>\n+\n+\t* gcc.target/i386/avx-vzeroupper-5.c: Changed scan-assembler-times.\n+\t* gcc.target/i386/avx-vzeroupper-8.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-9.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-10.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-11.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-12.c: Likewise.\n+\t* gcc.target/i386/avx-vzeroupper-19.c: Likewis.\n+\t* gcc.target/i386/avx-vzeroupper-27.c: New.\n+\n 2012-11-06  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/54917"}, {"sha": "5007753a0b747d8a7f2ef3c25f69dbc15e0a5c34", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-10.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -14,4 +14,4 @@ foo ()\n   _mm256_zeroupper ();\n }\n \n-/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 3 } } */"}, {"sha": "507f9454391fbad6beef3081a2a193dfbb92b46e", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-11.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -16,4 +16,4 @@ foo ()\n }\n \n /* { dg-final { scan-assembler-times \"\\\\*avx_vzeroall\" 1 } } */\n-/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 3 } } */"}, {"sha": "e694d4048bdbd0be746fdafed0fcb77c1b9e3714", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-12.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -16,5 +16,5 @@ foo ()\n   _mm256_zeroupper ();\n }\n \n-/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 4 } } */\n /* { dg-final { scan-assembler-times \"\\\\*avx_vzeroall\" 1 } } */"}, {"sha": "ae2f8611ea60297505421f41f0351c77e81b104e", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-19.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-19.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -14,4 +14,4 @@ void feat_s3_cep_dcep (int cepsize_used, float **mfc, float **feat)\n     f[i] = w[i] - _w[i];\n }\n \n-/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 2 } } */"}, {"sha": "7fa5de437630fd99d0a6d3ae27896d5910a064b0", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-27.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-27.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx -mtune=generic -dp\" } */\n+\n+typedef struct objc_class *Class;\n+typedef struct objc_object\n+{\n+  Class class_pointer;\n+} *id;\n+\n+typedef const struct objc_selector *SEL;\n+typedef void * retval_t;\n+typedef void * arglist_t;\n+\n+extern retval_t __objc_forward (id object, SEL sel, arglist_t args);\n+\n+double\n+__objc_double_forward (id rcv, SEL op, ...)\n+{\n+  void *args, *res;\n+\n+  args = __builtin_apply_args ();\n+  res = __objc_forward (rcv, op, args);\n+  __builtin_return (res);\n+}\n+\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 2 } } */"}, {"sha": "ba08978ab4e237435f782b7e9fd324a159b36c13", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-5.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -14,4 +14,4 @@ foo ()\n   _mm256_zeroupper ();\n }\n \n-/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */"}, {"sha": "bb370c5b44e883a9b44dcd983c53e4daf3da34db", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-8.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -13,4 +13,4 @@ foo ()\n   _mm256_zeroupper ();\n }\n \n-/* { dg-final { scan-assembler-not \"avx_vzeroupper\" } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */"}, {"sha": "974e1626a6d83c371a1340f8b1d5f63564908c63", "filename": "gcc/testsuite/gcc.target/i386/avx-vzeroupper-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff97910daf84acf7f3073b6b53660efcad9e6480/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-vzeroupper-9.c?ref=ff97910daf84acf7f3073b6b53660efcad9e6480", "patch": "@@ -15,4 +15,4 @@ foo ()\n   _mm256_zeroupper ();\n }\n \n-/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 1 } } */\n+/* { dg-final { scan-assembler-times \"avx_vzeroupper\" 4 } } */"}]}