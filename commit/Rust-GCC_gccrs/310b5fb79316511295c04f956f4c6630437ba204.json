{"sha": "310b5fb79316511295c04f956f4c6630437ba204", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwYjVmYjc5MzE2NTExMjk1YzA0Zjk1NmY0YzY2MzA0MzdiYTIwNA==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2019-07-22T16:02:29Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2019-07-22T16:02:29Z"}, "message": "MSP430: Don't save all callee-saved regs in non-leaf interrupt functions\n\nPreviously, all callee-saved regs would unconditionally be saved\nin interrupt functions that call another function.\n\n2019-07-22  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* config/msp430/msp430.c (msp430_preserve_reg_p): Don't save\n\tcallee-saved regs R4->R10 in an interrupt function that calls another\n\tfunction.\n\n2019-07-22  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* gcc.target/msp430/isr-push-pop-main.c: New test.\n\t* gcc.target/msp430/isr-push-pop-isr-430.c: Likewise.\n\t* gcc.target/msp430/isr-push-pop-isr-430x.c: Likewise.\n\t* gcc.target/msp430/isr-push-pop-leaf-isr-430.c: Likewise.\n\t* gcc.target/msp430/isr-push-pop-leaf-isr-430x.c: Likewise.\n\nFrom-SVN: r273702", "tree": {"sha": "438824e69ea2cf12dd9304e85b0b541fa9587a61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438824e69ea2cf12dd9304e85b0b541fa9587a61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/310b5fb79316511295c04f956f4c6630437ba204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310b5fb79316511295c04f956f4c6630437ba204", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310b5fb79316511295c04f956f4c6630437ba204", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310b5fb79316511295c04f956f4c6630437ba204/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9afb91b2d1aeabf49a2b76556ec6fe18dd5790f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9afb91b2d1aeabf49a2b76556ec6fe18dd5790f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9afb91b2d1aeabf49a2b76556ec6fe18dd5790f9"}], "stats": {"total": 228, "additions": 223, "deletions": 5}, "files": [{"sha": "687ae89cdc815a1dc234d64e7357527bde227ed0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -1,3 +1,9 @@\n+2019-07-22  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* config/msp430/msp430.c (msp430_preserve_reg_p): Don't save\n+\tcallee-saved regs R4->R10 in an interrupt function that calls another\n+\tfunction.\n+\n 2019-07-22  Paul A. Clarke  <pc@us.ibm.com>\n \n \t* config/rs6000/smmintrin.h (_mm_blend_epi16): New."}, {"sha": "265c2f642d82c62dcab3217284ebf6dfe0193522", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -1755,11 +1755,19 @@ msp430_preserve_reg_p (int regno)\n   if (fixed_regs [regno])\n     return false;\n \n-  /* Interrupt handlers save all registers they use, even\n-     ones which are call saved.  If they call other functions\n-     then *every* register is saved.  */\n-  if (msp430_is_interrupt_func ())\n-    return ! crtl->is_leaf || df_regs_ever_live_p (regno);\n+  /* For interrupt functions we must save and restore the used regs that\n+     would normally be caller-saved (R11->R15).  */\n+  if (msp430_is_interrupt_func () && regno >= 11 && regno <= 15)\n+    {\n+      if (crtl->is_leaf && df_regs_ever_live_p (regno))\n+\t/* If the interrupt func is a leaf then we only need to restore the\n+\t   caller-saved regs that are used.  */\n+\treturn true;\n+      else if (!crtl->is_leaf)\n+\t/* If the interrupt function is not a leaf we must save all\n+\t   caller-saved regs in case the callee modifies them.  */\n+\treturn true;\n+    }\n \n   if (!call_used_regs [regno]\n       && df_regs_ever_live_p (regno))"}, {"sha": "ecd2a9e5554c94ccc6b7cc7b225f4c61c0860115", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -1,3 +1,11 @@\n+2019-07-22  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* gcc.target/msp430/isr-push-pop-main.c: New test.\n+\t* gcc.target/msp430/isr-push-pop-isr-430.c: Likewise.\n+\t* gcc.target/msp430/isr-push-pop-isr-430x.c: Likewise.\n+\t* gcc.target/msp430/isr-push-pop-leaf-isr-430.c: Likewise.\n+\t* gcc.target/msp430/isr-push-pop-leaf-isr-430x.c: Likewise.\n+\n 2019-07-22  Andrea Corallo <andrea.corallo@arm.com>\n \n \t* jit.dg/test-error-gcc_jit_context_new_unary_op-bad-res-type.c:"}, {"sha": "a2bf8433ebd6859a7de21c874ca4dd1237fdf923", "filename": "gcc/testsuite/gcc.target/msp430/isr-push-pop-isr-430.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-isr-430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-isr-430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-isr-430.c?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430x*\" \"-mlarge\" } { \"\" } } */\n+/* { dg-options \"-mcpu=msp430\" } */\n+/* { dg-final { scan-assembler \"PUSH\\tR11\" } } */\n+/* { dg-final { scan-assembler-not \"PUSH\\tR10\" } } */\n+\n+void __attribute__((noinline)) callee (void);\n+\n+void __attribute__((interrupt))\n+isr (void)\n+{\n+  callee();\n+}"}, {"sha": "2d65186bdf96fd2d152499ff037424ee86563319", "filename": "gcc/testsuite/gcc.target/msp430/isr-push-pop-isr-430x.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-isr-430x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-isr-430x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-isr-430x.c?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" } { \"\" } } */\n+/* { dg-final { scan-assembler \"PUSHM.*#5\" } } */\n+/* { dg-final { scan-assembler-not \"PUSHM.*#12\" } } */\n+\n+void __attribute__((noinline)) callee (void);\n+\n+void __attribute__((interrupt))\n+isr (void)\n+{\n+  callee();\n+}"}, {"sha": "cbb45974c4ae1dd2b0adeb87e570f1f7e2c26c81", "filename": "gcc/testsuite/gcc.target/msp430/isr-push-pop-leaf-isr-430.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-leaf-isr-430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-leaf-isr-430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-leaf-isr-430.c?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430x*\" \"-mlarge\" } { \"\" } } */\n+/* { dg-options \"-mcpu=msp430\" } */\n+/* { dg-final { scan-assembler \"PUSH\\tR5\" } } */\n+/* { dg-final { scan-assembler \"PUSH\\tR12\" } } */\n+/* { dg-final { scan-assembler-not \"PUSH\\tR4\" } } */\n+/* { dg-final { scan-assembler-not \"PUSH\\tR11\" } } */\n+\n+/* To check that the compiler doesn't blindly save all regs, we omit R4 and R11\n+   from the trashing.  */\n+#define TRASH_REGS_LITE\t\t\t\t\\\n+  __asm__ (\"mov #0xFFFF, r5\" : : : \"R5\");\t\\\n+  __asm__ (\"mov #0xFFFF, r6\" : : : \"R6\");\t\\\n+  __asm__ (\"mov #0xFFFF, r7\" : : : \"R7\");\t\\\n+  __asm__ (\"mov #0xFFFF, r8\" : : : \"R8\");\t\\\n+  __asm__ (\"mov #0xFFFF, r9\" : : : \"R9\");\t\\\n+  __asm__ (\"mov #0xFFFF, r10\" : : : \"R10\");\t\\\n+  __asm__ (\"mov #0xFFFF, r12\" : : : \"R12\");\t\\\n+  __asm__ (\"mov #0xFFFF, r13\" : : : \"R13\");\t\\\n+  __asm__ (\"mov #0xFFFF, r14\" : : : \"R14\");\t\\\n+  __asm__ (\"mov #0xFFFF, r15\" : : : \"R15\");\n+\n+void __attribute__((interrupt))\n+isr_leaf (void)\n+{\n+  TRASH_REGS_LITE\n+}"}, {"sha": "872a40ef755cb5c45d6f1bddfd0954201168c6fc", "filename": "gcc/testsuite/gcc.target/msp430/isr-push-pop-leaf-isr-430x.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-leaf-isr-430x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-leaf-isr-430x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-leaf-isr-430x.c?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" } { \"\" } } */\n+/* { dg-final { scan-assembler \"PUSHM.*#4.*R15\" } } */\n+/* { dg-final { scan-assembler \"PUSHM.*#6.*R10\" } } */\n+\n+/* To check that the compiler doesn't blindly save all regs, we omit R4 and R11\n+   from the trashing.  */\n+#define TRASH_REGS_LITE\t\t\t\t\\\n+  __asm__ (\"mov #0xFFFF, r5\" : : : \"R5\");\t\\\n+  __asm__ (\"mov #0xFFFF, r6\" : : : \"R6\");\t\\\n+  __asm__ (\"mov #0xFFFF, r7\" : : : \"R7\");\t\\\n+  __asm__ (\"mov #0xFFFF, r8\" : : : \"R8\");\t\\\n+  __asm__ (\"mov #0xFFFF, r9\" : : : \"R9\");\t\\\n+  __asm__ (\"mov #0xFFFF, r10\" : : : \"R10\");\t\\\n+  __asm__ (\"mov #0xFFFF, r12\" : : : \"R12\");\t\\\n+  __asm__ (\"mov #0xFFFF, r13\" : : : \"R13\");\t\\\n+  __asm__ (\"mov #0xFFFF, r14\" : : : \"R14\");\t\\\n+  __asm__ (\"mov #0xFFFF, r15\" : : : \"R15\");\n+\n+void __attribute__((interrupt))\n+isr_leaf (void)\n+{\n+  TRASH_REGS_LITE\n+}"}, {"sha": "5c7b594b50b786e88e0d341d56e61b9658dd5dc2", "filename": "gcc/testsuite/gcc.target/msp430/isr-push-pop-main.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310b5fb79316511295c04f956f4c6630437ba204/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fisr-push-pop-main.c?ref=310b5fb79316511295c04f956f4c6630437ba204", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-do run } */\n+\n+#ifdef __MSP430X__\n+#include \"isr-push-pop-isr-430x.c\"\n+#include \"isr-push-pop-leaf-isr-430x.c\"\n+#else\n+#include \"isr-push-pop-isr-430.c\"\n+#include \"isr-push-pop-leaf-isr-430.c\"\n+#endif\n+\n+/* Test that ISRs which call other functions do not save extraneous registers.\n+   They only need to save the caller-saved regs R11->R15.\n+   We use a lot of asm statements to hide what is going on from the compiler to\n+   more accurately simulate an interrupt.  */\n+\n+/* Store the register number in each general register R4->R15, so they can be\n+   later checked their value has been kept.  */\n+#define SETUP_REGS\t\t\\\n+  __asm__ (\"mov #4, r4\");\t\\\n+  __asm__ (\"mov #5, r5\");\t\\\n+  __asm__ (\"mov #6, r6\");\t\\\n+  __asm__ (\"mov #7, r7\");\t\\\n+  __asm__ (\"mov #8, r8\");\t\\\n+  __asm__ (\"mov #9, r9\");\t\\\n+  __asm__ (\"mov #10, r10\");\t\\\n+  __asm__ (\"mov #11, r11\");\t\\\n+  __asm__ (\"mov #12, r12\");\t\\\n+  __asm__ (\"mov #13, r13\");\t\\\n+  __asm__ (\"mov #14, r14\");\t\\\n+  __asm__ (\"mov #15, r15\");\n+\n+/* Write an arbitrary value to all general regs.  */\n+#define TRASH_REGS\t\t\t\t\\\n+  __asm__ (\"mov #0xFFFF, r4\" : : : \"R4\");\t\\\n+  __asm__ (\"mov #0xFFFF, r5\" : : : \"R5\");\t\\\n+  __asm__ (\"mov #0xFFFF, r6\" : : : \"R6\");\t\\\n+  __asm__ (\"mov #0xFFFF, r7\" : : : \"R7\");\t\\\n+  __asm__ (\"mov #0xFFFF, r8\" : : : \"R8\");\t\\\n+  __asm__ (\"mov #0xFFFF, r9\" : : : \"R9\");\t\\\n+  __asm__ (\"mov #0xFFFF, r10\" : : : \"R10\");\t\\\n+  __asm__ (\"mov #0xFFFF, r11\" : : : \"R11\");\t\\\n+  __asm__ (\"mov #0xFFFF, r12\" : : : \"R12\");\t\\\n+  __asm__ (\"mov #0xFFFF, r13\" : : : \"R13\");\t\\\n+  __asm__ (\"mov #0xFFFF, r14\" : : : \"R14\");\t\\\n+  __asm__ (\"mov #0xFFFF, r15\" : : : \"R15\");\n+\n+/* Check the value in all general registers is the same as that set in\n+   SETUP_REGS.  */\n+#define CHECK_REGS\t\t\t\\\n+  __asm__ (\"cmp #4,  r4 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #5,  r5 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #6,  r6 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #7,  r7 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #8,  r8 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #9,  r9 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #10, r10 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #11, r11 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #12, r12 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #13, r13 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #14, r14 { jne ABORT\");\t\\\n+  __asm__ (\"cmp #15, r15 { jne ABORT\");\n+\n+void __attribute__((noinline))\n+callee (void)\n+{\n+  /* Here were modify all the regs, but tell the compiler that we are since\n+     this is just a way to simulate a function that happens to modify all the\n+     registers.  */\n+  TRASH_REGS\n+}\n+int \n+#ifdef __MSP430X_LARGE__ \n+__attribute__((lower))\n+#endif\n+main (void)\n+{\n+  SETUP_REGS\n+\n+  /* A surprise branch to the ISR that the compiler cannot prepare for.\n+     We must first simulate the interrupt acceptance procedure that the\n+     hardware would normally take care of.\n+     So push the desired PC return address, and then the SR (R2).\n+     MSP430X expects the high bits 19:16 of the PC return address to be stored\n+     in bits 12:15 of the SR stack slot.  This is hard to handle in hand-rolled\n+     assembly code, so we always place main() in lower memory so the return\n+     address is 16-bits.  */\n+  __asm__ (\"push #CHECK1\");\n+  __asm__ (\"push r2\");\n+  __asm__ (\"br #isr\");\n+\n+  __asm__ (\"CHECK1:\");\n+  /* If any of the regs R4->R15 don't match their original value, this will\n+     jump to ABORT.  */\n+  CHECK_REGS\n+\n+  /* Now test that an interrupt function that is a leaf also works\n+     correctly.  */\n+  __asm__ (\"push #CHECK2\");\n+  __asm__ (\"push r2\");\n+  __asm__ (\"br #isr_leaf\");\n+\n+  __asm__ (\"CHECK2:\");\n+  CHECK_REGS\n+\n+  /* The values in R4->R15 were successfully checked, now jump to FINISH to run\n+     the prologue generated by the compiler.  */\n+  __asm__ (\"jmp FINISH\");\n+\n+  /* CHECK_REGS will branch here if a register holds the wrong value.  */\n+  __asm__ (\"ABORT:\");\n+#ifdef __MSP430X_LARGE__ \n+  __asm__ (\"calla #abort\");\n+#else\n+  __asm__ (\"call #abort\");\n+#endif\n+\n+  __asm__ (\"FINISH:\");\n+  return 0;\n+}\n+"}]}