{"sha": "839df961206ef7e5df8136e88e7edac7fa66bb54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM5ZGY5NjEyMDZlZjdlNWRmODEzNmU4OGU3ZWRhYzdmYTY2YmI1NA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-04-16T18:35:02Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-04-16T18:35:02Z"}, "message": "InputStreamReader.java (<init>): Set super.in correctly.\n\n\ufffd\n\t* java/io/InputStreamReader.java (<init>):  Set super.in correctly.\n\t* java/io/OutputStreamWriter.java (<init>):  Set super.in correctly.\n\t(writeChars):  Don't be quite so eager to flush.\n\t* java/io/PrintStream.java:  Rewrite.  Now more similar to\n\tOutputStreamWriter, using explicit UnicodeToBytes converter.\n\tAlso, autoflush does not need to flush so often.\n\t* java/lang/natString.cc (getBytes):  More efficient algorithm.\n \t(init(jbyteArray,jint,jint,jstring)):  More efficient.\n\nFrom-SVN: r26509", "tree": {"sha": "d5fe22f8b6e8bfbf99f7efa65bace32141b44d8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5fe22f8b6e8bfbf99f7efa65bace32141b44d8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/839df961206ef7e5df8136e88e7edac7fa66bb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839df961206ef7e5df8136e88e7edac7fa66bb54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/839df961206ef7e5df8136e88e7edac7fa66bb54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839df961206ef7e5df8136e88e7edac7fa66bb54/comments", "author": null, "committer": null, "parents": [{"sha": "a99ce7cae5a040bbf71486ab1472f61ef0ced76c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a99ce7cae5a040bbf71486ab1472f61ef0ced76c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a99ce7cae5a040bbf71486ab1472f61ef0ced76c"}], "stats": {"total": 175, "additions": 120, "deletions": 55}, "files": [{"sha": "5d37303121bf0941ef3fa12ed078511de78bfb40", "filename": "libjava/java/io/InputStreamReader.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/839df961206ef7e5df8136e88e7edac7fa66bb54/libjava%2Fjava%2Fio%2FInputStreamReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/839df961206ef7e5df8136e88e7edac7fa66bb54/libjava%2Fjava%2Fio%2FInputStreamReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStreamReader.java?ref=839df961206ef7e5df8136e88e7edac7fa66bb54", "patch": "@@ -44,9 +44,9 @@ public InputStreamReader(InputStream in, String enc)\n \n   private InputStreamReader(InputStream in, BytesToUnicode decoder)\n   {\n-    super(in);\n-    this.in = in instanceof BufferedInputStream  ? (BufferedInputStream) in\n-      : new BufferedInputStream(in, 250);\n+    super((this.in = (in instanceof BufferedInputStream\n+\t\t      ? (BufferedInputStream) in\n+\t\t      : new BufferedInputStream(in, 250))));\n     converter = decoder;\n     converter.setInput(this.in.buf, 0, 0);\n   }"}, {"sha": "88841d9c1b4b9943712006d0604f655bea8ce3a8", "filename": "libjava/java/io/OutputStreamWriter.java", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/839df961206ef7e5df8136e88e7edac7fa66bb54/libjava%2Fjava%2Fio%2FOutputStreamWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/839df961206ef7e5df8136e88e7edac7fa66bb54/libjava%2Fjava%2Fio%2FOutputStreamWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FOutputStreamWriter.java?ref=839df961206ef7e5df8136e88e7edac7fa66bb54", "patch": "@@ -32,9 +32,9 @@ public class OutputStreamWriter extends Writer\n \n   private OutputStreamWriter(OutputStream out, UnicodeToBytes encoder)\n   {\n-    super(out);\n-    this.out = out instanceof BufferedOutputStream ? (BufferedOutputStream) out\n-      : new BufferedOutputStream(out, 2048);\n+    super((this.out = (out instanceof BufferedOutputStream\n+\t\t       ? (BufferedOutputStream) out\n+\t\t       : new BufferedOutputStream(out, 250))));\n     this.converter = encoder;\n   } \n \n@@ -90,12 +90,17 @@ public void write(char[] buf, int offset, int count)\n       }\n   }\n \n+  /** Writes characters through to the inferior BufferedOutputStream.\n+   * Ignores wcount and the work buffer. */\n   private void writeChars(char[] buf, int offset, int count)\n     throws IOException\n   {\n     while (count > 0)\n       {\n-\tif (out.count != 0)\n+\t// We must flush if out.count == out.buf.length.\n+\t// It is probably a good idea to flush if out.buf is almost full.\n+\t// This test is an approximation for \"almost full\".\n+\tif (out.count + count >= out.buf.length)\n \t  {\n \t    out.flush();\n \t    if (out.count != 0)"}, {"sha": "08d506f5492fdabca239d69fe4f9b75acbec585b", "filename": "libjava/java/io/PrintStream.java", "status": "modified", "additions": 108, "deletions": 48, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/839df961206ef7e5df8136e88e7edac7fa66bb54/libjava%2Fjava%2Fio%2FPrintStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/839df961206ef7e5df8136e88e7edac7fa66bb54/libjava%2Fjava%2Fio%2FPrintStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPrintStream.java?ref=839df961206ef7e5df8136e88e7edac7fa66bb54", "patch": "@@ -9,6 +9,7 @@\n details.  */\n \n package java.io;\n+import gnu.gcj.convert.UnicodeToBytes;\n \n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n@@ -22,6 +23,10 @@\n \n public class PrintStream extends FilterOutputStream\n {\n+  /* Notice the implementation is quite similar to OutputStreamWriter.\n+   * This leads to some minor duplication, because neither inherits\n+   * from the other, and we want to maximize performance. */\n+\n   public boolean checkError ()\n   {\n     return error;\n@@ -51,138 +56,193 @@ public void flush ()\n       }\n   }\n \n-  private final void print (String str, boolean check_term)\n+  private synchronized void print (String str, boolean println)\n+  {\n+    try\n+      {\n+        writeChars(str, 0, str.length());\n+\tif (println)\n+\t  writeChars(line_separator, 0, line_separator.length);\n+\tif (auto_flush)\n+\t  flush();\n+      }\n+    catch (IOException e)\n+      {\n+\tsetError ();\n+      }\n+  }\n+\n+  private synchronized void print (char[] chars, int pos, int len,\n+\t\t\t\t   boolean println)\n   {\n     try\n       {\n-\twrite(str.getBytes());\n-\tif (check_term\n-\t    && auto_flush\n-\t    && str.indexOf(line_separator) != -1)\n-\t  flush ();\n+        writeChars(chars, pos, len);\n+\tif (println)\n+\t  writeChars(line_separator, 0, line_separator.length);\n+\tif (auto_flush)\n+\t  flush();\n       }\n     catch (IOException e)\n       {\n \tsetError ();\n       }\n   }\n \n+  /** Writes characters through to the inferior BufferedOutputStream. */\n+  private void writeChars(char[] buf, int offset, int count)\n+    throws IOException\n+  {\n+    while (count > 0)\n+      {\n+\t// We must flush if out.count == out.buf.length.\n+\t// It is probably a good idea to flush if out.buf is almost full.\n+\t// This test is an approximation for \"almost full\".\n+\tif (out.count + count >= out.buf.length)\n+\t  {\n+\t    out.flush();\n+\t    if (out.count != 0)\n+\t      throw new IOException(\"unable to flush output byte buffer\");\n+\t  }\n+\tconverter.setOutput(out.buf, out.count);\n+\tint converted = converter.write(buf, offset, count);\n+\toffset += converted;\n+\tcount -= converted;\n+\tout.count = converter.count;\n+      }\n+  }\n+\n+  private void writeChars(String str, int offset, int count)\n+    throws IOException\n+  {\n+    while (count > 0)\n+      {\n+\t// We must flush if out.count == out.buf.length.\n+\t// It is probably a good idea to flush if out.buf is almost full.\n+\t// This test is an approximation for \"almost full\".\n+\tif (out.count + count >= out.buf.length)\n+\t  {\n+\t    out.flush();\n+\t    if (out.count != 0)\n+\t      throw new IOException(\"unable to flush output byte buffer\");\n+\t  }\n+\tconverter.setOutput(out.buf, out.count);\n+\tint converted = converter.write(str, offset, count, work);\n+\toffset += converted;\n+\tcount -= converted;\n+\tout.count = converter.count;\n+      }\n+  }\n+\n   public void print (boolean bool)\n   {\n-    print (String.valueOf(bool), false);\n+    print(String.valueOf(bool), false);\n   }\n \n   public void print (int inum)\n   {\n-    print (String.valueOf(inum), false);\n+    print(String.valueOf(inum), false);\n   }\n \n   public void print (long lnum)\n   {\n-    print (String.valueOf(lnum), false);\n+    print(String.valueOf(lnum), false);\n   }\n \n   public void print (float fnum)\n   {\n-    print (String.valueOf(fnum), false);\n+    print(String.valueOf(fnum), false);\n   }\n \n   public void print (double dnum)\n   {\n-    print (String.valueOf(dnum), false);\n+    print(String.valueOf(dnum), false);\n   }\n \n   public void print (Object obj)\n   {\n-    print (String.valueOf(obj), false);\n+    print(obj == null ? \"null\" : obj.toString(), false);\n   }\n \n   public void print (String str)\n   {\n-    print (str == null ? \"null\" : str, true);\n+    print(str == null ? \"null\" : str, false);\n   }\n \n-  public void print (char ch)\n+  public synchronized void print (char ch)\n   {\n-    print (String.valueOf(ch), true);\n+    work[0] = ch;\n+    print(work, 0, 1, false);\n   }\n \n   public void print (char[] charArray)\n   {\n-    print (String.valueOf(charArray), true);\n+    print(charArray, 0, charArray.length, false);\n   }\n \n   public void println ()\n   {\n-    print (line_separator, false);\n-    if (auto_flush)\n-      flush ();\n+    print(line_separator, 0, line_separator.length, false);\n   }\n \n   public void println (boolean bool)\n   {\n-    print (String.valueOf(bool), false);\n-    println ();\n+    print(String.valueOf(bool), true);\n   }\n \n   public void println (int inum)\n   {\n-    print (String.valueOf(inum), false);\n-    println ();\n+    print(String.valueOf(inum), true);\n   }\n \n   public void println (long lnum)\n   {\n-    print (String.valueOf(lnum), false);\n-    println ();\n+    print(String.valueOf(lnum), true);\n   }\n \n   public void println (float fnum)\n   {\n-    print (String.valueOf(fnum), false);\n-    println ();\n+    print(String.valueOf(fnum), true);\n   }\n \n   public void println (double dnum)\n   {\n-    print (String.valueOf(dnum), false);\n-    println ();\n+    print(String.valueOf(dnum), true);\n   }\n \n   public void println (Object obj)\n   {\n-    print (String.valueOf(obj), false);\n-    println ();\n+    print(obj == null ? \"null\" : obj.toString(), true);\n   }\n \n   public void println (String str)\n   {\n-    print (str == null ? \"null\" : str, false);\n+    print (str == null ? \"null\" : str, true);\n     println ();\n   }\n \n-  public void println (char ch)\n+  public synchronized void println (char ch)\n   {\n-    print (String.valueOf(ch), false);\n-    println ();\n+    work[0] = ch;\n+    print(work, 0, 1, true);\n   }\n \n   public void println (char[] charArray)\n   {\n-    print (String.valueOf(charArray), false);\n-    println ();\n+    print(charArray, 0, charArray.length, true);\n   }\n \n   public PrintStream (OutputStream out)\n   {\n-    super (out);\n-    error = false;\n-    auto_flush = false;\n+    this(out, false);\n   }\n \n   public PrintStream (OutputStream out, boolean af)\n   {\n-    super (out);\n+    super ((this.out = (out instanceof BufferedOutputStream\n+\t\t\t ? (BufferedOutputStream) out\n+\t\t\t : new BufferedOutputStream(out, 250))));\n+    converter = UnicodeToBytes.getDefaultEncoder();\n     error = false;\n     auto_flush = af;\n   }\n@@ -197,7 +257,6 @@ public void write (int oneByte)\n     try\n       {\n \tout.write(oneByte);\n-\t// JCL says to do this.  I think it is wrong.  FIXME.\n \tif (auto_flush && oneByte == '\\n')\n \t  out.flush();\n       }\n@@ -212,10 +271,6 @@ public void write (byte[] buffer, int offset, int count)\n     try\n       {\n \tout.write(buffer, offset, count);\n-\t// FIXME: JCL says to flush.  But elsewhere the JCL says to\n-\t// use write to write the stringified form of an object, and\n-\t// only to flush if that string contains the line separator.\n-\t// How to resolve the contradiction?\n \tif (auto_flush)\n \t  out.flush();\n       }\n@@ -225,12 +280,17 @@ public void write (byte[] buffer, int offset, int count)\n       }\n   }\n \n+  BufferedOutputStream out;\n+  UnicodeToBytes converter;\n+\n+  char[] work = new char[100];\n+\n   // True if error occurred.\n   private boolean error;\n   // True if auto-flush.\n   private boolean auto_flush;\n \n   // Line separator string.\n-  private static final String line_separator\n-    = System.getProperty(\"line.separator\");\n+  private static final char[] line_separator\n+    = System.getProperty(\"line.separator\").toCharArray();\n }"}]}