{"sha": "cddd902d35bfef2bf6cea89b63d6dea23e0babed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RkZDkwMmQzNWJmZWYyYmY2Y2VhODliNjNkNmRlYTIzZTBiYWJlZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-12-03T15:49:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-12-03T15:49:50Z"}, "message": "[Ada] Spurious error on dependent expression that is an array\n\nThis patch fixes a spurious error on a array expression that is a\ndependent expression of an if-expression, when the length of the array\nmatches that imposed by the context, but the bounds of both differ, in\nparticular when the expression and the context are both null arrays with\ndifferent bounds.\n\n2018-12-03  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_res.adb (Apply_Check): For array types, apply a length\n\tcheck rather than a qualification, to avoid spurious errors when\n\tthe value of a dependend expression has a matching length but\n\tdifferent bounds from those of the type of the contect.\n\ngcc/testsuite/\n\n\t* gnat.dg/array33.adb: New testcase.\n\nFrom-SVN: r266758", "tree": {"sha": "ed5a5e86f58663c1b86be9c8be960cae4e38edd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed5a5e86f58663c1b86be9c8be960cae4e38edd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cddd902d35bfef2bf6cea89b63d6dea23e0babed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cddd902d35bfef2bf6cea89b63d6dea23e0babed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cddd902d35bfef2bf6cea89b63d6dea23e0babed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cddd902d35bfef2bf6cea89b63d6dea23e0babed/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2e8f79193221a772798265b238b11c0549fb9e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e8f79193221a772798265b238b11c0549fb9e40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e8f79193221a772798265b238b11c0549fb9e40"}], "stats": {"total": 116, "additions": 110, "deletions": 6}, "files": [{"sha": "15b5bcffc7ae141593ad9b1aac0d5b59f3846737", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cddd902d35bfef2bf6cea89b63d6dea23e0babed", "patch": "@@ -1,3 +1,10 @@\n+2018-12-03  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Apply_Check): For array types, apply a length\n+\tcheck rather than a qualification, to avoid spurious errors when\n+\tthe value of a dependend expression has a matching length but\n+\tdifferent bounds from those of the type of the contect.\n+\n 2018-12-03  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* libgnat/a-calend.adb: Update the number of leap seconds. Add"}, {"sha": "ab26fbefb509c781a4270e32bb7fff5e4eb46cf4", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=cddd902d35bfef2bf6cea89b63d6dea23e0babed", "patch": "@@ -8461,7 +8461,9 @@ package body Sem_Res is\n       --  When a dependent expression is of a subtype different from\n       --  the context subtype, then insert a qualification to ensure\n       --  the generation of a constraint check. This was previously\n-      --  done only for scalar types.\n+      --  for scalar types. For array types apply a length check, given\n+      --  that the context in general allows sliding, while a qualified\n+      --  expression forces equality of bounds.\n \n       -----------------\n       -- Apply_Check --\n@@ -8472,12 +8474,18 @@ package body Sem_Res is\n          Loc      : constant Source_Ptr := Sloc (Expr);\n \n       begin\n-         if Expr_Typ /= Typ\n-           and then not Is_Tagged_Type (Typ)\n-           and then not Is_Access_Type (Typ)\n-           and then Is_Constrained (Typ)\n-           and then not Inside_A_Generic\n+         if Expr_Typ = Typ\n+           or else Is_Tagged_Type (Typ)\n+           or else Is_Access_Type (Typ)\n+           or else not Is_Constrained (Typ)\n+           or else Inside_A_Generic\n          then\n+            null;\n+\n+         elsif Is_Array_Type (Typ) then\n+            Apply_Length_Check (Expr, Typ);\n+\n+         else\n             Rewrite (Expr,\n               Make_Qualified_Expression (Loc,\n                 Subtype_Mark => New_Occurrence_Of (Typ, Loc),"}, {"sha": "e2b84554e30f5914fc4759e2cea4714a02872390", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cddd902d35bfef2bf6cea89b63d6dea23e0babed", "patch": "@@ -1,3 +1,7 @@\n+2018-12-03  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat.dg/array33.adb: New testcase.\n+\n 2018-12-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/array32.adb, gnat.dg/array32.ads: New testcase."}, {"sha": "3e146748f2137eecd737d237b69c87adff402861", "filename": "gcc/testsuite/gnat.dg/array33.adb", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Ftestsuite%2Fgnat.dg%2Farray33.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cddd902d35bfef2bf6cea89b63d6dea23e0babed/gcc%2Ftestsuite%2Fgnat.dg%2Farray33.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray33.adb?ref=cddd902d35bfef2bf6cea89b63d6dea23e0babed", "patch": "@@ -0,0 +1,85 @@\n+--  { dg-do run }\n+\n+procedure Array33 is\n+  generic\n+    type Item_T is private; -- The type of which the interval is made of.\n+    type Bound_T is private;\n+    None_Bound : Bound_T;\n+    Bounds_Are_Static : Boolean := False;\n+    type Value_T is private;\n+    type Base_Index_T is range <>;\n+  package General_Interval_Partition_G is\n+    subtype Length_T is Base_Index_T range 0 .. Base_Index_T'Last;\n+    subtype Index_T  is Base_Index_T range 1 .. Base_Index_T'Last;\n+    type T is private;\n+    function Single (First, Last : Bound_T; Value : Value_T) return T;\n+    function Single1 (First, Last : Bound_T; Value : Value_T) return T;\n+  private\n+    type Bounds_Array_T is array (Length_T range <>) of Bound_T;\n+    type Values_Array_T is array (Index_T  range <>) of Value_T;\n+\n+    First_Bounds_Index : constant Length_T\n+        := 2 * Boolean'Pos (Bounds_Are_Static);\n+    -- See below explanation on indexing the bounds.\n+\n+\n+    type Obj_T (Length : Length_T) is\n+      record\n+        Bounds : Bounds_Array_T (First_Bounds_Index .. Length)\n+           := (others => None_Bound);\n+        -- This is tricky. If Bounds_Are_Static is true, the array does not\n+        --  store the lower or upper bound.\n+        -- This lowers memory requirements for the data structure at the cost\n+        --  of slightly more complex indexing.\n+        --\n+        -- Bounds as seen internally depending on the parameter:\n+        --\n+        -- Bounds_Are_Static | Lower_Bound | Inbetween Bounds (if any) | Upper_Bound\n+        --     True         => Max_First   & Bounds (2 .. Length)      & Min_Last\n+        --     False        => Bounds (0)  & Bounds (1 .. Length - 1)  & Bounds (Length)\n+        --\n+        Values : Values_Array_T (1 .. Length);\n+      end record;\n+\n+    type T is access Obj_T;\n+    --@@ if ccf:defined(debug_pool) then\n+    --@@! for T'Storage_Pool use Pool_Selection_T'Storage_Pool;\n+    --@@ end if\n+\n+  end General_Interval_Partition_G;\n+\n+  package body General_Interval_Partition_G is\n+\n+    function Single (First, Last : Bound_T; Value : Value_T) return T is\n+    begin\n+      return new Obj_T'(Length => 1,\n+                        Bounds => (if Bounds_Are_Static\n+                                   then (2 .. 0 => None_Bound) \n+                --  Now raises constraint error here\n+                                   else (0 => First, 1 => Last)),\n+                        Values => (1 => Value));\n+    end Single;\n+    function Single1 (First, Last : Bound_T; Value : Value_T) return T is\n+    begin\n+      return new Obj_T'( 1,\n+                         (if Bounds_Are_Static\n+                                   then (2 .. 0 => None_Bound) \n+                --  Now raises constraint error here\n+                                   else (0 => First, 1 => Last)),\n+                        (1 => Value));\n+    end Single1;\n+  end General_Interval_Partition_G;\n+\n+  type T is new Integer;\n+\n+  package Partition is new General_Interval_Partition_G (Item_T            => T,\n+                                                         Bound_T           => T,\n+                                                         None_Bound        => 0,\n+                                                         Bounds_Are_Static => True,\n+                                                         Value_T           => T,\n+                                                         Base_Index_T      => Natural);\n+  X : constant Partition.T := Partition.Single (1,1,1);\n+  Z : constant Partition.T := Partition.Single1 (1,1,1);\n+begin\n+  null;\n+end;"}]}