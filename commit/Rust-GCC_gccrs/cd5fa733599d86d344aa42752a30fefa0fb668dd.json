{"sha": "cd5fa733599d86d344aa42752a30fefa0fb668dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q1ZmE3MzM1OTlkODZkMzQ0YWE0Mjc1MmEzMGZlZmEwZmI2NjhkZA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2020-04-30T06:29:26Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2020-04-30T06:29:26Z"}, "message": "IBM Z: vec_store_len_r/vec_load_len_r fix\n\nThis fixes a problem with the vec_store_len_r intrinsic.  The macros\nmapping the intrinsic to a GCC builtin had the wrong signature.\n\nWith the patch an immediate length operand of vlrl/vstrl is handled\nthe same way as if it was passed in a register to vlrlr/vstrlr.\nValues bigger than 15 always load the full vector.  If it can be\nrecognized that it is in effect a full vector register load or store\nit is now implemented with vl/vst instead.\n\ngcc/ChangeLog:\n\n2020-04-30  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* config/s390/constraints.md (\"j>f\", \"jb4\"): New constraints.\n\t* config/s390/vecintrin.h (vec_load_len_r, vec_store_len_r): Fix\n\tmacro definitions.\n\t* config/s390/vx-builtins.md (\"vlrlrv16qi\", \"vstrlrv16qi\"): Add a\n\tseparate expander.\n\t(\"*vlrlrv16qi\", \"*vstrlrv16qi\"): Add alternative for vl/vst.\n\tChange constraint for vlrl/vstrl to jb4.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-30  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* gcc.target/s390/zvector/vec_load_len_r.c: New test.\n\t* gcc.target/s390/zvector/vec_store_len_r.c: New test.", "tree": {"sha": "ed1e8da868d2704c82a433dcf9c82f3713031a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed1e8da868d2704c82a433dcf9c82f3713031a7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd5fa733599d86d344aa42752a30fefa0fb668dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5fa733599d86d344aa42752a30fefa0fb668dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5fa733599d86d344aa42752a30fefa0fb668dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5fa733599d86d344aa42752a30fefa0fb668dd/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2786c0221b65b443217c7709cbc51e96db1b87e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2786c0221b65b443217c7709cbc51e96db1b87e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2786c0221b65b443217c7709cbc51e96db1b87e1"}], "stats": {"total": 281, "additions": 266, "deletions": 15}, "files": [{"sha": "9de23aaaefaeef0c3d29c5a353da39a74d3d74c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd5fa733599d86d344aa42752a30fefa0fb668dd", "patch": "@@ -1,3 +1,13 @@\n+2020-04-30  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* config/s390/constraints.md (\"j>f\", \"jb4\"): New constraints.\n+\t* config/s390/vecintrin.h (vec_load_len_r, vec_store_len_r): Fix\n+\tmacro definitions.\n+\t* config/s390/vx-builtins.md (\"vlrlrv16qi\", \"vstrlrv16qi\"): Add a\n+\tseparate expander.\n+\t(\"*vlrlrv16qi\", \"*vstrlrv16qi\"): Add alternative for vl/vst.\n+\tChange constraint for vlrl/vstrl to jb4.\n+\n 2020-04-30  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>\n \n \t* var-tracking.c (vt_initialize): Move variables pre and post"}, {"sha": "0b05c5ca729a7d8d8cccb94bb17ba17a837d687d", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=cd5fa733599d86d344aa42752a30fefa0fb668dd", "patch": "@@ -38,6 +38,8 @@\n ;;              matching K constraint\n ;;         jm6: An integer operand with the lowest order 6 bits all ones.\n ;;         jdd: A constant operand that fits into the data section.\n+;;         j>f: An integer operand whose lower 32 bits are greater than or equal to 15\n+;;         jb4: An unsigned constant 4 bit operand.\n ;;    t -- Access registers 36 and 37.\n ;;    v -- Vector registers v0-v31.\n ;;    C -- A signed 8-bit constant (-128..127)\n@@ -425,7 +427,7 @@\n \n \n ;;\n-;; Vector constraints follow.\n+;; Vector and scalar constraints for constant values follow.\n ;;\n \n (define_constraint \"j00\"\n@@ -462,6 +464,16 @@\n   \"@internal An integer operand with the lowest order 6 bits all ones.\"\n   (match_operand 0 \"const_int_6bitset_operand\"))\n \n+(define_constraint \"j>f\"\n+  \"@internal An integer operand whose lower 32 bits are greater than or equal to 15.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned int)(ival & 0xffffffff) >= 15\")))\n+\n+(define_constraint \"jb4\"\n+  \"@internal Constant unsigned integer 4 bit value\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 15\")))\n+\n ;;\n ;; Memory constraints follow.\n ;;"}, {"sha": "8ef4f44bb34a2a2930ce4f27301d62e750ee32ff", "filename": "gcc/config/s390/vecintrin.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Fconfig%2Fs390%2Fvecintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Fconfig%2Fs390%2Fvecintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvecintrin.h?ref=cd5fa733599d86d344aa42752a30fefa0fb668dd", "patch": "@@ -111,8 +111,10 @@ __lcbb(const void *ptr, int bndry)\n #define vec_round(X)  __builtin_s390_vfi((X), 4, 4)\n #define vec_doublee(X) __builtin_s390_vfll((X))\n #define vec_floate(X) __builtin_s390_vflr((X), 0, 0)\n-#define vec_load_len_r(X,Y) __builtin_s390_vlrl((Y),(X))\n-#define vec_store_len_r(X,Y) __builtin_s390_vstrl((Y),(X))\n+#define vec_load_len_r(X,L)\t\t\t\t\\\n+  (__vector unsigned char)__builtin_s390_vlrlr((L),(X))\n+#define vec_store_len_r(X,Y,L) \\\n+  __builtin_s390_vstrlr((__vector signed char)(X),(L),(Y))\n \n #define vec_all_nan(a)\t\t\t\t\t\t\\\n   __extension__ ({\t\t\t\t\t\t\\"}, {"sha": "6f1add02d0b6b2547fd0d268494bb85c8291e411", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=cd5fa733599d86d344aa42752a30fefa0fb668dd", "patch": "@@ -202,16 +202,34 @@\n   \"vlbb\\t%v0,%1,%2\"\n   [(set_attr \"op_type\" \"VRX\")])\n \n-(define_insn \"vlrlrv16qi\"\n-  [(set (match_operand:V16QI              0 \"register_operand\"  \"=v,v\")\n-\t(unspec:V16QI [(match_operand:BLK 2 \"memory_operand\"     \"Q,Q\")\n-\t\t       (match_operand:SI  1 \"nonmemory_operand\"  \"d,C\")]\n+; Vector load rightmost with length\n+\n+(define_expand \"vlrlrv16qi\"\n+  [(set (match_operand:V16QI              0 \"register_operand\"  \"\")\n+\t(unspec:V16QI [(match_operand:BLK 2 \"memory_operand\"    \"\")\n+\t\t       (match_operand:SI  1 \"nonmemory_operand\" \"\")]\n+\t\t      UNSPEC_VEC_LOAD_LEN_R))]\n+  \"TARGET_VXE\"\n+{\n+  /* vlrlr sets all length values beyond 15 to 15.  Emulate the same\n+     behavior for immediate length operands.  vlrl would trigger a\n+     SIGILL for too large immediate operands.  */\n+  if (CONST_INT_P (operands[1])\n+      && (UINTVAL (operands[1]) & 0xffffffff) > 15)\n+    operands[1] = GEN_INT (15);\n+})\n+\n+(define_insn \"*vlrlrv16qi\"\n+  [(set (match_operand:V16QI              0 \"register_operand\"  \"=v,  v,  v\")\n+\t(unspec:V16QI [(match_operand:BLK 2 \"memory_operand\"     \"Q,  R,  Q\")\n+\t\t       (match_operand:SI  1 \"nonmemory_operand\"  \"d,j>f,jb4\")]\n \t\t      UNSPEC_VEC_LOAD_LEN_R))]\n   \"TARGET_VXE\"\n   \"@\n    vlrlr\\t%v0,%1,%2\n+   vl\\t%v0,%2%A2\n    vlrl\\t%v0,%2,%1\"\n-  [(set_attr \"op_type\" \"VRS,VSI\")])\n+  [(set_attr \"op_type\" \"VRS,VRX,VSI\")])\n \n \n ; FIXME: The following two patterns might using vec_merge. But what is\n@@ -545,16 +563,32 @@\n \n ; Vector store rightmost with length\n \n-(define_insn \"vstrlrv16qi\"\n-  [(set (match_operand:BLK                2 \"memory_operand\"    \"=Q,Q\")\n-\t(unspec:BLK [(match_operand:V16QI 0 \"register_operand\"   \"v,v\")\n-\t\t     (match_operand:SI    1 \"nonmemory_operand\"  \"d,C\")]\n+(define_expand \"vstrlrv16qi\"\n+  [(set (match_operand:BLK                2 \"memory_operand\"    \"\")\n+\t(unspec:BLK [(match_operand:V16QI 0 \"register_operand\"  \"\")\n+\t\t     (match_operand:SI    1 \"nonmemory_operand\" \"\")]\n+\t\t    UNSPEC_VEC_STORE_LEN_R))]\n+  \"TARGET_VXE\"\n+{\n+  /* vstrlr sets all length values beyond 15 to 15.  Emulate the same\n+     behavior for immediate length operands.  vstrl would trigger a\n+     SIGILL for too large immediate operands.  */\n+  if (CONST_INT_P (operands[1])\n+      && (UINTVAL (operands[1]) & 0xffffffff) > 15)\n+    operands[1] = GEN_INT (15);\n+})\n+\n+(define_insn \"*vstrlrv16qi\"\n+  [(set (match_operand:BLK                2 \"memory_operand\"    \"=Q,  R,  Q\")\n+\t(unspec:BLK [(match_operand:V16QI 0 \"register_operand\"   \"v,  v,  v\")\n+\t\t     (match_operand:SI    1 \"nonmemory_operand\"  \"d,j>f,jb4\")]\n \t\t    UNSPEC_VEC_STORE_LEN_R))]\n   \"TARGET_VXE\"\n   \"@\n-   vstrlr\\t%v0,%2,%1\n-   vstrl\\t%v0,%1,%2\"\n-  [(set_attr \"op_type\" \"VRS,VSI\")])\n+   vstrlr\\t%v0,%1,%2\n+   vst\\t%v0,%2%A2\n+   vstrl\\t%v0,%2,%1\"\n+  [(set_attr \"op_type\" \"VRS,VRX,VSI\")])\n \n \n "}, {"sha": "9d5944b688669c08957cb838bc120197fe8d13c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd5fa733599d86d344aa42752a30fefa0fb668dd", "patch": "@@ -1,3 +1,8 @@\n+2020-04-30  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* gcc.target/s390/zvector/vec_load_len_r.c: New test.\n+\t* gcc.target/s390/zvector/vec_store_len_r.c: New test.\n+\n 2020-04-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/94704"}, {"sha": "5d22bf61c7c1d9de949ffe609736ebf0af69e4d1", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec_load_len_r.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec_load_len_r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec_load_len_r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec_load_len_r.c?ref=cd5fa733599d86d344aa42752a30fefa0fb668dd", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target s390_vxe2 } */\n+/* { dg-options \"-O3 -mzarch -march=arch13 -mzvector --save-temps\" } */\n+\n+#include <string.h>\n+#include <vecintrin.h>\n+\n+typedef vector unsigned char uv16qi;\n+\n+const unsigned char test_vec[16] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };\n+\n+#define NUM_TEST_LENGTHS 3\n+\n+unsigned int test_len[NUM_TEST_LENGTHS] = { 0, 12, 18 };\n+\n+\n+/* Proceeding from left to right, the specified number (LEN+1) of\n+   bytes from SOURCE are stored right-justified in TARGET.  */\n+void __attribute__((noinline, noclone, target (\"arch=zEC12\")))\n+emul (const unsigned char *source, unsigned char *target, unsigned int len)\n+{\n+  int start = 15 - len;\n+  if (start < 0)\n+    start = 0;\n+  for (int s = 0, t = start; t < 16; s++, t++)\n+    target[t] = source[s];\n+}\n+\n+uv16qi __attribute__((noinline, noclone))\n+vec_load_len_r_reg (const unsigned char *s, unsigned int len)\n+{\n+  return vec_load_len_r (s, len);\n+}\n+\n+void __attribute__((noinline, noclone))\n+vec_load_len_r_mem (const unsigned char *s, uv16qi *t, unsigned int *len)\n+{\n+  *t = vec_load_len_r (s, *len);\n+}\n+\n+#define GEN_CONST_FUNC(CONST)\t\t\t\t\\\n+  static uv16qi inline\t\t\t\t\t\t\\\n+  vec_load_len_r_const##CONST (const unsigned char *s)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    return vec_load_len_r (s, CONST);\t\t\t\\\n+  }\n+\n+#define GEN_CONST_TEST(CONST)\t\t\t\t\\\n+  memset (exp_result, 0, 16);\t\t\t\t\\\n+  emul (test_vec, exp_result, CONST);\t\t\t\\\n+  result = (uv16qi) { 0 };\t\t\t\t\\\n+  result = vec_load_len_r_const##CONST (test_vec);\t\\\n+  if (memcmp ((char*)&result, exp_result, 16) != 0)\t\\\n+    __builtin_abort ();\n+\n+GEN_CONST_FUNC(0)\n+GEN_CONST_FUNC(12)\n+GEN_CONST_FUNC(18)\n+\n+int\n+main ()\n+{\n+  unsigned char exp_result[16];\n+  uv16qi result;\n+\n+  for (int i = 0; i < NUM_TEST_LENGTHS; i++)\n+    {\n+      memset (exp_result, 0, 16);\n+\n+      emul (test_vec, exp_result, test_len[i]);\n+\n+      result = (uv16qi) { 0 };\n+      result = vec_load_len_r_reg (test_vec, test_len[i]);\n+      if (memcmp ((char*)&result, exp_result, 16) != 0)\n+\t__builtin_abort ();\n+\n+      result = (uv16qi) { 0 };\n+      vec_load_len_r_mem (test_vec, &result, &test_len[i]);\n+      if (memcmp ((char*)&result, exp_result, 16) != 0)\n+\t__builtin_abort ();\n+    }\n+\n+  GEN_CONST_TEST(0)\n+  GEN_CONST_TEST(12)\n+  GEN_CONST_TEST(18)\n+\n+  return 0;\n+}\n+\n+/* vec_load_len_r_reg and vec_load_len_r_mem */\n+/* { dg-final { scan-assembler-times \"vlrlr\\t\" 2 } } */\n+\n+/* For the 2 constants.  The 3. should be implemented with vl.  */\n+/* { dg-final { scan-assembler-times \"vlrl\\t\" 2 } } */"}, {"sha": "83ef90a2b102fbcc2c10b57274c2b41ce435602e", "filename": "gcc/testsuite/gcc.target/s390/zvector/vec_store_len_r.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec_store_len_r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fa733599d86d344aa42752a30fefa0fb668dd/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec_store_len_r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fzvector%2Fvec_store_len_r.c?ref=cd5fa733599d86d344aa42752a30fefa0fb668dd", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target s390_vxe2 } */\n+/* { dg-options \"-O3 -mzarch -march=arch13 -mzvector --save-temps\" } */\n+\n+#include <string.h>\n+#include <vecintrin.h>\n+\n+typedef vector unsigned char uv16qi;\n+\n+uv16qi test_vec = (uv16qi){ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };\n+\n+#define NUM_TEST_LENGTHS 3\n+\n+unsigned int test_len[NUM_TEST_LENGTHS] = { 0, 12, 18 };\n+\n+\n+/* Proceeding from left to right, the specified number (LEN+1) of\n+   rightmost bytes from SOURCE are stored in TARGET.  */\n+void __attribute__((noinline, noclone, target (\"arch=zEC12\")))\n+emul (unsigned char *source, unsigned char *target, unsigned int len)\n+{\n+  int start = 15 - len;\n+  if (start < 0)\n+    start = 0;\n+  for (int s = start, t = 0; s < 16; s++, t++)\n+    target[t] = source[s];\n+}\n+\n+void __attribute__((noinline, noclone))\n+vec_store_len_r_reg (uv16qi s, unsigned char *t, unsigned int len)\n+{\n+  vec_store_len_r (s, t, len);\n+}\n+\n+void __attribute__((noinline, noclone))\n+vec_store_len_r_mem (uv16qi *s, unsigned char *t, unsigned int *len)\n+{\n+  vec_store_len_r (*s, t, *len);\n+}\n+\n+#define GEN_CONST_FUNC(CONST)\t\t\t\t\t\\\n+  static void inline\t\t\t\t\t\t\\\n+  vec_store_len_r_const##CONST (uv16qi s, unsigned char *t)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    vec_store_len_r (s, t, CONST);\t\t\t\t\\\n+  }\n+\n+#define GEN_CONST_TEST(CONST)\t\t\t\t\t\\\n+  memset (exp_result, 0, 16);\t\t\t\t\t\\\n+  emul ((unsigned char*)&test_vec, exp_result, CONST);\t\t\\\n+  memset (result, 0, 16);\t\t\t\t\t\\\n+  vec_store_len_r_const##CONST (test_vec, result);\t\t\\\n+  if (memcmp (result, exp_result, 16) != 0)\t\t\t\\\n+    __builtin_abort ();\n+\n+GEN_CONST_FUNC(0)\n+GEN_CONST_FUNC(12)\n+GEN_CONST_FUNC(18)\n+\n+int\n+main ()\n+{\n+  unsigned char exp_result[16];\n+  unsigned char result[16];\n+\n+  for (int i = 0; i < NUM_TEST_LENGTHS; i++)\n+    {\n+      memset (exp_result, 0, 16);\n+\n+      emul ((unsigned char*)&test_vec, exp_result, test_len[i]);\n+\n+      memset (result, 0, 16);\n+      vec_store_len_r_reg (test_vec, result, test_len[i]);\n+      if (memcmp (result, exp_result, 16) != 0)\n+\t__builtin_abort ();\n+\n+      memset (result, 0, 16);\n+      vec_store_len_r_mem (&test_vec, result, &test_len[i]);\n+      if (memcmp (result, exp_result, 16) != 0)\n+\t__builtin_abort ();\n+    }\n+\n+  GEN_CONST_TEST(0)\n+  GEN_CONST_TEST(12)\n+  GEN_CONST_TEST(18)\n+\n+  return 0;\n+}\n+\n+/* vec_store_len_r_reg and vec_store_len_r_mem */\n+/* { dg-final { scan-assembler-times \"vstrlr\\t\" 2 } } */\n+\n+/* For the 2 constants.  The 3. should be implemented with vst.  */\n+/* { dg-final { scan-assembler-times \"vstrl\\t\" 2 } } */"}]}