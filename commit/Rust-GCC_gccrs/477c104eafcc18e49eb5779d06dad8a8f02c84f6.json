{"sha": "477c104eafcc18e49eb5779d06dad8a8f02c84f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc3YzEwNGVhZmNjMThlNDllYjU3NzlkMDZkYWQ4YThmMDJjODRmNg==", "commit": {"author": {"name": "Maxim Kuznetsov", "email": "maxim.kuznetsov@intel.com", "date": "2012-11-19T10:19:20Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2012-11-19T10:19:20Z"}, "message": "md.texi: Document define_subst.\n\n        * doc/md.texi: Document define_subst.\n        * gensupport.c (MAX_OPERANDS): New define.\n        (operand_data): New.\n        (match_operand_entries_in_pattern): New.\n        (used_operands_numbers): New.\n        (subst_true): New.\n        (subst_false): New.\n        (define_subst_queue): New.\n        (define_subst_tail): New.\n        (define_subst_attr_queue): New.\n        (define_subst_attr_tail): New.\n        (has_subst_attribute): New.\n        (subst_pattern_match): New.\n        (get_alternatives_number): New.\n        (alter_output_for_subst_insn): New.\n        (alter_attrs_for_subst_insn): New.\n        (process_substs_on_one_elem): New.\n        (subst_dup): New.\n        (process_define_subst): New.\n        (duplicate_alternatives): New.\n        (duplicate_each_alternative): New.\n        (constraints_handler_t): New typedef.\n        (alter_constraints): New.\n        (adjust_operands_numbers): New.\n        (replace_duplicating_operands_in_pattern): New.\n        (remove_from_queue): New.\n        (process_rtx): Handle define_subst and define_subst_attr.\n        (change_subst_attribute): New.\n        (alter_predicate_for_insn): Fix formatting.\n        (alter_attrs_for_insn): Likewise.\n        (alter_output_for_insn): Likewise.\n        (mark_operands_from_match_dup): New.\n        (mark_operands_used_in_match_dup): New.\n        (find_first_unused_number_of_operand): New.\n        (renumerate_operands_in_pattern): New.\n        (generate_match_dup): New.\n        (check_define_attr_duplicates): New.\n        (init_rtx_reader_args_cb): Add checking for duplicated attrs and\n        processing of define_subst.\n        (read_md_rtx): Handle define_subst.\n        * read-rtl.c (struct subst_attr_to_iter_mapping): New.\n        (substs): New global.\n        (apply_subst_iterator): New.\n        (bind_subst_iter_and_attr): New.\n        (find_subst_iter_by_attr): New.\n        (map_attr_string): Handle subst-iterators.\n        (add_condition_to_rtx): Handle define_subst.\n        (apply_iterators): Likewise.\n        (initialize_iterators): Likewise.\n        (add_define_attr_for_define_subst): New.\n        (add_define_subst_attr): New.\n        (read_subst_mapping): New.\n        (read_rtx): Handle define_subst_attr.\n        (read_rtx_code): Add subst-attributes recognition during reading of\n        strings.\n        * rtl.def (DEFINE_EXPAND): Add vector of attributes.\n        (DEFINE_SUBST): New.\n        (DEFINE_SUBST_ATTR): New.\n\n\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\n\nFrom-SVN: r193618", "tree": {"sha": "752f646619b03ca24f6fb4099068b498294501fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/752f646619b03ca24f6fb4099068b498294501fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/477c104eafcc18e49eb5779d06dad8a8f02c84f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477c104eafcc18e49eb5779d06dad8a8f02c84f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477c104eafcc18e49eb5779d06dad8a8f02c84f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477c104eafcc18e49eb5779d06dad8a8f02c84f6/comments", "author": null, "committer": null, "parents": [{"sha": "d826d5c2092961ffe84e1eb9bf89a8fc894ca9b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d826d5c2092961ffe84e1eb9bf89a8fc894ca9b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d826d5c2092961ffe84e1eb9bf89a8fc894ca9b4"}], "stats": {"total": 1753, "additions": 1724, "deletions": 29}, "files": [{"sha": "410926432166b1333288b50868835bb3956f55f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=477c104eafcc18e49eb5779d06dad8a8f02c84f6", "patch": "@@ -1,3 +1,66 @@\n+2012-11-19  Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n+\t    Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* doc/md.texi: Document define_subst.\n+\t* gensupport.c (MAX_OPERANDS): New define.\n+\t(operand_data): New.\n+\t(match_operand_entries_in_pattern): New.\n+\t(used_operands_numbers): New.\n+\t(subst_true): New.\n+\t(subst_false): New.\n+\t(define_subst_queue): New.\n+\t(define_subst_tail): New.\n+\t(define_subst_attr_queue): New.\n+\t(define_subst_attr_tail): New.\n+\t(has_subst_attribute): New.\n+\t(subst_pattern_match): New.\n+\t(get_alternatives_number): New.\n+\t(alter_output_for_subst_insn): New.\n+\t(alter_attrs_for_subst_insn): New.\n+\t(process_substs_on_one_elem): New.\n+\t(subst_dup): New.\n+\t(process_define_subst): New.\n+\t(duplicate_alternatives): New.\n+\t(duplicate_each_alternative): New.\n+\t(constraints_handler_t): New typedef.\n+\t(alter_constraints): New.\n+\t(adjust_operands_numbers): New.\n+\t(replace_duplicating_operands_in_pattern): New.\n+\t(remove_from_queue): New.\n+\t(process_rtx): Handle define_subst and define_subst_attr.\n+\t(change_subst_attribute): New.\n+\t(alter_predicate_for_insn): Fix formatting.\n+\t(alter_attrs_for_insn): Likewise.\n+\t(alter_output_for_insn): Likewise.\n+\t(mark_operands_from_match_dup): New.\n+\t(mark_operands_used_in_match_dup): New.\n+\t(find_first_unused_number_of_operand): New.\n+\t(renumerate_operands_in_pattern): New.\n+\t(generate_match_dup): New.\n+\t(check_define_attr_duplicates): New.\n+\t(init_rtx_reader_args_cb): Add checking for duplicated attrs and\n+\tprocessing of define_subst.\n+\t(read_md_rtx): Handle define_subst.\n+\t* read-rtl.c (struct subst_attr_to_iter_mapping): New.\n+\t(substs): New global.\n+\t(apply_subst_iterator): New.\n+\t(bind_subst_iter_and_attr): New.\n+\t(find_subst_iter_by_attr): New.\n+\t(map_attr_string): Handle subst-iterators.\n+\t(add_condition_to_rtx): Handle define_subst.\n+\t(apply_iterators): Likewise.\n+\t(initialize_iterators): Likewise.\n+\t(add_define_attr_for_define_subst): New.\n+\t(add_define_subst_attr): New.\n+\t(read_subst_mapping): New.\n+\t(read_rtx): Handle define_subst_attr.\n+\t(read_rtx_code): Add subst-attributes recognition during reading of\n+\tstrings.\n+\t* rtl.def (DEFINE_EXPAND): Add vector of attributes.\n+\t(DEFINE_SUBST): New.\n+\t(DEFINE_SUBST_ATTR): New.\n+\n 2012-11-19  Tom de Vries  <tom@codesourcery.com>\n \n \tPR rtl-optimization/55315"}, {"sha": "297058cf36f4c054d9d6a7772e861b0e858ae83c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=477c104eafcc18e49eb5779d06dad8a8f02c84f6", "patch": "@@ -46,6 +46,8 @@ See the next chapter for information on the C header file.\n * Insn Attributes::     Specifying the value of attributes for generated insns.\n * Conditional Execution::Generating @code{define_insn} patterns for\n                          predication.\n+* Define Subst::\tGenerating @code{define_insn} and @code{define_expand}\n+\t\t\tpatterns from other patterns.\n * Constant Definitions::Defining symbolic constants that can be used in the\n                         md file.\n * Iterators::           Using iterators to generate patterns from a template.\n@@ -6756,6 +6758,10 @@ Usually these statements prepare temporary registers for use as\n internal operands in the RTL template, but they can also generate RTL\n insns directly by calling routines such as @code{emit_insn}, etc.\n Any such insns precede the ones that come from the RTL template.\n+\n+@item\n+Optionally, a vector containing the values of attributes. @xref{Insn\n+Attributes}.\n @end itemize\n \n Every RTL insn emitted by a @code{define_expand} must match some\n@@ -8893,6 +8899,213 @@ generates a new pattern\n @end smallexample\n \n @end ifset\n+@ifset INTERNALS\n+@node Define Subst\n+@section RTL Templates Transformations\n+@cindex define_subst\n+\n+For some hardware architectures there are common cases when the RTL\n+templates for the instructions can be derived from the other RTL\n+templates using simple transformations.  E.g., @file{i386.md} contains\n+an RTL template for the ordinary @code{sub} instruction---\n+@code{*subsi_1}, and for the @code{sub} instruction with subsequent\n+zero-extension---@code{*subsi_1_zext}.  Such cases can be easily\n+implemented by a single meta-template capable of generating a modified\n+case based on the initial one:\n+\n+@findex define_subst\n+@smallexample\n+(define_subst \"@var{name}\"\n+  [@var{input-template}]\n+  \"@var{condition}\"\n+  [@var{output-template}])\n+@end smallexample\n+@var{input-template} is a pattern describing the source RTL template,\n+which will be transformed.\n+\n+@var{condition} is a C expression that is conjunct with the condition\n+from the input-template to generate a condition to be used in the\n+output-template.\n+\n+@var{output-template} is a pattern that will be used in the resulting\n+template.\n+\n+@code{define_subst} mechanism is tightly coupled with the notion of the\n+subst attribute (@xref{Subst Iterators}).  The use of\n+@code{define_subst} is triggered by a reference to a subst attribute in\n+the transforming RTL template.  This reference initiates duplication of\n+the source RTL template and substitution of the attributes with their\n+values.  The source RTL template is left unchanged, while the copy is\n+transformed by @code{define_subst}.  This transformation can fail in the\n+case when the source RTL template is not matched against the\n+input-template of the @code{define_subst}.  In such case the copy is\n+deleted.\n+\n+@code{define_subst} can be used only in @code{define_insn} and\n+@code{define_expand}, it cannot be used in other expressions (e.g. in\n+@code{define_insn_and_split}).\n+\n+@menu\n+* Define Subst Example::\t    Example of @code{define_subst} work.\n+* Define Subst Pattern Matching::   Process of template comparison.\n+* Define Subst Output Template::    Generation of output template.\n+@end menu\n+\n+@node Define Subst Example\n+@subsection @code{define_subst} Example\n+@cindex define_subst\n+\n+To illustrate how @code{define_subst} works, let us examine a simple\n+template transformation.\n+\n+Suppose there are two kinds of instructions: one that touches flags and\n+the other that does not.  The instructions of the second type could be\n+generated with the following @code{define_subst}:\n+\n+@smallexample\n+(define_subst \"add_clobber_subst\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+        (match_operand:SI 1 \"\" \"\"))]\n+  \"\"\n+  [(set (match_dup 0)\n+        (match_dup 1))\n+   (clobber (reg:CC FLAGS_REG))]\n+@end smallexample\n+\n+This @code{define_subst} can be applied to any RTL pattern containing\n+@code{set} of mode SI and generates a copy with clobber when it is\n+applied.\n+\n+Assume there is an RTL template for a @code{max} instruction to be used\n+in @code{define_subst} mentioned above:\n+\n+@smallexample\n+(define_insn \"maxsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (max:SI\n+          (match_operand:SI 1 \"register_operand\" \"r\")\n+          (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"max\\t@{%2, %1, %0|%0, %1, %2@}\"\n+ [@dots{}])\n+@end smallexample\n+\n+To mark the RTL template for @code{define_subst} application,\n+subst-attributes are used.  They should be declared in advance:\n+\n+@smallexample\n+(define_subst_attr \"add_clobber_name\" \"add_clobber_subst\" \"_noclobber\" \"_clobber\")\n+@end smallexample\n+\n+Here @samp{add_clobber_name} is the attribute name,\n+@samp{add_clobber_subst} is the name of the corresponding\n+@code{define_subst}, the third argument (@samp{_noclobber}) is the\n+attribute value that would be substituted into the unchanged version of\n+the source RTL template, and the last argument (@samp{_clobber}) is the\n+value that would be substituted into the second, transformed,\n+version of the RTL template.\n+\n+Once the subst-attribute has been defined, it should be used in RTL\n+templates which need to be processed by the @code{define_subst}.  So,\n+the original RTL template should be changed:\n+\n+@smallexample\n+(define_insn \"maxsi<add_clobber_name>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (max:SI\n+          (match_operand:SI 1 \"register_operand\" \"r\")\n+          (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"max\\t@{%2, %1, %0|%0, %1, %2@}\"\n+ [@dots{}])\n+@end smallexample\n+\n+The result of the @code{define_subst} usage would look like the following:\n+\n+@smallexample\n+(define_insn \"maxsi_noclobber\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (max:SI\n+          (match_operand:SI 1 \"register_operand\" \"r\")\n+          (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"max\\t@{%2, %1, %0|%0, %1, %2@}\"\n+ [@dots{}])\n+(define_insn \"maxsi_clobber\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (max:SI\n+          (match_operand:SI 1 \"register_operand\" \"r\")\n+          (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"max\\t@{%2, %1, %0|%0, %1, %2@}\"\n+ [@dots{}])\n+@end smallexample\n+\n+@node Define Subst Pattern Matching\n+@subsection Pattern Matching in @code{define_subst}\n+@cindex define_subst\n+\n+All expressions, allowed in @code{define_insn} or @code{define_expand},\n+are allowed in the input-template of @code{define_subst}, except\n+@code{match_par_dup}, @code{match_scratch}, @code{match_parallel}. The\n+meanings of expressions in the input-template were changed:\n+\n+@code{match_operand} matches any expression (possibly, a subtree in\n+RTL-template), if modes of the @code{match_operand} and this expression\n+are the same, or mode of the @code{match_operand} is @code{VOIDmode}, or\n+this expression is @code{match_dup}, @code{match_op_dup}.  If the\n+expression is @code{match_operand} too, and predicate of\n+@code{match_operand} from the input pattern is not empty, then the\n+predicates are compared.  That can be used for more accurate filtering\n+of accepted RTL-templates.\n+\n+@code{match_operator} matches common operators (like @code{plus},\n+@code{minus}), @code{unspec}, @code{unspec_volatile} operators and\n+@code{match_operator}s from the original pattern if the modes match and\n+@code{match_operator} from the input pattern has the same number of\n+operands as the operator from the original pattern.\n+\n+@node Define Subst Output Template\n+@subsection Generation of output template in @code{define_subst}\n+@cindex define_subst\n+\n+If all necessary checks for @code{define_subst} application pass, a new\n+RTL-pattern, based on the output-template, is created to replace the old\n+template.  Like in input-patterns, meanings of some RTL expressions are\n+changed when they are used in output-patterns of a @code{define_subst}.\n+Thus, @code{match_dup} is used for copying the whole expression from the\n+original pattern, which matched corresponding @code{match_operand} from\n+the input pattern.\n+\n+@code{match_dup N} is used in the output template to be replaced with\n+the expression from the original pattern, which matched\n+@code{match_operand N} from the input pattern.  As a consequence,\n+@code{match_dup} cannot be used to point to @code{match_operand}s from\n+the output pattern, it should always refer to a @code{match_operand}\n+from the input pattern.\n+\n+In the output template one can refer to the expressions from the\n+original pattern and create new ones.  For instance, some operands could\n+be added by means of standard @code{match_operand}.\n+\n+After replacing @code{match_dup} with some RTL-subtree from the original\n+pattern, it could happen that several @code{match_operand}s in the\n+output pattern have the same indexes.  It is unknown, how many and what\n+indexes would be used in the expression which would replace\n+@code{match_dup}, so such conflicts in indexes are inevitable.  To\n+overcome this issue, @code{match_operands} and @code{match_operators},\n+which were introduced into the output pattern, are renumerated when all\n+@code{match_dup}s are replaced.\n+\n+Number of alternatives in @code{match_operand}s introduced into the\n+output template @code{M} could differ from the number of alternatives in\n+the original pattern @code{N}, so in the resultant pattern there would\n+be @code{N*M} alternatives.  Thus, constraints from the original pattern\n+would be duplicated @code{N} times, constraints from the output pattern\n+would be duplicated @code{M} times, producing all possible combinations.\n+@end ifset\n+\n @ifset INTERNALS\n @node Constant Definitions\n @section Constant Definitions\n@@ -9077,6 +9290,7 @@ facilities to make this process easier.\n * Mode Iterators::         Generating variations of patterns for different modes.\n * Code Iterators::         Doing the same for codes.\n * Int Iterators::          Doing the same for integers.\n+* Subst Iterators::\t   Generating variations of patterns for define_subst.\n @end menu\n \n @node Mode Iterators\n@@ -9425,4 +9639,51 @@ This is equivalent to:\n \n @end smallexample\n \n+@node Subst Iterators\n+@subsection Subst Iterators\n+@cindex subst iterators in @file{.md} files\n+@findex define_subst\n+@findex define_subst_attr\n+\n+Subst iterators are special type of iterators with the following\n+restrictions: they could not be declared explicitly, they always have\n+only two values, and they do not have explicit dedicated name.\n+Subst-iterators are triggered only when corresponding subst-attribute is\n+used in RTL-pattern.\n+\n+Subst iterators transform templates in the following way: the templates\n+are duplicated, the subst-attributes in these templates are replaced\n+with the corresponding values, and a new attribute is implicitly added\n+to the given @code{define_insn}/@code{define_expand}.  The name of the\n+added attribute matches the name of @code{define_subst}.  Such\n+attributes are declared implicitly, and it is not allowed to have a\n+@code{define_attr} named as a @code{define_subst}.\n+\n+Each subst iterator is linked to a @code{define_subst}.  It is declared\n+implicitly by the first appearance of the corresponding\n+@code{define_subst_attr}, and it is not allowed to define it explicitly.\n+\n+Declarations of subst-attributes have the following syntax:\n+\n+@findex define_subst_attr\n+@smallexample\n+(define_subst_attr \"@var{name}\"\n+  \"@var{subst-name}\"\n+  \"@var{no-subst-value}\"\n+  \"@var{subst-applied-value}\")\n+@end smallexample\n+\n+@var{name} is a string with which the given subst-attribute could be\n+referred to.\n+\n+@var{subst-name} shows which @code{define_subst} should be applied to an\n+RTL-template if the given subst-attribute is present in the\n+RTL-template.\n+\n+@var{no-subst-value} is a value with which subst-attribute would be\n+replaced in the first copy of the original RTL-template.\n+\n+@var{subst-applied-value} is a value with which subst-attribute would be\n+replaced in the second copy of the original RTL-template.\n+\n @end ifset"}, {"sha": "00290b00144de5a9bcf1f01527c81cfb876ddd05", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1125, "deletions": 20, "changes": 1145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=477c104eafcc18e49eb5779d06dad8a8f02c84f6", "patch": "@@ -29,6 +29,12 @@\n #include \"read-md.h\"\n #include \"gensupport.h\"\n \n+#define MAX_OPERANDS 40\n+\n+static rtx operand_data[MAX_OPERANDS];\n+static rtx match_operand_entries_in_pattern[MAX_OPERANDS];\n+static char used_operands_numbers[MAX_OPERANDS];\n+\n \n /* In case some macros used by files we include need it, define this here.  */\n int target_flags;\n@@ -48,10 +54,14 @@ static int predicable_default;\n static const char *predicable_true;\n static const char *predicable_false;\n \n+static const char *subst_true = \"yes\";\n+static const char *subst_false = \"no\";\n+\n static htab_t condition_table;\n \n-/* We initially queue all patterns, process the define_insn and\n-   define_cond_exec patterns, then return them one at a time.  */\n+/* We initially queue all patterns, process the define_insn,\n+   define_cond_exec and define_subst patterns, then return\n+   them one at a time.  */\n \n struct queue_elem\n {\n@@ -75,8 +85,12 @@ static struct queue_elem *define_insn_queue;\n static struct queue_elem **define_insn_tail = &define_insn_queue;\n static struct queue_elem *define_cond_exec_queue;\n static struct queue_elem **define_cond_exec_tail = &define_cond_exec_queue;\n+static struct queue_elem *define_subst_queue;\n+static struct queue_elem **define_subst_tail = &define_subst_queue;\n static struct queue_elem *other_queue;\n static struct queue_elem **other_tail = &other_queue;\n+static struct queue_elem *define_subst_attr_queue;\n+static struct queue_elem **define_subst_attr_tail = &define_subst_attr_queue;\n \n static struct queue_elem *queue_pattern (rtx, struct queue_elem ***,\n \t\t\t\t\t const char *, int);\n@@ -99,6 +113,24 @@ static void process_one_cond_exec (struct queue_elem *);\n static void process_define_cond_exec (void);\n static void init_predicate_table (void);\n static void record_insn_name (int, const char *);\n+\n+static bool has_subst_attribute (struct queue_elem *, struct queue_elem *);\n+static bool subst_pattern_match (rtx, rtx, int);\n+static int get_alternatives_number (rtx, int *, int);\n+static const char * alter_output_for_subst_insn (rtx, int);\n+static void alter_attrs_for_subst_insn (struct queue_elem *, int);\n+static void process_substs_on_one_elem (struct queue_elem *,\n+\t\t\t\t\tstruct queue_elem *);\n+static rtx subst_dup (rtx, int, int);\n+static void process_define_subst (void);\n+\n+static const char * duplicate_alternatives (const char *, int);\n+static const char * duplicate_each_alternative (const char * str, int n_dup);\n+\n+typedef const char * (*constraints_handler_t) (const char *, int);\n+static rtx alter_constraints (rtx, int, constraints_handler_t);\n+static rtx adjust_operands_numbers (rtx);\n+static rtx replace_duplicating_operands_in_pattern (rtx);\n \f\n /* Make a version of gen_rtx_CONST_INT so that GEN_INT can be used in\n    the gensupport programs.  */\n@@ -372,6 +404,27 @@ queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n   return e;\n }\n \n+/* Remove element ELEM from QUEUE.  */\n+static void\n+remove_from_queue (struct queue_elem *elem, struct queue_elem **queue)\n+{\n+  struct queue_elem *prev, *e;\n+  prev = NULL;\n+  for (e = *queue; e ; e = e->next)\n+    {\n+      if (e == elem)\n+\tbreak;\n+      prev = e;\n+    }\n+  if (e == NULL)\n+    return;\n+\n+  if (prev)\n+    prev->next = elem->next;\n+  else\n+    *queue = elem->next;\n+}\n+\n /* Build a define_attr for an binary attribute with name NAME and\n    possible values \"yes\" and \"no\", and queue it.  */\n static void\n@@ -439,6 +492,14 @@ process_rtx (rtx desc, int lineno)\n       queue_pattern (desc, &define_cond_exec_tail, read_md_filename, lineno);\n       break;\n \n+    case DEFINE_SUBST:\n+      queue_pattern (desc, &define_subst_tail, read_md_filename, lineno);\n+      break;\n+\n+    case DEFINE_SUBST_ATTR:\n+      queue_pattern (desc, &define_subst_attr_tail, read_md_filename, lineno);\n+      break;\n+\n     case DEFINE_ATTR:\n     case DEFINE_ENUM_ATTR:\n       queue_pattern (desc, &define_attr_tail, read_md_filename, lineno);\n@@ -584,6 +645,267 @@ is_predicable (struct queue_elem *elem)\n   return 0;\n }\n \n+/* Find attribute SUBST in ELEM and assign NEW_VALUE to it.  */\n+static void\n+change_subst_attribute (struct queue_elem *elem,\n+\t\t\tstruct queue_elem *subst_elem,\n+\t\t\tconst char *new_value)\n+{\n+  rtvec attrs_vec = XVEC (elem->data, 4);\n+  const char *subst_name = XSTR (subst_elem->data, 0);\n+  int i;\n+\n+  if (! attrs_vec)\n+    return;\n+\n+  for (i = GET_NUM_ELEM (attrs_vec) - 1; i >= 0; --i)\n+    {\n+      rtx cur_attr = RTVEC_ELT (attrs_vec, i);\n+      if (GET_CODE (cur_attr) != SET_ATTR)\n+\tcontinue;\n+      if (strcmp (XSTR (cur_attr, 0), subst_name) == 0)\n+\t{\n+\t  XSTR (cur_attr, 1) = new_value;\n+\t  return;\n+\t}\n+    }\n+}\n+\n+/* Return true if ELEM has the attribute with the name of DEFINE_SUBST\n+   represented by SUBST_ELEM and this attribute has value SUBST_TRUE.\n+   DEFINE_SUBST isn't applied to patterns without such attribute.  In other\n+   words, we suppose the default value of the attribute to be 'no' since it is\n+   always generated automaticaly in read-rtl.c.  */\n+static bool\n+has_subst_attribute (struct queue_elem *elem, struct queue_elem *subst_elem)\n+{\n+  rtvec attrs_vec = XVEC (elem->data, 4);\n+  const char *value, *subst_name = XSTR (subst_elem->data, 0);\n+  int i;\n+\n+  if (! attrs_vec)\n+    return false;\n+\n+  for (i = GET_NUM_ELEM (attrs_vec) - 1; i >= 0; --i)\n+    {\n+      rtx cur_attr = RTVEC_ELT (attrs_vec, i);\n+      switch (GET_CODE (cur_attr))\n+\t{\n+\tcase SET_ATTR:\n+\t  if (strcmp (XSTR (cur_attr, 0), subst_name) == 0)\n+\t    {\n+\t      value = XSTR (cur_attr, 1);\n+\t      goto found;\n+\t    }\n+\t  break;\n+\n+\tcase SET:\n+\t  if (GET_CODE (SET_DEST (cur_attr)) != ATTR\n+\t      || strcmp (XSTR (SET_DEST (cur_attr), 0), subst_name) != 0)\n+\t    break;\n+\t  cur_attr = SET_SRC (cur_attr);\n+\t  if (GET_CODE (cur_attr) == CONST_STRING)\n+\t    {\n+\t      value = XSTR (cur_attr, 0);\n+\t      goto found;\n+\t    }\n+\n+\t  /* Only (set_attr \"subst\" \"yes/no\") and\n+\t\t  (set (attr \"subst\" (const_string \"yes/no\")))\n+\t     are currently allowed.  */\n+\t  error_with_line (elem->lineno,\n+\t\t\t   \"unsupported value for `%s'\", subst_name);\n+\t  return false;\n+\n+\tcase SET_ATTR_ALTERNATIVE:\n+\t  error_with_line (elem->lineno,\n+\t\t\t   \"%s: `set_attr_alternative' is unsupported by \"\n+\t\t\t   \"`define_subst'\",\n+\t\t\t   XSTR (elem->data, 0));\n+\t  return false;\n+\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return false;\n+\n+ found:\n+  if (strcmp (value, subst_true) == 0)\n+    return true;\n+  if (strcmp (value, subst_false) == 0)\n+    return false;\n+\n+  error_with_line (elem->lineno,\n+\t\t   \"unknown value `%s' for `%s' attribute\", value, subst_name);\n+  return false;\n+}\n+\n+/* Compare RTL-template of original define_insn X to input RTL-template of\n+   define_subst PT.  Return 1 if the templates match, 0 otherwise.\n+   During the comparison, the routine also fills global_array OPERAND_DATA.  */\n+static bool\n+subst_pattern_match (rtx x, rtx pt, int lineno)\n+{\n+  RTX_CODE code, code_pt;\n+  int i, j, len;\n+  const char *fmt, *pred_name;\n+\n+  code = GET_CODE (x);\n+  code_pt = GET_CODE (pt);\n+\n+  if (code_pt == MATCH_OPERAND)\n+    {\n+      /* MATCH_DUP, and MATCH_OP_DUP don't have a specified mode, so we\n+\t always accept them.  */\n+      if (GET_MODE (pt) != VOIDmode && GET_MODE (x) != GET_MODE (pt)\n+\t  && (code != MATCH_DUP && code != MATCH_OP_DUP))\n+\treturn false; /* Modes don't match.  */\n+\n+      if (code == MATCH_OPERAND)\n+\t{\n+\t  pred_name = XSTR (pt, 1);\n+\t  if (pred_name[0] != 0)\n+\t    {\n+\t      const struct pred_data *pred_pt = lookup_predicate (pred_name);\n+\t      if (!pred_pt || pred_pt != lookup_predicate (XSTR (x, 1)))\n+\t\treturn false; /* Predicates don't match.  */\n+\t    }\n+\t}\n+\n+      gcc_assert (XINT (pt, 0) >= 0 && XINT (pt, 0) < MAX_OPERANDS);\n+      operand_data[XINT (pt, 0)] = x;\n+      return true;\n+    }\n+\n+  if (code_pt == MATCH_OPERATOR)\n+    {\n+      int x_vecexp_pos = -1;\n+\n+      /* Compare modes.  */\n+      if (GET_MODE (pt) != VOIDmode && GET_MODE (x) != GET_MODE (pt))\n+\treturn false;\n+\n+      /* In case X is also match_operator, compare predicates.  */\n+      if (code == MATCH_OPERATOR)\n+\t{\n+\t  pred_name = XSTR (pt, 1);\n+\t  if (pred_name[0] != 0)\n+\t    {\n+\t      const struct pred_data *pred_pt = lookup_predicate (pred_name);\n+\t      if (!pred_pt || pred_pt != lookup_predicate (XSTR (x, 1)))\n+\t\treturn false;\n+\t    }\n+\t}\n+\n+      /* Compare operands.\n+\t MATCH_OPERATOR in input template could match in original template\n+\t either 1) MATCH_OPERAND, 2) UNSPEC, 3) ordinary operation (like PLUS).\n+\t In the first case operands are at (XVECEXP (x, 2, j)), in the second\n+\t - at (XVECEXP (x, 0, j)), in the last one - (XEXP (x, j)).\n+\t X_VECEXP_POS variable shows, where to look for these operands.  */\n+      if (code == UNSPEC\n+\t  || code == UNSPEC_VOLATILE)\n+\tx_vecexp_pos = 0;\n+      else if (code == MATCH_OPERATOR)\n+\tx_vecexp_pos = 2;\n+      else\n+\tx_vecexp_pos = -1;\n+\n+      /* MATCH_OPERATOR or UNSPEC case.  */\n+      if (x_vecexp_pos >= 0)\n+\t{\n+\t  /* Compare operands number in X and PT.  */\n+\t  if (XVECLEN (x, x_vecexp_pos) != XVECLEN (pt, 2))\n+\t    return false;\n+\t  for (j = 0; j < XVECLEN (pt, 2); j++)\n+\t    if (!subst_pattern_match (XVECEXP (x, x_vecexp_pos, j),\n+\t\t\t\t      XVECEXP (pt, 2, j), lineno))\n+\t      return false;\n+\t}\n+\n+      /* Ordinary operator.  */\n+      else\n+\t{\n+\t  /* Compare operands number in X and PT.\n+\t     We count operands differently for X and PT since we compare\n+\t     an operator (with operands directly in RTX) and MATCH_OPERATOR\n+\t     (that has a vector with operands).  */\n+\t  if (GET_RTX_LENGTH (code) != XVECLEN (pt, 2))\n+\t    return false;\n+\t  for (j = 0; j < XVECLEN (pt, 2); j++)\n+\t    if (!subst_pattern_match (XEXP (x, j), XVECEXP (pt, 2, j), lineno))\n+\t      return false;\n+\t}\n+\n+      /* Store the operand to OPERAND_DATA array.  */\n+      gcc_assert (XINT (pt, 0) >= 0 && XINT (pt, 0) < MAX_OPERANDS);\n+      operand_data[XINT (pt, 0)] = x;\n+      return true;\n+    }\n+\n+  if (code_pt == MATCH_PAR_DUP\n+      || code_pt == MATCH_DUP\n+      || code_pt == MATCH_OP_DUP\n+      || code_pt == MATCH_SCRATCH\n+      || code_pt == MATCH_PARALLEL)\n+    {\n+      /* Currently interface for these constructions isn't defined -\n+\t probably they aren't needed in input template of define_subst at all.\n+\t So, for now their usage in define_subst is forbidden.  */\n+      error_with_line (lineno, \"%s cannot be used in define_subst\",\n+\t\t       GET_RTX_NAME (code_pt));\n+    }\n+\n+  gcc_assert (code != MATCH_PAR_DUP\n+      && code_pt != MATCH_DUP\n+      && code_pt != MATCH_OP_DUP\n+      && code_pt != MATCH_SCRATCH\n+      && code_pt != MATCH_PARALLEL\n+      && code_pt != MATCH_OPERAND\n+      && code_pt != MATCH_OPERATOR);\n+  /* If PT is none of the handled above, then we match only expressions with\n+     the same code in X.  */\n+  if (code != code_pt)\n+    return false;\n+\n+  fmt = GET_RTX_FORMAT (code_pt);\n+  len = GET_RTX_LENGTH (code_pt);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      if (fmt[i] == '0')\n+\tbreak;\n+\n+      switch (fmt[i])\n+\t{\n+\tcase 'i': case 'w': case 's':\n+\t  continue;\n+\n+\tcase 'e': case 'u':\n+\t  if (!subst_pattern_match (XEXP (x, i), XEXP (pt, i), lineno))\n+\t    return false;\n+\t  break;\n+\tcase 'E':\n+\t  {\n+\t    if (XVECLEN (x, i) != XVECLEN (pt, i))\n+\t      return false;\n+\t    for (j = 0; j < XVECLEN (pt, i); j++)\n+\t      if (!subst_pattern_match (XVECEXP (x, i, j), XVECEXP (pt, i, j),\n+\t\t\t\t\tlineno))\n+\t\treturn false;\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* Examine the attribute \"predicable\"; discover its boolean values\n    and its default.  */\n \n@@ -662,6 +984,78 @@ n_alternatives (const char *s)\n   return n;\n }\n \n+/* The routine scans rtl PATTERN, find match_operand in it and counts\n+   number of alternatives.  If PATTERN contains several match_operands\n+   with different number of alternatives, error is emitted, and the\n+   routine returns 0.  If all match_operands in PATTERN have the same\n+   number of alternatives, it's stored in N_ALT, and the routine returns 1.\n+   Argument LINENO is used in when the error is emitted.  */\n+static int\n+get_alternatives_number (rtx pattern, int *n_alt, int lineno)\n+{\n+  const char *fmt;\n+  enum rtx_code code;\n+  int i, j, len;\n+\n+  if (!n_alt)\n+    return 0;\n+\n+  code = GET_CODE (pattern);\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+      i = n_alternatives (XSTR (pattern, 2));\n+      /* n_alternatives returns 1 if constraint string is empty -\n+\t here we fix it up.  */\n+      if (!*(XSTR (pattern, 2)))\n+\ti = 0;\n+      if (*n_alt <= 0)\n+\t*n_alt = i;\n+\n+      else if (i && i != *n_alt)\n+\t{\n+\t  error_with_line (lineno,\n+\t\t\t   \"wrong number of alternatives in operand %d\",\n+\t\t\t   XINT (pattern, 0));\n+\t  return 0;\n+\t}\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  if (!get_alternatives_number (XEXP (pattern, i), n_alt, lineno))\n+\t\treturn 0;\n+\t  break;\n+\n+\tcase 'V':\n+\t  if (XVEC (pattern, i) == NULL)\n+\t    break;\n+\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    if (!get_alternatives_number (XVECEXP (pattern, i, j),\n+\t\t\t\t\t  n_alt, lineno))\n+\t\treturn 0;\n+\t  break;\n+\n+\tcase 'i': case 'w': case '0': case 's': case 'S': case 'T':\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+    return 1;\n+}\n+\n /* Determine how many alternatives there are in INSN, and how many\n    operands.  */\n \n@@ -746,7 +1140,7 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n \t  {\n \t    size_t c_len = strlen (c);\n \t    size_t len = alt * (c_len + 1);\n-\t    char *new_c = XNEWVEC(char, len);\n+\t    char *new_c = XNEWVEC (char, len);\n \n \t    memcpy (new_c, c, c_len);\n \t    for (i = 1; i < alt; ++i)\n@@ -806,6 +1200,64 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n   return pattern;\n }\n \n+/* Duplicate constraints in PATTERN.  If pattern is from original\n+   rtl-template, we need to duplicate each alternative - for that we\n+   need to use duplicate_each_alternative () as a functor ALTER.\n+   If pattern is from output-pattern of define_subst, we need to\n+   duplicate constraints in another way - with duplicate_alternatives ().\n+   N_DUP is multiplication factor.  */\n+static rtx\n+alter_constraints (rtx pattern, int n_dup, constraints_handler_t alter)\n+{\n+  const char *fmt;\n+  enum rtx_code code;\n+  int i, j, len;\n+\n+  code = GET_CODE (pattern);\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+      XSTR (pattern, 2) = alter (XSTR (pattern, 2), n_dup);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      rtx r;\n+\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  r = alter_constraints (XEXP (pattern, i), n_dup, alter);\n+\t  if (r == NULL)\n+\t    return r;\n+\t  break;\n+\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    {\n+\t      r = alter_constraints (XVECEXP (pattern, i, j), n_dup, alter);\n+\t      if (r == NULL)\n+\t\treturn r;\n+\t    }\n+\t  break;\n+\n+\tcase 'i': case 'w': case '0': case 's':\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  return pattern;\n+}\n+\n static const char *\n alter_test_for_insn (struct queue_elem *ce_elem,\n \t\t     struct queue_elem *insn_elem)\n@@ -920,7 +1372,7 @@ alter_attrs_for_insn (rtx insn)\n   if (!global_changes_made)\n     {\n       struct queue_elem *elem;\n-      \n+\n       global_changes_made = true;\n       add_define_attr (\"ce_enabled\");\n       add_define_attr (\"nonce_enabled\");\n@@ -954,23 +1406,63 @@ alter_attrs_for_insn (rtx insn)\n   XVEC (insn, 4) = new_vec;\n }\n \n-/* Adjust all of the operand numbers in SRC to match the shift they'll\n-   get from an operand displacement of DISP.  Return a pointer after the\n-   adjusted string.  */\n-\n-static char *\n-shift_output_template (char *dest, const char *src, int disp)\n+/* As number of constraints is changed after define_subst, we need to\n+   process attributes as well - we need to duplicate them the same way\n+   that we duplicated constraints in original pattern\n+   ELEM is a queue element, containing our rtl-template,\n+   N_DUP - multiplication factor.  */\n+static void\n+alter_attrs_for_subst_insn (struct queue_elem * elem, int n_dup)\n {\n-  while (*src)\n+  rtvec vec = XVEC (elem->data, 4);\n+  int num_elem;\n+  int i;\n+\n+  if (n_dup < 2 || ! vec)\n+    return;\n+\n+  num_elem = GET_NUM_ELEM (vec);\n+  for (i = num_elem - 1; i >= 0; --i)\n     {\n-      char c = *src++;\n-      *dest++ = c;\n-      if (c == '%')\n+      rtx sub = RTVEC_ELT (vec, i);\n+      switch (GET_CODE (sub))\n \t{\n-\t  c = *src++;\n-\t  if (ISDIGIT ((unsigned char) c))\n-\t    c += disp;\n-\t  else if (ISALPHA (c))\n+\tcase SET_ATTR:\n+\t  if (strchr (XSTR (sub, 1), ',') != NULL)\n+\t    XSTR (sub, 1) = duplicate_alternatives (XSTR (sub, 1), n_dup);\n+\t    break;\n+\n+\tcase SET_ATTR_ALTERNATIVE:\n+\tcase SET:\n+\t  error_with_line (elem->lineno,\n+\t\t\t   \"%s: `define_subst' does not support attributes \"\n+\t\t\t   \"assigned by `set' and `set_attr_alternative'\",\n+\t\t\t   XSTR (elem->data, 0));\n+\t  return;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+/* Adjust all of the operand numbers in SRC to match the shift they'll\n+   get from an operand displacement of DISP.  Return a pointer after the\n+   adjusted string.  */\n+\n+static char *\n+shift_output_template (char *dest, const char *src, int disp)\n+{\n+  while (*src)\n+    {\n+      char c = *src++;\n+      *dest++ = c;\n+      if (c == '%')\n+\t{\n+\t  c = *src++;\n+\t  if (ISDIGIT ((unsigned char) c))\n+\t    c += disp;\n+\t  else if (ISALPHA (c))\n \t    {\n \t      *dest++ = c;\n \t      c = *src++ + disp;\n@@ -1008,7 +1500,7 @@ alter_output_for_insn (struct queue_elem *ce_elem,\n   if (*insn_out == '@')\n     {\n       len = (ce_len + 1) * alt + insn_len + 1;\n-      p = result = XNEWVEC(char, len);\n+      p = result = XNEWVEC (char, len);\n \n       do\n \t{\n@@ -1042,6 +1534,136 @@ alter_output_for_insn (struct queue_elem *ce_elem,\n   return result;\n }\n \n+/* From string STR \"a,b,c\" produce \"a,b,c,a,b,c,a,b,c\", i.e. original\n+   string, duplicated N_DUP times.  */\n+\n+static const char *\n+duplicate_alternatives (const char * str, int n_dup)\n+{\n+  int i, len, new_len;\n+  char *result, *sp;\n+  const char *cp;\n+\n+  if (n_dup < 2)\n+    return str;\n+\n+  while (ISSPACE (*str))\n+    str++;\n+\n+  if (*str == '\\0')\n+    return str;\n+\n+  cp = str;\n+  len = strlen (str);\n+  new_len = (len + 1) * n_dup;\n+\n+  sp = result = XNEWVEC (char, new_len);\n+\n+  /* Global modifier characters mustn't be duplicated: skip if found.  */\n+  if (*cp == '=' || *cp == '+' || *cp == '%')\n+    {\n+      *sp++ = *cp++;\n+      len--;\n+    }\n+\n+  /* Copy original constraints N_DUP times.  */\n+  for (i = 0; i < n_dup; i++, sp += len+1)\n+    {\n+      memcpy (sp, cp, len);\n+      *(sp+len) = (i == n_dup - 1) ? '\\0' : ',';\n+    }\n+\n+  return result;\n+}\n+\n+/* From string STR \"a,b,c\" produce \"a,a,a,b,b,b,c,c,c\", i.e. string where\n+   each alternative from the original string is duplicated N_DUP times.  */\n+static const char *\n+duplicate_each_alternative (const char * str, int n_dup)\n+{\n+  int i, len, new_len;\n+  char *result, *sp, *ep, *cp;\n+\n+  if (n_dup < 2)\n+    return str;\n+\n+  while (ISSPACE (*str))\n+    str++;\n+\n+  if (*str == '\\0')\n+    return str;\n+\n+  cp = xstrdup (str);\n+\n+  new_len = (strlen (cp) + 1) * n_dup;\n+\n+  sp = result = XNEWVEC (char, new_len);\n+\n+  /* Global modifier characters mustn't be duplicated: skip if found.  */\n+  if (*cp == '=' || *cp == '+' || *cp == '%')\n+      *sp++ = *cp++;\n+\n+  do\n+    {\n+      if ((ep = strchr (cp, ',')) != NULL)\n+\t*ep++ = '\\0';\n+      len = strlen (cp);\n+\n+      /* Copy a constraint N_DUP times.  */\n+      for (i = 0; i < n_dup; i++, sp += len + 1)\n+\t{\n+\t  memcpy (sp, cp, len);\n+\t  *(sp+len) = (ep == NULL && i == n_dup - 1) ? '\\0' : ',';\n+\t}\n+\n+      cp = ep;\n+    }\n+  while (cp != NULL);\n+\n+  return result;\n+}\n+\n+/* Alter the output of INSN whose pattern was modified by\n+   DEFINE_SUBST.  We must replicate output strings according\n+   to the new number of alternatives ALT in substituted pattern.\n+   If ALT equals 1, output has one alternative or defined by C\n+   code, then output is returned without any changes.  */\n+\n+static const char *\n+alter_output_for_subst_insn (rtx insn, int alt)\n+{\n+  const char *insn_out, *sp ;\n+  char *old_out, *new_out, *cp;\n+  int i, j, new_len;\n+\n+  insn_out = XTMPL (insn, 3);\n+\n+  if (alt < 2 || *insn_out == '*' || *insn_out != '@')\n+    return insn_out;\n+\n+  old_out = XNEWVEC (char, strlen (insn_out)),\n+  sp = insn_out;\n+\n+  while (ISSPACE (*sp) || *sp == '@')\n+    sp++;\n+\n+  for (i = 0; *sp;)\n+    old_out[i++] = *sp++;\n+\n+  new_len = alt * (i + 1) + 1;\n+\n+  new_out = XNEWVEC (char, new_len);\n+  new_out[0] = '@';\n+\n+  for (j = 0, cp = new_out + 1; j < alt; j++, cp += i + 1)\n+    {\n+      memcpy (cp, old_out, i);\n+      *(cp+i) = (j == alt - 1) ? '\\0' : '\\n';\n+    }\n+\n+  return new_out;\n+}\n+\n /* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */\n \n static void\n@@ -1151,6 +1773,413 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n     }\n }\n \n+/* Try to apply define_substs to the given ELEM.\n+   Only define_substs, specified via attributes would be applied.\n+   If attribute, requiring define_subst, is set, but no define_subst\n+   was applied, ELEM would be deleted.  */\n+\n+static void\n+process_substs_on_one_elem (struct queue_elem *elem,\n+\t\t\t    struct queue_elem *queue)\n+{\n+  struct queue_elem *subst_elem;\n+  int i, j, patterns_match;\n+\n+  for (subst_elem = define_subst_queue;\n+       subst_elem; subst_elem = subst_elem->next)\n+    {\n+      int alternatives, alternatives_subst;\n+      rtx subst_pattern;\n+      rtvec subst_pattern_vec;\n+\n+      if (!has_subst_attribute (elem, subst_elem))\n+\tcontinue;\n+\n+      /* Compare original rtl-pattern from define_insn with input\n+\t pattern from define_subst.\n+\t Also, check if numbers of alternatives are the same in all\n+\t match_operands.  */\n+      if (XVECLEN (elem->data, 1) != XVECLEN (subst_elem->data, 1))\n+\tcontinue;\n+      patterns_match = 1;\n+      alternatives = -1;\n+      alternatives_subst = -1;\n+      for (j = 0; j < XVECLEN (elem->data, 1); j++)\n+\t{\n+\t  if (!subst_pattern_match (XVECEXP (elem->data, 1, j),\n+\t\t\t\t    XVECEXP (subst_elem->data, 1, j),\n+\t\t\t\t    subst_elem->lineno))\n+\t    {\n+\t      patterns_match = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (!get_alternatives_number (XVECEXP (elem->data, 1, j),\n+\t\t\t\t\t&alternatives, subst_elem->lineno))\n+\t    {\n+\t      patterns_match = 0;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* Check if numbers of alternatives are the same in all\n+\t match_operands in output template of define_subst.  */\n+      for (j = 0; j < XVECLEN (subst_elem->data, 3); j++)\n+\t{\n+\t  if (!get_alternatives_number (XVECEXP (subst_elem->data, 3, j),\n+\t\t\t\t\t&alternatives_subst,\n+\t\t\t\t\tsubst_elem->lineno))\n+\t    {\n+\t      patterns_match = 0;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (!patterns_match)\n+\tcontinue;\n+\n+      /* Clear array in which we save occupied indexes of operands.  */\n+      memset (used_operands_numbers, 0, sizeof (used_operands_numbers));\n+\n+      /* Create a pattern, based on the output one from define_subst.  */\n+      subst_pattern_vec = rtvec_alloc (XVECLEN (subst_elem->data, 3));\n+      for (j = 0; j < XVECLEN (subst_elem->data, 3); j++)\n+\t{\n+\t  subst_pattern = copy_rtx (XVECEXP (subst_elem->data, 3, j));\n+\n+\t  /* Duplicate constraints in substitute-pattern.  */\n+\t  subst_pattern = alter_constraints (subst_pattern, alternatives,\n+\t\t\t\t\t     duplicate_each_alternative);\n+\n+\t  subst_pattern = adjust_operands_numbers (subst_pattern);\n+\n+\t  /* Substitute match_dup and match_op_dup in the new pattern and\n+\t     duplicate constraints.  */\n+\t  subst_pattern = subst_dup (subst_pattern, alternatives,\n+\t\t\t\t     alternatives_subst);\n+\n+\t  replace_duplicating_operands_in_pattern (subst_pattern);\n+\n+\t  /* We don't need any constraints in DEFINE_EXPAND.  */\n+\t  if (GET_CODE (elem->data) == DEFINE_EXPAND)\n+\t    remove_constraints (subst_pattern);\n+\n+\t  RTVEC_ELT (subst_pattern_vec, j) = subst_pattern;\n+\t}\n+      XVEC (elem->data, 1) = subst_pattern_vec;\n+\n+      for (i = 0; i < MAX_OPERANDS; i++)\n+\t  match_operand_entries_in_pattern[i] = NULL;\n+\n+      if (GET_CODE (elem->data) == DEFINE_INSN)\n+\t{\n+\t  XTMPL (elem->data, 3) =\n+\t    alter_output_for_subst_insn (elem->data, alternatives_subst);\n+\t  alter_attrs_for_subst_insn (elem, alternatives_subst);\n+\t}\n+\n+      /* Recalculate condition, joining conditions from original and\n+\t DEFINE_SUBST input patterns.  */\n+      XSTR (elem->data, 2) = join_c_conditions (XSTR (subst_elem->data, 2),\n+\t\t\t\t\t\tXSTR (elem->data, 2));\n+      /* Mark that subst was applied by changing attribute from \"yes\"\n+\t to \"no\".  */\n+      change_subst_attribute (elem, subst_elem, subst_false);\n+    }\n+\n+  /* If ELEM contains a subst attribute with value \"yes\", then we\n+     expected that a subst would be applied, but it wasn't - so,\n+     we need to remove that elementto avoid duplicating.  */\n+  for (subst_elem = define_subst_queue;\n+       subst_elem; subst_elem = subst_elem->next)\n+    {\n+      if (has_subst_attribute (elem, subst_elem))\n+\t{\n+\t  remove_from_queue (elem, &queue);\n+\t  return;\n+\t}\n+    }\n+}\n+\n+/* This is a subroutine of mark_operands_used_in_match_dup.\n+   This routine is marks all MATCH_OPERANDs inside PATTERN as occupied.  */\n+static void\n+mark_operands_from_match_dup (rtx pattern)\n+{\n+  const char *fmt;\n+  int i, j, len, opno;\n+\n+  if (GET_CODE (pattern) == MATCH_OPERAND\n+      || GET_CODE (pattern) == MATCH_OPERATOR\n+      || GET_CODE (pattern) == MATCH_PARALLEL)\n+    {\n+      opno = XINT (pattern, 0);\n+      gcc_assert (opno >= 0 && opno < MAX_OPERANDS);\n+      used_operands_numbers [opno] = 1;\n+    }\n+  fmt = GET_RTX_FORMAT (GET_CODE (pattern));\n+  len = GET_RTX_LENGTH (GET_CODE (pattern));\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  mark_operands_from_match_dup (XEXP (pattern, i));\n+\t  break;\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    mark_operands_from_match_dup (XVECEXP (pattern, i, j));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* This is a subroutine of adjust_operands_numbers.\n+   It goes through all expressions in PATTERN and when MATCH_DUP is\n+   met, all MATCH_OPERANDs inside it is marked as occupied.  The\n+   process of marking is done by routin mark_operands_from_match_dup.  */\n+static void\n+mark_operands_used_in_match_dup (rtx pattern)\n+{\n+  const char *fmt;\n+  int i, j, len, opno;\n+\n+  if (GET_CODE (pattern) == MATCH_DUP)\n+    {\n+      opno = XINT (pattern, 0);\n+      gcc_assert (opno >= 0 && opno < MAX_OPERANDS);\n+      mark_operands_from_match_dup (operand_data[opno]);\n+      return;\n+    }\n+  fmt = GET_RTX_FORMAT (GET_CODE (pattern));\n+  len = GET_RTX_LENGTH (GET_CODE (pattern));\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  mark_operands_used_in_match_dup (XEXP (pattern, i));\n+\t  break;\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    mark_operands_used_in_match_dup (XVECEXP (pattern, i, j));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* This is subroutine of renumerate_operands_in_pattern.\n+   It finds first not-occupied operand-index.  */\n+static int\n+find_first_unused_number_of_operand ()\n+{\n+  int i;\n+  for (i = 0; i < MAX_OPERANDS; i++)\n+    if (!used_operands_numbers[i])\n+      return i;\n+  return MAX_OPERANDS;\n+}\n+\n+/* This is subroutine of adjust_operands_numbers.\n+   It visits all expressions in PATTERN and assigns not-occupied\n+   operand indexes to MATCH_OPERANDs and MATCH_OPERATORs of this\n+   PATTERN.  */\n+static void\n+renumerate_operands_in_pattern (rtx pattern)\n+{\n+  const char *fmt;\n+  enum rtx_code code;\n+  int i, j, len, new_opno;\n+  code = GET_CODE (pattern);\n+\n+  if (code == MATCH_OPERAND\n+      || code == MATCH_OPERATOR)\n+    {\n+      new_opno = find_first_unused_number_of_operand ();\n+      gcc_assert (new_opno >= 0 && new_opno < MAX_OPERANDS);\n+      XINT (pattern, 0) = new_opno;\n+      used_operands_numbers [new_opno] = 1;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (pattern));\n+  len = GET_RTX_LENGTH (GET_CODE (pattern));\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  renumerate_operands_in_pattern (XEXP (pattern, i));\n+\t  break;\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    renumerate_operands_in_pattern (XVECEXP (pattern, i, j));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* If output pattern of define_subst contains MATCH_DUP, then this\n+   expression would be replaced with the pattern, matched with\n+   MATCH_OPERAND from input pattern.  This pattern could contain any\n+   number of MATCH_OPERANDs, MATCH_OPERATORs etc., so it's possible\n+   that a MATCH_OPERAND from output_pattern (if any) would have the\n+   same number, as MATCH_OPERAND from copied pattern.  To avoid such\n+   indexes overlapping, we assign new indexes to MATCH_OPERANDs,\n+   laying in the output pattern outside of MATCH_DUPs.  */\n+static rtx\n+adjust_operands_numbers (rtx pattern)\n+{\n+  mark_operands_used_in_match_dup (pattern);\n+\n+  renumerate_operands_in_pattern (pattern);\n+\n+  return pattern;\n+}\n+\n+/* Generate RTL expression\n+   (match_dup OPNO)\n+   */\n+static rtx\n+generate_match_dup (int opno)\n+{\n+  rtx return_rtx = rtx_alloc (MATCH_DUP);\n+  PUT_CODE (return_rtx, MATCH_DUP);\n+  XINT (return_rtx, 0) = opno;\n+  return return_rtx;\n+}\n+\n+/* This routine checks all match_operands in PATTERN and if some of\n+   have the same index, it replaces all of them except the first one  to\n+   match_dup.\n+   Usually, match_operands with the same indexes are forbidden, but\n+   after define_subst copy an RTL-expression from original template,\n+   indexes of existed and just-copied match_operands could coincide.\n+   To fix it, we replace one of them with match_dup.  */\n+static rtx\n+replace_duplicating_operands_in_pattern (rtx pattern)\n+{\n+  const char *fmt;\n+  int i, j, len, opno;\n+  rtx mdup;\n+\n+  if (GET_CODE (pattern) == MATCH_OPERAND)\n+    {\n+      opno = XINT (pattern, 0);\n+      gcc_assert (opno >= 0 && opno < MAX_OPERANDS);\n+      if (match_operand_entries_in_pattern[opno] == NULL)\n+\t{\n+\t  match_operand_entries_in_pattern[opno] = pattern;\n+\t  return NULL;\n+\t}\n+      else\n+\t{\n+\t  /* Compare predicates before replacing with match_dup.  */\n+\t  if (strcmp (XSTR (pattern, 1),\n+\t\t      XSTR (match_operand_entries_in_pattern[opno], 1)))\n+\t    {\n+\t      error (\"duplicated match_operands with different predicates were\"\n+\t\t     \" found.\");\n+\t      return NULL;\n+\t    }\n+\t  return generate_match_dup (opno);\n+\t}\n+    }\n+  fmt = GET_RTX_FORMAT (GET_CODE (pattern));\n+  len = GET_RTX_LENGTH (GET_CODE (pattern));\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  mdup = replace_duplicating_operands_in_pattern (XEXP (pattern, i));\n+\t  if (mdup)\n+\t    XEXP (pattern, i) = mdup;\n+\t  break;\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    {\n+\t      mdup =\n+\t\treplace_duplicating_operands_in_pattern (XVECEXP\n+\t\t\t\t\t\t\t (pattern, i, j));\n+\t      if (mdup)\n+\t\tXVECEXP (pattern, i, j) = mdup;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+/* The routine modifies given input PATTERN of define_subst, replacing\n+   MATCH_DUP and MATCH_OP_DUP with operands from define_insn original\n+   pattern, whose operands are stored in OPERAND_DATA array.\n+   It also duplicates constraints in operands - constraints from\n+   define_insn operands are duplicated N_SUBST_ALT times, constraints\n+   from define_subst operands are duplicated N_ALT times.\n+   After the duplication, returned output rtl-pattern contains every\n+   combination of input constraints Vs constraints from define_subst\n+   output.  */\n+static rtx\n+subst_dup (rtx pattern, int n_alt, int n_subst_alt)\n+{\n+  const char *fmt;\n+  enum rtx_code code;\n+  int i, j, len, opno;\n+\n+  code = GET_CODE (pattern);\n+  switch (code)\n+    {\n+    case MATCH_DUP:\n+    case MATCH_OP_DUP:\n+      opno = XINT (pattern, 0);\n+\n+      gcc_assert (opno >= 0 && opno < MAX_OPERANDS);\n+\n+      if (operand_data[opno])\n+\t{\n+\t  pattern = copy_rtx (operand_data[opno]);\n+\n+\t  /* Duplicate constraints.  */\n+\t  pattern = alter_constraints (pattern, n_subst_alt,\n+\t\t\t\t       duplicate_alternatives);\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (pattern));\n+  len = GET_RTX_LENGTH (GET_CODE (pattern));\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  if (code != MATCH_DUP && code != MATCH_OP_DUP)\n+\t    XEXP (pattern, i) = subst_dup (XEXP (pattern, i),\n+\t\t\t\t\t   n_alt, n_subst_alt);\n+\t  break;\n+\tcase 'V':\n+\t  if (XVEC (pattern, i) == NULL)\n+\t    break;\n+\tcase 'E':\n+\t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n+\t    if (code != MATCH_DUP && code != MATCH_OP_DUP)\n+\t      XVECEXP (pattern, i, j) = subst_dup (XVECEXP (pattern, i, j),\n+\t\t\t\t\t\t   n_alt, n_subst_alt);\n+\t  break;\n+\n+\tcase 'i': case 'w': case '0': case 's': case 'S': case 'T':\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  return pattern;\n+}\n+\n /* If we have any DEFINE_COND_EXEC patterns, expand the DEFINE_INSN\n    patterns appropriately.  */\n \n@@ -1166,6 +2195,42 @@ process_define_cond_exec (void)\n   for (elem = define_cond_exec_queue; elem ; elem = elem->next)\n     process_one_cond_exec (elem);\n }\n+\n+/* If we have any DEFINE_SUBST patterns, expand DEFINE_INSN and\n+   DEFINE_EXPAND patterns appropriately.  */\n+\n+static void\n+process_define_subst (void)\n+{\n+  struct queue_elem *elem, *elem_attr;\n+\n+  /* Check if each define_subst has corresponding define_subst_attr.  */\n+  for (elem = define_subst_queue; elem ; elem = elem->next)\n+    {\n+      for (elem_attr = define_subst_attr_queue;\n+\t   elem_attr;\n+\t   elem_attr = elem_attr->next)\n+\tif (strcmp (XSTR (elem->data, 0), XSTR (elem_attr->data, 1)) == 0)\n+\t    goto found;\n+\n+\terror_with_line (elem->lineno,\n+\t\t\t \"%s: `define_subst' must have at least one \"\n+\t\t\t \"corresponding `define_subst_attr'\",\n+\t\t\t XSTR (elem->data, 0));\n+\treturn;\n+      found:\n+\tcontinue;\n+    }\n+\n+  for (elem = define_insn_queue; elem ; elem = elem->next)\n+    process_substs_on_one_elem (elem, define_insn_queue);\n+  for (elem = other_queue; elem ; elem = elem->next)\n+    {\n+      if (GET_CODE (elem->data) != DEFINE_EXPAND)\n+\tcontinue;\n+      process_substs_on_one_elem (elem, other_queue);\n+    }\n+}\n \f\n /* A read_md_files callback for reading an rtx.  */\n \n@@ -1391,6 +2456,38 @@ gen_mnemonic_attr (void)\n   XSTR (mnemonic_attr, 1) = XOBFINISH (&string_obstack, char *);\n }\n \n+/* Check if there are DEFINE_ATTRs with the same name.  */\n+static void\n+check_define_attr_duplicates ()\n+{\n+  struct queue_elem *elem;\n+  htab_t attr_htab;\n+  char * attr_name;\n+  void **slot;\n+\n+  attr_htab = htab_create (500, htab_hash_string, htab_eq_string, NULL);\n+\n+  for (elem = define_attr_queue; elem; elem = elem->next)\n+    {\n+      attr_name = xstrdup (XSTR (elem->data, 0));\n+\n+      slot = htab_find_slot (attr_htab, attr_name, INSERT);\n+\n+      /* Duplicate.  */\n+      if (*slot)\n+\t{\n+\t  error_with_line (elem->lineno, \"redefinition of attribute '%s'\",\n+\t\t\t   attr_name);\n+\t  htab_delete (attr_htab);\n+\t  return;\n+\t}\n+\n+      *slot = attr_name;\n+    }\n+\n+  htab_delete (attr_htab);\n+}\n+\n /* The entry point for initializing the reader.  */\n \n bool\n@@ -1407,10 +2504,17 @@ init_rtx_reader_args_cb (int argc, char **argv,\n \n   read_md_files (argc, argv, parse_opt, rtx_handle_directive);\n \n+  if (define_attr_queue != NULL)\n+    check_define_attr_duplicates ();\n+\n   /* Process define_cond_exec patterns.  */\n   if (define_cond_exec_queue != NULL)\n     process_define_cond_exec ();\n \n+  /* Process define_subst patterns.  */\n+  if (define_subst_queue != NULL)\n+    process_define_subst ();\n+\n   if (define_attr_queue != NULL)\n     gen_mnemonic_attr ();\n \n@@ -1470,6 +2574,7 @@ read_md_rtx (int *lineno, int *seqnr)\n     {\n     case DEFINE_INSN:\n     case DEFINE_EXPAND:\n+    case DEFINE_SUBST:\n       if (maybe_eval_c_test (XSTR (desc, 2)) != 0)\n \tsequence_num++;\n       else if (insn_elision)\n@@ -1545,7 +2650,7 @@ maybe_eval_c_test (const char *expr)\n   const struct c_test *test;\n   struct c_test dummy;\n \n-  if (expr[0] == 0)\n+  if (!expr || expr[0] == 0)\n     return 1;\n \n   dummy.expr = expr;"}, {"sha": "7da12b5b126fd84adf9fc7fb316337cfa61a97da", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 270, "deletions": 7, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=477c104eafcc18e49eb5779d06dad8a8f02c84f6", "patch": "@@ -102,13 +102,28 @@ struct attribute_use {\n /* Vector definitions for the above.  */\n typedef struct attribute_use attribute_use;\n \n+/* This struct is used to link subst_attr named ATTR_NAME with\n+   corresponding define_subst named ITER_NAME.  */\n+struct subst_attr_to_iter_mapping\n+{\n+    char *attr_name;\n+    char *iter_name;\n+};\n+\n+/* Hash-table to store links between subst-attributes and\n+   define_substs.  */\n+htab_t subst_attr_to_iter_map = NULL;\n+/* This global stores name of subst-iterator which is currently being\n+   processed.  */\n+const char *current_iterator_name;\n+\n static void validate_const_int (const char *);\n static rtx read_rtx_code (const char *);\n static rtx read_nested_rtx (void);\n static rtx read_rtx_variadic (rtx);\n \n /* The mode and code iterator structures.  */\n-static struct iterator_group modes, codes, ints;\n+static struct iterator_group modes, codes, ints, substs;\n \n /* All iterators used in the current rtx.  */\n static vec<mapping_ptr> current_iterators;\n@@ -178,6 +193,91 @@ apply_int_iterator (void *loc, int value)\n   *(int *)loc = value;\n }\n \n+/* This routine adds attribute or does nothing depending on VALUE.  When\n+   VALUE is 1, it does nothing - the first duplicate of original\n+   template is kept untouched when it's subjected to a define_subst.\n+   When VALUE isn't 1, the routine modifies RTL-template LOC, adding\n+   attribute, named exactly as define_subst, which later will be\n+   applied.  If such attribute has already been added, then no the\n+   routine has no effect.  */\n+static void\n+apply_subst_iterator (void *loc, int value)\n+{\n+  rtx rt = (rtx)loc;\n+  rtx new_attr;\n+  rtvec attrs_vec, new_attrs_vec;\n+  int i;\n+  if (value == 1)\n+    return;\n+  gcc_assert (GET_CODE (rt) == DEFINE_INSN\n+\t      || GET_CODE (rt) == DEFINE_EXPAND);\n+\n+  attrs_vec = XVEC (rt, 4);\n+\n+  /* If we've already added attribute 'current_iterator_name', then we\n+     have nothing to do now.  */\n+  if (attrs_vec)\n+    {\n+      for (i = 0; i < GET_NUM_ELEM (attrs_vec); i++)\n+\t{\n+\t  if (strcmp (XSTR (attrs_vec->elem[i], 0), current_iterator_name) == 0)\n+\t    return;\n+\t}\n+    }\n+\n+  /* Add attribute with subst name - it serves as a mark for\n+     define_subst which later would be applied to this pattern.  */\n+  new_attr = rtx_alloc (SET_ATTR);\n+  PUT_CODE (new_attr, SET_ATTR);\n+  XSTR (new_attr, 0) = xstrdup (current_iterator_name);\n+  XSTR (new_attr, 1) = xstrdup (\"yes\");\n+\n+  if (!attrs_vec)\n+    {\n+      new_attrs_vec = rtvec_alloc (1);\n+      new_attrs_vec->elem[0] = new_attr;\n+    }\n+  else\n+    {\n+      new_attrs_vec = rtvec_alloc (GET_NUM_ELEM (attrs_vec) + 1);\n+      memcpy (&new_attrs_vec->elem[0], &attrs_vec->elem[0],\n+\t      GET_NUM_ELEM (attrs_vec) * sizeof (rtx));\n+      new_attrs_vec->elem[GET_NUM_ELEM (attrs_vec)] = new_attr;\n+    }\n+  XVEC (rt, 4) = new_attrs_vec;\n+}\n+\n+/* Map subst-attribute ATTR to subst iterator ITER.  */\n+\n+static void\n+bind_subst_iter_and_attr (const char *iter, const char *attr)\n+{\n+  struct subst_attr_to_iter_mapping *value;\n+  void **slot;\n+  if (!subst_attr_to_iter_map)\n+    subst_attr_to_iter_map =\n+      htab_create (1, leading_string_hash, leading_string_eq_p, 0);\n+  value = XNEW (struct subst_attr_to_iter_mapping);\n+  value->attr_name = xstrdup (attr);\n+  value->iter_name = xstrdup (iter);\n+  slot = htab_find_slot (subst_attr_to_iter_map, value, INSERT);\n+  *slot = value;\n+}\n+\n+/* Return name of a subst-iterator, corresponding to subst-attribute ATTR.  */\n+\n+static char*\n+find_subst_iter_by_attr (const char *attr)\n+{\n+  char *iter_name = NULL;\n+  struct subst_attr_to_iter_mapping *value;\n+  value = (struct subst_attr_to_iter_mapping*)\n+    htab_find (subst_attr_to_iter_map, &attr);\n+  if (value)\n+    iter_name = value->iter_name;\n+  return iter_name;\n+}\n+\n /* Map attribute string P to its current value.  Return null if the attribute\n    isn't known.  */\n \n@@ -216,11 +316,23 @@ map_attr_string (const char *p)\n       /* Find the attribute specification.  */\n       m = (struct mapping *) htab_find (iterator->group->attrs, &attr);\n       if (m)\n-\t/* Find the attribute value associated with the current\n-\t   iterator value.  */\n-\tfor (v = m->values; v; v = v->next)\n-\t  if (v->number == iterator->current_value->number)\n-\t    return v;\n+\t{\n+\t  /* In contrast to code/mode/int iterators, attributes of subst\n+\t     iterators are linked to one specific subst-iterator.  So, if\n+\t     we are dealing with subst-iterator, we should check if it's\n+\t     the one which linked with the given attribute.  */\n+\t  if (iterator->group == &substs)\n+\t    {\n+\t      char *iter_name = find_subst_iter_by_attr (attr);\n+\t      if (strcmp (iter_name, iterator->name) != 0)\n+\t\tcontinue;\n+\t    }\n+\t  /* Find the attribute value associated with the current\n+\t     iterator value.  */\n+\t  for (v = m->values; v; v = v->next)\n+\t    if (v->number == iterator->current_value->number)\n+\t      return v;\n+\t}\n     }\n   return NULL;\n }\n@@ -337,6 +449,7 @@ add_condition_to_rtx (rtx x, const char *extra)\n     {\n     case DEFINE_INSN:\n     case DEFINE_EXPAND:\n+    case DEFINE_SUBST:\n       XSTR (x, 2) = add_condition_to_string (XSTR (x, 2), extra);\n       break;\n \n@@ -426,6 +539,7 @@ apply_iterators (rtx original, rtx *queue)\n   htab_traverse (modes.iterators, add_current_iterators, NULL);\n   htab_traverse (codes.iterators, add_current_iterators, NULL);\n   htab_traverse (ints.iterators, add_current_iterators, NULL);\n+  htab_traverse (substs.iterators, add_current_iterators, NULL);\n   gcc_assert (!current_iterators.is_empty ());\n \n   for (;;)\n@@ -435,6 +549,8 @@ apply_iterators (rtx original, rtx *queue)\n       condition = NULL;\n       FOR_EACH_VEC_ELT (iterator_uses, i, iuse)\n \t{\n+\t  if (iuse->iterator->group == &substs)\n+\t    continue;\n \t  v = iuse->iterator->current_value;\n \t  iuse->iterator->group->apply_iterator (iuse->ptr, v->number);\n \t  condition = join_c_conditions (condition, v->string);\n@@ -443,6 +559,19 @@ apply_iterators (rtx original, rtx *queue)\n       x = copy_rtx_for_iterators (original);\n       add_condition_to_rtx (x, condition);\n \n+      /* We apply subst iterator after RTL-template is copied, as during\n+\t subst-iterator processing, we could add an attribute to the\n+\t RTL-template, and we don't want to do it in the original one.  */\n+      FOR_EACH_VEC_ELT (iterator_uses, i, iuse)\n+\t{\n+\t  v = iuse->iterator->current_value;\n+\t  if (iuse->iterator->group == &substs)\n+\t    {\n+\t      iuse->ptr = x;\n+\t      current_iterator_name = iuse->iterator->name;\n+\t      iuse->iterator->group->apply_iterator (iuse->ptr, v->number);\n+\t    }\n+\t}\n       /* Add the new rtx to the end of the queue.  */\n       XEXP (*queue, 0) = x;\n       XEXP (*queue, 1) = NULL_RTX;\n@@ -538,6 +667,12 @@ initialize_iterators (void)\n   ints.find_builtin = find_int;\n   ints.apply_iterator = apply_int_iterator;\n \n+  substs.attrs = htab_create (13, leading_string_hash, leading_string_eq_p, 0);\n+  substs.iterators = htab_create (13, leading_string_hash,\n+\t\t\t\t leading_string_eq_p, 0);\n+  substs.find_builtin = find_int; /* We don't use it, anyway.  */\n+  substs.apply_iterator = apply_subst_iterator;\n+\n   lower = add_mapping (&modes, modes.attrs, \"mode\");\n   upper = add_mapping (&modes, modes.attrs, \"MODE\");\n   lower_ptr = &lower->values;\n@@ -780,6 +915,94 @@ read_mapping (struct iterator_group *group, htab_t table)\n   return m;\n }\n \n+/* For iterator with name ATTR_NAME generate define_attr with values\n+   'yes' and 'no'.  This attribute is used to mark templates to which\n+   define_subst ATTR_NAME should be applied.  This attribute is set and\n+   defined implicitly and automatically.  */\n+static void\n+add_define_attr_for_define_subst (const char *attr_name, rtx *queue)\n+{\n+  rtx const_str, return_rtx;\n+\n+  return_rtx = rtx_alloc (DEFINE_ATTR);\n+  PUT_CODE (return_rtx, DEFINE_ATTR);\n+\n+  const_str = rtx_alloc (CONST_STRING);\n+  PUT_CODE (const_str, CONST_STRING);\n+  XSTR (const_str, 0) = xstrdup (\"no\");\n+\n+  XSTR (return_rtx, 0) = xstrdup (attr_name);\n+  XSTR (return_rtx, 1) = xstrdup (\"no,yes\");\n+  XEXP (return_rtx, 2) = const_str;\n+\n+  XEXP (*queue, 0) = return_rtx;\n+  XEXP (*queue, 1) = NULL_RTX;\n+}\n+\n+/* This routine generates DEFINE_SUBST_ATTR expression with operands\n+   ATTR_OPERANDS and places it to QUEUE.  */\n+static void\n+add_define_subst_attr (const char **attr_operands, rtx *queue)\n+{\n+  rtx return_rtx;\n+  int i;\n+\n+  return_rtx = rtx_alloc (DEFINE_SUBST_ATTR);\n+  PUT_CODE (return_rtx, DEFINE_SUBST_ATTR);\n+\n+  for (i = 0; i < 4; i++)\n+    XSTR (return_rtx, i) = xstrdup (attr_operands[i]);\n+\n+  XEXP (*queue, 0) = return_rtx;\n+  XEXP (*queue, 1) = NULL_RTX;\n+}\n+\n+/* Read define_subst_attribute construction.  It has next form:\n+\t(define_subst_attribute <attribute_name> <iterator_name> <value1> <value2>)\n+   Attribute is substituted with value1 when no subst is applied and with\n+   value2 in the opposite case.\n+   Attributes are added to SUBST_ATTRS_TABLE.\n+   In case the iterator is encountered for the first time, it's added to\n+   SUBST_ITERS_TABLE.  Also, implicit define_attr is generated.  */\n+\n+static void\n+read_subst_mapping (htab_t subst_iters_table, htab_t subst_attrs_table,\n+\t\t    rtx *queue)\n+{\n+  struct mapping *m;\n+  struct map_value **end_ptr;\n+  const char *attr_operands[4];\n+  rtx * queue_elem = queue;\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    attr_operands[i] = read_string (false);\n+\n+  add_define_subst_attr (attr_operands, queue_elem);\n+\n+  bind_subst_iter_and_attr (attr_operands[1], attr_operands[0]);\n+\n+  m = (struct mapping *) htab_find (substs.iterators, &attr_operands[1]);\n+  if (!m)\n+    {\n+      m = add_mapping (&substs, subst_iters_table, attr_operands[1]);\n+      end_ptr = &m->values;\n+      end_ptr = add_map_value (end_ptr, 1, \"\");\n+      end_ptr = add_map_value (end_ptr, 2, \"\");\n+\n+      /* Add element to the queue.  */\n+      XEXP (*queue, 1) = rtx_alloc (EXPR_LIST);\n+      queue_elem = &XEXP (*queue, 1);\n+\n+      add_define_attr_for_define_subst (attr_operands[1], queue_elem);\n+    }\n+\n+  m = add_mapping (&substs, subst_attrs_table, attr_operands[0]);\n+  end_ptr = &m->values;\n+  end_ptr = add_map_value (end_ptr, 1, attr_operands[2]);\n+  end_ptr = add_map_value (end_ptr, 2, attr_operands[3]);\n+}\n+\n /* Check newly-created code iterator ITERATOR to see whether every code has the\n    same format.  */\n \n@@ -850,6 +1073,15 @@ read_rtx (const char *rtx_name, rtx *x)\n       read_mapping (&ints, ints.iterators);\n       return false;\n     }\n+  if (strcmp (rtx_name, \"define_subst_attr\") == 0)\n+    {\n+      read_subst_mapping (substs.iterators, substs.attrs, &queue_head);\n+      *x = queue_head;\n+\n+      /* READ_SUBST_MAPPING could generate a new DEFINE_ATTR.  Return\n+\t TRUE to process it.  */\n+      return true;\n+    }\n \n   apply_iterators (read_rtx_code (rtx_name), &queue_head);\n   iterator_uses.truncate (0);\n@@ -868,12 +1100,15 @@ read_rtx_code (const char *code_name)\n {\n   int i;\n   RTX_CODE code;\n-  struct mapping *iterator;\n+  struct mapping *iterator, *m;\n   const char *format_ptr;\n   struct md_name name;\n   rtx return_rtx;\n   int c;\n   HOST_WIDE_INT tmp_wide;\n+  char *str;\n+  char *start, *end, *ptr;\n+  char tmpstr[256];\n \n   /* Linked list structure for making RTXs: */\n   struct rtx_list\n@@ -1018,6 +1253,34 @@ read_rtx_code (const char *code_name)\n \t      stringbuf = XOBFINISH (&string_obstack, char *);\n \t    }\n \n+\t  /* Find attr-names in the string.  */\n+\t  ptr = &tmpstr[0];\n+\t  end = stringbuf;\n+\t  while ((start = strchr (end, '<')) && (end  = strchr (start, '>')))\n+\t    {\n+\t      if ((end - start - 1 > 0)\n+\t\t  && (end - start - 1 < (int)sizeof (tmpstr)))\n+\t\t{\n+\t\t  strncpy (tmpstr, start+1, end-start-1);\n+\t\t  tmpstr[end-start-1] = 0;\n+\t\t  end++;\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t      m = (struct mapping *) htab_find (substs.attrs, &ptr);\n+\t      if (m != 0)\n+\t\t{\n+\t\t  /* Here we should find linked subst-iter.  */\n+\t\t  str = find_subst_iter_by_attr (ptr);\n+\t\t  if (str)\n+\t\t    m = (struct mapping *) htab_find (substs.iterators, &str);\n+\t\t  else\n+\t\t    m = 0;\n+\t\t}\n+\t      if (m != 0)\n+\t\trecord_iterator_use (m, return_rtx);\n+\t    }\n+\n \t  if (star_if_braced)\n \t    XTMPL (return_rtx, i) = stringbuf;\n \t  else"}, {"sha": "6948bfe13ed72562cab9eaaf5b523379ef062507", "filename": "gcc/rtl.def", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477c104eafcc18e49eb5779d06dad8a8f02c84f6/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=477c104eafcc18e49eb5779d06dad8a8f02c84f6", "patch": "@@ -906,8 +906,9 @@ DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", RTX_EXTRA)\n \tThis might, for example, create some RTX's and store them in\n \telements of `recog_data.operand' for use by the vector of\n \tinsn-patterns.\n-\t(`operands' is an alias here for `recog_data.operand').  */\n-DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", RTX_EXTRA)\n+\t(`operands' is an alias here for `recog_data.operand').\n+   5th: optionally, a vector of attributes for this expand.  */\n+DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEssV\", RTX_EXTRA)\n \n /* Define a requirement for delay slots.\n    1st operand: Condition involving insn attributes that, if true,\n@@ -1280,6 +1281,8 @@ DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", RTX_EXTRA)\n    true, the second operand will be used as the value of the conditional.  */\n DEF_RTL_EXPR(COND, \"cond\", \"Ee\", RTX_EXTRA)\n \n+DEF_RTL_EXPR(DEFINE_SUBST, \"define_subst\", \"sEsE\", RTX_EXTRA)\n+DEF_RTL_EXPR(DEFINE_SUBST_ATTR, \"define_subst_attr\", \"ssss\", RTX_EXTRA)\n #endif /* GENERATOR_FILE */\n \n /*"}]}