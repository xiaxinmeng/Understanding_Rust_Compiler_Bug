{"sha": "b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBhZjEzZWFkZGY2Y2E2ZTVlOWZlNDhlOGU1NGZmZjZiM2VmNDU4Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-06-22T23:36:32Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-06-22T23:36:32Z"}, "message": "profiler_list_to_slist.h: Fix formatting, other minor stylistic changes.\n\n2010-06-22  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/profile/impl/profiler_list_to_slist.h: Fix formatting,\n\tother minor stylistic changes.\n\t* include/profile/impl/profiler_container_size.h: Likewise.\n\t* include/profile/impl/profiler_vector_size.h: Likewise.\n\t* include/profile/impl/profiler_hash_func.h: Likewise.\n\t* include/profile/impl/profiler_trace.h: Likewise.\n\t* include/profile/impl/profiler_list_to_vector.h: Likewise.\n\t* include/profile/impl/profiler_vector_to_list.h: Likewise.\n\t* include/profile/impl/profiler_state.h: Likewise.\n\t* include/profile/impl/profiler_map_to_unordered_map.h: Likewise.\n\t* include/profile/impl/profiler_hashtable_size.h: Likewise.\n\t* include/profile/impl/profiler_node.h: Likewise.\n\nFrom-SVN: r161236", "tree": {"sha": "a8248f78e666d091c8e02211d11d2ad57d1fef78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8248f78e666d091c8e02211d11d2ad57d1fef78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/comments", "author": null, "committer": null, "parents": [{"sha": "b2e894b50a1953727cb77898cc618e06577c34d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e894b50a1953727cb77898cc618e06577c34d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e894b50a1953727cb77898cc618e06577c34d9"}], "stats": {"total": 3807, "additions": 1990, "deletions": 1817}, "files": [{"sha": "465734fb777aa7c29c6fffff50090cbe5a9370dc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -1,3 +1,18 @@\n+2010-06-22  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/profile/impl/profiler_list_to_slist.h: Fix formatting,\n+\tother minor stylistic changes.\n+\t* include/profile/impl/profiler_container_size.h: Likewise.\n+\t* include/profile/impl/profiler_vector_size.h: Likewise.\n+\t* include/profile/impl/profiler_hash_func.h: Likewise.\n+\t* include/profile/impl/profiler_trace.h: Likewise.\n+\t* include/profile/impl/profiler_list_to_vector.h: Likewise.\n+\t* include/profile/impl/profiler_vector_to_list.h: Likewise.\n+\t* include/profile/impl/profiler_state.h: Likewise.\n+\t* include/profile/impl/profiler_map_to_unordered_map.h: Likewise.\n+\t* include/profile/impl/profiler_hashtable_size.h: Likewise.\n+\t* include/profile/impl/profiler_node.h: Likewise.\n+\n 2010-06-22  Matthias Klose  <doko@ubuntu.com>\n \n \t* python/libstdcxx/v6/printers.py: Don't use string exceptions."}, {"sha": "32388641a8614e089b57c928b78b0280361e3a97", "filename": "libstdc++-v3/include/profile/impl/profiler_container_size.h", "status": "modified", "additions": 172, "deletions": 182, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -55,188 +55,178 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief A container size instrumentation line in the object table.  */\n-class __container_size_info: public __object_info_base \n-{\n- public:\n-  __container_size_info();\n-  __container_size_info(const __container_size_info& __o);\n-  __container_size_info(__stack_t __stack, size_t __num);\n-  virtual ~__container_size_info() {}\n-\n-  void __write(FILE* f) const;\n-  float __magnitude() const { return static_cast<float>(_M_cost); }\n-  const char* __advice() const;\n-\n-  void __merge(const __container_size_info& __o);\n-  // Call if a container is destructed or cleaned.\n-  void __destruct(size_t __num, size_t __inum);\n-  // Estimate the cost of resize/rehash. \n-  float __resize_cost(size_t __from, size_t __to) { return __from; }\n-  // Call if container is resized.\n-  void __resize(size_t __from, size_t __to);\n-\n- private:\n-  size_t _M_init;\n-  size_t _M_max;  // range of # buckets\n-  size_t _M_min;\n-  size_t _M_total;\n-  size_t _M_item_min;  // range of # items\n-  size_t _M_item_max;\n-  size_t _M_item_total;\n-  size_t _M_count;\n-  size_t _M_resize;\n-  size_t _M_cost;\n-};\n-\n-inline const char* __container_size_info::__advice() const\n-{\n-  std::stringstream __message;\n-  if (_M_init < _M_item_max)\n-    __message << \"change initial container size from \" << _M_init\n-              << \" to \" << _M_item_max;\n-\n-  return strdup(__message.str().c_str());\n-}\n-\n-inline void __container_size_info::__destruct(size_t __num, size_t __inum) \n-{\n-  _M_max = std::max(_M_max, __num);\n-  _M_item_max = std::max(_M_item_max, __inum);\n-  if (_M_min == 0) {\n-    _M_min = __num; \n-    _M_item_min = __inum;\n-  } else {\n-    _M_min = std::min(_M_min, __num);\n-    _M_item_min = std::min(_M_item_min, __inum);\n-  }\n-  _M_total += __num;\n-  _M_item_total += __inum;\n-  _M_count += 1;\n-}\n-\n-inline void __container_size_info::__resize(size_t __from, size_t __to) \n-{\n-  _M_cost += this->__resize_cost(__from, __to);\n-  _M_resize += 1;\n-  _M_max = std::max(_M_max, __to);\n-}\n-\n-inline __container_size_info::__container_size_info(__stack_t __stack, \n-                                                    size_t __num)\n-    : __object_info_base(__stack), _M_init(0), _M_max(0), _M_item_max(0), \n-      _M_min(0), _M_item_min(0), _M_total(0), _M_item_total(0), _M_cost(0), \n-      _M_count(0), _M_resize(0)\n-{\n-  _M_init = _M_max = __num;\n-  _M_item_min = _M_item_max = _M_item_total = _M_total = 0;\n-  _M_min = 0;\n-  _M_count = 0;\n-  _M_resize = 0;\n-}\n-\n-inline void __container_size_info::__merge(const __container_size_info& __o)\n-{\n-  _M_init        = std::max(_M_init, __o._M_init);\n-  _M_max         = std::max(_M_max, __o._M_max);\n-  _M_item_max    = std::max(_M_item_max, __o._M_item_max);\n-  _M_min         = std::min(_M_min, __o._M_min);\n-  _M_item_min    = std::min(_M_item_min, __o._M_item_min);\n-  _M_total      += __o._M_total;\n-  _M_item_total += __o._M_item_total;\n-  _M_count      += __o._M_count;\n-  _M_cost       += __o._M_cost;\n-  _M_resize     += __o._M_resize;\n-}\n-\n-inline __container_size_info::__container_size_info()\n-    : _M_init(0), _M_max(0), _M_item_max(0), _M_min(0), _M_item_min(0),\n-      _M_total(0), _M_item_total(0), _M_cost(0), _M_count(0), _M_resize(0)\n-{\n-}\n-\n-inline __container_size_info::__container_size_info(\n-    const __container_size_info& __o)\n-    : __object_info_base(__o)\n-{\n-  _M_init        = __o._M_init;\n-  _M_max         = __o._M_max;\n-  _M_item_max    = __o._M_item_max;\n-  _M_min         = __o._M_min;\n-  _M_item_min    = __o._M_item_min;\n-  _M_total       = __o._M_total;\n-  _M_item_total  = __o._M_item_total;\n-  _M_cost        = __o._M_cost;\n-  _M_count       = __o._M_count;\n-  _M_resize      = __o._M_resize;\n-}\n-\n-/** @brief A container size instrumentation line in the stack table.  */\n-class __container_size_stack_info: public __container_size_info\n-{\n- public:\n-  __container_size_stack_info(const __container_size_info& __o)\n-      : __container_size_info(__o) {}\n-};\n-\n-/** @brief Container size instrumentation trace producer.  */\n-class __trace_container_size\n-    : public __trace_base<__container_size_info, __container_size_stack_info> \n-{\n- public:\n-  ~__trace_container_size() {}\n-  __trace_container_size()\n-      : __trace_base<__container_size_info, __container_size_stack_info>() {};\n-\n-  // Insert a new node at construct with object, callstack and initial size. \n-  void __insert(const __object_t __obj, __stack_t __stack, size_t __num);\n-  // Call at destruction/clean to set container final size.\n-  void __destruct(const void* __obj, size_t __num, size_t __inum);\n-  void __construct(const void* __obj, size_t __inum);\n-  // Call at resize to set resize/cost information.\n-  void __resize(const void* __obj, int __from, int __to);\n-};\n-\n-inline void __trace_container_size::__insert(const __object_t __obj,\n-                                             __stack_t __stack, size_t __num)\n-{\n-  __add_object(__obj, __container_size_info(__stack, __num));\n-}\n-\n-inline void __container_size_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu\\n\", \n-          _M_init, _M_count, _M_cost, _M_resize, _M_min, _M_max, _M_total,\n-          _M_item_min, _M_item_max, _M_item_total);\n-}\n-\n-inline void __trace_container_size::__destruct(const void* __obj, \n-                                               size_t __num, size_t __inum)\n-{\n-  if (!__is_on()) return;\n-\n-  __object_t __obj_handle = static_cast<__object_t>(__obj);\n-\n-  __container_size_info* __object_info = __get_object_info(__obj_handle);\n-  if (!__object_info)\n-    return;\n-\n-  __object_info->__destruct(__num, __inum);\n-  __retire_object(__obj_handle);\n-}\n-\n-inline void __trace_container_size::__resize(const void* __obj, int __from, \n-                                             int __to)\n-{\n-  if (!__is_on()) return;\n-\n-  __container_size_info* __object_info = __get_object_info(__obj);\n-  if (!__object_info)\n-    return;\n-\n-  __object_info->__resize(__from, __to);\n-}\n+  /** @brief A container size instrumentation line in the object table.  */\n+  class __container_size_info \n+  : public __object_info_base \n+  {\n+  public:\n+    __container_size_info()\n+    : _M_init(0), _M_max(0), _M_min(0), _M_total(0), _M_item_min(0),\n+      _M_item_max(0), _M_item_total(0), _M_count(0), _M_resize(0), _M_cost(0) \n+    { }\n+\n+    __container_size_info(const __container_size_info& __o)\n+    : __object_info_base(__o), _M_init(__o._M_init), _M_max(__o._M_max),\n+      _M_min(__o._M_min), _M_total(__o._M_total),\n+      _M_item_min(__o._M_item_min), _M_item_max(__o._M_item_max),\n+      _M_item_total(__o._M_item_total), _M_count(__o._M_count),\n+      _M_resize(__o._M_resize), _M_cost(__o._M_cost)\n+    { }\n+\n+    __container_size_info(__stack_t __stack, size_t __num)\n+    : __object_info_base(__stack), _M_init(__num), _M_max(__num),\n+      _M_min(0), _M_total(0), _M_item_min(0), _M_item_max(0),\n+      _M_item_total(0), _M_count(0), _M_resize(0), _M_cost(0)\n+    { }\n+\n+    virtual ~__container_size_info() { }\n+\n+    void\n+    __write(FILE* __f) const\n+    {\n+      fprintf(__f, \"%Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu\\n\", \n+\t      _M_init, _M_count, _M_cost, _M_resize, _M_min, _M_max, _M_total,\n+\t      _M_item_min, _M_item_max, _M_item_total);\n+    }\n+\n+    float\n+    __magnitude() const\n+    { return static_cast<float>(_M_cost); }\n+\n+    const char*\n+    __advice() const\n+    {\n+      std::stringstream __message;\n+      if (_M_init < _M_item_max)\n+\t__message << \"change initial container size from \" << _M_init\n+\t\t  << \" to \" << _M_item_max;\n+      return strdup(__message.str().c_str());\n+    }\n+\n+    void\n+    __merge(const __container_size_info& __o)\n+    {\n+      _M_init        = std::max(_M_init, __o._M_init);\n+      _M_max         = std::max(_M_max, __o._M_max);\n+      _M_item_max    = std::max(_M_item_max, __o._M_item_max);\n+      _M_min         = std::min(_M_min, __o._M_min);\n+      _M_item_min    = std::min(_M_item_min, __o._M_item_min);\n+      _M_total      += __o._M_total;\n+      _M_item_total += __o._M_item_total;\n+      _M_count      += __o._M_count;\n+      _M_cost       += __o._M_cost;\n+      _M_resize     += __o._M_resize;\n+    }\n+\n+    // Call if a container is destructed or cleaned.\n+    void\n+    __destruct(size_t __num, size_t __inum)\n+    {\n+      _M_max = std::max(_M_max, __num);\n+      _M_item_max = std::max(_M_item_max, __inum);\n+      if (_M_min == 0)\n+\t{\n+\t  _M_min = __num; \n+\t  _M_item_min = __inum;\n+\t}\n+      else\n+\t{\n+\t  _M_min = std::min(_M_min, __num);\n+\t  _M_item_min = std::min(_M_item_min, __inum);\n+\t}\n+      _M_total += __num;\n+      _M_item_total += __inum;\n+      _M_count += 1;\n+    }\n+\n+    // Estimate the cost of resize/rehash. \n+    float\n+    __resize_cost(size_t __from, size_t)\n+    { return __from; }\n+\n+    // Call if container is resized.\n+    void\n+    __resize(size_t __from, size_t __to)\n+    {\n+      _M_cost += this->__resize_cost(__from, __to);\n+      _M_resize += 1;\n+      _M_max = std::max(_M_max, __to);\n+    }\n+\n+  private:\n+    size_t _M_init;\n+    size_t _M_max;  // range of # buckets\n+    size_t _M_min;\n+    size_t _M_total;\n+    size_t _M_item_min;  // range of # items\n+    size_t _M_item_max;\n+    size_t _M_item_total;\n+    size_t _M_count;\n+    size_t _M_resize;\n+    size_t _M_cost;\n+  };\n+\n+\n+  /** @brief A container size instrumentation line in the stack table.  */\n+  class __container_size_stack_info\n+  : public __container_size_info\n+  {\n+  public:\n+    __container_size_stack_info(const __container_size_info& __o)\n+    : __container_size_info(__o) { }\n+  };\n+\n+  \n+  /** @brief Container size instrumentation trace producer.  */\n+  class __trace_container_size\n+  : public __trace_base<__container_size_info, __container_size_stack_info> \n+  {\n+  public:\n+    ~__trace_container_size() { }\n+\n+    __trace_container_size()\n+    : __trace_base<__container_size_info, __container_size_stack_info>() { };\n+\n+    // Insert a new node at construct with object, callstack and initial size. \n+    void\n+    __insert(const __object_t __obj, __stack_t __stack, size_t __num)\n+    { __add_object(__obj, __container_size_info(__stack, __num)); }\n+\n+    // XXX Undefined?\n+    void\n+    __construct(const void* __obj, size_t __inum);\n+  \n+    // Call at destruction/clean to set container final size.\n+    void\n+    __destruct(const void* __obj, size_t __num, size_t __inum)\n+    {\n+      if (!__is_on())\n+\treturn;\n+\n+      __object_t __obj_handle = static_cast<__object_t>(__obj);\n+\n+      __container_size_info* __object_info = __get_object_info(__obj_handle);\n+      if (!__object_info)\n+\treturn;\n+\n+      __object_info->__destruct(__num, __inum);\n+      __retire_object(__obj_handle);\n+    }\n+\n+    // Call at resize to set resize/cost information.\n+    void\n+    __resize(const void* __obj, int __from, int __to)\n+    {\n+      if (!__is_on())\n+\treturn;\n+\n+      __container_size_info* __object_info = __get_object_info(__obj);\n+      if (!__object_info)\n+\treturn;\n+\n+      __object_info->__resize(__from, __to);\n+    }\n+  };\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_CONTAINER_SIZE_H */"}, {"sha": "733348d98e033416892af139cf24ef37ea3e546d", "filename": "libstdc++-v3/include/profile/impl/profiler_hash_func.h", "status": "modified", "additions": 125, "deletions": 122, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -52,134 +52,137 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief A hash performance instrumentation line in the object table.  */\n-class __hashfunc_info: public __object_info_base\n-{\n- public:\n-  __hashfunc_info()\n-      :_M_longest_chain(0), _M_accesses(0), _M_hops(0) {}\n-  __hashfunc_info(const __hashfunc_info& o);\n-  __hashfunc_info(__stack_t __stack)\n-      : __object_info_base(__stack),\n-        _M_longest_chain(0), _M_accesses(0), _M_hops(0){} \n-  virtual ~__hashfunc_info() {}\n-\n-  void __merge(const __hashfunc_info& __o);\n-  void __destruct(size_t __chain, size_t __accesses, size_t __hops);\n-  void __write(FILE* __f) const;\n-  float __magnitude() const { return static_cast<float>(_M_hops); }\n-  const char* __advice() const { return strdup(\"change hash function\"); }\n-\n-private:\n-  size_t _M_longest_chain;\n-  size_t _M_accesses;\n-  size_t _M_hops;\n-};\n-\n-inline __hashfunc_info::__hashfunc_info(const __hashfunc_info& __o)\n-    : __object_info_base(__o)\n-{\n-  _M_longest_chain = __o._M_longest_chain;\n-  _M_accesses      = __o._M_accesses;\n-  _M_hops          = __o._M_hops;\n-}\n-\n-inline void __hashfunc_info::__merge(const __hashfunc_info& __o)\n-{\n-  _M_longest_chain  = std::max(_M_longest_chain, __o._M_longest_chain);\n-  _M_accesses      += __o._M_accesses;\n-  _M_hops          += __o._M_hops;\n-}\n-\n-inline void __hashfunc_info::__destruct(size_t __chain, size_t __accesses, \n-                                        size_t __hops)\n-{ \n-  _M_longest_chain  = std::max(_M_longest_chain, __chain);\n-  _M_accesses      += __accesses;\n-  _M_hops          += __hops;\n-}\n-\n-/** @brief A hash performance instrumentation line in the stack table.  */\n-class __hashfunc_stack_info: public __hashfunc_info {\n- public:\n-  __hashfunc_stack_info(const __hashfunc_info& __o) : __hashfunc_info(__o) {}\n-};\n-\n-/** @brief Hash performance instrumentation producer.  */\n-class __trace_hash_func\n-    : public __trace_base<__hashfunc_info, __hashfunc_stack_info> \n-{\n- public:\n-  __trace_hash_func();\n-  ~__trace_hash_func() {}\n-\n-  // Insert a new node at construct with object, callstack and initial size. \n-  void __insert(__object_t __obj, __stack_t __stack);\n-  // Call at destruction/clean to set container final size.\n-  void __destruct(const void* __obj, size_t __chain,\n-                  size_t __accesses, size_t __hops);\n-};\n-\n-inline __trace_hash_func::__trace_hash_func()\n+  /** @brief A hash performance instrumentation line in the object table.  */\n+  class __hashfunc_info \n+  : public __object_info_base\n+  {\n+  public:\n+    __hashfunc_info()\n+    : _M_longest_chain(0), _M_accesses(0), _M_hops(0) { }\n+  \n+    __hashfunc_info(const __hashfunc_info& __o)\n+      : __object_info_base(__o), _M_longest_chain(__o._M_longest_chain),\n+\t_M_accesses(__o._M_accesses), _M_hops(__o._M_hops) { }\n+  \n+    __hashfunc_info(__stack_t __stack)\n+    : __object_info_base(__stack),\n+      _M_longest_chain(0), _M_accesses(0), _M_hops(0){ }\n+ \n+    virtual ~__hashfunc_info() {}\n+\n+    void\n+    __merge(const __hashfunc_info& __o)\n+    {\n+      _M_longest_chain  = std::max(_M_longest_chain, __o._M_longest_chain);\n+      _M_accesses      += __o._M_accesses;\n+      _M_hops          += __o._M_hops;\n+    }\n+\n+    void\n+    __destruct(size_t __chain, size_t __accesses, size_t __hops)\n+    { \n+      _M_longest_chain  = std::max(_M_longest_chain, __chain);\n+      _M_accesses      += __accesses;\n+      _M_hops          += __hops;\n+    }\n+\n+    void\n+    __write(FILE* __f) const\n+    { fprintf(__f, \"%Zu %Zu %Zu\\n\", _M_hops, _M_accesses, _M_longest_chain); }\n+\n+    float\n+    __magnitude() const\n+    { return static_cast<float>(_M_hops); }\n+\n+    const char*\n+    __advice() const\n+    { return strdup(\"change hash function\"); }\n+\n+  private:\n+    size_t _M_longest_chain;\n+    size_t _M_accesses;\n+    size_t _M_hops;\n+  };\n+\n+\n+  /** @brief A hash performance instrumentation line in the stack table.  */\n+  class __hashfunc_stack_info \n+  : public __hashfunc_info\n+  {\n+  public:\n+    __hashfunc_stack_info(const __hashfunc_info& __o)\n+    : __hashfunc_info(__o) { }\n+  };\n+\n+\n+  /** @brief Hash performance instrumentation producer.  */\n+  class __trace_hash_func\n+  : public __trace_base<__hashfunc_info, __hashfunc_stack_info> \n+  {\n+  public:\n+    __trace_hash_func()\n     : __trace_base<__hashfunc_info, __hashfunc_stack_info>()\n-{\n-  __id = \"hash-distr\";\n-}\n-\n-inline void __trace_hash_func::__insert(__object_t __obj, __stack_t __stack)\n-{\n-  __add_object(__obj, __hashfunc_info(__stack));\n-}\n-\n-inline void __hashfunc_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu\\n\", _M_hops, _M_accesses, _M_longest_chain);\n-}\n-\n-inline void __trace_hash_func::__destruct(const void* __obj, size_t __chain,\n-                                          size_t __accesses, size_t __hops)\n-{\n-  if (!__is_on()) return;\n-\n-  // First find the item from the live objects and update the informations.\n-  __hashfunc_info* __objs = __get_object_info(__obj);\n-  if (!__objs)\n-    return;\n-\n-  __objs->__destruct(__chain, __accesses, __hops);\n-  __retire_object(__obj);\n-}\n-\n-inline void __trace_hash_func_init()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_hash_func) = new __trace_hash_func();\n-}\n-\n-inline void __trace_hash_func_report(FILE* __f,\n-                                     __warning_vector_t& __warnings)\n-{\n-  if (_GLIBCXX_PROFILE_DATA(_S_hash_func)) {\n-    _GLIBCXX_PROFILE_DATA(_S_hash_func)->__collect_warnings(__warnings);\n-    _GLIBCXX_PROFILE_DATA(_S_hash_func)->__write(__f);\n+    { __id = \"hash-distr\"; }\n+\n+    ~__trace_hash_func() {}\n+    \n+    // Insert a new node at construct with object, callstack and initial size.\n+    void\n+    __insert(__object_t __obj, __stack_t __stack)\n+    { __add_object(__obj, __hashfunc_info(__stack)); }\n+\n+    // Call at destruction/clean to set container final size.\n+    void\n+    __destruct(const void* __obj, size_t __chain,\n+\t       size_t __accesses, size_t __hops)\n+    {\n+      if (!__is_on())\n+\treturn;\n+\n+      // First find the item from the live objects and update the informations.\n+      __hashfunc_info* __objs = __get_object_info(__obj);\n+      if (!__objs)\n+\treturn;\n+\n+      __objs->__destruct(__chain, __accesses, __hops);\n+      __retire_object(__obj);\n+    }\n+  };\n+\n+\n+  inline void\n+  __trace_hash_func_init()\n+  { _GLIBCXX_PROFILE_DATA(_S_hash_func) = new __trace_hash_func(); }\n+\n+  inline void\n+  __trace_hash_func_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (_GLIBCXX_PROFILE_DATA(_S_hash_func))\n+      {\n+\t_GLIBCXX_PROFILE_DATA(_S_hash_func)->__collect_warnings(__warnings);\n+\t_GLIBCXX_PROFILE_DATA(_S_hash_func)->__write(__f);\n+      }\n   }\n-}\n \n-inline void __trace_hash_func_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_hash_func_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_hash_func)->__insert(__obj, __get_stack());\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_hash_func)->__insert(__obj, __get_stack());\n+  }\n \n-inline void __trace_hash_func_destruct(const void* __obj, size_t __chain,\n-                                       size_t __accesses, size_t __hops)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_hash_func_destruct(const void* __obj, size_t __chain,\n+\t\t\t     size_t __accesses, size_t __hops)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_hash_func)->__destruct(__obj, __chain, __accesses, \n-                                                  __hops);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_hash_func)->__destruct(__obj, __chain, __accesses, \n+\t\t\t\t\t\t    __hops);\n+  }\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_HASH_FUNC_H */"}, {"sha": "f91cc8c6026af5f4abf98c82d1c53fa1df11c4b3", "filename": "libstdc++-v3/include/profile/impl/profiler_hashtable_size.h", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n //\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -54,54 +54,60 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief Hashtable size instrumentation trace producer.  */\n-class __trace_hashtable_size : public __trace_container_size\n-{\n- public:\n-  __trace_hashtable_size() : __trace_container_size()\n+  /** @brief Hashtable size instrumentation trace producer.  */\n+  class __trace_hashtable_size\n+  : public __trace_container_size\n   {\n-    __id = \"hashtable-size\";\n-  }\n-};\n-\n-inline void __trace_hashtable_size_init()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_hashtable_size) = new __trace_hashtable_size();\n-}\n-\n-inline void __trace_hashtable_size_report(FILE* __f, \n-                                          __warning_vector_t& __warnings)\n-{\n-  if (_GLIBCXX_PROFILE_DATA(_S_hashtable_size)) {\n-    _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__collect_warnings(__warnings);\n-    _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__write(__f);\n+  public:\n+    __trace_hashtable_size()\n+    : __trace_container_size()\n+    { __id = \"hashtable-size\"; }\n+  };\n+\n+  inline void\n+  __trace_hashtable_size_init()\n+  { _GLIBCXX_PROFILE_DATA(_S_hashtable_size) = new __trace_hashtable_size(); }\n+\n+  inline void\n+  __trace_hashtable_size_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (_GLIBCXX_PROFILE_DATA(_S_hashtable_size))\n+      {\n+\t_GLIBCXX_PROFILE_DATA(_S_hashtable_size)->\n+\t  __collect_warnings(__warnings);\n+\t_GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__write(__f);\n+      }\n   }\n-}\n \n-inline void __trace_hashtable_size_construct(const void* __obj, size_t __num)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_hashtable_size_construct(const void* __obj, size_t __num)\n+  {\n+    if (!__profcxx_init())\n+      return;\n   \n-  _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__insert(__obj, __get_stack(),\n-                                                     __num);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__insert(__obj, __get_stack(),\n+\t\t\t\t\t\t       __num);\n+  }\n \n-inline void __trace_hashtable_size_destruct(const void* __obj, size_t __num, \n-                                            size_t __inum)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_hashtable_size_destruct(const void* __obj, size_t __num, \n+\t\t\t\t  size_t __inum)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__destruct(__obj, __num, __inum);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__destruct(__obj, __num, __inum);\n+  }\n \n-inline void __trace_hashtable_size_resize(const void* __obj, size_t __from, \n-                                          size_t __to)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_hashtable_size_resize(const void* __obj, size_t __from, \n+\t\t\t\tsize_t __to)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__resize(__obj, __from, __to);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__resize(__obj, __from, __to);\n+  }\n \n } // namespace __gnu_profile\n "}, {"sha": "ad924856142f23c7d0624a1bd20ca7a72dc9f2b8", "filename": "libstdc++-v3/include/profile/impl/profiler_list_to_slist.h", "status": "modified", "additions": 159, "deletions": 117, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_slist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_slist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_slist.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n //\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -52,131 +52,173 @@\n \n namespace __gnu_profile\n {\n-\n-class __list2slist_info: public __object_info_base\n-{\n- public:\n-  __list2slist_info() : _M_rewind(false), _M_operations(0) {}\n-  __list2slist_info(__stack_t __stack) \n-      : _M_rewind(false), _M_operations(0),__object_info_base(__stack) {}\n-  virtual ~__list2slist_info() {}\n-  __list2slist_info(const __list2slist_info& __o) : __object_info_base(__o)\n-  { _M_rewind = __o._M_rewind; _M_operations = __o._M_operations; }\n-  // XXX: the magnitude should be multiplied with a constant factor F,\n-  // where F is 1 when the malloc size class of list nodes is different\n-  // from the malloc size class of slist nodes.  When they fall into the same\n-  // class, the only slist benefit is from having to set fewer links, so\n-  // the factor F should be much smaller, closer to 0 than to 1.\n-  // This could be implemented by passing the size classes in the config file.\n-  // For now, we always assume F to be 1.\n-  float __magnitude() const\n-  { if (!_M_rewind) return _M_operations; else return 0; }\n-  void __merge(const __list2slist_info& __o) {};\n-  void __write(FILE* __f) const;\n-  const char* __advice() const\n-  { return strdup(\"change std::list to std::forward_list\"); }\n-  void __opr_rewind() { _M_rewind = true; _M_valid = false;}\n-  void __record_operation() { _M_operations++; }\n-  bool __has_rewind() { return _M_rewind; }\n-\n-private:\n-  bool _M_rewind;\n-  size_t _M_operations;\n-};\n-\n-class __list2slist_stack_info: public __list2slist_info {\n- public:\n-  __list2slist_stack_info(const __list2slist_info& __o) \n-      : __list2slist_info(__o) {}\n-};\n-\n-class __trace_list_to_slist\n-    : public __trace_base<__list2slist_info, __list2slist_stack_info> \n-{\n- public:\n-  ~__trace_list_to_slist() {}\n-  __trace_list_to_slist() \n-      : __trace_base<__list2slist_info, __list2slist_stack_info>()\n-  { __id = \"list-to-slist\"; }\n-  void __opr_rewind(const void* __obj);\n-  void __record_operation(const void* __obj);\n-  void __insert(const __object_t __obj, __stack_t __stack)\n-  { __add_object(__obj, __list2slist_info(__stack)); }\n-  void __destruct(const void* __obj);\n-};\n-\n-inline void __list2slist_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%s\\n\", _M_rewind ? \"invalid\" : \"valid\");\n-}\n-\n-inline void __trace_list_to_slist::__destruct(const void* __obj)\n-{\n-  if (!__is_on())\n-    return;\n-\n-  __list2slist_info* __res = __get_object_info(__obj);\n-  if (!__res)\n-    return;\n-\n-  __retire_object(__obj);\n-}\n-\n-inline void __trace_list_to_slist_init()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_list_to_slist) = new __trace_list_to_slist();\n-}\n-\n-inline void __trace_list_to_slist_report(FILE* __f, \n-                                       __warning_vector_t& __warnings)\n-{\n-  if (_GLIBCXX_PROFILE_DATA(_S_list_to_slist)) {\n-    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__collect_warnings(__warnings);\n-    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__write(__f);\n+  class __list2slist_info \n+  : public __object_info_base\n+  {\n+  public:\n+    __list2slist_info()\n+    : _M_rewind(false), _M_operations(0) { }\n+  \n+    __list2slist_info(__stack_t __stack)\n+    : __object_info_base(__stack), _M_rewind(false), _M_operations(0) { }\n+\n+    virtual ~__list2slist_info() { }\n+\n+    __list2slist_info(const __list2slist_info& __o)\n+    : __object_info_base(__o), _M_rewind(__o._M_rewind),\n+      _M_operations(__o._M_operations) { }\n+  \n+    // XXX: the magnitude should be multiplied with a constant factor F,\n+    // where F is 1 when the malloc size class of list nodes is different\n+    // from the malloc size class of slist nodes.  When they fall into the same\n+    // class, the only slist benefit is from having to set fewer links, so\n+    // the factor F should be much smaller, closer to 0 than to 1.\n+    // This could be implemented by passing the size classes in the config \n+    // file.  For now, we always assume F to be 1.\n+\n+    float\n+    __magnitude() const\n+    {\n+      if (!_M_rewind)\n+\treturn _M_operations;\n+      else\n+\treturn 0;\n+    }\n+    \n+    void\n+    __merge(const __list2slist_info&) { };\n+\n+    void\n+    __write(FILE* __f) const\n+    { fprintf(__f, \"%s\\n\", _M_rewind ? \"invalid\" : \"valid\"); }\n+\n+    const char*\n+    __advice() const\n+    { return strdup(\"change std::list to std::forward_list\"); }\n+\n+    void\n+    __opr_rewind()\n+    {\n+      _M_rewind = true;\n+      _M_valid = false;\n+    }\n+\n+    void\n+    __record_operation()\n+    { _M_operations++; }\n+\n+    bool\n+    __has_rewind()\n+    { return _M_rewind; }\n+\n+  private:\n+    bool _M_rewind;\n+    size_t _M_operations;\n+  };\n+\n+  class __list2slist_stack_info\n+  : public __list2slist_info\n+  {\n+  public:\n+    __list2slist_stack_info(const __list2slist_info& __o) \n+    : __list2slist_info(__o) { }\n+  };\n+\n+  class __trace_list_to_slist\n+  : public __trace_base<__list2slist_info, __list2slist_stack_info> \n+  {\n+  public:\n+    ~__trace_list_to_slist() { }\n+\n+    __trace_list_to_slist()\n+    : __trace_base<__list2slist_info, __list2slist_stack_info>()\n+    { __id = \"list-to-slist\"; }\n+\n+    void\n+    __opr_rewind(const void* __obj)\n+    {\n+      __list2slist_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__opr_rewind();\n+    }\n+\n+    void\n+    __record_operation(const void* __obj)\n+    {\n+      __list2slist_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__record_operation();\n+    }\n+\n+    void\n+    __insert(const __object_t __obj, __stack_t __stack)\n+    { __add_object(__obj, __list2slist_info(__stack)); }\n+  \n+    void\n+    __destruct(const void* __obj)\n+    {\n+      if (!__is_on())\n+\treturn;\n+\n+      __list2slist_info* __res = __get_object_info(__obj);\n+      if (!__res)\n+\treturn;\n+\n+      __retire_object(__obj);\n+    }\n+  };\n+\n+\n+  inline void\n+  __trace_list_to_slist_init()\n+  { _GLIBCXX_PROFILE_DATA(_S_list_to_slist) = new __trace_list_to_slist(); }\n+\n+  inline void\n+  __trace_list_to_slist_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (_GLIBCXX_PROFILE_DATA(_S_list_to_slist))\n+      {\n+\t_GLIBCXX_PROFILE_DATA(_S_list_to_slist)->\n+\t  __collect_warnings(__warnings);\n+\t_GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__write(__f);\n+      }\n   }\n-}\n \n-inline void __trace_list_to_slist::__opr_rewind(const void* __obj)\n-{\n-  __list2slist_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__opr_rewind();\n-}\n-\n-inline void __trace_list_to_slist::__record_operation(const void* __obj)\n-{\n-  __list2slist_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__record_operation();\n-}\n+  inline void\n+  __trace_list_to_slist_rewind(const void* __obj) \n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_list_to_slist_rewind(const void* __obj) \n-{\n-  if (!__profcxx_init()) return;\n-\n-  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__opr_rewind(__obj);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__opr_rewind(__obj);\n+  }\n \n-inline void __trace_list_to_slist_operation(const void* __obj) \n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_list_to_slist_operation(const void* __obj) \n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__record_operation(__obj);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__record_operation(__obj);\n+  }\n \n-inline void __trace_list_to_slist_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_list_to_slist_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__insert(__obj, __get_stack());\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__insert(__obj, __get_stack());\n+  }\n \n-inline void __trace_list_to_slist_destruct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_list_to_slist_destruct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__destruct(__obj);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__destruct(__obj);\n+  }\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_LIST_TO_SLIST_H */"}, {"sha": "f964b21ae62b2bd2d73a155a2d49ddcb8e66658e", "filename": "libstdc++-v3/include/profile/impl/profiler_list_to_vector.h", "status": "modified", "additions": 266, "deletions": 239, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_vector.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -54,260 +54,287 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief A list-to-vector instrumentation line in the object table.  */\n-class __list2vector_info: public __object_info_base\n-{\n- public:\n-  __list2vector_info()\n-      :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n-       _M_vector_cost(0), _M_valid(true), _M_max_size(0) {}\n-  __list2vector_info(__stack_t __stack)\n-      : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n-        _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true),\n-        _M_max_size(0) {}\n-  virtual ~__list2vector_info() {}\n-  __list2vector_info(const __list2vector_info& __o);\n-  void __merge(const __list2vector_info& __o);\n-  void __write(FILE* __f) const;\n-  float __magnitude() const { return _M_list_cost - _M_vector_cost; }\n-  const char* __advice() const;\n-  size_t __shift_count() { return _M_shift_count; }\n-  size_t __iterate()   { return _M_iterate; }\n-  float __list_cost() { return _M_list_cost; }\n-  size_t __resize() { return _M_resize; }\n-  void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n-  void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n-  bool __is_valid() { return _M_valid; }\n-  void __set_invalid() { _M_valid = false; }\n-\n-  void __opr_insert(size_t __shift, size_t __size);\n-  void __opr_iterate(size_t __num) { _M_iterate += __num;}\n-\n-  void __resize(size_t __from, size_t __to);\n-\n-private:\n-  size_t _M_shift_count;\n-  size_t _M_iterate;\n-  size_t _M_resize;\n-  float _M_list_cost;\n-  float _M_vector_cost;\n-  bool  _M_valid;\n-  size_t _M_max_size;\n-};\n-\n-inline __list2vector_info::__list2vector_info(const __list2vector_info& __o)\n-    : __object_info_base(__o)\n-{\n-  _M_shift_count  = __o._M_shift_count;\n-  _M_iterate      = __o._M_iterate;\n-  _M_vector_cost  = __o._M_vector_cost;\n-  _M_list_cost    = __o._M_list_cost;\n-  _M_valid        = __o._M_valid;\n-  _M_resize       = __o._M_resize;\n-  _M_max_size     = __o._M_max_size;\n-}\n-\n-inline const char* __list2vector_info::__advice() const {\n-  std::stringstream __sstream;\n-  __sstream \n-      << \"change std::list to std::vector and its initial size from 0 to \"\n-      << _M_max_size;\n-  return strdup(__sstream.str().c_str());\n-}\n-\n-inline void __list2vector_info::__merge(const __list2vector_info& __o)\n-{\n-  _M_shift_count  += __o._M_shift_count;\n-  _M_iterate      += __o._M_iterate;\n-  _M_vector_cost  += __o._M_vector_cost;\n-  _M_list_cost    += __o._M_list_cost;\n-  _M_valid        &= __o._M_valid;\n-  _M_resize       += __o._M_resize;\n-  _M_max_size     = std::max( _M_max_size, __o._M_max_size);\n-}\n-\n-inline void __list2vector_info::__opr_insert(size_t __shift, size_t __size) \n-{\n-  _M_shift_count += __shift;\n-  _M_max_size = std::max(_M_max_size, __size);\n-}\n-\n-inline void __list2vector_info::__resize(size_t __from, size_t __to)\n-{\n-  _M_resize += __from;\n-}\n-\n-class __list2vector_stack_info: public __list2vector_info {\n- public:\n-  __list2vector_stack_info(const __list2vector_info& __o) \n-      : __list2vector_info(__o) {}\n-};\n-\n-class __trace_list_to_vector\n-    : public __trace_base<__list2vector_info, __list2vector_stack_info> \n-{\n- public:\n-  __trace_list_to_vector();\n-  ~__trace_list_to_vector() {}\n-\n-  // Insert a new node at construct with object, callstack and initial size. \n-  void __insert(__object_t __obj, __stack_t __stack);\n-  // Call at destruction/clean to set container final size.\n-  void __destruct(const void* __obj);\n-\n-  // Find the node in the live map.\n-  __list2vector_info* __find(const void* __obj);\n-\n-  // Collect cost of operations.\n-  void __opr_insert(const void* __obj, size_t __shift, size_t __size);\n-  void __opr_iterate(const void* __obj, size_t __num);\n-  void __invalid_operator(const void* __obj);\n-  void __resize(const void* __obj, size_t __from, size_t __to);\n-  float __vector_cost(size_t __shift, size_t __iterate);\n-  float __list_cost(size_t __shift, size_t __iterate);\n-};\n-\n-inline __trace_list_to_vector::__trace_list_to_vector()\n+  /** @brief A list-to-vector instrumentation line in the object table.  */\n+  class __list2vector_info \n+  : public __object_info_base\n+  {\n+  public:\n+    __list2vector_info()\n+    : _M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n+      _M_vector_cost(0), _M_valid(true), _M_max_size(0) { }\n+\n+    __list2vector_info(__stack_t __stack)\n+    : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n+      _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true),\n+      _M_max_size(0) { }\n+\n+    virtual ~__list2vector_info() { }\n+\n+    __list2vector_info(const __list2vector_info& __o)\n+    : __object_info_base(__o), _M_shift_count(__o._M_shift_count),\n+      _M_iterate(__o._M_iterate), _M_resize(__o._M_resize),\n+      _M_list_cost(__o._M_list_cost), _M_vector_cost(__o._M_vector_cost),\n+      _M_valid(__o._M_valid), _M_max_size(__o._M_max_size) { }\n+\n+    void\n+    __merge(const __list2vector_info& __o)\n+    {\n+      _M_shift_count  += __o._M_shift_count;\n+      _M_iterate      += __o._M_iterate;\n+      _M_vector_cost  += __o._M_vector_cost;\n+      _M_list_cost    += __o._M_list_cost;\n+      _M_valid        &= __o._M_valid;\n+      _M_resize       += __o._M_resize;\n+      _M_max_size     = std::max( _M_max_size, __o._M_max_size);\n+    }\n+\n+    void\n+    __write(FILE* __f) const\n+    {\n+      fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\", _M_shift_count, _M_resize,\n+\t      _M_iterate, _M_vector_cost, _M_list_cost);\n+    }\n+\n+    float\n+    __magnitude() const\n+    { return _M_list_cost - _M_vector_cost; }\n+  \n+    const char*\n+    __advice() const\n+    {\n+      std::stringstream __sstream;\n+      __sstream \n+\t<< \"change std::list to std::vector and its initial size from 0 to \"\n+\t<< _M_max_size;\n+      return strdup(__sstream.str().c_str());\n+    }\n+\n+    size_t\n+    __shift_count()\n+    { return _M_shift_count; }\n+  \n+    size_t\n+    __iterate()\n+    { return _M_iterate; }\n+  \n+    float\n+    __list_cost()\n+    { return _M_list_cost; }\n+  \n+    size_t\n+    __resize()\n+    { return _M_resize; }\n+  \n+    void\n+    __set_list_cost(float __lc)\n+    { _M_list_cost = __lc; }\n+    \n+    void\n+    __set_vector_cost(float __vc)\n+    { _M_vector_cost = __vc; }\n+    \n+    bool\n+    __is_valid()\n+    { return _M_valid; }\n+    \n+    void\n+    __set_invalid()\n+    { _M_valid = false; }\n+\n+    void\n+    __opr_insert(size_t __shift, size_t __size)\n+    {\n+      _M_shift_count += __shift;\n+      _M_max_size = std::max(_M_max_size, __size);\n+    }\n+\n+    void\n+    __opr_iterate(size_t __num)\n+    { _M_iterate += __num;}\n+\n+    void\n+    __resize(size_t __from, size_t)\n+    { _M_resize += __from; }\n+\n+  private:\n+    size_t _M_shift_count;\n+    size_t _M_iterate;\n+    size_t _M_resize;\n+    float _M_list_cost;\n+    float _M_vector_cost;\n+    bool  _M_valid;\n+    size_t _M_max_size;\n+  };\n+\n+  class __list2vector_stack_info \n+  : public __list2vector_info\n+  {\n+  public:\n+    __list2vector_stack_info(const __list2vector_info& __o) \n+    : __list2vector_info(__o) {}\n+  };\n+\n+  class __trace_list_to_vector\n+  : public __trace_base<__list2vector_info, __list2vector_stack_info> \n+  {\n+  public:\n+    __trace_list_to_vector()\n     : __trace_base<__list2vector_info, __list2vector_stack_info>()\n-{\n-  __id = \"list-to-vector\";\n-}\n-\n-inline void __trace_list_to_vector::__insert(__object_t __obj,\n-                                             __stack_t __stack)\n-{\n-  __add_object(__obj, __list2vector_info(__stack));\n-}\n-\n-inline void __list2vector_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\",\n-          _M_shift_count, _M_resize, _M_iterate, _M_vector_cost, _M_list_cost);\n-}\n-\n-inline float __trace_list_to_vector::__vector_cost(size_t __shift, \n-                                                   size_t __iterate)\n-{\n-  // The resulting vector will use a 'reserve' method.\n-  return __shift * _GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor).__value + \n-      __iterate * _GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor).__value; \n-}\n-\n-inline float __trace_list_to_vector::__list_cost(size_t __shift, \n-                                                 size_t __iterate)\n-{\n-  return __shift * _GLIBCXX_PROFILE_DATA(__list_shift_cost_factor).__value + \n-      __iterate * _GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor).__value; \n-}\n-\n-inline void __trace_list_to_vector::__destruct(const void* __obj)\n-{\n-  if (!__is_on())\n-    return;\n-\n- __list2vector_info* __res = __get_object_info(__obj);\n-  if (!__res)\n-    return;\n-\n-  float __vc = __vector_cost(__res->__shift_count(), __res->__iterate());\n-  float __lc = __list_cost(__res->__shift_count(), __res->__iterate());\n-  __res->__set_vector_cost(__vc);\n-  __res->__set_list_cost(__lc);\n-  __retire_object(__obj);\n-}\n-\n-inline void __trace_list_to_vector::__opr_insert(const void* __obj, \n-                                                 size_t __shift, size_t __size)\n-{\n-  __list2vector_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__opr_insert(__shift, __size);\n-}\n-\n-inline void __trace_list_to_vector::__opr_iterate(const void* __obj,\n-                                                  size_t __num)\n-{\n-  __list2vector_info* __res = __get_object_info(__obj);\n-  if (__res) {\n-    __res->__opr_iterate(__num);\n+    { __id = \"list-to-vector\"; }\n+\n+    ~__trace_list_to_vector() { }\n+\n+    // Insert a new node at construct with object, callstack and initial size.\n+    void\n+    __insert(__object_t __obj, __stack_t __stack)\n+    { __add_object(__obj, __list2vector_info(__stack)); }\n+\n+    // Call at destruction/clean to set container final size.\n+    void\n+    __destruct(const void* __obj)\n+    {\n+      if (!__is_on())\n+\treturn;\n+\n+      __list2vector_info* __res = __get_object_info(__obj);\n+      if (!__res)\n+\treturn;\n+\n+      float __vc = __vector_cost(__res->__shift_count(), __res->__iterate());\n+      float __lc = __list_cost(__res->__shift_count(), __res->__iterate());\n+      __res->__set_vector_cost(__vc);\n+      __res->__set_list_cost(__lc);\n+      __retire_object(__obj);\n+    }\n+\n+    // Find the node in the live map.\n+    __list2vector_info* __find(const void* __obj);\n+\n+    // Collect cost of operations.\n+    void\n+    __opr_insert(const void* __obj, size_t __shift, size_t __size)\n+    {\n+      __list2vector_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__opr_insert(__shift, __size);\n+    }\n+\n+    void\n+    __opr_iterate(const void* __obj, size_t __num)\n+    {\n+      __list2vector_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__opr_iterate(__num);\n+    }\n+\n+    void\n+    __invalid_operator(const void* __obj)\n+    {\n+      __list2vector_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__set_invalid();\n+    }\n+\n+    void\n+    __resize(const void* __obj, size_t __from, size_t __to)\n+    {\n+      __list2vector_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__resize(__from, __to);\n+    }\n+\n+    float\n+    __vector_cost(size_t __shift, size_t __iterate)\n+    {\n+      // The resulting vector will use a 'reserve' method.\n+      return (__shift\n+\t      * _GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor).__value\n+\t      + __iterate\n+\t      * _GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor).__value); \n+    }\n+\n+    float\n+    __list_cost(size_t __shift, size_t __iterate)\n+    {\n+      return (__shift\n+\t      * _GLIBCXX_PROFILE_DATA(__list_shift_cost_factor).__value\n+\t      + __iterate\n+\t      * _GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor).__value); \n+    }\n+  };\n+\n+\n+  inline void\n+  __trace_list_to_vector_init()\n+  { _GLIBCXX_PROFILE_DATA(_S_list_to_vector) = new __trace_list_to_vector(); }\n+\n+  inline void\n+  __trace_list_to_vector_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (_GLIBCXX_PROFILE_DATA(_S_list_to_vector))\n+      {\n+\t_GLIBCXX_PROFILE_DATA(_S_list_to_vector)->\n+\t  __collect_warnings(__warnings);\n+\t_GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__write(__f);\n+      }\n   }\n-}\n-\n-inline void __trace_list_to_vector::__invalid_operator(const void* __obj)\n-{\n-  __list2vector_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__set_invalid();\n-}\n \n-inline void __trace_list_to_vector::__resize(const void* __obj, size_t __from, \n-                                             size_t __to)\n-{\n-  __list2vector_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__resize(__from, __to);\n-}\n+  inline void\n+  __trace_list_to_vector_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_list_to_vector_init()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_list_to_vector) = new __trace_list_to_vector();\n-}\n-\n-inline void __trace_list_to_vector_report(FILE* __f, \n-                                          __warning_vector_t& __warnings)\n-{\n-  if (_GLIBCXX_PROFILE_DATA(_S_list_to_vector)) {\n-    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__collect_warnings(__warnings);\n-    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__write(__f);\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__insert(__obj, __get_stack());\n   }\n-}\n-\n-inline void __trace_list_to_vector_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n-\n-  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__insert(__obj, __get_stack());\n-}\n \n-inline void __trace_list_to_vector_destruct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n-\n-  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__destruct(__obj);\n-}\n+  inline void\n+  __trace_list_to_vector_destruct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_list_to_vector_insert(const void* __obj, \n-                                          size_t __shift, size_t __size)\n-{\n-  if (!__profcxx_init()) return;\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__destruct(__obj);\n+  }\n \n-  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__opr_insert(__obj, __shift, \n-                                                         __size);\n-}\n+  inline void\n+  __trace_list_to_vector_insert(const void* __obj, \n+\t\t\t\tsize_t __shift, size_t __size)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__opr_insert(__obj, __shift, \n+\t\t\t\t\t\t\t   __size);\n+  }\n \n-inline void __trace_list_to_vector_iterate(const void* __obj, size_t __num = 1)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_list_to_vector_iterate(const void* __obj, size_t __num = 1)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__opr_iterate(__obj, __num);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__opr_iterate(__obj, __num);\n+  }\n \n-inline void __trace_list_to_vector_invalid_operator(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_list_to_vector_invalid_operator(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__invalid_operator(__obj);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__invalid_operator(__obj);\n+  }\n \n-inline void __trace_list_to_vector_resize(const void* __obj, \n-                                          size_t __from, size_t __to)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_list_to_vector_resize(const void* __obj, \n+\t\t\t\tsize_t __from, size_t __to)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__resize(__obj, __from, __to);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__resize(__obj, __from, __to);\n+  }\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_LIST_TO_VECTOR_H__ */"}, {"sha": "e3cc29718c6fee6cef60ae212f07d0301d48577a", "filename": "libstdc++-v3/include/profile/impl/profiler_map_to_unordered_map.h", "status": "modified", "additions": 221, "deletions": 207, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n //\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -52,241 +52,255 @@\n \n namespace __gnu_profile\n {\n-\n-inline int __log2(size_t __size)\n-{\n-  for (int __bit_count = sizeof(size_t) - 1; __bit_count >= 0; -- __bit_count) \n+  inline int\n+  __log2(size_t __size)\n   {\n-    if ((2 << __bit_count) & __size) {\n-      return __bit_count;\n-    }\n+    for (int __bit_count = sizeof(size_t) - 1; __bit_count >= 0;\n+\t -- __bit_count) \n+      if ((2 << __bit_count) & __size)\n+\treturn __bit_count;\n+    return 0;\n   }\n-  return 0;\n-}\n-\n-inline float __map_insert_cost(size_t __size)\n-{\n-  return (_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor).__value \n-          * static_cast<float>(__log2(__size)));\n-}\n-\n-inline float __map_erase_cost(size_t __size)\n-{\n-  return (_GLIBCXX_PROFILE_DATA(__map_erase_cost_factor).__value\n-          * static_cast<float>(__log2(__size)));\n-}\n \n-inline float __map_find_cost(size_t __size)\n-{\n-  return (_GLIBCXX_PROFILE_DATA(__map_find_cost_factor).__value\n-          * static_cast<float>(__log2(__size)));\n-}\n-\n-/** @brief A map-to-unordered_map instrumentation line in the object table.  */\n-class __map2umap_info: public __object_info_base\n-{\n- public:\n-  __map2umap_info()\n-      : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n-        _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {}\n-  __map2umap_info(__stack_t __stack)\n-      : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n-        _M_iterate(0), _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {} \n-  virtual ~__map2umap_info() {}\n-  __map2umap_info(const __map2umap_info& o);\n-  void __merge(const __map2umap_info& o);\n-  void __write(FILE* __f) const;\n-  float __magnitude() const { return _M_map_cost - _M_umap_cost; }\n-  const char* __advice() const;\n-\n-  void __record_insert(size_t __size, size_t __count);\n-  void __record_erase(size_t __size, size_t __count);\n-  void __record_find(size_t __size);\n-  void __record_iterate(size_t __count);\n-  void __record_invalidate();\n-\n- private:\n-  size_t _M_insert;\n-  size_t _M_erase;\n-  size_t _M_find;\n-  size_t _M_iterate;\n-  float _M_umap_cost;\n-  float _M_map_cost;\n-  bool  _M_valid;\n-};\n-\n-inline const char* __map2umap_info::__advice() const\n-{\n-  return strdup(\"change std::map to std::unordered_map\");\n-}\n-\n-inline __map2umap_info::__map2umap_info(const __map2umap_info& __o)\n-    : __object_info_base(__o), \n-      _M_insert(__o._M_insert),\n-      _M_erase(__o._M_erase),\n-      _M_find(__o._M_find),\n-      _M_iterate(__o._M_iterate),\n-      _M_map_cost(__o._M_map_cost),\n-      _M_umap_cost(__o._M_umap_cost),\n-      _M_valid(__o._M_valid)\n-{}\n-\n-inline void __map2umap_info::__merge(const __map2umap_info& __o)\n-{\n-  _M_insert    += __o._M_insert;\n-  _M_erase     += __o._M_erase;\n-  _M_find      += __o._M_find;\n-  _M_map_cost  += __o._M_map_cost;\n-  _M_umap_cost += __o._M_umap_cost;\n-  _M_valid     &= __o._M_valid;\n-}\n-\n-inline void __map2umap_info:: __record_insert(size_t __size, size_t __count)\n-{\n-  _M_insert += __count;\n-  _M_map_cost += __count * __map_insert_cost(__size);\n-  _M_umap_cost += (__count\n-                   * _GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor).__value);\n-}\n-\n-inline void __map2umap_info:: __record_erase(size_t __size, size_t __count)\n-{\n-  _M_erase += __count;\n-  _M_map_cost += __count * __map_erase_cost(__size);\n-  _M_umap_cost += (__count\n-                   * _GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor).__value);\n-}\n-\n-inline void __map2umap_info:: __record_find(size_t __size)\n-{\n-  _M_find += 1;\n-  _M_map_cost += __map_find_cost(__size);\n-  _M_umap_cost += _GLIBCXX_PROFILE_DATA(__umap_find_cost_factor).__value;\n-}\n+  inline float\n+  __map_insert_cost(size_t __size)\n+  { return (_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor).__value \n+\t    * static_cast<float>(__log2(__size))); }\n+\n+  inline float\n+  __map_erase_cost(size_t __size)\n+  { return (_GLIBCXX_PROFILE_DATA(__map_erase_cost_factor).__value\n+\t    * static_cast<float>(__log2(__size))); }\n+\n+  inline float\n+  __map_find_cost(size_t __size)\n+  { return (_GLIBCXX_PROFILE_DATA(__map_find_cost_factor).__value\n+\t    * static_cast<float>(__log2(__size))); }\n+\n+  /** @brief A map-to-unordered_map instrumentation line in the \n+      object table.  */\n+  class __map2umap_info \n+  : public __object_info_base\n+  {\n+  public:\n+    __map2umap_info()\n+    : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n+      _M_umap_cost(0.0), _M_map_cost(0.0), _M_valid(true) { }\n+    \n+    __map2umap_info(__stack_t __stack)\n+    : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n+      _M_iterate(0), _M_umap_cost(0.0), _M_map_cost(0.0), _M_valid(true) { }\n+\n+    virtual ~__map2umap_info() { }\n+\n+    __map2umap_info(const __map2umap_info& __o)\n+    : __object_info_base(__o), _M_insert(__o._M_insert),\n+      _M_erase(__o._M_erase), _M_find(__o._M_find),\n+      _M_iterate(__o._M_iterate), _M_umap_cost(__o._M_umap_cost),\n+      _M_map_cost(__o._M_map_cost), _M_valid(__o._M_valid) { }\n+\n+    void\n+    __merge(const __map2umap_info& __o)\n+    {\n+      _M_insert    += __o._M_insert;\n+      _M_erase     += __o._M_erase;\n+      _M_find      += __o._M_find;\n+      _M_umap_cost += __o._M_umap_cost;\n+      _M_map_cost  += __o._M_map_cost;\n+      _M_valid     &= __o._M_valid;\n+    }\n \n-inline void __map2umap_info:: __record_iterate(size_t __count)\n-{\n-  _M_iterate += __count;\n-  _M_map_cost += (__count\n-                  * _GLIBCXX_PROFILE_DATA(__map_iterate_cost_factor).__value);\n-  _M_umap_cost += (\n-      __count * _GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor).__value);\n-}\n-\n-inline void __map2umap_info:: __record_invalidate()\n-{\n-  _M_valid = false;\n-}\n+    void\n+    __write(FILE* __f) const\n+    {\n+      fprintf(__f, \"%Zu %Zu %Zu %Zu %.0f %.0f %s\\n\",\n+\t      _M_insert, _M_erase, _M_find, _M_iterate, _M_map_cost,\n+\t      _M_umap_cost, _M_valid ? \"valid\" : \"invalid\");\n+    }\n+    \n+    float\n+    __magnitude() const\n+    { return _M_map_cost - _M_umap_cost; }\n+\n+    const char*\n+    __advice() const\n+    { return strdup(\"change std::map to std::unordered_map\"); }\n+\n+    void\n+    __record_insert(size_t __size, size_t __count)\n+    {\n+      _M_insert += __count;\n+      _M_map_cost += __count * __map_insert_cost(__size);\n+      _M_umap_cost\n+\t+= (__count\n+\t    * _GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor).__value);\n+    }\n \n-inline void __map2umap_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu %Zu %.0f %.0f %s\\n\",\n-          _M_insert, _M_erase, _M_find, _M_iterate, _M_map_cost, _M_umap_cost,\n-          _M_valid ? \"valid\" : \"invalid\");\n-}\n+    void\n+    __record_erase(size_t __size, size_t __count)\n+    {\n+      _M_erase += __count;\n+      _M_map_cost += __count * __map_erase_cost(__size);\n+      _M_umap_cost\n+\t+= (__count\n+\t    * _GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor).__value);\n+    }\n \n-/** @brief A map-to-unordered_map instrumentation line in the stack table.  */\n-class __map2umap_stack_info: public __map2umap_info\n-{\n- public:\n-  __map2umap_stack_info(const __map2umap_info& o) : __map2umap_info(o) {}\n-};\n+    void\n+    __record_find(size_t __size)\n+    {\n+      _M_find += 1;\n+      _M_map_cost += __map_find_cost(__size);\n+      _M_umap_cost += _GLIBCXX_PROFILE_DATA(__umap_find_cost_factor).__value;\n+    }\n \n-/** @brief Map-to-unordered_map instrumentation producer.  */\n-class __trace_map2umap\n-    : public __trace_base<__map2umap_info, __map2umap_stack_info> \n-{\n- public:\n-  __trace_map2umap();\n-};\n+    void\n+    __record_iterate(size_t __count)\n+    {\n+      _M_iterate += __count;\n+      _M_map_cost\n+\t+= (__count\n+\t    * _GLIBCXX_PROFILE_DATA(__map_iterate_cost_factor).__value);\n+      _M_umap_cost\n+\t+= (__count\n+\t    * _GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor).__value);\n+    }\n \n-inline __trace_map2umap::__trace_map2umap()\n+    void\n+    __record_invalidate()\n+    { _M_valid = false; }\n+\n+  private:\n+    size_t _M_insert;\n+    size_t _M_erase;\n+    size_t _M_find;\n+    size_t _M_iterate;\n+    float _M_umap_cost;\n+    float _M_map_cost;\n+    bool  _M_valid;\n+  };\n+\n+\n+  /** @brief A map-to-unordered_map instrumentation line in the \n+      stack table.  */\n+  class __map2umap_stack_info \n+  : public __map2umap_info\n+  {\n+  public:\n+    __map2umap_stack_info(const __map2umap_info& __o)\n+    : __map2umap_info(__o) { }\n+  };\n+\n+  /** @brief Map-to-unordered_map instrumentation producer.  */\n+  class __trace_map2umap\n+  : public __trace_base<__map2umap_info, __map2umap_stack_info> \n+  {\n+  public:\n+    __trace_map2umap()\n     : __trace_base<__map2umap_info, __map2umap_stack_info>()\n-{\n-  __id = \"map-to-unordered-map\";\n-}\n+    { __id = \"map-to-unordered-map\"; }\n+  };\n \n-inline void __trace_map_to_unordered_map_init()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_map2umap) = new __trace_map2umap();\n-}\n+  inline void\n+  __trace_map_to_unordered_map_init()\n+  { _GLIBCXX_PROFILE_DATA(_S_map2umap) = new __trace_map2umap(); }\n \n-inline void __trace_map_to_unordered_map_report(\n-    FILE* __f, __warning_vector_t& __warnings)\n-{\n-  if (_GLIBCXX_PROFILE_DATA(_S_map2umap)) {\n-    _GLIBCXX_PROFILE_DATA(_S_map2umap)->__collect_warnings(__warnings);\n-    _GLIBCXX_PROFILE_DATA(_S_map2umap)->__write(__f);\n+  inline void\n+  __trace_map_to_unordered_map_report(FILE* __f,\n+\t\t\t\t      __warning_vector_t& __warnings)\n+  {\n+    if (_GLIBCXX_PROFILE_DATA(_S_map2umap)) \n+      {\n+\t_GLIBCXX_PROFILE_DATA(_S_map2umap)->__collect_warnings(__warnings);\n+\t_GLIBCXX_PROFILE_DATA(_S_map2umap)->__write(__f);\n+      }\n   }\n-}\n-\n-inline void __trace_map_to_unordered_map_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_map2umap)->__add_object(\n-      __obj, __map2umap_info(__get_stack()));\n-}\n-\n-inline void __trace_map_to_unordered_map_destruct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_map_to_unordered_map_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_map2umap)->__retire_object(__obj);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_map2umap)->\n+      __add_object(__obj, __map2umap_info(__get_stack()));\n+  }\n \n-inline void __trace_map_to_unordered_map_insert(const void* __obj, \n-                                                size_t __size, size_t __count)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_map_to_unordered_map_destruct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  __map2umap_info* __info =\n-      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n+    _GLIBCXX_PROFILE_DATA(_S_map2umap)->__retire_object(__obj);\n+  }\n \n-  if (__info) __info->__record_insert(__size, __count);\n-}\n+  inline void\n+  __trace_map_to_unordered_map_insert(const void* __obj, \n+\t\t\t\t      size_t __size, size_t __count)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_map_to_unordered_map_erase(const void* __obj, \n-                                               size_t __size, size_t __count)\n-{\n-  if (!__profcxx_init()) return;\n+    __map2umap_info* __info\n+      = _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-  __map2umap_info* __info =\n-      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n+    if (__info)\n+      __info->__record_insert(__size, __count);\n+  }\n \n-  if (__info) __info->__record_erase(__size, __count);\n-}\n+  inline void\n+  __trace_map_to_unordered_map_erase(const void* __obj, \n+\t\t\t\t     size_t __size, size_t __count)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-inline void __trace_map_to_unordered_map_find(const void* __obj, size_t __size)\n-{\n-  if (!__profcxx_init()) return;\n+    __map2umap_info* __info \n+      = _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-  __map2umap_info* __info =\n-      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n+    if (__info)\n+      __info->__record_erase(__size, __count);\n+  }\n \n-  if (__info) __info->__record_find(__size);\n-}\n+  inline void\n+  __trace_map_to_unordered_map_find(const void* __obj, size_t __size)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_map_to_unordered_map_iterate(const void* __obj, \n-                                                 size_t __count)\n-{\n-  if (!__profcxx_init()) return;\n+    __map2umap_info* __info\n+      = _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-  __map2umap_info* __info =\n-      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n+    if (__info)\n+      __info->__record_find(__size);\n+  }\n \n-  if (__info) __info->__record_iterate(__count);\n-}\n+  inline void\n+  __trace_map_to_unordered_map_iterate(const void* __obj, size_t __count)\n+  {\n+    if (!__profcxx_init())\n+      return;\n+\n+    __map2umap_info* __info\n+      = _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n+    \n+    if (__info)\n+      __info->__record_iterate(__count);\n+  }\n \n-inline void __trace_map_to_unordered_map_invalidate(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_map_to_unordered_map_invalidate(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  __map2umap_info* __info =\n-      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n+    __map2umap_info* __info\n+      = _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-  if (__info) __info->__record_invalidate();\n-}\n+    if (__info)\n+      __info->__record_invalidate();\n+  }\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_MAP_TO_UNORDERED_MAP_H */"}, {"sha": "2e29b69de186b5f024f5e6c3ea88e36c35af1957", "filename": "libstdc++-v3/include/profile/impl/profiler_node.h", "status": "modified", "additions": 102, "deletions": 97, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -53,120 +53,125 @@\n \n namespace __gnu_profile\n {\n-typedef const void* __object_t;\n-typedef void* __instruction_address_t;\n-typedef std::_GLIBCXX_STD_PR::vector<__instruction_address_t> __stack_npt;\n-typedef __stack_npt* __stack_t;\n+  typedef const void* __object_t;\n+  typedef void* __instruction_address_t;\n+  typedef std::_GLIBCXX_STD_PR::vector<__instruction_address_t> __stack_npt;\n+  typedef __stack_npt* __stack_t;\n \n-size_t __stack_max_depth();\n+  size_t __stack_max_depth();\n \n-inline __stack_t __get_stack()\n-{\n+  inline __stack_t\n+  __get_stack()\n+  {\n #if defined _GLIBCXX_HAVE_EXECINFO_H\n-  size_t __max_depth = __stack_max_depth();\n-  if (__max_depth == 0)\n-    return 0;\n-  __stack_npt __buffer(__max_depth);\n-  int __depth = backtrace(&__buffer[0], __max_depth);\n-  __stack_t __stack = new __stack_npt(__depth);\n-  memcpy(&(*__stack)[0], &__buffer[0], __depth * sizeof(__object_t));\n-  return __stack;\n+    size_t __max_depth = __stack_max_depth();\n+    if (__max_depth == 0)\n+      return 0;\n+    __stack_npt __buffer(__max_depth);\n+    int __depth = backtrace(&__buffer[0], __max_depth);\n+    __stack_t __stack = new __stack_npt(__depth);\n+    memcpy(&(*__stack)[0], &__buffer[0], __depth * sizeof(__object_t));\n+    return __stack;\n #else\n-  return 0;\n-#endif\n-}\n-\n-inline __size(const __stack_t& __stack)\n-{\n-  if (!__stack) {\n     return 0;\n-  } else {\n-    return __stack->size();\n-  }\n-}\n-\n-inline void __write(FILE* __f, const __stack_t __stack)\n-{\n-  if (!__stack) {\n-    return;\n-  }\n-\n-  __stack_npt::const_iterator __it;\n-  for (__it = __stack->begin(); __it != __stack->end(); ++__it) {\n-    fprintf(__f, \"%p \", *__it);\n+#endif\n   }\n-}\n \n-/** @brief Hash function for summary trace using call stack as index.  */\n-class __stack_hash \n-{\n- public:\n-  size_t operator()(const __stack_t __s) const\n+  inline size_t\n+  __size(__stack_t __stack)\n   {\n-    if (!__s) {\n+    if (!__stack)\n       return 0;\n-    }\n+    else\n+      return __stack->size();\n+  }\n \n-    uintptr_t __index = 0;\n+  // XXX\n+  inline void\n+  __write(FILE* __f, __stack_t __stack)\n+  {\n+    if (!__stack)\n+      return;\n+  \n     __stack_npt::const_iterator __it;\n-    for (__it = __s->begin(); __it != __s->end(); ++__it) {\n-      __index += reinterpret_cast<uintptr_t>(*__it);\n-    } \n-    return __index;\n+    for (__it = __stack->begin(); __it != __stack->end(); ++__it)\n+      fprintf(__f, \"%p \", *__it);\n   }\n \n-  bool operator() (const __stack_t __stack1, const __stack_t __stack2) const\n+  /** @brief Hash function for summary trace using call stack as index.  */\n+  class __stack_hash \n   {\n-    if (!__stack1 && !__stack2) return true;\n-    if (!__stack1 || !__stack2) return false;\n-    if (__stack1->size() != __stack2->size()) return false;\n-\n-    size_t __byte_size = __stack1->size() * sizeof(__stack_npt::value_type);\n-    return memcmp(&(*__stack1)[0], &(*__stack2)[0], __byte_size) == 0;\n-  }\n-};\n+  public:\n+    size_t\n+    operator()(__stack_t __s) const\n+    {\n+      if (!__s) \n+\treturn 0;\n+\n+      uintptr_t __index = 0;\n+      __stack_npt::const_iterator __it;\n+      for (__it = __s->begin(); __it != __s->end(); ++__it)\n+\t__index += reinterpret_cast<uintptr_t>(*__it);\n+      return __index;\n+    }\n \n-/** @brief Base class for a line in the object table.  */\n-class __object_info_base\n-{\n- public:\n-  __object_info_base() {}\n-  __object_info_base(__stack_t __stack);\n-  __object_info_base(const __object_info_base& o);\n-  virtual ~__object_info_base() {}\n-  bool __is_valid() const { return _M_valid; }\n-  __stack_t __stack() const { return _M_stack; }\n-  virtual void __write(FILE* f) const = 0;\n-\n- protected:\n-  __stack_t _M_stack;\n-  bool _M_valid;\n-};\n-\n-inline __object_info_base::__object_info_base(__stack_t __stack)\n-{\n-  _M_stack = __stack;\n-  _M_valid = true;\n-}\n+    bool operator() (__stack_t __stack1, __stack_t __stack2) const\n+    {\n+      if (!__stack1 && !__stack2)\n+\treturn true;\n+      if (!__stack1 || !__stack2)\n+\treturn false;\n+      if (__stack1->size() != __stack2->size())\n+\treturn false;\n+\n+      size_t __byte_size = __stack1->size() * sizeof(__stack_npt::value_type);\n+      return memcmp(&(*__stack1)[0], &(*__stack2)[0], __byte_size) == 0;\n+    }\n+  };\n \n-inline __object_info_base::__object_info_base(const __object_info_base& __o)\n-{\n-  _M_stack = __o._M_stack;\n-  _M_valid = __o._M_valid;\n-}\n \n-/** @brief Base class for a line in the stack table.  */\n-template<typename __object_info>\n-class __stack_info_base\n-{\n- public:\n-  __stack_info_base() {}\n-  __stack_info_base(const __object_info& __info) = 0;\n-  virtual ~__stack_info_base() {}\n-  void __merge(const __object_info& __info) = 0;\n-  virtual float __magnitude() const = 0;\n-  virtual const char* __get_id() const = 0;\n-};\n+  /** @brief Base class for a line in the object table.  */\n+  class __object_info_base\n+  {\n+  public:\n+    __object_info_base() { }\n+\n+    __object_info_base(__stack_t __stack)\n+    : _M_stack(__stack), _M_valid(true) { }\n+\n+    __object_info_base(const __object_info_base& __o)\n+    : _M_stack(__o._M_stack), _M_valid(__o._M_valid) { }\n+\n+    virtual ~__object_info_base() { }\n+\n+    bool\n+    __is_valid() const \n+    { return _M_valid; }\n+    \n+    __stack_t\n+    __stack() const\n+    { return _M_stack; }\n+    \n+    virtual void __write(FILE* f) const = 0;\n+\n+  protected:\n+    __stack_t _M_stack;\n+    bool _M_valid;\n+  };\n+\n+\n+  /** @brief Base class for a line in the stack table.  */\n+  template<typename __object_info>\n+    class __stack_info_base\n+    {\n+    public:\n+      __stack_info_base() { }\n+      __stack_info_base(const __object_info& __info) = 0;\n+      virtual ~__stack_info_base() {}\n+      void __merge(const __object_info& __info) = 0;\n+      virtual float __magnitude() const = 0;\n+      virtual const char* __get_id() const = 0;\n+    };\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_NODE_H */"}, {"sha": "111b97e0ecabed3ff152de152ad560f81bf24dd6", "filename": "libstdc++-v3/include/profile/impl/profiler_state.h", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n //\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -39,32 +39,35 @@\n \n namespace __gnu_profile\n {\n+  enum __state_type { __ON, __OFF, __INVALID };\n \n-enum __state_type { __ON, __OFF, __INVALID };\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__state_type, __state, __INVALID);\n \n-_GLIBCXX_PROFILE_DEFINE_DATA(__state_type, __state, __INVALID);\n+  inline bool\n+  __turn(__state_type __s)\n+  { return (_GLIBCXX_PROFILE_DATA(__state)\n+\t    == __sync_val_compare_and_swap(&_GLIBCXX_PROFILE_DATA(__state),\n+\t\t\t\t\t   __INVALID, __s)); }\n \n-inline bool __turn(__state_type __s)\n-{\n-  return (_GLIBCXX_PROFILE_DATA(__state)\n-          == __sync_val_compare_and_swap(&_GLIBCXX_PROFILE_DATA(__state),\n-                                         __INVALID, __s));\n-}\n-\n-inline bool __turn_on()\n-{ return __turn(__ON); }\n+  inline bool\n+  __turn_on()\n+  { return __turn(__ON); }\n \n-inline bool __turn_off()\n-{ return __turn(__OFF); }\n+  inline bool\n+  __turn_off()\n+  { return __turn(__OFF); }\n \n-inline bool __is_on()\n-{ return _GLIBCXX_PROFILE_DATA(__state) == __ON; }\n+  inline bool\n+  __is_on()\n+  { return _GLIBCXX_PROFILE_DATA(__state) == __ON; }\n \n-inline bool __is_off()\n-{ return _GLIBCXX_PROFILE_DATA(__state) == __OFF; }\n+  inline bool\n+  __is_off()\n+  { return _GLIBCXX_PROFILE_DATA(__state) == __OFF; }\n \n-inline bool __is_invalid()\n-{ return _GLIBCXX_PROFILE_DATA(__state) == __INVALID; }\n+  inline bool\n+  __is_invalid()\n+  { return _GLIBCXX_PROFILE_DATA(__state) == __INVALID; }\n \n } // end namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_STATE_H */"}, {"sha": "4679eddbe5d872b0505a5a381215be38b2f8ed7d", "filename": "libstdc++-v3/include/profile/impl/profiler_trace.h", "status": "modified", "additions": 531, "deletions": 490, "changes": 1021, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -65,333 +65,371 @@\n \n namespace __gnu_profile\n {\n-/** @brief Internal environment.  Values can be set one of two ways:\n-    1. In config file \"var = value\".  The default config file path is \n-       libstdcxx-profile.conf.\n-    2. By setting process environment variables.  For instance, in a Bash\n-       shell you can set the unit cost of iterating through a map like this:\n-       export __map_iterate_cost_factor=5.0.\n-    If a value is set both in the input file and through an environment\n-    variable, the environment value takes precedence.  */\n-typedef _GLIBCXX_IMPL_UNORDERED_MAP<std::string, std::string> __env_t;\n-_GLIBCXX_PROFILE_DEFINE_UNINIT_DATA(__env_t, __env);\n-\n-/** @brief Master lock.  */\n-_GLIBCXX_PROFILE_DEFINE_UNINIT_DATA(__gnu_cxx::__mutex, __global_lock);\n-\n-/** @brief Representation of a warning.  */\n-struct __warning_data\n-{\n-  float __magnitude;\n-  __stack_t __context;\n-  const char* __warning_id;\n-  const char* __warning_message;\n-  __warning_data()\n-  : __magnitude(0.0), __context(0), __warning_id(0),\n+  /** @brief Internal environment.  Values can be set one of two ways:\n+      1. In config file \"var = value\".  The default config file path is \n+         libstdcxx-profile.conf.\n+      2. By setting process environment variables.  For instance, in a Bash\n+         shell you can set the unit cost of iterating through a map like this:\n+         export __map_iterate_cost_factor=5.0.\n+\t If a value is set both in the input file and through an environment\n+\t variable, the environment value takes precedence.  */\n+  typedef _GLIBCXX_IMPL_UNORDERED_MAP<std::string, std::string> __env_t;\n+\n+  _GLIBCXX_PROFILE_DEFINE_UNINIT_DATA(__env_t, __env);\n+\n+  /** @brief Master lock.  */\n+  _GLIBCXX_PROFILE_DEFINE_UNINIT_DATA(__gnu_cxx::__mutex, __global_lock);\n+\n+  /** @brief Representation of a warning.  */\n+  struct __warning_data\n+  {\n+    float __magnitude;\n+    __stack_t __context;\n+    const char* __warning_id;\n+    const char* __warning_message;\n+    __warning_data()\n+    : __magnitude(0.0), __context(0), __warning_id(0),\n+    \n     __warning_message(0) { }\n-  __warning_data(float __m, __stack_t __c, const char* __id, \n-                 const char* __msg)\n-  : __magnitude(__m), __context(__c), __warning_id(__id), \n-    __warning_message(__msg) { }\n-  bool operator<(const struct __warning_data& __other) const\n-  { return __magnitude < __other.__magnitude; }\n-};\n-\n-typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n-\n-// Defined in profiler_<diagnostic name>.h.\n-class __trace_hash_func;\n-class __trace_hashtable_size;\n-class __trace_map2umap;\n-class __trace_vector_size;\n-class __trace_vector_to_list;\n-class __trace_list_to_slist; \n-class __trace_list_to_vector; \n-void __trace_vector_size_init();\n-void __trace_hashtable_size_init();\n-void __trace_hash_func_init();\n-void __trace_vector_to_list_init();\n-void __trace_list_to_slist_init();  \n-void __trace_list_to_vector_init();  \n-void __trace_map_to_unordered_map_init();\n-void __trace_vector_size_report(FILE*, __warning_vector_t&);\n-void __trace_hashtable_size_report(FILE*, __warning_vector_t&);\n-void __trace_hash_func_report(FILE*, __warning_vector_t&);\n-void __trace_vector_to_list_report(FILE*, __warning_vector_t&);\n-void __trace_list_to_slist_report(FILE*, __warning_vector_t&); \n-void __trace_list_to_vector_report(FILE*, __warning_vector_t&);\n-void __trace_map_to_unordered_map_report(FILE*, __warning_vector_t&);\n-\n-struct __cost_factor\n-{\n-  const char* __env_var;\n-  float __value;\n-};\n-\n-typedef std::_GLIBCXX_STD_PR::vector<__cost_factor*> __cost_factor_vector;\n-\n-_GLIBCXX_PROFILE_DEFINE_DATA(__trace_hash_func*, _S_hash_func, 0);\n-_GLIBCXX_PROFILE_DEFINE_DATA(__trace_hashtable_size*, _S_hashtable_size, 0);\n-_GLIBCXX_PROFILE_DEFINE_DATA(__trace_map2umap*, _S_map2umap, 0);\n-_GLIBCXX_PROFILE_DEFINE_DATA(__trace_vector_size*, _S_vector_size, 0);\n-_GLIBCXX_PROFILE_DEFINE_DATA(__trace_vector_to_list*, _S_vector_to_list, 0);\n-_GLIBCXX_PROFILE_DEFINE_DATA(__trace_list_to_slist*, _S_list_to_slist, 0); \n-_GLIBCXX_PROFILE_DEFINE_DATA(__trace_list_to_vector*, _S_list_to_vector, 0);\n-\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_shift_cost_factor, \n-                             {\"__vector_shift_cost_factor\", 1.0});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_iterate_cost_factor,\n-                             {\"__vector_iterate_cost_factor\", 1.0});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_resize_cost_factor,\n-                             {\"__vector_resize_cost_factor\", 1.0}); \n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_shift_cost_factor,\n-                             {\"__list_shift_cost_factor\", 0.0});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_iterate_cost_factor,\n-                             {\"__list_iterate_cost_factor\", 10.0}); \n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_resize_cost_factor,\n-                             {\"__list_resize_cost_factor\", 0.0}); \n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_insert_cost_factor,\n-                             {\"__map_insert_cost_factor\", 1.5});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_erase_cost_factor,\n-                             {\"__map_erase_cost_factor\", 1.5});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_find_cost_factor,\n-                             {\"__map_find_cost_factor\", 1});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_iterate_cost_factor,\n-                             {\"__map_iterate_cost_factor\", 2.3});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_insert_cost_factor,\n-                             {\"__umap_insert_cost_factor\", 12.0});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_erase_cost_factor,\n-                             {\"__umap_erase_cost_factor\", 12.0});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_find_cost_factor,\n-                             {\"__umap_find_cost_factor\", 10.0});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_iterate_cost_factor,\n-                             {\"__umap_iterate_cost_factor\", 1.7});\n-_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor_vector*, __cost_factors, 0);\n-\n-_GLIBCXX_PROFILE_DEFINE_DATA(const char*, _S_trace_file_name,\n-                             _GLIBCXX_PROFILE_TRACE_PATH_ROOT);\n-_GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_warn_count,\n-                             _GLIBCXX_PROFILE_MAX_WARN_COUNT);\n-_GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_stack_depth,\n-                             _GLIBCXX_PROFILE_MAX_STACK_DEPTH);\n-_GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_mem,\n-                             _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC);\n-\n-inline size_t __stack_max_depth()\n-{\n-  return _GLIBCXX_PROFILE_DATA(_S_max_stack_depth);\n-}\n-\n-inline size_t __max_mem()\n-{\n-  return _GLIBCXX_PROFILE_DATA(_S_max_mem);\n-}\n-\n-/** @brief Base class for all trace producers.  */\n-template <typename __object_info, typename __stack_info>\n-class __trace_base\n-{\n- public:\n-  __trace_base();\n-  virtual ~__trace_base() {}\n-\n-  void __add_object(__object_t object, __object_info __info);\n-  __object_info* __get_object_info(__object_t __object);\n-  void __retire_object(__object_t __object);\n-  void __write(FILE* f);\n-  void __collect_warnings(__warning_vector_t& __warnings);\n-\n- private:\n-  __gnu_cxx::__mutex __object_table_lock;\n-  __gnu_cxx::__mutex __stack_table_lock;\n-  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t, \n-                                      __object_info> __object_table_t;\n-  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info, __stack_hash, \n-                                      __stack_hash> __stack_table_t;\n-  __object_table_t __object_table;\n-  __stack_table_t __stack_table;\n-  size_t __stack_table_byte_size;\n-\n- protected:\n-  const char* __id;\n-};\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__collect_warnings(\n-    __warning_vector_t& __warnings)\n-{\n-  typename __stack_table_t::iterator __i = __stack_table.begin();\n-  for (; __i != __stack_table.end(); ++__i)\n+    __warning_data(float __m, __stack_t __c, const char* __id, \n+\t\t   const char* __msg)\n+    : __magnitude(__m), __context(__c), __warning_id(__id), \n+      __warning_message(__msg) { }\n+    \n+    bool\n+    operator<(const struct __warning_data& __other) const\n+    { return __magnitude < __other.__magnitude; }\n+  };\n+\n+  typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n+\n+  // Defined in profiler_<diagnostic name>.h.\n+  class __trace_hash_func;\n+  class __trace_hashtable_size;\n+  class __trace_map2umap;\n+  class __trace_vector_size;\n+  class __trace_vector_to_list;\n+  class __trace_list_to_slist; \n+  class __trace_list_to_vector; \n+  void __trace_vector_size_init();\n+  void __trace_hashtable_size_init();\n+  void __trace_hash_func_init();\n+  void __trace_vector_to_list_init();\n+  void __trace_list_to_slist_init();  \n+  void __trace_list_to_vector_init();  \n+  void __trace_map_to_unordered_map_init();\n+  void __trace_vector_size_report(FILE*, __warning_vector_t&);\n+  void __trace_hashtable_size_report(FILE*, __warning_vector_t&);\n+  void __trace_hash_func_report(FILE*, __warning_vector_t&);\n+  void __trace_vector_to_list_report(FILE*, __warning_vector_t&);\n+  void __trace_list_to_slist_report(FILE*, __warning_vector_t&); \n+  void __trace_list_to_vector_report(FILE*, __warning_vector_t&);\n+  void __trace_map_to_unordered_map_report(FILE*, __warning_vector_t&);\n+\n+  struct __cost_factor\n   {\n-    __warnings.push_back(__warning_data((*__i).second.__magnitude(), \n-                                        (*__i).first, \n-                                        __id,\n-                                        (*__i).second.__advice()));\n-  }\n-}\n+    const char* __env_var;\n+    float __value;\n+  };\n+\n+  typedef std::_GLIBCXX_STD_PR::vector<__cost_factor*> __cost_factor_vector;\n+\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__trace_hash_func*, _S_hash_func, 0);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__trace_hashtable_size*, _S_hashtable_size, 0);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__trace_map2umap*, _S_map2umap, 0);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__trace_vector_size*, _S_vector_size, 0);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__trace_vector_to_list*, _S_vector_to_list, 0);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__trace_list_to_slist*, _S_list_to_slist, 0); \n+  _GLIBCXX_PROFILE_DEFINE_DATA(__trace_list_to_vector*, _S_list_to_vector, 0);\n+\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_shift_cost_factor, \n+\t\t\t       {\"__vector_shift_cost_factor\", 1.0});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_iterate_cost_factor,\n+\t\t\t       {\"__vector_iterate_cost_factor\", 1.0});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_resize_cost_factor,\n+\t\t\t       {\"__vector_resize_cost_factor\", 1.0}); \n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_shift_cost_factor,\n+\t\t\t       {\"__list_shift_cost_factor\", 0.0});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_iterate_cost_factor,\n+\t\t\t       {\"__list_iterate_cost_factor\", 10.0}); \n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_resize_cost_factor,\n+\t\t\t       {\"__list_resize_cost_factor\", 0.0}); \n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_insert_cost_factor,\n+\t\t\t       {\"__map_insert_cost_factor\", 1.5});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_erase_cost_factor,\n+\t\t\t       {\"__map_erase_cost_factor\", 1.5});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_find_cost_factor,\n+\t\t\t       {\"__map_find_cost_factor\", 1});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_iterate_cost_factor,\n+\t\t\t       {\"__map_iterate_cost_factor\", 2.3});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_insert_cost_factor,\n+\t\t\t       {\"__umap_insert_cost_factor\", 12.0});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_erase_cost_factor,\n+\t\t\t       {\"__umap_erase_cost_factor\", 12.0});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_find_cost_factor,\n+\t\t\t       {\"__umap_find_cost_factor\", 10.0});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_iterate_cost_factor,\n+\t\t\t       {\"__umap_iterate_cost_factor\", 1.7});\n+  _GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor_vector*, __cost_factors, 0);\n+\n+  _GLIBCXX_PROFILE_DEFINE_DATA(const char*, _S_trace_file_name,\n+\t\t\t       _GLIBCXX_PROFILE_TRACE_PATH_ROOT);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_warn_count,\n+\t\t\t       _GLIBCXX_PROFILE_MAX_WARN_COUNT);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_stack_depth,\n+\t\t\t       _GLIBCXX_PROFILE_MAX_STACK_DEPTH);\n+  _GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_mem,\n+\t\t\t       _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC);\n+\n+  inline size_t\n+  __stack_max_depth()\n+  { return _GLIBCXX_PROFILE_DATA(_S_max_stack_depth); }\n+\n+  inline size_t\n+  __max_mem()\n+  { return _GLIBCXX_PROFILE_DATA(_S_max_mem); }\n+\n+  /** @brief Base class for all trace producers.  */\n+  template<typename __object_info, typename __stack_info>\n+    class __trace_base\n+    {\n+    public:\n+      __trace_base();\n+      virtual ~__trace_base() {}\n+\n+      void __add_object(__object_t object, __object_info __info);\n+      __object_info* __get_object_info(__object_t __object);\n+      void __retire_object(__object_t __object);\n+      void __write(FILE* f);\n+      void __collect_warnings(__warning_vector_t& __warnings);\n+\n+    private:\n+      __gnu_cxx::__mutex __object_table_lock;\n+      __gnu_cxx::__mutex __stack_table_lock;\n+      typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t, \n+\t\t\t\t\t  __object_info> __object_table_t;\n+      typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info,\n+\t\t\t\t\t  __stack_hash, \n+\t\t\t\t\t  __stack_hash> __stack_table_t;\n+      __object_table_t __object_table;\n+      __stack_table_t __stack_table;\n+      size_t __stack_table_byte_size;\n+\n+    protected:\n+      const char* __id;\n+    };\n+\n+  template<typename __object_info, typename __stack_info>\n+    void\n+    __trace_base<__object_info, __stack_info>::\n+    __collect_warnings(__warning_vector_t& __warnings)\n+    {\n+      typename __stack_table_t::iterator __i = __stack_table.begin();\n+      for (; __i != __stack_table.end(); ++__i)\n+\t__warnings.push_back(__warning_data((*__i).second.__magnitude(), \n+\t\t\t\t\t    (*__i).first, \n+\t\t\t\t\t    __id,\n+\t\t\t\t\t    (*__i).second.__advice()));\n+    }\n \n-template <typename __object_info, typename __stack_info>\n-__trace_base<__object_info, __stack_info>::__trace_base()\n-{\n-  // Do not pick the initial size too large, as we don't know which diagnostics\n-  // are more active.\n-  __object_table.rehash(10000);\n-  __stack_table.rehash(10000);\n-  __stack_table_byte_size = 0;\n-  __id = 0;\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__add_object(\n-    __object_t __object, __object_info __info)\n-{\n-  if (__max_mem() == 0 \n-      || __object_table.size() * sizeof(__object_info) <= __max_mem()) {\n-    this->__object_table_lock.lock();\n-    __object_table.insert(\n-        typename __object_table_t::value_type(__object, __info));\n-    this->__object_table_lock.unlock();\n-  }\n-}\n+  template<typename __object_info, typename __stack_info>\n+    __trace_base<__object_info, __stack_info>::\n+    __trace_base()\n+    {\n+      // Do not pick the initial size too large, as we don't know which\n+      // diagnostics are more active.\n+      __object_table.rehash(10000);\n+      __stack_table.rehash(10000);\n+      __stack_table_byte_size = 0;\n+      __id = 0;\n+    }\n \n-template <typename __object_info, typename __stack_info>\n-__object_info* __trace_base<__object_info, __stack_info>::__get_object_info(\n-    __object_t __object)\n-{\n-  // XXX: Revisit this to see if we can decrease mutex spans.\n-  // Without this mutex, the object table could be rehashed during an\n-  // insertion on another thread, which could result in a segfault.\n-  this->__object_table_lock.lock();\n-  typename __object_table_t::iterator __object_it = \n-      __object_table.find(__object);\n-  if (__object_it == __object_table.end()){\n-    this->__object_table_lock.unlock();\n-    return 0;\n-  } else {\n-    this->__object_table_lock.unlock();\n-    return &__object_it->second;\n-  }\n-}\n+  template<typename __object_info, typename __stack_info>\n+    void\n+    __trace_base<__object_info, __stack_info>::\n+    __add_object(__object_t __object, __object_info __info)\n+    {\n+      if (__max_mem() == 0 \n+\t  || __object_table.size() * sizeof(__object_info) <= __max_mem())\n+\t{\n+\t  this->__object_table_lock.lock();\n+\t  __object_table.insert(typename __object_table_t::\n+\t\t\t\tvalue_type(__object, __info));\n+\t  this->__object_table_lock.unlock();\n+\t}\n+    }\n \n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__retire_object(\n-    __object_t __object)\n-{\n-  this->__object_table_lock.lock();\n-  this->__stack_table_lock.lock();\n-  typename __object_table_t::iterator __object_it =\n-      __object_table.find(__object);\n-  if (__object_it != __object_table.end()){\n-    const __object_info& __info = __object_it->second;\n-    const __stack_t& __stack = __info.__stack();\n-    typename __stack_table_t::iterator __stack_it = \n-        __stack_table.find(__stack);\n-    if (__stack_it == __stack_table.end()) {\n-      // First occurence of this call context.\n-      if (__max_mem() == 0 || __stack_table_byte_size < __max_mem()) {\n-        __stack_table_byte_size += \n-            (sizeof(__instruction_address_t) * __size(__stack)\n-             + sizeof(__stack) + sizeof(__stack_info));\n-        __stack_table.insert(make_pair(__stack, __stack_info(__info)));\n-      }\n-    } else {\n-      // Merge object info into info summary for this call context.\n-      __stack_it->second.__merge(__info);\n-      delete __stack;\n+  template<typename __object_info, typename __stack_info>\n+    __object_info*\n+    __trace_base<__object_info, __stack_info>::\n+    __get_object_info(__object_t __object)\n+    {\n+      // XXX: Revisit this to see if we can decrease mutex spans.\n+      // Without this mutex, the object table could be rehashed during an\n+      // insertion on another thread, which could result in a segfault.\n+      this->__object_table_lock.lock();\n+      typename __object_table_t::iterator __object_it\n+\t=  __object_table.find(__object);\n+\n+      if (__object_it == __object_table.end())\n+\t{\n+\t  this->__object_table_lock.unlock();\n+\t  return 0;\n+\t}\n+      else\n+\t{\n+\t  this->__object_table_lock.unlock();\n+\t  return &__object_it->second;\n+\t}\n     }\n-    __object_table.erase(__object);\n-  }\n-  this->__object_table_lock.unlock();\n-  this->__stack_table_lock.unlock();\n-}\n \n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__write(FILE* __f)\n-{\n-  typename __stack_table_t::iterator __it;\n-\n-  for (__it = __stack_table.begin(); __it != __stack_table.end(); __it++) {\n-    if (__it->second.__is_valid()) {\n-      fprintf(__f, __id);\n-      fprintf(__f, \"|\");\n-      __gnu_profile::__write(__f, __it->first);\n-      fprintf(__f, \"|\");\n-      __it->second.__write(__f);\n+  template<typename __object_info, typename __stack_info>\n+    void\n+    __trace_base<__object_info, __stack_info>::\n+    __retire_object(__object_t __object)\n+    {\n+      this->__object_table_lock.lock();\n+      this->__stack_table_lock.lock();\n+      typename __object_table_t::iterator __object_it\n+\t= __object_table.find(__object);\n+  \n+      if (__object_it != __object_table.end())\n+\t{\n+\t  const __object_info& __info = __object_it->second;\n+\t  const __stack_t& __stack = __info.__stack();\n+\t  typename __stack_table_t::iterator __stack_it\n+\t    = __stack_table.find(__stack);\n+    \n+\t  if (__stack_it == __stack_table.end())\n+\t    {\n+\t      // First occurence of this call context.\n+\t      if (__max_mem() == 0 || __stack_table_byte_size < __max_mem()) \n+\t\t{\n+\t\t  __stack_table_byte_size \n+\t\t    += (sizeof(__instruction_address_t) * __size(__stack)\n+\t\t\t+ sizeof(__stack) + sizeof(__stack_info));\n+\t\t  __stack_table.insert(make_pair(__stack,\n+\t\t\t\t\t\t __stack_info(__info)));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // Merge object info into info summary for this call context.\n+\t      __stack_it->second.__merge(__info);\n+\t      delete __stack;\n+\t    }\n+\t  __object_table.erase(__object);\n+\t}\n+\n+      this->__object_table_lock.unlock();\n+      this->__stack_table_lock.unlock();\n     }\n-  }\n-}\n \n-inline size_t __env_to_size_t(const char* __env_var, size_t __default_value)\n-{\n-  char* __env_value = getenv(__env_var);\n-  if (__env_value) {\n-    long int __converted_value = strtol(__env_value, 0, 10);\n-    if (errno || __converted_value < 0) {\n-      fprintf(stderr, \"Bad value for environment variable '%s'.\\n\", __env_var);\n-      abort();\n-    } else {\n-      return static_cast<size_t>(__converted_value);\n+  template<typename __object_info, typename __stack_info>\n+    void\n+    __trace_base<__object_info, __stack_info>::\n+    __write(FILE* __f)\n+    {\n+      typename __stack_table_t::iterator __it;\n+\n+      for (__it = __stack_table.begin(); __it != __stack_table.end(); ++__it)\n+\t{\n+\t  if (__it->second.__is_valid())\n+\t    {\n+\t      fprintf(__f, __id);\n+\t      fprintf(__f, \"|\");\n+\t      __gnu_profile::__write(__f, __it->first);\n+\t      fprintf(__f, \"|\");\n+\t      __it->second.__write(__f);\n+\t    }\n+\t}\n     }\n-  } else {\n-    return __default_value;\n-  }\n-}\n \n-inline void __set_max_stack_trace_depth()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_max_stack_depth) = __env_to_size_t(\n-      _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR,\n-      _GLIBCXX_PROFILE_DATA(_S_max_stack_depth));\n-}\n+  inline size_t\n+  __env_to_size_t(const char* __env_var, size_t __default_value)\n+  {\n+    char* __env_value = getenv(__env_var);\n+    if (__env_value)\n+      {\n+\tlong __converted_value = strtol(__env_value, 0, 10);\n+\tif (errno || __converted_value < 0)\n+\t  {\n+\t    fprintf(stderr, \"Bad value for environment variable '%s'.\\n\",\n+\t\t    __env_var);\n+\t    abort();\n+\t  }\n+\telse\n+\t  return static_cast<size_t>(__converted_value);\n+      }\n+    else\n+      return __default_value;\n+  }\n \n-inline void __set_max_mem()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_max_mem) = __env_to_size_t(\n-      _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR,\n-      _GLIBCXX_PROFILE_DATA(_S_max_mem));\n-}\n+  inline void\n+  __set_max_stack_trace_depth()\n+  {\n+    _GLIBCXX_PROFILE_DATA(_S_max_stack_depth)\n+      = __env_to_size_t(_GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR,\n+\t\t\t_GLIBCXX_PROFILE_DATA(_S_max_stack_depth));\n+  }\n \n-inline int __log_magnitude(float __f)\n-{\n-  const float __log_base = 10.0;\n-  int __result = 0;\n-  int __sign = 1;\n-  if (__f < 0) {\n-    __f = -__f;\n-    __sign = -1;\n+  inline void\n+  __set_max_mem()\n+  {\n+    _GLIBCXX_PROFILE_DATA(_S_max_mem) \n+      = __env_to_size_t(_GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR,\n+\t\t\t_GLIBCXX_PROFILE_DATA(_S_max_mem));\n   }\n-  while (__f > __log_base) {\n-    ++__result;\n-    __f /= 10.0;\n+\n+  inline int\n+  __log_magnitude(float __f)\n+  {\n+    const float __log_base = 10.0;\n+    int __result = 0;\n+    int __sign = 1;\n+\n+    if (__f < 0) \n+      {\n+\t__f = -__f;\n+\t__sign = -1;\n+      }\n+\n+    while (__f > __log_base) \n+      {\n+\t++__result;\n+\t__f /= 10.0;\n+      }\n+    return __sign * __result;\n   }\n-  return __sign * __result;\n-}\n \n-inline FILE* __open_output_file(const char* __extension)\n-{\n-  // The path is made of _S_trace_file_name + \".\" + extension.\n-  size_t __root_len = strlen(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n-  size_t __ext_len = strlen(__extension);\n-  char* __file_name = new char[__root_len + 1 + __ext_len + 1];\n-  memcpy(__file_name, _GLIBCXX_PROFILE_DATA(_S_trace_file_name),\n-\t __root_len);\n-  *(__file_name + __root_len) = '.';\n-  memcpy(__file_name + __root_len + 1, __extension, __ext_len + 1);\n-  FILE* __out_file = fopen(__file_name, \"w\");\n-  if (__out_file) {\n-    return __out_file;\n-  } else {\n-    fprintf(stderr, \"Could not open trace file '%s'.\\n\", __file_name);\n-    abort();\n+  inline FILE* \n+  __open_output_file(const char* __extension)\n+  {\n+    // The path is made of _S_trace_file_name + \".\" + extension.\n+    size_t __root_len = strlen(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n+    size_t __ext_len = strlen(__extension);\n+    char* __file_name = new char[__root_len + 1 + __ext_len + 1];\n+    memcpy(__file_name, _GLIBCXX_PROFILE_DATA(_S_trace_file_name),\n+\t   __root_len);\n+    *(__file_name + __root_len) = '.';\n+    memcpy(__file_name + __root_len + 1, __extension, __ext_len + 1);\n+    FILE* __out_file = fopen(__file_name, \"w\");\n+    if (__out_file) \n+      return __out_file;\n+    else\n+      {\n+\tfprintf(stderr, \"Could not open trace file '%s'.\\n\", __file_name);\n+\tabort();\n+      }\n   }\n-}\n \n-struct __warn\n-{\n-  FILE* __file;\n-  __warn(FILE* __f) { __file = __f; }\n+  struct __warn\n+  {\n+    FILE* __file;\n+    __warn(FILE* __f) { __file = __f; }\n \n-  void operator() (const __warning_data& __info)\n+    void\n+    operator() (const __warning_data& __info)\n     {\n       fprintf(__file,  __info.__warning_id);\n       fprintf(__file, \": improvement = %d\",\n@@ -402,227 +440,230 @@ struct __warn\n       free(const_cast<void*>\n \t   (reinterpret_cast<const void*>(__info.__warning_message)));\n     }\n-};\n-\n-/** @brief Final report method, registered with @b atexit.\n- *\n- * This can also be called directly by user code, including signal handlers.\n- * It is protected against deadlocks by the reentrance guard in profiler.h.\n- * However, when called from a signal handler that triggers while within\n- * __gnu_profile (under the guarded zone), no output will be produced.\n- */\n-inline void __report(void)\n-{\n-  _GLIBCXX_PROFILE_DATA(__global_lock).lock();\n-\n-  __warning_vector_t __warnings, __top_warnings;\n-\n-  FILE* __raw_file = __open_output_file(\"raw\");\n-  __trace_vector_size_report(__raw_file, __warnings);\n-  __trace_hashtable_size_report(__raw_file, __warnings);\n-  __trace_hash_func_report(__raw_file, __warnings);\n-  __trace_vector_to_list_report(__raw_file, __warnings);\n-  __trace_list_to_slist_report(__raw_file, __warnings);\n-  __trace_list_to_vector_report(__raw_file, __warnings);\n-  __trace_map_to_unordered_map_report(__raw_file, __warnings);\n-  fclose(__raw_file);\n-\n-  // Sort data by magnitude, keeping just top N.\n-  size_t __cutoff = std::min(_GLIBCXX_PROFILE_DATA(_S_max_warn_count),\n-\t\t\t     __warnings.size());\n-  __top_n(__warnings, __top_warnings, __cutoff);\n-\n-  FILE* __warn_file = __open_output_file(\"txt\");\n-  __for_each(__top_warnings.begin(), __top_warnings.end(),\n-             __warn(__warn_file));\n-  fclose(__warn_file);\n-\n-  _GLIBCXX_PROFILE_DATA(__global_lock).unlock();\n-}\n-\n-inline void __set_trace_path()\n-{\n-  char* __env_trace_file_name = getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);\n-\n-  if (__env_trace_file_name) { \n-    _GLIBCXX_PROFILE_DATA(_S_trace_file_name) = __env_trace_file_name; \n+  };\n+\n+  /** @brief Final report method, registered with @b atexit.\n+   *\n+   * This can also be called directly by user code, including signal handlers.\n+   * It is protected against deadlocks by the reentrance guard in profiler.h.\n+   * However, when called from a signal handler that triggers while within\n+   * __gnu_profile (under the guarded zone), no output will be produced.\n+   */\n+  inline void\n+  __report(void)\n+  {\n+    _GLIBCXX_PROFILE_DATA(__global_lock).lock();\n+\n+    __warning_vector_t __warnings, __top_warnings;\n+\n+    FILE* __raw_file = __open_output_file(\"raw\");\n+    __trace_vector_size_report(__raw_file, __warnings);\n+    __trace_hashtable_size_report(__raw_file, __warnings);\n+    __trace_hash_func_report(__raw_file, __warnings);\n+    __trace_vector_to_list_report(__raw_file, __warnings);\n+    __trace_list_to_slist_report(__raw_file, __warnings);\n+    __trace_list_to_vector_report(__raw_file, __warnings);\n+    __trace_map_to_unordered_map_report(__raw_file, __warnings);\n+    fclose(__raw_file);\n+\n+    // Sort data by magnitude, keeping just top N.\n+    size_t __cutoff = std::min(_GLIBCXX_PROFILE_DATA(_S_max_warn_count),\n+\t\t\t       __warnings.size());\n+    __top_n(__warnings, __top_warnings, __cutoff);\n+\n+    FILE* __warn_file = __open_output_file(\"txt\");\n+    __for_each(__top_warnings.begin(), __top_warnings.end(),\n+\t       __warn(__warn_file));\n+    fclose(__warn_file);\n+\n+    _GLIBCXX_PROFILE_DATA(__global_lock).unlock();\n   }\n \n-  // Make sure early that we can create the trace file.\n-  fclose(__open_output_file(\"txt\"));\n-}\n+  inline void\n+  __set_trace_path()\n+  {\n+    char* __env_trace_file_name = getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);\n \n-inline void __set_max_warn_count()\n-{\n-  char* __env_max_warn_count_str = getenv(\n-      _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);\n+    if (__env_trace_file_name)\n+      _GLIBCXX_PROFILE_DATA(_S_trace_file_name) = __env_trace_file_name;\n \n-  if (__env_max_warn_count_str) {\n-    _GLIBCXX_PROFILE_DATA(_S_max_warn_count) = static_cast<size_t>(\n-        atoi(__env_max_warn_count_str));\n+    // Make sure early that we can create the trace file.\n+    fclose(__open_output_file(\"txt\"));\n   }\n-}\n \n-inline void\n-__read_cost_factors()\n-{\n-  std::string __conf_file_name(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n-  __conf_file_name += \".conf\";\n+  inline void\n+  __set_max_warn_count()\n+  {\n+    char* __env_max_warn_count_str\n+      = getenv(_GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);\n \n-  std::ifstream __conf_file(__conf_file_name.c_str());\n+    if (__env_max_warn_count_str)\n+      _GLIBCXX_PROFILE_DATA(_S_max_warn_count)\n+\t= static_cast<size_t>(atoi(__env_max_warn_count_str));\n+  }\n \n-  if (__conf_file.is_open())\n-    {\n-      std::string __line;\n+  inline void\n+  __read_cost_factors()\n+  {\n+    std::string __conf_file_name(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n+    __conf_file_name += \".conf\";\n \n-      while (std::getline(__conf_file, __line))\n-\t{\n-\t  std::string::size_type __i = __line.find_first_not_of(\" \\t\\n\\v\");\n+    std::ifstream __conf_file(__conf_file_name.c_str());\n \n-\t  if (__line.length() <= 0 || __line[__i] == '#')\n-\t    // Skip empty lines or comments.\n-\t    continue;\n-        }\n+    if (__conf_file.is_open())\n+      {\n+\tstd::string __line;\n \n-      // Trim.\n-      __line.erase(__remove(__line.begin(), __line.end(), ' '), __line.end());\n-      std::string::size_type __pos = __line.find(\"=\");\n-      std::string __factor_name = __line.substr(0, __pos);\n-      std::string::size_type __end = __line.find_first_of(\";\\n\");\n-      std::string __factor_value = __line.substr(__pos + 1, __end - __pos);\n+\twhile (std::getline(__conf_file, __line))\n+\t  {\n+\t    std::string::size_type __i = __line.find_first_not_of(\" \\t\\n\\v\");\n \n-      _GLIBCXX_PROFILE_DATA(__env)[__factor_name] = __factor_value;\n-    }\n-}\n+\t    if (__line.length() <= 0 || __line[__i] == '#')\n+\t      // Skip empty lines or comments.\n+\t      continue;\n+\t  }\n \n-struct __cost_factor_writer\n-{\n-  FILE* __file;\n-  __cost_factor_writer(FILE* __f) : __file(__f) {}\n-  void\n-  operator() (const __cost_factor* __factor)\n-  { fprintf(__file, \"%s = %f\\n\", __factor->__env_var, __factor->__value); }\n-};\n-\n-inline void\n-__write_cost_factors()\n-{\n-  FILE* __file = __open_output_file(\"conf.out\");\n-  __for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),\n-             _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),\n-             __cost_factor_writer(__file));\n-  fclose(__file);\n-}\n+\t// Trim.\n+\t__line.erase(__remove(__line.begin(), __line.end(), ' '),\n+\t\t     __line.end());\n+\tstd::string::size_type __pos = __line.find(\"=\");\n+\tstd::string __factor_name = __line.substr(0, __pos);\n+\tstd::string::size_type __end = __line.find_first_of(\";\\n\");\n+\tstd::string __factor_value = __line.substr(__pos + 1, __end - __pos);\n \n-struct __cost_factor_setter\n-{\n-  void operator() (__cost_factor* __factor)\n+\t_GLIBCXX_PROFILE_DATA(__env)[__factor_name] = __factor_value;\n+      }\n+  }\n+\n+  struct __cost_factor_writer\n+  {\n+    FILE* __file;\n+    __cost_factor_writer(FILE* __f) : __file(__f) { }\n+  \n+    void\n+    operator() (const __cost_factor* __factor)\n+    { fprintf(__file, \"%s = %f\\n\", __factor->__env_var, __factor->__value); }\n+  };\n+\n+  inline void\n+  __write_cost_factors()\n+  {\n+    FILE* __file = __open_output_file(\"conf.out\");\n+    __for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),\n+\t       _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),\n+\t       __cost_factor_writer(__file));\n+    fclose(__file);\n+  }\n+\n+  struct __cost_factor_setter\n+  {\n+    void\n+    operator() (__cost_factor* __factor)\n     {\n       // Look it up in the process environment first.\n       const char* __env_value = getenv(__factor->__env_var);\n \n       if (!__env_value)\n         {\n           // Look it up in the config file.\n-          __env_t::iterator it = _GLIBCXX_PROFILE_DATA(__env).find(\n-              __factor->__env_var);\n+          __env_t::iterator it \n+\t    = _GLIBCXX_PROFILE_DATA(__env).find(__factor->__env_var);\n           if (it != _GLIBCXX_PROFILE_DATA(__env).end())\n             __env_value = (*it).second.c_str();\n         }\n \n       if (__env_value)\n         __factor->__value = atof(__env_value);\n     }\n-};\n+  };\n \n-inline void __set_cost_factors()\n-{\n-  _GLIBCXX_PROFILE_DATA(__cost_factors) = new __cost_factor_vector;\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__list_shift_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__list_resize_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__map_erase_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__map_find_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__map_iterate_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__umap_find_cost_factor));\n-  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n-      &_GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor));\n+  inline void\n+  __set_cost_factors()\n+  {\n+    _GLIBCXX_PROFILE_DATA(__cost_factors) = new __cost_factor_vector;\n+    _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+      push_back(&_GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor));\n+    _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+      push_back(&_GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__list_shift_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__list_resize_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__map_erase_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__map_find_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__map_iterate_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__umap_find_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->\n+    push_back(&_GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor));\n   __for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),\n              _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),\n              __cost_factor_setter());\n-}\n-\n-inline void __profcxx_init_unconditional()\n-{\n-  _GLIBCXX_PROFILE_DATA(__global_lock).lock();\n-\n-  if (__is_invalid()) {\n-\n-    __set_max_warn_count();\n-\n-    if (_GLIBCXX_PROFILE_DATA(_S_max_warn_count) == 0) {\n-\n-      __turn_off();\n-\n-    } else {\n-\n-      __set_max_stack_trace_depth();\n-      __set_max_mem();\n-      __set_trace_path();\n-      __read_cost_factors(); \n-      __set_cost_factors();\n-      __write_cost_factors();\n-\n-      __trace_vector_size_init();\n-      __trace_hashtable_size_init();\n-      __trace_hash_func_init();\n-      __trace_vector_to_list_init();\n-      __trace_list_to_slist_init(); \n-      __trace_list_to_vector_init();\n-      __trace_map_to_unordered_map_init();\n-\n-      atexit(__report);\n+  }\n \n-      __turn_on();\n+  inline void\n+  __profcxx_init_unconditional()\n+  {\n+    _GLIBCXX_PROFILE_DATA(__global_lock).lock();\n+\n+    if (__is_invalid())\n+      {\n+\t__set_max_warn_count();\n+\n+\tif (_GLIBCXX_PROFILE_DATA(_S_max_warn_count) == 0)\n+\t  __turn_off();\n+\telse\n+\t  {\n+\t    __set_max_stack_trace_depth();\n+\t    __set_max_mem();\n+\t    __set_trace_path();\n+\t    __read_cost_factors(); \n+\t    __set_cost_factors();\n+\t    __write_cost_factors();\n+\n+\t    __trace_vector_size_init();\n+\t    __trace_hashtable_size_init();\n+\t    __trace_hash_func_init();\n+\t    __trace_vector_to_list_init();\n+\t    __trace_list_to_slist_init(); \n+\t    __trace_list_to_vector_init();\n+\t    __trace_map_to_unordered_map_init();\n+\n+\t    atexit(__report);\n+\n+\t    __turn_on();\n+\t  }\n+      }\n \n-    }\n+    _GLIBCXX_PROFILE_DATA(__global_lock).unlock();\n   }\n \n-  _GLIBCXX_PROFILE_DATA(__global_lock).unlock();\n-}\n+  /** @brief This function must be called by each instrumentation point.\n+   *\n+   * The common path is inlined fully.\n+   */\n+  inline bool\n+  __profcxx_init(void)\n+  {\n+    if (__is_invalid())\n+      __profcxx_init_unconditional();\n \n-/** @brief This function must be called by each instrumentation point.\n- *\n- * The common path is inlined fully.\n- */\n-inline bool __profcxx_init(void)\n-{\n-  if (__is_invalid()) {\n-    __profcxx_init_unconditional();\n+    return __is_on();\n   }\n \n-  return __is_on();\n-}\n-\n } // namespace __gnu_profile\n \n #endif /* _GLIBCXX_PROFILE_PROFILER_TRACE_H */"}, {"sha": "e0483efd67c03aa6c9ae1cfc59a705b59eed9d56", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_size.h", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n //\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -54,50 +54,57 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief Hashtable size instrumentation trace producer.  */\n-class __trace_vector_size : public __trace_container_size\n-{\n- public:\n-  __trace_vector_size() : __trace_container_size() { __id = \"vector-size\"; }\n-};\n-\n-inline void __trace_vector_size_init()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_vector_size) = new __trace_vector_size();\n-}\n-\n-inline void __trace_vector_size_report(FILE* __f, \n-                                       __warning_vector_t& __warnings)\n-{\n-  if (_GLIBCXX_PROFILE_DATA(_S_vector_size)) {\n-    _GLIBCXX_PROFILE_DATA(_S_vector_size)->__collect_warnings(__warnings);\n-    _GLIBCXX_PROFILE_DATA(_S_vector_size)->__write(__f);\n+  /** @brief Hashtable size instrumentation trace producer.  */\n+  class __trace_vector_size\n+  : public __trace_container_size\n+  {\n+  public:\n+    __trace_vector_size()\n+    : __trace_container_size()\n+    { __id = \"vector-size\"; }\n+  };\n+\n+  inline void\n+  __trace_vector_size_init()\n+  { _GLIBCXX_PROFILE_DATA(_S_vector_size) = new __trace_vector_size(); }\n+\n+  inline void\n+  __trace_vector_size_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (_GLIBCXX_PROFILE_DATA(_S_vector_size))\n+      {\n+\t_GLIBCXX_PROFILE_DATA(_S_vector_size)->__collect_warnings(__warnings);\n+\t_GLIBCXX_PROFILE_DATA(_S_vector_size)->__write(__f);\n+      }\n   }\n-}\n \n-inline void __trace_vector_size_construct(const void* __obj, size_t __num)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_vector_size_construct(const void* __obj, size_t __num)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_size)->__insert(__obj, __get_stack(), __num);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_vector_size)->__insert(__obj, __get_stack(),\n+\t\t\t\t\t\t    __num);\n+  }\n \n-inline void __trace_vector_size_destruct(const void* __obj, size_t __num,\n-                                         size_t __inum)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_vector_size_destruct(const void* __obj, size_t __num, size_t __inum)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_size)->__destruct(__obj, __num, __inum);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_vector_size)->__destruct(__obj, __num, __inum);\n+  }\n \n-inline void __trace_vector_size_resize(const void* __obj, size_t __from,\n-                                       size_t __to)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_vector_size_resize(const void* __obj, size_t __from, size_t __to)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_size)->__resize(__obj, __from, __to);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_vector_size)->__resize(__obj, __from, __to);\n+  }\n \n } // namespace __gnu_profile\n "}, {"sha": "9749ee85b9b93bc2a27d0b1b3247096a15eaa221", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_to_list.h", "status": "modified", "additions": 284, "deletions": 264, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h?ref=b0af13eaddf6ca6e5e9fe48e8e54fff6b3ef4582", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n //\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -52,285 +52,305 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief A vector-to-list instrumentation line in the object table.  */\n-class __vector2list_info: public __object_info_base\n-{\n- public:\n-  __vector2list_info()\n-      :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n-       _M_vector_cost(0), _M_valid(true) {}\n-  __vector2list_info(__stack_t __stack)\n-      : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n-        _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true) {} \n-  virtual ~__vector2list_info() {}\n-  __vector2list_info(const __vector2list_info& __o);\n-  void __merge(const __vector2list_info& __o);\n-  void __write(FILE* __f) const;\n-  float __magnitude() const { return _M_vector_cost - _M_list_cost; }\n-  const char* __advice() const \n-  { return strdup(\"change std::vector to std::list\"); }\n-\n-  size_t __shift_count() { return _M_shift_count; }\n-  size_t __iterate()   { return _M_iterate; }\n-  float __list_cost() { return _M_list_cost; }\n-  size_t __resize() { return _M_resize; }\n-  void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n-  void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n-  bool __is_valid() { return _M_valid; }\n-  void __set_invalid() { _M_valid = false; }\n-\n-  void __opr_insert(size_t __pos, size_t __num);\n-  void __opr_iterate(size_t __num);\n-  void __resize(size_t __from, size_t __to);\n-  void __opr_find(size_t __size);\n-\n-private:\n-  size_t _M_shift_count;\n-  size_t _M_iterate;\n-  size_t _M_resize;\n-  float _M_list_cost;\n-  float _M_vector_cost;\n-  bool  _M_valid;\n-};\n-\n-inline __vector2list_info::__vector2list_info(const __vector2list_info& __o)\n-    : __object_info_base(__o)\n-{\n-  _M_shift_count  = __o._M_shift_count;\n-  _M_iterate      = __o._M_iterate;\n-  _M_vector_cost  = __o._M_vector_cost;\n-  _M_list_cost    = __o._M_list_cost;\n-  _M_valid        = __o._M_valid;\n-  _M_resize       = __o._M_resize;\n-}\n-\n-inline void __vector2list_info::__merge(const __vector2list_info& __o)\n-{\n-  _M_shift_count  += __o._M_shift_count;\n-  _M_iterate      += __o._M_iterate;\n-  _M_vector_cost  += __o._M_vector_cost;\n-  _M_list_cost    += __o._M_list_cost;\n-  _M_valid        &= __o._M_valid;\n-  _M_resize       += __o._M_resize;\n-}\n-\n-inline void __vector2list_info::__opr_insert(size_t __pos, size_t __num)\n-{\n-  _M_shift_count += __num - __pos;\n-}\n-\n-inline void __vector2list_info::__resize(size_t __from, size_t __to)\n-{\n-  _M_resize += __from;\n-}\n-\n-inline void __vector2list_info::__opr_iterate(size_t __num)\n-{ \n-  _M_iterate += __num; \n-}\n-\n-inline void __vector2list_info::__opr_find(size_t __size)\n-{\n-  // Use average case complexity.\n-  _M_iterate += 3.0 / 4.0 * __size;\n-}\n-\n-/** @brief A vector-to-list instrumentation line in the stack table.  */\n-class __vector2list_stack_info: public __vector2list_info {\n- public:\n-  __vector2list_stack_info(const __vector2list_info& __o) \n-      : __vector2list_info(__o) {}\n-};\n-\n-/** @brief Vector-to-list instrumentation producer.  */\n-class __trace_vector_to_list\n-    : public __trace_base<__vector2list_info, __vector2list_stack_info> \n-{\n- public:\n-  __trace_vector_to_list();\n-  ~__trace_vector_to_list() {}\n-\n-  // Insert a new node at construct with object, callstack and initial size. \n-  void __insert(__object_t __obj, __stack_t __stack);\n-  // Call at destruction/clean to set container final size.\n-  void __destruct(const void* __obj);\n-\n-  // Find the node in the live map.\n-  __vector2list_info* __find(const void* __obj);\n-\n-  // Collect cost of operations.\n-  void __opr_insert(const void* __obj, size_t __pos, size_t __num);\n-  void __opr_iterate(const void* __obj, size_t __num);\n-  void __invalid_operator(const void* __obj);\n-  void __resize(const void* __obj, size_t __from, size_t __to);\n-  float __vector_cost(size_t __shift, size_t __iterate, size_t __resize);\n-  float __list_cost(size_t __shift, size_t __iterate, size_t __resize);\n-  void __opr_find(const void* __obj, size_t __size);\n-};\n-\n-inline __trace_vector_to_list::__trace_vector_to_list()\n+  /** @brief A vector-to-list instrumentation line in the object table.  */\n+  class __vector2list_info \n+  : public __object_info_base\n+  {\n+  public:\n+    __vector2list_info()\n+    : _M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n+      _M_vector_cost(0), _M_valid(true) { }\n+\n+    __vector2list_info(__stack_t __stack)\n+    : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n+      _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true) { }\n+\n+    virtual ~__vector2list_info() { }\n+\n+    __vector2list_info(const __vector2list_info& __o)\n+    : __object_info_base(__o), _M_shift_count(__o._M_shift_count),\n+      _M_iterate(__o._M_iterate), _M_resize(__o._M_resize),\n+      _M_list_cost(__o._M_list_cost), _M_vector_cost(__o._M_vector_cost),\n+      _M_valid(__o._M_valid) { }\n+\n+    void\n+    __merge(const __vector2list_info& __o)\n+    {\n+      _M_shift_count  += __o._M_shift_count;\n+      _M_iterate      += __o._M_iterate;\n+      _M_vector_cost  += __o._M_vector_cost;\n+      _M_list_cost    += __o._M_list_cost;\n+      _M_valid        &= __o._M_valid;\n+      _M_resize       += __o._M_resize;\n+    }\n+\n+    void\n+    __write(FILE* __f) const\n+    {\n+      fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\", _M_shift_count, _M_resize,\n+\t      _M_iterate, _M_vector_cost, _M_list_cost);\n+    }\n+\n+    float\n+    __magnitude() const\n+    { return _M_vector_cost - _M_list_cost; }\n+\n+    const char* __advice() const \n+    { return strdup(\"change std::vector to std::list\"); }\n+\n+    size_t\n+    __shift_count()\n+    { return _M_shift_count; }\n+\n+    size_t\n+    __iterate()\n+    { return _M_iterate; }\n+\n+    float __list_cost()\n+    { return _M_list_cost; }\n+\n+    size_t\n+    __resize()\n+    { return _M_resize; }\n+\n+    void\n+    __set_list_cost(float __lc)\n+    { _M_list_cost = __lc; }\n+    \n+    void\n+    __set_vector_cost(float __vc)\n+    { _M_vector_cost = __vc; }\n+    \n+    bool\n+    __is_valid()\n+    { return _M_valid; }\n+    \n+    void\n+    __set_invalid()\n+    { _M_valid = false; }\n+\n+    void\n+    __opr_insert(size_t __pos, size_t __num)\n+    { _M_shift_count += __num - __pos; }\n+\n+    void\n+    __opr_iterate(size_t __num)\n+    { _M_iterate += __num; }\n+\n+    void\n+    __resize(size_t __from, size_t)\n+    { _M_resize += __from; }\n+\n+    void __opr_find(size_t __size)\n+    {\n+      // Use average case complexity.\n+      _M_iterate += 3.0 / 4.0 * __size;\n+    }\n+\n+  private:\n+    size_t _M_shift_count;\n+    size_t _M_iterate;\n+    size_t _M_resize;\n+    float _M_list_cost;\n+    float _M_vector_cost;\n+    bool  _M_valid;\n+  };\n+\n+\n+  /** @brief A vector-to-list instrumentation line in the stack table.  */\n+  class __vector2list_stack_info\n+  : public __vector2list_info\n+  {\n+  public:\n+    __vector2list_stack_info(const __vector2list_info& __o) \n+    : __vector2list_info(__o) { }\n+  };\n+\n+\n+  /** @brief Vector-to-list instrumentation producer.  */\n+  class __trace_vector_to_list\n+  : public __trace_base<__vector2list_info, __vector2list_stack_info> \n+  {\n+  public:\n+    __trace_vector_to_list()\n     : __trace_base<__vector2list_info, __vector2list_stack_info>()\n-{\n-  __id = \"vector-to-list\";\n-}\n-\n-inline void __trace_vector_to_list::__insert(__object_t __obj,\n-                                             __stack_t __stack)\n-{\n-  __add_object(__obj, __vector2list_info(__stack));\n-}\n-\n-inline void __vector2list_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\",\n-          _M_shift_count, _M_resize, _M_iterate, _M_vector_cost, _M_list_cost);\n-}\n-\n-inline float __trace_vector_to_list::__vector_cost(size_t __shift, \n-                                                   size_t __iterate,\n-                                                   size_t __resize)\n-{\n-  return (\n-      __shift * _GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor).__value\n-      + __iterate * _GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor).__value\n-      + __resize * _GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor).__value\n-      );\n-}\n-\n-inline float __trace_vector_to_list::__list_cost(size_t __shift, \n-                                                 size_t __iterate,\n-                                                 size_t __resize)\n-{\n-  return (\n-      __shift * _GLIBCXX_PROFILE_DATA(__list_shift_cost_factor).__value\n-      + __iterate * _GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor).__value\n-      + __resize * _GLIBCXX_PROFILE_DATA(__list_resize_cost_factor).__value);\n-}\n-\n-inline void __trace_vector_to_list::__destruct(const void* __obj)\n-{\n-  if (!__is_on())\n-    return;\n-\n- __vector2list_info* __res = __get_object_info(__obj);\n-  if (!__res)\n-    return;\n-\n-  float __vc = __vector_cost(__res->__shift_count(), __res->__iterate(),\n-                             __res->__resize());\n-  float __lc = __list_cost(__res->__shift_count(), __res->__iterate(),\n-                           __res->__resize());\n-  __res->__set_vector_cost(__vc);\n-  __res->__set_list_cost(__lc);\n-\n-  __retire_object(__obj);\n-}\n-\n-inline void __trace_vector_to_list::__opr_insert(const void* __obj, \n-                                                 size_t __pos, size_t __num)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__opr_insert(__pos, __num);\n-}\n-\n-inline void __trace_vector_to_list::__opr_iterate(const void* __obj,\n-                                                  size_t __num)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__opr_iterate(__num);\n-}\n-\n-inline void __trace_vector_to_list::__invalid_operator(const void* __obj)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__set_invalid();\n-}\n-\n-inline void __trace_vector_to_list::__resize(const void* __obj, size_t __from, \n-                                             size_t __to)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__resize(__from, __to);\n-}\n-\n-inline void __trace_vector_to_list::__opr_find(const void* __obj,\n-                                               size_t __size)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__opr_find(__size);\n-}\n-\n-inline void __trace_vector_to_list_init()\n-{\n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list) = new __trace_vector_to_list();\n-}\n-\n-inline void __trace_vector_to_list_report(FILE* __f, \n-                                          __warning_vector_t& __warnings)\n-{\n-  if (_GLIBCXX_PROFILE_DATA(_S_vector_to_list)) {\n-    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__collect_warnings(__warnings);\n-    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__write(__f);\n+    { __id = \"vector-to-list\"; }\n+\n+    ~__trace_vector_to_list() { }\n+\n+    // Insert a new node at construct with object, callstack and initial size. \n+    void\n+    __insert(__object_t __obj, __stack_t __stack)\n+    { __add_object(__obj, __vector2list_info(__stack)); }\n+\n+    // Call at destruction/clean to set container final size.\n+    void\n+    __destruct(const void* __obj)\n+    {\n+      if (!__is_on())\n+\treturn;\n+\n+      __vector2list_info* __res = __get_object_info(__obj);\n+      if (!__res)\n+\treturn;\n+\n+      float __vc = __vector_cost(__res->__shift_count(), __res->__iterate(),\n+\t\t\t\t __res->__resize());\n+      float __lc = __list_cost(__res->__shift_count(), __res->__iterate(),\n+\t\t\t       __res->__resize());\n+      __res->__set_vector_cost(__vc);\n+      __res->__set_list_cost(__lc);\n+\n+      __retire_object(__obj);\n+    }\n+\n+    // Find the node in the live map.\n+    // XXX Undefined?!?\n+    __vector2list_info* __find(const void* __obj);\n+\n+    // Collect cost of operations.\n+    void\n+    __opr_insert(const void* __obj, size_t __pos, size_t __num)\n+    {\n+      __vector2list_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__opr_insert(__pos, __num);\n+    }\n+\n+    void\n+    __opr_iterate(const void* __obj, size_t __num)\n+    {\n+      __vector2list_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__opr_iterate(__num);\n+    }\n+\n+    void\n+    __invalid_operator(const void* __obj)\n+    {\n+      __vector2list_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__set_invalid();\n+    }\n+\n+    void\n+    __resize(const void* __obj, size_t __from, size_t __to)\n+    {\n+      __vector2list_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__resize(__from, __to);\n+    }\n+\n+    float\n+    __vector_cost(size_t __shift, size_t __iterate, size_t __resize)\n+    {\n+      return (__shift\n+\t      * _GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor).__value\n+\t      + __iterate\n+\t      * _GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor).__value\n+\t      + __resize\n+\t      * _GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor).__value);\n+    }\n+\n+    float\n+    __list_cost(size_t __shift, size_t __iterate, size_t __resize)\n+    {\n+      return (__shift\n+\t      * _GLIBCXX_PROFILE_DATA(__list_shift_cost_factor).__value\n+\t      + __iterate\n+\t      * _GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor).__value\n+\t      + __resize\n+\t      * _GLIBCXX_PROFILE_DATA(__list_resize_cost_factor).__value);\n+    }\n+\n+    void\n+    __opr_find(const void* __obj, size_t __size)\n+    {\n+      __vector2list_info* __res = __get_object_info(__obj);\n+      if (__res)\n+\t__res->__opr_find(__size);\n+    }\n+  };\n+\n+\n+  inline void\n+  __trace_vector_to_list_init()\n+  { _GLIBCXX_PROFILE_DATA(_S_vector_to_list) = new __trace_vector_to_list(); }\n+\n+  inline void\n+  __trace_vector_to_list_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (_GLIBCXX_PROFILE_DATA(_S_vector_to_list))\n+      {\n+\t_GLIBCXX_PROFILE_DATA(_S_vector_to_list)->\n+\t  __collect_warnings(__warnings);\n+\t_GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__write(__f);\n+      }\n   }\n-}\n-\n-inline void __trace_vector_to_list_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__insert(__obj, __get_stack());\n-}\n+  inline void\n+  __trace_vector_to_list_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_vector_to_list_destruct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__insert(__obj, __get_stack());\n+  }\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__destruct(__obj);\n-}\n+  inline void\n+  __trace_vector_to_list_destruct(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_vector_to_list_insert(const void* __obj, \n-                                          size_t __pos, size_t __num)\n-{\n-  if (!__profcxx_init()) return;\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__destruct(__obj);\n+  }\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_insert(__obj, __pos, __num);\n-}\n+  inline void\n+  __trace_vector_to_list_insert(const void* __obj, size_t __pos, size_t __num)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_insert(__obj, __pos,\n+\t\t\t\t\t\t\t   __num);\n+  }\n \n-inline void __trace_vector_to_list_iterate(const void* __obj, size_t __num = 1)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_vector_to_list_iterate(const void* __obj, size_t __num = 1)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_iterate(__obj, __num);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_iterate(__obj, __num);\n+  }\n \n-inline void __trace_vector_to_list_invalid_operator(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_vector_to_list_invalid_operator(const void* __obj)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__invalid_operator(__obj);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__invalid_operator(__obj);\n+  }\n \n-inline void __trace_vector_to_list_resize(const void* __obj, \n-                                          size_t __from, size_t __to)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_vector_to_list_resize(const void* __obj, size_t __from, size_t __to)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__resize(__obj, __from, __to);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__resize(__obj, __from, __to);\n+  }\n \n-inline void __trace_vector_to_list_find(const void* __obj, size_t __size)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_vector_to_list_find(const void* __obj, size_t __size)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_find(__obj, __size);\n-}\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_find(__obj, __size);\n+  }\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H */"}]}