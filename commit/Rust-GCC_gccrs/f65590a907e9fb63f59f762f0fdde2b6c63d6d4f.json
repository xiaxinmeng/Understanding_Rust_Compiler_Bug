{"sha": "f65590a907e9fb63f59f762f0fdde2b6c63d6d4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1NTkwYTkwN2U5ZmI2M2Y1OWY3NjJmMGZkZGUyYjZjNjNkNmQ0Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-07T20:38:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-07T20:38:50Z"}, "message": "pa.md (conditional branches): Use the full displacement range for the branch target.\n\n        * pa.md (conditional branches): Use the full displacement range\n        for the branch target.  Update length computations to match current\n        reality.\n        (branch on bit patterns): Likewise.\n        (decrement_and_branch_until_zero): Re-enable pattern.  Rewrite to\n        be simpler and more efficient.  Also handle case where loop counter\n        is in a FP register.\n\nFrom-SVN: r4874", "tree": {"sha": "3d434042f3c7a1e81819cf7e68afdc7a49b8da48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d434042f3c7a1e81819cf7e68afdc7a49b8da48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f/comments", "author": null, "committer": null, "parents": [{"sha": "e287977a716fb8aff5a719a10d2129804da450b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e287977a716fb8aff5a719a10d2129804da450b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e287977a716fb8aff5a719a10d2129804da450b2"}], "stats": {"total": 235, "additions": 112, "deletions": 123}, "files": [{"sha": "4fb738e1436e7ef29a2a88e6185303c9dea4d7fe", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 112, "deletions": 123, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=f65590a907e9fb63f59f762f0fdde2b6c63d6d4f", "patch": "@@ -85,10 +85,9 @@\n \n ;; Integer conditional branch delay slot description.\n ;; Nullification of conditional branches on the PA is dependent on the\n-;; direction of the branch.  Forward branches nullify true (direction > 0),\n-;; and backward branches nullify false (direction < 0).\n-;; If direction == 0, then the direction is unknown and we do not allow\n-;; any nullification.\n+;; direction of the branch.  Forward branches nullify true and\n+;; backward branches nullify false.  If the direction is unknown\n+;; then nullification is not allowed.\n (define_delay (eq_attr \"type\" \"cbranch\")\n   [(eq_attr \"in_branch_delay\" \"true\") \n    (and (eq_attr \"in_nullified_branch_delay\" \"true\") \n@@ -760,14 +759,10 @@\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\") \n-    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n-\t\t      (const_int 1023))\n+    (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n            (const_int 1)\n-\t   (and (lt (match_dup 0) (pc))\n-\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n-\t\t    (const_int 1)))\n-\t   (const_int 3)]\n-\t  (const_int 2)))])\n+\t   (const_int 2)))])\n \n ;; Match the negated branch.\n \n@@ -787,14 +782,10 @@\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\") \n-    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n-\t\t      (const_int 1023))\n+    (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n            (const_int 1)\n-\t   (and (lt (match_dup 0) (pc))\n-\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n-\t\t    (const_int 1)))\n-\t   (const_int 3)]\n-\t  (const_int 2)))])\n+\t   (const_int 2)))])\n \n ;; Branch on Bit patterns.\n (define_insn \"\"\n@@ -816,14 +807,10 @@\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\") \n-    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n-\t\t      (const_int 1023))\n+    (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n            (const_int 1)\n-\t   (and (lt (match_dup 0) (pc))\n-\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n-\t\t    (const_int 1)))\n-\t   (const_int 3)]\n-\t  (const_int 2)))])\n+\t   (const_int 2)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -844,17 +831,12 @@\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\") \n-    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n-\t\t      (const_int 1023))\n+    (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n            (const_int 1)\n-\t   (and (lt (match_dup 0) (pc))\n-\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n-\t\t    (const_int 1)))\n-\t   (const_int 3)]\n-\t  (const_int 2)))])\n+\t   (const_int 2)))])\n \n ;; Floating point branches\n-\n (define_insn \"\"\n   [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))\n \t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n@@ -2927,113 +2909,120 @@\n   [(set (pc)\n \t(if_then_else\n \t  (match_operator 2 \"comparison_operator\"\n-\t   [(plus:SI (match_operand:SI 0 \"register_operand\" \"+!r,m\")\n-\t\t     (match_operand:SI 1 \"int5_operand\" \"L,L\"))\n+\t   [(plus:SI (match_operand:SI 0 \"register_operand\" \"+!r,!*fx,!*m\")\n+\t\t     (match_operand:SI 1 \"int5_operand\" \"L,L,L\"))\n \t    (const_int 0)])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n \t  (pc)))\n    (set (match_dup 0)\n \t(plus:SI (match_dup 0) (match_dup 1)))\n-   (clobber (match_scratch:SI 4 \"=X,r\"))]\n-  \"0\"\n+   (clobber (match_scratch:SI 4 \"=X,r,r\"))]\n+  \"\"\n \"*\n {\n-  if (INSN_ANNULLED_BRANCH_P (insn))\n+\n+  if (which_alternative == 0)\n+    {\n+      int nullify = INSN_ANNULLED_BRANCH_P (insn);\n+      int length = get_attr_length (insn);\n+\n+      /* If this is a long branch with its delay slot unfilled, set `nullify'\n+\t as it can nullify the delay slot and save a nop.  */\n+      if (length == 2 && dbr_sequence_length () == 0)\n+\tnullify = 1;\n+\n+      /* If this is a short forward conditional branch which did not get\n+\t its delay slot filled, the delay slot can still be nullified.  */\n+      if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+\tnullify = forward_branch_p (insn);\n+\n+      /* Handle short versions first.  */\n+      if (length == 1 && nullify)\n+\treturn \\\"addib,%C2,n %1,%0,%3\\\";\n+      else if (length == 1 && ! nullify)\n+\treturn \\\"addib,%C2 %1,%0,%3\\\";\n+      else if (length == 2)\n+\t{\n+\t  /* Handle weird backwards branch with a fulled delay slot \n+\t     which is nullified.  */\n+\t  if (dbr_sequence_length () != 0\n+\t      && ! forward_branch_p (insn)\n+\t      && nullify)\n+\t    return \\\"addib,%N2,n %1,%0,.+12\\;bl %3,0\\\";\n+\t  \n+\t  /* Handle normal cases.  */  \n+\t  if (nullify)\n+\t    return \\\"addi,%N2 %1,%0,%0\\;bl,n %3,0\\\";\n+\t  else\n+\t    return \\\"addi,%N2 %1,%0,%0\\;bl %3,0\\\";\n+\t}\n+      else\n+\tabort();\n+    }\n+  /* Deal with gross reload from FP register case.  */\n+  else if (which_alternative == 1)\n     {\n-      /* Loop counter is in a register.  */\n-      if (which_alternative == 0)\n-\t/* Short branch.  Normal handling of nullification.  */\n-        if (get_attr_length (insn) == 1)\n-          return \\\"addib,%C2,n %1,%0,%3\\\";\n-\t/* Long Conditional branch forward with delay slot nullified if\n-\t   branch is taken.  */\n-        else if (get_attr_length (insn) == 2)\n-          return \\\"addi,%N2 %1,%0,%0\\;bl,n %3,0\\\";\n-\t/* Long Conditional branch backwards with delay slot nullified\n-\t   if branch is not taken.  */\n-        else\n-          return \\\"addib,%N2 %1,%0,.+16\\;nop\\;bl %3,0\\\";\n+      /* Move loop counter from FP register to MEM then into a GR,\n+\t increment the GR, store the GR into MEM, and finally reload\n+\t the FP register from MEM from within the branch's delay slot.  */ \n+      output_asm_insn (\\\"fstws %0,-16(0,%%r30)\\;ldw -16(0,%%r30),%4\\\",operands);\n+      output_asm_insn (\\\"ldo %1(%4),%4\\;stw %4,-16(0,%%r30)\\\", operands);\n+      if (get_attr_length (insn) == 6)\n+\treturn \\\"comb,%S2 0,%4,%3\\;fldws -16(0,%%r30),%0\\\";\n       else\n-        {\n-\t  /* Must reload loop counter from memory.  Ugly.  */\n-          output_asm_insn (\\\"ldw %0,%4\\;ldo %1(%4),%4\\;stw %4,%0\\\", operands);\n-\t  /* Short branch.  Normal handling of nullification.  */\n-          if (get_attr_length (insn) == 4)\n-\t    return \\\"comb,%S2,n 0,%4,%3\\\";\n-\t  /* Long Conditional branch forward with delay slot nullified if\n-\t     branch is taken.  */\n-          else if (get_attr_length (insn) == 5)\n-\t    return \\\"comclr,%B2 0,%4,0\\;bl,n %3,0\\\";\n-\t  else \n-\t  /* Long Conditional branch backwards with delay slot nullified\n-\t     if branch is not taken.  */\n-\t    return \\\"comb,%B2 0,%4,.+16\\;nop\\;bl %3,0\\\";\n-        }\n+\treturn \\\"comclr,%B2 0,%4,0\\;bl %3,0\\;fldws -16(0,%%r30),%0\\\";\n     }\n+  /* Deal with gross reload from memory case.  */\n   else\n     {\n-      /* We are not nullifying the delay slot.  Much simpler.  */\n-      if (which_alternative == 0)\n-        if (get_attr_length (insn) == 1)\n-\t  /* Short form.  */\n-          return \\\"addib,%C2 %1,%0,%3%#\\\";\n-        else\n-\t  /* Long form.  */\n-          return \\\"addi,%N2 %1,%0,%0\\;bl%* %3,0\\\";\n+      /* Reload loop counter from memory, the store back to memory\n+\t happens in the branch's delay slot.   */\n+      output_asm_insn (\\\"ldw %0,%4\\\", operands);\n+      if (get_attr_length (insn) == 3)\n+\treturn \\\"addib,%C2 %1,%4,%3;stw %4,%0\\\";\n       else\n-        {\n-\t  /* Reload loop counter from memory.  */\n-          output_asm_insn (\\\"ldw %0,%4\\;ldo %1(%4),%4\\;stw %4,%0\\\", operands);\n-\t  /* Short form.  */\n-          if (get_attr_length (insn) == 4)\n-\t    return \\\"comb,%S2 0,%4,%3%#\\\";\n-\t  /* Long form.  */\n-          else\n-\t    return \\\"comclr,%B2 0,%4,0\\;bl%* %3,0\\\";\n-        }\n+\treturn \\\"addi,%N2 %1,%4,%0\\;bl %3,0\\;stw %4,%0\\\";\n     }\n }\"\n ;; Do not expect to understand this the first time through.  \n-[(set_attr \"type\" \"cbranch\")\n+[(set_attr \"type\" \"cbranch,multi,multi\")\n  (set (attr \"length\")\n-      (if_then_else \n-\t(eq_attr \"alternative\" \"0\")\n-;; Loop counter in register case.\n-\t(cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 2))))\n-\t\t   (const_int 1023))\n-;; Short branch has a length of 1.\n-\t       (const_int 1)\n-;; Long backward branch with nullified delay slot has length of 3.\n-\t       (and (lt (match_dup 1) (pc))\n-\t\t    (eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n-\t\t\t(const_int 1)))\n-\t       (const_int 3)]\n-;; Default others to 2.\n-;; Long branches with unfilled delay slots  --or--\n-;; Long forward with nullified delay slot.\n-\t      (const_int 2))\n-;; Loop counter in memory case.   Similar to above except we pay\n-;; 3 extra insns in each case for reloading the counter into a register.\n-\t(if_then_else (lt (match_dup 1) (pc))\n-\t  (cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 5))))\n-\t\t     (const_int 1023))\n-;; Short branch has length of 4 (the reloading costs 3 insns)\n-\t\t (const_int 4)\n-\t\t (and (lt (match_dup 1) (pc))\n-\t\t      (eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n-\t\t\t  (const_int 1)))\n-;; Long backward branch with nullified delay slot has length of 6.\n-\t\t (const_int 6)]\n-;; Default others to 5.\n-;; Long branches with unfilled delay slots  --or--\n-;; Long forward with nullified delay slot.\n-\t\t(const_int 5))\n-\t  (if_then_else (lt (abs (minus (match_dup 1) \n-\t\t\t\t\t(plus (pc) (const_int 2))))\n-\t\t\t    (const_int 1023))\n-\t\t\t(const_int 4)\n-\t\t\t(const_int 5)))))])\n-\n+      (if_then_else (eq_attr \"alternative\" \"0\")\n+;; Loop counter in register case\n+;; Short branch has length of 1\n+;; Long branch has length of 2\n+\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t      (const_int 2047))\n+           (const_int 1)\n+\t   (const_int 2))\n+\n+;; Loop counter in FP reg case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else (eq_attr \"alternative\" \"1\")\n+\t  (if_then_else (lt (match_dup 3) (pc))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 6))))\n+\t\t  (const_int 2047))\n+\t      (const_int 6)\n+\t      (const_int 7))\n+\t    (if_then_else \n+\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t  (const_int 2047))\n+\t      (const_int 6)\n+\t      (const_int 7)))\n+;; Loop counter in memory case.\n+;; Extra goo to deal with additional reload insns.\n+\t(if_then_else (lt (match_dup 3) (pc))\n+\t  (if_then_else \n+\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 3))))\n+\t\t(const_int 2047))\n+\t    (const_int 3)\n+\t    (const_int 4))\n+\t  (if_then_else \n+\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 2))))\n+\t\t(const_int 2047))\n+\t    (const_int 3)\n+\t    (const_int 4))))))])\n \n ;; The next four peepholes take advantage of the new 5 operand \n ;; fmpy{add,sub} instructions available on 1.1 CPUS.  Basically"}]}