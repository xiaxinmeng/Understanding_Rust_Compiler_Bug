{"sha": "6ed551b487b1a3c085c97125700b8cf245d53b37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVkNTUxYjQ4N2IxYTNjMDg1Yzk3MTI1NzAwYjhjZjI0NWQ1M2IzNw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "1999-12-18T01:45:40Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "1999-12-18T01:45:40Z"}, "message": "toplev.c (notice, [...]): Move to diagnostic.c\n\n1999-12-18 Gabriel Dos Reis  <gdr@codesourcery.com>\n\n        * toplev.c (notice, vmessage, v_message_with_file_and_line,\n        v_message_with_decl, file_and_line_for_asm,\n        v_error_with_file_and_line, v_error_with_decl, v_error_for_asm,\n        verror, vfatal, v_warning_with_file_and_line, v_warning_with_decl,\n        v_warning_for_asm, vwarning, vpedwarn, v_pedwarn_with_decl,\n        v_pedwarn_with_file_and_line, vsorry, vnotice, count_error,\n        pfatal_with_name, fatal_io_error, need_error_newline,\n        last_error_function, last_error_tick, announce_function,\n        default_print_error_function, print_error_function,\n        report_error_function, fnotice, error_with_file_and_line,\n        error_with_decl, error_for_asm, error, set_fatal_function, fatal,\n        _fatal_insn, _fatal_insn_not_found, warning_with_file_and_line,\n        warning_with_decl, warning_for_asm, warning, pedwarn,\n        pedwarn_with_decl, pedwarn_with_file_and_line, sorry): Move to\n        diagnostic.c\n        (compile_file): Use fnotice instead of notice.  Adjust call.\n\n        * diagnostic.c: New file.\n\n        * Makefile.in (OBJS): Include diagnostic.o\n        (diagnostic.o): Define dependence.\n\nFrom-SVN: r31003", "tree": {"sha": "2dbd519717d22f69d49915efcbd38aa614bf0ff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dbd519717d22f69d49915efcbd38aa614bf0ff4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ed551b487b1a3c085c97125700b8cf245d53b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed551b487b1a3c085c97125700b8cf245d53b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ed551b487b1a3c085c97125700b8cf245d53b37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed551b487b1a3c085c97125700b8cf245d53b37/comments", "author": null, "committer": null, "parents": [{"sha": "ccfe7d0a0d5eee9236cb5bcf3e0216e4ce1e96e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccfe7d0a0d5eee9236cb5bcf3e0216e4ce1e96e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccfe7d0a0d5eee9236cb5bcf3e0216e4ce1e96e5"}], "stats": {"total": 1839, "additions": 964, "deletions": 875}, "files": [{"sha": "bbe9038409e3473f8ace059a8893b53f7455e27d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ed551b487b1a3c085c97125700b8cf245d53b37", "patch": "@@ -1,3 +1,27 @@\n+1999-12-18 Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+        * toplev.c (notice, vmessage, v_message_with_file_and_line,\n+        v_message_with_decl, file_and_line_for_asm,\n+        v_error_with_file_and_line, v_error_with_decl, v_error_for_asm,\n+        verror, vfatal, v_warning_with_file_and_line, v_warning_with_decl,\n+        v_warning_for_asm, vwarning, vpedwarn, v_pedwarn_with_decl,\n+        v_pedwarn_with_file_and_line, vsorry, vnotice, count_error,\n+        pfatal_with_name, fatal_io_error, need_error_newline,\n+        last_error_function, last_error_tick, announce_function,\n+        default_print_error_function, print_error_function,\n+        report_error_function, fnotice, error_with_file_and_line,\n+        error_with_decl, error_for_asm, error, set_fatal_function, fatal,\n+        _fatal_insn, _fatal_insn_not_found, warning_with_file_and_line,\n+        warning_with_decl, warning_for_asm, warning, pedwarn,\n+        pedwarn_with_decl, pedwarn_with_file_and_line, sorry): Move to\n+        diagnostic.c\n+        (compile_file): Use fnotice instead of notice.  Adjust call.\n+\n+        * diagnostic.c: New file.\n+\n+        * Makefile.in (OBJS): Include diagnostic.o\n+        (diagnostic.o): Define dependence.\n+\n 1999-12-18  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.h (ASM_OUTPUT_XXX): Wrap in do-while(0)."}, {"sha": "d138180514fef1a253ba628ca7140ea352c12aba", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6ed551b487b1a3c085c97125700b8cf245d53b37", "patch": "@@ -656,7 +656,8 @@ C_AND_OBJC_OBJS = c-lex.o c-pragma.o c-decl.o c-typeck.o c-convert.o \\\n C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n-OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n+OBJS = diagnostic.o \\\n+ toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o real.o \\\n  builtins.o intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o \\\n@@ -748,7 +749,7 @@ DEMANGLE_H = $(srcdir)/../include/demangle.h\n RECOG_H = recog.h\n EXPR_H = expr.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H)\n-INTEGRATE_H = integrate.h varray.h\n+INTREGRATE_H = integrate.h varray.h\n LOOP_H = loop.h varray.h\n #\f\n # Language makefile fragments.\n@@ -1463,6 +1464,8 @@ stor-layout.o : stor-layout.c $(CONFIG_H) system.h $(TREE_H) flags.h \\\n    function.h $(EXPR_H) $(RTL_H) toplev.h ggc.h\n fold-const.o : fold-const.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h \\\n    $(RTL_H) ggc.h\n+diagnostic.o : $(CONFIG_H) system.h $(TREE_H) $(RTL_H) tm_p.h flags.h \\\n+   input.h insn-attr.h insn-codes.h insn-config.h toplev.h intl.h\n toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n    insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\"}, {"sha": "857291328969f8cb51f60db25898add4dc3063b1", "filename": "gcc/diagnostic.c", "status": "added", "additions": 926, "deletions": 0, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=6ed551b487b1a3c085c97125700b8cf245d53b37", "patch": "@@ -0,0 +1,926 @@\n+/* Top level of GNU C compiler\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* This file implements the language independant aspect of diagnostic\n+   message module.  */\n+\n+#include \"config.h\"\n+#undef FLOAT /* This is for hpux. They should change hpux.  */\n+#undef FFS  /* Some systems define this in param.h.  */\n+#include \"system.h\"\n+\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"flags.h\"\n+#include \"input.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+#include \"insn-config.h\"\n+#include \"toplev.h\"\n+#include \"intl.h\"\n+\n+\n+/* Prototypes. */\n+static void notice PVPROTO((const char *s, ...)) ATTRIBUTE_PRINTF_1;\n+static void vmessage PROTO((const char *, const char *, va_list));\n+static void v_message_with_file_and_line PROTO((const char *, int, int,\n+\t\t\t\t\t\tconst char *, va_list));\n+static void v_message_with_decl PROTO((tree, int, const char *, va_list));\n+static void file_and_line_for_asm PROTO((rtx, char **, int *));\n+static void v_error_with_file_and_line PROTO((const char *, int,\n+\t\t\t\t\t      const char *, va_list));\n+static void v_error_with_decl PROTO((tree, const char *, va_list));\n+static void v_error_for_asm PROTO((rtx, const char *, va_list));\n+static void verror PROTO((const char *, va_list));\n+static void vfatal PROTO((const char *, va_list)) ATTRIBUTE_NORETURN;\n+static void v_warning_with_file_and_line PROTO ((const char *, int,\n+\t\t\t\t\t\t const char *, va_list));\n+static void v_warning_with_decl PROTO((tree, const char *, va_list));\n+static void v_warning_for_asm PROTO((rtx, const char *, va_list));\n+static void vwarning PROTO((const char *, va_list));\n+static void vpedwarn PROTO((const char *, va_list));\n+static void v_pedwarn_with_decl PROTO((tree, const char *, va_list));\n+static void v_pedwarn_with_file_and_line PROTO((const char *, int,\n+\t\t\t\t\t\tconst char *, va_list));\n+static void vsorry PROTO((const char *, va_list));\n+static void report_file_and_line PROTO ((const char *, int, int));\n+static void vnotice PROTO ((FILE *, const char *, va_list));\n+\n+\n+extern int rtl_dump_and_exit;\n+extern int inhibit_warnings;\n+extern int warnings_are_errors;\n+extern int warningcount;\n+extern int errorcount;\n+\n+static int need_error_newline;\n+\n+/* Function of last error message;\n+   more generally, function such that if next error message is in it\n+   then we don't have to mention the function name.  */\n+static tree last_error_function = NULL;\n+\n+/* Used to detect when input_file_stack has changed since last described.  */\n+static int last_error_tick;\n+\n+/* Called by report_error_function to print out function name.\n+ * Default may be overridden by language front-ends.  */\n+\n+void (*print_error_function) PROTO((const char *)) =\n+  default_print_error_function;\n+\n+\f\n+/* Print the message MSGID in FILE.  */\n+\n+static void\n+vnotice (file, msgid, ap)\n+     FILE *file;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  vfprintf (file, _(msgid), ap);\n+}\n+\n+/* Print MSGID on stderr.  */\n+\n+static void\n+notice VPROTO((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, char *);\n+#endif\n+\n+  vnotice (stderr, msgid, ap);\n+  va_end (ap);\n+}\n+\n+/* Report FILE and LINE (or program name), and optionally just WARN.  */\n+\n+static void\n+report_file_and_line (file, line, warn)\n+     const char *file;\n+     int line;\n+     int warn;\n+{\n+  if (file)\n+    fprintf (stderr, \"%s:%d: \", file, line);\n+  else\n+    fprintf (stderr, \"%s: \", progname);\n+\n+  if (warn)\n+    notice (\"warning: \");\n+}\n+\n+/* Print a PREFIXed MSGID.  */\n+\n+static void\n+vmessage (prefix, msgid, ap)\n+     const char *prefix;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  if (prefix)\n+    fprintf (stderr, \"%s: \", prefix);\n+\n+  vfprintf (stderr, msgid, ap);\n+}\n+\n+/* Print a message relevant to line LINE of file FILE.  */\n+\n+static void\n+v_message_with_file_and_line (file, line, warn, msgid, ap)\n+     const char *file;\n+     int line;\n+     int warn;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  report_file_and_line (file, line, warn);\n+  vnotice (stderr, msgid, ap);\n+  fputc ('\\n', stderr);\n+}\n+\n+/* Print a message relevant to the given DECL.  */\n+\n+static void\n+v_message_with_decl (decl, warn, msgid, ap)\n+     tree decl;\n+     int warn;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  const char *p;\n+\n+  report_file_and_line (DECL_SOURCE_FILE (decl),\n+\t\t\tDECL_SOURCE_LINE (decl), warn);\n+\n+  /* Do magic to get around lack of varargs support for insertion\n+     of arguments into existing list.  We know that the decl is first;\n+     we ass_u_me that it will be printed with \"%s\".  */\n+\n+  for (p = _(msgid); *p; ++p)\n+    {\n+      if (*p == '%')\n+\t{\n+\t  if (*(p + 1) == '%')\n+\t    ++p;\n+\t  else if (*(p + 1) != 's')\n+\t    abort ();\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+  if (p > _(msgid))\t\t\t/* Print the left-hand substring.  */\n+    {\n+      char fmt[sizeof \"%.255s\"];\n+      long width = p - _(msgid);\n+             \n+      if (width > 255L) width = 255L;\t/* arbitrary */\n+      sprintf (fmt, \"%%.%lds\", width);\n+      fprintf (stderr, fmt, _(msgid));\n+    }\n+\n+  if (*p == '%')\t\t/* Print the name.  */\n+    {\n+      const char *n = (DECL_NAME (decl)\n+\t\t ? (*decl_printable_name) (decl, 2)\n+\t\t : \"((anonymous))\");\n+      fputs (n, stderr);\n+      while (*p)\n+\t{\n+\t  ++p;\n+\t  if (ISALPHA (*(p - 1) & 0xFF))\n+\t    break;\n+\t}\n+    }\n+\n+  if (*p)\t\t\t/* Print the rest of the message.  */\n+    vmessage ((char *)NULL, p, ap);\n+\n+  fputc ('\\n', stderr);\n+}\n+\n+/* Figure file and line of the given INSN.  */\n+\n+static void\n+file_and_line_for_asm (insn, pfile, pline)\n+     rtx insn;\n+     char **pfile;\n+     int *pline;\n+{\n+  rtx body = PATTERN (insn);\n+  rtx asmop;\n+\n+  /* Find the (or one of the) ASM_OPERANDS in the insn.  */\n+  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+    asmop = SET_SRC (body);\n+  else if (GET_CODE (body) == ASM_OPERANDS)\n+    asmop = body;\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n+    asmop = SET_SRC (XVECEXP (body, 0, 0));\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+    asmop = XVECEXP (body, 0, 0);\n+  else\n+    asmop = NULL;\n+\n+  if (asmop)\n+    {\n+      *pfile = ASM_OPERANDS_SOURCE_FILE (asmop);\n+      *pline = ASM_OPERANDS_SOURCE_LINE (asmop);\n+    }\n+  else\n+    {\n+      *pfile = input_filename;\n+      *pline = lineno;\n+    }\n+}\n+\n+/* Report an error at line LINE of file FILE.  */\n+\n+static void\n+v_error_with_file_and_line (file, line, msgid, ap)\n+     const char *file;\n+     int line;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  count_error (0);\n+  report_error_function (file);\n+  v_message_with_file_and_line (file, line, 0, msgid, ap);\n+}\n+\n+/* Report an error at the declaration DECL.\n+   MSGID is a format string which uses %s to substitute the declaration\n+   name; subsequent substitutions are a la printf.  */\n+\n+static void\n+v_error_with_decl (decl, msgid, ap)\n+     tree decl;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  count_error (0);\n+  report_error_function (DECL_SOURCE_FILE (decl));\n+  v_message_with_decl (decl, 0, msgid, ap);\n+}\n+\n+\n+/* Report an error at the line number of the insn INSN.\n+   This is used only when INSN is an `asm' with operands,\n+   and each ASM_OPERANDS records its own source file and line.  */\n+\n+static void\n+v_error_for_asm (insn, msgid, ap)\n+     rtx insn;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  char *file;\n+  int line;\n+\n+  count_error (0);\n+  file_and_line_for_asm (insn, &file, &line);\n+  report_error_function (file);\n+  v_message_with_file_and_line (file, line, 0, msgid, ap);\n+}\n+\n+\n+/* Report an error at the current line number.  */\n+\n+static void\n+verror (msgid, ap)\n+     const char *msgid;\n+     va_list ap;\n+{\n+  v_error_with_file_and_line (input_filename, lineno, msgid, ap);\n+}\n+\n+\n+/* Report a fatal error at the current line number.  Allow a front end to\n+   intercept the message.  */\n+\n+static void (*fatal_function) PROTO ((const char *, va_list));\n+\n+static void\n+vfatal (msgid, ap)\n+     const char *msgid;\n+     va_list ap;\n+{\n+   if (fatal_function != 0)\n+     (*fatal_function) (_(msgid), ap);\n+\n+  verror (msgid, ap);\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* Report a warning at line LINE of file FILE.  */\n+\n+static void\n+v_warning_with_file_and_line (file, line, msgid, ap)\n+     const char *file;\n+     int line;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  if (count_error (1))\n+    {\n+      report_error_function (file);\n+      v_message_with_file_and_line (file, line, 1, msgid, ap);\n+    }\n+}\n+\n+\n+/* Report a warning at the declaration DECL.\n+   MSGID is a format string which uses %s to substitute the declaration\n+   name; subsequent substitutions are a la printf.  */\n+\n+static void\n+v_warning_with_decl (decl, msgid, ap)\n+     tree decl;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  if (count_error (1))\n+    {\n+      report_error_function (DECL_SOURCE_FILE (decl));\n+      v_message_with_decl (decl, 1, msgid, ap);\n+    }\n+}\n+\n+\n+/* Report a warning at the line number of the insn INSN.\n+   This is used only when INSN is an `asm' with operands,\n+   and each ASM_OPERANDS records its own source file and line.  */\n+\n+static void\n+v_warning_for_asm (insn, msgid, ap)\n+     rtx insn;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  if (count_error (1))\n+    {\n+      char *file;\n+      int line;\n+\n+      file_and_line_for_asm (insn, &file, &line);\n+      report_error_function (file);\n+      v_message_with_file_and_line (file, line, 1, msgid, ap);\n+    }\n+}\n+\n+\n+/* Report a warning at the current line number.  */\n+\n+static void\n+vwarning (msgid, ap)\n+     const char *msgid;\n+     va_list ap;\n+{\n+  v_warning_with_file_and_line (input_filename, lineno, msgid, ap);\n+}\n+\n+/* These functions issue either warnings or errors depending on\n+   -pedantic-errors.  */\n+\n+static void\n+vpedwarn (msgid, ap)\n+     const char *msgid;\n+     va_list ap;\n+{\n+  if (flag_pedantic_errors)\n+    verror (msgid, ap);\n+  else\n+    vwarning (msgid, ap);\n+}\n+\n+\n+static void\n+v_pedwarn_with_decl (decl, msgid, ap)\n+     tree decl;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  /* We don't want -pedantic-errors to cause the compilation to fail from\n+     \"errors\" in system header files.  Sometimes fixincludes can't fix what's\n+     broken (eg: unsigned char bitfields - fixing it may change the alignment\n+     which will cause programs to mysteriously fail because the C library\n+     or kernel uses the original layout).  There's no point in issuing a\n+     warning either, it's just unnecessary noise.  */\n+\n+  if (! DECL_IN_SYSTEM_HEADER (decl))\n+    {\n+      if (flag_pedantic_errors)\n+\tv_error_with_decl (decl, msgid, ap);\n+      else\n+\tv_warning_with_decl (decl, msgid, ap);\n+    }\n+}\n+\n+\n+static void\n+v_pedwarn_with_file_and_line (file, line, msgid, ap)\n+     const char *file;\n+     int line;\n+     const char *msgid;\n+     va_list ap;\n+{\n+  if (flag_pedantic_errors)\n+    v_error_with_file_and_line (file, line, msgid, ap);\n+  else\n+    v_warning_with_file_and_line (file, line, msgid, ap);\n+}\n+\n+\n+/* Apologize for not implementing some feature.  */\n+\n+static void\n+vsorry (msgid, ap)\n+     const char *msgid;\n+     va_list ap;\n+{\n+  sorrycount++;\n+  if (input_filename)\n+    fprintf (stderr, \"%s:%d: \", input_filename, lineno);\n+  else\n+    fprintf (stderr, \"%s: \", progname);\n+  notice (\"sorry, not implemented: \");\n+  vnotice (stderr, msgid, ap);\n+  fputc ('\\n', stderr);\n+}\n+\n+\f\n+/* Count an error or warning.  Return 1 if the message should be printed.  */\n+\n+int\n+count_error (warningp)\n+     int warningp;\n+{\n+  if (warningp && inhibit_warnings)\n+    return 0;\n+\n+  if (warningp && !warnings_are_errors)\n+    warningcount++;\n+  else\n+    {\n+      static int warning_message = 0;\n+\n+      if (warningp && !warning_message)\n+\t{\n+\t  notice (\"%s: warnings being treated as errors\\n\", progname);\n+\t  warning_message = 1;\n+\t}\n+      errorcount++;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Print a diagnistic MSGID on FILE.  */\n+void\n+fnotice VPROTO((FILE *file, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  FILE *file;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  file = va_arg (ap, FILE *);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  vnotice (file, msgid, ap);\n+  va_end (ap);\n+}\n+\n+\n+/* Print a fatal error message.  NAME is the text.\n+   Also include a system error message based on `errno'.  */\n+\n+void\n+pfatal_with_name (name)\n+  const char *name;\n+{\n+  fprintf (stderr, \"%s: \", progname);\n+  perror (name);\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+void\n+fatal_io_error (name)\n+  const char *name;\n+{\n+  notice (\"%s: %s: I/O error\\n\", progname, name);\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* Issue a pedantic warning MSGID.  */\n+void\n+pedwarn VPROTO((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  vpedwarn (msgid, ap);\n+  va_end (ap);\n+}\n+\n+/* Issue a pedantic waring about DECL.  */\n+void\n+pedwarn_with_decl VPROTO((tree decl, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  tree decl;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  decl = va_arg (ap, tree);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_pedwarn_with_decl (decl, msgid, ap);\n+  va_end (ap);\n+}\n+\n+/* Same as above but within the context FILE and LINE. */\n+void\n+pedwarn_with_file_and_line VPROTO((const char *file, int line,\n+\t\t\t\t   const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *file;\n+  int line;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  file = va_arg (ap, const char *);\n+  line = va_arg (ap, int);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_pedwarn_with_file_and_line (file, line, msgid, ap);\n+  va_end (ap);\n+}\n+\n+/* Just apologize with MSGID.  */\n+void\n+sorry VPROTO((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  vsorry (msgid, ap);\n+  va_end (ap);\n+}\n+\n+/* Called when the start of a function definition is parsed,\n+   this function prints on stderr the name of the function.  */\n+\n+void\n+announce_function (decl)\n+     tree decl;\n+{\n+  if (! quiet_flag)\n+    {\n+      if (rtl_dump_and_exit)\n+\tfprintf (stderr, \"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      else\n+\tfprintf (stderr, \" %s\", (*decl_printable_name) (decl, 2));\n+      fflush (stderr);\n+      need_error_newline = 1;\n+      last_error_function = current_function_decl;\n+    }\n+}\n+\n+/* The default function to print out name of current function that caused\n+   an error.  */\n+\n+void\n+default_print_error_function (file)\n+  const char *file;\n+{\n+  if (last_error_function != current_function_decl)\n+    {\n+      if (file)\n+\tfprintf (stderr, \"%s: \", file);\n+\n+      if (current_function_decl == NULL)\n+\tnotice (\"At top level:\\n\");\n+      else\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n+\t    notice (\"In method `%s':\\n\",\n+\t\t    (*decl_printable_name) (current_function_decl, 2));\n+\t  else\n+\t    notice (\"In function `%s':\\n\",\n+\t\t    (*decl_printable_name) (current_function_decl, 2));\n+\t}\n+\n+      last_error_function = current_function_decl;\n+    }\n+}\n+\n+/* Prints out, if necessary, the name of the current function\n+  that caused an error.  Called from all error and warning functions.\n+  We ignore the FILE parameter, as it cannot be relied upon.  */\n+\n+void\n+report_error_function (file)\n+  const char *file ATTRIBUTE_UNUSED;\n+{\n+  struct file_stack *p;\n+\n+  if (need_error_newline)\n+    {\n+      fprintf (stderr, \"\\n\");\n+      need_error_newline = 0;\n+    }\n+\n+  if (input_file_stack && input_file_stack->next != 0\n+      && input_file_stack_tick != last_error_tick)\n+    {\n+      for (p = input_file_stack->next; p; p = p->next)\n+\tif (p == input_file_stack->next)\n+\t  notice (\"In file included from %s:%d\", p->name, p->line);\n+\telse\n+\t  notice (\",\\n                 from %s:%d\", p->name, p->line);\n+      fprintf (stderr, \":\\n\");\n+      last_error_tick = input_file_stack_tick;\n+    }\n+\n+  (*print_error_function) (input_filename);\n+}\n+\n+void\n+error_with_file_and_line VPROTO((const char *file, int line,\n+\t\t\t\t const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *file;\n+  int line;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  file = va_arg (ap, const char *);\n+  line = va_arg (ap, int);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_error_with_file_and_line (file, line, msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+error_with_decl VPROTO((tree decl, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  tree decl;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  decl = va_arg (ap, tree);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_error_with_decl (decl, msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+error_for_asm VPROTO((rtx insn, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  rtx insn;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  insn = va_arg (ap, rtx);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_error_for_asm (insn, msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+error VPROTO((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  verror (msgid, ap);\n+  va_end (ap);\n+}\n+\n+/* Set the function to call when a fatal error occurs.  */\n+\n+void\n+set_fatal_function (f)\n+     void (*f) PROTO ((const char *, va_list));\n+{\n+  fatal_function = f;\n+}\n+\n+void\n+fatal VPROTO((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  vfatal (msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+_fatal_insn (msgid, insn, file, line, function)\n+     const char *msgid;\n+     rtx insn;\n+     const char *file;\n+     int line;\n+     const char *function;\n+{\n+  error (\"%s\", msgid);\n+  debug_rtx (insn);\n+  fancy_abort (file, line, function);\n+}\n+\n+void\n+_fatal_insn_not_found (insn, file, line, function)\n+     rtx insn;\n+     const char *file;\n+     int line;\n+     const char *function;\n+{\n+  if (INSN_CODE (insn) < 0)\n+    _fatal_insn (\"Unrecognizable insn:\", insn, file, line, function);\n+  else\n+    _fatal_insn (\"Insn does not satisfy its constraints:\",\n+\t\tinsn, file, line, function);\n+}\n+\n+void\n+warning_with_file_and_line VPROTO((const char *file, int line,\n+\t\t\t\t   const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *file;\n+  int line;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  file = va_arg (ap, const char *);\n+  line = va_arg (ap, int);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_warning_with_file_and_line (file, line, msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+warning_with_decl VPROTO((tree decl, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  tree decl;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  decl = va_arg (ap, tree);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_warning_with_decl (decl, msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+warning_for_asm VPROTO((rtx insn, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  rtx insn;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  insn = va_arg (ap, rtx);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  v_warning_for_asm (insn, msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+warning VPROTO((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  vwarning (msgid, ap);\n+  va_end (ap);\n+}\n+"}, {"sha": "a3fbd02489c0d387c57e8c0822e1afdcb9f89151", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 873, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed551b487b1a3c085c97125700b8cf245d53b37/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6ed551b487b1a3c085c97125700b8cf245d53b37", "patch": "@@ -151,30 +151,9 @@ extern char *version_string;\n extern int size_directive_output;\n extern tree last_assemble_variable_decl;\n \n-static void notice PVPROTO((const char *s, ...)) ATTRIBUTE_PRINTF_1;\n static void set_target_switch PROTO((const char *));\n static const char *decl_name PROTO((tree, int));\n-static void vmessage PROTO((const char *, const char *, va_list));\n-static void v_message_with_file_and_line PROTO((const char *, int, int,\n-\t\t\t\t\t\tconst char *, va_list));\n-static void v_message_with_decl PROTO((tree, int, const char *, va_list));\n-static void file_and_line_for_asm PROTO((rtx, char **, int *));\n-static void v_error_with_file_and_line PROTO((const char *, int,\n-\t\t\t\t\t      const char *, va_list));\n-static void v_error_with_decl PROTO((tree, const char *, va_list));\n-static void v_error_for_asm PROTO((rtx, const char *, va_list));\n-static void verror PROTO((const char *, va_list));\n-static void vfatal PROTO((const char *, va_list)) ATTRIBUTE_NORETURN;\n-static void v_warning_with_file_and_line PROTO ((const char *, int,\n-\t\t\t\t\t\t const char *, va_list));\n-static void v_warning_with_decl PROTO((tree, const char *, va_list));\n-static void v_warning_for_asm PROTO((rtx, const char *, va_list));\n-static void vwarning PROTO((const char *, va_list));\n-static void vpedwarn PROTO((const char *, va_list));\n-static void v_pedwarn_with_decl PROTO((tree, const char *, va_list));\n-static void v_pedwarn_with_file_and_line PROTO((const char *, int,\n-\t\t\t\t\t\tconst char *, va_list));\n-static void vsorry PROTO((const char *, va_list));\n+\n extern void set_fatal_function PROTO((void (*)(const char *, va_list)));\n static void float_signal PROTO((int)) ATTRIBUTE_NORETURN;\n static void pipe_closed PROTO((int)) ATTRIBUTE_NORETURN;\n@@ -189,7 +168,6 @@ static void clean_dump_file PROTO((const char *));\n static void compile_file PROTO((char *));\n static void display_help PROTO ((void));\n static void report_file_and_line PROTO ((const char *, int, int));\n-static void vnotice PROTO ((FILE *, const char *, va_list));\n static void mark_file_stack PROTO ((void *));\n \n static void decode_d_option PROTO ((const char *));\n@@ -1451,52 +1429,6 @@ print_time (str, total)\n \t   (double)total / (double)all_time * 100.0);\n }\n \n-/* Count an error or warning.  Return 1 if the message should be printed.  */\n-\n-int\n-count_error (warningp)\n-     int warningp;\n-{\n-  if (warningp && inhibit_warnings)\n-    return 0;\n-\n-  if (warningp && !warnings_are_errors)\n-    warningcount++;\n-  else\n-    {\n-      static int warning_message = 0;\n-\n-      if (warningp && !warning_message)\n-\t{\n-\t  notice (\"%s: warnings being treated as errors\\n\", progname);\n-\t  warning_message = 1;\n-\t}\n-      errorcount++;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Print a fatal error message.  NAME is the text.\n-   Also include a system error message based on `errno'.  */\n-\n-void\n-pfatal_with_name (name)\n-  const char *name;\n-{\n-  fprintf (stderr, \"%s: \", progname);\n-  perror (name);\n-  exit (FATAL_EXIT_CODE);\n-}\n-\n-void\n-fatal_io_error (name)\n-  const char *name;\n-{\n-  notice (\"%s: %s: I/O error\\n\", progname, name);\n-  exit (FATAL_EXIT_CODE);\n-}\n-\n /* This is the default decl_printable_name function.  */\n \n static const char *\n@@ -1525,793 +1457,6 @@ mark_file_stack (p)\n       stack = stack->next;\n     }\n }\n-\n-static int need_error_newline;\n-\n-/* Function of last error message;\n-   more generally, function such that if next error message is in it\n-   then we don't have to mention the function name.  */\n-static tree last_error_function = NULL;\n-\n-/* Used to detect when input_file_stack has changed since last described.  */\n-static int last_error_tick;\n-\n-/* Called when the start of a function definition is parsed,\n-   this function prints on stderr the name of the function.  */\n-\n-void\n-announce_function (decl)\n-     tree decl;\n-{\n-  if (! quiet_flag)\n-    {\n-      if (rtl_dump_and_exit)\n-\tfprintf (stderr, \"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n-      else\n-\tfprintf (stderr, \" %s\", (*decl_printable_name) (decl, 2));\n-      fflush (stderr);\n-      need_error_newline = 1;\n-      last_error_function = current_function_decl;\n-    }\n-}\n-\n-/* The default function to print out name of current function that caused\n-   an error.  */\n-\n-void\n-default_print_error_function (file)\n-  const char *file;\n-{\n-  if (last_error_function != current_function_decl)\n-    {\n-      if (file)\n-\tfprintf (stderr, \"%s: \", file);\n-\n-      if (current_function_decl == NULL)\n-\tnotice (\"At top level:\\n\");\n-      else\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n-\t    notice (\"In method `%s':\\n\",\n-\t\t    (*decl_printable_name) (current_function_decl, 2));\n-\t  else\n-\t    notice (\"In function `%s':\\n\",\n-\t\t    (*decl_printable_name) (current_function_decl, 2));\n-\t}\n-\n-      last_error_function = current_function_decl;\n-    }\n-}\n-\n-/* Called by report_error_function to print out function name.\n- * Default may be overridden by language front-ends.  */\n-\n-void (*print_error_function) PROTO((const char *)) =\n-  default_print_error_function;\n-\n-/* Prints out, if necessary, the name of the current function\n-  that caused an error.  Called from all error and warning functions.\n-  We ignore the FILE parameter, as it cannot be relied upon.  */\n-\n-void\n-report_error_function (file)\n-  const char *file ATTRIBUTE_UNUSED;\n-{\n-  struct file_stack *p;\n-\n-  if (need_error_newline)\n-    {\n-      fprintf (stderr, \"\\n\");\n-      need_error_newline = 0;\n-    }\n-\n-  if (input_file_stack && input_file_stack->next != 0\n-      && input_file_stack_tick != last_error_tick)\n-    {\n-      for (p = input_file_stack->next; p; p = p->next)\n-\tif (p == input_file_stack->next)\n-\t  notice (\"In file included from %s:%d\", p->name, p->line);\n-\telse\n-\t  notice (\",\\n                 from %s:%d\", p->name, p->line);\n-      fprintf (stderr, \":\\n\");\n-      last_error_tick = input_file_stack_tick;\n-    }\n-\n-  (*print_error_function) (input_filename);\n-}\n-\f\n-/* Print a message.  */\n-\n-static void\n-vnotice (file, msgid, ap)\n-     FILE *file;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  vfprintf (file, _(msgid), ap);\n-}\n-\n-static void\n-notice VPROTO((const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (ap, char *);\n-#endif\n-\n-  vnotice (stderr, msgid, ap);\n-  va_end (ap);\n-}\n-\n-void\n-fnotice VPROTO((FILE *file, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  FILE *file;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  file = va_arg (ap, FILE *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  vnotice (file, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report FILE and LINE (or program name), and optionally just WARN.  */\n-\n-static void\n-report_file_and_line (file, line, warn)\n-     const char *file;\n-     int line;\n-     int warn;\n-{\n-  if (file)\n-    fprintf (stderr, \"%s:%d: \", file, line);\n-  else\n-    fprintf (stderr, \"%s: \", progname);\n-\n-  if (warn)\n-    notice (\"warning: \");\n-}\n-\n-/* Print a message.  */\n-\n-static void\n-vmessage (prefix, msgid, ap)\n-     const char *prefix;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  if (prefix)\n-    fprintf (stderr, \"%s: \", prefix);\n-\n-  vfprintf (stderr, msgid, ap);\n-}\n-\n-/* Print a message relevant to line LINE of file FILE.  */\n-\n-static void\n-v_message_with_file_and_line (file, line, warn, msgid, ap)\n-     const char *file;\n-     int line;\n-     int warn;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  report_file_and_line (file, line, warn);\n-  vnotice (stderr, msgid, ap);\n-  fputc ('\\n', stderr);\n-}\n-\n-/* Print a message relevant to the given DECL.  */\n-\n-static void\n-v_message_with_decl (decl, warn, msgid, ap)\n-     tree decl;\n-     int warn;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  const char *p;\n-\n-  report_file_and_line (DECL_SOURCE_FILE (decl),\n-\t\t\tDECL_SOURCE_LINE (decl), warn);\n-\n-  /* Do magic to get around lack of varargs support for insertion\n-     of arguments into existing list.  We know that the decl is first;\n-     we ass_u_me that it will be printed with \"%s\".  */\n-\n-  for (p = _(msgid); *p; ++p)\n-    {\n-      if (*p == '%')\n-\t{\n-\t  if (*(p + 1) == '%')\n-\t    ++p;\n-\t  else if (*(p + 1) != 's')\n-\t    abort ();\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  if (p > _(msgid))\t\t\t/* Print the left-hand substring.  */\n-    {\n-      char fmt[sizeof \"%.255s\"];\n-      long width = p - _(msgid);\n-             \n-      if (width > 255L) width = 255L;\t/* arbitrary */\n-      sprintf (fmt, \"%%.%lds\", width);\n-      fprintf (stderr, fmt, _(msgid));\n-    }\n-\n-  if (*p == '%')\t\t/* Print the name.  */\n-    {\n-      const char *n = (DECL_NAME (decl)\n-\t\t ? (*decl_printable_name) (decl, 2)\n-\t\t : \"((anonymous))\");\n-      fputs (n, stderr);\n-      while (*p)\n-\t{\n-\t  ++p;\n-\t  if (ISALPHA (*(p - 1) & 0xFF))\n-\t    break;\n-\t}\n-    }\n-\n-  if (*p)\t\t\t/* Print the rest of the message.  */\n-    vmessage ((char *)NULL, p, ap);\n-\n-  fputc ('\\n', stderr);\n-}\n-\n-/* Figure file and line of the given INSN.  */\n-\n-static void\n-file_and_line_for_asm (insn, pfile, pline)\n-     rtx insn;\n-     char **pfile;\n-     int *pline;\n-{\n-  rtx body = PATTERN (insn);\n-  rtx asmop;\n-\n-  /* Find the (or one of the) ASM_OPERANDS in the insn.  */\n-  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n-    asmop = SET_SRC (body);\n-  else if (GET_CODE (body) == ASM_OPERANDS)\n-    asmop = body;\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n-    asmop = SET_SRC (XVECEXP (body, 0, 0));\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n-    asmop = XVECEXP (body, 0, 0);\n-  else\n-    asmop = NULL;\n-\n-  if (asmop)\n-    {\n-      *pfile = ASM_OPERANDS_SOURCE_FILE (asmop);\n-      *pline = ASM_OPERANDS_SOURCE_LINE (asmop);\n-    }\n-  else\n-    {\n-      *pfile = input_filename;\n-      *pline = lineno;\n-    }\n-}\n-\n-/* Report an error at line LINE of file FILE.  */\n-\n-static void\n-v_error_with_file_and_line (file, line, msgid, ap)\n-     const char *file;\n-     int line;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  count_error (0);\n-  report_error_function (file);\n-  v_message_with_file_and_line (file, line, 0, msgid, ap);\n-}\n-\n-void\n-error_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *file;\n-  int line;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  file = va_arg (ap, const char *);\n-  line = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_error_with_file_and_line (file, line, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report an error at the declaration DECL.\n-   MSGID is a format string which uses %s to substitute the declaration\n-   name; subsequent substitutions are a la printf.  */\n-\n-static void\n-v_error_with_decl (decl, msgid, ap)\n-     tree decl;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  count_error (0);\n-  report_error_function (DECL_SOURCE_FILE (decl));\n-  v_message_with_decl (decl, 0, msgid, ap);\n-}\n-\n-void\n-error_with_decl VPROTO((tree decl, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  tree decl;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  decl = va_arg (ap, tree);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_error_with_decl (decl, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report an error at the line number of the insn INSN.\n-   This is used only when INSN is an `asm' with operands,\n-   and each ASM_OPERANDS records its own source file and line.  */\n-\n-static void\n-v_error_for_asm (insn, msgid, ap)\n-     rtx insn;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  char *file;\n-  int line;\n-\n-  count_error (0);\n-  file_and_line_for_asm (insn, &file, &line);\n-  report_error_function (file);\n-  v_message_with_file_and_line (file, line, 0, msgid, ap);\n-}\n-\n-void\n-error_for_asm VPROTO((rtx insn, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  rtx insn;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  insn = va_arg (ap, rtx);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_error_for_asm (insn, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report an error at the current line number.  */\n-\n-static void\n-verror (msgid, ap)\n-     const char *msgid;\n-     va_list ap;\n-{\n-  v_error_with_file_and_line (input_filename, lineno, msgid, ap);\n-}\n-\n-void\n-error VPROTO((const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  verror (msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report a fatal error at the current line number.  Allow a front end to\n-   intercept the message.  */\n-\n-static void (*fatal_function) PROTO ((const char *, va_list));\n-\n-/* Set the function to call when a fatal error occurs.  */\n-\n-void\n-set_fatal_function (f)\n-     void (*f) PROTO ((const char *, va_list));\n-{\n-  fatal_function = f;\n-}\n-\n-static void\n-vfatal (msgid, ap)\n-     const char *msgid;\n-     va_list ap;\n-{\n-   if (fatal_function != 0)\n-     (*fatal_function) (_(msgid), ap);\n-\n-  verror (msgid, ap);\n-  exit (FATAL_EXIT_CODE);\n-}\n-\n-void\n-fatal VPROTO((const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  vfatal (msgid, ap);\n-  va_end (ap);\n-}\n-\n-void\n-_fatal_insn (msgid, insn, file, line, function)\n-     const char *msgid;\n-     rtx insn;\n-     const char *file;\n-     int line;\n-     const char *function;\n-{\n-  error (\"%s\", msgid);\n-  debug_rtx (insn);\n-  fancy_abort (file, line, function);\n-}\n-\n-void\n-_fatal_insn_not_found (insn, file, line, function)\n-     rtx insn;\n-     const char *file;\n-     int line;\n-     const char *function;\n-{\n-  if (INSN_CODE (insn) < 0)\n-    _fatal_insn (\"Unrecognizable insn:\", insn, file, line, function);\n-  else\n-    _fatal_insn (\"Insn does not satisfy its constraints:\",\n-\t\tinsn, file, line, function);\n-}\n-\n-/* Report a warning at line LINE of file FILE.  */\n-\n-static void\n-v_warning_with_file_and_line (file, line, msgid, ap)\n-     const char *file;\n-     int line;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  if (count_error (1))\n-    {\n-      report_error_function (file);\n-      v_message_with_file_and_line (file, line, 1, msgid, ap);\n-    }\n-}\n-\n-void\n-warning_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t   const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *file;\n-  int line;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  file = va_arg (ap, const char *);\n-  line = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_warning_with_file_and_line (file, line, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report a warning at the declaration DECL.\n-   MSGID is a format string which uses %s to substitute the declaration\n-   name; subsequent substitutions are a la printf.  */\n-\n-static void\n-v_warning_with_decl (decl, msgid, ap)\n-     tree decl;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  if (count_error (1))\n-    {\n-      report_error_function (DECL_SOURCE_FILE (decl));\n-      v_message_with_decl (decl, 1, msgid, ap);\n-    }\n-}\n-\n-void\n-warning_with_decl VPROTO((tree decl, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  tree decl;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  decl = va_arg (ap, tree);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_warning_with_decl (decl, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report a warning at the line number of the insn INSN.\n-   This is used only when INSN is an `asm' with operands,\n-   and each ASM_OPERANDS records its own source file and line.  */\n-\n-static void\n-v_warning_for_asm (insn, msgid, ap)\n-     rtx insn;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  if (count_error (1))\n-    {\n-      char *file;\n-      int line;\n-\n-      file_and_line_for_asm (insn, &file, &line);\n-      report_error_function (file);\n-      v_message_with_file_and_line (file, line, 1, msgid, ap);\n-    }\n-}\n-\n-void\n-warning_for_asm VPROTO((rtx insn, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  rtx insn;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  insn = va_arg (ap, rtx);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_warning_for_asm (insn, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Report a warning at the current line number.  */\n-\n-static void\n-vwarning (msgid, ap)\n-     const char *msgid;\n-     va_list ap;\n-{\n-  v_warning_with_file_and_line (input_filename, lineno, msgid, ap);\n-}\n-\n-void\n-warning VPROTO((const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  vwarning (msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* These functions issue either warnings or errors depending on\n-   -pedantic-errors.  */\n-\n-static void\n-vpedwarn (msgid, ap)\n-     const char *msgid;\n-     va_list ap;\n-{\n-  if (flag_pedantic_errors)\n-    verror (msgid, ap);\n-  else\n-    vwarning (msgid, ap);\n-}\n-\n-void\n-pedwarn VPROTO((const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  vpedwarn (msgid, ap);\n-  va_end (ap);\n-}\n-\n-static void\n-v_pedwarn_with_decl (decl, msgid, ap)\n-     tree decl;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  /* We don't want -pedantic-errors to cause the compilation to fail from\n-     \"errors\" in system header files.  Sometimes fixincludes can't fix what's\n-     broken (eg: unsigned char bitfields - fixing it may change the alignment\n-     which will cause programs to mysteriously fail because the C library\n-     or kernel uses the original layout).  There's no point in issuing a\n-     warning either, it's just unnecessary noise.  */\n-\n-  if (! DECL_IN_SYSTEM_HEADER (decl))\n-    {\n-      if (flag_pedantic_errors)\n-\tv_error_with_decl (decl, msgid, ap);\n-      else\n-\tv_warning_with_decl (decl, msgid, ap);\n-    }\n-}\n-\n-void\n-pedwarn_with_decl VPROTO((tree decl, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  tree decl;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  decl = va_arg (ap, tree);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_pedwarn_with_decl (decl, msgid, ap);\n-  va_end (ap);\n-}\n-\n-static void\n-v_pedwarn_with_file_and_line (file, line, msgid, ap)\n-     const char *file;\n-     int line;\n-     const char *msgid;\n-     va_list ap;\n-{\n-  if (flag_pedantic_errors)\n-    v_error_with_file_and_line (file, line, msgid, ap);\n-  else\n-    v_warning_with_file_and_line (file, line, msgid, ap);\n-}\n-\n-void\n-pedwarn_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t   const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *file;\n-  int line;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  file = va_arg (ap, const char *);\n-  line = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_pedwarn_with_file_and_line (file, line, msgid, ap);\n-  va_end (ap);\n-}\n-\n-/* Apologize for not implementing some feature.  */\n-\n-static void\n-vsorry (msgid, ap)\n-     const char *msgid;\n-     va_list ap;\n-{\n-  sorrycount++;\n-  if (input_filename)\n-    fprintf (stderr, \"%s:%d: \", input_filename, lineno);\n-  else\n-    fprintf (stderr, \"%s: \", progname);\n-  notice (\"sorry, not implemented: \");\n-  vnotice (stderr, msgid, ap);\n-  fputc ('\\n', stderr);\n-}\n-\n-void\n-sorry VPROTO((const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  vsorry (msgid, ap);\n-  va_end (ap);\n-}\n \f\n \n /* This calls abort and is used to avoid problems when abort if a macro.\n@@ -3238,7 +2383,7 @@ compile_file (name)\n   if (yyparse () != 0)\n     {\n       if (errorcount == 0)\n-\tnotice (\"Errors detected in input file (your bison.simple is out of date)\\n\");\n+\tfnotice (stderr, \"Errors detected in input file (your bison.simple is out of date)\\n\");\n \n       /* In case there were missing closebraces,\n \t get us back to the global binding level.  */\n@@ -3605,14 +2750,6 @@ rest_of_compilation (decl)\n      collector to reclaim the memory used by the notes.  */\n   remove_unncessary_notes ();\n \n-  /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n-     tree in sensible shape.  So, we just recalculate it here.  */\n-  if (current_function->x_whole_function_mode_p)\n-    {\n-      find_loop_tree_blocks ();\n-      unroll_block_trees ();\n-    }\n-\n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n \n@@ -4068,7 +3205,6 @@ rest_of_compilation (decl)\n \t(flow_time,\n \t {\n \t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n-\t   calculate_loop_depth (rtl_dump_file);\n \t   life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n \t });\n \n@@ -4401,6 +3537,12 @@ rest_of_compilation (decl)\n      ggc_collect ();\n #endif\n \n+  /* Shorten branches.  */\n+  TIMEVAR (shorten_branch_time,\n+\t   {\n+\t     shorten_branches (get_insns ());\n+\t   });\n+\n #ifdef STACK_REGS\n   if (stack_reg_dump)\n     open_dump_file (\".20.stack\", decl_printable_name (decl, 2));\n@@ -4418,12 +3560,6 @@ rest_of_compilation (decl)\n      ggc_collect ();\n #endif\n \n-  /* Shorten branches.  */\n-  TIMEVAR (shorten_branch_time,\n-\t   {\n-\t     shorten_branches (get_insns ());\n-\t   });\n-\n   /* Now turn the rtl into assembler code.  */\n \n   TIMEVAR (final_time,\n@@ -5624,7 +4760,7 @@ main (argc, argv)\n     {\n       char *lim = (char *) sbrk (0);\n \n-      notice (\"Data size %ld.\\n\", (long) (lim - (char *) &environ));\n+      fnotice (stderr, \"Data size %ld.\\n\", (long) (lim - (char *) &environ));\n       fflush (stderr);\n \n #ifndef __MSDOS__"}]}