{"sha": "fdd695fdb4650c6221ed38e952fa0fe00a214afa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRkNjk1ZmRiNDY1MGM2MjIxZWQzOGU5NTJmYTBmZTAwYTIxNGFmYQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-05-05T23:11:55Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-05-05T23:11:55Z"}, "message": "arm-protots.h (vfp_mem_operand): Rename ...\n\n\t* config/arm/arm-protots.h (vfp_mem_operand): Rename ...\n\t(arm_coproc_mem_operand): ... To this.\n\t* config/arm/arm.c (arm_legitimate_address_p): Allow ldrd modes.\n\t(arm_legitimate_index_p): Ditto.\n\t(vfp_mem_operand): Rename ...\n\t(arm_coproc_mem_operand): ... To this.  Handle writeback modes.\n\t(vfp_secondary_reload_class): Use it.\n\t(output_move_double): Use doubleword load/store instructions.\n\t(arm_hard_regno_mode_ok): Only allow even reg pairs for ldrd.\n\t* config/arm/arm.h (TARGET_LDRD): Define.\n\t(EXTRA_CONSTRAINT_STR_ARM): Add 'Uy'.\n\t* config/gcc/arm/arm.md (arm_movdi): Allow all valid memory operands.\n\tNew splitter for invalid doubleword loads.\n\t* config/arm/iwmmxt.md (iwmmxt_arm_movdi): Use Uy constraint.\n\t* config/arm/vfp.md (arm_movdi_vfp): Allow all valid memory operands.\n\t* doc/md.texi: Document Uy constraint.\n\nFrom-SVN: r81543", "tree": {"sha": "55df21a18e500fcafb6fcaf071eb2fc50186dc76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55df21a18e500fcafb6fcaf071eb2fc50186dc76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdd695fdb4650c6221ed38e952fa0fe00a214afa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdd695fdb4650c6221ed38e952fa0fe00a214afa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdd695fdb4650c6221ed38e952fa0fe00a214afa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdd695fdb4650c6221ed38e952fa0fe00a214afa/comments", "author": null, "committer": null, "parents": [{"sha": "74e94435cc57b47e9cd2a30e3bccd73c2b719102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e94435cc57b47e9cd2a30e3bccd73c2b719102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74e94435cc57b47e9cd2a30e3bccd73c2b719102"}], "stats": {"total": 340, "additions": 245, "deletions": 95}, "files": [{"sha": "05aa794899cf3afe5ffa62be978401d06618097c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -1,3 +1,22 @@\n+2004-05-06  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm-protots.h (vfp_mem_operand): Rename ...\n+\t(arm_coproc_mem_operand): ... To this.\n+\t* config/arm/arm.c (arm_legitimate_address_p): Allow ldrd modes.\n+\t(arm_legitimate_index_p): Ditto.\n+\t(vfp_mem_operand): Rename ...\n+\t(arm_coproc_mem_operand): ... To this.  Handle writeback modes.\n+\t(vfp_secondary_reload_class): Use it.\n+\t(output_move_double): Use doubleword load/store instructions.\n+\t(arm_hard_regno_mode_ok): Only allow even reg pairs for ldrd.\n+\t* config/arm/arm.h (TARGET_LDRD): Define.\n+\t(EXTRA_CONSTRAINT_STR_ARM): Add 'Uy'.\n+\t* config/gcc/arm/arm.md (arm_movdi): Allow all valid memory operands.\n+\tNew splitter for invalid doubleword loads.\n+\t* config/arm/iwmmxt.md (iwmmxt_arm_movdi): Use Uy constraint.\n+\t* config/arm/vfp.md (arm_movdi_vfp): Allow all valid memory operands.\n+\t* doc/md.texi: Document Uy constraint.\n+\n 2004-05-05  Jan Hubicka  <jh@suse.cz>\n \n \tPR opt/14980"}, {"sha": "0605803a3fe5223e3307ff7121d8bafd599f217c", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -100,7 +100,7 @@ extern int cirrus_general_operand (rtx, enum machine_mode);\n extern int cirrus_register_operand (rtx, enum machine_mode);\n extern int cirrus_shift_const (rtx, enum machine_mode);\n extern int cirrus_memory_offset (rtx);\n-extern int vfp_mem_operand (rtx);\n+extern int arm_coproc_mem_operand (rtx, bool);\n extern int vfp_compare_operand (rtx, enum machine_mode);\n extern int arm_float_compare_operand (rtx, enum machine_mode);\n extern int arm_no_early_store_addr_dep (rtx, rtx);"}, {"sha": "961dff2278ef7a9503520faa76194aaaff00870a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 193, "deletions": 88, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -2983,25 +2983,44 @@ int\n arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n \t\t\t  int strict_p)\n {\n+  bool use_ldrd;\n+  enum rtx_code code = GET_CODE (x);\n+  \n   if (arm_address_register_rtx_p (x, strict_p))\n     return 1;\n \n-  else if (GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_DEC)\n+  use_ldrd = (TARGET_LDRD\n+\t      && (mode == DImode\n+\t\t  || (mode == DFmode && (TARGET_SOFT_FLOAT || TARGET_VFP))));\n+\n+  if (code == POST_INC || code == PRE_DEC\n+      || ((code == PRE_INC || code == POST_DEC)\n+\t  && (use_ldrd || GET_MODE_SIZE (mode) <= 4)))\n     return arm_address_register_rtx_p (XEXP (x, 0), strict_p);\n \n-  else if ((GET_CODE (x) == POST_MODIFY || GET_CODE (x) == PRE_MODIFY)\n-\t   && GET_MODE_SIZE (mode) <= 4\n+  else if ((code == POST_MODIFY || code == PRE_MODIFY)\n \t   && arm_address_register_rtx_p (XEXP (x, 0), strict_p)\n \t   && GET_CODE (XEXP (x, 1)) == PLUS\n \t   && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n-    return arm_legitimate_index_p (mode, XEXP (XEXP (x, 1), 1), outer,\n-\t\t\t\t   strict_p);\n+    {\n+      rtx addend = XEXP (XEXP (x, 1), 1);\n+\n+      /* Don't allow ldrd post increment by register becuase it's hard\n+\t to fixup invalid register choices.  */\n+      if (use_ldrd\n+\t  && GET_CODE (x) == POST_MODIFY\n+\t  && GET_CODE (addend) == REG)\n+\treturn 0;\n+\n+      return ((use_ldrd || GET_MODE_SIZE (mode) <= 4)\n+\t      && arm_legitimate_index_p (mode, addend, outer, strict_p));\n+    }\n \n   /* After reload constants split into minipools will have addresses\n      from a LABEL_REF.  */\n   else if (reload_completed\n-\t   && (GET_CODE (x) == LABEL_REF\n-\t       || (GET_CODE (x) == CONST\n+\t   && (code == LABEL_REF\n+\t       || (code == CONST\n \t\t   && GET_CODE (XEXP (x, 0)) == PLUS\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n@@ -3010,38 +3029,7 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n   else if (mode == TImode)\n     return 0;\n \n-  else if (mode == DImode || (TARGET_SOFT_FLOAT && mode == DFmode))\n-    {\n-      if (GET_CODE (x) == PLUS\n-\t  && arm_address_register_rtx_p (XEXP (x, 0), strict_p)\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n-\n-          if (val == 4 || val == -4 || val == -8)\n-\t    return 1;\n-\t}\n-    }\n-\n-  else if (TARGET_HARD_FLOAT && TARGET_VFP && mode == DFmode)\n-    {\n-      if (GET_CODE (x) == PLUS\n-\t  && arm_address_register_rtx_p (XEXP (x, 0), strict_p)\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n-\n-\t  /* ??? valid arm offsets are a subset of VFP offsets.\n-\t     For now only allow this subset.  Proper fix is to add an\n-\t     additional memory constraint for arm address modes.\n-\t     Alternatively allow full vfp addressing and let\n-\t     output_move_double fix it up with a sub-optimal sequence.  */\n-          if (val == 4 || val == -4 || val == -8)\n-\t    return 1;\n-\t}\n-    }\n-\n-  else if (GET_CODE (x) == PLUS)\n+  else if (code == PLUS)\n     {\n       rtx xop0 = XEXP (x, 0);\n       rtx xop1 = XEXP (x, 1);\n@@ -3065,17 +3053,12 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n #endif\n \n   else if (GET_MODE_CLASS (mode) != MODE_FLOAT\n-\t   && GET_CODE (x) == SYMBOL_REF\n+\t   && code == SYMBOL_REF\n \t   && CONSTANT_POOL_ADDRESS_P (x)\n \t   && ! (flag_pic\n \t\t && symbol_mentioned_p (get_pool_constant (x))))\n     return 1;\n \n-  else if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == POST_DEC)\n-\t   && (GET_MODE_SIZE (mode) <= 4)\n-\t   && arm_address_register_rtx_p (XEXP (x, 0), strict_p))\n-    return 1;\n-\n   return 0;\n }\n \n@@ -3097,16 +3080,31 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n \t    && INTVAL (index) > -1024\n \t    && (INTVAL (index) & 3) == 0);\n \n-  if (arm_address_register_rtx_p (index, strict_p)\n-      && GET_MODE_SIZE (mode) <= 4)\n-    return 1;\n-\n   if (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (mode))\n     return (code == CONST_INT\n \t    && INTVAL (index) < 1024\n \t    && INTVAL (index) > -1024\n \t    && (INTVAL (index) & 3) == 0);\n \n+  if (arm_address_register_rtx_p (index, strict_p)\n+      && (GET_MODE_SIZE (mode) <= 4))\n+    return 1;\n+\n+  if (mode == DImode || mode == DFmode)\n+    {\n+      if (code == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (index);\n+\n+\t  if (TARGET_LDRD)\n+\t    return val > -256 && val < 256;\n+\t  else\n+\t    return val == 4 || val == -4 || val == -8;\n+\t}\n+\n+      return TARGET_LDRD && arm_address_register_rtx_p (index, strict_p);\n+    }\n+\n   if (GET_MODE_SIZE (mode) <= 4\n       && ! (arm_arch4\n \t    && (mode == HImode\n@@ -4614,14 +4612,15 @@ cirrus_shift_const (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n }\n \n \n-/* Return TRUE if OP is a valid VFP memory address pattern.  */\n-/* Copied from cirrus_memory_offset but with restricted offset range.  */\n+/* Return TRUE if OP is a valid VFP memory address pattern.\n+   WB if true if writeback address modes are allowed.  */\n \n int\n-vfp_mem_operand (rtx op)\n+arm_coproc_mem_operand (rtx op, bool wb)\n {\n-  /* Reject eliminable registers.  */\n+  rtx ind;\n \n+  /* Reject eliminable registers.  */\n   if (! (reload_in_progress || reload_completed)\n       && (   reg_mentioned_p (frame_pointer_rtx, op)\n \t  || reg_mentioned_p (arg_pointer_rtx, op)\n@@ -4632,35 +4631,49 @@ vfp_mem_operand (rtx op)\n     return FALSE;\n \n   /* Constants are converted into offsets from labels.  */\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx ind;\n-\n-      ind = XEXP (op, 0);\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n \n-      if (reload_completed\n-\t  && (GET_CODE (ind) == LABEL_REF\n-\t      || (GET_CODE (ind) == CONST\n-\t\t  && GET_CODE (XEXP (ind, 0)) == PLUS\n-\t\t  && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n-\t\t  && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n-\treturn TRUE;\n+  ind = XEXP (op, 0);\n \n-      /* Match: (mem (reg)).  */\n-      if (GET_CODE (ind) == REG)\n-\treturn arm_address_register_rtx_p (ind, 0);\n+  if (reload_completed\n+      && (GET_CODE (ind) == LABEL_REF\n+\t  || (GET_CODE (ind) == CONST\n+\t      && GET_CODE (XEXP (ind, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (ind, 0), 0)) == LABEL_REF\n+\t      && GET_CODE (XEXP (XEXP (ind, 0), 1)) == CONST_INT)))\n+    return TRUE;\n \n-      /* Match:\n-\t (mem (plus (reg)\n-\t            (const))).  */\n-      if (GET_CODE (ind) == PLUS\n-\t  && GET_CODE (XEXP (ind, 0)) == REG\n-\t  && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n-\t  && GET_CODE (XEXP (ind, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (ind, 1)) > -1024\n-\t  && INTVAL (XEXP (ind, 1)) <  1024)\n-\treturn TRUE;\n-    }\n+  /* Match: (mem (reg)).  */\n+  if (GET_CODE (ind) == REG)\n+    return arm_address_register_rtx_p (ind, 0);\n+\n+  /* Autoincremment addressing modes.  */\n+  if (wb\n+      && (GET_CODE (ind) == PRE_INC\n+\t  || GET_CODE (ind) == POST_INC\n+\t  || GET_CODE (ind) == PRE_DEC\n+\t  || GET_CODE (ind) == POST_DEC))\n+    return arm_address_register_rtx_p (XEXP (ind, 0), 0);\n+\n+  if (wb\n+      && (GET_CODE (ind) == POST_MODIFY || GET_CODE (ind) == PRE_MODIFY)\n+      && arm_address_register_rtx_p (XEXP (ind, 0), 0)\n+      && GET_CODE (XEXP (ind, 1)) == PLUS\n+      && rtx_equal_p (XEXP (XEXP (ind, 1), 0), XEXP (ind, 0)))\n+    ind = XEXP (ind, 1);\n+\n+  /* Match:\n+     (plus (reg)\n+\t   (const)).  */\n+  if (GET_CODE (ind) == PLUS\n+      && GET_CODE (XEXP (ind, 0)) == REG\n+      && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n+      && GET_CODE (XEXP (ind, 1)) == CONST_INT\n+      && INTVAL (XEXP (ind, 1)) > -1024\n+      && INTVAL (XEXP (ind, 1)) <  1024\n+      && (INTVAL (XEXP (ind, 1)) & 3) == 0)\n+    return TRUE;\n \n   return FALSE;\n }\n@@ -4684,7 +4697,7 @@ vfp_compare_operand (rtx op, enum machine_mode mode)\n enum reg_class\n vfp_secondary_reload_class (enum machine_mode mode, rtx x)\n {\n-  if (vfp_mem_operand (x) || s_register_operand (x, mode))\n+  if (arm_coproc_mem_operand (x, FALSE) || s_register_operand (x, mode))\n     return NO_REGS;\n \n   return GENERAL_REGS;\n@@ -8384,7 +8397,9 @@ output_move_double (rtx *operands)\n \t      break;\n \n   \t    case PRE_INC:\n-\t      abort (); /* Should never happen now.  */\n+\t      if (!TARGET_LDRD)\n+\t\tabort (); /* Should never happen now.  */\n+\t      output_asm_insn (\"ldr%?d\\t%0, [%m1, #8]!\", operands);\n \t      break;\n \n \t    case PRE_DEC:\n@@ -8396,7 +8411,33 @@ output_move_double (rtx *operands)\n \t      break;\n \n \t    case POST_DEC:\n-\t      abort (); /* Should never happen now.  */\n+\t      if (!TARGET_LDRD)\n+\t\tabort (); /* Should never happen now.  */\n+\t      output_asm_insn (\"ldr%?d\\t%0, [%m1], #-8\", operands);\n+\t      break;\n+\n+\t    case PRE_MODIFY:\n+\t    case POST_MODIFY:\n+\t      otherops[0] = operands[0];\n+\t      otherops[1] = XEXP (XEXP (XEXP (operands[1], 0), 1), 0);\n+\t      otherops[2] = XEXP (XEXP (XEXP (operands[1], 0), 1), 1);\n+\n+\t      if (GET_CODE (XEXP (operands[1], 0)) == PRE_MODIFY)\n+\t\t{\n+\t\t  if (reg_overlap_mentioned_p (otherops[0], otherops[2]))\n+\t\t    {\n+\t\t      /* Registers overlap so split out the increment.  */\n+\t\t      output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n+\t\t      output_asm_insn (\"ldr%?d\\t%0, [%1] @split\", otherops);\n+\t\t    }\n+\t\t  else\n+\t\t    output_asm_insn (\"ldr%?d\\t%0, [%1, %2]!\", otherops);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* We only allow constant increments, so this is safe.  */\n+\t\t  output_asm_insn (\"ldr%?d\\t%0, [%1], %2\", otherops);\n+\t\t}\n \t      break;\n \n \t    case LABEL_REF:\n@@ -8429,7 +8470,41 @@ output_move_double (rtx *operands)\n \t\t\t      output_asm_insn (\"ldm%?ib\\t%1, %M0\", otherops);\n \t\t\t      return \"\";\n \t\t\t    }\n-\n+\t\t\t}\n+\t\t      if (TARGET_LDRD\n+\t\t\t  && (GET_CODE (otherops[2]) == REG\n+\t\t\t      || (GET_CODE (otherops[2]) == CONST_INT\n+\t\t\t\t  && INTVAL (otherops[2]) > -256\n+\t\t\t\t  && INTVAL (otherops[2]) < 256)))\n+\t\t\t{\n+\t\t\t  if (reg_overlap_mentioned_p (otherops[0],\n+\t\t\t\t\t\t       otherops[2]))\n+\t\t\t    {\n+\t\t\t      /* Swap base and index registers over to\n+\t\t\t\t avoid a conflict.  */\n+\t\t\t      otherops[1] = XEXP (XEXP (operands[1], 0), 1);\n+\t\t\t      otherops[2] = XEXP (XEXP (operands[1], 0), 0);\n+\t\t\t      \n+\t\t\t    }\n+\t\t\t  /* If both registers conflict, it will usually\n+\t\t\t     have been fixed by a splitter.  */\n+\t\t\t  if (reg_overlap_mentioned_p (otherops[0],\n+\t\t\t\t\t\t\totherops[2]))\n+\t\t\t    {\n+\t\t\t      output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n+\t\t\t      output_asm_insn (\"ldr%?d\\t%0, [%1]\",\n+\t\t\t\t\t       otherops);\n+\t\t\t      return \"\";\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      output_asm_insn (\"ldr%?d\\t%0, [%1, %2]\",\n+\t\t\t\t\t       otherops);\n+\t\t\t      return \"\";\n+\t\t\t    }\n+\t\t\t}\n+\t\t      if (GET_CODE (otherops[2]) == CONST_INT)\n+\t\t\t{\n \t\t\t  if (!(const_ok_for_arm (INTVAL (otherops[2]))))\n \t\t\t    output_asm_insn (\"sub%?\\t%0, %1, #%n2\", otherops);\n \t\t\t  else\n@@ -8475,7 +8550,9 @@ output_move_double (rtx *operands)\n \t  break;\n \n         case PRE_INC:\n-\t  abort (); /* Should never happen now.  */\n+\t  if (!TARGET_LDRD)\n+\t    abort (); /* Should never happen now.  */\n+\t  output_asm_insn (\"str%?d\\t%1, [%m0, #8]!\", operands);\n \t  break;\n \n         case PRE_DEC:\n@@ -8487,11 +8564,26 @@ output_move_double (rtx *operands)\n \t  break;\n \n         case POST_DEC:\n-\t  abort (); /* Should never happen now.  */\n+\t  if (!TARGET_LDRD)\n+\t    abort (); /* Should never happen now.  */\n+\t  output_asm_insn (\"str%?d\\t%1, [%m0], #-8\", operands);\n+\t  break;\n+\n+\tcase PRE_MODIFY:\n+\tcase POST_MODIFY:\n+\t  otherops[0] = operands[1];\n+\t  otherops[1] = XEXP (XEXP (XEXP (operands[0], 0), 1), 0);\n+\t  otherops[2] = XEXP (XEXP (XEXP (operands[0], 0), 1), 1);\n+\n+\t  if (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)\n+\t    output_asm_insn (\"str%?d\\t%0, [%1, %2]!\", otherops);\n+\t  else\n+\t    output_asm_insn (\"str%?d\\t%0, [%1], %2\", otherops);\n \t  break;\n \n \tcase PLUS:\n-\t  if (GET_CODE (XEXP (XEXP (operands[0], 0), 1)) == CONST_INT)\n+\t  otherops[2] = XEXP (XEXP (operands[0], 0), 1);\n+\t  if (GET_CODE (otherops[2]) == CONST_INT)\n \t    {\n \t      switch ((int) INTVAL (XEXP (XEXP (operands[0], 0), 1)))\n \t\t{\n@@ -8508,6 +8600,17 @@ output_move_double (rtx *operands)\n \t\t  return \"\";\n \t\t}\n \t    }\n+\t  if (TARGET_LDRD\n+\t      && (GET_CODE (otherops[2]) == REG\n+\t\t  || (GET_CODE (otherops[2]) == CONST_INT\n+\t\t      && INTVAL (otherops[2]) > -256\n+\t\t      && INTVAL (otherops[2]) < 256)))\n+\t    {\n+\t      otherops[0] = operands[1];\n+\t      otherops[1] = XEXP (XEXP (operands[0], 0), 0);\n+\t      output_asm_insn (\"str%?d\\t%0, [%1, %2]\", otherops);\n+\t      return \"\";\n+\t    }\n \t  /* Fall through */\n \n         default:\n@@ -11393,9 +11496,11 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n   if (IS_IWMMXT_REGNUM (regno))\n     return VALID_IWMMXT_REG_MODE (mode);\n \n+  /* We allow any value to be stored in the general registers.\n+     Restrict doubleword quantities to even register pairs so that we can\n+     use ldrd.  */\n   if (regno <= LAST_ARM_REGNUM)\n-    /* We allow any value to be stored in the general registers.  */\n-    return 1;\n+    return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0);\n \n   if (   regno == FRAME_POINTER_REGNUM\n       || regno == ARG_POINTER_REGNUM)"}, {"sha": "c870af0052f513f390b6ffc7dfa6cfa942aafda7", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -306,6 +306,7 @@ extern GTY(()) rtx aof_pic_label;\n \t\t\t\t         ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE)\t\\\n \t\t\t\t         : (target_flags & THUMB_FLAG_BACKTRACE))\n #define TARGET_CIRRUS_FIX_INVALID_INSNS\t(target_flags & CIRRUS_FIX_INVALID_INSNS)\n+#define TARGET_LDRD\t\t\t(arm_arch5e && ARM_DOUBLEWORD_ALIGN)\n \n /* SUBTARGET_SWITCHES is used to add flags on a per-config basis.  */\n #ifndef SUBTARGET_SWITCHES\n@@ -1292,6 +1293,7 @@ enum reg_class\n    accessed without using a load.\n    'U' Prefixes an extended memory constraint where:\n    'Uv' is an address valid for VFP load/store insns.  \n+   'Uy' is an address valid for iwmmxt load/store insns.  \n    'Uq' is an address valid for ldrsb.  */\n \n #define EXTRA_CONSTRAINT_STR_ARM(OP, C, STR)\t\t\t\\\n@@ -1302,7 +1304,8 @@ enum reg_class\n \t\t   && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0))) :\t\\\n    ((C) == 'S') ? (optimize > 0 && CONSTANT_ADDRESS_P (OP)) :\t\\\n    ((C) == 'T') ? cirrus_memory_offset (OP) :\t\t\t\\\n-   ((C) == 'U' && (STR)[1] == 'v') ? vfp_mem_operand (OP) :\t\\\n+   ((C) == 'U' && (STR)[1] == 'v') ? arm_coproc_mem_operand (OP, FALSE) : \\\n+   ((C) == 'U' && (STR)[1] == 'y') ? arm_coproc_mem_operand (OP, TRUE) : \\\n    ((C) == 'U' && (STR)[1] == 'q')\t\t\t\t\\\n     ? arm_extendqisi_mem_op (OP, GET_MODE (OP))\t\t\t\\\n       : 0)"}, {"sha": "554b332283b08df1545d35019f4c8f1af9596b57", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -4073,7 +4073,7 @@\n )\n \n (define_insn \"*arm_movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, o<>\")\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r ,m\")\n \t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r\"))]\n   \"TARGET_ARM\n   && !(TARGET_HARD_FLOAT && (TARGET_MAVERICK || TARGET_VFP))\n@@ -4087,6 +4087,26 @@\n    (set_attr \"neg_pool_range\" \"*,1008,*\")]\n )\n \n+;; We can't actually do base+index doubleword loads if the index and\n+;; destination overlap.  Split here so that we at least have chance to\n+;; schedule.\n+(define_split\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n+\t(mem:DI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"s_register_operand\" \"\"))))]\n+  \"TARGET_LDRD\n+  && reg_overlap_mentioned_p (operands[0], operands[1])\n+  && reg_overlap_mentioned_p (operands[0], operands[2])\"\n+  [(set (match_dup 4)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0)\n+\t(mem:DI (match_dup 4)))]\n+  \"\n+  operands[4] = gen_rtx_REG (SImode, REGNO(operands[0]));\n+  \"\n+)\n+\n ;;; ??? This should have alternatives for constants.\n ;;; ??? This was originally identical to the movdf_insn pattern.\n ;;; ??? The 'i' constraint looks funny, but it should always be replaced by"}, {"sha": "758847fd54706994972608be1584104cfaa98273", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -64,8 +64,8 @@\n   [(set_attr \"predicable\" \"yes\")])\n \n (define_insn \"*iwmmxt_arm_movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, o<>,y,y,yr,y,yrm\")\n-\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r  ,y,yr,y,yrm,y\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, m,y,y,yr,y,yrUy\")\n+\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r,y,yr,y,yrUy,y\"))]\n   \"TARGET_REALLY_IWMMXT\"\n   \"*\n {"}, {"sha": "7008ab40c76b163d79845e7fbbceb736229d7a5d", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -136,8 +136,8 @@\n ;; DImode moves\n \n (define_insn \"*arm_movdi_vfp\"\n-  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r,o<>,w,r,w,w  ,Uv\")\n-\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r ,r,w,w,Uvi,w\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r,m,w,r,w,w, Uv\")\n+\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r,r,w,w,Uvi,w\"))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"*\n   switch (which_alternative)"}, {"sha": "b29f8b55fbc68c716706348afcb84f0d2da858b4", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdd695fdb4650c6221ed38e952fa0fe00a214afa/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=fdd695fdb4650c6221ed38e952fa0fe00a214afa", "patch": "@@ -1363,6 +1363,9 @@ A symbol in the text segment of the current file\n @item Uv\n A memory reference suitable for VFP load/store insns (reg+constant offset)\n \n+@item Uy\n+A memory reference suitable for iWMMXt load/store instructions.\n+\n @item Uq\n A memory reference suitable for for the ARMv4 ldrsb instruction.\n "}]}