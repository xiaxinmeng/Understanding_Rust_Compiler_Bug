{"sha": "954954d139a52ed7a9a305d5ac09bb3323b67a95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU0OTU0ZDEzOWE1MmVkN2E5YTMwNWQ1YWMwOWJiMzMyM2I2N2E5NQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2008-03-12T18:58:47Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2008-03-12T18:58:47Z"}, "message": "arm.c (use_return_insn): Use offsets->saved_regs_mask instead of {arm,thumb}_compute_save_reg_mask.\n\n2008-03-12  Paul Brook  <paul@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm.c (use_return_insn): Use offsets->saved_regs_mask\n\tinstead of {arm,thumb}_compute_save_reg_mask.\n\t(output_return_instruction): Ditto.\n\t(thumb_unexpanded_epilogue): Ditto.\n\t(thumb1_expand_prologue): Ditto.\n\t(thumb1_output_function_prologue): Ditto.\n\t(arm_set_return_address): Ditto.\n\t(thumb_set_return_address): Ditto.\n\t(arm_get_frame_offsets): Set offsets->saved_regs_mask.  Push extra\n\tregs to achieve stack alignment.\n\t(thumb1_compute_save_reg_mask): Fix compiler warning.\n\t(arm_output_epilogue): Use offsets->saved_regs_mask.\n\tAdjust stack pointer by poping call clobered registers.\n\t(arm_expand_prologue): Use offsets->saved_regs_mask.\n\tAdjust stack pointer by pushing extra registers.\n\t* gcc/config/arm.h (arm_stack_offsets): Add saved_regs_mask.\n\nFrom-SVN: r133148", "tree": {"sha": "20a1d9ac4838d1af36e10aa10f3bf9071e8fd931", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20a1d9ac4838d1af36e10aa10f3bf9071e8fd931"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/954954d139a52ed7a9a305d5ac09bb3323b67a95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954954d139a52ed7a9a305d5ac09bb3323b67a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954954d139a52ed7a9a305d5ac09bb3323b67a95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954954d139a52ed7a9a305d5ac09bb3323b67a95/comments", "author": null, "committer": null, "parents": [{"sha": "4b700ab045e25bb751584223b06e838d3e5dc826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b700ab045e25bb751584223b06e838d3e5dc826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b700ab045e25bb751584223b06e838d3e5dc826"}], "stats": {"total": 155, "additions": 132, "deletions": 23}, "files": [{"sha": "4bdbd1b7dca9e70a99e2f7710cce535388d46172", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954954d139a52ed7a9a305d5ac09bb3323b67a95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954954d139a52ed7a9a305d5ac09bb3323b67a95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=954954d139a52ed7a9a305d5ac09bb3323b67a95", "patch": "@@ -1,3 +1,22 @@\n+2008-03-12  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (use_return_insn): Use offsets->saved_regs_mask\n+\tinstead of {arm,thumb}_compute_save_reg_mask.\n+\t(output_return_instruction): Ditto.\n+\t(thumb_unexpanded_epilogue): Ditto.\n+\t(thumb1_expand_prologue): Ditto.\n+\t(thumb1_output_function_prologue): Ditto.\n+\t(arm_set_return_address): Ditto.\n+\t(thumb_set_return_address): Ditto.\n+\t(arm_get_frame_offsets): Set offsets->saved_regs_mask.  Push extra\n+\tregs to achieve stack alignment.\n+\t(thumb1_compute_save_reg_mask): Fix compiler warning.\n+\t(arm_output_epilogue): Use offsets->saved_regs_mask.\n+\tAdjust stack pointer by poping call clobered registers.\n+\t(arm_expand_prologue): Use offsets->saved_regs_mask.\n+\tAdjust stack pointer by pushing extra registers.\n+\t* gcc/config/arm.h (arm_stack_offsets): Add saved_regs_mask.\n+\n 2008-03-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR tree-opt/35422"}, {"sha": "304b4302cc61b53c1d04297f1aba0ce64623229c", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 112, "deletions": 23, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954954d139a52ed7a9a305d5ac09bb3323b67a95/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954954d139a52ed7a9a305d5ac09bb3323b67a95/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=954954d139a52ed7a9a305d5ac09bb3323b67a95", "patch": "@@ -74,7 +74,6 @@ static int thumb1_base_register_rtx_p (rtx, enum machine_mode, int);\n inline static int thumb1_index_register_rtx_p (rtx, int);\n static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n-static unsigned long thumb1_compute_save_reg_mask (void);\n static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n static rtx emit_sfm (int, int);\n static unsigned arm_size_return_regs (void);\n@@ -1666,7 +1665,7 @@ use_return_insn (int iscond, rtx sibling)\n \t\t\t\t && stack_adjust == 4)))\n     return 0;\n \n-  saved_int_regs = arm_compute_save_reg_mask ();\n+  saved_int_regs = offsets->saved_regs_mask;\n \n   /* Unfortunately, the insn\n \n@@ -10750,7 +10749,8 @@ arm_compute_save_reg0_reg12_mask (void)\n \n \n /* Compute a bit mask of which registers need to be\n-   saved on the stack for the current function.  */\n+   saved on the stack for the current function.\n+   This is used by arm_get_frame_offsets, which may add extra registers.  */\n \n static unsigned long\n arm_compute_save_reg_mask (void)\n@@ -10878,7 +10878,7 @@ thumb1_compute_save_reg_mask (void)\n       reg = thumb_find_work_register (1 << LAST_LO_REGNUM);\n       /* Make sure the register returned by thumb_find_work_register is\n \t not part of the return value.  */\n-      if (reg * UNITS_PER_WORD <= arm_size_return_regs ())\n+      if (reg * UNITS_PER_WORD <= (unsigned) arm_size_return_regs ())\n \treg = LAST_LO_REGNUM;\n \n       if (! call_used_regs[reg])\n@@ -10975,7 +10975,8 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \n   return_used_this_function = 1;\n \n-  live_regs_mask = arm_compute_save_reg_mask ();\n+  offsets = arm_get_frame_offsets ();\n+  live_regs_mask = offsets->saved_regs_mask;\n \n   if (live_regs_mask)\n     {\n@@ -11037,7 +11038,6 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t    {\n \t      unsigned HOST_WIDE_INT stack_adjust;\n \n-\t      offsets = arm_get_frame_offsets ();\n \t      stack_adjust = offsets->outgoing_args - offsets->saved_regs;\n \t      gcc_assert (stack_adjust == 0 || stack_adjust == 4);\n \n@@ -11285,7 +11285,7 @@ arm_output_epilogue (rtx sibling)\n   gcc_assert (!current_function_calls_eh_return || really_return);\n \n   offsets = arm_get_frame_offsets ();\n-  saved_regs_mask = arm_compute_save_reg_mask ();\n+  saved_regs_mask = offsets->saved_regs_mask;\n \n   if (TARGET_IWMMXT)\n     lrm_count = bit_count (saved_regs_mask);\n@@ -11482,8 +11482,35 @@ arm_output_epilogue (rtx sibling)\n \t    }\n \t  else\n \t    {\n+\t      unsigned long count;\n \t      operands[0] = stack_pointer_rtx;\n \t      amount = offsets->outgoing_args - offsets->saved_regs;\n+\t      /* pop call clobbered registers if it avoids a\n+\t         separate stack adjustment.  */\n+\t      count = offsets->saved_regs - offsets->saved_args;\n+\t      if (optimize_size\n+\t\t  && count != 0\n+\t\t  && !current_function_calls_eh_return\n+\t\t  && bit_count(saved_regs_mask) * 4 == count\n+\t\t  && !IS_INTERRUPT (func_type)\n+\t\t  && !cfun->tail_call_emit)\n+\t\t{\n+\t\t  unsigned long mask;\n+\t\t  mask = (1 << (arm_size_return_regs() / 4)) - 1;\n+\t\t  mask ^= 0xf;\n+\t\t  mask &= ~saved_regs_mask;\n+\t\t  reg = 0;\n+\t\t  while (bit_count (mask) * 4 > amount)\n+\t\t    {\n+\t\t      while ((mask & (1 << reg)) == 0)\n+\t\t\treg++;\n+\t\t      mask &= ~(1 << reg);\n+\t\t    }\n+\t\t  if (bit_count (mask) * 4 == amount) {\n+\t\t      amount = 0;\n+\t\t      saved_regs_mask |= mask;\n+\t\t  }\n+\t\t}\n \t    }\n \t  \n \t  if (amount)\n@@ -11954,7 +11981,8 @@ thumb_force_lr_save (void)\n \n \n /* Calculate stack offsets.  These are used to calculate register elimination\n-   offsets and in prologue/epilogue code.  */\n+   offsets and in prologue/epilogue code.  Also calculates which registers\n+   should be saved.  */\n \n static arm_stack_offsets *\n arm_get_frame_offsets (void)\n@@ -11963,7 +11991,9 @@ arm_get_frame_offsets (void)\n   unsigned long func_type;\n   int leaf;\n   int saved;\n+  int core_saved;\n   HOST_WIDE_INT frame_size;\n+  int i;\n \n   offsets = &cfun->machine->stack_offsets;\n \n@@ -11996,7 +12026,9 @@ arm_get_frame_offsets (void)\n     {\n       unsigned int regno;\n \n-      saved = bit_count (arm_compute_save_reg_mask ()) * 4;\n+      offsets->saved_regs_mask = arm_compute_save_reg_mask ();\n+      core_saved = bit_count (offsets->saved_regs_mask) * 4;\n+      saved = core_saved;\n \n       /* We know that SP will be doubleword aligned on entry, and we must\n \t preserve that condition at any subroutine call.  We also require the\n@@ -12027,7 +12059,9 @@ arm_get_frame_offsets (void)\n     }\n   else /* TARGET_THUMB1 */\n     {\n-      saved = bit_count (thumb1_compute_save_reg_mask ()) * 4;\n+      offsets->saved_regs_mask = thumb1_compute_save_reg_mask ();\n+      core_saved = bit_count (offsets->saved_regs_mask) * 4;\n+      saved = core_saved;\n       if (TARGET_BACKTRACE)\n \tsaved += 16;\n     }\n@@ -12047,7 +12081,39 @@ arm_get_frame_offsets (void)\n   /* Ensure SFP has the correct alignment.  */\n   if (ARM_DOUBLEWORD_ALIGN\n       && (offsets->soft_frame & 7))\n-    offsets->soft_frame += 4;\n+    {\n+      offsets->soft_frame += 4;\n+      /* Try to align stack by pushing an extra reg.  Don't bother doing this\n+         when there is a stack frame as the alignment will be rolled into\n+\t the normal stack adjustment.  */\n+      if (frame_size + current_function_outgoing_args_size == 0)\n+\t{\n+\t  int reg = -1;\n+\n+\t  for (i = 4; i <= (TARGET_THUMB1 ? LAST_LO_REGNUM : 11); i++)\n+\t    {\n+\t      if ((offsets->saved_regs_mask & (1 << i)) == 0)\n+\t\t{\n+\t\t  reg = i;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (reg == -1 && arm_size_return_regs () <= 12\n+\t      && !cfun->tail_call_emit)\n+\t    {\n+\t      /* Push/pop an argument register (r3) if all callee saved\n+\t         registers are already being pushed.  */\n+\t      reg = 3;\n+\t    }\n+\n+\t  if (reg != -1)\n+\t    {\n+\t      offsets->saved_regs += 4;\n+\t      offsets->saved_regs_mask |= (1 << reg);\n+\t    }\n+\t}\n+    }\n \n   offsets->locals_base = offsets->soft_frame + frame_size;\n   offsets->outgoing_args = (offsets->locals_base\n@@ -12303,7 +12369,8 @@ arm_expand_prologue (void)\n   args_to_push = current_function_pretend_args_size;\n \n   /* Compute which register we will have to save onto the stack.  */\n-  live_regs_mask = arm_compute_save_reg_mask ();\n+  offsets = arm_get_frame_offsets ();\n+  live_regs_mask = offsets->saved_regs_mask;\n \n   ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);\n \n@@ -12456,8 +12523,28 @@ arm_expand_prologue (void)\n \n   if (live_regs_mask)\n     {\n-      insn = emit_multi_reg_push (live_regs_mask);\n       saved_regs += bit_count (live_regs_mask) * 4;\n+      if (optimize_size && !frame_pointer_needed\n+\t  && saved_regs == offsets->saved_regs - offsets->saved_args)\n+\t{\n+\t  /* If no coprocessor registers are being pushed and we don't have\n+\t     to worry about a frame pointer then push extra registers to\n+\t     create the stack frame.  This is done is a way that does not\n+\t     alter the frame layout, so is independent of the epilogue.  */\n+\t  int n;\n+\t  int frame;\n+\t  n = 0;\n+\t  while (n < 8 && (live_regs_mask & (1 << n)) == 0)\n+\t    n++;\n+\t  frame = offsets->outgoing_args - (offsets->saved_args + saved_regs);\n+\t  if (frame && n * 4 >= frame)\n+\t    {\n+\t      n = frame / 4;\n+\t      live_regs_mask |= (1 << n) - 1;\n+\t      saved_regs += frame;\n+\t    }\n+\t}\n+      insn = emit_multi_reg_push (live_regs_mask);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -12498,7 +12585,6 @@ arm_expand_prologue (void)\n \t}\n     }\n \n-  offsets = arm_get_frame_offsets ();\n   if (offsets->outgoing_args != offsets->saved_args + saved_regs)\n     {\n       /* This add can produce multiple insns for a large constant, so we\n@@ -16494,6 +16580,7 @@ is_called_in_ARM_mode (tree func)\n const char *\n thumb_unexpanded_epilogue (void)\n {\n+  arm_stack_offsets *offsets;\n   int regno;\n   unsigned long live_regs_mask = 0;\n   int high_regs_pushed = 0;\n@@ -16506,7 +16593,8 @@ thumb_unexpanded_epilogue (void)\n   if (IS_NAKED (arm_current_func_type ()))\n     return \"\";\n \n-  live_regs_mask = thumb1_compute_save_reg_mask ();\n+  offsets = arm_get_frame_offsets ();\n+  live_regs_mask = offsets->saved_regs_mask;\n   high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n \n   /* If we can deduce the registers used from the function's return value.\n@@ -16768,7 +16856,8 @@ thumb1_expand_prologue (void)\n       return;\n     }\n \n-  live_regs_mask = thumb1_compute_save_reg_mask ();\n+  offsets = arm_get_frame_offsets ();\n+  live_regs_mask = offsets->saved_regs_mask;\n   /* Load the pic register before setting the frame pointer,\n      so we can use r7 as a temporary work register.  */\n   if (flag_pic && arm_pic_register != INVALID_REGNUM)\n@@ -16778,7 +16867,6 @@ thumb1_expand_prologue (void)\n     emit_move_insn (gen_rtx_REG (Pmode, ARM_HARD_FRAME_POINTER_REGNUM),\n \t\t    stack_pointer_rtx);\n \n-  offsets = arm_get_frame_offsets ();\n   amount = offsets->outgoing_args - offsets->saved_regs;\n   if (amount)\n     {\n@@ -16940,6 +17028,7 @@ thumb1_expand_epilogue (void)\n static void\n thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n+  arm_stack_offsets *offsets;\n   unsigned long live_regs_mask = 0;\n   unsigned long l_mask;\n   unsigned high_regs_pushed = 0;\n@@ -17024,7 +17113,8 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n     }\n \n   /* Get the registers we are going to push.  */\n-  live_regs_mask = thumb1_compute_save_reg_mask ();\n+  offsets = arm_get_frame_offsets ();\n+  live_regs_mask = offsets->saved_regs_mask;\n   /* Extract a mask of the ones we can give to the Thumb's push instruction.  */\n   l_mask = live_regs_mask & 0x40ff;\n   /* Then count how many other high registers will need to be pushed.  */\n@@ -18152,7 +18242,8 @@ arm_set_return_address (rtx source, rtx scratch)\n   rtx addr;\n   unsigned long saved_regs;\n \n-  saved_regs = arm_compute_save_reg_mask ();\n+  offsets = arm_get_frame_offsets ();\n+  saved_regs = offsets->saved_regs_mask;\n \n   if ((saved_regs & (1 << LR_REGNUM)) == 0)\n     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), source);\n@@ -18163,7 +18254,6 @@ arm_set_return_address (rtx source, rtx scratch)\n       else\n \t{\n \t  /* LR will be the first saved register.  */\n-\t  offsets = arm_get_frame_offsets ();\n \t  delta = offsets->outgoing_args - (offsets->frame + 4);\n \n \n@@ -18196,11 +18286,10 @@ thumb_set_return_address (rtx source, rtx scratch)\n \n   emit_insn (gen_rtx_USE (VOIDmode, source));\n \n-  mask = thumb1_compute_save_reg_mask ();\n+  offsets = arm_get_frame_offsets ();\n+  mask = offsets->saved_regs_mask;\n   if (mask & (1 << LR_REGNUM))\n     {\n-      offsets = arm_get_frame_offsets ();\n-\n       limit = 1024;\n       /* Find the saved regs.  */\n       if (frame_pointer_needed)"}, {"sha": "3901768d8d6d918ba2683d609224ca90caceedd7", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/954954d139a52ed7a9a305d5ac09bb3323b67a95/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/954954d139a52ed7a9a305d5ac09bb3323b67a95/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=954954d139a52ed7a9a305d5ac09bb3323b67a95", "patch": "@@ -1538,6 +1538,7 @@ typedef struct arm_stack_offsets GTY(())\n   int soft_frame;\t/* FRAME_POINTER_REGNUM.  */\n   int locals_base;\t/* THUMB_HARD_FRAME_POINTER_REGNUM.  */\n   int outgoing_args;\t/* STACK_POINTER_REGNUM.  */\n+  unsigned int saved_regs_mask;\n }\n arm_stack_offsets;\n "}]}