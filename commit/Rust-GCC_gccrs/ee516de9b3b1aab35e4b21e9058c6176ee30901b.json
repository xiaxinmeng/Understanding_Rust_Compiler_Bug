{"sha": "ee516de9b3b1aab35e4b21e9058c6176ee30901b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU1MTZkZTliM2IxYWFiMzVlNGIyMWU5MDU4YzYxNzZlZTMwOTAxYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-05-13T08:49:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-13T08:49:20Z"}, "message": "builtins.c (expand_builtin_memcmp): Do not emit the call here.\n\n\t* builtins.c (expand_builtin_memcmp): Do not emit the call here.\n\t(expand_builtin_trap): Emit a regular call.\n\t(set_builtin_user_assembler_name): Remove obsolete cases.\n\t* dse.c (scan_insn): Adjust.\n\t* except.c: Include calls.h.\n\t(sjlj_emit_function_enter): If DONT_USE_BUILTIN_SETJMP is defined,\n\temit a regular call to setjmp.\n\t* expr.c (emit_block_move_hints): Call emit_block_copy_via_libcall.\n\t(block_move_libcall_safe_for_call_parm): Use memcpy builtin.\n\t(emit_block_move_via_libcall): Delete.\n\t(block_move_fn): Delete.\n\t(init_block_move_fn): Likewise.\n\t(emit_block_move_libcall_fn): Likewise.\n\t(emit_block_op_via_libcall): New function.\n\t(set_storage_via_libcall): Tidy up and use memset builtin.\n\t(block_clear_fn): Delete.\n\t(init_block_clear_fn): Likewise.\n\t(clear_storage_libcall_fn): Likewise.\n\t(expand_assignment): Call emit_block_move_via_libcall.\n\tDo not include gt-expr.h.\n\t* expr.h (emit_block_op_via_libcall): Declare.\n\t(emit_block_copy_via_libcall): New inline function.\n\t(emit_block_move_via_libcall): Likewise.\n\t(emit_block_comp_via_libcall): Likewise.\n\t(block_clear_fn): Delete.\n\t(init_block_move_fn): Likewise.\n\t(init_block_clear_fn): Likewise.\n\t(emit_block_move_via_libcall): Likewise.\n\t(set_storage_via_libcall): Add default parameter value.\n\t* libfuncs.h (enum libfunc_index): Remove obsolete values.\n\t(abort_libfunc): Delete.\n\t(memcpy_libfunc): Likewise.\n\t(memmove_libfunc): Likewise.\n\t(memcmp_libfunc): Likewise.\n\t(memset_libfunc): Likewise.\n\t(setbits_libfunc): Likewise.\n\t(setjmp_libfunc): Likewise.\n\t(longjmp_libfunc): Likewise.\n\t(profile_function_entry_libfunc): Likewise.\n\t(profile_function_exit_libfunc): Likewise.\n\t(gcov_flush_libfunc): Likewise.\n\t* optabs-libfuncs.c (build_libfunc_function): Set DECL_ARTIFICIAL\n\tand DECL_VISIBILITY on the declaration.\n\t(init_optabs): Do not initialize obsolete libfuncs.\n\t* optabs.c (prepare_cmp_insn): Call emit_block_comp_via_libcall.\n\t* tree-core.h (ECF_RET1): Define.\n\t(ECF_TM_PURE): Adjust.\n\t(ECF_TM_BUILTIN): Likewise.\n\t* tree.c (set_call_expr_flags): Deal with ECF_RET1.\n\t(build_common_builtin_nodes): Initialize abort builtin.\n\tAdd ECF_RET1 on memcpy, memmove and memset builtins.\n\tPass final flags for alloca and alloca_with_align builtins.\n\t* config/alpha/alpha.c (alpha_init_libfuncs): Do not initialize\n\tobsolete builtins.\n\t* config/ia64/ia64.c (ia64_vms_init_libfuncs): Likewise.\n\t* config/i386/i386.c (ix86_expand_set_or_movmem): Adjust call to\n\tset_storage_via_libcall and call emit_block_copy_via_libcall.\n\nFrom-SVN: r236195", "tree": {"sha": "4b89253c5567cb98e1c4a7e0dbbf1e5628ac0cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b89253c5567cb98e1c4a7e0dbbf1e5628ac0cc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee516de9b3b1aab35e4b21e9058c6176ee30901b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee516de9b3b1aab35e4b21e9058c6176ee30901b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee516de9b3b1aab35e4b21e9058c6176ee30901b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee516de9b3b1aab35e4b21e9058c6176ee30901b/comments", "author": null, "committer": null, "parents": [{"sha": "fff9b5ddb7f5a165518c7c634c16d127749225ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff9b5ddb7f5a165518c7c634c16d127749225ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff9b5ddb7f5a165518c7c634c16d127749225ed"}], "stats": {"total": 564, "additions": 207, "deletions": 357}, "files": [{"sha": "d21e5da771577b7ecf7a16ee8cd1ae584d1500b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -1,3 +1,63 @@\n+2016-05-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* builtins.c (expand_builtin_memcmp): Do not emit the call here.\n+\t(expand_builtin_trap): Emit a regular call.\n+\t(set_builtin_user_assembler_name): Remove obsolete cases.\n+\t* dse.c (scan_insn): Adjust.\n+\t* except.c: Include calls.h.\n+\t(sjlj_emit_function_enter): If DONT_USE_BUILTIN_SETJMP is defined,\n+\temit a regular call to setjmp.\n+\t* expr.c (emit_block_move_hints): Call emit_block_copy_via_libcall.\n+\t(block_move_libcall_safe_for_call_parm): Use memcpy builtin.\n+\t(emit_block_move_via_libcall): Delete.\n+\t(block_move_fn): Delete.\n+\t(init_block_move_fn): Likewise.\n+\t(emit_block_move_libcall_fn): Likewise.\n+\t(emit_block_op_via_libcall): New function.\n+\t(set_storage_via_libcall): Tidy up and use memset builtin.\n+\t(block_clear_fn): Delete.\n+\t(init_block_clear_fn): Likewise.\n+\t(clear_storage_libcall_fn): Likewise.\n+\t(expand_assignment): Call emit_block_move_via_libcall.\n+\tDo not include gt-expr.h.\n+\t* expr.h (emit_block_op_via_libcall): Declare.\n+\t(emit_block_copy_via_libcall): New inline function.\n+\t(emit_block_move_via_libcall): Likewise.\n+\t(emit_block_comp_via_libcall): Likewise.\n+\t(block_clear_fn): Delete.\n+\t(init_block_move_fn): Likewise.\n+\t(init_block_clear_fn): Likewise.\n+\t(emit_block_move_via_libcall): Likewise.\n+\t(set_storage_via_libcall): Add default parameter value.\n+\t* libfuncs.h (enum libfunc_index): Remove obsolete values.\n+\t(abort_libfunc): Delete.\n+\t(memcpy_libfunc): Likewise.\n+\t(memmove_libfunc): Likewise.\n+\t(memcmp_libfunc): Likewise.\n+\t(memset_libfunc): Likewise.\n+\t(setbits_libfunc): Likewise.\n+\t(setjmp_libfunc): Likewise.\n+\t(longjmp_libfunc): Likewise.\n+\t(profile_function_entry_libfunc): Likewise.\n+\t(profile_function_exit_libfunc): Likewise.\n+\t(gcov_flush_libfunc): Likewise.\n+\t* optabs-libfuncs.c (build_libfunc_function): Set DECL_ARTIFICIAL\n+\tand DECL_VISIBILITY on the declaration.\n+\t(init_optabs): Do not initialize obsolete libfuncs.\n+\t* optabs.c (prepare_cmp_insn): Call emit_block_comp_via_libcall.\n+\t* tree-core.h (ECF_RET1): Define.\n+\t(ECF_TM_PURE): Adjust.\n+\t(ECF_TM_BUILTIN): Likewise.\n+\t* tree.c (set_call_expr_flags): Deal with ECF_RET1.\n+\t(build_common_builtin_nodes): Initialize abort builtin.\n+\tAdd ECF_RET1 on memcpy, memmove and memset builtins.\n+\tPass final flags for alloca and alloca_with_align builtins.\n+\t* config/alpha/alpha.c (alpha_init_libfuncs): Do not initialize\n+\tobsolete builtins.\n+\t* config/ia64/ia64.c (ia64_vms_init_libfuncs): Likewise.\n+\t* config/i386/i386.c (ix86_expand_set_or_movmem): Adjust call to\n+\tset_storage_via_libcall and call emit_block_copy_via_libcall.\n+\n 2016-05-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*call_got_x32): Change operand 0 to"}, {"sha": "931d4a6b7bc24b57c7f5d9b10bc8bff5027e18a6", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -3757,20 +3757,7 @@ expand_builtin_memcmp (tree exp, rtx target)\n       return convert_to_mode (mode, result, 0);\n     }\n \n-  result = target;\n-  if (! (result != 0\n-\t && REG_P (result) && GET_MODE (result) == mode\n-\t && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n-    result = gen_reg_rtx (mode);\n-\n-  emit_library_call_value (memcmp_libfunc, result, LCT_PURE,\n-\t\t\t   TYPE_MODE (integer_type_node), 3,\n-\t\t\t   XEXP (arg1_rtx, 0), Pmode,\n-\t\t\t   XEXP (arg2_rtx, 0), Pmode,\n-\t\t\t   convert_to_mode (TYPE_MODE (sizetype), arg3_rtx,\n-\t\t\t\t\t    TYPE_UNSIGNED (sizetype)),\n-\t\t\t   TYPE_MODE (sizetype));\n-  return result;\n+  return NULL_RTX;\n }\n \n /* Expand expression EXP, which is a call to the strcmp builtin.  Return NULL_RTX\n@@ -4455,7 +4442,12 @@ expand_builtin_trap (void)\n \tadd_reg_note (insn, REG_ARGS_SIZE, GEN_INT (stack_pointer_delta));\n     }\n   else\n-    emit_library_call (abort_libfunc, LCT_NORETURN, VOIDmode, 0);\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_ABORT);\n+      tree call_expr = build_call_expr (fn, 0);\n+      expand_call (call_expr, NULL_RTX, false);\n+    }\n+\n   emit_barrier ();\n }\n \n@@ -9888,42 +9880,19 @@ fold_call_stmt (gcall *stmt, bool ignore)\n void\n set_builtin_user_assembler_name (tree decl, const char *asmspec)\n {\n-  tree builtin;\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n \t      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n \t      && asmspec != 0);\n \n-  builtin = builtin_decl_explicit (DECL_FUNCTION_CODE (decl));\n+  tree builtin = builtin_decl_explicit (DECL_FUNCTION_CODE (decl));\n   set_user_assembler_name (builtin, asmspec);\n-  switch (DECL_FUNCTION_CODE (decl))\n+\n+  if (DECL_FUNCTION_CODE (decl) == BUILT_IN_FFS\n+      && INT_TYPE_SIZE < BITS_PER_WORD)\n     {\n-    case BUILT_IN_MEMCPY:\n-      init_block_move_fn (asmspec);\n-      memcpy_libfunc = set_user_assembler_libfunc (\"memcpy\", asmspec);\n-      break;\n-    case BUILT_IN_MEMSET:\n-      init_block_clear_fn (asmspec);\n-      memset_libfunc = set_user_assembler_libfunc (\"memset\", asmspec);\n-      break;\n-    case BUILT_IN_MEMMOVE:\n-      memmove_libfunc = set_user_assembler_libfunc (\"memmove\", asmspec);\n-      break;\n-    case BUILT_IN_MEMCMP:\n-      memcmp_libfunc = set_user_assembler_libfunc (\"memcmp\", asmspec);\n-      break;\n-    case BUILT_IN_ABORT:\n-      abort_libfunc = set_user_assembler_libfunc (\"abort\", asmspec);\n-      break;\n-    case BUILT_IN_FFS:\n-      if (INT_TYPE_SIZE < BITS_PER_WORD)\n-\t{\n-\t  set_user_assembler_libfunc (\"ffs\", asmspec);\n-\t  set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE,\n-\t\t\t\t\t\t       MODE_INT, 0), \"ffs\");\n-\t}\n-      break;\n-    default:\n-      break;\n+      set_user_assembler_libfunc (\"ffs\", asmspec);\n+      set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n+\t\t\t \"ffs\");\n     }\n }\n "}, {"sha": "94fed1029ba21c342274de9d00f5f27a7eb80dd9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -9752,8 +9752,6 @@ alpha_init_libfuncs (void)\n       set_optab_libfunc (smod_optab, DImode, \"OTS$REM_L\");\n       set_optab_libfunc (umod_optab, SImode, \"OTS$REM_UI\");\n       set_optab_libfunc (umod_optab, DImode, \"OTS$REM_UL\");\n-      abort_libfunc = init_one_libfunc (\"decc$abort\");\n-      memcmp_libfunc = init_one_libfunc (\"decc$memcmp\");\n #ifdef MEM_LIBFUNCS_INIT\n       MEM_LIBFUNCS_INIT;\n #endif"}, {"sha": "44580149f3966ff690dfad20ecce59761df59d74", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -26908,7 +26908,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t{\n \t  if (UINTVAL (count_exp) >= (unsigned HOST_WIDE_INT)dynamic_check)\n \t    {\n-\t      emit_block_move_via_libcall (dst, src, count_exp, false);\n+\t      emit_block_copy_via_libcall (dst, src, count_exp);\n \t      count_exp = const0_rtx;\n \t      goto epilogue;\n \t    }\n@@ -26923,9 +26923,9 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\t\t\t   1, hot_label);\n \t  predict_jump (REG_BR_PROB_BASE * 90 / 100);\n \t  if (issetmem)\n-\t    set_storage_via_libcall (dst, count_exp, val_exp, false);\n+\t    set_storage_via_libcall (dst, count_exp, val_exp);\n \t  else\n-\t    emit_block_move_via_libcall (dst, src, count_exp, false);\n+\t    emit_block_copy_via_libcall (dst, src, count_exp);\n \t  emit_jump (jump_around_label);\n \t  emit_label (hot_label);\n \t}"}, {"sha": "742123f401e044bdb593775ebf2da4093e8ca9cd", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -10624,8 +10624,6 @@ ia64_vms_init_libfuncs (void)\n   set_optab_libfunc (smod_optab, DImode, \"OTS$REM_L\");\n   set_optab_libfunc (umod_optab, SImode, \"OTS$REM_UI\");\n   set_optab_libfunc (umod_optab, DImode, \"OTS$REM_UL\");\n-  abort_libfunc = init_one_libfunc (\"decc$abort\");\n-  memcmp_libfunc = init_one_libfunc (\"decc$memcmp\");\n #ifdef MEM_LIBFUNCS_INIT\n   MEM_LIBFUNCS_INIT;\n #endif"}, {"sha": "68d06bb444fcb65aad165e79ddffae1aecccf5d6", "filename": "gcc/dse.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -2269,6 +2269,7 @@ scan_insn (bb_info_t bb_info, rtx_insn *insn)\n   if (CALL_P (insn))\n     {\n       bool const_call;\n+      rtx call, sym;\n       tree memset_call = NULL_TREE;\n \n       insn_info->cannot_delete = true;\n@@ -2278,24 +2279,16 @@ scan_insn (bb_info_t bb_info, rtx_insn *insn)\n \t been pushed onto the stack.\n \t memset and bzero don't read memory either.  */\n       const_call = RTL_CONST_CALL_P (insn);\n-      if (!const_call)\n-\t{\n-\t  rtx call = get_call_rtx_from (insn);\n-\t  if (call && GET_CODE (XEXP (XEXP (call, 0), 0)) == SYMBOL_REF)\n-\t    {\n-\t      rtx symbol = XEXP (XEXP (call, 0), 0);\n-\t      if (SYMBOL_REF_DECL (symbol)\n-\t\t  && TREE_CODE (SYMBOL_REF_DECL (symbol)) == FUNCTION_DECL)\n-\t\t{\n-\t\t  if ((DECL_BUILT_IN_CLASS (SYMBOL_REF_DECL (symbol))\n-\t\t       == BUILT_IN_NORMAL\n-\t\t       && (DECL_FUNCTION_CODE (SYMBOL_REF_DECL (symbol))\n-\t\t\t   == BUILT_IN_MEMSET))\n-\t\t      || SYMBOL_REF_DECL (symbol) == block_clear_fn)\n-\t\t    memset_call = SYMBOL_REF_DECL (symbol);\n-\t\t}\n-\t    }\n-\t}\n+      if (!const_call\n+\t  && (call = get_call_rtx_from (insn))\n+\t  && (sym = XEXP (XEXP (call, 0), 0))\n+\t  && GET_CODE (sym) == SYMBOL_REF\n+\t  && SYMBOL_REF_DECL (sym)\n+\t  && TREE_CODE (SYMBOL_REF_DECL (sym)) == FUNCTION_DECL\n+\t  && DECL_BUILT_IN_CLASS (SYMBOL_REF_DECL (sym)) == BUILT_IN_NORMAL\n+\t  && DECL_FUNCTION_CODE (SYMBOL_REF_DECL (sym)) == BUILT_IN_MEMSET)\n+\tmemset_call = SYMBOL_REF_DECL (sym);\n+\n       if (const_call || memset_call)\n \t{\n \t  insn_info_t i_ptr = active_local_stores;"}, {"sha": "e494915514f464634278fafa09bc0608f1f30ccd", "filename": "gcc/except.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -130,6 +130,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"explow.h\"\n #include \"stmt.h\"\n #include \"expr.h\"\n+#include \"calls.h\"\n #include \"libfuncs.h\"\n #include \"except.h\"\n #include \"output.h\"\n@@ -1173,20 +1174,22 @@ sjlj_emit_function_enter (rtx_code_label *dispatch_label)\n \n   if (dispatch_label)\n     {\n+      rtx addr = plus_constant (Pmode, XEXP (fc, 0), sjlj_fc_jbuf_ofs);\n+\n #ifdef DONT_USE_BUILTIN_SETJMP\n-      rtx x;\n-      x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_RETURNS_TWICE,\n-\t\t\t\t   TYPE_MODE (integer_type_node), 1,\n-\t\t\t\t   plus_constant (Pmode, XEXP (fc, 0),\n-\t\t\t\t\t\t  sjlj_fc_jbuf_ofs), Pmode);\n+      addr = copy_addr_to_reg (addr);\n+      addr = convert_memory_address (ptr_mode, addr);\n+      tree addr_tree = make_tree (ptr_type_node, addr);\n+\n+      tree fn = builtin_decl_implicit (BUILT_IN_SETJMP);\n+      tree call_expr = build_call_expr (fn, 1, addr_tree);\n+      rtx x = expand_call (call_expr, NULL_RTX, false);\n \n       emit_cmp_and_jump_insns (x, const0_rtx, NE, 0,\n \t\t\t       TYPE_MODE (integer_type_node), 0,\n \t\t\t       dispatch_label, REG_BR_PROB_BASE / 100);\n #else\n-      expand_builtin_setjmp_setup (plus_constant (Pmode, XEXP (fc, 0),\n-\t\t\t\t\t\t  sjlj_fc_jbuf_ofs),\n-\t\t\t\t   dispatch_label);\n+      expand_builtin_setjmp_setup (addr, dispatch_label);\n #endif\n     }\n "}, {"sha": "2f5a895015a9fef653f7803b70eeadac512f6bec", "filename": "gcc/expr.c", "status": "modified", "additions": 46, "deletions": 181, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -109,14 +109,12 @@ static bool block_move_libcall_safe_for_call_parm (void);\n static bool emit_block_move_via_movmem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n-static tree emit_block_move_libcall_fn (int);\n static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n static rtx clear_by_pieces_1 (void *, HOST_WIDE_INT, machine_mode);\n static void clear_by_pieces (rtx, unsigned HOST_WIDE_INT, unsigned int);\n static void store_by_pieces_1 (struct store_by_pieces_d *, unsigned int);\n static void store_by_pieces_2 (insn_gen_fn, machine_mode,\n \t\t\t       struct store_by_pieces_d *);\n-static tree clear_storage_libcall_fn (int);\n static rtx_insn *compress_float_constant (rtx, rtx);\n static rtx get_subtarget (rtx);\n static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n@@ -1132,7 +1130,7 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n \tmark_addressable (y_expr);\n       if (x_expr)\n \tmark_addressable (x_expr);\n-      retval = emit_block_move_via_libcall (x, y, size,\n+      retval = emit_block_copy_via_libcall (x, y, size,\n \t\t\t\t\t    method == BLOCK_OP_TAILCALL);\n     }\n \n@@ -1175,7 +1173,7 @@ block_move_libcall_safe_for_call_parm (void)\n   /* If registers go on the stack anyway, any argument is sure to clobber\n      an outgoing argument.  */\n #if defined (REG_PARM_STACK_SPACE)\n-  fn = emit_block_move_libcall_fn (false);\n+  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n   /* Avoid set but not used warning if *REG_PARM_STACK_SPACE doesn't\n      depend on its argument.  */\n   (void) fn;\n@@ -1191,7 +1189,7 @@ block_move_libcall_safe_for_call_parm (void)\n     cumulative_args_t args_so_far;\n     tree fn, arg;\n \n-    fn = emit_block_move_libcall_fn (false);\n+    fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n     INIT_CUMULATIVE_ARGS (args_so_far_v, TREE_TYPE (fn), NULL_RTX, 0, 3);\n     args_so_far = pack_cumulative_args (&args_so_far_v);\n \n@@ -1310,106 +1308,6 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n   return false;\n }\n \n-/* A subroutine of emit_block_move.  Expand a call to memcpy.\n-   Return the return value from memcpy, 0 otherwise.  */\n-\n-rtx\n-emit_block_move_via_libcall (rtx dst, rtx src, rtx size, bool tailcall)\n-{\n-  rtx dst_addr, src_addr;\n-  tree call_expr, fn, src_tree, dst_tree, size_tree;\n-  machine_mode size_mode;\n-  rtx retval;\n-\n-  /* Emit code to copy the addresses of DST and SRC and SIZE into new\n-     pseudos.  We can then place those new pseudos into a VAR_DECL and\n-     use them later.  */\n-\n-  dst_addr = copy_addr_to_reg (XEXP (dst, 0));\n-  src_addr = copy_addr_to_reg (XEXP (src, 0));\n-\n-  dst_addr = convert_memory_address (ptr_mode, dst_addr);\n-  src_addr = convert_memory_address (ptr_mode, src_addr);\n-\n-  dst_tree = make_tree (ptr_type_node, dst_addr);\n-  src_tree = make_tree (ptr_type_node, src_addr);\n-\n-  size_mode = TYPE_MODE (sizetype);\n-\n-  size = convert_to_mode (size_mode, size, 1);\n-  size = copy_to_mode_reg (size_mode, size);\n-\n-  /* It is incorrect to use the libcall calling conventions to call\n-     memcpy in this context.  This could be a user call to memcpy and\n-     the user may wish to examine the return value from memcpy.  For\n-     targets where libcalls and normal calls have different conventions\n-     for returning pointers, we could end up generating incorrect code.  */\n-\n-  size_tree = make_tree (sizetype, size);\n-\n-  fn = emit_block_move_libcall_fn (true);\n-  call_expr = build_call_expr (fn, 3, dst_tree, src_tree, size_tree);\n-  CALL_EXPR_TAILCALL (call_expr) = tailcall;\n-\n-  retval = expand_normal (call_expr);\n-\n-  return retval;\n-}\n-\n-/* A subroutine of emit_block_move_via_libcall.  Create the tree node\n-   for the function we use for block copies.  */\n-\n-static GTY(()) tree block_move_fn;\n-\n-void\n-init_block_move_fn (const char *asmspec)\n-{\n-  if (!block_move_fn)\n-    {\n-      tree args, fn, attrs, attr_args;\n-\n-      fn = get_identifier (\"memcpy\");\n-      args = build_function_type_list (ptr_type_node, ptr_type_node,\n-\t\t\t\t       const_ptr_type_node, sizetype,\n-\t\t\t\t       NULL_TREE);\n-\n-      fn = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, fn, args);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;\n-      DECL_VISIBILITY_SPECIFIED (fn) = 1;\n-\n-      attr_args = build_tree_list (NULL_TREE, build_string (1, \"1\"));\n-      attrs = tree_cons (get_identifier (\"fn spec\"), attr_args, NULL);\n-\n-      decl_attributes (&fn, attrs, ATTR_FLAG_BUILT_IN);\n-\n-      block_move_fn = fn;\n-    }\n-\n-  if (asmspec)\n-    set_user_assembler_name (block_move_fn, asmspec);\n-}\n-\n-static tree\n-emit_block_move_libcall_fn (int for_call)\n-{\n-  static bool emitted_extern;\n-\n-  if (!block_move_fn)\n-    init_block_move_fn (NULL);\n-\n-  if (for_call && !emitted_extern)\n-    {\n-      emitted_extern = true;\n-      make_decl_rtl (block_move_fn);\n-    }\n-\n-  return block_move_fn;\n-}\n-\n /* A subroutine of emit_block_move.  Copy the data via an explicit\n    loop.  This is used only when libcalls are forbidden.  */\n /* ??? It'd be nice to copy in hunks larger than QImode.  */\n@@ -1464,6 +1362,39 @@ emit_block_move_via_loop (rtx x, rtx y, rtx size,\n \t\t\t   true, top_label, REG_BR_PROB_BASE * 90 / 100);\n }\n \f\n+/* Expand a call to memcpy or memmove or memcmp, and return the result.\n+   TAILCALL is true if this is a tail call.  */\n+\n+rtx\n+emit_block_op_via_libcall (enum built_in_function fncode, rtx dst, rtx src,\n+\t\t\t   rtx size, bool tailcall)\n+{\n+  rtx dst_addr, src_addr;\n+  tree call_expr, dst_tree, src_tree, size_tree;\n+  machine_mode size_mode;\n+\n+  dst_addr = copy_addr_to_reg (XEXP (dst, 0));\n+  dst_addr = convert_memory_address (ptr_mode, dst_addr);\n+  dst_tree = make_tree (ptr_type_node, dst_addr);\n+\n+  src_addr = copy_addr_to_reg (XEXP (src, 0));\n+  src_addr = convert_memory_address (ptr_mode, src_addr);\n+  src_tree = make_tree (ptr_type_node, src_addr);\n+\n+  size_mode = TYPE_MODE (sizetype);\n+  size = convert_to_mode (size_mode, size, 1);\n+  size = copy_to_mode_reg (size_mode, size);\n+  size_tree = make_tree (sizetype, size);\n+\n+  /* It is incorrect to use the libcall calling conventions for calls to\n+     memcpy/memmove/memcmp because they can be provided by the user.  */\n+  tree fn = builtin_decl_implicit (fncode);\n+  call_expr = build_call_expr (fn, 3, dst_tree, src_tree, size_tree);\n+  CALL_EXPR_TAILCALL (call_expr) = tailcall;\n+\n+  return expand_call (call_expr, NULL_RTX, false);\n+}\n+\f\n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n \n@@ -2784,85 +2715,26 @@ set_storage_via_libcall (rtx object, rtx size, rtx val, bool tailcall)\n {\n   tree call_expr, fn, object_tree, size_tree, val_tree;\n   machine_mode size_mode;\n-  rtx retval;\n-\n-  /* Emit code to copy OBJECT and SIZE into new pseudos.  We can then\n-     place those into new pseudos into a VAR_DECL and use them later.  */\n \n   object = copy_addr_to_reg (XEXP (object, 0));\n+  object_tree = make_tree (ptr_type_node, object);\n+\n+  if (!CONST_INT_P (val))\n+    val = convert_to_mode (TYPE_MODE (integer_type_node), val, 1);\n+  val_tree = make_tree (integer_type_node, val);\n \n   size_mode = TYPE_MODE (sizetype);\n   size = convert_to_mode (size_mode, size, 1);\n   size = copy_to_mode_reg (size_mode, size);\n-\n-  /* It is incorrect to use the libcall calling conventions to call\n-     memset in this context.  This could be a user call to memset and\n-     the user may wish to examine the return value from memset.  For\n-     targets where libcalls and normal calls have different conventions\n-     for returning pointers, we could end up generating incorrect code.  */\n-\n-  object_tree = make_tree (ptr_type_node, object);\n-  if (!CONST_INT_P (val))\n-    val = convert_to_mode (TYPE_MODE (integer_type_node), val, 1);\n   size_tree = make_tree (sizetype, size);\n-  val_tree = make_tree (integer_type_node, val);\n \n-  fn = clear_storage_libcall_fn (true);\n+  /* It is incorrect to use the libcall calling conventions for calls to\n+     memset because it can be provided by the user.  */\n+  fn = builtin_decl_implicit (BUILT_IN_MEMSET);\n   call_expr = build_call_expr (fn, 3, object_tree, val_tree, size_tree);\n   CALL_EXPR_TAILCALL (call_expr) = tailcall;\n \n-  retval = expand_normal (call_expr);\n-\n-  return retval;\n-}\n-\n-/* A subroutine of set_storage_via_libcall.  Create the tree node\n-   for the function we use for block clears.  */\n-\n-tree block_clear_fn;\n-\n-void\n-init_block_clear_fn (const char *asmspec)\n-{\n-  if (!block_clear_fn)\n-    {\n-      tree fn, args;\n-\n-      fn = get_identifier (\"memset\");\n-      args = build_function_type_list (ptr_type_node, ptr_type_node,\n-\t\t\t\t       integer_type_node, sizetype,\n-\t\t\t\t       NULL_TREE);\n-\n-      fn = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, fn, args);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;\n-      DECL_VISIBILITY_SPECIFIED (fn) = 1;\n-\n-      block_clear_fn = fn;\n-    }\n-\n-  if (asmspec)\n-    set_user_assembler_name (block_clear_fn, asmspec);\n-}\n-\n-static tree\n-clear_storage_libcall_fn (int for_call)\n-{\n-  static bool emitted_extern;\n-\n-  if (!block_clear_fn)\n-    init_block_clear_fn (NULL);\n-\n-  if (for_call && !emitted_extern)\n-    {\n-      emitted_extern = true;\n-      make_decl_rtl (block_clear_fn);\n-    }\n-\n-  return block_clear_fn;\n+  return expand_call (call_expr, NULL_RTX, false);\n }\n \f\n /* Expand a setmem pattern; return true if successful.  */\n@@ -5157,12 +5029,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       size = expr_size (from);\n       from_rtx = expand_normal (from);\n \n-      emit_library_call (memmove_libfunc, LCT_NORMAL,\n-\t\t\t VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n-\t\t\t XEXP (from_rtx, 0), Pmode,\n-\t\t\t convert_to_mode (TYPE_MODE (sizetype),\n-\t\t\t\t\t  size, TYPE_UNSIGNED (sizetype)),\n-\t\t\t TYPE_MODE (sizetype));\n+      emit_block_move_via_libcall (XEXP (to_rtx, 0), XEXP (from_rtx, 0), size);\n \n       preserve_temp_slots (to_rtx);\n       pop_temp_slots ();\n@@ -11653,5 +11520,3 @@ int_expr_size (tree exp)\n \n   return tree_to_shwi (size);\n }\n-\n-#include \"gt-expr.h\""}, {"sha": "fea69a27e3aa29819b52b682a99936ea65234ac5", "filename": "gcc/expr.h", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -71,8 +71,29 @@ extern rtx convert_to_mode (machine_mode, rtx, int);\n /* Convert an rtx to MODE from OLDMODE and return the result.  */\n extern rtx convert_modes (machine_mode, machine_mode, rtx, int);\n \n-/* Emit code to move a block Y to a block X.  */\n+/* Expand a call to memcpy or memmove or memcmp, and return the result.  */\n+extern rtx emit_block_op_via_libcall (enum built_in_function, rtx, rtx, rtx,\n+\t\t\t\t      bool);\n+\n+static inline rtx\n+emit_block_copy_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n+{\n+  return emit_block_op_via_libcall (BUILT_IN_MEMCPY, dst, src, size, tailcall);\n+}\n \n+static inline rtx\n+emit_block_move_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n+{\n+  return emit_block_op_via_libcall (BUILT_IN_MEMMOVE, dst, src, size, tailcall);\n+}\n+\n+static inline rtx\n+emit_block_comp_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n+{\n+  return emit_block_op_via_libcall (BUILT_IN_MEMCMP, dst, src, size, tailcall);\n+}\n+\n+/* Emit code to move a block Y to a block X.  */\n enum block_op_methods\n {\n   BLOCK_OP_NORMAL,\n@@ -82,12 +103,7 @@ enum block_op_methods\n   BLOCK_OP_TAILCALL\n };\n \n-extern GTY(()) tree block_clear_fn;\n-extern void init_block_move_fn (const char *);\n-extern void init_block_clear_fn (const char *);\n-\n extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);\n-extern rtx emit_block_move_via_libcall (rtx, rtx, rtx, bool);\n extern rtx emit_block_move_hints (rtx, rtx, rtx, enum block_op_methods,\n \t\t\t          unsigned int, HOST_WIDE_INT,\n \t\t\t\t  unsigned HOST_WIDE_INT,\n@@ -166,7 +182,7 @@ extern rtx clear_storage_hints (rtx, rtx, enum block_op_methods,\n \t\t\t\tunsigned HOST_WIDE_INT,\n \t\t\t\tunsigned HOST_WIDE_INT);\n /* The same, but always output an library call.  */\n-rtx set_storage_via_libcall (rtx, rtx, rtx, bool);\n+extern rtx set_storage_via_libcall (rtx, rtx, rtx, bool = false);\n \n /* Expand a setmem pattern; return true if successful.  */\n extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int,"}, {"sha": "8250d5b001795b30f2575c2ea30ae229d76939c0", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -24,25 +24,9 @@ along with GCC; see the file COPYING3.  If not see\n /* Enumeration of indexes into libfunc_table.  */\n enum libfunc_index\n {\n-  LTI_abort,\n-  LTI_memcpy,\n-  LTI_memmove,\n-  LTI_memcmp,\n-  LTI_memset,\n-  LTI_setbits,\n-\n-  LTI_setjmp,\n-  LTI_longjmp,\n   LTI_unwind_sjlj_register,\n   LTI_unwind_sjlj_unregister,\n-\n-  LTI_profile_function_entry,\n-  LTI_profile_function_exit,\n-\n   LTI_synchronize,\n-\n-  LTI_gcov_flush,\n-\n   LTI_MAX\n };\n \n@@ -89,26 +73,11 @@ extern struct target_libfuncs *this_target_libfuncs;\n \n /* Accessor macros for libfunc_table.  */\n \n-#define abort_libfunc\t(libfunc_table[LTI_abort])\n-#define memcpy_libfunc\t(libfunc_table[LTI_memcpy])\n-#define memmove_libfunc\t(libfunc_table[LTI_memmove])\n-#define memcmp_libfunc\t(libfunc_table[LTI_memcmp])\n-#define memset_libfunc\t(libfunc_table[LTI_memset])\n-#define setbits_libfunc\t(libfunc_table[LTI_setbits])\n-\n-#define setjmp_libfunc\t(libfunc_table[LTI_setjmp])\n-#define longjmp_libfunc\t(libfunc_table[LTI_longjmp])\n #define unwind_sjlj_register_libfunc (libfunc_table[LTI_unwind_sjlj_register])\n #define unwind_sjlj_unregister_libfunc \\\n   (libfunc_table[LTI_unwind_sjlj_unregister])\n-\n-#define profile_function_entry_libfunc\t(libfunc_table[LTI_profile_function_entry])\n-#define profile_function_exit_libfunc\t(libfunc_table[LTI_profile_function_exit])\n-\n #define synchronize_libfunc\t(libfunc_table[LTI_synchronize])\n \n-#define gcov_flush_libfunc\t(libfunc_table[LTI_gcov_flush])\n-\n /* In explow.c */\n extern void set_stack_check_libfunc (const char *);\n "}, {"sha": "79a07d68b2c90a941392bef4281d765e6338de79", "filename": "gcc/optabs-libfuncs.c", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Foptabs-libfuncs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Foptabs-libfuncs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-libfuncs.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -731,14 +731,15 @@ static GTY (()) hash_table<libfunc_decl_hasher> *libfunc_decls;\n tree\n build_libfunc_function (const char *name)\n {\n+  /* ??? We don't have any type information; pretend this is \"int foo ()\".  */\n   tree decl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL,\n \t\t\t  get_identifier (name),\n \t\t\t  build_function_type (integer_type_node, NULL_TREE));\n-  /* ??? We don't have any type information except for this is\n-     a function.  Pretend this is \"int foo ()\".  */\n-  DECL_ARTIFICIAL (decl) = 1;\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n+  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n   gcc_assert (DECL_ASSEMBLER_NAME (decl));\n \n   /* Zap the nonsensical SYMBOL_REF_DECL for this.  What we're left with\n@@ -887,32 +888,10 @@ init_optabs (void)\n     set_optab_libfunc (abs_optab, TYPE_MODE (complex_double_type_node),\n \t\t       \"cabs\");\n \n-  abort_libfunc = init_one_libfunc (\"abort\");\n-  memcpy_libfunc = init_one_libfunc (\"memcpy\");\n-  memmove_libfunc = init_one_libfunc (\"memmove\");\n-  memcmp_libfunc = init_one_libfunc (\"memcmp\");\n-  memset_libfunc = init_one_libfunc (\"memset\");\n-  setbits_libfunc = init_one_libfunc (\"__setbits\");\n-\n-#ifndef DONT_USE_BUILTIN_SETJMP\n-  setjmp_libfunc = init_one_libfunc (\"__builtin_setjmp\");\n-  longjmp_libfunc = init_one_libfunc (\"__builtin_longjmp\");\n-#else\n-  setjmp_libfunc = init_one_libfunc (\"setjmp\");\n-  longjmp_libfunc = init_one_libfunc (\"longjmp\");\n-#endif\n   unwind_sjlj_register_libfunc = init_one_libfunc (\"_Unwind_SjLj_Register\");\n   unwind_sjlj_unregister_libfunc\n     = init_one_libfunc (\"_Unwind_SjLj_Unregister\");\n \n-  /* For function entry/exit instrumentation.  */\n-  profile_function_entry_libfunc\n-    = init_one_libfunc (\"__cyg_profile_func_enter\");\n-  profile_function_exit_libfunc\n-    = init_one_libfunc (\"__cyg_profile_func_exit\");\n-\n-  gcov_flush_libfunc = init_one_libfunc (\"__gcov_flush\");\n-\n   /* Allow the target to add more libcalls or rename some, etc.  */\n   targetm.init_libfuncs ();\n }"}, {"sha": "2bd81db5166201f68c2fbf40e6a2a2e0e7442785", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -3776,8 +3776,6 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n     {\n       machine_mode result_mode;\n       enum insn_code cmp_code;\n-      tree length_type;\n-      rtx libfunc;\n       rtx result;\n       rtx opalign\n \t= GEN_INT (MIN (MEM_ALIGN (x), MEM_ALIGN (y)) / BITS_PER_UNIT);\n@@ -3818,22 +3816,12 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n       if (methods != OPTAB_LIB && methods != OPTAB_LIB_WIDEN)\n \tgoto fail;\n \n-      /* Otherwise call a library function, memcmp.  */\n-      libfunc = memcmp_libfunc;\n-      length_type = sizetype;\n-      result_mode = TYPE_MODE (integer_type_node);\n-      cmp_mode = TYPE_MODE (length_type);\n-      size = convert_to_mode (TYPE_MODE (length_type), size,\n-\t\t\t      TYPE_UNSIGNED (length_type));\n-\n-      result = emit_library_call_value (libfunc, 0, LCT_PURE,\n-\t\t\t\t\tresult_mode, 3,\n-\t\t\t\t\tXEXP (x, 0), Pmode,\n-\t\t\t\t\tXEXP (y, 0), Pmode,\n-\t\t\t\t\tsize, cmp_mode);\n+      /* Otherwise call a library function.  */\n+      result = emit_block_comp_via_libcall (XEXP (x, 0), XEXP (y, 0), size);\n+\n       x = result;\n       y = const0_rtx;\n-      mode = result_mode;\n+      mode = TYPE_MODE (integer_type_node);\n       methods = OPTAB_LIB_WIDEN;\n       unsignedp = false;\n     }"}, {"sha": "e4c5068241b1781943f8a2ca87375acb649cfcd8", "filename": "gcc/tree-core.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -81,11 +81,14 @@ struct die_struct;\n /* The function does not lead to calls within current function unit.  */\n #define ECF_LEAF\t\t  (1 << 10)\n \n+/* Nonzero if this call returns its first argument.  */\n+#define ECF_RET1\t\t  (1 << 11)\n+\n /* Nonzero if this call does not affect transactions.  */\n-#define ECF_TM_PURE\t\t  (1 << 11)\n+#define ECF_TM_PURE\t\t  (1 << 12)\n \n /* Nonzero if this call is into the transaction runtime library.  */\n-#define ECF_TM_BUILTIN\t\t  (1 << 12)\n+#define ECF_TM_BUILTIN\t\t  (1 << 13)\n \n /* Call argument flags.  */\n /* Nonzero if the argument is not dereferenced recursively, thus only"}, {"sha": "4e0000416d860b6d43b9502f6bf633af299007b7", "filename": "gcc/tree.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee516de9b3b1aab35e4b21e9058c6176ee30901b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ee516de9b3b1aab35e4b21e9058c6176ee30901b", "patch": "@@ -10451,6 +10451,11 @@ set_call_expr_flags (tree decl, int flags)\n   if (flags & ECF_LEAF)\n     DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"leaf\"),\n \t\t\t\t\tNULL, DECL_ATTRIBUTES (decl));\n+  if (flags & ECF_RET1)\n+    DECL_ATTRIBUTES (decl)\n+      = tree_cons (get_identifier (\"fn spec\"),\n+\t\t   build_tree_list (NULL_TREE, build_string (1, \"1\")),\n+\t\t   DECL_ATTRIBUTES (decl));\n   if ((flags & ECF_TM_PURE) && flag_tm)\n     apply_tm_attr (decl, get_identifier (\"transaction_pure\"));\n   /* Looping const or pure is implied by noreturn.\n@@ -10486,13 +10491,20 @@ build_common_builtin_nodes (void)\n   tree tmp, ftype;\n   int ecf_flags;\n \n-  if (!builtin_decl_explicit_p (BUILT_IN_UNREACHABLE))\n+  if (!builtin_decl_explicit_p (BUILT_IN_UNREACHABLE)\n+      || !builtin_decl_explicit_p (BUILT_IN_ABORT))\n     {\n       ftype = build_function_type (void_type_node, void_list_node);\n-      local_define_builtin (\"__builtin_unreachable\", ftype, BUILT_IN_UNREACHABLE,\n-\t\t\t    \"__builtin_unreachable\",\n-\t\t\t    ECF_NOTHROW | ECF_LEAF | ECF_NORETURN\n-\t\t\t    | ECF_CONST);\n+      if (!builtin_decl_explicit_p (BUILT_IN_UNREACHABLE))\n+\tlocal_define_builtin (\"__builtin_unreachable\", ftype,\n+\t\t\t      BUILT_IN_UNREACHABLE,\n+\t\t\t      \"__builtin_unreachable\",\n+\t\t\t      ECF_NOTHROW | ECF_LEAF | ECF_NORETURN\n+\t\t\t      | ECF_CONST);\n+      if (!builtin_decl_explicit_p (BUILT_IN_ABORT))\n+\tlocal_define_builtin (\"__builtin_abort\", ftype, BUILT_IN_ABORT,\n+\t\t\t      \"abort\",\n+\t\t\t      ECF_LEAF | ECF_NORETURN | ECF_CONST);\n     }\n \n   if (!builtin_decl_explicit_p (BUILT_IN_MEMCPY)\n@@ -10504,10 +10516,10 @@ build_common_builtin_nodes (void)\n \n       if (!builtin_decl_explicit_p (BUILT_IN_MEMCPY))\n \tlocal_define_builtin (\"__builtin_memcpy\", ftype, BUILT_IN_MEMCPY,\n-\t\t\t      \"memcpy\", ECF_NOTHROW | ECF_LEAF);\n+\t\t\t      \"memcpy\", ECF_NOTHROW | ECF_LEAF | ECF_RET1);\n       if (!builtin_decl_explicit_p (BUILT_IN_MEMMOVE))\n \tlocal_define_builtin (\"__builtin_memmove\", ftype, BUILT_IN_MEMMOVE,\n-\t\t\t      \"memmove\", ECF_NOTHROW | ECF_LEAF);\n+\t\t\t      \"memmove\", ECF_NOTHROW | ECF_LEAF | ECF_RET1);\n     }\n \n   if (!builtin_decl_explicit_p (BUILT_IN_MEMCMP))\n@@ -10525,30 +10537,27 @@ build_common_builtin_nodes (void)\n \t\t\t\t\tptr_type_node, integer_type_node,\n \t\t\t\t\tsize_type_node, NULL_TREE);\n       local_define_builtin (\"__builtin_memset\", ftype, BUILT_IN_MEMSET,\n-\t\t\t    \"memset\", ECF_NOTHROW | ECF_LEAF);\n+\t\t\t    \"memset\", ECF_NOTHROW | ECF_LEAF | ECF_RET1);\n     }\n \n+  /* If we're checking the stack, `alloca' can throw.  */\n+  const int alloca_flags\n+    = ECF_MALLOC | ECF_LEAF | (flag_stack_check ? 0 : ECF_NOTHROW);\n+\n   if (!builtin_decl_explicit_p (BUILT_IN_ALLOCA))\n     {\n       ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t\tsize_type_node, NULL_TREE);\n       local_define_builtin (\"__builtin_alloca\", ftype, BUILT_IN_ALLOCA,\n-\t\t\t    \"alloca\", ECF_MALLOC | ECF_NOTHROW | ECF_LEAF);\n+\t\t\t    \"alloca\", alloca_flags);\n     }\n \n   ftype = build_function_type_list (ptr_type_node, size_type_node,\n \t\t\t\t    size_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_alloca_with_align\", ftype,\n \t\t\tBUILT_IN_ALLOCA_WITH_ALIGN,\n \t\t\t\"__builtin_alloca_with_align\",\n-\t\t\tECF_MALLOC | ECF_NOTHROW | ECF_LEAF);\n-\n-  /* If we're checking the stack, `alloca' can throw.  */\n-  if (flag_stack_check)\n-    {\n-      TREE_NOTHROW (builtin_decl_explicit (BUILT_IN_ALLOCA)) = 0;\n-      TREE_NOTHROW (builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN)) = 0;\n-    }\n+\t\t\talloca_flags);\n \n   ftype = build_function_type_list (void_type_node,\n \t\t\t\t    ptr_type_node, ptr_type_node,"}]}