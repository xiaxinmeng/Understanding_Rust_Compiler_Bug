{"sha": "3dbc772128e944819b09e21021d4fcd5dc17f2d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiYzc3MjEyOGU5NDQ4MTliMDllMjEwMjFkNGZjZDVkYzE3ZjJkNA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-23T15:59:00Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-23T19:34:57Z"}, "message": "coroutines: Fix handling of conditional statements [PR94288]\n\nNormally, when we find a statement containing an await expression\nthis will be expanded to a statement list implementing the control\nflow implied.  The expansion process successively replaces each\nawait expression in a statement with the result of its await_resume().\n\nIn the case of conditional statements (if, while, do, switch) the\nexpansion of the condition (or expression in the case of do-while)\ncannot take place 'inline', leading to the PR.\n\nThe solution is to evaluate the expression separately, and to\ntransform while and do-while loops into endless loops with a break\non the required condition.\n\nIn fixing this, I realised that I'd also made a thinko in the case\nof expanding truth-and/or-if expressions, where one arm of the\nexpression might need to be short-circuited.  The mechanism for\nexpanding via the tree walk will not work correctly in this case and\nwe need to pre-expand any truth-and/or-if with an await expression\non its conditionally-taken arm.  This applies to any statement with\ntruth-and/or-if expressions, so can be handled generically.\n\ngcc/cp/ChangeLog:\n\n2020-04-23  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94288\n\t* coroutines.cc (await_statement_expander): Simplify cases.\n\t(struct susp_frame_data): Add fields for truth and/or if\n\tcases, rename one field.\n\t(analyze_expression_awaits): New.\n\t(expand_one_truth_if): New.\n\t(add_var_to_bind): New helper.\n\t(coro_build_add_if_not_cond_break): New helper.\n\t(await_statement_walker): Handle conditional expressions,\n\thandle expansion of truth-and/or-if cases.\n\t(bind_expr_find_in_subtree): New, checking-only.\n\t(coro_body_contains_bind_expr_p): New, checking-only.\n\t(morph_fn_to_coro): Ensure that we have a top level bind\n\texpression.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-23  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94288\n\t* g++.dg/coroutines/torture/co-await-18-if-cond.C: New test.\n\t* g++.dg/coroutines/torture/co-await-19-while-cond.C: New test.\n\t* g++.dg/coroutines/torture/co-await-20-do-while-cond.C: New test.\n\t* g++.dg/coroutines/torture/co-await-21-switch-value.C: New test.\n\t* g++.dg/coroutines/torture/co-await-22-truth-and-of-if.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-16-simple-control-flow.C: New test.", "tree": {"sha": "389001201cb096a63933c1499409b7da23303331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/389001201cb096a63933c1499409b7da23303331"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dbc772128e944819b09e21021d4fcd5dc17f2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dbc772128e944819b09e21021d4fcd5dc17f2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dbc772128e944819b09e21021d4fcd5dc17f2d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dbc772128e944819b09e21021d4fcd5dc17f2d4/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7291b2edf6f87fba839b0d10c04b2562a5f6bd60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7291b2edf6f87fba839b0d10c04b2562a5f6bd60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7291b2edf6f87fba839b0d10c04b2562a5f6bd60"}], "stats": {"total": 874, "additions": 864, "deletions": 10}, "files": [{"sha": "fa150e3462fc29f064c6fc1dd3f092fb56e23633", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -1,3 +1,20 @@\n+2020-04-23 Iain Sandoe <iain@sandoe.co.uk>\n+\n+\tPR c++/94288\n+\t* coroutines.cc (await_statement_expander): Simplify cases.\n+\t(struct susp_frame_data): Add fields for truth and/or if\n+\tcases, rename one field.\n+\t(analyze_expression_awaits): New.\n+\t(expand_one_truth_if): New.\n+\t(add_var_to_bind): New helper.\n+\t(coro_build_add_if_not_cond_break): New helper.\n+\t(await_statement_walker): Handle conditional expressions,\n+\thandle expansion of truth-and/or-if cases.\n+\t(bind_expr_find_in_subtree): New, checking-only.\n+\t(coro_body_contains_bind_expr_p): New, checking-only.\n+\t(morph_fn_to_coro): Ensure that we have a top level bind\n+\texpression.\n+\n 2020-04-22  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR translation/94698"}, {"sha": "bec165b6ec6b204196488b645c79e437aad305e7", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 423, "deletions": 10, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -1627,9 +1627,8 @@ await_statement_expander (tree *stmt, int *do_subtree, void *d)\n   tree res = NULL_TREE;\n \n   /* Process a statement at a time.  */\n-  if (TREE_CODE (*stmt) == BIND_EXPR)\n-    res = cp_walk_tree (&BIND_EXPR_BODY (*stmt), await_statement_expander,\n-\t\t\td, NULL);\n+  if (STATEMENT_CLASS_P (*stmt) || TREE_CODE (*stmt) == BIND_EXPR)\n+    return NULL_TREE; /* Just process the sub-trees.  */\n   else if (TREE_CODE (*stmt) == STATEMENT_LIST)\n     {\n       tree_stmt_iterator i;\n@@ -1642,8 +1641,6 @@ await_statement_expander (tree *stmt, int *do_subtree, void *d)\n \t}\n       *do_subtree = 0; /* Done subtrees.  */\n     }\n-  else if (STATEMENT_CLASS_P (*stmt))\n-    return NULL_TREE; /* Process the sub-trees.  */\n   else if (EXPR_P (*stmt))\n     {\n       process_one_statement (stmt, d);\n@@ -2587,12 +2584,14 @@ struct susp_frame_data\n   vec<tree, va_gc> *block_stack; /* Track block scopes.  */\n   vec<tree, va_gc> *bind_stack;  /* Track current bind expr.  */\n   unsigned await_number;\t /* Which await in the function.  */\n-  unsigned condition_number;\t /* Which replaced condition in the fn.  */\n+  unsigned cond_number;\t\t /* Which replaced condition in the fn.  */\n   /* Temporary values for one statement or expression being analyzed.  */\n   hash_set<tree> captured_temps; /* The suspend captured these temps.  */\n   vec<tree, va_gc> *to_replace;  /* The VAR decls to replace.  */\n+  hash_set<tree> *truth_aoif_to_expand; /* The set of TRUTH exprs to expand.  */\n   unsigned saw_awaits;\t\t /* Count of awaits in this statement  */\n   bool captures_temporary;\t /* This expr captures temps by ref.  */\n+  bool needs_truth_if_exp;\t /* We must expand a truth_if expression.  */\n };\n \n /* Walk the sub-tree looking for call expressions that both capture\n@@ -2896,6 +2895,178 @@ maybe_promote_captured_temps (tree *stmt, void *d)\n   return NULL_TREE;\n }\n \n+/* Lightweight callback to determine two key factors:\n+   1) If the statement/expression contains any await expressions.\n+   2) If the statement/expression potentially requires a re-write to handle\n+      TRUTH_{AND,OR}IF_EXPRs since, in most cases, they will need expansion\n+      so that the await expressions are not processed in the case of the\n+      short-circuit arm.\n+   CO_YIELD expressions are re-written to their underlying co_await.  */\n+\n+static tree\n+analyze_expression_awaits (tree *stmt, int *do_subtree, void *d)\n+{\n+  susp_frame_data *awpts = (susp_frame_data *) d;\n+\n+  switch (TREE_CODE (*stmt))\n+    {\n+      default: return NULL_TREE;\n+      case CO_YIELD_EXPR:\n+\t/* co_yield is syntactic sugar, re-write it to co_await.  */\n+\t*stmt = TREE_OPERAND (*stmt, 1);\n+\t/* FALLTHROUGH */\n+      case CO_AWAIT_EXPR:\n+\tawpts->saw_awaits++;\n+\tbreak;\n+      case TRUTH_ANDIF_EXPR:\n+      case TRUTH_ORIF_EXPR:\n+\t{\n+\t  /* We don't need special action for awaits in the always-executed\n+\t     arm of a TRUTH_IF.  */\n+\t  if (tree res = cp_walk_tree (&TREE_OPERAND (*stmt, 0),\n+\t\t\t\t       analyze_expression_awaits, d, NULL))\n+\t    return res;\n+\t  /* However, if there are await expressions on the conditionally\n+\t     executed branch, we must expand the TRUTH_IF to ensure that the\n+\t     expanded await expression control-flow is fully contained in the\n+\t     conditionally executed code.  */\n+\t  unsigned aw_count = awpts->saw_awaits;\n+\t  if (tree res = cp_walk_tree (&TREE_OPERAND (*stmt, 1),\n+\t\t\t\t       analyze_expression_awaits, d, NULL))\n+\t    return res;\n+\t  if (awpts->saw_awaits > aw_count)\n+\t    {\n+\t      awpts->truth_aoif_to_expand->add (*stmt);\n+\t      awpts->needs_truth_if_exp = true;\n+\t    }\n+\t  /* We've done the sub-trees here.  */\n+\t  *do_subtree = 0;\n+\t}\n+\tbreak;\n+    }\n+\n+  return NULL_TREE; /* Recurse until done.  */\n+}\n+\n+/* Given *EXPR\n+   If EXPR contains a TRUTH_{AND,OR}IF_EXPR, TAOIE with an await expr on\n+   the conditional branch expand this to:\n+\n+   bool not_expr = TAOIE == TRUTH_ORIF_EXPR ? NOT : NOP;\n+   A) bool t = always exec expr\n+      if (not_expr (t))\n+   B)   t = conditionally exec expr\n+   c) EXPR' = EXPR with  TAOIE replaced by t.\n+\n+   Then repeat this for A, B and C.  */\n+\n+struct truth_if_transform {\n+  tree *orig_stmt;\n+  tree scratch_var;\n+  hash_set<tree> *truth_aoif_to_expand;\n+};\n+\n+static tree\n+expand_one_truth_if (tree *expr, int *do_subtree, void *d)\n+{\n+  truth_if_transform *xform = (truth_if_transform *) d;\n+\n+  bool needs_not = false;\n+  switch (TREE_CODE (*expr))\n+    {\n+      default: break;\n+      case TRUTH_ORIF_EXPR:\n+\tneeds_not = true;\n+\t/* FALLTHROUGH */\n+      case TRUTH_ANDIF_EXPR:\n+\t{\n+\t  if (!xform->truth_aoif_to_expand->contains (*expr))\n+\t    break;\n+\n+\t  location_t sloc = EXPR_LOCATION (*expr);\n+\t  tree type = TREE_TYPE (xform->scratch_var);\n+\t  gcc_checking_assert (TREE_CODE (type) == BOOLEAN_TYPE);\n+\t  tree new_list = push_stmt_list ();\n+\t  /* Init our scratch with the unconditionally-evaluated expr.  */\n+\t  tree new_s = build2_loc (sloc, INIT_EXPR, boolean_type_node,\n+\t\t\t\t   xform->scratch_var,\n+\t\t\t\t   TREE_OPERAND (*expr, 0));\n+\t  finish_expr_stmt (new_s);\n+\t  tree *pre = tsi_stmt_ptr (tsi_last (new_list));\n+\t  tree if_cond = xform->scratch_var;\n+\t  if (needs_not)\n+\t    if_cond = build1 (TRUTH_NOT_EXPR, boolean_type_node, if_cond);\n+\t  tree if_stmt = begin_if_stmt ();\n+\t  finish_if_stmt_cond (if_cond, if_stmt);\n+\t  /* If we take the if branch, then overwrite scratch with the cond\n+\t     executed branch.  */\n+\t  new_s = build2 (INIT_EXPR, boolean_type_node,\n+\t\t\t  xform->scratch_var, TREE_OPERAND (*expr, 1));\n+\t  finish_expr_stmt (new_s);\n+\t  finish_then_clause (if_stmt);\n+\t  finish_if_stmt (if_stmt);\n+\t  *expr = xform->scratch_var; /* now contains the result.  */\n+\t  /* So now we've got a statement list expanding one TAOIe.  */\n+\t  add_stmt (*xform->orig_stmt);\n+\t  tree *post = tsi_stmt_ptr (tsi_last (new_list));\n+\t  *xform->orig_stmt = pop_stmt_list (new_list);\n+\t  /* Now recurse into the pre, if and post parts.  */\n+\t  truth_if_transform sub_data = {pre, xform->scratch_var,\n+\t\t\t\t\t xform->truth_aoif_to_expand};\n+\t  if (tree res = cp_walk_tree (pre, expand_one_truth_if, &sub_data,\n+\t\t\t\t       NULL))\n+\t    return res;\n+\t  sub_data.orig_stmt = &THEN_CLAUSE (if_stmt);\n+\t  if (tree res = cp_walk_tree (&THEN_CLAUSE (if_stmt),\n+\t\t\t\t       expand_one_truth_if, &sub_data, NULL))\n+\t    return res;\n+\t  sub_data.orig_stmt = post;\n+\t  if (tree res = cp_walk_tree (post, expand_one_truth_if, &sub_data,\n+\t\t\t\t       NULL))\n+\t    return res;\n+\t  /* We've done the sub-trees here.  */\n+\t  *do_subtree = 0;\n+\t}\n+\tbreak;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Helper that adds a new variable of VAR_TYPE to a bind scope BIND, the\n+   name is made up from NAM_ROOT, NAM_VERS.  */\n+\n+static tree\n+add_var_to_bind (tree& bind, tree var_type,\n+\t\t const char *nam_root, unsigned nam_vers)\n+{\n+\n+  tree b_vars = BIND_EXPR_VARS (bind);\n+  /* Build a variable to hold the condition, this will be included in the\n+     frame as a local var.  */\n+  char *nam = xasprintf (\"%s.%d\", nam_root, nam_vers);\n+  tree newvar = build_lang_decl (VAR_DECL, get_identifier (nam), var_type);\n+  free (nam);\n+  DECL_CHAIN (newvar) = b_vars;\n+  BIND_EXPR_VARS (bind) = newvar;\n+  return newvar;\n+}\n+\n+/* Helper to build and add if (!cond) break;  */\n+\n+static void\n+coro_build_add_if_not_cond_break (tree cond)\n+{\n+  tree if_stmt = begin_if_stmt ();\n+  tree invert = build1 (TRUTH_NOT_EXPR, boolean_type_node, cond);\n+  finish_if_stmt_cond (invert, if_stmt);\n+  finish_break_stmt ();\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt (if_stmt);\n+}\n+\n+/* Tree walk callback to analyze, register and pre-process statements that\n+   contain await expressions.  */\n+\n static tree\n await_statement_walker (tree *stmt, int *do_subtree, void *d)\n {\n@@ -2905,14 +3076,19 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n   /* Process a statement at a time.  */\n   if (TREE_CODE (*stmt) == BIND_EXPR)\n     {\n+      /* For conditional expressions, we might wish to add an artificial var\n+\t to their containing bind expr.  */\n+      vec_safe_push (awpts->bind_stack, *stmt);\n       /* We might need to insert a new bind expression, and want to link it\n \t into the correct scope, so keep a note of the current block scope.  */\n       tree blk = BIND_EXPR_BLOCK (*stmt);\n       vec_safe_push (awpts->block_stack, blk);\n       res = cp_walk_tree (&BIND_EXPR_BODY (*stmt), await_statement_walker,\n \t\t\t  d, NULL);\n       awpts->block_stack->pop ();\n+      awpts->bind_stack->pop ();\n       *do_subtree = 0; /* Done subtrees.  */\n+      return res;\n     }\n   else if (TREE_CODE (*stmt) == STATEMENT_LIST)\n     {\n@@ -2925,13 +3101,205 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t    return res;\n \t}\n       *do_subtree = 0; /* Done subtrees.  */\n+      return NULL_TREE;\n     }\n-  else if (STATEMENT_CLASS_P (*stmt))\n-    return NULL_TREE; /* Process the subtrees.  */\n+\n+  /* We have something to be handled as a single statement.  */\n+  hash_set<tree> visited;\n+  awpts->saw_awaits = 0;\n+  hash_set<tree> truth_aoif_to_expand;\n+  awpts->truth_aoif_to_expand = &truth_aoif_to_expand;\n+  awpts->needs_truth_if_exp = false;\n+\n+  if (STATEMENT_CLASS_P (*stmt))\n+    switch (TREE_CODE (*stmt))\n+      {\n+\t/* Unless it's a special case, just walk the subtrees as usual.  */\n+\tdefault: return NULL_TREE;\n+\n+\t/* When we have a conditional expression, which contains one or more\n+\t   await expressions, we have to break the condition out into a\n+\t   regular statement so that the control flow introduced by the await\n+\t   transforms can be implemented.  */\n+\tcase IF_STMT:\n+\t  {\n+\t    /* Transform 'if (cond with awaits) then stmt1 else stmt2' into\n+\t       bool cond = cond with awaits.\n+\t       if (cond) then stmt1 else stmt2.  */\n+\t    tree if_stmt = *stmt;\n+\t    /* We treat the condition as if it was a stand-alone statement,\n+\t       to see if there are any await expressions which will be analysed\n+\t       and registered.  */\n+\t    if ((res = cp_walk_tree (&IF_COND (if_stmt),\n+\t\tanalyze_expression_awaits, d, &visited)))\n+\t      return res;\n+\t    if (!awpts->saw_awaits)\n+\t      return NULL_TREE; /* Nothing special to do here.  */\n+\n+\t    gcc_checking_assert (!awpts->bind_stack->is_empty());\n+\t    tree& bind_expr = awpts->bind_stack->last ();\n+\t    tree newvar = add_var_to_bind (bind_expr, boolean_type_node,\n+\t\t\t\t\t   \"ifcd\", awpts->cond_number++);\n+\t    tree insert_list = push_stmt_list ();\n+\t    tree cond_inner = IF_COND (if_stmt);\n+\t    if (TREE_CODE (cond_inner) == CLEANUP_POINT_EXPR)\n+\t      cond_inner = TREE_OPERAND (cond_inner, 0);\n+\t    add_decl_expr (newvar);\n+\t    location_t sloc = EXPR_LOCATION (IF_COND (if_stmt));\n+\t    /* We want to initialize the new variable with the expression\n+\t       that contains the await(s) and potentially also needs to\n+\t       have truth_if expressions expanded.  */\n+\t    tree new_s = build2_loc (sloc, MODIFY_EXPR, boolean_type_node,\n+\t\t\t\t     newvar, cond_inner);\n+\t    finish_expr_stmt (new_s);\n+\t    if (awpts->needs_truth_if_exp)\n+\t      {\n+\t\ttree *sp = tsi_stmt_ptr (tsi_last (insert_list));\n+\t\ttruth_if_transform xf = {sp, newvar, &truth_aoif_to_expand};\n+\t\tif ((res = cp_walk_tree (sp, expand_one_truth_if, &xf, NULL)))\n+\t\t  return res;\n+\t      }\n+\t    IF_COND (if_stmt) = newvar;\n+\t    add_stmt (if_stmt);\n+\t    *stmt = pop_stmt_list (insert_list);\n+\t    /* So now walk the new statement list.  */\n+\t    res = cp_walk_tree (stmt, await_statement_walker, d, NULL);\n+\t    *do_subtree = 0; /* Done subtrees.  */\n+\t    return res;\n+\t  }\n+\t  break;\n+\tcase WHILE_STMT:\n+\t  {\n+\t    /* We turn 'while (cond with awaits) stmt' into\n+\t       while (true) {\n+\t\t  if (!(cond with awaits))\n+\t\t    break;\n+\t\t  stmt..\n+\t\t} */\n+\t    tree while_stmt = *stmt;\n+\t    if ((res = cp_walk_tree (&WHILE_COND (while_stmt),\n+\t\tanalyze_expression_awaits, d, &visited)))\n+\t      return res;\n+\t    if (!awpts->saw_awaits)\n+\t      return NULL_TREE; /* Nothing special to do here.  */\n+\n+\t    tree insert_list = push_stmt_list ();\n+\t    coro_build_add_if_not_cond_break (WHILE_COND (while_stmt));\n+\t    /* The original while body.  */\n+\t    add_stmt (WHILE_BODY (while_stmt));\n+\t    /* The new while body.  */\n+\t    WHILE_BODY (while_stmt) = pop_stmt_list (insert_list);\n+\t    WHILE_COND (while_stmt) = boolean_true_node;\n+\t    /* So now walk the new statement list.  */\n+\t    res = cp_walk_tree (&WHILE_BODY (while_stmt),\n+\t\t\t\tawait_statement_walker, d, NULL);\n+\t    *do_subtree = 0; /* Done subtrees.  */\n+\t    return res;\n+\t  }\n+\t  break;\n+\tcase DO_STMT:\n+\t  {\n+\t    /* We turn do stmt while (cond with awaits) into:\n+\t       do {\n+\t\t  stmt..\n+\t\t  if (!(cond with awaits))\n+\t\t    break;\n+\t       } while (true); */\n+\t    tree do_stmt = *stmt;\n+\t    if ((res = cp_walk_tree (&DO_COND (do_stmt),\n+\t\tanalyze_expression_awaits, d, &visited)))\n+\t      return res;\n+\t    if (!awpts->saw_awaits)\n+\t      return NULL_TREE; /* Nothing special to do here.  */\n+\n+\t    tree insert_list = push_stmt_list ();\n+\t    /* The original do stmt body.  */\n+\t    add_stmt (DO_BODY (do_stmt));\n+\t    coro_build_add_if_not_cond_break (DO_COND (do_stmt));\n+\t    /* The new while body.  */\n+\t    DO_BODY (do_stmt) = pop_stmt_list (insert_list);\n+\t    DO_COND (do_stmt) = boolean_true_node;\n+\t    /* So now walk the new statement list.  */\n+\t    res = cp_walk_tree (&DO_BODY (do_stmt), await_statement_walker,\n+\t\t\t\td, NULL);\n+\t    *do_subtree = 0; /* Done subtrees.  */\n+\t    return res;\n+\n+\t  }\n+\t  break;\n+\tcase SWITCH_STMT:\n+\t  {\n+\t    /* We turn 'switch (cond with awaits) stmt' into\n+\t       switch_type cond = cond with awaits\n+\t       switch (cond) stmt.  */\n+\t    tree sw_stmt = *stmt;\n+\t    if ((res = cp_walk_tree (&SWITCH_STMT_COND (sw_stmt),\n+\t\tanalyze_expression_awaits, d, &visited)))\n+\t      return res;\n+\t    if (!awpts->saw_awaits)\n+\t      return NULL_TREE; /* Nothing special to do here.  */\n+\n+\t    gcc_checking_assert (!awpts->bind_stack->is_empty());\n+\t    /* Build a variable to hold the condition, this will be\n+\t\t   included in the frame as a local var.  */\n+\t    tree& bind_expr = awpts->bind_stack->last ();\n+\t    tree sw_type = SWITCH_STMT_TYPE (sw_stmt);\n+\t    tree newvar = add_var_to_bind (bind_expr, sw_type, \"swch\",\n+\t\t\t\t\t   awpts->cond_number++);\n+\t    tree insert_list = push_stmt_list ();\n+\t    add_decl_expr (newvar);\n+\n+\t    tree cond_inner = SWITCH_STMT_COND (sw_stmt);\n+\t    if (TREE_CODE (cond_inner) == CLEANUP_POINT_EXPR)\n+\t      cond_inner = TREE_OPERAND (cond_inner, 0);\n+\t    location_t sloc = EXPR_LOCATION (SWITCH_STMT_COND (sw_stmt));\n+\t    tree new_s = build2_loc (sloc, INIT_EXPR, sw_type, newvar,\n+\t\t\t\t     cond_inner);\n+\t    finish_expr_stmt (new_s);\n+\t    SWITCH_STMT_COND (sw_stmt) = newvar;\n+\t    /* Now add the switch statement with the condition re-\n+\t\t   written to use the local var.  */\n+\t    add_stmt (sw_stmt);\n+\t    *stmt = pop_stmt_list (insert_list);\n+\t    /* Process the expanded list.  */\n+\t    res = cp_walk_tree (stmt, await_statement_walker,\n+\t\t\t\td, NULL);\n+\t    *do_subtree = 0; /* Done subtrees.  */\n+\t    return res;\n+\t  }\n+\t  break;\n+      }\n   else if (EXPR_P (*stmt))\n     {\n-      res = maybe_promote_captured_temps (stmt, d);\n+      if ((res = cp_walk_tree (stmt, analyze_expression_awaits, d, &visited)))\n+\treturn res;\n       *do_subtree = 0; /* Done subtrees.  */\n+      if (!awpts->saw_awaits)\n+\treturn NULL_TREE; /* Nothing special to do here.  */\n+\n+      /* Unless we need to expand any truth-and/or-if expressions, then the\n+\t remaining action is to check for temporaries to await expressions\n+\t captured by refence.  */\n+      if (!awpts->needs_truth_if_exp)\n+\treturn maybe_promote_captured_temps (stmt, d);\n+\n+      gcc_checking_assert (!awpts->bind_stack->is_empty());\n+      tree& bind_expr = awpts->bind_stack->last ();\n+      /* Build a variable to hold the condition, this will be\n+      included in the frame as a local var.  */\n+      tree newvar = add_var_to_bind (bind_expr, boolean_type_node,\n+\t\t\t\t     \"taoi\", awpts->cond_number++);\n+      tree insert_list = push_stmt_list ();\n+      add_decl_expr (newvar);\n+      add_stmt (*stmt);\n+      tree *sp = tsi_stmt_ptr (tsi_last (insert_list));\n+      *stmt = pop_stmt_list (insert_list);\n+\n+      truth_if_transform xf = {sp, newvar, &truth_aoif_to_expand};\n+      if ((res = cp_walk_tree (sp, expand_one_truth_if, &xf, NULL)))\n+\treturn res;\n+      /* Process the expanded trees.  */\n+      return cp_walk_tree (stmt, await_statement_walker, d, NULL);\n     }\n  \n   /* Continue recursion, if needed.  */\n@@ -3073,6 +3441,27 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n   return fn;\n }\n \n+#if CHECKING_P\n+/* Return a bind expression if we see one, else NULL_TREE.  */\n+static tree\n+bind_expr_find_in_subtree (tree *stmt, int *, void *)\n+{\n+  if (TREE_CODE (*stmt) == BIND_EXPR)\n+    return *stmt;\n+  return NULL_TREE;\n+}\n+\n+/* Return the first bind expression that the sub-tree given by STMT\n+   contains.  */\n+\n+static tree\n+coro_body_contains_bind_expr_p (tree *stmt)\n+{\n+  hash_set<tree> visited;\n+  return cp_walk_tree (stmt, bind_expr_find_in_subtree, NULL, &visited);\n+}\n+#endif\n+\n /* Here we:\n    a) Check that the function and promise type are valid for a\n       coroutine.\n@@ -3160,6 +3549,30 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       TREE_OPERAND (body_start, 0) = push_stmt_list ();\n     }\n \n+  /* We can be presented with a function that currently has no outer bind\n+     expression.  We will insert bind scopes in expanding await expressions,\n+     and therefore need a top level to the tree, so synthesize an outer bind\n+     expression and scope.  */\n+  tree check_bind = expr_first (fnbody);\n+  if (check_bind && TREE_CODE (check_bind) != BIND_EXPR)\n+    {\n+      tree update_body = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+      tree blk = make_node (BLOCK);\n+      gcc_checking_assert (!coro_body_contains_bind_expr_p (&fnbody));\n+      BIND_EXPR_BLOCK (update_body) = blk;\n+      if (TREE_CODE (fnbody) == STATEMENT_LIST)\n+\tBIND_EXPR_BODY (update_body) = fnbody;\n+      else\n+\t{\n+\t  tree tlist = NULL_TREE;\n+\t  append_to_statement_list_force (fnbody, &tlist);\n+\t  BIND_EXPR_BODY (update_body) = tlist;\n+\t}\n+      tree new_body_list = NULL_TREE;\n+      append_to_statement_list_force (update_body, &new_body_list);\n+      fnbody = new_body_list;\n+    }\n+\n   /* Create the coro frame type, as far as it can be known at this stage.\n      1. Types we already know.  */\n \n@@ -3309,7 +3722,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      vars) they will get added to the coro frame along with other locals.  */\n   susp_frame_data body_aw_points\n     = {&field_list, handle_type, NULL, NULL, 0, 0,\n-       hash_set<tree> (), NULL, 0, false};\n+       hash_set<tree> (), NULL, NULL, 0, false, false};\n   body_aw_points.block_stack = make_tree_vector ();\n   body_aw_points.bind_stack = make_tree_vector ();\n   body_aw_points.to_replace = make_tree_vector ();"}, {"sha": "249a1520581f134dff85fccc6f67e9d77f764b08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -1,3 +1,13 @@\n+2020-04-23 Iain Sandoe <iain@sandoe.co.uk>\n+\n+\tPR c++/94288\n+\t* g++.dg/coroutines/torture/co-await-18-if-cond.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-19-while-cond.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-20-do-while-cond.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-21-switch-value.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-22-truth-and-of-if.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-16-simple-control-flow.C: New test.\n+\n 2020-04-23  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94733"}, {"sha": "6b05cfb44acde153539fda2011670aedc77c7269", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-18-if-cond.C", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-18-if-cond.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-18-if-cond.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-18-if-cond.C?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -0,0 +1,85 @@\n+// { dg-do run }\n+\n+// Test co-await in if condition.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns a boolean as the\n+   await_resume output.  */\n+struct BoolAwaiter {\n+  bool v;\n+  BoolAwaiter (bool _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  bool await_resume () { return v; }\n+};\n+\n+/* An awaiter that suspends always and returns an int as the\n+   await_resume output.  */\n+struct IntAwaiter {\n+  int v;\n+  IntAwaiter (int _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  int await_resume () { return v; }\n+};\n+\n+//extern int tt ();\n+  int three = 3;\n+  int two = 2;\n+\n+struct coro1\n+my_coro (bool t) noexcept\n+{\n+//  if (int two = 2;tt () || co_await BoolAwaiter (t) && t && co_await IntAwaiter (5) == co_await IntAwaiter (7))\n+  if (co_await BoolAwaiter (t) && co_await IntAwaiter (5) == 5)\n+    {\n+      int five = three + two;\n+      co_return 6169 + five;\n+    }\n+  else\n+    {\n+      int five = three + two;\n+      co_return 37 + five;\n+    }\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro\");\n+  struct coro1 x = my_coro (true);\n+\n+  if (x.handle.done())\n+    {\n+      PRINT (\"main: apparently done when we should not be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resume initial suspend\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: if condition 1 - true\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: if condition 2 - true\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    {\n+      PRINTF (\"main: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "2cd37616aaa4d8147563c44f6bb147e7c97a3529", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-19-while-cond.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-19-while-cond.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-19-while-cond.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-19-while-cond.C?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -0,0 +1,68 @@\n+// { dg-do run }\n+\n+// Test co-await in while condition.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns a boolean as the\n+   await_resume output.  */\n+struct BoolAwaiter {\n+  bool v;\n+  BoolAwaiter (bool _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  bool await_resume () { return v; }\n+};\n+\n+//extern bool tt(void);\n+int three = 3;\n+struct coro1\n+my_coro (bool t)\n+{\n+  //int three = 3;\n+  while (co_await BoolAwaiter (t) && t)\n+    {\n+      int five = three + 2;\n+      co_yield 6169 + five;\n+    }\n+\n+  co_return 42;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro\");\n+  struct coro1 x = my_coro (false);\n+\n+  if (x.handle.done())\n+    {\n+      PRINT (\"main: apparently done when we shouldn't be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resume initial suspend\");\n+  x.handle.resume();\n+\n+  // will be false - so no yield expected.\n+  PRINT (\"main: while condition\");\n+  x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    {\n+      PRINTF (\"main: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "bb1e97a6ef0623b194532888cb2ba7ae04bb6612", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-20-do-while-cond.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-20-do-while-cond.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-20-do-while-cond.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-20-do-while-cond.C?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -0,0 +1,68 @@\n+// { dg-do run }\n+\n+// Test co-await in do-while conditional\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns a boolean as the\n+   await_resume output.  The boolean toggles on each call.  */\n+struct BoolAwaiter {\n+  bool v;\n+  BoolAwaiter (bool _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  bool await_resume () { v = !v; return v; }\n+};\n+\n+int v = 32;\n+\n+struct coro1\n+my_coro (bool t)\n+{\n+  auto aw = BoolAwaiter (t);\n+  do {\n+    int five = 5;\n+    v += five;\n+  } while (co_await aw && !t);\n+\n+  co_return v;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro\");\n+  struct coro1 x = my_coro (false);\n+\n+  if (x.handle.done())\n+    {\n+      PRINT (\"main: apparently done when we should not be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resume initial suspend\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: resume while test, succeed first time\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: resume while test, fail second\");\n+  x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    {\n+      PRINTF (\"main: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "b5e1bf38050e1e9234d65c95eb5b3eb5031f00c8", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-21-switch-value.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-21-switch-value.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-21-switch-value.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-21-switch-value.C?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do run }\n+\n+// Test co-await in while condition.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns an int as the\n+   await_resume output.  */\n+struct IntAwaiter {\n+  int v;\n+  IntAwaiter (int _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  int await_resume () { return v; }\n+};\n+\n+struct coro1\n+my_coro (int t)\n+{\n+  int v = 6174;\n+  switch (co_await IntAwaiter (t) + 5)\n+  {\n+    default: break;\n+    case 22: co_return v;\n+  }\n+  co_return 42;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro\");\n+  struct coro1 x = my_coro (17);\n+\n+  if (x.handle.done())\n+    {\n+      PRINT (\"main: apparently done when we should not be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resume initial suspend\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: resume switch condition\");\n+  x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    {\n+      PRINTF (\"main: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "54659741cbedda84f8ce6cf6db495826d1dc5ca6", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-22-truth-and-of-if.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-22-truth-and-of-if.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-22-truth-and-of-if.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-22-truth-and-of-if.C?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -0,0 +1,81 @@\n+// { dg-do run }\n+\n+// Test co-await in while condition.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns an int as the\n+   await_resume output.  */\n+\n+struct IntAwaiter {\n+  int v;\n+  IntAwaiter (int _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  int await_resume () { return v; }\n+};\n+\n+/* An awaiter that suspends always and returns a boolean as the\n+   await_resume output.  The boolean toggles on each call.  */\n+\n+struct BoolAwaiter {\n+  bool v;\n+  BoolAwaiter (bool _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  bool await_resume () { v = !v; return v; }\n+};\n+\n+/* We will be able to establish that the second part of the conditional\n+   expression is not evaluated (if it was, then we'd need an additional\n+   resume to complete the coroutine).  */\n+\n+struct coro1\n+my_coro (int t)\n+{\n+\n+  bool x = co_await IntAwaiter (t) == 5 || co_await BoolAwaiter (false);\n+\n+  if (x)\n+    co_return 6174;\n+  co_return 42;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro\");\n+  struct coro1 x = my_coro (5);\n+\n+  if (x.handle.done())\n+    {\n+      PRINT (\"main: apparently done when we should not be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resume initial suspend\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: resume IntAwaiter\");\n+  x.handle.resume();\n+\n+  // The evaluation of 'co_await IntAwaiter (t) == 5' should be true, thus\n+  // the second co_await in the expression will be unexecuted. \n+  \n+  int y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    {\n+      PRINTF (\"main: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "6d4196d64f057853190ce2a3b36fe28513fb0e97", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-16-simple-control-flow.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-16-simple-control-flow.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dbc772128e944819b09e21021d4fcd5dc17f2d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-16-simple-control-flow.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-16-simple-control-flow.C?ref=3dbc772128e944819b09e21021d4fcd5dc17f2d4", "patch": "@@ -0,0 +1,49 @@\n+#if 0\n+//  { d g-do run }\n+\n+// Test returning an int.\n+// We will use the promise to contain this to avoid having to include\n+// additional C++ headers.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int v)\n+{\n+  if (co_await coro1::suspend_always_intprt{v} == 10)\n+    co_return 6174;\n+  else\n+    {\n+      int v = 42;\n+      PRINT (\"coro1: about to return\");\n+      co_return v;\n+    }\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (10);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  // initial susp\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  // if condition\n+  x.handle.resume();\n+  int y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}\n+#endif"}]}