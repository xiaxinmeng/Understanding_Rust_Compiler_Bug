{"sha": "40fda55b4060ddc9f5d5bebe39cd409d63af9388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmZGE1NWI0MDYwZGRjOWY1ZDViZWJlMzljZDQwOWQ2M2FmOTM4OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-04T22:48:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-04T22:48:54Z"}, "message": "ipa-inline.c (reset_edge_caches): New function.\n\n\t* ipa-inline.c (reset_edge_caches): New function.\n\t(update_caller_keys): Add check_inlinablity_for; do not\n\treset edge caches; remove now unnecesary loop.\n\t(update_callee_keys): Add comments; reset\n\tnode_growth_cache of callee.\n\t(update_all_callee_keys): Likewise.\n\t(inline_small_functions): Sanity check cache; update code\n\trecomputing it.\n\nFrom-SVN: r173399", "tree": {"sha": "015b84dec1ea6f1b81c2cfdfecaf345a63e3e13f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/015b84dec1ea6f1b81c2cfdfecaf345a63e3e13f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40fda55b4060ddc9f5d5bebe39cd409d63af9388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fda55b4060ddc9f5d5bebe39cd409d63af9388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40fda55b4060ddc9f5d5bebe39cd409d63af9388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fda55b4060ddc9f5d5bebe39cd409d63af9388/comments", "author": null, "committer": null, "parents": [{"sha": "bf9fa1b972229c9caa32c5b95c0ca211757a1e9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf9fa1b972229c9caa32c5b95c0ca211757a1e9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf9fa1b972229c9caa32c5b95c0ca211757a1e9b"}], "stats": {"total": 137, "additions": 108, "deletions": 29}, "files": [{"sha": "509a742770f54f6b07e50a2a9a5bee3c5f9a5912", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fda55b4060ddc9f5d5bebe39cd409d63af9388/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fda55b4060ddc9f5d5bebe39cd409d63af9388/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40fda55b4060ddc9f5d5bebe39cd409d63af9388", "patch": "@@ -1,3 +1,14 @@\n+2011-05-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (reset_edge_caches): New function.\n+\t(update_caller_keys): Add check_inlinablity_for; do not\n+\treset edge caches; remove now unnecesary loop.\n+\t(update_callee_keys): Add comments; reset\n+\tnode_growth_cache of callee.\n+\t(update_all_callee_keys): Likewise.\n+\t(inline_small_functions): Sanity check cache; update code\n+\trecomputing it.\n+\n 2011-05-04  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR rtl-optimization/47612"}, {"sha": "653623233bc77207fa10ded165b2a14ffd7eeb17", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 97, "deletions": 29, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fda55b4060ddc9f5d5bebe39cd409d63af9388/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fda55b4060ddc9f5d5bebe39cd409d63af9388/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=40fda55b4060ddc9f5d5bebe39cd409d63af9388", "patch": "@@ -850,11 +850,64 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n     }\n }\n \n-/* Recompute heap nodes for each of caller edge.  */\n+\n+/* NODE was inlined.\n+   All caller edges needs to be resetted because\n+   size estimates change. Similarly callees needs reset\n+   because better context may be known.  */\n+\n+static void\n+reset_edge_caches (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *edge;\n+  struct cgraph_edge *e = node->callees;\n+  struct cgraph_node *where = node;\n+\n+  if (where->global.inlined_to)\n+    where = where->global.inlined_to;\n+\n+  /* WHERE body size has changed, the cached growth is invalid.  */\n+  reset_node_growth_cache (where);\n+\n+  for (edge = where->callers; edge; edge = edge->next_caller)\n+    if (edge->inline_failed)\n+      reset_edge_growth_cache (edge);\n+\n+  if (!e)\n+    return;\n+\n+  while (true)\n+    if (!e->inline_failed && e->callee->callees)\n+      e = e->callee->callees;\n+    else\n+      {\n+\tif (e->inline_failed)\n+\t  reset_edge_growth_cache (e);\n+\tif (e->next_callee)\n+\t  e = e->next_callee;\n+\telse\n+\t  {\n+\t    do\n+\t      {\n+\t\tif (e->caller == node)\n+\t\t  return;\n+\t\te = e->caller->callers;\n+\t      }\n+\t    while (!e->next_callee);\n+\t    e = e->next_callee;\n+\t  }\n+      }\n+}\n+\n+/* Recompute HEAP nodes for each of caller of NODE.\n+   UPDATED_NODES track nodes we already visited, to avoid redundant work.\n+   When CHECK_INLINABLITY_FOR is set, re-check for specified edge that\n+   it is inlinable. Otherwise check all edges.  */\n \n static void\n update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n-\t\t    bitmap updated_nodes)\n+\t\t    bitmap updated_nodes,\n+\t\t    struct cgraph_edge *check_inlinablity_for)\n {\n   struct cgraph_edge *edge;\n \n@@ -864,32 +917,29 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n-  reset_node_growth_cache (node);\n \n-  /* See if there is something to do.  */\n   for (edge = node->callers; edge; edge = edge->next_caller)\n-    if (edge->inline_failed)\n-      break;\n-  if (!edge)\n-    return;\n-\n-  for (; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       {\n-\treset_edge_growth_cache (edge);\n-\tif (can_inline_edge_p (edge, false)\n-\t    && want_inline_small_function_p (edge, false))\n-          update_edge_key (heap, edge);\n-\telse if (edge->aux)\n+        if (!check_inlinablity_for\n+\t    || check_inlinablity_for == edge)\n \t  {\n-\t    report_inline_failed_reason (edge);\n-\t    fibheap_delete_node (heap, (fibnode_t) edge->aux);\n-\t    edge->aux = NULL;\n+\t    if (can_inline_edge_p (edge, false)\n+\t\t&& want_inline_small_function_p (edge, false))\n+\t      update_edge_key (heap, edge);\n+\t    else if (edge->aux)\n+\t      {\n+\t\treport_inline_failed_reason (edge);\n+\t\tfibheap_delete_node (heap, (fibnode_t) edge->aux);\n+\t\tedge->aux = NULL;\n+\t      }\n \t  }\n+\telse if (edge->aux)\n+\t  update_edge_key (heap, edge);\n       }\n }\n \n-/* Recompute heap nodes for each uninlined call.\n+/* Recompute HEAP nodes for each uninlined call in NODE.\n    This is used when we know that edge badnesses are going only to increase\n    (we introduced new call site) and thus all we need is to insert newly\n    created edges into heap.  */\n@@ -900,23 +950,30 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n {\n   struct cgraph_edge *e = node->callees;\n \n-  reset_node_growth_cache (node);\n-\n   if (!e)\n     return;\n   while (true)\n     if (!e->inline_failed && e->callee->callees)\n       e = e->callee->callees;\n     else\n       {\n-\treset_edge_growth_cache (e);\n+\t/* We inlined and thus callees might have different number of calls.\n+\t   Reset their caches  */\n+        reset_node_growth_cache (e->callee);\n \tif (e->inline_failed\n \t    && inline_summary (e->callee)->inlinable\n \t    && cgraph_function_body_availability (e->callee) >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, e->callee->uid))\n \t  {\n-\t    reset_node_growth_cache (node);\n-\t    update_edge_key (heap, e);\n+\t    if (can_inline_edge_p (e, false)\n+\t\t&& want_inline_small_function_p (e, false))\n+\t      update_edge_key (heap, e);\n+\t    else if (e->aux)\n+\t      {\n+\t\treport_inline_failed_reason (e);\n+\t\tfibheap_delete_node (heap, (fibnode_t) e->aux);\n+\t\te->aux = NULL;\n+\t      }\n \t  }\n \tif (e->next_callee)\n \t  e = e->next_callee;\n@@ -943,17 +1000,18 @@ update_all_callee_keys (fibheap_t heap, struct cgraph_node *node,\n {\n   struct cgraph_edge *e = node->callees;\n \n-  reset_node_growth_cache (node);\n-\n   if (!e)\n     return;\n   while (true)\n     if (!e->inline_failed && e->callee->callees)\n       e = e->callee->callees;\n     else\n       {\n+\t/* We inlined and thus callees might have different number of calls.\n+\t   Reset their caches  */\n+        reset_node_growth_cache (e->callee);\n \tif (e->inline_failed)\n-\t  update_caller_keys (heap, e->callee, updated_nodes);\n+\t  update_caller_keys (heap, e->callee, updated_nodes, e);\n \tif (e->next_callee)\n \t  e = e->next_callee;\n \telse\n@@ -1234,6 +1292,12 @@ inline_small_functions (void)\n       if (!edge->inline_failed)\n \tcontinue;\n \n+      /* Be sure that caches are maintained consistent.  */\n+#ifdef ENABLE_CHECKING\n+      reset_edge_growth_cache (edge);\n+      reset_node_growth_cache (edge->callee);\n+#endif\n+\n       /* When updating the edge costs, we only decrease badness in the keys.\n \t Increases of badness are handled lazilly; when we see key with out\n \t of date value on it, we re-insert it now.  */\n@@ -1302,6 +1366,7 @@ inline_small_functions (void)\n \t      edge->inline_failed = CIF_RECURSIVE_INLINING;\n \t      continue;\n \t    }\n+\t  reset_edge_caches (where);\n \t  /* Recursive inliner inlines all recursive calls of the function\n \t     at once. Consequently we need to update all callee keys.  */\n \t  if (flag_indirect_inlining)\n@@ -1344,6 +1409,9 @@ inline_small_functions (void)\n \t  if (flag_indirect_inlining)\n \t    add_new_edges_to_heap (heap, new_indirect_edges);\n \n+\t  reset_edge_caches (edge->callee);\n+          reset_node_growth_cache (callee);\n+\n \t  /* We inlined last offline copy to the body.  This might lead\n \t     to callees of function having fewer call sites and thus they\n \t     may need updating.  */\n@@ -1362,12 +1430,12 @@ inline_small_functions (void)\n \t inlined into (since it's body size changed) and for the functions\n \t called by function we inlined (since number of it inlinable callers\n \t might change).  */\n-      update_caller_keys (heap, where, updated_nodes);\n+      update_caller_keys (heap, where, updated_nodes, NULL);\n \n       /* We removed one call of the function we just inlined.  If offline\n \t copy is still needed, be sure to update the keys.  */\n       if (callee != where && !callee->global.inlined_to)\n-        update_caller_keys (heap, callee, updated_nodes);\n+        update_caller_keys (heap, callee, updated_nodes, NULL);\n       bitmap_clear (updated_nodes);\n \n       if (dump_file)"}]}