{"sha": "6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVhZjNmOWVlYjdhYThlZGViNGE1NTk4N2VmN2U2YWIyMjkxOGY5Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-07-16T08:57:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-07-16T08:57:03Z"}, "message": "Simplify range location creation in C++ parser.\n\nMany places in the parser follow the same pattern of capturing the location\nof the last lexed token, either before or after lexing it, and then using\nthat as the end of a location range; this can be simplified by passing the\nlexer to make_location and grabbing the token location there.\n\n\t* parser.c (make_location): Add overload taking cp_lexer* as last\n\tparameter.\n\nFrom-SVN: r273516", "tree": {"sha": "d592b411dcc6fa62b4cce5f37f8ec9e93bbca082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d592b411dcc6fa62b4cce5f37f8ec9e93bbca082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e6c847fb8f90b1c119a677b81cfc294b13eb7772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c847fb8f90b1c119a677b81cfc294b13eb7772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6c847fb8f90b1c119a677b81cfc294b13eb7772"}], "stats": {"total": 75, "additions": 29, "deletions": 46}, "files": [{"sha": "c9091f523c54b99d0810ece53b551239eafe2682", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97", "patch": "@@ -1,5 +1,8 @@\n 2019-07-16  Jason Merrill  <jason@redhat.com>\n \n+\t* parser.c (make_location): Add overload taking cp_lexer* as last\n+\tparameter.\n+\n \t* parser.c (cp_parser_simple_type_specifier): Separate tentative\n \tparses for optional type-spec and CTAD.\n "}, {"sha": "1a5da1dd8e8b1e54a3efc9c9bb9c5e4d47b15ec6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6eaf3f9eeb7aa8edeb4a55987ef7e6ab22918f97", "patch": "@@ -773,6 +773,16 @@ cp_lexer_previous_token (cp_lexer *lexer)\n   return cp_lexer_token_at (lexer, tp);\n }\n \n+/* Overload for make_location, taking the lexer to mean the location of the\n+   previous token.  */\n+\n+static inline location_t\n+make_location (location_t caret, location_t start, cp_lexer *lexer)\n+{\n+  cp_token *t = cp_lexer_previous_token (lexer);\n+  return make_location (caret, start, t->location);\n+}\n+\n /* nonzero if we are presently saving tokens.  */\n \n static inline int\n@@ -7774,10 +7784,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t       ~~~^~~~~~~~~~~~~\n \t     where the caret is at the deref token, ranging from\n \t     the start of postfix_expression to the end of the access expr.  */\n-\t  location_t end_loc\n-\t    = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n \t  location_t combined_loc\n-\t    = make_location (input_location, start_loc, end_loc);\n+\t    = make_location (input_location, start_loc, parser->lexer);\n \t  protected_set_expr_location (postfix_expression, combined_loc);\n \t}\n     }\n@@ -8187,10 +8195,8 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t       ^~~~~~~~~~~~~~\n \t       with start == caret at the start of the \"alignof\"/\"sizeof\"\n \t       token, with the endpoint at the final closing paren.  */\n-\t    location_t finish_loc\n-\t      = cp_lexer_previous_token (parser->lexer)->location;\n \t    location_t compound_loc\n-\t      = make_location (start_loc, start_loc, finish_loc);\n+\t      = make_location (start_loc, start_loc, parser->lexer);\n \n \t    cp_expr ret_expr (ret);\n \t    ret_expr.set_location (compound_loc);\n@@ -8291,16 +8297,14 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \n \t    parser->type_definition_forbidden_message = saved_message;\n \n-\t    location_t finish_loc\n-\t      = cp_lexer_peek_token (parser->lexer)->location;\n \t    parens.require_close (parser);\n \n \t    /* Construct a location of the form:\n \t       noexcept (expr)\n \t       ^~~~~~~~~~~~~~~\n \t       with start == caret, finishing at the close-paren.  */\n \t    location_t noexcept_loc\n-\t      = make_location (start_loc, start_loc, finish_loc);\n+\t      = make_location (start_loc, start_loc, parser->lexer);\n \n \t    return cp_expr (finish_noexcept_expr (expr, tf_warning_or_error),\n \t\t\t    noexcept_loc);\n@@ -8351,15 +8355,13 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t  /* Consume the '&&' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Look for the identifier.  */\n-\t  location_t finish_loc\n-\t    = get_finish (cp_lexer_peek_token (parser->lexer)->location);\n \t  identifier = cp_parser_identifier (parser);\n \t  /* Construct a location of the form:\n \t       &&label\n \t       ^~~~~~~\n \t     with caret==start at the \"&&\", finish at the end of the label.  */\n \t  location_t combined_loc\n-\t    = make_location (start_loc, start_loc, finish_loc);\n+\t    = make_location (start_loc, start_loc, parser->lexer);\n \t  /* Create an expression representing the address.  */\n \t  expression = finish_label_address_expr (identifier, combined_loc);\n \t  if (cp_parser_non_integral_constant_expression (parser,\n@@ -8607,10 +8609,8 @@ cp_parser_has_attribute_expression (cp_parser *parser)\n      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      with start == caret at the start of the built-in token,\n      and with the endpoint at the final closing paren.  */\n-  location_t finish_loc\n-    = cp_lexer_previous_token (parser->lexer)->location;\n   location_t compound_loc\n-    = make_location (start_loc, start_loc, finish_loc);\n+    = make_location (start_loc, start_loc, parser->lexer);\n \n   cp_expr ret_expr (ret ? boolean_true_node : boolean_false_node);\n   ret_expr.set_location (compound_loc);\n@@ -8732,9 +8732,8 @@ cp_parser_new_expression (cp_parser* parser)\n                  ^~~~~~~~~~~~\n          with caret == start at the start of the \"new\" token, and the end\n          at the end of the final token we consumed.  */\n-      cp_token *end_tok = cp_lexer_previous_token (parser->lexer);\n-      location_t end_loc = get_finish (end_tok->location);\n-      location_t combined_loc = make_location (start_loc, start_loc, end_loc);\n+      location_t combined_loc = make_location (start_loc, start_loc,\n+\t\t\t\t\t       parser->lexer);\n \n       /* Create a representation of the new-expression.  */\n       ret = build_new (&placement, type, nelts, &initializer, global_scope_p,\n@@ -10501,10 +10500,9 @@ cp_parser_lambda_expression (cp_parser* parser)\n   insert_pending_capture_proxies ();\n \n   /* Update the lambda expression to a range.  */\n-  cp_token *end_tok = cp_lexer_previous_token (parser->lexer);\n   LAMBDA_EXPR_LOCATION (lambda_expr) = make_location (token->location,\n \t\t\t\t\t\t      token->location,\n-\t\t\t\t\t\t      end_tok->location);\n+\t\t\t\t\t\t      parser->lexer);\n \n   if (ok)\n     lambda_expr = build_lambda_object (lambda_expr);\n@@ -11147,11 +11145,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n     cp_parser_parse_tentatively (parser);\n   std_attrs = cp_parser_std_attribute_spec_seq (parser);\n   if (std_attrs)\n-    {\n-      location_t end_loc\n-\t= cp_lexer_previous_token (parser->lexer)->location;\n-      attrs_loc = make_location (attrs_loc, attrs_loc, end_loc);\n-    }\n+    attrs_loc = make_location (attrs_loc, attrs_loc, parser->lexer);\n   if (c_dialect_objc ())\n     {\n       if (!cp_parser_parse_definitely (parser))\n@@ -15529,10 +15523,8 @@ cp_parser_operator (cp_parser* parser, location_t start_loc)\n \t     ^~~~~~~~~~~~~~~~~~~~~\n \t   with caret == start at the start token, finish at the end of the\n \t   suffix identifier.  */\n-\tlocation_t finish_loc\n-\t  = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n \tlocation_t combined_loc\n-\t  = make_location (start_loc, start_loc, finish_loc);\n+\t  = make_location (start_loc, start_loc, parser->lexer);\n \treturn cp_expr (id, combined_loc);\n       }\n \n@@ -16454,10 +16446,8 @@ cp_parser_template_id (cp_parser *parser,\n      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      with caret == start at the start of the template-name,\n      ranging until the closing '>'.  */\n-  location_t finish_loc\n-    = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n   location_t combined_loc\n-    = make_location (token->location, token->location, finish_loc);\n+    = make_location (token->location, token->location, parser->lexer);\n \n   /* Check for concepts autos where they don't belong.  We could\n      identify types in some cases of idnetifier TEMPL, looking ahead\n@@ -28567,10 +28557,8 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n \t    ^~~~~~~~~~~~~~~\n \t with caret == start at the start of the type name,\n \t finishing at the closing brace.  */\n-      location_t finish_loc\n-\t= get_finish (cp_lexer_previous_token (parser->lexer)->location);\n       location_t combined_loc = make_location (start_loc, start_loc,\n-\t\t\t\t\t       finish_loc);\n+\t\t\t\t\t       parser->lexer);\n       cast.set_location (combined_loc);\n       return cast;\n    }\n@@ -28605,9 +28593,7 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n        ^~~~~~~~\n      with caret == start at the start of the type name,\n      finishing at the closing paren.  */\n-  location_t finish_loc\n-    = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n-  location_t combined_loc = make_location (start_loc, start_loc, finish_loc);\n+  location_t combined_loc = make_location (start_loc, start_loc, parser->lexer);\n   cast.set_location (combined_loc);\n   return cast;\n }\n@@ -30652,9 +30638,7 @@ cp_parser_objc_encode_expression (cp_parser* parser)\n        @encode(int)\n        ^~~~~~~~~~~~\n      with caret==start at the @ token, finishing at the close paren.  */\n-  location_t combined_loc\n-    = make_location (start_loc, start_loc,\n-                     cp_lexer_previous_token (parser->lexer)->location);\n+  location_t combined_loc = make_location (start_loc, start_loc, parser->lexer);\n \n   return cp_expr (objc_build_encode_expr (type), combined_loc);\n }\n@@ -30698,9 +30682,7 @@ cp_parser_objc_protocol_expression (cp_parser* parser)\n        @protocol(prot)\n        ^~~~~~~~~~~~~~~\n      with caret==start at the @ token, finishing at the close paren.  */\n-  location_t combined_loc\n-    = make_location (start_loc, start_loc,\n-                     cp_lexer_previous_token (parser->lexer)->location);\n+  location_t combined_loc = make_location (start_loc, start_loc, parser->lexer);\n   tree result = objc_build_protocol_expr (proto);\n   protected_set_expr_location (result, combined_loc);\n   return result;\n@@ -30785,9 +30767,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n        @selector(func)\n        ^~~~~~~~~~~~~~~\n      with caret==start at the @ token, finishing at the close paren.  */\n-  location_t combined_loc\n-    = make_location (loc, loc,\n-                     cp_lexer_previous_token (parser->lexer)->location);\n+  location_t combined_loc = make_location (loc, loc, parser->lexer);\n   tree result = objc_build_selector_expr (combined_loc, sel_seq);\n   /* TODO: objc_build_selector_expr doesn't always honor the location.  */\n   protected_set_expr_location (result, combined_loc);"}]}