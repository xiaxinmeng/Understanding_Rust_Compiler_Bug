{"sha": "15c151967dd1cde61b79d26374f608f63a29d411", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVjMTUxOTY3ZGQxY2RlNjFiNzlkMjYzNzRmNjA4ZjYzYTI5ZDQxMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-06-28T13:17:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-06-28T13:17:20Z"}, "message": "tree-ssa-structalias.c (callused_id, [...]): Add.\n\n2008-06-28  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (callused_id, var_callused,\n\tcallused_tree): Add.\n\t(handle_pure_call): New function.\n\t(find_func_aliases): Call it.\n\t(find_what_p_points_to): Handle the call-used set.\n\t(clobber_what_escaped): Likewise.\n\t(compute_call_used_vars): New function.\n\t(init_base_vars): Init the call-used variable.\n\t(do_sd_constraint): Do not propagate the solution from CALLUSED\n\tbut use CALLUSED as a placeholder.\n\t(solve_graph): Likewise.\n\t* tree-flow-inline.h (gimple_call_used_vars): New function.\n\t* tree-flow.h (struct gimple_df): Add call_used_vars bitmap.\n\t(compute_call_used_vars): Declare.\n\t* tree-ssa-alias.c (set_initial_properties): Call\n\tcompute_call_used_vars.\n\t(reset_alias_info): Clear call-used variables.\n\t(add_call_clobber_ops): Assert we are not called for const/pure\n\tfunctions.  Remove handling of them.\n\t(add_call_read_ops): Handle pure functions by adding the\n\tcall-used set of variables as VUSEs.\n\t* tree-ssa.c (init_tree_ssa): Allocate call-used bitmap.\n\t(delete_tree_ssa): Free it.\n\t* tree-dfa.c (remove_referenced_var): Clear the var from the\n\tcall-used bitmap.\n\n\t* gcc.dg/tree-ssa/pr24287.c: Remove XFAIL.\n\nFrom-SVN: r137222", "tree": {"sha": "c154f74717a3c268c9eb1d50886dc65b0a3c38db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c154f74717a3c268c9eb1d50886dc65b0a3c38db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15c151967dd1cde61b79d26374f608f63a29d411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c151967dd1cde61b79d26374f608f63a29d411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15c151967dd1cde61b79d26374f608f63a29d411", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c151967dd1cde61b79d26374f608f63a29d411/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff1c393bd32f3b018957ba9f552e344ab040f309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff1c393bd32f3b018957ba9f552e344ab040f309", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff1c393bd32f3b018957ba9f552e344ab040f309"}], "stats": {"total": 284, "additions": 249, "deletions": 35}, "files": [{"sha": "8a53395b23f5a73a2e6b7bac3995d0cb1a789566", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -1,3 +1,31 @@\n+2008-06-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (callused_id, var_callused,\n+\tcallused_tree): Add.\n+\t(handle_pure_call): New function.\n+\t(find_func_aliases): Call it.\n+\t(find_what_p_points_to): Handle the call-used set.\n+\t(clobber_what_escaped): Likewise.\n+\t(compute_call_used_vars): New function.\n+\t(init_base_vars): Init the call-used variable.\n+\t(do_sd_constraint): Do not propagate the solution from CALLUSED\n+\tbut use CALLUSED as a placeholder.\n+\t(solve_graph): Likewise.\n+\t* tree-flow-inline.h (gimple_call_used_vars): New function.\n+\t* tree-flow.h (struct gimple_df): Add call_used_vars bitmap.\n+\t(compute_call_used_vars): Declare.\n+\t* tree-ssa-alias.c (set_initial_properties): Call\n+\tcompute_call_used_vars.\n+\t(reset_alias_info): Clear call-used variables.\n+\t(add_call_clobber_ops): Assert we are not called for const/pure\n+\tfunctions.  Remove handling of them.\n+\t(add_call_read_ops): Handle pure functions by adding the\n+\tcall-used set of variables as VUSEs.\n+\t* tree-ssa.c (init_tree_ssa): Allocate call-used bitmap.\n+\t(delete_tree_ssa): Free it.\n+\t* tree-dfa.c (remove_referenced_var): Clear the var from the\n+\tcall-used bitmap.\n+\n 2008-06-28  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* tree.c (build_varargs_function_type_list): New."}, {"sha": "e3f8556acacc617ae005660758b0d013c00e5599", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -1,3 +1,7 @@\n+2008-06-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/pr24287.c: Remove XFAIL.\n+\n 2008-06-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/abi/arm_cxa_vec2.C: New test."}, {"sha": "63120457c4de8dfce2f2a89f2048d5a74da13f8a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr24287.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24287.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24287.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr24287.c?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -21,5 +21,5 @@ int g(void)\n     link_error ();\n   return t2 == 2;\n }\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "285af39b3cadbc020d78090bed1269907e0168bc", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -746,6 +746,7 @@ remove_referenced_var (tree var)\n   unsigned int uid = DECL_UID (var);\n \n   clear_call_clobbered (var);\n+  bitmap_clear_bit (gimple_call_used_vars (cfun), uid);\n   if ((v_ann = var_ann (var)))\n     {\n       /* Preserve var_anns of globals, but clear their alias info.  */"}, {"sha": "bff697db5ae089a9478a1756f10ea0b9950dfc69", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -66,6 +66,15 @@ gimple_call_clobbered_vars (const struct function *fun)\n   return fun->gimple_df->call_clobbered_vars;\n }\n \n+/* Call-used variables in the function.  If bit I is set, then\n+   REFERENCED_VARS (I) is call-used at pure function call-sites.  */\n+static inline bitmap\n+gimple_call_used_vars (const struct function *fun)\n+{\n+  gcc_assert (fun && fun->gimple_df);\n+  return fun->gimple_df->call_used_vars;\n+}\n+\n /* Array of all variables referenced in the function.  */\n static inline htab_t\n gimple_referenced_vars (const struct function *fun)"}, {"sha": "961054703dba5414ee0f7064ffef2de38c2d943b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -162,6 +162,10 @@ struct gimple_df GTY(())\n      REFERENCED_VARS (I) is call-clobbered.  */\n   bitmap call_clobbered_vars;\n \n+  /* Call-used variables in the function.  If bit I is set, then\n+     REFERENCED_VARS (I) is call-used at pure function call-sites.  */\n+  bitmap call_used_vars;\n+\n   /* Addressable variables in the function.  If bit I is set, then\n      REFERENCED_VARS (I) has had its address taken.  Note that\n      CALL_CLOBBERED_VARS and ADDRESSABLE_VARS are not related.  An\n@@ -1174,6 +1178,7 @@ tree gimple_fold_indirect_ref (tree);\n /* In tree-ssa-structalias.c */\n bool find_what_p_points_to (tree);\n bool clobber_what_escaped (void);\n+void compute_call_used_vars (void);\n \n /* In tree-ssa-live.c */\n extern void remove_unused_locals (void);"}, {"sha": "9a6552bb9d5006fbfa0a05def2c3b4459d6c1780", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -505,7 +505,7 @@ compute_tag_properties (void)\n   VEC_free (tree, heap, taglist);\n }\n \n-/* Set up the initial variable clobbers and globalness.\n+/* Set up the initial variable clobbers, call-uses and globalness.\n    When this function completes, only tags whose aliases need to be\n    clobbered will be set clobbered.  Tags clobbered because they   \n    contain call clobbered vars are handled in compute_tag_properties.  */\n@@ -543,6 +543,8 @@ set_initial_properties (struct alias_info *ai)\n       pt_anything_mask |= ESCAPE_TO_CALL;\n     }\n \n+  compute_call_used_vars ();\n+\n   for (i = 0; VEC_iterate (tree, ai->processed_ptrs, i, ptr); i++)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n@@ -2000,6 +2002,9 @@ reset_alias_info (void)\n   /* There should be no call-clobbered variable left.  */\n   gcc_assert (bitmap_empty_p (gimple_call_clobbered_vars (cfun)));\n \n+  /* Clear the call-used variables.  */\n+  bitmap_clear (gimple_call_used_vars (cfun));\n+\n   /* Clear flow-sensitive points-to information from each SSA name.  */\n   for (i = 1; i < num_ssa_names; i++)\n     {"}, {"sha": "0aeea9f7f93c244876e32e21eb134bb023d2a81c", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -1660,7 +1660,10 @@ add_call_clobber_ops (tree stmt, tree callee)\n   bitmap_iterator bi;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n   bitmap not_read_b, not_written_b;\n-  \n+  tree call = get_call_expr_in (stmt);\n+\n+  gcc_assert (!(call_expr_flags (call) & (ECF_PURE | ECF_CONST)));\n+\n   /* If we created .GLOBAL_VAR earlier, just use it.  */\n   if (gimple_global_var (cfun))\n     {\n@@ -1674,12 +1677,10 @@ add_call_clobber_ops (tree stmt, tree callee)\n      or write that variable.  */\n   not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n   not_written_b = callee ? ipa_reference_get_not_written_global (callee) : NULL; \n-\n   /* Add a VDEF operand for every call clobbered variable.  */\n   EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, u, bi)\n     {\n       tree var = referenced_var_lookup (u);\n-      unsigned int escape_mask = var_ann (var)->escape_mask;\n       tree real_var = var;\n       bool not_read;\n       bool not_written;\n@@ -1697,24 +1698,6 @@ add_call_clobber_ops (tree stmt, tree callee)\n \n       /* See if this variable is really clobbered by this function.  */\n \n-      /* Trivial case: Things escaping only to pure/const are not\n-\t clobbered by non-pure-const, and only read by pure/const. */\n-      if ((escape_mask & ~(ESCAPE_TO_PURE_CONST)) == 0)\n-\t{\n-\t  tree call = get_call_expr_in (stmt);\n-\t  if (call_expr_flags (call) & (ECF_CONST | ECF_PURE))\n-\t    {\n-\t      add_virtual_operand (var, s_ann, opf_use, NULL, 0, -1, true);\n-\t      clobber_stats.unescapable_clobbers_avoided++;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      clobber_stats.unescapable_clobbers_avoided++;\n-\t      continue;\n-\t    }\n-\t}\n-            \n       if (not_written)\n \t{\n \t  clobber_stats.static_write_clobbers_avoided++;\n@@ -1739,18 +1722,47 @@ add_call_read_ops (tree stmt, tree callee)\n   bitmap_iterator bi;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n   bitmap not_read_b;\n+  tree call = get_call_expr_in (stmt);\n+\n+  /* Const functions do not reference memory.  */\n+  if (call_expr_flags (call) & ECF_CONST)\n+    return;\n \n-  /* if the function is not pure, it may reference memory.  Add\n-     a VUSE for .GLOBAL_VAR if it has been created.  See add_referenced_var\n-     for the heuristic used to decide whether to create .GLOBAL_VAR.  */\n+  not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL;\n+\n+  /* For pure functions we compute non-escaped uses separately.  */\n+  if (call_expr_flags (call) & ECF_PURE)\n+    EXECUTE_IF_SET_IN_BITMAP (gimple_call_used_vars (cfun), 0, u, bi)\n+      {\n+\ttree var = referenced_var_lookup (u);\n+\ttree real_var = var;\n+\tbool not_read;\n+\n+\tif (unmodifiable_var_p (var))\n+\t  continue;\n+\n+\tnot_read = not_read_b\n+\t    ? bitmap_bit_p (not_read_b, DECL_UID (real_var))\n+\t    : false;\n+\n+\tclobber_stats.readonly_clobbers++;\n+\n+\t/* See if this variable is really used by this function.  */\n+\tif (!not_read)\n+\t  add_virtual_operand (var, s_ann, opf_use, NULL, 0, -1, true);\n+\telse\n+\t  clobber_stats.static_readonly_clobbers_avoided++;\n+      }\n+\n+  /* Add a VUSE for .GLOBAL_VAR if it has been created.  See\n+     add_referenced_var for the heuristic used to decide whether to\n+     create .GLOBAL_VAR.  */\n   if (gimple_global_var (cfun))\n     {\n       tree var = gimple_global_var (cfun);\n       add_virtual_operand (var, s_ann, opf_use, NULL, 0, -1, true);\n       return;\n     }\n-  \n-  not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n \n   /* Add a VUSE for each call-clobbered variable.  */\n   EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, u, bi)"}, {"sha": "4a3896bc4406e68562a22caf64d6f8d5813d8f42", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 155, "deletions": 7, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -296,7 +296,7 @@ get_varinfo_fc (unsigned int n)\n \n /* Static IDs for the special variables.  */\n enum { nothing_id = 0, anything_id = 1, readonly_id = 2,\n-       escaped_id = 3, nonlocal_id = 4, integer_id = 5 };\n+       escaped_id = 3, nonlocal_id = 4, callused_id = 5, integer_id = 6 };\n \n /* Variable that represents the unknown pointer.  */\n static varinfo_t var_anything;\n@@ -318,6 +318,10 @@ static tree escaped_tree;\n static varinfo_t var_nonlocal;\n static tree nonlocal_tree;\n \n+/* Variable that represents call-used memory.  */\n+static varinfo_t var_callused;\n+static tree callused_tree;\n+\n /* Variable that represents integers.  This is used for when people do things\n    like &0->a.b.  */\n static varinfo_t var_integer;\n@@ -1429,11 +1433,13 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  if (get_varinfo (t)->is_special_var)\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \t  /* Merging the solution from ESCAPED needlessly increases\n-\t     the set.  Use ESCAPED as representative instead.  */\n-\t  else if (get_varinfo (t)->id == escaped_id\n+\t     the set.  Use ESCAPED as representative instead.\n+\t     Same for CALLUSED.  */\n+\t  else if ((get_varinfo (t)->id == escaped_id\n+\t\t    || get_varinfo (t)->id == callused_id)\n \t\t   && !bitmap_bit_p (sol, get_varinfo (t)->id))\n \t    {\n-\t      bitmap_set_bit (sol, escaped_id);\n+\t      bitmap_set_bit (sol, get_varinfo (t)->id);\n \t      flag = true;\n \t    }\n \t  else if (add_graph_edge (graph, lhs, t))\n@@ -2369,8 +2375,9 @@ solve_graph (constraint_graph_t graph)\n \t      solution_empty = bitmap_empty_p (solution);\n \n \t      if (!solution_empty\n-\t\t  /* Do not propagate the ESCAPED solution.  */\n-\t\t  && i != escaped_id)\n+\t\t  /* Do not propagate the ESCAPED/CALLUSED solutions.  */\n+\t\t  && i != escaped_id\n+\t\t  && i != callused_id)\n \t\t{\n \t\t  bitmap_iterator bi;\n \n@@ -3702,6 +3709,61 @@ handle_const_call (tree stmt)\n   VEC_free (ce_s, heap, lhsc);\n }\n \n+/* For non-IPA mode, generate constraints necessary for a call to a\n+   pure function in statement STMT.  */\n+\n+static void\n+handle_pure_call (tree stmt)\n+{\n+  tree call = get_call_expr_in (stmt);\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+\n+  /* Memory reached from pointer arguments is call-used.  */\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+    if (could_have_pointers (arg))\n+      make_constraint_to (callused_id, arg);\n+\n+  /* The static chain is used as well.  */\n+  if (CALL_EXPR_STATIC_CHAIN (call))\n+    make_constraint_to (callused_id, CALL_EXPR_STATIC_CHAIN (call));\n+\n+  /* If the call returns a pointer it may point to reachable memory\n+     from the arguments.  */\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+      && could_have_pointers (GIMPLE_STMT_OPERAND (stmt, 0)))\n+    {\n+      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      VEC(ce_s, heap) *lhsc = NULL;\n+      struct constraint_expr rhsc;\n+      struct constraint_expr *lhsp;\n+      unsigned j;\n+\n+      get_constraint_for (lhs, &lhsc);\n+\n+      /* If this is a nested function then it can return anything.  */\n+      if (CALL_EXPR_STATIC_CHAIN (call))\n+\t{\n+\t  rhsc.var = anything_id;\n+\t  rhsc.offset = 0;\n+\t  rhsc.type = ADDRESSOF;\n+\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\t    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+\t  VEC_free (ce_s, heap, lhsc);\n+\t  return;\n+\t}\n+\n+      /* Else just add the call-used memory here.  Escaped variables\n+         and globals will be dealt with in handle_lhs_call.  */\n+      rhsc.var = callused_id;\n+      rhsc.offset = 0;\n+      rhsc.type = ADDRESSOF;\n+      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\tprocess_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+      VEC_free (ce_s, heap, lhsc);\n+    }\n+}\n+\n /* Walk statement T setting up aliasing constraints according to the\n    references found in T.  This function is the main part of the\n    constraint builder.  AI points to auxiliary alias information used\n@@ -3778,6 +3840,13 @@ find_func_aliases (tree origt)\n \t\t  && could_have_pointers (GIMPLE_STMT_OPERAND (t, 1)))\n \t\thandle_const_call (t);\n \t    }\n+\t  else if (flags & ECF_PURE)\n+\t    {\n+\t      handle_pure_call (t);\n+\t      if (TREE_CODE (t) == GIMPLE_MODIFY_STMT\n+\t\t  && could_have_pointers (GIMPLE_STMT_OPERAND (t, 1)))\n+\t\thandle_lhs_call (GIMPLE_STMT_OPERAND (t, 0));\n+\t    }\n \t  /* Pure functions can return addresses in and of memory\n \t     reachable from their arguments, but they are not an escape\n \t     point for reachable memory of their arguments.  But as we\n@@ -4940,7 +5009,8 @@ find_what_p_points_to (tree p)\n \t\t    pi->pt_null = 1;\n \t\t  else if (vi->id == anything_id\n \t\t\t   || vi->id == nonlocal_id\n-\t\t\t   || vi->id == escaped_id)\n+\t\t\t   || vi->id == escaped_id\n+\t\t\t   || vi->id == callused_id)\n \t\t    was_pt_anything = 1;\n \t\t  else if (vi->id == readonly_id)\n \t\t    was_pt_anything = 1;\n@@ -5007,6 +5077,15 @@ clobber_what_escaped (void)\n      variable for escaped_id.  */\n   vi = get_varinfo (find (escaped_id));\n \n+  /* If call-used memory escapes we need to include it in the\n+     set of escaped variables.  This can happen if a pure\n+     function returns a pointer and this pointer escapes.  */\n+  if (bitmap_bit_p (vi->solution, callused_id))\n+    {\n+      varinfo_t cu_vi = get_varinfo (find (callused_id));\n+      bitmap_ior_into (vi->solution, cu_vi->solution);\n+    }\n+\n   /* Mark variables in the solution call-clobbered.  */\n   EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n     {\n@@ -5036,6 +5115,54 @@ clobber_what_escaped (void)\n   return true;\n }\n \n+/* Compute the call-used variables.  */\n+\n+void\n+compute_call_used_vars (void)\n+{\n+  varinfo_t vi;\n+  unsigned int i;\n+  bitmap_iterator bi;\n+  bool has_anything_id = false;\n+\n+  if (!have_alias_info)\n+    return;\n+\n+  /* This variable may have been collapsed, let's get the real\n+     variable for escaped_id.  */\n+  vi = get_varinfo (find (callused_id));\n+\n+  /* Mark variables in the solution call-clobbered.  */\n+  EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n+    {\n+      varinfo_t vi = get_varinfo (i);\n+\n+      if (vi->is_artificial_var)\n+\t{\n+\t  /* For anything_id and integer_id we need to make\n+\t     all local addressable vars call-used.  */\n+\t  if (vi->id == anything_id\n+\t      || vi->id == integer_id)\n+\t    has_anything_id = true;\n+\t}\n+\n+      /* Only artificial heap-vars are further interesting.  */\n+      if (vi->is_artificial_var && !vi->is_heap_var)\n+\tcontinue;\n+\n+      if ((TREE_CODE (vi->decl) == VAR_DECL\n+\t   || TREE_CODE (vi->decl) == PARM_DECL\n+\t   || TREE_CODE (vi->decl) == RESULT_DECL)\n+\t  && !unmodifiable_var_p (vi->decl))\n+\tbitmap_set_bit (gimple_call_used_vars (cfun), DECL_UID (vi->decl));\n+    }\n+\n+  /* If anything is call-used, add all addressable locals to the set.  */\n+  if (has_anything_id)\n+    bitmap_ior_into (gimple_call_used_vars (cfun),\n+\t\t     gimple_addressable_vars (cfun));\n+}\n+\n \n /* Dump points-to information to OUTFILE.  */\n \n@@ -5193,6 +5320,27 @@ init_base_vars (void)\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n \n+  /* Create the CALLUSED variable, used to represent the set of call-used\n+     memory.  */\n+  callused_tree = create_tmp_var_raw (void_type_node, \"CALLUSED\");\n+  var_callused = new_var_info (callused_tree, callused_id, \"CALLUSED\");\n+  insert_vi_for_tree (callused_tree, var_callused);\n+  var_callused->is_artificial_var = 1;\n+  var_callused->offset = 0;\n+  var_callused->size = ~0;\n+  var_callused->fullsize = ~0;\n+  var_callused->is_special_var = 0;\n+  VEC_safe_push (varinfo_t, heap, varmap, var_callused);\n+\n+  /* CALLUSED = *CALLUSED, because call-used is may-deref'd at calls, etc.  */\n+  lhs.type = SCALAR;\n+  lhs.var = callused_id;\n+  lhs.offset = 0;\n+  rhs.type = DEREF;\n+  rhs.var = callused_id;\n+  rhs.offset = 0;\n+  process_constraint_1 (new_constraint (lhs, rhs), true);\n+\n   /* Create the INTEGER variable, used to represent that a variable points\n      to an INTEGER.  */\n   integer_tree = create_tmp_var_raw (void_type_node, \"INTEGER\");"}, {"sha": "7f567b57a2ed1d3594ba9d3870e2f5f88d024fe5", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c151967dd1cde61b79d26374f608f63a29d411/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=15c151967dd1cde61b79d26374f608f63a29d411", "patch": "@@ -937,6 +937,7 @@ init_tree_ssa (struct function *fn)\n   fn->gimple_df->default_defs = htab_create_ggc (20, uid_ssaname_map_hash, \n \t\t\t\t                 uid_ssaname_map_eq, NULL);\n   fn->gimple_df->call_clobbered_vars = BITMAP_GGC_ALLOC ();\n+  fn->gimple_df->call_used_vars = BITMAP_GGC_ALLOC ();\n   fn->gimple_df->addressable_vars = BITMAP_GGC_ALLOC ();\n   init_ssanames (fn, 0);\n   init_phinodes ();\n@@ -1009,6 +1010,7 @@ delete_tree_ssa (void)\n   htab_delete (cfun->gimple_df->default_defs);\n   cfun->gimple_df->default_defs = NULL;\n   cfun->gimple_df->call_clobbered_vars = NULL;\n+  cfun->gimple_df->call_used_vars = NULL;\n   cfun->gimple_df->addressable_vars = NULL;\n   cfun->gimple_df->modified_noreturn_calls = NULL;\n   if (gimple_aliases_computed_p (cfun))"}]}