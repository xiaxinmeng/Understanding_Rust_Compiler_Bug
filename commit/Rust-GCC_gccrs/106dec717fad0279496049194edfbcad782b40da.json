{"sha": "106dec717fad0279496049194edfbcad782b40da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA2ZGVjNzE3ZmFkMDI3OTQ5NjA0OTE5NGVkZmJjYWQ3ODJiNDBkYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-11-09T00:09:43Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-09T00:09:43Z"}, "message": "re PR tree-optimization/29738 (Missed constant propagation into loops)\n\n\tPR tree-optimization/29738\n\t* tree-ssa-ccp.c: Remove UNKNOWN_VAL from comments.\n\t(ccp_lattice_t): Remove UNKNOWN_VAL.\n\t(dump_lattice_value, ccp_lattice_meet, ccp_visit_phi_node):\n\tDo not handle UNKNOWN_VAL.\n\t(get_default_value): Set initial value of virtual operands to\n\tVARYING.\n\t(get_value): Always use get_default_value on uninitialized\n\toperands.\n\t(set_value_varying, surely_varying_stmt_p): New functions.\n\t(set_lattice_value): Do not pass argument to get_value.\n\tDo not handle UNKNOWN_VAL.\n\t(likely_value): Follow the semantics described in the comment.\n\t(ccp_initialize): Use surely_varying_stmt_p.  Do not mark\n\tphi nodes DONT_SIMULATE_AGAIN.\n\t(ccp_fold): Do not pass argument to get_value.\n\t(fold_const_aggregate_ref, visit_assignment): Ditto.  Do not\n\thandle UNKNOWN_VAL.\n\n\t* gcc.dg/tree-ssa/ssa-ccp-14.c: New test.\n\t* gcc.dg/tree-ssa/ssa-ccp-15.c: New test.\n\nFrom-SVN: r118602", "tree": {"sha": "f954bb3cfcd6ce1c81fbe5f7585478ecdae6ff10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f954bb3cfcd6ce1c81fbe5f7585478ecdae6ff10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/106dec717fad0279496049194edfbcad782b40da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106dec717fad0279496049194edfbcad782b40da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106dec717fad0279496049194edfbcad782b40da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106dec717fad0279496049194edfbcad782b40da/comments", "author": null, "committer": null, "parents": [{"sha": "5e3c2d4c683546748ea64ac2904e1fcc40300d64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3c2d4c683546748ea64ac2904e1fcc40300d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e3c2d4c683546748ea64ac2904e1fcc40300d64"}], "stats": {"total": 396, "additions": 217, "deletions": 179}, "files": [{"sha": "549d5bc864d37fb1a2128b384737083cfe78ab99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106dec717fad0279496049194edfbcad782b40da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106dec717fad0279496049194edfbcad782b40da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=106dec717fad0279496049194edfbcad782b40da", "patch": "@@ -1,3 +1,24 @@\n+2006-11-08  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/29738\n+\t* tree-ssa-ccp.c: Remove UNKNOWN_VAL from comments.\n+\t(ccp_lattice_t): Remove UNKNOWN_VAL.\n+\t(dump_lattice_value, ccp_lattice_meet, ccp_visit_phi_node):\n+\tDo not handle UNKNOWN_VAL.\n+\t(get_default_value): Set initial value of virtual operands to\n+\tVARYING.\n+\t(get_value): Always use get_default_value on uninitialized\n+\toperands.\n+\t(set_value_varying, surely_varying_stmt_p): New functions.\n+\t(set_lattice_value): Do not pass argument to get_value.\n+\tDo not handle UNKNOWN_VAL.\n+\t(likely_value): Follow the semantics described in the comment.\n+\t(ccp_initialize): Use surely_varying_stmt_p.  Do not mark\n+\tphi nodes DONT_SIMULATE_AGAIN.\n+\t(ccp_fold): Do not pass argument to get_value.\n+\t(fold_const_aggregate_ref, visit_assignment): Ditto.  Do not\n+\thandle UNKNOWN_VAL.\n+\n 2006-11-08  Andrew Pinski  <Andrew_Pinski@playstation.sony.com>\n \n \t* tree-pretty-print.c (dump_generic_node) <INTEGER_CST>: Use "}, {"sha": "4c2bc3a56f1c8e71e1ae59a8068597763ddcea38", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=106dec717fad0279496049194edfbcad782b40da", "patch": "@@ -1,3 +1,8 @@\n+2006-11-08  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/ssa-ccp-14.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-ccp-15.c: New test.\n+\n 2006-11-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-math-3.c: Add more sincos tests."}, {"sha": "6e0a8f14478643b6b27a69c960728d21314ce239", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-14.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-14.c?ref=106dec717fad0279496049194edfbcad782b40da", "patch": "@@ -0,0 +1,21 @@\n+/* PR tree-optimization/29738.  We used not to realize that \"i\" can never\n+   become nonzero.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int i;\n+\n+void foo (void);\n+void bar (void)\n+{\n+  int j;\n+  i = 0;\n+  for (j = 0; j < 10000; j++)\n+    if (i)\n+      foo ();\n+}\n+\n+/* Everything except for the \"i = 0\" assignment should get removed.  */\n+/* { dg-final { scan-tree-dump-times \"if\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "aaf57126a64556e26d9dd5354176ad49a6c8ca27", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-15.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-15.c?ref=106dec717fad0279496049194edfbcad782b40da", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+/* Check that the initial values are honored when necessary.  */\n+\n+void link_error (void);\n+\n+/* The call to link_error cannot be eliminated in this case.  */\n+\n+void test1 (int param1, int param2, int x)\n+{\n+  if (param1)\n+    x = 3;\n+\n+  if (param2)\n+    if (x != 3)\n+      link_error ();\n+}\n+\n+/* The call to link_error cannot be eliminated in this case.  */\n+\n+int global;\n+void test2 (int param1, int param2)\n+{\n+  if (param1)\n+    global = 3;\n+\n+  if (param2)\n+    if (global != 3)\n+      link_error ();\n+}\n+\n+/* In this case, we can eliminate the call, as unless \"local\" is set\n+   to 3, its value is undefined.  */\n+\n+void test3 (int param1, int param2)\n+{\n+  int local;\n+\n+  if (param1)\n+    local = 3;\n+\n+  if (param2)\n+    if (local != 3)\n+      link_error ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"link_error\" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ca9647130dee0e1f77c26c0b60c9a5a31a156998", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 121, "deletions": 179, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106dec717fad0279496049194edfbcad782b40da/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=106dec717fad0279496049194edfbcad782b40da", "patch": "@@ -29,8 +29,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    with SSA names.  Given an SSA name V_i, it may take one of the\n    following values:\n \n-   \tUNINITIALIZED\t->  This is the default starting value.  V_i\n-\t\t\t    has not been processed yet.\n+\tUNINITIALIZED   ->  the initial state of the value.  This value\n+\t\t\t    is replaced with a correct initial value\n+\t\t\t    the first time the value is used, so the\n+\t\t\t    rest of the pass does not need to care about\n+\t\t\t    it.  Using this value simplifies initialization\n+\t\t\t    of the pass, and prevents us from needlessly\n+\t\t\t    scanning statements that are never reached.\n \n \tUNDEFINED\t->  V_i is a local variable whose definition\n \t\t\t    has not been processed yet.  Therefore we\n@@ -143,11 +148,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    it would be wrong to replace the load from 'a.b' with '2', because\n    '2' had been stored into a.a.\n \n-   To support STORE-CCP, it is necessary to add a new value to the\n-   constant propagation lattice.  When evaluating a load for a memory\n-   reference we can no longer assume a value of UNDEFINED if we\n-   haven't seen a preceding store to the same memory location.\n-   Consider, for instance global variables:\n+   Note that the initial value of virtual operands is VARYING, not\n+   UNDEFINED.  Consider, for instance global variables:\n \n    \tint A;\n \n@@ -165,10 +167,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n    The value of A_2 cannot be assumed to be UNDEFINED, as it may have\n    been defined outside of foo.  If we were to assume it UNDEFINED, we\n-   would erroneously optimize the above into 'return 3;'.  Therefore,\n-   when doing STORE-CCP, we introduce a fifth lattice value\n-   (UNKNOWN_VAL), which overrides any other value when computing the\n-   meet operation in PHI nodes.\n+   would erroneously optimize the above into 'return 3;'.\n \n    Though STORE-CCP is not too expensive, it does have to do more work\n    than regular CCP, so it is only enabled at -O2.  Both regular CCP\n@@ -214,9 +213,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Possible lattice values.  */\n typedef enum\n {\n-  UNINITIALIZED = 0,\n+  UNINITIALIZED,\n   UNDEFINED,\n-  UNKNOWN_VAL,\n   CONSTANT,\n   VARYING\n } ccp_lattice_t;\n@@ -248,9 +246,6 @@ dump_lattice_value (FILE *outf, const char *prefix, prop_value_t val)\n     case VARYING:\n       fprintf (outf, \"%sVARYING\", prefix);\n       break;\n-    case UNKNOWN_VAL:\n-      fprintf (outf, \"%sUNKNOWN_VAL\", prefix);\n-      break;\n     case CONSTANT:\n       fprintf (outf, \"%sCONSTANT \", prefix);\n       print_generic_expr (outf, val.value, dump_flags);\n@@ -317,17 +312,15 @@ ccp_decl_initial_min_invariant (tree t)\n    4- Variables defined by statements other than assignments and PHI\n       nodes are considered VARYING.\n \n-   5- Variables that are not GIMPLE registers are considered\n-      UNKNOWN_VAL, which is really a stronger version of UNDEFINED.\n-      It's used to avoid the short circuit evaluation implied by\n-      UNDEFINED in ccp_lattice_meet.  */\n+   5- Initial values of variables that are not GIMPLE registers are\n+      considered VARYING.  */\n \n static prop_value_t\n get_default_value (tree var)\n {\n   tree sym = SSA_NAME_VAR (var);\n   prop_value_t val = { UNINITIALIZED, NULL_TREE, NULL_TREE };\n-\n+  \n   if (!do_store_ccp && !is_gimple_reg (var))\n     {\n       /* Short circuit for regular CCP.  We are not interested in any\n@@ -360,25 +353,19 @@ get_default_value (tree var)\n \t{\n \t  /* Variables defined by an empty statement are those used\n \t     before being initialized.  If VAR is a local variable, we\n-\t     can assume initially that it is UNDEFINED.  If we are\n-\t     doing STORE-CCP, function arguments and non-register\n-\t     variables are initially UNKNOWN_VAL, because we cannot\n-\t     discard the value incoming from outside of this function\n-\t     (see ccp_lattice_meet for details).  */\n+\t     can assume initially that it is UNDEFINED, otherwise we must\n+\t     consider it VARYING.  */\n \t  if (is_gimple_reg (sym) && TREE_CODE (sym) != PARM_DECL)\n \t    val.lattice_val = UNDEFINED;\n-\t  else if (do_store_ccp)\n-\t    val.lattice_val = UNKNOWN_VAL;\n \t  else\n \t    val.lattice_val = VARYING;\n \t}\n       else if (TREE_CODE (stmt) == MODIFY_EXPR\n \t       || TREE_CODE (stmt) == PHI_NODE)\n \t{\n \t  /* Any other variable defined by an assignment or a PHI node\n-\t     is considered UNDEFINED (or UNKNOWN_VAL if VAR is not a\n-\t     GIMPLE register).  */\n-\t  val.lattice_val = is_gimple_reg (sym) ? UNDEFINED : UNKNOWN_VAL;\n+\t     is considered UNDEFINED.  */\n+\t  val.lattice_val = UNDEFINED;\n \t}\n       else\n \t{\n@@ -391,63 +378,60 @@ get_default_value (tree var)\n }\n \n \n-/* Get the constant value associated with variable VAR.  If\n-   MAY_USE_DEFAULT_P is true, call get_default_value on variables that\n-   have the lattice value UNINITIALIZED.  */\n+/* Get the constant value associated with variable VAR.  */\n \n-static prop_value_t *\n-get_value (tree var, bool may_use_default_p)\n+static inline prop_value_t *\n+get_value (tree var)\n {\n   prop_value_t *val = &const_val[SSA_NAME_VERSION (var)];\n-  if (may_use_default_p && val->lattice_val == UNINITIALIZED)\n+\n+  if (val->lattice_val == UNINITIALIZED)\n     *val = get_default_value (var);\n \n   return val;\n }\n \n+/* Sets the value associated with VAR to VARYING.  */\n+\n+static inline void\n+set_value_varying (tree var)\n+{\n+  prop_value_t *val = &const_val[SSA_NAME_VERSION (var)];\n+\n+  val->lattice_val = VARYING;\n+  val->value = NULL_TREE;\n+  val->mem_ref = NULL_TREE;\n+}\n \n /* Set the value for variable VAR to NEW_VAL.  Return true if the new\n    value is different from VAR's previous value.  */\n \n static bool\n set_lattice_value (tree var, prop_value_t new_val)\n {\n-  prop_value_t *old_val = get_value (var, false);\n+  prop_value_t *old_val = get_value (var);\n \n   /* Lattice transitions must always be monotonically increasing in\n-     value.  We allow two exceptions:\n-     \n-     1- If *OLD_VAL and NEW_VAL are the same, return false to\n-\tinform the caller that this was a non-transition.\n-\n-     2- If we are doing store-ccp (i.e., DOING_STORE_CCP is true),\n-\tallow CONSTANT->UNKNOWN_VAL.  The UNKNOWN_VAL state is a\n-\tspecial type of UNDEFINED state which prevents the short\n-\tcircuit evaluation of PHI arguments (see ccp_visit_phi_node\n-\tand ccp_lattice_meet).  */\n+     value.  If *OLD_VAL and NEW_VAL are the same, return false to\n+     inform the caller that this was a non-transition.  */\n+\n   gcc_assert (old_val->lattice_val <= new_val.lattice_val\n               || (old_val->lattice_val == new_val.lattice_val\n \t\t  && old_val->value == new_val.value\n-\t\t  && old_val->mem_ref == new_val.mem_ref)\n-\t      || (do_store_ccp\n-\t\t  && old_val->lattice_val == CONSTANT\n-\t\t  && new_val.lattice_val == UNKNOWN_VAL));\n+\t\t  && old_val->mem_ref == new_val.mem_ref));\n \n   if (old_val->lattice_val != new_val.lattice_val)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  dump_lattice_value (dump_file, \"Lattice value changed to \", new_val);\n-\t  fprintf (dump_file, \".  %sdding SSA edges to worklist.\\n\",\n-\t           new_val.lattice_val != UNDEFINED ? \"A\" : \"Not a\");\n+\t  fprintf (dump_file, \".  Adding SSA edges to worklist.\\n\");\n \t}\n \n       *old_val = new_val;\n \n-      /* Transitions UNINITIALIZED -> UNDEFINED are never interesting\n-\t for propagation purposes.  In these cases return false to\n-\t avoid doing useless work.  */\n-      return (new_val.lattice_val != UNDEFINED);\n+      gcc_assert (new_val.lattice_val != UNDEFINED);\n+      return true;\n     }\n \n   return false;\n@@ -467,7 +451,7 @@ set_lattice_value (tree var, prop_value_t new_val)\n static ccp_lattice_t\n likely_value (tree stmt)\n {\n-  bool found_constant;\n+  bool has_constant_operand;\n   stmt_ann_t ann;\n   tree use;\n   ssa_op_iter iter;\n@@ -494,40 +478,71 @@ likely_value (tree stmt)\n   /* Anything other than assignments and conditional jumps are not\n      interesting for CCP.  */\n   if (TREE_CODE (stmt) != MODIFY_EXPR\n+      && !(TREE_CODE (stmt) == RETURN_EXPR && get_rhs (stmt) != NULL_TREE)\n       && TREE_CODE (stmt) != COND_EXPR\n       && TREE_CODE (stmt) != SWITCH_EXPR)\n     return VARYING;\n \n   if (is_gimple_min_invariant (get_rhs (stmt)))\n     return CONSTANT;\n \n-  found_constant = false;\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE|SSA_OP_VUSE)\n+  has_constant_operand = false;\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n     {\n-      prop_value_t *val = get_value (use, true);\n+      prop_value_t *val = get_value (use);\n \n-      if (val->lattice_val == VARYING)\n-\treturn VARYING;\n-\n-      if (val->lattice_val == UNKNOWN_VAL)\n-\t{\n-\t  /* UNKNOWN_VAL is invalid when not doing STORE-CCP.  */\n-\t  gcc_assert (do_store_ccp);\n-\t  return UNKNOWN_VAL;\n-\t}\n+      if (val->lattice_val == UNDEFINED)\n+\treturn UNDEFINED;\n \n       if (val->lattice_val == CONSTANT)\n-\tfound_constant = true;\n+\thas_constant_operand = true;\n     }\n \n-  if (found_constant\n-      || ZERO_SSA_OPERANDS (stmt, SSA_OP_USE)\n-      || ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n+  if (has_constant_operand\n+      /* We do not consider virtual operands here -- load from read-only\n+\t memory may have only VARYING virtual operands, but still be\n+\t constant.  */\n+      || ZERO_SSA_OPERANDS (stmt, SSA_OP_USE))\n     return CONSTANT;\n \n-  return UNDEFINED;\n+  return VARYING;\n }\n \n+/* Returns true if STMT cannot be constant.  */\n+\n+static bool\n+surely_varying_stmt_p (tree stmt)\n+{\n+  /* If the statement has operands that we cannot handle, it cannot be\n+     constant.  */\n+  if (stmt_ann (stmt)->has_volatile_ops)\n+    return true;\n+\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+    {\n+      if (!do_store_ccp)\n+\treturn true;\n+\n+      /* We can only handle simple loads and stores.  */\n+      if (!stmt_makes_single_load (stmt)\n+\t  && !stmt_makes_single_store (stmt))\n+\treturn true;\n+    }\n+\n+  /* If it contains a call, it is varying.  */\n+  if (get_call_expr_in (stmt) != NULL_TREE)\n+    return true;\n+\n+  /* Anything other than assignments and conditional jumps are not\n+     interesting for CCP.  */\n+  if (TREE_CODE (stmt) != MODIFY_EXPR\n+      && !(TREE_CODE (stmt) == RETURN_EXPR && get_rhs (stmt) != NULL_TREE)\n+      && TREE_CODE (stmt) != COND_EXPR\n+      && TREE_CODE (stmt) != SWITCH_EXPR)\n+    return true;\n+\n+  return false;\n+}\n \n /* Initialize local data structures for CCP.  */\n \n@@ -546,56 +561,40 @@ ccp_initialize (void)\n \n       for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n         {\n-\t  bool is_varying = false;\n \t  tree stmt = bsi_stmt (i);\n+\t  bool is_varying = surely_varying_stmt_p (stmt);\n \n-\t  if (likely_value (stmt) == VARYING)\n-\n+\t  if (is_varying)\n \t    {\n \t      tree def;\n \t      ssa_op_iter iter;\n \n \t      /* If the statement will not produce a constant, mark\n \t\t all its outputs VARYING.  */\n \t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n-\t\tget_value (def, false)->lattice_val = VARYING;\n-\n-\t      /* Never mark conditional jumps with DONT_SIMULATE_AGAIN,\n-\t\t otherwise the propagator will never add the outgoing\n-\t\t control edges.  */\n-\t      if (TREE_CODE (stmt) != COND_EXPR\n-\t\t  && TREE_CODE (stmt) != SWITCH_EXPR)\n-\t\tis_varying = true;\n+\t\t{\n+\t\t  if (is_varying)\n+\t\t    set_value_varying (def);\n+\t\t}\n \t    }\n \n \t  DONT_SIMULATE_AGAIN (stmt) = is_varying;\n \t}\n     }\n \n-  /* Now process PHI nodes.  */\n+  /* Now process PHI nodes.  We never set DONT_SIMULATE_AGAIN on phi node,\n+     since we do not know which edges are executable yet, except for\n+     phi nodes for virtual operands when we do not do store ccp.  */\n   FOR_EACH_BB (bb)\n     {\n       tree phi;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n-\t  int i;\n-\t  tree arg;\n-\t  prop_value_t *val = get_value (PHI_RESULT (phi), false);\n-\n-\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\t    {\n-\t      arg = PHI_ARG_DEF (phi, i);\n-\n-\t      if (TREE_CODE (arg) == SSA_NAME\n-\t\t  && get_value (arg, false)->lattice_val == VARYING)\n-\t\t{\n-\t\t  val->lattice_val = VARYING;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  DONT_SIMULATE_AGAIN (phi) = (val->lattice_val == VARYING);\n+\t  if (!do_store_ccp && !is_gimple_reg (PHI_RESULT (phi)))\n+\t    DONT_SIMULATE_AGAIN (phi) = true;\n+\t  else\n+\t    DONT_SIMULATE_AGAIN (phi) = false;\n \t}\n     }\n }\n@@ -618,36 +617,10 @@ ccp_finalize (void)\n    in VAL1.\n \n    \t\tany  M UNDEFINED   = any\n-\t\tany  M UNKNOWN_VAL = UNKNOWN_VAL\n \t\tany  M VARYING     = VARYING\n \t\tCi   M Cj\t   = Ci\t\tif (i == j)\n \t\tCi   M Cj\t   = VARYING\tif (i != j)\n-\n-   Lattice values UNKNOWN_VAL and UNDEFINED are similar but have\n-   different semantics at PHI nodes.  Both values imply that we don't\n-   know whether the variable is constant or not.  However, UNKNOWN_VAL\n-   values override all others.  For instance, suppose that A is a\n-   global variable:\n-\n-\t\t+------+\n-\t\t|      |\n-\t\t|     / \\\n-\t\t|    /   \\\n-\t\t|   |  A_1 = 4\n-\t\t|    \\   /\n-\t\t|     \\ /    \n-\t\t| A_3 = PHI (A_2, A_1)\n-\t\t| ... = A_3\n-\t\t|    |\n-\t\t+----+\n-\n-   If the edge into A_2 is not executable, the first visit to A_3 will\n-   yield the constant 4.  But the second visit to A_3 will be with A_2\n-   in state UNKNOWN_VAL.  We can no longer conclude that A_3 is 4\n-   because A_2 may have been set in another function.  If we had used\n-   the lattice value UNDEFINED, we would have had wrongly concluded\n-   that A_3 is 4.  */\n-   \n+   */\n \n static void\n ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n@@ -663,17 +636,6 @@ ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n          Nothing to do.  VAL1 already contains the value we want.  */\n       ;\n     }\n-  else if (val1->lattice_val == UNKNOWN_VAL\n-           || val2->lattice_val == UNKNOWN_VAL)\n-    {\n-      /* UNKNOWN_VAL values are invalid if we are not doing STORE-CCP.  */\n-      gcc_assert (do_store_ccp);\n-\n-      /* any M UNKNOWN_VAL = UNKNOWN_VAL.  */\n-      val1->lattice_val = UNKNOWN_VAL;\n-      val1->value = NULL_TREE;\n-      val1->mem_ref = NULL_TREE;\n-    }\n   else if (val1->lattice_val == VARYING\n            || val2->lattice_val == VARYING)\n     {\n@@ -725,7 +687,7 @@ ccp_visit_phi_node (tree phi)\n       print_generic_expr (dump_file, phi, dump_flags);\n     }\n \n-  old_val = get_value (PHI_RESULT (phi), false);\n+  old_val = get_value (PHI_RESULT (phi));\n   switch (old_val->lattice_val)\n     {\n     case VARYING:\n@@ -735,19 +697,7 @@ ccp_visit_phi_node (tree phi)\n       new_val = *old_val;\n       break;\n \n-    case UNKNOWN_VAL:\n-      /* To avoid the default value of UNKNOWN_VAL overriding\n-         that of its possible constant arguments, temporarily\n-\t set the PHI node's default lattice value to be \n-\t UNDEFINED.  If the PHI node's old value was UNKNOWN_VAL and\n-\t the new value is UNDEFINED, then we prevent the invalid\n-\t transition by not calling set_lattice_value.  */\n-      gcc_assert (do_store_ccp);\n-\n-      /* FALLTHRU  */\n-\n     case UNDEFINED:\n-    case UNINITIALIZED:\n       new_val.lattice_val = UNDEFINED;\n       new_val.value = NULL_TREE;\n       new_val.mem_ref = NULL_TREE;\n@@ -785,7 +735,7 @@ ccp_visit_phi_node (tree phi)\n \t      arg_val.mem_ref = NULL_TREE;\n \t    }\n \t  else\n-\t    arg_val = *(get_value (arg, true));\n+\t    arg_val = *(get_value (arg));\n \n \t  ccp_lattice_meet (&new_val, &arg_val);\n \n@@ -808,13 +758,7 @@ ccp_visit_phi_node (tree phi)\n       fprintf (dump_file, \"\\n\\n\");\n     }\n \n-  /* Check for an invalid change from UNKNOWN_VAL to UNDEFINED.  */\n-  if (do_store_ccp\n-      && old_val->lattice_val == UNKNOWN_VAL\n-      && new_val.lattice_val == UNDEFINED)\n-    return SSA_PROP_NOT_INTERESTING;\n-\n-  /* Otherwise, make the transition to the new value.  */\n+  /* Make the transition to the new value.  */\n   if (set_lattice_value (PHI_RESULT (phi), new_val))\n     {\n       if (new_val.lattice_val == VARYING)\n@@ -848,7 +792,7 @@ ccp_fold (tree stmt)\n     {\n       /* If the RHS is an SSA_NAME, return its known constant value,\n \t if any.  */\n-      return get_value (rhs, true)->value;\n+      return get_value (rhs)->value;\n     }\n   else if (do_store_ccp && stmt_makes_single_load (stmt))\n     {\n@@ -881,9 +825,9 @@ ccp_fold (tree stmt)\n       /* Simplify the operand down to a constant.  */\n       if (TREE_CODE (op0) == SSA_NAME)\n \t{\n-\t  prop_value_t *val = get_value (op0, true);\n+\t  prop_value_t *val = get_value (op0);\n \t  if (val->lattice_val == CONSTANT)\n-\t    op0 = get_value (op0, true)->value;\n+\t    op0 = get_value (op0)->value;\n \t}\n \n       if ((code == NOP_EXPR || code == CONVERT_EXPR)\n@@ -909,14 +853,14 @@ ccp_fold (tree stmt)\n       /* Simplify the operands down to constants when appropriate.  */\n       if (TREE_CODE (op0) == SSA_NAME)\n \t{\n-\t  prop_value_t *val = get_value (op0, true);\n+\t  prop_value_t *val = get_value (op0);\n \t  if (val->lattice_val == CONSTANT)\n \t    op0 = val->value;\n \t}\n \n       if (TREE_CODE (op1) == SSA_NAME)\n \t{\n-\t  prop_value_t *val = get_value (op1, true);\n+\t  prop_value_t *val = get_value (op1);\n \t  if (val->lattice_val == CONSTANT)\n \t    op1 = val->value;\n \t}\n@@ -1022,7 +966,7 @@ fold_const_aggregate_ref (tree t)\n       switch (TREE_CODE (idx))\n \t{\n \tcase SSA_NAME:\n-\t  if ((value = get_value (idx, true))\n+\t  if ((value = get_value (idx))\n \t      && value->lattice_val == CONSTANT\n \t      && TREE_CODE (value->value) == INTEGER_CST)\n \t    idx = value->value;\n@@ -1151,7 +1095,7 @@ evaluate_stmt (tree stmt)\n       /* The statement produced a nonconstant value.  If the statement\n \t had UNDEFINED operands, then the result of the statement\n \t should be UNDEFINED.  Otherwise, the statement is VARYING.  */\n-      if (likelyvalue == UNDEFINED || likelyvalue == UNKNOWN_VAL)\n+      if (likelyvalue == UNDEFINED)\n \tval.lattice_val = likelyvalue;\n       else\n \tval.lattice_val = VARYING;\n@@ -1181,18 +1125,19 @@ visit_assignment (tree stmt, tree *output_p)\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       /* For a simple copy operation, we copy the lattice values.  */\n-      prop_value_t *nval = get_value (rhs, true);\n+      prop_value_t *nval = get_value (rhs);\n       val = *nval;\n     }\n   else if (do_store_ccp && stmt_makes_single_load (stmt))\n     {\n       /* Same as above, but the RHS is not a gimple register and yet\n-         has a known VUSE.  If STMT is loading from the same memory\n+\t has a known VUSE.  If STMT is loading from the same memory\n \t location that created the SSA_NAMEs for the virtual operands,\n \t we can propagate the value on the RHS.  */\n       prop_value_t *nval = get_value_loaded_by (stmt, const_val);\n \n-      if (nval && nval->mem_ref\n+      if (nval\n+\t  && nval->mem_ref\n \t  && operand_equal_p (nval->mem_ref, rhs, 0))\n \tval = *nval;\n       else\n@@ -1271,12 +1216,9 @@ visit_assignment (tree stmt, tree *output_p)\n       tree vdef;\n       bool changed;\n \n-      /* Stores cannot take on an UNDEFINED value.  */\n-      if (val.lattice_val == UNDEFINED)\n-\tval.lattice_val = UNKNOWN_VAL;      \n-\n       /* Mark VAL as stored in the LHS of this assignment.  */\n-      val.mem_ref = lhs;\n+      if (val.lattice_val == CONSTANT)\n+\tval.mem_ref = lhs;\n \n       /* Set the value of every VDEF to VAL.  */\n       changed = false;"}]}