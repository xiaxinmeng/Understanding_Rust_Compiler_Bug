{"sha": "402c818ac0b19d168e9ffc0b3413344dd6020f6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyYzgxOGFjMGIxOWQxNjhlOWZmYzBiMzQxMzM0NGRkNjAyMGY2YQ==", "commit": {"author": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2021-06-22T19:25:11Z"}, "committer": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2021-06-23T14:18:30Z"}, "message": "Use more logicals to eliminate useless test/compare instructions\n\ngcc/\n\t* config/h8300/logical.md (<code><mode>3<ccnz>): Use <cczn>\n\tso this pattern can be used for test/compare removal.  Pass\n\tcurrent insn to compute_logical_op_length and output_logical_op.\n\t* config/h8300/h8300.c (compute_logical_op_cc): Remove.\n\t(h8300_and_costs): Add argument to compute_logical_op_length.\n\t(output_logical_op): Add new argument.  Use it to determine if the\n\tcondition codes are used and adjust the output accordingly.\n\t(compute_logical_op_length): Add new argument and update length\n\tcomputations when condition codes are used.\n\t* config/h8300/h8300-protos.h (compute_logical_op_length): Update\n\tprototype.\n\t(output_logical_op): Likewise.", "tree": {"sha": "8e0bb68651a33f643a3abba12f8dec90d3e836b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e0bb68651a33f643a3abba12f8dec90d3e836b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/402c818ac0b19d168e9ffc0b3413344dd6020f6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402c818ac0b19d168e9ffc0b3413344dd6020f6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/402c818ac0b19d168e9ffc0b3413344dd6020f6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402c818ac0b19d168e9ffc0b3413344dd6020f6a/comments", "author": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37e93925366676201b526624e9f8dc32d82b4ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37e93925366676201b526624e9f8dc32d82b4ff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37e93925366676201b526624e9f8dc32d82b4ff2"}], "stats": {"total": 150, "additions": 55, "deletions": 95}, "files": [{"sha": "d7efa978aa0197ad2788e7b83337fbeb02b25791", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/402c818ac0b19d168e9ffc0b3413344dd6020f6a/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/402c818ac0b19d168e9ffc0b3413344dd6020f6a/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=402c818ac0b19d168e9ffc0b3413344dd6020f6a", "patch": "@@ -36,10 +36,11 @@ extern const char *output_simode_bld (int, rtx[]);\n extern void final_prescan_insn (rtx_insn *, rtx *, int);\n extern int h8300_expand_movsi (rtx[]);\n extern machine_mode  h8300_select_cc_mode (RTX_CODE, rtx, rtx);\n-extern const char *output_logical_op (machine_mode, rtx_code code, rtx *);\n-extern unsigned int compute_logical_op_length (machine_mode, rtx_code, rtx *);\n+extern const char *output_logical_op (machine_mode, rtx_code code,\n+\t\t\t\t      rtx *, rtx_insn *);\n+extern unsigned int compute_logical_op_length (machine_mode, rtx_code,\n+\t\t\t\t\t      rtx *, rtx_insn *);\n \n-extern int compute_logical_op_cc (machine_mode, rtx *);\n extern int compute_a_shift_cc (rtx, rtx *);\n #ifdef HAVE_ATTR_cc\n extern enum attr_cc compute_plussi_cc (rtx *);"}, {"sha": "511c2b28e4020f632b8e427937faaeb9ee19f6e4", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 48, "deletions": 88, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/402c818ac0b19d168e9ffc0b3413344dd6020f6a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/402c818ac0b19d168e9ffc0b3413344dd6020f6a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=402c818ac0b19d168e9ffc0b3413344dd6020f6a", "patch": "@@ -1100,7 +1100,7 @@ h8300_and_costs (rtx x)\n   operands[1] = XEXP (x, 0);\n   operands[2] = XEXP (x, 1);\n   operands[3] = x;\n-  return compute_logical_op_length (GET_MODE (x), AND, operands) / 2;\n+  return compute_logical_op_length (GET_MODE (x), AND, operands, NULL) / 2;\n }\n \n /* Compute the cost of a shift insn.  */\n@@ -2881,7 +2881,7 @@ compute_plussi_cc (rtx *operands)\n /* Output a logical insn.  */\n \n const char *\n-output_logical_op (machine_mode mode, rtx_code code, rtx *operands)\n+output_logical_op (machine_mode mode, rtx_code code, rtx *operands, rtx_insn *insn)\n {\n   /* Pretend that every byte is affected if both operands are registers.  */\n   const unsigned HOST_WIDE_INT intval =\n@@ -2906,6 +2906,19 @@ output_logical_op (machine_mode mode, rtx_code code, rtx *operands)\n   const char *opname;\n   char insn_buf[100];\n \n+  /* INSN is the current insn, we examine its overall form to see if we're\n+     supposed to set or clobber the condition codes.\n+\n+     This is important to know.  If we are setting condition codes, then we\n+     must do the operation in MODE and not in some smaller size.\n+\n+     The key is to look at the second object in the PARALLEL. If it is not\n+     a CLOBBER, then we care about the condition codes.  */\n+  rtx pattern = PATTERN (insn);\n+  gcc_assert (GET_CODE (pattern) == PARALLEL);\n+  rtx second_op = XVECEXP (pattern, 0, 1);\n+  bool cc_meaningful = (GET_CODE (second_op) != CLOBBER);\n+\n   switch (code)\n     {\n     case AND:\n@@ -2928,8 +2941,9 @@ output_logical_op (machine_mode mode, rtx_code code, rtx *operands)\n       output_asm_insn (insn_buf, operands);\n       break;\n     case E_HImode:\n-      /* First, see if we can finish with one insn.  */\n-      if (b0 != 0 && b1 != 0)\n+      /* First, see if we can (or must) finish with one insn.  */\n+      if (cc_meaningful\n+\t  || (b0 != 0 && b1 != 0))\n \t{\n \t  sprintf (insn_buf, \"%s.w\\t%%T2,%%T0\", opname);\n \t  output_asm_insn (insn_buf, operands);\n@@ -2964,10 +2978,11 @@ output_logical_op (machine_mode mode, rtx_code code, rtx *operands)\n \n       /* Check if doing everything with one insn is no worse than\n \t using multiple insns.  */\n-      if (w0 != 0 && w1 != 0\n-\t  && !(lower_half_easy_p && upper_half_easy_p)\n-\t  && !(code == IOR && w1 == 0xffff\n-\t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n+      if (cc_meaningful\n+\t  || (w0 != 0 && w1 != 0\n+\t      && !(lower_half_easy_p && upper_half_easy_p)\n+\t      && !(code == IOR && w1 == 0xffff\n+\t\t   && (w0 & 0x8000) != 0 && lower_half_easy_p)))\n \t{\n \t  sprintf (insn_buf, \"%s.l\\t%%S2,%%S0\", opname);\n \t  output_asm_insn (insn_buf, operands);\n@@ -3037,7 +3052,7 @@ output_logical_op (machine_mode mode, rtx_code code, rtx *operands)\n /* Compute the length of a logical insn.  */\n \n unsigned int\n-compute_logical_op_length (machine_mode mode, rtx_code code, rtx *operands)\n+compute_logical_op_length (machine_mode mode, rtx_code code, rtx *operands, rtx_insn *insn)\n {\n   /* Pretend that every byte is affected if both operands are registers.  */\n   const unsigned HOST_WIDE_INT intval =\n@@ -3061,14 +3076,32 @@ compute_logical_op_length (machine_mode mode, rtx_code code, rtx *operands)\n   /* Insn length.  */\n   unsigned int length = 0;\n \n+  /* INSN is the current insn, we examine its overall form to see if we're\n+     supposed to set or clobber the condition codes.\n+\n+     This is important to know.  If we are setting condition codes, then we\n+     must do the operation in MODE and not in some smaller size.\n+\n+     The key is to look at the second object in the PARALLEL. If it is not\n+     a CLOBBER, then we care about the condition codes.  */\n+  bool cc_meaningful = false;\n+  if (insn)\n+    {\n+      rtx pattern = PATTERN (insn);\n+      gcc_assert (GET_CODE (pattern) == PARALLEL);\n+      rtx second_op = XVECEXP (pattern, 0, 1);\n+      cc_meaningful = (GET_CODE (second_op) != CLOBBER);\n+    }\n+\n   switch (mode)\n     {\n     case E_QImode:\n       return 2;\n \n     case E_HImode:\n       /* First, see if we can finish with one insn.  */\n-      if (b0 != 0 && b1 != 0)\n+      if (cc_meaningful\n+\t  || (b0 != 0 && b1 != 0))\n \t{\n \t  length = h8300_length_from_table (operands[1], operands[2],\n \t\t\t\t\t    &logicw_length_table);\n@@ -3098,10 +3131,11 @@ compute_logical_op_length (machine_mode mode, rtx_code code, rtx *operands)\n \n       /* Check if doing everything with one insn is no worse than\n \t using multiple insns.  */\n-      if (w0 != 0 && w1 != 0\n-\t  && !(lower_half_easy_p && upper_half_easy_p)\n-\t  && !(code == IOR && w1 == 0xffff\n-\t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n+      if (cc_meaningful\n+\t  || (w0 != 0 && w1 != 0\n+\t      && !(lower_half_easy_p && upper_half_easy_p)\n+\t      && !(code == IOR && w1 == 0xffff\n+\t\t   && (w0 & 0x8000) != 0 && lower_half_easy_p)))\n \t{\n \t  length = h8300_length_from_table (operands[1], operands[2],\n \t\t\t\t\t    &logicl_length_table);\n@@ -3158,80 +3192,6 @@ compute_logical_op_length (machine_mode mode, rtx_code code, rtx *operands)\n   return length;\n }\n \n-/* Compute which flag bits are valid after a logical insn.  */\n-\n-int\n-compute_logical_op_cc (machine_mode mode, rtx *operands)\n-{\n-  /* Figure out the logical op that we need to perform.  */\n-  enum rtx_code code = GET_CODE (operands[3]);\n-  /* Pretend that every byte is affected if both operands are registers.  */\n-  const unsigned HOST_WIDE_INT intval =\n-    (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n-\t\t\t      /* Always use the full instruction if the\n-\t\t\t\t first operand is in memory.  It is better\n-\t\t\t\t to use define_splits to generate the shorter\n-\t\t\t\t sequence where valid.  */\n-\t\t\t      && register_operand (operands[1], VOIDmode)\n-\t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n-  /* The determinant of the algorithm.  If we perform an AND, 0\n-     affects a bit.  Otherwise, 1 affects a bit.  */\n-  const unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n-  /* Break up DET into pieces.  */\n-  const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n-  const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n-  const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n-  const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n-  int lower_half_easy_p = 0;\n-  int upper_half_easy_p = 0;\n-  /* Condition code.  */\n-  enum attr_old_cc cc = OLD_CC_CLOBBER;\n-\n-  switch (mode)\n-    {\n-    case E_HImode:\n-      /* First, see if we can finish with one insn.  */\n-      if (b0 != 0 && b1 != 0)\n-\t{\n-\t  cc = OLD_CC_SET_ZNV;\n-\t}\n-      break;\n-    case E_SImode:\n-      /* Determine if the lower half can be taken care of in no more\n-\t than two bytes.  */\n-      lower_half_easy_p = (b0 == 0\n-\t\t\t   || b1 == 0\n-\t\t\t   || (code != IOR && w0 == 0xffff));\n-\n-      /* Determine if the upper half can be taken care of in no more\n-         than two bytes.  */\n-      upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n-\t\t\t   || (code == AND && w1 == 0xff00));\n-\n-      /* Check if doing everything with one insn is no worse than\n-\t using multiple insns.  */\n-      if (w0 != 0 && w1 != 0\n-\t  && !(lower_half_easy_p && upper_half_easy_p)\n-\t  && !(code == IOR && w1 == 0xffff\n-\t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n-\t{\n-\t  cc = OLD_CC_SET_ZNV;\n-\t}\n-      else\n-\t{\n-\t  if (code == IOR\n-\t      && w1 == 0xffff\n-\t      && (w0 & 0x8000) != 0)\n-\t    {\n-\t      cc = OLD_CC_SET_ZNV;\n-\t    }\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return cc;\n-}\n \f\n #if 0\n /* Expand a conditional branch.  */"}, {"sha": "f07c79e1eac24165fac919fb5777301bdc9e4e34", "filename": "gcc/config/h8300/logical.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/402c818ac0b19d168e9ffc0b3413344dd6020f6a/gcc%2Fconfig%2Fh8300%2Flogical.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/402c818ac0b19d168e9ffc0b3413344dd6020f6a/gcc%2Fconfig%2Fh8300%2Flogical.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Flogical.md?ref=402c818ac0b19d168e9ffc0b3413344dd6020f6a", "patch": "@@ -251,17 +251,16 @@\n \t\t   (logicals:QHSI (match_dup 1) (match_dup 2)))\n \t      (clobber (reg:CC CC_REG))])])\n \n-(define_insn \"*<code><mode>3_clobber_flags\"\n+(define_insn \"*<code><mode>3<cczn>\"\n   [(set (match_operand:QHSI 0 \"h8300_dst_operand\" \"=rQ\")\n \t(logicals:QHSI\n \t  (match_operand:QHSI 1 \"h8300_dst_operand\" \"%0\")\n \t  (match_operand:QHSI 2 \"h8300_src_operand\" \"rQi\")))\n    (clobber (reg:CC CC_REG))]\n   \"h8300_operands_match_p (operands)\"\n-  { return output_logical_op (<MODE>mode, <CODE>, operands); }\n+  { return output_logical_op (<MODE>mode, <CODE>, operands, insn); }\n   [(set (attr \"length\")\n-\t(symbol_ref \"compute_logical_op_length (<MODE>mode, <CODE>, operands)\"))])\n-\n+\t(symbol_ref \"compute_logical_op_length (<MODE>mode, <CODE>, operands, insn)\"))])\n \f\n ;; ----------------------------------------------------------------------\n ;; NOT INSTRUCTIONS"}]}