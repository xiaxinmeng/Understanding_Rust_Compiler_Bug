{"sha": "6e0a231a4aa2407bb7167daf98a37795a67364d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwYTIzMWE0YWEyNDA3YmI3MTY3ZGFmOThhMzc3OTVhNjczNjRkOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-27T22:15:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-02-01T14:49:42Z"}, "message": "c++: alias in qualified-id in template arg [PR98570]\n\ntemplate_args_equal has handled dependent alias specializations for a while,\nbut in this testcase the actual template argument is a SCOPE_REF, so we\ncalled cp_tree_equal, which doesn't handle aliases specially when we get to\nthem.\n\nThis patch generalizes this by setting a flag so structural_comptypes will\ncheck for template alias equivalence (if we aren't doing partial ordering).\nThe existing flag, comparing_specializations, was too broad; in particular,\nwhen we're doing decls_match, we want to treat corresponding parameters as\nequivalent, so we need to separate that from alias comparison.  So I\nintroduce the comparing_dependent_aliases flag.\n\nFrom looking at other uses of comparing_specializations, it seems to me that\nthe new flag is what modules wants, as well.\n\nThe other use of comparing_specializations in structural_comptypes is a hack\nto deal with spec_hasher::equal not calling push_to_top_level, which we\nalso don't want to tie to the alias comparison semantics.\n\nThis patch also changes how we get to structural comparison of aliases from\nchecking TYPE_CANONICAL in comptypes to marking the aliases as getting\nstructural comparison when they are built, which is more consistent with how\ne.g. typename is handled.\n\nAs I mention in the comment for comparing_dependent_aliases, I think the\ndefault should be to treat different dependent aliases for the same type as\ndistinct, only treating them as equal during deduction (particularly partial\nordering).  But that's a matter for the C++ committee, to try in stage 1.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/98570\n\t* cp-tree.h: Declare it.\n\t* pt.c (comparing_dependent_aliases): New flag.\n\t(template_args_equal, spec_hasher::equal): Set it.\n\t(dependent_alias_template_spec_p): Assert that we don't\n\tget non-types other than error_mark_node.\n\t(instantiate_alias_template): SET_TYPE_STRUCTURAL_EQUALITY\n\ton complex alias specializations.  Set TYPE_DEPENDENT_P here.\n\t(tsubst_decl): Not here.\n\t* module.cc (module_state::read_cluster): Set\n\tcomparing_dependent_aliases instead of\n\tcomparing_specializations.\n\t* tree.c (cp_tree_equal): Remove comparing_specializations\n\tmodule handling.\n\t* typeck.c (structural_comptypes): Adjust.\n\t(comptypes): Remove comparing_specializations handling.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98570\n\t* g++.dg/cpp0x/alias-decl-targ1.C: New test.", "tree": {"sha": "0683075c4ce5a5cf8691e6eb6cc1a84241a999fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0683075c4ce5a5cf8691e6eb6cc1a84241a999fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e0a231a4aa2407bb7167daf98a37795a67364d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0a231a4aa2407bb7167daf98a37795a67364d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e0a231a4aa2407bb7167daf98a37795a67364d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0a231a4aa2407bb7167daf98a37795a67364d8/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bec5dbae5649da4bd7ea2731a8446ac481cb78ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec5dbae5649da4bd7ea2731a8446ac481cb78ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec5dbae5649da4bd7ea2731a8446ac481cb78ab"}], "stats": {"total": 90, "additions": 53, "deletions": 37}, "files": [{"sha": "aed85d7928715fd9613c455ff78c63f744d526e3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6e0a231a4aa2407bb7167daf98a37795a67364d8", "patch": "@@ -5449,11 +5449,14 @@ extern GTY(()) tree integer_two_node;\n    function, two inside the body of a function in a local class, etc.)  */\n extern int function_depth;\n \n-/* Nonzero if we are inside eq_specializations, which affects\n-   comparison of PARM_DECLs in cp_tree_equal and alias specializations\n-   in structrual_comptypes.  */\n+/* Nonzero if we are inside spec_hasher::equal, which affects\n+   comparison of PARM_DECLs in cp_tree_equal.  */\n extern int comparing_specializations;\n \n+/* Nonzero if we want different dependent aliases to compare as unequal.\n+   FIXME we should always do this except during deduction/ordering.  */\n+extern int comparing_dependent_aliases;\n+\n /* When comparing specializations permit context _FROM to match _TO.  */\n extern tree map_context_from;\n extern tree map_context_to;"}, {"sha": "41ce20115255aae298acc7da0af51de8845cd9e4", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=6e0a231a4aa2407bb7167daf98a37795a67364d8", "patch": "@@ -14801,7 +14801,7 @@ module_state::read_cluster (unsigned snum)\n   dump.indent ();\n \n   /* We care about structural equality.  */\n-  comparing_specializations++;\n+  comparing_dependent_aliases++;\n \n   /* First seed the imports.  */\n   while (tree import = sec.tree_node ())\n@@ -14976,7 +14976,7 @@ module_state::read_cluster (unsigned snum)\n #undef cfun\n   cfun = old_cfun;\n   current_function_decl = old_cfd;\n-  comparing_specializations--;\n+  comparing_dependent_aliases--;\n \n   dump.outdent ();\n   dump () && dump (\"Read section:%u\", snum);"}, {"sha": "db0ff73bdeb8a75c9b9b50d1dbbc01ccd0838ee9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6e0a231a4aa2407bb7167daf98a37795a67364d8", "patch": "@@ -1709,6 +1709,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \n /* Restricts tree and type comparisons.  */\n int comparing_specializations;\n+int comparing_dependent_aliases;\n \n /* Returns true iff two spec_entry nodes are equivalent.  */\n \n@@ -1718,6 +1719,7 @@ spec_hasher::equal (spec_entry *e1, spec_entry *e2)\n   int equal;\n \n   ++comparing_specializations;\n+  ++comparing_dependent_aliases;\n   equal = (e1->tmpl == e2->tmpl\n \t   && comp_template_args (e1->args, e2->args));\n   if (equal && flag_concepts\n@@ -1732,6 +1734,7 @@ spec_hasher::equal (spec_entry *e1, spec_entry *e2)\n       tree c2 = e2->spec ? get_constraints (e2->spec) : NULL_TREE;\n       equal = equivalent_constraints (c1, c2);\n     }\n+  --comparing_dependent_aliases;\n   --comparing_specializations;\n \n   return equal;\n@@ -6516,7 +6519,11 @@ complex_alias_template_p (const_tree tmpl)\n tree\n dependent_alias_template_spec_p (const_tree t, bool transparent_typedefs)\n {\n-  if (!TYPE_P (t) || !typedef_variant_p (t))\n+  if (t == error_mark_node)\n+    return NULL_TREE;\n+  gcc_assert (TYPE_P (t));\n+\n+  if (!typedef_variant_p (t))\n     return NULL_TREE;\n \n   tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t);\n@@ -9166,6 +9173,18 @@ template_args_equal (tree ot, tree nt, bool partial_order /* = false */)\n   if (class_nttp_const_wrapper_p (ot))\n     ot = TREE_OPERAND (ot, 0);\n \n+  /* DR 1558: Don't treat an alias template specialization with dependent\n+     arguments as equivalent to its underlying type when used as a template\n+     argument; we need them to be distinct so that we substitute into the\n+     specialization arguments at instantiation time.  And aliases can't be\n+     equivalent without being ==, so we don't need to look any deeper.\n+\n+     During partial ordering, however, we need to treat them normally so we can\n+     order uses of the same alias with different cv-qualification (79960).  */\n+  auto cso = make_temp_override (comparing_dependent_aliases);\n+  if (!partial_order)\n+    ++comparing_dependent_aliases;\n+\n   if (TREE_CODE (nt) == TREE_VEC || TREE_CODE (ot) == TREE_VEC)\n     /* For member templates */\n     return TREE_CODE (ot) == TREE_CODE (nt) && comp_template_args (ot, nt);\n@@ -9183,21 +9202,7 @@ template_args_equal (tree ot, tree nt, bool partial_order /* = false */)\n     {\n       if (!(TYPE_P (nt) && TYPE_P (ot)))\n \treturn false;\n-      /* Don't treat an alias template specialization with dependent\n-\t arguments as equivalent to its underlying type when used as a\n-\t template argument; we need them to be distinct so that we\n-\t substitute into the specialization arguments at instantiation\n-\t time.  And aliases can't be equivalent without being ==, so\n-\t we don't need to look any deeper.\n-\n-         During partial ordering, however, we need to treat them normally so\n-         that we can order uses of the same alias with different\n-         cv-qualification (79960).  */\n-      if (!partial_order\n-\t  && (TYPE_ALIAS_P (nt) || TYPE_ALIAS_P (ot)))\n-\treturn false;\n-      else\n-\treturn same_type_p (ot, nt);\n+      return same_type_p (ot, nt);\n     }\n   else\n     {\n@@ -14903,10 +14908,6 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  {\n \t    DECL_ORIGINAL_TYPE (r) = NULL_TREE;\n \t    set_underlying_type (r);\n-\t    if (TYPE_DECL_ALIAS_P (r))\n-\t      /* An alias template specialization can be dependent\n-\t\t even if its underlying type is not.  */\n-\t      TYPE_DEPENDENT_P_VALID (TREE_TYPE (r)) = false;\n \t  }\n \n \tlayout_decl (r, 0);\n@@ -21136,6 +21137,17 @@ instantiate_alias_template (tree tmpl, tree args, tsubst_flags_t complain)\n   tree r = instantiate_template (tmpl, args, complain);\n   pop_tinst_level ();\n \n+  if (tree d = dependent_alias_template_spec_p (TREE_TYPE (r), nt_opaque))\n+    {\n+      /* An alias template specialization can be dependent\n+\t even if its underlying type is not.  */\n+      TYPE_DEPENDENT_P (d) = true;\n+      TYPE_DEPENDENT_P_VALID (d) = true;\n+      /* Sometimes a dependent alias spec is equivalent to its expansion,\n+\t sometimes not.  So always use structural_comptypes.  */\n+      SET_TYPE_STRUCTURAL_EQUALITY (d);\n+    }\n+\n   return r;\n }\n "}, {"sha": "2e5a1f198e82ec926a5e18e5d63ec2b83479a160", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6e0a231a4aa2407bb7167daf98a37795a67364d8", "patch": "@@ -3847,12 +3847,7 @@ cp_tree_equal (tree t1, tree t2)\n \t template.  */\n \n       if (comparing_specializations\n-\t  && DECL_CONTEXT (t1) != DECL_CONTEXT (t2)\n-\t  /* Module duplicate checking can have t1 = new, t2 =\n-\t     existing, and they should be considered matching at this\n-\t     point.  */\n-\t  && !(DECL_CONTEXT (t1) == map_context_from\n-\t       && DECL_CONTEXT (t2) == map_context_to))\n+\t  && DECL_CONTEXT (t1) != DECL_CONTEXT (t2))\n \t/* When comparing hash table entries, only an exact match is\n \t   good enough; we don't want to replace 'this' with the\n \t   version from another function.  But be more flexible"}, {"sha": "a87d5e5f2ac9bea9ee4dfcbc70c9e3840bf40a5d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6e0a231a4aa2407bb7167daf98a37795a67364d8", "patch": "@@ -1251,6 +1251,8 @@ structural_comptypes (tree t1, tree t2, int strict)\n   /* Both should be types that are not obviously the same.  */\n   gcc_checking_assert (t1 != t2 && TYPE_P (t1) && TYPE_P (t2));\n \n+  /* Suppress typename resolution under spec_hasher::equal in place of calling\n+     push_to_top_level there.  */\n   if (!comparing_specializations)\n     {\n       /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n@@ -1483,7 +1485,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n     return false;\n \n  check_alias:\n-  if (comparing_specializations)\n+  if (comparing_dependent_aliases)\n     {\n       /* Don't treat an alias template specialization with dependent\n \t arguments as equivalent to its underlying type when used as a\n@@ -1519,11 +1521,6 @@ comptypes (tree t1, tree t2, int strict)\n   if (t1 == error_mark_node || t2 == error_mark_node)\n     return false;\n \n-  if (strict == COMPARE_STRICT && comparing_specializations\n-      && (t1 != TYPE_CANONICAL (t1) || t2 != TYPE_CANONICAL (t2)))\n-    /* If comparing_specializations, treat dependent aliases as distinct.  */\n-    strict = COMPARE_STRUCTURAL;\n-\n   if (strict == COMPARE_STRICT)\n     {\n       if (TYPE_STRUCTURAL_EQUALITY_P (t1) || TYPE_STRUCTURAL_EQUALITY_P (t2))"}, {"sha": "dd97479eff9b870424ac3655df816cd936634bcf", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-targ1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-targ1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0a231a4aa2407bb7167daf98a37795a67364d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-targ1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-targ1.C?ref=6e0a231a4aa2407bb7167daf98a37795a67364d8", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/98570\n+// { dg-do compile { target c++11 } }\n+\n+template <int> struct b { enum { c }; };\n+template <typename> using i = b<0>;\n+\n+template <int> struct d { };\n+template <typename l> d<i<l>::c> m() { }\n+template <typename n> d<i<n*>::c> m() { }"}]}