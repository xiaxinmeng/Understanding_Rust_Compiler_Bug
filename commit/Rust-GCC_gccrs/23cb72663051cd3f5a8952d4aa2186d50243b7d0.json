{"sha": "23cb72663051cd3f5a8952d4aa2186d50243b7d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNjYjcyNjYzMDUxY2QzZjVhODk1MmQ0YWEyMTg2ZDUwMjQzYjdkMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-05-13T19:18:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-05-13T19:18:35Z"}, "message": "Fix type-dependence and the current instantiation.\n\n\tPR c++/10200\n\tPR c++/69753\n\t* pt.c (tsubst_decl): Use uses_template_parms.\n\t(instantiate_template_1): Handle non-dependent calls in templates.\n\t(value_dependent_expression_p): Handle BASELINK, FUNCTION_DECL.\n\t(type_dependent_expression_p): Only consider innermost template\targs.\n\t(dependent_template_arg_p): Check enclosing class of a template here.\n\t(dependent_template_p): Not here.\n\t(type_dependent_object_expression_p): New.\n\t* typeck.c (finish_class_member_access_expr): Use it.\n\t* parser.c (cp_parser_postfix_expression): Use it.\n\t(cp_parser_postfix_dot_deref_expression): Use it.  Use comptypes\n\tto detect the current instantiation.\n\t(cp_parser_lookup_name): Really implement DR 141.\n\t* search.c (lookup_field_r): Prefer a dependent using-declaration.\n\t(any_dependent_bases_p): Split out from...\n\t* name-lookup.c (do_class_using_decl): ...here.\n\t* call.c (build_new_method_call_1): Use it.\n\t* semantics.c (finish_call_expr): 'this' doesn't make a call dependent.\n\t* tree.c (non_static_member_function_p): Remove.\n\t* typeck2.c (build_x_arrow): Use dependent_scope_p.\n\nFrom-SVN: r236221", "tree": {"sha": "e9aad0aad6326cf9be486f34c8cb1608f3166a1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9aad0aad6326cf9be486f34c8cb1608f3166a1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23cb72663051cd3f5a8952d4aa2186d50243b7d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23cb72663051cd3f5a8952d4aa2186d50243b7d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23cb72663051cd3f5a8952d4aa2186d50243b7d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23cb72663051cd3f5a8952d4aa2186d50243b7d0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "827e5d3f706ff07400025488c76e1ad7b3300d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827e5d3f706ff07400025488c76e1ad7b3300d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/827e5d3f706ff07400025488c76e1ad7b3300d83"}], "stats": {"total": 325, "additions": 207, "deletions": 118}, "files": [{"sha": "025c41274e2ec3a5d35ab512ff3376148739f85f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -1,5 +1,27 @@\n 2016-05-13  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/10200\n+\tPR c++/69753\n+\t* pt.c (tsubst_decl): Use uses_template_parms.\n+\t(instantiate_template_1): Handle non-dependent calls in templates.\n+\t(value_dependent_expression_p): Handle BASELINK, FUNCTION_DECL.\n+\t(type_dependent_expression_p): Only consider innermost template\targs.\n+\t(dependent_template_arg_p): Check enclosing class of a template here.\n+\t(dependent_template_p): Not here.\n+\t(type_dependent_object_expression_p): New.\n+\t* typeck.c (finish_class_member_access_expr): Use it.\n+\t* parser.c (cp_parser_postfix_expression): Use it.\n+\t(cp_parser_postfix_dot_deref_expression): Use it.  Use comptypes\n+\tto detect the current instantiation.\n+\t(cp_parser_lookup_name): Really implement DR 141.\n+\t* search.c (lookup_field_r): Prefer a dependent using-declaration.\n+\t(any_dependent_bases_p): Split out from...\n+\t* name-lookup.c (do_class_using_decl): ...here.\n+\t* call.c (build_new_method_call_1): Use it.\n+\t* semantics.c (finish_call_expr): 'this' doesn't make a call dependent.\n+\t* tree.c (non_static_member_function_p): Remove.\n+\t* typeck2.c (build_x_arrow): Use dependent_scope_p.\n+\n \t* parser.c (cp_parser_postfix_dot_deref_expression): Use\n \tcomplete_type_or_else for unknown_type_node, too.\n "}, {"sha": "0b59c403b31be5ca18a64767c665fbd3544f8302", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -8407,6 +8407,9 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t\t     we know we really need it.  */\n \t\t  cand->first_arg = instance;\n \t\t}\n+\t      else if (any_dependent_bases_p ())\n+\t\t/* We can't tell until instantiation time whether we can use\n+\t\t   *this as the implicit object argument.  */;\n \t      else\n \t\t{\n \t\t  if (complain & tf_error)"}, {"sha": "ad21cdf8334193a55599468ba797960b1059f6dc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -6125,6 +6125,7 @@ extern bool any_dependent_template_arguments_p  (const_tree);\n extern bool dependent_template_p\t\t(tree);\n extern bool dependent_template_id_p\t\t(tree, tree);\n extern bool type_dependent_expression_p\t\t(tree);\n+extern bool type_dependent_object_expression_p\t(tree);\n extern bool any_type_dependent_arguments_p      (const vec<tree, va_gc> *);\n extern bool any_type_dependent_elements_p       (const_tree);\n extern bool type_dependent_expression_p_push\t(tree);\n@@ -6233,6 +6234,7 @@ extern tree adjust_result_of_qualified_name_lookup\n extern tree copied_binfo\t\t\t(tree, tree);\n extern tree original_binfo\t\t\t(tree, tree);\n extern int shared_member_p\t\t\t(tree);\n+extern bool any_dependent_bases_p (tree = current_nonlambda_class_type ());\n \n /* The representation of a deferred access check.  */\n \n@@ -6525,7 +6527,6 @@ extern tree get_first_fn\t\t\t(tree);\n extern tree ovl_cons\t\t\t\t(tree, tree);\n extern tree build_overload\t\t\t(tree, tree);\n extern tree ovl_scope\t\t\t\t(tree);\n-extern bool non_static_member_function_p        (tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n extern const char *cxx_printable_name_translate\t(tree, int);\n extern tree build_exception_variant\t\t(tree, tree);"}, {"sha": "d32a1532e1ad74e14f27fbb8c107c8cc081e7666", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -3333,8 +3333,6 @@ do_class_using_decl (tree scope, tree name)\n   /* True if any of the bases of CURRENT_CLASS_TYPE are dependent.  */\n   bool bases_dependent_p;\n   tree binfo;\n-  tree base_binfo;\n-  int i;\n \n   if (name == error_mark_node)\n     return NULL_TREE;\n@@ -3371,16 +3369,7 @@ do_class_using_decl (tree scope, tree name)\n \t\t      || (IDENTIFIER_TYPENAME_P (name)\n \t\t\t  && dependent_type_p (TREE_TYPE (name))));\n \n-  bases_dependent_p = false;\n-  if (processing_template_decl)\n-    for (binfo = TYPE_BINFO (current_class_type), i = 0;\n-\t BINFO_BASE_ITERATE (binfo, i, base_binfo);\n-\t i++)\n-      if (dependent_type_p (TREE_TYPE (base_binfo)))\n-\t{\n-\t  bases_dependent_p = true;\n-\t  break;\n-\t}\n+  bases_dependent_p = any_dependent_bases_p ();\n \n   decl = NULL_TREE;\n "}, {"sha": "539f16540634745411d21ede786eefb6aa512e69", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -6851,7 +6851,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\ttree fn = TREE_OPERAND (postfix_expression, 1);\n \n \t\tif (processing_template_decl\n-\t\t    && (type_dependent_expression_p (instance)\n+\t\t    && (type_dependent_object_expression_p (instance)\n \t\t\t|| (!BASELINK_P (fn)\n \t\t\t    && TREE_CODE (fn) != FIELD_DECL)\n \t\t\t|| type_dependent_expression_p (fn)\n@@ -7186,8 +7186,9 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n   if (token_type == CPP_DEREF)\n     postfix_expression = build_x_arrow (location, postfix_expression,\n \t\t\t\t\ttf_warning_or_error);\n-  /* Check to see whether or not the expression is type-dependent.  */\n-  dependent_p = type_dependent_expression_p (postfix_expression);\n+  /* Check to see whether or not the expression is type-dependent and\n+     not the current instantiation.  */\n+  dependent_p = type_dependent_object_expression_p (postfix_expression);\n   /* The identifier following the `->' or `.' is not qualified.  */\n   parser->scope = NULL_TREE;\n   parser->qualifying_scope = NULL_TREE;\n@@ -7211,7 +7212,10 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t required to be of complete type for purposes of class member\n \t access (5.2.5) outside the member function body.  */\n       if (postfix_expression != current_class_ref\n-\t  && !(processing_template_decl && scope == current_class_type))\n+\t  && !(processing_template_decl\n+\t       && current_class_type\n+\t       && (same_type_ignoring_top_level_qualifiers_p\n+\t\t   (scope, current_class_type))))\n \tscope = complete_type_or_else (scope, postfix_expression);\n       /* Let the name lookup machinery know that we are processing a\n \t class member access expression.  */\n@@ -24806,24 +24810,11 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \tdecl = NULL_TREE;\n \n       if (!decl)\n-\t{\n-\t  /* Look it up in the enclosing context.  */\n-\t  decl = lookup_name_real (name, tag_type != none_type,\n-\t\t\t\t   /*nonclass=*/0,\n-\t\t\t\t   /*block_p=*/true, is_namespace, 0);\n-\t  /* DR 141 says when looking for a template-name after -> or ., only\n-\t     consider class templates.  We need to fix our handling of\n-\t     dependent expressions to implement that properly, but for now\n-\t     let's ignore namespace-scope function templates.  */\n-\t  if (decl && is_template && !DECL_TYPE_TEMPLATE_P (decl))\n-\t    {\n-\t      tree d = decl;\n-\t      if (is_overloaded_fn (d))\n-\t\td = get_first_fn (d);\n-\t      if (DECL_P (d) && !DECL_CLASS_SCOPE_P (d))\n-\t\tdecl = NULL_TREE;\n-\t    }\n-\t}\n+\t/* Look it up in the enclosing context.  DR 141: When looking for a\n+\t   template-name after -> or ., only consider class templates.  */\n+\tdecl = lookup_name_real (name, tag_type != none_type || is_template,\n+\t\t\t\t /*nonclass=*/0,\n+\t\t\t\t /*block_p=*/true, is_namespace, 0);\n       if (object_type == unknown_type_node)\n \t/* The object is type-dependent, so we can't look anything up; we used\n \t   this to get the DR 141 behavior.  */"}, {"sha": "65bfd42a2e7c44f67d266b355ea352e0233d06a4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 67, "deletions": 36, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -11700,16 +11700,9 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (TREE_CODE (DECL_TI_TEMPLATE (t)) == TEMPLATE_DECL)\n \t  {\n \t    tree spec;\n-\t    bool dependent_p;\n \n-\t    /* If T is not dependent, just return it.  We have to\n-\t       increment PROCESSING_TEMPLATE_DECL because\n-\t       value_dependent_expression_p assumes that nothing is\n-\t       dependent when PROCESSING_TEMPLATE_DECL is zero.  */\n-\t    ++processing_template_decl;\n-\t    dependent_p = value_dependent_expression_p (t);\n-\t    --processing_template_decl;\n-\t    if (!dependent_p)\n+\t    /* If T is not dependent, just return it.  */\n+\t    if (!uses_template_parms (DECL_TI_ARGS (t)))\n \t      RETURN (t);\n \n \t    /* Calculate the most general template of which R is a\n@@ -17328,12 +17321,14 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n \n   /* Check to see if we already have this specialization.  */\n   gen_tmpl = most_general_template (tmpl);\n-  if (tmpl != gen_tmpl)\n-    /* The TMPL is a partial instantiation.  To get a full set of\n-       arguments we must add the arguments used to perform the\n-       partial instantiation.  */\n-    targ_ptr = add_outermost_template_args (DECL_TI_ARGS (tmpl),\n-\t\t\t\t\t    targ_ptr);\n+  if (TMPL_ARGS_DEPTH (targ_ptr)\n+      < TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (gen_tmpl)))\n+    /* targ_ptr only has the innermost template args, so add the outer ones\n+       from tmpl, which could be either a partial instantiation or gen_tmpl (in\n+       the case of a non-dependent call within a template definition).  */\n+    targ_ptr = (add_outermost_template_args\n+\t\t(DECL_TI_ARGS (DECL_TEMPLATE_RESULT (tmpl)),\n+\t\t targ_ptr));\n \n   /* It would be nice to avoid hashing here and then again in tsubst_decl,\n      but it doesn't seem to be on the hot path.  */\n@@ -22653,6 +22648,22 @@ value_dependent_expression_p (tree expression)\n \n   switch (TREE_CODE (expression))\n     {\n+    case BASELINK:\n+      /* A member function of a dependent class has dependent template\n+\t arguments from its class.  */\n+      if (dependent_type_p (BINFO_TYPE (BASELINK_BINFO (expression))))\n+\treturn true;\n+      return value_dependent_expression_p (BASELINK_FUNCTIONS (expression));\n+\n+    case FUNCTION_DECL:\n+      /* A function template specialization is value-dependent if it has any\n+\t dependent template arguments, since that means it cannot be\n+\t instantiated for constexpr evaluation.  */\n+      if (DECL_LANG_SPECIFIC (expression)\n+\t  && DECL_TEMPLATE_INFO (expression))\n+\treturn any_dependent_template_arguments_p (DECL_TI_ARGS (expression));\n+      break;\n+\n     case IDENTIFIER_NODE:\n       /* A name that has not been looked up -- must be dependent.  */\n       return true;\n@@ -22797,10 +22808,10 @@ value_dependent_expression_p (tree expression)\n \n     case CALL_EXPR:\n       {\n+\tif (value_dependent_expression_p (CALL_EXPR_FN (expression)))\n+\t  return true;\n \ttree fn = get_callee_fndecl (expression);\n \tint i, nargs;\n-\tif (!fn && value_dependent_expression_p (CALL_EXPR_FN (expression)))\n-\t  return true;\n \tnargs = call_expr_nargs (expression);\n \tfor (i = 0; i < nargs; ++i)\n \t  {\n@@ -22964,13 +22975,6 @@ type_dependent_expression_p (tree expression)\n \t      || dependent_scope_p (scope));\n     }\n \n-  /* A function template specialization is type-dependent if it has any\n-     dependent template arguments.  */\n-  if (TREE_CODE (expression) == FUNCTION_DECL\n-      && DECL_LANG_SPECIFIC (expression)\n-      && DECL_TEMPLATE_INFO (expression))\n-    return any_dependent_template_arguments_p (DECL_TI_ARGS (expression));\n-\n   if (TREE_CODE (expression) == TEMPLATE_DECL\n       && !DECL_TEMPLATE_TEMPLATE_PARM_P (expression))\n     return false;\n@@ -23023,13 +23027,18 @@ type_dependent_expression_p (tree expression)\n       && DECL_INITIAL (expression))\n    return true;\n \n-  /* A variable template specialization is type-dependent if it has any\n-     dependent template arguments.  */\n-  if (VAR_P (expression)\n+  /* A function or variable template-id is type-dependent if it has any\n+     dependent template arguments.  Note that we only consider the innermost\n+     template arguments here, since those are the ones that come from the\n+     template-id; the template arguments for the enclosing class do not make it\n+     type-dependent, they only make a member function value-dependent.  */\n+  if (VAR_OR_FUNCTION_DECL_P (expression)\n       && DECL_LANG_SPECIFIC (expression)\n       && DECL_TEMPLATE_INFO (expression)\n-      && variable_template_p (DECL_TI_TEMPLATE (expression)))\n-    return any_dependent_template_arguments_p (DECL_TI_ARGS (expression));\n+      && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (expression))\n+      && (any_dependent_template_arguments_p\n+\t  (INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n+    return true;\n \n   /* Always dependent, on the number of arguments if nothing else.  */\n   if (TREE_CODE (expression) == EXPR_PACK_EXPANSION)\n@@ -23087,6 +23096,22 @@ type_dependent_expression_p (tree expression)\n   return (dependent_type_p (TREE_TYPE (expression)));\n }\n \n+/* [temp.dep.expr]/5: A class member access expression (5.2.5) is\n+   type-dependent if the expression refers to a member of the current\n+   instantiation and the type of the referenced member is dependent, or the\n+   class member access expression refers to a member of an unknown\n+   specialization.\n+\n+   This function returns true if the OBJECT in such a class member access\n+   expression is of an unknown specialization.  */\n+\n+bool\n+type_dependent_object_expression_p (tree object)\n+{\n+  tree scope = TREE_TYPE (object);\n+  return (!scope || dependent_scope_p (scope));\n+}\n+\n /* walk_tree callback function for instantiation_dependent_expression_p,\n    below.  Returns non-zero if a dependent subexpression is found.  */\n \n@@ -23291,9 +23316,18 @@ dependent_template_arg_p (tree arg)\n   if (TREE_CODE (arg) == ARGUMENT_PACK_SELECT)\n     arg = ARGUMENT_PACK_SELECT_ARG (arg);\n \n-  if (TREE_CODE (arg) == TEMPLATE_DECL\n-      || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-    return dependent_template_p (arg);\n+  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+    return true;\n+  if (TREE_CODE (arg) == TEMPLATE_DECL)\n+    {\n+      if (DECL_TEMPLATE_PARM_P (arg))\n+\treturn true;\n+      /* A member template of a dependent class is not necessarily\n+\t type-dependent, but it is a dependent template argument because it\n+\t will be a member of an unknown specialization to that template.  */\n+      tree scope = CP_DECL_CONTEXT (arg);\n+      return TYPE_P (scope) && dependent_type_p (scope);\n+    }\n   else if (ARGUMENT_PACK_P (arg))\n     {\n       tree args = ARGUMENT_PACK_ARGS (arg);\n@@ -23389,7 +23423,7 @@ any_dependent_template_arguments_p (const_tree args)\n   return false;\n }\n \n-/* Returns TRUE if the template TMPL is dependent.  */\n+/* Returns TRUE if the template TMPL is type-dependent.  */\n \n bool\n dependent_template_p (tree tmpl)\n@@ -23412,9 +23446,6 @@ dependent_template_p (tree tmpl)\n   /* So are names that have not been looked up.  */\n   if (TREE_CODE (tmpl) == SCOPE_REF || identifier_p (tmpl))\n     return true;\n-  /* So are member templates of dependent classes.  */\n-  if (TYPE_P (CP_DECL_CONTEXT (tmpl)))\n-    return dependent_type_p (DECL_CONTEXT (tmpl));\n   return false;\n }\n "}, {"sha": "f47833f0686aeea307371ea8bf9d45bca61da39a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -1106,6 +1106,14 @@ lookup_field_r (tree binfo, void *data)\n   if (!nval)\n     /* Look for a data member or type.  */\n     nval = lookup_field_1 (type, lfi->name, lfi->want_type);\n+  else if (TREE_CODE (nval) == OVERLOAD && OVL_USED (nval))\n+    {\n+      /* If we have both dependent and non-dependent using-declarations, return\n+\t the dependent one rather than an incomplete list of functions.  */\n+      tree dep_using = lookup_field_1 (type, lfi->name, lfi->want_type);\n+      if (dep_using && TREE_CODE (dep_using) == USING_DECL)\n+\tnval = dep_using;\n+    }\n \n   /* If there is no declaration with the indicated name in this type,\n      then there's nothing to do.  */\n@@ -2844,3 +2852,21 @@ original_binfo (tree binfo, tree here)\n   return result;\n }\n \n+/* True iff TYPE has any dependent bases (and therefore we can't say\n+   definitively that another class is not a base of an instantiation of\n+   TYPE).  */\n+\n+bool\n+any_dependent_bases_p (tree type)\n+{\n+  if (!type || !CLASS_TYPE_P (type) || !processing_template_decl)\n+    return false;\n+\n+  unsigned i;\n+  tree base_binfo;\n+  FOR_EACH_VEC_SAFE_ELT (BINFO_BASE_BINFOS (TYPE_BINFO (type)), i, base_binfo)\n+    if (BINFO_DEPENDENT_BASE_P (base_binfo))\n+      return true;\n+\n+  return false;\n+}"}, {"sha": "06dee5a66698bd16233520892e72fbf1ebe3e834", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -2300,18 +2300,7 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \t with no type; type_dependent_expression_p recognizes\n \t expressions with no type as being dependent.  */\n       if (type_dependent_expression_p (fn)\n-\t  || any_type_dependent_arguments_p (*args)\n-\t  /* For a non-static member function that doesn't have an\n-\t     explicit object argument, we need to specifically\n-\t     test the type dependency of the \"this\" pointer because it\n-\t     is not included in *ARGS even though it is considered to\n-\t     be part of the list of arguments.  Note that this is\n-\t     related to CWG issues 515 and 1005.  */\n-\t  || (TREE_CODE (fn) != COMPONENT_REF\n-\t      && non_static_member_function_p (fn)\n-\t      && !DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (get_first_fn (fn))\n-\t      && current_class_ref\n-\t      && type_dependent_expression_p (current_class_ref)))\n+\t  || any_type_dependent_arguments_p (*args))\n \t{\n \t  result = build_nt_call_vec (fn, *args);\n \t  SET_EXPR_LOCATION (result, EXPR_LOC_OR_LOC (fn, input_location));\n@@ -2399,17 +2388,6 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \tobject = maybe_dummy_object (BINFO_TYPE (BASELINK_ACCESS_BINFO (fn)),\n \t\t\t\t     NULL);\n \n-      if (processing_template_decl)\n-\t{\n-\t  if (type_dependent_expression_p (object))\n-\t    {\n-\t      tree ret = build_nt_call_vec (orig_fn, orig_args);\n-\t      release_tree_vector (orig_args);\n-\t      return ret;\n-\t    }\n-\t  object = build_non_dependent_expr (object);\n-\t}\n-\n       result = build_new_method_call (object, fn, args, NULL_TREE,\n \t\t\t\t      (disallow_virtual\n \t\t\t\t       ? LOOKUP_NORMAL|LOOKUP_NONVIRTUAL"}, {"sha": "04702ee1c006cae956f8183ffcb87182258d28b6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -2127,23 +2127,6 @@ ovl_scope (tree ovl)\n     ovl = OVL_CHAIN (ovl);\n   return CP_DECL_CONTEXT (OVL_CURRENT (ovl));\n }\n-\n-/* Return TRUE if FN is a non-static member function, FALSE otherwise.\n-   This function looks into BASELINK and OVERLOAD nodes.  */\n-\n-bool\n-non_static_member_function_p (tree fn)\n-{\n-  if (fn == NULL_TREE)\n-    return false;\n-\n-  if (is_overloaded_fn (fn))\n-    fn = get_first_fn (fn);\n-\n-  return (DECL_P (fn)\n-\t  && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn));\n-}\n-\n \f\n #define PRINT_RING_SIZE 4\n "}, {"sha": "cd058fa258ec43f4a63b6b4a365adff5ca56bcd4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -2668,7 +2668,7 @@ finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n   if (processing_template_decl)\n     {\n       if (/* If OBJECT is dependent, so is OBJECT.NAME.  */\n-\t  type_dependent_expression_p (object)\n+\t  type_dependent_object_expression_p (object)\n \t  /* If NAME is \"f<args>\", where either 'f' or 'args' is\n \t     dependent, then the expression is dependent.  */\n \t  || (TREE_CODE (name) == TEMPLATE_ID_EXPR\n@@ -2678,9 +2678,12 @@ finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n \t     expression is dependent.  */\n \t  || (TREE_CODE (name) == SCOPE_REF\n \t      && TYPE_P (TREE_OPERAND (name, 0))\n-\t      && dependent_type_p (TREE_OPERAND (name, 0))))\n-\treturn build_min_nt_loc (UNKNOWN_LOCATION, COMPONENT_REF,\n-\t\t\t\t object.get_value (), name, NULL_TREE);\n+\t      && dependent_scope_p (TREE_OPERAND (name, 0))))\n+\t{\n+\tdependent:\n+\t  return build_min_nt_loc (UNKNOWN_LOCATION, COMPONENT_REF,\n+\t\t\t\t   orig_object, name, NULL_TREE);\n+\t}\n       object = build_non_dependent_expr (object);\n     }\n   else if (c_dialect_objc ()\n@@ -2805,14 +2808,22 @@ finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n \t}\n \n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\tmember = lookup_destructor (object, scope, name, complain);\n+\t{\n+\t  if (dependent_type_p (object_type))\n+\t    /* The destructor isn't declared yet.  */\n+\t    goto dependent;\n+\t  member = lookup_destructor (object, scope, name, complain);\n+\t}\n       else\n \t{\n \t  /* Look up the member.  */\n \t  member = lookup_member (access_path, name, /*protect=*/1,\n \t\t\t\t  /*want_type=*/false, complain);\n \t  if (member == NULL_TREE)\n \t    {\n+\t      if (dependent_type_p (object_type))\n+\t\t/* Try again at instantiation time.  */\n+\t\tgoto dependent;\n \t      if (complain & tf_error)\n \t\t{\n \t\t  tree guessed_id = lookup_member_fuzzy (access_path, name,\n@@ -2842,6 +2853,8 @@ finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n \t    }\n \t  if (member == error_mark_node)\n \t    return error_mark_node;\n+\t  if (TREE_CODE (member) == USING_DECL && DECL_DEPENDENT_P (member))\n+\t    goto dependent;\n \t}\n \n       if (is_template_id)"}, {"sha": "833be20f7fed43b2a8bf35bac38e3f1e9d490526", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -1703,7 +1703,10 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \n   if (processing_template_decl)\n     {\n-      if (type_dependent_expression_p (expr))\n+      if (type && TREE_CODE (type) == POINTER_TYPE\n+\t  && !dependent_scope_p (TREE_TYPE (type)))\n+\t/* Pointer to current instantiation, don't treat as dependent.  */;\n+      else if (type_dependent_expression_p (expr))\n \treturn build_min_nt_loc (loc, ARROW_EXPR, expr);\n       expr = build_non_dependent_expr (expr);\n     }"}, {"sha": "6fab2f9d17b0175970f84943fa4a47854e85c241", "filename": "gcc/testsuite/g++.dg/lookup/member4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember4.C?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/69753\n+// { dg-do compile { target c++11 } }\n+\n+class A {\n+public:\n+  template <typename> void As();\n+  static A *FromWebContents();\n+  A *FromWebContents2();\n+};\n+template <typename T> class B : A {\n+  void FromWebContents() {\n+    auto guest = this->A::FromWebContents();\n+    guest ? guest->As<T>() : nullptr;\n+    auto guest2 = this->A::FromWebContents2();\n+    guest2 ? guest2->As<T>() : nullptr;\n+  }\n+};"}, {"sha": "fec1ecd5bfd49b8461e68479d83248f939d3abfb", "filename": "gcc/testsuite/g++.dg/lookup/member5.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fmember5.C?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/69753\n+// { dg-do compile { target c++11 } }\n+\n+struct B {\n+  template <class> void bfn ();\n+};\n+\n+template <class T>\n+constexpr int x(T) { return 42; }\n+\n+template <int I>\n+struct C\n+{\n+  template <class> void cfn ();\n+};\n+\n+template <typename T> struct A {\n+  static B fn(int);\n+  template <class U> static B ft(U);\n+\n+  void g()\n+  {\n+    auto b = this->fn(42);\n+    b.bfn<int>();\n+\n+    auto b2 = this->ft(42);\n+    b2.bfn<int>();\n+\n+    auto c = C<x(42)>();\n+    c.cfn<int>();\n+  }\n+};"}, {"sha": "f1d9799343b49a7462d5e27b6537f29dbe7991c3", "filename": "gcc/testsuite/g++.dg/template/using14.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23cb72663051cd3f5a8952d4aa2186d50243b7d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing14.C?ref=23cb72663051cd3f5a8952d4aa2186d50243b7d0", "patch": "@@ -17,5 +17,5 @@ template <class T> struct C : public B1<T>, public B2\n int main()\n {\n   C<int> c;\n-  c.f();\t\t\t// { dg-message \"required\" }\n+  c.f();\n }"}]}