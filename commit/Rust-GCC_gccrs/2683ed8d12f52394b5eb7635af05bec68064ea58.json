{"sha": "2683ed8d12f52394b5eb7635af05bec68064ea58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4M2VkOGQxMmY1MjM5NGI1ZWI3NjM1YWYwNWJlYzY4MDY0ZWE1OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-10-17T09:34:21Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-10-17T09:34:21Z"}, "message": "Improved sequence point warnings\n\nFrom-SVN: r36901", "tree": {"sha": "9a9bf64517120736c23b7a0ecdb4c40f71e7b674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a9bf64517120736c23b7a0ecdb4c40f71e7b674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2683ed8d12f52394b5eb7635af05bec68064ea58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2683ed8d12f52394b5eb7635af05bec68064ea58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2683ed8d12f52394b5eb7635af05bec68064ea58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2683ed8d12f52394b5eb7635af05bec68064ea58/comments", "author": null, "committer": null, "parents": [{"sha": "9ece379a8a290603ecbafcd30dac259fc7c880a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ece379a8a290603ecbafcd30dac259fc7c880a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ece379a8a290603ecbafcd30dac259fc7c880a4"}], "stats": {"total": 447, "additions": 306, "deletions": 141}, "files": [{"sha": "15904fab2dcbc30373ef170af21682853802d6e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -1,3 +1,17 @@\n+2000-10-17  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* c-tree.h (warn_sequence_point): Move declaration to...\n+\t* c-common.h (warn_sequence_point): ... here.\n+\t* c-decl.c (warn_sequence_point): Move definition to...\n+\t* c-common.c (warn_sequence_point): ... here.\n+\t(struct reverse_tree): New.\n+\t(reverse_list, reverse_max_depth): New static variables.\n+\t(build_reverse_tree, common_ancestor, modify_ok\n+\tverify_sequence_points): New functions.\n+\t(c_expand_expr_stmt): Call verify_sequence_points if -Wsequence-point.\n+\t* c-typeck.c (check_modify_expr): Delete.\n+\t(build_modify_expr): Don't call it.\n+\n 2000-10-17  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-common.h (warn_missing_format_attribute): New variable."}, {"sha": "f1989e5f396c44bc18851b641d84a35ebdc3ce9b", "filename": "gcc/c-common.c", "status": "modified", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -140,6 +140,10 @@ cpp_reader  parse_in;\n \n tree c_global_trees[CTI_MAX];\n \n+/* Nonzero means warn about possible violations of sequence point rules.  */\n+\n+int warn_sequence_point;\n+\n /* The elements of `ridpointers' are identifier nodes for the reserved\n    type names and storage classes.  It is indexed by a RID_... value.  */\n tree *ridpointers;\n@@ -3346,6 +3350,263 @@ convert_and_check (type, expr)\n   return t;\n }\n \f\n+/* Describe a reversed version of a normal tree, so that we can get to the\n+   parent of each node.  */\n+struct reverse_tree\n+{\n+  /* All reverse_tree structures for a given tree are chained through this\n+     field.  */\n+  struct reverse_tree *next;\n+  /* The parent of this node.  */\n+  struct reverse_tree *parent;\n+  /* The actual tree node.  */\n+  tree x;\n+  /* The operand number this node corresponds to in the parent.  */\n+  int operandno;\n+  /* Describe whether this expression is written to or read.  */\n+  char read, write;\n+};\n+\n+/* A list of all reverse_tree structures for a given expression, built by\n+   build_reverse_tree.  */\n+static struct reverse_tree *reverse_list;\n+/* The maximum depth of a tree, computed by build_reverse_tree.  */\n+static int reverse_max_depth;\n+\n+static void build_reverse_tree PARAMS ((tree, struct reverse_tree *, int, int,\n+\t\t\t\t\tint, int));\n+static struct reverse_tree *common_ancestor PARAMS ((struct reverse_tree *,\n+\t\t\t\t\t\t     struct reverse_tree *,\n+\t\t\t\t\t\t     struct reverse_tree **,\n+\t\t\t\t\t\t     struct reverse_tree **));\n+static int modify_ok PARAMS ((struct reverse_tree *, struct reverse_tree *));\n+static void verify_sequence_points PARAMS ((tree));\n+\n+/* Recursively process an expression, X, building a reverse tree while\n+   descending and recording OPERANDNO, READ, and WRITE in the created\n+   structures.  DEPTH is used to compute reverse_max_depth.\n+   FIXME: if walk_tree gets moved out of the C++ front end, this should\n+   probably use walk_tree.  */\n+\n+static void\n+build_reverse_tree (x, parent, operandno, read, write, depth)\n+     tree x;\n+     struct reverse_tree *parent;\n+     int operandno, read, write, depth;\n+{\n+  struct reverse_tree *node;\n+\n+  if (x == 0 || x == error_mark_node)\n+    return;\n+\n+  node = (struct reverse_tree *) xmalloc (sizeof (struct reverse_tree));\n+\n+  node->parent = parent;\n+  node->x = x;\n+  node->read = read;\n+  node->write = write;\n+  node->operandno = operandno;\n+  node->next = reverse_list;\n+  reverse_list = node;\n+  if (depth > reverse_max_depth)\n+    reverse_max_depth = depth;\n+\n+  switch (TREE_CODE (x))\n+    {\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      build_reverse_tree (TREE_OPERAND (x, 0), node, 0, 1, 1, depth + 1);\n+      break;\n+\n+    case CALL_EXPR:\n+      build_reverse_tree (TREE_OPERAND (x, 0), node, 0, 1, 0, depth + 1);\n+      x = TREE_OPERAND (x, 1);\n+      while (x)\n+\t{\n+\t  build_reverse_tree (TREE_VALUE (x), node, 1, 1, 0, depth + 1);\n+\t  x = TREE_CHAIN (x);\n+\t}\n+      break;\n+\n+    case TREE_LIST:\n+      /* Scan all the list, e.g. indices of multi dimensional array.  */\n+      while (x)\n+\t{\n+\t  build_reverse_tree (TREE_VALUE (x), node, 0, 1, 0, depth + 1);\n+\t  x = TREE_CHAIN (x);\n+\t}\n+      break;\n+\n+    case MODIFY_EXPR:\n+      build_reverse_tree (TREE_OPERAND (x, 0), node, 0, 0, 1, depth + 1);\n+      build_reverse_tree (TREE_OPERAND (x, 1), node, 1, 1, 0, depth + 1);\n+      break;\n+\n+    default:\n+      switch (TREE_CODE_CLASS (TREE_CODE (x)))\n+\t{\n+\tcase 'r':\n+\tcase '<':\n+\tcase '2':\n+\tcase 'b':\n+\tcase '1':\n+\tcase 'e':\n+\tcase 's':\n+\tcase 'x':\n+\t  {\n+\t    int lp;\n+\t    int max = first_rtl_op (TREE_CODE (x));\n+\t    for (lp = 0; lp < max; lp++)\n+\t      build_reverse_tree (TREE_OPERAND (x, lp), node, lp, 1, 0,\n+\t\t\t\t  depth + 1);\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+    }\n+}\n+\n+/* Given nodes P1 and P2 as well as enough scratch space pointed to by TMP1\n+   and TMP2, find the common ancestor of P1 and P2.  */\n+\n+static struct reverse_tree *\n+common_ancestor (p1, p2, tmp1, tmp2)\n+     struct reverse_tree *p1, *p2;\n+     struct reverse_tree **tmp1, **tmp2;\n+{\n+  struct reverse_tree *t1 = p1;\n+  struct reverse_tree *t2 = p2;\n+  int i, j;\n+\n+  /* First, check if we're actually looking at the same expression twice,\n+     which can happen if it's wrapped in a SAVE_EXPR - in this case there's\n+     no chance of conflict.  */\n+  while (t1 && t2 && t1->x == t2->x)\n+    {\n+      if (TREE_CODE (t1->x) == SAVE_EXPR)\n+\treturn 0;\n+      t1 = t1->parent;\n+      t2 = t2->parent;\n+    }\n+\n+  for (i = 0; p1; i++, p1 = p1->parent)\n+    tmp1[i] = p1;\n+  for (j = 0; p2; j++, p2 = p2->parent)\n+    tmp2[j] = p2;\n+  while (tmp1[i - 1] == tmp2[j - 1])\n+    i--, j--;\n+\n+  return tmp1[i];\n+}\n+\n+/* Subroutine of verify_sequence_points to check whether a node T corresponding\n+   to a MODIFY_EXPR invokes undefined behaviour.  OTHER occurs somewhere in the\n+   RHS, and an identical expression is the LHS of T.\n+   For MODIFY_EXPRs, some special cases apply when testing for undefined\n+   behaviour if one of the expressions we found is the LHS of the MODIFY_EXPR.\n+   If the other expression is just a use, then there's no undefined behaviour.\n+   Likewise, if the other expression is wrapped inside another expression that\n+   will force a sequence point, then there's no undefined behaviour either.  */\n+\n+static int\n+modify_ok (t, other)\n+     struct reverse_tree *t, *other;\n+{\n+  struct reverse_tree *p;\n+\n+  if (! other->write)\n+    return 1;\n+\n+  /* See if there's an intervening sequence point.  */\n+  for (p = other; p->parent != t; p = p->parent)\n+    {\n+      if ((TREE_CODE (p->parent->x) == COMPOUND_EXPR\n+\t   || TREE_CODE (p->parent->x) == TRUTH_ANDIF_EXPR\n+\t   || TREE_CODE (p->parent->x) == TRUTH_ORIF_EXPR\n+\t   || TREE_CODE (p->parent->x) == COND_EXPR)\n+\t  && p->operandno == 0)\n+\treturn 1;\n+      if (TREE_CODE (p->parent->x) == SAVE_EXPR)\n+\treturn 1;\n+      if (TREE_CODE (p->parent->x) == CALL_EXPR\n+\t  && p->operandno != 0)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Try to warn for undefined behaviour in EXPR due to missing sequence\n+   points.  */\n+\n+static void\n+verify_sequence_points (expr)\n+     tree expr;\n+{\n+  struct reverse_tree **tmp1, **tmp2;\n+  struct reverse_tree *p;\n+\n+  reverse_list = 0;\n+  reverse_max_depth = 0;\n+  build_reverse_tree (expr, NULL, 0, 1, 0, 1);\n+\n+  tmp1 = (struct reverse_tree **) xmalloc (sizeof (struct reverse_tree *)\n+\t\t\t\t\t   * reverse_max_depth);\n+  tmp2 = (struct reverse_tree **) xmalloc (sizeof (struct reverse_tree *)\n+\t\t\t\t\t   * reverse_max_depth);\n+\n+  /* Search for multiple occurrences of the same variable, where either both\n+     occurrences are writes, or one is a read and a write.  If we can't prove\n+     that these are ordered by a sequence point, warn that the expression is\n+     undefined.  */\n+  for (p = reverse_list; p; p = p->next)\n+    {\n+      struct reverse_tree *p2;\n+      if (TREE_CODE (p->x) != VAR_DECL && TREE_CODE (p->x) != PARM_DECL)\n+\tcontinue;\n+      for (p2 = p->next; p2; p2 = p2->next)\n+\t{\n+\t  if ((TREE_CODE (p2->x) == VAR_DECL || TREE_CODE (p2->x) == PARM_DECL)\n+\t      && DECL_NAME (p->x) == DECL_NAME (p2->x)\n+\t      && (p->write || p2->write))\n+\t    {\n+\t      struct reverse_tree *t = common_ancestor (p, p2, tmp1, tmp2);\n+\n+\t      if (t == 0\n+\t\t  || TREE_CODE (t->x) == COMPOUND_EXPR\n+\t\t  || TREE_CODE (t->x) == TRUTH_ANDIF_EXPR\n+\t\t  || TREE_CODE (t->x) == TRUTH_ORIF_EXPR\n+\t\t  || TREE_CODE (t->x) == COND_EXPR)\n+\t\tcontinue;\n+\t      if (TREE_CODE (t->x) == MODIFY_EXPR\n+\t\t  && p->parent == t\n+\t\t  && modify_ok (t, p2))\n+\t\tcontinue;\n+\t      if (TREE_CODE (t->x) == MODIFY_EXPR\n+\t\t  && p2->parent == t\n+\t\t  && modify_ok (t, p))\n+\t\tcontinue;\n+\n+\t      warning (\"operation on `%s' may be undefined\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (p->x)));\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  while (reverse_list)\n+    {\n+      struct reverse_tree *p = reverse_list;\n+      reverse_list = p->next;\n+      free (p);\n+    }\n+  free (tmp1);\n+  free (tmp2);\n+}\n+\n void\n c_expand_expr_stmt (expr)\n      tree expr;\n@@ -3356,6 +3617,9 @@ c_expand_expr_stmt (expr)\n       || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n     expr = default_conversion (expr);\n \n+  if (warn_sequence_point)\n+    verify_sequence_points (expr);\n+\n   if (TREE_TYPE (expr) != error_mark_node\n       && !COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (expr))\n       && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)"}, {"sha": "2280b93a93e80967f8171b48de202d4231b18ec8", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -337,6 +337,10 @@ extern int flag_const_strings;\n \n extern int warn_format;\n \n+/* Warn about possible violations of sequence point rules.  */\n+\n+extern int warn_sequence_point;\n+\n /* Warn about functions which might be candidates for format attributes.  */\n \n extern int warn_missing_format_attribute;"}, {"sha": "9ca6f97a5ad8539adfffc1ee54b648d48b458a6e", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -498,10 +498,6 @@ int warn_float_equal = 0;\n \n int warn_multichar = 1;\n \n-/* Nonzero means warn about possible violations of sequence point rules.  */\n-\n-int warn_sequence_point;\n-\n /* The variant of the C language being processed.  */\n \n c_language_kind c_language = clk_c;"}, {"sha": "b8adce15454f6aae02dc5b472f3bd7901ead2d67", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -366,10 +366,6 @@ extern int warn_missing_braces;\n \n extern int warn_sign_compare;\n \n-/* Warn about possible violations of sequence point rules.  */\n-\n-extern int warn_sequence_point;\n-\n /* Warn about testing equality of floating point numbers. */\n \n extern int warn_float_equal;"}, {"sha": "0d2209e501a473621636ef262cd384bf2ef9e6d8", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -61,7 +61,6 @@ static tree pointer_diff\t\tPARAMS ((tree, tree));\n static tree unary_complex_lvalue\tPARAMS ((enum tree_code, tree));\n static void pedantic_lvalue_warning\tPARAMS ((enum tree_code));\n static tree internal_build_compound_expr PARAMS ((tree, int));\n-static void check_modify_expr\t\tPARAMS ((tree, tree));\n static tree convert_for_assignment\tPARAMS ((tree, tree, const char *,\n \t\t\t\t\t\t tree, tree, int));\n static void warn_for_assignment\t\tPARAMS ((const char *, const char *,\n@@ -3815,132 +3814,6 @@ build_c_cast (type, expr)\n \n   return value;\n }\n-\f\n-/* Recursive check for expressions that break the sequence point rules\n-   and so have undefined semantics (e.g. n = n++).  FIXME: if walk_tree\n-   gets moved out of the C++ front end, this should probably be moved\n-   to code shared between the front ends and use walk_tree.  */\n-static void\n-check_modify_expr (lhs, rhs)\n-     tree lhs, rhs;\n-{\n-  tree identifier_name;   /* A VAR_DECL name on the LHS that could\n-\t\t\t     be the same as one on the RHS. */\n-  identifier_name = NULL_TREE;\n-\n-  if ((lhs == NULL_TREE) || (rhs == NULL_TREE))\n-    return;\n-\n-  switch (TREE_CODE (rhs))\n-    {\n-    case ERROR_MARK:\n-      return;\n-    case VAR_DECL:\n-    case PARM_DECL:\n-      identifier_name = DECL_NAME (rhs);\n-      break;\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-      {\n-\ttree var_decl = TREE_OPERAND (rhs, 0);\n-\tif (TREE_CODE (var_decl) == VAR_DECL\n-\t    || TREE_CODE (var_decl) == PARM_DECL)\n-\t  identifier_name = DECL_NAME (var_decl);\n-      }\n-      break;\n-    case TREE_LIST:\n-      {\n-\ttree parm = TREE_CHAIN (rhs);\n-\t/* Now scan all the list, e.g. indices of multi dimensional array.  */\n-\twhile (parm)\n-\t  {\n-\t    check_modify_expr (lhs, TREE_VALUE (parm));\n-\t    parm = TREE_CHAIN (parm);\n-\t  }\n-      }\n-      return;\n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n-    case NON_LVALUE_EXPR:\n-      check_modify_expr (lhs, TREE_OPERAND (rhs, 0));\n-      return;\n-    case MODIFY_EXPR:\n-      /* First check for form a = b = a++ by checking RHS.  */\n-      check_modify_expr (lhs, TREE_OPERAND (rhs, 1));\n-      /* Then check for a = (a = 1) + 2 and a = b[a++] = c.  */\n-      if (TREE_CODE (TREE_OPERAND (rhs, 0)) == VAR_DECL\n-\t  || TREE_CODE (TREE_OPERAND (rhs, 0)) == PARM_DECL)\n-\t{\n-\t  identifier_name = DECL_NAME (TREE_OPERAND (rhs, 0));\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  check_modify_expr (lhs, TREE_OPERAND (rhs, 0));\n-\t  return;\n-\t}\n-    default:\n-      /* We don't know what to do... pray check_modify_expr removes\n-\t loops in the tree.  */\n-      switch (TREE_CODE_CLASS (TREE_CODE (rhs)))\n-\t{\n-\tcase 'r':\n-\tcase '<':\n-\tcase '2':\n-\tcase 'b':\n-\tcase '1':\n-\tcase 'e':\n-\tcase 's':\n-\tcase 'x':\n-\t  {\n-\t    int lp;\n-\t    int max = first_rtl_op (TREE_CODE (rhs));\n-\t    for (lp = 0; lp < max; lp++)\n-\t      check_modify_expr (lhs, TREE_OPERAND (rhs, lp));\n-\t    return;\n-\t  }\n-\tdefault:\n-\t  return;\n-\t}\n-      break;\n-    }\n-  if (identifier_name != NULL_TREE)\n-    {\n-      switch (TREE_CODE (lhs))\n-\t{\n-\tcase ERROR_MARK:\n-\t  return;\n-\t  /* Perhaps this variable was incremented on the RHS.  */\n-\tcase VAR_DECL:\n-\tcase PARM_DECL:\n-\t  if (TREE_CODE (rhs) != VAR_DECL && TREE_CODE (rhs) != PARM_DECL)\n-\t    if (DECL_NAME (lhs) == identifier_name)\n-\t      warning (\"operation on `%s' may be undefined\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (lhs)));\n-\t  break;\n-\tcase PREDECREMENT_EXPR:\n-\tcase PREINCREMENT_EXPR:\n-\tcase POSTDECREMENT_EXPR:\n-\tcase POSTINCREMENT_EXPR:\n-\t  {\n-\t    tree var_decl = TREE_OPERAND (lhs, 0);\n-\t    if (TREE_CODE (var_decl) == VAR_DECL\n-\t\t|| TREE_CODE (var_decl) == PARM_DECL)\n-\t      if (identifier_name == DECL_NAME (var_decl))\n-\t\twarning (\"operation on `%s' may be undefined\",\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (var_decl)));\n-\t  }\n-\t  break;\n-\tdefault:\n-\t  /* To save duplicating tree traversal code swap args, and recurse.  */\n-\t  check_modify_expr (rhs, lhs);\n-\t  break;\n-\t}\n-    }\n-}\n-\n \f\n /* Build an assignment expression of lvalue LHS from value RHS.\n    MODIFYCODE is the code for a binary operator that we use\n@@ -4096,9 +3969,6 @@ build_modify_expr (lhs, modifycode, rhs)\n   if (TREE_CODE (newrhs) == ERROR_MARK)\n     return error_mark_node;\n \n-  if (warn_sequence_point)\n-    check_modify_expr (lhs, rhs);\n-\n   /* Scan operands */\n \n   result = build (MODIFY_EXPR, lhstype, lhs, newrhs);"}, {"sha": "65aadee0f2564bce21843b70f551d954b23ec5bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -1,3 +1,7 @@\n+2000-10-17  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* gcc.dg/sequence-pt-1.c: Several new tests; remove xfail from some old tests.\n+\n 2000-10-17  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/format-miss-1.c: New test."}, {"sha": "022a998fc780b43ba6dc5afb8ed3f2c44dba3031", "filename": "gcc/testsuite/gcc.dg/sequence-pt-1.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2683ed8d12f52394b5eb7635af05bec68064ea58/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c?ref=2683ed8d12f52394b5eb7635af05bec68064ea58", "patch": "@@ -11,18 +11,20 @@ struct s\n };\n \n extern int fn (int);\n+extern int fnb (int, int);\n+extern int fnc (int *);\n extern int sprintf (char *, const char *, ...);\n \n void\n foo (int a, int b, int n, int p, int *ptr, struct s *sptr,\n      int *ap, int *bp, int **cp, char *ans)\n {\n   int len;\n+    \n   a = a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = --a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = ++a + b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = a-- + b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n-  a = (a++ && 4); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" { xfail *-*-* } } */\n   ap[n] = bp[n++]; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   ap[--n] = bp[n]; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   ap[++n] = bp[--n]; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n@@ -31,12 +33,27 @@ foo (int a, int b, int n, int p, int *ptr, struct s *sptr,\n   *ptr++ = (int)ptr++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   sptr->a = sptr->a++; /* { dg-warning \"undefined\" \"sequence point warning\" { xfail *-*-* } } */\n   sptr->a = (int)(sptr++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n-  len = sprintf (ans, \"%d\", len++); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" { xfail *-*-* } } */\n-  *ptr++ = fn (*ptr); /* { dg-warning \"undefined\" \"sequence point warning\" { xfail *-*-* } } */\n+  *ptr++ = fn (*ptr); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = b = a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   b = a = --b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = 1 + (a = 1); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = (a = b); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = (a = b) + 1; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = (bp[a++] = b) + 1; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a = b++ * b++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a = fnb (b++, b++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  *ap = fnc (ap++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  (a += b) + (a += n); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+  a =  (b, b++) + (b++, b); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n+\n+  a = (a++ && 4); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+  len = sprintf (ans, \"%d\", len++); /* { dg-bogus \"undefined\" \"bogus sequence point warning\" } */\n+  a = fn (a++); /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  (a = b++), (a = b++); /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  a = (b++, b++); /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  a = b++ && b++; /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  a = b++ || b++; /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  a = (b++ ? b++ : a); /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  a = (b++ ? a : b++); /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n+  ap[a++] += bp[b]; /* { dg-bogus \"undefined\" \"sequence point warning\" } */\n }"}]}