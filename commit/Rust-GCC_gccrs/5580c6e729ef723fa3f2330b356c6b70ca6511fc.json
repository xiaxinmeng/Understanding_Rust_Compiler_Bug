{"sha": "5580c6e729ef723fa3f2330b356c6b70ca6511fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU4MGM2ZTcyOWVmNzIzZmEzZjIzMzBiMzU2YzZiNzBjYTY1MTFmYw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2009-06-05T08:45:26Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-06-05T08:45:26Z"}, "message": "throw_allocator.h: Rework.\n\n2009-06-04  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/ext/throw_allocator.h: Rework.\n\t* include/ext/pb_ds/detail/debug_map_base.hpp: Adjust usage.\n\t* include/ext/pb_ds/detail/gp_hash_table_map_/resize_fn_imps.hpp: Same.\n\t* include/ext/pb_ds/detail/ov_tree_map_/erase_fn_imps.hpp: Same.\n\t* include/ext/pb_ds/detail/ov_tree_map_/ov_tree_map_.hpp: Same.\n\t* testsuite/23_containers/list/modifiers/insert/25288.cc: Same.\n\t* testsuite/util/regression/rand/priority_queue/\n\tcontainer_rand_regression_test.tcc: Inline functions.\n\t* testsuite/util/regression/rand/assoc/\n\tcontainer_rand_regression_test.tcc: Same.\n\nFrom-SVN: r148204", "tree": {"sha": "a48529bab8ace2cc0a3a6d215dce1eafb86c5534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a48529bab8ace2cc0a3a6d215dce1eafb86c5534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5580c6e729ef723fa3f2330b356c6b70ca6511fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5580c6e729ef723fa3f2330b356c6b70ca6511fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5580c6e729ef723fa3f2330b356c6b70ca6511fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5580c6e729ef723fa3f2330b356c6b70ca6511fc/comments", "author": null, "committer": null, "parents": [{"sha": "2771246a535b04258f26c8b768664dd271771db3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2771246a535b04258f26c8b768664dd271771db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2771246a535b04258f26c8b768664dd271771db3"}], "stats": {"total": 748, "additions": 383, "deletions": 365}, "files": [{"sha": "749779aaf7c5a6e4962b0da3393113bb76dd37f2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -1,3 +1,16 @@\n+2009-06-04  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/ext/throw_allocator.h: Rework.\n+\t* include/ext/pb_ds/detail/debug_map_base.hpp: Adjust usage.\n+\t* include/ext/pb_ds/detail/gp_hash_table_map_/resize_fn_imps.hpp: Same.\n+\t* include/ext/pb_ds/detail/ov_tree_map_/erase_fn_imps.hpp: Same.\n+\t* include/ext/pb_ds/detail/ov_tree_map_/ov_tree_map_.hpp: Same.\n+\t* testsuite/23_containers/list/modifiers/insert/25288.cc: Same.\n+\t* testsuite/util/regression/rand/priority_queue/\n+\tcontainer_rand_regression_test.tcc: Inline functions.\n+\t* testsuite/util/regression/rand/assoc/\n+\tcontainer_rand_regression_test.tcc: Same.\n+\n 2009-06-03  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/23_containers/list/cons/6.cc: Adjust test name."}, {"sha": "2227691feb0eb5247df6ae17d85b04f7cebd6c75", "filename": "libstdc++-v3/include/ext/pb_ds/detail/debug_map_base.hpp", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fdebug_map_base.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fdebug_map_base.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fdebug_map_base.hpp?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -154,8 +154,8 @@ namespace __gnu_pbds\n     {\n       _GLIBCXX_DEBUG_ONLY(assert_valid();)\n       __gnu_cxx::throw_allocator<char> alloc;\n-      const double orig_throw_prob = alloc.get_throw_prob();\n-      alloc.set_throw_prob(0);\n+      const double orig_throw_prob = alloc.get_probability();\n+      alloc.set_probability(0);\n       if (find(r_key) != m_key_set.end())\n \t{\n \t  std::cerr << \"insert_new\" << r_key << std::endl;\n@@ -171,7 +171,7 @@ namespace __gnu_pbds\n \t  std::cerr << \"insert_new\" << r_key << std::endl;\n \t  std::abort();\n \t}\n-      alloc.set_throw_prob(orig_throw_prob);\n+      alloc.set_probability(orig_throw_prob);\n       _GLIBCXX_DEBUG_ONLY(assert_valid();)\n     }\n \n@@ -315,8 +315,8 @@ namespace __gnu_pbds\n     split(const_key_reference r_key, Cmp_Fn cmp_fn, PB_DS_CLASS_C_DEC& other)\n     {\n       __gnu_cxx::throw_allocator<char> alloc;\n-      const double orig_throw_prob = alloc.get_throw_prob();\n-      alloc.set_throw_prob(0);\n+      const double orig_throw_prob = alloc.get_probability();\n+      alloc.set_probability(0);\n       other.clear();\n       key_set_iterator it = m_key_set.begin();\n       while (it != m_key_set.end())\n@@ -327,7 +327,7 @@ namespace __gnu_pbds\n \t  }\n         else\n \t  ++it;\n-      alloc.set_throw_prob(orig_throw_prob);\n+      alloc.set_probability(orig_throw_prob);\n     }\n \n     PB_DS_CLASS_T_DEC\n@@ -336,16 +336,16 @@ namespace __gnu_pbds\n     join(PB_DS_CLASS_C_DEC& other)\n     {\n       __gnu_cxx::throw_allocator<char> alloc;\n-      const double orig_throw_prob = alloc.get_throw_prob();\n-      alloc.set_throw_prob(0);\n+      const double orig_throw_prob = alloc.get_probability();\n+      alloc.set_probability(0);\n       key_set_iterator it = other.m_key_set.begin();\n       while (it != other.m_key_set.end())\n \t{\n \t  insert_new(*it);\n \t  it = other.m_key_set.erase(it);\n \t}\n       _GLIBCXX_DEBUG_ASSERT(other.m_key_set.empty());\n-      alloc.set_throw_prob(orig_throw_prob);\n+      alloc.set_probability(orig_throw_prob);\n     }\n \n #undef PB_DS_CLASS_T_DEC"}, {"sha": "0492a47928b58eb9f05cdee824e2ae7f988e30d0", "filename": "libstdc++-v3/include/ext/pb_ds/detail/gp_hash_table_map_/resize_fn_imps.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fgp_hash_table_map_%2Fresize_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fgp_hash_table_map_%2Fresize_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fgp_hash_table_map_%2Fresize_fn_imps.hpp?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -79,7 +79,7 @@ PB_DS_CLASS_C_DEC::\n resize_imp(size_type new_size)\n {\n #ifdef PB_DS_REGRESSION\n-  typename Allocator::group_throw_prob_adjustor adjust(m_num_e);\n+  typename Allocator::group_adjustor adjust(m_num_e);\n #endif \n \n   if (new_size == m_num_e)"}, {"sha": "05e7d1a11075ce1ed323b132a41a3090069a5a8d", "filename": "libstdc++-v3/include/ext/pb_ds/detail/ov_tree_map_/erase_fn_imps.hpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fov_tree_map_%2Ferase_fn_imps.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fov_tree_map_%2Ferase_fn_imps.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fov_tree_map_%2Ferase_fn_imps.hpp?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -71,7 +71,7 @@ erase_if(Pred pred)\n   _GLIBCXX_DEBUG_ONLY(assert_valid();)\n \n #ifdef PB_DS_REGRESSION\n-    typename Allocator::group_throw_prob_adjustor adjust(m_size);\n+    typename Allocator::group_adjustor adjust(m_size);\n #endif \n \n   size_type new_size = 0;\n@@ -133,7 +133,7 @@ erase_imp(It it)\n   _GLIBCXX_DEBUG_ONLY(PB_DS_CLASS_C_DEC::check_key_exists(PB_DS_V2F(*it));)\n \n #ifdef PB_DS_REGRESSION\n-    typename Allocator::group_throw_prob_adjustor adjust(m_size);\n+    typename Allocator::group_adjustor adjust(m_size);\n #endif \n \n   _GLIBCXX_DEBUG_ASSERT(m_size > 0);"}, {"sha": "7d2ed3f1aaa97698e13f3ce0d65deda9202b95ef", "filename": "libstdc++-v3/include/ext/pb_ds/detail/ov_tree_map_/ov_tree_map_.hpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fov_tree_map_%2Fov_tree_map_.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fov_tree_map_%2Fov_tree_map_.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fov_tree_map_%2Fov_tree_map_.hpp?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -414,7 +414,7 @@ namespace __gnu_pbds\n       {\n \t_GLIBCXX_DEBUG_ONLY(assert_valid();)\n #ifdef PB_DS_REGRESSION\n-\t  typename Allocator::group_throw_prob_adjustor adjust(m_size);\n+\t  typename Allocator::group_adjustor adjust(m_size);\n #endif \n \n \t_GLIBCXX_DEBUG_ONLY(debug_base::check_key_does_not_exist(PB_DS_V2F(r_value)));"}, {"sha": "69daa15f5dbf0eb15fa7d2d94680f2e5bea2826a", "filename": "libstdc++-v3/include/ext/throw_allocator.h", "status": "modified", "additions": 271, "deletions": 265, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -51,28 +51,19 @@\n #include <ostream>\n #include <stdexcept>\n #include <utility>\n-#include <tr1/random>\n #include <bits/functexcept.h>\n #include <bits/move.h>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+# include <functional>\n+# include <random>\n+#else\n+# include <tr1/functional>\n+# include <tr1/random>\n+#endif\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n-  class twister_rand_gen\n-  {    \n-  private:\n-    std::tr1::mt19937 _M_generator;\n-\n-  public:\n-    twister_rand_gen(unsigned int s = static_cast<unsigned int>(std::time(0)));\n-    \n-    void\n-    init(unsigned int);\n-    \n-    double\n-    get_prob();\n-  };\n-\n-  /** \n+  /**\n    *  @brief Thown by throw_allocator.\n    *  @ingroup exceptions\n    */\n@@ -90,102 +81,286 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n #endif\n   }\n \n-  /// Base class.\n-  class throw_allocator_base\n+  // Base class for checking address and label information about\n+  // allocations. Create a std::map between the allocated address\n+  // (void*) and a datum for annotations, which are a pair of numbers\n+  // corresponding to label and allocated size.\n+  struct annotate_base\n   {\n-  public:\n+    annotate_base()\n+    {\n+      label();\n+      map();\n+    }\n+    \n+    static void\n+    set_label(size_t l)\n+    { label() = l; }\n+\n+    static size_t\n+    get_label()\n+    { return label(); }\n+\n     void\n-    init(unsigned long seed);\n+    insert(void* p, size_t size)\n+    {\n+      if (p == NULL)\n+\t{\n+\t  std::string error(\"throw_allocator_base::insert null insert!\\n\");\n+\t  log_to_string(error, make_entry(p, size));\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n \n-    static void\n-    set_throw_prob(double throw_prob);\n+      const_iterator found = map().find(p);\n+      if (found != map().end())\n+\t{\n+\t  std::string error(\"throw_allocator_base::insert double insert!\\n\");\n+\t  log_to_string(error, make_entry(p, size));\n+\t  log_to_string(error, *found);\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n \n-    static double\n-    get_throw_prob();\n+      map().insert(make_entry(p, size));\n+    }\n \n-    static void\n-    set_label(size_t l);\n+    void\n+    erase(void* p, size_t size)\n+    {\n+      check_allocated(p, size);\n+      map().erase(p);\n+    }\n \n-    static bool\n-    empty();\n+    // See if a particular address and size has been allocated.\n+    inline void\n+    check_allocated(void* p, size_t size)\n+    {\n+      const_iterator found = map().find(p);\n+      if (found == map().end())\n+\t{\n+\t  std::string error(\"annotate_base::check_allocated by value \"\n+\t\t\t    \"null erase!\\n\");\n+\t  log_to_string(error, make_entry(p, size));\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+      \n+      if (found->second.second != size)\n+\t{\n+\t  std::string error(\"annotate_base::check_allocated by value \"\n+\t\t\t    \"wrong-size erase!\\n\");\n+\t  log_to_string(error, make_entry(p, size));\n+\t  log_to_string(error, *found);\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+    }\n \n-    struct group_throw_prob_adjustor\n+    // See if a given label has been allocated.\n+    inline void\n+    check_allocated(size_t label)\n     {\n-      group_throw_prob_adjustor(size_t size) : _M_throw_prob_orig(_S_throw_prob)\n-      {\n-\t_S_throw_prob =\n-\t  1 - std::pow(double(1 - _S_throw_prob), double(0.5 / (size + 1)));\n-      }\n+      const_iterator beg = map().begin();\n+      const_iterator end = map().end();\n+      std::string found;\n+      while (beg != end)\n+\t{\n+\t  if (beg->second.first == label)\n+\t    log_to_string(found, *beg);\n+\t  ++beg;\n+\t}\n+      \n+      if (!found.empty())\n+\t{\n+\t  std::string error(\"annotate_base::check_allocated by label\\n\");\n+\t  error += found;\n+\t  std::__throw_logic_error(error.c_str());\n+\t}\n+    }\n+\n+  private:\n+    typedef std::pair<size_t, size_t> \t\tdata_type;\n+    typedef std::map<void*, data_type> \t\tmap_type;\n+    typedef map_type::value_type \t\tentry_type;\n+    typedef map_type::const_iterator \t\tconst_iterator;\n+    typedef map_type::const_reference \t\tconst_reference;\n \n-      ~group_throw_prob_adjustor()\n-      { _S_throw_prob = _M_throw_prob_orig; }\n+    friend std::ostream&\n+    operator<<(std::ostream&, const annotate_base&);\n \n+    entry_type\n+    make_entry(void* p, size_t size)\n+    { return std::make_pair(p, data_type(get_label(), size)); }\n+\n+    void\n+    log_to_string(std::string& s, const_reference ref) const\n+    {\n+      char buf[40];\n+      const char tab('\\t');\n+      s += \"label: \";\n+      unsigned long l = static_cast<unsigned long>(ref.second.first);\n+      __builtin_sprintf(buf, \"%lu\", l);\n+      s += buf;\n+      s += tab;\n+      s += \"size: \";\n+      l = static_cast<unsigned long>(ref.second.second);\n+      __builtin_sprintf(buf, \"%lu\", l);\n+      s += buf;\n+      s += tab;\n+      s += \"address: \";\n+      __builtin_sprintf(buf, \"%p\", ref.first);\n+      s += buf;\n+      s += '\\n';\n+    }\n+\n+    static size_t&\n+    label()\n+    {\n+      static size_t ll;\n+      return ll;\n+    }\n+\n+    static map_type&\n+    map()\n+    {\n+      static map_type mp;\n+      return mp;\n+    }\n+  };\n+\n+  inline std::ostream&\n+  operator<<(std::ostream& os, const annotate_base& __b)\n+  {\n+    std::string error;\n+    typedef annotate_base base_type;\n+    base_type::const_iterator beg = __b.map().begin();\n+    base_type::const_iterator end = __b.map().end();\n+    for (; beg != end; ++beg)\n+      __b.log_to_string(error, *beg);\n+    return os << error;\n+  }\n+\n+  /// Base class for probability control and throw.\n+  struct probability_base\n+  {\n+    // Scope-level probability adjustor objects: set probability for\n+    // throw at the beginning of a scope block, and restores to\n+    // previous probability when object is destroyed on exiting the\n+    // block.\n+    struct adjustor_base\n+    {\n     private:\n-      const double _M_throw_prob_orig;\n+      const double _M_prob;\n+\n+    public:\n+      adjustor_base() : _M_prob(get_probability()) { }\n+\n+      virtual ~adjustor_base()\n+      { set_probability(_M_prob); }\n     };\n \n-    struct zero_throw_prob_adjustor\n+    // Group condition.\n+    struct group_adjustor : public adjustor_base\n     {\n-      zero_throw_prob_adjustor() : _M_throw_prob_orig(_S_throw_prob)\n-      { _S_throw_prob = 0; }\n+      group_adjustor(size_t size)\n+      { set_probability(1 - std::pow(double(1 - get_probability()),\n+\t\t\t\t     double(0.5 / (size + 1))));\n+      }\n+    };\n \n-      ~zero_throw_prob_adjustor()\n-      { _S_throw_prob = _M_throw_prob_orig; }\n+    // Never enter the condition.\n+    struct never_adjustor : public adjustor_base\n+    {\n+      never_adjustor() { set_probability(0); }\n+    };\n \n-    private:\n-      const double _M_throw_prob_orig;\n+    // Always enter the condition.\n+    struct always_adjustor : public adjustor_base\n+    {\n+      always_adjustor() { set_probability(1); }\n     };\n \n-  protected:\n-    static void\n-    insert(void*, size_t);\n+    probability_base()\n+    {\n+      probability();\n+      engine();\n+    }\n \n     static void\n-    erase(void*, size_t);\n+    set_probability(double __p)\n+    { probability() = __p; }\n \n-    static void\n-    throw_conditionally();\n+    static double&\n+    get_probability()\n+    { return probability(); }\n \n-    // See if a particular address and size has been allocated by this\n-    // allocator.\n-    static void\n-    check_allocated(void*, size_t);\n+    void\n+    throw_conditionally()\n+    {\n+      if (generate() < get_probability())\n+\t__throw_forced_exception_error();\n+    }\n \n-    // See if a given label has been allocated by this allocator.\n-    static void\n-    check_allocated(size_t);\n+    void\n+    seed(unsigned long __s)\n+    { engine().seed(__s); }\n \n   private:\n-    typedef std::pair<size_t, size_t> \t\talloc_data_type;\n-    typedef std::map<void*, alloc_data_type> \tmap_type;\n-    typedef map_type::value_type \t\tentry_type;\n-    typedef map_type::const_iterator \t\tconst_iterator;\n-    typedef map_type::const_reference \t\tconst_reference;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    typedef std::uniform_real_distribution<double> \tdistribution_type;\n+    typedef std::mt19937 \t\t\t\tengine_type;\n+#else\n+    typedef std::tr1::uniform_real<double> \t\tdistribution_type;\n+    typedef std::tr1::mt19937 \t\t\t\tengine_type;\n+#endif\n \n-    friend std::ostream& \n-    operator<<(std::ostream&, const throw_allocator_base&);\n+    double\n+    generate()\n+    {\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const distribution_type distribution(0, 1);\n+      static auto generator = std::bind(distribution, engine());\n+#else\n+      // Use variate_generator to get normalized results.\n+      typedef std::tr1::variate_generator<engine_type, distribution_type> gen_t;\n+      distribution_type distribution(0, 1);\n+      static gen_t generator(engine(), distribution);\n+#endif\n \n-    static entry_type\n-    make_entry(void*, size_t);\n+      double random = generator();\n+      if (random < distribution.min() || random > distribution.max())\n+\t{\n+\t  std::string __s(\"throw_allocator::throw_conditionally\");\n+\t  __s += \"\\n\";\n+\t  __s += \"random number generated is: \";\n+\t  char buf[40];\n+\t  __builtin_sprintf(buf, \"%f\", random);\n+\t  __s += buf;\n+\t  std::__throw_out_of_range(__s.c_str());\n+\t}\n \n-    static void\n-    print_to_string(std::string&);\n+      return random;\n+    }\n \n-    static void\n-    print_to_string(std::string&, const_reference);\n+    static double&\n+    probability()\n+    {\n+      static double __p;\n+      return __p;\n+    }\n \n-    static twister_rand_gen \t_S_g;\n-    static map_type \t\t_S_map;\n-    static double \t\t_S_throw_prob;\n-    static size_t \t\t_S_label;\n+    static engine_type&\n+    engine()\n+    {\n+      static engine_type __e;\n+      return __e;\n+    }\n   };\n \n-  /** \n+  /**\n    *  @brief Allocator class with logging and exception control.\n    *  @ingroup allocators\n    */\n   template<typename T>\n-    class throw_allocator : public throw_allocator_base\n+    class throw_allocator\n+    : public probability_base, public annotate_base\n     {\n     public:\n       typedef size_t \t\t\t\tsize_type;\n@@ -196,25 +371,28 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       typedef value_type& \t\t\treference;\n       typedef const value_type& \t\tconst_reference;\n \n+    private:\n+      std::allocator<value_type> \t\t_M_allocator;\n \n+    public:\n       template<typename U>\n       struct rebind\n       {\n-        typedef throw_allocator<U> other;\n+\ttypedef throw_allocator<U> other;\n       };\n \n       throw_allocator() throw() { }\n \n       throw_allocator(const throw_allocator&) throw() { }\n \n       template<typename U>\n-      throw_allocator(const throw_allocator<U>&) throw() { }\n+\tthrow_allocator(const throw_allocator<U>&) throw() { }\n \n       ~throw_allocator() throw() { }\n \n       size_type\n       max_size() const throw()\n-      { return std::allocator<value_type>().max_size(); }\n+      { return _M_allocator.max_size(); }\n \n       pointer\n       allocate(size_type __n, std::allocator<void>::const_pointer hint = 0)\n@@ -223,43 +401,41 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  std::__throw_bad_alloc();\n \n \tthrow_conditionally();\n-\tvalue_type* const a = std::allocator<value_type>().allocate(__n, hint);\n+\tpointer const a = _M_allocator.allocate(__n, hint);\n \tinsert(a, sizeof(value_type) * __n);\n \treturn a;\n       }\n \n       void\n       construct(pointer __p, const T& val)\n-      { return std::allocator<value_type>().construct(__p, val); }\n+      { return _M_allocator.construct(__p, val); }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       template<typename... _Args>\n-        void\n-        construct(pointer __p, _Args&&... __args)\n-\t{ \n-\t  return std::allocator<value_type>().\n-\t    construct(__p, std::forward<_Args>(__args)...);\n-\t}\n+\tvoid\n+\tconstruct(pointer __p, _Args&&... __args)\n+\t{ return _M_allocator.construct(__p, std::forward<_Args>(__args)...); }\n #endif\n \n       void\n       destroy(pointer __p)\n-      { std::allocator<value_type>().destroy(__p); }\n+      { _M_allocator.destroy(__p); }\n \n       void\n       deallocate(pointer __p, size_type __n)\n       {\n \terase(__p, sizeof(value_type) * __n);\n-\tstd::allocator<value_type>().deallocate(__p, __n);\n+\t_M_allocator.deallocate(__p, __n);\n       }\n \n       void\n       check_allocated(pointer __p, size_type __n)\n-      { throw_allocator_base::check_allocated(__p, sizeof(value_type) * __n); }\n+      {\n+\tsize_type __t = sizeof(value_type) * __n;\n+\tannotate_base::check_allocated(__p, __t);\n+      }\n \n-      void\n-      check_allocated(size_type label)\n-      { throw_allocator_base::check_allocated(label); }\n+      using annotate_base::check_allocated;\n     };\n \n   template<typename T>\n@@ -272,176 +448,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     operator!=(const throw_allocator<T>&, const throw_allocator<T>&)\n     { return false; }\n \n-  std::ostream& \n-  operator<<(std::ostream& os, const throw_allocator_base& alloc)\n-  {\n-    std::string error;\n-    throw_allocator_base::print_to_string(error);\n-    os << error;\n-    return os;\n-  }\n-\n-  // XXX Should be in .cc.\n-  twister_rand_gen::\n-  twister_rand_gen(unsigned int seed) : _M_generator(seed)  { }\n-\n-  void\n-  twister_rand_gen::\n-  init(unsigned int seed)\n-  { _M_generator.seed(seed); }\n-\n-  double\n-  twister_rand_gen::\n-  get_prob()\n-  {\n-    const double min = _M_generator.min();\n-    const double res = static_cast<const double>(_M_generator() - min);\n-    const double range = static_cast<const double>(_M_generator.max() - min);\n-    const double ret = res / range;\n-    _GLIBCXX_DEBUG_ASSERT(ret >= 0 && ret <= 1);\n-    return ret;\n-  }\n-\n-  twister_rand_gen throw_allocator_base::_S_g;\n-\n-  throw_allocator_base::map_type \n-  throw_allocator_base::_S_map;\n-\n-  double throw_allocator_base::_S_throw_prob;\n-\n-  size_t throw_allocator_base::_S_label = 0;\n-\n-  throw_allocator_base::entry_type\n-  throw_allocator_base::make_entry(void* p, size_t size)\n-  { return std::make_pair(p, alloc_data_type(_S_label, size)); }\n-\n-  void\n-  throw_allocator_base::init(unsigned long seed)\n-  { _S_g.init(seed); }\n-\n-  void\n-  throw_allocator_base::set_throw_prob(double throw_prob)\n-  { _S_throw_prob = throw_prob; }\n-\n-  double\n-  throw_allocator_base::get_throw_prob()\n-  { return _S_throw_prob; }\n-\n-  void\n-  throw_allocator_base::set_label(size_t l)\n-  { _S_label = l; }\n-\n-  void\n-  throw_allocator_base::insert(void* p, size_t size)\n-  {\n-    const_iterator found_it = _S_map.find(p);\n-    if (found_it != _S_map.end())\n-      {\n-\tstd::string error(\"throw_allocator_base::insert\");\n-\terror += \"double insert!\";\n-\terror += '\\n';\n-\tprint_to_string(error, make_entry(p, size));\n-\tprint_to_string(error, *found_it);\n-\tstd::__throw_logic_error(error.c_str());\n-      }\n-    _S_map.insert(make_entry(p, size));\n-  }\n-\n-  bool\n-  throw_allocator_base::empty()\n-  { return _S_map.empty(); }\n-\n-  void\n-  throw_allocator_base::erase(void* p, size_t size)\n-  {\n-    check_allocated(p, size);\n-    _S_map.erase(p);\n-  }\n-\n-  void\n-  throw_allocator_base::check_allocated(void* p, size_t size)\n-  {\n-    const_iterator found_it = _S_map.find(p);\n-    if (found_it == _S_map.end())\n-      {\n-\tstd::string error(\"throw_allocator_base::check_allocated by value \");\n-\terror += \"null erase!\";\n-\terror += '\\n';\n-\tprint_to_string(error, make_entry(p, size));\n-\tstd::__throw_logic_error(error.c_str());\n-      }\n-\n-    if (found_it->second.second != size)\n-      {\n-\tstd::string error(\"throw_allocator_base::check_allocated by value \");\n-\terror += \"wrong-size erase!\";\n-\terror += '\\n';\n-\tprint_to_string(error, make_entry(p, size));\n-\tprint_to_string(error, *found_it);\n-\tstd::__throw_logic_error(error.c_str());\n-      }\n-  }\n-\n-  void\n-  throw_allocator_base::check_allocated(size_t label)\n-  {\n-    std::string found;\n-    const_iterator it = _S_map.begin();\n-    while (it != _S_map.end())\n-      {\n-\tif (it->second.first == label)\n-\t  {\n-\t    print_to_string(found, *it);\n-\t  }\n-\t++it;\n-      }\n-\n-    if (!found.empty())\n-      {\n-\tstd::string error(\"throw_allocator_base::check_allocated by label \");\n-\terror += '\\n';\n-\terror += found;\n-\tstd::__throw_logic_error(error.c_str());\n-      }\t\n-  }\n-\n-  void\n-  throw_allocator_base::throw_conditionally()\n-  {\n-    if (_S_g.get_prob() < _S_throw_prob)\n-      __throw_forced_exception_error();\n-  }\n-\n-  void\n-  throw_allocator_base::print_to_string(std::string& s)\n-  {\n-    const_iterator begin = throw_allocator_base::_S_map.begin();\n-    const_iterator end = throw_allocator_base::_S_map.end();\n-    for (; begin != end; ++begin)\n-      print_to_string(s, *begin);\n-  }\n-\n-  void\n-  throw_allocator_base::print_to_string(std::string& s, const_reference ref)\n-  {\n-    char buf[40];\n-    const char tab('\\t');\n-    s += \"address: \";\n-    __builtin_sprintf(buf, \"%p\", ref.first);\n-    s += buf;\n-    s += tab;\n-    s += \"label: \";\n-    unsigned long l = static_cast<unsigned long>(ref.second.first);\n-    __builtin_sprintf(buf, \"%lu\", l);\n-    s += buf;\n-    s += tab;\n-    s += \"size: \";\n-    l = static_cast<unsigned long>(ref.second.second);\n-    __builtin_sprintf(buf, \"%lu\", l);\n-    s += buf;\n-    s += '\\n';\n-  }\n-\n _GLIBCXX_END_NAMESPACE\n \n-#endif \n+#endif"}, {"sha": "e108288586ecbcab08ac0d57c20d2fcfbb5e4067", "filename": "libstdc++-v3/testsuite/23_containers/list/modifiers/insert/25288.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Finsert%2F25288.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Finsert%2F25288.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Finsert%2F25288.cc?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -38,15 +38,15 @@ void insert1()\n     for (int i = 0; i < 10; ++i)\n       {\n \tallocator_type alloc1;\n-\ttypename allocator_type::zero_throw_prob_adjustor adjust1;\n+\ttypename allocator_type::never_adjustor adjust1;\n \tlist_type list1(alloc1);\n \t\n \tfor (int k = 0; k < j; ++k)\n \t  list1.push_back(value_type(-(k + 1)));\n       \n \ttry\n \t  {\n-\t    alloc1.set_throw_prob(1);\n+\t    typename allocator_type::always_adjustor adjust2;\n \t    list1.insert(list1.begin(), 10, 99);\n \t    VERIFY( false );\n \t  }\n@@ -56,15 +56,14 @@ void insert1()\n \t  }\n \tcatch (...)\n \t  {\n-\t    VERIFY( false );\n+\t    __throw_exception_again;\n \t  }\n \t\n \tVERIFY( list1.size() == size_type(j) );\n \tVERIFY( list1.size() == 0 || list1.back() == -j );\n \tVERIFY( list1.size() == 0 || list1.front() == -1 );\n \n \tallocator_type alloc2;\n-\ttypename allocator_type::zero_throw_prob_adjustor adjust2;\n \tlist_type list2(alloc2);\n \t\n \tconst int data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n@@ -74,7 +73,7 @@ void insert1()\n \t\n \ttry\n \t  {\n-\t    alloc2.set_throw_prob(1);\n+\t    typename allocator_type::always_adjustor adjust3;\n \t    list2.insert(list2.begin(), data, data + 10);\n \t    VERIFY( false );\n \t  }"}, {"sha": "d995a049ed61c9aa9d575f51e9337e8c1c9cdb18", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/container_rand_regression_test.tcc", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Fcontainer_rand_regression_test.tcc?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -60,7 +60,7 @@ default_constructor()\n {\n   PB_DS_TRACE(\"default_constructor\");\n   bool done = true;\n-  m_alloc.set_throw_prob(m_tp);\n+  m_alloc.set_probability(m_tp);\n \n   try\n     {\n@@ -82,9 +82,9 @@ PB_DS_CLASS_C_DEC::\n swap()\n {\n   PB_DS_TRACE(\"swap\");\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   Cntnr* p_c = new Cntnr;\n-  m_alloc.set_throw_prob(1);\n+  m_alloc.set_probability(1);\n   p_c->swap(*m_p_c);\n   std::swap(p_c, m_p_c);\n   delete p_c;\n@@ -99,8 +99,8 @@ copy_constructor()\n   PB_DS_TRACE(\"copy_constructor\");\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(m_tp);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n   try\n     {\n@@ -125,8 +125,8 @@ assignment_operator()\n   PB_DS_TRACE(\"assignment operator\");\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(m_tp);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n   try\n     {\n@@ -160,8 +160,8 @@ it_constructor_imp(__gnu_pbds::cc_hash_tag)\n {\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(m_tp);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n   try\n     {\n@@ -227,8 +227,8 @@ it_constructor_imp(__gnu_pbds::gp_hash_tag)\n {\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(m_tp);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n   try\n     {\n@@ -310,8 +310,8 @@ it_constructor_imp(__gnu_pbds::tree_tag)\n {\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(m_tp);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n   try\n     {\n@@ -346,8 +346,8 @@ it_constructor_imp(__gnu_pbds::list_update_tag)\n {\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(m_tp);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n   try\n     {\n@@ -371,8 +371,8 @@ it_constructor_imp(__gnu_pbds::pat_trie_tag)\n {\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(m_tp);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n   try\n     {\n@@ -409,7 +409,7 @@ PB_DS_CLASS_C_DEC::\n cmp(const Cntnr& r_c, const native_type& r_native_c, \n     const std::string& r_call_fn)\n {\n-  m_alloc.set_throw_prob(1);\n+  m_alloc.set_probability(1);\n   const size_t size = r_c.size();\n   const size_t native_size = r_native_c.size();\n   PB_DS_THROW_IF_FAILED(size == native_size,\n@@ -447,9 +447,9 @@ basic_cmp_(const Cntnr& r_c, const native_type& r_native_c)\n     {\n       typename native_type::key_type native_key = test_traits::extract_native_key(*it);\n \n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       const key_type k = native_key;\n-      m_alloc.set_throw_prob(1);\n+      m_alloc.set_probability(1);\n       typename cntnr::const_point_iterator found_it = r_c.find(k);\n       PB_DS_THROW_IF_FAILED(found_it != r_c.end(),\n \t\t\t    test_traits::native_val_to_string(*it),\n@@ -622,9 +622,9 @@ PB_DS_CLASS_C_DEC::\n order_statistics_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n {\n   {\n-    m_alloc.set_throw_prob(0);\n+    m_alloc.set_probability(0);\n     const key_type k = test_traits::generate_key(m_g, m_m);\n-    m_alloc.set_throw_prob(1);\n+    m_alloc.set_probability(1);\n     const size_type order = r_c.order_of_key(k);\n     const size_type native_order = std::distance(r_native_c.begin(),\n \t\t\t\t\t\t r_native_c.lower_bound(test_traits::native_key(k)));\n@@ -675,9 +675,9 @@ PB_DS_CLASS_C_DEC::\n prefix_search_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n {\n   PB_DS_SET_DESTRUCT_PRINT\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   const key_type k = test_traits::generate_key(m_g, m_m);\n-  m_alloc.set_throw_prob(1);\n+  m_alloc.set_probability(1);\n   try\n     {\n       typedef\n@@ -794,9 +794,9 @@ PB_DS_CLASS_C_DEC::\n lower_bound_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n {\n   PB_DS_SET_DESTRUCT_PRINT\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   const key_type k = test_traits::generate_key(m_g, m_m);\n-  m_alloc.set_throw_prob(1);\n+  m_alloc.set_probability(1);\n   typename cntnr::const_iterator it = r_c.lower_bound(k);\n   typename native_type::key_type native_k = test_traits::native_key(k);\n   typename native_type::const_iterator native_it = r_native_c.lower_bound(native_k);\n@@ -833,9 +833,9 @@ PB_DS_CLASS_C_DEC::\n upper_bound_cmp_imp(const Cntnr& r_c, const native_type& r_native_c, __gnu_pbds::detail::true_type)\n {\n   PB_DS_SET_DESTRUCT_PRINT\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   const key_type k = test_traits::generate_key(m_g, m_m);\n-  m_alloc.set_throw_prob(1);\n+  m_alloc.set_probability(1);\n   typename cntnr::const_iterator it =  r_c.upper_bound(k);\n   typename native_type::key_type native_k = test_traits::native_key(k);\n   typename native_type::const_iterator native_it = r_native_c.upper_bound(native_k);\n@@ -879,7 +879,7 @@ operator()()\n \n   // Track allocation from this point only.\n   const size_t memory_label = 775;\n-  m_alloc.init(m_seed);\n+  m_alloc.seed(m_seed);\n   m_alloc.set_label(memory_label);  \n \n   prog_bar pb(m_n, std::cout, m_disp);\n@@ -1012,7 +1012,7 @@ operator()()\n     }\n \n   // Reset throw probability.\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n \n   if (m_disp)\n     {\n@@ -1069,9 +1069,9 @@ insert()\n   PB_DS_SET_DESTRUCT_PRINT\n   try\n     {\n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       value_type v = test_traits::generate_value(m_g, m_m);\n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       const_key_reference r_k = test_traits::extract_key(v);\n       typename cntnr::const_point_iterator found_it = m_p_c->find(r_k);\n       const bool existed = (found_it != m_p_c->end());\n@@ -1130,10 +1130,10 @@ subscript_imp(__gnu_pbds::detail::false_type)\n \n   try\n     {\n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       value_type v = test_traits::generate_value(m_g, m_m);\n \n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       (*m_p_c)[v.first] = v.second;\n \n       m_native_c[test_traits::native_value(v).first] =\n@@ -1158,9 +1158,9 @@ subscript_imp(__gnu_pbds::detail::true_type)\n   PB_DS_SET_DESTRUCT_PRINT\n   try\n     {\n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       value_type v = test_traits::generate_value(m_g, m_m);\n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       (*m_p_c)[v] = __gnu_pbds::null_mapped_type();\n       m_native_c.insert(test_traits::native_value(v));\n     }\n@@ -1195,9 +1195,9 @@ erase()\n   PB_DS_TRACE(\"erase\");\n   bool done = true;\n   PB_DS_SET_DESTRUCT_PRINT\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   const key_type k = test_traits::generate_key(m_g, m_m);\n-  m_alloc.set_throw_prob(m_tp);\n+  m_alloc.set_probability(m_tp);\n \n   try\n     {\n@@ -1244,7 +1244,7 @@ erase_if()\n \ttypename test_traits::template erase_if_fn<value_type>\n \terase_if_fn_t;\n       \n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       \n       const size_t ersd = m_p_c->erase_if(erase_if_fn_t());      \n       const size_t native_ersd = test_traits::erase_if(m_native_c);      \n@@ -1296,9 +1296,9 @@ erase_it_imp(__gnu_pbds::detail::true_type)\n \n   try\n     {\n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       const key_type k = test_traits::generate_key(m_g, m_m);\n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n \n       typename cntnr::iterator found_it = m_p_c->find(k);\n \n@@ -1373,9 +1373,9 @@ erase_rev_it_imp(__gnu_pbds::detail::true_type)\n \n   try\n     {\n-      m_alloc.set_throw_prob(0);      \n+      m_alloc.set_probability(0);      \n       const key_type k = test_traits::generate_key(m_g, m_m);      \n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       \n       typename cntnr::iterator found_it = m_p_c->find(k);\n       typename native_type::iterator native_it = m_native_c.find(test_traits::native_key(k));\n@@ -1728,14 +1728,14 @@ split_join_imp(__gnu_pbds::detail::true_type)\n \n   try\n     {\n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       Cntnr lhs(*m_p_c);\n       Cntnr rhs;\n       native_type native_lhs(m_native_c);\n       native_type native_rhs;\n       const key_type k = test_traits::generate_key(m_g, m_m);\n       \n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       lhs.split(k, rhs);\n       \n       typename native_type::const_iterator it =\n@@ -1753,7 +1753,7 @@ split_join_imp(__gnu_pbds::detail::true_type)\n       PB_DS_COND_COMPARE(lhs, native_lhs);\n       PB_DS_COND_COMPARE(rhs, native_rhs);\n       \n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       \n       if (m_g.get_prob() < 0.5)\n \tlhs.swap(rhs);\n@@ -1972,8 +1972,8 @@ resize_imp(__gnu_pbds::detail::true_type)\n \t  max_new_size = 2000\n         };\n \n-      m_alloc.set_throw_prob(m_tp);\n-      typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+      m_alloc.set_probability(m_tp);\n+      typename alloc_t::group_adjustor adjust(m_p_c->size());\n       const size_t new_size = m_g.get_unsigned_long(min_new_size, max_new_size);\n       m_p_c->resize(new_size);\n       const size_t actual_new_size = m_p_c->get_actual_size();\n@@ -2023,8 +2023,8 @@ get_set_load_imp(__gnu_pbds::detail::true_type)\n   PB_DS_TRACE(\"get_set_load\");\n   PB_DS_SET_DESTRUCT_PRINT\n   m_p_c->get_load();\n-  m_alloc.set_throw_prob(1);\n-  typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+  m_alloc.set_probability(1);\n+  typename alloc_t::group_adjustor adjust(m_p_c->size());\n   const float min_load = static_cast<float>(0.05);\n   const float max_load = static_cast<float>(0.9);\n \n@@ -2070,9 +2070,9 @@ get_set_loads_imp(__gnu_pbds::detail::true_type)\n \n   try\n     {\n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n \n-      typename alloc_t::group_throw_prob_adjustor adjust(m_p_c->size());\n+      typename alloc_t::group_adjustor adjust(m_p_c->size());\n \n       const float min_min_load = static_cast<float>(0.05);\n       const float max_min_load = static_cast<float>(0.2);\n@@ -2107,7 +2107,7 @@ void\n PB_DS_CLASS_C_DEC::\n print_container(const native_type& r_cnt, std::ostream& r_os) const\n {\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   typename native_type::const_iterator it = r_cnt.begin();\n   while (it != r_cnt.end())\n     {\n@@ -2121,7 +2121,7 @@ void\n PB_DS_CLASS_C_DEC::\n print_container(const cntnr& r_cnt, std::ostream& r_os) const\n {\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   typename cntnr::const_iterator it = r_cnt.begin();\n   while (it != r_cnt.end())\n     {"}, {"sha": "d4b395b126a90a5266d759008054f36da3069012", "filename": "libstdc++-v3/testsuite/util/regression/rand/assoc/rand_regression_test.hpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Frand_regression_test.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Frand_regression_test.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fassoc%2Frand_regression_test.hpp?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -148,7 +148,7 @@ namespace detail\n \n namespace detail\n {\n-  void\n+  inline void\n   usage(const std::string& name)\n   {\n     using namespace std;\n@@ -179,7 +179,7 @@ namespace detail\n     cerr << \"'t' or 'f' determine whether progress will be displayed\" << endl;\n   }\n \n-  void\n+  inline void\n   verify_params(size_t& r_seed, size_t& r_n, \n \t\tsize_t& r_m, double& r_tp, double& r_ip, double& r_ep, \n \t\tdouble& r_cp, double& r_mp, bool& r_d)"}, {"sha": "fe8ae6ba7edf62fc6802d3aaa4e313f5c8d7927e", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/container_rand_regression_test.tcc", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Fcontainer_rand_regression_test.tcc?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -60,7 +60,7 @@ default_constructor()\n {\n   PB_DS_TRACE(\"default_constructor\");\n   bool done = true;\n-  m_alloc.set_throw_prob(m_tp);\n+  m_alloc.set_probability(m_tp);\n \n   try\n     {\n@@ -83,9 +83,9 @@ PB_DS_CLASS_C_DEC::\n swap()\n {\n   PB_DS_TRACE(\"swap\");\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   Cntnr* p_c = new Cntnr;\n-  m_alloc.set_throw_prob(1);\n+  m_alloc.set_probability(1);\n   p_c->swap(*m_p_c);\n   std::swap(p_c, m_p_c);\n   delete p_c;\n@@ -100,9 +100,9 @@ copy_constructor()\n   PB_DS_TRACE(\"copy_constructor\");\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n+  m_alloc.set_probability(m_tp);\n \n-  typedef typename allocator_type::group_throw_prob_adjustor adjustor;\n+  typedef typename allocator_type::group_adjustor adjustor;\n   adjustor adjust(m_p_c->size());\n \n   try\n@@ -128,9 +128,9 @@ assignment_operator()\n   PB_DS_TRACE(\"assignment operator\");\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n+  m_alloc.set_probability(m_tp);\n \n-  typedef typename allocator_type::group_throw_prob_adjustor adjustor;\n+  typedef typename allocator_type::group_adjustor adjustor;\n   adjustor adjust(m_p_c->size());\n \n   try\n@@ -156,8 +156,8 @@ it_constructor()\n {\n   bool done = true;\n   Cntnr* p_c = NULL;\n-  m_alloc.set_throw_prob(m_tp);\n-  typedef typename allocator_type::group_throw_prob_adjustor adjustor;\n+  m_alloc.set_probability(m_tp);\n+  typedef typename allocator_type::group_adjustor adjustor;\n   adjustor adjust(m_p_c->size());\n \n   try\n@@ -201,7 +201,7 @@ cmp(const Cntnr& c, const native_type& native, const std::string& callfn)\n \n   try\n     {\n-      m_alloc.set_throw_prob(1);\n+      m_alloc.set_probability(1);\n       \n       const size_t size = c.size();\n       const size_t native_size = native.size();\n@@ -248,7 +248,7 @@ operator()()\n \t\t\t       string_form<Cntnr>::desc());\n \n   m_g.init(m_seed);\n-  m_alloc.init(m_seed);\n+  m_alloc.seed(m_seed);\n \n   // The __throw_allocator::_S_label defaults to 0, so to make things\n   // easier and more precise when debugging, start at 1.\n@@ -363,7 +363,7 @@ operator()()\n     }\n \n   // Reset throw probability.\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n \n   if (m_disp)\n     {\n@@ -425,9 +425,9 @@ push()\n \n     try\n       {\n-        m_alloc.set_throw_prob(0);\n+        m_alloc.set_probability(0);\n         value_type v = test_traits::generate_value(m_g, m_m);\n-        m_alloc.set_throw_prob(m_tp);\n+        m_alloc.set_probability(m_tp);\n         const typename cntnr::size_type sz = m_p_c->size();\n         m_p_c->push(v);\n         _GLIBCXX_THROW_IF(sz != m_p_c->size() - 1, sz, m_p_c, &m_native_c);\n@@ -460,10 +460,10 @@ modify()\n   bool done = true;\n   try\n     {\n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       value_type v = test_traits::generate_value(m_g, m_m);\n \n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       typename cntnr::iterator it = m_p_c->begin();\n       std::advance(it, m_g.get_unsigned_long(0, m_p_c->size()));\n       if (it != m_p_c->end())\n@@ -510,7 +510,7 @@ pop()\n   bool done = true;\n   try\n     {\n-      m_alloc.set_throw_prob(1);\n+      m_alloc.set_probability(1);\n       if (!m_p_c->empty())\n         {\n \t  m_p_c->pop();\n@@ -543,7 +543,7 @@ erase_if()\n \ttypename std::iterator_traits<typename cntnr::iterator>::reference\n \tit_const_reference;\n       \n-      m_alloc.set_throw_prob(1);\n+      m_alloc.set_probability(1);\n       \n       typedef\n \ttypename test_traits::template erase_if_fn<value_type>\n@@ -582,7 +582,7 @@ erase_it()\n   bool done = true;\n   try\n     {\n-      m_alloc.set_throw_prob(1);      \n+      m_alloc.set_probability(1);      \n       typename cntnr::iterator it = m_p_c->begin();      \n       std::advance(it, m_g.get_unsigned_long(0, m_p_c->size()));\n       \n@@ -689,11 +689,11 @@ split_join()\n   bool done = true;\n   try\n     {\n-      m_alloc.set_throw_prob(0);\n+      m_alloc.set_probability(0);\n       Cntnr lhs(*m_p_c);\n       Cntnr rhs;\n       native_type native_lhs(m_native_c);\n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       \n       typedef typename test_traits::template erase_if_fn<value_type> split_fn_t;\n       lhs.split(split_fn_t(), rhs);\n@@ -706,7 +706,7 @@ split_join()\n       PB_DS_COND_COMPARE(lhs, native_lhs);\n       PB_DS_COND_COMPARE(rhs, native_rhs);\n       \n-      m_alloc.set_throw_prob(m_tp);\n+      m_alloc.set_probability(m_tp);\n       \n       if (m_g.get_prob() < 0.5)\n \tlhs.swap(rhs);      \n@@ -815,7 +815,7 @@ void\n PB_DS_CLASS_C_DEC::\n print_container(const native_type& cnt, std::ostream& os) const\n {\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   native_type cpy(cnt);\n   while (!cpy.empty())\n     {\n@@ -830,7 +830,7 @@ PB_DS_CLASS_C_DEC::\n print_container(const cntnr& cnt, std::ostream& os) const\n {\n   typedef typename cntnr::const_iterator const_iterator;\n-  m_alloc.set_throw_prob(0);\n+  m_alloc.set_probability(0);\n   for (const_iterator it = cnt.begin(); it != cnt.end(); ++it)\n     os << *it << std::endl;\n }"}, {"sha": "1cf86020d454fe1d04ef1bfd93f5722170e098aa", "filename": "libstdc++-v3/testsuite/util/regression/rand/priority_queue/rand_regression_test.hpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Frand_regression_test.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5580c6e729ef723fa3f2330b356c6b70ca6511fc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Frand_regression_test.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fregression%2Frand%2Fpriority_queue%2Frand_regression_test.hpp?ref=5580c6e729ef723fa3f2330b356c6b70ca6511fc", "patch": "@@ -150,7 +150,7 @@ namespace detail\n \n namespace detail\n {\n-  void\n+  inline void\n   usage(const std::string& name)\n   {\n     using namespace std;\n@@ -182,7 +182,7 @@ namespace detail\n     cerr << \"'t' or 'f' determine whether progress will be displayed\" << endl;\n   }\n \n-  void\n+  inline void\n   verify_params(size_t& r_seed, size_t& r_n, \n \t\tsize_t& r_m, double& r_tp, double& r_ip, double& r_dp, \n \t\tdouble& r_ep, double& r_cp, double& r_mp, bool& r_d)"}]}