{"sha": "e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "node_id": "C_kwDOANBUbNoAKGU4OWQwYmVmZTNlYzMyMzhmY2E2ZGUyY2IwNzhlYjQwM2I4YzdlOTk", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2022-01-17T11:46:48Z"}, "committer": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2022-01-24T22:16:16Z"}, "message": "Fortran: provide a fallback implementation of issignaling\n\nFor targets with IEEE support but without the issignaling macro in libc\n(currently, everywhere except glibc), this allows us to provide a fallback\nimplementation. In order to keep the code in ieee_helper.c relatively\nreadable, I've put that new implementation in a separate file,\nissignaling_fallback.h.\n\nlibgfortran/ChangeLog:\n\n\t* ieee/issignaling_fallback.h: New file.\n\t* ieee/ieee_helper.c: Include issignaling_fallback.h when target\n\tdoes not define issignaling macro.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/ieee/signaling_1.f90: Do not require issignaling.\n\t* gfortran.dg/ieee/signaling_2.f90: Add comment.\n\t* gfortran.dg/ieee/signaling_3.f90: New test.", "tree": {"sha": "41fae2bcc0c07ac87ddfa6c3c32dc3a9b283fb47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41fae2bcc0c07ac87ddfa6c3c32dc3a9b283fb47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4343f5e256791a5abaaef29fe1f831a03bab129e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4343f5e256791a5abaaef29fe1f831a03bab129e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4343f5e256791a5abaaef29fe1f831a03bab129e"}], "stats": {"total": 290, "additions": 285, "deletions": 5}, "files": [{"sha": "1c7c7cf16a5bf5763e6caec2890aafa0205a2872", "filename": "gcc/testsuite/gfortran.dg/ieee/signaling_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_1.f90?ref=e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "patch": "@@ -1,7 +1,6 @@\n ! { dg-do run { xfail { { i?86-*-* x86_64-*-* } && ilp32 } } }\n ! x87 / x86-32 ABI is unsuitable for signaling NaNs\n !\n-! { dg-require-effective-target issignaling } */\n ! { dg-additional-sources signaling_1_c.c }\n ! { dg-additional-options \"-w\" }\n ! The -w option is needed to make cc1 not report a warning for "}, {"sha": "ee3805272a099913b8f019018b3d0e5394315213", "filename": "gcc/testsuite/gfortran.dg/ieee/signaling_2.f90", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_2.f90?ref=e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "patch": "@@ -2,6 +2,8 @@\n ! x87 / x86-32 ABI is unsuitable for signaling NaNs\n !\n ! { dg-require-effective-target issignaling } */\n+! The companion C source needs access to the issignaling macro.\n+!\n ! { dg-additional-sources signaling_2_c.c }\n ! { dg-additional-options \"-w\" }\n ! The -w option is needed to make cc1 not report a warning for"}, {"sha": "45bd9c3599f54e9473a48c81c156ffdcc8bb9265", "filename": "gcc/testsuite/gfortran.dg/ieee/signaling_3.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignaling_3.f90?ref=e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+!\n+program test\n+  use, intrinsic :: iso_c_binding\n+  use, intrinsic :: ieee_arithmetic\n+  implicit none\n+\n+  real(kind=c_float) :: x\n+  real(kind=c_double) :: y\n+  real(kind=c_long_double) :: z\n+\n+  if (ieee_support_nan(x)) then\n+    x = ieee_value(x, ieee_signaling_nan)\n+    if (ieee_class(x) /= ieee_signaling_nan) stop 100\n+    if (.not. ieee_is_nan(x)) stop 101\n+\n+    x = ieee_value(x, ieee_quiet_nan)\n+    if (ieee_class(x) /= ieee_quiet_nan) stop 103\n+    if (.not. ieee_is_nan(x)) stop 104\n+  end if\n+\n+  if (ieee_support_nan(y)) then\n+    y = ieee_value(y, ieee_signaling_nan)\n+    if (ieee_class(y) /= ieee_signaling_nan) stop 100\n+    if (.not. ieee_is_nan(y)) stop 101\n+\n+    y = ieee_value(y, ieee_quiet_nan)\n+    if (ieee_class(y) /= ieee_quiet_nan) stop 103\n+    if (.not. ieee_is_nan(y)) stop 104\n+  end if\n+\n+  if (ieee_support_nan(z)) then\n+    z = ieee_value(z, ieee_signaling_nan)\n+    if (ieee_class(z) /= ieee_signaling_nan) stop 100\n+    if (.not. ieee_is_nan(z)) stop 101\n+\n+    z = ieee_value(z, ieee_quiet_nan)\n+    if (ieee_class(z) /= ieee_quiet_nan) stop 103\n+    if (.not. ieee_is_nan(z)) stop 104\n+  end if\n+\n+end program test"}, {"sha": "7e310f2c5b07895768945d4b6752a59864503dba", "filename": "libgfortran/ieee/ieee_helper.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/libgfortran%2Fieee%2Fieee_helper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/libgfortran%2Fieee%2Fieee_helper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_helper.c?ref=e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "patch": "@@ -26,11 +26,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-/* Check support for issignaling macro.\n-   TODO: In the future, provide fallback implementations for IEEE types,\n-   because many libc's do not have issignaling yet.  */\n+/* Check support for issignaling macro.  If not, we include our own\n+   fallback implementation.  */\n #ifndef issignaling\n-# define issignaling(X) 0\n+# include \"issignaling_fallback.h\"\n #endif\n \n "}, {"sha": "e824cf8c59bde4b2cf58ac3834a3cf5e82f751c1", "filename": "libgfortran/ieee/issignaling_fallback.h", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/libgfortran%2Fieee%2Fissignaling_fallback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89d0befe3ec3238fca6de2cb078eb403b8c7e99/libgfortran%2Fieee%2Fissignaling_fallback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fissignaling_fallback.h?ref=e89d0befe3ec3238fca6de2cb078eb403b8c7e99", "patch": "@@ -0,0 +1,238 @@\n+/* Fallback implementation of issignaling macro.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+/* This header provides an implementation of the type-generic issignaling macro.\n+   Some points of note:\n+\n+     - This header is only included if the issignaling macro is not defined.\n+     - All targets for which Fortran IEEE modules are supported currently have\n+       the high-order bit of the NaN mantissa clear for signaling (and set\n+       for quiet), as recommended by IEEE.\n+     - We use the __*_IS_IEC_60559__ macros to make sure we only deal with formats\n+       we know. For other floating-point formats, we consider all NaNs as quiet.\n+\n+ */\n+\n+typedef union\n+{\n+  float value;\n+  uint32_t word;\n+} ieee_float_shape_type;\n+\n+static inline int\n+__issignalingf (float x)\n+{\n+#if __FLT_IS_IEC_60559__\n+  uint32_t xi;\n+  ieee_float_shape_type u;\n+\n+  u.value = x;\n+  xi = u.word;\n+\n+  xi ^= 0x00400000;\n+  return (xi & 0x7fffffff) > 0x7fc00000;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+\n+typedef union\n+{\n+  double value;\n+  uint64_t word;\n+} ieee_double_shape_type;\n+\n+static inline int\n+__issignaling (double x)\n+{\n+#if __DBL_IS_IEC_60559__\n+  ieee_double_shape_type u;\n+  uint64_t xi;\n+\n+  u.value = x;\n+  xi = u.word;\n+\n+  xi ^= UINT64_C (0x0008000000000000);\n+  return (xi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7ff8000000000000);\n+#else\n+  return 0;\n+#endif\n+}\n+\n+\n+#if __LDBL_DIG__ == __DBL_DIG__\n+\n+/* Long double is the same as double.  */\n+static inline int\n+__issignalingl (long double x)\n+{\n+  return __issignaling (x);\n+}\n+\n+#elif (__LDBL_DIG__ == 18) && __LDBL_IS_IEC_60559__\n+\n+/* Long double is x86 extended type.  */\n+\n+typedef union\n+{\n+  long double value;\n+  struct\n+  {\n+#if __FLOAT_WORD_ORDER == __BIG_ENDIAN\n+    int sign_exponent:16;\n+    unsigned int empty:16;\n+    uint32_t msw;\n+    uint32_t lsw;\n+#elif __FLOAT_WORD_ORDER == __LITTLE_ENDIAN\n+    uint32_t lsw;\n+    uint32_t msw;\n+    int sign_exponent:16;\n+    unsigned int empty:16;\n+#endif\n+  } parts;\n+} ieee_long_double_shape_type;\n+\n+static inline int\n+__issignalingl (long double x)\n+{\n+  int ret;\n+  uint32_t exi, hxi, lxi;\n+  ieee_long_double_shape_type u;\n+\n+  u.value = x;\n+  exi = u.parts.sign_exponent;\n+  hxi = u.parts.msw;\n+  lxi = u.parts.lsw;\n+\n+  /* Pseudo numbers on x86 are always signaling.  */\n+  ret = (exi & 0x7fff) && ((hxi & 0x80000000) == 0);\n+\n+  hxi ^= 0x40000000;\n+  hxi |= (lxi | -lxi) >> 31;\n+  return ret || (((exi & 0x7fff) == 0x7fff) && (hxi > 0xc0000000));\n+}\n+\n+#elif (__LDBL_DIG__ = 33) && __LDBL_IS_IEC_60559__\n+\n+/* Long double is 128-bit type.  */\n+\n+typedef union\n+{\n+  long double value;\n+  struct\n+  {\n+#if __FLOAT_WORD_ORDER == __BIG_ENDIAN\n+    uint64_t msw;\n+    uint64_t lsw;\n+#elif __FLOAT_WORD_ORDER == __LITTLE_ENDIAN\n+    uint64_t lsw;\n+    uint64_t msw;\n+#endif\n+  } parts64;\n+} ieee854_long_double_shape_type;\n+\n+static inline int\n+__issignalingl (long double x)\n+{\n+  uint64_t hxi, lxi;\n+  ieee854_long_double_shape_type u;\n+\n+  u.value = x;\n+  hxi = u.parts64.msw;\n+  lxi = u.parts64.lsw;\n+\n+  hxi ^= UINT64_C (0x0000800000000000);\n+  hxi |= (lxi | -lxi) >> 63;\n+  return (hxi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7fff800000000000);\n+}\n+\n+#else\n+\n+static inline int\n+__issignalingl (long double x)\n+{\n+  return 0;\n+}\n+\n+#endif\n+\n+\n+#if __FLT128_IS_IEC_60559__\n+\n+/* We have a _Float128 type.  */\n+\n+typedef union\n+{\n+  __float128 value;\n+  struct\n+  {\n+#if __FLOAT_WORD_ORDER == __BIG_ENDIAN\n+    uint64_t msw;\n+    uint64_t lsw;\n+#elif __FLOAT_WORD_ORDER == __LITTLE_ENDIAN\n+    uint64_t lsw;\n+    uint64_t msw;\n+#endif\n+  } parts64;\n+} ieee854_float128_shape_type;\n+\n+static inline int\n+__issignalingf128 (__float128 x)\n+{\n+  uint64_t hxi, lxi;\n+  ieee854_float128_shape_type u;\n+\n+  u.value = x;\n+  hxi = u.parts64.msw;\n+  lxi = u.parts64.lsw;\n+\n+  hxi ^= UINT64_C (0x0000800000000000);\n+  hxi |= (lxi | -lxi) >> 63;\n+  return (hxi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7fff800000000000);\n+}\n+\n+#endif\n+\n+\n+/* Define the type-generic macro based on the functions above.  */\n+\n+#if __FLT128_IS_IEC_60559__\n+# define issignaling(X) \\\n+  _Generic ((X), \\\n+\t    __float128: __issignalingf128, \\\n+\t    float: __issignalingf, \\\n+\t    double: __issignaling, \\\n+\t    long double: __issignalingl)(X)\n+#else\n+# define issignaling(X) \\\n+  _Generic ((X), \\\n+\t    float: __issignalingf, \\\n+\t    double: __issignaling, \\\n+\t    long double: __issignalingl)(X)\n+#endif\n+"}]}