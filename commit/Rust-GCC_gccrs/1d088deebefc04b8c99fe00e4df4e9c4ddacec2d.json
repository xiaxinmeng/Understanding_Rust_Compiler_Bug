{"sha": "1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQwODhkZWViZWZjMDRiOGM5OWZlMDBlNGRmNGU5YzRkZGFjZWMyZA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-07-06T06:15:36Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-06T06:15:36Z"}, "message": "gcc.c: Convert prototypes to ISO C90.\n\n\t* gcc.c: Convert prototypes to ISO C90.\n\t* gcc.h: Likewise.\n\t* gcov-dump.c: Likewise.\n\t* gcov-iov.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattrtab.h: Likewise.\n\t* ggc.h: Likewise.\n\t* global.c: Likewise.\n\t* graph.c: Likewise.\n\t* graph.h: Likewise.\n\t* hosthooks.h: Likewise.\n\t* hooks.h: Likewise.\n\t* hooks.c: Likewise.\n\t* hashtable.h: Likewise.\n\t* hashtable.c: Likewise.\n\t* haifa-sched.c: Likewise.\n\t* integrate.h: Likewise.\n\t* integrate.c: Likewise.\n\t* input.h: Likewise.\n\t* ifcvt.c: Likewise.\n\nFrom-SVN: r68995", "tree": {"sha": "5608aad0f59e34928c3ebcd5b5bf7492d6a81e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5608aad0f59e34928c3ebcd5b5bf7492d6a81e96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "481668695af894b6738d2d64f3e005b2709399c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481668695af894b6738d2d64f3e005b2709399c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/481668695af894b6738d2d64f3e005b2709399c5"}], "stats": {"total": 2692, "additions": 1044, "deletions": 1648}, "files": [{"sha": "d78bcc6f4b48a70c62fb4b559e28be1bcbb4269a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,3 +1,26 @@\n+2003-07-06  Andreas Jaeger  <aj@suse.de>\n+\n+\t* gcc.c: Convert prototypes to ISO C90.\n+\t* gcc.h: Likewise.\n+\t* gcov-dump.c: Likewise.\n+\t* gcov-iov.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattrtab.h: Likewise.\n+\t* ggc.h: Likewise.\n+\t* global.c: Likewise.\n+\t* graph.c: Likewise.\n+\t* graph.h: Likewise.\n+\t* hosthooks.h: Likewise.\n+\t* hooks.h: Likewise.\n+\t* hooks.c: Likewise.\n+\t* hashtable.h: Likewise.\n+\t* hashtable.c: Likewise.\n+\t* haifa-sched.c: Likewise.\n+\t* integrate.h: Likewise.\n+\t* integrate.c: Likewise.\n+\t* input.h: Likewise.\n+\t* ifcvt.c: Likewise.\n+\n 2003-07-05  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* combine.c (nonzero_bits1): Fix a warning."}, {"sha": "28341d5e4297efe0ceebdf9e82dcb4b28b7720e3", "filename": "gcc/gcc.c", "status": "modified", "additions": 171, "deletions": 280, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -88,7 +88,7 @@ compilation is specified by a string called a \"spec\".  */\n #include <sys/resource.h>\n #endif\n #if defined (HAVE_DECL_GETRUSAGE) && !HAVE_DECL_GETRUSAGE\n-extern int getrusage PARAMS ((int, struct rusage *));\n+extern int getrusage (int, struct rusage *);\n #endif\n \n /* By default there is no special suffix for target executables.  */\n@@ -286,82 +286,74 @@ static struct rusage rus, prus;\n /* Forward declaration for prototypes.  */\n struct path_prefix;\n \n-static void init_spec\t\tPARAMS ((void));\n-static void store_arg\t\tPARAMS ((const char *, int, int));\n-static char *load_specs\t\tPARAMS ((const char *));\n-static void read_specs\t\tPARAMS ((const char *, int));\n-static void set_spec\t\tPARAMS ((const char *, const char *));\n-static struct compiler *lookup_compiler PARAMS ((const char *, size_t, const char *));\n-static char *build_search_list\tPARAMS ((struct path_prefix *, const char *, int));\n-static void putenv_from_prefixes PARAMS ((struct path_prefix *, const char *));\n-static int access_check\t\tPARAMS ((const char *, int));\n-static char *find_a_file\tPARAMS ((struct path_prefix *, const char *,\n-\t\t\t\t\t int, int));\n-static void add_prefix\t\tPARAMS ((struct path_prefix *, const char *,\n-\t\t\t\t\t const char *, int, int, int *, int));\n-static void add_sysrooted_prefix PARAMS ((struct path_prefix *, const char *,\n-\t\t\t\t\t  const char *, int, int, int *, int));\n-static void translate_options\tPARAMS ((int *, const char *const **));\n-static char *skip_whitespace\tPARAMS ((char *));\n-static void delete_if_ordinary\tPARAMS ((const char *));\n-static void delete_temp_files\tPARAMS ((void));\n-static void delete_failure_queue PARAMS ((void));\n-static void clear_failure_queue PARAMS ((void));\n-static int check_live_switch\tPARAMS ((int, int));\n-static const char *handle_braces PARAMS ((const char *));\n-static inline bool input_suffix_matches PARAMS ((const char *,\n-\t\t\t\t\t\t const char *));\n-static inline bool switch_matches PARAMS ((const char *,\n-\t\t\t\t\t   const char *, int));\n-static inline void mark_matching_switches PARAMS ((const char *,\n-\t\t\t\t\t\t   const char *, int));\n-static inline void process_marked_switches PARAMS ((void));\n-static const char *process_brace_body PARAMS ((const char *, const char *,\n-\t\t\t\t\t       const char *, int, int));\n-static const struct spec_function *lookup_spec_function PARAMS ((const char *));\n-static const char *eval_spec_function\tPARAMS ((const char *, const char *));\n-static const char *handle_spec_function PARAMS ((const char *));\n-static char *save_string\tPARAMS ((const char *, int));\n-static void set_collect_gcc_options PARAMS ((void));\n-static int do_spec_1\t\tPARAMS ((const char *, int, const char *));\n-static int do_spec_2\t\tPARAMS ((const char *));\n-static void do_option_spec\tPARAMS ((const char *, const char *));\n-static void do_self_spec\tPARAMS ((const char *));\n-static const char *find_file\tPARAMS ((const char *));\n-static int is_directory\t\tPARAMS ((const char *, const char *, int));\n-static const char *validate_switches\tPARAMS ((const char *));\n-static void validate_all_switches PARAMS ((void));\n-static inline void validate_switches_from_spec PARAMS ((const char *));\n-static void give_switch\t\tPARAMS ((int, int));\n-static int used_arg\t\tPARAMS ((const char *, int));\n-static int default_arg\t\tPARAMS ((const char *, int));\n-static void set_multilib_dir\tPARAMS ((void));\n-static void print_multilib_info\tPARAMS ((void));\n-static void perror_with_name\tPARAMS ((const char *));\n-static void pfatal_pexecute\tPARAMS ((const char *, const char *))\n-  ATTRIBUTE_NORETURN;\n-static void notice\t\tPARAMS ((const char *, ...))\n-  ATTRIBUTE_PRINTF_1;\n-static void display_help \tPARAMS ((void));\n-static void add_preprocessor_option\tPARAMS ((const char *, int));\n-static void add_assembler_option\tPARAMS ((const char *, int));\n-static void add_linker_option\t\tPARAMS ((const char *, int));\n-static void process_command\t\tPARAMS ((int, const char *const *));\n-static int execute\t\t\tPARAMS ((void));\n-static void alloc_args\t\t\tPARAMS ((void));\n-static void clear_args\t\t\tPARAMS ((void));\n-static void fatal_error\t\t\tPARAMS ((int));\n+static void init_spec (void);\n+static void store_arg (const char *, int, int);\n+static char *load_specs (const char *);\n+static void read_specs (const char *, int);\n+static void set_spec (const char *, const char *);\n+static struct compiler *lookup_compiler (const char *, size_t, const char *);\n+static char *build_search_list (struct path_prefix *, const char *, int);\n+static void putenv_from_prefixes (struct path_prefix *, const char *);\n+static int access_check (const char *, int);\n+static char *find_a_file (struct path_prefix *, const char *, int, int);\n+static void add_prefix (struct path_prefix *, const char *, const char *,\n+\t\t\tint, int, int *, int);\n+static void add_sysrooted_prefix (struct path_prefix *, const char *,\n+\t\t\t\t  const char *, int, int, int *, int);\n+static void translate_options (int *, const char *const **);\n+static char *skip_whitespace (char *);\n+static void delete_if_ordinary (const char *);\n+static void delete_temp_files (void);\n+static void delete_failure_queue (void);\n+static void clear_failure_queue (void);\n+static int check_live_switch (int, int);\n+static const char *handle_braces (const char *);\n+static inline bool input_suffix_matches (const char *, const char *);\n+static inline bool switch_matches (const char *, const char *, int);\n+static inline void mark_matching_switches (const char *, const char *, int);\n+static inline void process_marked_switches (void);\n+static const char *process_brace_body (const char *, const char *, const char *, int, int);\n+static const struct spec_function *lookup_spec_function (const char *);\n+static const char *eval_spec_function (const char *, const char *);\n+static const char *handle_spec_function (const char *);\n+static char *save_string (const char *, int);\n+static void set_collect_gcc_options (void);\n+static int do_spec_1 (const char *, int, const char *);\n+static int do_spec_2 (const char *);\n+static void do_option_spec (const char *, const char *);\n+static void do_self_spec (const char *);\n+static const char *find_file (const char *);\n+static int is_directory (const char *, const char *, int);\n+static const char *validate_switches (const char *);\n+static void validate_all_switches (void);\n+static inline void validate_switches_from_spec (const char *);\n+static void give_switch (int, int);\n+static int used_arg (const char *, int);\n+static int default_arg (const char *, int);\n+static void set_multilib_dir (void);\n+static void print_multilib_info (void);\n+static void perror_with_name (const char *);\n+static void pfatal_pexecute (const char *, const char *) ATTRIBUTE_NORETURN;\n+static void notice (const char *, ...) ATTRIBUTE_PRINTF_1;\n+static void display_help (void);\n+static void add_preprocessor_option (const char *, int);\n+static void add_assembler_option (const char *, int);\n+static void add_linker_option (const char *, int);\n+static void process_command (int, const char *const *);\n+static int execute (void);\n+static void alloc_args (void);\n+static void clear_args (void);\n+static void fatal_error (int);\n #ifdef ENABLE_SHARED_LIBGCC\n-static void init_gcc_specs              PARAMS ((struct obstack *,\n-\t\t\t\t\t\t const char *, const char *,\n-\t\t\t\t\t\t const char *));\n+static void init_gcc_specs (struct obstack *, const char *, const char *,\n+\t\t\t    const char *);\n #endif\n #if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)\n-static const char *convert_filename\tPARAMS ((const char *, int, int));\n+static const char *convert_filename (const char *, int, int);\n #endif\n \n-static const char *if_exists_spec_function PARAMS ((int, const char **));\n-static const char *if_exists_else_spec_function PARAMS ((int, const char **));\n+static const char *if_exists_spec_function (int, const char **);\n+static const char *if_exists_else_spec_function (int, const char **);\n \f\n /* The Specs Language\n \n@@ -503,9 +495,9 @@ or with constant text in a single argument.\n \tname starts with `o'.  %{o*} would substitute this text,\n \tincluding the space; thus, two arguments would be generated.\n  %{S*&T*} likewise, but preserve order of S and T options (the order\n- \tof S and T in the spec is not significant).  Can be any number\n- \tof ampersand-separated variables; for each the wild card is\n- \toptional.  Useful for CPP as %{D*&U*&A*}.\n+\tof S and T in the spec is not significant).  Can be any number\n+\tof ampersand-separated variables; for each the wild card is\n+\toptional.  Useful for CPP as %{D*&U*&A*}.\n \n  %{S:X}   substitutes X, if the -S switch was given to CC.\n  %{!S:X}  substitutes X, if the -S switch was NOT given to CC.\n@@ -958,7 +950,7 @@ static const struct compiler default_compilers[] =\n        as %(asm_debug) %(asm_options) %m.s %A }}}}\"\n #endif\n    , 0},\n-  \n+\n #include \"specs.h\"\n   /* Mark end of table.  */\n   {0, 0, 0}\n@@ -1109,9 +1101,7 @@ static const struct {\n    and store its length in *ARGVC.  */\n \n static void\n-translate_options (argcp, argvp)\n-     int *argcp;\n-     const char *const **argvp;\n+translate_options (int *argcp, const char *const **argvp)\n {\n   int i;\n   int argc = *argcp;\n@@ -1321,8 +1311,7 @@ translate_options (argcp, argvp)\n }\n \f\n static char *\n-skip_whitespace (p)\n-     char *p;\n+skip_whitespace (char *p)\n {\n   while (1)\n     {\n@@ -1546,11 +1535,8 @@ static int processing_spec_function;\n \n #ifdef ENABLE_SHARED_LIBGCC\n static void\n-init_gcc_specs (obstack, shared_name, static_name, eh_name)\n-     struct obstack *obstack;\n-     const char *shared_name;\n-     const char *static_name;\n-     const char *eh_name;\n+init_gcc_specs (struct obstack *obstack, const char *shared_name,\n+\t\tconst char *static_name, const char *eh_name)\n {\n   char *buf;\n \n@@ -1719,9 +1705,7 @@ init_spec ()\n    current spec.  */\n \n static void\n-set_spec (name, spec)\n-     const char *name;\n-     const char *spec;\n+set_spec (const char *name, const char *spec)\n {\n   struct spec_list *sl;\n   const char *old_spec;\n@@ -1827,7 +1811,7 @@ alloc_args ()\n /* Clear out the vector of arguments (after a command is executed).  */\n \n static void\n-clear_args ()\n+clear_args (void)\n {\n   argbuf_index = 0;\n }\n@@ -1840,9 +1824,7 @@ clear_args ()\n     and the file should be deleted if this compilation fails.  */\n \n static void\n-store_arg (arg, delete_always, delete_failure)\n-     const char *arg;\n-     int delete_always, delete_failure;\n+store_arg (const char *arg, int delete_always, int delete_failure)\n {\n   if (argbuf_index + 1 == argbuf_length)\n     argbuf\n@@ -1861,8 +1843,7 @@ store_arg (arg, delete_always, delete_failure)\n    a single \\n.  */\n \n static char *\n-load_specs (filename)\n-     const char *filename;\n+load_specs (const char *filename)\n {\n   int desc;\n   int readlen;\n@@ -1926,9 +1907,7 @@ load_specs (filename)\n    Anything invalid in the file is a fatal error.  */\n \n static void\n-read_specs (filename, main_p)\n-     const char *filename;\n-     int main_p;\n+read_specs (const char *filename, int main_p)\n {\n   char *buffer;\n   char *p;\n@@ -2198,10 +2177,7 @@ static struct temp_file *failure_delete_queue;\n    otherwise delete it in any case.  */\n \n void\n-record_temp_file (filename, always_delete, fail_delete)\n-     const char *filename;\n-     int always_delete;\n-     int fail_delete;\n+record_temp_file (const char *filename, int always_delete, int fail_delete)\n {\n   char *const name = xstrdup (filename);\n \n@@ -2239,8 +2215,7 @@ record_temp_file (filename, always_delete, fail_delete)\n /* Delete all the temporary files whose names we previously recorded.  */\n \n static void\n-delete_if_ordinary (name)\n-     const char *name;\n+delete_if_ordinary (const char *name)\n {\n   struct stat st;\n #ifdef DEBUG\n@@ -2262,7 +2237,7 @@ delete_if_ordinary (name)\n }\n \n static void\n-delete_temp_files ()\n+delete_temp_files (void)\n {\n   struct temp_file *temp;\n \n@@ -2274,7 +2249,7 @@ delete_temp_files ()\n /* Delete all the files to be deleted on error.  */\n \n static void\n-delete_failure_queue ()\n+delete_failure_queue (void)\n {\n   struct temp_file *temp;\n \n@@ -2283,7 +2258,7 @@ delete_failure_queue ()\n }\n \n static void\n-clear_failure_queue ()\n+clear_failure_queue (void)\n {\n   failure_delete_queue = 0;\n }\n@@ -2295,10 +2270,8 @@ clear_failure_queue ()\n    It is also used by the --print-search-dirs flag.  */\n \n static char *\n-build_search_list (paths, prefix, check_dir_p)\n-     struct path_prefix *paths;\n-     const char *prefix;\n-     int check_dir_p;\n+build_search_list (struct path_prefix *paths, const char *prefix,\n+\t\t   int check_dir_p)\n {\n   int suffix_len = (machine_suffix) ? strlen (machine_suffix) : 0;\n   int just_suffix_len\n@@ -2357,9 +2330,7 @@ build_search_list (paths, prefix, check_dir_p)\n    for collect.  */\n \n static void\n-putenv_from_prefixes (paths, env_var)\n-     struct path_prefix *paths;\n-     const char *env_var;\n+putenv_from_prefixes (struct path_prefix *paths, const char *env_var)\n {\n   putenv (build_search_list (paths, env_var, 1));\n }\n@@ -2368,9 +2339,7 @@ putenv_from_prefixes (paths, env_var)\n    except that it never considers directories to be executable.  */\n \n static int\n-access_check (name, mode)\n-     const char *name;\n-     int mode;\n+access_check (const char *name, int mode)\n {\n   if (mode == X_OK)\n     {\n@@ -2389,10 +2358,8 @@ access_check (name, mode)\n    Return 0 if not found, otherwise return its name, allocated with malloc.  */\n \n static char *\n-find_a_file (pprefix, name, mode, multilib)\n-     struct path_prefix *pprefix;\n-     const char *name;\n-     int mode, multilib;\n+find_a_file (struct path_prefix *pprefix, const char *name, int mode,\n+\t     int multilib)\n {\n   char *temp;\n   const char *const file_suffix =\n@@ -2567,15 +2534,9 @@ enum path_prefix_priority\n    2 means try both machine_suffix and just_machine_suffix.  */\n \n static void\n-add_prefix (pprefix, prefix, component, priority, require_machine_suffix,\n-\t    warn, os_multilib)\n-     struct path_prefix *pprefix;\n-     const char *prefix;\n-     const char *component;\n-     /* enum prefix_priority */ int priority;\n-     int require_machine_suffix;\n-     int *warn;\n-     int os_multilib;\n+add_prefix (struct path_prefix *pprefix, const char *prefix,\n+\t    const char *component, /* enum prefix_priority */ int priority,\n+\t    int require_machine_suffix, int *warn, int os_multilib)\n {\n   struct prefix_list *pl, **prev;\n   int len;\n@@ -2608,15 +2569,10 @@ add_prefix (pprefix, prefix, component, priority, require_machine_suffix,\n \n /* Same as add_prefix, but prepending target_system_root to prefix.  */\n static void\n-add_sysrooted_prefix (pprefix, prefix, component, priority,\n-\t\t      require_machine_suffix, warn, os_multilib)\n-     struct path_prefix *pprefix;\n-     const char *prefix;\n-     const char *component;\n-     /* enum prefix_priority */ int priority;\n-     int require_machine_suffix;\n-     int *warn;\n-     int os_multilib;\n+add_sysrooted_prefix (struct path_prefix *pprefix, const char *prefix,\n+\t\t      const char *component,\n+\t\t      /* enum prefix_priority */ int priority,\n+\t\t      int require_machine_suffix, int *warn, int os_multilib)\n {\n   if (!IS_ABSOLUTE_PATH (prefix))\n     abort ();\n@@ -2643,7 +2599,7 @@ add_sysrooted_prefix (pprefix, prefix, component, priority,\n    Return 0 if successful, -1 if failed.  */\n \n static int\n-execute ()\n+execute (void)\n {\n   int i;\n   int n_commands;\t\t/* # of command.  */\n@@ -2957,10 +2913,8 @@ static int *warn_std_ptr = 0;\n    is true if we should look for an object suffix.  */\n \n static const char *\n-convert_filename (name, do_exe, do_obj)\n-     const char *name;\n-     int do_exe ATTRIBUTE_UNUSED;\n-     int do_obj ATTRIBUTE_UNUSED;\n+convert_filename (const char *name, int do_exe ATTRIBUTE_UNUSED,\n+\t\t  int do_obj ATTRIBUTE_UNUSED)\n {\n #if defined(HAVE_TARGET_EXECUTABLE_SUFFIX)\n   int i;\n@@ -3010,7 +2964,7 @@ convert_filename (name, do_exe, do_obj)\n \f\n /* Display the command line switches accepted by gcc.  */\n static void\n-display_help ()\n+display_help (void)\n {\n   printf (_(\"Usage: %s [options] file...\\n\"), programname);\n   fputs (_(\"Options:\\n\"), stdout);\n@@ -3070,9 +3024,7 @@ display_help ()\n }\n \n static void\n-add_preprocessor_option (option, len)\n-     const char *option;\n-     int len;\n+add_preprocessor_option (const char *option, int len)\n {\n   n_preprocessor_options++;\n \n@@ -3089,9 +3041,7 @@ add_preprocessor_option (option, len)\n }\n \n static void\n-add_assembler_option (option, len)\n-     const char *option;\n-     int len;\n+add_assembler_option (const char *option, int len)\n {\n   n_assembler_options++;\n \n@@ -3107,9 +3057,7 @@ add_assembler_option (option, len)\n }\n \n static void\n-add_linker_option (option, len)\n-     const char *option;\n-     int len;\n+add_linker_option (const char *option, int len)\n {\n   n_linker_options++;\n \n@@ -3128,9 +3076,7 @@ add_linker_option (option, len)\n    Store its length in `n_switches'.  */\n \n static void\n-process_command (argc, argv)\n-     int argc;\n-     const char *const *argv;\n+process_command (int argc, const char *const *argv)\n {\n   int i;\n   const char *temp;\n@@ -3175,7 +3121,7 @@ process_command (argc, argv)\n       char **new_argv;\n       char *new_argv0;\n       int baselen;\n-      \n+\n       while (argc > 1 && argv[1][0] == '-'\n \t     && (argv[1][1] == 'V' || argv[1][1] == 'b'))\n \t{\n@@ -3204,7 +3150,7 @@ process_command (argc, argv)\n       for (baselen = strlen (progname); baselen > 0; baselen--)\n \tif (IS_DIR_SEPARATOR (progname[baselen-1]))\n \t  break;\n-      new_argv0 = xmemdup (progname, baselen, \n+      new_argv0 = xmemdup (progname, baselen,\n \t\t\t   baselen + concat_length (new_version, new_machine,\n \t\t\t\t\t\t    \"-gcc-\", NULL) + 1);\n       strcpy (new_argv0 + baselen, new_machine);\n@@ -3784,7 +3730,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \n       use_pipes = 0;\n     }\n-  \n+\n   /* Set up the search paths before we go looking for config files.  */\n \n   /* These come before the md prefixes so that we will find gcc's subcommands\n@@ -4120,7 +4066,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n    and place that in the environment.  */\n \n static void\n-set_collect_gcc_options ()\n+set_collect_gcc_options (void)\n {\n   int i;\n   int first_time;\n@@ -4225,8 +4171,7 @@ static const char *suffix_subst;\n    Returns 0 if the spec is successfully processed; -1 if failed.  */\n \n int\n-do_spec (spec)\n-     const char *spec;\n+do_spec (const char *spec)\n {\n   int value;\n \n@@ -4249,8 +4194,7 @@ do_spec (spec)\n }\n \n static int\n-do_spec_2 (spec)\n-     const char *spec;\n+do_spec_2 (const char *spec)\n {\n   const char *string;\n   int result;\n@@ -4286,9 +4230,7 @@ do_spec_2 (spec)\n    of the switches/n_switches array.  */\n \n static void\n-do_option_spec (name, spec)\n-     const char *name;\n-     const char *spec;\n+do_option_spec (const char *name, const char *spec)\n {\n   unsigned int i, value_count, value_len;\n   const char *p, *q, *value;\n@@ -4337,8 +4279,7 @@ do_option_spec (name, spec)\n    of the switches/n_switches array.  */\n \n static void\n-do_self_spec (spec)\n-     const char *spec;\n+do_self_spec (const char *spec)\n {\n   do_spec_2 (spec);\n   do_spec_1 (\" \", 0, NULL);\n@@ -4384,10 +4325,7 @@ do_self_spec (spec)\n    and the command on that line reported an error.  */\n \n static int\n-do_spec_1 (spec, inswitch, soft_matched_part)\n-     const char *spec;\n-     int inswitch;\n-     const char *soft_matched_part;\n+do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n {\n   const char *p = spec;\n   int c;\n@@ -4681,7 +4619,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t  p++;\n \t\tif (p[0] == '%' && p[1] == 'O')\n \t\t  p += 2;\n-\t\t\n+\n \t\tbreak;\n \t      }\n \t    goto create_temp_file;\n@@ -4693,7 +4631,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t  p++;\n \t\tif (p[0] == '%' && p[1] == 'O')\n \t\t  p += 2;\n-\t\t\n+\n \t\tbreak;\n \t      }\n \t    goto create_temp_file;\n@@ -4744,24 +4682,24 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t    temp_filename = alloca (temp_filename_length + 1);\n \t\t    strncpy ((char *) temp_filename, input_basename, basename_length);\n \t\t    strncpy ((char *) temp_filename + basename_length, suffix,\n-\t\t    \t     suffix_length);\n+\t\t\t     suffix_length);\n \t\t    *((char *) temp_filename + temp_filename_length) = '\\0';\n \t\t    if (strcmp (temp_filename, input_filename) != 0)\n \t\t      {\n-\t\t      \tstruct stat st_temp;\n+\t\t\tstruct stat st_temp;\n \n-\t\t      \t/* Note, set_input() resets input_stat_set to 0.  */\n-\t\t      \tif (input_stat_set == 0)\n-\t\t      \t  {\n-\t\t      \t    input_stat_set = stat (input_filename, &input_stat);\n-\t\t      \t    if (input_stat_set >= 0)\n-\t\t      \t      input_stat_set = 1;\n-\t\t      \t  }\n+\t\t\t/* Note, set_input() resets input_stat_set to 0.  */\n+\t\t\tif (input_stat_set == 0)\n+\t\t\t  {\n+\t\t\t    input_stat_set = stat (input_filename, &input_stat);\n+\t\t\t    if (input_stat_set >= 0)\n+\t\t\t      input_stat_set = 1;\n+\t\t\t  }\n \n-\t\t      \t/* If we have the stat for the input_filename\n-\t\t      \t   and we can do the stat for the temp_filename\n-\t\t      \t   then the they could still refer to the same\n-\t\t      \t   file if st_dev/st_ino's are the same.  */\n+\t\t\t/* If we have the stat for the input_filename\n+\t\t\t   and we can do the stat for the temp_filename\n+\t\t\t   then the they could still refer to the same\n+\t\t\t   file if st_dev/st_ino's are the same.  */\n \n \t\t\tif (input_stat_set != 1\n \t\t\t    || stat (temp_filename, &st_temp) < 0\n@@ -4771,7 +4709,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t    temp_filename = save_string (temp_filename,\n \t\t\t\t\t\t\t temp_filename_length + 1);\n \t\t\t    obstack_grow (&obstack, temp_filename,\n-\t\t\t    \t\t\t    temp_filename_length);\n+\t\t\t\t\t\t    temp_filename_length);\n \t\t\t    arg_going = 1;\n \t\t\t    delete_this_arg = 0;\n \t\t\t    break;\n@@ -5058,11 +4996,11 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    /* We assume there is a directory\n \t       separator at the end of this string.  */\n \t    if (target_system_root)\n-\t      { \n-\t        obstack_grow (&obstack, target_system_root, \n+\t      {\n+\t        obstack_grow (&obstack, target_system_root,\n \t\t\t      strlen (target_system_root));\n \t\tif (target_sysroot_suffix)\n-\t\t  obstack_grow (&obstack, target_sysroot_suffix, \n+\t\t  obstack_grow (&obstack, target_sysroot_suffix,\n \t\t\t\tstrlen (target_sysroot_suffix));\n \t      }\n \t    break;\n@@ -5264,8 +5202,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n /* Look up a spec function.  */\n \n static const struct spec_function *\n-lookup_spec_function (name)\n-     const char *name;\n+lookup_spec_function (const char *name)\n {\n   static const struct spec_function * const spec_function_tables[] =\n   {\n@@ -5288,8 +5225,7 @@ lookup_spec_function (name)\n /* Evaluate a spec function.  */\n \n static const char *\n-eval_spec_function (func, args)\n-     const char *func, *args;\n+eval_spec_function (const char *func, const char *args)\n {\n   const struct spec_function *sf;\n   const char *funcval;\n@@ -5361,8 +5297,7 @@ eval_spec_function (func, args)\n    NULL if no processing is required.  */\n \n static const char *\n-handle_spec_function (p)\n-     const char *p;\n+handle_spec_function (const char *p)\n {\n   char *func, *args;\n   const char *endp, *funcval;\n@@ -5420,9 +5355,7 @@ handle_spec_function (p)\n /* Inline subroutine of handle_braces.  Returns true if the current\n    input suffix matches the atom bracketed by ATOM and END_ATOM.  */\n static inline bool\n-input_suffix_matches (atom, end_atom)\n-     const char *atom;\n-     const char *end_atom;\n+input_suffix_matches (const char *atom, const char *end_atom)\n {\n   return (input_suffix\n \t  && !strncmp (input_suffix, atom, end_atom - atom)\n@@ -5433,10 +5366,7 @@ input_suffix_matches (atom, end_atom)\n    matching the atom bracketed by ATOM and END_ATOM appeared on the\n    command line.  */\n static inline bool\n-switch_matches (atom, end_atom, starred)\n-     const char *atom;\n-     const char *end_atom;\n-     int starred;\n+switch_matches (const char *atom, const char *end_atom, int starred)\n {\n   int i;\n   int len = end_atom - atom;\n@@ -5455,10 +5385,7 @@ switch_matches (atom, end_atom, starred)\n    match ATOM (extends to END_ATOM; STARRED indicates whether there\n    was a star after the atom) for later processing.  */\n static inline void\n-mark_matching_switches (atom, end_atom, starred)\n-     const char *atom;\n-     const char *end_atom;\n-     int starred;\n+mark_matching_switches (const char *atom, const char *end_atom, int starred)\n {\n   int i;\n   int len = end_atom - atom;\n@@ -5474,7 +5401,7 @@ mark_matching_switches (atom, end_atom, starred)\n /* Inline subroutine of handle_braces.  Process all the currently\n    marked switches through give_switch, and clear the marks.  */\n static inline void\n-process_marked_switches ()\n+process_marked_switches (void)\n {\n   int i;\n \n@@ -5491,8 +5418,7 @@ process_marked_switches ()\n    if we call do_spec_1 and that returns -1.  */\n \n static const char *\n-handle_braces (p)\n-     const char *p;\n+handle_braces (const char *p)\n {\n   const char *atom, *end_atom;\n   const char *d_atom = NULL, *d_end_atom = NULL;\n@@ -5640,12 +5566,8 @@ handle_braces (p)\n    returns -1.  */\n \n static const char *\n-process_brace_body (p, atom, end_atom, starred, matched)\n-     const char *p;\n-     const char *atom;\n-     const char *end_atom;\n-     int starred;\n-     int matched;\n+process_brace_body (const char *p, const char *atom, const char *end_atom,\n+\t\t    int starred, int matched)\n {\n   const char *body, *end_body;\n   unsigned int nesting_level;\n@@ -5672,7 +5594,7 @@ process_brace_body (p, atom, end_atom, starred, matched)\n \tabort ();\n       p++;\n     }\n-  \n+\n   end_body = p;\n   while (end_body[-1] == ' ' || end_body[-1] == '\\t')\n     end_body--;\n@@ -5725,9 +5647,7 @@ process_brace_body (p, atom, end_atom, starred, matched)\n    with the \"no-\", similarly for a switch with the \"no-\" prefix.  */\n \n static int\n-check_live_switch (switchnum, prefix_length)\n-     int switchnum;\n-     int prefix_length;\n+check_live_switch (int switchnum, int prefix_length)\n {\n   const char *name = switches[switchnum].part1;\n   int i;\n@@ -5801,9 +5721,7 @@ check_live_switch (switchnum, prefix_length)\n    If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */\n \n static void\n-give_switch (switchnum, omit_first_word)\n-     int switchnum;\n-     int omit_first_word;\n+give_switch (int switchnum, int omit_first_word)\n {\n   if (switches[switchnum].live_cond == SWITCH_IGNORE)\n     return;\n@@ -5853,8 +5771,7 @@ give_switch (switchnum, omit_first_word)\n    Return the absolute file name found.  If nothing is found, return NAME.  */\n \n static const char *\n-find_file (name)\n-     const char *name;\n+find_file (const char *name)\n {\n   char *newname;\n \n@@ -5879,10 +5796,7 @@ find_file (name)\n    limit.  */\n \n static int\n-is_directory (path1, path2, linker)\n-     const char *path1;\n-     const char *path2;\n-     int linker;\n+is_directory (const char *path1, const char *path2, int linker)\n {\n   int len1 = strlen (path1);\n   int len2 = strlen (path2);\n@@ -5924,8 +5838,7 @@ is_directory (path1, path2, linker)\n    the input file named FILENAME.  */\n \n void\n-set_input (filename)\n-     const char *filename;\n+set_input (const char *filename)\n {\n   const char *p;\n \n@@ -5966,8 +5879,7 @@ set_input (filename)\n /* On fatal signals, delete all the temporary files.  */\n \n static void\n-fatal_error (signum)\n-     int signum;\n+fatal_error (int signum)\n {\n   signal (signum, SIG_DFL);\n   delete_failure_queue ();\n@@ -5977,12 +5889,10 @@ fatal_error (signum)\n   kill (getpid (), signum);\n }\n \n-extern int main PARAMS ((int, const char *const *));\n+extern int main (int, const char *const *);\n \n int\n-main (argc, argv)\n-     int argc;\n-     const char *const *argv;\n+main (int argc, const char *const *argv)\n {\n   size_t i;\n   int value;\n@@ -6512,10 +6422,7 @@ main (argc, argv)\n    or 0 if this file is to be passed to the linker.  */\n \n static struct compiler *\n-lookup_compiler (name, length, language)\n-     const char *name;\n-     size_t length;\n-     const char *language;\n+lookup_compiler (const char *name, size_t length, const char *language)\n {\n   struct compiler *cp;\n \n@@ -6581,9 +6488,7 @@ lookup_compiler (name, length, language)\n }\n \f\n static char *\n-save_string (s, len)\n-     const char *s;\n-     int len;\n+save_string (const char *s, int len)\n {\n   char *result = xmalloc (len + 1);\n \n@@ -6593,25 +6498,21 @@ save_string (s, len)\n }\n \n void\n-pfatal_with_name (name)\n-     const char *name;\n+pfatal_with_name (const char *name)\n {\n   perror_with_name (name);\n   delete_temp_files ();\n   exit (1);\n }\n \n static void\n-perror_with_name (name)\n-     const char *name;\n+perror_with_name (const char *name)\n {\n   error (\"%s: %s\", name, xstrerror (errno));\n }\n \n static void\n-pfatal_pexecute (errmsg_fmt, errmsg_arg)\n-     const char *errmsg_fmt;\n-     const char *errmsg_arg;\n+pfatal_pexecute (const char *errmsg_fmt, const char *errmsg_arg)\n {\n   if (errmsg_arg)\n     {\n@@ -6631,7 +6532,7 @@ pfatal_pexecute (errmsg_fmt, errmsg_arg)\n /* Output an error message and exit.  */\n \n void\n-fancy_abort ()\n+fancy_abort (void)\n {\n   fatal (\"internal gcc abort\");\n }\n@@ -6642,7 +6543,7 @@ void\n fatal (const char *msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n \n   fprintf (stderr, \"%s: \", programname);\n@@ -6657,7 +6558,7 @@ void\n error (const char *msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   fprintf (stderr, \"%s: \", programname);\n   vfprintf (stderr, _(msgid), ap);\n@@ -6670,15 +6571,14 @@ static void\n notice (const char *msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   vfprintf (stderr, _(msgid), ap);\n   va_end (ap);\n }\n \f\n static inline void\n-validate_switches_from_spec (spec)\n-     const char *spec;\n+validate_switches_from_spec (const char *spec)\n {\n   const char *p = spec;\n   char c;\n@@ -6689,7 +6589,7 @@ validate_switches_from_spec (spec)\n }\n \n static void\n-validate_all_switches ()\n+validate_all_switches (void)\n {\n   struct compiler *comp;\n   struct spec_list *spec;\n@@ -6708,18 +6608,17 @@ validate_all_switches ()\n    and mark as valid all supplied switches that match it.  */\n \n static const char *\n-validate_switches (start)\n-     const char *start;\n+validate_switches (const char *start)\n {\n   const char *p = start;\n   const char *atom;\n   size_t len;\n   int i;\n   bool suffix = false;\n   bool starred = false;\n-  \n+\n #define SKIP_WHITE() do { while (*p == ' ' || *p == '\\t') p++; } while (0)\n-  \n+\n next_member:\n   SKIP_WHITE ();\n \n@@ -6792,9 +6691,7 @@ static int n_mdswitches;\n    canonicalize the switches to keep only the ones we care about.  */\n \n static int\n-used_arg (p, len)\n-     const char *p;\n-     int len;\n+used_arg (const char *p, int len)\n {\n   struct mswitchstr\n   {\n@@ -6932,9 +6829,7 @@ used_arg (p, len)\n }\n \n static int\n-default_arg (p, len)\n-     const char *p;\n-     int len;\n+default_arg (const char *p, int len)\n {\n   int i;\n \n@@ -6957,7 +6852,7 @@ default_arg (p, len)\n    will be used.  */\n \n static void\n-set_multilib_dir ()\n+set_multilib_dir (void)\n {\n   const char *p;\n   unsigned int this_path_len;\n@@ -6993,7 +6888,7 @@ set_multilib_dir ()\n \n \t  if (*start == '\\0')\n \t    break;\n-                                  \n+\n \t  for (end = start + 1;\n \t       *end != ' ' && *end != '\\t' && *end != '\\0'; end++)\n \t    ;\n@@ -7192,7 +7087,7 @@ set_multilib_dir ()\n    the exclusions.  */\n \n static void\n-print_multilib_info ()\n+print_multilib_info (void)\n {\n   const char *p = multilib_select;\n   const char *last_path = 0, *this_path;\n@@ -7440,9 +7335,7 @@ print_multilib_info ()\n    (whose name has been expanded with %s).  */\n \n static const char *\n-if_exists_spec_function (argc, argv)\n-     int argc;\n-     const char **argv;\n+if_exists_spec_function (int argc, const char **argv)\n {\n   /* Must have only one argument.  */\n   if (argc == 1 && IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK))\n@@ -7457,9 +7350,7 @@ if_exists_spec_function (argc, argv)\n    is returned if the first argument does not exist.  */\n \n static const char *\n-if_exists_else_spec_function (argc, argv)\n-     int argc;\n-     const char **argv;\n+if_exists_else_spec_function (int argc, const char **argv)\n {\n   /* Must have exactly two arguments.  */\n   if (argc != 2)"}, {"sha": "9df9ffd12522381ce29259196c802b5d72fded3f", "filename": "gcc/gcc.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -26,9 +26,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* The mapping of a spec function name to the C function that\n    implements it.  */\n struct spec_function\n-{       \n+{\n   const char *name;\n-  const char *(*func) PARAMS ((int, const char **));\n+  const char *(*func) (int, const char **);\n };\n \n /* This defines which switch letters take arguments.  */\n@@ -54,22 +54,21 @@ struct spec_function\n \n \n /* These are exported by gcc.c.  */\n-extern int do_spec PARAMS ((const char *));\n-extern void record_temp_file PARAMS ((const char *, int, int));\n-extern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n-extern void fatal PARAMS ((const char *, ...))\n-     ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-extern void pfatal_with_name PARAMS ((const char *)) ATTRIBUTE_NORETURN;\n-extern void set_input PARAMS ((const char *));\n+extern int do_spec (const char *);\n+extern void record_temp_file (const char *, int, int);\n+extern void fancy_abort (void) ATTRIBUTE_NORETURN;\n+extern void fatal (const char *, ...) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void error (const char *, ...) ATTRIBUTE_PRINTF_1;\n+extern void pfatal_with_name (const char *) ATTRIBUTE_NORETURN;\n+extern void set_input (const char *);\n \n /* Spec files linked with gcc.c must provide definitions for these.  */\n \n /* Called before processing to change/add/remove arguments.  */\n-extern void lang_specific_driver PARAMS ((int *, const char *const **, int *));\n+extern void lang_specific_driver (int *, const char *const **, int *);\n \n /* Called before linking.  Returns 0 on success and -1 on failure.  */\n-extern int lang_specific_pre_link PARAMS ((void));\n+extern int lang_specific_pre_link (void);\n \n extern int n_infiles;\n "}, {"sha": "86834e25b7b4bee948818270c3d645fa3e4db1a4", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 51, "deletions": 68, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,5 +1,5 @@\n /* Dump a gcov file, for debugging use.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Nathan Sidwell <nathan@codesourcery.com>\n \n Gcov is free software; you can redistribute it and/or modify\n@@ -27,17 +27,17 @@ Boston, MA 02111-1307, USA.  */\n #include \"gcov-io.h\"\n #include \"gcov-io.c\"\n \n-static void dump_file PARAMS ((const char *));\n-static void print_prefix PARAMS ((const char *, unsigned, gcov_position_t));\n-static void print_usage PARAMS ((void));\n-static void print_version PARAMS ((void));\n-static void tag_function PARAMS ((const char *, unsigned, unsigned));\n-static void tag_blocks PARAMS ((const char *, unsigned, unsigned));\n-static void tag_arcs PARAMS ((const char *, unsigned, unsigned));\n-static void tag_lines PARAMS ((const char *, unsigned, unsigned));\n-static void tag_counters PARAMS ((const char *, unsigned, unsigned));\n-static void tag_summary PARAMS ((const char *, unsigned, unsigned));\n-extern int main PARAMS ((int, char **));\n+static void dump_file (const char *);\n+static void print_prefix (const char *, unsigned, gcov_position_t);\n+static void print_usage (void);\n+static void print_version (void);\n+static void tag_function (const char *, unsigned, unsigned);\n+static void tag_blocks (const char *, unsigned, unsigned);\n+static void tag_arcs (const char *, unsigned, unsigned);\n+static void tag_lines (const char *, unsigned, unsigned);\n+static void tag_counters (const char *, unsigned, unsigned);\n+static void tag_summary (const char *, unsigned, unsigned);\n+extern int main (int, char **);\n \n typedef struct tag_format\n {\n@@ -72,9 +72,8 @@ static const tag_format_t tag_table[] =\n   {0, NULL, NULL}\n };\n \n-int main (argc, argv)\n-     int argc ATTRIBUTE_UNUSED;\n-     char **argv;\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n {\n   int opt;\n \n@@ -98,14 +97,14 @@ int main (argc, argv)\n \t  fprintf (stderr, \"unknown flag `%c'\\n\", opt);\n \t}\n     }\n-  \n+\n   while (argv[optind])\n     dump_file (argv[optind++]);\n   return 0;\n }\n \n static void\n-print_usage ()\n+print_usage (void)\n {\n   printf (\"Usage: gcov-dump [OPTION] ... gcovfiles\\n\");\n   printf (\"Print coverage file contents\\n\");\n@@ -116,7 +115,7 @@ print_usage ()\n }\n \n static void\n-print_version ()\n+print_version (void)\n {\n   char v[4];\n   unsigned version = GCOV_VERSION;\n@@ -131,32 +130,28 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n }\n \n static void\n-print_prefix (filename, depth, position)\n-     const char *filename;\n-     unsigned depth;\n-     gcov_position_t position;\n+print_prefix (const char *filename, unsigned depth, gcov_position_t position)\n {\n   static const char prefix[] = \"    \";\n-  \n+\n   printf (\"%s:\", filename);\n   if (flag_dump_positions)\n     printf (\"%lu:\", (unsigned long) position);\n   printf (\"%.*s\", (int) depth, prefix);\n }\n \n static void\n-dump_file (filename)\n-     const char *filename;\n+dump_file (const char *filename)\n {\n   unsigned tags[4];\n   unsigned depth = 0;\n-  \n+\n   if (!gcov_open (filename, 1))\n     {\n       fprintf (stderr, \"%s:cannot open\\n\", filename);\n       return;\n     }\n-  \n+\n   /* magic */\n   {\n     unsigned magic = gcov_read_unsigned ();\n@@ -166,7 +161,7 @@ dump_file (filename)\n     unsigned expected = GCOV_VERSION;\n     unsigned ix;\n     int different = version != GCOV_VERSION;\n-    \n+\n     if (magic == GCOV_DATA_MAGIC)\n       type = \"data\";\n     else if (magic == GCOV_GRAPH_MAGIC)\n@@ -183,7 +178,7 @@ dump_file (filename)\n \tv[ix] = version;\n \tm[ix] = magic;\n       }\n-    \n+\n     printf (\"%s:%s:magic `%.4s':version `%.4s'\\n\", filename, type, m, v);\n     if (different)\n       printf (\"%s:warning:current version is `%.4s'\\n\", filename, e);\n@@ -229,17 +224,17 @@ dump_file (filename)\n \t  depth = tag_depth;\n \t  tags[depth - 1] = tag;\n \t}\n-      \n+\n       print_prefix (filename, tag_depth, position);\n       printf (\"%08x:%4u:%s\", tag, length, format->name);\n       if (format->proc)\n \t(*format->proc) (filename, tag, length);\n-      \n+\n       printf (\"\\n\");\n       if (flag_dump_contents && format->proc)\n \t{\n \t  unsigned long actual_length = gcov_position () - base;\n-\t  \n+\n \t  if (actual_length > length)\n \t    printf (\"%s:record size mismatch %lu bytes overread\\n\",\n \t\t    filename, actual_length - length);\n@@ -262,20 +257,18 @@ dump_file (filename)\n }\n \n static void\n-tag_function (filename, tag, length)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     unsigned tag ATTRIBUTE_UNUSED;\n-     unsigned length ATTRIBUTE_UNUSED;\n+tag_function (const char *filename ATTRIBUTE_UNUSED,\n+\t      unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   unsigned long pos = gcov_position ();\n-  \n+\n   printf (\" ident=%u\", gcov_read_unsigned ());\n   printf (\", checksum=0x%08x\", gcov_read_unsigned ());\n \n   if (gcov_position () - pos < length)\n     {\n       const char *name;\n-      \n+\n       name = gcov_read_string ();\n       printf (\", `%s'\", name ? name : \"NULL\");\n       name = gcov_read_string ();\n@@ -285,13 +278,11 @@ tag_function (filename, tag, length)\n }\n \n static void\n-tag_blocks (filename, tag, length)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     unsigned tag ATTRIBUTE_UNUSED;\n-     unsigned length ATTRIBUTE_UNUSED;\n+tag_blocks (const char *filename ATTRIBUTE_UNUSED,\n+\t    unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   unsigned n_blocks = length / 4;\n-  \n+\n   printf (\" %u blocks\", n_blocks);\n \n   if (flag_dump_contents)\n@@ -312,10 +303,8 @@ tag_blocks (filename, tag, length)\n }\n \n static void\n-tag_arcs (filename, tag, length)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     unsigned tag ATTRIBUTE_UNUSED;\n-     unsigned length ATTRIBUTE_UNUSED;\n+tag_arcs (const char *filename ATTRIBUTE_UNUSED,\n+\t  unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   unsigned n_arcs = (length - 4) / 8;\n \n@@ -328,7 +317,7 @@ tag_arcs (filename, tag, length)\n       for (ix = 0; ix != n_arcs; ix++)\n \t{\n \t  unsigned dst, flags;\n-\t  \n+\n \t  if (!(ix & 3))\n \t    {\n \t      printf (\"\\n\");\n@@ -343,10 +332,8 @@ tag_arcs (filename, tag, length)\n }\n \n static void\n-tag_lines (filename, tag, length)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     unsigned tag ATTRIBUTE_UNUSED;\n-     unsigned length ATTRIBUTE_UNUSED;\n+tag_lines (const char *filename ATTRIBUTE_UNUSED,\n+\t   unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   if (flag_dump_contents)\n     {\n@@ -358,15 +345,15 @@ tag_lines (filename, tag, length)\n \t  gcov_position_t position = gcov_position ();\n \t  const char *source = NULL;\n \t  unsigned lineno = gcov_read_unsigned ();\n-\t  \n+\n \t  if (!lineno)\n \t    {\n \t      source = gcov_read_string ();\n \t      if (!source)\n \t\tbreak;\n \t      sep = NULL;\n \t    }\n-\t  \n+\n \t  if (!sep)\n \t    {\n \t      printf (\"\\n\");\n@@ -389,14 +376,12 @@ tag_lines (filename, tag, length)\n }\n \n static void\n-tag_counters (filename, tag, length)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     unsigned tag ATTRIBUTE_UNUSED;\n-     unsigned length ATTRIBUTE_UNUSED;\n+tag_counters (const char *filename ATTRIBUTE_UNUSED,\n+\t      unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   static const char *const counter_names[] = GCOV_COUNTER_NAMES;\n   unsigned n_counts = length / 8;\n-  \n+\n   printf (\" %s %u counts\",\n \t  counter_names[GCOV_COUNTER_FOR_TAG (tag)], n_counts);\n   if (flag_dump_contents)\n@@ -406,14 +391,14 @@ tag_counters (filename, tag, length)\n       for (ix = 0; ix != n_counts; ix++)\n \t{\n \t  gcov_type count;\n-\t  \n+\n \t  if (!(ix & 7))\n \t    {\n \t      printf (\"\\n\");\n \t      print_prefix (filename, 0, gcov_position ());\n \t      printf (\"\\t\\t%u\", ix);\n \t    }\n-\t  \n+\n \t  count = gcov_read_counter ();\n \t  printf (\" \");\n \t  printf (HOST_WIDEST_INT_PRINT_DEC, count);\n@@ -422,24 +407,22 @@ tag_counters (filename, tag, length)\n }\n \n static void\n-tag_summary (filename, tag, length)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     unsigned tag ATTRIBUTE_UNUSED;\n-     unsigned length ATTRIBUTE_UNUSED;\n+tag_summary (const char *filename ATTRIBUTE_UNUSED,\n+\t     unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   struct gcov_summary summary;\n   unsigned ix;\n-  \n+\n   gcov_read_summary (&summary);\n   printf (\" checksum=0x%08x\", summary.checksum);\n-  \n+\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     {\n       printf (\"\\n\");\n       print_prefix (filename, 0, 0);\n       printf (\"\\t\\tcounts=%u, runs=%u\",\n \t      summary.ctrs[ix].num, summary.ctrs[ix].runs);\n-      \n+\n       printf (\", sum_all=\" HOST_WIDEST_INT_PRINT_DEC,\n \t      (HOST_WIDEST_INT)summary.ctrs[ix].sum_all);\n       printf (\", run_max=\" HOST_WIDEST_INT_PRINT_DEC,"}, {"sha": "a4ceeccbd3e76b5ef2ef7e24933185c02498659a", "filename": "gcc/gcov-iov.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcov-iov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcov-iov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-iov.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,8 +1,8 @@\n /* Generate gcov version string from version.c. See gcov-io.h for\n    description of how the version string is generated.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Nathan Sidwell <nathan@codesourcery.com>\n-   \n+\n This file is part of GCC.\n \n GCC is free software; you can redistribute it and/or modify it under\n@@ -26,12 +26,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm.h\"\n #include \"version.c\" /* We want the actual string.  */\n \n-int main PARAMS ((int, char **));\n+int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc ATTRIBUTE_UNUSED;\n-     char **argv;\n+main (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n {\n   unsigned version = 0;\n   unsigned char v[4];\n@@ -56,7 +54,7 @@ main (argc, argv)\n   v[1] = (minor / 10) + '0';\n   v[2] = (minor % 10) + '0';\n   v[3] = s ? s : '*';\n-    \n+\n   for (ix = 0; ix != 4; ix++)\n     version = (version << 8) | v[ix];\n \n@@ -65,6 +63,6 @@ main (argc, argv)\n   printf (\"\\n\");\n   printf (\"#define GCOV_VERSION ((unsigned)%#08x)  /* %.4s */\\n\",\n \t  version, v);\n-  \n+\n   return 0;\n }"}, {"sha": "9d83f05903969d1d5ea322d1763f2142a59143aa", "filename": "gcc/gcse.c", "status": "modified", "additions": 334, "deletions": 556, "changes": 890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -548,174 +548,166 @@ struct null_pointer_info\n   sbitmap *nonnull_killed;\n };\n \f\n-static void compute_can_copy\tPARAMS ((void));\n-static char *gmalloc\t\tPARAMS ((unsigned int));\n-static char *grealloc\t\tPARAMS ((char *, unsigned int));\n-static char *gcse_alloc\t\tPARAMS ((unsigned long));\n-static void alloc_gcse_mem\tPARAMS ((rtx));\n-static void free_gcse_mem\tPARAMS ((void));\n-static void alloc_reg_set_mem\tPARAMS ((int));\n-static void free_reg_set_mem\tPARAMS ((void));\n-static int get_bitmap_width     PARAMS ((int, int, int));\n-static void record_one_set\tPARAMS ((int, rtx));\n-static void record_set_info\tPARAMS ((rtx, rtx, void *));\n-static void compute_sets\tPARAMS ((rtx));\n-static void hash_scan_insn\tPARAMS ((rtx, struct hash_table *, int));\n-static void hash_scan_set\tPARAMS ((rtx, rtx, struct hash_table *));\n-static void hash_scan_clobber\tPARAMS ((rtx, rtx, struct hash_table *));\n-static void hash_scan_call\tPARAMS ((rtx, rtx, struct hash_table *));\n-static int want_to_gcse_p\tPARAMS ((rtx));\n-static bool gcse_constant_p\tPARAMS ((rtx));\n-static int oprs_unchanged_p\tPARAMS ((rtx, rtx, int));\n-static int oprs_anticipatable_p PARAMS ((rtx, rtx));\n-static int oprs_available_p\tPARAMS ((rtx, rtx));\n-static void insert_expr_in_table PARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t  int, int, struct hash_table *));\n-static void insert_set_in_table PARAMS ((rtx, rtx, struct hash_table *));\n-static unsigned int hash_expr\tPARAMS ((rtx, enum machine_mode, int *, int));\n-static unsigned int hash_expr_1 PARAMS ((rtx, enum machine_mode, int *));\n-static unsigned int hash_string_1 PARAMS ((const char *));\n-static unsigned int hash_set\tPARAMS ((int, int));\n-static int expr_equiv_p\t        PARAMS ((rtx, rtx));\n-static void record_last_reg_set_info PARAMS ((rtx, int));\n-static void record_last_mem_set_info PARAMS ((rtx));\n-static void record_last_set_info PARAMS ((rtx, rtx, void *));\n-static void compute_hash_table\tPARAMS ((struct hash_table *));\n-static void alloc_hash_table PARAMS ((int, struct hash_table *, int));\n-static void free_hash_table PARAMS ((struct hash_table *));\n-static void compute_hash_table_work PARAMS ((struct hash_table *));\n-static void dump_hash_table\tPARAMS ((FILE *, const char *,\n-\t\t\t\t\tstruct hash_table *));\n-static struct expr *lookup_expr\tPARAMS ((rtx, struct hash_table *));\n-static struct expr *lookup_set\tPARAMS ((unsigned int, struct hash_table *));\n-static struct expr *next_set\tPARAMS ((unsigned int, struct expr *));\n-static void reset_opr_set_tables PARAMS ((void));\n-static int oprs_not_set_p\tPARAMS ((rtx, rtx));\n-static void mark_call\t\tPARAMS ((rtx));\n-static void mark_set\t\tPARAMS ((rtx, rtx));\n-static void mark_clobber\tPARAMS ((rtx, rtx));\n-static void mark_oprs_set\tPARAMS ((rtx));\n-static void alloc_cprop_mem\tPARAMS ((int, int));\n-static void free_cprop_mem\tPARAMS ((void));\n-static void compute_transp\tPARAMS ((rtx, int, sbitmap *, int));\n-static void compute_transpout\tPARAMS ((void));\n-static void compute_local_properties PARAMS ((sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t\t      struct hash_table *));\n-static void compute_cprop_data\tPARAMS ((void));\n-static void find_used_regs\tPARAMS ((rtx *, void *));\n-static int try_replace_reg\tPARAMS ((rtx, rtx, rtx));\n-static struct expr *find_avail_set PARAMS ((int, rtx));\n-static int cprop_jump\t\tPARAMS ((basic_block, rtx, rtx, rtx, rtx));\n-static void mems_conflict_for_gcse_p PARAMS ((rtx, rtx, void *));\n-static int load_killed_in_block_p    PARAMS ((basic_block, int, rtx, int));\n-static void canon_list_insert        PARAMS ((rtx, rtx, void *));\n-static int cprop_insn\t\tPARAMS ((rtx, int));\n-static int cprop\t\tPARAMS ((int));\n-static void find_implicit_sets\tPARAMS ((void));\n-static int one_cprop_pass\tPARAMS ((int, int, int));\n-static bool constprop_register\tPARAMS ((rtx, rtx, rtx, int));\n-static struct expr *find_bypass_set PARAMS ((int, int));\n-static bool reg_killed_on_edge\t    PARAMS ((rtx, edge));\n-static int bypass_block\t\t    PARAMS ((basic_block, rtx, rtx));\n-static int bypass_conditional_jumps PARAMS ((void));\n-static void alloc_pre_mem\tPARAMS ((int, int));\n-static void free_pre_mem\tPARAMS ((void));\n-static void compute_pre_data\tPARAMS ((void));\n-static int pre_expr_reaches_here_p PARAMS ((basic_block, struct expr *,\n-\t\t\t\t\t    basic_block));\n-static void insert_insn_end_bb\tPARAMS ((struct expr *, basic_block, int));\n-static void pre_insert_copy_insn PARAMS ((struct expr *, rtx));\n-static void pre_insert_copies\tPARAMS ((void));\n-static int pre_delete\t\tPARAMS ((void));\n-static int pre_gcse\t\tPARAMS ((void));\n-static int one_pre_gcse_pass\tPARAMS ((int));\n-static void add_label_notes\tPARAMS ((rtx, rtx));\n-static void alloc_code_hoist_mem PARAMS ((int, int));\n-static void free_code_hoist_mem\tPARAMS ((void));\n-static void compute_code_hoist_vbeinout\tPARAMS ((void));\n-static void compute_code_hoist_data PARAMS ((void));\n-static int hoist_expr_reaches_here_p PARAMS ((basic_block, int, basic_block,\n-\t\t\t\t\t      char *));\n-static void hoist_code\t\tPARAMS ((void));\n-static int one_code_hoisting_pass PARAMS ((void));\n-static void alloc_rd_mem\tPARAMS ((int, int));\n-static void free_rd_mem\t\tPARAMS ((void));\n-static void handle_rd_kill_set\tPARAMS ((rtx, int, basic_block));\n-static void compute_kill_rd\tPARAMS ((void));\n-static void compute_rd\t\tPARAMS ((void));\n-static void alloc_avail_expr_mem PARAMS ((int, int));\n-static void free_avail_expr_mem PARAMS ((void));\n-static void compute_ae_gen\tPARAMS ((struct hash_table *));\n-static int expr_killed_p\tPARAMS ((rtx, basic_block));\n-static void compute_ae_kill\tPARAMS ((sbitmap *, sbitmap *, struct hash_table *));\n-static int expr_reaches_here_p\tPARAMS ((struct occr *, struct expr *,\n-\t\t\t\t\t basic_block, int));\n-static rtx computing_insn\tPARAMS ((struct expr *, rtx));\n-static int def_reaches_here_p\tPARAMS ((rtx, rtx));\n-static int can_disregard_other_sets PARAMS ((struct reg_set **, rtx, int));\n-static int handle_avail_expr\tPARAMS ((rtx, struct expr *));\n-static int classic_gcse\t\tPARAMS ((void));\n-static int one_classic_gcse_pass PARAMS ((int));\n-static void invalidate_nonnull_info PARAMS ((rtx, rtx, void *));\n-static int delete_null_pointer_checks_1 PARAMS ((unsigned int *,\n-\t\t\t\t\t\t  sbitmap *, sbitmap *,\n-\t\t\t\t\t\t  struct null_pointer_info *));\n-static rtx process_insert_insn\tPARAMS ((struct expr *));\n-static int pre_edge_insert\tPARAMS ((struct edge_list *, struct expr **));\n-static int expr_reaches_here_p_work PARAMS ((struct occr *, struct expr *,\n-\t\t\t\t\t     basic_block, int, char *));\n-static int pre_expr_reaches_here_p_work\tPARAMS ((basic_block, struct expr *,\n-\t\t\t\t\t\t basic_block, char *));\n-static struct ls_expr * ldst_entry \tPARAMS ((rtx));\n-static void free_ldst_entry \t\tPARAMS ((struct ls_expr *));\n-static void free_ldst_mems\t\tPARAMS ((void));\n-static void print_ldst_list \t\tPARAMS ((FILE *));\n-static struct ls_expr * find_rtx_in_ldst PARAMS ((rtx));\n-static int enumerate_ldsts\t\tPARAMS ((void));\n-static inline struct ls_expr * first_ls_expr PARAMS ((void));\n-static inline struct ls_expr * next_ls_expr  PARAMS ((struct ls_expr *));\n-static int simple_mem\t\t\tPARAMS ((rtx));\n-static void invalidate_any_buried_refs\tPARAMS ((rtx));\n-static void compute_ld_motion_mems\tPARAMS ((void));\n-static void trim_ld_motion_mems\t\tPARAMS ((void));\n-static void update_ld_motion_stores\tPARAMS ((struct expr *));\n-static void reg_set_info\t\tPARAMS ((rtx, rtx, void *));\n-static bool store_ops_ok\t\tPARAMS ((rtx, int *));\n-static rtx extract_mentioned_regs\tPARAMS ((rtx));\n-static rtx extract_mentioned_regs_helper PARAMS ((rtx, rtx));\n-static void find_moveable_store\t\tPARAMS ((rtx, int *, int *));\n-static int compute_store_table\t\tPARAMS ((void));\n-static bool load_kills_store\t\tPARAMS ((rtx, rtx));\n-static bool find_loads\t\t\tPARAMS ((rtx, rtx));\n-static bool store_killed_in_insn\tPARAMS ((rtx, rtx, rtx));\n-static bool store_killed_after\t\tPARAMS ((rtx, rtx, rtx, basic_block,\n-\t\t\t\t\t\t int *, rtx *));\n-static bool store_killed_before\t\tPARAMS ((rtx, rtx, rtx, basic_block,\n-\t\t\t\t\t\t int *));\n-static void build_store_vectors\t\tPARAMS ((void));\n-static void insert_insn_start_bb\tPARAMS ((rtx, basic_block));\n-static int insert_store\t\t\tPARAMS ((struct ls_expr *, edge));\n-static void replace_store_insn\t\tPARAMS ((rtx, rtx, basic_block));\n-static void delete_store\t\tPARAMS ((struct ls_expr *,\n-\t\t\t\t\t\t basic_block));\n-static void free_store_memory\t\tPARAMS ((void));\n-static void store_motion\t\tPARAMS ((void));\n-static void free_insn_expr_list_list\tPARAMS ((rtx *));\n-static void clear_modify_mem_tables\tPARAMS ((void));\n-static void free_modify_mem_tables\tPARAMS ((void));\n-static rtx gcse_emit_move_after\t\tPARAMS ((rtx, rtx, rtx));\n-static void local_cprop_find_used_regs\tPARAMS ((rtx *, void *));\n-static bool do_local_cprop\t\tPARAMS ((rtx, rtx, int, rtx*));\n-static bool adjust_libcall_notes\tPARAMS ((rtx, rtx, rtx, rtx*));\n-static void local_cprop_pass\t\tPARAMS ((int));\n+static void compute_can_copy (void);\n+static char *gmalloc (unsigned int);\n+static char *grealloc (char *, unsigned int);\n+static char *gcse_alloc (unsigned long);\n+static void alloc_gcse_mem (rtx);\n+static void free_gcse_mem (void);\n+static void alloc_reg_set_mem (int);\n+static void free_reg_set_mem (void);\n+static int get_bitmap_width (int, int, int);\n+static void record_one_set (int, rtx);\n+static void record_set_info (rtx, rtx, void *);\n+static void compute_sets (rtx);\n+static void hash_scan_insn (rtx, struct hash_table *, int);\n+static void hash_scan_set (rtx, rtx, struct hash_table *);\n+static void hash_scan_clobber (rtx, rtx, struct hash_table *);\n+static void hash_scan_call (rtx, rtx, struct hash_table *);\n+static int want_to_gcse_p (rtx);\n+static bool gcse_constant_p (rtx);\n+static int oprs_unchanged_p (rtx, rtx, int);\n+static int oprs_anticipatable_p (rtx, rtx);\n+static int oprs_available_p (rtx, rtx);\n+static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int,\n+\t\t\t\t  struct hash_table *);\n+static void insert_set_in_table (rtx, rtx, struct hash_table *);\n+static unsigned int hash_expr (rtx, enum machine_mode, int *, int);\n+static unsigned int hash_expr_1 (rtx, enum machine_mode, int *);\n+static unsigned int hash_string_1 (const char *);\n+static unsigned int hash_set (int, int);\n+static int expr_equiv_p (rtx, rtx);\n+static void record_last_reg_set_info (rtx, int);\n+static void record_last_mem_set_info (rtx);\n+static void record_last_set_info (rtx, rtx, void *);\n+static void compute_hash_table (struct hash_table *);\n+static void alloc_hash_table (int, struct hash_table *, int);\n+static void free_hash_table (struct hash_table *);\n+static void compute_hash_table_work (struct hash_table *);\n+static void dump_hash_table (FILE *, const char *, struct hash_table *);\n+static struct expr *lookup_expr (rtx, struct hash_table *);\n+static struct expr *lookup_set (unsigned int, struct hash_table *);\n+static struct expr *next_set (unsigned int, struct expr *);\n+static void reset_opr_set_tables (void);\n+static int oprs_not_set_p (rtx, rtx);\n+static void mark_call (rtx);\n+static void mark_set (rtx, rtx);\n+static void mark_clobber (rtx, rtx);\n+static void mark_oprs_set (rtx);\n+static void alloc_cprop_mem (int, int);\n+static void free_cprop_mem (void);\n+static void compute_transp (rtx, int, sbitmap *, int);\n+static void compute_transpout (void);\n+static void compute_local_properties (sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t      struct hash_table *);\n+static void compute_cprop_data (void);\n+static void find_used_regs (rtx *, void *);\n+static int try_replace_reg (rtx, rtx, rtx);\n+static struct expr *find_avail_set (int, rtx);\n+static int cprop_jump (basic_block, rtx, rtx, rtx, rtx);\n+static void mems_conflict_for_gcse_p (rtx, rtx, void *);\n+static int load_killed_in_block_p (basic_block, int, rtx, int);\n+static void canon_list_insert (rtx, rtx, void *);\n+static int cprop_insn (rtx, int);\n+static int cprop (int);\n+static void find_implicit_sets (void);\n+static int one_cprop_pass (int, int, int);\n+static bool constprop_register (rtx, rtx, rtx, int);\n+static struct expr *find_bypass_set (int, int);\n+static bool reg_killed_on_edge (rtx, edge);\n+static int bypass_block (basic_block, rtx, rtx);\n+static int bypass_conditional_jumps (void);\n+static void alloc_pre_mem (int, int);\n+static void free_pre_mem (void);\n+static void compute_pre_data (void);\n+static int pre_expr_reaches_here_p (basic_block, struct expr *,\n+\t\t\t\t    basic_block);\n+static void insert_insn_end_bb (struct expr *, basic_block, int);\n+static void pre_insert_copy_insn (struct expr *, rtx);\n+static void pre_insert_copies (void);\n+static int pre_delete (void);\n+static int pre_gcse (void);\n+static int one_pre_gcse_pass (int);\n+static void add_label_notes (rtx, rtx);\n+static void alloc_code_hoist_mem (int, int);\n+static void free_code_hoist_mem (void);\n+static void compute_code_hoist_vbeinout (void);\n+static void compute_code_hoist_data (void);\n+static int hoist_expr_reaches_here_p (basic_block, int, basic_block, char *);\n+static void hoist_code (void);\n+static int one_code_hoisting_pass (void);\n+static void alloc_rd_mem (int, int);\n+static void free_rd_mem (void);\n+static void handle_rd_kill_set (rtx, int, basic_block);\n+static void compute_kill_rd (void);\n+static void compute_rd (void);\n+static void alloc_avail_expr_mem (int, int);\n+static void free_avail_expr_mem (void);\n+static void compute_ae_gen (struct hash_table *);\n+static int expr_killed_p (rtx, basic_block);\n+static void compute_ae_kill (sbitmap *, sbitmap *, struct hash_table *);\n+static int expr_reaches_here_p (struct occr *, struct expr *, basic_block,\n+\t\t\t\tint);\n+static rtx computing_insn (struct expr *, rtx);\n+static int def_reaches_here_p (rtx, rtx);\n+static int can_disregard_other_sets (struct reg_set **, rtx, int);\n+static int handle_avail_expr (rtx, struct expr *);\n+static int classic_gcse (void);\n+static int one_classic_gcse_pass (int);\n+static void invalidate_nonnull_info (rtx, rtx, void *);\n+static int delete_null_pointer_checks_1 (unsigned int *, sbitmap *, sbitmap *,\n+\t\t\t\t\t struct null_pointer_info *);\n+static rtx process_insert_insn (struct expr *);\n+static int pre_edge_insert (struct edge_list *, struct expr **);\n+static int expr_reaches_here_p_work (struct occr *, struct expr *,\n+\t\t\t\t     basic_block, int, char *);\n+static int pre_expr_reaches_here_p_work (basic_block, struct expr *,\n+\t\t\t\t\t basic_block, char *);\n+static struct ls_expr * ldst_entry (rtx);\n+static void free_ldst_entry (struct ls_expr *);\n+static void free_ldst_mems (void);\n+static void print_ldst_list (FILE *);\n+static struct ls_expr * find_rtx_in_ldst (rtx);\n+static int enumerate_ldsts (void);\n+static inline struct ls_expr * first_ls_expr (void);\n+static inline struct ls_expr * next_ls_expr (struct ls_expr *);\n+static int simple_mem (rtx);\n+static void invalidate_any_buried_refs (rtx);\n+static void compute_ld_motion_mems (void);\n+static void trim_ld_motion_mems (void);\n+static void update_ld_motion_stores (struct expr *);\n+static void reg_set_info (rtx, rtx, void *);\n+static bool store_ops_ok (rtx, int *);\n+static rtx extract_mentioned_regs (rtx);\n+static rtx extract_mentioned_regs_helper (rtx, rtx);\n+static void find_moveable_store (rtx, int *, int *);\n+static int compute_store_table (void);\n+static bool load_kills_store (rtx, rtx);\n+static bool find_loads (rtx, rtx);\n+static bool store_killed_in_insn (rtx, rtx, rtx);\n+static bool store_killed_after (rtx, rtx, rtx, basic_block, int *, rtx *);\n+static bool store_killed_before (rtx, rtx, rtx, basic_block, int *);\n+static void build_store_vectors (void);\n+static void insert_insn_start_bb (rtx, basic_block);\n+static int insert_store (struct ls_expr *, edge);\n+static void replace_store_insn (rtx, rtx, basic_block);\n+static void delete_store (struct ls_expr *, basic_block);\n+static void free_store_memory (void);\n+static void store_motion (void);\n+static void free_insn_expr_list_list (rtx *);\n+static void clear_modify_mem_tables (void);\n+static void free_modify_mem_tables (void);\n+static rtx gcse_emit_move_after (rtx, rtx, rtx);\n+static void local_cprop_find_used_regs (rtx *, void *);\n+static bool do_local_cprop (rtx, rtx, int, rtx*);\n+static bool adjust_libcall_notes (rtx, rtx, rtx, rtx*);\n+static void local_cprop_pass (int);\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n \n int\n-gcse_main (f, file)\n-     rtx f;\n-     FILE *file;\n+gcse_main (rtx f, FILE *file)\n {\n   int changed, pass;\n   /* Bytes used at start of pass.  */\n@@ -917,7 +909,7 @@ static char can_copy[(int) NUM_MACHINE_MODES];\n /* Compute which modes support reg/reg copy operations.  */\n \n static void\n-compute_can_copy ()\n+compute_can_copy (void)\n {\n   int i;\n #ifndef AVOID_CCMODE_COPIES\n@@ -947,8 +939,7 @@ compute_can_copy ()\n /* Returns whether the mode supports reg/reg copy operations.  */\n \n bool\n-can_copy_p (mode)\n-     enum machine_mode mode;\n+can_copy_p (enum machine_mode mode)\n {\n   static bool can_copy_init_p = false;\n \n@@ -964,8 +955,7 @@ can_copy_p (mode)\n /* Cover function to xmalloc to record bytes allocated.  */\n \n static char *\n-gmalloc (size)\n-     unsigned int size;\n+gmalloc (unsigned int size)\n {\n   bytes_used += size;\n   return xmalloc (size);\n@@ -976,18 +966,15 @@ gmalloc (size)\n    It won't affect memory usage stats much anyway.  */\n \n static char *\n-grealloc (ptr, size)\n-     char *ptr;\n-     unsigned int size;\n+grealloc (char *ptr, unsigned int size)\n {\n   return xrealloc (ptr, size);\n }\n \n /* Cover function to obstack_alloc.  */\n \n static char *\n-gcse_alloc (size)\n-     unsigned long size;\n+gcse_alloc (unsigned long size)\n {\n   bytes_used += size;\n   return (char *) obstack_alloc (&gcse_obstack, size);\n@@ -999,8 +986,7 @@ gcse_alloc (size)\n    This is called at the start of each pass.  */\n \n static void\n-alloc_gcse_mem (f)\n-     rtx f;\n+alloc_gcse_mem (rtx f)\n {\n   int i, n;\n   rtx insn;\n@@ -1050,7 +1036,7 @@ alloc_gcse_mem (f)\n /* Free memory allocated by alloc_gcse_mem.  */\n \n static void\n-free_gcse_mem ()\n+free_gcse_mem (void)\n {\n   free (uid_cuid);\n   free (cuid_insn);\n@@ -1081,10 +1067,7 @@ free_gcse_mem ()\n    less space.  */\n \n static int\n-get_bitmap_width (n, x, y)\n-     int n;\n-     int x;\n-     int y;\n+get_bitmap_width (int n, int x, int y)\n {\n   /* It's not really worth figuring out *exactly* how much memory will\n      be used by a particular choice.  The important thing is to get\n@@ -1134,11 +1117,7 @@ get_bitmap_width (n, x, y)\n    ABSALTERED.  */\n \n static void\n-compute_local_properties (transp, comp, antloc, table)\n-     sbitmap *transp;\n-     sbitmap *comp;\n-     sbitmap *antloc;\n-     struct hash_table *table;\n+compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc, struct hash_table *table)\n {\n   unsigned int i;\n \n@@ -1210,8 +1189,7 @@ compute_local_properties (transp, comp, antloc, table)\n static struct obstack reg_set_obstack;\n \n static void\n-alloc_reg_set_mem (n_regs)\n-     int n_regs;\n+alloc_reg_set_mem (int n_regs)\n {\n   unsigned int n;\n \n@@ -1224,7 +1202,7 @@ alloc_reg_set_mem (n_regs)\n }\n \n static void\n-free_reg_set_mem ()\n+free_reg_set_mem (void)\n {\n   free (reg_set_table);\n   obstack_free (&reg_set_obstack, NULL);\n@@ -1233,9 +1211,7 @@ free_reg_set_mem ()\n /* Record REGNO in the reg_set table.  */\n \n static void\n-record_one_set (regno, insn)\n-     int regno;\n-     rtx insn;\n+record_one_set (int regno, rtx insn)\n {\n   /* Allocate a new reg_set element and link it onto the list.  */\n   struct reg_set *new_reg_info;\n@@ -1266,9 +1242,7 @@ record_one_set (regno, insn)\n    occurring.  */\n \n static void\n-record_set_info (dest, setter, data)\n-     rtx dest, setter ATTRIBUTE_UNUSED;\n-     void *data;\n+record_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n   rtx record_set_insn = (rtx) data;\n \n@@ -1282,8 +1256,7 @@ record_set_info (dest, setter, data)\n    `reg_set_table' for further documentation.  */\n \n static void\n-compute_sets (f)\n-     rtx f;\n+compute_sets (rtx f)\n {\n   rtx insn;\n \n@@ -1310,8 +1283,7 @@ static basic_block current_bb;\n \n static GTY(()) rtx test_insn;\n static int\n-want_to_gcse_p (x)\n-     rtx x;\n+want_to_gcse_p (rtx x)\n {\n   int num_clobbers = 0;\n   int icode;\n@@ -1362,9 +1334,7 @@ want_to_gcse_p (x)\n    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */\n \n static int\n-oprs_unchanged_p (x, insn, avail_p)\n-     rtx x, insn;\n-     int avail_p;\n+oprs_unchanged_p (rtx x, rtx insn, int avail_p)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -1457,9 +1427,8 @@ static rtx gcse_mem_operand;\n    gcse_mems_conflict_p to a nonzero value.  */\n \n static void\n-mems_conflict_for_gcse_p (dest, setter, data)\n-     rtx dest, setter ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+mems_conflict_for_gcse_p (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n+\t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n   while (GET_CODE (dest) == SUBREG\n \t || GET_CODE (dest) == ZERO_EXTRACT\n@@ -1497,11 +1466,7 @@ mems_conflict_for_gcse_p (dest, setter, data)\n    AVAIL_P to 0.  */\n \n static int\n-load_killed_in_block_p (bb, uid_limit, x, avail_p)\n-     basic_block bb;\n-     int uid_limit;\n-     rtx x;\n-     int avail_p;\n+load_killed_in_block_p (basic_block bb, int uid_limit, rtx x, int avail_p)\n {\n   rtx list_entry = modify_mem_list[bb->index];\n   while (list_entry)\n@@ -1544,8 +1509,7 @@ load_killed_in_block_p (bb, uid_limit, x, avail_p)\n    the start of INSN's basic block up to but not including INSN.  */\n \n static int\n-oprs_anticipatable_p (x, insn)\n-     rtx x, insn;\n+oprs_anticipatable_p (rtx x, rtx insn)\n {\n   return oprs_unchanged_p (x, insn, 0);\n }\n@@ -1554,8 +1518,7 @@ oprs_anticipatable_p (x, insn)\n    INSN to the end of INSN's basic block.  */\n \n static int\n-oprs_available_p (x, insn)\n-     rtx x, insn;\n+oprs_available_p (rtx x, rtx insn)\n {\n   return oprs_unchanged_p (x, insn, 1);\n }\n@@ -1569,11 +1532,7 @@ oprs_available_p (x, insn)\n    ??? One might want to merge this with canon_hash.  Later.  */\n \n static unsigned int\n-hash_expr (x, mode, do_not_record_p, hash_table_size)\n-     rtx x;\n-     enum machine_mode mode;\n-     int *do_not_record_p;\n-     int hash_table_size;\n+hash_expr (rtx x, enum machine_mode mode, int *do_not_record_p, int hash_table_size)\n {\n   unsigned int hash;\n \n@@ -1586,8 +1545,7 @@ hash_expr (x, mode, do_not_record_p, hash_table_size)\n /* Hash a string.  Just add its bytes up.  */\n \n static inline unsigned\n-hash_string_1 (ps)\n-     const char *ps;\n+hash_string_1 (const char *ps)\n {\n   unsigned hash = 0;\n   const unsigned char *p = (const unsigned char *) ps;\n@@ -1602,10 +1560,7 @@ hash_string_1 (ps)\n /* Subroutine of hash_expr to do the actual work.  */\n \n static unsigned int\n-hash_expr_1 (x, mode, do_not_record_p)\n-     rtx x;\n-     enum machine_mode mode;\n-     int *do_not_record_p;\n+hash_expr_1 (rtx x, enum machine_mode mode, int *do_not_record_p)\n {\n   int i, j;\n   unsigned hash = 0;\n@@ -1793,9 +1748,7 @@ hash_expr_1 (x, mode, do_not_record_p)\n    ??? May need to make things more elaborate.  Later, as necessary.  */\n \n static unsigned int\n-hash_set (regno, hash_table_size)\n-     int regno;\n-     int hash_table_size;\n+hash_set (int regno, int hash_table_size)\n {\n   unsigned int hash;\n \n@@ -1807,8 +1760,7 @@ hash_set (regno, hash_table_size)\n    ??? Borrowed from cse.c.  Might want to remerge with cse.c.  Later.  */\n \n static int\n-expr_equiv_p (x, y)\n-     rtx x, y;\n+expr_equiv_p (rtx x, rtx y)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -1955,12 +1907,8 @@ expr_equiv_p (x, y)\n    AVAIL_P is nonzero if X is an available expression.  */\n \n static void\n-insert_expr_in_table (x, mode, insn, antic_p, avail_p, table)\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx insn;\n-     int antic_p, avail_p;\n-     struct hash_table *table;\n+insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n+\t\t      int avail_p, struct hash_table *table)\n {\n   int found, do_not_record_p;\n   unsigned int hash;\n@@ -2084,10 +2032,7 @@ insert_expr_in_table (x, mode, insn, antic_p, avail_p, table)\n    basic block.  */\n \n static void\n-insert_set_in_table (x, insn, table)\n-     rtx x;\n-     rtx insn;\n-     struct hash_table *table;\n+insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n {\n   int found;\n   unsigned int hash;\n@@ -2170,8 +2115,7 @@ insert_set_in_table (x, insn, table)\n    the purposes of GCSE's constant propagation.  */\n \n static bool\n-gcse_constant_p (x)\n-     rtx x;\n+gcse_constant_p (rtx x)\n {\n   /* Consider a COMPARE of two integers constant.  */\n   if (GET_CODE (x) == COMPARE\n@@ -2189,9 +2133,7 @@ gcse_constant_p (x)\n    expression one).  */\n \n static void\n-hash_scan_set (pat, insn, table)\n-     rtx pat, insn;\n-     struct hash_table *table;\n+hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n {\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n@@ -2265,17 +2207,15 @@ hash_scan_set (pat, insn, table)\n }\n \n static void\n-hash_scan_clobber (x, insn, table)\n-     rtx x ATTRIBUTE_UNUSED, insn ATTRIBUTE_UNUSED;\n-     struct hash_table *table ATTRIBUTE_UNUSED;\n+hash_scan_clobber (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n+\t\t   struct hash_table *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n }\n \n static void\n-hash_scan_call (x, insn, table)\n-     rtx x ATTRIBUTE_UNUSED, insn ATTRIBUTE_UNUSED;\n-     struct hash_table *table ATTRIBUTE_UNUSED;\n+hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n+\t\tstruct hash_table *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n }\n@@ -2294,10 +2234,7 @@ hash_scan_call (x, insn, table)\n    not record any expressions.  */\n \n static void\n-hash_scan_insn (insn, table, in_libcall_block)\n-     rtx insn;\n-     struct hash_table *table;\n-     int in_libcall_block;\n+hash_scan_insn (rtx insn, struct hash_table *table, int in_libcall_block)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n@@ -2330,10 +2267,7 @@ hash_scan_insn (insn, table, in_libcall_block)\n }\n \n static void\n-dump_hash_table (file, name, table)\n-     FILE *file;\n-     const char *name;\n-     struct hash_table *table;\n+dump_hash_table (FILE *file, const char *name, struct hash_table *table)\n {\n   int i;\n   /* Flattened out table, so it's printed in proper order.  */\n@@ -2386,9 +2320,7 @@ dump_hash_table (file, name, table)\n    and is used to compute \"transparency\".  */\n \n static void\n-record_last_reg_set_info (insn, regno)\n-     rtx insn;\n-     int regno;\n+record_last_reg_set_info (rtx insn, int regno)\n {\n   struct reg_avail_info *info = &reg_avail_info[regno];\n   int cuid = INSN_CUID (insn);\n@@ -2408,10 +2340,8 @@ record_last_reg_set_info (insn, regno)\n    taken off pairwise.  */\n \n static void\n-canon_list_insert (dest, unused1, v_insn)\n-     rtx    dest ATTRIBUTE_UNUSED;\n-     rtx    unused1 ATTRIBUTE_UNUSED;\n-     void * v_insn;\n+canon_list_insert (rtx dest ATTRIBUTE_UNUSED, rtx unused1 ATTRIBUTE_UNUSED,\n+\t\t   void * v_insn)\n {\n   rtx dest_addr, insn;\n   int bb;\n@@ -2446,8 +2376,7 @@ canon_list_insert (dest, unused1, v_insn)\n    a CALL_INSN).  We merely need to record which insns modify memory.  */\n \n static void\n-record_last_mem_set_info (insn)\n-     rtx insn;\n+record_last_mem_set_info (rtx insn)\n {\n   int bb = BLOCK_NUM (insn);\n \n@@ -2474,9 +2403,7 @@ record_last_mem_set_info (insn)\n    the SET is taking place.  */\n \n static void\n-record_last_set_info (dest, setter, data)\n-     rtx dest, setter ATTRIBUTE_UNUSED;\n-     void *data;\n+record_last_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n   rtx last_set_insn = (rtx) data;\n \n@@ -2508,8 +2435,7 @@ record_last_set_info (dest, setter, data)\n    TABLE is the table computed.  */\n \n static void\n-compute_hash_table_work (table)\n-     struct hash_table *table;\n+compute_hash_table_work (struct hash_table *table)\n {\n   unsigned int i;\n \n@@ -2600,10 +2526,7 @@ compute_hash_table_work (table)\n    be created.  */\n \n static void\n-alloc_hash_table (n_insns, table, set_p)\n-     int n_insns;\n-     struct hash_table *table;\n-     int set_p;\n+alloc_hash_table (int n_insns, struct hash_table *table, int set_p)\n {\n   int n;\n \n@@ -2623,8 +2546,7 @@ alloc_hash_table (n_insns, table, set_p)\n /* Free things allocated by alloc_hash_table.  */\n \n static void\n-free_hash_table (table)\n-     struct hash_table *table;\n+free_hash_table (struct hash_table *table)\n {\n   free (table->table);\n }\n@@ -2633,8 +2555,7 @@ free_hash_table (table)\n    expression hash table.  */\n \n static void\n-compute_hash_table (table)\n-    struct hash_table *table;\n+compute_hash_table (struct hash_table *table)\n {\n   /* Initialize count of number of entries in hash table.  */\n   table->n_elems = 0;\n@@ -2650,9 +2571,7 @@ compute_hash_table (table)\n    The result is a pointer to the table entry, or NULL if not found.  */\n \n static struct expr *\n-lookup_expr (pat, table)\n-     rtx pat;\n-     struct hash_table *table;\n+lookup_expr (rtx pat, struct hash_table *table)\n {\n   int do_not_record_p;\n   unsigned int hash = hash_expr (pat, GET_MODE (pat), &do_not_record_p,\n@@ -2674,9 +2593,7 @@ lookup_expr (pat, table)\n    table entry, or NULL if not found.  */\n \n static struct expr *\n-lookup_set (regno, table)\n-     unsigned int regno;\n-     struct hash_table *table;\n+lookup_set (unsigned int regno, struct hash_table *table)\n {\n   unsigned int hash = hash_set (regno, table->size);\n   struct expr *expr;\n@@ -2692,9 +2609,7 @@ lookup_set (regno, table)\n /* Return the next entry for REGNO in list EXPR.  */\n \n static struct expr *\n-next_set (regno, expr)\n-     unsigned int regno;\n-     struct expr *expr;\n+next_set (unsigned int regno, struct expr *expr)\n {\n   do\n     expr = expr->next_same_hash;\n@@ -2707,8 +2622,7 @@ next_set (regno, expr)\n    types may be mixed.  */\n \n static void\n-free_insn_expr_list_list (listp)\n-     rtx *listp;\n+free_insn_expr_list_list (rtx *listp)\n {\n   rtx list, next;\n \n@@ -2726,7 +2640,7 @@ free_insn_expr_list_list (listp)\n \n /* Clear canon_modify_mem_list and modify_mem_list tables.  */\n static void\n-clear_modify_mem_tables ()\n+clear_modify_mem_tables (void)\n {\n   int i;\n \n@@ -2743,7 +2657,7 @@ clear_modify_mem_tables ()\n /* Release memory used by modify_mem_list_set and canon_modify_mem_list_set.  */\n \n static void\n-free_modify_mem_tables ()\n+free_modify_mem_tables (void)\n {\n   clear_modify_mem_tables ();\n   free (modify_mem_list);\n@@ -2756,7 +2670,7 @@ free_modify_mem_tables ()\n    start of the block].  */\n \n static void\n-reset_opr_set_tables ()\n+reset_opr_set_tables (void)\n {\n   /* Maintain a bitmap of which regs have been set since beginning of\n      the block.  */\n@@ -2772,8 +2686,7 @@ reset_opr_set_tables ()\n    INSN's basic block.  */\n \n static int\n-oprs_not_set_p (x, insn)\n-     rtx x, insn;\n+oprs_not_set_p (rtx x, rtx insn)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -2836,8 +2749,7 @@ oprs_not_set_p (x, insn)\n /* Mark things set by a CALL.  */\n \n static void\n-mark_call (insn)\n-     rtx insn;\n+mark_call (rtx insn)\n {\n   if (! CONST_OR_PURE_CALL_P (insn))\n     record_last_mem_set_info (insn);\n@@ -2846,8 +2758,7 @@ mark_call (insn)\n /* Mark things set by a SET.  */\n \n static void\n-mark_set (pat, insn)\n-     rtx pat, insn;\n+mark_set (rtx pat, rtx insn)\n {\n   rtx dest = SET_DEST (pat);\n \n@@ -2869,8 +2780,7 @@ mark_set (pat, insn)\n /* Record things set by a CLOBBER.  */\n \n static void\n-mark_clobber (pat, insn)\n-     rtx pat, insn;\n+mark_clobber (rtx pat, rtx insn)\n {\n   rtx clob = XEXP (pat, 0);\n \n@@ -2887,8 +2797,7 @@ mark_clobber (pat, insn)\n    This data is used by oprs_not_set_p.  */\n \n static void\n-mark_oprs_set (insn)\n-     rtx insn;\n+mark_oprs_set (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n@@ -2920,8 +2829,7 @@ mark_oprs_set (insn)\n /* Allocate reaching def variables.  */\n \n static void\n-alloc_rd_mem (n_blocks, n_insns)\n-     int n_blocks, n_insns;\n+alloc_rd_mem (int n_blocks, int n_insns)\n {\n   rd_kill = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n   sbitmap_vector_zero (rd_kill, n_blocks);\n@@ -2939,7 +2847,7 @@ alloc_rd_mem (n_blocks, n_insns)\n /* Free reaching def variables.  */\n \n static void\n-free_rd_mem ()\n+free_rd_mem (void)\n {\n   sbitmap_vector_free (rd_kill);\n   sbitmap_vector_free (rd_gen);\n@@ -2950,10 +2858,7 @@ free_rd_mem ()\n /* Add INSN to the kills of BB.  REGNO, set in BB, is killed by INSN.  */\n \n static void\n-handle_rd_kill_set (insn, regno, bb)\n-     rtx insn;\n-     int regno;\n-     basic_block bb;\n+handle_rd_kill_set (rtx insn, int regno, basic_block bb)\n {\n   struct reg_set *this_reg;\n \n@@ -2965,7 +2870,7 @@ handle_rd_kill_set (insn, regno, bb)\n /* Compute the set of kill's for reaching definitions.  */\n \n static void\n-compute_kill_rd ()\n+compute_kill_rd (void)\n {\n   int cuid;\n   unsigned int regno;\n@@ -3020,7 +2925,7 @@ compute_kill_rd ()\n    expressions but applied to the gens and kills of reaching definitions.  */\n \n static void\n-compute_rd ()\n+compute_rd (void)\n {\n   int changed, passes;\n   basic_block bb;\n@@ -3051,8 +2956,7 @@ compute_rd ()\n /* Allocate memory for available expression computation.  */\n \n static void\n-alloc_avail_expr_mem (n_blocks, n_exprs)\n-     int n_blocks, n_exprs;\n+alloc_avail_expr_mem (int n_blocks, int n_exprs)\n {\n   ae_kill = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n   sbitmap_vector_zero (ae_kill, n_blocks);\n@@ -3068,7 +2972,7 @@ alloc_avail_expr_mem (n_blocks, n_exprs)\n }\n \n static void\n-free_avail_expr_mem ()\n+free_avail_expr_mem (void)\n {\n   sbitmap_vector_free (ae_kill);\n   sbitmap_vector_free (ae_gen);\n@@ -3079,8 +2983,7 @@ free_avail_expr_mem ()\n /* Compute the set of available expressions generated in each basic block.  */\n \n static void\n-compute_ae_gen (expr_hash_table)\n-     struct hash_table *expr_hash_table;\n+compute_ae_gen (struct hash_table *expr_hash_table)\n {\n   unsigned int i;\n   struct expr *expr;\n@@ -3099,9 +3002,7 @@ compute_ae_gen (expr_hash_table)\n /* Return nonzero if expression X is killed in BB.  */\n \n static int\n-expr_killed_p (x, bb)\n-     rtx x;\n-     basic_block bb;\n+expr_killed_p (rtx x, basic_block bb)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -3162,9 +3063,8 @@ expr_killed_p (x, bb)\n /* Compute the set of available expressions killed in each basic block.  */\n \n static void\n-compute_ae_kill (ae_gen, ae_kill, expr_hash_table)\n-     sbitmap *ae_gen, *ae_kill;\n-     struct hash_table *expr_hash_table;\n+compute_ae_kill (sbitmap *ae_gen, sbitmap *ae_kill,\n+\t\t struct hash_table *expr_hash_table)\n {\n   basic_block bb;\n   unsigned int i;\n@@ -3202,12 +3102,8 @@ compute_ae_kill (ae_gen, ae_kill, expr_hash_table)\n    the closest such expression.  */\n \n static int\n-expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited)\n-     struct occr *occr;\n-     struct expr *expr;\n-     basic_block bb;\n-     int check_self_loop;\n-     char *visited;\n+expr_reaches_here_p_work (struct occr *occr, struct expr *expr,\n+\t\t\t  basic_block bb, int check_self_loop, char *visited)\n {\n   edge pred;\n \n@@ -3264,11 +3160,8 @@ expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited)\n    memory allocated for that function is returned.  */\n \n static int\n-expr_reaches_here_p (occr, expr, bb, check_self_loop)\n-     struct occr *occr;\n-     struct expr *expr;\n-     basic_block bb;\n-     int check_self_loop;\n+expr_reaches_here_p (struct occr *occr, struct expr *expr, basic_block bb,\n+\t\t     int check_self_loop)\n {\n   int rval;\n   char *visited = (char *) xcalloc (last_basic_block, 1);\n@@ -3285,9 +3178,7 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop)\n    Called only by handle_avail_expr.  */\n \n static rtx\n-computing_insn (expr, insn)\n-     struct expr *expr;\n-     rtx insn;\n+computing_insn (struct expr *expr, rtx insn)\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n@@ -3350,8 +3241,7 @@ computing_insn (expr, insn)\n    Only called by can_disregard_other_sets.  */\n \n static int\n-def_reaches_here_p (insn, def_insn)\n-     rtx insn, def_insn;\n+def_reaches_here_p (rtx insn, rtx def_insn)\n {\n   rtx reg;\n \n@@ -3387,10 +3277,7 @@ def_reaches_here_p (insn, def_insn)\n    always safe to return zero.  */\n \n static int\n-can_disregard_other_sets (addr_this_reg, insn, for_combine)\n-     struct reg_set **addr_this_reg;\n-     rtx insn;\n-     int for_combine;\n+can_disregard_other_sets (struct reg_set **addr_this_reg, rtx insn, int for_combine)\n {\n   int number_of_reaching_defs = 0;\n   struct reg_set *this_reg;\n@@ -3435,9 +3322,7 @@ can_disregard_other_sets (addr_this_reg, insn, for_combine)\n    The result is nonzero if any changes were made.  */\n \n static int\n-handle_avail_expr (insn, expr)\n-     rtx insn;\n-     struct expr *expr;\n+handle_avail_expr (rtx insn, struct expr *expr)\n {\n   rtx pat, insn_computes_expr, expr_set;\n   rtx to;\n@@ -3593,7 +3478,7 @@ handle_avail_expr (insn, expr)\n    The result is nonzero if a change was made.  */\n \n static int\n-classic_gcse ()\n+classic_gcse (void)\n {\n   int changed;\n   rtx insn;\n@@ -3652,8 +3537,7 @@ classic_gcse ()\n    Return nonzero if a change was made.  */\n \n static int\n-one_classic_gcse_pass (pass)\n-     int pass;\n+one_classic_gcse_pass (int pass)\n {\n   int changed = 0;\n \n@@ -3706,8 +3590,7 @@ static sbitmap *cprop_avout;\n    basic blocks.  N_SETS is the number of sets.  */\n \n static void\n-alloc_cprop_mem (n_blocks, n_sets)\n-     int n_blocks, n_sets;\n+alloc_cprop_mem (int n_blocks, int n_sets)\n {\n   cprop_pavloc = sbitmap_vector_alloc (n_blocks, n_sets);\n   cprop_absaltered = sbitmap_vector_alloc (n_blocks, n_sets);\n@@ -3719,7 +3602,7 @@ alloc_cprop_mem (n_blocks, n_sets)\n /* Free vars used by copy/const propagation.  */\n \n static void\n-free_cprop_mem ()\n+free_cprop_mem (void)\n {\n   sbitmap_vector_free (cprop_pavloc);\n   sbitmap_vector_free (cprop_absaltered);\n@@ -3734,11 +3617,7 @@ free_cprop_mem ()\n    bit in BMAP.  */\n \n static void\n-compute_transp (x, indx, bmap, set_p)\n-     rtx x;\n-     int indx;\n-     sbitmap *bmap;\n-     int set_p;\n+compute_transp (rtx x, int indx, sbitmap *bmap, int set_p)\n {\n   int i, j;\n   basic_block bb;\n@@ -3869,7 +3748,7 @@ compute_transp (x, indx, bmap, set_p)\n    propagation.  */\n \n static void\n-compute_cprop_data ()\n+compute_cprop_data (void)\n {\n   compute_local_properties (cprop_absaltered, cprop_pavloc, NULL, &set_hash_table);\n   compute_available (cprop_pavloc, cprop_absaltered,\n@@ -3896,9 +3775,7 @@ static int reg_use_count;\n    This doesn't hurt anything but it will slow things down.  */\n \n static void\n-find_used_regs (xptr, data)\n-     rtx *xptr;\n-     void *data ATTRIBUTE_UNUSED;\n+find_used_regs (rtx *xptr, void *data ATTRIBUTE_UNUSED)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -3948,8 +3825,7 @@ find_used_regs (xptr, data)\n    Returns nonzero is successful.  */\n \n static int\n-try_replace_reg (from, to, insn)\n-     rtx from, to, insn;\n+try_replace_reg (rtx from, rtx to, rtx insn)\n {\n   rtx note = find_reg_equal_equiv_note (insn);\n   rtx src = 0;\n@@ -4005,9 +3881,7 @@ try_replace_reg (from, to, insn)\n    NULL no such set is found.  */\n \n static struct expr *\n-find_avail_set (regno, insn)\n-     int regno;\n-     rtx insn;\n+find_avail_set (int regno, rtx insn)\n {\n   /* SET1 contains the last set found that can be returned to the caller for\n      use in a substitution.  */\n@@ -4079,12 +3953,7 @@ find_avail_set (regno, insn)\n    if a change was made.  */\n \n static int\n-cprop_jump (bb, setcc, jump, from, src)\n-     basic_block bb;\n-     rtx setcc;\n-     rtx jump;\n-     rtx from;\n-     rtx src;\n+cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n {\n   rtx new, set_src, note_src;\n   rtx set = pc_set (jump);\n@@ -4183,11 +4052,7 @@ cprop_jump (bb, setcc, jump, from, src)\n }\n \n static bool\n-constprop_register (insn, from, to, alter_jumps)\n-     rtx insn;\n-     rtx from;\n-     rtx to;\n-     int alter_jumps;\n+constprop_register (rtx insn, rtx from, rtx to, int alter_jumps)\n {\n   rtx sset;\n \n@@ -4224,9 +4089,7 @@ constprop_register (insn, from, to, alter_jumps)\n    The result is nonzero if a change was made.  */\n \n static int\n-cprop_insn (insn, alter_jumps)\n-     rtx insn;\n-     int alter_jumps;\n+cprop_insn (rtx insn, int alter_jumps)\n {\n   struct reg_use *reg_used;\n   int changed = 0;\n@@ -4325,9 +4188,7 @@ cprop_insn (insn, alter_jumps)\n    can legitimately make replacements.  */\n \n static void\n-local_cprop_find_used_regs (xptr, data)\n-     rtx *xptr;\n-     void *data;\n+local_cprop_find_used_regs (rtx *xptr, void *data)\n {\n   rtx x = *xptr;\n \n@@ -4365,16 +4226,12 @@ local_cprop_find_used_regs (xptr, data)\n \n   find_used_regs (xptr, data);\n }\n-  \n+\n /* LIBCALL_SP is a zero-terminated array of insns at the end of a libcall;\n    their REG_EQUAL notes need updating.  */\n \n static bool\n-do_local_cprop (x, insn, alter_jumps, libcall_sp)\n-     rtx x;\n-     rtx insn;\n-     int alter_jumps;\n-     rtx *libcall_sp;\n+do_local_cprop (rtx x, rtx insn, int alter_jumps, rtx *libcall_sp)\n {\n   rtx newreg = NULL, newcnst = NULL;\n \n@@ -4453,8 +4310,7 @@ do_local_cprop (x, insn, alter_jumps, libcall_sp)\n    replaced with NEWVAL in INSN.  Return true if all substitutions could\n    be made.  */\n static bool\n-adjust_libcall_notes (oldreg, newval, insn, libcall_sp)\n-     rtx oldreg, newval, insn, *libcall_sp;\n+adjust_libcall_notes (rtx oldreg, rtx newval, rtx insn, rtx *libcall_sp)\n {\n   rtx end;\n \n@@ -4490,8 +4346,7 @@ adjust_libcall_notes (oldreg, newval, insn, libcall_sp)\n #define MAX_NESTED_LIBCALLS 9\n \n static void\n-local_cprop_pass (alter_jumps)\n-     int alter_jumps;\n+local_cprop_pass (int alter_jumps)\n {\n   rtx insn;\n   struct reg_use *reg_used;\n@@ -4554,8 +4409,7 @@ local_cprop_pass (alter_jumps)\n    nonzero if a change was made.  */\n \n static int\n-cprop (alter_jumps)\n-     int alter_jumps;\n+cprop (int alter_jumps)\n {\n   int changed;\n   basic_block bb;\n@@ -4608,8 +4462,7 @@ cprop (alter_jumps)\n    but this would require some code reorganization.  */\n \n rtx\n-fis_get_condition (jump)\n-     rtx jump;\n+fis_get_condition (rtx jump)\n {\n   rtx cond, set, tmp, insn, earliest;\n   bool reverse;\n@@ -4665,7 +4518,7 @@ fis_get_condition (jump)\n    basic block.  */\n \n static void\n-find_implicit_sets ()\n+find_implicit_sets (void)\n {\n   basic_block bb, dest;\n   unsigned int count;\n@@ -4714,10 +4567,7 @@ find_implicit_sets ()\n    perform conditional jump bypassing optimizations.  */\n \n static int\n-one_cprop_pass (pass, cprop_jumps, bypass_jumps)\n-     int pass;\n-     int cprop_jumps;\n-     int bypass_jumps;\n+one_cprop_pass (int pass, int cprop_jumps, int bypass_jumps)\n {\n   int changed = 0;\n \n@@ -4779,9 +4629,7 @@ static int bypass_last_basic_block;\n    find_avail_set.  */\n \n static struct expr *\n-find_bypass_set (regno, bb)\n-     int regno;\n-     int bb;\n+find_bypass_set (int regno, int bb)\n {\n   struct expr *result = 0;\n \n@@ -4823,9 +4671,7 @@ find_bypass_set (regno, bb)\n    valid prior to commit_edge_insertions.  */\n \n static bool\n-reg_killed_on_edge (reg, e)\n-     rtx reg;\n-     edge e;\n+reg_killed_on_edge (rtx reg, edge e)\n {\n   rtx insn;\n \n@@ -4847,9 +4693,7 @@ reg_killed_on_edge (reg, e)\n    these inserted insns when performing its transformations.  */\n \n static int\n-bypass_block (bb, setcc, jump)\n-     basic_block bb;\n-     rtx setcc, jump;\n+bypass_block (basic_block bb, rtx setcc, rtx jump)\n {\n   rtx insn, note;\n   edge e, enext, edest;\n@@ -4921,7 +4765,7 @@ bypass_block (bb, setcc, jump)\n \t  new = simplify_replace_rtx (src, reg_used->reg_rtx,\n \t\t\t\t      SET_SRC (set->expr));\n \n-\t  /* Jump bypassing may have already placed instructions on \n+\t  /* Jump bypassing may have already placed instructions on\n \t     edges of the CFG.  We can't bypass an outgoing edge that\n \t     has instructions associated with it, as these insns won't\n \t     get executed if the incoming edge is redirected.  */\n@@ -4985,7 +4829,7 @@ bypass_block (bb, setcc, jump)\n    This function is now mis-named, because we also handle indirect jumps.  */\n \n static int\n-bypass_conditional_jumps ()\n+bypass_conditional_jumps (void)\n {\n   basic_block bb;\n   int changed;\n@@ -5083,8 +4927,7 @@ static sbitmap pre_redundant_insns;\n /* Allocate vars used for PRE analysis.  */\n \n static void\n-alloc_pre_mem (n_blocks, n_exprs)\n-     int n_blocks, n_exprs;\n+alloc_pre_mem (int n_blocks, int n_exprs)\n {\n   transp = sbitmap_vector_alloc (n_blocks, n_exprs);\n   comp = sbitmap_vector_alloc (n_blocks, n_exprs);\n@@ -5104,7 +4947,7 @@ alloc_pre_mem (n_blocks, n_exprs)\n /* Free vars used for PRE analysis.  */\n \n static void\n-free_pre_mem ()\n+free_pre_mem (void)\n {\n   sbitmap_vector_free (transp);\n   sbitmap_vector_free (comp);\n@@ -5132,7 +4975,7 @@ free_pre_mem ()\n /* Top level routine to do the dataflow analysis needed by PRE.  */\n \n static void\n-compute_pre_data ()\n+compute_pre_data (void)\n {\n   sbitmap trapping_expr;\n   basic_block bb;\n@@ -5203,11 +5046,7 @@ compute_pre_data ()\n    the closest such expression.  */\n \n static int\n-pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited)\n-     basic_block occr_bb;\n-     struct expr *expr;\n-     basic_block bb;\n-     char *visited;\n+pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr, basic_block bb, char *visited)\n {\n   edge pred;\n \n@@ -5252,10 +5091,7 @@ pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited)\n    memory allocated for that function is returned.  */\n \n static int\n-pre_expr_reaches_here_p (occr_bb, expr, bb)\n-     basic_block occr_bb;\n-     struct expr *expr;\n-     basic_block bb;\n+pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n {\n   int rval;\n   char *visited = (char *) xcalloc (last_basic_block, 1);\n@@ -5272,8 +5108,7 @@ pre_expr_reaches_here_p (occr_bb, expr, bb)\n    the value of BB.  */\n \n static rtx\n-process_insert_insn (expr)\n-     struct expr *expr;\n+process_insert_insn (struct expr *expr)\n {\n   rtx reg = expr->reaching_reg;\n   rtx exp = copy_rtx (expr->expr);\n@@ -5307,10 +5142,7 @@ process_insert_insn (expr)\n    no sense for code hoisting.  */\n \n static void\n-insert_insn_end_bb (expr, bb, pre)\n-     struct expr *expr;\n-     basic_block bb;\n-     int pre;\n+insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n {\n   rtx insn = bb->end;\n   rtx new_insn;\n@@ -5439,9 +5271,7 @@ insert_insn_end_bb (expr, bb, pre)\n    the expressions fully redundant.  */\n \n static int\n-pre_edge_insert (edge_list, index_map)\n-     struct edge_list *edge_list;\n-     struct expr **index_map;\n+pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n {\n   int e, i, j, num_edges, set_size, did_insert = 0;\n   sbitmap *inserted;\n@@ -5523,9 +5353,7 @@ pre_edge_insert (edge_list, index_map)\n /* Copy the result of INSN to REG.  INDX is the expression number.  */\n \n static void\n-pre_insert_copy_insn (expr, insn)\n-     struct expr *expr;\n-     rtx insn;\n+pre_insert_copy_insn (struct expr *expr, rtx insn)\n {\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n@@ -5555,7 +5383,7 @@ pre_insert_copy_insn (expr, insn)\n    to `reaching_reg'.  */\n \n static void\n-pre_insert_copies ()\n+pre_insert_copies (void)\n {\n   unsigned int i;\n   struct expr *expr;\n@@ -5613,8 +5441,7 @@ pre_insert_copies ()\n /* Emit move from SRC to DEST noting the equivalence with expression computed\n    in INSN.  */\n static rtx\n-gcse_emit_move_after (src, dest, insn)\n-     rtx src, dest, insn;\n+gcse_emit_move_after (rtx src, rtx dest, rtx insn)\n {\n   rtx new;\n   rtx set = single_set (insn), set2;\n@@ -5648,7 +5475,7 @@ gcse_emit_move_after (src, dest, insn)\n    Returns nonzero if a change is made.  */\n \n static int\n-pre_delete ()\n+pre_delete (void)\n {\n   unsigned int i;\n   int changed;\n@@ -5726,7 +5553,7 @@ pre_delete ()\n    redundancies.  */\n \n static int\n-pre_gcse ()\n+pre_gcse (void)\n {\n   unsigned int i;\n   int did_insert, changed;\n@@ -5773,8 +5600,7 @@ pre_gcse ()\n    Return nonzero if a change was made.  */\n \n static int\n-one_pre_gcse_pass (pass)\n-     int pass;\n+one_pre_gcse_pass (int pass)\n {\n   int changed = 0;\n \n@@ -5828,9 +5654,7 @@ one_pre_gcse_pass (pass)\n    necessary REG_LABEL notes.  */\n \n static void\n-add_label_notes (x, insn)\n-     rtx x;\n-     rtx insn;\n+add_label_notes (rtx x, rtx insn)\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -5875,7 +5699,7 @@ add_label_notes (x, insn)\n    EH table sizes, this may not be worthwhile.  */\n \n static void\n-compute_transpout ()\n+compute_transpout (void)\n {\n   basic_block bb;\n   unsigned int i;\n@@ -5916,10 +5740,7 @@ compute_transpout ()\n    We ignore hard registers.  */\n \n static void\n-invalidate_nonnull_info (x, setter, data)\n-     rtx x;\n-     rtx setter ATTRIBUTE_UNUSED;\n-     void *data;\n+invalidate_nonnull_info (rtx x, rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n   unsigned int regno;\n   struct null_pointer_info *npi = (struct null_pointer_info *) data;\n@@ -5944,12 +5765,9 @@ invalidate_nonnull_info (x, setter, data)\n    they are not our responsibility to free.  */\n \n static int\n-delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n-\t\t\t      nonnull_avout, npi)\n-     unsigned int *block_reg;\n-     sbitmap *nonnull_avin;\n-     sbitmap *nonnull_avout;\n-     struct null_pointer_info *npi;\n+delete_null_pointer_checks_1 (unsigned int *block_reg, sbitmap *nonnull_avin,\n+\t\t\t      sbitmap *nonnull_avout,\n+\t\t\t      struct null_pointer_info *npi)\n {\n   basic_block bb, current_block;\n   sbitmap *nonnull_local = npi->nonnull_local;\n@@ -6116,8 +5934,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n    This could probably be integrated with global cprop with a little work.  */\n \n int\n-delete_null_pointer_checks (f)\n-     rtx f ATTRIBUTE_UNUSED;\n+delete_null_pointer_checks (rtx f ATTRIBUTE_UNUSED)\n {\n   sbitmap *nonnull_avin, *nonnull_avout;\n   unsigned int *block_reg;\n@@ -6234,8 +6051,7 @@ dominance_info dominators;\n /* Allocate vars used for code hoisting analysis.  */\n \n static void\n-alloc_code_hoist_mem (n_blocks, n_exprs)\n-     int n_blocks, n_exprs;\n+alloc_code_hoist_mem (int n_blocks, int n_exprs)\n {\n   antloc = sbitmap_vector_alloc (n_blocks, n_exprs);\n   transp = sbitmap_vector_alloc (n_blocks, n_exprs);\n@@ -6250,7 +6066,7 @@ alloc_code_hoist_mem (n_blocks, n_exprs)\n /* Free vars used for code hoisting analysis.  */\n \n static void\n-free_code_hoist_mem ()\n+free_code_hoist_mem (void)\n {\n   sbitmap_vector_free (antloc);\n   sbitmap_vector_free (transp);\n@@ -6270,7 +6086,7 @@ free_code_hoist_mem ()\n    compute the expression.  */\n \n static void\n-compute_code_hoist_vbeinout ()\n+compute_code_hoist_vbeinout (void)\n {\n   int changed, passes;\n   basic_block bb;\n@@ -6305,7 +6121,7 @@ compute_code_hoist_vbeinout ()\n /* Top level routine to do the dataflow analysis needed by code hoisting.  */\n \n static void\n-compute_code_hoist_data ()\n+compute_code_hoist_data (void)\n {\n   compute_local_properties (transp, comp, antloc, &expr_hash_table);\n   compute_transpout ();\n@@ -6329,11 +6145,7 @@ compute_code_hoist_data ()\n    paths.  */\n \n static int\n-hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n-     basic_block expr_bb;\n-     int expr_index;\n-     basic_block bb;\n-     char *visited;\n+hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb, char *visited)\n {\n   edge pred;\n   int visited_allocated_locally = 0;\n@@ -6380,7 +6192,7 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n /* Actually perform code hoisting.  */\n \n static void\n-hoist_code ()\n+hoist_code (void)\n {\n   basic_block bb, dominated;\n   basic_block *domby;\n@@ -6460,7 +6272,7 @@ hoist_code ()\n       /* If we found nothing to hoist, then quit now.  */\n       if (! found)\n         {\n-  \t  free (domby);\n+\t  free (domby);\n \tcontinue;\n \t}\n \n@@ -6546,7 +6358,7 @@ hoist_code ()\n    Return nonzero if a change was made.  */\n \n static int\n-one_code_hoisting_pass ()\n+one_code_hoisting_pass (void)\n {\n   int changed = 0;\n \n@@ -6597,8 +6409,7 @@ one_code_hoisting_pass ()\n    doesn't find one, we create one and initialize it.  */\n \n static struct ls_expr *\n-ldst_entry (x)\n-     rtx x;\n+ldst_entry (rtx x)\n {\n   struct ls_expr * ptr;\n \n@@ -6629,8 +6440,7 @@ ldst_entry (x)\n /* Free up an individual ldst entry.  */\n \n static void\n-free_ldst_entry (ptr)\n-     struct ls_expr * ptr;\n+free_ldst_entry (struct ls_expr * ptr)\n {\n   free_INSN_LIST_list (& ptr->loads);\n   free_INSN_LIST_list (& ptr->stores);\n@@ -6641,7 +6451,7 @@ free_ldst_entry (ptr)\n /* Free up all memory associated with the ldst list.  */\n \n static void\n-free_ldst_mems ()\n+free_ldst_mems (void)\n {\n   while (pre_ldst_mems)\n     {\n@@ -6658,8 +6468,7 @@ free_ldst_mems ()\n /* Dump debugging info about the ldst list.  */\n \n static void\n-print_ldst_list (file)\n-     FILE * file;\n+print_ldst_list (FILE * file)\n {\n   struct ls_expr * ptr;\n \n@@ -6694,8 +6503,7 @@ print_ldst_list (file)\n /* Returns 1 if X is in the list of ldst only expressions.  */\n \n static struct ls_expr *\n-find_rtx_in_ldst (x)\n-     rtx x;\n+find_rtx_in_ldst (rtx x)\n {\n   struct ls_expr * ptr;\n \n@@ -6709,7 +6517,7 @@ find_rtx_in_ldst (x)\n /* Assign each element of the list of mems a monotonically increasing value.  */\n \n static int\n-enumerate_ldsts ()\n+enumerate_ldsts (void)\n {\n   struct ls_expr * ptr;\n   int n = 0;\n@@ -6723,16 +6531,15 @@ enumerate_ldsts ()\n /* Return first item in the list.  */\n \n static inline struct ls_expr *\n-first_ls_expr ()\n+first_ls_expr (void)\n {\n   return pre_ldst_mems;\n }\n \n /* Return the next item in the list after the specified one.  */\n \n static inline struct ls_expr *\n-next_ls_expr (ptr)\n-     struct ls_expr * ptr;\n+next_ls_expr (struct ls_expr * ptr)\n {\n   return ptr->next;\n }\n@@ -6744,8 +6551,7 @@ next_ls_expr (ptr)\n    ld_motion list, otherwise we let the usual aliasing take care of it.  */\n \n static int\n-simple_mem (x)\n-     rtx x;\n+simple_mem (rtx x)\n {\n   if (GET_CODE (x) != MEM)\n     return 0;\n@@ -6784,8 +6590,7 @@ simple_mem (x)\n    fix it up.  */\n \n static void\n-invalidate_any_buried_refs (x)\n-     rtx x;\n+invalidate_any_buried_refs (rtx x)\n {\n   const char * fmt;\n   int i, j;\n@@ -6820,7 +6625,7 @@ invalidate_any_buried_refs (x)\n    later.  */\n \n static void\n-compute_ld_motion_mems ()\n+compute_ld_motion_mems (void)\n {\n   struct ls_expr * ptr;\n   basic_block bb;\n@@ -6885,7 +6690,7 @@ compute_ld_motion_mems ()\n    expression list for pre gcse.  */\n \n static void\n-trim_ld_motion_mems ()\n+trim_ld_motion_mems (void)\n {\n   struct ls_expr * last = NULL;\n   struct ls_expr * ptr = first_ls_expr ();\n@@ -6952,8 +6757,7 @@ trim_ld_motion_mems ()\n    correct value in the reaching register for the loads.  */\n \n static void\n-update_ld_motion_stores (expr)\n-     struct expr * expr;\n+update_ld_motion_stores (struct expr * expr)\n {\n   struct ls_expr * mem_ptr;\n \n@@ -7024,9 +6828,8 @@ static int num_stores;\n /* Checks to set if we need to mark a register set. Called from note_stores.  */\n \n static void\n-reg_set_info (dest, setter, data)\n-     rtx dest, setter ATTRIBUTE_UNUSED;\n-     void * data ATTRIBUTE_UNUSED;\n+reg_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n+\t      void *data ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n@@ -7037,38 +6840,33 @@ reg_set_info (dest, setter, data)\n \n /* Return zero if some of the registers in list X are killed\n    due to set of registers in bitmap REGS_SET.  */\n-  \n+\n static bool\n-store_ops_ok (x, regs_set)\n-     rtx x;\n-     int *regs_set;\n+store_ops_ok (rtx x, int *regs_set)\n {\n   rtx reg;\n \n   for (; x; x = XEXP (x, 1))\n     {\n       reg = XEXP (x, 0);\n       if (regs_set[REGNO(reg)])\n-\treturn false; \n+\treturn false;\n     }\n \n   return true;\n }\n \n /* Returns a list of registers mentioned in X.  */\n static rtx\n-extract_mentioned_regs (x)\n-     rtx x;\n+extract_mentioned_regs (rtx x)\n {\n   return extract_mentioned_regs_helper (x, NULL_RTX);\n }\n \n /* Helper for extract_mentioned_regs; ACCUM is used to accumulate used\n    registers.  */\n static rtx\n-extract_mentioned_regs_helper (x, accum)\n-     rtx x;\n-     rtx accum;\n+extract_mentioned_regs_helper (rtx x, rtx accum)\n {\n   int i;\n   enum rtx_code code;\n@@ -7149,7 +6947,7 @@ extract_mentioned_regs_helper (x, accum)\n    current insn, REGS_SET_AFTER is bitmap of registers set after (and\n    including) the insn in this basic block.  We must be passing through BB from\n    head to end, as we are using this fact to speed things up.\n-   \n+\n    The results are stored this way:\n \n    -- the first anticipatable expression is added into ANTIC_STORE_LIST\n@@ -7167,10 +6965,7 @@ extract_mentioned_regs_helper (x, accum)\n    */\n \n static void\n-find_moveable_store (insn, regs_set_before, regs_set_after)\n-     rtx insn;\n-     int *regs_set_before;\n-     int *regs_set_after;\n+find_moveable_store (rtx insn, int *regs_set_before, int *regs_set_after)\n {\n   struct ls_expr * ptr;\n   rtx dest, set, tmp;\n@@ -7195,7 +6990,7 @@ find_moveable_store (insn, regs_set_before, regs_set_after)\n      continue.  */\n   if (flag_non_call_exceptions && may_trap_p (dest))\n     return;\n-    \n+\n   ptr = ldst_entry (dest);\n   if (!ptr->pattern_regs)\n     ptr->pattern_regs = extract_mentioned_regs (dest);\n@@ -7255,11 +7050,11 @@ find_moveable_store (insn, regs_set_before, regs_set_after)\n   if (!check_available)\n     AVAIL_STORE_LIST (ptr) = alloc_INSN_LIST (insn, AVAIL_STORE_LIST (ptr));\n }\n-  \n+\n /* Find available and anticipatable stores.  */\n \n static int\n-compute_store_table ()\n+compute_store_table (void)\n {\n   int ret;\n   basic_block bb;\n@@ -7394,8 +7189,7 @@ compute_store_table ()\n /* Check to see if the load X is aliased with STORE_PATTERN.  */\n \n static bool\n-load_kills_store (x, store_pattern)\n-     rtx x, store_pattern;\n+load_kills_store (rtx x, rtx store_pattern)\n {\n   if (true_dependence (x, GET_MODE (x), store_pattern, rtx_addr_varies_p))\n     return true;\n@@ -7406,8 +7200,7 @@ load_kills_store (x, store_pattern)\n    STORE_PATTERN.  Return true if found.  */\n \n static bool\n-find_loads (x, store_pattern)\n-     rtx x, store_pattern;\n+find_loads (rtx x, rtx store_pattern)\n {\n   const char * fmt;\n   int i, j;\n@@ -7443,8 +7236,7 @@ find_loads (x, store_pattern)\n    Return true if it it does.  */\n \n static bool\n-store_killed_in_insn (x, x_regs, insn)\n-     rtx x, x_regs, insn;\n+store_killed_in_insn (rtx x, rtx x_regs, rtx insn)\n {\n   rtx reg, base;\n \n@@ -7493,16 +7285,13 @@ store_killed_in_insn (x, x_regs, insn)\n    is killed, return the last insn in that it occurs in FAIL_INSN.  */\n \n static bool\n-store_killed_after (x, x_regs, insn, bb, regs_set_after, fail_insn)\n-     rtx x, x_regs, insn;\n-     basic_block bb;\n-     int *regs_set_after;\n-     rtx *fail_insn;\n+store_killed_after (rtx x, rtx x_regs, rtx insn, basic_block bb,\n+\t\t    int *regs_set_after, rtx *fail_insn)\n {\n   rtx last = bb->end, act;\n \n   if (!store_ops_ok (x_regs, regs_set_after))\n-    { \n+    {\n       /* We do not know where it will happen.  */\n       if (fail_insn)\n \t*fail_insn = NULL_RTX;\n@@ -7520,15 +7309,13 @@ store_killed_after (x, x_regs, insn, bb, regs_set_after, fail_insn)\n \n   return false;\n }\n-  \n+\n /* Returns true if the expression X is loaded or clobbered on or before INSN\n    within basic block BB. X_REGS is list of registers mentioned in X.\n    REGS_SET_BEFORE is bitmap of registers set before or in this insn.  */\n static bool\n-store_killed_before (x, x_regs, insn, bb, regs_set_before)\n-     rtx x, x_regs, insn;\n-     basic_block bb;\n-     int *regs_set_before;\n+store_killed_before (rtx x, rtx x_regs, rtx insn, basic_block bb,\n+\t\t     int *regs_set_before)\n {\n   rtx first = bb->head;\n \n@@ -7541,11 +7328,11 @@ store_killed_before (x, x_regs, insn, bb, regs_set_before)\n \n   return false;\n }\n-  \n+\n /* Fill in available, anticipatable, transparent and kill vectors in\n    STORE_DATA, based on lists of available and anticipatable stores.  */\n static void\n-build_store_vectors ()\n+build_store_vectors (void)\n {\n   basic_block bb;\n   int *regs_set_in_block;\n@@ -7613,10 +7400,10 @@ build_store_vectors ()\n \t      if (!TEST_BIT (st_antloc[bb->index], ptr->index)\n \t\t  || !TEST_BIT (ae_gen[bb->index], ptr->index))\n \t\tSET_BIT (ae_kill[bb->index], ptr->index);\n-  \t    }\n-  \t  else\n-  \t    SET_BIT (transp[bb->index], ptr->index);\n-       \t}\n+\t    }\n+\t  else\n+\t    SET_BIT (transp[bb->index], ptr->index);\n+\t}\n     }\n \n   free (regs_set_in_block);\n@@ -7634,9 +7421,7 @@ build_store_vectors ()\n    the BLOCK_HEAD if needed.  */\n \n static void\n-insert_insn_start_bb (insn, bb)\n-     rtx insn;\n-     basic_block bb;\n+insert_insn_start_bb (rtx insn, basic_block bb)\n {\n   /* Insert at start of successor block.  */\n   rtx prev = PREV_INSN (bb->head);\n@@ -7669,9 +7454,7 @@ insert_insn_start_bb (insn, bb)\n    if an edge insertion was performed.  */\n \n static int\n-insert_store (expr, e)\n-     struct ls_expr * expr;\n-     edge e;\n+insert_store (struct ls_expr * expr, edge e)\n {\n   rtx reg, insn;\n   basic_block bb;\n@@ -7735,9 +7518,7 @@ insert_store (expr, e)\n /* This routine will replace a store with a SET to a specified register.  */\n \n static void\n-replace_store_insn (reg, del, bb)\n-     rtx reg, del;\n-     basic_block bb;\n+replace_store_insn (rtx reg, rtx del, basic_block bb)\n {\n   rtx insn;\n \n@@ -7762,9 +7543,7 @@ replace_store_insn (reg, del, bb)\n    the reaching_reg for later storing.  */\n \n static void\n-delete_store (expr, bb)\n-     struct ls_expr * expr;\n-     basic_block bb;\n+delete_store (struct ls_expr * expr, basic_block bb)\n {\n   rtx reg, i, del;\n \n@@ -7789,7 +7568,7 @@ delete_store (expr, bb)\n /* Free memory used by store motion.  */\n \n static void\n-free_store_memory ()\n+free_store_memory (void)\n {\n   free_ldst_mems ();\n \n@@ -7816,7 +7595,7 @@ free_store_memory ()\n    other way by looking at the flowgraph in reverse.  */\n \n static void\n-store_motion ()\n+store_motion (void)\n {\n   basic_block bb;\n   int x;\n@@ -7873,8 +7652,7 @@ store_motion ()\n /* Entry point for jump bypassing optimization pass.  */\n \n int\n-bypass_jumps (file)\n-     FILE *file;\n+bypass_jumps (FILE *file)\n {\n   int changed;\n "}, {"sha": "b1391a80457b26aa960cece0f87b9022d8408d77", "filename": "gcc/ggc.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -219,8 +219,7 @@ extern void ggc_splay_dont_free (void *, void *);\n /* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n    If LENGTH is -1, then CONTENTS is assumed to be a\n    null-terminated string and the memory sized accordingly.  */\n-extern const char *ggc_alloc_string\tPARAMS ((const char *contents,\n-\t\t\t\t\t\t int length));\n+extern const char *ggc_alloc_string (const char *contents, int length);\n \n /* Make a copy of S, in GC-able memory.  */\n #define ggc_strdup(S) ggc_alloc_string((S), -1)"}, {"sha": "0573eeb285f2a62c18faba80372ac40418890f42", "filename": "gcc/global.c", "status": "modified", "additions": 47, "deletions": 80, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,6 +1,6 @@\n /* Allocate registers for pseudo-registers that span basic blocks.\n    Copyright (C) 1987, 1988, 1991, 1994, 1996, 1997, 1998,\n-   1999, 2000, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -289,24 +289,23 @@ static int n_regs_set;\n \n static HARD_REG_SET eliminable_regset;\n \n-static int allocno_compare\tPARAMS ((const void *, const void *));\n-static void global_conflicts\tPARAMS ((void));\n-static void mirror_conflicts\tPARAMS ((void));\n-static void expand_preferences\tPARAMS ((void));\n-static void prune_preferences\tPARAMS ((void));\n-static void find_reg\t\tPARAMS ((int, HARD_REG_SET, int, int, int));\n-static void record_one_conflict PARAMS ((int));\n-static void record_conflicts\tPARAMS ((int *, int));\n-static void mark_reg_store\tPARAMS ((rtx, rtx, void *));\n-static void mark_reg_clobber\tPARAMS ((rtx, rtx, void *));\n-static void mark_reg_conflicts\tPARAMS ((rtx));\n-static void mark_reg_death\tPARAMS ((rtx));\n-static void mark_reg_live_nc\tPARAMS ((int, enum machine_mode));\n-static void set_preference\tPARAMS ((rtx, rtx));\n-static void dump_conflicts\tPARAMS ((FILE *));\n-static void reg_becomes_live\tPARAMS ((rtx, rtx, void *));\n-static void reg_dies\t\tPARAMS ((int, enum machine_mode,\n-\t\t\t\t       struct insn_chain *));\n+static int allocno_compare (const void *, const void *);\n+static void global_conflicts (void);\n+static void mirror_conflicts (void);\n+static void expand_preferences (void);\n+static void prune_preferences (void);\n+static void find_reg (int, HARD_REG_SET, int, int, int);\n+static void record_one_conflict (int);\n+static void record_conflicts (int *, int);\n+static void mark_reg_store (rtx, rtx, void *);\n+static void mark_reg_clobber (rtx, rtx, void *);\n+static void mark_reg_conflicts (rtx);\n+static void mark_reg_death (rtx);\n+static void mark_reg_live_nc (int, enum machine_mode);\n+static void set_preference (rtx, rtx);\n+static void dump_conflicts (FILE *);\n+static void reg_becomes_live (rtx, rtx, void *);\n+static void reg_dies (int, enum machine_mode, struct insn_chain *);\n \f\n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n    FILE is a file to output debugging information on,\n@@ -316,8 +315,7 @@ static void reg_dies\t\tPARAMS ((int, enum machine_mode,\n    and we must not do any more for this function.  */\n \n int\n-global_alloc (file)\n-     FILE *file;\n+global_alloc (FILE *file)\n {\n   int retval;\n #ifdef ELIMINABLE_REGS\n@@ -599,9 +597,7 @@ global_alloc (file)\n    Returns -1 (1) if *v1 should be allocated before (after) *v2.  */\n \n static int\n-allocno_compare (v1p, v2p)\n-     const void *v1p;\n-     const void *v2p;\n+allocno_compare (const void *v1p, const void *v2p)\n {\n   int v1 = *(const int *)v1p, v2 = *(const int *)v2p;\n   /* Note that the quotient will never be bigger than\n@@ -629,7 +625,7 @@ allocno_compare (v1p, v2p)\n    conflict matrices and preference tables.  */\n \n static void\n-global_conflicts ()\n+global_conflicts (void)\n {\n   int i;\n   basic_block b;\n@@ -703,11 +699,11 @@ global_conflicts ()\n \t    scan the instruction that makes either X or Y become live.  */\n \trecord_conflicts (block_start_allocnos, ax);\n \n- \t/* Pseudos can't go in stack regs at the start of a basic block that\n- \t   is reached by an abnormal edge. Likewise for call clobbered regs,\n- \t   because because caller-save, fixup_abnormal_edges, and possibly\n- \t   the table driven EH machinery are not quite ready to handle such\n- \t   regs live across such edges.  */\n+\t/* Pseudos can't go in stack regs at the start of a basic block that\n+\t   is reached by an abnormal edge. Likewise for call clobbered regs,\n+\t   because because caller-save, fixup_abnormal_edges, and possibly\n+\t   the table driven EH machinery are not quite ready to handle such\n+\t   regs live across such edges.  */\n \t{\n \t  edge e;\n \n@@ -852,7 +848,7 @@ global_conflicts ()\n    merge any preferences between those allocnos.  */\n \n static void\n-expand_preferences ()\n+expand_preferences (void)\n {\n   rtx insn;\n   rtx link;\n@@ -903,7 +899,7 @@ expand_preferences ()\n    we will avoid using these registers.  */\n \n static void\n-prune_preferences ()\n+prune_preferences (void)\n {\n   int i;\n   int num;\n@@ -991,12 +987,7 @@ prune_preferences ()\n    If not, do nothing.  */\n \n static void\n-find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n-     int num;\n-     HARD_REG_SET losers;\n-     int alt_regs_p;\n-     int accept_call_clobbered;\n-     int retrying;\n+find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbered, int retrying)\n {\n   int i, best_reg, pass;\n   HARD_REG_SET used, used1, used2;\n@@ -1110,7 +1101,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n \t\t    && (REGNO_REG_CLASS (j)\n-\t\t    \t== REGNO_REG_CLASS (best_reg + (j - i))\n+\t\t\t== REGNO_REG_CLASS (best_reg + (j - i))\n \t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (j),\n \t\t\t\t\t       REGNO_REG_CLASS (best_reg + (j - i)))\n \t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg + (j - i)),\n@@ -1149,7 +1140,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n \t\t    && (REGNO_REG_CLASS (j)\n-\t\t    \t== REGNO_REG_CLASS (best_reg + (j - i))\n+\t\t\t== REGNO_REG_CLASS (best_reg + (j - i))\n \t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (j),\n \t\t\t\t\t       REGNO_REG_CLASS (best_reg + (j - i)))\n \t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg + (j - i)),\n@@ -1311,9 +1302,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n    If FORBIDDEN_REGS is zero, no regs are forbidden.  */\n \n void\n-retry_global_alloc (regno, forbidden_regs)\n-     int regno;\n-     HARD_REG_SET forbidden_regs;\n+retry_global_alloc (int regno, HARD_REG_SET forbidden_regs)\n {\n   int alloc_no = reg_allocno[regno];\n   if (alloc_no >= 0)\n@@ -1344,8 +1333,7 @@ retry_global_alloc (regno, forbidden_regs)\n    reg_renumber before calling here.  */\n \n static void\n-record_one_conflict (regno)\n-     int regno;\n+record_one_conflict (int regno)\n {\n   int j;\n \n@@ -1388,9 +1376,7 @@ record_one_conflict (regno)\n    are currently live.  Their bits are also flagged in allocnos_live.  */\n \n static void\n-record_conflicts (allocno_vec, len)\n-     int *allocno_vec;\n-     int len;\n+record_conflicts (int *allocno_vec, int len)\n {\n   while (--len >= 0)\n     IOR_HARD_REG_SET (allocno[allocno_vec[len]].hard_reg_conflicts,\n@@ -1399,7 +1385,7 @@ record_conflicts (allocno_vec, len)\n \n /* If CONFLICTP (i, j) is true, make sure CONFLICTP (j, i) is also true.  */\n static void\n-mirror_conflicts ()\n+mirror_conflicts (void)\n {\n   int i, j;\n   int rw = allocno_row_words;\n@@ -1447,9 +1433,7 @@ mirror_conflicts ()\n    a REG_INC note was found for it).  */\n \n static void\n-mark_reg_store (reg, setter, data)\n-     rtx reg, setter;\n-     void *data ATTRIBUTE_UNUSED;\n+mark_reg_store (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n {\n   int regno;\n \n@@ -1496,9 +1480,7 @@ mark_reg_store (reg, setter, data)\n /* Like mark_reg_set except notice just CLOBBERs; ignore SETs.  */\n \n static void\n-mark_reg_clobber (reg, setter, data)\n-     rtx reg, setter;\n-     void *data ATTRIBUTE_UNUSED;\n+mark_reg_clobber (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (setter) == CLOBBER)\n     mark_reg_store (reg, setter, data);\n@@ -1508,8 +1490,7 @@ mark_reg_clobber (reg, setter, data)\n    Do not mark REG itself as live.  */\n \n static void\n-mark_reg_conflicts (reg)\n-     rtx reg;\n+mark_reg_conflicts (rtx reg)\n {\n   int regno;\n \n@@ -1548,8 +1529,7 @@ mark_reg_conflicts (reg)\n    Store a 0 in regs_live or allocnos_live for this register.  */\n \n static void\n-mark_reg_death (reg)\n-     rtx reg;\n+mark_reg_death (rtx reg)\n {\n   int regno = REGNO (reg);\n \n@@ -1585,9 +1565,7 @@ mark_reg_death (reg)\n    it is assumed that the caller will do that.  */\n \n static void\n-mark_reg_live_nc (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n+mark_reg_live_nc (int regno, enum machine_mode mode)\n {\n   int last = regno + HARD_REGNO_NREGS (regno, mode);\n   while (regno < last)\n@@ -1607,8 +1585,7 @@ mark_reg_live_nc (regno, mode)\n    pseudo-register to a hard register.  */\n \n static void\n-set_preference (dest, src)\n-     rtx dest, src;\n+set_preference (rtx dest, rtx src)\n {\n   unsigned int src_regno, dest_regno;\n   /* Amount to add to the hard regno for SRC, or subtract from that for DEST,\n@@ -1715,8 +1692,7 @@ set_preference (dest, src)\n    a use of TO.  */\n \n void\n-mark_elimination (from, to)\n-     int from, to;\n+mark_elimination (int from, int to)\n {\n   basic_block bb;\n \n@@ -1738,10 +1714,7 @@ static regset live_relevant_regs;\n /* Record in live_relevant_regs and REGS_SET that register REG became live.\n    This is called via note_stores.  */\n static void\n-reg_becomes_live (reg, setter, regs_set)\n-     rtx reg;\n-     rtx setter ATTRIBUTE_UNUSED;\n-     void *regs_set;\n+reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *regs_set)\n {\n   int regno;\n \n@@ -1772,10 +1745,7 @@ reg_becomes_live (reg, setter, regs_set)\n \n /* Record in live_relevant_regs that register REGNO died.  */\n static void\n-reg_dies (regno, mode, chain)\n-     int regno;\n-     enum machine_mode mode;\n-     struct insn_chain *chain;\n+reg_dies (int regno, enum machine_mode mode, struct insn_chain *chain)\n {\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n@@ -1799,8 +1769,7 @@ reg_dies (regno, mode, chain)\n /* Walk the insns of the current function and build reload_insn_chain,\n    and record register life information.  */\n void\n-build_insn_chain (first)\n-     rtx first;\n+build_insn_chain (rtx first)\n {\n   struct insn_chain **p = &reload_insn_chain;\n   struct insn_chain *prev = 0;\n@@ -1905,8 +1874,7 @@ build_insn_chain (first)\n    showing the information on which the allocation decisions are based.  */\n \n static void\n-dump_conflicts (file)\n-     FILE *file;\n+dump_conflicts (FILE *file)\n {\n   int i;\n   int has_preferences;\n@@ -1963,8 +1931,7 @@ dump_conflicts (file)\n }\n \n void\n-dump_global_regs (file)\n-     FILE *file;\n+dump_global_regs (FILE *file)\n {\n   int i, j;\n "}, {"sha": "45788a7c3a4fe3cedcccbe6d758e0764953ff2b9", "filename": "gcc/graph.c", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for graphical representation.\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.\n \n This file is part of GCC.\n@@ -39,17 +39,16 @@ static const char *const graph_ext[] =\n   /* vcg */      \".vcg\",\n };\n \n-static void start_fct PARAMS ((FILE *));\n-static void start_bb PARAMS ((FILE *, int));\n-static void node_data PARAMS ((FILE *, rtx));\n-static void draw_edge PARAMS ((FILE *, int, int, int, int));\n-static void end_fct PARAMS ((FILE *));\n-static void end_bb PARAMS ((FILE *));\n+static void start_fct (FILE *);\n+static void start_bb (FILE *, int);\n+static void node_data (FILE *, rtx);\n+static void draw_edge (FILE *, int, int, int, int);\n+static void end_fct (FILE *);\n+static void end_bb (FILE *);\n \n /* Output text for new basic block.  */\n static void\n-start_fct (fp)\n-     FILE *fp;\n+start_fct (FILE *fp)\n {\n   switch (graph_dump_format)\n     {\n@@ -64,9 +63,7 @@ graph: { title: \\\"%s\\\"\\nfolding: 1\\nhidden: 2\\nnode: { title: \\\"%s.0\\\" }\\n\",\n }\n \n static void\n-start_bb (fp, bb)\n-     FILE *fp;\n-     int bb;\n+start_bb (FILE *fp, int bb)\n {\n   switch (graph_dump_format)\n     {\n@@ -105,9 +102,7 @@ label: \\\"basic block %d\",\n }\n \n static void\n-node_data (fp, tmp_rtx)\n-     FILE *fp;\n-     rtx tmp_rtx;\n+node_data (FILE *fp, rtx tmp_rtx)\n {\n   if (PREV_INSN (tmp_rtx) == 0)\n     {\n@@ -168,12 +163,7 @@ darkgrey\\n  shape: ellipse\" : \"white\",\n }\n \n static void\n-draw_edge (fp, from, to, bb_edge, class)\n-     FILE *fp;\n-     int from;\n-     int to;\n-     int bb_edge;\n-     int class;\n+draw_edge (FILE *fp, int from, int to, int bb_edge, int class)\n {\n   const char * color;\n   switch (graph_dump_format)\n@@ -200,8 +190,7 @@ draw_edge (fp, from, to, bb_edge, class)\n }\n \n static void\n-end_bb (fp)\n-     FILE *fp;\n+end_bb (FILE *fp)\n {\n   switch (graph_dump_format)\n     {\n@@ -214,8 +203,7 @@ end_bb (fp)\n }\n \n static void\n-end_fct (fp)\n-     FILE *fp;\n+end_fct (FILE *fp)\n {\n   switch (graph_dump_format)\n     {\n@@ -231,10 +219,7 @@ end_fct (fp)\n /* Like print_rtl, but also print out live information for the start of each\n    basic block.  */\n void\n-print_rtl_graph_with_bb (base, suffix, rtx_first)\n-     const char *base;\n-     const char *suffix;\n-     rtx rtx_first;\n+print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n {\n   rtx tmp_rtx;\n   size_t namelen = strlen (base);\n@@ -400,9 +385,7 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n /* Similar as clean_dump_file, but this time for graph output files.  */\n \n void\n-clean_graph_dump_file (base, suffix)\n-     const char *base;\n-     const char *suffix;\n+clean_graph_dump_file (const char *base, const char *suffix)\n {\n   size_t namelen = strlen (base);\n   size_t suffixlen = strlen (suffix);\n@@ -434,9 +417,7 @@ clean_graph_dump_file (base, suffix)\n \n /* Do final work on the graph output file.  */\n void\n-finish_graph_dump_file (base, suffix)\n-     const char *base;\n-     const char *suffix;\n+finish_graph_dump_file (const char *base, const char *suffix)\n {\n   size_t namelen = strlen (base);\n   size_t suffixlen = strlen (suffix);"}, {"sha": "e69f3361660ee09bdfd7de7bb7e13d46bd65cca1", "filename": "gcc/graph.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,5 +1,5 @@\n /* Header file for graph routines.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -21,8 +21,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_GRAPH_H\n #define GCC_GRAPH_H\n \n-extern void print_rtl_graph_with_bb PARAMS ((const char *, const char *, rtx));\n-extern void clean_graph_dump_file PARAMS ((const char *, const char *));\n-extern void finish_graph_dump_file PARAMS ((const char *, const char *));\n+extern void print_rtl_graph_with_bb (const char *, const char *, rtx);\n+extern void clean_graph_dump_file (const char *, const char *);\n+extern void finish_graph_dump_file (const char *, const char *);\n \n #endif /* ! GCC_GRAPH_H */"}, {"sha": "397c251e0397215dd78c880e92a7349849071e2f", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 113, "deletions": 180, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -189,8 +189,7 @@ static int old_max_uid;\n    of the -fsched-verbose=N option.  */\n \n void\n-fix_sched_param (param, val)\n-     const char *param, *val;\n+fix_sched_param (const char *param, const char *val)\n {\n   if (!strcmp (param, \"verbose\"))\n     sched_verbose_param = atoi (val);\n@@ -305,7 +304,7 @@ struct ready_list\n   int n_ready;\n };\n \n-static int may_trap_exp PARAMS ((rtx, int));\n+static int may_trap_exp (rtx, int);\n \n /* Nonzero iff the address is comprised from at most 1 register.  */\n #define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n@@ -319,9 +318,7 @@ static int may_trap_exp PARAMS ((rtx, int));\n    as found by analyzing insn's expression.  */\n \n static int\n-may_trap_exp (x, is_store)\n-     rtx x;\n-     int is_store;\n+may_trap_exp (rtx x, int is_store)\n {\n   enum rtx_code code;\n \n@@ -394,8 +391,7 @@ may_trap_exp (x, is_store)\n    being either PFREE or PRISKY.  */\n \n int\n-haifa_classify_insn (insn)\n-     rtx insn;\n+haifa_classify_insn (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   int tmp_class = TRAP_FREE;\n@@ -473,21 +469,21 @@ haifa_classify_insn (insn)\n \n /* The scheduler using only DFA description should never use the\n    following five functions:  */\n-static unsigned int blockage_range PARAMS ((int, rtx));\n-static void clear_units PARAMS ((void));\n-static void schedule_unit PARAMS ((int, rtx, int));\n-static int actual_hazard PARAMS ((int, rtx, int, int));\n-static int potential_hazard PARAMS ((int, rtx, int));\n-\n-static int priority PARAMS ((rtx));\n-static int rank_for_schedule PARAMS ((const void *, const void *));\n-static void swap_sort PARAMS ((rtx *, int));\n-static void queue_insn PARAMS ((rtx, int));\n-static int schedule_insn PARAMS ((rtx, struct ready_list *, int));\n-static int find_set_reg_weight PARAMS ((rtx));\n-static void find_insn_reg_weight PARAMS ((int));\n-static void adjust_priority PARAMS ((rtx));\n-static void advance_one_cycle PARAMS ((void));\n+static unsigned int blockage_range (int, rtx);\n+static void clear_units (void);\n+static void schedule_unit (int, rtx, int);\n+static int actual_hazard (int, rtx, int, int);\n+static int potential_hazard (int, rtx, int);\n+\n+static int priority (rtx);\n+static int rank_for_schedule (const void *, const void *);\n+static void swap_sort (rtx *, int);\n+static void queue_insn (rtx, int);\n+static int schedule_insn (rtx, struct ready_list *, int);\n+static int find_set_reg_weight (rtx);\n+static void find_insn_reg_weight (int);\n+static void adjust_priority (rtx);\n+static void advance_one_cycle (void);\n \n /* Notes handling mechanism:\n    =========================\n@@ -512,28 +508,28 @@ static void advance_one_cycle PARAMS ((void));\n    unlink_other_notes ()).  After scheduling the block, these notes are\n    inserted at the beginning of the block (in schedule_block()).  */\n \n-static rtx unlink_other_notes PARAMS ((rtx, rtx));\n-static rtx unlink_line_notes PARAMS ((rtx, rtx));\n-static rtx reemit_notes PARAMS ((rtx, rtx));\n+static rtx unlink_other_notes (rtx, rtx);\n+static rtx unlink_line_notes (rtx, rtx);\n+static rtx reemit_notes (rtx, rtx);\n \n-static rtx *ready_lastpos PARAMS ((struct ready_list *));\n-static void ready_sort PARAMS ((struct ready_list *));\n-static rtx ready_remove_first PARAMS ((struct ready_list *));\n+static rtx *ready_lastpos (struct ready_list *);\n+static void ready_sort (struct ready_list *);\n+static rtx ready_remove_first (struct ready_list *);\n \n-static void queue_to_ready PARAMS ((struct ready_list *));\n+static void queue_to_ready (struct ready_list *);\n \n-static void debug_ready_list PARAMS ((struct ready_list *));\n+static void debug_ready_list (struct ready_list *);\n \n-static rtx move_insn1 PARAMS ((rtx, rtx));\n-static rtx move_insn PARAMS ((rtx, rtx));\n+static rtx move_insn1 (rtx, rtx);\n+static rtx move_insn (rtx, rtx);\n \n /* The following functions are used to implement multi-pass scheduling\n    on the first cycle.  It is used only for DFA based scheduler.  */\n-static rtx ready_element PARAMS ((struct ready_list *, int));\n-static rtx ready_remove PARAMS ((struct ready_list *, int));\n-static int max_issue PARAMS ((struct ready_list *, int *));\n+static rtx ready_element (struct ready_list *, int);\n+static rtx ready_remove (struct ready_list *, int);\n+static int max_issue (struct ready_list *, int *);\n \n-static rtx choose_ready PARAMS ((struct ready_list *));\n+static rtx choose_ready (struct ready_list *);\n \n #endif /* INSN_SCHEDULING */\n \f\n@@ -542,8 +538,7 @@ struct sched_info *current_sched_info;\n \f\n #ifndef INSN_SCHEDULING\n void\n-schedule_insns (dump_file)\n-     FILE *dump_file ATTRIBUTE_UNUSED;\n+schedule_insns (FILE *dump_file ATTRIBUTE_UNUSED)\n {\n }\n #else\n@@ -562,8 +557,7 @@ static rtx last_scheduled_insn;\n    should never use the following function.  */\n \n HAIFA_INLINE int\n-insn_unit (insn)\n-     rtx insn;\n+insn_unit (rtx insn)\n {\n   int unit = INSN_UNIT (insn);\n \n@@ -601,9 +595,7 @@ insn_unit (insn)\n    function.  */\n \n HAIFA_INLINE static unsigned int\n-blockage_range (unit, insn)\n-     int unit;\n-     rtx insn;\n+blockage_range (int unit, rtx insn)\n {\n   unsigned int blockage = INSN_BLOCKAGE (insn);\n   unsigned int range;\n@@ -656,16 +648,15 @@ static int unit_n_insns[1];\n    following function.  */\n \n rtx\n-get_unit_last_insn (instance)\n-     int instance;\n+get_unit_last_insn (int instance)\n {\n   return unit_last_insn[instance];\n }\n \n /* Reset the function unit state to the null state.  */\n \n static void\n-clear_units ()\n+clear_units (void)\n {\n   memset ((char *) unit_last_insn, 0, sizeof (unit_last_insn));\n   memset ((char *) unit_tick, 0, sizeof (unit_tick));\n@@ -676,8 +667,7 @@ clear_units ()\n    description should never use the following function.  */\n \n HAIFA_INLINE int\n-insn_issue_delay (insn)\n-     rtx insn;\n+insn_issue_delay (rtx insn)\n {\n   int i, delay = 0;\n   int unit = insn_unit (insn);\n@@ -707,9 +697,7 @@ insn_issue_delay (insn)\n    use the following function.  */\n \n HAIFA_INLINE int\n-actual_hazard_this_instance (unit, instance, insn, clock, cost)\n-     int unit, instance, clock, cost;\n-     rtx insn;\n+actual_hazard_this_instance (int unit, int instance, rtx insn, int clock, int cost)\n {\n   int tick = unit_tick[instance]; /* Issue time of the last issued insn.  */\n \n@@ -745,9 +733,7 @@ actual_hazard_this_instance (unit, instance, insn, clock, cost)\n    never use the following function.  */\n \n HAIFA_INLINE static void\n-schedule_unit (unit, insn, clock)\n-     int unit, clock;\n-     rtx insn;\n+schedule_unit (int unit, rtx insn, int clock)\n {\n   int i;\n \n@@ -779,9 +765,7 @@ schedule_unit (unit, insn, clock)\n    use the following function.  */\n \n HAIFA_INLINE static int\n-actual_hazard (unit, insn, clock, cost)\n-     int unit, clock, cost;\n-     rtx insn;\n+actual_hazard (int unit, rtx insn, int clock, int cost)\n {\n   int i;\n \n@@ -830,9 +814,7 @@ actual_hazard (unit, insn, clock, cost)\n    the following function.  */\n \n HAIFA_INLINE static int\n-potential_hazard (unit, insn, cost)\n-     int unit, cost;\n-     rtx insn;\n+potential_hazard (int unit, rtx insn, int cost)\n {\n   int i, ncost;\n   unsigned int minb, maxb;\n@@ -875,8 +857,7 @@ potential_hazard (unit, insn, cost)\n    instruction results.  */\n \n HAIFA_INLINE int\n-insn_cost (insn, link, used)\n-     rtx insn, link, used;\n+insn_cost (rtx insn, rtx link, rtx used)\n {\n   int cost = INSN_COST (insn);\n \n@@ -898,10 +879,10 @@ insn_cost (insn, link, used)\n \t    cost = insn_default_latency (insn);\n \t  else\n \t    cost = result_ready_cost (insn);\n-\t  \n+\n \t  if (cost < 0)\n \t    cost = 0;\n-\t  \n+\n \t  INSN_COST (insn) = cost;\n \t}\n     }\n@@ -942,15 +923,14 @@ insn_cost (insn, link, used)\n       if (cost < 0)\n \tcost = 0;\n     }\n-  \n+\n   return cost;\n }\n \n /* Compute the priority number for INSN.  */\n \n static int\n-priority (insn)\n-     rtx insn;\n+priority (rtx insn)\n {\n   rtx link;\n \n@@ -1006,9 +986,7 @@ while (0)\n    unstable.  */\n \n static int\n-rank_for_schedule (x, y)\n-     const void *x;\n-     const void *y;\n+rank_for_schedule (const void *x, const void *y)\n {\n   rtx tmp = *(const rtx *) y;\n   rtx tmp2 = *(const rtx *) x;\n@@ -1087,9 +1065,7 @@ rank_for_schedule (x, y)\n /* Resort the array A in which only element at index N may be out of order.  */\n \n HAIFA_INLINE static void\n-swap_sort (a, n)\n-     rtx *a;\n-     int n;\n+swap_sort (rtx *a, int n)\n {\n   rtx insn = a[n - 1];\n   int i = n - 2;\n@@ -1107,9 +1083,7 @@ swap_sort (a, n)\n    chain for debugging purposes.  */\n \n HAIFA_INLINE static void\n-queue_insn (insn, n_cycles)\n-     rtx insn;\n-     int n_cycles;\n+queue_insn (rtx insn, int n_cycles)\n {\n   int next_q = NEXT_Q_AFTER (q_ptr, n_cycles);\n   rtx link = alloc_INSN_LIST (insn, insn_queue[next_q]);\n@@ -1129,8 +1103,7 @@ queue_insn (insn, n_cycles)\n    with the lowest priority.  */\n \n HAIFA_INLINE static rtx *\n-ready_lastpos (ready)\n-     struct ready_list *ready;\n+ready_lastpos (struct ready_list *ready)\n {\n   if (ready->n_ready == 0)\n     abort ();\n@@ -1141,9 +1114,7 @@ ready_lastpos (ready)\n    priority.  */\n \n HAIFA_INLINE void\n-ready_add (ready, insn)\n-     struct ready_list *ready;\n-     rtx insn;\n+ready_add (struct ready_list *ready, rtx insn)\n {\n   if (ready->first == ready->n_ready)\n     {\n@@ -1160,8 +1131,7 @@ ready_add (ready, insn)\n    return it.  */\n \n HAIFA_INLINE static rtx\n-ready_remove_first (ready)\n-     struct ready_list *ready;\n+ready_remove_first (struct ready_list *ready)\n {\n   rtx t;\n   if (ready->n_ready == 0)\n@@ -1183,9 +1153,7 @@ ready_remove_first (ready)\n    N_READY - 1.  */\n \n HAIFA_INLINE static rtx\n-ready_element (ready, index)\n-     struct ready_list *ready;\n-     int index;\n+ready_element (struct ready_list *ready, int index)\n {\n #ifdef ENABLE_CHECKING\n   if (ready->n_ready == 0 || index >= ready->n_ready)\n@@ -1199,9 +1167,7 @@ ready_element (ready, index)\n    has N_READY - 1.  */\n \n HAIFA_INLINE static rtx\n-ready_remove (ready, index)\n-     struct ready_list *ready;\n-     int index;\n+ready_remove (struct ready_list *ready, int index)\n {\n   rtx t;\n   int i;\n@@ -1222,8 +1188,7 @@ ready_remove (ready, index)\n    macro.  */\n \n HAIFA_INLINE static void\n-ready_sort (ready)\n-     struct ready_list *ready;\n+ready_sort (struct ready_list *ready)\n {\n   rtx *first = ready_lastpos (ready);\n   SCHED_SORT (first, ready->n_ready);\n@@ -1234,8 +1199,7 @@ ready_sort (ready)\n    provide a hook for the target to tweek itself.  */\n \n HAIFA_INLINE static void\n-adjust_priority (prev)\n-     rtx prev;\n+adjust_priority (rtx prev)\n {\n   /* ??? There used to be code here to try and estimate how an insn\n      affected register lifetimes, but it did it by looking at REG_DEAD\n@@ -1251,7 +1215,7 @@ adjust_priority (prev)\n \n /* Advance time on one cycle.  */\n HAIFA_INLINE static void\n-advance_one_cycle ()\n+advance_one_cycle (void)\n {\n   if (targetm.sched.use_dfa_pipeline_interface\n       && (*targetm.sched.use_dfa_pipeline_interface) ())\n@@ -1278,10 +1242,7 @@ static int last_clock_var;\n    zero for insns in a schedule group).  */\n \n static int\n-schedule_insn (insn, ready, clock)\n-     rtx insn;\n-     struct ready_list *ready;\n-     int clock;\n+schedule_insn (rtx insn, struct ready_list *ready, int clock)\n {\n   rtx link;\n   int advance = 0;\n@@ -1324,7 +1285,7 @@ schedule_insn (insn, ready, clock)\n \n       if (MAX_BLOCKAGE > 1 || issue_rate > 1 || sched_verbose)\n \tschedule_unit (unit, insn, clock);\n-      \n+\n       if (INSN_DEPEND (insn) == 0)\n \treturn 0;\n     }\n@@ -1393,8 +1354,7 @@ schedule_insn (insn, ready, clock)\n    Returns the insn following the notes.  */\n \n static rtx\n-unlink_other_notes (insn, tail)\n-     rtx insn, tail;\n+unlink_other_notes (rtx insn, rtx tail)\n {\n   rtx prev = PREV_INSN (insn);\n \n@@ -1430,8 +1390,7 @@ unlink_other_notes (insn, tail)\n    they can be reused.  Returns the insn following the notes.  */\n \n static rtx\n-unlink_line_notes (insn, tail)\n-     rtx insn, tail;\n+unlink_line_notes (rtx insn, rtx tail)\n {\n   rtx prev = PREV_INSN (insn);\n \n@@ -1461,10 +1420,7 @@ unlink_line_notes (insn, tail)\n /* Return the head and tail pointers of BB.  */\n \n void\n-get_block_head_tail (b, headp, tailp)\n-     int b;\n-     rtx *headp;\n-     rtx *tailp;\n+get_block_head_tail (int b, rtx *headp, rtx *tailp)\n {\n   /* HEAD and TAIL delimit the basic block being scheduled.  */\n   rtx head = BLOCK_HEAD (b);\n@@ -1491,8 +1447,7 @@ get_block_head_tail (b, headp, tailp)\n /* Return nonzero if there are no real insns in the range [ HEAD, TAIL ].  */\n \n int\n-no_real_insns_p (head, tail)\n-     rtx head, tail;\n+no_real_insns_p (rtx head, rtx tail)\n {\n   while (head != NEXT_INSN (tail))\n     {\n@@ -1508,8 +1463,7 @@ no_real_insns_p (head, tail)\n    block in which notes should be processed.  */\n \n void\n-rm_line_notes (head, tail)\n-     rtx head, tail;\n+rm_line_notes (rtx head, rtx tail)\n {\n   rtx next_tail;\n   rtx insn;\n@@ -1541,9 +1495,7 @@ rm_line_notes (head, tail)\n    the boundaries of the block in which notes should be processed.  */\n \n void\n-save_line_notes (b, head, tail)\n-     int b;\n-     rtx head, tail;\n+save_line_notes (int b, rtx head, rtx tail)\n {\n   rtx next_tail;\n \n@@ -1569,8 +1521,7 @@ save_line_notes (b, head, tail)\n    be processed.  */\n \n void\n-restore_line_notes (head, tail)\n-     rtx head, tail;\n+restore_line_notes (rtx head, rtx tail)\n {\n   rtx line, note, prev, new;\n   int added_notes = 0;\n@@ -1633,7 +1584,7 @@ restore_line_notes (head, tail)\n    insns list.  */\n \n void\n-rm_redundant_line_notes ()\n+rm_redundant_line_notes (void)\n {\n   rtx line = 0;\n   rtx insn = get_insns ();\n@@ -1682,9 +1633,7 @@ rm_redundant_line_notes ()\n    of notes ended by NOTE_LIST.  */\n \n void\n-rm_other_notes (head, tail)\n-     rtx head;\n-     rtx tail;\n+rm_other_notes (rtx head, rtx tail)\n {\n   rtx next_tail;\n   rtx insn;\n@@ -1724,8 +1673,7 @@ rm_other_notes (head, tail)\n    a new register is not needed.  */\n \n static int\n-find_set_reg_weight (x)\n-    rtx x;\n+find_set_reg_weight (rtx x)\n {\n   if (GET_CODE (x) == CLOBBER\n       && register_operand (SET_DEST (x), VOIDmode))\n@@ -1748,8 +1696,7 @@ find_set_reg_weight (x)\n /* Calculate INSN_REG_WEIGHT for all insns of a block.  */\n \n static void\n-find_insn_reg_weight (b)\n-     int b;\n+find_insn_reg_weight (int b)\n {\n   rtx insn, next_tail, head, tail;\n \n@@ -1769,14 +1716,14 @@ find_insn_reg_weight (b)\n       x = PATTERN (insn);\n       reg_weight += find_set_reg_weight (x);\n       if (GET_CODE (x) == PARALLEL)\n- \t{\n- \t  int j;\n- \t  for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n- \t    {\n- \t      x = XVECEXP (PATTERN (insn), 0, j);\n+\t{\n+\t  int j;\n+\t  for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n+\t    {\n+\t      x = XVECEXP (PATTERN (insn), 0, j);\n \t      reg_weight += find_set_reg_weight (x);\n- \t    }\n- \t}\n+\t    }\n+\t}\n       /* Decrement weight for each register that dies here.  */\n       for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n \t{\n@@ -1795,8 +1742,7 @@ static int clock_var;\n /* Move insns that became ready to fire from queue to ready list.  */\n \n static void\n-queue_to_ready (ready)\n-     struct ready_list *ready;\n+queue_to_ready (struct ready_list *ready)\n {\n   rtx insn;\n   rtx link;\n@@ -1866,8 +1812,7 @@ queue_to_ready (ready)\n /* Print the ready list for debugging purposes.  Callable from debugger.  */\n \n static void\n-debug_ready_list (ready)\n-     struct ready_list *ready;\n+debug_ready_list (struct ready_list *ready)\n {\n   rtx *p;\n   int i;\n@@ -1887,8 +1832,7 @@ debug_ready_list (ready)\n /* move_insn1: Remove INSN from insn chain, and link it after LAST insn.  */\n \n static rtx\n-move_insn1 (insn, last)\n-     rtx insn, last;\n+move_insn1 (rtx insn, rtx last)\n {\n   NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n   PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n@@ -1910,9 +1854,7 @@ move_insn1 (insn, last)\n    output by the instruction scheduler.  Return the new value of LAST.  */\n \n static rtx\n-reemit_notes (insn, last)\n-     rtx insn;\n-     rtx last;\n+reemit_notes (rtx insn, rtx last)\n {\n   rtx note, retval;\n \n@@ -1941,8 +1883,7 @@ reemit_notes (insn, last)\n    return value from the first call to reemit_notes.  */\n \n static rtx\n-move_insn (insn, last)\n-     rtx insn, last;\n+move_insn (rtx insn, rtx last)\n {\n   rtx retval = NULL;\n \n@@ -2011,9 +1952,7 @@ static int cached_issue_rate = 0;\n    of the best insn in READY.  The following function is used only for\n    first cycle multipass scheduling.  */\n static int\n-max_issue (ready, index)\n-  struct ready_list *ready;\n-  int *index;\n+max_issue (struct ready_list *ready, int *index)\n {\n   int n, i, all, n_ready, best, delay, tries_num;\n   struct choice_entry *top;\n@@ -2089,8 +2028,7 @@ max_issue (ready, index)\n    cycle multipass scheduling.  */\n \n static rtx\n-choose_ready (ready)\n-     struct ready_list *ready;\n+choose_ready (struct ready_list *ready)\n {\n   int lookahead = 0;\n \n@@ -2133,8 +2071,7 @@ choose_ready (ready)\n    the instruction stream.  */\n \n rtx\n-sched_emit_insn (pat)\n-     rtx pat;\n+sched_emit_insn (rtx pat)\n {\n   rtx insn = emit_insn_after (pat, last_scheduled_insn);\n   last_scheduled_insn = insn;\n@@ -2145,9 +2082,7 @@ sched_emit_insn (pat)\n    possibly bringing insns from subsequent blocks in the same region.  */\n \n void\n-schedule_block (b, rgn_n_insns)\n-     int b;\n-     int rgn_n_insns;\n+schedule_block (int b, int rgn_n_insns)\n {\n   struct ready_list ready;\n   int i, first_cycle_insn_p;\n@@ -2248,18 +2183,18 @@ schedule_block (b, rgn_n_insns)\n \t  start_clock_var = clock_var;\n \n \t  clock_var++;\n-\t  \n+\n \t  advance_one_cycle ();\n-\t  \n+\n \t  /* Add to the ready list all pending insns that can be issued now.\n \t     If there are no ready insns, increment clock until one\n \t     is ready and add all pending insns at that point to the ready\n \t     list.  */\n \t  queue_to_ready (&ready);\n-\t  \n+\n \t  if (ready.n_ready == 0)\n \t    abort ();\n-\t  \n+\n \t  if (sched_verbose >= 2)\n \t    {\n \t      fprintf (sched_dump, \";;\\t\\tReady list after queue_to_ready:  \");\n@@ -2273,7 +2208,7 @@ schedule_block (b, rgn_n_insns)\n \t{\n \t  /* Sort the ready list based on priority.  */\n \t  ready_sort (&ready);\n-\t  \n+\n \t  if (sched_verbose >= 2)\n \t    {\n \t      fprintf (sched_dump, \";;\\t\\tReady list after ready_sort:  \");\n@@ -2322,13 +2257,13 @@ schedule_block (b, rgn_n_insns)\n \t\t  || state_dead_lock_p (curr_state)\n \t\t  || !(*current_sched_info->schedule_more_p) ())\n \t\tbreak;\n-\t      \n+\n \t      /* Select and remove the insn from the ready list.  */\n \t      if (sort_p)\n \t\tinsn = choose_ready (&ready);\n \t      else\n \t\tinsn = ready_remove_first (&ready);\n-\t      \n+\n \t      if (targetm.sched.dfa_new_cycle\n \t\t  && (*targetm.sched.dfa_new_cycle) (sched_dump, sched_verbose,\n \t\t\t\t\t\t     insn, last_clock_var,\n@@ -2337,7 +2272,7 @@ schedule_block (b, rgn_n_insns)\n \t\t  ready_add (&ready, insn);\n \t\t  break;\n \t\t}\n-\t    \n+\n \t      sort_p = TRUE;\n \t      memcpy (temp_state, curr_state, dfa_state_size);\n \t      if (recog_memoized (insn) < 0)\n@@ -2366,53 +2301,53 @@ schedule_block (b, rgn_n_insns)\n \t\t\t{\n \t\t\t  int j;\n \t\t\t  rtx bubble;\n-\t\t\t  \n+\n \t\t\t  for (j = 0;\n \t\t\t       (bubble = (*targetm.sched.dfa_bubble) (j))\n \t\t\t\t != NULL_RTX;\n \t\t\t       j++)\n \t\t\t    {\n \t\t\t      memcpy (temp_state, curr_state, dfa_state_size);\n-\t\t\t      \n+\n \t\t\t      if (state_transition (temp_state, bubble) < 0\n \t\t\t\t  && state_transition (temp_state, insn) < 0)\n \t\t\t\tbreak;\n \t\t\t    }\n-\t\t\t  \n+\n \t\t\t  if (bubble != NULL_RTX)\n \t\t\t    {\n \t\t\t      if (insert_schedule_bubbles_p)\n \t\t\t\t{\n \t\t\t\t  rtx copy;\n-\t\t\t\t  \n+\n \t\t\t\t  copy = copy_rtx (PATTERN (bubble));\n \t\t\t\t  emit_insn_after (copy, last_scheduled_insn);\n \t\t\t\t  last_scheduled_insn\n \t\t\t\t    = NEXT_INSN (last_scheduled_insn);\n \t\t\t\t  INSN_CODE (last_scheduled_insn)\n \t\t\t\t    = INSN_CODE (bubble);\n-\t\t\t\t  \n+\n \t\t\t\t  /* Annotate the same for the first insns\n \t\t\t\t     scheduling by using mode.  */\n \t\t\t\t  PUT_MODE (last_scheduled_insn,\n \t\t\t\t\t    (clock_var > last_clock_var\n \t\t\t\t\t     ? clock_var - last_clock_var\n \t\t\t\t\t     : VOIDmode));\n \t\t\t\t  last_clock_var = clock_var;\n-\t\t\t\t  \n+\n \t\t\t\t  if (sched_verbose >= 2)\n \t\t\t\t    {\n \t\t\t\t      fprintf (sched_dump,\n \t\t\t\t\t       \";;\\t\\t--> scheduling bubble insn <<<%d>>>:reservation \",\n \t\t\t\t\t       INSN_UID (last_scheduled_insn));\n-\t\t\t\t      \n+\n \t\t\t\t      if (recog_memoized (last_scheduled_insn)\n \t\t\t\t\t  < 0)\n \t\t\t\t\tfprintf (sched_dump, \"nothing\");\n \t\t\t\t      else\n \t\t\t\t\tprint_reservation\n \t\t\t\t\t  (sched_dump, last_scheduled_insn);\n-\t\t\t\t      \n+\n \t\t\t\t      fprintf (sched_dump, \"\\n\");\n \t\t\t\t    }\n \t\t\t\t}\n@@ -2447,7 +2382,7 @@ schedule_block (b, rgn_n_insns)\n \t\tcycle_issued_insns++;\n \t      memcpy (curr_state, temp_state, dfa_state_size);\n \t    }\n-\t    \n+\n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n \t      (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n@@ -2515,7 +2450,7 @@ schedule_block (b, rgn_n_insns)\n   if (!reload_completed)\n     {\n       rtx insn, link, next;\n-      \n+\n       /* INSN_TICK (minimum clock tick at which the insn becomes\n          ready) may be not correct for the insn in the subsequent\n          blocks of the region.  We should use a correct value of\n@@ -2580,8 +2515,7 @@ schedule_block (b, rgn_n_insns)\n /* Set_priorities: compute priority of each insn in the block.  */\n \n int\n-set_priorities (head, tail)\n-     rtx head, tail;\n+set_priorities (rtx head, rtx tail)\n {\n   rtx insn;\n   int n_insn;\n@@ -2610,8 +2544,7 @@ set_priorities (head, tail)\n    for debugging output.  */\n \n void\n-sched_init (dump_file)\n-     FILE *dump_file;\n+sched_init (FILE *dump_file)\n {\n   int luid;\n   basic_block b;\n@@ -2659,14 +2592,14 @@ sched_init (dump_file)\n     {\n       if (targetm.sched.init_dfa_pre_cycle_insn)\n \t(*targetm.sched.init_dfa_pre_cycle_insn) ();\n-      \n+\n       if (targetm.sched.init_dfa_post_cycle_insn)\n \t(*targetm.sched.init_dfa_post_cycle_insn) ();\n-      \n+\n       if (targetm.sched.first_cycle_multipass_dfa_lookahead\n \t  && targetm.sched.init_dfa_bubbles)\n \t(*targetm.sched.init_dfa_bubbles) ();\n-      \n+\n       dfa_start ();\n       dfa_state_size = state_size ();\n       curr_state = xmalloc (dfa_state_size);\n@@ -2757,7 +2690,7 @@ sched_init (dump_file)\n /* Free global data used during insn scheduling.  */\n \n void\n-sched_finish ()\n+sched_finish (void)\n {\n   free (h_i_d);\n "}, {"sha": "88b1a293456bb4f8a04db3b67744d1c8a57b0a21", "filename": "gcc/hashtable.c", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhashtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhashtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,5 +1,5 @@\n /* Hash tables.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -32,15 +32,13 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    existing entry with a potential new one.  Also, the ability to\n    delete members from the table has been removed.  */\n \n-static unsigned int calc_hash PARAMS ((const unsigned char *, unsigned int));\n-static void ht_expand PARAMS ((hash_table *));\n+static unsigned int calc_hash (const unsigned char *, unsigned int);\n+static void ht_expand (hash_table *);\n \n /* Calculate the hash of the string STR of length LEN.  */\n \n static unsigned int\n-calc_hash (str, len)\n-     const unsigned char *str;\n-     unsigned int len;\n+calc_hash (const unsigned char *str, unsigned int len)\n {\n   unsigned int n = len;\n   unsigned int r = 0;\n@@ -56,8 +54,7 @@ calc_hash (str, len)\n /* Initialize an identifier hashtable.  */\n \n hash_table *\n-ht_create (order)\n-     unsigned int order;\n+ht_create (unsigned int order)\n {\n   unsigned int nslots = 1 << order;\n   hash_table *table;\n@@ -77,8 +74,7 @@ ht_create (order)\n /* Frees all memory associated with a hash table.  */\n \n void\n-ht_destroy (table)\n-     hash_table *table;\n+ht_destroy (hash_table *table)\n {\n   obstack_free (&table->stack, NULL);\n   free (table->entries);\n@@ -94,11 +90,8 @@ ht_destroy (table)\n    CPP_ALLOCED and the item is assumed to be at the top of the\n    obstack.  */\n hashnode\n-ht_lookup (table, str, len, insert)\n-     hash_table *table;\n-     const unsigned char *str;\n-     unsigned int len;\n-     enum ht_lookup_option insert;\n+ht_lookup (hash_table *table, const unsigned char *str, unsigned int len,\n+\t   enum ht_lookup_option insert)\n {\n   unsigned int hash = calc_hash (str, len);\n   unsigned int hash2;\n@@ -158,8 +151,7 @@ ht_lookup (table, str, len, insert)\n /* Double the size of a hash table, re-hashing existing entries.  */\n \n static void\n-ht_expand (table)\n-     hash_table *table;\n+ht_expand (hash_table *table)\n {\n   hashnode *nentries, *p, *limit;\n   unsigned int size, sizemask;\n@@ -200,10 +192,7 @@ ht_expand (table)\n /* For all nodes in TABLE, callback CB with parameters TABLE->PFILE,\n    the node, and V.  */\n void\n-ht_forall (table, cb, v)\n-     hash_table *table;\n-     ht_cb cb;\n-     const void *v;\n+ht_forall (hash_table *table, ht_cb cb, const void *v)\n {\n   hashnode *p, *limit;\n \n@@ -221,8 +210,7 @@ ht_forall (table, cb, v)\n /* Dump allocation statistics to stderr.  */\n \n void\n-ht_dump_statistics (table)\n-     hash_table *table;\n+ht_dump_statistics (hash_table *table)\n {\n   size_t nelts, nids, overhead, headers;\n   size_t total_bytes, longest, sum_of_squares;\n@@ -251,7 +239,7 @@ ht_dump_statistics (table)\n \tnids++;\n       }\n   while (++p < limit);\n-      \n+\n   nelts = table->nelements;\n   overhead = obstack_memory_used (&table->stack) - total_bytes;\n   headers = table->nslots * sizeof (hashnode);\n@@ -287,8 +275,7 @@ ht_dump_statistics (table)\n /* Return the approximate positive square root of a number N.  This is for\n    statistical reports, not code generation.  */\n double\n-approx_sqrt (x)\n-     double x;\n+approx_sqrt (double x)\n {\n   double s, d;\n "}, {"sha": "47ec1cccd3bd920edcfa7ad6fbbcf713fb673428", "filename": "gcc/hashtable.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,5 +1,5 @@\n /* Hash tables.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -46,7 +46,7 @@ struct ht\n \n   hashnode *entries;\n   /* Call back.  */\n-  hashnode (*alloc_node) PARAMS ((hash_table *));\n+  hashnode (*alloc_node) (hash_table *);\n \n   unsigned int nslots;\t\t/* Total slots in the entries array.  */\n   unsigned int nelements;\t/* Number of live elements.  */\n@@ -60,25 +60,25 @@ struct ht\n };\n \n /* Initialize the hashtable with 2 ^ order entries.  */\n-extern hash_table *ht_create PARAMS ((unsigned int order));\n+extern hash_table *ht_create (unsigned int order);\n \n /* Frees all memory associated with a hash table.  */\n-extern void ht_destroy PARAMS ((hash_table *));\n+extern void ht_destroy (hash_table *);\n \n-extern hashnode ht_lookup PARAMS ((hash_table *, const unsigned char *,\n-\t\t\t\t   unsigned int, enum ht_lookup_option));\n+extern hashnode ht_lookup (hash_table *, const unsigned char *,\n+\t\t\t   unsigned int, enum ht_lookup_option);\n \n /* For all nodes in TABLE, make a callback.  The callback takes\n    TABLE->PFILE, the node, and a PTR, and the callback sequence stops\n    if the callback returns zero.  */\n-typedef int (*ht_cb) PARAMS ((struct cpp_reader *, hashnode, const void *));\n-extern void ht_forall PARAMS ((hash_table *, ht_cb, const void *));\n+typedef int (*ht_cb) (struct cpp_reader *, hashnode, const void *);\n+extern void ht_forall (hash_table *, ht_cb, const void *);\n \n /* Dump allocation statistics to stderr.  */\n-extern void ht_dump_statistics PARAMS ((hash_table *));\n+extern void ht_dump_statistics (hash_table *);\n \n /* Approximate positive square root of a host double.  This is for\n    statistical reports, not code generation.  */\n-extern double approx_sqrt PARAMS ((double));\n+extern double approx_sqrt (double);\n \n #endif /* GCC_HASHTABLE_H */"}, {"sha": "d737000620b533e32b8b876994f6935d2d5f0b2a", "filename": "gcc/hooks.c", "status": "modified", "additions": 29, "deletions": 49, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -30,13 +30,13 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n /* Generic hook that does absolutely zappo.  */\n void\n-hook_void_void ()\n+hook_void_void (void)\n {\n }\n \n /* Generic hook that takes no arguments and returns false.  */\n bool\n-hook_bool_void_false ()\n+hook_bool_void_false (void)\n {\n   return false;\n }\n@@ -58,63 +58,53 @@ hook_bool_bool_false (bool a ATTRIBUTE_UNUSED)\n \n /* Generic hook that takes (tree, int) and does nothing.  */\n void\n-hook_void_tree_int (a, b)\n-     tree a ATTRIBUTE_UNUSED;\n-     int b ATTRIBUTE_UNUSED;\n+hook_void_tree_int (tree a ATTRIBUTE_UNUSED, int b ATTRIBUTE_UNUSED)\n {\n }\n \n /* Generic hook that takes (FILE *, const char *) and does nothing.  */\n void\n-hook_void_FILEptr_constcharptr (a, b)\n-     FILE *a ATTRIBUTE_UNUSED;\n-     const char *b ATTRIBUTE_UNUSED;\n+hook_void_FILEptr_constcharptr (FILE *a ATTRIBUTE_UNUSED, const char *b ATTRIBUTE_UNUSED)\n {\n }\n \n /* Used for the TARGET_ASM_CAN_OUTPUT_MI_THUNK hook.  */\n bool\n-hook_bool_tree_hwi_hwi_tree_false (a, b, c, d)\n-     tree a ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT b ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT c ATTRIBUTE_UNUSED;\n-     tree d ATTRIBUTE_UNUSED;\n+hook_bool_tree_hwi_hwi_tree_false (tree a ATTRIBUTE_UNUSED,\n+\t\t\t\t   HOST_WIDE_INT b ATTRIBUTE_UNUSED,\n+\t\t\t\t   HOST_WIDE_INT c ATTRIBUTE_UNUSED,\n+\t\t\t\t   tree d ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n bool\n-hook_bool_tree_hwi_hwi_tree_true (a, b, c, d)\n-     tree a ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT b ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT c ATTRIBUTE_UNUSED;\n-     tree d ATTRIBUTE_UNUSED;\n+hook_bool_tree_hwi_hwi_tree_true (tree a ATTRIBUTE_UNUSED,\n+\t\t\t\t  HOST_WIDE_INT b ATTRIBUTE_UNUSED,\n+\t\t\t\t  HOST_WIDE_INT c ATTRIBUTE_UNUSED,\n+\t\t\t\t  tree d ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n \n bool\n-default_can_output_mi_thunk_no_vcall (a, b, c, d)\n-     tree a ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT b ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT c;\n-     tree d ATTRIBUTE_UNUSED;\n+default_can_output_mi_thunk_no_vcall (tree a ATTRIBUTE_UNUSED,\n+\t\t\t\t      HOST_WIDE_INT b ATTRIBUTE_UNUSED,\n+\t\t\t\t      HOST_WIDE_INT c,\n+\t\t\t\t      tree d ATTRIBUTE_UNUSED)\n {\n   return c == 0;\n }\n \n /* ??? Used for comp_type_attributes, which ought to return bool.  */\n int\n-hook_int_tree_tree_1 (a, b)\n-     tree a ATTRIBUTE_UNUSED;\n-     tree b ATTRIBUTE_UNUSED;\n+hook_int_tree_tree_1 (tree a ATTRIBUTE_UNUSED, tree b ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n \n int\n-hook_int_rtx_0 (a)\n-     rtx a ATTRIBUTE_UNUSED;\n+hook_int_rtx_0 (rtx a ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -141,62 +131,52 @@ hook_uint_uint_constcharptrptr_0 (unsigned int a ATTRIBUTE_UNUSED,\n }\n \n void\n-hook_void_tree (a)\n-     tree a ATTRIBUTE_UNUSED;\n+hook_void_tree (tree a ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-hook_void_tree_treeptr (a, b)\n-     tree a ATTRIBUTE_UNUSED;\n-     tree *b ATTRIBUTE_UNUSED;\n+hook_void_tree_treeptr (tree a ATTRIBUTE_UNUSED, tree *b ATTRIBUTE_UNUSED)\n {\n }\n \n bool\n-hook_bool_tree_false (a)\n-     tree a ATTRIBUTE_UNUSED;\n+hook_bool_tree_false (tree a ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n bool\n-hook_bool_tree_tree_false (a, b)\n-     tree a ATTRIBUTE_UNUSED;\n-     tree b ATTRIBUTE_UNUSED;\n+hook_bool_tree_tree_false (tree a ATTRIBUTE_UNUSED, tree b ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n bool\n-hook_bool_rtx_false (a)\n-     rtx a ATTRIBUTE_UNUSED;\n+hook_bool_rtx_false (rtx a ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n bool\n-hook_bool_rtx_int_int_intp_false (a, b, c, d)\n-     rtx a ATTRIBUTE_UNUSED;\n-     int b ATTRIBUTE_UNUSED;\n-     int c ATTRIBUTE_UNUSED;\n-     int *d ATTRIBUTE_UNUSED;\n+hook_bool_rtx_int_int_intp_false (rtx a ATTRIBUTE_UNUSED,\n+\t\t\t\t  int b ATTRIBUTE_UNUSED,\n+\t\t\t\t  int c ATTRIBUTE_UNUSED,\n+\t\t\t\t  int *d ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n /* Generic hook that takes an rtx and returns it.  */\n rtx\n-hook_rtx_rtx_identity (x)\n-     rtx x;\n+hook_rtx_rtx_identity (rtx x)\n {\n   return x;\n }\n \n /* Generic hook that takes an rtx and returns NULL_RTX.  */\n rtx\n-hook_rtx_rtx_null (x)\n-     rtx x ATTRIBUTE_UNUSED;\n+hook_rtx_rtx_null (rtx x ATTRIBUTE_UNUSED)\n {\n   return 0;\n }"}, {"sha": "4309a5dca7235a3df0b607207f20d929ed7cc2d4", "filename": "gcc/hooks.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -22,36 +22,36 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #ifndef GCC_HOOKS_H\n #define GCC_HOOKS_H\n \n-bool hook_bool_void_false PARAMS ((void));\n+bool hook_bool_void_false (void);\n bool hook_bool_bool_false (bool);\n-bool hook_bool_tree_false PARAMS ((tree));\n-bool hook_bool_tree_hwi_hwi_tree_false\n-  PARAMS ((tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n-bool hook_bool_tree_hwi_hwi_tree_true\n-  PARAMS ((tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n-bool hook_bool_rtx_false PARAMS ((rtx));\n-bool hook_bool_rtx_int_int_intp_false PARAMS ((rtx, int, int, int *));\n-\n-void hook_void_tree_int PARAMS ((tree, int));\n-void hook_void_void PARAMS ((void));\n-void hook_void_FILEptr_constcharptr PARAMS ((FILE *, const char *));\n-void hook_void_tree PARAMS ((tree));\n-void hook_void_tree_treeptr PARAMS ((tree, tree *));\n-\n-int hook_int_tree_tree_1 PARAMS ((tree, tree));\n-int hook_int_rtx_0 PARAMS ((rtx));\n+bool hook_bool_tree_false (tree);\n+bool hook_bool_tree_hwi_hwi_tree_false (tree, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\ttree);\n+bool hook_bool_tree_hwi_hwi_tree_true (tree, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t       tree);\n+bool hook_bool_rtx_false (rtx);\n+bool hook_bool_rtx_int_int_intp_false (rtx, int, int, int *);\n+\n+void hook_void_tree_int (tree, int);\n+void hook_void_void (void);\n+void hook_void_FILEptr_constcharptr (FILE *, const char *);\n+void hook_void_tree (tree);\n+void hook_void_tree_treeptr (tree, tree *);\n+\n+int hook_int_tree_tree_1 (tree, tree);\n+int hook_int_rtx_0 (rtx);\n int hook_int_void_0 (void);\n int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);\n int hook_int_void_no_regs (void);\n \n unsigned hook_uint_uint_constcharptrptr_0 (unsigned, const char **);\n \n-bool default_can_output_mi_thunk_no_vcall\n-  PARAMS ((tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n+bool default_can_output_mi_thunk_no_vcall (tree, HOST_WIDE_INT,\n+\t\t\t\t\t   HOST_WIDE_INT, tree);\n \n-bool hook_bool_tree_tree_false PARAMS ((tree, tree));\n+bool hook_bool_tree_tree_false (tree, tree);\n \n-rtx hook_rtx_rtx_identity PARAMS ((rtx));\n-rtx hook_rtx_rtx_null PARAMS ((rtx));\n+rtx hook_rtx_rtx_identity (rtx);\n+rtx hook_rtx_rtx_null (rtx);\n \n #endif"}, {"sha": "cf6382b9419406c544f7081773ac52efb192a1ae", "filename": "gcc/hosthooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhosthooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fhosthooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -21,9 +21,9 @@ Boston, MA 02111-1307, USA.  */\n #ifndef GCC_HOST_HOOKS_H\n #define GCC_HOST_HOOKS_H\n \n-struct host_hooks \n+struct host_hooks\n {\n-  void (*extra_signals) PARAMS((void));\n+  void (*extra_signals) (void);\n \n   /* Whenever you add entries here, make sure you adjust hosthooks-def.h.  */\n };"}, {"sha": "60723efa3b333032d416d590d915952fcd4c4cdb", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 112, "deletions": 163, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,5 +1,5 @@\n /* If-conversion support.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -86,37 +86,35 @@ static bool life_data_ok;\n static dominance_info post_dominators;\n \n /* Forward references.  */\n-static int count_bb_insns\t\tPARAMS ((basic_block));\n-static rtx first_active_insn\t\tPARAMS ((basic_block));\n-static rtx last_active_insn\t\tPARAMS ((basic_block, int));\n-static int seq_contains_jump\t\tPARAMS ((rtx));\n-static basic_block block_fallthru\tPARAMS ((basic_block));\n-static int cond_exec_process_insns\tPARAMS ((ce_if_block_t *,\n-\t\t\t\t\t\t rtx, rtx, rtx, rtx, int));\n-static rtx cond_exec_get_condition\tPARAMS ((rtx));\n-static int cond_exec_process_if_block\tPARAMS ((ce_if_block_t *, int));\n-static rtx noce_get_condition\t\tPARAMS ((rtx, rtx *));\n-static int noce_operand_ok\t\tPARAMS ((rtx));\n-static int noce_process_if_block\tPARAMS ((ce_if_block_t *));\n-static int process_if_block\t\tPARAMS ((ce_if_block_t *));\n-static void merge_if_block\t\tPARAMS ((ce_if_block_t *));\n-static int find_cond_trap\t\tPARAMS ((basic_block, edge, edge));\n-static basic_block find_if_header\tPARAMS ((basic_block, int));\n-static int block_jumps_and_fallthru_p\tPARAMS ((basic_block, basic_block));\n-static int find_if_block\t\tPARAMS ((ce_if_block_t *));\n-static int find_if_case_1\t\tPARAMS ((basic_block, edge, edge));\n-static int find_if_case_2\t\tPARAMS ((basic_block, edge, edge));\n-static int find_memory\t\t\tPARAMS ((rtx *, void *));\n-static int dead_or_predicable\t\tPARAMS ((basic_block, basic_block,\n-\t\t\t\t\t\t basic_block, basic_block, int));\n-static void noce_emit_move_insn\t\tPARAMS ((rtx, rtx));\n-static rtx block_has_only_trap\t\tPARAMS ((basic_block));\n+static int count_bb_insns (basic_block);\n+static rtx first_active_insn (basic_block);\n+static rtx last_active_insn (basic_block, int);\n+static int seq_contains_jump (rtx);\n+static basic_block block_fallthru (basic_block);\n+static int cond_exec_process_insns (ce_if_block_t *, rtx, rtx, rtx, rtx, int);\n+static rtx cond_exec_get_condition (rtx);\n+static int cond_exec_process_if_block (ce_if_block_t *, int);\n+static rtx noce_get_condition (rtx, rtx *);\n+static int noce_operand_ok (rtx);\n+static int noce_process_if_block (ce_if_block_t *);\n+static int process_if_block (ce_if_block_t *);\n+static void merge_if_block (ce_if_block_t *);\n+static int find_cond_trap (basic_block, edge, edge);\n+static basic_block find_if_header (basic_block, int);\n+static int block_jumps_and_fallthru_p (basic_block, basic_block);\n+static int find_if_block (ce_if_block_t *);\n+static int find_if_case_1 (basic_block, edge, edge);\n+static int find_if_case_2 (basic_block, edge, edge);\n+static int find_memory (rtx *, void *);\n+static int dead_or_predicable (basic_block, basic_block, basic_block,\n+\t\t\t       basic_block, int);\n+static void noce_emit_move_insn (rtx, rtx);\n+static rtx block_has_only_trap (basic_block);\n \f\n /* Count the number of non-jump active insns in BB.  */\n \n static int\n-count_bb_insns (bb)\n-     basic_block bb;\n+count_bb_insns (basic_block bb)\n {\n   int count = 0;\n   rtx insn = bb->head;\n@@ -137,8 +135,7 @@ count_bb_insns (bb)\n /* Return the first non-jump active insn in the basic block.  */\n \n static rtx\n-first_active_insn (bb)\n-     basic_block bb;\n+first_active_insn (basic_block bb)\n {\n   rtx insn = bb->head;\n \n@@ -165,9 +162,7 @@ first_active_insn (bb)\n /* Return the last non-jump active (non-jump) insn in the basic block.  */\n \n static rtx\n-last_active_insn (bb, skip_use_p)\n-     basic_block bb;\n-     int skip_use_p;\n+last_active_insn (basic_block bb, int skip_use_p)\n {\n   rtx insn = bb->end;\n   rtx head = bb->head;\n@@ -189,14 +184,13 @@ last_active_insn (bb, skip_use_p)\n   return insn;\n }\n \n-/* It is possible, especially when having dealt with multi-word \n+/* It is possible, especially when having dealt with multi-word\n    arithmetic, for the expanders to have emitted jumps.  Search\n    through the sequence and return TRUE if a jump exists so that\n    we can abort the conversion.  */\n \n static int\n-seq_contains_jump (insn)\n-     rtx insn;\n+seq_contains_jump (rtx insn)\n {\n   while (insn)\n     {\n@@ -208,8 +202,7 @@ seq_contains_jump (insn)\n }\n \n static basic_block\n-block_fallthru (bb)\n-     basic_block bb;\n+block_fallthru (basic_block bb)\n {\n   edge e;\n \n@@ -226,13 +219,12 @@ block_fallthru (bb)\n    insns were processed.  */\n \n static int\n-cond_exec_process_insns (ce_info, start, end, test, prob_val, mod_ok)\n-     ce_if_block_t *ce_info ATTRIBUTE_UNUSED;\t/* if block information */\n-     rtx start;\t\t\t/* first insn to look at */\n-     rtx end;\t\t\t/* last insn to look at */\n-     rtx test;\t\t\t/* conditional execution test */\n-     rtx prob_val;\t\t/* probability of branch taken.  */\n-     int mod_ok;\t\t/* true if modifications ok last insn.  */\n+cond_exec_process_insns (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n+\t\t\t /* if block information */rtx start,\n+\t\t\t /* first insn to look at */rtx end,\n+\t\t\t /* last insn to look at */rtx test,\n+\t\t\t /* conditional execution test */rtx prob_val,\n+\t\t\t /* probability of branch taken. */int mod_ok)\n {\n   int must_be_last = FALSE;\n   rtx insn;\n@@ -253,7 +245,7 @@ cond_exec_process_insns (ce_info, start, end, test, prob_val, mod_ok)\n       /* Remove USE insns that get in the way.  */\n       if (reload_completed && GET_CODE (PATTERN (insn)) == USE)\n \t{\n-\t  /* ??? Ug.  Actually unlinking the thing is problematic, \n+\t  /* ??? Ug.  Actually unlinking the thing is problematic,\n \t     given what we'd have to coordinate with our callers.  */\n \t  PUT_CODE (insn, NOTE);\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n@@ -317,8 +309,7 @@ cond_exec_process_insns (ce_info, start, end, test, prob_val, mod_ok)\n /* Return the condition for a jump.  Do not do any special processing.  */\n \n static rtx\n-cond_exec_get_condition (jump)\n-     rtx jump;\n+cond_exec_get_condition (rtx jump)\n {\n   rtx test_if, cond;\n \n@@ -349,9 +340,8 @@ cond_exec_get_condition (jump)\n    converting the block.  */\n \n static int\n-cond_exec_process_if_block (ce_info, do_multiple_p)\n-     ce_if_block_t * ce_info;\t/* if block information */\n-     int do_multiple_p;\t\t/* != 0 if we should handle && and || blocks */\n+cond_exec_process_if_block (ce_if_block_t * ce_info,\n+\t\t\t    /* if block information */int do_multiple_p)\n {\n   basic_block test_bb = ce_info->test_bb;\t/* last test block */\n   basic_block then_bb = ce_info->then_bb;\t/* THEN */\n@@ -416,7 +406,7 @@ cond_exec_process_if_block (ce_info, do_multiple_p)\n \n   /* Map test_expr/test_jump into the appropriate MD tests to use on\n      the conditionally executed code.  */\n-  \n+\n   true_expr = test_expr;\n \n   false_code = reversed_comparison_code (true_expr, test_bb->end);\n@@ -566,10 +556,10 @@ cond_exec_process_if_block (ce_info, do_multiple_p)\n   return FALSE;\n }\n \f\n-/* Used by noce_process_if_block to communicate with its subroutines. \n+/* Used by noce_process_if_block to communicate with its subroutines.\n \n    The subroutines know that A and B may be evaluated freely.  They\n-   know that X is a register.  They should insert new instructions \n+   know that X is a register.  They should insert new instructions\n    before cond_earliest.  */\n \n struct noce_if_info\n@@ -580,29 +570,24 @@ struct noce_if_info\n   rtx jump, cond, cond_earliest;\n };\n \n-static rtx noce_emit_store_flag\t\tPARAMS ((struct noce_if_info *,\n-\t\t\t\t\t\t rtx, int, int));\n-static int noce_try_store_flag\t\tPARAMS ((struct noce_if_info *));\n-static int noce_try_addcc\t\tPARAMS ((struct noce_if_info *));\n-static int noce_try_store_flag_constants PARAMS ((struct noce_if_info *));\n-static int noce_try_store_flag_mask\tPARAMS ((struct noce_if_info *));\n-static rtx noce_emit_cmove\t\tPARAMS ((struct noce_if_info *,\n-\t\t\t\t\t\t rtx, enum rtx_code, rtx,\n-\t\t\t\t\t\t rtx, rtx, rtx));\n-static int noce_try_cmove\t\tPARAMS ((struct noce_if_info *));\n-static int noce_try_cmove_arith\t\tPARAMS ((struct noce_if_info *));\n-static rtx noce_get_alt_condition\tPARAMS ((struct noce_if_info *,\n-\t\t\t\t\t\t rtx, rtx *));\n-static int noce_try_minmax\t\tPARAMS ((struct noce_if_info *));\n-static int noce_try_abs\t\t\tPARAMS ((struct noce_if_info *));\n+static rtx noce_emit_store_flag (struct noce_if_info *, rtx, int, int);\n+static int noce_try_store_flag (struct noce_if_info *);\n+static int noce_try_addcc (struct noce_if_info *);\n+static int noce_try_store_flag_constants (struct noce_if_info *);\n+static int noce_try_store_flag_mask (struct noce_if_info *);\n+static rtx noce_emit_cmove (struct noce_if_info *, rtx, enum rtx_code, rtx,\n+\t\t\t    rtx, rtx, rtx);\n+static int noce_try_cmove (struct noce_if_info *);\n+static int noce_try_cmove_arith (struct noce_if_info *);\n+static rtx noce_get_alt_condition (struct noce_if_info *, rtx, rtx *);\n+static int noce_try_minmax (struct noce_if_info *);\n+static int noce_try_abs (struct noce_if_info *);\n \n /* Helper function for noce_try_store_flag*.  */\n \n static rtx\n-noce_emit_store_flag (if_info, x, reversep, normalize)\n-     struct noce_if_info *if_info;\n-     rtx x;\n-     int reversep, normalize;\n+noce_emit_store_flag (struct noce_if_info *if_info, rtx x, int reversep,\n+\t\t      int normalize)\n {\n   rtx cond = if_info->cond;\n   int cond_complex;\n@@ -660,8 +645,7 @@ noce_emit_store_flag (if_info, x, reversep, normalize)\n \n /* Emit instruction to move an rtx into STRICT_LOW_PART.  */\n static void\n-noce_emit_move_insn (x, y)\n-     rtx x, y;\n+noce_emit_move_insn (rtx x, rtx y)\n {\n   enum machine_mode outmode, inmode;\n   rtx outer, inner;\n@@ -689,8 +673,7 @@ noce_emit_move_insn (x, y)\n    a go at the conversion.  */\n \n static int\n-noce_try_store_flag (if_info)\n-     struct noce_if_info *if_info;\n+noce_try_store_flag (struct noce_if_info *if_info)\n {\n   int reversep;\n   rtx target, seq;\n@@ -732,8 +715,7 @@ noce_try_store_flag (if_info)\n /* Convert \"if (test) x = a; else x = b\", for A and B constant.  */\n \n static int\n-noce_try_store_flag_constants (if_info)\n-     struct noce_if_info *if_info;\n+noce_try_store_flag_constants (struct noce_if_info *if_info)\n {\n   rtx target, seq;\n   int reversep;\n@@ -783,7 +765,7 @@ noce_try_store_flag_constants (if_info)\n \treturn FALSE;\n \n       if (reversep)\n-      \t{\n+\t{\n \t  tmp = itrue; itrue = ifalse; ifalse = tmp;\n \t  diff = trunc_int_for_mode (-diff, mode);\n \t}\n@@ -861,12 +843,11 @@ noce_try_store_flag_constants (if_info)\n   return FALSE;\n }\n \n-/* Convert \"if (test) foo++\" into \"foo += (test != 0)\", and \n+/* Convert \"if (test) foo++\" into \"foo += (test != 0)\", and\n    similarly for \"foo--\".  */\n \n static int\n-noce_try_addcc (if_info)\n-     struct noce_if_info *if_info;\n+noce_try_addcc (struct noce_if_info *if_info)\n {\n   rtx target, seq;\n   int subtract, normalize;\n@@ -907,7 +888,7 @@ noce_try_addcc (if_info)\n \t    }\n \t  end_sequence ();\n \t}\n-\t\n+\n       /* If that fails, construct conditional increment or decrement using\n \t setcc.  */\n       if (BRANCH_COST >= 2\n@@ -958,8 +939,7 @@ noce_try_addcc (if_info)\n /* Convert \"if (test) x = 0;\" to \"x &= -(test == 0);\"  */\n \n static int\n-noce_try_store_flag_mask (if_info)\n-     struct noce_if_info *if_info;\n+noce_try_store_flag_mask (struct noce_if_info *if_info)\n {\n   rtx target, seq;\n   int reversep;\n@@ -1011,10 +991,8 @@ noce_try_store_flag_mask (if_info)\n /* Helper function for noce_try_cmove and noce_try_cmove_arith.  */\n \n static rtx\n-noce_emit_cmove (if_info, x, code, cmp_a, cmp_b, vfalse, vtrue)\n-     struct noce_if_info *if_info;\n-     rtx x, cmp_a, cmp_b, vfalse, vtrue;\n-     enum rtx_code code;\n+noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n+\t\t rtx cmp_a, rtx cmp_b, rtx vfalse, rtx vtrue)\n {\n   /* If earliest == jump, try to build the cmove insn directly.\n      This is helpful when combine has created some complex condition\n@@ -1057,7 +1035,7 @@ noce_emit_cmove (if_info, x, code, cmp_a, cmp_b, vfalse, vtrue)\n #else\n   /* We'll never get here, as noce_process_if_block doesn't call the\n      functions involved.  Ifdef code, however, should be discouraged\n-     because it leads to typos in the code not selected.  However, \n+     because it leads to typos in the code not selected.  However,\n      emit_conditional_move won't exist either.  */\n   return NULL_RTX;\n #endif\n@@ -1068,8 +1046,7 @@ noce_emit_cmove (if_info, x, code, cmp_a, cmp_b, vfalse, vtrue)\n    has had a go at it.  */\n \n static int\n-noce_try_cmove (if_info)\n-     struct noce_if_info *if_info;\n+noce_try_cmove (struct noce_if_info *if_info)\n {\n   enum rtx_code code;\n   rtx target, seq;\n@@ -1109,8 +1086,7 @@ noce_try_cmove (if_info)\n /* Try more complex cases involving conditional_move.  */\n \n static int\n-noce_try_cmove_arith (if_info)\n-     struct noce_if_info *if_info;\n+noce_try_cmove_arith (struct noce_if_info *if_info)\n {\n   rtx a = if_info->a;\n   rtx b = if_info->b;\n@@ -1146,7 +1122,7 @@ noce_try_cmove_arith (if_info)\n \tif (test)\n \t  x = y;\n   */\n-  \n+\n   code = GET_CODE (if_info->cond);\n   insn_a = if_info->insn_a;\n   insn_b = if_info->insn_b;\n@@ -1172,7 +1148,7 @@ noce_try_cmove_arith (if_info)\n \n   /* If either operand is complex, load it into a register first.\n      The best way to do this is to copy the original insn.  In this\n-     way we preserve any clobbers etc that the insn may have had.  \n+     way we preserve any clobbers etc that the insn may have had.\n      This is of course not possible in the IS_MEM case.  */\n   if (! general_operand (a, GET_MODE (a)))\n     {\n@@ -1268,10 +1244,8 @@ noce_try_cmove_arith (if_info)\n    For these we wish to know that it is A or B in the condition.  */\n \n static rtx\n-noce_get_alt_condition (if_info, target, earliest)\n-     struct noce_if_info *if_info;\n-     rtx target;\n-     rtx *earliest;\n+noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n+\t\t\trtx *earliest)\n {\n   rtx cond, set, insn;\n   int reverse;\n@@ -1417,9 +1391,8 @@ noce_get_alt_condition (if_info, target, earliest)\n /* Convert \"if (a < b) x = a; else x = b;\" to \"x = min(a, b);\", etc.  */\n \n static int\n-noce_try_minmax (if_info)\n-     struct noce_if_info *if_info;\n-{ \n+noce_try_minmax (struct noce_if_info *if_info)\n+{\n   rtx cond, earliest, target, seq;\n   enum rtx_code code, op;\n   int unsignedp;\n@@ -1502,7 +1475,7 @@ noce_try_minmax (if_info)\n     noce_emit_move_insn (if_info->x, target);\n \n   seq = get_insns ();\n-  end_sequence ();  \n+  end_sequence ();\n \n   if (seq_contains_jump (seq))\n     return FALSE;\n@@ -1517,9 +1490,8 @@ noce_try_minmax (if_info)\n /* Convert \"if (a < 0) x = -a; else x = a;\" to \"x = abs(a);\", etc.  */\n \n static int\n-noce_try_abs (if_info)\n-     struct noce_if_info *if_info;\n-{ \n+noce_try_abs (struct noce_if_info *if_info)\n+{\n   rtx cond, earliest, target, seq, a, b, c;\n   int negate;\n \n@@ -1539,7 +1511,7 @@ noce_try_abs (if_info)\n     }\n   else\n     return FALSE;\n-   \n+\n   cond = noce_get_alt_condition (if_info, b, &earliest);\n   if (!cond)\n     return FALSE;\n@@ -1560,7 +1532,7 @@ noce_try_abs (if_info)\n       for (insn = earliest;\n \t   insn != if_info->test_bb->head;\n \t   insn = PREV_INSN (insn))\n-\tif (INSN_P (insn) \n+\tif (INSN_P (insn)\n \t    && ((note = find_reg_note (insn, REG_EQUAL, c))\n \t\t|| (note = find_reg_note (insn, REG_EQUIV, c))))\n \t  break;\n@@ -1574,7 +1546,7 @@ noce_try_abs (if_info)\n     c = get_pool_constant (XEXP (c, 0));\n \n   /* Work around funny ideas get_condition has wrt canonicalization.\n-     Note that these rtx constants are known to be CONST_INT, and \n+     Note that these rtx constants are known to be CONST_INT, and\n      therefore imply integer comparisons.  */\n   if (c == constm1_rtx && GET_CODE (cond) == GT)\n     ;\n@@ -1620,7 +1592,7 @@ noce_try_abs (if_info)\n     noce_emit_move_insn (if_info->x, target);\n \n   seq = get_insns ();\n-  end_sequence ();  \n+  end_sequence ();\n \n   if (seq_contains_jump (seq))\n     return FALSE;\n@@ -1636,9 +1608,7 @@ noce_try_abs (if_info)\n    valid at JUMP, instead of at EARLIEST.  */\n \n static rtx\n-noce_get_condition (jump, earliest)\n-     rtx jump;\n-     rtx *earliest;\n+noce_get_condition (rtx jump, rtx *earliest)\n {\n   rtx cond, set, tmp, insn;\n   bool reverse;\n@@ -1704,8 +1674,7 @@ noce_get_condition (jump, earliest)\n /* Return true if OP is ok for if-then-else processing.  */\n \n static int\n-noce_operand_ok (op)\n-     rtx op;\n+noce_operand_ok (rtx op)\n {\n   /* We special-case memories, so handle any of them with\n      no address side effects.  */\n@@ -1723,8 +1692,7 @@ noce_operand_ok (op)\n    successful at converting the block.  */\n \n static int\n-noce_process_if_block (ce_info)\n-     struct ce_if_block * ce_info;\n+noce_process_if_block (struct ce_if_block * ce_info)\n {\n   basic_block test_bb = ce_info->test_bb;\t/* test block */\n   basic_block then_bb = ce_info->then_bb;\t/* THEN */\n@@ -1824,7 +1792,7 @@ noce_process_if_block (ce_info)\n \n   /* If x has side effects then only the if-then-else form is safe to\n      convert.  But even in that case we would need to restore any notes\n-     (such as REG_INC) at then end.  That can be tricky if \n+     (such as REG_INC) at then end.  That can be tricky if\n      noce_emit_move_insn expands to more than one insn, so disable the\n      optimization entirely for now if there are side effects.  */\n   if (side_effects_p (x))\n@@ -1890,7 +1858,7 @@ noce_process_if_block (ce_info)\n \t x must be executed twice.  */\n       else if (insn_b && side_effects_p (orig_x))\n \treturn FALSE;\n-\t\n+\n       x = orig_x;\n       goto success;\n     }\n@@ -1958,8 +1926,7 @@ noce_process_if_block (ce_info)\n    straight line code.  Return true if successful.  */\n \n static int\n-process_if_block (ce_info)\n-     struct ce_if_block * ce_info;\n+process_if_block (struct ce_if_block * ce_info)\n {\n   if (! reload_completed\n       && noce_process_if_block (ce_info))\n@@ -1989,8 +1956,7 @@ process_if_block (ce_info)\n /* Merge the blocks and mark for local life update.  */\n \n static void\n-merge_if_block (ce_info)\n-     struct ce_if_block * ce_info;\n+merge_if_block (struct ce_if_block * ce_info)\n {\n   basic_block test_bb = ce_info->test_bb;\t/* last test block */\n   basic_block then_bb = ce_info->then_bb;\t/* THEN */\n@@ -2009,7 +1975,7 @@ merge_if_block (ce_info)\n       basic_block bb = test_bb;\n       basic_block last_test_bb = ce_info->last_test_bb;\n       basic_block fallthru = block_fallthru (bb);\n-      \n+\n       do\n \t{\n \t  bb = fallthru;\n@@ -2088,7 +2054,7 @@ merge_if_block (ce_info)\n      Since we've already merged the TEST, THEN and ELSE blocks, we should\n      have only one remaining edge from our if-then-else diamond.  If there\n      is more than one remaining edge, it must come from elsewhere.  There\n-     may be zero incoming edges if the THEN block didn't actually join \n+     may be zero incoming edges if the THEN block didn't actually join\n      back up (as with a call to abort).  */\n   else if ((join_bb->pred == NULL\n \t    || join_bb->pred->pred_next == NULL)\n@@ -2128,9 +2094,7 @@ merge_if_block (ce_info)\n    first block if some transformation was done.  Return NULL otherwise.  */\n \n static basic_block\n-find_if_header (test_bb, pass)\n-     basic_block test_bb;\n-     int pass;\n+find_if_header (basic_block test_bb, int pass)\n {\n   ce_if_block_t ce_info;\n   edge then_edge;\n@@ -2200,9 +2164,7 @@ find_if_header (test_bb, pass)\n    of non-note, non-jump, non-USE/CLOBBER insns in the block.  */\n \n static int\n-block_jumps_and_fallthru_p (cur_bb, target_bb)\n-     basic_block cur_bb;\n-     basic_block target_bb;\n+block_jumps_and_fallthru_p (basic_block cur_bb, basic_block target_bb)\n {\n   edge cur_edge;\n   int fallthru_p = FALSE;\n@@ -2271,8 +2233,7 @@ block_jumps_and_fallthru_p (cur_bb, target_bb)\n    Return TRUE if we were successful at converting the block.  */\n \n static int\n-find_if_block (ce_info)\n-     struct ce_if_block * ce_info;\n+find_if_block (struct ce_if_block * ce_info)\n {\n   basic_block test_bb = ce_info->test_bb;\n   basic_block then_bb = ce_info->then_bb;\n@@ -2308,7 +2269,7 @@ find_if_block (ce_info)\n \t}\n       else if ((n_insns = block_jumps_and_fallthru_p (bb, then_bb)) >= 0)\n \t{\n-\t  ce_info->and_and_p = FALSE;\t  \n+\t  ce_info->and_and_p = FALSE;\n \t  target_bb = then_bb;\n \t}\n       else\n@@ -2429,7 +2390,7 @@ find_if_block (ce_info)\n \n   /* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */\n   else\n-    return FALSE;\t   \n+    return FALSE;\n \n   num_possible_if_blocks++;\n \n@@ -2491,9 +2452,7 @@ find_if_block (ce_info)\n    to a trap, into a conditional trap.  */\n \n static int\n-find_cond_trap (test_bb, then_edge, else_edge)\n-     basic_block test_bb;\n-     edge then_edge, else_edge;\n+find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n {\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n@@ -2589,12 +2548,11 @@ find_cond_trap (test_bb, then_edge, else_edge)\n   return TRUE;\n }\n \n-/* Subroutine of find_cond_trap: if BB contains only a trap insn, \n+/* Subroutine of find_cond_trap: if BB contains only a trap insn,\n    return it.  */\n \n static rtx\n-block_has_only_trap (bb)\n-     basic_block bb;\n+block_has_only_trap (basic_block bb)\n {\n   rtx trap;\n \n@@ -2694,9 +2652,7 @@ block_has_only_trap (bb)\n /* Tests for case 1 above.  */\n \n static int\n-find_if_case_1 (test_bb, then_edge, else_edge)\n-      basic_block test_bb;\n-      edge then_edge, else_edge;\n+find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n {\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest, new_bb;\n@@ -2730,7 +2686,7 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */\n-  if (! dead_or_predicable (test_bb, then_bb, else_bb, \n+  if (! dead_or_predicable (test_bb, then_bb, else_bb,\n \t\t\t    then_bb->succ->dest, 1))\n     return FALSE;\n \n@@ -2740,7 +2696,7 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   bitmap_operation (test_bb->global_live_at_end,\n \t\t    else_bb->global_live_at_start,\n \t\t    then_bb->global_live_at_end, BITMAP_IOR);\n-  \n+\n   new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb), else_bb);\n   then_bb_index = then_bb->index;\n   if (post_dominators)\n@@ -2768,9 +2724,7 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n /* Test for case 2 above.  */\n \n static int\n-find_if_case_2 (test_bb, then_edge, else_edge)\n-      basic_block test_bb;\n-      edge then_edge, else_edge;\n+find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n {\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n@@ -2798,7 +2752,7 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n     ;\n   else if (else_succ->dest->index < 0\n-\t   || dominated_by_p (post_dominators, then_bb, \n+\t   || dominated_by_p (post_dominators, then_bb,\n \t\t\t      else_succ->dest))\n     ;\n   else\n@@ -2824,7 +2778,7 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   bitmap_operation (test_bb->global_live_at_end,\n \t\t    then_bb->global_live_at_start,\n \t\t    else_bb->global_live_at_end, BITMAP_IOR);\n-  \n+\n   if (post_dominators)\n     delete_from_dominance_info (post_dominators, else_bb);\n   delete_block (else_bb);\n@@ -2842,9 +2796,7 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n    Return 1 if a memory is found.  */\n \n static int\n-find_memory (px, data)\n-     rtx *px;\n-     void *data ATTRIBUTE_UNUSED;\n+find_memory (rtx *px, void *data ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (*px) == MEM;\n }\n@@ -2858,10 +2810,8 @@ find_memory (px, data)\n    REVERSEP is true if the sense of the branch should be reversed.  */\n \n static int\n-dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n-     basic_block test_bb, merge_bb, other_bb;\n-     basic_block new_dest;\n-     int reversep;\n+dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n+\t\t    basic_block other_bb, basic_block new_dest, int reversep)\n {\n   rtx head, end, jump, earliest, old_dest, new_label = NULL_RTX;\n \n@@ -2986,7 +2936,7 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n       test_set = INITIALIZE_REG_SET (test_set_head);\n \n       /* ??? bb->local_set is only valid during calculate_global_regs_live,\n-\t so we must recompute usage for MERGE_BB.  Not so bad, I suppose, \n+\t so we must recompute usage for MERGE_BB.  Not so bad, I suppose,\n          since we've already asserted that MERGE_BB is small.  */\n       propagate_block (merge_bb, tmp, merge_set, merge_set, 0);\n \n@@ -3117,8 +3067,7 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n /* Main entry point for all if-conversion.  */\n \n void\n-if_convert (x_life_data_ok)\n-     int x_life_data_ok;\n+if_convert (int x_life_data_ok)\n {\n   basic_block bb;\n   int pass;"}, {"sha": "f422f74f98f35ae54a3c7cd74316a78dd9a78535", "filename": "gcc/input.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -25,7 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* The data structure used to record a location in a translation unit.  */\n struct location_s GTY (())\n {\n-  /* The name of the source file involved.  */     \n+  /* The name of the source file involved.  */\n   const char *file;\n \n   /* The line-location in the source file.  */\n@@ -53,7 +53,7 @@ extern struct file_stack *input_file_stack;\n /* Incremented on each change to input_file_stack.  */\n extern int input_file_stack_tick;\n \n-extern void push_srcloc PARAMS ((const char *name, int line));\n-extern void pop_srcloc PARAMS ((void));\n+extern void push_srcloc (const char *name, int line);\n+extern void pop_srcloc (void);\n \n #endif"}, {"sha": "b8ec068313b49ebf8665cd8231b040457fed0fdb", "filename": "gcc/integrate.c", "status": "modified", "additions": 59, "deletions": 132, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -74,28 +74,23 @@ typedef struct initial_value_struct GTY(()) {\n   initial_value_pair * GTY ((length (\"%h.num_entries\"))) entries;\n } initial_value_struct;\n \n-static void setup_initial_hard_reg_value_integration PARAMS ((struct function *, struct inline_remap *));\n-\n-static rtvec initialize_for_inline\tPARAMS ((tree));\n-static void note_modified_parmregs\tPARAMS ((rtx, rtx, void *));\n-static void integrate_parm_decls\tPARAMS ((tree, struct inline_remap *,\n-\t\t\t\t\t\t rtvec));\n-static tree integrate_decl_tree\t\tPARAMS ((tree,\n-\t\t\t\t\t\t struct inline_remap *));\n-static void subst_constants\t\tPARAMS ((rtx *, rtx,\n-\t\t\t\t\t\t struct inline_remap *, int));\n-static void set_block_origin_self\tPARAMS ((tree));\n-static void set_block_abstract_flags\tPARAMS ((tree, int));\n-static void process_reg_param\t\tPARAMS ((struct inline_remap *, rtx,\n-\t\t\t\t\t\t rtx));\n-static void mark_stores                 PARAMS ((rtx, rtx, void *));\n-static void save_parm_insns\t\tPARAMS ((rtx, rtx));\n-static void copy_insn_list              PARAMS ((rtx, struct inline_remap *,\n-\t\t\t\t\t\t rtx));\n-static void copy_insn_notes\t\tPARAMS ((rtx, struct inline_remap *,\n-\t\t\t\t\t\t int));\n-static int compare_blocks               PARAMS ((const void *, const void *));\n-static int find_block                   PARAMS ((const void *, const void *));\n+static void setup_initial_hard_reg_value_integration (struct function *,\n+\t\t\t\t\t\t      struct inline_remap *);\n+\n+static rtvec initialize_for_inline (tree);\n+static void note_modified_parmregs (rtx, rtx, void *);\n+static void integrate_parm_decls (tree, struct inline_remap *, rtvec);\n+static tree integrate_decl_tree (tree, struct inline_remap *);\n+static void subst_constants (rtx *, rtx, struct inline_remap *, int);\n+static void set_block_origin_self (tree);\n+static void set_block_abstract_flags (tree, int);\n+static void process_reg_param (struct inline_remap *, rtx, rtx);\n+static void mark_stores (rtx, rtx, void *);\n+static void save_parm_insns (rtx, rtx);\n+static void copy_insn_list (rtx, struct inline_remap *, rtx);\n+static void copy_insn_notes (rtx, struct inline_remap *, int);\n+static int compare_blocks (const void *, const void *);\n+static int find_block (const void *, const void *);\n \n /* Used by copy_rtx_and_substitute; this indicates whether the function is\n    called for the purpose of inlining or some other purpose (i.e. loop\n@@ -109,9 +104,7 @@ static struct function *inlining = 0;\n    explosions when the label_map gets very large.  */\n \n rtx\n-get_label_from_map (map, i)\n-     struct inline_remap *map;\n-     int i;\n+get_label_from_map (struct inline_remap *map, int i)\n {\n   rtx x = map->label_map[i];\n \n@@ -124,8 +117,7 @@ get_label_from_map (map, i)\n /* Return false if the function FNDECL cannot be inlined on account of its\n    attributes, true otherwise.  */\n bool\n-function_attribute_inlinable_p (fndecl)\n-     tree fndecl;\n+function_attribute_inlinable_p (tree fndecl)\n {\n   if (targetm.attribute_table)\n     {\n@@ -151,8 +143,7 @@ function_attribute_inlinable_p (fndecl)\n    for the function's name.  */\n \n const char *\n-function_cannot_inline_p (fndecl)\n-     tree fndecl;\n+function_cannot_inline_p (tree fndecl)\n {\n   rtx insn;\n   tree last = tree_last (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n@@ -285,8 +276,7 @@ static int in_nonparm_insns;\n    needed to save FNDECL's insns and info for future inline expansion.  */\n \n static rtvec\n-initialize_for_inline (fndecl)\n-     tree fndecl;\n+initialize_for_inline (tree fndecl)\n {\n   int i;\n   rtvec arg_vector;\n@@ -337,10 +327,7 @@ initialize_for_inline (fndecl)\n    TO_FN.  */\n \n tree\n-copy_decl_for_inlining (decl, from_fn, to_fn)\n-     tree decl;\n-     tree from_fn;\n-     tree to_fn;\n+copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n {\n   tree copy;\n \n@@ -441,8 +428,7 @@ copy_decl_for_inlining (decl, from_fn, to_fn)\n    functions at the end of compilation.  */\n \n void\n-save_for_inline (fndecl)\n-     tree fndecl;\n+save_for_inline (tree fndecl)\n {\n   rtx insn;\n   rtvec argvec;\n@@ -518,9 +504,7 @@ save_for_inline (fndecl)\n    register and track the new register's life.  */\n \n static void\n-save_parm_insns (insn, first_nonparm_insn)\n-     rtx insn;\n-     rtx first_nonparm_insn;\n+save_parm_insns (rtx insn, rtx first_nonparm_insn)\n {\n   if (insn == NULL_RTX)\n     return;\n@@ -554,10 +538,7 @@ save_parm_insns (insn, first_nonparm_insn)\n /* Note whether a parameter is modified or not.  */\n \n static void\n-note_modified_parmregs (reg, x, data)\n-     rtx reg;\n-     rtx x ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+note_modified_parmregs (rtx reg, rtx x ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (reg) == REG && in_nonparm_insns\n       && REGNO (reg) < max_parm_reg\n@@ -588,9 +569,7 @@ varray_type global_const_equiv_varray;\n    Also, don't allow hard registers here; they might not be valid when\n    substituted into insns.  */\n static void\n-process_reg_param (map, loc, copy)\n-     struct inline_remap *map;\n-     rtx loc, copy;\n+process_reg_param (struct inline_remap *map, rtx loc, rtx copy)\n {\n   if ((GET_CODE (copy) != REG && GET_CODE (copy) != SUBREG)\n       || (GET_CODE (copy) == REG && REG_USERVAR_P (loc)\n@@ -612,9 +591,7 @@ process_reg_param (map, loc, copy)\n    two pointers, because it may overflow sizeof(int).  */\n \n static int\n-compare_blocks (v1, v2)\n-     const void *v1;\n-     const void *v2;\n+compare_blocks (const void *v1, const void *v2)\n {\n   tree b1 = *((const tree *) v1);\n   tree b2 = *((const tree *) v2);\n@@ -630,9 +607,7 @@ compare_blocks (v1, v2)\n    an original block; the second to a remapped equivalent.  */\n \n static int\n-find_block (v1, v2)\n-     const void *v1;\n-     const void *v2;\n+find_block (const void *v1, const void *v2)\n {\n   const union tree_node *b1 = (const union tree_node *) v1;\n   tree b2 = *((const tree *) v2);\n@@ -658,13 +633,8 @@ find_block (v1, v2)\n    else an rtx for where the value is stored.  */\n \n rtx\n-expand_inline_function (fndecl, parms, target, ignore, type,\n-\t\t\tstructure_value_addr)\n-     tree fndecl, parms;\n-     rtx target;\n-     int ignore;\n-     tree type;\n-     rtx structure_value_addr;\n+expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n+\t\t\ttree type, rtx structure_value_addr)\n {\n   struct function *inlining_previous;\n   struct function *inl_f = DECL_SAVED_INSNS (fndecl);\n@@ -812,10 +782,10 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n       /* If the formal type was const but the actual was not, we might\n \t end up here with an rtx wrongly tagged unchanging in the caller's\n \t context.  Fix that.  */\n-      if (arg_vals[i] != 0 \n+      if (arg_vals[i] != 0\n \t  && (GET_CODE (arg_vals[i]) == REG || GET_CODE (arg_vals[i]) == MEM)\n \t  && ! TREE_READONLY (TREE_VALUE (actual)))\n-\tRTX_UNCHANGING_P (arg_vals[i]) = 0;      \n+\tRTX_UNCHANGING_P (arg_vals[i]) = 0;\n \n       if (arg_vals[i] != 0\n \t  && (! TREE_READONLY (formal)\n@@ -1039,7 +1009,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n      REG_FUNCTION_RETURN_VALUE_P.  */\n \n   map->inline_target = 0;\n-  loc = (DECL_RTL_SET_P (DECL_RESULT (fndecl)) \n+  loc = (DECL_RTL_SET_P (DECL_RESULT (fndecl))\n \t ? DECL_RTL (DECL_RESULT (fndecl)) : NULL_RTX);\n \n   if (TYPE_MODE (type) == VOIDmode)\n@@ -1348,10 +1318,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n    register for the function.  */\n \n static void\n-copy_insn_list (insns, map, static_chain_value)\n-     rtx insns;\n-     struct inline_remap *map;\n-     rtx static_chain_value;\n+copy_insn_list (rtx insns, struct inline_remap *map, rtx static_chain_value)\n {\n   int i;\n   rtx insn;\n@@ -1732,10 +1699,7 @@ copy_insn_list (insns, map, static_chain_value)\n    that are valid across the entire function.  */\n \n static void\n-copy_insn_notes (insns, map, eh_region_offset)\n-     rtx insns;\n-     struct inline_remap *map;\n-     int eh_region_offset;\n+copy_insn_notes (rtx insns, struct inline_remap *map, int eh_region_offset)\n {\n   rtx insn, new_insn;\n \n@@ -1791,10 +1755,7 @@ copy_insn_notes (insns, map, eh_region_offset)\n    push all of those decls and give each one the corresponding home.  */\n \n static void\n-integrate_parm_decls (args, map, arg_vector)\n-     tree args;\n-     struct inline_remap *map;\n-     rtvec arg_vector;\n+integrate_parm_decls (tree args, struct inline_remap *map, rtvec arg_vector)\n {\n   tree tail;\n   int i;\n@@ -1827,9 +1788,7 @@ integrate_parm_decls (args, map, arg_vector)\n    no mapping is necessary.  */\n \n static tree\n-integrate_decl_tree (let, map)\n-     tree let;\n-     struct inline_remap *map;\n+integrate_decl_tree (tree let, struct inline_remap *map)\n {\n   tree t;\n   tree new_block;\n@@ -1898,10 +1857,7 @@ integrate_decl_tree (let, map)\n    calling `force_const_mem'.  */\n \n rtx\n-copy_rtx_and_substitute (orig, map, for_lhs)\n-     rtx orig;\n-     struct inline_remap *map;\n-     int for_lhs;\n+copy_rtx_and_substitute (rtx orig, struct inline_remap *map, int for_lhs)\n {\n   rtx copy, temp;\n   int i, j;\n@@ -2050,7 +2006,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t    {\n \t      if (!map->leaf_reg_map[regno][mode])\n \t\tmap->leaf_reg_map[regno][mode] = gen_rtx_REG (mode, regno);\n-\t      return map->leaf_reg_map[regno][mode]; \n+\t      return map->leaf_reg_map[regno][mode];\n \t    }\n #endif\n \t  else\n@@ -2280,7 +2236,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t  MEM_COPY_ATTRIBUTES (copy, XEXP (orig, 0));\n \n \t  return\n-\t    gen_rtx_CALL (GET_MODE (orig), copy, \n+\t    gen_rtx_CALL (GET_MODE (orig), copy,\n \t\t\t  copy_rtx_and_substitute (XEXP (orig, 1), map, 0));\n \t}\n       break;\n@@ -2447,9 +2403,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n /* Substitute known constant values into INSN, if that is valid.  */\n \n void\n-try_constants (insn, map)\n-     rtx insn;\n-     struct inline_remap *map;\n+try_constants (rtx insn, struct inline_remap *map)\n {\n   int i;\n \n@@ -2463,7 +2417,7 @@ try_constants (insn, map)\n   apply_change_group ();\n   subst_constants (&PATTERN (insn), insn, map, 0);\n   apply_change_group ();\n-  \n+\n   /* Enforce consistency between the addresses in the regular insn flow\n      and the ones in CALL_INSN_FUNCTION_USAGE lists, if any.  */\n   if (GET_CODE (insn) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (insn))\n@@ -2521,11 +2475,7 @@ try_constants (insn, map)\n    If MEMONLY is nonzero, only make changes inside a MEM.  */\n \n static void\n-subst_constants (loc, insn, map, memonly)\n-     rtx *loc;\n-     rtx insn;\n-     struct inline_remap *map;\n-     int memonly;\n+subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n {\n   rtx x = *loc;\n   int i, j;\n@@ -2599,7 +2549,7 @@ subst_constants (loc, insn, map, memonly)\n \t     integral mode and extracting the low part.  */\n \t  subst_constants (&inner, NULL_RTX, map, 0);\n \t  new = simplify_gen_subreg (GET_MODE (x), inner,\n-\t\t\t \t     GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t     GET_MODE (SUBREG_REG (x)),\n \t\t\t\t     SUBREG_BYTE (x));\n \n \t  if (new)\n@@ -2856,10 +2806,7 @@ subst_constants (loc, insn, map, memonly)\n    called from note_stores with parts of the new insn.  */\n \n static void\n-mark_stores (dest, x, data)\n-     rtx dest;\n-     rtx x ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+mark_stores (rtx dest, rtx x ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n {\n   int regno = -1;\n   enum machine_mode mode = VOIDmode;\n@@ -2908,8 +2855,7 @@ mark_stores (dest, x, data)\n    values to point to themselves.  */\n \n static void\n-set_block_origin_self (stmt)\n-     tree stmt;\n+set_block_origin_self (tree stmt)\n {\n   if (BLOCK_ABSTRACT_ORIGIN (stmt) == NULL_TREE)\n     {\n@@ -2947,8 +2893,7 @@ set_block_origin_self (stmt)\n    point to themselves.  */\n \n void\n-set_decl_origin_self (decl)\n-     tree decl;\n+set_decl_origin_self (tree decl)\n {\n   if (DECL_ABSTRACT_ORIGIN (decl) == NULL_TREE)\n     {\n@@ -2972,9 +2917,7 @@ set_decl_origin_self (decl)\n    (recursively) which are contained therein.  */\n \n static void\n-set_block_abstract_flags (stmt, setting)\n-     tree stmt;\n-     int setting;\n+set_block_abstract_flags (tree stmt, int setting)\n {\n   tree local_decl;\n   tree subblock;\n@@ -2999,9 +2942,7 @@ set_block_abstract_flags (stmt, setting)\n    blocks and sub-blocks (recursively) to the same setting.  */\n \n void\n-set_decl_abstract_flags (decl, setting)\n-     tree decl;\n-     int setting;\n+set_decl_abstract_flags (tree decl, int setting)\n {\n   DECL_ABSTRACT (decl) = setting;\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -3023,8 +2964,7 @@ set_decl_abstract_flags (decl, setting)\n static GTY(()) struct function *old_cfun;\n \n void\n-output_inline_function (fndecl)\n-     tree fndecl;\n+output_inline_function (tree fndecl)\n {\n   enum debug_info_type old_write_symbols = write_symbols;\n   const struct gcc_debug_hooks *const old_debug_hooks = debug_hooks;\n@@ -3067,9 +3007,7 @@ output_inline_function (fndecl)\n    the function.  */\n \n rtx\n-get_hard_reg_initial_reg (fun, reg)\n-     struct function *fun;\n-     rtx reg;\n+get_hard_reg_initial_reg (struct function *fun, rtx reg)\n {\n   struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n   int i;\n@@ -3085,9 +3023,7 @@ get_hard_reg_initial_reg (fun, reg)\n }\n \n rtx\n-has_func_hard_reg_initial_val (fun, reg)\n-     struct function *fun;\n-     rtx reg;\n+has_func_hard_reg_initial_val (struct function *fun, rtx reg)\n {\n   struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n   int i;\n@@ -3103,9 +3039,7 @@ has_func_hard_reg_initial_val (fun, reg)\n }\n \n rtx\n-get_func_hard_reg_initial_val (fun, reg)\n-     struct function *fun;\n-     rtx reg;\n+get_func_hard_reg_initial_val (struct function *fun, rtx reg)\n {\n   struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n   rtx rv = has_func_hard_reg_initial_val (fun, reg);\n@@ -3125,7 +3059,7 @@ get_func_hard_reg_initial_val (fun, reg)\n   if (ivs->num_entries >= ivs->max_entries)\n     {\n       ivs->max_entries += 5;\n-      ivs->entries = \n+      ivs->entries =\n \t(initial_value_pair *) ggc_realloc (ivs->entries,\n \t\t\t\t\t    ivs->max_entries\n \t\t\t\t\t    * sizeof (initial_value_pair));\n@@ -3138,25 +3072,19 @@ get_func_hard_reg_initial_val (fun, reg)\n }\n \n rtx\n-get_hard_reg_initial_val (mode, regno)\n-     enum machine_mode mode;\n-     int regno;\n+get_hard_reg_initial_val (enum machine_mode mode, int regno)\n {\n   return get_func_hard_reg_initial_val (cfun, gen_rtx_REG (mode, regno));\n }\n \n rtx\n-has_hard_reg_initial_val (mode, regno)\n-     enum machine_mode mode;\n-     int regno;\n+has_hard_reg_initial_val (enum machine_mode mode, int regno)\n {\n   return has_func_hard_reg_initial_val (cfun, gen_rtx_REG (mode, regno));\n }\n \n static void\n-setup_initial_hard_reg_value_integration (inl_f, remap)\n-     struct function *inl_f;\n-     struct inline_remap *remap;\n+setup_initial_hard_reg_value_integration (struct function *inl_f, struct inline_remap *remap)\n {\n   struct initial_value_struct *ivs = inl_f->hard_reg_initial_vals;\n   int i;\n@@ -3171,7 +3099,7 @@ setup_initial_hard_reg_value_integration (inl_f, remap)\n \n \n void\n-emit_initial_value_sets ()\n+emit_initial_value_sets (void)\n {\n   struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;\n   int i;\n@@ -3192,8 +3120,7 @@ emit_initial_value_sets ()\n /* If the backend knows where to allocate pseudos for hard\n    register initial values, register these allocations now.  */\n void\n-allocate_initial_values (reg_equiv_memory_loc)\n-     rtx *reg_equiv_memory_loc ATTRIBUTE_UNUSED;\n+allocate_initial_values (rtx *reg_equiv_memory_loc ATTRIBUTE_UNUSED)\n {\n #ifdef ALLOCATE_INITIAL_VALUE\n   struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;"}, {"sha": "f5fbaabba13bd433a77d1457eef18f8a7377dfb8", "filename": "gcc/integrate.h", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d088deebefc04b8c99fe00e4df4e9c4ddacec2d/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=1d088deebefc04b8c99fe00e4df4e9c4ddacec2d", "patch": "@@ -1,5 +1,6 @@\n /* Function integration definitions for GCC\n-   Copyright (C) 1990, 1995, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 1995, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -112,7 +113,7 @@ struct inline_remap\n       rtx dest;\n       rtx equiv;\n     }  equiv_sets[MAX_RECOG_OPERANDS];\n-  /* Record the last thing assigned to pc.  This is used for folded \n+  /* Record the last thing assigned to pc.  This is used for folded\n      conditional branch insns.  */\n   rtx last_pc_value;\n #ifdef HAVE_cc0\n@@ -127,41 +128,41 @@ struct inline_remap\n \n /* Return a copy of an rtx (as needed), substituting pseudo-register,\n    labels, and frame-pointer offsets as necessary.  */\n-extern rtx copy_rtx_and_substitute PARAMS ((rtx, struct inline_remap *, int));\n+extern rtx copy_rtx_and_substitute (rtx, struct inline_remap *, int);\n \n /* Return a pseudo that corresponds to the value in the specified hard\n    reg as of the start of the function (for inlined functions, the\n    value at the start of the parent function).  */\n-extern rtx get_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n+extern rtx get_hard_reg_initial_val (enum machine_mode, int);\n /* Likewise, but for a different than the current function, or\n    arbitrary expression.  */\n-extern rtx get_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n+extern rtx get_func_hard_reg_initial_val (struct function *, rtx);\n /* Likewise, but iff someone else has caused it to become allocated.  */\n-extern rtx has_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n+extern rtx has_func_hard_reg_initial_val (struct function *, rtx);\n /* Likewise, but for common cases.  */\n-extern rtx has_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n+extern rtx has_hard_reg_initial_val (enum machine_mode, int);\n /* If a pseudo represents an initial hard reg (or expression), return\n    it, else return NULL_RTX.  */\n-extern rtx get_hard_reg_initial_reg\t\tPARAMS ((struct function *, rtx));\n+extern rtx get_hard_reg_initial_reg (struct function *, rtx);\n /* Called from rest_of_compilation.  */\n-extern void emit_initial_value_sets\t\tPARAMS ((void));\n-extern void allocate_initial_values\t\tPARAMS ((rtx *));\n+extern void emit_initial_value_sets (void);\n+extern void allocate_initial_values (rtx *);\n \n /* Copy a declaration when one function is substituted inline into\n    another.  */\n-extern union tree_node *copy_decl_for_inlining PARAMS ((union tree_node *,\n-\t\t\t\t\t\t      union tree_node *,\n-\t\t\t\t\t\t      union tree_node *));\n+extern union tree_node *copy_decl_for_inlining (union tree_node *,\n+\t\t\t\t\t\tunion tree_node *,\n+\t\t\t\t\t\tunion tree_node *);\n \n /* Check whether there's any attribute in a function declaration that\n    makes the function uninlinable.  Returns false if it finds any,\n    true otherwise.  */\n-extern bool function_attribute_inlinable_p PARAMS ((union tree_node *));\n+extern bool function_attribute_inlinable_p (union tree_node *);\n \n-extern void try_constants PARAMS ((rtx, struct inline_remap *));\n+extern void try_constants (rtx, struct inline_remap *);\n \n /* Return the label indicated.  */\n-extern rtx get_label_from_map PARAMS ((struct inline_remap *, int));\n+extern rtx get_label_from_map (struct inline_remap *, int);\n \n /* Set the label indicated.  */\n #define set_label_in_map(MAP, I, X) ((MAP)->label_map[I] = (X))"}]}