{"sha": "0bddee8e5451093d776659f0fe401b08b2199eb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJkZGVlOGU1NDUxMDkzZDc3NjY1OWYwZmU0MDFiMDhiMjE5OWViNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-06-21T14:38:38Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-06-21T14:38:38Z"}, "message": "gensupport.c (add_define_attr): New static function.\n\n\t* gensupport.c (add_define_attr): New static function.\n\t(is_predicable): Allow multi-alternative lists for the \"predicable\"\n\tattribute.\n\t(modify_attr_enabled_ce, alter_attrs_for_insn): New static functions.\n\t(process_one_cond_exec): Call alter_attrs_for_insn.\n\t* doc/md.texi (Defining Attributes): Mention some standard names.\n\t(Conditional Execution): Update documentation for \"predicable\".\n\nFrom-SVN: r175263", "tree": {"sha": "6c18112608b45b07352ab4067660097dfe524dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c18112608b45b07352ab4067660097dfe524dff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bddee8e5451093d776659f0fe401b08b2199eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bddee8e5451093d776659f0fe401b08b2199eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bddee8e5451093d776659f0fe401b08b2199eb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bddee8e5451093d776659f0fe401b08b2199eb5/comments", "author": null, "committer": null, "parents": [{"sha": "e4d48a4dd55f96d6f7bb11b4efcc1ee7d8af0147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d48a4dd55f96d6f7bb11b4efcc1ee7d8af0147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4d48a4dd55f96d6f7bb11b4efcc1ee7d8af0147"}], "stats": {"total": 205, "additions": 187, "deletions": 18}, "files": [{"sha": "26bfc6f5c1a11a05bffffbb44fb5a6428dc198a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bddee8e5451093d776659f0fe401b08b2199eb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bddee8e5451093d776659f0fe401b08b2199eb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bddee8e5451093d776659f0fe401b08b2199eb5", "patch": "@@ -1,5 +1,13 @@\n 2011-06-21  Bernd Schmidt  <bernds@codesourcery.com>\n \n+\t* gensupport.c (add_define_attr): New static function.\n+\t(is_predicable): Allow multi-alternative lists for the \"predicable\"\n+\tattribute.\n+\t(modify_attr_enabled_ce, alter_attrs_for_insn): New static functions.\n+\t(process_one_cond_exec): Call alter_attrs_for_insn.\n+\t* doc/md.texi (Defining Attributes): Mention some standard names.\n+\t(Conditional Execution): Update documentation for \"predicable\".\n+\n \t* doc/extend.texi (__builtin_clrsb, __builtin_clrsbl,\n \t__builtin_clrsbll): Document.\n \t* doc/rtl.texi (clrsb): New entry."}, {"sha": "65e4070d91da83184c1f4d8579c4faf57fb62137", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bddee8e5451093d776659f0fe401b08b2199eb5/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bddee8e5451093d776659f0fe401b08b2199eb5/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0bddee8e5451093d776659f0fe401b08b2199eb5", "patch": "@@ -6745,6 +6745,14 @@ by the target machine.  It looks like:\n @end smallexample\n \n @var{name} is a string specifying the name of the attribute being defined.\n+Some attributes are used in a special way by the rest of the compiler. The\n+@code{enabled} attribute can be used to conditionally enable or disable\n+insn alternatives (@pxref{Disable Insn Alternatives}). The @code{predicable}\n+attribute, together with a suitable @code{define_cond_exec}\n+(@pxref{Conditional Execution}), can be used to automatically generate\n+conditional variants of instruction patterns. The compiler internally uses\n+the names @code{ce_enabled} and @code{nonce_enabled}, so they should not be\n+used elsewhere as alternative names.\n \n @var{list-of-values} is either a string that specifies a comma-separated\n list of values that can be assigned to the attribute, or a null string to\n@@ -7954,11 +7962,14 @@ if the current insn is predicated, and will otherwise be @code{NULL}.\n \n When @code{define_cond_exec} is used, an implicit reference to\n the @code{predicable} instruction attribute is made.\n-@xref{Insn Attributes}.  This attribute must be boolean (i.e.@: have\n-exactly two elements in its @var{list-of-values}).  Further, it must\n-not be used with complex expressions.  That is, the default and all\n-uses in the insns must be a simple constant, not dependent on the\n-alternative or anything else.\n+@xref{Insn Attributes}.  This attribute must be a boolean (i.e.@: have\n+exactly two elements in its @var{list-of-values}), with the possible\n+values being @code{no} and @code{yes}.  The default and all uses in\n+the insns must be a simple constant, not a complex expressions.  It\n+may, however, depend on the alternative, by using a comma-separated\n+list of values.  If that is the case, the port should also define an\n+@code{enabled} attribute (@pxref{Disable Insn Alternatives}), which\n+should also allow only @code{no} and @code{yes} as its values.\n \n For each @code{define_insn} for which the @code{predicable}\n attribute is true, a new @code{define_insn} pattern will be"}, {"sha": "e56291e3a383297084dd0116090557e56fc903f9", "filename": "gcc/gensupport.c", "status": "modified", "additions": 163, "deletions": 13, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bddee8e5451093d776659f0fe401b08b2199eb5/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bddee8e5451093d776659f0fe401b08b2199eb5/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=0bddee8e5451093d776659f0fe401b08b2199eb5", "patch": "@@ -368,6 +368,25 @@ queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n   return e;\n }\n \n+/* Build a define_attr for an binary attribute with name NAME and\n+   possible values \"yes\" and \"no\", and queue it.  */\n+static void\n+add_define_attr (const char *name)\n+{\n+  struct queue_elem *e = XNEW(struct queue_elem);\n+  rtx t1 = rtx_alloc (DEFINE_ATTR);\n+  XSTR (t1, 0) = name;\n+  XSTR (t1, 1) = \"no,yes\";\n+  XEXP (t1, 2) = rtx_alloc (CONST_STRING);\n+  XSTR (XEXP (t1, 2), 0) = \"yes\";\n+  e->data = t1;\n+  e->filename = \"built-in\";\n+  e->lineno = -1;\n+  e->next = define_attr_queue;\n+  define_attr_queue = e;\n+\n+}\n+\n /* Recursively remove constraints from an rtx.  */\n \n static void\n@@ -547,17 +566,10 @@ is_predicable (struct queue_elem *elem)\n   return predicable_default;\n \n  found:\n-  /* Verify that predicability does not vary on the alternative.  */\n-  /* ??? It should be possible to handle this by simply eliminating\n-     the non-predicable alternatives from the insn.  FRV would like\n-     to do this.  Delay this until we've got the basics solid.  */\n+  /* Find out which value we're looking at.  Multiple alternatives means at\n+     least one is predicable.  */\n   if (strchr (value, ',') != NULL)\n-    {\n-      error_with_line (elem->lineno, \"multiple alternatives for `predicable'\");\n-      return 0;\n-    }\n-\n-  /* Find out which value we're looking at.  */\n+    return 1;\n   if (strcmp (value, predicable_true) == 0)\n     return 1;\n   if (strcmp (value, predicable_false) == 0)\n@@ -798,6 +810,146 @@ alter_test_for_insn (struct queue_elem *ce_elem,\n \t\t\t    XSTR (insn_elem->data, 2));\n }\n \n+/* Modify VAL, which is an attribute expression for the \"enabled\" attribute,\n+   to take \"ce_enabled\" into account.  Return the new expression.  */\n+static rtx\n+modify_attr_enabled_ce (rtx val)\n+{\n+  rtx eq_attr, str;\n+  rtx ite;\n+  eq_attr = rtx_alloc (EQ_ATTR);\n+  ite = rtx_alloc (IF_THEN_ELSE);\n+  str = rtx_alloc (CONST_STRING);\n+\n+  XSTR (eq_attr, 0) = \"ce_enabled\";\n+  XSTR (eq_attr, 1) = \"yes\";\n+  XSTR (str, 0) = \"no\";\n+  XEXP (ite, 0) = eq_attr;\n+  XEXP (ite, 1) = val;\n+  XEXP (ite, 2) = str;\n+\n+  return ite;\n+}\n+\n+/* Alter the attribute vector of INSN, which is a COND_EXEC variant created\n+   from a define_insn pattern.  We must modify the \"predicable\" attribute\n+   to be named \"ce_enabled\", and also change any \"enabled\" attribute that's\n+   present so that it takes ce_enabled into account.\n+   We rely on the fact that INSN was created with copy_rtx, and modify data\n+   in-place.  */\n+\n+static void\n+alter_attrs_for_insn (rtx insn)\n+{\n+  static bool global_changes_made = false;\n+  rtvec vec = XVEC (insn, 4);\n+  rtvec new_vec;\n+  rtx val, set;\n+  int num_elem;\n+  int predicable_idx = -1;\n+  int enabled_idx = -1;\n+  int i;\n+\n+  if (! vec)\n+    return;\n+\n+  num_elem = GET_NUM_ELEM (vec);\n+  for (i = num_elem - 1; i >= 0; --i)\n+    {\n+      rtx sub = RTVEC_ELT (vec, i);\n+      switch (GET_CODE (sub))\n+\t{\n+\tcase SET_ATTR:\n+\t  if (strcmp (XSTR (sub, 0), \"predicable\") == 0)\n+\t    {\n+\t      predicable_idx = i;\n+\t      XSTR (sub, 0) = \"ce_enabled\";\n+\t    }\n+\t  else if (strcmp (XSTR (sub, 0), \"enabled\") == 0)\n+\t    {\n+\t      enabled_idx = i;\n+\t      XSTR (sub, 0) = \"nonce_enabled\";\n+\t    }\n+\t  break;\n+\n+\tcase SET_ATTR_ALTERNATIVE:\n+\t  if (strcmp (XSTR (sub, 0), \"predicable\") == 0)\n+\t    /* We already give an error elsewhere.  */\n+\t    return;\n+\t  else if (strcmp (XSTR (sub, 0), \"enabled\") == 0)\n+\t    {\n+\t      enabled_idx = i;\n+\t      XSTR (sub, 0) = \"nonce_enabled\";\n+\t    }\n+\t  break;\n+\n+\tcase SET:\n+\t  if (GET_CODE (SET_DEST (sub)) != ATTR)\n+\t    break;\n+\t  if (strcmp (XSTR (SET_DEST (sub), 0), \"predicable\") == 0)\n+\t    {\n+\t      sub = SET_SRC (sub);\n+\t      if (GET_CODE (sub) == CONST_STRING)\n+\t\t{\n+\t\t  predicable_idx = i;\n+\t\t  XSTR (sub, 0) = \"ce_enabled\";\n+\t\t}\n+\t      else\n+\t\t/* We already give an error elsewhere.  */\n+\t\treturn;\n+\t      break;\n+\t    }\n+\t  if (strcmp (XSTR (SET_DEST (sub), 0), \"enabled\") == 0)\n+\t    {\n+\t      enabled_idx = i;\n+\t      XSTR (SET_DEST (sub), 0) = \"nonce_enabled\";\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  if (predicable_idx == -1)\n+    return;\n+\n+  if (!global_changes_made)\n+    {\n+      struct queue_elem *elem;\n+      \n+      global_changes_made = true;\n+      add_define_attr (\"ce_enabled\");\n+      add_define_attr (\"nonce_enabled\");\n+\n+      for (elem = define_attr_queue; elem ; elem = elem->next)\n+\tif (strcmp (XSTR (elem->data, 0), \"enabled\") == 0)\n+\t  {\n+\t    XEXP (elem->data, 2)\n+\t      = modify_attr_enabled_ce (XEXP (elem->data, 2));\n+\t  }\n+    }\n+  if (enabled_idx == -1)\n+    return;\n+\n+  new_vec = rtvec_alloc (num_elem + 1);\n+  for (i = 0; i < num_elem; i++)\n+    RTVEC_ELT (new_vec, i) = RTVEC_ELT (vec, i);\n+  val = rtx_alloc (IF_THEN_ELSE);\n+  XEXP (val, 0) = rtx_alloc (EQ_ATTR);\n+  XEXP (val, 1) = rtx_alloc (CONST_STRING);\n+  XEXP (val, 2) = rtx_alloc (CONST_STRING);\n+  XSTR (XEXP (val, 0), 0) = \"nonce_enabled\";\n+  XSTR (XEXP (val, 0), 1) = \"yes\";\n+  XSTR (XEXP (val, 1), 0) = \"yes\";\n+  XSTR (XEXP (val, 2), 0) = \"no\";\n+  set = rtx_alloc (SET);\n+  SET_DEST (set) = rtx_alloc (ATTR);\n+  XSTR (SET_DEST (set), 0) = \"enabled\";\n+  SET_SRC (set) = modify_attr_enabled_ce (val);\n+  RTVEC_ELT (new_vec, i) = set;\n+  XVEC (insn, 4) = new_vec;\n+}\n+\n /* Adjust all of the operand numbers in SRC to match the shift they'll\n    get from an operand displacement of DISP.  Return a pointer after the\n    adjusted string.  */\n@@ -943,9 +1095,7 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n       XSTR (insn, 2) = alter_test_for_insn (ce_elem, insn_elem);\n       XTMPL (insn, 3) = alter_output_for_insn (ce_elem, insn_elem,\n \t\t\t\t\t      alternatives, max_operand);\n-\n-      /* ??? Set `predicable' to false.  Not crucial since it's really\n-         only used here, and we won't reprocess this new pattern.  */\n+      alter_attrs_for_insn (insn);\n \n       /* Put the new pattern on the `other' list so that it\n \t (a) is not reprocessed by other define_cond_exec patterns"}]}