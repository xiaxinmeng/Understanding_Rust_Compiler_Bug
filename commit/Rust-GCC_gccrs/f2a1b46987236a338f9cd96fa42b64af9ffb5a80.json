{"sha": "f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJhMWI0Njk4NzIzNmEzMzhmOWNkOTZmYTQyYjY0YWY5ZmZiNWE4MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-11-02T16:34:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-11-02T16:34:52Z"}, "message": "re PR tree-optimization/55079 (false positive -Warray-bounds (also seen at -O3 bootstrap))\n\n\n\tPR middle-end/55079\n\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Update\n\tMAX field if NITER was folded to contant.\n\t(record_estimate): Sanity check.\n\t* tree-ssa-loop-ivcanon.c (remove_exits_and_undefined_stmts): New\n\tfunction.\n\t(remove_redundant_iv_test): New function.\n\t(loops_to_unloop, loops_to_unloop_nunroll): New static vars.\n\t(unloop_loops): Break out from ...\n\t(try_unroll_loop_completely): ... here; Pass in MAXITER; use\n\tremove_exits_and_undefined_stmts; do not unloop.\n\t(canonicalize_loop_induction_variables): Compute MAXITER;\n\tuse remove_redundant_iv_test; remove loop_close_ssa_invalidated\n\tand irred_invalidated arguments.\n\t(canonicalize_induction_variables): Compute fresh bound estimates;\n\tunloop; walk from innermost.\n\t(tree_unroll_loops_completely): Likewise.\n\n\t* gcc.dg/tree-ssa/cunroll-10.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-9.c: New testcase.\n\nFrom-SVN: r193098", "tree": {"sha": "f422408bb685a50d53e449a1a6c13e851119cfe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f422408bb685a50d53e449a1a6c13e851119cfe9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/comments", "author": null, "committer": null, "parents": [{"sha": "7ee840b6bf0ec12da6506591c10ceb1e78af532a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee840b6bf0ec12da6506591c10ceb1e78af532a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ee840b6bf0ec12da6506591c10ceb1e78af532a"}], "stats": {"total": 356, "additions": 286, "deletions": 70}, "files": [{"sha": "793c4933f79fb0f02472b05e908a5cecf45409e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "patch": "@@ -1,3 +1,23 @@\n+2012-11-02  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/55079\n+\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Update\n+\tMAX field if NITER was folded to contant.\n+\t(record_estimate): Sanity check.\n+\t* tree-ssa-loop-ivcanon.c (remove_exits_and_undefined_stmts): New\n+\tfunction.\n+\t(remove_redundant_iv_test): New function.\n+\t(loops_to_unloop, loops_to_unloop_nunroll): New static vars.\n+\t(unloop_loops): Break out from ...\n+\t(try_unroll_loop_completely): ... here; Pass in MAXITER; use\n+\tremove_exits_and_undefined_stmts; do not unloop.\n+\t(canonicalize_loop_induction_variables): Compute MAXITER;\n+\tuse remove_redundant_iv_test; remove loop_close_ssa_invalidated\n+\tand irred_invalidated arguments.\n+\t(canonicalize_induction_variables): Compute fresh bound estimates;\n+\tunloop; walk from innermost.\n+\t(tree_unroll_loops_completely): Likewise.\n+\n 2012-11-02  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/55130"}, {"sha": "cc75c0b64756f318cff1a60dab51d97e0f743589", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "patch": "@@ -1,3 +1,8 @@\n+2012-11-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/cunroll-10.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-9.c: New testcase.\n+\n 2012-11-02  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/55130"}, {"sha": "7893565918a68387c462d265072a589787b45a48", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-10.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-10.c?ref=f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -Warray-bounds -fdump-tree-cunroll-details\" } */\n+int a[3];\n+int b[4];\n+main()\n+{\n+  int i;\n+  for (i=0;i<4;i++)\n+    if (b[i]==2)\n+     a[i]++;\n+}\n+/* { dg-final { scan-tree-dump-times \"Forced statement unreachable\" 2 \"cunroll\" } } */\n+/* { dg-final { cleanup-tree-dump \"cunroll\" } } */"}, {"sha": "3205b8d396515d1f0e4b76547b790cd2b87974e7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-9.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-9.c?ref=f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli\" } */\n+void abort (void);\n+int a[10];\n+int b[11];\n+t (int n)\n+{\n+  int i;\n+  int sum = 0;\n+  for (i = 0; i < n; i++)\n+    {\n+      if (i > 1000)\n+\tabort ();\n+      if (q ())\n+\tsum += a[i];\n+      else\n+\tsum += b[i];\n+    }\n+  return sum;\n+}\n+/* { dg-final { scan-tree-dump-times 1 \"Removed pointless exit:\" \"cunroli\" } } */\n+/* { dg-final { cleanup-tree-dump \"cunroli\" } } */"}, {"sha": "433bb7783cf3320e54af5ca18b2f1ebd2eec49c4", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 220, "deletions": 70, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "patch": "@@ -389,33 +389,192 @@ loop_edge_to_cancel (struct loop *loop)\n   return NULL;\n }\n \n-/* Tries to unroll LOOP completely, i.e. NITER times.\n-   UL determines which loops we are allowed to unroll.\n-   EXIT is the exit of the loop that should be eliminated.  \n+/* Remove all tests for exits that are known to be taken after LOOP was\n+   peeled NPEELED times. Put gcc_unreachable before every statement\n+   known to not be executed.  */\n+\n+static bool\n+remove_exits_and_undefined_stmts (struct loop *loop, unsigned int npeeled)\n+{\n+  struct nb_iter_bound *elt;\n+  bool changed = false;\n+\n+  for (elt = loop->bounds; elt; elt = elt->next)\n+    {\n+      /* If statement is known to be undefined after peeling, turn it\n+\t into unreachable (or trap when debugging experience is supposed\n+\t to be good).  */\n+      if (!elt->is_exit\n+\t  && elt->bound.ult (double_int::from_uhwi (npeeled)))\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (elt->stmt);\n+\t  gimple stmt = gimple_build_call\n+\t      (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n+\n+\t  gimple_set_location (stmt, gimple_location (elt->stmt));\n+\t  gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n+\t  changed = true;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Forced statement unreachable: \");\n+\t      print_gimple_stmt (dump_file, elt->stmt, 0, 0);\n+\t    }\n+\t}\n+      /* If we know the exit will be taken after peeling, update.  */\n+      else if (elt->is_exit\n+\t       && elt->bound.ule (double_int::from_uhwi (npeeled)))\n+\t{\n+\t  basic_block bb = gimple_bb (elt->stmt);\n+\t  edge exit_edge = EDGE_SUCC (bb, 0);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Forced exit to be taken: \");\n+\t      print_gimple_stmt (dump_file, elt->stmt, 0, 0);\n+\t    }\n+\t  if (!loop_exit_edge_p (loop, exit_edge))\n+\t    exit_edge = EDGE_SUCC (bb, 1);\n+\t  gcc_checking_assert (loop_exit_edge_p (loop, exit_edge));\n+\t  if (exit_edge->flags & EDGE_TRUE_VALUE)\n+\t    gimple_cond_make_true (elt->stmt);\n+\t  else\n+\t    gimple_cond_make_false (elt->stmt);\n+\t  update_stmt (elt->stmt);\n+\t  changed = true;\n+\t}\n+    }\n+  return changed;\n+}\n+\n+/* Remove all exits that are known to be never taken because of the loop bound\n+   discovered.  */\n+\n+static bool\n+remove_redundant_iv_tests (struct loop *loop)\n+{\n+  struct nb_iter_bound *elt;\n+  bool changed = false;\n+\n+  if (!loop->any_upper_bound)\n+    return false;\n+  for (elt = loop->bounds; elt; elt = elt->next)\n+    {\n+      /* Exit is pointless if it won't be taken before loop reaches\n+\t upper bound.  */\n+      if (elt->is_exit && loop->any_upper_bound\n+          && loop->nb_iterations_upper_bound.ult (elt->bound))\n+\t{\n+\t  basic_block bb = gimple_bb (elt->stmt);\n+\t  edge exit_edge = EDGE_SUCC (bb, 0);\n+\t  struct tree_niter_desc niter;\n+\n+\t  if (!loop_exit_edge_p (loop, exit_edge))\n+\t    exit_edge = EDGE_SUCC (bb, 1);\n+\n+\t  /* Only when we know the actual number of iterations, not\n+\t     just a bound, we can remove the exit.  */\n+\t  if (!number_of_iterations_exit (loop, exit_edge,\n+\t\t\t\t\t  &niter, false, false))\n+\t    gcc_unreachable ();\n+\t  if (!integer_onep (niter.assumptions)\n+\t      || !integer_zerop (niter.may_be_zero)\n+\t      || !niter.niter\n+\t      || TREE_CODE (niter.niter) != INTEGER_CST\n+\t      || !loop->nb_iterations_upper_bound.ult\n+\t\t   (tree_to_double_int (niter.niter)))\n+\t    continue;\n+\t  \n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Removed pointless exit: \");\n+\t      print_gimple_stmt (dump_file, elt->stmt, 0, 0);\n+\t    }\n+\t  if (exit_edge->flags & EDGE_TRUE_VALUE)\n+\t    gimple_cond_make_false (elt->stmt);\n+\t  else\n+\t    gimple_cond_make_true (elt->stmt);\n+\t  update_stmt (elt->stmt);\n+\t  changed = true;\n+\t}\n+    }\n+  return changed;\n+}\n+\n+/* Stores loops that will be unlooped after we process whole loop tree. */\n+static VEC(loop_p, heap) *loops_to_unloop;\n+static VEC(int, heap) *loops_to_unloop_nunroll;\n+\n+/* Cancel all fully unrolled loops by putting __builtin_unreachable\n+   on the latch edge.  \n+   We do it after all unrolling since unlooping moves basic blocks\n+   across loop boundaries trashing loop closed SSA form as well\n+   as SCEV info needed to be intact during unrolling. \n+\n    IRRED_INVALIDATED is used to bookkeep if information about\n    irreducible regions may become invalid as a result\n    of the transformation.  \n    LOOP_CLOSED_SSA_INVALIDATED is used to bookkepp the case\n    when we need to go into loop closed SSA form.  */\n \n+void\n+unloop_loops (bitmap loop_closed_ssa_invalidated,\n+\t      bool *irred_invalidated)\n+{\n+  while (VEC_length (loop_p, loops_to_unloop))\n+    {\n+      struct loop *loop = VEC_pop (loop_p, loops_to_unloop);\n+      int n_unroll = VEC_pop (int, loops_to_unloop_nunroll);\n+      basic_block latch = loop->latch;\n+      edge latch_edge = loop_latch_edge (loop);\n+      int flags = latch_edge->flags;\n+      location_t locus = latch_edge->goto_locus;\n+      gimple stmt;\n+      gimple_stmt_iterator gsi;\n+\n+      remove_exits_and_undefined_stmts (loop, n_unroll);\n+\n+      /* Unloop destroys the latch edge.  */\n+      unloop (loop, irred_invalidated, loop_closed_ssa_invalidated);\n+\n+      /* Create new basic block for the latch edge destination and wire\n+\t it in.  */\n+      stmt = gimple_build_call (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n+      latch_edge = make_edge (latch, create_basic_block (NULL, NULL, latch), flags);\n+      latch_edge->probability = 0;\n+      latch_edge->count = 0;\n+      latch_edge->flags |= flags;\n+      latch_edge->goto_locus = locus;\n+\n+      latch_edge->dest->loop_father = current_loops->tree_root;\n+      latch_edge->dest->count = 0;\n+      latch_edge->dest->frequency = 0;\n+      set_immediate_dominator (CDI_DOMINATORS, latch_edge->dest, latch_edge->src);\n+\n+      gsi = gsi_start_bb (latch_edge->dest);\n+      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+    }\n+  VEC_free (loop_p, heap, loops_to_unloop);\n+  loops_to_unloop = NULL;\n+  VEC_free (int, heap, loops_to_unloop_nunroll);\n+  loops_to_unloop_nunroll = NULL;\n+}\n+\n+/* Tries to unroll LOOP completely, i.e. NITER times.\n+   UL determines which loops we are allowed to unroll.\n+   EXIT is the exit of the loop that should be eliminated.  \n+   MAXITER specfy bound on number of iterations, -1 if it is\n+   not known or too large for HOST_WIDE_INT.  */\n+\n static bool\n try_unroll_loop_completely (struct loop *loop,\n \t\t\t    edge exit, tree niter,\n \t\t\t    enum unroll_level ul,\n-\t\t\t    bool *irred_invalidated,\n-\t\t\t    bitmap loop_closed_ssa_invalidated)\n+\t\t\t    HOST_WIDE_INT maxiter)\n {\n   unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll, unr_insns;\n   gimple cond;\n   struct loop_size size;\n   bool n_unroll_found = false;\n-  HOST_WIDE_INT maxiter;\n-  basic_block latch;\n-  edge latch_edge;\n-  location_t locus;\n-  int flags;\n-  gimple stmt;\n-  gimple_stmt_iterator gsi;\n   edge edge_to_cancel = NULL;\n   int num = loop->num;\n \n@@ -445,7 +604,6 @@ try_unroll_loop_completely (struct loop *loop,\n     exit = NULL;\n \n   /* See if we can improve our estimate by using recorded loop bounds.  */\n-  maxiter = max_loop_iterations_int (loop);\n   if (maxiter >= 0\n       && (!n_unroll_found || (unsigned HOST_WIDE_INT)maxiter < n_unroll))\n     {\n@@ -545,6 +703,7 @@ try_unroll_loop_completely (struct loop *loop,\n       free_original_copy_tables ();\n     }\n \n+\n   /* Remove the conditional from the last copy of the loop.  */\n   if (edge_to_cancel)\n     {\n@@ -557,37 +716,10 @@ try_unroll_loop_completely (struct loop *loop,\n       /* Do not remove the path. Doing so may remove outer loop\n \t and confuse bookkeeping code in tree_unroll_loops_completelly.  */\n     }\n-  /* We did not manage to cancel the loop.\n-     The loop latch remains reachable even if it will never be reached\n-     at runtime.  We must redirect it to somewhere, so create basic\n-     block containg __builtin_unreachable call for this reason.  */\n-  else\n-    {\n-      latch = loop->latch;\n-      latch_edge = loop_latch_edge (loop);\n-      flags = latch_edge->flags;\n-      locus = latch_edge->goto_locus;\n \n-      /* Unloop destroys the latch edge.  */\n-      unloop (loop, irred_invalidated, loop_closed_ssa_invalidated);\n-\n-      /* Create new basic block for the latch edge destination and wire\n-\t it in.  */\n-      stmt = gimple_build_call (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n-      latch_edge = make_edge (latch, create_basic_block (NULL, NULL, latch), flags);\n-      latch_edge->probability = 0;\n-      latch_edge->count = 0;\n-      latch_edge->flags |= flags;\n-      latch_edge->goto_locus = locus;\n-\n-      latch_edge->dest->loop_father = current_loops->tree_root;\n-      latch_edge->dest->count = 0;\n-      latch_edge->dest->frequency = 0;\n-      set_immediate_dominator (CDI_DOMINATORS, latch_edge->dest, latch_edge->src);\n-\n-      gsi = gsi_start_bb (latch_edge->dest);\n-      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n-    }\n+  /* Store the loop for later unlooping and exit removal.  */\n+  VEC_safe_push (loop_p, heap, loops_to_unloop, loop);\n+  VEC_safe_push (int, heap, loops_to_unloop_nunroll, n_unroll);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -614,19 +746,17 @@ try_unroll_loop_completely (struct loop *loop,\n    CREATE_IV is true if we may create a new iv.  UL determines\n    which loops we are allowed to completely unroll.  If TRY_EVAL is true, we try\n    to determine the number of iterations of a loop by direct evaluation.\n-   Returns true if cfg is changed.  \n-\n-   IRRED_INVALIDATED is used to keep if irreducible reginos needs to be recomputed.  */\n+   Returns true if cfg is changed.   */\n \n static bool\n canonicalize_loop_induction_variables (struct loop *loop,\n \t\t\t\t       bool create_iv, enum unroll_level ul,\n-\t\t\t\t       bool try_eval,\n-\t\t\t\t       bool *irred_invalidated,\n-\t\t\t\t       bitmap loop_closed_ssa_invalidated)\n+\t\t\t\t       bool try_eval)\n {\n   edge exit = NULL;\n   tree niter;\n+  HOST_WIDE_INT maxiter;\n+  bool modified = false;\n \n   niter = number_of_latch_executions (loop);\n   if (TREE_CODE (niter) == INTEGER_CST)\n@@ -657,6 +787,9 @@ canonicalize_loop_induction_variables (struct loop *loop,\n   if (niter && TREE_CODE (niter) == INTEGER_CST)\n     record_niter_bound (loop, tree_to_double_int (niter), false, true);\n \n+  /* Force re-computation of loop bounds so we can remove redundant exits.  */\n+  maxiter = max_loop_iterations_int (loop);\n+\n   if (dump_file && (dump_flags & TDF_DETAILS)\n       && TREE_CODE (niter) == INTEGER_CST)\n     {\n@@ -665,21 +798,25 @@ canonicalize_loop_induction_variables (struct loop *loop,\n       fprintf (dump_file, \" times.\\n\");\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS)\n-      && max_loop_iterations_int (loop) >= 0)\n+      && maxiter >= 0)\n     {\n       fprintf (dump_file, \"Loop %d iterates at most %i times.\\n\", loop->num,\n-\t       (int)max_loop_iterations_int (loop));\n+\t       (int)maxiter);\n     }\n \n-  if (try_unroll_loop_completely (loop, exit, niter, ul, irred_invalidated,\n-\t\t\t\t  loop_closed_ssa_invalidated))\n+  /* Remove exits that are known to be never taken based on loop bound.\n+     Needs to be called after compilation of max_loop_iterations_int that\n+     populates the loop bounds.  */\n+  modified |= remove_redundant_iv_tests (loop);\n+\n+  if (try_unroll_loop_completely (loop, exit, niter, ul, maxiter))\n     return true;\n \n   if (create_iv\n       && niter && !chrec_contains_undetermined (niter))\n     create_canonical_iv (loop, exit, niter);\n \n-  return false;\n+  return modified;\n }\n \n /* The main entry point of the pass.  Adds canonical induction variables\n@@ -694,16 +831,18 @@ canonicalize_induction_variables (void)\n   bool irred_invalidated = false;\n   bitmap loop_closed_ssa_invalidated = BITMAP_ALLOC (NULL);\n \n-  FOR_EACH_LOOP (li, loop, 0)\n+  free_numbers_of_iterations_estimates ();\n+  estimate_numbers_of_iterations ();\n+\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       changed |= canonicalize_loop_induction_variables (loop,\n \t\t\t\t\t\t\ttrue, UL_SINGLE_ITER,\n-\t\t\t\t\t\t\ttrue,\n-\t\t\t\t\t\t\t&irred_invalidated,\n-\t\t\t\t\t\t\tloop_closed_ssa_invalidated);\n+\t\t\t\t\t\t\ttrue);\n     }\n   gcc_assert (!need_ssa_update_p (cfun));\n \n+  unloop_loops (loop_closed_ssa_invalidated, &irred_invalidated);\n   if (irred_invalidated\n       && loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n     mark_irreducible_loops ();\n@@ -822,7 +961,10 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n       if (loops_state_satisfies_p (LOOP_CLOSED_SSA))\n \tloop_closed_ssa_invalidated = BITMAP_ALLOC (NULL);\n \n-      FOR_EACH_LOOP (li, loop, 0)\n+      free_numbers_of_iterations_estimates ();\n+      estimate_numbers_of_iterations ();\n+\n+      FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n \t{\n \t  struct loop *loop_father = loop_outer (loop);\n \n@@ -835,8 +977,7 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t    ul = UL_NO_GROWTH;\n \n \t  if (canonicalize_loop_induction_variables\n-\t\t (loop, false, ul, !flag_tree_loop_ivcanon,\n-\t\t  &irred_invalidated, loop_closed_ssa_invalidated))\n+\t\t (loop, false, ul, !flag_tree_loop_ivcanon))\n \t    {\n \t      changed = true;\n \t      /* If we'll continue unrolling, we need to propagate constants\n@@ -856,8 +997,16 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  struct loop **iter;\n \t  unsigned i;\n \n-\t  /* We can not use TODO_update_ssa_no_phi because VOPS gets confused.  */\n+\t  /* Be sure to skip unlooped loops while procesing father_stack\n+\t     array.  */\n+\t  FOR_EACH_VEC_ELT (loop_p, loops_to_unloop, i, iter)\n+\t    (*iter)->aux = NULL;\n+\t  FOR_EACH_VEC_ELT (loop_p, father_stack, i, iter)\n+\t    if (!(*iter)->aux)\n+\t      *iter = NULL;\n+          unloop_loops (loop_closed_ssa_invalidated, &irred_invalidated);\n \n+\t  /* We can not use TODO_update_ssa_no_phi because VOPS gets confused.  */\n \t  if (loop_closed_ssa_invalidated\n \t      && !bitmap_empty_p (loop_closed_ssa_invalidated))\n             rewrite_into_loop_closed_ssa (loop_closed_ssa_invalidated,\n@@ -867,14 +1016,15 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \n \t  /* Propagate the constants within the new basic blocks.  */\n \t  FOR_EACH_VEC_ELT (loop_p, father_stack, i, iter)\n-\t    {\n-\t      unsigned j;\n-\t      basic_block *body = get_loop_body_in_dom_order (*iter);\n-\t      for (j = 0; j < (*iter)->num_nodes; j++)\n-\t\tpropagate_constants_for_unrolling (body[j]);\n-\t      free (body);\n-\t      (*iter)->aux = NULL;\n-\t    }\n+\t    if (*iter)\n+\t      {\n+\t\tunsigned j;\n+\t\tbasic_block *body = get_loop_body_in_dom_order (*iter);\n+\t\tfor (j = 0; j < (*iter)->num_nodes; j++)\n+\t\t  propagate_constants_for_unrolling (body[j]);\n+\t\tfree (body);\n+\t\t(*iter)->aux = NULL;\n+\t      }\n \t  VEC_truncate (loop_p, father_stack, 0);\n \n \t  /* This will take care of removing completely unrolled loops"}, {"sha": "b77bcbbe5bade64ea315c2fa20ad3008689829cd", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1b46987236a338f9cd96fa42b64af9ffb5a80/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f2a1b46987236a338f9cd96fa42b64af9ffb5a80", "patch": "@@ -1880,6 +1880,10 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \n   fold_undefer_and_ignore_overflow_warnings ();\n \n+  /* If NITER has simplified into a constant, update MAX.  */\n+  if (TREE_CODE (niter->niter) == INTEGER_CST)\n+    niter->max = tree_to_double_int (niter->niter);\n+\n   if (integer_onep (niter->assumptions))\n     return true;\n \n@@ -2556,6 +2560,8 @@ record_estimate (struct loop *loop, tree bound, double_int i_bound,\n      real number of iterations.  */\n   if (TREE_CODE (bound) != INTEGER_CST)\n     realistic = false;\n+  else\n+    gcc_checking_assert (i_bound == tree_to_double_int (bound));\n   if (!upper && !realistic)\n     return;\n "}]}