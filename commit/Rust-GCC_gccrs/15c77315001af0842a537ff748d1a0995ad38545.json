{"sha": "15c77315001af0842a537ff748d1a0995ad38545", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVjNzczMTUwMDFhZjA4NDJhNTM3ZmY3NDhkMWEwOTk1YWQzODU0NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-09-30T08:10:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-09-30T08:10:15Z"}, "message": "re PR target/82361 (Useless \"mov eax, eax\" in generated code)\n\n\tPR target/82361\n\t* config/i386/i386.md\n\t(TARGET_USE_8BIT_IDIV zext divmodsi4 splitter): New define_split.\n\t(divmodsi4_zext_1, divmodsi4_zext_2, *divmodsi4_zext_1,\n\t*divmodsi4_zext_2): New define_insn_and_split.\n\t(*divmodsi4_noext_zext_1, *divmodsi4_noext_zext_2): New define_insn.\n\t(TARGET_USE_8BIT_IDIV zext udivmodsi4 splitter): New define_split.\n\t(udivmodsi4_zext_1, udivmodsi4_zext_2, *udivmodsi4_zext_1,\n\t*udivmodsi4_zext_2, *udivmodsi4_pow2_zext_1, *udivmodsi4_pow2_zext_2):\n\tNew define_insn_and_split.\n\t(*udivmodsi4_noext_zext_1, *udivmodsi4_noext_zext_2): New define_insn.\n\t* config/i386/i386.c (ix86_split_idivmod): Handle operands[0] or\n\toperands[1] having DImode when mode is SImode.\n\n\t* gcc.target/i386/pr82361-1.c: New test.\n\t* gcc.target/i386/pr82361-2.c: New test.\n\nFrom-SVN: r253317", "tree": {"sha": "88422c20d5913d279b89b716af89576b2fe24a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88422c20d5913d279b89b716af89576b2fe24a3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15c77315001af0842a537ff748d1a0995ad38545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c77315001af0842a537ff748d1a0995ad38545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15c77315001af0842a537ff748d1a0995ad38545", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c77315001af0842a537ff748d1a0995ad38545/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6bc1d858fbeba5ed7ee06266a3d6738bad2d8b3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc1d858fbeba5ed7ee06266a3d6738bad2d8b3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc1d858fbeba5ed7ee06266a3d6738bad2d8b3f"}], "stats": {"total": 518, "additions": 514, "deletions": 4}, "files": [{"sha": "65cfd80bfafe129007451f55d79e998ff336a8b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c77315001af0842a537ff748d1a0995ad38545/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c77315001af0842a537ff748d1a0995ad38545/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15c77315001af0842a537ff748d1a0995ad38545", "patch": "@@ -1,5 +1,19 @@\n 2017-09-30  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/82361\n+\t* config/i386/i386.md\n+\t(TARGET_USE_8BIT_IDIV zext divmodsi4 splitter): New define_split.\n+\t(divmodsi4_zext_1, divmodsi4_zext_2, *divmodsi4_zext_1,\n+\t*divmodsi4_zext_2): New define_insn_and_split.\n+\t(*divmodsi4_noext_zext_1, *divmodsi4_noext_zext_2): New define_insn.\n+\t(TARGET_USE_8BIT_IDIV zext udivmodsi4 splitter): New define_split.\n+\t(udivmodsi4_zext_1, udivmodsi4_zext_2, *udivmodsi4_zext_1,\n+\t*udivmodsi4_zext_2, *udivmodsi4_pow2_zext_1, *udivmodsi4_pow2_zext_2):\n+\tNew define_insn_and_split.\n+\t(*udivmodsi4_noext_zext_1, *udivmodsi4_noext_zext_2): New define_insn.\n+\t* config/i386/i386.c (ix86_split_idivmod): Handle operands[0] or\n+\toperands[1] having DImode when mode is SImode.\n+\n \t* config/i386/i386.c (ix86_split_idivmod): Use mode instead of\n \talways SImode for DIV and MOD in REG_EQUAL notes.\n "}, {"sha": "519336e0ed18897beb59bba8a0e01807078224c3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=15c77315001af0842a537ff748d1a0995ad38545", "patch": "@@ -21927,9 +21927,22 @@ ix86_split_idivmod (machine_mode mode, rtx operands[],\n   switch (mode)\n     {\n     case E_SImode:\n-      gen_divmod4_1 = signed_p ? gen_divmodsi4_1 : gen_udivmodsi4_1;\n+      if (GET_MODE (operands[0]) == SImode)\n+\t{\n+\t  if (GET_MODE (operands[1]) == SImode)\n+\t    gen_divmod4_1 = signed_p ? gen_divmodsi4_1 : gen_udivmodsi4_1;\n+\t  else\n+\t    gen_divmod4_1\n+\t      = signed_p ? gen_divmodsi4_zext_2 : gen_udivmodsi4_zext_2;\n+\t  gen_zero_extend = gen_zero_extendqisi2;\n+\t}\n+      else\n+\t{\n+\t  gen_divmod4_1\n+\t    = signed_p ? gen_divmodsi4_zext_1 : gen_udivmodsi4_zext_1;\n+\t  gen_zero_extend = gen_zero_extendqidi2;\n+\t}\n       gen_test_ccno_1 = gen_testsi_ccno_1;\n-      gen_zero_extend = gen_zero_extendqisi2;\n       break;\n     case E_DImode:\n       gen_divmod4_1 = signed_p ? gen_divmoddi4_1 : gen_udivmoddi4_1;\n@@ -21988,16 +22001,24 @@ ix86_split_idivmod (machine_mode mode, rtx operands[],\n       div = gen_rtx_UDIV (mode, operands[2], operands[3]);\n       mod = gen_rtx_UMOD (mode, operands[2], operands[3]);\n     }\n+  if (mode == SImode)\n+    {\n+      if (GET_MODE (operands[0]) != SImode)\n+\tdiv = gen_rtx_ZERO_EXTEND (DImode, div);\n+      if (GET_MODE (operands[1]) != SImode)\n+\tmod = gen_rtx_ZERO_EXTEND (DImode, mod);\n+    }\n \n   /* Extract remainder from AH.  */\n-  tmp1 = gen_rtx_ZERO_EXTRACT (mode, tmp0, GEN_INT (8), GEN_INT (8));\n+  tmp1 = gen_rtx_ZERO_EXTRACT (GET_MODE (operands[1]),\n+\t\t\t       tmp0, GEN_INT (8), GEN_INT (8));\n   if (REG_P (operands[1]))\n     insn = emit_move_insn (operands[1], tmp1);\n   else\n     {\n       /* Need a new scratch register since the old one has result\n \t of 8bit divide.  */\n-      scratch = gen_reg_rtx (mode);\n+      scratch = gen_reg_rtx (GET_MODE (operands[1]));\n       emit_move_insn (scratch, tmp1);\n       insn = emit_move_insn (operands[1], scratch);\n     }"}, {"sha": "99497a9f65425a4a9a9dfc6b935e027a73f733f5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=15c77315001af0842a537ff748d1a0995ad38545", "patch": "@@ -7635,6 +7635,36 @@\n   [(const_int 0)]\n   \"ix86_split_idivmod (<MODE>mode, operands, true); DONE;\")\n \n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(zero_extend:DI\n+\t  (div:SI (match_operand:SI 2 \"register_operand\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\"))))\n+   (set (match_operand:SI 1 \"register_operand\")\n+\t(mod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_8BIT_IDIV\n+   && TARGET_QIMODE_MATH\n+   && can_create_pseudo_p ()\n+   && !optimize_insn_for_size_p ()\"\n+  [(const_int 0)]\n+  \"ix86_split_idivmod (SImode, operands, true); DONE;\")\n+\n+(define_split\n+  [(set (match_operand:DI 1 \"register_operand\")\n+\t(zero_extend:DI\n+\t  (mod:SI (match_operand:SI 2 \"register_operand\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\"))))\n+   (set (match_operand:SI 0 \"register_operand\")\n+\t(div:SI  (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_8BIT_IDIV\n+   && TARGET_QIMODE_MATH\n+   && can_create_pseudo_p ()\n+   && !optimize_insn_for_size_p ()\"\n+  [(const_int 0)]\n+  \"ix86_split_idivmod (SImode, operands, true); DONE;\")\n+\n (define_insn_and_split \"divmod<mode>4_1\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=a\")\n \t(div:SWI48 (match_operand:SWI48 2 \"register_operand\" \"0\")\n@@ -7670,6 +7700,79 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"divmodsi4_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (div:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n+\t(mod:SI (match_dup 2) (match_dup 3)))\n+   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 1)\n+\t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (div:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 1)\n+\t\t   (mod:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[5] = GEN_INT (GET_MODE_BITSIZE (SImode)-1);\n+\n+  if (optimize_function_for_size_p (cfun) || TARGET_USE_CLTD)\n+    operands[4] = operands[2];\n+  else\n+    {\n+      /* Avoid use of cltd in favor of a mov+shift.  */\n+      emit_move_insn (operands[1], operands[2]);\n+      operands[4] = operands[1];\n+    }\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"divmodsi4_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n+\t(zero_extend:DI\n+\t  (mod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(div:SI (match_dup 2) (match_dup 3)))\n+   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 6)\n+\t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (mod:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 0)\n+\t\t   (div:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 6))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[5] = GEN_INT (GET_MODE_BITSIZE (SImode)-1);\n+  operands[6] = gen_lowpart (SImode, operands[1]);\n+\n+  if (optimize_function_for_size_p (cfun) || TARGET_USE_CLTD)\n+    operands[4] = operands[2];\n+  else\n+    {\n+      /* Avoid use of cltd in favor of a mov+shift.  */\n+      emit_move_insn (operands[6], operands[2]);\n+      operands[4] = operands[6];\n+    }\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn_and_split \"*divmod<mode>4\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n \t(div:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n@@ -7705,6 +7808,77 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*divmodsi4_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (div:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n+\t(mod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 1)\n+\t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (div:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 1)\n+\t\t   (mod:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[5] = GEN_INT (GET_MODE_BITSIZE (SImode)-1);\n+\n+  if (optimize_function_for_size_p (cfun) || TARGET_USE_CLTD)\n+    operands[4] = operands[2];\n+  else\n+    {\n+      /* Avoid use of cltd in favor of a mov+shift.  */\n+      emit_move_insn (operands[1], operands[2]);\n+      operands[4] = operands[1];\n+    }\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*divmodsi4_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n+\t(zero_extend:DI\n+\t  (mod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(div:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 6)\n+\t\t   (ashiftrt:SI (match_dup 4) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (mod:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 0)\n+\t\t   (div:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 6))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[5] = GEN_INT (GET_MODE_BITSIZE (SImode)-1);\n+  operands[6] = gen_lowpart (SImode, operands[1]);\n+\n+  if (optimize_function_for_size_p (cfun) || TARGET_USE_CLTD)\n+    operands[4] = operands[2];\n+  else\n+    {\n+      /* Avoid use of cltd in favor of a mov+shift.  */\n+      emit_move_insn (operands[6], operands[2]);\n+      operands[4] = operands[6];\n+    }\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*divmod<mode>4_noext\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n \t(div:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n@@ -7718,6 +7892,34 @@\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*divmodsi4_noext_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (div:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=d\")\n+\t(mod:SI (match_dup 2) (match_dup 3)))\n+   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"idiv{l}\\t%3\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*divmodsi4_noext_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=d\")\n+\t(zero_extend:DI\n+\t  (mod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(div:SI (match_dup 2) (match_dup 3)))\n+   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"idiv{l}\\t%3\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"divmodqi4\"\n   [(parallel [(set (match_operand:QI 0 \"register_operand\")\n \t\t   (div:QI\n@@ -7808,6 +8010,38 @@\n   [(const_int 0)]\n   \"ix86_split_idivmod (<MODE>mode, operands, false); DONE;\")\n \n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\"))))\n+   (set (match_operand:SI 1 \"register_operand\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\n+   && TARGET_USE_8BIT_IDIV\n+   && TARGET_QIMODE_MATH\n+   && can_create_pseudo_p ()\n+   && !optimize_insn_for_size_p ()\"\n+  [(const_int 0)]\n+  \"ix86_split_idivmod (SImode, operands, false); DONE;\")\n+\n+(define_split\n+  [(set (match_operand:DI 1 \"register_operand\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\"))))\n+   (set (match_operand:SI 0 \"register_operand\")\n+\t(udiv:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\n+   && TARGET_USE_8BIT_IDIV\n+   && TARGET_QIMODE_MATH\n+   && can_create_pseudo_p ()\n+   && !optimize_insn_for_size_p ()\"\n+  [(const_int 0)]\n+  \"ix86_split_idivmod (SImode, operands, false); DONE;\")\n+\n (define_insn_and_split \"udivmod<mode>4_1\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=a\")\n \t(udiv:SWI48 (match_operand:SWI48 2 \"register_operand\" \"0\")\n@@ -7830,6 +8064,52 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"udivmodsi4_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (udiv:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 1)\n+\t\t   (umod:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"udivmodsi4_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:SI (match_dup 2) (match_dup 3)))\n+   (unspec [(const_int 0)] UNSPEC_DIV_ALREADY_SPLIT)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 4) (const_int 0))\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (umod:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 0)\n+\t\t   (udiv:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 4))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"operands[4] = gen_lowpart (SImode, operands[1]);\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn_and_split \"*udivmod<mode>4\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n \t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n@@ -7851,6 +8131,50 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*udivmodsi4_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&d\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 1) (const_int 0))\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (udiv:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 1)\n+\t\t   (umod:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*udivmodsi4_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=&d\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 4) (const_int 0))\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (umod:SI (match_dup 2) (match_dup 3))))\n+\t      (set (match_dup 0)\n+\t\t   (udiv:SI (match_dup 2) (match_dup 3)))\n+\t      (use (match_dup 4))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"operands[4] = gen_lowpart (SImode, operands[1]);\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n ;; Optimize division or modulo by constant power of 2, if the constant\n ;; materializes only after expansion.\n (define_insn_and_split \"*udivmod<mode>4_pow2\"\n@@ -7877,6 +8201,60 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*udivmodsi4_pow2_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\n+   && IN_RANGE (INTVAL (operands[3]), 2, HOST_WIDE_INT_UC (0x80000000))\n+   && (UINTVAL (operands[3]) & (UINTVAL (operands[3]) - 1)) == 0\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (lshiftrt:SI (match_dup 2) (match_dup 4))))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 1) (and:SI (match_dup 1) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  int v = exact_log2 (UINTVAL (operands[3]));\n+  operands[4] = GEN_INT (v);\n+  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*udivmodsi4_pow2_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"const_int_operand\" \"n\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\n+   && IN_RANGE (INTVAL (operands[3]), 2, HOST_WIDE_INT_UC (0x80000000))\n+   && (UINTVAL (operands[3]) & (UINTVAL (operands[3]) - 1)) == 0\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (parallel [(set (match_dup 0) (lshiftrt:SI (match_dup 2) (match_dup 4)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 1)\n+\t\t   (zero_extend:DI (and:SI (match_dup 1) (match_dup 5))))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  int v = exact_log2 (UINTVAL (operands[3]));\n+  operands[4] = GEN_INT (v);\n+  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << v) - 1);\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"*udivmod<mode>4_noext\"\n   [(set (match_operand:SWIM248 0 \"register_operand\" \"=a\")\n \t(udiv:SWIM248 (match_operand:SWIM248 2 \"register_operand\" \"0\")\n@@ -7890,6 +8268,34 @@\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*udivmodsi4_noext_zext_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(zero_extend:DI\n+\t  (udiv:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=d\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"div{l}\\t%3\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*udivmodsi4_noext_zext_2\"\n+  [(set (match_operand:DI 1 \"register_operand\" \"=d\")\n+\t(zero_extend:DI\n+\t  (umod:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 3 \"nonimmediate_operand\" \"rm\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:SI (match_dup 2) (match_dup 3)))\n+   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"div{l}\\t%3\"\n+  [(set_attr \"type\" \"idiv\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"udivmodqi4\"\n   [(parallel [(set (match_operand:QI 0 \"register_operand\")\n \t\t   (udiv:QI"}, {"sha": "ebcfb1b518179f039d5734ccfcb0abfa0ce88ca8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15c77315001af0842a537ff748d1a0995ad38545", "patch": "@@ -1,3 +1,9 @@\n+2017-09-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/82361\n+\t* gcc.target/i386/pr82361-1.c: New test.\n+\t* gcc.target/i386/pr82361-2.c: New test.\n+\n 2017-09-29  Yury Gribov  <tetra2005@gmail.com>\n \n \tPR middle-end/82319"}, {"sha": "fbef3c928ad03bc93d108da3af1a452375c14301", "filename": "gcc/testsuite/gcc.target/i386/pr82361-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c?ref=15c77315001af0842a537ff748d1a0995ad38545", "patch": "@@ -0,0 +1,53 @@\n+/* PR target/82361 */\n+/* { dg-do compile { target lp64 } } */\n+/* { dg-options \"-O2 -mtune=generic -masm=att -mno-8bit-idiv\" } */\n+/* We should be able to optimize all %eax to %rax zero extensions, because\n+   div and idiv instructions with 32-bit operands zero-extend both results.   */\n+/* { dg-final { scan-assembler-not \"movl\\t%eax, %eax\" } } */\n+/* FIXME: We are still not able to optimize the modulo in f1/f2, only manage\n+   one.  */\n+/* { dg-final { scan-assembler-times \"movl\\t%edx, %edx\" 2 } } */\n+\n+void\n+f1 (unsigned int a, unsigned int b)\n+{\n+  unsigned long long c = a / b;\n+  unsigned long long d = a % b;\n+  asm volatile (\"\" : : \"r\" (c), \"r\" (d));\n+}\n+\n+void\n+f2 (int a, int b)\n+{\n+  unsigned long long c = (unsigned int) (a / b);\n+  unsigned long long d = (unsigned int) (a % b);\n+  asm volatile (\"\" : : \"r\" (c), \"r\" (d));\n+}\n+\n+void\n+f3 (unsigned int a, unsigned int b)\n+{\n+  unsigned long long c = a / b;\n+  asm volatile (\"\" : : \"r\" (c));\n+}\n+\n+void\n+f4 (int a, int b)\n+{\n+  unsigned long long c = (unsigned int) (a / b);\n+  asm volatile (\"\" : : \"r\" (c));\n+}\n+\n+void\n+f5 (unsigned int a, unsigned int b)\n+{\n+  unsigned long long d = a % b;\n+  asm volatile (\"\" : : \"r\" (d));\n+}\n+\n+void\n+f6 (int a, int b)\n+{\n+  unsigned long long d = (unsigned int) (a % b);\n+  asm volatile (\"\" : : \"r\" (d));\n+}"}, {"sha": "c1e484d6e113545946c6f6b7105f4d5603ebd7fe", "filename": "gcc/testsuite/gcc.target/i386/pr82361-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15c77315001af0842a537ff748d1a0995ad38545/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-2.c?ref=15c77315001af0842a537ff748d1a0995ad38545", "patch": "@@ -0,0 +1,10 @@\n+/* PR target/82361 */\n+/* { dg-do compile { target lp64 } } */\n+/* { dg-options \"-O2 -mtune=generic -masm=att -m8bit-idiv\" } */\n+/* We should be able to optimize all %eax to %rax zero extensions, because\n+   div and idiv instructions with 32-bit operands zero-extend both results.   */\n+/* { dg-final { scan-assembler-not \"movl\\t%eax, %eax\" } } */\n+/* Ditto %edx to %rdx zero extensions.  */\n+/* { dg-final { scan-assembler-not \"movl\\t%edx, %edx\" } } */\n+\n+#include \"pr82361-1.c\""}]}