{"sha": "4a31a8add56d49867c187d90b3a89e97634543c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEzMWE4YWRkNTZkNDk4NjdjMTg3ZDkwYjNhODllOTc2MzQ1NDNjMg==", "commit": {"author": {"name": "Kaipeng Zhou", "email": "zhoukaipeng3@huawei.com", "date": "2020-06-17T19:19:16Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-06-17T19:19:16Z"}, "message": "vect: CSE for bump and offset in strided load/store operations.\n\nEvery time \"vect_get_strided_load_store_ops\" is called, new bump and offset\nvariables and a series of stmts are created.  And IVOPTs is not able to\neliminate them.  The patch use \"cse_and_gimplify_to_preheader\" to CSE them.\n\n2020-06-17  Bin Cheng  <bin.cheng@linux.alibaba.com>\n\t    Kaipeng Zhou  <zhoukaipeng3@huawei.com>\n\n\tPR tree-optimization/95199\n\t* tree-vect-stmts.c: Eliminate common stmts for bump and offset in\n\tstrided load/store operations and remove redundant code.\n\n2020-06-17  Bin Cheng  <bin.cheng@linux.alibaba.com>\n\t    Kaipeng Zhou  <zhoukaipeng3@huawei.com>\n\n\tPR tree-optimization/95199\n\t* gcc.target/aarch64/sve/pr95199.c: New test.", "tree": {"sha": "798100e6fd1899ce1c505a151f32fb6f04d398c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/798100e6fd1899ce1c505a151f32fb6f04d398c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a31a8add56d49867c187d90b3a89e97634543c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a31a8add56d49867c187d90b3a89e97634543c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a31a8add56d49867c187d90b3a89e97634543c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a31a8add56d49867c187d90b3a89e97634543c2/comments", "author": null, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44492e248cbff60b12f5cbdaa32b265c5e8c9aff"}], "stats": {"total": 34, "additions": 22, "deletions": 12}, "files": [{"sha": "adcd5124a7cb491956531e6e3132aea3f49248d2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr95199.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a31a8add56d49867c187d90b3a89e97634543c2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr95199.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a31a8add56d49867c187d90b3a89e97634543c2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr95199.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr95199.c?ref=4a31a8add56d49867c187d90b3a89e97634543c2", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=armv8.2-a+sve -fdump-tree-vect\" } */\n+\n+void\n+foo (double *a, double *b, double m, int inc_x, int inc_y)\n+{\n+  int ix = 0, iy = 0;\n+  for (int i = 0; i < 1000; ++i)\n+    {\n+      a[ix] += m * b[iy];\n+      ix += inc_x;\n+      iy += inc_y;\n+    }\n+  return ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"VEC_SERIES_EXPR\" 2 \"vect\" } } */"}, {"sha": "c9174395fcab8c1b645a8a6eb145c593733f75eb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a31a8add56d49867c187d90b3a89e97634543c2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a31a8add56d49867c187d90b3a89e97634543c2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4a31a8add56d49867c187d90b3a89e97634543c2", "patch": "@@ -2846,33 +2846,26 @@ vect_get_strided_load_store_ops (stmt_vec_info stmt_info,\n \t\t\t\t tree *dataref_bump, tree *vec_offset)\n {\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  gimple_seq stmts;\n \n   tree bump = size_binop (MULT_EXPR,\n \t\t\t  fold_convert (sizetype, unshare_expr (DR_STEP (dr))),\n \t\t\t  size_int (TYPE_VECTOR_SUBPARTS (vectype)));\n-  *dataref_bump = force_gimple_operand (bump, &stmts, true, NULL_TREE);\n-  if (stmts)\n-    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+  *dataref_bump = cse_and_gimplify_to_preheader (loop_vinfo, bump);\n \n   /* The offset given in GS_INFO can have pointer type, so use the element\n      type of the vector instead.  */\n-  tree offset_type = TREE_TYPE (gs_info->offset);\n-  offset_type = TREE_TYPE (gs_info->offset_vectype);\n+  tree offset_type = TREE_TYPE (gs_info->offset_vectype);\n \n   /* Calculate X = DR_STEP / SCALE and convert it to the appropriate type.  */\n   tree step = size_binop (EXACT_DIV_EXPR, unshare_expr (DR_STEP (dr)),\n \t\t\t  ssize_int (gs_info->scale));\n   step = fold_convert (offset_type, step);\n-  step = force_gimple_operand (step, &stmts, true, NULL_TREE);\n \n   /* Create {0, X, X*2, X*3, ...}.  */\n-  *vec_offset = gimple_build (&stmts, VEC_SERIES_EXPR, gs_info->offset_vectype,\n-\t\t\t      build_zero_cst (offset_type), step);\n-  if (stmts)\n-    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+  tree offset = fold_build2 (VEC_SERIES_EXPR, gs_info->offset_vectype,\n+\t\t\t     build_zero_cst (offset_type), step);\n+  *vec_offset = cse_and_gimplify_to_preheader (loop_vinfo, offset);\n }\n \n /* Return the amount that should be added to a vector pointer to move"}]}