{"sha": "533e3abc48268dd8eee0c63ddcf133e7a14b370d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMzZTNhYmM0ODI2OGRkOGVlZTBjNjNkZGNmMTMzZTdhMTRiMzcwZA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2017-01-06T11:56:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-06T11:56:16Z"}, "message": "snames.ads-tmpl (Renamed): New name for the pragma argument.\n\n2017-01-06  Bob Duff  <duff@adacore.com>\n\n\t* snames.ads-tmpl (Renamed): New name for the pragma argument.\n\t* par-ch2.adb: Allow the new pragma (with analysis deferred\n\tto Sem_Prag).\n\t* sinfo.ads, sinfo.adb (Map_Pragma_Name, Pragma_Name_Mapped):\n\tKeep a mapping from new pragma names to old names.\n\t* sem_prag.adb: Check legality of pragma Rename_Pragma, and\n\timplement it by calling Map_Pragma_Name.\n\t* checks.adb, contracts.adb, einfo.adb, errout.adb,\n\t* exp_attr.adb, exp_ch3.adb, exp_ch6.adb, exp_ch7.adb, exp_ch9.adb,\n\t* exp_prag.adb, exp_util.adb, freeze.adb, frontend.adb, ghost.adb,\n\t* inline.adb, lib-writ.adb, scans.adb, scans.ads, sem_attr.adb,\n\t* sem_aux.adb, sem_ch10.adb, sem_ch13.adb, sem_ch6.adb, sem_ch9.adb,\n\t* sem_elab.adb, sem_res.adb, sem_util.adb, sem_util.ads,\n\t* sem_warn.adb: Call Pragma_Name_Mapped instead of Pragma_Name\n\tas appropriate.\n\nFrom-SVN: r244144", "tree": {"sha": "e8e7f4a54bb69880fbcb93c3100b1f285bc23820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8e7f4a54bb69880fbcb93c3100b1f285bc23820"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/533e3abc48268dd8eee0c63ddcf133e7a14b370d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533e3abc48268dd8eee0c63ddcf133e7a14b370d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533e3abc48268dd8eee0c63ddcf133e7a14b370d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533e3abc48268dd8eee0c63ddcf133e7a14b370d/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a62e6287d91309dd07957739d5a000fc0b0073c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62e6287d91309dd07957739d5a000fc0b0073c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62e6287d91309dd07957739d5a000fc0b0073c9"}], "stats": {"total": 418, "additions": 253, "deletions": 165}, "files": [{"sha": "4232d36ee2ef14b90fb444c2c5e4dfad033e8706", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -1,3 +1,21 @@\n+2017-01-06  Bob Duff  <duff@adacore.com>\n+\n+\t* snames.ads-tmpl (Renamed): New name for the pragma argument.\n+\t* par-ch2.adb: Allow the new pragma (with analysis deferred\n+\tto Sem_Prag).\n+\t* sinfo.ads, sinfo.adb (Map_Pragma_Name, Pragma_Name_Mapped):\n+\tKeep a mapping from new pragma names to old names.\n+\t* sem_prag.adb: Check legality of pragma Rename_Pragma, and\n+\timplement it by calling Map_Pragma_Name.\n+\t* checks.adb, contracts.adb, einfo.adb, errout.adb,\n+\t* exp_attr.adb, exp_ch3.adb, exp_ch6.adb, exp_ch7.adb, exp_ch9.adb,\n+\t* exp_prag.adb, exp_util.adb, freeze.adb, frontend.adb, ghost.adb,\n+\t* inline.adb, lib-writ.adb, scans.adb, scans.ads, sem_attr.adb,\n+\t* sem_aux.adb, sem_ch10.adb, sem_ch13.adb, sem_ch6.adb, sem_ch9.adb,\n+\t* sem_elab.adb, sem_res.adb, sem_util.adb, sem_util.ads,\n+\t* sem_warn.adb: Call Pragma_Name_Mapped instead of Pragma_Name\n+\tas appropriate.\n+\n 2017-01-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch9.adb: Minor reformatting."}, {"sha": "f9cb0ba95532056b7c78289b42a7a84c0aaf7aec", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -2412,8 +2412,7 @@ package body Checks is\n          begin\n             Prag :=\n               Make_Pragma (Loc,\n-                Pragma_Identifier            =>\n-                  Make_Identifier (Loc, Prag_Nam),\n+                Chars => Prag_Nam,\n                 Pragma_Argument_Associations => New_List (\n                   Make_Pragma_Argument_Association (Loc,\n                     Chars      => Name_Check,"}, {"sha": "7ed7e41b7ced9c1c3a6d234768a58a0474d53acb", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -115,16 +115,14 @@ package body Contracts is\n \n       --  Local variables\n \n-      Prag_Nam : Name_Id;\n-\n-   --  Start of processing for Add_Contract_Item\n-\n-   begin\n       --  A contract must contain only pragmas\n \n       pragma Assert (Nkind (Prag) = N_Pragma);\n-      Prag_Nam := Pragma_Name (Prag);\n+      Prag_Nam : constant Name_Id := Pragma_Name_Mapped (Prag);\n+\n+   --  Start of processing for Add_Contract_Item\n \n+   begin\n       --  Create a new contract when adding the first item\n \n       if No (Items) then\n@@ -577,7 +575,7 @@ package body Contracts is\n \n          Prag := Contract_Test_Cases (Items);\n          while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n+            Prag_Nam := Pragma_Name_Mapped (Prag);\n \n             if Prag_Nam = Name_Contract_Cases then\n \n@@ -606,7 +604,7 @@ package body Contracts is\n \n          Prag := Classifications (Items);\n          while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n+            Prag_Nam := Pragma_Name_Mapped (Prag);\n \n             if Prag_Nam = Name_Depends then\n                Depends := Prag;\n@@ -1021,7 +1019,7 @@ package body Contracts is\n \n          Prag := Classifications (Items);\n          while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n+            Prag_Nam := Pragma_Name_Mapped (Prag);\n \n             if Prag_Nam = Name_Initial_Condition then\n                Init_Cond := Prag;\n@@ -1787,7 +1785,7 @@ package body Contracts is\n             if Present (Items) then\n                Prag := Contract_Test_Cases (Items);\n                while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Contract_Cases then\n+                  if Pragma_Name_Mapped (Prag) = Name_Contract_Cases then\n                      Expand_Pragma_Contract_Cases\n                        (CCs     => Prag,\n                         Subp_Id => Subp_Id,\n@@ -1840,7 +1838,7 @@ package body Contracts is\n             if Present (Items) then\n                Prag := Pre_Post_Conditions (Items);\n                while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Post_Nam then\n+                  if Pragma_Name_Mapped (Prag) = Post_Nam then\n                      Append_Enabled_Item\n                        (Item => Build_Pragma_Check_Equivalent (Prag),\n                         List => Stmts);\n@@ -1862,7 +1860,7 @@ package body Contracts is\n                   --  Note that non-matching pragmas are skipped\n \n                   if Nkind (Decl) = N_Pragma then\n-                     if Pragma_Name (Decl) = Post_Nam then\n+                     if Pragma_Name_Mapped (Decl) = Post_Nam then\n                         Append_Enabled_Item\n                           (Item => Build_Pragma_Check_Equivalent (Decl),\n                            List => Stmts);\n@@ -1904,7 +1902,7 @@ package body Contracts is\n             if Present (Items) then\n                Prag := Pre_Post_Conditions (Items);\n                while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Postcondition then\n+                  if Pragma_Name_Mapped (Prag) = Name_Postcondition then\n                      Append_Enabled_Item\n                        (Item => Build_Pragma_Check_Equivalent (Prag),\n                         List => Stmts);\n@@ -1924,7 +1922,7 @@ package body Contracts is\n                if Present (Items) then\n                   Prag := Pre_Post_Conditions (Items);\n                   while Present (Prag) loop\n-                     if Pragma_Name (Prag) = Name_Postcondition\n+                     if Pragma_Name_Mapped (Prag) = Name_Postcondition\n                        and then Class_Present (Prag)\n                      then\n                         Append_Enabled_Item\n@@ -2191,7 +2189,7 @@ package body Contracts is\n                if Present (Items) then\n                   Prag := Pre_Post_Conditions (Items);\n                   while Present (Prag) loop\n-                     if Pragma_Name (Prag) = Name_Precondition\n+                     if Pragma_Name_Mapped (Prag) = Name_Precondition\n                        and then Class_Present (Prag)\n                      then\n                         Check_Prag :=\n@@ -2240,7 +2238,7 @@ package body Contracts is\n             if Present (Items) then\n                Prag := Pre_Post_Conditions (Items);\n                while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Precondition then\n+                  if Pragma_Name_Mapped (Prag) = Name_Precondition then\n                      Prepend_To_Decls_Or_Save (Prag);\n                   end if;\n \n@@ -2265,7 +2263,7 @@ package body Contracts is\n                   --  Note that non-matching pragmas are skipped\n \n                   if Nkind (Decl) = N_Pragma then\n-                     if Pragma_Name (Decl) = Name_Precondition then\n+                     if Pragma_Name_Mapped (Decl) = Name_Precondition then\n                         Prepend_To_Decls_Or_Save (Decl);\n                      end if;\n "}, {"sha": "0e66f426a4d0228fd87b126fb3b75d09bca5eb3d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -7419,7 +7419,7 @@ package body Einfo is\n       Ritem := First_Rep_Item (Id);\n       while Present (Ritem) loop\n          if Nkind (Ritem) = N_Pragma\n-           and then Pragma_Name (Ritem) = Name_Attach_Handler\n+           and then Pragma_Name_Mapped (Ritem) = Name_Attach_Handler\n          then\n             return True;\n          else\n@@ -7480,7 +7480,7 @@ package body Einfo is\n       Ritem := First_Rep_Item (Id);\n       while Present (Ritem) loop\n          if Nkind (Ritem) = N_Pragma\n-           and then Pragma_Name (Ritem) = Name_Interrupt_Handler\n+           and then Pragma_Name_Mapped (Ritem) = Name_Interrupt_Handler\n          then\n             return True;\n          else"}, {"sha": "f655452c848598f3ba68bf04e96ed2c48de25558", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -2800,7 +2800,7 @@ package body Errout is\n       --  identifiers, pragmas, and pragma argument associations.\n \n       if Nkind (Node) = N_Pragma then\n-         Nam := Pragma_Name (Node);\n+         Nam := Pragma_Name_Mapped (Node);\n          Loc := Sloc (Node);\n \n       --  The other cases have Chars fields"}, {"sha": "894a3f5a7059879e218387043b2ef1870527f029", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -8100,7 +8100,7 @@ package body Exp_Attr is\n       N := First_Rep_Item (Implementation_Base_Type (T));\n       while Present (N) loop\n          if Nkind (N) = N_Pragma\n-           and then Pragma_Name (N) = Name_Stream_Convert\n+           and then Pragma_Name_Mapped (N) = Name_Stream_Convert\n          then\n             --  For tagged types this pragma is not inherited, so we\n             --  must verify that it is defined for the given type and"}, {"sha": "81eaf8c861a52f9f82d8df83c75472bf7a847bdb", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -2758,7 +2758,7 @@ package body Exp_Ch3 is\n                            --  Conversion for Priority expression\n \n                            if Nam = Name_Priority then\n-                              if Pragma_Name (Ritem) = Name_Priority\n+                              if Pragma_Name_Mapped (Ritem) = Name_Priority\n                                 and then not GNAT_Mode\n                               then\n                                  Exp := Convert_To (RTE (RE_Priority), Exp);"}, {"sha": "85c381fca9b736ecef8353fa793ea1078ba83f67", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -5618,7 +5618,7 @@ package body Exp_Ch6 is\n \n          elsif Present (Next (N))\n            and then Nkind (Next (N)) = N_Pragma\n-           and then Get_Pragma_Id (Pragma_Name (Next (N))) = Pragma_Import\n+           and then Get_Pragma_Id (Next (N)) = Pragma_Import\n          then\n             --  In SPARK, subprogram declarations are also permitted in\n             --  declarative parts when immediately followed by a corresponding"}, {"sha": "ac188b490155446ed4bdbdd565bda523fc417e39", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -4358,8 +4358,7 @@ package body Exp_Ch7 is\n \n                Create_Append (Checks,\n                  Make_Pragma (Ploc,\n-                   Pragma_Identifier            =>\n-                     Make_Identifier (Ploc, Name_Check),\n+                   Chars                        => Name_Check,\n                    Pragma_Argument_Associations => Assoc));\n             end if;\n \n@@ -4392,7 +4391,7 @@ package body Exp_Ch7 is\n             Rep_Item := First_Rep_Item (T);\n             while Present (Rep_Item) loop\n                if Nkind (Rep_Item) = N_Pragma\n-                 and then Pragma_Name (Rep_Item) = Name_Invariant\n+                 and then Pragma_Name_Mapped (Rep_Item) = Name_Invariant\n                then\n                   --  Stop the traversal of the rep item chain once a specific\n                   --  item is encountered."}, {"sha": "7eb38b5e4d1a05286beb6eeb3402a6b4592e44b6", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -1416,7 +1416,7 @@ package body Exp_Ch9 is\n \n          Prag := Contract_Test_Cases (Items);\n          while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Contract_Cases\n+            if Pragma_Name_Mapped (Prag) = Name_Contract_Cases\n               and then Is_Checked (Prag)\n             then\n                Has_Pragma := True;\n@@ -9142,7 +9142,7 @@ package body Exp_Ch9 is\n                Ritem := First_Rep_Item (Prot_Typ);\n                while Present (Ritem) loop\n                   if Nkind (Ritem) = N_Pragma\n-                    and then Pragma_Name (Ritem) = Name_Attach_Handler\n+                    and then Pragma_Name_Mapped (Ritem) = Name_Attach_Handler\n                   then\n                      Num_Attach_Handler := Num_Attach_Handler + 1;\n                   end if;\n@@ -11682,7 +11682,7 @@ package body Exp_Ch9 is\n          N := First (Visible_Declarations (T));\n          while Present (N) loop\n             if Nkind (N) = N_Pragma\n-              and then Pragma_Name (N) = Name_Relative_Deadline\n+              and then Pragma_Name_Mapped (N) = Name_Relative_Deadline\n             then\n                return N;\n             end if;\n@@ -11693,7 +11693,7 @@ package body Exp_Ch9 is\n          N := First (Private_Declarations (T));\n          while Present (N) loop\n             if Nkind (N) = N_Pragma\n-              and then Pragma_Name (N) = Name_Relative_Deadline\n+              and then Pragma_Name_Mapped (N) = Name_Relative_Deadline\n             then\n                return N;\n             end if;\n@@ -13706,7 +13706,7 @@ package body Exp_Ch9 is\n \n                   --  Get_Rep_Item returns either priority pragma.\n \n-                  if Pragma_Name (Prio_Clause) = Name_Priority then\n+                  if Pragma_Name_Mapped (Prio_Clause) = Name_Priority then\n                      Prio_Type := RTE (RE_Any_Priority);\n                   else\n                      Prio_Type := RTE (RE_Interrupt_Priority);\n@@ -13940,7 +13940,7 @@ package body Exp_Ch9 is\n \n             while Present (Ritem) loop\n                if Nkind (Ritem) = N_Pragma\n-                 and then Pragma_Name (Ritem) = Name_Attach_Handler\n+                 and then Pragma_Name_Mapped (Ritem) = Name_Attach_Handler\n                then\n                   declare\n                      Handler : constant Node_Id :="}, {"sha": "30284ae48776402cae21b630394e8ff709c2c3e7", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -162,7 +162,7 @@ package body Exp_Prag is\n    ---------------------\n \n    procedure Expand_N_Pragma (N : Node_Id) is\n-      Pname : constant Name_Id := Pragma_Name (N);\n+      Pname : constant Name_Id := Pragma_Name_Mapped (N);\n \n    begin\n       --  Rewrite pragma ignored by Ignore_Pragma to null statement, so that\n@@ -174,52 +174,48 @@ package body Exp_Prag is\n          return;\n       end if;\n \n-      --  Note: we may have a pragma whose Pragma_Identifier field is not a\n-      --  recognized pragma, and we must ignore it at this stage.\n+      case Get_Pragma_Id (Pname) is\n \n-      if Is_Pragma_Name (Pname) then\n-         case Get_Pragma_Id (Pname) is\n+         --  Pragmas requiring special expander action\n \n-            --  Pragmas requiring special expander action\n+         when Pragma_Abort_Defer =>\n+            Expand_Pragma_Abort_Defer (N);\n \n-            when Pragma_Abort_Defer =>\n-               Expand_Pragma_Abort_Defer (N);\n+         when Pragma_Check =>\n+            Expand_Pragma_Check (N);\n \n-            when Pragma_Check =>\n-               Expand_Pragma_Check (N);\n+         when Pragma_Common_Object =>\n+            Expand_Pragma_Common_Object (N);\n \n-            when Pragma_Common_Object =>\n-               Expand_Pragma_Common_Object (N);\n+         when Pragma_Import =>\n+            Expand_Pragma_Import_Or_Interface (N);\n \n-            when Pragma_Import =>\n-               Expand_Pragma_Import_Or_Interface (N);\n+         when Pragma_Inspection_Point =>\n+            Expand_Pragma_Inspection_Point (N);\n \n-            when Pragma_Inspection_Point =>\n-               Expand_Pragma_Inspection_Point (N);\n+         when Pragma_Interface =>\n+            Expand_Pragma_Import_Or_Interface (N);\n \n-            when Pragma_Interface =>\n-               Expand_Pragma_Import_Or_Interface (N);\n+         when Pragma_Interrupt_Priority =>\n+            Expand_Pragma_Interrupt_Priority (N);\n \n-            when Pragma_Interrupt_Priority =>\n-               Expand_Pragma_Interrupt_Priority (N);\n+         when Pragma_Loop_Variant =>\n+            Expand_Pragma_Loop_Variant (N);\n \n-            when Pragma_Loop_Variant =>\n-               Expand_Pragma_Loop_Variant (N);\n+         when Pragma_Psect_Object =>\n+            Expand_Pragma_Psect_Object (N);\n \n-            when Pragma_Psect_Object =>\n-               Expand_Pragma_Psect_Object (N);\n+         when Pragma_Relative_Deadline =>\n+            Expand_Pragma_Relative_Deadline (N);\n \n-            when Pragma_Relative_Deadline =>\n-               Expand_Pragma_Relative_Deadline (N);\n+         when Pragma_Suppress_Initialization =>\n+            Expand_Pragma_Suppress_Initialization (N);\n \n-            when Pragma_Suppress_Initialization =>\n-               Expand_Pragma_Suppress_Initialization (N);\n+         --  All other pragmas need no expander action (includes\n+         --  Unknown_Pragma).\n \n-            --  All other pragmas need no expander action\n-\n-            when others => null;\n-         end case;\n-      end if;\n+         when others => null;\n+      end case;\n \n    end Expand_N_Pragma;\n \n@@ -1292,7 +1288,7 @@ package body Exp_Prag is\n \n       if Relaxed_RM_Semantics\n         and then List_Length (Pragma_Argument_Associations (N)) = 2\n-        and then Chars (Pragma_Identifier (N)) = Name_Import\n+        and then Pragma_Name_Mapped (N) = Name_Import\n         and then Nkind (Arg2 (N)) = N_String_Literal\n       then\n          Def_Id := Entity (Arg1 (N));"}, {"sha": "31eaf6ef095b56baf9fa21d61ac57b32412ae2d0", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -3901,7 +3901,7 @@ package body Exp_Util is\n \n       begin\n          if Nkind (N) = N_Pragma\n-           and then Get_Pragma_Id (Pragma_Name (N)) = Pragma_Annotate\n+           and then Get_Pragma_Id (N) = Pragma_Annotate\n            and then List_Length (Pragma_Argument_Associations (N)) = 2\n          then\n             declare\n@@ -6856,7 +6856,7 @@ package body Exp_Util is\n \n       return\n         Make_Pragma (Loc,\n-          Pragma_Identifier            => Make_Identifier (Loc, Name_Check),\n+          Chars                        => Name_Check,\n           Pragma_Argument_Associations => Arg_List);\n    end Make_Predicate_Check;\n "}, {"sha": "44b306dda6fd8b1294c96834df3de8ba9ba50c04", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -8464,7 +8464,7 @@ package body Freeze is\n \n             if Present (Decl)\n               and then Nkind (Decl) = N_Pragma\n-              and then Pragma_Name (Decl) = Name_Import\n+              and then Pragma_Name_Mapped (Decl) = Name_Import\n             then\n                return;\n             end if;"}, {"sha": "1f06614ce4f8bd306bdce0e7ed0a86e1707a4b41", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -492,7 +492,7 @@ begin\n       Item := First (Context_Items (Cunit (Main_Unit)));\n       while Present (Item) loop\n          if Nkind (Item) = N_Pragma\n-           and then Pragma_Name (Item) = Name_Initialize_Scalars\n+           and then Pragma_Name_Mapped (Item) = Name_Initialize_Scalars\n          then\n             Initialize_Scalars := True;\n          end if;"}, {"sha": "fd0d34edbe30c49823cba6ac87f777d0305bb612", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -992,7 +992,7 @@ package body Ghost is\n \n       while Present (Decl) loop\n          if Nkind (Decl) = N_Pragma\n-           and then Pragma_Name (Decl) = Name_Ghost\n+           and then Pragma_Name_Mapped (Decl) = Name_Ghost\n          then\n             return\n               Enables_Ghostness (First (Pragma_Argument_Associations (Decl)));"}, {"sha": "4ecd11a956100bc34cbacdf3ca19847918a3795b", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -2541,7 +2541,7 @@ package body Inline is\n          --  not be posting warnings on the inlined body so it is unneeded.\n \n          elsif Nkind (N) = N_Pragma\n-           and then Pragma_Name (N) = Name_Unreferenced\n+           and then Pragma_Name_Mapped (N) = Name_Unreferenced\n          then\n             Rewrite (N, Make_Null_Statement (Sloc (N)));\n             return OK;"}, {"sha": "ae6dbf750223fac530b6923defea4aa8cb40af2a", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -672,7 +672,7 @@ package body Lib.Writ is\n                   Write_Info_Initiate ('N');\n                   Write_Info_Char (' ');\n \n-                  case Chars (Pragma_Identifier (N)) is\n+                  case Pragma_Name (N) is\n                      when Name_Annotate =>\n                         C := 'A';\n                      when Name_Comment =>"}, {"sha": "fd8b963d22b6018c294ac12ecea32f07f5a6ddd8", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -279,12 +279,10 @@ package body Ch2 is\n       --  Ada 2005 (AI-284): INTERFACE is a new reserved word but it is\n       --  allowed as a pragma name.\n \n-      if Ada_Version >= Ada_2005\n-        and then Token = Tok_Interface\n-      then\n-         Prag_Name  := Name_Interface;\n-         Ident_Node := Make_Identifier (Token_Ptr, Name_Interface);\n-         Scan; -- past INTERFACE\n+      if Is_Reserved_Keyword (Token) then\n+         Prag_Name  := Keyword_Name (Token);\n+         Ident_Node := Make_Identifier (Token_Ptr, Prag_Name);\n+         Scan; -- past the keyword\n       else\n          Ident_Node := P_Identifier;\n       end if;\n@@ -490,8 +488,8 @@ package body Ch2 is\n       Reserved_Words_OK : Boolean := False)\n    is\n       function P_Expression_Or_Reserved_Word return Node_Id;\n-      --  Parse an expression or, if the token denotes one of the following\n-      --  reserved words, construct an identifier with proper Chars field.\n+      --  Parse an expression or, if the token is one of the following reserved\n+      --  words, construct an identifier with proper Chars field.\n       --    Access\n       --    Delta\n       --    Digits"}, {"sha": "461a3784b53944a008d154ebfc5a406ee330f3a2", "filename": "gcc/ada/scans.adb", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fscans.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fscans.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -143,6 +143,29 @@ package body Scans is\n \n    end Initialize_Ada_Keywords;\n \n+   ------------------\n+   -- Keyword_Name --\n+   ------------------\n+\n+   function Keyword_Name (Token : Token_Type) return Name_Id is\n+      Tok : String := Token'Img;\n+      pragma Assert (Tok (1 .. 4) = \"TOK_\");\n+      Name : String renames Tok (5 .. Tok'Last);\n+   begin\n+      --  Convert to lower case. We don't want to add a dependence on a\n+      --  general-purpose To_Lower routine, so we convert \"by hand\" here.\n+      --  All keywords use 7-bit ASCII letters only, so this works.\n+\n+      for J in Name'Range loop\n+         pragma Assert (Name (J) in 'A' .. 'Z');\n+         Name (J) :=\n+           Character'Val (Character'Pos (Name (J)) +\n+                            (Character'Pos ('a') - Character'Pos ('A')));\n+      end loop;\n+\n+      return Name_Find (Name);\n+   end Keyword_Name;\n+\n    ------------------------\n    -- Restore_Scan_State --\n    ------------------------"}, {"sha": "afbdf96aab2cddc9575ee15f3586744a7c4d8711", "filename": "gcc/ada/scans.ads", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,10 +45,6 @@ package Scans is\n    --  The class column in this table indicates the token classes which\n    --  apply to the token, as defined by subsequent subtype declarations.\n \n-   --  Note: Namet.Is_Keyword_Name depends on the fact that the first entry in\n-   --  this type declaration is *not* for a reserved word. For details on why\n-   --  there is this requirement, see Initialize_Ada_Keywords below.\n-\n    type Token_Type is (\n \n       --  Token name          Token type   Class(es)\n@@ -228,6 +224,11 @@ package Scans is\n       --  No_Token is used for initializing Token values to indicate that\n       --  no value has been set yet.\n \n+   function Keyword_Name (Token : Token_Type) return Name_Id;\n+   --  Given a token that is a reserved word, return the corresponding Name_Id\n+   --  in lower case. E.g. Keyword_Name (Tok_Begin) = Name_Find (\"begin\").\n+   --  It is an error to pass any other kind of token.\n+\n    --  Note: in the RM, operator symbol is a special case of string literal.\n    --  We distinguish at the lexical level in this compiler, since there are\n    --  many syntactic situations in which only an operator symbol is allowed."}, {"sha": "393ebe90b066020e3b869df941c248495b69266f", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -1306,7 +1306,7 @@ package body Sem_Attr is\n             if Nkind (Prag) = N_Aspect_Specification then\n                Prag_Nam := Chars (Identifier (Prag));\n             else\n-               Prag_Nam := Pragma_Name (Prag);\n+               Prag_Nam := Pragma_Name_Mapped (Prag);\n             end if;\n \n             if Prag_Nam = Name_Check then"}, {"sha": "326cd073abe7c07d4824b86a533b7d12f1a1a3a4", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -512,9 +512,10 @@ package body Sem_Aux is\n            and then\n              (Pragma_Name (N) = Nam\n                or else (Nam = Name_Priority\n-                         and then Pragma_Name (N) = Name_Interrupt_Priority)\n+                         and then Pragma_Name_Mapped (N) =\n+                           Name_Interrupt_Priority)\n                or else (Nam = Name_Interrupt_Priority\n-                         and then Pragma_Name (N) = Name_Priority))\n+                         and then Pragma_Name_Mapped (N) = Name_Priority))\n          then\n             if Check_Parents then\n                return N;"}, {"sha": "9cd1489eef172a04255c905a07d66c54566d076b", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -1332,7 +1332,7 @@ package body Sem_Ch10 is\n       Item := First (Context_Items (N));\n       while Present (Item)\n         and then Nkind (Item) = N_Pragma\n-        and then Pragma_Name (Item) in Configuration_Pragma_Names\n+        and then Pragma_Name_Mapped (Item) in Configuration_Pragma_Names\n       loop\n          Analyze (Item);\n          Next (Item);\n@@ -3384,7 +3384,7 @@ package body Sem_Ch10 is\n       Item := First (Context_Items (N));\n       while Present (Item)\n         and then Nkind (Item) = N_Pragma\n-        and then Pragma_Name (Item) in Configuration_Pragma_Names\n+        and then Pragma_Name_Mapped (Item) in Configuration_Pragma_Names\n       loop\n          Next (Item);\n       end loop;\n@@ -4526,7 +4526,7 @@ package body Sem_Ch10 is\n                   Check_Declarations (Specification (Decl));\n \n                elsif Nkind (Decl) = N_Pragma\n-                 and then Pragma_Name (Decl) = Name_Import\n+                 and then Pragma_Name_Mapped (Decl) = Name_Import\n                then\n                   Check_Pragma_Import (Decl);\n                end if;\n@@ -4558,7 +4558,7 @@ package body Sem_Ch10 is\n                   Append_Elmt (Decl, Incomplete_Decls);\n \n                elsif Nkind (Decl) = N_Pragma\n-                 and then Pragma_Name (Decl) = Name_Import\n+                 and then Pragma_Name_Mapped (Decl) = Name_Import\n                then\n                   Check_Pragma_Import (Decl);\n                end if;\n@@ -5826,7 +5826,7 @@ package body Sem_Ch10 is\n \n             Decl := First (Decls);\n             while Present (Decl) and then Nkind (Decl) = N_Pragma loop\n-               if Pragma_Name (Decl) = Name_Abstract_State then\n+               if Pragma_Name_Mapped (Decl) = Name_Abstract_State then\n                   Process_State\n                     (Get_Pragma_Arg\n                        (First (Pragma_Argument_Associations (Decl))));"}, {"sha": "1685ff3d33636ba4b04eaf3aea5b3ca8663c2f1e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -6868,7 +6868,7 @@ package body Sem_Ch13 is\n \n             --  The only pragma of interest is Complete_Representation\n \n-            if Pragma_Name (CC) = Name_Complete_Representation then\n+            if Pragma_Name_Mapped (CC) = Name_Complete_Representation then\n                CR_Pragma := CC;\n             end if;\n \n@@ -8406,7 +8406,7 @@ package body Sem_Ch13 is\n          Ritem := First_Rep_Item (Typ);\n          while Present (Ritem) loop\n             if Nkind (Ritem) = N_Pragma\n-              and then Pragma_Name (Ritem) = Name_Predicate\n+              and then Pragma_Name_Mapped (Ritem) = Name_Predicate\n             then\n                Add_Predicate (Ritem);\n \n@@ -8424,7 +8424,7 @@ package body Sem_Ch13 is\n \n                begin\n                   if Nkind (Prag) = N_Pragma\n-                    and then Pragma_Name (Prag) = Name_Predicate\n+                    and then Pragma_Name_Mapped (Prag) = Name_Predicate\n                   then\n                      Add_Predicate (Prag);\n                   end if;\n@@ -12367,7 +12367,7 @@ package body Sem_Ch13 is\n \n       if Is_Overloadable (T) and then Nkind (N) = N_Pragma then\n          declare\n-            Pname : constant Name_Id := Pragma_Name (N);\n+            Pname : constant Name_Id := Pragma_Name_Mapped (N);\n          begin\n             if Nam_In (Pname, Name_Convention, Name_Import,   Name_Export,\n                               Name_External,   Name_Interface)\n@@ -13560,7 +13560,7 @@ package body Sem_Ch13 is\n \n       procedure No_Independence is\n       begin\n-         if Pragma_Name (N) = Name_Independent then\n+         if Pragma_Name_Mapped (N) = Name_Independent then\n             Error_Msg_NE (\"independence cannot be guaranteed for&\", N, E);\n          else\n             Error_Msg_NE\n@@ -13691,7 +13691,7 @@ package body Sem_Ch13 is\n       for J in Independence_Checks.First .. Independence_Checks.Last loop\n          N  := Independence_Checks.Table (J).N;\n          E  := Independence_Checks.Table (J).E;\n-         IC := Pragma_Name (N) = Name_Independent_Components;\n+         IC := Pragma_Name_Mapped (N) = Name_Independent_Components;\n \n          --  Deal with component case\n "}, {"sha": "014c2d4bbb72db3c6c05eb99c3f87b7e96b8e1ab", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -2692,7 +2692,7 @@ package body Sem_Ch6 is\n                   Analyze (Prag);\n                   Set_Has_Pragma_Inline (Subp);\n \n-                  if Pragma_Name (Prag) = Name_Inline_Always then\n+                  if Pragma_Name_Mapped (Prag) = Name_Inline_Always then\n                      Set_Is_Inlined (Subp);\n                      Set_Has_Pragma_Inline_Always (Subp);\n                   end if;\n@@ -6064,7 +6064,7 @@ package body Sem_Ch6 is\n \n          begin\n             if Nkind (Orig) = N_Pragma\n-              and then Pragma_Name (Orig) = Name_Assert\n+              and then Pragma_Name_Mapped (Orig) = Name_Assert\n               and then not Error_Posted (Orig)\n             then\n                declare\n@@ -9301,7 +9301,7 @@ package body Sem_Ch6 is\n                      if Class_Present (Prag)\n                        and then not Split_PPC (Prag)\n                      then\n-                        if Pragma_Name (Prag) = Name_Precondition then\n+                        if Pragma_Name_Mapped (Prag) = Name_Precondition then\n                            Error_Msg_N\n                              (\"info: & inherits `Pre''Class` aspect from \"\n                               & \"#?L?\", E);"}, {"sha": "1c01f3e74a2a044f575d2f44bf476927cb48eba1", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -498,9 +498,10 @@ package body Sem_Ch9 is\n \n                      elsif Kind = N_Pragma then\n                         declare\n-                           Prag_Name : constant Name_Id   := Pragma_Name (N);\n+                           Prag_Name : constant Name_Id   :=\n+                             Pragma_Name_Mapped (N);\n                            Prag_Id   : constant Pragma_Id :=\n-                                         Get_Pragma_Id (Prag_Name);\n+                             Get_Pragma_Id (Prag_Name);\n \n                         begin\n                            if Prag_Id = Pragma_Export\n@@ -2148,7 +2149,7 @@ package body Sem_Ch9 is\n                --  Pragma case\n \n                else\n-                  Error_Msg_Name_1 := Pragma_Name (Prio_Item);\n+                  Error_Msg_Name_1 := Pragma_Name_Mapped (Prio_Item);\n                   Error_Msg_NE\n                     (\"pragma% for & has no effect when Lock_Free given??\",\n                      Prio_Item, Id);\n@@ -2188,7 +2189,7 @@ package body Sem_Ch9 is\n                --  Pragma case\n \n                elsif Nkind (Prio_Item) = N_Pragma\n-                 and then Pragma_Name (Prio_Item) = Name_Priority\n+                 and then Pragma_Name_Mapped (Prio_Item) = Name_Priority\n                then\n                   Error_Msg_N\n                     (\"pragma Interrupt_Priority is preferred in presence of \""}, {"sha": "e623262138e846158cee29e52ec0cf7746be1f55", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -2099,7 +2099,7 @@ package body Sem_Elab is\n          Par := Call;\n          while Present (Par) loop\n             if Nkind (Par) = N_Pragma then\n-               Nam := Pragma_Name (Par);\n+               Nam := Pragma_Name_Mapped (Par);\n \n                --  Pragma Initial_Condition appears in its alternative from as\n                --  Check (Initial_Condition, ...).\n@@ -2485,7 +2485,7 @@ package body Sem_Elab is\n                --  Or, in the case of an initial condition, specifically by a\n                --  Check pragma specifying an Initial_Condition check.\n \n-               elsif Pragma_Name (O) = Name_Check\n+               elsif Pragma_Name_Mapped (O) = Name_Check\n                  and then\n                    Chars\n                      (Expression (First (Pragma_Argument_Associations (O)))) =\n@@ -3716,7 +3716,7 @@ package body Sem_Elab is\n          Item := First (Context_Items (CU));\n          while Present (Item) loop\n             if Nkind (Item) = N_Pragma\n-              and then Pragma_Name (Item) = Name_Elaborate_All\n+              and then Pragma_Name_Mapped (Item) = Name_Elaborate_All\n             then\n                --  Return if some previous error on the pragma itself. The\n                --  pragma may be unanalyzed, because of a previous error, or"}, {"sha": "a5ae0d0d39e97ecd502ad534556167eb2230f187", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -2006,7 +2006,7 @@ package body Sem_Prag is\n          return;\n       end if;\n \n-      Error_Msg_Name_1 := Pragma_Name (N);\n+      Error_Msg_Name_1 := Pragma_Name_Mapped (N);\n \n       --  An external property pragma must apply to an effectively volatile\n       --  object other than a formal subprogram parameter (SPARK RM 7.1.3(2)).\n@@ -5289,7 +5289,7 @@ package body Sem_Prag is\n          --  previously given aspect specification or attribute definition\n          --  clause for the same pragma.\n \n-         P := Get_Rep_Item (E, Pragma_Name (N), Check_Parents => False);\n+         P := Get_Rep_Item (E, Pragma_Name_Mapped (N), Check_Parents => False);\n \n          if Present (P) then\n \n@@ -5322,7 +5322,7 @@ package body Sem_Prag is\n \n             --  Here we have a definite duplicate\n \n-            Error_Msg_Name_1 := Pragma_Name (N);\n+            Error_Msg_Name_1 := Pragma_Name_Mapped (N);\n             Error_Msg_Sloc := Sloc (P);\n \n             --  For a single protected or a single task object, the error is\n@@ -6496,7 +6496,7 @@ package body Sem_Prag is\n          if Is_Rewrite_Substitution (N)\n            and then Nkind (Original_Node (N)) = N_Pragma\n          then\n-            Error_Msg_Name_1 := Pragma_Name (Original_Node (N));\n+            Error_Msg_Name_1 := Pragma_Name_Mapped (Original_Node (N));\n          end if;\n \n          --  Case where pragma comes from an aspect specification\n@@ -7212,7 +7212,7 @@ package body Sem_Prag is\n \n                      if Nam_In (Pragma_Name (Decl), Name_Export,\n                                                     Name_Convention,\n-                                                    Pragma_Name (N))\n+                                                    Pragma_Name_Mapped (N))\n                      then\n                         exit;\n \n@@ -10381,7 +10381,7 @@ package body Sem_Prag is\n \n       --  Deal with unrecognized pragma\n \n-      Pname := Pragma_Name (N);\n+      Pname := Pragma_Name_Mapped (N);\n \n       if not Is_Pragma_Name (Pname) then\n          if Warn_On_Unrecognized_Pragma then\n@@ -13800,7 +13800,7 @@ package body Sem_Prag is\n                --  Skip prior pragmas, but check for duplicates\n \n                if Nkind (Stmt) = N_Pragma then\n-                  if Pragma_Name (Stmt) = Pname then\n+                  if Pragma_Name_Mapped (Stmt) = Pname then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_Sloc   := Sloc (Stmt);\n                      Error_Msg_N (\"pragma % duplicates pragma declared#\", N);\n@@ -15290,7 +15290,7 @@ package body Sem_Prag is\n                --  Skip prior pragmas, but check for duplicates\n \n                if Nkind (Stmt) = N_Pragma then\n-                  if Pragma_Name (Stmt) = Pname then\n+                  if Pragma_Name_Mapped (Stmt) = Pname then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_Sloc   := Sloc (Stmt);\n                      Error_Msg_N (\"pragma % duplicates pragma declared#\", N);\n@@ -16564,7 +16564,7 @@ package body Sem_Prag is\n                   if Is_Imported (Def_Id)\n                     and then Present (First_Rep_Item (Def_Id))\n                     and then Nkind (First_Rep_Item (Def_Id)) = N_Pragma\n-                    and then Pragma_Name (First_Rep_Item (Def_Id)) =\n+                    and then Pragma_Name_Mapped (First_Rep_Item (Def_Id)) =\n                       Name_Interface\n                   then\n                      null;\n@@ -17604,7 +17604,7 @@ package body Sem_Prag is\n             Nod := Next (N);\n             while Present (Nod) loop\n                if Nkind (Nod) = N_Pragma\n-                 and then Pragma_Name (Nod) = Name_Main\n+                 and then Pragma_Name_Mapped (Nod) = Name_Main\n                then\n                   Error_Msg_Name_1 := Pname;\n                   Error_Msg_N (\"duplicate pragma% not permitted\", Nod);\n@@ -17648,7 +17648,7 @@ package body Sem_Prag is\n             Nod := Next (N);\n             while Present (Nod) loop\n                if Nkind (Nod) = N_Pragma\n-                 and then Pragma_Name (Nod) = Name_Main_Storage\n+                 and then Pragma_Name_Mapped (Nod) = Name_Main_Storage\n                then\n                   Error_Msg_Name_1 := Pname;\n                   Error_Msg_N (\"duplicate pragma% not permitted\", Nod);\n@@ -19040,20 +19040,40 @@ package body Sem_Prag is\n \n          --  pragma Rename_Pragma (\n          --           [New_Name =>] IDENTIFIER,\n-         --           [Renames  =>] pragma_IDENTIFIER);\n-\n-         --  ??? this is work in progress\n+         --           [Renamed  =>] pragma_IDENTIFIER);\n \n          pragma Warnings (Off);\n          when Pragma_Rename_Pragma => Rename_Pragma : declare\n-            GNAT_Pragma_Arg : constant Node_Id := Get_Pragma_Arg (Arg2);\n-            Synonym         : constant Node_Id := Get_Pragma_Arg (Arg1);\n-\n+            New_Name : constant Node_Id := Get_Pragma_Arg (Arg1);\n+            Old_Name : constant Node_Id := Get_Pragma_Arg (Arg2);\n          begin\n             GNAT_Pragma;\n+            Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (2);\n             Check_Optional_Identifier (Arg1, Name_New_Name);\n-            Check_Optional_Identifier (Arg2, Name_Renames);\n+            Check_Optional_Identifier (Arg2, Name_Renamed);\n+\n+            if Nkind (New_Name) /= N_Identifier then\n+               Error_Pragma_Arg (\"identifier expected\", Arg1);\n+            end if;\n+\n+            if Nkind (Old_Name) /= N_Identifier then\n+               Error_Pragma_Arg (\"identifier expected\", Arg2);\n+            end if;\n+\n+            --  The New_Name arg should not be an existing pragma (but we allow\n+            --  it; it's just a warning). The Old_Name arg must be an existing\n+            --  pragma.\n+\n+            if Is_Pragma_Name (Chars (New_Name)) then\n+               Error_Pragma_Arg (\"??pragma is already defined\", Arg1);\n+            end if;\n+\n+            if not Is_Pragma_Name (Chars (Old_Name)) then\n+               Error_Pragma_Arg (\"existing pragma name expected\", Arg1);\n+            end if;\n+\n+            Map_Pragma_Name (From => Chars (New_Name), To => Chars (Old_Name));\n          end Rename_Pragma;\n          pragma Warnings (On);\n \n@@ -19694,7 +19714,7 @@ package body Sem_Prag is\n \n                Import :=\n                  Make_Pragma (Loc,\n-                   Chars                        => Name_Import,\n+                   Chars => Name_Import,\n                    Pragma_Argument_Associations => New_List (\n                      Make_Pragma_Argument_Association (Loc,\n                        Expression => Make_Identifier (Loc, Name_Intrinsic)),\n@@ -21357,7 +21377,7 @@ package body Sem_Prag is\n                   --  this also takes care of pragmas generated for aspects.\n \n                   if Nkind (Stmt) = N_Pragma then\n-                     if Pragma_Name (Stmt) = Pname then\n+                     if Pragma_Name_Mapped (Stmt) = Pname then\n                         Error_Msg_Name_1 := Pname;\n                         Error_Msg_Sloc   := Sloc (Stmt);\n                         Error_Msg_N (\"pragma% duplicates pragma declared#\", N);\n@@ -22207,7 +22227,7 @@ package body Sem_Prag is\n                if Present (Items) then\n                   Prag := Contract_Test_Cases (Items);\n                   while Present (Prag) loop\n-                     if Pragma_Name (Prag) = Name_Test_Case\n+                     if Pragma_Name_Mapped (Prag) = Name_Test_Case\n                        and then Prag /= N\n                        and then String_Equal\n                                   (Name, Get_Name_From_CTC_Pragma (Prag))\n@@ -22437,7 +22457,7 @@ package body Sem_Prag is\n                Nod := Next (N);\n                while Present (Nod) loop\n                   if Nkind (Nod) = N_Pragma\n-                    and then Pragma_Name (Nod) = Name_Time_Slice\n+                    and then Pragma_Name_Mapped (Nod) = Name_Time_Slice\n                   then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_N (\"duplicate pragma% not permitted\", Nod);\n@@ -26928,7 +26948,7 @@ package body Sem_Prag is\n       --  Local variables\n \n       Loc          : constant Source_Ptr := Sloc (Prag);\n-      Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n+      Prag_Nam     : constant Name_Id    := Pragma_Name_Mapped (Prag);\n       Check_Prag   : Node_Id;\n       Msg_Arg      : Node_Id;\n       Nam          : Name_Id;\n@@ -27964,7 +27984,9 @@ package body Sem_Prag is\n          --  Skip prior pragmas, but check for duplicates\n \n          if Nkind (Stmt) = N_Pragma then\n-            if Do_Checks and then Pragma_Name (Stmt) = Pragma_Name (Prag) then\n+            if Do_Checks\n+              and then Pragma_Name_Mapped (Stmt) = Pragma_Name_Mapped (Prag)\n+            then\n                Duplication_Error\n                  (Prag => Prag,\n                   Prev => Stmt);\n@@ -28171,7 +28193,7 @@ package body Sem_Prag is\n       Do_Checks : Boolean := False) return Node_Id\n    is\n       Context  : constant Node_Id := Parent (Prag);\n-      Prag_Nam : constant Name_Id := Pragma_Name (Prag);\n+      Prag_Nam : constant Name_Id := Pragma_Name_Mapped (Prag);\n       Stmt     : Node_Id;\n \n    begin\n@@ -28181,7 +28203,7 @@ package body Sem_Prag is\n          --  Skip prior pragmas, but check for duplicates\n \n          if Nkind (Stmt) = N_Pragma then\n-            if Do_Checks and then Pragma_Name (Stmt) = Prag_Nam then\n+            if Do_Checks and then Pragma_Name_Mapped (Stmt) = Prag_Nam then\n                Duplication_Error\n                  (Prag => Prag,\n                   Prev => Stmt);\n@@ -28558,7 +28580,7 @@ package body Sem_Prag is\n    begin\n       pragma Assert\n         (Nkind (N) = N_Pragma\n-          and then Pragma_Name (N) = Name_SPARK_Mode\n+          and then Pragma_Name_Mapped (N) = Name_SPARK_Mode\n           and then Is_List_Member (N));\n \n       --  Pragma SPARK_Mode affects the elaboration of a package body when it\n@@ -28930,7 +28952,7 @@ package body Sem_Prag is\n    function Is_Pragma_String_Literal (Par : Node_Id) return Boolean is\n       Pragn : constant Node_Id := Parent (Par);\n       Assoc : constant List_Id := Pragma_Argument_Associations (Pragn);\n-      Pname : constant Name_Id := Pragma_Name (Pragn);\n+      Pname : constant Name_Id := Pragma_Name_Mapped (Pragn);\n       Argn  : Natural;\n       N     : Node_Id;\n \n@@ -28992,7 +29014,7 @@ package body Sem_Prag is\n    begin\n       pragma Assert\n         (Nkind (N) = N_Pragma\n-          and then Pragma_Name (N) = Name_SPARK_Mode\n+          and then Pragma_Name_Mapped (N) = Name_SPARK_Mode\n           and then Is_List_Member (N));\n \n       --  For pragma SPARK_Mode to be private, it has to appear in the private"}, {"sha": "692a00ae20b44b2fdf32b1c175890f75a93160c0", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -10018,7 +10018,7 @@ package body Sem_Res is\n             --  Special handling of Asssert pragma\n \n             if Nkind (Orig) = N_Pragma\n-              and then Pragma_Name (Orig) = Name_Assert\n+              and then Pragma_Name_Mapped (Orig) = Name_Assert\n             then\n                declare\n                   Expr : constant Node_Id :=\n@@ -10059,7 +10059,7 @@ package body Sem_Res is\n             --  Similar processing for Check pragma\n \n             elsif Nkind (Orig) = N_Pragma\n-              and then Pragma_Name (Orig) = Name_Check\n+              and then Pragma_Name_Mapped (Orig) = Name_Check\n             then\n                --  Don't want to warn if original condition is explicit False\n "}, {"sha": "64cbbea3be0c096a334c8805bf43cd9c0df3d6c8", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -1319,9 +1319,7 @@ package body Sem_Util is\n \n                Stmt :=\n                  Make_Pragma (Loc,\n-                   Pragma_Identifier            =>\n-                     Make_Identifier (Loc, Name_Check),\n-\n+                   Chars            => Name_Check,\n                    Pragma_Argument_Associations => New_List (\n                      Make_Pragma_Argument_Association (Loc,\n                        Expression =>\n@@ -2025,7 +2023,7 @@ package body Sem_Util is\n       Par := Parent (Ref);\n       while Present (Par) loop\n          if Nkind (Par) = N_Pragma then\n-            Prag_Nam := Pragma_Name (Par);\n+            Prag_Nam := Pragma_Name_Mapped (Par);\n \n             --  A concurrent constituent is allowed to appear in pragmas\n             --  Initial_Condition and Initializes as this is part of the\n@@ -3417,12 +3415,12 @@ package body Sem_Util is\n                Check_Function_Result (Expr);\n \n                if not Mentions_Post_State (Expr) then\n-                  if Pragma_Name (Prag) = Name_Contract_Cases then\n+                  if Pragma_Name_Mapped (Prag) = Name_Contract_Cases then\n                      Error_Msg_NE\n                        (\"contract case does not check the outcome of calling \"\n                         & \"&?T?\", Expr, Subp_Id);\n \n-                  elsif Pragma_Name (Prag) = Name_Refined_Post then\n+                  elsif Pragma_Name_Mapped (Prag) = Name_Refined_Post then\n                      Error_Msg_NE\n                        (\"refined postcondition does not check the outcome of \"\n                         & \"calling &?T?\", Prag, Subp_Id);\n@@ -3534,7 +3532,7 @@ package body Sem_Util is\n          Expr  : constant Node_Id :=\n                    Get_Pragma_Arg\n                      (First (Pragma_Argument_Associations (Prag)));\n-         Nam   : constant Name_Id := Pragma_Name (Prag);\n+         Nam   : constant Name_Id := Pragma_Name_Mapped (Prag);\n          CCase : Node_Id;\n \n       --  Start of processing for Check_Result_And_Post_State_In_Pragma\n@@ -3643,7 +3641,7 @@ package body Sem_Util is\n \n       Prag := Contract_Test_Cases (Items);\n       while Present (Prag) loop\n-         if Pragma_Name (Prag) = Name_Contract_Cases\n+         if Pragma_Name_Mapped (Prag) = Name_Contract_Cases\n            and then not Error_Posted (Prag)\n          then\n             Case_Prag := Prag;\n@@ -5172,7 +5170,7 @@ package body Sem_Util is\n \n       Arg : constant Node_Id :=\n               Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n-      Nam : constant Name_Id := Pragma_Name (Prag);\n+      Nam : constant Name_Id := Pragma_Name_Mapped (Prag);\n \n    --  Start of processing for Contains_Refined_State\n \n@@ -6984,7 +6982,7 @@ package body Sem_Util is\n          Decl := Next (Unit_Declaration_Node (Subp));\n          while Present (Decl) loop\n             if Nkind (Decl) = N_Pragma\n-              and then Pragma_Name (Decl) = Name_Extensions_Visible\n+              and then Pragma_Name_Mapped (Decl) = Name_Extensions_Visible\n             then\n                Prag := Decl;\n                exit;\n@@ -10993,7 +10991,7 @@ package body Sem_Util is\n       loop\n          if No (P) then\n             return False;\n-         elsif Nkind (P) = N_Pragma and then Pragma_Name (P) = Nam then\n+         elsif Nkind (P) = N_Pragma and then Pragma_Name_Mapped (P) = Nam then\n             return True;\n          else\n             P := Parent (P);\n@@ -12359,7 +12357,7 @@ package body Sem_Util is\n \n             elsif Nkind (P) = N_Pragma\n               and then\n-                Get_Pragma_Id (Pragma_Name (P)) = Pragma_Predicate_Failure\n+                Get_Pragma_Id (P) = Pragma_Predicate_Failure\n             then\n                return True;\n             end if;\n@@ -14052,7 +14050,7 @@ package body Sem_Util is\n          Nam := Chars (Identifier (Item));\n \n       else pragma Assert (Nkind (Item) = N_Pragma);\n-         Nam := Pragma_Name (Item);\n+         Nam := Pragma_Name_Mapped (Item);\n       end if;\n \n       return    Nam = Name_Abstract_State\n@@ -14871,7 +14869,7 @@ package body Sem_Util is\n          Nam := Chars (Identifier (Item));\n \n       else pragma Assert (Nkind (Item) = N_Pragma);\n-         Nam := Pragma_Name (Item);\n+         Nam := Pragma_Name_Mapped (Item);\n       end if;\n \n       return    Nam = Name_Contract_Cases"}, {"sha": "0e95bdd3cd490105ca55420a2f51ac305bb01d98", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -958,7 +958,7 @@ package Sem_Util is\n \n    function Get_Pragma_Id (N : Node_Id) return Pragma_Id;\n    pragma Inline (Get_Pragma_Id);\n-   --  Obtains the Pragma_Id from the Chars field of Pragma_Identifier (N)\n+   --  Obtains the Pragma_Id from Pragma_Name (N)\n \n    function Get_Qualified_Name\n      (Id     : Entity_Id;"}, {"sha": "f722ada0a5672cccdd323b684935328c2977eaaf", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -1887,7 +1887,8 @@ package body Sem_Warn is\n                               P := Parent (Nod);\n \n                               if Nkind (P) = N_Pragma\n-                                and then Pragma_Name (P) = Name_Test_Case\n+                                and then Pragma_Name_Mapped (P) =\n+                                  Name_Test_Case\n                                 and then Nod = Test_Case_Arg (P, Name_Ensures)\n                               then\n                                  return True;"}, {"sha": "4059f218b8b5f20e410599a45db9425c81ec8158", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -6822,18 +6822,44 @@ package body Sinfo is\n    -- Map_Pragma_Name --\n    ---------------------\n \n+   --  We don't want to introduce a dependence on some hash table package or\n+   --  similar, so we use a simple array of Key => Value pairs, and do a linear\n+   --  search. Linear search is plenty efficient, given that we don't expect\n+   --  more than a couple of entries in the mapping.\n+\n+   type Name_Pair is record\n+      Key   : Name_Id;\n+      Value : Name_Id;\n+   end record;\n+\n+   type Pragma_Map_Index is range 1 .. 100;\n+   Pragma_Map : array (Pragma_Map_Index) of Name_Pair;\n+   Last_Pair : Pragma_Map_Index'Base range 0 .. Pragma_Map_Index'Last := 0;\n+\n    procedure Map_Pragma_Name (From, To : Name_Id) is\n    begin\n-      null; -- not yet implemented\n+      if Last_Pair = Pragma_Map'Last then\n+         raise Too_Many_Pragma_Mappings;\n+      end if;\n+\n+      Last_Pair := Last_Pair + 1;\n+      Pragma_Map (Last_Pair) := (Key => From, Value => To);\n    end Map_Pragma_Name;\n \n    ------------------------\n    -- Pragma_Name_Mapped --\n    ------------------------\n \n    function Pragma_Name_Mapped (N : Node_Id) return Name_Id is\n+      Result : constant Name_Id := Pragma_Name (N);\n    begin\n-      return Pragma_Name (N);\n+      for J in Pragma_Map'Range loop\n+         if Result = Pragma_Map (J).Key then\n+            return Pragma_Map (J).Value;\n+         end if;\n+      end loop;\n+\n+      return Result;\n    end Pragma_Name_Mapped;\n \n end Sinfo;"}, {"sha": "1aec0869deb87e168a4d5604938282613168e712", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -11012,10 +11012,16 @@ package Sinfo is\n \n    procedure Map_Pragma_Name (From, To : Name_Id);\n    --  Used in the implementation of pragma Rename_Pragma. Maps pragma name\n-   --  From to pragma name To, we From can be used as a synonym for To.\n+   --  From to pragma name To, so From can be used as a synonym for To.\n+\n+   Too_Many_Pragma_Mappings : exception;\n+   --  Raised if Map_Pragma_Name is called too many times. We expect that few\n+   --  programs will use it at all, and those that do will use it approximately\n+   --  once or twice.\n \n    function Pragma_Name_Mapped (N : Node_Id) return Name_Id;\n-   --  ????Work in progress.\n+   --  Same as Pragma_Name, except that if From has been mapped to To, and\n+   --  Pragma_Name (N) = From, then this returns To.\n \n    -----------------------------\n    -- Syntactic Parent Tables --"}, {"sha": "a45b895d09ffd842291d798b23c57fbcd7c873d8", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533e3abc48268dd8eee0c63ddcf133e7a14b370d/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=533e3abc48268dd8eee0c63ddcf133e7a14b370d", "patch": "@@ -796,6 +796,7 @@ package Snames is\n    Name_Proof_In                       : constant Name_Id := N + $;\n    Name_Reason                         : constant Name_Id := N + $;\n    Name_Reference                      : constant Name_Id := N + $;\n+   Name_Renamed                        : constant Name_Id := N + $;\n    Name_Requires                       : constant Name_Id := N + $;\n    Name_Restricted                     : constant Name_Id := N + $;\n    Name_Result_Mechanism               : constant Name_Id := N + $;"}]}