{"sha": "3f660e47266016fcf2e906d8dfc023a612557fe1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y2NjBlNDcyNjYwMTZmY2YyZTkwNmQ4ZGZjMDIzYTYxMjU1N2ZlMQ==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2011-11-16T14:58:04Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2011-11-16T14:58:04Z"}, "message": "re PR tree-optimization/49960 (inconsistent outputs when enabling autopar for a self -dependence testcase)\n\n\tPR tree-optimization/49960\n\n\t* gcc.dg/autopar/pr49960.c: New test.\n\t* gcc.dg/autopar/pr49960-1.c: New test.\n\nFrom-SVN: r181409", "tree": {"sha": "04974874ad8de829faf176584e85f01c9624c577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04974874ad8de829faf176584e85f01c9624c577"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f660e47266016fcf2e906d8dfc023a612557fe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f660e47266016fcf2e906d8dfc023a612557fe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f660e47266016fcf2e906d8dfc023a612557fe1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f660e47266016fcf2e906d8dfc023a612557fe1/comments", "author": null, "committer": null, "parents": [{"sha": "807133470ce50b8dd4e552857f3c864ee3932a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/807133470ce50b8dd4e552857f3c864ee3932a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/807133470ce50b8dd4e552857f3c864ee3932a50"}], "stats": {"total": 85, "additions": 85, "deletions": 0}, "files": [{"sha": "ac9d567849910c16d41228b035608f0e9f5907c6", "filename": "gcc/testsuite/gcc.dg/autopar/pr49960-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f660e47266016fcf2e906d8dfc023a612557fe1/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49960-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f660e47266016fcf2e906d8dfc023a612557fe1/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49960-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49960-1.c?ref=3f660e47266016fcf2e906d8dfc023a612557fe1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+int main() \n+{\n+  unsigned int x, y, idx, H = 1024, W = 1024;\n+  \n+  int * tmps = (int *)malloc(H*W*sizeof(int));\n+  \n+  /* This loop gets parallelized even though output dependences exist \n+     between writes to 'tmps' that prevent parallelization. \n+     For example: tmps[1] = 1, ..., tmps[1] = 17.  */\n+  \n+  for(x = 1; x < H; x++) \n+    {\n+      for(y = 1; y < W; y++) \n+\t{\n+\t  idx = x*W+y;\n+\t  tmps[idx % 4096] = idx;\t  \n+\t}\n+    }\n+  \n+  for(x = 1; x < 8; x++)\n+    printf(\"tmps[%d]=%d\\n\", x, tmps[x]);\n+  \n+  return 0;\n+}\n+/* Check that no loop gets parallelized.  */\n+\n+/* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 0 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1f3482f170d054549f7c08a45ac7998578f5c3cb", "filename": "gcc/testsuite/gcc.dg/autopar/pr49960.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f660e47266016fcf2e906d8dfc023a612557fe1/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f660e47266016fcf2e906d8dfc023a612557fe1/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49960.c?ref=3f660e47266016fcf2e906d8dfc023a612557fe1", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized\" } */\n+\n+#include <stdio.h>\n+#define MB 100\n+#define NA 450\n+#define MA 400\n+\n+int T[MA][MB],A[MA][NA],B[MB][NA];\n+void MRTRBR(int MA_1, int NA_1, int MB_1)\n+{\n+  int i,j, t,k;\n+\n+  /* The outer most loop is not parallel because for different k's there\n+     is write-write dependency for T[i][j].  */\n+  \n+  /* The two inner loops don't get parallelized due to low number of \n+     iterations.  */\n+\n+  for (k = 3; k < NA_1; k++)\n+    for (i = 3; i < MA_1; i++)\n+      for (j = 3; j < MB_1; j++)\n+\t{\n+\t  t = T[i][j];\n+\t  T[i][j] = t+2+A[i][k]*B[j][k];\n+\t}\n+}\n+void main ()\n+{\n+  int j,i;\n+  \n+  for (i = 3; i < MA; i++)\n+    for (j = 3; j < MB; j++)\n+      T[i][j] = (i>j?i:j);\n+  \n+  MRTRBR (MA,NA,MB);\n+  \n+  for (i = MA-1; i < MA; i++)\n+    for (j = MB-10; j < MB; j++)\n+      printf (\"i %d j %d T[i][j] = %d\\n\",i,j,T[i][j]);\n+}\n+\n+\n+/* Check that the outer most loop doesn't get parallelized (thus no loop gets parallelized)  */\n+\n+/* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 0 \"parloops\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}