{"sha": "9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRjZjFmODY4YzA0OGUyMGM3MmRmN2VlNWQzNzg2MjVkMWU3N2JjOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:54:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:54:17Z"}, "message": "poly_int: ira subreg liveness tracking\n\nNormmaly the IRA-reload interface tries to track the liveness of\nindividual bytes of an allocno if the allocno is sometimes written\nto as a SUBREG.  This isn't possible for variable-sized allocnos,\nbut it doesn't matter because targets with variable-sized registers\nshould use LRA instead.\n\nThis patch adds a get_subreg_tracking_sizes function for deciding\nwhether it is possible to model a partial read or write.  Later\npatches make it return false if anything is variable.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* ira.c (get_subreg_tracking_sizes): New function.\n\t(init_live_subregs): Take an integer size rather than a register.\n\t(build_insn_chain): Use get_subreg_tracking_sizes.  Update calls\n\tto init_live_subregs.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255881", "tree": {"sha": "fbb848314cbe3951097d2ceaad0c9faa22cb53f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbb848314cbe3951097d2ceaad0c9faa22cb53f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dcf1f868c048e20c72df7ee5d378625d1e77bc8/comments", "author": null, "committer": null, "parents": [{"sha": "7f679e470b6255bcf495b8200d66acfed1e975a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f679e470b6255bcf495b8200d66acfed1e975a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f679e470b6255bcf495b8200d66acfed1e975a3"}], "stats": {"total": 69, "additions": 49, "deletions": 20}, "files": [{"sha": "91f1927ff69d7ee462a657ce1ef3ff731ac81f94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dcf1f868c048e20c72df7ee5d378625d1e77bc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dcf1f868c048e20c72df7ee5d378625d1e77bc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "patch": "@@ -1,3 +1,12 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* ira.c (get_subreg_tracking_sizes): New function.\n+\t(init_live_subregs): Take an integer size rather than a register.\n+\t(build_insn_chain): Use get_subreg_tracking_sizes.  Update calls\n+\tto init_live_subregs.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "13972540a9cfa45f9fbe3662e7edd3ca7d6b1b90", "filename": "gcc/ira.c", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dcf1f868c048e20c72df7ee5d378625d1e77bc8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dcf1f868c048e20c72df7ee5d378625d1e77bc8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "patch": "@@ -4037,16 +4037,27 @@ pseudo_for_reload_consideration_p (int regno)\n   return (reg_renumber[regno] >= 0 || ira_conflicts_p);\n }\n \n-/* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] using\n-   REG to the number of nregs, and INIT_VALUE to get the\n-   initialization.  ALLOCNUM need not be the regno of REG.  */\n+/* Return true if we can track the individual bytes of subreg X.\n+   When returning true, set *OUTER_SIZE to the number of bytes in\n+   X itself, *INNER_SIZE to the number of bytes in the inner register\n+   and *START to the offset of the first byte.  */\n+static bool\n+get_subreg_tracking_sizes (rtx x, HOST_WIDE_INT *outer_size,\n+\t\t\t   HOST_WIDE_INT *inner_size, HOST_WIDE_INT *start)\n+{\n+  rtx reg = regno_reg_rtx[REGNO (SUBREG_REG (x))];\n+  *outer_size = GET_MODE_SIZE (GET_MODE (x));\n+  *inner_size = GET_MODE_SIZE (GET_MODE (reg));\n+  *start = SUBREG_BYTE (x);\n+  return true;\n+}\n+\n+/* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] for\n+   a register with SIZE bytes, making the register live if INIT_VALUE.  */\n static void\n init_live_subregs (bool init_value, sbitmap *live_subregs,\n-\t\t   bitmap live_subregs_used, int allocnum, rtx reg)\n+\t\t   bitmap live_subregs_used, int allocnum, int size)\n {\n-  unsigned int regno = REGNO (SUBREG_REG (reg));\n-  int size = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n-\n   gcc_assert (size > 0);\n \n   /* Been there, done that.  */\n@@ -4155,19 +4166,26 @@ build_insn_chain (void)\n \t\t\t&& (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL)))\n \t\t      {\n \t\t\trtx reg = DF_REF_REG (def);\n-\n-\t\t\t/* We can model subregs, but not if they are\n-\t\t\t   wrapped in ZERO_EXTRACTS.  */\n+\t\t\tHOST_WIDE_INT outer_size, inner_size, start;\n+\n+\t\t\t/* We can usually track the liveness of individual\n+\t\t\t   bytes within a subreg.  The only exceptions are\n+\t\t\t   subregs wrapped in ZERO_EXTRACTs and subregs whose\n+\t\t\t   size is not known; in those cases we need to be\n+\t\t\t   conservative and treat the definition as a partial\n+\t\t\t   definition of the full register rather than a full\n+\t\t\t   definition of a specific part of the register.  */\n \t\t\tif (GET_CODE (reg) == SUBREG\n-\t\t\t    && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n+\t\t\t    && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT)\n+\t\t\t    && get_subreg_tracking_sizes (reg, &outer_size,\n+\t\t\t\t\t\t\t  &inner_size, &start))\n \t\t\t  {\n-\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n-\t\t\t    unsigned int last = start\n-\t\t\t      + GET_MODE_SIZE (GET_MODE (reg));\n+\t\t\t    HOST_WIDE_INT last = start + outer_size;\n \n \t\t\t    init_live_subregs\n \t\t\t      (bitmap_bit_p (live_relevant_regs, regno),\n-\t\t\t       live_subregs, live_subregs_used, regno, reg);\n+\t\t\t       live_subregs, live_subregs_used, regno,\n+\t\t\t       inner_size);\n \n \t\t\t    if (!DF_REF_FLAGS_IS_SET\n \t\t\t\t(def, DF_REF_STRICT_LOW_PART))\n@@ -4252,18 +4270,20 @@ build_insn_chain (void)\n \t\t    if (regno < FIRST_PSEUDO_REGISTER\n \t\t\t|| pseudo_for_reload_consideration_p (regno))\n \t\t      {\n+\t\t\tHOST_WIDE_INT outer_size, inner_size, start;\n \t\t\tif (GET_CODE (reg) == SUBREG\n \t\t\t    && !DF_REF_FLAGS_IS_SET (use,\n \t\t\t\t\t\t     DF_REF_SIGN_EXTRACT\n-\t\t\t\t\t\t     | DF_REF_ZERO_EXTRACT))\n+\t\t\t\t\t\t     | DF_REF_ZERO_EXTRACT)\n+\t\t\t    && get_subreg_tracking_sizes (reg, &outer_size,\n+\t\t\t\t\t\t\t  &inner_size, &start))\n \t\t\t  {\n-\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n-\t\t\t    unsigned int last = start\n-\t\t\t      + GET_MODE_SIZE (GET_MODE (reg));\n+\t\t\t    HOST_WIDE_INT last = start + outer_size;\n \n \t\t\t    init_live_subregs\n \t\t\t      (bitmap_bit_p (live_relevant_regs, regno),\n-\t\t\t       live_subregs, live_subregs_used, regno, reg);\n+\t\t\t       live_subregs, live_subregs_used, regno,\n+\t\t\t       inner_size);\n \n \t\t\t    /* Ignore the paradoxical bits.  */\n \t\t\t    if (last > SBITMAP_SIZE (live_subregs[regno]))"}]}