{"sha": "aa4945c138ce494613b711ede795a489bceaf62f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0OTQ1YzEzOGNlNDk0NjEzYjcxMWVkZTc5NWE0ODliY2VhZjYyZg==", "commit": {"author": {"name": "Jon Beniston", "email": "jon@beniston.com", "date": "2009-11-11T16:43:06Z"}, "committer": {"name": "Jon Beniston", "email": "jbeniston@gcc.gnu.org", "date": "2009-11-11T16:43:06Z"}, "message": "config.gcc: Add lm32 elf and uclinux targets.\n\ngcc/\n2009-11-11  Jon Beniston <jon@beniston.com>\n\n        * config.gcc: Add lm32 elf and uclinux targets.\n        * config/lm32: New directory.\n        * config/lm32/lm32.c: New file.\n        * config/lm32/lm32.h: New file.\n        * config/lm32/lm32.md: New file.\n        * config/lm32/lm32.opt: New file.\n        * config/lm32/lm32-protos.h: New file.\n        * config/lm32/constraints.md: New file.\n        * config/lm32/predicates.md: New file.\n        * config/lm32/sfp-machine.h: New file.\n        * config/lm32/t-fprules-softfp: New file.\n        * config/lm32/uclinux-elf.h: New file.\n        * doc/invoke.texi: Document lm32 options. \n        * doc/contrib.texi: Document lm32 porter.\n        * doc/install.texi: Document lm32 targets.\n\ngcc/testsuite/\n2009-11-11  Jon Beniston <jon@beniston.com>\n\n        * lib/target-supports.exp (check_profiling_available): lm32 target \n          doesn't support profiling.\n        * gcc.dg/20020312-2.c: Add lm32 support.\n        * g++.dg/other/packed1.C: Expect to fail on lm32.        \n        * g++.old-deja/g++.jason/thunk3.C: Likewise.                 \n\nlibgcc/\n2009-11-11  Jon Beniston <jon@beniston.com>\n\n        * config.host: Add lm32 targets.\n        * config/lm32: New directory.\n        * config/lm32/libgcc_lm32.h: New file.\n        * config/lm32/_mulsi3.c: New file.\n        * config/lm32/_udivmodsi4.c: New file.\n        * config/lm32/_divsi3.c: New file.\n        * config/lm32/_modsi3.c: New file.\n        * config/lm32/_udivsi3.c: New file.\n        * config/lm32/_umodsi3.c: New file.\n        * config/lm32/_lshrsi3.S: New file.\n        * config/lm32/_ashrsi3.S: New file.\n        * config/lm32/_ashlsi3.S: New file.\n        * config/lm32/crti.S: New file.\n        * config/lm32/crtn.S: New file.\n        * config/lm32/t-lm32: New file.\n        * config/lm32/t-elf: New file.\n        * config/lm32/t-uclinux: New file.\n\nFrom-SVN: r154096", "tree": {"sha": "cf4108b3353e1f46c1d6b52a3ce2c3d91d0e79d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf4108b3353e1f46c1d6b52a3ce2c3d91d0e79d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4945c138ce494613b711ede795a489bceaf62f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4945c138ce494613b711ede795a489bceaf62f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4945c138ce494613b711ede795a489bceaf62f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4945c138ce494613b711ede795a489bceaf62f/comments", "author": {"login": "srcejon", "id": 57259258, "node_id": "MDQ6VXNlcjU3MjU5MjU4", "avatar_url": "https://avatars.githubusercontent.com/u/57259258?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srcejon", "html_url": "https://github.com/srcejon", "followers_url": "https://api.github.com/users/srcejon/followers", "following_url": "https://api.github.com/users/srcejon/following{/other_user}", "gists_url": "https://api.github.com/users/srcejon/gists{/gist_id}", "starred_url": "https://api.github.com/users/srcejon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srcejon/subscriptions", "organizations_url": "https://api.github.com/users/srcejon/orgs", "repos_url": "https://api.github.com/users/srcejon/repos", "events_url": "https://api.github.com/users/srcejon/events{/privacy}", "received_events_url": "https://api.github.com/users/srcejon/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "05d3aa37b35924bdbc3f321581716bf9c05b765b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05d3aa37b35924bdbc3f321581716bf9c05b765b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05d3aa37b35924bdbc3f321581716bf9c05b765b"}], "stats": {"total": 4129, "additions": 4125, "deletions": 4}, "files": [{"sha": "546ec363fb9b267e43c1aefb651e672b9a9d46a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -1,3 +1,22 @@\n+gcc/\n+2009-11-11  Jon Beniston <jon@beniston.com>\n+\n+        * config.gcc: Add lm32 elf and uclinux targets.\n+        * config/lm32: New directory.\n+        * config/lm32/lm32.c: New file.\n+        * config/lm32/lm32.h: New file.\n+        * config/lm32/lm32.md: New file.\n+        * config/lm32/lm32.opt: New file.\n+        * config/lm32/lm32-protos.h: New file.\n+        * config/lm32/constraints.md: New file.\n+        * config/lm32/predicates.md: New file.\n+        * config/lm32/sfp-machine.h: New file.\n+        * config/lm32/t-fprules-softfp: New file.\n+        * config/lm32/uclinux-elf.h: New file.\n+        * doc/invoke.texi: Document lm32 options. \n+        * doc/contrib.texi: Document lm32 porter.\n+        * doc/install.texi: Document lm32 targets.\n+\n 2009-11-11  Martin Jambor  <mjambor@suse.cz>\n \n \tPR lto/41932"}, {"sha": "dc22e38de729a1e87f9c51856986ceffa9a55406", "filename": "gcc/config.gcc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -1469,6 +1469,14 @@ iq2000*-*-elf*)\n         out_file=iq2000/iq2000.c\n         md_file=iq2000/iq2000.md\n         ;;\n+lm32-*-elf*)\n+        tm_file=\"dbxelf.h elfos.h ${tm_file}\"\n+\ttmake_file=\"${tmake_file} lm32/t-fprules-softfp soft-fp/t-softfp\"\n+        ;;\n+lm32-*-uclinux*)\n+        tm_file=\"dbxelf.h elfos.h ${tm_file} linux.h lm32/uclinux-elf.h\"\n+\ttmake_file=\"${tmake_file} lm32/t-fprules-softfp soft-fp/t-softfp\"\n+        ;;\n m32r-*-elf*)\n \ttm_file=\"dbxelf.h elfos.h svr4.h newlib-stdint.h ${tm_file}\"\n \textra_parts=\"crtinit.o crtfini.o\""}, {"sha": "a8c7f97e2cad20ec83ebd492dc95e1b05265e132", "filename": "gcc/config/lm32/constraints.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Fconstraints.md?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,57 @@\n+;; Constraint definitions for Lattice Mico32 architecture.\n+;; Contributed by Jon Beniston <jon@beniston.com>\n+;;\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_constraint \"J\"\n+  \"The value 0.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+       \n+(define_constraint \"K\"\n+  \"A signed 16-bit immediate in the range -32768 to 32767.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -32768, 32767)\")))\n+\n+(define_constraint \"L\"\n+  \"An unsigned 16-bit immediate in the range 0 to 65535.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 65535)\")))\n+\n+(define_constraint \"M\"\n+  \"The value 1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1\")))\n+\n+(define_constraint \"U\"\n+  \"A shifted signed 16-bit constant appropriate for orhi.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xffff) == 0\n+\t\t    && (ival >> 31 == -1 || ival >> 31 == 0)\")))\n+\n+(define_constraint \"S\"\n+  \"A symbol in the small data section.\"\n+  (match_operand 0 \"no_pic_small_symbol\"))\n+\n+(define_constraint \"Y\"\n+  \"A high part of a symbol.\"\n+  (and (match_code \"high\")\n+       (ior (ior (match_code \"symbol_ref\" \"0\")\n+                 (match_code \"label_ref\" \"0\"))\n+            (match_code \"const\" \"0\"))))"}, {"sha": "70d97f0d1d8244248ae8f08b8a2f1149b3590211", "filename": "gcc/config/lm32/lm32-protos.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32-protos.h?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,42 @@\n+/* Prototypes of target machine functions, Lattice Mico32 architecture.\n+   Contributed by Jon Beniston <jon@beniston.com>\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+extern int lm32_return_in_memory (tree type);\n+extern void lm32_declare_object (FILE *stream, char *name, char *init_string, \n+                                 char *final_string, int size);\n+extern void lm32_expand_prologue (void);\n+extern void lm32_expand_epilogue (void);\n+extern void lm32_print_operand (FILE *file, rtx op, int letter);\n+extern void lm32_print_operand_address (FILE *file, rtx addr);\n+extern rtx lm32_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n+                              tree type, int named);\n+extern void lm32_override_options (void);\n+extern HOST_WIDE_INT lm32_compute_initial_elimination_offset (int from, \n+                                                             int to);\n+extern int lm32_can_use_return (void);\n+extern rtx lm32_return_addr_rtx (int count, rtx frame);\n+extern int lm32_expand_block_move (rtx *);\n+extern int nonpic_symbol_mentioned_p (rtx);\n+extern rtx lm32_legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern void lm32_expand_scc (rtx operands[]);\n+extern void lm32_expand_conditional_branch (rtx operands[]);\n+extern bool lm32_move_ok (enum machine_mode, rtx operands[2]);\n+extern bool lm32_legitimate_constant_p (rtx);"}, {"sha": "f3e381196085ac6244619ba19515969e0c2f5e7b", "filename": "gcc/config/lm32/lm32.c", "status": "added", "additions": 1216, "deletions": 0, "changes": 1216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,1216 @@\n+/* Subroutines used for code generation on the Lattice Mico32 architecture.\n+   Contributed by Jon Beniston <jon@beniston.com>\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"reload.h\"\n+#include \"tm_p.h\"\n+#include \"function.h\"\n+#include \"toplev.h\"\n+#include \"optabs.h\"\n+#include \"libfuncs.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\n+#include \"tm-constrs.h\"\n+#include \"df.h\"\n+\n+struct lm32_frame_info\n+{\n+  HOST_WIDE_INT total_size;\t/* number of bytes of entire frame.  */\n+  HOST_WIDE_INT callee_size;\t/* number of bytes to save callee saves.  */\n+  HOST_WIDE_INT pretend_size;\t/* number of bytes we pretend caller did.  */\n+  HOST_WIDE_INT args_size;\t/* number of bytes for outgoing arguments.  */\n+  HOST_WIDE_INT locals_size;\t/* number of bytes for local variables.  */\n+  unsigned int reg_save_mask;\t/* mask of saved registers.  */\n+};\n+\n+/* Prototypes for static functions.  */\n+static rtx emit_add (rtx dest, rtx src0, rtx src1);\n+static void expand_save_restore (struct lm32_frame_info *info, int op);\n+static void stack_adjust (HOST_WIDE_INT amount);\n+static bool lm32_in_small_data_p (const_tree);\n+static void lm32_setup_incoming_varargs (CUMULATIVE_ARGS * cum,\n+\t\t\t\t\t enum machine_mode mode, tree type,\n+\t\t\t\t\t int *pretend_size, int no_rtl);\n+static bool lm32_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t\t    bool speed);\n+static bool lm32_can_eliminate (const int, const int);\n+static bool\n+lm32_legitimate_address_p (enum machine_mode mode, rtx x, bool strict);\n+static HOST_WIDE_INT lm32_compute_frame_size (int size);\n+\n+#undef TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST hook_int_rtx_bool_0\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS lm32_rtx_costs\n+#undef TARGET_IN_SMALL_DATA_P\n+#define TARGET_IN_SMALL_DATA_P lm32_in_small_data_p\n+#undef TARGET_PROMOTE_FUNCTION_MODE\n+#define TARGET_PROMOTE_FUNCTION_MODE default_promote_function_mode_always_promote\n+#undef TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS lm32_setup_incoming_varargs\n+#undef TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n+#undef TARGET_MIN_ANCHOR_OFFSET\n+#define TARGET_MIN_ANCHOR_OFFSET -0x8000\n+#undef TARGET_MAX_ANCHOR_OFFSET\n+#define TARGET_MAX_ANCHOR_OFFSET 0x7fff\n+#undef TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE lm32_can_eliminate\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P lm32_legitimate_address_p\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+/* Current frame information calculated by lm32_compute_frame_size.  */\n+static struct lm32_frame_info current_frame_info;\n+\n+/* Return non-zero if the given return type should be returned in memory.  */\n+\n+int\n+lm32_return_in_memory (tree type)\n+{\n+  HOST_WIDE_INT size;\n+\n+  if (!AGGREGATE_TYPE_P (type))\n+    {\n+      /* All simple types are returned in registers.  */\n+      return 0;\n+    }\n+\n+  size = int_size_in_bytes (type);\n+  if (size >= 0 && size <= UNITS_PER_WORD)\n+    {\n+      /* If it can fit in one register.  */\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Generate an emit a word sized add instruction.  */\n+\n+static rtx\n+emit_add (rtx dest, rtx src0, rtx src1)\n+{\n+  rtx insn;\n+  insn = emit_insn (gen_addsi3 (dest, src0, src1));\n+  return insn;\n+}\n+\n+/* Generate the code to compare (and possibly branch) two integer values\n+   TEST_CODE is the comparison code we are trying to emulate \n+     (or implement directly)\n+   RESULT is where to store the result of the comparison, \n+     or null to emit a branch\n+   CMP0 CMP1 are the two comparison operands\n+   DESTINATION is the destination of the branch, or null to only compare\n+   */\n+\n+static void\n+gen_int_relational (enum rtx_code code,\t\n+\t\t    rtx result,\t\n+\t\t    rtx cmp0,\t\n+\t\t    rtx cmp1,\t\n+\t\t    rtx destination)\t\n+{\n+  enum machine_mode mode;\n+  int branch_p;\n+\n+  mode = GET_MODE (cmp0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (cmp1);\n+\n+  /* Is this a branch or compare.  */\n+  branch_p = (destination != 0);\n+\n+  /* Instruction set doesn't support LE or LT, so swap operands and use \n+     GE, GT.  */\n+  switch (code)\n+    {\n+    case LE:\n+    case LT:\n+    case LEU:\n+    case LTU:\n+      code = swap_condition (code);\n+      rtx temp = cmp0;\n+      cmp0 = cmp1;\n+      cmp1 = temp;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (branch_p)\n+    {\n+      rtx insn;\n+\n+      /* Operands must be in registers.  */\n+      if (!register_operand (cmp0, mode))\n+\tcmp0 = force_reg (mode, cmp0);\n+      if (!register_operand (cmp1, mode))\n+\tcmp1 = force_reg (mode, cmp1);\n+\n+      /* Generate conditional branch instruction.  */\n+      rtx cond = gen_rtx_fmt_ee (code, mode, cmp0, cmp1);\n+      rtx label = gen_rtx_LABEL_REF (VOIDmode, destination);\n+      insn = gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t  gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\t\tcond, label, pc_rtx));\n+      emit_jump_insn (insn);\n+    }\n+  else\n+    {\n+      /* We can't have const_ints in cmp0, other than 0.  */\n+      if ((GET_CODE (cmp0) == CONST_INT) && (INTVAL (cmp0) != 0))\n+\tcmp0 = force_reg (mode, cmp0);\n+\n+      /* If the comparison is against an int not in legal range\n+         move it into a register.  */\n+      if (GET_CODE (cmp1) == CONST_INT)\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case EQ:\n+\t    case NE:\n+\t    case LE:\n+\t    case LT:\n+\t    case GE:\n+\t    case GT:\n+\t      if (!satisfies_constraint_K (cmp1))\n+\t\tcmp1 = force_reg (mode, cmp1);\n+\t      break;\n+\t    case LEU:\n+\t    case LTU:\n+\t    case GEU:\n+\t    case GTU:\n+\t      if (!satisfies_constraint_L (cmp1))\n+\t\tcmp1 = force_reg (mode, cmp1);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      /* Generate compare instruction.  */\n+      emit_move_insn (result, gen_rtx_fmt_ee (code, mode, cmp0, cmp1));\n+    }\n+}\n+\n+/* Try performing the comparison in OPERANDS[1], whose arms are OPERANDS[2]\n+   and OPERAND[3].  Store the result in OPERANDS[0].  */\n+\n+void\n+lm32_expand_scc (rtx operands[])\n+{\n+  rtx target = operands[0];\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx op0 = operands[2];\n+  rtx op1 = operands[3];\n+\n+  gen_int_relational (code, target, op0, op1, NULL_RTX);  \n+}\n+\n+/* Compare OPERANDS[1] with OPERANDS[2] using comparison code\n+   CODE and jump to OPERANDS[3] if the condition holds.  */\n+\n+void\n+lm32_expand_conditional_branch (rtx operands[])\n+{\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  rtx op0 = operands[1];\n+  rtx op1 = operands[2];\n+  rtx destination = operands[3];\n+\n+  gen_int_relational (code, NULL_RTX, op0, op1, destination);  \n+}\n+\n+/* Generate and emit RTL to save or restore callee save registers.  */\n+static void\n+expand_save_restore (struct lm32_frame_info *info, int op)\n+{\n+  unsigned int reg_save_mask = info->reg_save_mask;\n+  int regno;\n+  HOST_WIDE_INT offset;\n+  rtx insn;\n+\n+  /* Callee saves are below locals and above outgoing arguments.  */\n+  offset = info->args_size + info->callee_size;\n+  for (regno = 0; regno <= 31; regno++)\n+    {\n+      if ((reg_save_mask & (1 << regno)) != 0)\n+\t{\n+\t  rtx offset_rtx;\n+\t  rtx mem;\n+\t  \n+\t  offset_rtx = GEN_INT (offset);\n+\t  if (satisfies_constraint_K (offset_rtx))\n+\t    {\t\n+              mem = gen_rtx_MEM (word_mode,\n+                                 gen_rtx_PLUS (Pmode,\n+                                               stack_pointer_rtx,\n+                                               offset_rtx));\n+            }\n+          else\n+            {\n+              /* r10 is caller saved so it can be used as a temp reg.  */\n+              rtx r10;        \n+               \n+              r10 = gen_rtx_REG (word_mode, 10);\n+              insn = emit_move_insn (r10, offset_rtx);\n+              if (op == 0)\n+                RTX_FRAME_RELATED_P (insn) = 1;\n+              insn = emit_add (r10, r10, stack_pointer_rtx);\n+              if (op == 0)\n+                RTX_FRAME_RELATED_P (insn) = 1;                \n+              mem = gen_rtx_MEM (word_mode, r10);\n+            }                                                 \t    \n+\t    \t    \n+\t  if (op == 0)\n+\t    insn = emit_move_insn (mem, gen_rtx_REG (word_mode, regno));\n+\t  else\n+\t    insn = emit_move_insn (gen_rtx_REG (word_mode, regno), mem);\n+        \n+\t  /* only prologue instructions which set the sp fp or save a\n+\t     register should be marked as frame related.  */\n+\t  if (op == 0)\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t  offset -= UNITS_PER_WORD;\n+\t}\n+    }\n+}\n+\n+static void\n+stack_adjust (HOST_WIDE_INT amount)\n+{\n+  rtx insn;\n+\n+  if (!IN_RANGE (amount, -32776, 32768))\n+    {\n+      /* r10 is caller saved so it can be used as a temp reg.  */\n+      rtx r10;\n+      r10 = gen_rtx_REG (word_mode, 10);\n+      insn = emit_move_insn (r10, GEN_INT (amount));\n+      if (amount < 0)\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_add (stack_pointer_rtx, stack_pointer_rtx, r10);\n+      if (amount < 0)\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    {\n+      insn = emit_add (stack_pointer_rtx,\n+\t\t       stack_pointer_rtx, GEN_INT (amount));\n+      if (amount < 0)\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+\n+/* Create and emit instructions for a functions prologue.  */\n+void\n+lm32_expand_prologue (void)\n+{\n+  rtx insn;\n+\n+  lm32_compute_frame_size (get_frame_size ());\n+\n+  if (current_frame_info.total_size > 0)\n+    {\n+      /* Add space on stack new frame.  */\n+      stack_adjust (-current_frame_info.total_size);\n+\n+      /* Save callee save registers.  */\n+      if (current_frame_info.reg_save_mask != 0)\n+\texpand_save_restore (&current_frame_info, 0);\n+\n+      /* Setup frame pointer if it's needed.  */\n+      if (frame_pointer_needed == 1)\n+\t{\n+\t  /* Load offset - Don't use total_size, as that includes pretend_size, \n+             which isn't part of this frame?  */\n+\t  insn =\n+\t    emit_move_insn (frame_pointer_rtx,\n+\t\t\t    GEN_INT (current_frame_info.args_size +\n+\t\t\t\t     current_frame_info.callee_size +\n+\t\t\t\t     current_frame_info.locals_size));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  /* Add in sp.  */\n+\t  insn = emit_add (frame_pointer_rtx,\n+\t\t\t   frame_pointer_rtx, stack_pointer_rtx);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      /* Prevent prologue from being scheduled into function body.  */\n+      emit_insn (gen_blockage ());\n+    }\n+}\n+\n+/* Create an emit instructions for a functions epilogue.  */\n+void\n+lm32_expand_epilogue (void)\n+{\n+  rtx ra_rtx = gen_rtx_REG (Pmode, RA_REGNUM);\n+\n+  lm32_compute_frame_size (get_frame_size ());\n+\n+  if (current_frame_info.total_size > 0)\n+    {\n+      /* Prevent stack code from being reordered.  */\n+      emit_insn (gen_blockage ());\n+\n+      /* Restore callee save registers.  */\n+      if (current_frame_info.reg_save_mask != 0)\n+\texpand_save_restore (&current_frame_info, 1);\n+\n+      /* Deallocate stack.  */\n+      stack_adjust (current_frame_info.total_size);\n+\n+      /* Return to calling function.  */\n+      emit_jump_insn (gen_return_internal (ra_rtx));\n+    }\n+  else\n+    {\n+      /* Return to calling function.  */\n+      emit_jump_insn (gen_return_internal (ra_rtx));\n+    }\n+}\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.  */\n+static HOST_WIDE_INT\n+lm32_compute_frame_size (int size)\n+{\n+  int regno;\n+  HOST_WIDE_INT total_size, locals_size, args_size, pretend_size, callee_size;\n+  unsigned int reg_save_mask;\n+\n+  locals_size = size;\n+  args_size = crtl->outgoing_args_size;\n+  pretend_size = crtl->args.pretend_args_size;\n+  callee_size = 0;\n+  reg_save_mask = 0;\n+\n+  /* Build mask that actually determines which regsiters we save\n+     and calculate size required to store them in the stack.  */\n+  for (regno = 1; regno < SP_REGNUM; regno++)\n+    {\n+      if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n+\t{\n+\t  reg_save_mask |= 1 << regno;\n+\t  callee_size += UNITS_PER_WORD;\n+\t}\n+    }\n+  if (df_regs_ever_live_p (RA_REGNUM) || !current_function_is_leaf\n+      || !optimize)\n+    {\n+      reg_save_mask |= 1 << RA_REGNUM;\n+      callee_size += UNITS_PER_WORD;\n+    }\n+  if (!(reg_save_mask & (1 << FP_REGNUM)) && frame_pointer_needed)\n+    {\n+      reg_save_mask |= 1 << FP_REGNUM;\n+      callee_size += UNITS_PER_WORD;\n+    }\n+\n+  /* Compute total frame size.  */\n+  total_size = pretend_size + args_size + locals_size + callee_size;\n+\n+  /* Align frame to appropriate boundary.  */\n+  total_size = (total_size + 3) & ~3;\n+\n+  /* Save computed information.  */\n+  current_frame_info.total_size = total_size;\n+  current_frame_info.callee_size = callee_size;\n+  current_frame_info.pretend_size = pretend_size;\n+  current_frame_info.locals_size = locals_size;\n+  current_frame_info.args_size = args_size;\n+  current_frame_info.reg_save_mask = reg_save_mask;\n+\n+  return total_size;\n+}\n+\n+void\n+lm32_print_operand (FILE * file, rtx op, int letter)\n+{\n+  enum rtx_code code;\n+\n+  code = GET_CODE (op);\n+\n+  if (code == SIGN_EXTEND)\n+    op = XEXP (op, 0), code = GET_CODE (op);\n+  else if (code == REG || code == SUBREG)\n+    {\n+      int regnum;\n+\n+      if (code == REG)\n+\tregnum = REGNO (op);\n+      else\n+\tregnum = true_regnum (op);\n+\n+      fprintf (file, \"%s\", reg_names[regnum]);\n+    }\n+  else if (code == HIGH)\n+    output_addr_const (file, XEXP (op, 0));  \n+  else if (code == MEM)\n+    output_address (XEXP (op, 0));\n+  else if (letter == 'z' && GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n+    fprintf (file, \"%s\", reg_names[0]);\n+  else if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      if ((CONST_DOUBLE_LOW (op) != 0) || (CONST_DOUBLE_HIGH (op) != 0))\n+\toutput_operand_lossage (\"Only 0.0 can be loaded as an immediate\");\n+      else\n+\tfprintf (file, \"0\");\n+    }\n+  else if (code == EQ)\n+    fprintf (file, \"e  \");\n+  else if (code == NE)\n+    fprintf (file, \"ne \");\n+  else if (code == GT)\n+    fprintf (file, \"g  \");\n+  else if (code == GTU)\n+    fprintf (file, \"gu \");\n+  else if (code == LT)\n+    fprintf (file, \"l  \");\n+  else if (code == LTU)\n+    fprintf (file, \"lu \");\n+  else if (code == GE)\n+    fprintf (file, \"ge \");\n+  else if (code == GEU)\n+    fprintf (file, \"geu\");\n+  else if (code == LE)\n+    fprintf (file, \"le \");\n+  else if (code == LEU)\n+    fprintf (file, \"leu\");\n+  else\n+    output_addr_const (file, op);\n+}\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is ADDR.  ADDR is an RTL expression.\n+\n+   On some machines, the syntax for a symbolic address depends on\n+   the section that the address refers to.  On these machines,\n+   define the macro `ENCODE_SECTION_INFO' to store the information\n+   into the `symbol_ref', and then check for it here.  */\n+\n+void\n+lm32_print_operand_address (FILE * file, rtx addr)\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      fprintf (file, \"(%s+0)\", reg_names[REGNO (addr)]);\n+      break;\n+\n+    case MEM:\n+      output_address (XEXP (addr, 0));\n+      break;\n+\n+    case PLUS:\n+      {\n+\trtx arg0 = XEXP (addr, 0);\n+\trtx arg1 = XEXP (addr, 1);\n+\n+\tif (GET_CODE (arg0) == REG && CONSTANT_P (arg1))\n+\t  {\n+\t    if (GET_CODE (arg1) == CONST_INT)\n+\t      fprintf (file, \"(%s+%ld)\", reg_names[REGNO (arg0)],\n+\t\t       INTVAL (arg1));\n+\t    else\n+\t      {\n+\t\tfprintf (file, \"(%s+\", reg_names[REGNO (arg0)]);\n+\t\toutput_addr_const (file, arg1);\n+\t\tfprintf (file, \")\");\n+\t      }\n+\t  }\n+\telse if (CONSTANT_P (arg0) && CONSTANT_P (arg1))\n+\t  output_addr_const (file, addr);\n+\telse\n+\t  fatal_insn (\"bad operand\", addr);\n+      }\n+      break;\n+\n+    case SYMBOL_REF:\n+      if (SYMBOL_REF_SMALL_P (addr))\n+\t{\n+\t  fprintf (file, \"gp(\");\n+\t  output_addr_const (file, addr);\n+\t  fprintf (file, \")\");\n+\t}\n+      else\n+\tfatal_insn (\"can't use non gp relative absolute address\", addr);\n+      break;\n+\n+    default:\n+      fatal_insn (\"invalid addressing mode\", addr);\n+      break;\n+    }\n+}\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+rtx\n+lm32_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n+\t\t   tree type, int named)\n+{\n+  if (mode == VOIDmode)\n+    /* Compute operand 2 of the call insn.  */\n+    return GEN_INT (0);\n+\n+  if (targetm.calls.must_pass_in_stack (mode, type))\n+    return NULL_RTX;\n+\n+  if (!named || (cum + LM32_NUM_REGS2 (mode, type) > LM32_NUM_ARG_REGS))\n+    return NULL_RTX;\n+\n+  return gen_rtx_REG (mode, cum + LM32_FIRST_ARG_REG);\n+}\n+\n+HOST_WIDE_INT\n+lm32_compute_initial_elimination_offset (int from, int to)\n+{\n+  HOST_WIDE_INT offset = 0;\n+\n+  switch (from)\n+    {\n+    case ARG_POINTER_REGNUM:\n+      switch (to)\n+\t{\n+\tcase FRAME_POINTER_REGNUM:\n+\t  offset = 0;\n+\t  break;\n+\tcase STACK_POINTER_REGNUM:\n+\t  offset =\n+\t    lm32_compute_frame_size (get_frame_size ()) -\n+\t    current_frame_info.pretend_size;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return offset;\n+}\n+\n+static void\n+lm32_setup_incoming_varargs (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+\t\t\t     tree type, int *pretend_size, int no_rtl)\n+{\n+  int first_anon_arg;\n+  tree fntype;\n+  int stdarg_p;\n+\n+  fntype = TREE_TYPE (current_function_decl);\n+  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n+\t      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t  != void_type_node));\n+\n+  if (stdarg_p)\n+    first_anon_arg = *cum + LM32_FIRST_ARG_REG;\n+  else\n+    {\n+      /* this is the common case, we have been passed details setup\n+         for the last named argument, we want to skip over the\n+         registers, if any used in passing this named paramter in\n+         order to determine which is the first registers used to pass\n+         anonymous arguments.  */\n+      int size;\n+\n+      if (mode == BLKmode)\n+\tsize = int_size_in_bytes (type);\n+      else\n+\tsize = GET_MODE_SIZE (mode);\n+\n+      first_anon_arg =\n+\t*cum + LM32_FIRST_ARG_REG +\n+\t((size + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+    }\n+\n+  if ((first_anon_arg < (LM32_FIRST_ARG_REG + LM32_NUM_ARG_REGS)) && !no_rtl)\n+    {\n+      int first_reg_offset = first_anon_arg;\n+      int size = LM32_FIRST_ARG_REG + LM32_NUM_ARG_REGS - first_anon_arg;\n+      rtx regblock;\n+\n+      regblock = gen_rtx_MEM (BLKmode,\n+\t\t\t      plus_constant (arg_pointer_rtx,\n+\t\t\t\t\t     FIRST_PARM_OFFSET (0)));\n+      move_block_from_reg (first_reg_offset, regblock, size);\n+\n+      *pretend_size = size * UNITS_PER_WORD;\n+    }\n+}\n+\n+/* Override command line options.  */\n+void\n+lm32_override_options (void)\n+{\n+  /* We must have sign-extend enabled if barrel-shift isn't.  */\n+  if (!TARGET_BARREL_SHIFT_ENABLED && !TARGET_SIGN_EXTEND_ENABLED)\n+    target_flags |= MASK_SIGN_EXTEND_ENABLED;\n+}\n+\n+/* Return nonzero if this function is known to have a null epilogue.\n+   This allows the optimizer to omit jumps to jumps if no stack\n+   was created.  */\n+int\n+lm32_can_use_return (void)\n+{\n+  if (!reload_completed)\n+    return 0;\n+\n+  if (df_regs_ever_live_p (RA_REGNUM) || crtl->profile)\n+    return 0;\n+\n+  if (lm32_compute_frame_size (get_frame_size ()) != 0)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Support function to determine the return address of the function\n+   'count' frames back up the stack.  */\n+rtx\n+lm32_return_addr_rtx (int count, rtx frame)\n+{\n+  rtx r;\n+  if (count == 0)\n+    {\n+      if (!df_regs_ever_live_p (RA_REGNUM))\n+\tr = gen_rtx_REG (Pmode, RA_REGNUM);\n+      else\n+\t{\n+\t  r = gen_rtx_MEM (Pmode,\n+\t\t\t   gen_rtx_PLUS (Pmode, frame,\n+\t\t\t\t\t GEN_INT (-2 * UNITS_PER_WORD)));\n+\t  set_mem_alias_set (r, get_frame_alias_set ());\n+\t}\n+    }\n+  else if (flag_omit_frame_pointer)\n+    r = NULL_RTX;\n+  else\n+    {\n+      r = gen_rtx_MEM (Pmode,\n+\t\t       gen_rtx_PLUS (Pmode, frame,\n+\t\t\t\t     GEN_INT (-2 * UNITS_PER_WORD)));\n+      set_mem_alias_set (r, get_frame_alias_set ());\n+    }\n+  return r;\n+}\n+\n+/* Return true if EXP should be placed in the small data section.  */\n+\n+static bool\n+lm32_in_small_data_p (const_tree exp)\n+{\n+  /* We want to merge strings, so we never consider them small data.  */\n+  if (TREE_CODE (exp) == STRING_CST)\n+    return false;\n+\n+  /* Functions are never in the small data area.  Duh.  */\n+  if (TREE_CODE (exp) == FUNCTION_DECL)\n+    return false;\n+\n+  if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))\n+    {\n+      const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));\n+      if (strcmp (section, \".sdata\") == 0 || strcmp (section, \".sbss\") == 0)\n+\treturn true;\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n+\n+      /* If this is an incomplete type with size 0, then we can't put it\n+         in sdata because it might be too big when completed.  */\n+      if (size > 0 && (unsigned HOST_WIDE_INT) size <= g_switch_value)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Emit straight-line code to move LENGTH bytes from SRC to DEST.\n+   Assume that the areas do not overlap.  */\n+\n+static void\n+lm32_block_move_inline (rtx dest, rtx src, HOST_WIDE_INT length,\n+\t\t\tHOST_WIDE_INT alignment)\n+{\n+  HOST_WIDE_INT offset, delta;\n+  unsigned HOST_WIDE_INT bits;\n+  int i;\n+  enum machine_mode mode;\n+  rtx *regs;\n+\n+  /* Work out how many bits to move at a time.  */\n+  switch (alignment)\n+    {\n+    case 1:\n+      bits = 8;\n+      break;\n+    case 2:\n+      bits = 16;\n+      break;\n+    default:\n+      bits = 32;\n+      break;\n+    }\n+\n+  mode = mode_for_size (bits, MODE_INT, 0);\n+  delta = bits / BITS_PER_UNIT;\n+\n+  /* Allocate a buffer for the temporary registers.  */\n+  regs = alloca (sizeof (rtx) * length / delta);\n+\n+  /* Load as many BITS-sized chunks as possible.  */\n+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)\n+    {\n+      regs[i] = gen_reg_rtx (mode);\n+      emit_move_insn (regs[i], adjust_address (src, mode, offset));\n+    }\n+\n+  /* Copy the chunks to the destination.  */\n+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)\n+    emit_move_insn (adjust_address (dest, mode, offset), regs[i]);\n+\n+  /* Mop up any left-over bytes.  */\n+  if (offset < length)\n+    {\n+      src = adjust_address (src, BLKmode, offset);\n+      dest = adjust_address (dest, BLKmode, offset);\n+      move_by_pieces (dest, src, length - offset,\n+\t\t      MIN (MEM_ALIGN (src), MEM_ALIGN (dest)), 0);\n+    }\n+}\n+\n+/* Expand string/block move operations.\n+\n+   operands[0] is the pointer to the destination.\n+   operands[1] is the pointer to the source.\n+   operands[2] is the number of bytes to move.\n+   operands[3] is the alignment.  */\n+\n+int\n+lm32_expand_block_move (rtx * operands)\n+{\n+  if ((GET_CODE (operands[2]) == CONST_INT) && (INTVAL (operands[2]) <= 32))\n+    {\n+      lm32_block_move_inline (operands[0], operands[1], INTVAL (operands[2]),\n+\t\t\t      INTVAL (operands[3]));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return TRUE if X references a SYMBOL_REF or LABEL_REF whose symbol\n+   isn't protected by a PIC unspec.  */\n+int\n+nonpic_symbol_mentioned_p (rtx x)\n+{\n+  const char *fmt;\n+  int i;\n+\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF\n+      || GET_CODE (x) == PC)\n+    return 1;\n+\n+  /* We don't want to look into the possible MEM location of a\n+     CONST_DOUBLE, since we're not going to use it, in general.  */\n+  if (GET_CODE (x) == CONST_DOUBLE)\n+    return 0;\n+\n+  if (GET_CODE (x) == UNSPEC)\n+    return 0;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (nonpic_symbol_mentioned_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && nonpic_symbol_mentioned_p (XEXP (x, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+lm32_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  bool small_mode;\n+\n+  const int arithmetic_latency = 1;\n+  const int shift_latency = 1;\n+  const int compare_latency = 2;\n+  const int multiply_latency = 3;\n+  const int load_latency = 3;\n+  const int libcall_size_cost = 5;\n+\n+  /* Determine if we can handle the given mode size in a single instruction.  */\n+  small_mode = (mode == QImode) || (mode == HImode) || (mode == SImode);\n+\n+  switch (code)\n+    {\n+\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case NOT:\n+    case NEG:\n+      if (!speed)\n+\t*total = COSTS_N_INSNS (LM32_NUM_REGS (mode));\n+      else\n+\t*total =\n+\t  COSTS_N_INSNS (arithmetic_latency + (LM32_NUM_REGS (mode) - 1));\n+      break;\n+\n+    case COMPARE:\n+      if (small_mode)\n+\t{\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = COSTS_N_INSNS (compare_latency);\n+\t}\n+      else\n+\t{\n+\t  /* FIXME. Guessing here.  */\n+\t  *total = COSTS_N_INSNS (LM32_NUM_REGS (mode) * (2 + 3) / 2);\n+\t}\n+      break;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (TARGET_BARREL_SHIFT_ENABLED && small_mode)\n+\t{\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = COSTS_N_INSNS (shift_latency);\n+\t}\n+      else if (TARGET_BARREL_SHIFT_ENABLED)\n+\t{\n+\t  /* FIXME: Guessing here.  */\n+\t  *total = COSTS_N_INSNS (LM32_NUM_REGS (mode) * 4);\n+\t}\n+      else if (small_mode && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  *total = COSTS_N_INSNS (INTVAL (XEXP (x, 1)));\n+\t}\n+      else\n+\t{\n+\t  /* Libcall.  */\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (libcall_size_cost);\n+\t  else\n+\t    *total = COSTS_N_INSNS (100);\n+\t}\n+      break;\n+\n+    case MULT:\n+      if (TARGET_MULTIPLY_ENABLED && small_mode)\n+\t{\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = COSTS_N_INSNS (multiply_latency);\n+\t}\n+      else\n+\t{\n+\t  /* Libcall.  */\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (libcall_size_cost);\n+\t  else\n+\t    *total = COSTS_N_INSNS (100);\n+\t}\n+      break;\n+\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      if (TARGET_DIVIDE_ENABLED && small_mode)\n+\t{\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    {\n+\t      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t\t{\n+\t\t  int cycles = 0;\n+\t\t  unsigned HOST_WIDE_INT i = INTVAL (XEXP (x, 1));\n+\n+\t\t  while (i)\n+\t\t    {\n+\t\t      i >>= 2;\n+\t\t      cycles++;\n+\t\t    }\n+\t\t  if (IN_RANGE (i, 0, 65536))\n+\t\t    *total = COSTS_N_INSNS (1 + 1 + cycles);\n+\t\t  else\n+\t\t    *total = COSTS_N_INSNS (2 + 1 + cycles);\n+\t\t  return true;\n+\t\t}\n+\t      else if (GET_CODE (XEXP (x, 1)) == REG)\n+\t\t{\n+\t\t  *total = COSTS_N_INSNS (1 + GET_MODE_SIZE (mode) / 2);\n+\t\t  return true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *total = COSTS_N_INSNS (1 + GET_MODE_SIZE (mode) / 2);\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Libcall.  */\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (libcall_size_cost);\n+\t  else\n+\t    *total = COSTS_N_INSNS (100);\n+\t}\n+      break;\n+\n+    case HIGH:\n+    case LO_SUM:\n+      if (!speed)\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (arithmetic_latency);\n+      break;\n+\n+    case ZERO_EXTEND:\n+      if (MEM_P (XEXP (x, 0)))\n+\t*total = COSTS_N_INSNS (0);\n+      else if (small_mode)\n+\t{\n+\t  if (!speed)\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = COSTS_N_INSNS (arithmetic_latency);\n+\t}\n+      else\n+\t*total = COSTS_N_INSNS (LM32_NUM_REGS (mode) / 2);\n+      break;\n+\n+    case CONST_INT:\n+      {\n+\tswitch (outer_code)\n+\t  {\n+\t  case HIGH:\n+\t  case LO_SUM:\n+\t    *total = COSTS_N_INSNS (0);\n+\t    return true;\n+\n+\t  case AND:\n+\t  case XOR:\n+\t  case IOR:\n+\t  case ASHIFT:\n+\t  case ASHIFTRT:\n+\t  case LSHIFTRT:\n+\t  case ROTATE:\n+\t  case ROTATERT:\n+\t    if (satisfies_constraint_L (x))\n+\t      *total = COSTS_N_INSNS (0);\n+\t    else\n+\t      *total = COSTS_N_INSNS (2);\n+\t    return true;\n+\n+\t  case SET:\n+\t  case PLUS:\n+\t  case MINUS:\n+\t  case COMPARE:\n+\t    if (satisfies_constraint_K (x))\n+\t      *total = COSTS_N_INSNS (0);\n+\t    else\n+\t      *total = COSTS_N_INSNS (2);\n+\t    return true;\n+\n+\t  case MULT:\n+\t    if (TARGET_MULTIPLY_ENABLED)\n+\t      {\n+\t        if (satisfies_constraint_K (x))\n+\t         *total = COSTS_N_INSNS (0);\n+\t        else\n+\t          *total = COSTS_N_INSNS (2);\n+\t\treturn true;\n+\t      }\n+\t    /* Fall through.  */ \n+\n+\t  default:\n+            if (satisfies_constraint_K (x))\n+\t      *total = COSTS_N_INSNS (1);\n+\t    else\n+\t      *total = COSTS_N_INSNS (2);\n+\t    return true;\n+\t  }\n+      }\n+\n+    case SYMBOL_REF:\n+    case CONST:\n+      switch (outer_code)\n+\t{\n+\tcase HIGH:\n+\tcase LO_SUM:\n+\t  *total = COSTS_N_INSNS (0);\n+\t  return true;\n+\n+\tcase MEM:\n+\tcase SET:\n+\t  if (g_switch_value)\n+\t    {\n+\t      *total = COSTS_N_INSNS (0);\n+\t      return true;\n+\t    }\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+\n+    case LABEL_REF:\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case SET:\n+      *total = COSTS_N_INSNS (1);\n+      break;\n+\n+    case MEM:\n+      if (!speed)\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (load_latency);\n+      break;\n+\n+    }\n+\n+  return false;\n+}\n+\n+/* Implemenent TARGET_CAN_ELIMINATE.  */\n+\n+bool\n+lm32_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n+{\n+  return (to == STACK_POINTER_REGNUM && frame_pointer_needed) ? false : true;\n+}\n+\n+/* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n+\n+static bool\n+lm32_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x, bool strict)\n+{  \n+   /* (rM) */                                                    \n+  if (strict && REG_P (x) && STRICT_REG_OK_FOR_BASE_P (x))\n+    return true;\n+  if (!strict && REG_P (x) && NONSTRICT_REG_OK_FOR_BASE_P (x))\n+    return true;\n+       \n+  /* (rM)+literal) */                               \n+  if (GET_CODE (x) == PLUS  \n+     && REG_P (XEXP (x, 0))                                     \n+     && ((strict && STRICT_REG_OK_FOR_BASE_P (XEXP (x, 0)))\n+         || (!strict && NONSTRICT_REG_OK_FOR_BASE_P (XEXP (x, 0))))                           \n+     && GET_CODE (XEXP (x, 1)) == CONST_INT                      \n+     && satisfies_constraint_K (XEXP ((x), 1)))\n+    return true;\n+              \n+  /* gp(sym)  */   \n+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_SMALL_P (x)) \n+    return true;\n+    \n+  return false;                                \n+}\n+\n+/* Check a move is not memory to memory.  */ \n+\n+bool \n+lm32_move_ok (enum machine_mode mode, rtx operands[2]) {\n+  if (memory_operand (operands[0], mode))\n+    return register_or_zero_operand (operands[1], mode);\n+  return true;\n+}\n+\n+/* Implement LEGITIMATE_CONSTANT_P.  */\n+\n+bool\n+lm32_legitimate_constant_p (rtx x)\n+{\n+  /* 32-bit addresses require multiple instructions.  */  \n+  if (!flag_pic && reloc_operand (x, GET_MODE (x)))\n+    return false; \n+  \n+  return true;\n+}"}, {"sha": "814f5b5258c6b776bdee14ec3c9e8d8d1888046e", "filename": "gcc/config/lm32/lm32.h", "status": "added", "additions": 581, "deletions": 0, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.h?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,581 @@\n+/* Definitions of target machine for GNU compiler, Lattice Mico32 architecture.\n+   Contributed by Jon Beniston <jon@beniston.com>\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/*-------------------------------*/\n+/* Run-time Target Specification */\n+/*-------------------------------*/\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#ifndef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (LatticeMico32)\")\n+#endif\n+\n+/* Target CPU builtins.  */\n+#define TARGET_CPU_CPP_BUILTINS()                       \\\n+  do                                                    \\\n+    {                                                   \\\n+      builtin_define (\"__lm32__\");                      \\\n+      builtin_assert (\"cpu=lm32\");                      \\\n+      builtin_assert (\"machine=lm32\");                  \\\n+      if (TARGET_MULTIPLY_ENABLED)                      \\\n+        builtin_define (\"__multiply_enabled__\");        \\\n+      if (TARGET_DIVIDE_ENABLED)                        \\\n+        builtin_define (\"__divide_enabled__\");          \\\n+      if (TARGET_BARREL_SHIFT_ENABLED)                  \\\n+        builtin_define (\"__barrel_shift_enabled__\");    \\\n+      if (TARGET_SIGN_EXTEND_ENABLED)                   \\\n+        builtin_define (\"__sign_extend_enabled__\");     \\\n+      if (TARGET_USER_ENABLED)                          \\\n+        builtin_define (\"__user_enabled__\");            \\\n+    }                                                   \\\n+  while (0)\n+\n+#undef  ASM_SPEC\n+#define ASM_SPEC \"\\\n+%{mmultiply-enabled} \\\n+%{mdivide-enabled} \\\n+%{mbarrel-shift-enabled} \\\n+%{msign-extend-enabled} \\\n+%{muser-extend-enabled} \\\n+%{v} \\\n+\"\n+\n+/* Let link script define all link options. \n+   Default to using simulator link script.  */\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"\"\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"\"\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"%{!T*:-T sim.ld}\"\n+\n+#define OVERRIDE_OPTIONS lm32_override_options()\n+\n+extern int target_flags;\n+\n+/* Add -G xx support.  */\n+\n+#undef  SWITCH_TAKES_ARG\n+#define SWITCH_TAKES_ARG(CHAR) \\\n+(DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n+\n+#undef  CC1_SPEC\n+#define CC1_SPEC \"%{G*}\"\n+\n+/*---------------------------------*/\n+/* Target machine storage layout.  */\n+/*---------------------------------*/\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN 1\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+\n+#define BITS_PER_UNIT 8\n+#define BITS_PER_WORD 32\n+#define UNITS_PER_WORD 4\n+\n+#define POINTER_SIZE 32\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \\\n+do {                                                    \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT                 \\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)         \\\n+    (MODE) = word_mode;                                 \\\n+} while (0)\n+\n+#define PARM_BOUNDARY 32\n+\n+#define STACK_BOUNDARY 32\n+\n+#define BIGGEST_ALIGNMENT 64\n+\n+#define FUNCTION_BOUNDARY  32\n+\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+#define STRICT_ALIGNMENT 1\n+\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays and structures word-aligned to allow faster copying etc.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  ((((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\t\\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+/* We need this for the same reason as DATA_ALIGNMENT, namely to cause\n+   character arrays to be word-aligned so that `strcpy' calls that copy\n+   constants to character arrays can be done inline, and 'strcmp' can be\n+   optimised to use word loads.  */\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n+  DATA_ALIGNMENT (TYPE, ALIGN)\n+\n+/*----------------------------------------*/\n+/* Layout of source language data types.  */\n+/*----------------------------------------*/\n+\n+#define INT_TYPE_SIZE\t\t    32\n+#define SHORT_TYPE_SIZE\t\t    16\n+#define LONG_TYPE_SIZE\t\t    32\n+#define LONG_LONG_TYPE_SIZE\t    64\n+\n+#define FLOAT_TYPE_SIZE\t\t    32\n+#define DOUBLE_TYPE_SIZE\t    64\n+#define LONG_DOUBLE_TYPE_SIZE       64\n+\n+#define DEFAULT_SIGNED_CHAR         0\n+\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#define PTRDIFF_TYPE \"int\"\n+\n+/*---------------------------*/\n+/* Standard register usage.  */\n+/*---------------------------*/\n+\n+#define FIRST_PSEUDO_REGISTER  32\n+\n+#define RV_REGNUM   1\n+#define GP_REGNUM   26\n+#define FP_REGNUM   27\n+#define SP_REGNUM   28\n+#define RA_REGNUM   29\n+\n+#define G_REG_P(X)      ((X)<32)\n+\n+#define FIXED_REGISTERS   \\\n+{ 1, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 1, 0, 1, 0, 1, 1}\n+\n+#define CALL_USED_REGISTERS \\\n+{ 1, 1, 1, 1, 1, 1, 1, 1,   \\\n+  1, 1, 1, 0, 0, 0, 0, 0,   \\\n+  0, 0, 0, 0, 0, 0, 0, 0,   \\\n+  0, 0, 1, 0, 1, 0, 1, 1}\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n+    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) G_REG_P(REGNO)\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)           \\\n+(      GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n+    && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n+    && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n+    && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n+\n+#define AVOID_CCMODE_COPIES\n+\n+/*----------------------------------*/\n+/* Register classes and constants.  */\n+/*----------------------------------*/\n+\n+enum reg_class\n+{\n+  NO_REGS,                                      \n+  GENERAL_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES { \"NO_REGS\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+\n+#define REG_CLASS_CONTENTS      \\\n+{ {0x00000000},                 \\\n+  {0xffffffff},                 \\\n+  {0xffffffff}                  \\\n+}\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+    (G_REG_P(REGNO) ? GENERAL_REGS : NO_REGS)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define INDEX_REG_CLASS NO_REGS\n+\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+    (G_REG_P (REGNO) || G_REG_P ((unsigned) reg_renumber[REGNO]))\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n+\n+/*----------------------------------------*/\n+/* Stack Layout and Calling Conventions.  */\n+/*----------------------------------------*/\n+\n+#define STACK_GROWS_DOWNWARD 1\n+\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+#define STACK_POINTER_OFFSET (UNITS_PER_WORD)\n+\n+#define STARTING_FRAME_OFFSET (UNITS_PER_WORD)\n+\n+#define FIRST_PARM_OFFSET(FNDECL) (UNITS_PER_WORD)\n+\n+#define STACK_POINTER_REGNUM SP_REGNUM\n+\n+#define FRAME_POINTER_REGNUM FP_REGNUM\n+\n+#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n+\n+#define RETURN_ADDR_RTX(count, frame)                                   \\\n+  lm32_return_addr_rtx (count, frame)\n+\n+/* FIXME - This is not yet supported.  */\n+#define STATIC_CHAIN_REGNUM 9\n+\n+#define ELIMINABLE_REGS \\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },                        \\\n+ { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },                          \\\n+}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)                    \\\n+  (OFFSET) = lm32_compute_initial_elimination_offset (FROM, TO)\n+\n+/*-----------------------------*/\n+/* Function argument passing.  */\n+/*-----------------------------*/\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define RETURN_POPS_ARGS(DECL, FUNTYPE, SIZE) 0\n+\n+/*--------------------------------*/\n+/* Passing Arguments in Registers */\n+/*--------------------------------*/\n+\n+/* The first argument register.  */\n+#define LM32_FIRST_ARG_REG 1\n+\n+/* The number of (integer) argument register available.  */\n+#define LM32_NUM_ARG_REGS 8\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)                            \\\n+  lm32_function_arg ((CUM), (MODE), (TYPE), (NAMED))\n+\n+#define CUMULATIVE_ARGS int\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT,N_NAMED_ARGS)  \\\n+  (CUM) = 0\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)                    \\\n+  (CUM) += LM32_NUM_REGS2 (MODE, TYPE)\n+\n+#define FUNCTION_ARG_REGNO_P(r)                                         \\\n+  (((r) >= LM32_FIRST_ARG_REG) && ((r) <= LM32_NUM_ARG_REGS))\n+\n+/*--------------------*/\n+/* Function results.  */\n+/*--------------------*/\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)                                   \\\n+   gen_rtx_REG ((INTEGRAL_TYPE_P (VALTYPE)                              \\\n+                 && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)           \\\n+\t            ? word_mode                                         \\\n+\t            : TYPE_MODE (VALTYPE),\t\t\t\t\\\n+\t            RV_REGNUM)\n+\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, RV_REGNUM)\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == RV_REGNUM)\n+\n+#define RETURN_IN_MEMORY(TYPE) lm32_return_in_memory (TYPE)\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Convert from bytes to ints.  */\n+#define LM32_NUM_INTS(X) (((X) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The number of (integer) registers required to hold a quantity of\n+   type MODE.  */\n+#define LM32_NUM_REGS(MODE) LM32_NUM_INTS (GET_MODE_SIZE (MODE))\n+\n+/* The number of (integer) registers required to hold a quantity of\n+   TYPE MODE.  */\n+#define LM32_NUM_REGS2(MODE, TYPE)                       \\\n+  LM32_NUM_INTS ((MODE) == BLKmode ?                     \\\n+  int_size_in_bytes (TYPE) : GET_MODE_SIZE (MODE))\n+\n+#define STRUCT_VALUE 0\n+\n+/*---------------------------*/\n+/* Function entry and exit.  */\n+/*---------------------------*/\n+\n+/*-------------*/\n+/* Profiling.  */\n+/*-------------*/\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n+\n+/*---------------*/\n+/* Trampolines.  */\n+/*---------------*/\n+\n+#define TRAMPOLINE_SIZE\t\t0\n+\n+/*---------------------*/\n+/*  Addressing Modes.  */\n+/*---------------------*/\n+\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+    || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n+    || (GET_CODE (X) == CONST)))\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+#define STRICT_REG_OK_FOR_BASE_P(X)                                     \\\n+  (REGNO_OK_FOR_BASE_P (REGNO (X)))\n+#define NONSTRICT_REG_OK_FOR_BASE_P(X)                                  \\\n+  (G_REG_P (REGNO (X)) || !HARD_REGISTER_NUM_P (REGNO (X)))\n+\n+#ifdef REG_OK_STRICT\n+#define REG_OK_FOR_BASE_P(X) STRICT_REG_OK_FOR_BASE_P(X)\n+#else\n+#define REG_OK_FOR_BASE_P(X) NONSTRICT_REG_OK_FOR_BASE_P(X)\n+#endif\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \t\t\t\\\n+  if (GET_CODE (ADDR) == PLUS) goto LABEL;\t\t      \t\t\\\n+\n+#define LEGITIMATE_CONSTANT_P(X) lm32_legitimate_constant_p\n+\n+/*-------------------------*/\n+/* Condition Code Status.  */\n+/*-------------------------*/\n+\n+#define REVERSIBLE_CC_MODE(MODE) 1\n+\n+/*---------*/\n+/* Costs.  */\n+/*---------*/\n+\n+#define SLOW_BYTE_ACCESS 1\n+\n+#define NO_FUNCTION_CSE\n+\n+#define BRANCH_COST(speed_p, predictable_p) 4\n+\n+#define MOVE_RATIO(speed) (speed ? 24 : 3)\n+\n+/*------------*/\n+/* Sections.  */\n+/*------------*/\n+\n+#define TEXT_SECTION_ASM_OP             \"\\t.section\\t.text\"\n+#define DATA_SECTION_ASM_OP             \"\\t.section\\t.data\"\n+#define SDATA_SECTION_ASM_OP            \"\\t.section\\t.sdata,\\\"aw\\\"\"\n+#define BSS_SECTION_ASM_OP              \"\\t.section\\t.bss\"\n+#define SBSS_SECTION_ASM_OP             \"\\t.section\\t.sbss,\\\"aw\\\"\"\n+\n+/*-------*/\n+/* PIC.  */\n+/*-------*/\n+\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? GP_REGNUM : INVALID_REGNUM)\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X)                                    \\\n+\t(!(nonpic_symbol_mentioned_p (X)))\n+\n+/*-------------*/\n+/* Assembler.  */\n+/*-------------*/\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n+ do {\t\t\t\t\t\t\t\t\t\\\n+\tfputc ( '\\t', FILE);\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n+\tfputs ( \" = \", FILE);\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n+\tfputc ( '\\n', FILE);\t\t\t\t\t\t\\\n+ } while (0)\n+\n+/* Override default implementation in elfos.h to support -G.  */\n+#undef  ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((SIZE) <= g_switch_value)\t\t\t\t\t\t\\\n+    switch_to_section (sbss_section);\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    switch_to_section (bss_section);\t\t\t\t\t\\\n+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\t\\\n+  if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+    ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);\t\t\t\\\n+  ASM_OUTPUT_ALIGN ((FILE), exact_log2((ALIGN) / BITS_PER_UNIT));\t\\\n+  ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SKIP((FILE), (SIZE) ? (SIZE) : 1);\t\t\t\t\\\n+} while (0)\n+\n+/* Override default implementation in elfos.h to support -G.  */\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do \t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((SIZE) <= g_switch_value)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      switch_to_section (sbss_section);\t\t\t\t\t\\\n+      (*targetm.asm_out.globalize_label) (FILE, NAME);\t\t\t\\\n+      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\t\\\n+      if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+\tASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);\t\t\t\\\n+      ASM_OUTPUT_ALIGN ((FILE), exact_log2((ALIGN) / BITS_PER_UNIT));\t\\\n+      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+      ASM_OUTPUT_SKIP((FILE), (SIZE) ? (SIZE) : 1);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      switch_to_section (bss_section);\t\t\t\t\t\\\n+      fprintf ((FILE), \"%s\", COMMON_ASM_OP);\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",          \\\n+               (SIZE), (ALIGN) / BITS_PER_UNIT);\t                \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME) \\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  do {\t\t\t\t\t\\\n+    const char *xname = (NAME);\t\t\\\n+    if (xname[0] == '@')\t\t\\\n+      xname += 1;\t\t\t\\\n+    if (xname[0] == '*')\t\t\\\n+      xname += 1;\t\t\t\\\n+    fputs (xname, FILE);\t\t\\\n+  } while (0)\n+\n+#define ASM_OUTPUT_SYMBOL_REF(STREAM, SYMBOL)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    assemble_name (STREAM, XSTR (SYMBOL, 0));\t\t\t\t\\\n+  } while (0)\n+\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n+\n+#define REGISTER_NAMES                                          \\\n+{                                                               \\\n+ \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t        \\\n+ \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",        \\\n+ \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",        \\\n+ \"r24\", \"r25\",  \"gp\",  \"fp\",  \"sp\",  \"ra\",  \"ea\",  \"ba\"}\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+  (((CHAR) == '&') || ((CHAR) == '@') || ((CHAR) == '*'))\n+\n+#define PRINT_OPERAND(FILE, X, CODE)                            \\\n+  lm32_print_operand (FILE, X, CODE)\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)                       \\\n+  lm32_print_operand_address (FILE, ADDR)\n+\n+#ifndef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX\t\".\"\n+#endif\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)                              \\\n+  do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", (1 << (LOG))); } while (0)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)                    \\\n+do {                                                            \\\n+  char label[64];                                               \\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);              \\\n+  fprintf (FILE, \"\\n\\t.word\\t\");                                \\\n+  assemble_name (FILE, label);                                  \\\n+  fprintf (FILE, \"\\n\");                                         \\\n+} while (0)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)        \\\n+do {                                                            \\\n+  char label[64];                                               \\\n+  fprintf (FILE, \"\\t.word\\t(\");                                 \\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\\\n+  assemble_name (FILE, label);                                  \\\n+  fprintf (FILE, \"-\");                                          \\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", REL);                \\\n+  assemble_name (FILE, label);                                  \\\n+  fprintf (FILE, \")\\n\");                                        \\\n+} while (0)\n+\n+/*-------------*/\n+/* Debugging.  */\n+/*-------------*/\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+#define DEFAULT_GDB_EXTENSIONS 1\n+\n+/*--------*/\n+/* Misc.  */\n+/*--------*/\n+\n+#define CASE_VECTOR_MODE Pmode\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\n+\n+#define MOVE_MAX        UNITS_PER_WORD\n+#define MAX_MOVE_MAX    4\n+\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define Pmode SImode\n+\n+#define FUNCTION_MODE SImode\n+\n+#ifndef NO_IMPLICIT_EXTERN_C\n+#define NO_IMPLICIT_EXTERN_C\n+#endif\n+\n+#define STORE_FLAG_VALUE 1"}, {"sha": "6d4305380c0b6e9cc261f8db846720dae54c0dda", "filename": "gcc/config/lm32/lm32.md", "status": "added", "additions": 996, "deletions": 0, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.md?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,996 @@\n+;; Machine description of the Lattice Mico32 architecture for GNU C compiler.\n+;; Contributed by Jon Beniston <jon@beniston.com>\n+\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  \n+\n+;; Include predicate and constraint definitions\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+\n+;; Register numbers\n+(define_constants\n+  [(RA_REGNUM           29)\t; return address register.\n+  ]\n+)\n+\n+;; LM32 specific volatile operations\n+(define_constants\n+  [(UNSPECV_BLOCKAGE    1)]     ; prevent scheduling across pro/epilog boundaries\n+)\n+\n+;; LM32 specific operations\n+(define_constants\n+  [(UNSPEC_GOT          2)\n+   (UNSPEC_GOTOFF_HI16  3)\n+   (UNSPEC_GOTOFF_LO16  4)]     \n+)\n+\n+;; --------------------------------- \n+;;      instruction types\n+;; ---------------------------------\n+\n+(define_attr \"type\"\n+  \"unknown,load,store,arith,compare,shift,multiply,divide,call,icall,ubranch,uibranch,cbranch\"\n+  (const_string \"unknown\"))\n+  \n+;; ---------------------------------\n+;;      instruction lengths\n+;; ---------------------------------\n+  \n+; All instructions are 4 bytes\n+; Except for branches that are out of range, and have to be implemented\n+; as two instructions\n+(define_attr \"length\" \"\" \n+        (cond [\n+                (eq_attr \"type\" \"cbranch\")\n+                (if_then_else\n+                        (lt (abs (minus (match_dup 2) (pc)))\n+                                (const_int 32768)\n+                        )\n+                        (const_int 4)\n+                        (const_int 8)               \n+                )\n+              ] \n+        (const_int 4))\n+)\n+                    \n+;; ---------------------------------\n+;;           scheduling \n+;; ---------------------------------\n+\n+(define_automaton \"lm32\")\n+\n+(define_cpu_unit \"x\" \"lm32\")\n+(define_cpu_unit \"m\" \"lm32\")\n+(define_cpu_unit \"w\" \"lm32\")\n+\n+(define_insn_reservation \"singlecycle\" 1\n+  (eq_attr \"type\" \"store,arith,call,icall,ubranch,uibranch,cbranch\")\n+ \"x\")\n+\n+(define_insn_reservation \"twocycle\" 2\n+  (eq_attr \"type\" \"compare,shift,divide\")\n+ \"x,m\") \n+\n+(define_insn_reservation \"threecycle\" 3\n+  (eq_attr \"type\" \"load,multiply\")\n+ \"x,m,w\")\n+\n+;; ---------------------------------\n+;;               mov \n+;; ---------------------------------\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+        (match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (can_create_pseudo_p ())\n+    {\n+      if (GET_CODE (operand0) == MEM)\n+        {\n+          /* Source operand for store must be in a register.  */\n+          operands[1] = force_reg (QImode, operands[1]);\n+        }\n+    }\n+}\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+        (match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (can_create_pseudo_p ())\n+    {\n+      if (GET_CODE (operands[0]) == MEM)\n+        {\n+          /* Source operand for store must be in a register.  */\n+          operands[1] = force_reg (HImode, operands[1]);\n+        }\n+    }\n+}\")\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+        (match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (can_create_pseudo_p ())\n+    {\n+      if (GET_CODE (operands[0]) == MEM \n+\t  || (GET_CODE (operands[0]) == SUBREG \n+\t      && GET_CODE (SUBREG_REG (operands[0])) == MEM))\n+        {\n+          /* Source operand for store must be in a register.  */\n+          operands[1] = force_reg (SImode, operands[1]);\n+        }\n+    }\n+\n+  if (flag_pic && symbolic_operand (operands[1], SImode)) \n+    {\n+      if (GET_CODE (operands[1]) == LABEL_REF\n+          || (GET_CODE (operands[1]) == SYMBOL_REF \n+              && SYMBOL_REF_LOCAL_P (operands[1])\n+              && !SYMBOL_REF_WEAK (operands[1])))\n+        {\n+          emit_insn (gen_movsi_gotoff_hi16 (operands[0], operands[1]));\n+          emit_insn (gen_addsi3 (operands[0], \n+                                 operands[0], \n+                                 pic_offset_table_rtx));\n+          emit_insn (gen_movsi_gotoff_lo16 (operands[0], \n+                                            operands[0], \n+                                            operands[1]));\n+        } \n+      else \n+        emit_insn (gen_movsi_got (operands[0], operands[1]));\n+      crtl->uses_pic_offset_table = 1;\n+      DONE;\n+    }         \n+  else if (flag_pic && GET_CODE (operands[1]) == CONST) \n+    {\n+      rtx op = XEXP (operands[1], 0);\n+      if (GET_CODE (op) == PLUS)\n+        {\n+          rtx arg0 = XEXP (op, 0);\n+          rtx arg1 = XEXP (op, 1);\n+          if (GET_CODE (arg0) == LABEL_REF\n+              || (GET_CODE (arg0) == SYMBOL_REF \n+                  && SYMBOL_REF_LOCAL_P (arg0)\n+                  && !SYMBOL_REF_WEAK (arg0)))\n+            {\n+              emit_insn (gen_movsi_gotoff_hi16 (operands[0], arg0));\n+              emit_insn (gen_addsi3 (operands[0], \n+                                     operands[0], \n+                                     pic_offset_table_rtx));\n+              emit_insn (gen_movsi_gotoff_lo16 (operands[0], \n+                                                operands[0], \n+                                                arg0));\n+            } \n+          else \n+            emit_insn (gen_movsi_got (operands[0], arg0));\n+          emit_insn (gen_addsi3 (operands[0], operands[0], arg1));\n+          crtl->uses_pic_offset_table = 1;\n+          DONE;\n+        }     \n+    }\n+  else if (!flag_pic && reloc_operand (operands[1], GET_MODE (operands[1]))) \n+    {\n+      emit_insn (gen_rtx_SET (SImode, operands[0], gen_rtx_HIGH (SImode, operands[1])));\n+      emit_insn (gen_rtx_SET (SImode, operands[0], gen_rtx_LO_SUM (SImode, operands[0], operands[1])));\n+      DONE;\n+    }  \n+  else if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (!(satisfies_constraint_K (operands[1]) \n+          || satisfies_constraint_L (operands[1])\n+          || satisfies_constraint_U (operands[1])))      \n+        {\n+          emit_insn (gen_movsi_insn (operands[0], \n+                                     GEN_INT (INTVAL (operands[1]) & ~0xffff)));\n+          emit_insn (gen_iorsi3 (operands[0], \n+                                 operands[0], \n+                                 GEN_INT (INTVAL (operands[1]) & 0xffff)));\n+          DONE;\n+        }\n+    }    \n+}\")\n+\n+(define_expand \"movmemsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"\" \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n+  \"\"\n+{\n+  if (!lm32_expand_block_move (operands))\n+    FAIL;\n+  DONE;\n+})\n+\n+;; ---------------------------------\n+;;        load/stores/moves \n+;; ---------------------------------\n+\n+(define_insn \"movsi_got\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_operand 1 \"\" \"\")] UNSPEC_GOT))]\n+  \"flag_pic\"\n+  \"lw       %0, (gp+got(%1))\"\n+  [(set_attr \"type\" \"load\")]\n+)\n+\n+(define_insn \"movsi_gotoff_hi16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_operand 1 \"\" \"\")] UNSPEC_GOTOFF_HI16))]\n+  \"flag_pic\"\n+  \"orhi     %0, r0, gotoffhi16(%1)\"\n+  [(set_attr \"type\" \"load\")]\n+)\n+\n+(define_insn \"movsi_gotoff_lo16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                             (match_operand 2 \"\" \"\"))] UNSPEC_GOTOFF_LO16))]        \n+  \"flag_pic\"\n+  \"addi     %0, %1, gotofflo16(%2)\"\n+  [(set_attr \"type\" \"arith\")]\n+)\n+  \n+(define_insn \"*movsi_lo_sum\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (lo_sum:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                   (match_operand:SI 2 \"reloc_operand\" \"i\")))]\n+  \"!flag_pic\"\n+  \"ori      %0, %0, lo(%2)\"\n+  [(set_attr \"type\" \"arith\")]\n+)\n+\n+(define_insn \"*movqi_insn\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m,m,r\")\n+        (match_operand:QI 1 \"general_operand\" \"m,r,r,J,n\"))]\n+  \"lm32_move_ok (QImode, operands)\"\n+  \"@\n+   lbu      %0, %1\n+   or       %0, %1, r0\n+   sb       %0, %1\n+   sb       %0, r0\n+   addi     %0, r0, %1\"\n+  [(set_attr \"type\" \"load,arith,store,store,arith\")]   \n+)\n+   \n+(define_insn \"*movhi_insn\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,m,m,r,r\")\n+        (match_operand:HI 1 \"general_operand\" \"m,r,r,J,K,L\"))]\n+  \"lm32_move_ok (HImode, operands)\"\n+  \"@\n+   lhu      %0, %1\n+   or       %0, %1, r0\n+   sh       %0, %1\n+   sh       %0, r0\n+   addi     %0, r0, %1\n+   ori      %0, r0, %1\"\n+  [(set_attr \"type\" \"load,arith,store,store,arith,arith\")]   \n+)\n+\n+(define_insn \"movsi_insn\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,m,r,r,r,r,r\")\n+        (match_operand:SI 1 \"movsi_rhs_operand\" \"m,r,r,J,K,L,U,S,Y\"))]\n+  \"lm32_move_ok (SImode, operands)\"\n+  \"@\n+   lw       %0, %1\n+   or       %0, %1, r0\n+   sw       %0, %1\n+   sw       %0, r0\n+   addi     %0, r0, %1\n+   ori      %0, r0, %1\n+   orhi     %0, r0, hi(%1)\n+   mva      %0, gp(%1)\n+   orhi     %0, r0, hi(%1)\"\n+  [(set_attr \"type\" \"load,arith,store,store,arith,arith,arith,arith,arith\")]   \n+)\n+\n+;; ---------------------------------\n+;;      sign and zero extension \n+;; ---------------------------------\n+\n+(define_insn \"*extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_SIGN_EXTEND_ENABLED || (GET_CODE (operands[1]) != REG)\"\n+  \"@\n+   lb       %0, %1\n+   sextb    %0, %1\"\n+  [(set_attr \"type\" \"load,arith\")]\n+)\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+        (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"@\n+   lbu      %0, %1\n+   andi     %0, %1, 0xff\"\n+  [(set_attr \"type\" \"load,arith\")]  \n+)\n+\n+(define_insn \"*extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_SIGN_EXTEND_ENABLED || (GET_CODE (operands[1]) != REG)\"\n+  \"@\n+   lb       %0, %1\n+   sextb    %0, %1\"\n+  [(set_attr \"type\" \"load,arith\")]\n+)\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"@\n+   lbu      %0, %1\n+   andi     %0, %1, 0xff\"\n+  [(set_attr \"type\" \"load,arith\")]  \n+)\n+\n+(define_insn \"*extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_SIGN_EXTEND_ENABLED || (GET_CODE (operands[1]) != REG)\"\n+  \"@\n+   lh       %0, %1\n+   sexth    %0, %1\"\n+  [(set_attr \"type\" \"load,arith\")]\n+)\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"\"\n+  \"@\n+   lhu      %0, %1\n+   andi     %0, %1, 0xffff\"\n+  [(set_attr \"type\" \"load,arith\")]  \n+)\n+\n+;; ---------------------------------\n+;;             compare \n+;; ---------------------------------\n+\n+(define_expand \"cstoresi4\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(match_operator:SI 1 \"ordered_comparison_operator\"\n+\t [(match_operand:SI 2 \"register_operand\")\n+\t  (match_operand:SI 3 \"register_or_int_operand\")]))]\n+  \"\"\n+{\n+  lm32_expand_scc (operands);\n+  DONE;\n+})\n+\n+(define_insn \"*seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (eq:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+               (match_operand:SI 2 \"register_or_K_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   cmpe     %0, %z1, %2\n+   cmpei    %0, %z1, %2\"\n+  [(set_attr \"type\" \"compare\")]\n+)\n+\n+(define_insn \"*sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ne:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+               (match_operand:SI 2 \"register_or_K_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   cmpne    %0, %z1, %2\n+   cmpnei   %0, %z1, %2\"\n+  [(set_attr \"type\" \"compare\")]\n+)\n+\n+(define_insn \"*sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (gt:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ,rJ\")\n+               (match_operand:SI 2 \"register_or_K_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   cmpg     %0, %z1, %2\n+   cmpgi    %0, %z1, %2\"\n+  [(set_attr \"type\" \"compare\")]\n+)\n+\n+(define_insn \"*sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ge:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ,rJ\")\n+               (match_operand:SI 2 \"register_or_K_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   cmpge    %0, %z1, %2\n+   cmpgei   %0, %z1, %2\"\n+  [(set_attr \"type\" \"compare\")]\n+)\n+\n+(define_insn \"*sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (gtu:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ,rJ\")\n+                (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"\"\n+  \"@\n+   cmpgu    %0, %z1, %2\n+   cmpgui   %0, %z1, %2\"\n+  [(set_attr \"type\" \"compare\")]\n+)\n+\n+(define_insn \"*sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (geu:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ,rJ\")\n+                (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"\"\n+  \"@\n+   cmpgeu   %0, %z1, %2\n+   cmpgeui  %0, %z1, %2\"\n+  [(set_attr \"type\" \"compare\")]\n+)\n+\n+;; ---------------------------------\n+;;       unconditional branch\n+;; ---------------------------------\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"bi       %0\"\n+  [(set_attr \"type\" \"ubranch\")]\n+)\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"b        %0\"\n+  [(set_attr \"type\" \"uibranch\")]\n+)\n+\n+;; ---------------------------------\n+;;        conditional branch\n+;; ---------------------------------\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+   (if_then_else (match_operator 0 \"comparison_operator\" \n+                  [(match_operand:SI 1 \"register_operand\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\")])\n+                 (label_ref (match_operand 3 \"\" \"\"))\n+                 (pc)))]\n+  \"\"\n+  \"\n+{   \n+  lm32_expand_conditional_branch (operands);\n+  DONE;\n+}\")\n+\n+(define_insn \"*beq\"\n+  [(set (pc)\n+        (if_then_else (eq:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n+                             (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  return get_attr_length (insn) == 4\n+        ? \"be     %z0,%z1,%2\"\n+        : \"bne    %z0,%z1,8\\n\\tbi     %2\";\n+}  \n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"*bne\"\n+  [(set (pc)\n+        (if_then_else (ne:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n+                             (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  return get_attr_length (insn) == 4\n+        ? \"bne    %z0,%z1,%2\"\n+        : \"be     %z0,%z1,8\\n\\tbi     %2\";\n+}  \n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"*bgt\"\n+  [(set (pc)\n+        (if_then_else (gt:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n+                             (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  return get_attr_length (insn) == 4\n+        ? \"bg     %z0,%z1,%2\"\n+        : \"bge    %z1,%z0,8\\n\\tbi     %2\";\n+}  \n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"*bge\"\n+  [(set (pc)\n+        (if_then_else (ge:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n+                             (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  return get_attr_length (insn) == 4\n+        ? \"bge    %z0,%z1,%2\"\n+        : \"bg     %z1,%z0,8\\n\\tbi     %2\";\n+}  \n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"*bgtu\"\n+  [(set (pc)\n+        (if_then_else (gtu:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n+                              (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  return get_attr_length (insn) == 4\n+        ? \"bgu    %z0,%z1,%2\"\n+        : \"bgeu   %z1,%z0,8\\n\\tbi     %2\";\n+}  \n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"*bgeu\"\n+  [(set (pc)\n+        (if_then_else (geu:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n+                              (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))]\n+  \"\"\n+{\n+  return get_attr_length (insn) == 4\n+        ? \"bgeu   %z0,%z1,%2\"\n+        : \"bgu    %z1,%z0,8\\n\\tbi     %2\";\n+}  \n+  [(set_attr \"type\" \"cbranch\")])\n+\n+;; ---------------------------------\n+;;               call \n+;; ---------------------------------\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+                    (match_operand 1 \"\" \"\"))\n+              (clobber (reg:SI RA_REGNUM))\n+             ])]\n+  \"\"\n+  \"\n+{\n+  rtx addr = XEXP (operands[0], 0);\n+  if (!CONSTANT_ADDRESS_P (addr))\n+    XEXP (operands[0], 0) = force_reg (Pmode, addr);\n+}\")\n+\n+(define_insn \"*call\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"r,s\"))\n+         (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI RA_REGNUM))]\n+  \"\"\n+  \"@\n+   call     %0\n+   calli    %0\"\n+  [(set_attr \"type\" \"call,icall\")]  \n+)\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+                   (call (match_operand 1 \"\" \"\")\n+                         (match_operand 2 \"\" \"\")))\n+              (clobber (reg:SI RA_REGNUM))\n+             ])]\n+  \"\"\n+  \"\n+{\n+  rtx addr = XEXP (operands[1], 0);\n+  if (!CONSTANT_ADDRESS_P (addr))\n+    XEXP (operands[1], 0) = force_reg (Pmode, addr); \n+}\")\n+\n+(define_insn \"*call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=r,r\")\n+        (call (mem:SI (match_operand:SI 1 \"call_operand\" \"r,s\"))\n+              (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI RA_REGNUM))]\n+  \"\"\n+  \"@\n+   call     %1\n+   calli    %1\"\n+  [(set_attr \"type\" \"call,icall\")]  \n+)\n+\n+(define_insn \"return_internal\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (return)]\n+  \"\"\n+  \"b        %0\"\n+  [(set_attr \"type\" \"uibranch\")]  \n+)\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"lm32_can_use_return ()\"\n+  \"ret\"\n+  [(set_attr \"type\" \"uibranch\")]  \n+) \n+\n+;; ---------------------------------\n+;;       switch/case statements \n+;; ---------------------------------\n+  \n+(define_expand \"tablejump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx target = operands[0];\n+  if (flag_pic)\n+    {\n+      /* For PIC, the table entry is relative to the start of the table.  */\n+      rtx label = gen_reg_rtx (SImode);\n+      target = gen_reg_rtx (SImode);\n+      emit_move_insn (label, gen_rtx_LABEL_REF (SImode, operands[1]));\n+      emit_insn (gen_addsi3 (target, operands[0], label));\n+    }\n+  emit_jump_insn (gen_tablejumpsi (target, operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn \"tablejumpsi\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"b        %0\"\n+  [(set_attr \"type\" \"ubranch\")]  \n+)\n+\n+;; ---------------------------------\n+;;            arithmetic \n+;; ---------------------------------\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (plus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+                 (match_operand:SI 2 \"register_or_K_operand\" \"r,K\")))]\n+  \"\"\n+  \"@\n+   add      %0, %z1, %2\n+   addi     %0, %z1, %2\"\n+  [(set_attr \"type\" \"arith\")]  \n+)\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                  (match_operand:SI 2 \"register_or_zero_operand\" \"rJ\")))]\n+  \"\"\n+  \"sub      %0, %z1, %z2\"\n+  [(set_attr \"type\" \"arith\")]  \n+)\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (mult:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+                 (match_operand:SI 2 \"register_or_K_operand\" \"r,K\")))]\n+  \"TARGET_MULTIPLY_ENABLED\"\n+  \"@\n+   mul      %0, %z1, %2\n+   muli     %0, %z1, %2\"\n+  [(set_attr \"type\" \"multiply\")]\n+)\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (udiv:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIVIDE_ENABLED\"\n+  \"divu     %0, %z1, %2\"\n+  [(set_attr \"type\" \"divide\")]\n+)\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (umod:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIVIDE_ENABLED\"\n+  \"modu     %0, %z1, %2\"\n+  [(set_attr \"type\" \"divide\")]\n+)\n+\n+;; ---------------------------------\n+;;      negation and inversion \n+;; ---------------------------------\n+               \n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (neg:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")))]\n+  \"\"\n+  \"sub      %0, r0, %z1\"\n+  [(set_attr \"type\" \"arith\")]\n+)      \n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (not:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")))]\n+  \"\"\n+  \"not      %0, %z1\"\n+  [(set_attr \"type\" \"arith\")]\n+)\n+\n+;; ---------------------------------\n+;;             logical \n+;; ---------------------------------\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (and:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+                (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"\"\n+  \"@\n+   and      %0, %z1, %2\n+   andi     %0, %z1, %2\"\n+  [(set_attr \"type\" \"arith\")]\n+)\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ior:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+                (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"\"\n+  \"@\n+   or       %0, %z1, %2\n+   ori      %0, %z1, %2\"\n+  [(set_attr \"type\" \"arith\")]\n+)\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (xor:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+                (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"\"\n+  \"@\n+   xor      %0, %z1, %2\n+   xori     %0, %z1, %2\"\n+  [(set_attr \"type\" \"arith\")]\n+)\n+\n+(define_insn \"*norsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(not:SI (ior:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+\t\t\t(match_operand:SI 2 \"register_or_L_operand\" \"r,L\"))))]\n+  \"\"\n+  \"@ \n+   nor      %0, %z1, %2\n+   nori     %0, %z1, %2\"     \t\t\n+  [(set_attr \"type\" \"arith\")]\n+)                \n+\n+(define_insn \"*xnorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ,rJ\")\n+\t\t\t(match_operand:SI 2 \"register_or_L_operand\" \"r,L\"))))]\n+  \"\"\n+  \"@\n+   xnor     %0, %z1, %2\n+   xnori    %0, %z1, %2\"     \t\t\n+  [(set_attr \"type\" \"arith\")]\n+)                \n+\n+;; ---------------------------------\n+;;              shifts \n+;; ---------------------------------\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ashift:SI (match_operand:SI 1 \"register_or_zero_operand\" \"\")\n+                   (match_operand:SI 2 \"register_or_L_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_BARREL_SHIFT_ENABLED)\n+    {\n+      if (!optimize_size \n+          && satisfies_constraint_L (operands[2])\n+          && INTVAL (operands[2]) <= 8)\n+        {\n+          int i;\n+          int shifts = INTVAL (operands[2]);\n+          rtx one = GEN_INT (1);\n+          \n+          if (shifts == 0)\n+            emit_move_insn (operands[0], operands[1]);\n+          else\n+            emit_insn (gen_addsi3 (operands[0], operands[1], operands[1]));\n+          for (i = 1; i < shifts; i++) \n+            emit_insn (gen_addsi3 (operands[0], operands[0], operands[0]));\n+          DONE;                  \n+        }\n+      else\n+        FAIL;\n+    }\n+})  \n+\n+(define_insn \"*ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ashift:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ,rJ\")\n+                   (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"TARGET_BARREL_SHIFT_ENABLED\"\n+  \"@ \n+   sl       %0, %z1, %2\n+   sli      %0, %z1, %2\"\n+  [(set_attr \"type\" \"shift\")]\n+)\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ashiftrt:SI (match_operand:SI 1 \"register_or_zero_operand\" \"\")\n+                     (match_operand:SI 2 \"register_or_L_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_BARREL_SHIFT_ENABLED)\n+    {\n+      if (!optimize_size \n+          && satisfies_constraint_L (operands[2])\n+          && INTVAL (operands[2]) <= 8)\n+        {\n+          int i;\n+          int shifts = INTVAL (operands[2]);\n+          rtx one = GEN_INT (1);\n+          \n+          if (shifts == 0)\n+            emit_move_insn (operands[0], operands[1]);\n+          else\n+            emit_insn (gen_ashrsi3_1bit (operands[0], operands[1], one));\n+          for (i = 1; i < shifts; i++) \n+            emit_insn (gen_ashrsi3_1bit (operands[0], operands[0], one));\n+          DONE;                  \n+        }\n+      else\n+        FAIL;\n+    }\n+})  \n+                       \n+(define_insn \"*ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (ashiftrt:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ,rJ\")\n+                     (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"TARGET_BARREL_SHIFT_ENABLED\"\n+  \"@\n+   sr       %0, %z1, %2\n+   sri      %0, %z1, %2\"\n+  [(set_attr \"type\" \"shift\")]\n+)\n+\n+(define_insn \"ashrsi3_1bit\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (ashiftrt:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                     (match_operand:SI 2 \"constant_M_operand\" \"M\")))]\n+  \"!TARGET_BARREL_SHIFT_ENABLED\"\n+  \"sri      %0, %z1, %2\"\n+  [(set_attr \"type\" \"shift\")]\n+)\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (lshiftrt:SI (match_operand:SI 1 \"register_or_zero_operand\" \"\")\n+                     (match_operand:SI 2 \"register_or_L_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_BARREL_SHIFT_ENABLED)\n+    {\n+      if (!optimize_size \n+          && satisfies_constraint_L (operands[2])\n+          && INTVAL (operands[2]) <= 8)\n+        {\n+          int i;\n+          int shifts = INTVAL (operands[2]);\n+          rtx one = GEN_INT (1);\n+          \n+          if (shifts == 0)\n+            emit_move_insn (operands[0], operands[1]);\n+          else\n+            emit_insn (gen_lshrsi3_1bit (operands[0], operands[1], one));\n+          for (i = 1; i < shifts; i++) \n+            emit_insn (gen_lshrsi3_1bit (operands[0], operands[0], one));\n+          DONE;                  \n+        }\n+      else\n+        FAIL;\n+    }\n+})  \n+\n+(define_insn \"*lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (lshiftrt:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ,rJ\")\n+                     (match_operand:SI 2 \"register_or_L_operand\" \"r,L\")))]\n+  \"TARGET_BARREL_SHIFT_ENABLED\"\n+  \"@ \n+   sru      %0, %z1, %2\n+   srui     %0, %z1, %2\"\n+  [(set_attr \"type\" \"shift\")]   \n+)\n+\n+(define_insn \"lshrsi3_1bit\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (lshiftrt:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+                     (match_operand:SI 2 \"constant_M_operand\" \"M\")))]\n+  \"!TARGET_BARREL_SHIFT_ENABLED\"\n+  \"srui     %0, %z1, %2\"\n+  [(set_attr \"type\" \"shift\")]   \n+)\n+\n+;; ---------------------------------\n+;;     function entry / exit \n+;; ---------------------------------\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\n+{\n+  lm32_expand_prologue ();\n+  DONE;\n+}\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  lm32_expand_epilogue ();\n+  DONE;\n+}\")\n+\n+;; ---------------------------------\n+;;              nop \n+;; ---------------------------------\n+\n+(define_insn \"nop\"  \n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\" \"arith\")]\n+)\n+\n+;; ---------------------------------\n+;;             blockage \n+;; ---------------------------------\n+\n+;; used to stop the scheduler from \n+;; scheduling code across certain boundaries\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")]\n+)"}, {"sha": "9efecdd7c1313fae7223aabd34c52ed21a696212", "filename": "gcc/config/lm32/lm32.opt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Flm32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.opt?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,40 @@\n+; Options for the Lattice Mico32 port of the compiler.\n+; Contributed by Jon Beniston <jon@beniston.com>\n+;\n+; Copyright (C) 2009 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published\n+; by the Free Software Foundation; either version 3, or (at your\n+; option) any later version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+; \n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+;  <http://www.gnu.org/licenses/>.  \n+   \n+mmultiply-enabled\n+Target Report Mask(MULTIPLY_ENABLED)\n+Enable multiply instructions\n+\n+mdivide-enabled\n+Target Report Mask(DIVIDE_ENABLED)\n+Enable divide and modulus instructions\n+\n+mbarrel-shift-enabled\n+Target Report Mask(BARREL_SHIFT_ENABLED)\n+Enable barrel shift instructions\n+\n+msign-extend-enabled\n+Target Report Mask(SIGN_EXTEND_ENABLED)\n+Enable sign extend instructions\n+\n+muser-enabled\n+Target Report Mask(USER_ENABLED)\n+Enable user-defined instructions"}, {"sha": "7137c01142897cdd9c3d4d811283007eabff9015", "filename": "gcc/config/lm32/predicates.md", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Fpredicates.md?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,77 @@\n+;; Predicate definitions for Lattice Mico32 architecture.\n+;; Contributed by Jon Beniston <jon@beniston.com>\n+;;\n+;; Copyright (C) 2009 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;; \n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;;  <http://www.gnu.org/licenses/>.  \n+\n+(define_predicate \"const0_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"constant_K_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_K (op)\")))\n+       \n+(define_predicate \"constant_L_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_L (op)\")))\n+\n+(define_predicate \"constant_M_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_M (op)\")))\n+\n+(define_predicate \"register_or_zero_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const0_operand\")))\n+\n+(define_predicate \"register_or_K_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"constant_K_operand\")))\n+         \n+(define_predicate \"register_or_L_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"constant_L_operand\")))\n+\n+(define_predicate \"register_or_int_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_code \"const_int\")))\n+\n+(define_predicate \"reloc_operand\"\n+  (ior (ior (match_code \"label_ref\")\n+            (match_code \"symbol_ref\"))\n+       (match_code \"const\")))\n+\n+(define_predicate \"symbolic_operand\"\n+  (ior (match_code \"label_ref\")\n+       (match_code \"symbol_ref\")))\n+       \n+(define_predicate \"no_pic_small_symbol\"\n+  (match_code \"symbol_ref\")\n+{\n+  return !flag_pic && SYMBOL_REF_SMALL_P (op);\n+})\n+\n+(define_predicate \"call_operand\"\n+  (ior (match_code \"symbol_ref\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"movsi_rhs_operand\"\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (ior (match_code \"const_int\")\n+            (ior (match_test \"satisfies_constraint_S (op)\")\n+                 (match_test \"satisfies_constraint_Y (op)\")))))"}, {"sha": "19038485493cbf7532b82609147e7d4695587a5d", "filename": "gcc/config/lm32/sfp-machine.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Fsfp-machine.h?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,51 @@\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n+#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_NANSIGN_Q\t\t0\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+/* Someone please check this.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#define __BYTE_ORDER __BIG_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));"}, {"sha": "f99f51cfdc035a18c049c086d5f35c2fb14c2e54", "filename": "gcc/config/lm32/t-fprules-softfp", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Ft-fprules-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Ft-fprules-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Ft-fprules-softfp?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,5 @@\n+softfp_float_modes := sf df\n+softfp_int_modes := si di\n+softfp_extensions := sfdf\n+softfp_truncations := dfsf\n+softfp_machine_header := lm32/sfp-machine.h"}, {"sha": "ce9719a3be619f29c0b4b1796c08b85d3e8d3d87", "filename": "gcc/config/lm32/uclinux-elf.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fuclinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fconfig%2Flm32%2Fuclinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Fuclinux-elf.h?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,85 @@\n+/* Definitions for LM32 running Linux-based GNU systems using ELF\n+   Copyright (C) 1993, 1994, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   2009 Free Software Foundation, Inc.\n+   Contributed by Philip Blundell <philb@gnu.org>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* elfos.h should have already been included.  Now just override\n+   any conflicting definitions and add any extras.  */\n+\n+/* Run-time Target Specification.  */\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION  fputs (\" (LM32 GNU/Linux with ELF)\", stderr);\n+\n+/* Do not assume anything about header files.  */\n+#undef NO_IMPLICIT_EXTERN_C\n+#define NO_IMPLICIT_EXTERN_C\n+\n+/* The GNU C++ standard library requires that these macros be defined.  */\n+#undef CPLUSPLUS_CPP_SPEC\n+#define CPLUSPLUS_CPP_SPEC \"-D_GNU_SOURCE %(cpp)\"\n+\n+/* Now we define the strings used to build the spec file.  */\n+#undef  LIB_SPEC\n+#define LIB_SPEC \\\n+  \"%{pthread:-lpthread} \\\n+   %{shared:-lc} \\\n+   %{!shared:-lc} \"\n+\n+#define LIBGCC_SPEC \"-lgcc\"\n+\n+/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add\n+   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which\n+   provides part of the support for getting C++ file-scope static\n+   object constructed before entering `main'.  */\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shared: \\\n+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \\\n+                       %{!p:%{profile:gcrt1.o%s} \\\n+                         %{!profile:crt1.o%s}}}} \\\n+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}\"\n+\n+/* Provide a ENDFILE_SPEC appropriate for GNU/Linux.  Here we tack on\n+   the GNU/Linux magical crtend.o file (see crtstuff.c) which\n+   provides part of the support for getting C++ file-scope static\n+   object constructed before entering `main', followed by a normal\n+   GNU/Linux \"finalizer\" file, `crtn.o'.  */\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+  \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s\"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC \"%{h*} %{version:-v} \\\n+   %{b} %{Wl,*:%*} \\\n+   %{static:-Bstatic} \\\n+   %{shared:-shared} \\\n+   %{symbolic:-Bsymbolic} \\\n+   %{rdynamic:-export-dynamic} \\\n+   %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}\"\n+\n+#define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()\n+\n+#define LINK_GCC_C_SEQUENCE_SPEC \\\n+  \"%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}\"\n+\n+#undef  CC1_SPEC\n+#define CC1_SPEC \"%{G*} %{!fno-PIC:-fPIC}\"\n+"}, {"sha": "6ee5b5001d77042be2f456119e5b35786d8fd392", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -55,7 +55,7 @@ Scott Bambrough for help porting the Java compiler.\n Wolfgang Bangerth for processing tons of bug reports.\n \n @item\n-Jon Beniston for his Microsoft Windows port of Java.\n+Jon Beniston for his Microsoft Windows port of Java and port to Lattice Mico32.\n \n @item\n Daniel Berlin for better DWARF2 support, faster/better optimizations,"}, {"sha": "98da008855f16f60345527ec0fe63e7aee86b32e", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -2888,6 +2888,10 @@ information are.\n @item\n @uref{#iq2000-x-elf,,iq2000-*-elf}\n @item\n+@uref{#lm32-x-elf,,lm32-*-elf}\n+@item\n+@uref{#lm32-x-uclinux,,lm32-*-uclinux}\n+@item\n @uref{#m32c-x-elf,,m32c-*-elf}\n @item\n @uref{#m32r-x-elf,,m32r-*-elf}\n@@ -3663,6 +3667,20 @@ switch and using the configure option @option{--with-cpu-@var{cpu_type}}.\n Vitesse IQ2000 processors.  These are used in embedded\n applications.  There are no standard Unix configurations.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{lm32-x-elf}lm32-*-elf\n+Lattice Mico32 processor.\n+This configuration is intended for embedded systems.\n+\n+@html\n+<hr />\n+@end html\n+@heading @anchor{lm32-x-uclinux}lm32-*-uclinux\n+Lattice Mico32 processor.\n+This configuration is intended for embedded systems running uClinux.\n+\n @html\n <hr />\n @end html"}, {"sha": "9d79d3307c5f1b5b0e2e8796fb42e6e8a91cc32b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -631,6 +631,10 @@ Objective-C and Objective-C++ Dialects}.\n @emph{IA-64/VMS Options}\n @gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mmalloc64}\n \n+@emph{LM32 Options}\n+@gccoptlist{-mbarrel-shift-enabled -mdivide-enabled -mmultiply-enabled @gol\n+-msign-extend-enabled -muser-enabled}\n+\n @emph{M32R/D Options}\n @gccoptlist{-m32r2 -m32rx -m32r @gol\n -mdebug @gol\n@@ -9534,6 +9538,7 @@ platform.\n * i386 and x86-64 Windows Options::\n * IA-64 Options::\n * IA-64/VMS Options::\n+* LM32 Options::\n * M32C Options::\n * M32R/D Options::\n * M680x0 Options::\n@@ -12565,6 +12570,35 @@ routine for the debugger.\n Default to 64bit memory allocation routines.\n @end table\n \n+@node LM32 Options\n+@subsection LM32 Options\n+@cindex LM32 options\n+\n+These @option{-m} options are defined for the Lattice Mico32 architecture:\n+\n+@table @gcctabopt\n+@item -mbarrel-shift-enabled\n+@opindex mbarrel-shift-enabled\n+Enable barrel-shift instructions.\n+\n+@item -mdivide-enabled\n+@opindex mdivide-enabled\n+Enable divide and modulus instructions.\n+\n+@item -mmultiply-enabled\n+@opindex multiply-enabled\n+Enable multiply instructions.\n+\n+@item -msign-extend-enabled\n+@opindex msign-extend-enabled\n+Enable sign extend instructions.\n+\n+@item -muser-enabled\n+@opindex muser-enabled\n+Enable user-defined instructions.\n+\n+@end table\n+\n @node M32C Options\n @subsection M32C Options\n @cindex M32C options"}, {"sha": "2eec61213ff79516b9e88c56c9ffa36c83b59c4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -1,3 +1,12 @@\n+gcc/testsuite/\n+2009-11-11  Jon Beniston <jon@beniston.com>\n+\n+        * lib/target-supports.exp (check_profiling_available): lm32 target \n+          doesn't support profiling.\n+        * gcc.dg/20020312-2.c: Add lm32 support.\n+        * g++.dg/other/packed1.C: Expect to fail on lm32.        \n+        * g++.old-deja/g++.jason/thunk3.C: Likewise.                 \n+\n 2009-11-11  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* gcc.target/arm/neon: Regenerate generated tests."}, {"sha": "91d0ed3a7245bb9c0b1fcabc8288678bddc78f91", "filename": "gcc/testsuite/g++.dg/other/packed1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpacked1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpacked1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpacked1.C?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { xfail arm-*-* sh-*-* } }\n+// { dg-do run { xfail arm-*-* sh-*-* lm32-*-* } }\n \n // NMS:2003-04-21 this fails on strict aligned architectures again,\n // the patch was reverted because it broke something more important."}, {"sha": "f382852482c077676173c0b03e98be358b6be40f", "filename": "gcc/testsuite/g++.old-deja/g++.jason/thunk3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk3.C?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { xfail rs6000-*-* powerpc-*-eabi mn10300-*-* v850-*-* sh-*-* sh64-*-* h8*-*-* xtensa*-*-* m32r*-*-* } }\n+// { dg-do run { xfail rs6000-*-* powerpc-*-eabi mn10300-*-* v850-*-* sh-*-* sh64-*-* h8*-*-* xtensa*-*-* m32r*-*-* lm32-*-* } }\n // Test that variadic function calls using thunks work right.\n // Note that this will break on any target that uses the generic thunk\n //  support, because it doesn't support variadic functions."}, {"sha": "057c19e1a9988d9789a413dd8864f6a48c4559da", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -30,6 +30,8 @@ extern void abort (void);\n # define PIC_REG  \"ebx\"\n #elif defined(__ia64__)\n /* PIC register is r1, but is used even without -fpic.  */\n+#elif defined(__lm32__)\n+/* No pic register.  */\n #elif defined(__M32R__)\n /* No pic register.  */\n #elif defined(__m68k__)"}, {"sha": "4b8d6f312ffc7e2868c430d23ab599a8f1f72a0d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -496,7 +496,8 @@ proc check_profiling_available { test_what } {\n \t     || [istarget crisv32-*-*]\n \t     || [istarget fido-*-elf]\n \t     || [istarget h8300-*-*]\n-\t     || [istarget m32c-*-elf]\n+             || [istarget lm32-*-*]\n+             || [istarget m32c-*-elf]\n \t     || [istarget m68k-*-elf]\n \t     || [istarget m68k-*-uclinux*]\n \t     || [istarget mep-*-elf]"}, {"sha": "54c7fe533029e3abe740687e7575c6f18c615c55", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -1,3 +1,24 @@\n+libgcc/\n+2009-11-11  Jon Beniston <jon@beniston.com>\n+\n+        * config.host: Add lm32 targets.\n+        * config/lm32: New directory.\n+        * config/lm32/libgcc_lm32.h: New file.\n+        * config/lm32/_mulsi3.c: New file.\n+        * config/lm32/_udivmodsi4.c: New file.\n+        * config/lm32/_divsi3.c: New file.\n+        * config/lm32/_modsi3.c: New file.\n+        * config/lm32/_udivsi3.c: New file.\n+        * config/lm32/_umodsi3.c: New file.\n+        * config/lm32/_lshrsi3.S: New file.\n+        * config/lm32/_ashrsi3.S: New file.\n+        * config/lm32/_ashlsi3.S: New file.\n+        * config/lm32/crti.S: New file.\n+        * config/lm32/crtn.S: New file.\n+        * config/lm32/t-lm32: New file.\n+        * config/lm32/t-elf: New file.\n+        * config/lm32/t-uclinux: New file.\n+\n 2009-10-26  Nick Clifton  <nickc@redhat.com>\n \n \t* config.host: Add support for RX target."}, {"sha": "1a66beb4736584c8806f47dc822057e6f641105e", "filename": "libgcc/config.host", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -97,6 +97,9 @@ ia64-*-*)\n hppa*-*-*)\n \tcpu_type=pa\n \t;;\n+lm32*-*-*)\n+\tcpu_type=lm32\n+\t;;\n m32r*-*-*)\n         cpu_type=m32r\n         ;;\n@@ -354,6 +357,14 @@ ia64-hp-*vms*)\n \t;;\n iq2000*-*-elf*)\n         ;;\n+lm32-*-elf*)\n+        extra_parts=\"crtbegin.o crtend.o crti.o crtn.o\"\n+        tmake_file=\"lm32/t-lm32 lm32/t-elf t-softfp\"\n+\t;;\n+lm32-*-uclinux*)\n+        extra_parts=\"crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o\"\n+        tmake_file=\"lm32/t-lm32 lm32/t-uclinux t-softfp\"\n+\t;;\t\n m32r-*-elf*|m32r-*-rtems*)\n  \t;;\n m32rle-*-elf*)"}, {"sha": "1f8f48d93483de68c4b5c6b5bfb084e25a50f867", "filename": "libgcc/config/lm32/_ashlsi3.S", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_ashlsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_ashlsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_ashlsi3.S?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,114 @@\n+# _ashlsi3.S for Lattice Mico32 \n+# Contributed by Jon Beniston <jon@beniston.com> and Richard Henderson.\n+#\n+# Copyright (C) 2009 Free Software Foundation, Inc. \n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+# \n+\n+/* Arithmetic left shift.  */\n+        \n+        .text\n+\n+        .global __ashlsi3\n+        .type __ashlsi3,@function\n+\n+        .align 4        \n+__ashlsi3:\n+        /* Only use 5 LSBs, as that's all the h/w shifter uses.  */\n+        andi    r2, r2, 0x1f\n+        /* Get address of offset into unrolled shift loop to jump to.  */\n+#ifdef __PIC__\n+        lw      r3, (gp+got(__ashlsi3_0))\n+#else\n+        mvhi    r3, hi(__ashlsi3_0)\n+        ori     r3, r3, lo(__ashlsi3_0)\n+#endif\n+        add     r2, r2, r2\n+        add     r2, r2, r2\n+        sub     r3, r3, r2\n+        b       r3        \n+        \n+__ashlsi3_31:\n+        add     r1, r1, r1\n+__ashlsi3_30:\n+        add     r1, r1, r1\n+__ashlsi3_29:\n+        add     r1, r1, r1\n+__ashlsi3_28:\n+        add     r1, r1, r1\n+__ashlsi3_27:\n+        add     r1, r1, r1\n+__ashlsi3_26:\n+        add     r1, r1, r1\n+__ashlsi3_25:\n+        add     r1, r1, r1\n+__ashlsi3_24:\n+        add     r1, r1, r1\n+__ashlsi3_23:\n+        add     r1, r1, r1\n+__ashlsi3_22:\n+        add     r1, r1, r1\n+__ashlsi3_21:\n+        add     r1, r1, r1\n+__ashlsi3_20:\n+        add     r1, r1, r1\n+__ashlsi3_19:\n+        add     r1, r1, r1\n+__ashlsi3_18:\n+        add     r1, r1, r1\n+__ashlsi3_17:\n+        add     r1, r1, r1\n+__ashlsi3_16:\n+        add     r1, r1, r1\n+__ashlsi3_15:\n+        add     r1, r1, r1\n+__ashlsi3_14:\n+        add     r1, r1, r1\n+__ashlsi3_13:\n+        add     r1, r1, r1\n+__ashlsi3_12:\n+        add     r1, r1, r1\n+__ashlsi3_11:\n+        add     r1, r1, r1\n+__ashlsi3_10:\n+        add     r1, r1, r1\n+__ashlsi3_9:\n+        add     r1, r1, r1\n+__ashlsi3_8:\n+        add     r1, r1, r1\n+__ashlsi3_7:\n+        add     r1, r1, r1\n+__ashlsi3_6:\n+        add     r1, r1, r1\n+__ashlsi3_5:\n+        add     r1, r1, r1\n+__ashlsi3_4:\n+        add     r1, r1, r1\n+__ashlsi3_3:\n+        add     r1, r1, r1\n+__ashlsi3_2:\n+        add     r1, r1, r1\n+__ashlsi3_1:\n+        add     r1, r1, r1\n+__ashlsi3_0:\n+        ret\n+                \n+        \n\\ No newline at end of file"}, {"sha": "393cbeb54cd159091818fb106c9fcc36a719bff8", "filename": "libgcc/config/lm32/_ashrsi3.S", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_ashrsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_ashrsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_ashrsi3.S?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,110 @@\n+# _ashrsi3.S for Lattice Mico32 \n+# Contributed by Jon Beniston <jon@beniston.com> and Richard Henderson.\n+#\n+# Copyright (C) 2009 Free Software Foundation, Inc. \n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+# \n+\n+/* Arithmetic right shift.  */\n+\n+        .global __ashrsi3\n+        .type __ashrsi3,@function\n+                                                  \n+__ashrsi3:\n+        /* Only use 5 LSBs, as that's all the h/w shifter uses.  */\n+        andi    r2, r2, 0x1f\n+        /* Get address of offset into unrolled shift loop to jump to.  */\n+#ifdef __PIC__\n+        lw      r3, (gp+got(__ashrsi3_0))\n+#else\n+        mvhi    r3, hi(__ashrsi3_0)\n+        ori     r3, r3, lo(__ashrsi3_0)\n+#endif\n+        add     r2, r2, r2\n+        add     r2, r2, r2\n+        sub     r3, r3, r2\n+        b       r3        \n+        \n+__ashrsi3_31:\n+        sri     r1, r1, 1\n+__ashrsi3_30:\n+        sri     r1, r1, 1\n+__ashrsi3_29:\n+        sri     r1, r1, 1\n+__ashrsi3_28:\n+        sri     r1, r1, 1\n+__ashrsi3_27:\n+        sri     r1, r1, 1\n+__ashrsi3_26:\n+        sri     r1, r1, 1\n+__ashrsi3_25:\n+        sri     r1, r1, 1\n+__ashrsi3_24:\n+        sri     r1, r1, 1\n+__ashrsi3_23:\n+        sri     r1, r1, 1\n+__ashrsi3_22:\n+        sri     r1, r1, 1\n+__ashrsi3_21:\n+        sri     r1, r1, 1\n+__ashrsi3_20:\n+        sri     r1, r1, 1\n+__ashrsi3_19:\n+        sri     r1, r1, 1\n+__ashrsi3_18:\n+        sri     r1, r1, 1\n+__ashrsi3_17:\n+        sri     r1, r1, 1\n+__ashrsi3_16:\n+        sri     r1, r1, 1\n+__ashrsi3_15:\n+        sri     r1, r1, 1\n+__ashrsi3_14:\n+        sri     r1, r1, 1\n+__ashrsi3_13:\n+        sri     r1, r1, 1\n+__ashrsi3_12:\n+        sri     r1, r1, 1\n+__ashrsi3_11:\n+        sri     r1, r1, 1\n+__ashrsi3_10:\n+        sri     r1, r1, 1\n+__ashrsi3_9:\n+        sri     r1, r1, 1\n+__ashrsi3_8:\n+        sri     r1, r1, 1\n+__ashrsi3_7:\n+        sri     r1, r1, 1\n+__ashrsi3_6:\n+        sri     r1, r1, 1\n+__ashrsi3_5:\n+        sri     r1, r1, 1\n+__ashrsi3_4:\n+        sri     r1, r1, 1\n+__ashrsi3_3:\n+        sri     r1, r1, 1\n+__ashrsi3_2:\n+        sri     r1, r1, 1\n+__ashrsi3_1:\n+        sri     r1, r1, 1\n+__ashrsi3_0:\n+        ret\n+        \n\\ No newline at end of file"}, {"sha": "1a5dda0932590e47c51fe8d776044b8d28df6912", "filename": "libgcc/config/lm32/_divsi3.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_divsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_divsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_divsi3.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,99 @@\n+/* _divsi3 for Lattice Mico32.\n+   Contributed by Jon Beniston <jon@beniston.com> \n+   \n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+   \n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+   \n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"libgcc_lm32.h\"\n+\n+/* Signed integer division.  */\n+\n+static const UQItype __divsi3_table[] = {\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 4, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 5, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 6, 3, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 7, 3, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 8, 4, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n+  0, 9, 4, 3, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n+  0, 10, 5, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,\n+  0, 11, 5, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n+  0, 12, 6, 4, 3, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0,\n+  0, 13, 6, 4, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n+  0, 14, 7, 4, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0,\n+  0, 15, 7, 5, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1,\n+};\n+\n+SItype\n+__divsi3 (SItype a, SItype b)\n+{\n+  int neg = 0;\n+  SItype res;\n+  int cfg;\n+\n+  if (b == 0)\n+    {\n+      /* Raise divide by zero exception.  */\n+      int eba, sr;\n+      /* Save interrupt enable.  */\n+      __asm__ __volatile__ (\"rcsr %0, IE\":\"=r\" (sr));\n+      sr = (sr & 1) << 1;\n+      __asm__ __volatile__ (\"wcsr IE, %0\"::\"r\" (sr));\n+      /* Branch to exception handler.  */\n+      __asm__ __volatile__ (\"rcsr %0, EBA\":\"=r\" (eba));\n+      eba += 32 * 5;\n+      __asm__ __volatile__ (\"mv ea, ra\");\n+      __asm__ __volatile__ (\"b %0\"::\"r\" (eba));\n+      __builtin_unreachable ();\n+    }\n+\n+  if (((USItype) (a | b)) < 16)\n+    res = __divsi3_table[(a << 4) + b];\n+  else\n+    {\n+\n+      if (a < 0)\n+\t{\n+\t  a = -a;\n+\t  neg = !neg;\n+\t}\n+\n+      if (b < 0)\n+\t{\n+\t  b = -b;\n+\t  neg = !neg;\n+\t}\n+\n+    __asm__ (\"rcsr %0, CFG\":\"=r\" (cfg));\n+      if (cfg & 2)\n+      __asm__ (\"divu %0, %1, %2\": \"=r\" (res):\"r\" (a), \"r\" (b));\n+      else\n+\tres = __udivmodsi4 (a, b, 0);\n+\n+      if (neg)\n+\tres = -res;\n+    }\n+\n+  return res;\n+}"}, {"sha": "706fd003a4932f46b6b0381787ba3a60d98a3aff", "filename": "libgcc/config/lm32/_lshrsi3.S", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_lshrsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_lshrsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_lshrsi3.S?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,109 @@\n+# _lshrsi3.S for Lattice Mico32 \n+# Contributed by Jon Beniston <jon@beniston.com> and Richard Henderson.\n+#\n+# Copyright (C) 2009 Free Software Foundation, Inc. \n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+# \n+\n+/* Logical right shift.  */\n+        \n+        .global __lshrsi3\n+        .type __lshrsi3,@function\n+\n+__lshrsi3:\n+        /* Only use 5 LSBs, as that's all the h/w shifter uses.  */\n+        andi    r2, r2, 0x1f\n+        /* Get address of offset into unrolled shift loop to jump to.  */\n+#ifdef __PIC__\n+        lw      r3, (gp+got(__lshrsi3_0))\n+#else\n+        mvhi    r3, hi(__lshrsi3_0)\n+        ori     r3, r3, lo(__lshrsi3_0)\n+#endif\n+        add     r2, r2, r2\n+        add     r2, r2, r2\n+        sub     r3, r3, r2\n+        b       r3        \n+        \n+__lshrsi3_31:        \n+        srui    r1, r1, 1\n+__lshrsi3_30:        \n+        srui    r1, r1, 1\n+__lshrsi3_29:        \n+        srui    r1, r1, 1\n+__lshrsi3_28:        \n+        srui    r1, r1, 1\n+__lshrsi3_27:        \n+        srui    r1, r1, 1\n+__lshrsi3_26:        \n+        srui    r1, r1, 1\n+__lshrsi3_25:        \n+        srui    r1, r1, 1\n+__lshrsi3_24:        \n+        srui    r1, r1, 1\n+__lshrsi3_23:        \n+        srui    r1, r1, 1\n+__lshrsi3_22:        \n+        srui    r1, r1, 1\n+__lshrsi3_21:        \n+        srui    r1, r1, 1\n+__lshrsi3_20:        \n+        srui    r1, r1, 1\n+__lshrsi3_19:        \n+        srui    r1, r1, 1\n+__lshrsi3_18:        \n+        srui    r1, r1, 1\n+__lshrsi3_17:        \n+        srui    r1, r1, 1\n+__lshrsi3_16:        \n+        srui    r1, r1, 1\n+__lshrsi3_15:        \n+        srui    r1, r1, 1\n+__lshrsi3_14:        \n+        srui    r1, r1, 1\n+__lshrsi3_13:        \n+        srui    r1, r1, 1\n+__lshrsi3_12:        \n+        srui    r1, r1, 1\n+__lshrsi3_11:        \n+        srui    r1, r1, 1\n+__lshrsi3_10:        \n+        srui    r1, r1, 1\n+__lshrsi3_9:        \n+        srui    r1, r1, 1\n+__lshrsi3_8:        \n+        srui    r1, r1, 1\n+__lshrsi3_7:        \n+        srui    r1, r1, 1\n+__lshrsi3_6:        \n+        srui    r1, r1, 1\n+__lshrsi3_5:        \n+        srui    r1, r1, 1\n+__lshrsi3_4:        \n+        srui    r1, r1, 1\n+__lshrsi3_3:        \n+        srui    r1, r1, 1\n+__lshrsi3_2:        \n+        srui    r1, r1, 1\n+__lshrsi3_1:        \n+        srui    r1, r1, 1\n+__lshrsi3_0:        \n+        ret"}, {"sha": "a4a3d320a8fa022d2e43b19535f7ee863ba54dee", "filename": "libgcc/config/lm32/_modsi3.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_modsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_modsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_modsi3.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,71 @@\n+/* _modsi3 for Lattice Mico32.\n+   Contributed by Jon Beniston <jon@beniston.com> \n+   \n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+   \n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+   \n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"libgcc_lm32.h\"\n+\n+/* Signed integer modulus.  */\n+\n+SItype\n+__modsi3 (SItype a, SItype b)\n+{\n+  int neg = 0;\n+  SItype res;\n+  int cfg;\n+\n+  if (b == 0)\n+    {\n+      /* Raise divide by zero exception.  */\n+      int eba, sr;\n+      /* Save interrupt enable.  */\n+      __asm__ __volatile__ (\"rcsr %0, IE\":\"=r\" (sr));\n+      sr = (sr & 1) << 1;\n+      __asm__ __volatile__ (\"wcsr IE, %0\"::\"r\" (sr));\n+      /* Branch to exception handler.  */\n+      __asm__ __volatile__ (\"rcsr %0, EBA\":\"=r\" (eba));\n+      eba += 32 * 5;\n+      __asm__ __volatile__ (\"mv ea, ra\");\n+      __asm__ __volatile__ (\"b %0\"::\"r\" (eba));\n+      __builtin_unreachable ();\n+    }\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+__asm__ (\"rcsr %0, CFG\":\"=r\" (cfg));\n+  if (cfg & 2)\n+  __asm__ (\"modu %0, %1, %2\": \"=r\" (res):\"r\" (a), \"r\" (b));\n+  else\n+    res = __udivmodsi4 (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}"}, {"sha": "5b2646b4551a295f687bbb4249862350fe286ff2", "filename": "libgcc/config/lm32/_mulsi3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_mulsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_mulsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_mulsi3.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,48 @@\n+/* _mulsi3 for Lattice Mico32.\n+   Contributed by Jon Beniston <jon@beniston.com> \n+   \n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+   \n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+   \n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"libgcc_lm32.h\"\n+\n+/* Integer multiplication.  */\n+\n+USItype\n+__mulsi3 (USItype a, USItype b)\n+{\n+  USItype result;\n+\n+  result = 0;\n+\n+  if (a == 0)\n+    return 0;\n+\n+  while (b != 0)\n+    {\n+      if (b & 1)\n+\tresult += a;\n+      a <<= 1;\n+      b >>= 1;\n+    }\n+\n+  return result;\n+}"}, {"sha": "1d067630e22d89fff75c06ae78d32337218d6f6b", "filename": "libgcc/config/lm32/_udivmodsi4.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_udivmodsi4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_udivmodsi4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_udivmodsi4.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,53 @@\n+/* _udivmodsi4 for Lattice Mico32.\n+   Contributed by Jon Beniston <jon@beniston.com> \n+   \n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+   \n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+   \n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"libgcc_lm32.h\"\n+\n+/* Unsigned integer division/modulus.  */\n+\n+USItype\n+__udivmodsi4 (USItype num, USItype den, int modwanted)\n+{\n+  USItype bit = 1;\n+  USItype res = 0;\n+\n+  while (den < num && bit && !(den & (1L << 31)))\n+    {\n+      den <<= 1;\n+      bit <<= 1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>= 1;\n+      den >>= 1;\n+    }\n+  if (modwanted)\n+    return num;\n+  return res;\n+}"}, {"sha": "284fef6cc1959475fc3c2e70d557de66cd21fa61", "filename": "libgcc/config/lm32/_udivsi3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_udivsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_udivsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_udivsi3.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,49 @@\n+/* _udivsi3 for Lattice Mico32.\n+   Contributed by Jon Beniston <jon@beniston.com> \n+   \n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+   \n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+   \n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"libgcc_lm32.h\"\n+\n+/* Unsigned integer division.  */\n+\n+USItype\n+__udivsi3 (USItype a, USItype b)\n+{\n+  if (b == 0)\n+    {\n+      /* Raise divide by zero exception.  */\n+      int eba, sr;\n+      /* Save interrupt enable.  */\n+      __asm__ __volatile__ (\"rcsr %0, IE\":\"=r\" (sr));\n+      sr = (sr & 1) << 1;\n+      __asm__ __volatile__ (\"wcsr IE, %0\"::\"r\" (sr));\n+      /* Branch to exception handler.  */\n+      __asm__ __volatile__ (\"rcsr %0, EBA\":\"=r\" (eba));\n+      eba += 32 * 5;\n+      __asm__ __volatile__ (\"mv ea, ra\");\n+      __asm__ __volatile__ (\"b %0\"::\"r\" (eba));\n+      __builtin_unreachable ();\n+    }\n+\n+  return __udivmodsi4 (a, b, 0);\n+}"}, {"sha": "d4af217e6f1ecba6a056ce2867f334114ef499ed", "filename": "libgcc/config/lm32/_umodsi3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_umodsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2F_umodsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2F_umodsi3.c?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,49 @@\n+/* _umodsi3 for Lattice Mico32.\n+   Contributed by Jon Beniston <jon@beniston.com> \n+   \n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+   \n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+   \n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"libgcc_lm32.h\"\n+\n+/* Unsigned modulus.  */\n+\n+USItype\n+__umodsi3 (USItype a, USItype b)\n+{\n+  if (b == 0)\n+    {\n+      /* Raise divide by zero exception.  */\n+      int eba, sr;\n+      /* Save interrupt enable.  */\n+      __asm__ __volatile__ (\"rcsr %0, IE\":\"=r\" (sr));\n+      sr = (sr & 1) << 1;\n+      __asm__ __volatile__ (\"wcsr IE, %0\"::\"r\" (sr));\n+      /* Branch to exception handler.  */\n+      __asm__ __volatile__ (\"rcsr %0, EBA\":\"=r\" (eba));\n+      eba += 32 * 5;\n+      __asm__ __volatile__ (\"mv ea, ra\");\n+      __asm__ __volatile__ (\"b %0\"::\"r\" (eba));\n+      __builtin_unreachable ();\n+    }\n+\n+  return __udivmodsi4 (a, b, 1);\n+}"}, {"sha": "6e6455b9f98b9d44e8fb6724d1aa4b7ab0071c1c", "filename": "libgcc/config/lm32/crti.S", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Fcrti.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Fcrti.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2Fcrti.S?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,40 @@\n+# crti.S for Lattice Mico32 \n+# Contributed by Jon Beniston <jon@beniston.com>\n+#\n+# Copyright (C) 2009 Free Software Foundation, Inc. \n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+#\n+\n+        .section .init\n+        .global _init\n+        .type _init,@function\n+        .align 4\n+_init:\n+        addi    sp, sp, -4        \n+        sw      (sp+4), ra\n+\n+        .section .fini\n+        .global _fini\n+        .type _fini,@function\n+        .align 4\n+_fini:        \n+        addi    sp, sp, -4        \n+        sw      (sp+4), ra"}, {"sha": "aa6321565df07cfb8f6bc1db044fd5135f254f96", "filename": "libgcc/config/lm32/crtn.S", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2Fcrtn.S?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,37 @@\n+# crtn.S for Lattice Mico32\n+# Contributed by Jon Beniston <jon@beniston.com>\n+#\n+# Copyright (C) 2009 Free Software Foundation, Inc. \n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+# \n+\n+        .section .init\n+        \n+        lw      ra, (sp+4)\n+        addi    sp, sp, 4\n+        ret\n+                \n+        .section .fini\n+        \n+        lw      ra, (sp+4)\n+        addi    sp, sp, 4\n+        ret\n+        "}, {"sha": "4a9a6e675f160345795f71401a64ab105b882d00", "filename": "libgcc/config/lm32/libgcc_lm32.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Flibgcc_lm32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Flibgcc_lm32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2Flibgcc_lm32.h?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,43 @@\n+/* Integer arithmetic support for Lattice Mico32.\n+   Contributed by Jon Beniston <jon@beniston.com> \n+   \n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+   \n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+   \n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#ifndef LIBGCC_LM32_H\n+#define LIBGCC_LM32_H \n+\n+/* Types.  */\n+\n+typedef unsigned char UQItype __attribute__ ((mode (QI)));\n+typedef long SItype __attribute__ ((mode (SI)));\n+typedef unsigned long USItype __attribute__ ((mode (SI)));\n+\n+/* Prototypes.  */\n+\n+USItype __mulsi3 (USItype a, USItype b);\n+USItype __udivmodsi4 (USItype num, USItype den, int modwanted);\n+SItype __divsi3 (SItype a, SItype b);\n+SItype __modsi3 (SItype a, SItype b);\n+USItype __udivsi3 (USItype a, USItype b);\n+USItype __umodsi3 (USItype a, USItype b);\n+\n+#endif /* LIBGCC_LM32_H */"}, {"sha": "679f00711e7c2ce828d88afd2f22739f5a6ea952", "filename": "libgcc/config/lm32/t-elf", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Ft-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Ft-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2Ft-elf?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,12 @@\n+# Assemble startup files.\n+\n+$(T)crti.o: $(srcdir)/config/lm32/crti.S $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/lm32/crti.S\n+\n+$(T)crtn.o: $(srcdir)/config/lm32/crtn.S $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/lm32/crtn.S\n+\n+CRTSTUFF_T_CFLAGS = -G 0 -msign-extend-enabled\n+HOST_LIBGCC2_CFLAGS = -G 0 -msign-extend-enabled"}, {"sha": "ec760418290b4235cf6981076864ea6d671d1b74", "filename": "libgcc/config/lm32/t-lm32", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Ft-lm32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Ft-lm32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2Ft-lm32?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,12 @@\n+LIB2ADD += \\\n+        $(srcdir)/config/lm32/_ashlsi3.S \\\n+        $(srcdir)/config/lm32/_ashrsi3.S \\\n+        $(srcdir)/config/lm32/_lshrsi3.S \\\n+        $(srcdir)/config/lm32/_mulsi3.c \\\n+        $(srcdir)/config/lm32/_udivmodsi4.c \\\n+        $(srcdir)/config/lm32/_divsi3.c \\\n+        $(srcdir)/config/lm32/_modsi3.c \\\n+        $(srcdir)/config/lm32/_udivsi3.c \\\n+        $(srcdir)/config/lm32/_umodsi3.c\n+\n+MULTILIB_OPTIONS = mmultiply-enabled mbarrel-shift-enabled "}, {"sha": "d388f56c3a276dbaf7b84605b394ff5b0ce4aa82", "filename": "libgcc/config/lm32/t-uclinux", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Ft-uclinux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4945c138ce494613b711ede795a489bceaf62f/libgcc%2Fconfig%2Flm32%2Ft-uclinux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flm32%2Ft-uclinux?ref=aa4945c138ce494613b711ede795a489bceaf62f", "patch": "@@ -0,0 +1,2 @@\n+CRTSTUFF_T_CFLAGS = -fPIC -msign-extend-enabled\n+HOST_LIBGCC2_CFLAGS = -fPIC -msign-extend-enabled"}]}