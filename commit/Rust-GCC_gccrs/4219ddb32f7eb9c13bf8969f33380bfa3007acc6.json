{"sha": "4219ddb32f7eb9c13bf8969f33380bfa3007acc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIxOWRkYjMyZjdlYjljMTNiZjg5NjlmMzMzODBiZmEzMDA3YWNjNg==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2015-11-19T16:22:13Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2015-11-19T16:22:13Z"}, "message": "libgomp-plugin-intelmic.cpp (struct TargetImageDesc): New.\n\nliboffloadmic/\n\t* plugin/libgomp-plugin-intelmic.cpp (struct TargetImageDesc): New.\n\t(ImgDescMap): New typedef.\n\t(image_descriptors): New static var.\n\t(init): Allocate image_descriptors.\n\t(offload): Remove vars2 argument.  Pass NULL to __offload_offload1\n\tinstead of vars2.\n\t(unregister_main_image): New static function.\n\t(register_main_image): Call unregister_main_image at exit.\n\t(GOMP_OFFLOAD_init_device): Print device number, fix offload args.\n\t(GOMP_OFFLOAD_fini_device): Likewise.\n\t(get_target_table): Remove vd1g and vd2g, don't pass them to offload.\n\t(offload_image): Remove declaration of the struct TargetImage.\n\tFree table.  Insert new descriptor into image_descriptors.\n\t(GOMP_OFFLOAD_unload_image): Call __offload_unregister_image, free\n\tthe corresponding descriptor, and remove it from address_table and\n\timage_descriptors.\n\t(GOMP_OFFLOAD_alloc): Print device number, remove vd1g.\n\t(GOMP_OFFLOAD_free): Likewise.\n\t(GOMP_OFFLOAD_host2dev): Print device number, remove vd1g and vd2g.\n\t(GOMP_OFFLOAD_dev2host): Likewise.\n\t(GOMP_OFFLOAD_run): Print device number, remove vd1g.\n\t* plugin/offload_target_main.cpp (__offload_target_table_p1): Remove\n\tvd2, don't pass it to __offload_target_enter.\n\t(__offload_target_table_p2): Likewise.\n\t(__offload_target_alloc): Likewise.\n\t(__offload_target_free): Likewise.\n\t(__offload_target_host2tgt_p1): Likewise.\n\t(__offload_target_host2tgt_p2): Likewise.\n\t(__offload_target_tgt2host_p1): Likewise.\n\t(__offload_target_tgt2host_p2): Likewise.\n\t(__offload_target_run): Likewise.\n\t(__offload_target_tgt2tgt): Remove vd1g, don't pass it to\n\t__offload_target_enter.\n\nFrom-SVN: r230614", "tree": {"sha": "bf28d3d01afdaa0748feba002dc5a1ed32326cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf28d3d01afdaa0748feba002dc5a1ed32326cfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4219ddb32f7eb9c13bf8969f33380bfa3007acc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4219ddb32f7eb9c13bf8969f33380bfa3007acc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4219ddb32f7eb9c13bf8969f33380bfa3007acc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4219ddb32f7eb9c13bf8969f33380bfa3007acc6/comments", "author": null, "committer": null, "parents": [{"sha": "2c4437019f044d7d659e0cb36ff0afb461950977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4437019f044d7d659e0cb36ff0afb461950977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c4437019f044d7d659e0cb36ff0afb461950977"}], "stats": {"total": 321, "additions": 183, "deletions": 138}, "files": [{"sha": "fb9fa8515128c6bc2deb98d66329b1645b177f0f", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4219ddb32f7eb9c13bf8969f33380bfa3007acc6/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4219ddb32f7eb9c13bf8969f33380bfa3007acc6/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=4219ddb32f7eb9c13bf8969f33380bfa3007acc6", "patch": "@@ -1,3 +1,39 @@\n+2015-11-19  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* plugin/libgomp-plugin-intelmic.cpp (struct TargetImageDesc): New.\n+\t(ImgDescMap): New typedef.\n+\t(image_descriptors): New static var.\n+\t(init): Allocate image_descriptors.\n+\t(offload): Remove vars2 argument.  Pass NULL to __offload_offload1\n+\tinstead of vars2.\n+\t(unregister_main_image): New static function.\n+\t(register_main_image): Call unregister_main_image at exit.\n+\t(GOMP_OFFLOAD_init_device): Print device number, fix offload args.\n+\t(GOMP_OFFLOAD_fini_device): Likewise.\n+\t(get_target_table): Remove vd1g and vd2g, don't pass them to offload.\n+\t(offload_image): Remove declaration of the struct TargetImage.\n+\tFree table.  Insert new descriptor into image_descriptors.\n+\t(GOMP_OFFLOAD_unload_image): Call __offload_unregister_image, free\n+\tthe corresponding descriptor, and remove it from address_table and\n+\timage_descriptors.\n+\t(GOMP_OFFLOAD_alloc): Print device number, remove vd1g.\n+\t(GOMP_OFFLOAD_free): Likewise.\n+\t(GOMP_OFFLOAD_host2dev): Print device number, remove vd1g and vd2g.\n+\t(GOMP_OFFLOAD_dev2host): Likewise.\n+\t(GOMP_OFFLOAD_run): Print device number, remove vd1g.\n+\t* plugin/offload_target_main.cpp (__offload_target_table_p1): Remove\n+\tvd2, don't pass it to __offload_target_enter.\n+\t(__offload_target_table_p2): Likewise.\n+\t(__offload_target_alloc): Likewise.\n+\t(__offload_target_free): Likewise.\n+\t(__offload_target_host2tgt_p1): Likewise.\n+\t(__offload_target_host2tgt_p2): Likewise.\n+\t(__offload_target_tgt2host_p1): Likewise.\n+\t(__offload_target_tgt2host_p2): Likewise.\n+\t(__offload_target_run): Likewise.\n+\t(__offload_target_tgt2tgt): Remove vd1g, don't pass it to\n+\t__offload_target_enter.\n+\n 2015-11-14  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* runtime/offload_host.cpp (task_completion_callback): New\n@@ -11,7 +47,7 @@\n \t(register_main_image): Call register_main_image.\n \t(GOMP_OFFLOAD_init_device, get_target_table, GOMP_OFFLOAD_alloc,\n \tGOMP_OFFLOAD_free, GOMP_OFFLOAD_host2dev, GOMP_OFFLOAD_dev2host,\n-\tGOMP_OFFLOAD_dev2dev) Adjust offload callers.\n+\tGOMP_OFFLOAD_dev2dev): Adjust offload callers.\n \t(GOMP_OFFLOAD_async_run): New function.\n \t(GOMP_OFFLOAD_run): Implement using GOMP_OFFLOAD_async_run.\n "}, {"sha": "f8c172562ae9f89d566aac1d32dbda8866694650", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 91, "deletions": 71, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4219ddb32f7eb9c13bf8969f33380bfa3007acc6/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4219ddb32f7eb9c13bf8969f33380bfa3007acc6/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=4219ddb32f7eb9c13bf8969f33380bfa3007acc6", "patch": "@@ -65,6 +65,17 @@ typedef std::vector<AddrVect> DevAddrVect;\n /* Addresses for all images and all devices.  */\n typedef std::map<const void *, DevAddrVect> ImgDevAddrMap;\n \n+/* Image descriptor needed by __offload_[un]register_image.  */\n+struct TargetImageDesc {\n+  int64_t size;\n+  /* 10 characters is enough for max int value.  */\n+  char name[sizeof (\"lib0000000000.so\")];\n+  char data[];\n+};\n+\n+/* Image descriptors, indexed by a pointer obtained from libgomp.  */\n+typedef std::map<const void *, TargetImageDesc *> ImgDescMap;\n+\n \n /* Total number of available devices.  */\n static int num_devices;\n@@ -76,6 +87,9 @@ static int num_images;\n    second key is number of device.  Contains a vector of pointer pairs.  */\n static ImgDevAddrMap *address_table;\n \n+/* Descriptors of all images, registered in liboffloadmic.  */\n+static ImgDescMap *image_descriptors;\n+\n /* Thread-safe registration of the main image.  */\n static pthread_once_t main_image_is_registered = PTHREAD_ONCE_INIT;\n \n@@ -156,6 +170,7 @@ init (void)\n \n out:\n   address_table = new ImgDevAddrMap;\n+  image_descriptors = new ImgDescMap;\n   num_devices = _Offload_number_of_devices ();\n }\n \n@@ -192,14 +207,13 @@ GOMP_OFFLOAD_get_num_devices (void)\n \n static void\n offload (const char *file, uint64_t line, int device, const char *name,\n-\t int num_vars, VarDesc *vars, VarDesc2 *vars2, const void **async_data)\n+\t int num_vars, VarDesc *vars, const void **async_data)\n {\n   OFFLOAD ofld = __offload_target_acquire1 (&device, file, line);\n   if (ofld)\n     {\n       if (async_data == NULL)\n-\t__offload_offload1 (ofld, name, 0, num_vars, vars, vars2, 0, NULL,\n-\t\t\t    NULL);\n+\t__offload_offload1 (ofld, name, 0, num_vars, vars, NULL, 0, NULL, NULL);\n       else\n \t{\n \t  OffloadFlags flags;\n@@ -216,31 +230,45 @@ offload (const char *file, uint64_t line, int device, const char *name,\n     }\n }\n \n+static void\n+unregister_main_image ()\n+{\n+  __offload_unregister_image (&main_target_image);\n+}\n+\n static void\n register_main_image ()\n {\n+  /* Do not check the return value, because old versions of liboffloadmic did\n+     not have return values.  */\n   __offload_register_image (&main_target_image);\n \n   /* liboffloadmic will call GOMP_PLUGIN_target_task_completion when\n      asynchronous task on target is completed.  */\n   __offload_register_task_callback (GOMP_PLUGIN_target_task_completion);\n+\n+  if (atexit (unregister_main_image) != 0)\n+    {\n+      fprintf (stderr, \"%s: atexit failed\\n\", __FILE__);\n+      exit (1);\n+    }\n }\n \n /* liboffloadmic loads and runs offload_target_main on all available devices\n    during a first call to offload ().  */\n extern \"C\" void\n GOMP_OFFLOAD_init_device (int device)\n {\n-  TRACE (\"\");\n+  TRACE (\"(device = %d)\", device);\n   pthread_once (&main_image_is_registered, register_main_image);\n-  offload (__FILE__, __LINE__, device, \"__offload_target_init_proc\", 0,\n-\t   NULL, NULL, NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_init_proc\", 0, NULL,\n+\t   NULL);\n }\n \n extern \"C\" void\n GOMP_OFFLOAD_fini_device (int device)\n {\n-  TRACE (\"\");\n+  TRACE (\"(device = %d)\", device);\n   /* Unreachable for GOMP_OFFLOAD_CAP_OPENMP_400.  */\n   abort ();\n }\n@@ -253,10 +281,9 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n   vd1[0].size = sizeof (num_funcs);\n   vd1[1].ptr = &num_vars;\n   vd1[1].size = sizeof (num_vars);\n-  VarDesc2 vd1g[2] = { { \"num_funcs\", 0 }, { \"num_vars\", 0 } };\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_table_p1\", 2,\n-\t   vd1, vd1g, NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_table_p1\", 2, vd1,\n+\t   NULL);\n \n   int table_size = num_funcs + 2 * num_vars;\n   if (table_size > 0)\n@@ -267,10 +294,9 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n       vd2 = vd_tgt2host;\n       vd2.ptr = table;\n       vd2.size = table_size * sizeof (void *);\n-      VarDesc2 vd2g = { \"table\", 0 };\n \n-      offload (__FILE__, __LINE__, device, \"__offload_target_table_p2\", 1,\n-\t       &vd2, &vd2g, NULL);\n+      offload (__FILE__, __LINE__, device, \"__offload_target_table_p2\", 1, &vd2,\n+\t       NULL);\n     }\n }\n \n@@ -280,23 +306,15 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n static void\n offload_image (const void *target_image)\n {\n-  struct TargetImage {\n-    int64_t size;\n-    /* 10 characters is enough for max int value.  */\n-    char name[sizeof (\"lib0000000000.so\")];\n-    char data[];\n-  } __attribute__ ((packed));\n-\n   void *image_start = ((void **) target_image)[0];\n   void *image_end   = ((void **) target_image)[1];\n \n   TRACE (\"(target_image = %p { %p, %p })\",\n \t target_image, image_start, image_end);\n \n   int64_t image_size = (uintptr_t) image_end - (uintptr_t) image_start;\n-  TargetImage *image\n-    = (TargetImage *) malloc (sizeof (int64_t) + sizeof (\"lib0000000000.so\")\n-\t\t\t      + image_size);\n+  TargetImageDesc *image = (TargetImageDesc *) malloc (offsetof (TargetImageDesc, data)\n+\t\t\t\t\t\t       + image_size);\n   if (!image)\n     {\n       fprintf (stderr, \"%s: Can't allocate memory\\n\", __FILE__);\n@@ -309,6 +327,8 @@ offload_image (const void *target_image)\n \n   TRACE (\"() __offload_register_image %s { %p, %d }\",\n \t image->name, image_start, image->size);\n+  /* Do not check the return value, because old versions of liboffloadmic did\n+     not have return values.  */\n   __offload_register_image (image);\n \n   /* Receive tables for target_image from all devices.  */\n@@ -343,11 +363,11 @@ offload_image (const void *target_image)\n \t}\n \n       dev_table.push_back (curr_dev_table);\n+      delete [] table;\n     }\n \n   address_table->insert (std::make_pair (target_image, dev_table));\n-\n-  free (image);\n+  image_descriptors->insert (std::make_pair (target_image, image));\n }\n \n /* Return the libgomp version number we're compatible with.  There is\n@@ -398,49 +418,53 @@ GOMP_OFFLOAD_unload_image (int device, unsigned version,\n \n   TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n \n-  /* TODO: Currently liboffloadmic doesn't support __offload_unregister_image\n-     for libraries.  */\n+  /* liboffloadmic unloads the image from all available devices.  */\n+  if (image_descriptors->count (target_image) > 0)\n+    {\n+      TargetImageDesc *image_desc = (*image_descriptors)[target_image];\n+      __offload_unregister_image (image_desc);\n+      free (image_desc);\n \n-  address_table->erase (target_image);\n+      address_table->erase (target_image);\n+      image_descriptors->erase (target_image);\n+    }\n }\n \n extern \"C\" void *\n GOMP_OFFLOAD_alloc (int device, size_t size)\n {\n-  TRACE (\"(size = %d)\", size);\n+  TRACE (\"(device = %d, size = %d)\", device, size);\n \n   void *tgt_ptr;\n-  VarDesc vd1[2] = { vd_host2tgt, vd_tgt2host };\n-  vd1[0].ptr = &size;\n-  vd1[0].size = sizeof (size);\n-  vd1[1].ptr = &tgt_ptr;\n-  vd1[1].size = sizeof (void *);\n-  VarDesc2 vd1g[2] = { { \"size\", 0 }, { \"tgt_ptr\", 0 } };\n-\n-  offload (__FILE__, __LINE__, device, \"__offload_target_alloc\", 2, vd1, vd1g,\n-\t   NULL);\n+  VarDesc vd[2] = { vd_host2tgt, vd_tgt2host };\n+  vd[0].ptr = &size;\n+  vd[0].size = sizeof (size);\n+  vd[1].ptr = &tgt_ptr;\n+  vd[1].size = sizeof (void *);\n+\n+  offload (__FILE__, __LINE__, device, \"__offload_target_alloc\", 2, vd, NULL);\n+\n   return tgt_ptr;\n }\n \n extern \"C\" void\n GOMP_OFFLOAD_free (int device, void *tgt_ptr)\n {\n-  TRACE (\"(tgt_ptr = %p)\", tgt_ptr);\n+  TRACE (\"(device = %d, tgt_ptr = %p)\", device, tgt_ptr);\n \n-  VarDesc vd1 = vd_host2tgt;\n-  vd1.ptr = &tgt_ptr;\n-  vd1.size = sizeof (void *);\n-  VarDesc2 vd1g = { \"tgt_ptr\", 0 };\n+  VarDesc vd = vd_host2tgt;\n+  vd.ptr = &tgt_ptr;\n+  vd.size = sizeof (void *);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_free\", 1, &vd1, &vd1g,\n-\t   NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_free\", 1, &vd, NULL);\n }\n \n extern \"C\" void *\n GOMP_OFFLOAD_host2dev (int device, void *tgt_ptr, const void *host_ptr,\n \t\t       size_t size)\n {\n-  TRACE (\"(tgt_ptr = %p, host_ptr = %p, size = %d)\", tgt_ptr, host_ptr, size);\n+  TRACE (\"(device = %d, tgt_ptr = %p, host_ptr = %p, size = %d)\",\n+\t device, tgt_ptr, host_ptr, size);\n   if (!size)\n     return tgt_ptr;\n \n@@ -449,18 +473,16 @@ GOMP_OFFLOAD_host2dev (int device, void *tgt_ptr, const void *host_ptr,\n   vd1[0].size = sizeof (void *);\n   vd1[1].ptr = &size;\n   vd1[1].size = sizeof (size);\n-  VarDesc2 vd1g[2] = { { \"tgt_ptr\", 0 }, { \"size\", 0 } };\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p1\", 2,\n-\t   vd1, vd1g, NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p1\", 2, vd1,\n+\t   NULL);\n \n   VarDesc vd2 = vd_host2tgt;\n   vd2.ptr = (void *) host_ptr;\n   vd2.size = size;\n-  VarDesc2 vd2g = { \"var\", 0 };\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p2\", 1,\n-\t   &vd2, &vd2g, NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p2\", 1, &vd2,\n+\t   NULL);\n \n   return tgt_ptr;\n }\n@@ -469,7 +491,8 @@ extern \"C\" void *\n GOMP_OFFLOAD_dev2host (int device, void *host_ptr, const void *tgt_ptr,\n \t\t       size_t size)\n {\n-  TRACE (\"(host_ptr = %p, tgt_ptr = %p, size = %d)\", host_ptr, tgt_ptr, size);\n+  TRACE (\"(device = %d, host_ptr = %p, tgt_ptr = %p, size = %d)\",\n+\t device, host_ptr, tgt_ptr, size);\n   if (!size)\n     return host_ptr;\n \n@@ -478,18 +501,16 @@ GOMP_OFFLOAD_dev2host (int device, void *host_ptr, const void *tgt_ptr,\n   vd1[0].size = sizeof (void *);\n   vd1[1].ptr = &size;\n   vd1[1].size = sizeof (size);\n-  VarDesc2 vd1g[2] = { { \"tgt_ptr\", 0 }, { \"size\", 0 } };\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p1\", 2,\n-\t   vd1, vd1g, NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p1\", 2, vd1,\n+\t   NULL);\n \n   VarDesc vd2 = vd_tgt2host;\n   vd2.ptr = (void *) host_ptr;\n   vd2.size = size;\n-  VarDesc2 vd2g = { \"var\", 0 };\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p2\", 1,\n-\t   &vd2, &vd2g, NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p2\", 1, &vd2,\n+\t   NULL);\n \n   return host_ptr;\n }\n@@ -498,21 +519,20 @@ extern \"C\" void *\n GOMP_OFFLOAD_dev2dev (int device, void *dst_ptr, const void *src_ptr,\n \t\t      size_t size)\n {\n-  TRACE (\"(dst_ptr = %p, src_ptr = %p, size = %d)\", dst_ptr, src_ptr, size);\n+  TRACE (\"(device = %d, dst_ptr = %p, src_ptr = %p, size = %d)\",\n+\t device, dst_ptr, src_ptr, size);\n   if (!size)\n     return dst_ptr;\n \n-  VarDesc vd1[3] = { vd_host2tgt, vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &dst_ptr;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &src_ptr;\n-  vd1[1].size = sizeof (void *);\n-  vd1[2].ptr = &size;\n-  vd1[2].size = sizeof (size);\n-  VarDesc2 vd1g[3] = { { \"dst_ptr\", 0 }, { \"src_ptr\", 0 }, { \"size\", 0 } };\n+  VarDesc vd[3] = { vd_host2tgt, vd_host2tgt, vd_host2tgt };\n+  vd[0].ptr = &dst_ptr;\n+  vd[0].size = sizeof (void *);\n+  vd[1].ptr = &src_ptr;\n+  vd[1].size = sizeof (void *);\n+  vd[2].ptr = &size;\n+  vd[2].size = sizeof (size);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2tgt\", 3, vd1,\n-\t   vd1g, NULL);\n+  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2tgt\", 3, vd, NULL);\n \n   return dst_ptr;\n }\n@@ -530,7 +550,7 @@ GOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,\n   vd[1].ptr = &tgt_vars;\n   vd[1].size = sizeof (void *);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_run\", 2, vd, NULL,\n+  offload (__FILE__, __LINE__, device, \"__offload_target_run\", 2, vd,\n \t   (const void **) async_data);\n }\n "}, {"sha": "584381076845ad3d261a65ad3bda98b91b54b7dd", "filename": "liboffloadmic/plugin/offload_target_main.cpp", "status": "modified", "additions": 55, "deletions": 66, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4219ddb32f7eb9c13bf8969f33380bfa3007acc6/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4219ddb32f7eb9c13bf8969f33380bfa3007acc6/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Foffload_target_main.cpp?ref=4219ddb32f7eb9c13bf8969f33380bfa3007acc6", "patch": "@@ -1,6 +1,6 @@\n /* Plugin for offload execution on Intel MIC devices.\n \n-   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n \n    Contributed by Ilya Verbin <ilya.verbin@intel.com>.\n \n@@ -139,14 +139,13 @@ __offload_target_table_p1 (OFFLOAD ofldt)\n   int num_vars = (var_table_end - var_table_begin) / 2;\n   TRACE (\"(num_funcs = %d, num_vars = %d)\", num_funcs, num_vars);\n \n-  VarDesc vd1[2] = { vd_tgt2host, vd_tgt2host };\n-  vd1[0].ptr = &num_funcs;\n-  vd1[0].size = sizeof (num_funcs);\n-  vd1[1].ptr = &num_vars;\n-  vd1[1].size = sizeof (num_vars);\n-  VarDesc2 vd2[2] = { { \"num_funcs\", 0 }, { \"num_vars\", 0 } };\n+  VarDesc vd[2] = { vd_tgt2host, vd_tgt2host };\n+  vd[0].ptr = &num_funcs;\n+  vd[0].size = sizeof (num_funcs);\n+  vd[1].ptr = &num_vars;\n+  vd[1].size = sizeof (num_vars);\n \n-  __offload_target_enter (ofldt, 2, vd1, vd2);\n+  __offload_target_enter (ofldt, 2, vd, NULL);\n   __offload_target_leave (ofldt);\n }\n \n@@ -166,13 +165,11 @@ __offload_target_table_p2 (OFFLOAD ofldt)\n   void **table = (void **) malloc (table_size);\n   TRACE (\"(table_size = %d)\", table_size);\n \n-  VarDesc vd1;\n-  vd1 = vd_tgt2host;\n-  vd1.ptr = table;\n-  vd1.size = table_size;\n-  VarDesc2 vd2 = { \"table\", 0 };\n+  VarDesc vd = vd_tgt2host;\n+  vd.ptr = table;\n+  vd.size = table_size;\n \n-  __offload_target_enter (ofldt, 1, &vd1, &vd2);\n+  __offload_target_enter (ofldt, 1, &vd, NULL);\n \n   void **p;\n   int i = 0;\n@@ -193,14 +190,13 @@ __offload_target_alloc (OFFLOAD ofldt)\n   size_t size = 0;\n   void *ptr = NULL;\n \n-  VarDesc vd1[2] = { vd_host2tgt, vd_tgt2host };\n-  vd1[0].ptr = &size;\n-  vd1[0].size = sizeof (size);\n-  vd1[1].ptr = &ptr;\n-  vd1[1].size = sizeof (void *);\n-  VarDesc2 vd2[2] = { { \"size\", 0 }, { \"ptr\", 0 } };\n+  VarDesc vd[2] = { vd_host2tgt, vd_tgt2host };\n+  vd[0].ptr = &size;\n+  vd[0].size = sizeof (size);\n+  vd[1].ptr = &ptr;\n+  vd[1].size = sizeof (void *);\n \n-  __offload_target_enter (ofldt, 2, vd1, vd2);\n+  __offload_target_enter (ofldt, 2, vd, NULL);\n   ptr = malloc (size);\n   TRACE (\"(size = %d): ptr = %p\", size, ptr);\n   __offload_target_leave (ofldt);\n@@ -212,12 +208,11 @@ __offload_target_free (OFFLOAD ofldt)\n {\n   void *ptr = 0;\n \n-  VarDesc vd1 = vd_host2tgt;\n-  vd1.ptr = &ptr;\n-  vd1.size = sizeof (void *);\n-  VarDesc2 vd2 = { \"ptr\", 0 };\n+  VarDesc vd = vd_host2tgt;\n+  vd.ptr = &ptr;\n+  vd.size = sizeof (void *);\n \n-  __offload_target_enter (ofldt, 1, &vd1, &vd2);\n+  __offload_target_enter (ofldt, 1, &vd, NULL);\n   TRACE (\"(ptr = %p)\", ptr);\n   free (ptr);\n   __offload_target_leave (ofldt);\n@@ -231,14 +226,13 @@ __offload_target_host2tgt_p1 (OFFLOAD ofldt)\n   void *var_ptr = NULL;\n   size_t var_size = 0;\n \n-  VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &var_ptr;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &var_size;\n-  vd1[1].size = sizeof (var_size);\n-  VarDesc2 vd2[2] = { { \"var_ptr\", 0 }, { \"var_size\", 0 } };\n+  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n+  vd[0].ptr = &var_ptr;\n+  vd[0].size = sizeof (void *);\n+  vd[1].ptr = &var_size;\n+  vd[1].size = sizeof (var_size);\n \n-  __offload_target_enter (ofldt, 2, vd1, vd2);\n+  __offload_target_enter (ofldt, 2, vd, NULL);\n   TRACE (\"(var_ptr = %p, var_size = %d)\", var_ptr, var_size);\n   last_var_ptr = var_ptr;\n   last_var_size = var_size;\n@@ -252,12 +246,11 @@ __offload_target_host2tgt_p2 (OFFLOAD ofldt)\n   TRACE (\"(last_var_ptr = %p, last_var_size = %d)\",\n \t last_var_ptr, last_var_size);\n \n-  VarDesc vd1 = vd_host2tgt;\n-  vd1.ptr = last_var_ptr;\n-  vd1.size = last_var_size;\n-  VarDesc2 vd2 = { \"var\", 0 };\n+  VarDesc vd = vd_host2tgt;\n+  vd.ptr = last_var_ptr;\n+  vd.size = last_var_size;\n \n-  __offload_target_enter (ofldt, 1, &vd1, &vd2);\n+  __offload_target_enter (ofldt, 1, &vd, NULL);\n   __offload_target_leave (ofldt);\n }\n \n@@ -269,14 +262,13 @@ __offload_target_tgt2host_p1 (OFFLOAD ofldt)\n   void *var_ptr = NULL;\n   size_t var_size = 0;\n \n-  VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &var_ptr;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &var_size;\n-  vd1[1].size = sizeof (var_size);\n-  VarDesc2 vd2[2] = { { \"var_ptr\", 0 }, { \"var_size\", 0 } };\n+  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n+  vd[0].ptr = &var_ptr;\n+  vd[0].size = sizeof (void *);\n+  vd[1].ptr = &var_size;\n+  vd[1].size = sizeof (var_size);\n \n-  __offload_target_enter (ofldt, 2, vd1, vd2);\n+  __offload_target_enter (ofldt, 2, vd, NULL);\n   TRACE (\"(var_ptr = %p, var_size = %d)\", var_ptr, var_size);\n   last_var_ptr = var_ptr;\n   last_var_size = var_size;\n@@ -290,12 +282,11 @@ __offload_target_tgt2host_p2 (OFFLOAD ofldt)\n   TRACE (\"(last_var_ptr = %p, last_var_size = %d)\",\n \t last_var_ptr, last_var_size);\n \n-  VarDesc vd1 = vd_tgt2host;\n-  vd1.ptr = last_var_ptr;\n-  vd1.size = last_var_size;\n-  VarDesc2 vd2 = { \"var\", 0 };\n+  VarDesc vd = vd_tgt2host;\n+  vd.ptr = last_var_ptr;\n+  vd.size = last_var_size;\n \n-  __offload_target_enter (ofldt, 1, &vd1, &vd2);\n+  __offload_target_enter (ofldt, 1, &vd, NULL);\n   __offload_target_leave (ofldt);\n }\n \n@@ -307,16 +298,15 @@ __offload_target_tgt2tgt (OFFLOAD ofldt)\n   void *dst_ptr = NULL;\n   size_t size = 0;\n \n-  VarDesc vd1[3] = { vd_host2tgt, vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &dst_ptr;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &src_ptr;\n-  vd1[1].size = sizeof (void *);\n-  vd1[2].ptr = &size;\n-  vd1[2].size = sizeof (size);\n-  VarDesc2 vd1g[3] = { { \"dst_ptr\", 0 }, { \"src_ptr\", 0 }, { \"size\", 0 } };\n+  VarDesc vd[3] = { vd_host2tgt, vd_host2tgt, vd_host2tgt };\n+  vd[0].ptr = &dst_ptr;\n+  vd[0].size = sizeof (void *);\n+  vd[1].ptr = &src_ptr;\n+  vd[1].size = sizeof (void *);\n+  vd[2].ptr = &size;\n+  vd[2].size = sizeof (size);\n \n-  __offload_target_enter (ofldt, 3, vd1, vd1g);\n+  __offload_target_enter (ofldt, 3, vd, NULL);\n   TRACE (\"(dst_ptr = %p, src_ptr = %p, size = %d)\", dst_ptr, src_ptr, size);\n   memcpy (dst_ptr, src_ptr, size);\n   __offload_target_leave (ofldt);\n@@ -329,14 +319,13 @@ __offload_target_run (OFFLOAD ofldt)\n   void *fn_ptr;\n   void *vars_ptr;\n \n-  VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n-  vd1[0].ptr = &fn_ptr;\n-  vd1[0].size = sizeof (void *);\n-  vd1[1].ptr = &vars_ptr;\n-  vd1[1].size = sizeof (void *);\n-  VarDesc2 vd2[2] = { { \"fn_ptr\", 0 }, { \"vars_ptr\", 0 } };\n+  VarDesc vd[2] = { vd_host2tgt, vd_host2tgt };\n+  vd[0].ptr = &fn_ptr;\n+  vd[0].size = sizeof (void *);\n+  vd[1].ptr = &vars_ptr;\n+  vd[1].size = sizeof (void *);\n \n-  __offload_target_enter (ofldt, 2, vd1, vd2);\n+  __offload_target_enter (ofldt, 2, vd, NULL);\n   TRACE (\"(fn_ptr = %p, vars_ptr = %p)\", fn_ptr, vars_ptr);\n   void (*fn)(void *) = (void (*)(void *)) fn_ptr;\n   fn (vars_ptr);"}]}