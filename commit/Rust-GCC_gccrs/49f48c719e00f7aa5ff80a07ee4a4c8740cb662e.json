{"sha": "49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlmNDhjNzE5ZTAwZjdhYTVmZjgwYTA3ZWU0YTRjODc0MGNiNjYyZQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-08-04T13:30:51Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-08-04T13:30:51Z"}, "message": "Warning fixes:\n\n        * Makefile.in (lang.o): Depend on $(RTL_H) $(EXPR_H).\n\n        * expr.c (java_stack_pop, java_array_data_offset,\n        build_java_throw_out_of_bounds_exception, case_identity,\n        build_java_check_indexed_type): Add static prototypes.\n        (linenumber_table, expand_invoke, expand_java_field_op,\n        build_primtype_type_ref, expand_byte_code): Constify a char*.\n\n        * java-tree.h (build_primtype_type_ref, linenumber_table):\n        Constify a char*.\n        (java_lang_expand_expr): Add prototype.\n\n        * lang.c: Include rtl.h and expr.h.  Remove extern prototype for\n        `java_lang_expand_expr'.\n\n        * lex.c (java_lex_error): Constify a char*.\n        (java_get_unicode, java_read_char, java_allocate_new_line,\n        java_unget_unicode, java_sneak_unicode): Prototype.\n\n        * parse-scan.y (current_class, package_name, method_declarator,\n        report_class_declaration, yyerror): Constify a char*.\n\n        * parse.h (java_report_errors): Prototype.\n        (yyerror): Constify a char*.\n\n        * parse.y (classitf_redefinition_error, check_modifiers,\n        parse_jdk1_1_error, lookup_package_type,\n        lookup_package_type_and_set_next, get_printable_method_name,\n        purify_type_name): Constify a char*.\n        (build_super_invocation, maybe_generate_finit,\n        verify_constructor_super, parser_add_interface,\n        add_superinterfaces, jdep_resolve_class, note_possible_classname,\n        java_complete_expand_methods, java_expand_finals,\n        cut_identifier_in_qualified, java_stabilize_reference,\n        do_unary_numeric_promotion, operator_string, do_merge_string_cste,\n        merge_string_cste): Prototype.\n        (single_type_import_declaration, yyerror,\n        variable_redefinition_error, build_array_from_name,\n        build_unresolved_array_type, check_class_interface_creation,\n        resolve_class, complete_class_report_errors,\n        note_possible_classname, read_import_dir,\n        find_in_imports_on_demand, resolve_package, fix_constructors,\n        check_deprecation, lookup_method_invoke,\n        maybe_build_primttype_type_ref, array_constructor_check_entry):\n        Constify a char*.\n        (java_complete_expand_methods, java_expand_finals): Make static.\n        (convert_narrow): Remove static prototype.\n\nFrom-SVN: r28498", "tree": {"sha": "7ed9d2bdd4e749c40cb45884bcc897adc9697db6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ed9d2bdd4e749c40cb45884bcc897adc9697db6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/comments", "author": null, "committer": null, "parents": [{"sha": "cc3dea85a80afdd34f4e021a7d186e7dd384ca0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc3dea85a80afdd34f4e021a7d186e7dd384ca0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc3dea85a80afdd34f4e021a7d186e7dd384ca0c"}], "stats": {"total": 1612, "additions": 814, "deletions": 798}, "files": [{"sha": "73cc8629142e59204cb7b7222dd072e63bc19b03", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -1,3 +1,53 @@\n+1999-08-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* Makefile.in (lang.o): Depend on $(RTL_H) $(EXPR_H).\n+\n+\t* expr.c (java_stack_pop, java_array_data_offset,\n+\tbuild_java_throw_out_of_bounds_exception, case_identity,\n+\tbuild_java_check_indexed_type): Add static prototypes.\n+\t(linenumber_table, expand_invoke, expand_java_field_op,\n+\tbuild_primtype_type_ref, expand_byte_code): Constify a char*.\n+\n+\t* java-tree.h (build_primtype_type_ref, linenumber_table):\n+\tConstify a char*.\n+\t(java_lang_expand_expr): Add prototype.\n+\n+\t* lang.c: Include rtl.h and expr.h.  Remove extern prototype for\n+\t`java_lang_expand_expr'.\n+\n+\t* lex.c (java_lex_error): Constify a char*.\n+\t(java_get_unicode, java_read_char, java_allocate_new_line,\n+\tjava_unget_unicode, java_sneak_unicode): Prototype.\n+\n+\t* parse-scan.y (current_class, package_name, method_declarator,\n+\treport_class_declaration, yyerror): Constify a char*.\n+\n+\t* parse.h (java_report_errors): Prototype.\n+\t(yyerror): Constify a char*.\n+\n+\t* parse.y (classitf_redefinition_error, check_modifiers,\n+\tparse_jdk1_1_error, lookup_package_type,\n+\tlookup_package_type_and_set_next, get_printable_method_name,\n+\tpurify_type_name): Constify a char*.\n+\t(build_super_invocation, maybe_generate_finit,\n+\tverify_constructor_super, parser_add_interface,\n+\tadd_superinterfaces, jdep_resolve_class, note_possible_classname,\n+\tjava_complete_expand_methods, java_expand_finals,\n+\tcut_identifier_in_qualified, java_stabilize_reference,\n+\tdo_unary_numeric_promotion, operator_string, do_merge_string_cste,\n+\tmerge_string_cste): Prototype.\n+\t(single_type_import_declaration, yyerror,\n+\tvariable_redefinition_error, build_array_from_name,\n+\tbuild_unresolved_array_type, check_class_interface_creation,\n+\tresolve_class, complete_class_report_errors,\n+\tnote_possible_classname, read_import_dir,\n+\tfind_in_imports_on_demand, resolve_package, fix_constructors,\n+\tcheck_deprecation, lookup_method_invoke,\n+\tmaybe_build_primttype_type_ref, array_constructor_check_entry):\n+\tConstify a char*.\n+\t(java_complete_expand_methods, java_expand_finals): Make static.\n+\t(convert_narrow): Remove static prototype.\n+\n Tue Aug  3 20:21:20 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* Makefile.in (decl.o): Depends on $(srcdir)/../defaults.h."}, {"sha": "073de958d9a43d35e4ebf8d0a0ae9d1ce536bf16", "filename": "gcc/java/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMakefile.in?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -310,7 +310,7 @@ jcf-write.o : jcf-write.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(RTL_H) \\\n jv-scan.o : jv-scan.c $(CONFIG_H) $(srcdir)/../system.h\n jvgenmain.o : jvgenmain.c $(CONFIG_H) $(srcdir)/../system.h\n lang.o : lang.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(srcdir)/../input.h \\\n-  $(srcdir)/../toplev.h $(srcdir)/../system.h\n+  $(srcdir)/../toplev.h $(srcdir)/../system.h $(RTL_H) $(EXPR_H)\n mangle.o : mangle.c $(CONFIG_H) jcf.h $(JAVA_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n parse-scan.o : $(CONFIG_H) $(srcdir)/../system.h $(srcdir)/../toplev.h"}, {"sha": "59376a1ce748aab57e350c3762d82d10c439b8d3", "filename": "gcc/java/expr.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -74,6 +74,11 @@ static tree pop_arguments PROTO ((tree));\n static void expand_invoke PROTO ((int, int, int)); \n static void expand_java_field_op PROTO ((int, int, int)); \n static void java_push_constant_from_pool PROTO ((struct JCF *, int)); \n+static void java_stack_pop PROTO ((int)); \n+static tree build_java_throw_out_of_bounds_exception PROTO ((tree)); \n+static tree build_java_check_indexed_type PROTO ((tree, tree)); \n+static tree java_array_data_offset PROTO ((tree)); \n+static tree case_identity PROTO ((tree, tree)); \n  \n static tree operand_type[59];\n extern struct obstack permanent_obstack;\n@@ -125,7 +130,7 @@ tree tree_list_free_list = NULL_TREE;\n \n int stack_pointer;\n \n-unsigned char *linenumber_table;\n+const unsigned char *linenumber_table;\n int linenumber_count;\n \n tree\n@@ -1630,7 +1635,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n   tree method_name = COMPONENT_REF_NAME (&current_jcf->cpool, method_ref_index);\n   tree self_type = get_class_constant\n     (current_jcf, COMPONENT_REF_CLASS_INDEX(&current_jcf->cpool, method_ref_index));\n-  char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n+  const char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n   tree call, func, method, arg_list, method_type;\n \n   if (! CLASS_LOADED_P (self_type))\n@@ -1738,7 +1743,7 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n       get_class_constant (current_jcf, \n \t\t\t  COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool, \n \t\t\t\t\t\t     field_ref_index));\n-  char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n+  const char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n   tree field_name = COMPONENT_REF_NAME (&current_jcf->cpool, field_ref_index);\n   tree field_signature = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, \n \t\t\t\t\t\t  field_ref_index);\n@@ -1820,9 +1825,9 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n \n tree\n build_primtype_type_ref (self_name)\n-    char *self_name;\n+    const char *self_name;\n {\n-  char *class_name = self_name+10;\n+  const char *class_name = self_name+10;\n   tree typ;\n   if (strncmp(class_name, \"Byte\", 4) == 0)\n     typ = byte_type_node;\n@@ -2043,7 +2048,7 @@ expand_byte_code (jcf, method)\n   int PC;\n   int i;\n   int saw_index;\n-  unsigned char *linenumber_pointer;\n+  const unsigned char *linenumber_pointer;\n   int dead_code_index = -1;\n \n #undef RET /* Defined by config/i386/i386.h */"}, {"sha": "dfa17a24cfc1a9d2a41870488da0853e3df2fbbd", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -584,7 +584,7 @@ extern void write_classfile PROTO ((tree));\n extern char *print_int_node PROTO ((tree));\n extern void parse_error_context PVPROTO ((tree cl, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n-extern tree build_primtype_type_ref PROTO ((char *));\n+extern tree build_primtype_type_ref PROTO ((const char *));\n extern tree java_get_real_method_name PROTO ((tree));\n extern void finish_class PROTO ((tree));\n extern void java_layout_seen_class_methods PROTO ((void));\n@@ -647,6 +647,13 @@ extern char* open_class PROTO ((char *, struct JCF *, int, const char *));\n # endif /* JCF_USE_STDIO */\n #endif\n \n+/* We use ARGS_SIZE_RTX to indicate that gcc/expr.h has been included\n+   to declare `enum expand_modifier'. */\n+#if defined (TREE_CODE) && defined(RTX_CODE) && defined (HAVE_MACHINE_MODES) && defined (ARGS_SIZE_RTX)\n+struct rtx_def * java_lang_expand_expr PROTO ((tree, rtx, enum machine_mode,\n+\t\t\t\t\t       enum expand_modifier)); \n+#endif /* TREE_CODE && RTX_CODE && HAVE_MACHINE_MODES && ARGS_SIZE_RTX */\n+\n /* Access flags etc for a method (a FUNCTION_DECL): */\n \n #define METHOD_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n@@ -731,7 +738,7 @@ extern char *instruction_bits;\n #define BCODE_VERIFIED 8\n \n /* A pointer to the line number table of the current method. */\n-extern unsigned char *linenumber_table;\n+extern const unsigned char *linenumber_table;\n /* The length (in items) of the line number table. */\n extern int linenumber_count;\n "}, {"sha": "40647336440225349daefbc3456a2dce71c5b744", "filename": "gcc/java/lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -28,6 +28,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"input.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n #include \"java-tree.h\"\n #include \"jcf.h\"\n #include \"toplev.h\"\n@@ -485,7 +487,6 @@ lang_print_error (file)\n void\n lang_init ()\n {\n-  extern struct rtx_def * java_lang_expand_expr ();\n   extern struct rtx_def * (*lang_expand_expr) ();\n   extern void (*print_error_function) PROTO((char *));\n #if 0"}, {"sha": "5e339de22e53525d5288a987444c30e4db5bc667", "filename": "gcc/java/lex.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -44,7 +44,7 @@ extern struct obstack *expression_obstack;\n static int java_lineterminator PROTO ((unicode_t));\n static char *java_sprint_unicode PROTO ((struct java_line *, int));\n static void java_unicode_2_utf8 PROTO ((unicode_t));\n-static void java_lex_error PROTO ((char *, int));\n+static void java_lex_error PROTO ((const char *, int));\n #ifndef JC1_LITE\n static int java_is_eol PROTO ((FILE *, int));\n static tree build_wfl_node PROTO ((tree));\n@@ -54,13 +54,13 @@ static unicode_t java_parse_escape_sequence PROTO ((void));\n static int java_letter_or_digit_p PROTO ((unicode_t));\n static int java_parse_doc_section PROTO ((unicode_t));\n static void java_parse_end_comment PROTO ((unicode_t));\n-static unicode_t java_get_unicode PROTO (());\n+static unicode_t java_get_unicode PROTO ((void));\n static unicode_t java_read_unicode PROTO ((int, int *));\n static void java_store_unicode PROTO ((struct java_line *, unicode_t, int));\n-static unicode_t java_read_char PROTO (());\n-static void java_allocate_new_line PROTO (());\n-static void java_unget_unicode PROTO (());\n-static unicode_t java_sneak_unicode PROTO (());\n+static unicode_t java_read_char PROTO ((void));\n+static void java_allocate_new_line PROTO ((void));\n+static void java_unget_unicode PROTO ((void));\n+static unicode_t java_sneak_unicode PROTO ((void));\n \n void\n java_init_lex ()\n@@ -1295,7 +1295,7 @@ build_wfl_node (node)\n \n static void\n java_lex_error (msg, forward)\n-     char *msg ATTRIBUTE_UNUSED;\n+     const char *msg ATTRIBUTE_UNUSED;\n      int forward ATTRIBUTE_UNUSED;\n {\n #ifndef JC1_LITE"}, {"sha": "5560b8f584298f7177b226d47c8ea4b01fb264c8", "filename": "gcc/java/parse-scan.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.c?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -143,8 +143,8 @@ static int absorber;\n #define USE_ABSORBER absorber = 0\n \n /* Keep track of the current class name and package name.  */\n-static char *current_class;\n-static char *package_name;\n+static const char *current_class;\n+static const char *package_name;\n \n /* Keep track of whether things have be listed before.  */\n static int previous_output;\n@@ -158,8 +158,8 @@ static int bracket_count;\n \n /* Record a method declaration  */\n struct method_declarator {\n-  char *method_name;\n-  char *args;\n+  const char *method_name;\n+  const char *args;\n };\n #define NEW_METHOD_DECLARATOR(D,N,A)\t\t\t\t\t     \\\n {\t\t\t\t\t\t\t\t\t     \\\n@@ -170,7 +170,7 @@ struct method_declarator {\n }\n \n /* Two actions for this grammar */\n-static void report_class_declaration PROTO ((char *));\n+static void report_class_declaration PROTO ((const char *));\n static void report_main_declaration PROTO ((struct method_declarator *));\n \n #include \"lex.h\"\n@@ -1375,7 +1375,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/x1/java/posix/share/bison.simple\"\n+#line 3 \"/usr/local/gnu/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1568,7 +1568,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/x1/java/posix/share/bison.simple\"\n+#line 196 \"/usr/local/gnu/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2156,7 +2156,7 @@ case 337:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/x1/java/posix/share/bison.simple\"\n+#line 498 \"/usr/local/gnu/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -2374,7 +2374,7 @@ java_push_parser_context ()\n \n static void\n report_class_declaration (name)\n-     char * name;\n+     const char * name;\n {\n   extern int flag_dump_class, flag_list_filename;\n \n@@ -2432,7 +2432,7 @@ void reset_report ()\n \n void\n yyerror (msg)\n-     char *msg ATTRIBUTE_UNUSED;\n+     const char *msg ATTRIBUTE_UNUSED;\n {\n }\n "}, {"sha": "8197a17b1968e5215947b1f6d25a6a99b66a3f6a", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -63,8 +63,8 @@ static int absorber;\n #define USE_ABSORBER absorber = 0\n \n /* Keep track of the current class name and package name.  */\n-static char *current_class;\n-static char *package_name;\n+static const char *current_class;\n+static const char *package_name;\n \n /* Keep track of whether things have be listed before.  */\n static int previous_output;\n@@ -78,8 +78,8 @@ static int bracket_count;\n \n /* Record a method declaration  */\n struct method_declarator {\n-  char *method_name;\n-  char *args;\n+  const char *method_name;\n+  const char *args;\n };\n #define NEW_METHOD_DECLARATOR(D,N,A)\t\t\t\t\t     \\\n {\t\t\t\t\t\t\t\t\t     \\\n@@ -90,7 +90,7 @@ struct method_declarator {\n }\n \n /* Two actions for this grammar */\n-static void report_class_declaration PROTO ((char *));\n+static void report_class_declaration PROTO ((const char *));\n static void report_main_declaration PROTO ((struct method_declarator *));\n \n #include \"lex.h\"\n@@ -1123,7 +1123,7 @@ java_push_parser_context ()\n \n static void\n report_class_declaration (name)\n-     char * name;\n+     const char * name;\n {\n   extern int flag_dump_class, flag_list_filename;\n \n@@ -1181,7 +1181,7 @@ void reset_report ()\n \n void\n yyerror (msg)\n-     char *msg ATTRIBUTE_UNUSED;\n+     const char *msg ATTRIBUTE_UNUSED;\n {\n }\n "}, {"sha": "dfec79281af020ec30f1283d46bd33f9a8e3b2ad", "filename": "gcc/java/parse.c", "status": "modified", "additions": 651, "deletions": 709, "changes": 1360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e"}, {"sha": "ea689a20cacab7a94dbbc04cc21c5a27cc2d6b02", "filename": "gcc/java/parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -659,7 +659,7 @@ void java_check_final PROTO ((void));\n void java_layout_classes PROTO ((void));\n tree java_method_add_stmt PROTO ((tree, tree));\n void java_expand_switch PROTO ((tree));\n-int java_report_errors PROTO (());\n+int java_report_errors PROTO ((void));\n extern tree do_resolve_class PROTO ((tree, tree, tree));\n #endif\n char *java_get_line_col PROTO ((char *, int, int));\n@@ -674,6 +674,6 @@ extern void java_parser_context_restore_global PROTO ((void));\n int yyparse PROTO ((void));\n extern int java_parse PROTO ((void));\n int yylex ();\n-void yyerror PROTO ((char *));\n+void yyerror PROTO ((const char *));\n extern void java_expand_classes PROTO ((void));\n #endif"}, {"sha": "98e8e608c38e5dac809fe7478b05ba4ca3a756d0", "filename": "gcc/java/parse.y", "status": "modified", "additions": 64, "deletions": 53, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49f48c719e00f7aa5ff80a07ee4a4c8740cb662e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=49f48c719e00f7aa5ff80a07ee4a4c8740cb662e", "patch": "@@ -72,9 +72,9 @@ definitions and other extensions.  */\n \n /* Local function prototypes */\n static char *java_accstring_lookup PROTO ((int));\n-static void  classitf_redefinition_error PROTO ((char *,tree, tree, tree));\n+static void  classitf_redefinition_error PROTO ((const char *,tree, tree, tree));\n static void  variable_redefinition_error PROTO ((tree, tree, tree, int));\n-static void  check_modifiers PROTO ((char *, int, int));\n+static void  check_modifiers PROTO ((const char *, int, int));\n static tree  create_class PROTO ((int, tree, tree, tree));\n static tree  create_interface PROTO ((int, tree, tree));\n static tree  find_field PROTO ((tree, tree));\n@@ -93,16 +93,16 @@ static tree method_declarator PROTO ((tree, tree));\n static void parse_warning_context PVPROTO ((tree cl, const char *msg, ...))\n   ATTRIBUTE_PRINTF_2;\n static void issue_warning_error_from_context PROTO ((tree, const char *msg, va_list));\n-static tree parse_jdk1_1_error PROTO ((char *));\n+static tree parse_jdk1_1_error PROTO ((const char *));\n static void complete_class_report_errors PROTO ((jdep *));\n static int process_imports PROTO ((void));\n static void read_import_dir PROTO ((tree));\n static int find_in_imports_on_demand PROTO ((tree));\n static int find_in_imports PROTO ((tree));\n static int check_pkg_class_access PROTO ((tree, tree));\n static tree resolve_package PROTO ((tree, tree *));\n-static tree lookup_package_type PROTO ((char *, int));\n-static tree lookup_package_type_and_set_next PROTO ((char *, int, tree *));\n+static tree lookup_package_type PROTO ((const char *, int));\n+static tree lookup_package_type_and_set_next PROTO ((const char *, int, tree *));\n static tree resolve_class PROTO ((tree, tree, tree));\n static void declare_local_variables PROTO ((int, tree, tree));\n static void source_start_java_method PROTO ((tree));\n@@ -215,16 +215,16 @@ static int check_thrown_exceptions_do PROTO ((tree));\n static void purge_unchecked_exceptions PROTO ((tree));\n static void check_throws_clauses PROTO ((tree, tree, tree));\n static void finish_method_declaration PROTO ((tree));\n-static tree build_super_invocation PROTO (());\n+static tree build_super_invocation PROTO ((void));\n static int verify_constructor_circularity PROTO ((tree, tree));\n static char *constructor_circularity_msg PROTO ((tree, tree));\n static tree build_this_super_qualified_invocation PROTO ((int, tree, tree,\n \t\t\t\t\t\t\t  int, int));\n-static char *get_printable_method_name PROTO ((tree));\n+static const char *get_printable_method_name PROTO ((tree));\n static tree patch_conditional_expr PROTO ((tree, tree, tree));\n-static void maybe_generate_finit PROTO (());\n+static void maybe_generate_finit PROTO ((void));\n static void fix_constructors PROTO ((tree));\n-static int verify_constructor_super PROTO (());\n+static int verify_constructor_super PROTO ((void));\n static tree create_artificial_method PROTO ((tree, int, tree, tree, tree));\n static void start_artificial_method_body PROTO ((tree));\n static void end_artificial_method_body PROTO ((tree));\n@@ -240,11 +240,23 @@ static tree build_new_array_init PROTO ((int, tree));\n static tree patch_new_array_init PROTO ((tree, tree));\n static tree maybe_build_array_element_wfl PROTO ((tree));\n static int array_constructor_check_entry PROTO ((tree, tree));\n-static char *purify_type_name PROTO ((char *));\n+static const char *purify_type_name PROTO ((const char *));\n static tree fold_constant_for_init PROTO ((tree, tree));\n static tree strip_out_static_field_access_decl PROTO ((tree));\n static jdeplist *reverse_jdep_list PROTO ((struct parser_ctxt *));\n static void static_ref_err PROTO ((tree, tree, tree));\n+static void parser_add_interface PROTO ((tree, tree, tree));\n+static void add_superinterfaces PROTO ((tree, tree));\n+static tree jdep_resolve_class PROTO ((jdep *));\n+static int note_possible_classname PROTO ((const char *, int));\n+static void java_complete_expand_methods PROTO ((void));\n+static void java_expand_finals PROTO ((void));\n+static tree cut_identifier_in_qualified PROTO ((tree));\n+static tree java_stabilize_reference PROTO ((tree));\n+static tree do_unary_numeric_promotion PROTO ((tree));\n+static char * operator_string PROTO ((tree));\n+static tree do_merge_string_cste PROTO ((tree, const char *, int, int));\n+static tree merge_string_cste PROTO ((tree, tree, int));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -583,7 +595,7 @@ single_type_import_declaration:\n \t\t{\n \t\t  tree name = EXPR_WFL_NODE ($2), node, last_name;\n \t\t  int   i = IDENTIFIER_LENGTH (name)-1;\n-\t\t  char *last = &IDENTIFIER_POINTER (name)[i];\n+\t\t  const char *last = &IDENTIFIER_POINTER (name)[i];\n \t\t  while (last != IDENTIFIER_POINTER (name))\n \t\t    {\n \t\t      if (last [0] == '.')\n@@ -2050,7 +2062,7 @@ cast_expression:\t\t/* Error handling here is potentially weak */\n \t\t{ $$ = build_cast ($1.location, $2, $4); }\n |\tOP_TK name dims CP_TK unary_expression_not_plus_minus\n \t\t{ \n-\t\t  char *ptr;\n+\t\t  const char *ptr;\n \t\t  while (CURRENT_OSB (ctxp)--)\n \t\t    obstack_1grow (&temporary_obstack, '[');\n \t\t  ctxp->osb_depth--;\n@@ -2415,7 +2427,7 @@ java_pop_parser_context (generate)\n \n static tree\n parse_jdk1_1_error (msg)\n-    char *msg;\n+    const char *msg;\n {\n   sorry (\": `%s' JDK1.1(TM) feature\", msg);\n   java_error_count++;\n@@ -2426,11 +2438,11 @@ static int do_warning = 0;\n \n void\n yyerror (msg)\n-     char *msg;\n+     const char *msg;\n {\n   static java_lc elc;\n   static int  prev_lineno;\n-  static char *prev_msg;\n+  static const char *prev_msg;\n \n   int save_lineno;\n   char *remainder, *code_from_source;\n@@ -2680,7 +2692,7 @@ java_accstring_lookup (flags)\n \n static void\n classitf_redefinition_error (context, id, decl, cl)\n-     char *context;\n+     const char *context;\n      tree id, decl, cl;\n {\n   parse_error_context (cl, \"%s `%s' already defined in %s:%d\", \n@@ -2694,7 +2706,7 @@ variable_redefinition_error (context, name, type, line)\n      tree context, name, type;\n      int line;\n {\n-  char *type_name;\n+  const char *type_name;\n \n   /* Figure a proper name for type. We might haven't resolved it */\n   if (TREE_CODE (type) == POINTER_TYPE && !TREE_TYPE (type))\n@@ -2714,7 +2726,7 @@ build_array_from_name (type, type_wfl, name, ret_name)\n      tree type, type_wfl, name, *ret_name;\n {\n   int more_dims = 0;\n-  char *string;\n+  const char *string;\n \n   /* Eventually get more dims */\n   string = IDENTIFIER_POINTER (name);\n@@ -2765,7 +2777,7 @@ static tree\n build_unresolved_array_type (type_or_wfl)\n      tree type_or_wfl;\n {\n-  char *ptr;\n+  const char *ptr;\n \n   /* TYPE_OR_WFL might be an array on a resolved type. In this case,\n      just create a array type */\n@@ -2792,7 +2804,7 @@ build_unresolved_array_type (type_or_wfl)\n \n static void\n check_modifiers (message, value, mask)\n-     char *message;\n+     const char *message;\n      int value;\n      int mask;\n {\n@@ -2853,7 +2865,7 @@ check_class_interface_creation (is_interface, flags, raw_name, qualified_name, d\n   /* If public, file name should match class/interface name */\n   if (flags & ACC_PUBLIC)\n     {\n-      char *f;\n+      const char *f;\n \n       /* Contains OS dependent assumption on path separator. FIXME */\n       for (f = &input_filename [strlen (input_filename)]; \n@@ -4149,8 +4161,8 @@ static tree\n resolve_class (class_type, decl, cl)\n      tree class_type, decl, cl;\n {\n-  char *name = IDENTIFIER_POINTER (TYPE_NAME (class_type));\n-  char *base = name;\n+  const char *name = IDENTIFIER_POINTER (TYPE_NAME (class_type));\n+  const char *base = name;\n   tree resolved_type = TREE_TYPE (class_type);\n   tree resolved_type_decl;\n   \n@@ -4366,9 +4378,9 @@ resolve_no_layout (name, cl)\n /* Called when reporting errors. Skip leader '[' in a complex array\n    type description that failed to be resolved.  */\n \n-static char *\n+static const char *\n purify_type_name (name)\n-     char *name;\n+     const char *name;\n {\n   while (*name && *name == '[')\n     name++;\n@@ -4381,7 +4393,7 @@ static void\n complete_class_report_errors (dep)\n      jdep *dep;\n {\n-  char *name;\n+  const char *name;\n \n   if (!JDEP_WFL (dep))\n     return;\n@@ -4454,11 +4466,11 @@ java_check_final ()\n    DECL is a constructor, use the class name instead of the form\n    <init> */\n \n-static char *\n+static const char *\n get_printable_method_name (decl)\n      tree decl;\n {\n-  char *to_return;\n+  const char *to_return;\n   tree name = NULL_TREE;\n \n   if (DECL_CONSTRUCTOR_P (decl))\n@@ -5035,7 +5047,7 @@ find_in_imports (class_type)\n \n static int\n note_possible_classname (name, len)\n-     char *name;\n+     const char *name;\n      int len;\n {\n   tree node;\n@@ -5060,7 +5072,7 @@ read_import_dir (wfl)\n      tree wfl;\n {\n   tree package_id = EXPR_WFL_NODE (wfl);\n-  char *package_name = IDENTIFIER_POINTER (package_id);\n+  const char *package_name = IDENTIFIER_POINTER (package_id);\n   int package_length = IDENTIFIER_LENGTH (package_id);\n   DIR *dirp = NULL;\n   JCF *saved_jcf = current_jcf;\n@@ -5080,7 +5092,7 @@ read_import_dir (wfl)\n \n   for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))\n     {\n-      char *entry_name = jcf_path_name (entry);\n+      const char *entry_name = jcf_path_name (entry);\n       int entry_length = strlen (entry_name);\n       if (jcf_path_is_zipfile (entry))\n \t{\n@@ -5104,7 +5116,7 @@ read_import_dir (wfl)\n \n \t      for (k = 0; k < zipf->count;  k++, zipd = ZIPDIR_NEXT (zipd))\n \t\t{\n-\t\t  char *current_entry = ZIPDIR_FILENAME (zipd);\n+\t\t  const char *current_entry = ZIPDIR_FILENAME (zipd);\n \t\t  int current_entry_len = zipd->filename_length;\n \n \t\t  if (current_entry_len >= BUFFER_LENGTH (filename)\n@@ -5136,7 +5148,7 @@ read_import_dir (wfl)\n \t  for (;;)\n \t    {\n \t      int len; \n-\t      char *d_name;\n+\t      const char *d_name;\n \t      struct dirent *direntp = readdir (dirp);\n \t      if (!direntp)\n \t\tbreak;\n@@ -5192,7 +5204,7 @@ find_in_imports_on_demand (class_type)\n \n   for (import = ctxp->import_demand_list; import; import = TREE_CHAIN (import))\n     {\n-      char *id_name;\n+      const char *id_name;\n       obstack_grow (&temporary_obstack, \n \t\t    IDENTIFIER_POINTER (EXPR_WFL_NODE (TREE_PURPOSE (import))),\n \t\t    IDENTIFIER_LENGTH (EXPR_WFL_NODE (TREE_PURPOSE (import))));\n@@ -5250,7 +5262,7 @@ resolve_package (pkg, next)\n {\n   tree current;\n   tree type_name = NULL_TREE;\n-  char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (pkg));\n+  const char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (pkg));\n \n   /* The trick is to determine when the package name stops and were\n      the name of something contained in the package starts. Then we\n@@ -5309,11 +5321,11 @@ resolve_package (pkg, next)\n \n static tree\n lookup_package_type_and_set_next (name, len, next)\n-     char *name;\n+     const char *name;\n      int len;\n      tree *next;\n {\n-  char *ptr;\n+  const char *ptr;\n   tree type_name = lookup_package_type (name, len);\n \n   if (!type_name)\n@@ -5330,11 +5342,11 @@ lookup_package_type_and_set_next (name, len, next)\n \n static tree\n lookup_package_type (name, from)\n-     char *name;\n+     const char *name;\n      int from;\n {\n   char subname [128];\n-  char *sub = &name[from+1];\n+  const char *sub = &name[from+1];\n   while (*sub != '.' && *sub)\n     sub++;\n   strncpy (subname, name, sub-name);\n@@ -5800,7 +5812,7 @@ java_layout_classes ()\n \n /* Expand all methods in all registered classes.  */\n \n-void\n+static void\n java_complete_expand_methods ()\n {\n   tree current;\n@@ -5998,7 +6010,7 @@ fix_constructors (mdecl)\n       if (verify_constructor_super ())\n \t{\n \t  tree sclass_decl = TYPE_NAME (CLASSTYPE_SUPER (current_class));\n-\t  char *n = IDENTIFIER_POINTER (DECL_NAME (sclass_decl));\n+\t  const char *n = IDENTIFIER_POINTER (DECL_NAME (sclass_decl));\n \t  parse_error_context (lookup_cl (TYPE_NAME (current_class)), \n \t\t\t       \"No constructor matching `%s()' found in \"\n \t\t\t       \"class `%s'\", n, n);\n@@ -6079,7 +6091,7 @@ verify_constructor_super ()\n \n /* Expand finals.  */\n \n-void\n+static void\n java_expand_finals ()\n {\n }\n@@ -6820,7 +6832,7 @@ static void\n check_deprecation (wfl, decl)\n      tree wfl, decl;\n {\n-  char *file = DECL_SOURCE_FILE (decl);\n+  const char *file = DECL_SOURCE_FILE (decl);\n   /* Complain if the field is deprecated and the file it was defined\n      in isn't compiled at the same time the file which contains its\n      use is */\n@@ -7352,7 +7364,7 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n {\n   tree atl = end_params_node;\t\t/* Arg Type List */\n   tree method, signature, list, node;\n-  char *candidates;\t\t/* Used for error report */\n+  const char *candidates;\t\t/* Used for error report */\n \n   /* Fix the arguments */\n   for (node = arg_list; node; node = TREE_CHAIN (node))\n@@ -8828,7 +8840,7 @@ maybe_build_primttype_type_ref (rhs, wfl)\n \t  && DECL_NAME (n) == TYPE_identifier_node\n \t  && rhs_type == class_ptr_type)\n \t{\n-\t  char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));\n+\t  const char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));\n \t  if (!strncmp (self_name, \"java.lang.\", 10))\n \t    to_return = build_primtype_type_ref (self_name);\n \t}\n@@ -9722,11 +9734,11 @@ patch_binop (node, wfl_op1, wfl_op2)\n static tree\n do_merge_string_cste (cste, string, string_len, after)\n      tree cste;\n-     char *string;\n+     const char *string;\n      int string_len, after;\n {\n   int len = TREE_STRING_LENGTH (cste) + string_len;\n-  char *old = TREE_STRING_POINTER (cste);\n+  const char *old = TREE_STRING_POINTER (cste);\n   TREE_STRING_LENGTH (cste) = len;\n   TREE_STRING_POINTER (cste) = obstack_alloc (expression_obstack, len+1);\n   if (after)\n@@ -9758,11 +9770,11 @@ merge_string_cste (op1, op2, after)\n   /* Reasonable integer constant can be treated right away */\n   if (TREE_CODE (op2) == INTEGER_CST && !TREE_CONSTANT_OVERFLOW (op2))\n     {\n-      static char *boolean_true = \"true\";\n-      static char *boolean_false = \"false\";\n-      static char *null_pointer = \"null\";\n+      static const char *boolean_true = \"true\";\n+      static const char *boolean_false = \"false\";\n+      static const char *null_pointer = \"null\";\n       char ch[3];\n-      char *string;\n+      const char *string;\n       \n       if (op2 == boolean_true_node)\n \tstring = boolean_true;\n@@ -10209,7 +10221,6 @@ patch_cast (node, wfl_operator)\n   /* Check on cast that are proven correct at compile time */\n   if (JNUMERIC_TYPE_P (cast_type) && JNUMERIC_TYPE_P (op_type))\n     {\n-      static tree convert_narrow ();\n       /* Same type */\n       if (cast_type == op_type)\n \treturn node;\n@@ -10602,7 +10613,7 @@ array_constructor_check_entry (type, entry)\n   /* Check and report errors */\n   if (!new_value)\n     {\n-      char *msg = (!valid_cast_to_p (type_value, type) ?\n+      const char *msg = (!valid_cast_to_p (type_value, type) ?\n \t\t   \"Can't\" : \"Explicit cast needed to\");\n       if (!array_type_string)\n \tarray_type_string = strdup (lang_printable_name (type, 1));"}]}