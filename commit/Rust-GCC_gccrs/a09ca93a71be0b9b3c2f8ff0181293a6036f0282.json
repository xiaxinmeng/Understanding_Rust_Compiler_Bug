{"sha": "a09ca93a71be0b9b3c2f8ff0181293a6036f0282", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA5Y2E5M2E3MWJlMGI5YjNjMmY4ZmYwMTgxMjkzYTYwMzZmMDI4Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-10-27T16:54:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-10-27T16:54:49Z"}, "message": "gimple-ssa-sprintf.c: Include domwalk.h.\n\n\t* gimple-ssa-sprintf.c: Include domwalk.h.\n\t(class sprintf_dom_walker): New class, derived from dom_walker.\n\t(sprintf_dom_walker::before_dom_children): New function.\n\t(struct call_info): Moved into sprintf_dom_walker class\n\t(compute_formath_length, handle_gimple_call): Likewise.\n\t(sprintf_length::execute): Call the dominator walker rather\n\tthan walking the statements.\n\nFrom-SVN: r254156", "tree": {"sha": "028b671db983183eab1364f9dfbb600546fcccef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/028b671db983183eab1364f9dfbb600546fcccef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a09ca93a71be0b9b3c2f8ff0181293a6036f0282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09ca93a71be0b9b3c2f8ff0181293a6036f0282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a09ca93a71be0b9b3c2f8ff0181293a6036f0282", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09ca93a71be0b9b3c2f8ff0181293a6036f0282/comments", "author": null, "committer": null, "parents": [{"sha": "a565d95cd0f0ce7b7c44cfd86ea5abfe4fcba1b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a565d95cd0f0ce7b7c44cfd86ea5abfe4fcba1b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a565d95cd0f0ce7b7c44cfd86ea5abfe4fcba1b7"}], "stats": {"total": 83, "additions": 53, "deletions": 30}, "files": [{"sha": "c740c8b17058e208f1143d7c786264d39ef56396", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a09ca93a71be0b9b3c2f8ff0181293a6036f0282/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a09ca93a71be0b9b3c2f8ff0181293a6036f0282/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a09ca93a71be0b9b3c2f8ff0181293a6036f0282", "patch": "@@ -1,5 +1,13 @@\n 2017-10-27  Jeff Law  <law@redhat.com>\n \n+\t* gimple-ssa-sprintf.c: Include domwalk.h.\n+\t(class sprintf_dom_walker): New class, derived from dom_walker.\n+\t(sprintf_dom_walker::before_dom_children): New function.\n+\t(struct call_info): Moved into sprintf_dom_walker class\n+\t(compute_formath_length, handle_gimple_call): Likewise.\n+\t(sprintf_length::execute): Call the dominator walker rather\n+\tthan walking the statements.\n+\n \t* tree-vrp.c (check_all_array_refs): Do not use wi->info to smuggle\n \tgimple statement locations.\n \t(check_array_bounds): Corresponding changes.  Get the statement's"}, {"sha": "74154138fc9f09172e407dc27ab6cf96c70e92b2", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a09ca93a71be0b9b3c2f8ff0181293a6036f0282/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a09ca93a71be0b9b3c2f8ff0181293a6036f0282/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=a09ca93a71be0b9b3c2f8ff0181293a6036f0282", "patch": "@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"substring-locations.h\"\n #include \"diagnostic.h\"\n+#include \"domwalk.h\"\n \n /* The likely worst case value of MB_LEN_MAX for the target, large enough\n    for UTF-8.  Ideally, this would be obtained by a target hook if it were\n@@ -113,6 +114,19 @@ static int warn_level;\n \n struct format_result;\n \n+class sprintf_dom_walker : public dom_walker\n+{\n+ public:\n+  sprintf_dom_walker () : dom_walker (CDI_DOMINATORS) {}\n+  ~sprintf_dom_walker () {}\n+\n+  virtual edge before_dom_children (basic_block) FINAL OVERRIDE;\n+  bool handle_gimple_call (gimple_stmt_iterator *);\n+\n+  struct call_info;\n+  bool compute_format_length (call_info &, format_result *);\n+};\n+\n class pass_sprintf_length : public gimple_opt_pass\n {\n   bool fold_return_value;\n@@ -135,10 +149,6 @@ class pass_sprintf_length : public gimple_opt_pass\n       fold_return_value = param;\n     }\n \n-  bool handle_gimple_call (gimple_stmt_iterator *);\n-\n-  struct call_info;\n-  bool compute_format_length (call_info &, format_result *);\n };\n \n bool\n@@ -976,7 +986,7 @@ bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n \n /* Description of a call to a formatted function.  */\n \n-struct pass_sprintf_length::call_info\n+struct sprintf_dom_walker::call_info\n {\n   /* Function call statement.  */\n   gimple *callstmt;\n@@ -2348,7 +2358,7 @@ format_plain (const directive &dir, tree)\n    should be diagnosed given the AVAILable space in the destination.  */\n \n static bool\n-should_warn_p (const pass_sprintf_length::call_info &info,\n+should_warn_p (const sprintf_dom_walker::call_info &info,\n \t       const result_range &avail, const result_range &result)\n {\n   if (result.max <= avail.min)\n@@ -2419,7 +2429,7 @@ should_warn_p (const pass_sprintf_length::call_info &info,\n \n static bool\n maybe_warn (substring_loc &dirloc, location_t argloc,\n-\t    const pass_sprintf_length::call_info &info,\n+\t    const sprintf_dom_walker::call_info &info,\n \t    const result_range &avail_range, const result_range &res,\n \t    const directive &dir)\n {\n@@ -2716,7 +2726,7 @@ maybe_warn (substring_loc &dirloc, location_t argloc,\n    in *RES.  Return true if the directive has been handled.  */\n \n static bool\n-format_directive (const pass_sprintf_length::call_info &info,\n+format_directive (const sprintf_dom_walker::call_info &info,\n \t\t  format_result *res, const directive &dir)\n {\n   /* Offset of the beginning of the directive from the beginning\n@@ -3004,7 +3014,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n    the directive.  */\n \n static size_t\n-parse_directive (pass_sprintf_length::call_info &info,\n+parse_directive (sprintf_dom_walker::call_info &info,\n \t\t directive &dir, format_result *res,\n \t\t const char *str, unsigned *argno)\n {\n@@ -3431,7 +3441,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n    that caused the processing to be terminated early).  */\n \n bool\n-pass_sprintf_length::compute_format_length (call_info &info,\n+sprintf_dom_walker::compute_format_length (call_info &info,\n \t\t\t\t\t    format_result *res)\n {\n   if (dump_file)\n@@ -3514,7 +3524,7 @@ get_destination_size (tree dest)\n    of its return values.  */\n \n static bool\n-is_call_safe (const pass_sprintf_length::call_info &info,\n+is_call_safe (const sprintf_dom_walker::call_info &info,\n \t      const format_result &res, bool under4k,\n \t      unsigned HOST_WIDE_INT retval[2])\n {\n@@ -3573,7 +3583,7 @@ is_call_safe (const pass_sprintf_length::call_info &info,\n \n static bool\n try_substitute_return_value (gimple_stmt_iterator *gsi,\n-\t\t\t     const pass_sprintf_length::call_info &info,\n+\t\t\t     const sprintf_dom_walker::call_info &info,\n \t\t\t     const format_result &res)\n {\n   tree lhs = gimple_get_lhs (info.callstmt);\n@@ -3690,7 +3700,7 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \n static bool\n try_simplify_call (gimple_stmt_iterator *gsi,\n-\t\t   const pass_sprintf_length::call_info &info,\n+\t\t   const sprintf_dom_walker::call_info &info,\n \t\t   const format_result &res)\n {\n   unsigned HOST_WIDE_INT dummy[2];\n@@ -3717,7 +3727,7 @@ try_simplify_call (gimple_stmt_iterator *gsi,\n    and gsi_next should not be performed in the caller.  */\n \n bool\n-pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n+sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n {\n   call_info info = call_info ();\n \n@@ -3982,33 +3992,38 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n   return call_removed;\n }\n \n+edge\n+sprintf_dom_walker::before_dom_children (basic_block bb)\n+{\n+  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si); )\n+    {\n+      /* Iterate over statements, looking for function calls.  */\n+      gimple *stmt = gsi_stmt (si);\n+\n+      if (is_gimple_call (stmt) && handle_gimple_call (&si))\n+\t/* If handle_gimple_call returns true, the iterator is\n+\t   already pointing to the next statement.  */\n+\tcontinue;\n+\n+      gsi_next (&si);\n+    }\n+  return NULL;\n+}\n+\n /* Execute the pass for function FUN.  */\n \n unsigned int\n pass_sprintf_length::execute (function *fun)\n {\n   init_target_to_host_charmap ();\n \n-  basic_block bb;\n-  FOR_EACH_BB_FN (bb, fun)\n-    {\n-      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si); )\n-\t{\n-\t  /* Iterate over statements, looking for function calls.  */\n-\t  gimple *stmt = gsi_stmt (si);\n-\n-\t  if (is_gimple_call (stmt) && handle_gimple_call (&si))\n-\t    /* If handle_gimple_call returns true, the iterator is\n-\t       already pointing to the next statement.  */\n-\t    continue;\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n-\t  gsi_next (&si);\n-\t}\n-    }\n+  sprintf_dom_walker sprintf_dom_walker;\n+  sprintf_dom_walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n   /* Clean up object size info.  */\n   fini_object_sizes ();\n-\n   return 0;\n }\n "}]}