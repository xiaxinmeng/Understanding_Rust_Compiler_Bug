{"sha": "788b962aa00959e861b45767c5c88ec41ca30c21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg4Yjk2MmFhMDA5NTllODYxYjQ1NzY3YzVjODhlYzQxY2EzMGMyMQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-23T09:06:21Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-23T17:37:42Z"}, "message": "coroutines: Add a cleanup expression for g-r-o when needed [PR95477].\n\nThe PR reports that we fail to destroy the object initially created from\nthe get-return-object call.  Fixed by adding a cleanup when the DTOR is\nnon-trivial.  In addition, to meet the specific wording that the call to\nget_return_object creates the glvalue for the return, we must construct\nthat in-place in the return object to avoid a second copy/move CTOR.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95477\n\t* coroutines.cc (morph_fn_to_coro): Apply a cleanup to\n\tthe get return object when the DTOR is non-trivial.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95477\n\t* g++.dg/coroutines/pr95477.C: New test.\n\t* g++.dg/coroutines/void-gro-non-class-coro.C: New test.", "tree": {"sha": "ca5baf402ff7008dc7ed672f0c6ff906623863c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca5baf402ff7008dc7ed672f0c6ff906623863c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/788b962aa00959e861b45767c5c88ec41ca30c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/788b962aa00959e861b45767c5c88ec41ca30c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/788b962aa00959e861b45767c5c88ec41ca30c21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/788b962aa00959e861b45767c5c88ec41ca30c21/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17964eb3a054c634b743aae9d1d9414e1bf21885", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17964eb3a054c634b743aae9d1d9414e1bf21885", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17964eb3a054c634b743aae9d1d9414e1bf21885"}], "stats": {"total": 167, "additions": 156, "deletions": 11}, "files": [{"sha": "9cdb0c591d5987c9b79b4e11194a21a55a68baf0", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 60, "deletions": 11, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/788b962aa00959e861b45767c5c88ec41ca30c21/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/788b962aa00959e861b45767c5c88ec41ca30c21/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=788b962aa00959e861b45767c5c88ec41ca30c21", "patch": "@@ -4279,12 +4279,34 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   tree gro = NULL_TREE;\n   tree gro_bind_vars = NULL_TREE;\n+  tree gro_cleanup_stmt = NULL_TREE;\n   /* We have to sequence the call to get_return_object before initial\n      suspend.  */\n   if (gro_is_void_p)\n-    finish_expr_stmt (get_ro);\n+    r = get_ro;\n+  else if (same_type_p (gro_type, fn_return_type))\n+    {\n+     /* [dcl.fct.def.coroutine] / 7\n+\tThe expression promise.get_return_object() is used to initialize the\n+\tglvalue result or... (see below)\n+\tConstruct the return result directly.  */\n+      if (TYPE_NEEDS_CONSTRUCTING (gro_type))\n+\t{\n+\t  vec<tree, va_gc> *arg = make_tree_vector_single (get_ro);\n+\t  r = build_special_member_call (DECL_RESULT (orig),\n+\t\t\t\t\t complete_ctor_identifier,\n+\t\t\t\t\t &arg, gro_type, LOOKUP_NORMAL,\n+\t\t\t\t\t tf_warning_or_error);\n+\t  release_tree_vector (arg);\n+\t}\n+      else\n+\tr = build2_loc (fn_start, INIT_EXPR, gro_type,\n+\t\t\tDECL_RESULT (orig), get_ro);\n+    }\n   else\n     {\n+      /* ... or ... Construct an object that will be used as the single\n+\tparam to the CTOR for the return object.  */\n       gro = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro\"), gro_type);\n       DECL_CONTEXT (gro) = current_scope ();\n       DECL_ARTIFICIAL (gro) = true;\n@@ -4301,8 +4323,21 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t}\n       else\n \tr = build2_loc (fn_start, INIT_EXPR, gro_type, gro, get_ro);\n-      finish_expr_stmt (r);\n+      /* The constructed object might require a cleanup.  */\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (gro_type))\n+\t{\n+\t  tree cleanup\n+\t    = build_special_member_call (gro, complete_dtor_identifier,\n+\t\t\t\t\t NULL, gro_type, LOOKUP_NORMAL,\n+\t\t\t\t\t tf_warning_or_error);\n+\t  gro_cleanup_stmt = build_stmt (input_location, CLEANUP_STMT, NULL,\n+\t\t\t\t\t cleanup, gro);\n+\t}\n     }\n+  finish_expr_stmt (r);\n+\n+  if (gro_cleanup_stmt)\n+    CLEANUP_BODY (gro_cleanup_stmt) = push_stmt_list ();\n \n   /* Initialize the resume_idx_name to 0, meaning \"not started\".  */\n   tree resume_idx_m\n@@ -4344,21 +4379,20 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      promise was constructed.  We now supply a reference to that var,\n      either as the return value (if it's the same type) or to the CTOR\n      for an object of the return type.  */\n-  if (gro_is_void_p)\n-    r = NULL_TREE;\n-  else\n-    r = rvalue (gro);\n \n-  if (!same_type_p (gro_type, fn_return_type))\n+  if (same_type_p (gro_type, fn_return_type))\n+    r = gro_is_void_p ? NULL_TREE : DECL_RESULT (orig);\n+  else\n     {\n-      /* The return object is , even if the gro is void.  */\n       if (CLASS_TYPE_P (fn_return_type))\n \t{\n+\t  /* For class type return objects, we can attempt to construct,\n+\t     even if the gro is void.  */\n \t  vec<tree, va_gc> *args = NULL;\n \t  vec<tree, va_gc> **arglist = NULL;\n \t  if (!gro_is_void_p)\n \t    {\n-\t      args = make_tree_vector_single (r);\n+\t      args = make_tree_vector_single (rvalue (gro));\n \t      arglist = &args;\n \t    }\n \t  r = build_special_member_call (NULL_TREE,\n@@ -4369,12 +4403,27 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  if (args)\n \t    release_tree_vector (args);\n \t}\n-      else /* ??? suppose we have non-class return and void gro?  */\n-\tr = build1_loc (input_location, CONVERT_EXPR, fn_return_type, r);\n+      else if (gro_is_void_p)\n+\t{\n+\t  /* We can't initialize a non-class return value from void.  */\n+\t  error_at (input_location, \"cannot initialize a return object of type\"\n+\t\t    \" %qT with an rvalue of type %<void%>\", fn_return_type);\n+\t  r = error_mark_node;\n+\t}\n+      else\n+\tr = build1_loc (input_location, CONVERT_EXPR,\n+\t\t\tfn_return_type, rvalue (gro));\n     }\n \n   finish_return_stmt (r);\n \n+  if (gro_cleanup_stmt)\n+    {\n+      CLEANUP_BODY (gro_cleanup_stmt)\n+\t= pop_stmt_list (CLEANUP_BODY (gro_cleanup_stmt));\n+      add_stmt (gro_cleanup_stmt);\n+    }\n+\n   /* Finish up the ramp function.  */\n   BIND_EXPR_VARS (gro_context_bind) = gro_bind_vars;\n   BIND_EXPR_BODY (gro_context_bind) = pop_stmt_list (gro_context_body);"}, {"sha": "7050aee00781f638472aac73c330ba3dcdcfa821", "filename": "gcc/testsuite/g++.dg/coroutines/pr95477.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/788b962aa00959e861b45767c5c88ec41ca30c21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95477.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/788b962aa00959e861b45767c5c88ec41ca30c21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95477.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95477.C?ref=788b962aa00959e861b45767c5c88ec41ca30c21", "patch": "@@ -0,0 +1,37 @@\n+//  { dg-do run }\n+\n+#include \"coro.h\"\n+\n+struct simple {\n+  static inline int alive = 0;\n+  simple() { ++alive; }\n+  simple(simple&&) { ++alive; }\n+  ~simple() { --alive; }\n+\n+  struct promise_type {\n+    simple get_return_object() { return simple{}; }\n+    void return_void() {}\n+    void unhandled_exception() {}\n+    auto initial_suspend() noexcept { return coro::suspend_never{}; }\n+    auto final_suspend() noexcept { return coro::suspend_never{}; }\n+  };\n+};\n+\n+simple\n+f()\n+{\n+  co_return;\n+}\n+\n+int main() {\n+  {\n+    f();\n+  }\n+\n+  if (simple::alive != 0)\n+   {\n+     PRINTF (\"something wrong with dtors: %d\\n\", simple::alive);\n+     abort ();\n+   }\n+  return 0;\n+}"}, {"sha": "8176c8a10afa2238a8575bfd55cf14112d09fe0f", "filename": "gcc/testsuite/g++.dg/coroutines/void-gro-non-class-coro.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/788b962aa00959e861b45767c5c88ec41ca30c21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fvoid-gro-non-class-coro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/788b962aa00959e861b45767c5c88ec41ca30c21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fvoid-gro-non-class-coro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fvoid-gro-non-class-coro.C?ref=788b962aa00959e861b45767c5c88ec41ca30c21", "patch": "@@ -0,0 +1,59 @@\n+// Test handling of the case where we have a void g-r-o and a non-void\n+// and non-class-type ramp return.\n+\n+#include \"coro.h\"\n+\n+int g_promise = -1;\n+\n+template<typename R, typename HandleRef, typename ...T>\n+struct std::coroutine_traits<R, HandleRef, T...> {\n+    struct promise_type {\n+        promise_type (HandleRef h, T ...args)\n+        { h = std::coroutine_handle<promise_type>::from_promise (*this);\n+          PRINT (\"Created Promise\");\n+          g_promise = 1;\n+        }\n+\t~promise_type () { PRINT (\"Destroyed Promise\"); g_promise = 0;}\n+        void get_return_object() {}\n+\n+        auto initial_suspend() {\n+          return std::suspend_always{};\n+         }\n+        auto final_suspend() { return std::suspend_never{}; }\n+\n+        void return_void() {}\n+        void unhandled_exception() {}\n+    };\n+};\n+\n+int\n+my_coro (std::coroutine_handle<>& h)\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+} // { dg-error {cannot initialize a return object of type 'int' with an rvalue of type 'void'} }\n+\n+int main ()\n+{\n+  std::coroutine_handle<> h;\n+  int t = my_coro (h);\n+\n+  if (h.done())\n+    {\n+      PRINT (\"main: apparently was already done...\");\n+      abort ();\n+    }\n+\n+  // initial suspend.\n+  h.resume ();\n+\n+  // The coro should have self-destructed.\n+  if (g_promise)\n+    {\n+      PRINT (\"main: apparently we did not complete...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}]}