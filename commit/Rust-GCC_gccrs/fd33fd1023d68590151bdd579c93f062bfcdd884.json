{"sha": "fd33fd1023d68590151bdd579c93f062bfcdd884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQzM2ZkMTAyM2Q2ODU5MDE1MWJkZDU3OWM5M2YwNjJiZmNkZDg4NA==", "commit": {"author": {"name": "Shujing Zhao", "email": "pearly.zhao@oracle.com", "date": "2010-05-25T06:26:07Z"}, "committer": {"name": "Shujing Zhao", "email": "pzhao@gcc.gnu.org", "date": "2010-05-25T06:26:07Z"}, "message": "re PR c++/18249 (C++ parser i18n problems)\n\n2010-05-25  Shujing Zhao  <pearly.zhao@oracle.com>\n\n        PR c++/18249\n        * parser.c: Remove inclusion of dyn-string.h.\n        (non_integral_constant): New enum.\n        (name_lookup_error): New enum.\n        (required_token): New enum.\n        (cp_parser_required_error): New function.\n        (cp_parser_require): Change the type of variable token_desc to\n        required_token and use cp_parser_required_error.\n        (cp_parser_require_keyword): Likewise.\n        (cp_parser_error): Use gmsgid as parameter.\n        (cp_parser_name_lookup_error): Change the type of variable desired to\n        name_lookup_error and put the diagnostic in the full sentences. Change\n        caller.\n        (cp_parser_non_integral_constant_expression): Change the type of the\n        variable thing to non_integral_constant and put the diagnostics in\n        full sentences. Change caller.\n\nFrom-SVN: r159808", "tree": {"sha": "ec00ecffbf2ebeee6346550855750bf8c7447e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec00ecffbf2ebeee6346550855750bf8c7447e40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd33fd1023d68590151bdd579c93f062bfcdd884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd33fd1023d68590151bdd579c93f062bfcdd884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd33fd1023d68590151bdd579c93f062bfcdd884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd33fd1023d68590151bdd579c93f062bfcdd884/comments", "author": null, "committer": null, "parents": [{"sha": "ee4e170616ee6a3c4f626ecf365175663c17b291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee4e170616ee6a3c4f626ecf365175663c17b291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee4e170616ee6a3c4f626ecf365175663c17b291"}], "stats": {"total": 1001, "additions": 715, "deletions": 286}, "files": [{"sha": "8615d2b57d5ce14933344d67b64af2af5ce21198", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd33fd1023d68590151bdd579c93f062bfcdd884/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd33fd1023d68590151bdd579c93f062bfcdd884/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fd33fd1023d68590151bdd579c93f062bfcdd884", "patch": "@@ -1,3 +1,22 @@\n+2010-05-25  Shujing Zhao  <pearly.zhao@oracle.com>\n+\t\n+\tPR c++/18249\n+\t* parser.c: Remove inclusion of dyn-string.h.\n+\t(non_integral_constant): New enum.\n+\t(name_lookup_error): New enum.\n+\t(required_token): New enum.\n+\t(cp_parser_required_error): New function.\n+\t(cp_parser_require): Change the type of variable token_desc to\n+\trequired_token and use cp_parser_required_error.\n+\t(cp_parser_require_keyword): Likewise.\n+\t(cp_parser_error): Use gmsgid as parameter.\n+\t(cp_parser_name_lookup_error): Change the type of variable desired to\n+\tname_lookup_error and put the diagnostic in the full sentences. Change\n+\tcaller.\n+\t(cp_parser_non_integral_constant_expression): Change the type of the\n+\tvariable thing to non_integral_constant and put the diagnostics in\n+\tfull sentences. Change caller.\n+\n 2010-05-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/44100"}, {"sha": "ce0a27a98c440b4328ecdc54a95f4ed5cf8f87b4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 696, "deletions": 286, "changes": 982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd33fd1023d68590151bdd579c93f062bfcdd884/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd33fd1023d68590151bdd579c93f062bfcdd884/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fd33fd1023d68590151bdd579c93f062bfcdd884", "patch": "@@ -23,7 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"dyn-string.h\"\n #include \"cpplib.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n@@ -149,6 +148,126 @@ typedef struct GTY(()) cp_token_cache {\n   cp_token * GTY ((skip)) last;\n } cp_token_cache;\n \n+/* The various kinds of non integral constant we encounter. */\n+typedef enum non_integral_constant {\n+  /* floating-point literal */\n+  NIC_FLOAT,\n+  /* %<this%> */\n+  NIC_THIS,\n+  /* %<__FUNCTION__%> */\n+  NIC_FUNC_NAME,\n+  /* %<__PRETTY_FUNCTION__%> */\n+  NIC_PRETTY_FUNC,\n+  /* %<__func__%> */\n+  NIC_C99_FUNC,\n+  /* \"%<va_arg%> */\n+  NIC_VA_ARG,\n+  /* a cast */\n+  NIC_CAST,\n+  /* %<typeid%> operator */\n+  NIC_TYPEID,\n+  /* non-constant compound literals */\n+  NIC_NCC,\n+  /* a function call */\n+  NIC_FUNC_CALL,\n+  /* an increment */\n+  NIC_INC,\n+  /* an decrement */\n+  NIC_DEC,\n+  /* an array reference */\n+  NIC_ARRAY_REF,\n+  /* %<->%> */\n+  NIC_ARROW,\n+  /* %<.%> */\n+  NIC_POINT,\n+  /* the address of a label */\n+  NIC_ADDR_LABEL,\n+  /* %<*%> */\n+  NIC_STAR,\n+  /* %<&%> */\n+  NIC_ADDR,\n+  /* %<++%> */\n+  NIC_PREINCREMENT,\n+  /* %<--%> */\n+  NIC_PREDECREMENT,\n+  /* %<new%> */\n+  NIC_NEW,\n+  /* %<delete%> */\n+  NIC_DEL,\n+  /* calls to overloaded operators */\n+  NIC_OVERLOADED,\n+  /* an assignment */\n+  NIC_ASSIGNMENT,\n+  /* a comma operator */\n+  NIC_COMMA,\n+  /* a call to a constructor */\n+  NIC_CONSTRUCTOR\n+} non_integral_constant;\n+\n+/* The various kinds of errors about name-lookup failing. */\n+typedef enum name_lookup_error {\n+  /* NULL */\n+  NLE_NULL,\n+  /* is not a type */\n+  NLE_TYPE,\n+  /* is not a class or namespace */\n+  NLE_CXX98,\n+  /* is not a class, namespace, or enumeration */\n+  NLE_NOT_CXX98\n+} name_lookup_error;\n+\n+/* The various kinds of required token */\n+typedef enum required_token {\n+  RT_SEMICOLON = 1,  /* ';' */\n+  RT_OPEN_PAREN, /* '(' */\n+  RT_CLOSE_BRACE, /* '}' */\n+  RT_OPEN_BRACE,  /* '{' */\n+  RT_CLOSE_SQUARE, /* ']' */\n+  RT_OPEN_SQUARE,  /* '[' */\n+  RT_COMMA, /* ',' */\n+  RT_SCOPE, /* '::' */\n+  RT_LESS, /* '<' */\n+  RT_GREATER, /* '>' */\n+  RT_EQ, /* '=' */\n+  RT_ELLIPSIS, /* '...' */\n+  RT_MULT, /* '*' */\n+  RT_COMPL, /* '~' */\n+  RT_COLON, /* ':' */\n+  RT_COLON_SCOPE, /* ':' or '::' */\n+  RT_CLOSE_PAREN, /* ')' */\n+  RT_COMMA_CLOSE_PAREN, /* ',' or ')' */\n+  RT_PRAGMA_EOL, /* end of line */\n+  RT_NAME, /* identifier */\n+\n+  /* The type is CPP_KEYWORD */\n+  RT_NEW, /* new */\n+  RT_DELETE, /* delete */\n+  RT_RETURN, /* return */\n+  RT_WHILE, /* while */\n+  RT_EXTERN, /* extern */\n+  RT_STATIC_ASSERT, /* static_assert */\n+  RT_DECLTYPE, /* decltype */\n+  RT_OPERATOR, /* operator */\n+  RT_CLASS, /* class */\n+  RT_TEMPLATE, /* template */\n+  RT_NAMESPACE, /* namespace */\n+  RT_USING, /* using */\n+  RT_ASM, /* asm */\n+  RT_TRY, /* try */\n+  RT_CATCH, /* catch */\n+  RT_THROW, /* throw */\n+  RT_LABEL, /* __label__ */\n+  RT_AT_TRY, /* @try */\n+  RT_AT_SYNCHRONIZED, /* @synchronized */\n+  RT_AT_THROW, /* @throw */\n+\n+  RT_SELECT,  /* selection-statement */\n+  RT_INTERATION, /* iteration-statement */\n+  RT_JUMP, /* jump-statement */\n+  RT_CLASS_KEY, /* class-key */\n+  RT_CLASS_TYPENAME_TEMPLATE /* class, typename, or template */\n+} required_token;\n+\n /* Prototypes.  */\n \n static cp_lexer *cp_lexer_new_main\n@@ -1972,10 +2091,12 @@ static void cp_parser_set_decl_spec_type\n   (cp_decl_specifier_seq *, tree, location_t, bool);\n static bool cp_parser_friend_p\n   (const cp_decl_specifier_seq *);\n+static void cp_parser_required_error\n+  (cp_parser *, required_token, bool);\n static cp_token *cp_parser_require\n-  (cp_parser *, enum cpp_ttype, const char *);\n+  (cp_parser *, enum cpp_ttype, required_token);\n static cp_token *cp_parser_require_keyword\n-  (cp_parser *, enum rid, const char *);\n+  (cp_parser *, enum rid, required_token);\n static bool cp_parser_token_starts_function_definition_p\n   (cp_token *);\n static bool cp_parser_next_token_starts_class_definition_p\n@@ -2011,7 +2132,7 @@ static bool cp_parser_uncommitted_to_tentative_parse_p\n static void cp_parser_error\n   (cp_parser *, const char *);\n static void cp_parser_name_lookup_error\n-  (cp_parser *, tree, tree, const char *, location_t);\n+  (cp_parser *, tree, tree, name_lookup_error, location_t);\n static bool cp_parser_simulate_error\n   (cp_parser *);\n static bool cp_parser_check_type_definition\n@@ -2021,7 +2142,7 @@ static void cp_parser_check_for_definition_in_return_type\n static void cp_parser_check_for_invalid_template_id\n   (cp_parser *, tree, location_t location);\n static bool cp_parser_non_integral_constant_expression\n-  (cp_parser *, const char *);\n+  (cp_parser *, non_integral_constant);\n static void cp_parser_diagnose_invalid_type_name\n   (cp_parser *, tree, tree, location_t);\n static bool cp_parser_parse_and_diagnose_invalid_type_name\n@@ -2088,7 +2209,7 @@ cp_parser_is_keyword (cp_token* token, enum rid keyword)\n    OTHER-TOKEN\".  */\n \n static void\n-cp_parser_error (cp_parser* parser, const char* message)\n+cp_parser_error (cp_parser* parser, const char* gmsgid)\n {\n   if (!cp_parser_simulate_error (parser))\n     {\n@@ -2105,7 +2226,7 @@ cp_parser_error (cp_parser* parser, const char* message)\n \t  return;\n \t}\n \n-      c_parse_error (message,\n+      c_parse_error (gmsgid,\n \t\t     /* Because c_parser_error does not understand\n \t\t\tCPP_KEYWORD, keywords are treated like\n \t\t\tidentifiers.  */\n@@ -2123,7 +2244,7 @@ static void\n cp_parser_name_lookup_error (cp_parser* parser,\n \t\t\t     tree name,\n \t\t\t     tree decl,\n-\t\t\t     const char* desired,\n+\t\t\t     name_lookup_error desired,\n \t\t\t     location_t location)\n {\n   /* If name lookup completely failed, tell the user that NAME was not\n@@ -2146,11 +2267,64 @@ cp_parser_name_lookup_error (cp_parser* parser,\n \terror_at (location, \"%qE has not been declared\", name);\n     }\n   else if (parser->scope && parser->scope != global_namespace)\n-    error_at (location, \"%<%E::%E%> %s\", parser->scope, name, desired);\n+    {\n+      switch (desired)\n+\t{\n+\t  case NLE_TYPE:\n+\t    error_at (location, \"%<%E::%E%> is not a type\",\n+\t    \t\t\tparser->scope, name);\n+\t    break;\n+\t  case NLE_CXX98:\n+\t    error_at (location, \"%<%E::%E%> is not a class or namespace\",\n+\t    \t\t\tparser->scope, name);\n+\t    break;\n+\t  case NLE_NOT_CXX98:\n+\t    error_at (location,\n+\t    \t      \"%<%E::%E%> is not a class, namespace, or enumeration\",\n+\t\t      parser->scope, name);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t    \n+\t}\n+    }\n   else if (parser->scope == global_namespace)\n-    error_at (location, \"%<::%E%> %s\", name, desired);\n+    {\n+      switch (desired)\n+\t{\n+\t  case NLE_TYPE:\n+\t    error_at (location, \"%<::%E%> is not a type\", name);\n+\t    break;\n+\t  case NLE_CXX98:\n+\t    error_at (location, \"%<::%E%> is not a class or namespace\", name);\n+\t    break;\n+\t  case NLE_NOT_CXX98:\n+\t    error_at (location,\n+\t\t      \"%<::%E%> is not a class, namespace, or enumeration\",\n+\t\t      name);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+    }\n   else\n-    error_at (location, \"%qE %s\", name, desired);\n+    {\n+      switch (desired)\n+\t{\n+\t  case NLE_TYPE:\n+\t    error_at (location, \"%qE is not a type\", name);\n+\t    break;\n+\t  case NLE_CXX98:\n+\t    error_at (location, \"%qE is not a class or namespace\", name);\n+\t    break;\n+\t  case NLE_NOT_CXX98:\n+\t    error_at (location,\n+\t\t      \"%qE is not a class, namespace, or enumeration\", name);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+    }\n }\n \n /* If we are parsing tentatively, remember that an error has occurred\n@@ -2302,20 +2476,112 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n \n static bool\n cp_parser_non_integral_constant_expression (cp_parser  *parser,\n-\t\t\t\t\t    const char *thing)\n+\t\t\t\t\t    non_integral_constant thing)\n {\n   parser->non_integral_constant_expression_p = true;\n   if (parser->integral_constant_expression_p)\n     {\n       if (!parser->allow_non_integral_constant_expression_p)\n \t{\n-\t  /* Don't use `%s' to print THING, because quotations (`%<', `%>')\n-\t     in the message need to be interpreted.  */\n-\t  char *message = concat (thing,\n-\t\t\t\t  \" cannot appear in a constant-expression\",\n-\t\t\t\t  NULL);\n-\t  error (message);\n-\t  free (message);\n+\t  const char *msg = NULL;\n+\t  switch (thing)\n+\t    {\n+  \t      case NIC_FLOAT:\n+\t\terror (\"floating-point literal \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_CAST:\n+\t\terror (\"a cast to a type other than an integral or \"\n+\t\t       \"enumeration type cannot appear in a \"\n+\t\t       \"constant-expression\");\n+\t\treturn true;\n+\t      case NIC_TYPEID:\n+\t\terror (\"%<typeid%> operator \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_NCC:\n+\t\terror (\"non-constant compound literals \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_FUNC_CALL:\n+\t\terror (\"a function call \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_INC:\n+\t\terror (\"an increment \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_DEC:\n+\t\terror (\"an decrement \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_ARRAY_REF:\n+\t\terror (\"an array reference \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_ADDR_LABEL:\n+\t\terror (\"the address of a label \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_OVERLOADED:\n+\t\terror (\"calls to overloaded operators \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_ASSIGNMENT:\n+\t\terror (\"an assignment cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_COMMA:\n+\t\terror (\"a comma operator \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_CONSTRUCTOR:\n+\t\terror (\"a call to a constructor \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n+\t      case NIC_THIS:\n+\t\tmsg = \"this\";\n+\t\tbreak;\n+\t      case NIC_FUNC_NAME:\n+\t\tmsg = \"__FUNCTION__\";\n+\t\tbreak;\n+  \t      case NIC_PRETTY_FUNC:\n+\t\tmsg = \"__PRETTY_FUNCTION__\";\n+\t\tbreak;\n+\t      case NIC_C99_FUNC:\n+\t\tmsg = \"__func__\";\n+\t\tbreak;\n+\t      case NIC_VA_ARG:\n+\t\tmsg = \"va_arg\";\n+\t\tbreak;\n+\t      case NIC_ARROW:\n+\t\tmsg = \"->\";\n+\t\tbreak;\n+\t      case NIC_POINT:\n+\t\tmsg = \".\";\n+\t\tbreak;\n+\t      case NIC_STAR:\n+\t\tmsg = \"*\";\n+\t\tbreak;\n+\t      case NIC_ADDR:\n+\t\tmsg = \"&\";\n+\t\tbreak;\n+\t      case NIC_PREINCREMENT:\n+\t\tmsg = \"++\";\n+\t\tbreak;\n+\t      case NIC_PREDECREMENT:\n+\t\tmsg = \"--\";\n+\t\tbreak;\n+\t      case NIC_NEW:\n+\t\tmsg = \"new\";\n+\t\tbreak;\n+\t      case NIC_DEL:\n+\t\tmsg = \"delete\";\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  if (msg)\n+\t    error (\"%qs cannot appear in a constant-expression\", msg);\n \t  return true;\n \t}\n     }\n@@ -2638,7 +2904,7 @@ static void\n cp_parser_consume_semicolon_at_end_of_statement (cp_parser *parser)\n {\n   /* Look for the trailing `;'.  */\n-  if (!cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\"))\n+  if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n     {\n       /* If there is additional (erroneous) input, skip to the end of\n \t the statement.  */\n@@ -2766,7 +3032,7 @@ static void\n cp_parser_require_pragma_eol (cp_parser *parser, cp_token *pragma_tok)\n {\n   parser->lexer->in_pragma = false;\n-  if (!cp_parser_require (parser, CPP_PRAGMA_EOL, \"end of line\"))\n+  if (!cp_parser_require (parser, CPP_PRAGMA_EOL, RT_PRAGMA_EOL))\n     cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n }\n \n@@ -2934,7 +3200,7 @@ cp_parser_identifier (cp_parser* parser)\n   cp_token *token;\n \n   /* Look for the identifier.  */\n-  token = cp_parser_require (parser, CPP_NAME, \"identifier\");\n+  token = cp_parser_require (parser, CPP_NAME, RT_NAME);\n   /* Return the value.  */\n   return token ? token->u.value : error_mark_node;\n }\n@@ -3253,8 +3519,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t     checked at that point.  If we are not within a cast, then\n \t     this code is invalid.  */\n \t  if (!cast_p)\n-\t    cp_parser_non_integral_constant_expression\n-\t      (parser, \"floating-point literal\");\n+\t    cp_parser_non_integral_constant_expression (parser, NIC_FLOAT);\n \t}\n       return token->u.value;\n \n@@ -3332,7 +3597,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tparser->greater_than_is_operator_p\n \t  = saved_greater_than_is_operator_p;\n \t/* Consume the `)'.  */\n-\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \t  cp_parser_skip_to_end_of_statement (parser);\n \n \treturn expr;\n@@ -3383,7 +3648,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      return error_mark_node;\n \t    }\n \t  /* Pointers cannot appear in constant-expressions.  */\n-\t  if (cp_parser_non_integral_constant_expression (parser, \"%<this%>\"))\n+\t  if (cp_parser_non_integral_constant_expression (parser, NIC_THIS))\n \t    return error_mark_node;\n \t  return finish_this_expr ();\n \n@@ -3396,7 +3661,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_PRETTY_FUNCTION_NAME:\n \tcase RID_C99_FUNCTION_NAME:\n \t  {\n-\t    const char *name;\n+\t    non_integral_constant name;\n \n \t    /* The symbols __FUNCTION__, __PRETTY_FUNCTION__, and\n \t       __func__ are the names of variables -- but they are\n@@ -3410,13 +3675,13 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    switch (token->keyword)\n \t      {\n \t      case RID_FUNCTION_NAME:\n-\t\tname = \"%<__FUNCTION__%>\";\n+\t\tname = NIC_FUNC_NAME;\n \t\tbreak;\n \t      case RID_PRETTY_FUNCTION_NAME:\n-\t\tname = \"%<__PRETTY_FUNCTION__%>\";\n+\t\tname = NIC_PRETTY_FUNC;\n \t\tbreak;\n \t      case RID_C99_FUNCTION_NAME:\n-\t\tname = \"%<__func__%>\";\n+\t\tname = NIC_C99_FUNC;\n \t\tbreak;\n \t      default:\n \t\tgcc_unreachable ();\n@@ -3438,20 +3703,19 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       `va_arg'.  Consume the `__builtin_va_arg' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Look for the opening `('.  */\n-\t    cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+\t    cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \t    /* Now, parse the assignment-expression.  */\n \t    expression = cp_parser_assignment_expression (parser,\n \t\t\t\t\t\t\t  /*cast_p=*/false, NULL);\n \t    /* Look for the `,'.  */\n-\t    cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+\t    cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \t    /* Parse the type-id.  */\n \t    type = cp_parser_type_id (parser);\n \t    /* Look for the closing `)'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t    /* Using `va_arg' in a constant-expression is not\n \t       allowed.  */\n-\t    if (cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\t    \"%<va_arg%>\"))\n+\t    if (cp_parser_non_integral_constant_expression (parser,NIC_VA_ARG))\n \t      return error_mark_node;\n \t    return build_x_va_arg (expression, type);\n \t  }\n@@ -4204,7 +4468,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n                                        type_p,\n                                        is_declaration);\n       /* Look for the `::' token.  */\n-      cp_parser_require (parser, CPP_SCOPE, \"%<::%>\");\n+      cp_parser_require (parser, CPP_SCOPE, RT_SCOPE);\n \n       /* If we found what we wanted, we keep going; otherwise, we're\n \t done.  */\n@@ -4257,12 +4521,14 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t}\n \t\t      else\n                         {\n-                          const char* msg = \"is not a class or namespace\";\n                           if (cxx_dialect != cxx98)\n-                            msg = \"is not a class, namespace, or enumeration\";\n-                          cp_parser_name_lookup_error\n-                            (parser, token->u.value, decl, msg,\n+                            cp_parser_name_lookup_error\n+                            (parser, token->u.value, decl, NLE_NOT_CXX98,\n \t  \t\t     token->location);\n+\t\t\t  else\n+\t\t\t    cp_parser_name_lookup_error\n+\t\t\t    (parser, token->u.value, decl, NLE_CXX98,\n+\t\t\t     token->location);\n                         }\n \t\t    }\n \t\t  parser->scope = error_mark_node;\n@@ -4560,26 +4826,23 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  = G_(\"types may not be defined in casts\");\n \n \t/* Look for the opening `<'.  */\n-\tcp_parser_require (parser, CPP_LESS, \"%<<%>\");\n+\tcp_parser_require (parser, CPP_LESS, RT_LESS);\n \t/* Parse the type to which we are casting.  */\n \ttype = cp_parser_type_id (parser);\n \t/* Look for the closing `>'.  */\n-\tcp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n+\tcp_parser_require (parser, CPP_GREATER, RT_GREATER);\n \t/* Restore the old message.  */\n \tparser->type_definition_forbidden_message = saved_message;\n \n \t/* And the expression which is being cast.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \texpression = cp_parser_expression (parser, /*cast_p=*/true, & idk);\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n \t/* Only type conversions to integral or enumeration types\n \t   can be used in constant-expressions.  */\n \tif (!cast_valid_in_integral_constant_expression_p (type)\n-\t    && (cp_parser_non_integral_constant_expression\n-\t\t(parser,\n-\t\t \"a cast to a type other than an integral or \"\n-\t\t \"enumeration type\")))\n+\t    && (cp_parser_non_integral_constant_expression (parser, NIC_CAST)))\n \t  return error_mark_node;\n \n \tswitch (keyword)\n@@ -4616,7 +4879,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* Consume the `typeid' token.  */\n \tcp_lexer_consume_token (parser->lexer);\n \t/* Look for the `(' token.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \t/* Types cannot be defined in a `typeid' expression.  */\n \tsaved_message = parser->type_definition_forbidden_message;\n \tparser->type_definition_forbidden_message\n@@ -4632,7 +4895,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* Look for the `)' token.  Otherwise, we can't be sure that\n \t   we're not looking at an expression: consider `typeid (int\n \t   (3))', for example.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t/* If all went well, simply lookup the type-id.  */\n \tif (cp_parser_parse_definitely (parser))\n \t  postfix_expression = get_typeid (type);\n@@ -4646,13 +4909,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    /* Compute its typeid.  */\n \t    postfix_expression = build_typeid (expression);\n \t    /* Look for the `)' token.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t  }\n \t/* Restore the saved message.  */\n \tparser->type_definition_forbidden_message = saved_message;\n \t/* `typeid' may not appear in an integral constant expression.  */\n-\tif (cp_parser_non_integral_constant_expression(parser,\n-\t\t\t\t\t\t       \"%<typeid%> operator\"))\n+\tif (cp_parser_non_integral_constant_expression(parser, NIC_TYPEID))\n \t  return error_mark_node;\n       }\n       break;\n@@ -4707,9 +4969,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    type = cp_parser_type_id (parser);\n \t    parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t    /* Look for the `)'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t    /* Look for the `{'.  */\n-\t    cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n+\t    cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n \t    /* If things aren't going well, there's no need to\n \t       keep going.  */\n \t    if (!cp_parser_error_occurred (parser))\n@@ -4722,7 +4984,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\tif (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t/* Look for the final `}'.  */\n-\t\tcp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+\t\tcp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \t      }\n \t    /* If that worked, we're definitely looking at a\n \t       compound-literal expression.  */\n@@ -4740,8 +5002,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t   currently accepted programs.  (Of course, as\n \t\t   compound literals are not part of ISO C++, the\n \t\t   standard has nothing to say.)  */\n-\t\tif (cp_parser_non_integral_constant_expression \n-\t\t    (parser, \"non-constant compound literals\"))\n+\t\tif (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t\tNIC_NCC))\n \t\t  {\n \t\t    postfix_expression = error_mark_node;\n \t\t    break;\n@@ -4833,7 +5095,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t       constant-expressions.  */\n \t    if (! builtin_valid_in_constant_expr_p (postfix_expression)\n \t\t&& cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\t       \"a function call\"))\n+\t\t\t\t\t\t\t       NIC_FUNC_CALL))\n \t      {\n \t\tpostfix_expression = error_mark_node;\n \t\trelease_tree_vector (args);\n@@ -4971,8 +5233,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    = finish_increment_expr (postfix_expression,\n \t\t\t\t     POSTINCREMENT_EXPR);\n \t  /* Increments may not appear in constant-expressions.  */\n-\t  if (cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\t  \"an increment\"))\n+\t  if (cp_parser_non_integral_constant_expression (parser, NIC_INC))\n \t    postfix_expression = error_mark_node;\n \t  idk = CP_ID_KIND_NONE;\n           is_member_access = false;\n@@ -4987,8 +5248,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    = finish_increment_expr (postfix_expression,\n \t\t\t\t     POSTDECREMENT_EXPR);\n \t  /* Decrements may not appear in constant-expressions.  */\n-\t  if (cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\t  \"a decrement\"))\n+\t  if (cp_parser_non_integral_constant_expression (parser, NIC_DEC))\n \t    postfix_expression = error_mark_node;\n \t  idk = CP_ID_KIND_NONE;\n           is_member_access = false;\n@@ -5041,16 +5301,15 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n     index = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \n   /* Look for the closing `]'.  */\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \n   /* Build the ARRAY_REF.  */\n   postfix_expression = grok_array_decl (postfix_expression, index);\n \n   /* When not doing offsetof, array references are not permitted in\n      constant-expressions.  */\n   if (!for_offsetof\n-      && (cp_parser_non_integral_constant_expression\n-\t  (parser, \"an array reference\")))\n+      && (cp_parser_non_integral_constant_expression (parser, NIC_ARRAY_REF)))\n     postfix_expression = error_mark_node;\n \n   return postfix_expression;\n@@ -5225,7 +5484,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n      constant-expressions.  */\n   if (!for_offsetof\n       && (cp_parser_non_integral_constant_expression\n-\t  (parser, token_type == CPP_DEREF ? \"%<->%>\" : \"%<.%>\")))\n+\t  (parser, token_type == CPP_DEREF ? NIC_ARROW : NIC_POINT)))\n     postfix_expression = error_mark_node;\n \n   return postfix_expression;\n@@ -5273,7 +5532,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n   if (non_constant_p)\n     *non_constant_p = false;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return NULL;\n \n   expression_list = make_tree_vector ();\n@@ -5364,7 +5623,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \tcp_lexer_consume_token (parser->lexer);\n       }\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     {\n       int ending;\n \n@@ -5439,7 +5698,7 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n \t\t\t     /*check_dependency_p=*/false,\n \t\t\t     /*is_declaration=*/true);\n       /* Look for the `::' token.  */\n-      cp_parser_require (parser, CPP_SCOPE, \"%<::%>\");\n+      cp_parser_require (parser, CPP_SCOPE, RT_SCOPE);\n     }\n   /* If the next token is not a `~', then there might be some\n      additional qualification.  */\n@@ -5465,13 +5724,13 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n \treturn;\n \n       /* Look for the `::' token.  */\n-      cp_parser_require (parser, CPP_SCOPE, \"%<::%>\");\n+      cp_parser_require (parser, CPP_SCOPE, RT_SCOPE);\n     }\n   else\n     *scope = NULL_TREE;\n \n   /* Look for the `~'.  */\n-  cp_parser_require (parser, CPP_COMPL, \"%<~%>\");\n+  cp_parser_require (parser, CPP_COMPL, RT_COMPL);\n   /* Look for the type-name again.  We are not responsible for\n      checking that it matches the first type-name.  */\n   *type = cp_parser_nonclass_name (parser);\n@@ -5627,7 +5886,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  /* Create an expression representing the address.  */\n \t  expression = finish_label_address_expr (identifier, loc);\n \t  if (cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\"the address of a label\"))\n+\t\t\t\t\t\t\t  NIC_ADDR_LABEL))\n \t    expression = error_mark_node;\n \t  return expression;\n \t}\n@@ -5636,7 +5895,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n     {\n       tree cast_expression;\n       tree expression = error_mark_node;\n-      const char *non_constant_p = NULL;\n+      non_integral_constant non_constant_p = 0;\n \n       /* Consume the operator token.  */\n       token = cp_lexer_consume_token (parser->lexer);\n@@ -5649,13 +5908,13 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n       switch (unary_operator)\n \t{\n \tcase INDIRECT_REF:\n-\t  non_constant_p = \"%<*%>\";\n+\t  non_constant_p = NIC_STAR;\n \t  expression = build_x_indirect_ref (cast_expression, RO_UNARY_STAR,\n                                              tf_warning_or_error);\n \t  break;\n \n \tcase ADDR_EXPR:\n-\t  non_constant_p = \"%<&%>\";\n+\t   non_constant_p = NIC_ADDR;\n \t  /* Fall through.  */\n \tcase BIT_NOT_EXPR:\n \t  expression = build_x_unary_op (unary_operator, cast_expression,\n@@ -5664,8 +5923,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n \tcase PREINCREMENT_EXPR:\n \tcase PREDECREMENT_EXPR:\n-\t  non_constant_p = (unary_operator == PREINCREMENT_EXPR\n-\t\t\t    ? \"%<++%>\" : \"%<--%>\");\n+\t  non_constant_p = unary_operator == PREINCREMENT_EXPR\n+\t\t\t   ? NIC_PREINCREMENT : NIC_PREDECREMENT;\n \t  /* Fall through.  */\n \tcase UNARY_PLUS_EXPR:\n \tcase NEGATE_EXPR:\n@@ -5745,7 +6004,7 @@ cp_parser_new_expression (cp_parser* parser)\n \t\t\t\t   /*current_scope_valid_p=*/false)\n        != NULL_TREE);\n   /* Look for the `new' operator.  */\n-  cp_parser_require_keyword (parser, RID_NEW, \"%<new%>\");\n+  cp_parser_require_keyword (parser, RID_NEW, RT_NEW);\n   /* There's no easy way to tell a new-placement from the\n      `( type-id )' construct.  */\n   cp_parser_parse_tentatively (parser);\n@@ -5769,7 +6028,7 @@ cp_parser_new_expression (cp_parser* parser)\n       /* Parse the type-id.  */\n       type = cp_parser_type_id (parser);\n       /* Look for the closing `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n       token = cp_lexer_peek_token (parser->lexer);\n       /* There should not be a direct-new-declarator in this production,\n \t but GCC used to allowed this, so we check and emit a sensible error\n@@ -5797,7 +6056,7 @@ cp_parser_new_expression (cp_parser* parser)\n \n   /* A new-expression may not appear in an integral constant\n      expression.  */\n-  if (cp_parser_non_integral_constant_expression (parser, \"%<new%>\"))\n+  if (cp_parser_non_integral_constant_expression (parser, NIC_NEW))\n     ret = error_mark_node;\n   else\n     {\n@@ -5963,7 +6222,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       tree expression;\n \n       /* Look for the opening `['.  */\n-      cp_parser_require (parser, CPP_OPEN_SQUARE, \"%<[%>\");\n+      cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);\n       /* The first expression is not required to be constant.  */\n       if (!declarator)\n \t{\n@@ -5997,7 +6256,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t\t\t\t\t   /*allow_non_constant=*/false,\n \t\t\t\t\t   NULL);\n       /* Look for the closing `]'.  */\n-      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+      cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \n       /* Add this bound to the declarator.  */\n       declarator = make_array_declarator (declarator, expression);\n@@ -6063,14 +6322,14 @@ cp_parser_delete_expression (cp_parser* parser)\n \t\t\t\t   /*current_scope_valid_p=*/false)\n        != NULL_TREE);\n   /* Look for the `delete' keyword.  */\n-  cp_parser_require_keyword (parser, RID_DELETE, \"%<delete%>\");\n+  cp_parser_require_keyword (parser, RID_DELETE, RT_DELETE);\n   /* See if the array syntax is in use.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n     {\n       /* Consume the `[' token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the `]' token.  */\n-      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+      cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n       /* Remember that this is the `[]' construct.  */\n       array_p = true;\n     }\n@@ -6082,7 +6341,7 @@ cp_parser_delete_expression (cp_parser* parser)\n \n   /* A delete-expression may not appear in an integral constant\n      expression.  */\n-  if (cp_parser_non_integral_constant_expression (parser, \"%<delete%>\"))\n+  if (cp_parser_non_integral_constant_expression (parser, NIC_DEL))\n     return error_mark_node;\n \n   return delete_sanity (expression, NULL_TREE, array_p, global_scope_p);\n@@ -6215,7 +6474,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  /* Look for the type-id.  */\n \t  type = cp_parser_type_id (parser);\n \t  /* Look for the closing `)'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t  parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t}\n \n@@ -6244,10 +6503,8 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  /* Only type conversions to integral or enumeration types\n \t     can be used in constant-expressions.  */\n \t  if (!cast_valid_in_integral_constant_expression_p (type)\n-\t      && (cp_parser_non_integral_constant_expression\n-\t\t  (parser,\n-\t\t   \"a cast to a type other than an integral or \"\n-\t\t   \"enumeration type\")))\n+\t      && (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t      NIC_CAST)))\n \t    return error_mark_node;\n \n \t  /* Perform the cast.  */\n@@ -6482,8 +6739,8 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t least one of the operands is of enumeration type.  */\n \n       if (overloaded_p\n-\t  && (cp_parser_non_integral_constant_expression\n-\t      (parser, \"calls to overloaded operators\")))\n+\t  && (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t  NIC_OVERLOADED)))\n \treturn error_mark_node;\n     }\n \n@@ -6530,7 +6787,7 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n     }\n \n   /* The next token should be a `:'.  */\n-  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n+  cp_parser_require (parser, CPP_COLON, RT_COLON);\n   /* Parse the assignment-expression.  */\n   assignment_expr = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n   c_inhibit_evaluation_warnings -= logical_or_expr == truthvalue_true_node;\n@@ -6595,7 +6852,7 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n \t      /* An assignment may not appear in a\n \t\t constant-expression.  */\n \t      if (cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\t      \"an assignment\"))\n+\t\t\t\t\t\t\t      NIC_ASSIGNMENT))\n \t\treturn error_mark_node;\n \t      /* Build the assignment expression.  */\n \t      expr = build_x_modify_expr (expr,\n@@ -6730,8 +6987,7 @@ cp_parser_expression (cp_parser* parser, bool cast_p, cp_id_kind * pidk)\n       /* Consume the `,'.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* A comma operator cannot appear in a constant-expression.  */\n-      if (cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t      \"a comma operator\"))\n+      if (cp_parser_non_integral_constant_expression (parser, NIC_COMMA))\n \texpression = error_mark_node;\n     }\n \n@@ -6837,11 +7093,11 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   /* Consume the \"__builtin_offsetof\" token.  */\n   cp_lexer_consume_token (parser->lexer);\n   /* Consume the opening `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   /* Parse the type-id.  */\n   type = cp_parser_type_id (parser);\n   /* Look for the `,'.  */\n-  cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+  cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n   token = cp_lexer_peek_token (parser->lexer);\n \n   /* Build the (type *)null that begins the traditional offsetof macro.  */\n@@ -6882,7 +7138,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \tdefault:\n \t  /* Error.  We know the following require will fail, but\n \t     that gives the proper error message.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t  cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n \t  expr = error_mark_node;\n \t  goto failure;\n@@ -6982,7 +7238,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n   /* Consume the token.  */\n   cp_lexer_consume_token (parser->lexer);\n \n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n   type1 = cp_parser_type_id (parser);\n \n@@ -6999,7 +7255,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n \n   if (binary)\n     {\n-      cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+      cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n  \n       type2 = cp_parser_type_id (parser);\n \n@@ -7015,7 +7271,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n \t\t\t      /*initialized=*/0, /*attrlist=*/NULL);\n     }\n \n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   /* Complete the trait expression, which may mean either processing\n      the trait expr now or saving it for template instantiation.  */\n@@ -7184,7 +7440,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n   bool first = true;\n \n   /* Eat the leading `['.  */\n-  cp_parser_require (parser, CPP_OPEN_SQUARE, \"%<[%>\");\n+  cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);\n \n   /* Record default capture mode.  \"[&\" \"[=\" \"[&,\" \"[=,\"  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_AND)\n@@ -7223,7 +7479,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n       if (first)\n \tfirst = false;\n       else\n-\tcp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+\tcp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \n       /* Possibly capture `this'.  */\n       if (cp_lexer_next_token_is_keyword (parser->lexer, RID_THIS))\n@@ -7318,7 +7574,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t\t   explicit_init_p);\n     }\n \n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n }\n \n /* Parse the (optional) middle of a lambda expression.\n@@ -7363,7 +7619,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t  pedwarn (DECL_SOURCE_LOCATION (TREE_VALUE (t)), OPT_pedantic,\n \t\t   \"default argument specified for lambda parameter\");\n \n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n       attributes = cp_parser_attributes_opt (parser);\n \n@@ -7497,13 +7753,13 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n \t   statement.  */\n \tcp_parser_parse_tentatively (parser);\n \n-\tcp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n-\tcp_parser_require_keyword (parser, RID_RETURN, \"%<return%>\");\n+\tcp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n+\tcp_parser_require_keyword (parser, RID_RETURN, RT_RETURN);\n \n \texpr = cp_parser_expression (parser, /*cast_p=*/false, &idk);\n \n-\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n-\tcp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+\tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+\tcp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \n \tif (cp_parser_parse_definitely (parser))\n \t  {\n@@ -7780,7 +8036,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n     }\n \n   /* Require the `:' token.  */\n-  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n+  cp_parser_require (parser, CPP_COLON, RT_COLON);\n \n   /* An ordinary label may optionally be followed by attributes.\n      However, this is only permitted if the attributes are then\n@@ -7884,7 +8140,7 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n   tree compound_stmt;\n \n   /* Consume the `{'.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n     return error_mark_node;\n   /* Begin the compound-statement.  */\n   compound_stmt = begin_compound_stmt (in_try ? BCS_TRY_BLOCK : 0);\n@@ -7896,7 +8152,7 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n   /* Finish the compound-statement.  */\n   finish_compound_stmt (compound_stmt);\n   /* Consume the `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \n   return compound_stmt;\n }\n@@ -7963,7 +8219,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n     *if_p = false;\n \n   /* Peek at the next token.  */\n-  token = cp_parser_require (parser, CPP_KEYWORD, \"selection-statement\");\n+  token = cp_parser_require (parser, CPP_KEYWORD, RT_SELECT);\n \n   /* See what kind of keyword it is.  */\n   keyword = token->keyword;\n@@ -7976,7 +8232,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \ttree condition;\n \n \t/* Look for the `('.  */\n-\tif (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+\tif (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n \t  {\n \t    cp_parser_skip_to_end_of_statement (parser);\n \t    return error_mark_node;\n@@ -7991,7 +8247,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t/* Parse the condition.  */\n \tcondition = cp_parser_condition (parser);\n \t/* Look for the `)'.  */\n-\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \t  cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t\t /*consume_paren=*/true);\n \n@@ -8186,7 +8442,7 @@ cp_parser_condition (cp_parser* parser)\n \t  else\n \t    {\n \t      /* Consume the `='.  */\n-\t      cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n+\t      cp_parser_require (parser, CPP_EQ, RT_EQ);\n \t      initializer = cp_parser_initializer_clause (parser, &non_constant_p);\n \t    }\n \t  if (BRACE_ENCLOSED_INITIALIZER_P (initializer))\n@@ -8235,7 +8491,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n   unsigned char in_statement;\n \n   /* Peek at the next token.  */\n-  token = cp_parser_require (parser, CPP_KEYWORD, \"iteration-statement\");\n+  token = cp_parser_require (parser, CPP_KEYWORD, RT_INTERATION);\n   if (!token)\n     return error_mark_node;\n \n@@ -8254,12 +8510,12 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Begin the while-statement.  */\n \tstatement = begin_while_stmt ();\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \t/* Parse the condition.  */\n \tcondition = cp_parser_condition (parser);\n \tfinish_while_stmt_cond (condition, statement);\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t/* Parse the dependent statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n \tcp_parser_already_scoped_statement (parser);\n@@ -8281,17 +8537,17 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tparser->in_statement = in_statement;\n \tfinish_do_body (statement);\n \t/* Look for the `while' keyword.  */\n-\tcp_parser_require_keyword (parser, RID_WHILE, \"%<while%>\");\n+\tcp_parser_require_keyword (parser, RID_WHILE, RT_WHILE);\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \t/* Parse the expression.  */\n \texpression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \t/* We're done with the do-statement.  */\n \tfinish_do_stmt (expression, statement);\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t/* Look for the `;'.  */\n-\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+\tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       }\n       break;\n \n@@ -8303,7 +8559,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Begin the for-statement.  */\n \tstatement = begin_for_stmt ();\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \t/* Parse the initialization.  */\n \tcp_parser_for_init_statement (parser);\n \tfinish_for_init_stmt (statement);\n@@ -8313,14 +8569,14 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t  condition = cp_parser_condition (parser);\n \tfinish_for_cond (condition, statement);\n \t/* Look for the `;'.  */\n-\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+\tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n \t/* If there's an expression, process it.  */\n \tif (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n \t  expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \tfinish_for_expr (expression, statement);\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n \t/* Parse the body of the for-statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n@@ -8398,7 +8654,7 @@ cp_parser_jump_statement (cp_parser* parser)\n   unsigned char in_statement;\n \n   /* Peek at the next token.  */\n-  token = cp_parser_require (parser, CPP_KEYWORD, \"jump-statement\");\n+  token = cp_parser_require (parser, CPP_KEYWORD, RT_JUMP);\n   if (!token)\n     return error_mark_node;\n \n@@ -8425,7 +8681,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t  error_at (token->location, \"break statement used with OpenMP for loop\");\n \t  break;\n \t}\n-      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       break;\n \n     case RID_CONTINUE:\n@@ -8444,7 +8700,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       break;\n \n     case RID_RETURN:\n@@ -8466,7 +8722,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t/* Build the return-statement.  */\n \tstatement = finish_return_stmt (expr);\n \t/* Look for the final `;'.  */\n-\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+\tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       }\n       break;\n \n@@ -8484,7 +8740,7 @@ cp_parser_jump_statement (cp_parser* parser)\n       else\n \tfinish_goto_stmt (cp_parser_identifier (parser));\n       /* Look for the final `;'.  */\n-      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       break;\n \n     default:\n@@ -8582,13 +8838,13 @@ cp_parser_already_scoped_statement (cp_parser* parser)\n     {\n       /* Avoid calling cp_parser_compound_statement, so that we\n \t don't create a new scope.  Do everything else by hand.  */\n-      cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n+      cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n       /* If the next keyword is `__label__' we have a label declaration.  */\n       while (cp_lexer_next_token_is_keyword (parser->lexer, RID_LABEL))\n \tcp_parser_label_declaration (parser);\n       /* Parse an (optional) statement-seq.  */\n       cp_parser_statement_seq_opt (parser, NULL_TREE);\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n     }\n }\n \n@@ -9033,7 +9289,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n     }\n \n   /* Consume the `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n  done:\n   pop_deferring_access_checks ();\n@@ -9400,7 +9656,7 @@ cp_parser_linkage_specification (cp_parser* parser)\n   tree linkage;\n \n   /* Look for the `extern' keyword.  */\n-  cp_parser_require_keyword (parser, RID_EXTERN, \"%<extern%>\");\n+  cp_parser_require_keyword (parser, RID_EXTERN, RT_EXTERN);\n \n   /* Look for the string-literal.  */\n   linkage = cp_parser_string_literal (parser, false, false);\n@@ -9430,7 +9686,7 @@ cp_parser_linkage_specification (cp_parser* parser)\n       /* Parse the declarations.  */\n       cp_parser_declaration_seq_opt (parser);\n       /* Look for the closing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n     }\n   /* Otherwise, there's just one declaration.  */\n   else\n@@ -9471,7 +9727,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n \n   /* Look for the `static_assert' keyword.  */\n   if (!cp_parser_require_keyword (parser, RID_STATIC_ASSERT, \n-                                  \"%<static_assert%>\"))\n+                                  RT_STATIC_ASSERT))\n     return;\n \n   /*  We know we are in a static assertion; commit to any tentative\n@@ -9480,7 +9736,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n     cp_parser_commit_to_tentative_parse (parser);\n \n   /* Parse the `(' starting the static assertion condition.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n   /* Parse the constant-expression.  */\n   condition = \n@@ -9489,22 +9745,22 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n                                    /*non_constant_p=*/NULL);\n \n   /* Parse the separating `,'.  */\n-  cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+  cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \n   /* Parse the string-literal message.  */\n   message = cp_parser_string_literal (parser, \n                                       /*translate=*/false,\n                                       /*wide_ok=*/true);\n \n   /* A `)' completes the static assertion.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     cp_parser_skip_to_closing_parenthesis (parser, \n                                            /*recovering=*/true, \n                                            /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n \n   /* A semicolon terminates the declaration.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n   /* Complete the static assertion, which may mean either processing \n      the static assert now or saving it for template instantiation.  */\n@@ -9527,7 +9783,7 @@ cp_parser_decltype (cp_parser *parser)\n   cp_token *id_expr_start_token;\n \n   /* Look for the `decltype' token.  */\n-  if (!cp_parser_require_keyword (parser, RID_DECLTYPE, \"%<decltype%>\"))\n+  if (!cp_parser_require_keyword (parser, RID_DECLTYPE, RT_DECLTYPE))\n     return error_mark_node;\n \n   /* Types cannot be defined in a `decltype' expression.  Save away the\n@@ -9553,7 +9809,7 @@ cp_parser_decltype (cp_parser *parser)\n   ++c_inhibit_evaluation_warnings;\n \n   /* Parse the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return error_mark_node;\n   \n   /* First, try parsing an id-expression.  */\n@@ -9687,7 +9943,7 @@ cp_parser_decltype (cp_parser *parser)\n     }\n   \n   /* Parse to the closing `)'.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     {\n       cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t     /*consume_paren=*/true);\n@@ -9716,7 +9972,7 @@ cp_parser_conversion_function_id (cp_parser* parser)\n   tree pushed_scope = NULL_TREE;\n \n   /* Look for the `operator' token.  */\n-  if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"%<operator%>\"))\n+  if (!cp_parser_require_keyword (parser, RID_OPERATOR, RT_OPERATOR))\n     return error_mark_node;\n   /* When we parse the conversion-type-id, the current scope will be\n      reset.  However, we need that information in able to look up the\n@@ -10092,7 +10348,7 @@ static tree\n cp_parser_operator_function_id (cp_parser* parser)\n {\n   /* Look for the `operator' keyword.  */\n-  if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"%<operator%>\"))\n+  if (!cp_parser_require_keyword (parser, RID_OPERATOR, RT_OPERATOR))\n     return error_mark_node;\n   /* And then the name of the operator itself.  */\n   return cp_parser_operator (parser);\n@@ -10148,7 +10404,7 @@ cp_parser_operator (cp_parser* parser)\n \t    /* Consume the `[' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Look for the `]' token.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+\t    cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \t    id = ansi_opname (op == NEW_EXPR\n \t\t\t      ? VEC_NEW_EXPR : VEC_DELETE_EXPR);\n \t  }\n@@ -10307,14 +10563,14 @@ cp_parser_operator (cp_parser* parser)\n       /* Consume the `('.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the matching `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n       return ansi_opname (CALL_EXPR);\n \n     case CPP_OPEN_SQUARE:\n       /* Consume the `['.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the matching `]'.  */\n-      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+      cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n       return ansi_opname (ARRAY_REF);\n \n     default:\n@@ -10602,8 +10858,7 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n   tree parameter;\n \n   /* Look for a keyword to tell us what kind of parameter this is.  */\n-  token = cp_parser_require (parser, CPP_KEYWORD,\n-\t\t\t     \"%<class%>, %<typename%>, or %<template%>\");\n+  token = cp_parser_require (parser, CPP_KEYWORD, RT_CLASS_TYPENAME_TEMPLATE);\n   if (!token)\n     return error_mark_node;\n \n@@ -10676,13 +10931,13 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \ttree default_argument;\n \n \t/* Look for the `<'.  */\n-\tcp_parser_require (parser, CPP_LESS, \"%<<%>\");\n+\tcp_parser_require (parser, CPP_LESS, RT_LESS);\n \t/* Parse the template-parameter-list.  */\n \tcp_parser_template_parameter_list (parser);\n \t/* Look for the `>'.  */\n-\tcp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n+\tcp_parser_require (parser, CPP_GREATER, RT_GREATER);\n \t/* Look for the `class' keyword.  */\n-\tcp_parser_require_keyword (parser, RID_CLASS, \"%<class%>\");\n+\tcp_parser_require_keyword (parser, RID_CLASS, RT_CLASS);\n         /* If the next token is an ellipsis, we have a template\n            argument pack. */\n         if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n@@ -10919,7 +11174,7 @@ cp_parser_template_id (cp_parser *parser,\n   else\n     {\n       /* Look for the `<' that starts the template-argument-list.  */\n-      if (!cp_parser_require (parser, CPP_LESS, \"%<<%>\"))\n+      if (!cp_parser_require (parser, CPP_LESS, RT_LESS))\n \t{\n \t  pop_deferring_access_checks ();\n \t  return error_mark_node;\n@@ -11553,7 +11808,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n     }\n \n   /* Look for the `template' keyword.  */\n-  cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\");\n+  cp_parser_require_keyword (parser, RID_TEMPLATE, RT_TEMPLATE);\n   /* Let the front end know that we are processing an explicit\n      instantiation.  */\n   begin_explicit_instantiation ();\n@@ -11638,11 +11893,11 @@ cp_parser_explicit_specialization (cp_parser* parser)\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n   /* Look for the `template' keyword.  */\n-  cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\");\n+  cp_parser_require_keyword (parser, RID_TEMPLATE, RT_TEMPLATE);\n   /* Look for the `<'.  */\n-  cp_parser_require (parser, CPP_LESS, \"%<<%>\");\n+  cp_parser_require (parser, CPP_LESS, RT_LESS);\n   /* Look for the `>'.  */\n-  cp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n+  cp_parser_require (parser, CPP_GREATER, RT_GREATER);\n   /* We have processed another parameter list.  */\n   ++parser->num_template_parameter_lists;\n   /* [temp]\n@@ -12219,7 +12474,7 @@ cp_parser_nonclass_name (cp_parser* parser)\n     {\n       if (!cp_parser_simulate_error (parser))\n \tcp_parser_name_lookup_error (parser, identifier, type_decl,\n-\t\t\t\t     \"is not a type\", token->location);\n+\t\t\t\t     NLE_TYPE, token->location);\n       return error_mark_node;\n     }\n   /* Remember that the name was used in the definition of the\n@@ -12703,7 +12958,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n     cp_parser_enumerator_list (parser, type);\n \n   /* Consume the final '}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \n   /* Look for trailing attributes to apply to this enumeration, and\n      apply them if appropriate.  */\n@@ -12890,7 +13145,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n     is_inline = false;\n \n   /* Look for the `namespace' keyword.  */\n-  cp_parser_require_keyword (parser, RID_NAMESPACE, \"%<namespace%>\");\n+  cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);\n \n   /* Get the name of the namespace.  We do not attempt to distinguish\n      between an original-namespace-definition and an\n@@ -12905,7 +13160,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n   attribs = cp_parser_attributes_opt (parser);\n \n   /* Look for the `{' to start the namespace.  */\n-  cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n+  cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n   /* Start the namespace.  */\n   push_namespace (identifier);\n \n@@ -12937,7 +13192,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n   /* Finish the namespace.  */\n   pop_namespace ();\n   /* Look for the final `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n }\n \n /* Parse a namespace-body.\n@@ -12965,7 +13220,7 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n   /* Look for the `namespace' keyword.  */\n-  cp_parser_require_keyword (parser, RID_NAMESPACE, \"%<namespace%>\");\n+  cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);\n   /* Look for the identifier.  */\n   identifier = cp_parser_identifier (parser);\n   if (identifier == error_mark_node)\n@@ -12981,12 +13236,12 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n \tcp_lexer_consume_token (parser->lexer);\n       return;\n     }\n-  cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n+  cp_parser_require (parser, CPP_EQ, RT_EQ);\n   /* Look for the qualified-namespace-specifier.  */\n   namespace_specifier\n     = cp_parser_qualified_namespace_specifier (parser);\n   /* Look for the `;' token.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n   /* Register the alias in the symbol table.  */\n   do_namespace_alias (identifier, namespace_specifier);\n@@ -13045,7 +13300,7 @@ cp_parser_using_declaration (cp_parser* parser,\n   else\n     {\n       /* Look for the `using' keyword.  */\n-      cp_parser_require_keyword (parser, RID_USING, \"%<using%>\");\n+      cp_parser_require_keyword (parser, RID_USING, RT_USING);\n       \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -13136,7 +13391,7 @@ cp_parser_using_declaration (cp_parser* parser,\n \t\t\t\t\t       token->location);\n \t  if (decl == error_mark_node)\n \t    cp_parser_name_lookup_error (parser, identifier,\n-\t\t\t\t\t decl, NULL,\n+\t\t\t\t\t decl, NLE_NULL,\n \t\t\t\t\t token->location);\n \t  else if (check_for_bare_parameter_packs (decl))\n \t    return false;\n@@ -13148,7 +13403,7 @@ cp_parser_using_declaration (cp_parser* parser,\n     }\n \n   /* Look for the final `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n   \n   return true;\n }\n@@ -13166,9 +13421,9 @@ cp_parser_using_directive (cp_parser* parser)\n   tree attribs;\n \n   /* Look for the `using' keyword.  */\n-  cp_parser_require_keyword (parser, RID_USING, \"%<using%>\");\n+  cp_parser_require_keyword (parser, RID_USING, RT_USING);\n   /* And the `namespace' keyword.  */\n-  cp_parser_require_keyword (parser, RID_NAMESPACE, \"%<namespace%>\");\n+  cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);\n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n   /* And the optional nested-name-specifier.  */\n@@ -13184,7 +13439,7 @@ cp_parser_using_directive (cp_parser* parser)\n   /* Update the symbol table.  */\n   parse_using_directive (namespace_decl, attribs);\n   /* Look for the final `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n }\n \n /* Parse an asm-definition.\n@@ -13220,10 +13475,10 @@ cp_parser_asm_definition (cp_parser* parser)\n   bool invalid_inputs_p = false;\n   bool invalid_outputs_p = false;\n   bool goto_p = false;\n-  const char *missing = NULL;\n+  required_token missing = 0;\n \n   /* Look for the `asm' keyword.  */\n-  cp_parser_require_keyword (parser, RID_ASM, \"%<asm%>\");\n+  cp_parser_require_keyword (parser, RID_ASM, RT_ASM);\n   /* See if the next token is `volatile'.  */\n   if (cp_parser_allow_gnu_extensions_p (parser)\n       && cp_lexer_next_token_is_keyword (parser->lexer, RID_VOLATILE))\n@@ -13243,7 +13498,7 @@ cp_parser_asm_definition (cp_parser* parser)\n       cp_lexer_consume_token (parser->lexer);\n     }\n   /* Look for the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return;\n   /* Look for the string.  */\n   string = cp_parser_string_literal (parser, false, false);\n@@ -13348,17 +13603,17 @@ cp_parser_asm_definition (cp_parser* parser)\n \t}\n \n       if (goto_p && !labels_p)\n-\tmissing = clobbers_p ? \"%<:%>\" : \"%<:%> or %<::%>\";\n+\tmissing = clobbers_p ? RT_COLON : RT_COLON_SCOPE;\n     }\n   else if (goto_p)\n-    missing = \"%<:%> or %<::%>\";\n+    missing = RT_COLON_SCOPE;\n \n   /* Look for the closing `)'.  */\n   if (!cp_parser_require (parser, missing ? CPP_COLON : CPP_CLOSE_PAREN,\n-\t\t\t  missing ? missing : \"%<)%>\"))\n+\t\t\t  missing ? missing : RT_CLOSE_PAREN))\n     cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t   /*consume_paren=*/true);\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n   if (!invalid_inputs_p && !invalid_outputs_p)\n     {\n@@ -14027,7 +14282,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t    *ctor_dtor_or_conv_p = *ctor_dtor_or_conv_p < 0;\n \t\t  first = false;\n \t\t  /* Consume the `)'.  */\n-\t\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+\t\t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n \t\t  /* Parse the cv-qualifier-seq.  */\n \t\t  cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n@@ -14081,7 +14336,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t      first = false;\n \t      /* Expect a `)'.  */\n-\t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+\t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \t\tdeclarator = cp_error_declarator;\n \t      if (declarator == cp_error_declarator)\n \t\tbreak;\n@@ -14141,7 +14396,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  else\n \t    bounds = NULL_TREE;\n \t  /* Look for the closing `]'.  */\n-\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\"))\n+\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))\n \t    {\n \t      declarator = cp_error_declarator;\n \t      break;\n@@ -14455,7 +14710,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n       /* If we found it, and the next token is a `*', then we are\n \t indeed looking at a pointer-to-member operator.  */\n       if (!cp_parser_error_occurred (parser)\n-\t  && cp_parser_require (parser, CPP_MULT, \"%<*%>\"))\n+\t  && cp_parser_require (parser, CPP_MULT, RT_MULT))\n \t{\n \t  /* Indicate that the `*' operator was used.  */\n \t  code = INDIRECT_REF;\n@@ -14851,7 +15106,7 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n       cp_lexer_consume_token (parser->lexer);\n       /* Expect an ellipsis.  */\n       ellipsis_p\n-\t= (cp_parser_require (parser, CPP_ELLIPSIS, \"%<...%>\") != NULL);\n+\t= (cp_parser_require (parser, CPP_ELLIPSIS, RT_ELLIPSIS) != NULL);\n     }\n   /* It might also be `...' if the optional trailing `,' was\n      omitted.  */\n@@ -15559,7 +15814,7 @@ cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n \tcp_lexer_consume_token (parser->lexer);\n     }\n   /* Now, there should be a trailing `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n   TREE_TYPE (initializer) = init_list_type_node;\n   return initializer;\n }\n@@ -15855,7 +16110,7 @@ cp_parser_class_specifier (cp_parser* parser)\n     }\n \n   /* Look for the `{'.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n     {\n       pop_deferring_access_checks ();\n       return error_mark_node;\n@@ -15906,7 +16161,7 @@ cp_parser_class_specifier (cp_parser* parser)\n     cp_parser_member_specification_opt (parser);\n \n   /* Look for the trailing `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n   /* Look for trailing attributes to apply to this class.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     attributes = cp_parser_attributes_opt (parser);\n@@ -16433,7 +16688,7 @@ cp_parser_class_key (cp_parser* parser)\n   enum tag_types tag_type;\n \n   /* Look for the class-key.  */\n-  token = cp_parser_require (parser, CPP_KEYWORD, \"class-key\");\n+  token = cp_parser_require (parser, CPP_KEYWORD, RT_CLASS_KEY);\n   if (!token)\n     return none_type;\n \n@@ -16478,7 +16733,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n \t  /* Remember which access-specifier is active.  */\n \t  current_access_specifier = token->u.value;\n \t  /* Look for the `:'.  */\n-\t  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n+\t  cp_parser_require (parser, CPP_COLON, RT_COLON);\n \t  break;\n \n \tdefault:\n@@ -16909,7 +17164,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t}\n     }\n \n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n }\n \n /* Parse a pure-specifier.\n@@ -16926,7 +17181,7 @@ cp_parser_pure_specifier (cp_parser* parser)\n   cp_token *token;\n \n   /* Look for the `=' token.  */\n-  if (!cp_parser_require (parser, CPP_EQ, \"%<=%>\"))\n+  if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n     return error_mark_node;\n   /* Look for the `0' token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -16973,7 +17228,7 @@ static tree\n cp_parser_constant_initializer (cp_parser* parser)\n {\n   /* Look for the `=' token.  */\n-  if (!cp_parser_require (parser, CPP_EQ, \"%<=%>\"))\n+  if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n     return error_mark_node;\n \n   /* It is invalid to write:\n@@ -16990,7 +17245,7 @@ cp_parser_constant_initializer (cp_parser* parser)\n       /* Skip the initializer.  */\n       cp_parser_skip_to_closing_brace (parser);\n       /* Look for the trailing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \n       return error_mark_node;\n     }\n@@ -17024,7 +17279,7 @@ cp_parser_base_clause (cp_parser* parser)\n   tree bases = NULL_TREE;\n \n   /* Look for the `:' that begins the list.  */\n-  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n+  cp_parser_require (parser, CPP_COLON, RT_COLON);\n \n   /* Scan the base-specifier-list.  */\n   while (true)\n@@ -17233,7 +17488,7 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n   cp_lexer_consume_token (parser->lexer);\n \n   /* Look for the `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -17255,7 +17510,7 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n     type_id_list = empty_except_spec;\n \n   /* Look for the `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   return type_id_list;\n }\n@@ -17314,7 +17569,7 @@ cp_parser_try_block (cp_parser* parser)\n {\n   tree try_block;\n \n-  cp_parser_require_keyword (parser, RID_TRY, \"%<try%>\");\n+  cp_parser_require_keyword (parser, RID_TRY, RT_TRY);\n   try_block = begin_try_block ();\n   cp_parser_compound_statement (parser, NULL, true);\n   finish_try_block (try_block);\n@@ -17337,7 +17592,7 @@ cp_parser_function_try_block (cp_parser* parser)\n   bool ctor_initializer_p;\n \n   /* Look for the `try' keyword.  */\n-  if (!cp_parser_require_keyword (parser, RID_TRY, \"%<try%>\"))\n+  if (!cp_parser_require_keyword (parser, RID_TRY, RT_TRY))\n     return false;\n   /* Let the rest of the front end know where we are.  */\n   try_block = begin_function_try_block (&compound_stmt);\n@@ -17387,12 +17642,12 @@ cp_parser_handler (cp_parser* parser)\n   tree handler;\n   tree declaration;\n \n-  cp_parser_require_keyword (parser, RID_CATCH, \"%<catch%>\");\n+  cp_parser_require_keyword (parser, RID_CATCH, RT_CATCH);\n   handler = begin_handler ();\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   declaration = cp_parser_exception_declaration (parser);\n   finish_handler_parms (declaration, handler);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n   cp_parser_compound_statement (parser, NULL, false);\n   finish_handler (handler);\n }\n@@ -17463,7 +17718,7 @@ cp_parser_throw_expression (cp_parser* parser)\n   tree expression;\n   cp_token* token;\n \n-  cp_parser_require_keyword (parser, RID_THROW, \"%<throw%>\");\n+  cp_parser_require_keyword (parser, RID_THROW, RT_THROW);\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Figure out whether or not there is an assignment-expression\n      following the \"throw\" keyword.  */\n@@ -17508,13 +17763,13 @@ cp_parser_asm_specification_opt (cp_parser* parser)\n   /* Consume the `asm' token.  */\n   cp_lexer_consume_token (parser->lexer);\n   /* Look for the `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n   /* Look for the string-literal.  */\n   asm_specification = cp_parser_string_literal (parser, false, false);\n \n   /* Look for the `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   return asm_specification;\n }\n@@ -17558,19 +17813,19 @@ cp_parser_asm_operand_list (cp_parser* parser)\n \t    name = build_string (IDENTIFIER_LENGTH (name),\n \t\t\t\t IDENTIFIER_POINTER (name));\n \t  /* Look for the closing `]'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+\t  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \t}\n       else\n \tname = NULL_TREE;\n       /* Look for the string-literal.  */\n       string_literal = cp_parser_string_literal (parser, false, false);\n \n       /* Look for the `('.  */\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n       /* Parse the expression.  */\n       expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n       /* Look for the `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n       if (name == error_mark_node \n \t  || string_literal == error_mark_node \n@@ -17697,8 +17952,8 @@ cp_parser_attributes_opt (cp_parser* parser)\n       /* Consume the `__attribute__' keyword.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the two `(' tokens.  */\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -17711,8 +17966,8 @@ cp_parser_attributes_opt (cp_parser* parser)\n \tattribute_list = NULL;\n \n       /* Look for the two `)' tokens.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n       /* Add these new attributes to the list.  */\n       attributes = chainon (attributes, attribute_list);\n@@ -17857,7 +18112,7 @@ static void\n cp_parser_label_declaration (cp_parser* parser)\n {\n   /* Look for the `__label__' keyword.  */\n-  cp_parser_require_keyword (parser, RID_LABEL, \"%<__label__%>\");\n+  cp_parser_require_keyword (parser, RID_LABEL, RT_LABEL);\n \n   while (true)\n     {\n@@ -17874,11 +18129,11 @@ cp_parser_label_declaration (cp_parser* parser)\n       if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n \tbreak;\n       /* Look for the `,' separating the label declarations.  */\n-      cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n+      cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n     }\n \n   /* Look for the final `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n }\n \n /* Support Functions */\n@@ -18475,7 +18730,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t takes one parameter (of type `int') and returns a value of type\n \t `S'.  */\n       if (constructor_p\n-\t  && !cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+\t  && !cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n \tconstructor_p = false;\n \n       if (constructor_p\n@@ -18693,11 +18948,11 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n \n   /* Look for the `template' keyword.  */\n   token = cp_lexer_peek_token (parser->lexer);\n-  if (!cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\"))\n+  if (!cp_parser_require_keyword (parser, RID_TEMPLATE, RT_TEMPLATE))\n     return;\n \n   /* And the `<'.  */\n-  if (!cp_parser_require (parser, CPP_LESS, \"%<<%>\"))\n+  if (!cp_parser_require (parser, CPP_LESS, RT_LESS))\n     return;\n   if (at_class_scope_p () && current_function_decl)\n     {\n@@ -18946,7 +19201,7 @@ cp_parser_single_declaration (cp_parser* parser,\n   /* Look for a trailing `;' after the declaration.  */\n   if (!function_definition_p\n       && (decl == error_mark_node\n-\t  || !cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\")))\n+\t  || !cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON)))\n     cp_parser_skip_to_end_of_block_or_statement (parser);\n \n   return decl;\n@@ -19003,8 +19258,8 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n     type = TREE_TYPE (type);\n   if (cast != error_mark_node\n       && !cast_valid_in_integral_constant_expression_p (type)\n-      && (cp_parser_non_integral_constant_expression\n-\t  (parser, \"a call to a constructor\")))\n+      && (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t      NIC_CONSTRUCTOR)))\n     return error_mark_node;\n   return cast;\n }\n@@ -19443,7 +19698,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n       type = cp_parser_type_id (parser);\n       parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n       /* Now, look for the trailing `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n       /* If all went well, then we're done.  */\n       if (cp_parser_parse_definitely (parser))\n \t{\n@@ -19616,6 +19871,171 @@ cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)\n   return decl_specifiers->specs[(int) ds_friend] != 0;\n }\n \n+/* Issue an error message indicating that TOKEN_DESC was expected.\n+   If KEYWORD is true, it indicated this function is called by\n+   cp_parser_require_keword and the required token can only be\n+   a indicated keyword. */\n+\n+static void\n+cp_parser_required_error (cp_parser *parser,\n+\t\t\t  required_token token_desc,\n+\t\t\t  bool keyword)\n+{\n+  switch (token_desc)\n+    {\n+      case RT_NEW:\n+\tcp_parser_error (parser, \"expected %<new%>\");\n+\treturn;\n+      case RT_DELETE:\n+\tcp_parser_error (parser, \"expected %<delete%>\");\n+\treturn;\n+      case RT_RETURN:\n+\tcp_parser_error (parser, \"expected %<return%>\");\n+\treturn;\n+      case RT_WHILE:\n+\tcp_parser_error (parser, \"expected %<while%>\");\n+\treturn;\n+      case RT_EXTERN:\n+\tcp_parser_error (parser, \"expected %<extern%>\");\n+\treturn;\n+      case RT_STATIC_ASSERT:\n+\tcp_parser_error (parser, \"expected %<static_assert%>\");\n+\treturn;\n+      case RT_DECLTYPE:\n+\tcp_parser_error (parser, \"expected %<decltype%>\");\n+\treturn;\n+      case RT_OPERATOR:\n+\tcp_parser_error (parser, \"expected %<operator%>\");\n+\treturn;\n+      case RT_CLASS:\n+\tcp_parser_error (parser, \"expected %<class%>\");\n+\treturn;\n+      case RT_TEMPLATE:\n+\tcp_parser_error (parser, \"expected %<template%>\");\n+\treturn;\n+      case RT_NAMESPACE:\n+\tcp_parser_error (parser, \"expected %<namespace%>\");\n+\treturn;\n+      case RT_USING:\n+\tcp_parser_error (parser, \"expected %<using%>\");\n+\treturn;\n+      case RT_ASM:\n+\tcp_parser_error (parser, \"expected %<asm%>\");\n+\treturn;\n+      case RT_TRY:\n+\tcp_parser_error (parser, \"expected %<try%>\");\n+\treturn;\n+      case RT_CATCH:\n+\tcp_parser_error (parser, \"expected %<catch%>\");\n+\treturn;\n+      case RT_THROW:\n+\tcp_parser_error (parser, \"expected %<throw%>\");\n+\treturn;\n+      case RT_LABEL:\n+\tcp_parser_error (parser, \"expected %<__label__%>\");\n+\treturn;\n+      case RT_AT_TRY:\n+\tcp_parser_error (parser, \"expected %<@try%>\");\n+\treturn;\n+      case RT_AT_SYNCHRONIZED:\n+\tcp_parser_error (parser, \"expected %<@synchronized%>\");\n+\treturn;\n+      case RT_AT_THROW:\n+\tcp_parser_error (parser, \"expected %<@throw%>\");\n+\treturn;\n+      default:\n+\tbreak;\n+    }\n+  if (!keyword)\n+    {\n+      switch (token_desc)\n+        {\n+\t  case RT_SEMICOLON:\n+\t    cp_parser_error (parser, \"expected %<;%>\");\n+\t    return;\n+\t  case RT_OPEN_PAREN:\n+\t    cp_parser_error (parser, \"expected %<(%>\");\n+\t    return;\n+\t  case RT_CLOSE_BRACE:\n+\t    cp_parser_error (parser, \"expected %<}%>\");\n+\t    return;\n+\t  case RT_OPEN_BRACE:\n+\t    cp_parser_error (parser, \"expected %<{%>\");\n+\t    return;\n+\t  case RT_CLOSE_SQUARE:\n+\t    cp_parser_error (parser, \"expected %<]%>\");\n+\t    return;\n+\t  case RT_OPEN_SQUARE:\n+\t    cp_parser_error (parser, \"expected %<[%>\");\n+\t    return;\n+\t  case RT_COMMA:\n+\t    cp_parser_error (parser, \"expected %<,%>\");\n+\t    return;\n+\t  case RT_SCOPE:\n+\t    cp_parser_error (parser, \"expected %<::%>\");\n+\t    return;\n+\t  case RT_LESS:\n+\t    cp_parser_error (parser, \"expected %<<%>\");\n+\t    return;\n+\t  case RT_GREATER:\n+\t    cp_parser_error (parser, \"expected %<>%>\");\n+\t    return;\n+\t  case RT_EQ:\n+\t    cp_parser_error (parser, \"expected %<=%>\");\n+\t    return;\n+\t  case RT_ELLIPSIS:\n+\t    cp_parser_error (parser, \"expected %<...%>\");\n+\t    return;\n+\t  case RT_MULT:\n+\t    cp_parser_error (parser, \"expected %<*%>\");\n+\t    return;\n+\t  case RT_COMPL:\n+\t    cp_parser_error (parser, \"expected %<~%>\");\n+\t    return;\n+\t  case RT_COLON:\n+\t    cp_parser_error (parser, \"expected %<:%>\");\n+\t    return;\n+\t  case RT_COLON_SCOPE:\n+\t    cp_parser_error (parser, \"expected %<:%> or %<::%>\");\n+\t    return;\n+\t  case RT_CLOSE_PAREN:\n+\t    cp_parser_error (parser, \"expected %<)%>\");\n+\t    return;\n+\t  case RT_COMMA_CLOSE_PAREN:\n+\t    cp_parser_error (parser, \"expected %<,%> or %<)%>\");\n+\t    return;\n+\t  case RT_PRAGMA_EOL:\n+\t    cp_parser_error (parser, \"expected end of line\");\n+\t    return;\n+\t  case RT_NAME:\n+\t    cp_parser_error (parser, \"expected identifier\");\n+\t    return;\n+\t  case RT_SELECT:\n+\t    cp_parser_error (parser, \"expected selection-statement\");\n+\t    return;\n+\t  case RT_INTERATION:\n+\t    cp_parser_error (parser, \"expected iteration-statement\");\n+\t    return;\n+\t  case RT_JUMP:\n+\t    cp_parser_error (parser, \"expected jump-statement\");\n+\t    return;\n+\t  case RT_CLASS_KEY:\n+\t    cp_parser_error (parser, \"expected class-key\");\n+\t    return;\n+\t  case RT_CLASS_TYPENAME_TEMPLATE:\n+\t    cp_parser_error (parser,\n+\t  \t \"expected %<class%>, %<typename%>, or %<template%>\");\n+\t    return;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+\n /* If the next token is of the indicated TYPE, consume it.  Otherwise,\n    issue an error message indicating that TOKEN_DESC was expected.\n \n@@ -19625,19 +20045,15 @@ cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)\n static cp_token *\n cp_parser_require (cp_parser* parser,\n \t\t   enum cpp_ttype type,\n-\t\t   const char* token_desc)\n+\t\t   required_token token_desc)\n {\n   if (cp_lexer_next_token_is (parser->lexer, type))\n     return cp_lexer_consume_token (parser->lexer);\n   else\n     {\n       /* Output the MESSAGE -- unless we're parsing tentatively.  */\n       if (!cp_parser_simulate_error (parser))\n-\t{\n-\t  char *message = concat (\"expected \", token_desc, NULL);\n-\t  cp_parser_error (parser, message);\n-\t  free (message);\n-\t}\n+\tcp_parser_required_error (parser, token_desc, /*keyword=*/false);\n       return NULL;\n     }\n }\n@@ -19655,7 +20071,7 @@ cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n   unsigned nesting_depth = 0;\n \n   /* Are we ready, yet?  If not, issue error message.  */\n-  if (cp_parser_require (parser, CPP_GREATER, \"%<>%>\"))\n+  if (cp_parser_require (parser, CPP_GREATER, RT_GREATER))\n     return;\n \n   /* Skip tokens until the desired token is found.  */\n@@ -19732,20 +20148,13 @@ cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n static cp_token *\n cp_parser_require_keyword (cp_parser* parser,\n \t\t\t   enum rid keyword,\n-\t\t\t   const char* token_desc)\n+\t\t\t   required_token token_desc)\n {\n   cp_token *token = cp_parser_require (parser, CPP_KEYWORD, token_desc);\n \n   if (token && token->keyword != keyword)\n     {\n-      dyn_string_t error_msg;\n-\n-      /* Format the error message.  */\n-      error_msg = dyn_string_new (0);\n-      dyn_string_append_cstr (error_msg, \"expected \");\n-      dyn_string_append_cstr (error_msg, token_desc);\n-      cp_parser_error (parser, error_msg->s);\n-      dyn_string_delete (error_msg);\n+      cp_parser_required_error (parser, token_desc, /*keyword=*/true); \n       return NULL;\n     }\n \n@@ -20176,7 +20585,7 @@ cp_parser_objc_message_expression (cp_parser* parser)\n   cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n   receiver = cp_parser_objc_message_receiver (parser);\n   messageargs = cp_parser_objc_message_args (parser);\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \n   return objc_build_message_expr (build_tree_list (receiver, messageargs));\n }\n@@ -20248,7 +20657,7 @@ cp_parser_objc_message_args (cp_parser* parser)\n \treturn build_tree_list (selector, NULL_TREE);\n \n       maybe_unary_selector_p = false;\n-      cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n+      cp_parser_require (parser, CPP_COLON, RT_COLON);\n       arg = cp_parser_assignment_expression (parser, false, NULL);\n \n       sel_args\n@@ -20290,10 +20699,10 @@ cp_parser_objc_encode_expression (cp_parser* parser)\n   cp_token *token;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   token = cp_lexer_peek_token (parser->lexer);\n   type = complete_type (cp_parser_type_id (parser));\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   if (!type)\n     {\n@@ -20313,9 +20722,9 @@ cp_parser_objc_defs_expression (cp_parser *parser)\n   tree name;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   name = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   return objc_get_class_ivars (name);\n }\n@@ -20333,9 +20742,9 @@ cp_parser_objc_protocol_expression (cp_parser* parser)\n   tree proto;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   proto = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   return objc_build_protocol_expr (proto);\n }\n@@ -20364,7 +20773,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   token = cp_lexer_peek_token (parser->lexer);\n \n   while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n@@ -20411,7 +20820,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n     }\n \n  finish_selector:\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   return objc_build_selector_expr (loc, sel_seq);\n }\n@@ -20497,7 +20906,7 @@ cp_parser_objc_protocol_refs_opt (cp_parser* parser)\n     {\n       cp_lexer_consume_token (parser->lexer);  /* Eat '<'.  */\n       protorefs = cp_parser_objc_identifier_list (parser);\n-      cp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n+      cp_parser_require (parser, CPP_GREATER, RT_GREATER);\n     }\n \n   return protorefs;\n@@ -20586,7 +20995,7 @@ cp_parser_objc_typename (cp_parser* parser)\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n \tcp_type = cp_parser_type_id (parser);\n \n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n       type_name = build_tree_list (proto_quals, cp_type);\n     }\n \n@@ -20658,7 +21067,7 @@ cp_parser_objc_method_keyword_params (cp_parser* parser)\n \treturn selector;\n \n       maybe_unary_selector_p = false;\n-      cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n+      cp_parser_require (parser, CPP_COLON, RT_COLON);\n       type_name = cp_parser_objc_typename (parser);\n       identifier = cp_parser_identifier (parser);\n \n@@ -20988,7 +21397,7 @@ cp_parser_objc_superclass_or_category (cp_parser *parser, tree *super,\n     {\n       cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n       *categ = cp_parser_identifier (parser);\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n     }\n }\n \n@@ -21109,7 +21518,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n   location_t location;\n   tree stmt;\n \n-  cp_parser_require_keyword (parser, RID_AT_TRY, \"%<@try%>\");\n+  cp_parser_require_keyword (parser, RID_AT_TRY, RT_AT_TRY);\n   location = cp_lexer_peek_token (parser->lexer)->location;\n   /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n      node, lest it get absorbed into the surrounding block.  */\n@@ -21123,13 +21532,13 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n       tree parm;\n \n       cp_lexer_consume_token (parser->lexer);\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n       parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n       parm = grokdeclarator (parmdecl->declarator,\n \t\t\t     &parmdecl->decl_specifiers,\n \t\t\t     PARM, /*initialized=*/0,\n \t\t\t     /*attrlist=*/NULL);\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n       objc_begin_catch_clause (parm);\n       cp_parser_compound_statement (parser, NULL, false);\n       objc_finish_catch_clause ();\n@@ -21161,12 +21570,12 @@ cp_parser_objc_synchronized_statement (cp_parser *parser) {\n   location_t location;\n   tree lock, stmt;\n \n-  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, \"%<@synchronized%>\");\n+  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, RT_AT_SYNCHRONIZED);\n \n   location = cp_lexer_peek_token (parser->lexer)->location;\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   lock = cp_parser_expression (parser, false, NULL);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n      node, lest it get absorbed into the surrounding block.  */\n@@ -21188,7 +21597,7 @@ cp_parser_objc_throw_statement (cp_parser *parser) {\n   tree expr = NULL_TREE;\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n-  cp_parser_require_keyword (parser, RID_AT_THROW, \"%<@throw%>\");\n+  cp_parser_require_keyword (parser, RID_AT_THROW, RT_AT_THROW);\n \n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     expr = cp_parser_assignment_expression (parser, false, NULL);\n@@ -21346,7 +21755,8 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \n       decl = cp_parser_lookup_name_simple (parser, name, token->location);\n       if (decl == error_mark_node)\n-\tcp_parser_name_lookup_error (parser, name, decl, NULL, token->location);\n+\tcp_parser_name_lookup_error (parser, name, decl, NLE_NULL,\n+\t\t\t\t     token->location);\n       else if (kind != 0)\n \t{\n \t  tree u = build_omp_clause (token->location, kind);\n@@ -21363,7 +21773,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     {\n       int ending;\n \n@@ -21387,7 +21797,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n static tree\n cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n {\n-  if (cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return cp_parser_omp_var_list_no_open (parser, kind, list);\n   return list;\n }\n@@ -21403,12 +21813,12 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location\n   HOST_WIDE_INT n;\n \n   loc = cp_lexer_peek_token (parser->lexer)->location;\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n   num = cp_parser_constant_expression (parser, false, NULL);\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -21442,7 +21852,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list, location_t location)\n   enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n   tree c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -21475,7 +21885,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list, location_t location)\n       cp_parser_error (parser, \"expected %<none%> or %<shared%>\");\n     }\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -21499,13 +21909,13 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location)\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n   t = cp_parser_condition (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -21544,13 +21954,13 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n   t = cp_parser_expression (parser, false, NULL);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -21594,7 +22004,7 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n   enum tree_code code;\n   tree nlist, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n   switch (cp_lexer_peek_token (parser->lexer)->type)\n@@ -21634,7 +22044,7 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n     }\n   cp_lexer_consume_token (parser->lexer);\n \n-  if (!cp_parser_require (parser, CPP_COLON, \"%<:%>\"))\n+  if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n     goto resync_fail;\n \n   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_REDUCTION, list);\n@@ -21656,7 +22066,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n {\n   tree c, t;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n   c = build_omp_clause (location, OMP_CLAUSE_SCHEDULE);\n@@ -21717,10 +22127,10 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n       else\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \tgoto resync_fail;\n     }\n-  else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<,%> or %<)%>\"))\n+  else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))\n     goto resync_fail;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\", location);\n@@ -22030,7 +22440,7 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n       name = cp_parser_identifier (parser);\n \n       if (name == error_mark_node\n-\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -22228,7 +22638,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t}\n       loc = cp_lexer_consume_token (parser->lexer)->location;\n \n-      if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+      if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n \treturn NULL;\n \n       init = decl = real_decl = NULL;\n@@ -22288,7 +22698,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t\t       \"OpenMP %<for%> loop\");\n \t\t      else\n \t\t\t/* Trigger an error.  */\n-\t\t\tcp_parser_require (parser, CPP_EQ, \"%<=%>\");\n+\t\t\tcp_parser_require (parser, CPP_EQ, RT_EQ);\n \n \t\t      init = error_mark_node;\n \t\t      cp_parser_skip_to_end_of_statement (parser);\n@@ -22363,7 +22773,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t  tree rhs;\n \n \t\t  cp_parser_parse_definitely (parser);\n-\t\t  cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n+\t\t  cp_parser_require (parser, CPP_EQ, RT_EQ);\n \t\t  rhs = cp_parser_assignment_expression (parser, false, NULL);\n \t\t  finish_expr_stmt (build_x_modify_expr (decl, NOP_EXPR,\n \t\t\t\t\t\t\t rhs,\n@@ -22384,7 +22794,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t}\n \t    }\n \t}\n-      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       if (this_pre_body)\n \t{\n \t  this_pre_body = pop_stmt_list (this_pre_body);\n@@ -22471,7 +22881,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n       cond = NULL;\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n \tcond = cp_parser_omp_for_cond (parser, decl);\n-      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n       incr = NULL;\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n@@ -22486,7 +22896,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t    incr = cp_parser_expression (parser, false, NULL);\n \t}\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -22657,7 +23067,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n   bool error_suppress = false;\n   cp_token *tok;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n     return NULL_TREE;\n \n   stmt = push_stmt_list ();\n@@ -22712,7 +23122,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       add_stmt (substmt);\n     }\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \n   substmt = pop_stmt_list (stmt);\n "}]}