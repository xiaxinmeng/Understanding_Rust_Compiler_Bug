{"sha": "38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhjMWYyZDdlNmRlOTcwYTczNDViN2Q3ZmFiZTM5NTJmMmY3YWY4OQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-29T16:13:13Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-29T16:13:13Z"}, "message": "Fix various problems; Add -m{,no-}fused-madd, -m{,no-}no-update switches; Allow add/and/ior/xor of 32 bit constants\n\nFrom-SVN: r14361", "tree": {"sha": "ba58f6722502142779630876cdbc8b23a4251d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba58f6722502142779630876cdbc8b23a4251d91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/comments", "author": null, "committer": null, "parents": [{"sha": "8b0c969eb1027fdd6f0290e1c59bde46e1fd4fb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b0c969eb1027fdd6f0290e1c59bde46e1fd4fb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b0c969eb1027fdd6f0290e1c59bde46e1fd4fb1"}], "stats": {"total": 848, "additions": 532, "deletions": 316}, "files": [{"sha": "60262a9aba4144acc3a6ea18b48ab18efb1d3474", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 255, "deletions": 87, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "patch": "@@ -104,6 +104,14 @@ enum rs6000_abi rs6000_current_abi;\n int rs6000_fpmem_offset;\n int rs6000_fpmem_size;\n \n+/* Debug flags */\n+char *rs6000_debug_name;\n+int rs6000_debug_stack;\t\t/* debug stack applications */\n+int rs6000_debug_arg;\t\t/* debug argument handling */\n+\n+/* Flag to say the TOC is initialized */\n+int toc_initialized;\n+\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -297,6 +305,19 @@ rs6000_override_options (default_cpu)\n \t}\n     }\n \n+  /* Set debug flags */\n+  if (rs6000_debug_name)\n+    {\n+      if (!strcmp (rs6000_debug_name, \"all\"))\n+\trs6000_debug_stack = rs6000_debug_arg = 1;\n+      else if (!strcmp (rs6000_debug_name, \"stack\"))\n+\trs6000_debug_stack = 1;\n+      else if (!strcmp (rs6000_debug_name, \"arg\"))\n+\trs6000_debug_arg = 1;\n+      else\n+\terror (\"Unknown -mdebug-%s switch\", rs6000_debug_name);\n+    }\n+\n #ifdef TARGET_REGNAMES\n   /* If the user desires alternate register names, copy in the alternate names\n      now.  */\n@@ -416,7 +437,8 @@ any_operand (op, mode)\n }\n \n /* Returns 1 if op is the count register */\n-int count_register_operand(op, mode)\n+int\n+count_register_operand(op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n@@ -434,7 +456,8 @@ int count_register_operand(op, mode)\n \n /* Returns 1 if op is memory location for float/int conversions that masquerades\n    as a register.  */\n-int fpmem_operand(op, mode)\n+int\n+fpmem_operand(op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n@@ -576,6 +599,17 @@ got_operand (op, mode)\n \t  || GET_CODE (op) == LABEL_REF);\n }\n \n+/* Return 1 if the operand is a simple references that can be loaded via\n+   the GOT (labels involving addition aren't allowed).  */\n+\n+int\n+got_no_const_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF);\n+}\n+\n /* Return the number of instructions it takes to form a constant in an\n    integer register.  */\n \n@@ -869,8 +903,7 @@ and_operand (op, mode)\n     register rtx op;\n     enum machine_mode mode;\n {\n-  return (reg_or_short_operand (op, mode)\n-\t  || logical_operand (op, mode)\n+  return (logical_operand (op, mode)\n \t  || mask_operand (op, mode));\n }\n \n@@ -1009,7 +1042,7 @@ small_data_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-#ifdef TARGET_SDATA\n+#if TARGET_ELF\n   rtx sym_ref, const_part;\n \n   if (rs6000_sdata == SDATA_NONE || rs6000_sdata == SDATA_DATA)\n@@ -2168,6 +2201,7 @@ rs6000_finalize_pic ()\n       rtx insn = get_insns ();\n       rtx reg = NULL_RTX;\n       rtx first_insn;\n+      rtx last_insn = NULL_RTX;\n \n       if (GET_CODE (insn) == NOTE)\n \tinsn = next_nonnote_insn (insn);\n@@ -2186,12 +2220,17 @@ rs6000_finalize_pic ()\n \t\t\t\t\t\t\t GOT_TOC_REGNUM,\n \t\t\t\t\t\t\t &reg);\n \t    }\n+\n+\t  if (GET_CODE (insn) != NOTE)\n+\t    last_insn = insn;\n \t}\n \n       if (reg)\n \t{\n \t  rtx init = gen_init_v4_pic (reg);\n \t  emit_insn_before (init, first_insn);\n+\t  if (!optimize && last_insn)\n+\t    emit_insn_after (gen_rtx (USE, VOIDmode, reg), last_insn);\n \t}\n     }\n }\n@@ -2274,7 +2313,7 @@ rs6000_init_expanders ()\n \f\n /* Print an operand.  Recognize special options, documented below.  */\n \n-#ifdef TARGET_SDATA\n+#if TARGET_ELF\n #define SMALL_DATA_RELOC ((rs6000_sdata == SDATA_EABI) ? \"sda21\" : \"sdarel\")\n #else\n #define SMALL_DATA_RELOC \"sda21\"\n@@ -2875,8 +2914,10 @@ rs6000_makes_calls ()\n {\n   rtx insn;\n \n-  /* If we are profiling, we will be making a call to __mcount.  */\n-  if (profile_flag)\n+  /* If we are profiling, we will be making a call to __mcount.\n+     Under the System V ABI's, we store the LR directly, so\n+     we don't need to do it here.  */\n+  if (DEFAULT_ABI == ABI_AIX && profile_flag)\n     return 1;\n \n   for (insn = get_insns (); insn; insn = next_insn (insn))\n@@ -3066,7 +3107,8 @@ rs6000_stack_info ()\n \n \n   /* Determine if we need to save the link register */\n-  if (regs_ever_live[65] || profile_flag\n+  if (regs_ever_live[65]\n+      || (DEFAULT_ABI == ABI_AIX && profile_flag)\n #ifdef TARGET_RELOCATABLE\n       || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n #endif\n@@ -3336,8 +3378,9 @@ debug_stack_info (info)\n    a constant pool.  */\n \n void\n-rs6000_output_load_toc_table (file)\n+rs6000_output_load_toc_table (file, reg)\n      FILE *file;\n+     int reg;\n {\n   char buf[256];\n \n@@ -3349,8 +3392,45 @@ rs6000_output_load_toc_table (file)\n       assemble_name (file, buf);\n       fprintf (file, \"\\n\");\n \n+      /* possibly create the toc section */\n+      if (!toc_initialized)\n+\t{\n+\t  toc_section ();\n+\t  function_section (current_function_decl);\n+\t}\n+\n+      /* If not first call in this function, we need to put the\n+\t different between .LCTOC1 and the address we get to right\n+\t after the bl.  It will mess up disassembling the instructions\n+\t but that can't be helped.  We will later need to bias the\n+\t address before loading.  */\n+      if (rs6000_pic_func_labelno != rs6000_pic_labelno)\n+\t{\n+\t  char *init_ptr = (TARGET_64BIT) ? \".quad\" : \".long\";\n+\t  char *buf_ptr;\n+\n+\t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LCL\", rs6000_pic_labelno);\n+\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n+\t  STRIP_NAME_ENCODING (buf_ptr, buf);\n+\t  fprintf (file, \"\\t%s %s-\", init_ptr, buf_ptr);\n+\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n+\t  fprintf (file, \"%s\\n\", buf_ptr);\n+\t}\n+\n       ASM_OUTPUT_INTERNAL_LABEL (file, \"LCF\", rs6000_pic_labelno);\n-      fprintf (file, \"\\tmflr %s\\n\", reg_names[30]);\n+      fprintf (file, \"\\tmflr %s\\n\", reg_names[reg]);\n+\n+      if (rs6000_pic_func_labelno != rs6000_pic_labelno)\n+\t{\n+\t  if (TARGET_POWERPC64)\n+\t    fprintf (file, \"\\taddi %s,%s,8\\n\", reg_names[reg], reg_names[reg]);\n+\t  else if (TARGET_NEW_MNEMONICS)\n+\t    fprintf (file, \"\\taddi %s,%s,4\\n\", reg_names[reg], reg_names[reg]);\n+\t  else\n+\t    fprintf (file, \"\\tcal %s,4(%s)\\n\", reg_names[reg], reg_names[reg]);\n+\t}\n \n       if (TARGET_POWERPC64)\n \tfprintf (file, \"\\tld\");\n@@ -3360,46 +3440,102 @@ rs6000_output_load_toc_table (file)\n \tfprintf (file, \"\\tl\");\n \n       fprintf (file, \" %s,(\", reg_names[0]);\n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_func_labelno);\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_labelno);\n       assemble_name (file, buf);\n       fprintf (file, \"-\");\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n       assemble_name (file, buf);\n-      fprintf (file, \")(%s)\\n\", reg_names[30]);\n+      fprintf (file, \")(%s)\\n\", reg_names[reg]);\n       asm_fprintf (file, \"\\t{cax|add} %s,%s,%s\\n\",\n-\t\t   reg_names[30], reg_names[0], reg_names[30]);\n+\t\t   reg_names[reg], reg_names[0], reg_names[reg]);\n       rs6000_pic_labelno++;\n     }\n   else if (!TARGET_64BIT)\n     {\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n-      asm_fprintf (file, \"\\t{cau|addis} %s,%s,\", reg_names[30], reg_names[0]);\n+      asm_fprintf (file, \"\\t{cau|addis} %s,%s,\", reg_names[reg], reg_names[0]);\n       assemble_name (file, buf);\n       asm_fprintf (file, \"@ha\\n\");\n       if (TARGET_NEW_MNEMONICS)\n \t{\n-\t  asm_fprintf (file, \"\\taddi %s,%s,\", reg_names[30], reg_names[30]);\n+\t  asm_fprintf (file, \"\\taddi %s,%s,\", reg_names[reg], reg_names[reg]);\n \t  assemble_name (file, buf);\n \t  asm_fprintf (file, \"@l\\n\");\n \t}\n       else\n \t{\n-\t  asm_fprintf (file, \"\\tcal %s,\", reg_names[30]);\n+\t  asm_fprintf (file, \"\\tcal %s,\", reg_names[reg]);\n \t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[30]);\n+\t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[reg]);\n \t}\n     }\n   else\n     abort ();\n \n #else\t/* !USING_SVR4_H */\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 0);\n-  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[30]);\n+  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[reg]);\n   assemble_name (file, buf);\n   asm_fprintf (file, \"(%s)\\n\", reg_names[2]);\n #endif /* USING_SVR4_H */\n }\n \n+\f\n+/* Emit the correct code for allocating stack space.  If COPY_R12, make sure a copy\n+   of the old frame is left in r12.  */\n+\n+void\n+rs6000_allocate_stack_space (file, size, copy_r12)\n+     FILE *file;\n+     int size;\n+     int copy_r12;\n+{\n+  int neg_size = -size;\n+  if (TARGET_UPDATE)\n+    {\n+      if (size < 32767)\n+\tasm_fprintf (file,\n+\t\t     (TARGET_32BIT) ? \"\\t{stu|stwu} %s,%d(%s)\\n\" : \"\\tstdu %s,%d(%s)\\n\",\n+\t\t     reg_names[1], neg_size, reg_names[1]);\n+      else\n+\t{\n+\t  if (copy_r12)\n+\t    fprintf (file, \"\\tmr %s,%s\\n\", reg_names[12], reg_names[1]);\n+\n+\t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n+\t\t       reg_names[0], (neg_size >> 16) & 0xffff,\n+\t\t       reg_names[0], reg_names[0], neg_size & 0xffff);\n+\t  asm_fprintf (file,\n+\t\t       (TARGET_32BIT) ? \"\\t{stux|stwux} %s,%s,%s\\n\" : \"\\tstdux %s,%s,%s\\n\",\n+\t\t       reg_names[1], reg_names[1], reg_names[0]);\n+\t}\n+    }\n+  else\n+    {\n+      fprintf (file, \"\\tmr %s,%s\\n\", reg_names[12], reg_names[1]);\n+      if (size < 32767)\n+\t{\n+\t  if (TARGET_NEW_MNEMONICS)\n+\t    fprintf (file, \"\\taddi %s,%s,%d\\n\", reg_names[1], reg_names[1], neg_size);\n+\t  else\n+\t    fprintf (file, \"\\tcal %s,%d(%s)\\n\", reg_names[1], neg_size, reg_names[1]);\n+\t}\n+      else\n+\t{\n+\t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n+\t\t       reg_names[0], (neg_size >> 16) & 0xffff,\n+\t\t       reg_names[0], reg_names[0], neg_size & 0xffff);\n+\t  asm_fprintf (file, \"\\t{cax|add} %s,%s,%s\\n\", reg_names[1],\n+\t\t       reg_names[0], reg_names[1]);\n+\t}\n+\n+      asm_fprintf (file,\n+\t\t   (TARGET_32BIT) ? \"\\t{st|stw} %s,0(%s)\\n\" : \"\\tstd %s,0(%s)\\n\",\n+\t\t   reg_names[12], reg_names[1]);\n+    }\n+}\n+\n+\f\n /* Write function prologue.  */\n void\n output_prolog (file, size)\n@@ -3458,24 +3594,10 @@ output_prolog (file, size)\n   if (info->push_p && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS))\n     {\n       if (info->total_size < 32767)\n-\t{\n-\t  asm_fprintf (file,\n-\t\t       (TARGET_32BIT) ? \"\\t{stu|stwu} %s,%d(%s)\\n\" : \"\\tstdu %s,%d(%s)\\n\",\n-\t\t       reg_names[1], - info->total_size, reg_names[1]);\n-\t  sp_offset = info->total_size;\n-\t}\n+\tsp_offset = info->total_size;\n       else\n-\t{\n-\t  int neg_size = - info->total_size;\n-\t  sp_reg = 12;\n-\t  asm_fprintf (file, \"\\tmr %s,%s\\n\", reg_names[12], reg_names[1]);\n-\t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n-\t\t       reg_names[0], (neg_size >> 16) & 0xffff,\n-\t\t       reg_names[0], reg_names[0], neg_size & 0xffff);\n-\t  asm_fprintf (file,\n-\t\t       (TARGET_32BIT) ? \"\\t{stux|stwux} %s,%s,%s\\n\" : \"\\tstdux %s,%s,%s\\n\",\n-\t\t       reg_names[1], reg_names[1], reg_names[0]);\n-\t}\n+\tsp_reg = 12;\n+      rs6000_allocate_stack_space (file, info->total_size, sp_reg == 12);\n     }\n \n   /* If we use the link register, get it into r0.  */\n@@ -3589,24 +3711,9 @@ output_prolog (file, size)\n \t}\n     }\n \n-  /* Update stack and set back pointer and we have already done so for V.4.  */\n+  /* Update stack and set back pointer unless this is V.4, which was done previously */\n   if (info->push_p && DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS)\n-    {\n-      if (info->total_size < 32767)\n-\tasm_fprintf (file,\n-\t\t     (TARGET_32BIT) ? \"\\t{stu|stwu} %s,%d(%s)\\n\" : \"\\tstdu %s,%d(%s)\\n\",\n-\t\t     reg_names[1], - info->total_size, reg_names[1]);\n-      else\n-\t{\n-\t  int neg_size = - info->total_size;\n-\t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n-\t\t       reg_names[0], (neg_size >> 16) & 0xffff,\n-\t\t       reg_names[0], reg_names[0], neg_size & 0xffff);\n-\t  asm_fprintf (file,\n-\t\t       (TARGET_32BIT) ? \"\\t{stux|stwux} %s,%s,%s\\n\" : \"\\tstdux %s,%s,%s\\n\",\n-\t\t       reg_names[1], reg_names[1], reg_names[0]);\n-\t}\n-    }\n+    rs6000_allocate_stack_space (file, info->total_size, FALSE);\n \n   /* Set frame pointer, if needed.  */\n   if (frame_pointer_needed)\n@@ -3671,9 +3778,10 @@ output_prolog (file, size)\n   if (TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n     {\n #ifdef USING_SVR4_H\n-      rs6000_pic_func_labelno = rs6000_pic_labelno;\n+      if (!profile_flag)\n+\trs6000_pic_func_labelno = rs6000_pic_labelno;\n #endif\n-      rs6000_output_load_toc_table (file);\n+      rs6000_output_load_toc_table (file, 30);\n     }\n \n   if (DEFAULT_ABI == ABI_NT)\n@@ -4287,55 +4395,115 @@ output_function_profiler (file, labelno)\n   int i, j;\n   char buf[100];\n \n-  if (DEFAULT_ABI != ABI_AIX)\n-    abort ();\n-\n-  /* Set up a TOC entry for the profiler label.  */\n-  toc_section ();\n-  ASM_OUTPUT_INTERNAL_LABEL (file, \"LPC\", labelno);\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LP\", labelno);\n-  if (TARGET_MINIMAL_TOC)\n-    {\n-      fputs (\"\\t.long \", file);\n-      assemble_name (file, buf);\n-      putc ('\\n', file);\n-    }\n-  else\n+  switch (DEFAULT_ABI)\n     {\n-      fputs (\"\\t.tc\\t\", file);\n-      assemble_name (file, buf);\n-      fputs (\"[TC],\", file);\n-      assemble_name (file, buf);\n-      putc ('\\n', file);\n-    }\n-  text_section ();\n+    default:\n+      abort ();\n+\n+    case ABI_V4:\n+    case ABI_SOLARIS:\n+    case ABI_AIX_NODESC:\n+      fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n+      if (flag_pic == 1)\n+\t{\n+\t  fprintf (file, \"\\tbl _GLOBAL_OFFSET_TABLE_@local-4\\n\");\n+\t  fprintf (file, \"\\tmflr %s\\n\", reg_names[11]);\n+\t  fprintf (file, \"\\t%s %s,\", (TARGET_NEW_MNEMONICS) ? \"lwz\" : \"l\",\n+\t\t   reg_names[11]);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"@got(%s)\\n\", reg_names[11]);\n+\t}\n+#if TARGET_ELF\n+      else if (flag_pic > 1 || TARGET_RELOCATABLE)\n+\t{\n+\t  fprintf (file, \"\\tstw %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n+\t  fprintf (file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"X = .-.LCTOC1\\n\");\n+\t  fprintf (file, \"\\t.long \");\n+\t  assemble_name (file, buf);\n+\t  fputs (\"\\n\\t.previous\\n\", file);\n+\t  rs6000_pic_func_labelno = rs6000_pic_labelno;\n+\t  rs6000_output_load_toc_table (file, 11);\n+\t  fprintf (file, \"\\t%s %s,\", (TARGET_NEW_MNEMONICS) ? \"lwz\" : \"l\",\n+\t\t   reg_names[11]);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"X(%s)\\n\", reg_names[11]);\n+\t}\n+#endif\n+      else if (TARGET_NEW_MNEMONICS)\n+\t{\n+\t  fprintf (file, \"\\taddis %s,%s,\", reg_names[11], reg_names[11]);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"@ha\\n\");\n+\t  fprintf (file, \"\\tstw %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n+\t  fprintf (file, \"\\taddi %s,%s,\", reg_names[11], reg_names[11]);\n+\t  assemble_name (file, buf);\n+\t  fputs (\"@l\\n\", file);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tcau %s,%s,\", reg_names[11], reg_names[11]);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"@ha\\n\");\n+\t  fprintf (file, \"\\tst %s,4(%s)\\n\", reg_names[0], reg_names[1]);\n+\t  fprintf (file, \"\\tcal %s,\", reg_names[11]);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"@l(%s)\\n\", reg_names[11]);\n+\t}\n+\n+      fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n+      break;\n+\n+    case ABI_AIX:\n+      /* Set up a TOC entry for the profiler label.  */\n+      toc_section ();\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"LPC\", labelno);\n+      if (TARGET_MINIMAL_TOC)\n+\t{\n+\t  fputs (\"\\t.long \", file);\n+\t  assemble_name (file, buf);\n+\t  putc ('\\n', file);\n+\t}\n+      else\n+\t{\n+\t  fputs (\"\\t.tc\\t\", file);\n+\t  assemble_name (file, buf);\n+\t  fputs (\"[TC],\", file);\n+\t  assemble_name (file, buf);\n+\t  putc ('\\n', file);\n+\t}\n+      text_section ();\n \n   /* Figure out last used parameter register.  The proper thing to do is\n      to walk incoming args of the function.  A function might have live\n      parameter registers even if it has no incoming args.  */\n \n-  for (last_parm_reg = 10;\n-       last_parm_reg > 2 && ! regs_ever_live [last_parm_reg];\n-       last_parm_reg--)\n-    ;\n+      for (last_parm_reg = 10;\n+\t   last_parm_reg > 2 && ! regs_ever_live [last_parm_reg];\n+\t   last_parm_reg--)\n+\t;\n \n   /* Save parameter registers in regs 23-30.  Don't overwrite reg 31, since\n      it might be set up as the frame pointer.  */\n \n-  for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n-    asm_fprintf (file, \"\\tmr %d,%d\\n\", j, i);\n+      for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n+\tasm_fprintf (file, \"\\tmr %d,%d\\n\", j, i);\n \n   /* Load location address into r3, and call mcount.  */\n \n-  ASM_GENERATE_INTERNAL_LABEL (buf, \"LPC\", labelno);\n-  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[3]);\n-  assemble_name (file, buf);\n-  asm_fprintf (file, \"(%s)\\n\\tbl %s\\n\", reg_names[2], RS6000_MCOUNT);\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LPC\", labelno);\n+      asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[3]);\n+      assemble_name (file, buf);\n+      asm_fprintf (file, \"(%s)\\n\\tbl %s\\n\", reg_names[2], RS6000_MCOUNT);\n \n   /* Restore parameter registers.  */\n \n-  for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n-    asm_fprintf (file, \"\\tmr %d,%d\\n\", i, j);\n+      for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n+\tasm_fprintf (file, \"\\tmr %d,%d\\n\", i, j);\n+      break;\n+    }\n }\n \n /* Adjust the cost of a scheduling dependency.  Return the new cost of"}, {"sha": "60b4c529e82d9e4915062574d412261e92552077", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 115, "deletions": 80, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "patch": "@@ -208,33 +208,33 @@ Boston, MA 02111-1307, USA.  */\n extern int target_flags;\n \n /* Use POWER architecture instructions and MQ register.  */\n-#define MASK_POWER\t\t0x01\n+#define MASK_POWER\t\t0x00000001\n \n /* Use POWER2 extensions to POWER architecture.  */\n-#define MASK_POWER2\t\t0x02\n+#define MASK_POWER2\t\t0x00000002\n \n /* Use PowerPC architecture instructions.  */\n-#define MASK_POWERPC\t\t0x04\n+#define MASK_POWERPC\t\t0x00000004\n \n /* Use PowerPC General Purpose group optional instructions, e.g. fsqrt.  */\n-#define MASK_PPC_GPOPT\t\t0x08\n+#define MASK_PPC_GPOPT\t\t0x00000008\n \n /* Use PowerPC Graphics group optional instructions, e.g. fsel.  */\n-#define MASK_PPC_GFXOPT\t\t0x10\n+#define MASK_PPC_GFXOPT\t\t0x00000010\n \n /* Use PowerPC-64 architecture instructions.  */\n-#define MASK_POWERPC64\t\t0x20\n+#define MASK_POWERPC64\t\t0x00000020\n \n /* Use revised mnemonic names defined for PowerPC architecture.  */\n-#define MASK_NEW_MNEMONICS\t0x40\n+#define MASK_NEW_MNEMONICS\t0x00000040\n \n /* Disable placing fp constants in the TOC; can be turned on when the\n    TOC overflows.  */\n-#define MASK_NO_FP_IN_TOC\t0x80\n+#define MASK_NO_FP_IN_TOC\t0x00000080\n \n /* Disable placing symbol+offset constants in the TOC; can be turned on when\n    the TOC overflows.  */\n-#define MASK_NO_SUM_IN_TOC\t0x100\n+#define MASK_NO_SUM_IN_TOC\t0x00000100\n \n /* Output only one TOC entry per module.  Normally linking fails if\n    there are more than 16K unique variables/constants in an executable.  With\n@@ -243,25 +243,27 @@ extern int target_flags;\n \n    This is at the cost of having 2 extra loads and one extra store per\n    function, and one less allocatable register.  */\n-#define MASK_MINIMAL_TOC\t0x200\n+#define MASK_MINIMAL_TOC\t0x00000200\n \n /* Nonzero for the 64bit model: ints, longs, and pointers are 64 bits.  */\n-#define MASK_64BIT\t\t0x400\n+#define MASK_64BIT\t\t0x00000400\n \n /* Disable use of FPRs.  */\n-#define MASK_SOFT_FLOAT\t\t0x800\n+#define MASK_SOFT_FLOAT\t\t0x00000800\n \n /* Enable load/store multiple, even on powerpc */\n-#define\tMASK_MULTIPLE\t\t0x1000\n-#define\tMASK_MULTIPLE_SET\t0x2000\n+#define\tMASK_MULTIPLE\t\t0x00001000\n+#define\tMASK_MULTIPLE_SET\t0x00002000\n \n /* Use string instructions for block moves */\n-#define MASK_STRING\t\t0x4000\n-#define MASK_STRING_SET\t\t0x8000\n+#define MASK_STRING\t\t0x00004000\n+#define MASK_STRING_SET\t\t0x00008000\n \n-/* Temporary debug switches */\n-#define MASK_DEBUG_STACK\t0x10000\n-#define MASK_DEBUG_ARG\t\t0x20000\n+/* Disable update form of load/store */\n+#define MASK_NO_UPDATE\t\t0x00010000\n+\n+/* Disable fused multiply/add operations */\n+#define MASK_NO_FUSED_MADD\t0x00020000\n \n #define TARGET_POWER\t\t(target_flags & MASK_POWER)\n #define TARGET_POWER2\t\t(target_flags & MASK_POWER2)\n@@ -279,11 +281,13 @@ extern int target_flags;\n #define\tTARGET_MULTIPLE_SET\t(target_flags & MASK_MULTIPLE_SET)\n #define TARGET_STRING\t\t(target_flags & MASK_STRING)\n #define TARGET_STRING_SET\t(target_flags & MASK_STRING_SET)\n-#define\tTARGET_DEBUG_STACK\t(target_flags & MASK_DEBUG_STACK)\n-#define\tTARGET_DEBUG_ARG\t(target_flags & MASK_DEBUG_ARG)\n+#define TARGET_NO_UPDATE\t(target_flags & MASK_NO_UPDATE)\n+#define TARGET_NO_FUSED_MADD\t(target_flags & MASK_NO_FUSED_MADD)\n \n #define TARGET_32BIT\t\t(! TARGET_64BIT)\n #define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n+#define TARGET_UPDATE\t\t(! TARGET_NO_UPDATE)\n+#define TARGET_FUSED_MADD\t(! TARGET_NO_FUSED_MADD)\n \n /* Pseudo target to indicate whether the object format is ELF\n    (to get around not having conditional compilation in the md file)  */\n@@ -366,8 +370,10 @@ extern int target_flags;\n   {\"string\",\t\tMASK_STRING | MASK_STRING_SET},\t\t\t\\\n   {\"no-string\",\t\t- MASK_STRING},\t\t\t\t\t\\\n   {\"no-string\",\t\tMASK_STRING_SET},\t\t\t\t\\\n-  {\"debug-stack\",\tMASK_DEBUG_STACK},\t\t\t\t\\\n-  {\"debug-arg\",\t\tMASK_DEBUG_ARG},\t\t\t\t\\\n+  {\"update\",\t\t- MASK_NO_UPDATE},\t\t\t\t\\\n+  {\"no-update\",\t\tMASK_NO_UPDATE},\t\t\t\t\\\n+  {\"fused-madd\",\t- MASK_NO_FUSED_MADD},\t\t\t\t\\\n+  {\"no-fused-madd\",\tMASK_NO_FUSED_MADD},\t\t\t\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n   {\"\",\t\t\tTARGET_DEFAULT}}\n \n@@ -427,6 +433,8 @@ extern enum processor_type rs6000_cpu;\n {\t\t\t\t\t\t\\\n    {\"cpu=\",  &rs6000_select[1].string},\t\t\\\n    {\"tune=\", &rs6000_select[2].string},\t\t\\\n+   {\"debug-\", &rs6000_debug_name},\t\t\\\n+   {\"debug=\", &rs6000_debug_name},\t\t\\\n    SUBTARGET_OPTIONS\t\t\t\t\\\n }\n \n@@ -441,6 +449,14 @@ struct rs6000_cpu_select\n \n extern struct rs6000_cpu_select rs6000_select[];\n \n+/* Debug support */\n+extern char *rs6000_debug_name;\t\t/* Name for -mdebug-xxxx option */\n+extern int rs6000_debug_stack;\t\t/* debug stack applications */\n+extern int rs6000_debug_arg;\t\t/* debug argument handling */\n+\n+#define\tTARGET_DEBUG_STACK\trs6000_debug_stack\n+#define\tTARGET_DEBUG_ARG\trs6000_debug_arg\n+\n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n    `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n@@ -1811,6 +1827,7 @@ typedef struct rs6000_args\n { if (LEGITIMATE_INDIRECT_ADDRESS_P (X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC) \\\n+      && TARGET_UPDATE\t\t\t\t\t\\\n       && LEGITIMATE_INDIRECT_ADDRESS_P (XEXP (X, 0)))\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   if (LEGITIMATE_SMALL_DATA_P (MODE, X))\t\t\\\n@@ -1904,9 +1921,9 @@ typedef struct rs6000_args\n       && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1),\t\\\n \t\t\t\t\t (TARGET_32BIT ? 4 : 8))) \\\n     goto LABEL;\t\t\t\t\t\t\t\\\n-  if (GET_CODE (ADDR) == PRE_INC)\t\t\t\t\\\n+  if (TARGET_UPDATE && GET_CODE (ADDR) == PRE_INC)\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n-  if (GET_CODE (ADDR) == PRE_DEC)\t\t\t\t\\\n+  if (TARGET_UPDATE && GET_CODE (ADDR) == PRE_DEC)\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n   if (GET_CODE (ADDR) == LO_SUM)\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n@@ -2096,59 +2113,74 @@ typedef struct rs6000_args\n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE.  */\n \n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-  switch (rs6000_cpu)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-    case PROCESSOR_RIOS1:\t\t\t\t\\\n-      return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\\\n-\t      ? COSTS_N_INSNS (5)\t\t\t\\\n-\t      : INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n-\t      ? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\t\\\n-    case PROCESSOR_RIOS2:\t\t\t\t\\\n-    case PROCESSOR_MPCCORE:\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\\\n-    case PROCESSOR_PPC601:\t\t\t\t\\\n-      return COSTS_N_INSNS (5);\t\t\t\t\\\n-    case PROCESSOR_PPC603:\t\t\t\t\\\n-      return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\\\n-\t      ? COSTS_N_INSNS (5)\t\t\t\\\n-\t      : INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n-\t      ? COSTS_N_INSNS (2) : COSTS_N_INSNS (3));\t\\\n-    case PROCESSOR_PPC403:\t\t\t\t\\\n-    case PROCESSOR_PPC604:\t\t\t\t\\\n-    case PROCESSOR_PPC620:\t\t\t\t\\\n-      return COSTS_N_INSNS (4);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n-\t&& exact_log2 (INTVAL (XEXP (X, 1))) >= 0)\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\\\n-    /* otherwise fall through to normal divide.  */\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-  switch (rs6000_cpu)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-    case PROCESSOR_RIOS1:\t\t\t\t\\\n-      return COSTS_N_INSNS (19);\t\t\t\\\n-    case PROCESSOR_RIOS2:\t\t\t\t\\\n-      return COSTS_N_INSNS (13);\t\t\t\\\n-    case PROCESSOR_MPCCORE:\t\t\t\t\\\n-      return COSTS_N_INSNS (6);\t\t\t\t\\\n-    case PROCESSOR_PPC403:\t\t\t\t\\\n-      return COSTS_N_INSNS (33);\t\t\t\\\n-    case PROCESSOR_PPC601:\t\t\t\t\\\n-      return COSTS_N_INSNS (36);\t\t\t\\\n-    case PROCESSOR_PPC603:\t\t\t\t\\\n-      return COSTS_N_INSNS (37);\t\t\t\\\n-    case PROCESSOR_PPC604:\t\t\t\t\\\n-    case PROCESSOR_PPC620:\t\t\t\t\\\n-      return COSTS_N_INSNS (20);\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  case FFS:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (4);\t\t\t\t\\\n-  case MEM:\t\t\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\t\\\n+    return ((GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t     && (unsigned HOST_WIDE_INT) ((INTVAL (XEXP (X, 1))\t\t\\\n+\t\t\t\t\t   + 0x8000) >= 0x10000))\t\\\n+\t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n+\t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n+  case AND:\t\t\t\t\t\t\t\t\\\n+    return ((non_and_cint_operand (XEXP (X, 1), SImode))\t\t\\\n+\t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n+\t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n+  case IOR:\t\t\t\t\t\t\t\t\\\n+  case XOR:\t\t\t\t\t\t\t\t\\\n+    return ((non_logical_cint_operand (XEXP (X, 1), SImode))\t\t\\\n+\t    ? COSTS_N_INSNS (2)\t\t\t\t\t\t\\\n+\t    : COSTS_N_INSNS (1));\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    switch (rs6000_cpu)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+      case PROCESSOR_RIOS1:\t\t\t\t\t\t\\\n+        return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n+\t\t? COSTS_N_INSNS (5)\t\t\t\t\t\\\n+\t\t: INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n+\t\t? COSTS_N_INSNS (3) : COSTS_N_INSNS (4));\t\t\\\n+      case PROCESSOR_RIOS2:\t\t\t\t\t\t\\\n+      case PROCESSOR_MPCCORE:\t\t\t\t\t\t\\\n+        return COSTS_N_INSNS (2);\t\t\t\t\t\\\n+      case PROCESSOR_PPC601:\t\t\t\t\t\t\\\n+        return COSTS_N_INSNS (5);\t\t\t\t\t\\\n+      case PROCESSOR_PPC603:\t\t\t\t\t\t\\\n+        return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n+\t\t? COSTS_N_INSNS (5)\t\t\t\t\t\\\n+\t\t: INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n+\t\t? COSTS_N_INSNS (2) : COSTS_N_INSNS (3));\t\t\\\n+      case PROCESSOR_PPC403:\t\t\t\t\t\t\\\n+      case PROCESSOR_PPC604:\t\t\t\t\t\t\\\n+      case PROCESSOR_PPC620:\t\t\t\t\t\t\\\n+        return COSTS_N_INSNS (4);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+\t&& exact_log2 (INTVAL (XEXP (X, 1))) >= 0)\t\t\t\\\n+      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n+    /* otherwise fall through to normal divide.  */\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\t\t\\\n+    switch (rs6000_cpu)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+      case PROCESSOR_RIOS1:\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (19);\t\t\t\t\t\\\n+      case PROCESSOR_RIOS2:\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (13);\t\t\t\t\t\\\n+      case PROCESSOR_MPCCORE:\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (6);\t\t\t\t\t\\\n+      case PROCESSOR_PPC403:\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (33);\t\t\t\t\t\\\n+      case PROCESSOR_PPC601:\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (36);\t\t\t\t\t\\\n+      case PROCESSOR_PPC603:\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (37);\t\t\t\t\t\\\n+      case PROCESSOR_PPC604:\t\t\t\t\t\t\\\n+      case PROCESSOR_PPC620:\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (20);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  case FFS:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\t\t\\\n     /* MEM should be slightly more expensive than (plus (reg) (const)) */ \\\n     return 5;\n \n@@ -2373,8 +2405,6 @@ toc_section ()\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   if (TARGET_MINIMAL_TOC)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      static int toc_initialized = 0;\t\t\t\\\n-\t\t\t\t\t\t\t\\\n       /* toc_section is always called at least once from ASM_FILE_START, \\\n \t so this is guaranteed to always be defined once and only once   \\\n \t in each file.  */\t\t\t\t\t\t \\\n@@ -2396,6 +2426,9 @@ toc_section ()\t\t\t\t\t\t\\\n   in_section = toc;\t\t\t\t\t\\\n }\n \n+/* Flag to say the TOC is initialized */\n+extern int toc_initialized;\n+\n /* This macro produces the initial definition of a function name.\n    On the RS/6000, we need to place an extra '.' in the function name and\n    output the function descriptor.\n@@ -2998,6 +3031,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n+  {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\\\n   {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\\\n   {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\\\n   {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\\\n@@ -3058,6 +3092,7 @@ extern int reg_or_neg_short_operand ();\n extern int reg_or_u_short_operand ();\n extern int reg_or_cint_operand ();\n extern int got_operand ();\n+extern int got_no_const_operand ();\n extern int num_insns_constant ();\n extern int easy_fp_constant ();\n extern int volatile_mem_operand ();"}, {"sha": "0e6e259c8c897fdb39de7ca1f35a52d46d1a3d3e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 135, "deletions": 116, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "patch": "@@ -859,15 +859,17 @@\n ;; Discourage ai/addic because of carry but provide it in an alternative\n ;; allowing register zero as source.\n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,?r,r\")\n-\t(plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,b,r,b\")\n-\t\t (match_operand:SI 2 \"add_operand\" \"r,I,I,J\")))]\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,?r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,b,r,b,b\")\n+\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,I,I,J,n\")))]\n   \"\"\n   \"@\n    {cax|add} %0,%1,%2\n    {cal %0,%2(%1)|addi %0,%1,%2}\n    {ai|addic} %0,%1,%2\n-   {cau|addis} %0,%1,%v2\")\n+   {cau|addis} %0,%1,%v2\n+   #\"\n+  [(set_attr \"length\" \"4,4,4,4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x\")\n@@ -1646,16 +1648,18 @@\n   [(set_attr \"type\" \"idiv\")])\n \f\n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n-\t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"?r,L,K,J\")))\n-   (clobber (match_scratch:CC 3 \"=X,X,x,x\"))]\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n+\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"?r,L,K,J,n\")))\n+   (clobber (match_scratch:CC 3 \"=X,X,x,x,x\"))]\n   \"\"\n   \"@\n    and %0,%1,%2\n    {rlinm|rlwinm} %0,%1,0,%m2,%M2\n    {andil.|andi.} %0,%1,%b2\n-   {andiu.|andis.} %0,%1,%u2\")\n+   {andiu.|andis.} %0,%1,%u2\n+   #\"\n+  [(set_attr \"length\" \"4,4,4,4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x\")\n@@ -1687,54 +1691,37 @@\n   [(set_attr \"type\" \"compare,compare,compare,delayed_compare\")])\n \n ;; Take a AND with a constant that cannot be done in a single insn and try to\n-;; split it into two insns.  This does not verify that the insns are valid\n-;; since this need not be done as combine will do it.\n+;; split it into two insns.\n \n (define_split\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"non_and_cint_operand\" \"\")))]\n-  \"\"\n-  [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 3)))\n-   (set (match_dup 0) (and:SI (match_dup 0) (match_dup 4)))]\n+\t\t(match_operand:SI 2 \"non_and_cint_operand\" \"\")))\n+   (clobber (match_scratch:CC 3 \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 4))) (clobber (match_dup 6))])\n+   (parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 5))) (clobber (match_dup 7))])]\n   \"\n {\n-  int maskval = INTVAL (operands[2]);\n-  int i, transitions, last_bit_value;\n-  int orig = maskval, first_c = maskval, second_c;\n-\n-  /* We know that MASKVAL must have more than 2 bit-transitions.  Start at\n-     the low-order bit and count for the third transition.  When we get there,\n-     make a first mask that has everything to the left of that position\n-     a one.  Then make the second mask to turn off whatever else is needed.  */\n-\n-  for (i = 1, transitions = 0, last_bit_value = maskval & 1; i < 32; i++)\n-    {\n-      if (((maskval >>= 1) & 1) != last_bit_value)\n-\tlast_bit_value ^= 1, transitions++;\n-\n-      if (transitions > 2)\n-\t{\n-\t  first_c |= (~0) << i;\n-\t  break;\n-\t}\n-    }\n-\n-  second_c = orig | ~ first_c;\n-\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode, first_c);\n-  operands[4] = gen_rtx (CONST_INT, VOIDmode, second_c);\n+  operands[4] = GEN_INT (INTVAL (operands[2]) & 0xffff0000);\n+  operands[5] = GEN_INT (INTVAL (operands[2]) & 0x0000ffff);\n+  operands[6] = ((mask_constant (INTVAL (operands[4])))\n+\t\t ? gen_rtx (SCRATCH, CCmode)\n+\t\t : operands[3]);\n+  operands[7] = operands[3];\n }\")\n \n (define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n+\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,K,J,n\")))]\n   \"\"\n   \"@\n    or %0,%1,%2\n    {oril|ori} %0,%1,%b2\n-   {oriu|oris} %0,%1,%u2\")\n+   {oriu|oris} %0,%1,%u2\n+   #\"\n+  [(set_attr \"length\" \"4,4,4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n@@ -1758,7 +1745,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n ;; Split an IOR that we can't do in one insn into two insns, each of which\n-;; does one 16-bit part.  This is used by combine.\n+;; does one 16-bit part.\n \n (define_split\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n@@ -1769,20 +1756,21 @@\n    (set (match_dup 0) (ior:SI (match_dup 0) (match_dup 4)))]\n \"\n {\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t INTVAL (operands[2]) & 0xffff0000);\n-  operands[4] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+  operands[3] = GEN_INT (INTVAL (operands[2]) & 0xffff0000);\n+  operands[4] = GEN_INT (INTVAL (operands[2]) & 0x0000ffff);\n }\")\n \n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n-\t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n+\t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n+\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,K,J,n\")))]\n   \"\"\n   \"@\n    xor %0,%1,%2\n    {xoril|xori} %0,%1,%b2\n-   {xoriu|xoris} %0,%1,%u2\")\n+   {xoriu|xoris} %0,%1,%u2\n+   #\"\n+  [(set_attr \"length\" \"4,4,4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n@@ -1806,7 +1794,7 @@\n   [(set_attr \"type\" \"compare\")])\n \n ;; Split an XOR that we can't do in one insn into two insns, each of which\n-;; does one 16-bit part.  This is used by combine.\n+;; does one 16-bit part.\n \n (define_split\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n@@ -1817,9 +1805,8 @@\n    (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 4)))]\n \"\n {\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t INTVAL (operands[2]) & 0xffff0000);\n-  operands[4] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+  operands[3] = GEN_INT (INTVAL (operands[2]) & 0xffff0000);\n+  operands[4] = GEN_INT (INTVAL (operands[2]) & 0x0000ffff);\n }\")\n \n (define_insn \"\"\n@@ -3058,7 +3045,7 @@\n \t(plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"fmadds %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -3067,7 +3054,7 @@\n \t(plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"! TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"! TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"{fma|fmadd} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n@@ -3076,7 +3063,7 @@\n \t(minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"fmsubs %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -3085,7 +3072,7 @@\n \t(minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"! TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"! TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"{fms|fmsub} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n@@ -3094,7 +3081,7 @@\n \t(neg:SF (plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"fnmadds %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -3103,7 +3090,7 @@\n \t(neg:SF (plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"! TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"! TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"{fnma|fnmadd} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n@@ -3112,7 +3099,7 @@\n \t(neg:SF (minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"fnmsubs %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -3121,7 +3108,7 @@\n \t(neg:SF (minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n \t\t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"! TARGET_POWERPC && TARGET_HARD_FLOAT\"\n+  \"! TARGET_POWERPC && TARGET_HARD_FLOAT && TARGET_FUSED_MADD\"\n   \"{fnms|fnmsub} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n@@ -5039,12 +5026,30 @@\n   \"(DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && flag_pic == 1\"\n   \"\n {\n+  if (GET_CODE (operands[1]) == CONST)\n+    {\n+      rtx offset = const0_rtx;\n+      HOST_WIDE_INT value;\n+\n+      operands[1] = eliminate_constant_term (XEXP (operands[1], 0), &offset);\n+      value = INTVAL (offset);\n+      if (value != 0)\n+\t{\n+\t  rtx tmp = ((reload_in_progress || reload_completed)\n+\t\t     ? operands[0]\n+\t\t     : gen_reg_rtx (Pmode));\n+\t  emit_insn (gen_movsi_got (tmp, operands[1]));\n+\t  emit_insn (gen_addsi3 (operands[0], tmp, offset));\n+\t  DONE;\n+\t}\n+    }\n+\n   operands[2] = rs6000_got_register (operands[1]);\n }\")\n \n (define_insn \"*movsi_got_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec [(match_operand:SI 1 \"got_operand\" \"\")\n+\t(unspec [(match_operand:SI 1 \"got_no_const_operand\" \"\")\n \t\t (match_operand:SI 2 \"register_operand\" \"b\")] 8))]\n   \"(DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && flag_pic == 1\"\n   \"{l|lwz} %0,%a1@got(%2)\"\n@@ -5132,24 +5137,7 @@\n \n \t  emit_insn (gen_movsi (tmp1, sym));\n \t  if (INTVAL (const_term) != 0)\n-\t    {\n-\t      if (value + 0x8000 < 0x10000)\n-\t\temit_insn (gen_addsi3 (operands[0], tmp1, GEN_INT (value)));\n-\n-\t      else\n-\t\t{\n-\t\t  HOST_WIDE_INT high_int = value & (~ (HOST_WIDE_INT) 0xffff);\n-\t\t  HOST_WIDE_INT low_int = value & 0xffff;\n-\t\t  rtx tmp2 = (!new_reg_p || !low_int) ? operands[0] : gen_reg_rtx (Pmode);\n-\n-\t\t  if (low_int & 0x8000)\n-\t\t    high_int += 0x10000, low_int |= ((HOST_WIDE_INT) -1) << 16;\n-\n-\t\t  emit_insn (gen_addsi3 (tmp2, tmp1, GEN_INT (high_int)));\n-\t\t  if (low_int)\n-\t\t    emit_insn (gen_addsi3 (operands[0], tmp2, GEN_INT (low_int)));\n-\t\t}\n-\t    }\n+\t    emit_insn (gen_addsi3 (operands[0], tmp1, GEN_INT (value)));\n \t  DONE;\n \t}\n       else\n@@ -6745,19 +6733,19 @@\n ;; tie and these are the pair most likely to be tieable (and the ones\n ;; that will benefit the most).\n \n-(define_insn \"\"\n+(define_insn \"*movdi_update1\"\n   [(set (match_operand:DI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(mem:DI (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:DI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC64\"\n+  \"TARGET_POWERPC64 && TARGET_UPDATE\"\n   \"@\n    ldux %3,%0,%2\n    ldu %3,%2(%0)\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"*movdi_update2\"\n   [(set (match_operand:DI 3 \"gpc_reg_operand\" \"=r\")\n \t(sign_extend:DI\n \t (mem:SI (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"0\")\n@@ -6774,13 +6762,13 @@\n \t(match_operand:DI 3 \"gpc_reg_operand\" \"r,r\"))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC64\"\n+  \"TARGET_POWERPC64 && TARGET_UPDATE\"\n   \"@\n    stdux %3,%0,%2\n    stdu %3,%2(%0)\"\n   [(set_attr \"type\" \"store\")])\n \n-(define_insn \"\"\n+(define_insn \"*movsi_update1\"\n   [(set (match_operand:SI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(mem:SI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n@@ -6798,142 +6786,166 @@\n \t(match_operand:SI 3 \"gpc_reg_operand\" \"r,r\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    {stux|stwux} %3,%0,%2\n    {stu|stwu} %3,%2(%0)\"\n   [(set_attr \"type\" \"store\")])\n \n-(define_insn \"\"\n+(define_insn \"*movhi_update\"\n   [(set (match_operand:HI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(mem:HI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    lhzux %3,%0,%2\n    lhzu %3,%2(%0)\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"*movhi_update2\"\n   [(set (match_operand:SI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(zero_extend:SI\n \t (mem:HI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    lhzux %3,%0,%2\n    lhzu %3,%2(%0)\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"*movhi_update3\"\n   [(set (match_operand:SI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(sign_extend:SI\n \t (mem:HI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    lhaux %3,%0,%2\n    lhau %3,%2(%0)\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"*movhi_update4\"\n   [(set (mem:HI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))\n \t(match_operand:HI 3 \"gpc_reg_operand\" \"r,r\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    sthux %3,%0,%2\n    sthu %3,%2(%0)\"\n   [(set_attr \"type\" \"store\")])\n \n-(define_insn \"\"\n+(define_insn \"*movqi_update1\"\n   [(set (match_operand:QI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(mem:QI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    lbzux %3,%0,%2\n    lbzu %3,%2(%0)\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"*movqi_update2\"\n   [(set (match_operand:SI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(zero_extend:SI\n \t (mem:QI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    lbzux %3,%0,%2\n    lbzu %3,%2(%0)\"\n   [(set_attr \"type\" \"load\")])\n \n-(define_insn \"\"\n+(define_insn \"*movqi_update3\"\n   [(set (mem:QI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))\n \t(match_operand:QI 3 \"gpc_reg_operand\" \"r,r\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n+  \"TARGET_UPDATE\"\n   \"@\n    stbux %3,%0,%2\n    stbu %3,%2(%0)\"\n   [(set_attr \"type\" \"store\")])\n \n-(define_insn \"\"\n+(define_insn \"*movsf_update1\"\n   [(set (match_operand:SF 3 \"gpc_reg_operand\" \"=f,f\")\n \t(mem:SF (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\"\n   \"@\n    lfsux %3,%0,%2\n    lfsu %3,%2(%0)\"\n   [(set_attr \"type\" \"fpload\")])\n \n-(define_insn \"\"\n+(define_insn \"*movsf_update2\"\n   [(set (mem:SF (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))\n \t(match_operand:SF 3 \"gpc_reg_operand\" \"f,f\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\"\n   \"@\n    stfsux %3,%0,%2\n    stfsu %3,%2(%0)\"\n   [(set_attr \"type\" \"fpstore\")])\n \n-(define_insn \"\"\n+(define_insn \"*movsf_update3\"\n+  [(set (match_operand:SF 3 \"gpc_reg_operand\" \"=r,r\")\n+\t(mem:SF (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n+\t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_SOFT_FLOAT && TARGET_UPDATE\"\n+  \"@\n+   {lux|lwzux} %3,%0,%2\n+   {lu|lwzu} %3,%2(%0)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*movsf_update4\"\n+  [(set (mem:SF (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n+\t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))\n+\t(match_operand:SF 3 \"gpc_reg_operand\" \"r,r\"))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_SOFT_FLOAT && TARGET_UPDATE\"\n+  \"@\n+   {stux|stwux} %3,%0,%2\n+   {stu|stwu} %3,%2(%0)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*movdf_update1\"\n   [(set (match_operand:DF 3 \"gpc_reg_operand\" \"=f,f\")\n \t(mem:DF (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\"\n   \"@\n    lfdux %3,%0,%2\n    lfdu %3,%2(%0)\"\n   [(set_attr \"type\" \"fpload\")])\n \n-(define_insn \"\"\n+(define_insn \"*movdf_update2\"\n   [(set (mem:DF (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))\n \t(match_operand:DF 3 \"gpc_reg_operand\" \"f,f\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\"\n   \"@\n    stfdux %3,%0,%2\n    stfdu %3,%2(%0)\"\n@@ -7007,11 +7019,18 @@\n   else\n     neg_op0 = GEN_INT (- INTVAL (operands[0]));\n \n-  if (TARGET_32BIT)\n-    emit_insn (gen_movsi_update (stack_pointer_rtx, stack_pointer_rtx, neg_op0, chain));\n-  else\n-    emit_insn (gen_movdi_update (stack_pointer_rtx, stack_pointer_rtx, neg_op0, chain));\n+  if (TARGET_UPDATE)\n+    emit_insn ((* ((TARGET_32BIT) ? gen_movsi_update : gen_movdi_update))\n+\t\t(stack_pointer_rtx, stack_pointer_rtx, neg_op0, chain));\n \n+  else\n+    {\n+      emit_insn ((* ((TARGET_32BIT) ? gen_addsi3 : gen_adddi3))\n+\t\t (stack_pointer_rtx, stack_pointer_rtx, neg_op0));\n+      emit_move_insn (gen_rtx (MEM, (TARGET_32BIT) ? SImode : DImode,\n+\t\t\t       stack_pointer_rtx),\n+\t\t      chain);\n+    }\n   DONE;\n }\")\n \n@@ -7089,7 +7108,7 @@\n   \"TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0\"\n   \"*\n {\n-  rs6000_output_load_toc_table (asm_out_file);\n+  rs6000_output_load_toc_table (asm_out_file, 30);\n   return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"load\")])"}, {"sha": "294debf3f9883023c80b879cb05949ffbadab4d4", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c1f2d7e6de970a7345b7d7fabe3952f2f7af89/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=38c1f2d7e6de970a7345b7d7fabe3952f2f7af89", "patch": "@@ -33,20 +33,18 @@ extern enum rs6000_sdata_type rs6000_sdata;\n #define\tMASK_NO_BITFIELD_TYPE\t0x40000000\t/* Set PCC_BITFIELD_TYPE_MATTERS to 0 */\n #define\tMASK_STRICT_ALIGN\t0x20000000\t/* Set STRICT_ALIGNMENT to 1.  */\n #define MASK_RELOCATABLE\t0x10000000\t/* GOT pointers are PC relative */\n-#define\tMASK_SDATA\t\t0x08000000\t/* use small data areas */\n+#define\tMASK_EABI\t\t0x08000000\t/* Adhere to eabi, not System V spec */\n #define MASK_LITTLE_ENDIAN\t0x04000000\t/* target is little endian */\n #define MASK_REGNAMES\t\t0x02000000\t/* use alternate register names.  */\n #define MASK_PROTOTYPE\t\t0x01000000\t/* Only prototyped fcns pass variable args */\n-#define\tMASK_EABI\t\t0x00800000\t/* Adhere to eabi, not System V spec */\n \n #define\tTARGET_NO_BITFIELD_TYPE\t(target_flags & MASK_NO_BITFIELD_TYPE)\n #define TARGET_STRICT_ALIGN\t(target_flags & MASK_STRICT_ALIGN)\n #define TARGET_RELOCATABLE\t(target_flags & MASK_RELOCATABLE)\n-#define TARGET_SDATA\t\t(target_flags & MASK_SDATA)\n+#define TARGET_EABI\t\t(target_flags & MASK_EABI)\n #define TARGET_LITTLE_ENDIAN\t(target_flags & MASK_LITTLE_ENDIAN)\n #define TARGET_REGNAMES\t\t(target_flags & MASK_REGNAMES)\n #define\tTARGET_PROTOTYPE\t(target_flags & MASK_PROTOTYPE)\n-#define TARGET_EABI\t\t(target_flags & MASK_EABI)\n #define\tTARGET_TOC\t\t((target_flags & MASK_64BIT)\t\t\\\n \t\t\t\t || ((target_flags & (MASK_RELOCATABLE\t\\\n \t\t\t\t\t\t      | MASK_MINIMAL_TOC)) \\\n@@ -73,13 +71,9 @@ extern enum rs6000_sdata_type rs6000_sdata;\n   { \"strict-align\",\t MASK_STRICT_ALIGN },\t\t\t\t\\\n   { \"no-strict-align\",\t-MASK_STRICT_ALIGN },\t\t\t\t\\\n   { \"relocatable\",\t MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC }, \\\n-  { \"relocatable\",\t-MASK_SDATA },\t\t\t\t\t\\\n   { \"no-relocatable\",\t-MASK_RELOCATABLE },\t\t\t\t\\\n   { \"relocatable-lib\",\t MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC }, \\\n-  { \"relocatable-lib\",\t-MASK_SDATA },\t\t\t\t\t\\\n   { \"no-relocatable-lib\", -MASK_RELOCATABLE },\t\t\t\t\\\n-  { \"sdata\",\t\t MASK_SDATA },\t\t\t\t\t\\\n-  { \"no-sdata\",\t\t-MASK_SDATA },\t\t\t\t\t\\\n   { \"little-endian\",\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"little\",\t\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big-endian\",\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n@@ -94,6 +88,8 @@ extern enum rs6000_sdata_type rs6000_sdata;\n   { \"no-eabi\",\t\t-MASK_EABI },\t\t\t\t\t\\\n   { \"regnames\",\t\t  MASK_REGNAMES },\t\t\t\t\\\n   { \"no-regnames\",\t -MASK_REGNAMES },\t\t\t\t\\\n+  { \"sdata\",\t\t 0 },\t\t\t\t\t\t\\\n+  { \"no-sdata\",\t\t 0 },\t\t\t\t\t\t\\\n   { \"sim\",\t\t 0 },\t\t\t\t\t\t\\\n   { \"mvme\",\t\t 0 },\t\t\t\t\t\t\\\n   { \"emb\",\t\t 0 },\t\t\t\t\t\t\\\n@@ -169,12 +165,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (rs6000_sdata_name)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      target_flags |= MASK_SDATA;\t\t\t\t\t\\\n       if (!strcmp (rs6000_sdata_name, \"none\"))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rs6000_sdata = SDATA_NONE;\t\t\t\t\t\\\n-\t  target_flags &= ~MASK_SDATA;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+\trs6000_sdata = SDATA_NONE;\t\t\t\t\t\\\n       else if (!strcmp (rs6000_sdata_name, \"data\"))\t\t\t\\\n \trs6000_sdata = SDATA_DATA;\t\t\t\t\t\\\n       else if (!strcmp (rs6000_sdata_name, \"default\"))\t\t\t\\\n@@ -186,21 +178,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \terror (\"Bad value for -msdata=%s\", rs6000_sdata_name);\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else if (TARGET_SDATA && TARGET_EABI)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rs6000_sdata = SDATA_EABI;\t\t\t\t\t\\\n-      rs6000_sdata_name = \"eabi\";\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (TARGET_SDATA)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rs6000_sdata = SDATA_SYSV;\t\t\t\t\t\\\n-      rs6000_sdata_name = \"sysv\";\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n   else if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rs6000_sdata = SDATA_DATA;\t\t\t\t\t\\\n       rs6000_sdata_name = \"data\";\t\t\t\t\t\\\n-      target_flags |= MASK_SDATA;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -225,10 +206,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t     rs6000_sdata_name);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_SDATA && DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS) \\\n+  if (rs6000_sdata != SDATA_NONE && DEFAULT_ABI != ABI_V4\t\t\\\n+      && DEFAULT_ABI != ABI_SOLARIS)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      target_flags &= ~MASK_SDATA;\t\t\t\t\t\\\n-      error (\"-msdata and -mcall-%s are incompatible.\", rs6000_abi_name); \\\n+      rs6000_sdata = SDATA_NONE;\t\t\t\t\t\\\n+      error (\"-msdata=%s and -mcall-%s are incompatible.\",\t\t\\\n+\t     rs6000_sdata_name, rs6000_abi_name);\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (TARGET_RELOCATABLE && !TARGET_MINIMAL_TOC)\t\t\t\\\n@@ -467,8 +450,6 @@ extern void sbss_section ();\n void\t\t\t\t\t\t\t\t\t\\\n toc_section ()\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  static int toc_initialized = 0;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_toc)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       in_section = in_toc;\t\t\t\t\t\t\\\n@@ -628,7 +609,7 @@ extern int rs6000_pic_labelno;\n     char *init_ptr = (TARGET_64BIT) ? \".quad\" : \".long\";\t\t\\\n     STRIP_NAME_ENCODING (orig_name, NAME);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_RELOCATABLE && get_pool_size () != 0)\t\t\t\\\n+    if (TARGET_RELOCATABLE && (get_pool_size () != 0 || profile_flag))\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tchar buf[256], *buf_ptr;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -701,7 +682,8 @@ extern int rs6000_pic_labelno;\n #undef ASM_OUTPUT_ALIGNED_LOCAL\n #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_SDATA && (SIZE) > 0 && (SIZE) <= g_switch_value)\t\t\\\n+  if (rs6000_sdata != SDATA_NONE && (SIZE) > 0\t\t\t\t\\\n+      && (SIZE) <= g_switch_value)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       sdata_section ();\t\t\t\t\t\t\t\\\n       ASM_OUTPUT_ALIGN (FILE, exact_log2 (ALIGN / BITS_PER_UNIT));\t\\\n@@ -961,7 +943,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Pass various options to the assembler */\n #undef ASM_SPEC\n-#define ASM_SPEC \"%(asm_cpu) %{mregnames} %{mno-regnames} \\\n+#define ASM_SPEC \"%(asm_cpu) \\\n+%{.s: %{mregnames} %{mno-regnames}} %{.S: %{mregnames} %{mno-regnames}} \\\n %{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \\\n %{mrelocatable} %{mrelocatable-lib} %{fpic:-K PIC} %{fPIC:-K PIC} \\\n %{memb} %{!memb: %{msdata: -memb} %{msdata=eabi: -memb}} \\\n@@ -983,7 +966,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n %{!meabi: %{!mno-eabi: \\\n     %{mrelocatable: -meabi } \\\n     %{mcall-solaris: -mno-eabi } \\\n-    %{mcall-linux: -mno-eabi }}}\"\n+    %{mcall-linux: -mno-eabi }}} \\\n+%{msdata: -msdata=default} \\\n+%{mno-sdata: -msdata=none}\"\n \n /* Don't put -Y P,<path> for cross compilers */\n #undef LINK_PATH_SPEC\n@@ -1357,3 +1342,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #undef\tMULTILIB_DEFAULTS\n #define\tMULTILIB_DEFAULTS { \"mbig\", \"mcall-sysv\" }\n+\n+/* Define this macro if the code for function profiling should come\n+   before the function prologue.  Normally, the profiling code comes\n+   after.  */\n+#define PROFILE_BEFORE_PROLOGUE 1\n+\n+/* Function name to call to do profiling.  */\n+#undef\tRS6000_MCOUNT\n+#define RS6000_MCOUNT \"_mcount\""}]}