{"sha": "7735d6c72eba0eebcabb4613e893b35c874e7091", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzczNWQ2YzcyZWJhMGVlYmNhYmI0NjEzZTg5M2IzNWM4NzRlNzA5MQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-06-22T16:37:40Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-06-22T16:37:40Z"}, "message": "double-int.c (double_int_multiple_of): New function.\n\n2012-06-22  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* double-int.c (double_int_multiple_of): New function.\n\t* double-int.h (double_int_multiple_of): New decl.\n\t* tree-ssa-loop-ivopts.c (add_cost, zero_cost): Remove undefs.\n\t(mbc_entry_hash): New forward decl.\n\t(mbc_entry_eq): Likewise.\n\t(zero_cost): Change to no_cost.\n\t(mult_costs): New static var.\n\t(cost_tables_exist): Likewise.\n\t(initialize_costs): New function.\n\t(finalize_costs): Likewise.\n\t(tree_ssa_iv_optimize_init): Call initialize_costs.\n\t(add_cost): Change to add_regs_cost; distinguish costs by speed.\n\t(multiply_regs_cost): New function.\n\t(add_const_cost): Likewise.\n\t(extend_or_trunc_reg_cost): Likewise.\n\t(negate_reg_cost): Likewise.\n\t(multiply_by_cost): Change to multiply_by_const_cost; distinguish\n\tcosts by speed.\n\t(get_address_cost): Change add_cost to add_regs_cost; change\n\tmultiply_by_cost to multiply_by_const_cost.\n\t(force_expr_to_var_cost): Change zero_cost to no_cost; change\n\tadd_cost to add_regs_cost; change multiply_by_cost to\n\tmultiply_by_const_cost.\n\t(split_cost): Change zero_cost to no_cost.\n\t(ptr_difference_cost): Likewise.\n\t(difference_cost): Change zero_cost to no_cost; change multiply_by_cost\n\tto multiply_by_const_cost.\n\t(get_computation_cost_at): Change add_cost to add_regs_cost; change\n\tmultiply_by_cost to multiply_by_const_cost.\n\t(determine_use_iv_cost_generic): Change zero_cost to no_cost.\n\t(determine_iv_cost): Change add_cost to add_regs_cost.\n\t(iv_ca_new): Change zero_cost to no_cost.\n\t(tree_ssa_iv_optimize_finalize): Call finalize_costs.\n\t* tree-ssa-address.c (most_expensive_mult_to_index): Change\n\tmultiply_by_cost to multiply_by_const_cost.\n\t* tree-flow.h (multiply_by_cost): Change to multiply_by_const_cost.\n\t(add_regs_cost): New decl.\n\t(multiply_regs_cost): Likewise.\n\t(add_const_cost): Likewise.\n\t(extend_or_trunc_reg_cost): Likewise.\n\t(negate_reg_cost): Likewise.\n\nFrom-SVN: r188891", "tree": {"sha": "2b808a6c7523b9ca43e5d9f1ad34d249e171a402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b808a6c7523b9ca43e5d9f1ad34d249e171a402"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7735d6c72eba0eebcabb4613e893b35c874e7091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7735d6c72eba0eebcabb4613e893b35c874e7091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7735d6c72eba0eebcabb4613e893b35c874e7091", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7735d6c72eba0eebcabb4613e893b35c874e7091/comments", "author": null, "committer": null, "parents": [{"sha": "62e0a1ed43184c59f3c5d0d30b7a573c7574c00f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e0a1ed43184c59f3c5d0d30b7a573c7574c00f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e0a1ed43184c59f3c5d0d30b7a573c7574c00f"}], "stats": {"total": 330, "additions": 286, "deletions": 44}, "files": [{"sha": "fc34120de2473cb1e5c44d408aeb591600fbd4fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7735d6c72eba0eebcabb4613e893b35c874e7091", "patch": "@@ -1,3 +1,47 @@\n+2012-06-22  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* double-int.c (double_int_multiple_of): New function.\n+\t* double-int.h (double_int_multiple_of): New decl.\n+\t* tree-ssa-loop-ivopts.c (add_cost, zero_cost): Remove undefs.\n+\t(mbc_entry_hash): New forward decl.\n+\t(mbc_entry_eq): Likewise.\n+\t(zero_cost): Change to no_cost.\n+\t(mult_costs): New static var.\n+\t(cost_tables_exist): Likewise.\n+\t(initialize_costs): New function.\n+\t(finalize_costs): Likewise.\n+\t(tree_ssa_iv_optimize_init): Call initialize_costs.\n+\t(add_cost): Change to add_regs_cost; distinguish costs by speed.\n+\t(multiply_regs_cost): New function.\n+\t(add_const_cost): Likewise.\n+\t(extend_or_trunc_reg_cost): Likewise.\n+\t(negate_reg_cost): Likewise.\n+\t(multiply_by_cost): Change to multiply_by_const_cost; distinguish\n+\tcosts by speed.\n+\t(get_address_cost): Change add_cost to add_regs_cost; change\n+\tmultiply_by_cost to multiply_by_const_cost.\n+\t(force_expr_to_var_cost): Change zero_cost to no_cost; change\n+\tadd_cost to add_regs_cost; change multiply_by_cost to\n+\tmultiply_by_const_cost.\n+\t(split_cost): Change zero_cost to no_cost.\n+\t(ptr_difference_cost): Likewise.\n+\t(difference_cost): Change zero_cost to no_cost; change multiply_by_cost\n+\tto multiply_by_const_cost.\n+\t(get_computation_cost_at): Change add_cost to add_regs_cost; change\n+\tmultiply_by_cost to multiply_by_const_cost.\n+\t(determine_use_iv_cost_generic): Change zero_cost to no_cost.\n+\t(determine_iv_cost): Change add_cost to add_regs_cost.\n+\t(iv_ca_new): Change zero_cost to no_cost.\n+\t(tree_ssa_iv_optimize_finalize): Call finalize_costs.\n+\t* tree-ssa-address.c (most_expensive_mult_to_index): Change\n+\tmultiply_by_cost to multiply_by_const_cost.\n+\t* tree-flow.h (multiply_by_cost): Change to multiply_by_const_cost.\n+\t(add_regs_cost): New decl.\n+\t(multiply_regs_cost): Likewise.\n+\t(add_const_cost): Likewise.\n+\t(extend_or_trunc_reg_cost): Likewise.\n+\t(negate_reg_cost): Likewise.\n+\n 2012-06-22  Richard Guenther  <rguenther@suse.de>\n \n \tMerge from graphite branch"}, {"sha": "ae63ead903f59992b709fb338d53f14813709d21", "filename": "gcc/double-int.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=7735d6c72eba0eebcabb4613e893b35c874e7091", "patch": "@@ -865,6 +865,26 @@ double_int_umod (double_int a, double_int b, unsigned code)\n   return double_int_mod (a, b, true, code);\n }\n \n+/* Return TRUE iff PRODUCT is an integral multiple of FACTOR, and return\n+   the multiple in *MULTIPLE.  Otherwise return FALSE and leave *MULTIPLE\n+   unchanged.  */\n+\n+bool\n+double_int_multiple_of (double_int product, double_int factor,\n+\t\t\tbool unsigned_p, double_int *multiple)\n+{\n+  double_int remainder;\n+  double_int quotient = double_int_divmod (product, factor, unsigned_p,\n+\t\t\t\t\t   TRUNC_DIV_EXPR, &remainder);\n+  if (double_int_zero_p (remainder))\n+    {\n+      *multiple = quotient;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Set BITPOS bit in A.  */\n double_int\n double_int_setbit (double_int a, unsigned bitpos)"}, {"sha": "ef9a8a9a1b790cb82643e0ba4380bc5069618039", "filename": "gcc/double-int.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=7735d6c72eba0eebcabb4613e893b35c874e7091", "patch": "@@ -150,6 +150,8 @@ double_int double_int_divmod (double_int, double_int, bool, unsigned, double_int\n double_int double_int_sdivmod (double_int, double_int, unsigned, double_int *);\n double_int double_int_udivmod (double_int, double_int, unsigned, double_int *);\n \n+bool double_int_multiple_of (double_int, double_int, bool, double_int *);\n+\n double_int double_int_setbit (double_int, unsigned);\n int double_int_ctz (double_int);\n "}, {"sha": "1978e1061900b5c423060eea935aa3cbab36698b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7735d6c72eba0eebcabb4613e893b35c874e7091", "patch": "@@ -810,7 +810,12 @@ bool expr_invariant_in_loop_p (struct loop *, tree);\n bool stmt_invariant_in_loop_p (struct loop *, gimple);\n bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,\n \t\t\t\t      addr_space_t);\n-unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode, bool);\n+unsigned multiply_by_const_cost (HOST_WIDE_INT, enum machine_mode, bool);\n+unsigned add_regs_cost (enum machine_mode, bool);\n+unsigned multiply_regs_cost (enum machine_mode, bool);\n+unsigned add_const_cost (enum machine_mode, bool);\n+unsigned extend_or_trunc_reg_cost (tree, tree, bool);\n+unsigned negate_reg_cost (enum machine_mode, bool);\n bool may_be_nonaddressable_p (tree expr);\n \n /* In tree-ssa-threadupdate.c.  */"}, {"sha": "22892c5acbbd16ea35320ca259eaeb869cc39774", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=7735d6c72eba0eebcabb4613e893b35c874e7091", "patch": "@@ -556,7 +556,7 @@ most_expensive_mult_to_index (tree type, struct mem_address *parts,\n \t  || !multiplier_allowed_in_address_p (coef, TYPE_MODE (type), as))\n \tcontinue;\n \n-      acost = multiply_by_cost (coef, address_mode, speed);\n+      acost = multiply_by_const_cost (coef, address_mode, speed);\n \n       if (acost > best_mult_cost)\n \t{"}, {"sha": "6c4f83746e4c2eb366d9ce8304a7fc4179556522", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 213, "deletions": 42, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7735d6c72eba0eebcabb4613e893b35c874e7091/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=7735d6c72eba0eebcabb4613e893b35c874e7091", "patch": "@@ -89,12 +89,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"tree-inline.h\"\n #include \"tree-ssa-propagate.h\"\n-\n-/* FIXME: add_cost and zero_cost defined in exprmed.h conflict with local uses.\n- */\n #include \"expmed.h\"\n-#undef add_cost\n-#undef zero_cost\n+\n+static hashval_t mbc_entry_hash (const void *);\n+static int mbc_entry_eq (const void*, const void *);\n \n /* FIXME: Expressions are expanded to RTL in this pass to determine the\n    cost of different addressing modes.  This should be moved to a TBD\n@@ -162,7 +160,7 @@ typedef struct\n \t\t\t   complex expressions and addressing modes).  */\n } comp_cost;\n \n-static const comp_cost zero_cost = {0, 0};\n+static const comp_cost no_cost = {0, 0};\n static const comp_cost infinite_cost = {INFTY, INFTY};\n \n /* The candidate - cost pair.  */\n@@ -386,6 +384,11 @@ struct iv_ca_delta\n \n static VEC(tree,heap) *decl_rtl_to_reset;\n \n+/* Cached costs for multiplies by constants, and a flag to indicate\n+   when they're valid.  */\n+static htab_t mult_costs[2];\n+static bool cost_tables_exist = false;\n+\n static comp_cost force_expr_to_var_cost (tree, bool);\n \n /* Number of uses recorded in DATA.  */\n@@ -851,6 +854,26 @@ htab_inv_expr_hash (const void *ent)\n   return expr->hash;\n }\n \n+/* Allocate data structures for the cost model.  */\n+\n+static void\n+initialize_costs (void)\n+{\n+  mult_costs[0] = htab_create (100, mbc_entry_hash, mbc_entry_eq, free);\n+  mult_costs[1] = htab_create (100, mbc_entry_hash, mbc_entry_eq, free);\n+  cost_tables_exist = true;\n+}\n+\n+/* Release data structures for the cost model.  */\n+\n+static void\n+finalize_costs (void)\n+{\n+  cost_tables_exist = false;\n+  htab_delete (mult_costs[0]);\n+  htab_delete (mult_costs[1]);\n+}\n+\n /* Initializes data structures used by the iv optimization pass, stored\n    in DATA.  */\n \n@@ -869,6 +892,8 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n                                     htab_inv_expr_eq, free);\n   data->inv_expr_id = 0;\n   decl_rtl_to_reset = VEC_alloc (tree, heap, 20);\n+\n+  initialize_costs ();\n }\n \n /* Returns a memory object to that EXPR points.  In case we are able to\n@@ -3057,15 +3082,15 @@ adjust_setup_cost (struct ivopts_data *data, unsigned cost)\n \n /* Returns cost of addition in MODE.  */\n \n-static unsigned\n-add_cost (enum machine_mode mode, bool speed)\n+unsigned\n+add_regs_cost (enum machine_mode mode, bool speed)\n {\n-  static unsigned costs[NUM_MACHINE_MODES];\n+  static unsigned costs[NUM_MACHINE_MODES][2];\n   rtx seq;\n   unsigned cost;\n \n-  if (costs[mode])\n-    return costs[mode];\n+  if (costs[mode][speed])\n+    return costs[mode][speed];\n \n   start_sequence ();\n   force_operand (gen_rtx_fmt_ee (PLUS, mode,\n@@ -3079,14 +3104,156 @@ add_cost (enum machine_mode mode, bool speed)\n   if (!cost)\n     cost = 1;\n \n-  costs[mode] = cost;\n+  costs[mode][speed] = cost;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Addition in %s costs %d\\n\",\n \t     GET_MODE_NAME (mode), cost);\n   return cost;\n }\n \n+/* Returns cost of multiplication in MODE.  */\n+\n+unsigned\n+multiply_regs_cost (enum machine_mode mode, bool speed)\n+{\n+  static unsigned costs[NUM_MACHINE_MODES][2];\n+  rtx seq;\n+  unsigned cost;\n+\n+  if (costs[mode][speed])\n+    return costs[mode][speed];\n+\n+  start_sequence ();\n+  force_operand (gen_rtx_fmt_ee (MULT, mode,\n+\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1),\n+\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 2)),\n+\t\t NULL_RTX);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  cost = seq_cost (seq, speed);\n+  if (!cost)\n+    cost = 1;\n+\n+  costs[mode][speed] = cost;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Multiplication in %s costs %d\\n\",\n+\t     GET_MODE_NAME (mode), cost);\n+  return cost;\n+}\n+\n+/* Returns cost of addition with a constant in MODE.  */\n+\n+unsigned\n+add_const_cost (enum machine_mode mode, bool speed)\n+{\n+  static unsigned costs[NUM_MACHINE_MODES][2];\n+  rtx seq;\n+  unsigned cost;\n+\n+  if (costs[mode][speed])\n+    return costs[mode][speed];\n+\n+  /* Arbitrarily generate insns for x + 2, as the exact constant\n+     shouldn't matter.  */\n+  start_sequence ();\n+  force_operand (gen_rtx_fmt_ee (PLUS, mode,\n+\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1),\n+\t\t\t\t gen_int_mode (2, mode)),\n+\t\t NULL_RTX);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  cost = seq_cost (seq, speed);\n+  if (!cost)\n+    cost = 1;\n+\n+  costs[mode][speed] = cost;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Addition to constant in %s costs %d\\n\",\n+\t     GET_MODE_NAME (mode), cost);\n+  return cost;\n+}\n+\n+/* Returns cost of extend or truncate in MODE.  */\n+\n+unsigned\n+extend_or_trunc_reg_cost (tree type_to, tree type_from, bool speed)\n+{\n+  static unsigned costs[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n+  rtx seq;\n+  unsigned cost;\n+  enum machine_mode mode_to = TYPE_MODE (type_to);\n+  enum machine_mode mode_from = TYPE_MODE (type_from);\n+  tree size_to = TYPE_SIZE (type_to);\n+  tree size_from = TYPE_SIZE (type_from);\n+  enum rtx_code code;\n+\n+  gcc_assert (TREE_CODE (size_to) == INTEGER_CST\n+\t      && TREE_CODE (size_from) == INTEGER_CST);\n+\n+  if (costs[mode_to][mode_from][speed])\n+    return costs[mode_to][mode_from][speed];\n+\n+  if (tree_int_cst_lt (size_to, size_from))\n+    code = TRUNCATE;\n+  else if (TYPE_UNSIGNED (type_to))\n+    code = ZERO_EXTEND;\n+  else\n+    code = SIGN_EXTEND;\n+\n+  start_sequence ();\n+  gen_rtx_fmt_e (code, mode_to,\n+\t\t gen_raw_REG (mode_from, LAST_VIRTUAL_REGISTER + 1));\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  cost = seq_cost (seq, speed);\n+  if (!cost)\n+    cost = 1;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Conversion from %s to %s costs %d\\n\",\n+\t     GET_MODE_NAME (mode_to), GET_MODE_NAME (mode_from), cost);\n+\n+  costs[mode_to][mode_from][speed] = cost;\n+  return cost;\n+}\n+\n+/* Returns cost of negation in MODE.  */\n+\n+unsigned\n+negate_reg_cost (enum machine_mode mode, bool speed)\n+{\n+  static unsigned costs[NUM_MACHINE_MODES][2];\n+  rtx seq;\n+  unsigned cost;\n+\n+  if (costs[mode][speed])\n+    return costs[mode][speed];\n+\n+  start_sequence ();\n+  force_operand (gen_rtx_fmt_e (NEG, mode,\n+\t\t\t\tgen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1)),\n+\t\t NULL_RTX);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  cost = seq_cost (seq, speed);\n+  if (!cost)\n+    cost = 1;\n+\n+  costs[mode][speed] = cost;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Negation in %s costs %d\\n\",\n+\t     GET_MODE_NAME (mode), cost);\n+  return cost;\n+}\n+\n /* Entry in a hashtable of already known costs for multiplication.  */\n struct mbc_entry\n {\n@@ -3120,19 +3287,19 @@ mbc_entry_eq (const void *entry1, const void *entry2)\n /* Returns cost of multiplication by constant CST in MODE.  */\n \n unsigned\n-multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode, bool speed)\n+multiply_by_const_cost (HOST_WIDE_INT cst, enum machine_mode mode, bool speed)\n {\n-  static htab_t costs;\n   struct mbc_entry **cached, act;\n   rtx seq;\n   unsigned cost;\n \n-  if (!costs)\n-    costs = htab_create (100, mbc_entry_hash, mbc_entry_eq, free);\n+  gcc_assert (cost_tables_exist);\n \n   act.mode = mode;\n   act.cst = cst;\n-  cached = (struct mbc_entry **) htab_find_slot (costs, &act, INSERT);\n+  cached = (struct mbc_entry **)\n+    htab_find_slot (mult_costs[speed], &act, INSERT);\n+    \n   if (*cached)\n     return (*cached)->cost;\n \n@@ -3418,7 +3585,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t If VAR_PRESENT is true, try whether the mode with\n \t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n \t if this is the case, use it.  */\n-      add_c = add_cost (address_mode, speed);\n+      add_c = add_regs_cost (address_mode, speed);\n       for (i = 0; i < 8; i++)\n \t{\n \t  var_p = i & 1;\n@@ -3499,10 +3666,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \t     && multiplier_allowed_in_address_p (ratio, mem_mode, as));\n \n   if (ratio != 1 && !ratio_p)\n-    cost += multiply_by_cost (ratio, address_mode, speed);\n+    cost += multiply_by_const_cost (ratio, address_mode, speed);\n \n   if (s_offset && !offset_p && !symbol_present)\n-    cost += add_cost (address_mode, speed);\n+    cost += add_regs_cost (address_mode, speed);\n \n   if (may_autoinc)\n     *may_autoinc = autoinc;\n@@ -3601,7 +3768,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n   STRIP_NOPS (expr);\n \n   if (SSA_VAR_P (expr))\n-    return zero_cost;\n+    return no_cost;\n \n   if (is_gimple_min_invariant (expr))\n     {\n@@ -3633,12 +3800,12 @@ force_expr_to_var_cost (tree expr, bool speed)\n       STRIP_NOPS (op1);\n \n       if (is_gimple_val (op0))\n-\tcost0 = zero_cost;\n+\tcost0 = no_cost;\n       else\n \tcost0 = force_expr_to_var_cost (op0, speed);\n \n       if (is_gimple_val (op1))\n-\tcost1 = zero_cost;\n+\tcost1 = no_cost;\n       else\n \tcost1 = force_expr_to_var_cost (op1, speed);\n \n@@ -3650,11 +3817,11 @@ force_expr_to_var_cost (tree expr, bool speed)\n       op1 = NULL_TREE;\n \n       if (is_gimple_val (op0))\n-\tcost0 = zero_cost;\n+\tcost0 = no_cost;\n       else\n \tcost0 = force_expr_to_var_cost (op0, speed);\n \n-      cost1 = zero_cost;\n+      cost1 = no_cost;\n       break;\n \n     default:\n@@ -3669,7 +3836,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case NEGATE_EXPR:\n-      cost = new_cost (add_cost (mode, speed), 0);\n+      cost = new_cost (add_regs_cost (mode, speed), 0);\n       if (TREE_CODE (expr) != NEGATE_EXPR)\n         {\n           tree mult = NULL_TREE;\n@@ -3689,9 +3856,11 @@ force_expr_to_var_cost (tree expr, bool speed)\n \n     case MULT_EXPR:\n       if (cst_and_fits_in_hwi (op0))\n-\tcost = new_cost (multiply_by_cost (int_cst_value (op0), mode, speed), 0);\n+\tcost = new_cost (multiply_by_const_cost (int_cst_value (op0),\n+\t\t\t\t\t\t mode, speed), 0);\n       else if (cst_and_fits_in_hwi (op1))\n-\tcost = new_cost (multiply_by_cost (int_cst_value (op1), mode, speed), 0);\n+\tcost = new_cost (multiply_by_const_cost (int_cst_value (op1),\n+\t\t\t\t\t\t mode, speed), 0);\n       else\n \treturn new_cost (target_spill_cost [speed], 0);\n       break;\n@@ -3766,12 +3935,12 @@ split_address_cost (struct ivopts_data *data,\n     {\n       *symbol_present = true;\n       *var_present = false;\n-      return zero_cost;\n+      return no_cost;\n     }\n \n   *symbol_present = false;\n   *var_present = true;\n-  return zero_cost;\n+  return no_cost;\n }\n \n /* Estimates cost of expressing difference of addresses E1 - E2 as\n@@ -3796,7 +3965,7 @@ ptr_difference_cost (struct ivopts_data *data,\n       *offset += diff;\n       *symbol_present = false;\n       *var_present = false;\n-      return zero_cost;\n+      return no_cost;\n     }\n \n   if (integer_zerop (e2))\n@@ -3846,7 +4015,7 @@ difference_cost (struct ivopts_data *data,\n   if (operand_equal_p (e1, e2, 0))\n     {\n       *var_present = false;\n-      return zero_cost;\n+      return no_cost;\n     }\n \n   *var_present = true;\n@@ -3857,7 +4026,7 @@ difference_cost (struct ivopts_data *data,\n   if (integer_zerop (e1))\n     {\n       comp_cost cost = force_var_cost (data, e2, depends_on);\n-      cost.cost += multiply_by_cost (-1, mode, data->speed);\n+      cost.cost += multiply_by_const_cost (-1, mode, data->speed);\n       return cost;\n     }\n \n@@ -4168,7 +4337,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t\t\t &symbol_present, &var_present,\n \t\t\t\t\t &offset, depends_on));\n       cost.cost /= avg_loop_niter (data->current_loop);\n-      cost.cost += add_cost (TYPE_MODE (ctype), data->speed);\n+      cost.cost += add_regs_cost (TYPE_MODE (ctype), data->speed);\n     }\n \n   if (inv_expr_id)\n@@ -4201,26 +4370,26 @@ get_computation_cost_at (struct ivopts_data *data,\n   if (!symbol_present && !var_present && !offset)\n     {\n       if (ratio != 1)\n-\tcost.cost += multiply_by_cost (ratio, TYPE_MODE (ctype), speed);\n+\tcost.cost += multiply_by_const_cost (ratio, TYPE_MODE (ctype), speed);\n       return cost;\n     }\n \n   /* Symbol + offset should be compile-time computable so consider that they\n       are added once to the variable, if present.  */\n   if (var_present && (symbol_present || offset))\n     cost.cost += adjust_setup_cost (data,\n-\t\t\t\t    add_cost (TYPE_MODE (ctype), speed));\n+\t\t\t\t    add_regs_cost (TYPE_MODE (ctype), speed));\n \n   /* Having offset does not affect runtime cost in case it is added to\n      symbol, but it increases complexity.  */\n   if (offset)\n     cost.complexity++;\n \n-  cost.cost += add_cost (TYPE_MODE (ctype), speed);\n+  cost.cost += add_regs_cost (TYPE_MODE (ctype), speed);\n \n   aratio = ratio > 0 ? ratio : -ratio;\n   if (aratio != 1)\n-    cost.cost += multiply_by_cost (aratio, TYPE_MODE (ctype), speed);\n+    cost.cost += multiply_by_const_cost (aratio, TYPE_MODE (ctype), speed);\n   return cost;\n \n fallback:\n@@ -4277,7 +4446,7 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n   if (cand->pos == IP_ORIGINAL\n       && cand->incremented_at == use->stmt)\n     {\n-      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE,\n+      set_use_iv_cost (data, use, cand, no_cost, NULL, NULL_TREE,\n                        ERROR_MARK, -1);\n       return true;\n     }\n@@ -5066,7 +5235,7 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n      or a const set.  */\n   if (cost_base.cost == 0)\n     cost_base.cost = COSTS_N_INSNS (1);\n-  cost_step = add_cost (TYPE_MODE (TREE_TYPE (base)), data->speed);\n+  cost_step = add_regs_cost (TYPE_MODE (TREE_TYPE (base)), data->speed);\n \n   cost = cost_step + adjust_setup_cost (data, cost_base.cost);\n \n@@ -5561,10 +5730,10 @@ iv_ca_new (struct ivopts_data *data)\n   nw->cands = BITMAP_ALLOC (NULL);\n   nw->n_cands = 0;\n   nw->n_regs = 0;\n-  nw->cand_use_cost = zero_cost;\n+  nw->cand_use_cost = no_cost;\n   nw->cand_cost = 0;\n   nw->n_invariant_uses = XCNEWVEC (unsigned, data->max_inv_id + 1);\n-  nw->cost = zero_cost;\n+  nw->cost = no_cost;\n   nw->used_inv_expr = XCNEWVEC (unsigned, data->inv_expr_id + 1);\n   nw->num_used_inv_expr = 0;\n \n@@ -6638,6 +6807,8 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   VEC_free (iv_use_p, heap, data->iv_uses);\n   VEC_free (iv_cand_p, heap, data->iv_candidates);\n   htab_delete (data->inv_expr_tab);\n+\n+  finalize_costs ();\n }\n \n /* Returns true if the loop body BODY includes any function calls.  */"}]}