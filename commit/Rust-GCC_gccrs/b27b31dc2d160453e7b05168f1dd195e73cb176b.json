{"sha": "b27b31dc2d160453e7b05168f1dd195e73cb176b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI3YjMxZGMyZDE2MDQ1M2U3YjA1MTY4ZjFkZDE5NWU3M2NiMTc2Yg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-01-12T14:43:58Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-01-12T14:43:58Z"}, "message": "Fix --enable-gather-detailed-mem-stats build.\n\n2018-01-12  Martin Liska  <mliska@suse.cz>\n\n\t* Makefile.in: As qsort_chk is implemented in vec.c, add\n\tvec.o to linkage of gencfn-macros.\n\t* tree.c (build_new_poly_int_cst): Add CXX_MEM_STAT_INFO as it's\n\tpassing the info to record_node_allocation_statistics.\n\t(test_vector_cst_patterns): Add CXX_MEM_STAT_INFO to declaration\n\tand pass the info.\n\t* ggc-common.c (struct ggc_usage): Add operator== and use\n\tit in operator< and compare function.\n\t* mem-stats.h (struct mem_usage): Likewise.\n\t* vec.c (struct vec_usage): Remove operator< and compare\n\tfunction. Can be simply inherited.\n\nFrom-SVN: r256582", "tree": {"sha": "a6dbb2f5ef07d7accb9a8d71b0c192cb21e1b696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6dbb2f5ef07d7accb9a8d71b0c192cb21e1b696"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b27b31dc2d160453e7b05168f1dd195e73cb176b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27b31dc2d160453e7b05168f1dd195e73cb176b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b27b31dc2d160453e7b05168f1dd195e73cb176b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27b31dc2d160453e7b05168f1dd195e73cb176b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a0d0ed28fe9695b95e30b5aea4e45c78420d359"}], "stats": {"total": 109, "additions": 71, "deletions": 38}, "files": [{"sha": "88417f738bacc495cd4559d4def4de1fe256f63c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b27b31dc2d160453e7b05168f1dd195e73cb176b", "patch": "@@ -1,3 +1,17 @@\n+2018-01-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: As qsort_chk is implemented in vec.c, add\n+\tvec.o to linkage of gencfn-macros.\n+\t* tree.c (build_new_poly_int_cst): Add CXX_MEM_STAT_INFO as it's\n+\tpassing the info to record_node_allocation_statistics.\n+\t(test_vector_cst_patterns): Add CXX_MEM_STAT_INFO to declaration\n+\tand pass the info.\n+\t* ggc-common.c (struct ggc_usage): Add operator== and use\n+\tit in operator< and compare function.\n+\t* mem-stats.h (struct mem_usage): Likewise.\n+\t* vec.c (struct vec_usage): Remove operator< and compare\n+\tfunction. Can be simply inherited.\n+\n 2018-01-12  Martin Jambor  <mjambor@suse.cz>\n \n \tPR target/81616"}, {"sha": "f04b8a224c0661ea4f9e14c88f8b6f956c2e5df1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b27b31dc2d160453e7b05168f1dd195e73cb176b", "patch": "@@ -2810,7 +2810,8 @@ genprog = $(genprogerr) check checksum condmd match\n build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n \n build/genrecog$(build_exeext) : build/hash-table.o build/inchash.o\n-build/gencfn-macros$(build_exeext) : build/hash-table.o build/ggc-none.o\n+build/gencfn-macros$(build_exeext) : build/hash-table.o build/vec.o \\\n+  build/ggc-none.o\n \n # For stage1 and when cross-compiling use the build libcpp which is\n # built with NLS disabled.  For stage2+ use the host library and"}, {"sha": "f83fc136d04ee553a8bd4519db9ad812e4cf9493", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=b27b31dc2d160453e7b05168f1dd195e73cb176b", "patch": "@@ -836,10 +836,22 @@ struct ggc_usage: public mem_usage\n     : mem_usage (allocated, times, peak),\n     m_freed (freed), m_collected (collected), m_overhead (overhead) {}\n \n+  /* Equality operator.  */\n+  inline bool\n+  operator== (const ggc_usage &second) const\n+  {\n+    return (get_balance () == second.get_balance ()\n+\t    && m_peak == second.m_peak\n+\t    && m_times == second.m_times);\n+  }\n+\n   /* Comparison operator.  */\n   inline bool\n   operator< (const ggc_usage &second) const\n   {\n+    if (*this == second)\n+      return false;\n+\n     return (get_balance () == second.get_balance () ?\n \t    (m_peak == second.m_peak ? m_times < second.m_times\n \t     : m_peak < second.m_peak)\n@@ -926,7 +938,10 @@ struct ggc_usage: public mem_usage\n     const mem_pair_t f = *(const mem_pair_t *)first;\n     const mem_pair_t s = *(const mem_pair_t *)second;\n \n-    return (*f.second) < (*s.second);\n+    if (*f.second == *s.second)\n+      return 0;\n+\n+    return *f.second < *s.second ? 1 : -1;\n   }\n \n   /* Compare rows in final GGC summary dump.  */"}, {"sha": "741c07301d993dc18aa593925666da2e43c2f0e4", "filename": "gcc/mem-stats.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Fmem-stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Fmem-stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmem-stats.h?ref=b27b31dc2d160453e7b05168f1dd195e73cb176b", "patch": "@@ -163,10 +163,22 @@ struct mem_usage\n \t\t      m_instances + second.m_instances);\n   }\n \n+  /* Equality operator.  */\n+  inline bool\n+  operator== (const mem_usage &second) const\n+  {\n+    return (m_allocated == second.m_allocated\n+\t    && m_peak == second.m_peak\n+\t    && m_allocated == second.m_allocated);\n+  }\n+\n   /* Comparison operator.  */\n   inline bool\n   operator< (const mem_usage &second) const\n   {\n+    if (*this == second)\n+      return false;\n+\n     return (m_allocated == second.m_allocated ?\n \t    (m_peak == second.m_peak ? m_times < second.m_times\n \t     : m_peak < second.m_peak) : m_allocated < second.m_allocated);\n@@ -181,7 +193,10 @@ struct mem_usage\n     const mem_pair_t f = *(const mem_pair_t *)first;\n     const mem_pair_t s = *(const mem_pair_t *)second;\n \n-    return (*f.second) < (*s.second);\n+    if (*f.second == *s.second)\n+      return 0;\n+\n+    return *f.second < *s.second ? 1 : -1;\n   }\n \n   /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */"}, {"sha": "722ce021b674beec83a2cca86334d1cbc567d360", "filename": "gcc/tree.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b27b31dc2d160453e7b05168f1dd195e73cb176b", "patch": "@@ -1332,7 +1332,8 @@ build_new_int_cst (tree type, const wide_int &cst)\n /* Return a new POLY_INT_CST with coefficients COEFFS and type TYPE.  */\n \n static tree\n-build_new_poly_int_cst (tree type, tree (&coeffs)[NUM_POLY_INT_COEFFS])\n+build_new_poly_int_cst (tree type, tree (&coeffs)[NUM_POLY_INT_COEFFS]\n+\t\t\tCXX_MEM_STAT_INFO)\n {\n   size_t length = sizeof (struct tree_poly_int_cst);\n   record_node_allocation_statistics (POLY_INT_CST, length);\n@@ -14429,7 +14430,7 @@ check_vector_cst_stepped (vec<tree> expected, tree actual,\n /* Test the creation of VECTOR_CSTs.  */\n \n static void\n-test_vector_cst_patterns ()\n+test_vector_cst_patterns (ALONE_CXX_MEM_STAT_INFO)\n {\n   auto_vec<tree, 8> elements (8);\n   elements.quick_grow (8);\n@@ -14440,24 +14441,28 @@ test_vector_cst_patterns ()\n      { 0, 1, 2, 3, 4, 5, 6, 7 }.  */\n   for (unsigned int i = 0; i < 8; ++i)\n     elements[i] = build_int_cst (element_type, i);\n-  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+  tree vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_stepped (elements, vector, 1);\n \n   /* Try the same with the first element replaced by 100:\n      { 100, 1, 2, 3, 4, 5, 6, 7 }.  */\n   elements[0] = build_int_cst (element_type, 100);\n-  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_stepped (elements, vector, 1);\n \n   /* Try a series that wraps around.\n      { 100, 65531, 65532, 65533, 65534, 65535, 0, 1 }.  */\n   for (unsigned int i = 1; i < 8; ++i)\n     elements[i] = build_int_cst (element_type, (65530 + i) & 0xffff);\n-  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_stepped (elements, vector, 1);\n \n   /* Try a downward series:\n      { 100, 79, 78, 77, 76, 75, 75, 73 }.  */\n   for (unsigned int i = 1; i < 8; ++i)\n     elements[i] = build_int_cst (element_type, 80 - i);\n-  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 1);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_stepped (elements, vector, 1);\n \n   /* Try two interleaved series with different bases and steps:\n      { 100, 53, 66, 206, 62, 212, 58, 218 }.  */\n@@ -14467,39 +14472,43 @@ test_vector_cst_patterns ()\n       elements[i] = build_int_cst (element_type, 70 - i * 2);\n       elements[i + 1] = build_int_cst (element_type, 200 + i * 3);\n     }\n-  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 2);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_stepped (elements, vector, 2);\n \n   /* Try a duplicated value:\n      { 100, 100, 100, 100, 100, 100, 100, 100 }.  */\n   for (unsigned int i = 1; i < 8; ++i)\n     elements[i] = elements[0];\n-  check_vector_cst_duplicate (elements,\n-\t\t\t      build_vector (vector_type, elements), 1);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_duplicate (elements, vector, 1);\n \n   /* Try an interleaved duplicated value:\n      { 100, 55, 100, 55, 100, 55, 100, 55 }.  */\n   elements[1] = build_int_cst (element_type, 55);\n   for (unsigned int i = 2; i < 8; ++i)\n     elements[i] = elements[i - 2];\n-  check_vector_cst_duplicate (elements,\n-\t\t\t      build_vector (vector_type, elements), 2);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_duplicate (elements, vector, 2);\n \n   /* Try a duplicated value with 2 exceptions\n      { 41, 97, 100, 55, 100, 55, 100, 55 }.  */\n   elements[0] = build_int_cst (element_type, 41);\n   elements[1] = build_int_cst (element_type, 97);\n-  check_vector_cst_fill (elements, build_vector (vector_type, elements), 2);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_fill (elements, vector, 2);\n \n   /* Try with and without a step\n      { 41, 97, 100, 21, 100, 35, 100, 49 }.  */\n   for (unsigned int i = 3; i < 8; i += 2)\n     elements[i] = build_int_cst (element_type, i * 7);\n-  check_vector_cst_stepped (elements, build_vector (vector_type, elements), 2);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_stepped (elements, vector, 2);\n \n   /* Try a fully-general constant:\n      { 41, 97, 100, 21, 100, 9990, 100, 49 }.  */\n   elements[5] = build_int_cst (element_type, 9990);\n-  check_vector_cst_fill (elements, build_vector (vector_type, elements), 4);\n+  vector = build_vector (vector_type, elements PASS_MEM_STAT);\n+  check_vector_cst_fill (elements, vector, 4);\n }\n \n /* Verify that STRIP_NOPS (NODE) is EXPECTED."}, {"sha": "695cd1eba5ad436d02fe7f29ab923907b6e482d7", "filename": "gcc/vec.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b27b31dc2d160453e7b05168f1dd195e73cb176b/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=b27b31dc2d160453e7b05168f1dd195e73cb176b", "patch": "@@ -60,15 +60,6 @@ struct vec_usage: public mem_usage\n     : mem_usage (allocated, times, peak),\n     m_items (items), m_items_peak (items_peak) {}\n \n-  /* Comparison operator.  */\n-  inline bool\n-  operator< (const vec_usage &second) const\n-  {\n-    return (m_allocated == second.m_allocated ?\n-\t    (m_peak == second.m_peak ? m_times < second.m_times\n-\t     : m_peak < second.m_peak) : m_allocated < second.m_allocated);\n-  }\n-\n   /* Sum the usage with SECOND usage.  */\n   vec_usage\n   operator+ (const vec_usage &second)\n@@ -115,18 +106,6 @@ struct vec_usage: public mem_usage\n     print_dash_line ();\n   }\n \n-  /* Compare wrapper used by qsort method.  */\n-  static int\n-  compare (const void *first, const void *second)\n-  {\n-    typedef std::pair<mem_location *, vec_usage *> mem_pair_t;\n-\n-    const mem_pair_t f = *(const mem_pair_t *)first;\n-    const mem_pair_t s = *(const mem_pair_t *)second;\n-\n-    return (*f.second) < (*s.second);\n-  }\n-\n   /* Current number of items allocated.  */\n   size_t m_items;\n   /* Peak value of number of allocated items.  */"}]}