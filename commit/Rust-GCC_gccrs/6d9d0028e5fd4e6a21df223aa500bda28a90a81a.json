{"sha": "6d9d0028e5fd4e6a21df223aa500bda28a90a81a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ5ZDAwMjhlNWZkNGU2YTIxZGYyMjNhYTUwMGJkYTI4YTkwYTgxYQ==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-04-21T20:01:26Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-04-21T20:01:26Z"}, "message": "forgot to add this in last commit.\n\nFrom-SVN: r134528", "tree": {"sha": "4abda1f435010137c7d2db6523d29200e9870074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4abda1f435010137c7d2db6523d29200e9870074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d9d0028e5fd4e6a21df223aa500bda28a90a81a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9d0028e5fd4e6a21df223aa500bda28a90a81a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d9d0028e5fd4e6a21df223aa500bda28a90a81a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9d0028e5fd4e6a21df223aa500bda28a90a81a/comments", "author": null, "committer": null, "parents": [{"sha": "cc806ac109a1cc625e80d9a38d94a7a589a559ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc806ac109a1cc625e80d9a38d94a7a589a559ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc806ac109a1cc625e80d9a38d94a7a589a559ee"}], "stats": {"total": 340, "additions": 340, "deletions": 0}, "files": [{"sha": "c1c36197e5957594778fa68152c0f9bc8b1862d4", "filename": "gcc/df-byte-scan.c", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9d0028e5fd4e6a21df223aa500bda28a90a81a/gcc%2Fdf-byte-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9d0028e5fd4e6a21df223aa500bda28a90a81a/gcc%2Fdf-byte-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-byte-scan.c?ref=6d9d0028e5fd4e6a21df223aa500bda28a90a81a", "patch": "@@ -0,0 +1,340 @@\n+/* Scanning of rtl byte level scanning for dataflow analysis.\n+   Copyright (C) 2008  Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck (zadeck@naturalbridge.com).\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"df.h\"\n+#include \"output.h\"\n+#include \"dbgcnt.h\"\n+\n+/* The following suite of functions provides bytewise modeling of REFs\n+   which are struct df_ref.  START_BYTE and LAST_BYTE are returned.\n+   These can be used as indexes into bitmaps.  The indexes are\n+   normalized so that 0 is the lowest numbered byte, of the inner\n+   register according to the natural ordering of the machine.\n+\n+   This code is designed to be used in backwards scans (which is, of\n+   course, the way all dataflow scanning should really be done).  It\n+   would require a lot of reworking of the api to make it work in a\n+   forwards scanning world.  */\n+\n+\n+/* Helper for df_compute_accessed_bytes.  Ref is some sort of extract.\n+   Return true if this effects the entire reg in REF.  Return false if\n+   otherwise and set START_BYTE and LAST_BYTE.  See the description of\n+   df_compute_accessed_bytes for a description of MM.  */ \n+\n+static bool \n+df_compute_accessed_bytes_extract (struct df_ref *ref,\n+\t\t\t\t   enum df_mm mm ,\n+\t\t\t\t   unsigned int *start_byte, \n+\t\t\t\t   unsigned int *last_byte)\n+{\n+  int start;\n+  int last;\n+  rtx reg = DF_REF_REG (ref);\n+  enum machine_mode m1;\n+  int m1_size;\n+  enum machine_mode m2;\n+  int m2_size;\n+\n+  /* (*_extract:M1 (reg:M2 X) WIDTH POS)\n+     (*_extract:M1 (subreg:M1 (reg:M2 X N) WIDTH POS)\n+      \n+     This is a bitfield extraction.  The assignment clobbers/extracts\n+     exactly the bits named by WIDTH and POS and does not affect the\n+     other bits in register X.  It is also technically possible that\n+     the bits asked for are longer than units per word.  */\n+  \n+  int offset = DF_REF_EXTRACT_OFFSET (ref);\n+  int width = DF_REF_EXTRACT_WIDTH (ref);\n+\n+  if (width == -1 || offset == -1)\n+    return true;\n+\n+  m1 = DF_REF_EXTRACT_MODE (ref);\n+  m1_size = GET_MODE_SIZE (m1);\n+\n+  gcc_assert (m1_size <= UNITS_PER_WORD);\n+\n+  /* There is nothing to do if this is a pure big or small endian\n+     machine, but if the machine is a pastiche, we have to convert the\n+     bit offsets into byte offsets.  This is only possible because we\n+     do not care about individual bits because this conversion may\n+     make the bits non-contiguous.  */\n+  if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n+    offset = GET_MODE_BITSIZE (m1_size) - (offset + width);\n+\n+  /* The offset is now in the same order as the subreg_byte.  */\n+  if (GET_CODE (reg) == SUBREG)\n+    {\n+      m2 = GET_MODE (SUBREG_REG (reg));\n+      m2_size = GET_MODE_SIZE (m2);\n+      if (m1_size > m2_size)\n+\t/* If it is paradoxical, subreg_byte will be zero.  */\n+\toffset -= subreg_lowpart_offset (m2, m1) * BITS_PER_UNIT;\n+      else\n+\toffset += SUBREG_BYTE (reg) * BITS_PER_UNIT;\n+    }\n+  else\n+    {\n+      m2 = GET_MODE (reg);\n+      m2_size = GET_MODE_SIZE (m2);\n+    }\n+\n+  if (mm == DF_MM_MUST)\n+    {\n+      /* For defs (generally), count the byte only if the whole byte\n+\t is touched.  */\n+      start = (offset + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+      last = (width + offset) / BITS_PER_UNIT;\n+\n+      /* In the case where there is nothing, start may be one larger\n+\t than last, we canonize this to return zeros.  This keeps\n+\t computations of length from being negative.  */\n+      if (start >= last)\n+\t{\n+\t  start = 0;\n+\t  last = 0;\n+\t}\n+    }\n+  else\n+    {\n+      /* For uses (generally), count the byte if any part of the byte\n+\t is touched.  */\n+      start = offset / BITS_PER_UNIT;\n+      last = (width + offset + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+    }\n+\n+  /* Paradoxical truncation.  */\n+  if (start < 0)\n+    start = 0;\n+  if (last > m2_size)\n+    last = m2_size;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"    cpb extract regno=%d start=%d last=%d\\n\", \n+\t     DF_REF_REGNO (ref), start, last);\n+  \n+  *start_byte = start;\n+  *last_byte = last;\n+  return false;\n+}\n+\n+\n+/* Helper for df_compute_accessed_bytes.  Ref is a strict_low_part.\n+   Return true if this effects the entire reg in REF. Return false if\n+   otherwise and set START_BYTE and LAST_BYTE.  */ \n+\n+static bool \n+df_compute_accessed_bytes_strict_low_part (struct df_ref *ref, \n+\t\t\t\t\t   unsigned int *start_byte, \n+\t\t\t\t\t   unsigned int *last_byte)\n+{\n+  int start;\n+  int last;\n+  rtx reg = DF_REF_REG (ref);\n+  enum machine_mode m1;\n+  int m1_size;\n+  enum machine_mode m2;\n+  int m2_size;\n+  int offset;\n+\n+  /* In order to accomodate multiword subregs of a hardreg, df_scan\n+     eats the subreg and it can only be found from the loc.  */\n+  if (REG_P (reg))\n+    reg = *(DF_REF_LOC (ref));\n+\n+  m1 = GET_MODE (reg);\n+  m1_size = GET_MODE_SIZE (m1);\n+  m2 = GET_MODE (SUBREG_REG (reg));\n+  m2_size = GET_MODE_SIZE (m2);\n+  offset = SUBREG_BYTE (reg);\n+\n+  /* It does not seem to be meaningful to apply a strict_low_part of a\n+     paradoxical register.  */\n+  gcc_assert (m1_size <= m2_size);\n+\n+  /* (set (strict_low_part (subreg:M1 (reg:M2 X) N)) ...)\n+      \n+  This is a bitfield insertion.  The assignment clobbers exactly the\n+  bits named by the subreg--the M1 bits at position N.  It is also\n+  technically possible that the bits asked for are longer than units\n+  per word.  */\n+  \n+  start = offset;\n+  last = offset + m1_size;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"    cpb strict low part regno=%d start=%d last=%d\\n\", \n+\t     DF_REF_REGNO (ref), start, last);\n+\n+  *start_byte = start;\n+  *last_byte = last;\n+  return false;\n+}\n+\n+/* Helper for df_compute_accessed_bytes.  Ref is a naked subreg.\n+   Return true if this effects the entire reg in REF. Return false if\n+   otherwise and set START_BYTE and LAST_BYTE.  */ \n+\n+static bool \n+df_compute_accessed_bytes_subreg (struct df_ref *ref, unsigned int *start_byte, \n+\t\t\t\t  unsigned int *last_byte)\n+\n+{\n+  /* (subreg:M1 (reg:M2 X) N) */\n+  int start;\n+  int last;\n+  rtx reg = DF_REF_REG (ref);\n+\n+  enum machine_mode m1;\n+  int m1_size;\n+  enum machine_mode m2;\n+  int m2_size;\n+\n+  /* In order to accomodate multiword subregs of a hardreg, df_scan\n+     eats the subreg and it can only be found from the loc.  */\n+  if (REG_P (reg))\n+    reg = *(DF_REF_LOC (ref));\n+\n+  m1 = GET_MODE (reg);\n+  m1_size = GET_MODE_SIZE (m1);\n+  m2 = GET_MODE (SUBREG_REG (reg));\n+  m2_size = GET_MODE_SIZE (m2);\n+\n+  /* A simple paradoxical subreg just accesses the entire inner reg.  */\n+  if (m1_size >= m2_size)\n+    return true;\n+\n+  /* Defs and uses are different in the amount of the reg that touch.  */\n+  if (DF_REF_TYPE (ref) == DF_REF_REG_DEF)\n+    {\n+      /* This is an lvalue.  */ \n+\n+      if (m2_size > UNITS_PER_WORD)\n+\t{\n+\t  /* The assignment clobbers UNITS_PER_WORD segments of X.\n+\t     Look at the bytes named by the subreg, and expand it to\n+\t     cover a UNITS_PER_WORD part of register X.  That part of\n+\t     register X is clobbered, the rest is not.\n+\t     \n+\t     E.g., (subreg:SI (reg:DI X) 0), where UNITS_PER_WORD is the\n+\t     size of SImode, clobbers the first SImode part of X, and does\n+\t     not affect the second SImode part.\n+\t     \n+\t     E.g., (subreg:QI (reg:DI X) 0), where UNITS_PER_WORD is the\n+\t     size of SImode, clobbers the first SImode part of X, and does\n+\t     not affect the second SImode part.  Here the QImode byte is\n+\t     expanded to a UNITS_PER_WORD portion of the register for\n+\t     purposes of determining what is clobbered.\n+\t     \n+\t     If this is an rvalue, then it touches just the bytes that it\n+\t     talks about.  */\n+\t  int offset = SUBREG_BYTE (reg);\n+\t  \n+\t  start = offset & ~(UNITS_PER_WORD - 1);\n+\t  last = (offset + m1_size + UNITS_PER_WORD - 1) \n+\t    & ~(UNITS_PER_WORD - 1);\n+\t}\n+      else\n+\t/* Whole register size M2 equal to or smaller than\n+\t   UNITS_PER_WORD The assignment clobbers the entire register\n+\t   X.  */\n+\treturn true;\n+    }\n+  else \n+    {\n+      /* This is an rvalue. It touches just the bytes they explicitly\n+\t mentioned.  */\n+      int offset = SUBREG_BYTE (reg);\n+      start = offset;\n+      last = start + m1_size;\n+    }\n+  \n+  if (dump_file)\n+    fprintf (dump_file, \"    cpb subreg regno=%d start=%d last=%d\\n\", \n+\t     DF_REF_REGNO (ref), start, last);\n+\n+  *start_byte = start;\n+  *last_byte = last;\n+  return false;\n+}\n+\n+\n+/* Compute the set of affected bytes by a store to a pseudo to REF.\n+   MM is either DF_MM_MAY or DF_MM_MUST.  This is only relevant for\n+   the extracts which are not aligned to byte boundaries.  The\n+   DF_MM_MAY returns all of the bytes that any bit is set in and the\n+   DF_MM_MUST returns only the bytes that are completely covered.  In\n+   general DF_MM_MAY is used for uses and DF_MM_MUST is used for defs,\n+   but there are exceptions such as the inner loop of the byte level\n+   dead code eliminator which needs DF_MM_MAY for the defs to see if\n+   it any possible bit could be used.\n+\n+   If the store is to the whole register, just return TRUE, if it is\n+   to part of the register, return FALSE and set START_BYTE and\n+   LAST_BYTE properly.  In the case where fabricated uses are passed\n+   in, START_BYTE and LAST_BYTE are set to 0 and false is returned.\n+   This means that this use can be ignored.  */\n+\n+bool \n+df_compute_accessed_bytes (struct df_ref *ref, enum df_mm mm, \n+\t\t\t   unsigned int *start_byte, \n+\t\t\t   unsigned int *last_byte)\n+{\n+  if (!dbg_cnt (df_byte_scan))\n+    return true;\n+\n+  if (DF_REF_TYPE (ref) != DF_REF_REG_DEF \n+      && DF_REF_FLAGS_IS_SET (ref, DF_REF_READ_WRITE))\n+    {\n+      if (DF_REF_FLAGS_IS_SET (ref, DF_REF_PRE_POST_MODIFY))\n+\t/* Pre/post modify/inc/dec always read and write the entire\n+\t   reg.  */\n+\treturn true;\n+      else\n+\t{\n+\t  /* DF_REF_READ_WRITE on a use (except for the\n+\t     DF_REF_PRE_POST_MODIFY) means that this use is fabricated\n+\t     from a def that is a partial set to a multiword reg.\n+\t     Here, we only model those cases precisely so the only one\n+\t     to consider is the use put on a auto inc and dec\n+\t     insns.  */\n+\t  *start_byte = 0;\n+\t  *last_byte = 0;\n+\t  return false;\n+\t}\n+    }\n+\n+  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+    return df_compute_accessed_bytes_extract (ref, mm, start_byte, last_byte);\n+  else if (DF_REF_FLAGS_IS_SET (ref, DF_REF_STRICT_LOW_PART))\n+    return df_compute_accessed_bytes_strict_low_part (ref, \n+\t\t\t\t\t\t      start_byte, last_byte);\n+  else if (GET_CODE (DF_REF_REG (ref)) == SUBREG)\n+    return df_compute_accessed_bytes_subreg (ref, start_byte, last_byte);\n+  return true;\n+}\n+"}]}