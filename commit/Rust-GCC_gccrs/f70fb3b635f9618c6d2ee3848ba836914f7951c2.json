{"sha": "f70fb3b635f9618c6d2ee3848ba836914f7951c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcwZmIzYjYzNWY5NjE4YzZkMmVlMzg0OGJhODM2OTE0Zjc5NTFjMg==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2015-06-01T15:18:19Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2015-06-01T15:18:19Z"}, "message": "re PR target/65697 (__atomic memory barriers not strong enough for __sync builtins)\n\n        PR target/65697\n\t* config/aarch64/aarch64.c (aarch64_emit_post_barrier):New.\n\t(aarch64_split_atomic_op): Check for __sync memory models, emit\n\tappropriate initial loads and final barriers.\n\nFrom-SVN: r223983", "tree": {"sha": "fe81d44ef889699582bcebedca3d4329ff80c8fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe81d44ef889699582bcebedca3d4329ff80c8fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f70fb3b635f9618c6d2ee3848ba836914f7951c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70fb3b635f9618c6d2ee3848ba836914f7951c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70fb3b635f9618c6d2ee3848ba836914f7951c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70fb3b635f9618c6d2ee3848ba836914f7951c2/comments", "author": null, "committer": null, "parents": [{"sha": "fc65eccabc6d6e881ff5efcd674aa3791cf8cee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc65eccabc6d6e881ff5efcd674aa3791cf8cee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc65eccabc6d6e881ff5efcd674aa3791cf8cee6"}], "stats": {"total": 38, "additions": 37, "deletions": 1}, "files": [{"sha": "0c109c33c0a50d9bde8b259ccf4bbf60ec1f4821", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f70fb3b635f9618c6d2ee3848ba836914f7951c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f70fb3b635f9618c6d2ee3848ba836914f7951c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f70fb3b635f9618c6d2ee3848ba836914f7951c2", "patch": "@@ -1,3 +1,10 @@\n+2015-06-01  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+        PR target/65697\n+\t* config/aarch64/aarch64.c (aarch64_emit_post_barrier):New.\n+\t(aarch64_split_atomic_op): Check for __sync memory models, emit\n+\tappropriate initial loads and final barriers.\n+\n 2015-06-01  Vidya Praveen  <vidya.praveen@atmel.com>\n \n \t* Makefile.in: Fix gcov dependencies that should"}, {"sha": "93bea074d6831b2aea2c0a40dacddc9ad20788c7", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f70fb3b635f9618c6d2ee3848ba836914f7951c2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f70fb3b635f9618c6d2ee3848ba836914f7951c2/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f70fb3b635f9618c6d2ee3848ba836914f7951c2", "patch": "@@ -9409,6 +9409,23 @@ aarch64_expand_compare_and_swap (rtx operands[])\n   emit_insn (gen_rtx_SET (bval, x));\n }\n \n+/* Emit a barrier, that is appropriate for memory model MODEL, at the end of a\n+   sequence implementing an atomic operation.  */\n+\n+static void\n+aarch64_emit_post_barrier (enum memmodel model)\n+{\n+  const enum memmodel base_model = memmodel_base (model);\n+\n+  if (is_mm_sync (model)\n+      && (base_model == MEMMODEL_ACQUIRE\n+\t  || base_model == MEMMODEL_ACQ_REL\n+\t  || base_model == MEMMODEL_SEQ_CST))\n+    {\n+      emit_insn (gen_mem_thread_fence (GEN_INT (MEMMODEL_SEQ_CST)));\n+    }\n+}\n+\n /* Split a compare and swap pattern.  */\n \n void\n@@ -9471,6 +9488,8 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n {\n   machine_mode mode = GET_MODE (mem);\n   machine_mode wmode = (mode == DImode ? DImode : SImode);\n+  const enum memmodel model = memmodel_from_int (INTVAL (model_rtx));\n+  const bool is_sync = is_mm_sync (model);\n   rtx_code_label *label;\n   rtx x;\n \n@@ -9485,7 +9504,13 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n     old_out = new_out;\n   value = simplify_gen_subreg (wmode, value, mode, 0);\n \n-  aarch64_emit_load_exclusive (mode, old_out, mem, model_rtx);\n+  /* The initial load can be relaxed for a __sync operation since a final\n+     barrier will be emitted to stop code hoisting.  */\n+ if (is_sync)\n+    aarch64_emit_load_exclusive (mode, old_out, mem,\n+\t\t\t\t GEN_INT (MEMMODEL_RELAXED));\n+  else\n+    aarch64_emit_load_exclusive (mode, old_out, mem, model_rtx);\n \n   switch (code)\n     {\n@@ -9521,6 +9546,10 @@ aarch64_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n   x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n \t\t\t    gen_rtx_LABEL_REF (Pmode, label), pc_rtx);\n   aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n+\n+  /* Emit any final barrier needed for a __sync operation.  */\n+  if (is_sync)\n+    aarch64_emit_post_barrier (model);\n }\n \n static void"}]}