{"sha": "6cfea11bd14394d177d61efd1f1cc908ce5534b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmZWExMWJkMTQzOTRkMTc3ZDYxZWZkMWYxY2M5MDhjZTU1MzRiMg==", "commit": {"author": {"name": "Tim Josling", "email": "tej@melbpc.org.au", "date": "2002-05-05T04:24:18Z"}, "committer": {"name": "Tim Josling", "email": "timjosling@gcc.gnu.org", "date": "2002-05-05T04:24:18Z"}, "message": "Added new sample language treelang.\n\nFrom-SVN: r53169", "tree": {"sha": "f9f7f1ab980437234d5a7681a7427727d00adb41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9f7f1ab980437234d5a7681a7427727d00adb41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cfea11bd14394d177d61efd1f1cc908ce5534b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cfea11bd14394d177d61efd1f1cc908ce5534b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cfea11bd14394d177d61efd1f1cc908ce5534b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cfea11bd14394d177d61efd1f1cc908ce5534b2/comments", "author": null, "committer": null, "parents": [{"sha": "6d030676cc896eeb605f7997f76942a7734b661b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d030676cc896eeb605f7997f76942a7734b661b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d030676cc896eeb605f7997f76942a7734b661b"}], "stats": {"total": 5383, "additions": 5383, "deletions": 0}, "files": [{"sha": "e3d6c49aed27150563830d0787806a6dc39fa542", "filename": "gcc/testsuite/lib/treelang.exp", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Flib%2Ftreelang.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Flib%2Ftreelang.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftreelang.exp?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,20 @@\n+# Copyright (C) 1988, 90, 91, 92, 95, 96, 1997, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+# Having this file here magically tells dejagnu that the treelang\n+# directory is worthy of testing\n+\n+"}, {"sha": "d7f7c78948bbcb84b169f1d106b8c37d48363302", "filename": "gcc/testsuite/treelang/ChangeLog", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2FChangeLog?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,40 @@\n+2002-04-13  Tim Josling  <tej@melbpc.org.au>\n+      * treetree.c (tree_code_create_function_initial)\n+      Remove duplicate call to layout_decl\n+\n+2001-12-02  Tim Josling  <tej@melbpc.org.au>\n+      * Make-lang.in\n+      Ensure directory is built during install (installdirs dependency)\n+\n+      * lex.l\n+      Work around poisoned malloc (undef IN_GCC)\n+      Remove fake definition of tree.\n+\n+      * parse.y\n+      Work around poisoned malloc (undef IN_GCC)\n+\n+      * tree1.c\n+      New front end interface. \n+      (top level) New structure lang_hooks.\n+      (tree_post_options) Remove. \n+      errorcount now a macro so do not define it.\n+      current_nesting_level => work_nesting_level due to clash. \n+\n+      * treelang.h\n+      errorcount now a macro so do not reference it.\n+\n+      * treetree.c\n+      Replace NULL_PTR by NULL.\n+      (tree_code_get_expression) Mark op3 unused.\n+      Do not init builtins.\n+\n+2001-06-11  Tim Josling  <tej@melbpc.org.au>\n+\n+\t* treelang.exp (global) remove COBOL specific code. \n+\n+2001-05-24  Tim Josling  <tej@melbpc.org.au>\n+\n+        Created this directory and its tests. All derived from the cobol\n+\ttest swamp which was also all written by me.\n+\t\n+"}, {"sha": "908131bd110a5ff449a13e1f228c2cdcdeb1a2d9", "filename": "gcc/testsuite/treelang/Makefile.in", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2FMakefile.in?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,9 @@\n+# Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+all: \n+\n+clean:\n+\t-rm -f *.o *.diff *~ *.bad core *.x\n+\n+distclean:\tclean\n+\t-rm -f Makefile config.status"}, {"sha": "69ab63dac97d0edb5ad087fca930bd26f0bd59e3", "filename": "gcc/testsuite/treelang/a01gcci01.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.c?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,19 @@\n+/* Driver for treelang test pgm */\n+\n+int add(int, int);\n+int subtract(int, int);\n+int first_nonzero(int, int);\n+\n+int \n+main (int argc, char *argv[])\n+{\n+  printf(\"2:%d\\n\", add(1,1));\n+  printf(\"7:%d\\n\", add(3,4));\n+  printf(\"-1:%d\\n\", subtract(3,4));\n+  printf(\"1:%d\\n\", subtract(2,1));\n+  printf(\"3:%d\\n\", first_nonzero(0,3));\n+  printf(\"0:%d\\n\", first_nonzero(0,0));\n+  printf(\"1:%d\\n\", first_nonzero(1,0));\n+  printf(\"15:%d\\n\", double_plus_one(7));\n+  return 0;\n+}"}, {"sha": "e1e1ac1659fbc230a535f3156e400ec9688c091b", "filename": "gcc/testsuite/treelang/a01gcci01.tree", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fa01gcci01.tree?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,39 @@\n+// -*- c -*- c mode in emacs\n+\n+external_definition int add(int arg1, int arg2);\n+external_definition int subtract(int arg3, int arg4);\n+external_definition int first_nonzero(int arg5, int arg6);\n+external_definition int double_plus_one(int arg7);\n+\n+add \n+{\n+  return arg1 + arg2;\n+}\n+\n+        \n+subtract \n+{\n+  return arg3 - arg4;\n+}\n+\n+double_plus_one\n+{\n+  automatic int aaa;\n+  aaa=add(arg7, arg7);\n+  aaa=add(aaa, aaa);\n+  aaa=subtract(subtract(aaa, arg7), arg7) + 1;\n+  return aaa;\n+}\n+\n+first_nonzero\n+{\n+  if (arg5)\n+    {\n+      return arg5;\n+    }\n+  else\n+    {\n+    }\n+  return arg6;\n+}\n+"}, {"sha": "3c2c743c77d9a89de567d0bcee6d01d325015a51", "filename": "gcc/testsuite/treelang/a01gcco01runpgm", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Fa01gcco01runpgm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Fa01gcco01runpgm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fa01gcco01runpgm?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,8 @@\n+2:2\n+7:7\n+-1:-1\n+1:1\n+3:3\n+0:0\n+1:1\n+15:15"}, {"sha": "10e6f8419c1e70642a79a4cd4fd70354c18cfdae", "filename": "gcc/testsuite/treelang/treetests.exp", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Ftreetests.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftestsuite%2Ftreelang%2Ftreetests.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Ftreetests.exp?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,289 @@\n+\n+# Tests for treelang; run from gcc/treelang/Make-lang.in => gcc/Makefile\n+\n+# Copyright (C) 1999, 2000, 2001, 2002 by The Free Software Foundation\n+\n+# find ttt for the actual tests\n+\n+# Check the pgm is even there and set up the basics\n+proc init_utility {pgm} {\n+    global transform\n+    global pgm_actual\n+    global pgm_base\n+    global fix_progname\n+    global path\n+# maybe add \"X\" to front of fail to say it is an expected failure\n+    global X\n+\n+    set pgm_base ${pgm}\n+    set pgm_actual ${pgm}\n+\n+    if { ${transform} != \"s,x,x,\"} {\n+        verbose \"1. program name was ${pgm}\" 2\n+        set sed_rc [catch {eval exec sed -e \"${transform}\" <<${pgm} } catch_res]\n+        if { ${sed_rc} != \"0\" } {\n+            verbose \"2. Program name transform failed rc=${sed_rc} stat=${catch_res}\" 1\n+            ${X}fail \"${pgm} sed\"\n+            return 0\n+        }\n+        set pgm_actual ${catch_res}\n+        verbose \"3. program name after transformation is ${pgm_actual}\" 2\n+    }\n+\n+    set which_rc [catch {exec which ${pgm_actual}} stat]\n+    if { ${which_rc} != \"0\" } {\n+        verbose \"4. ${pgm_base} cannot be found rc=${which_rc} stat=${stat}\" 1\n+        ${X}fail \"${pgm} = ${pgm_actual} not found in path (${path})\"\n+        return 0\n+    }\n+    set fix_progname \"s,${pgm_actual},${pgm_base},\"\n+    verbose \"5. fix program name value = ${fix_progname}\" 4\n+    return 1\n+}\n+\n+#run pgm, option to remove file names from outputs\n+proc run3 {srcdd testdd parms group_nbr item_nbr nonzero_RC_expected check_file sanitize_output tree1 pipe} {\n+\n+    global transform\n+    global pgm_actual\n+    global pgm_base\n+    global fix_progname\n+    global X\n+    global extras\n+\n+    set error_msg 0\n+    set basefile \"a${group_nbr}${pgm_base}.out${item_nbr}\"\n+    set infile  \"\"\n+    set outfile  \"\"\n+    set suffix \"\"\n+    set temp_extras \"-O3 \"\n+    set real_pgm_actual ${pgm_actual}\n+\n+    if  {${tree1} > 0} {\n+        if {\"${pgm_actual}\" == \"gcc\"} {\n+            set real_pgm_actual \"xgcc\"\n+            set temp_extras \"${extras}\"\n+        }\n+        set infile \"${srcdd}/a${group_nbr}${pgm_base}i${item_nbr}.tree\"\n+        set mainfile \"${srcdd}/a${group_nbr}${pgm_base}i${item_nbr}.c\"\n+        set outfile \"-o ${testdd}/a${group_nbr}${pgm_base}o${item_nbr}${suffix}\"\n+    }\n+    \n+    verbose \"6. exec ${real_pgm_actual} ${temp_extras} ${parms} ${mainfile} ${infile} ${outfile} >${testdd}/${basefile} 2>${testdd}/${basefile}err\" 2\n+    set run_rc [catch {eval exec ${real_pgm_actual} ${temp_extras} ${parms} ${mainfile} ${infile} ${outfile} >${testdd}/${basefile} 2>${testdd}/${basefile}err} catch_res]\n+    if {${run_rc} == 1} {\n+        if {${nonzero_RC_expected} == 0} {\n+            verbose \"7. ${real_pgm_actual} ${group_nbr} ${item_nbr} failed due to rc=${run_rc} status=${catch_res}\" 1\n+            ${X}fail \"${pgm_base} ${group_nbr} ${item_nbr} rc!=0\" \n+            return\n+        } \n+    } else {\n+        if {${nonzero_RC_expected} == 1} {\n+            verbose \"8. ${pgm_actual} ${group_nbr} ${item_nbr} failed - did not produce nonzero return code as expected rc=${run_rc} status=${catch_res}\" 1\n+            ${X}fail \"${pgm_base} ${group_nbr} ${item_nbr} rc=0\" \n+            return\n+        } \n+    }\n+\n+# change the filenames to (file) in output if needed to allow testing\n+    set checkfile1 \"${srcdd}/${basefile}\"\n+    set checkfile2 \"${testdd}/${basefile}\"\n+    if {${sanitize_output} != 0} {\n+        set oldcheckfile1 \"${checkfile1}\"\n+        set oldcheckfile2 \"${checkfile2}\"\n+        set checkfile1 \"${testdd}/${basefile}.test.nofilename\"\n+        set checkfile2 \"${testdd}/${basefile}.run.nofilename\"\n+        set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile1} >${checkfile1}} catch_res]\n+        if {${run_rc} == 1} {\n+            verbose \"9. sed to cleanup filenames (std 1) in pgm output failed due to rc=${run_rc} status=${catch_res}\" 1\n+            if  {${error_msg} == 0} {\n+                set error_msg \"9. sed to cleanup filenames (std 1) in pgm output failed due to rc=${run_rc} status=${catch_res}\"\n+            }\n+        }\n+        set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile2} | sed -e  \"${fix_progname}\"  >${checkfile2}} catch_res]\n+        if {${run_rc} == 1} {\n+            verbose \"10. sed to cleanup filenames (std 2) in pgm output failed due to rc=${run_rc} status=${catch_res}\" 1\n+            if  {${error_msg} == 0} {\n+                set error_msg \"10. sed to cleanup filenames (std 2) in pgm output failed due to rc=${run_rc} status=${catch_res}\" \n+            }\n+        }\n+    }\n+    set diff [diff ${checkfile1} ${checkfile2}]\n+    if {${diff} != 1} {\n+        verbose \"11. ${pgm_actual} ${group_nbr} ${item_nbr} diff stdout failed rc=${diff}\" 1\n+        if  {${error_msg} == 0} {\n+            set error_msg \"11. ${pgm_actual} ${group_nbr} ${item_nbr} diff stdout failed rc=${diff}\"\n+        }\n+    }\n+\n+    set checkfile1 \"${srcdd}/${basefile}err\"\n+    set checkfile2 \"${testdd}/${basefile}err\"\n+    if {${sanitize_output} != 0} {\n+        set oldcheckfile1 \"${checkfile1}\"\n+        set oldcheckfile2 \"${checkfile2}\"\n+        set checkfile1 \"${testdd}/${basefile}err.test.nofilename\"\n+        set checkfile2 \"${testdd}/${basefile}err.run.nofilename\"\n+        set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile1} >${checkfile1}} catch_res]\n+        if {${run_rc} == 1} {\n+            verbose \"12. sed to cleanup filenames (err 1) in pgm output failed due to rc=${run_rc} status=${catch_res}\" 1\n+            if  {${error_msg} == 0} {\n+                set error_msg \"12. sed to cleanup filenames (err 1) in pgm output failed due to rc=${run_rc} status=${catch_res}\"\n+            }\n+        }\n+        set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile2} | sed -e  \"${fix_progname}\"  >${checkfile2}} catch_res]\n+        if {${run_rc} == 1} {\n+            verbose \"13. sed to cleanup filenames (err 2) in pgm output failed due to rc=${run_rc} status=${catch_res}\" 1\n+            if  {${error_msg} == 0} {\n+                set error_msg \"13. sed to cleanup filenames (err 2) in pgm output failed due to rc=${run_rc} status=${catch_res}\"\n+            }\n+        }\n+    }\n+    set diff [diff ${checkfile1} ${checkfile2}]\n+    if {${diff} != 1} {\n+        verbose \"14. ${pgm_actual} ${group_nbr} ${item_nbr} diff stderr failed rc=${diff}\" 1\n+        if  {${error_msg} == 0} {\n+            set error_msg \"14. ${pgm_actual} ${group_nbr} ${item_nbr} diff stderr failed rc=${diff}\"\n+        }\n+    }\n+\n+    if {${check_file} >0} {\n+        if  {${tree1} == 0} {\n+            set checkfile1 \"${srcdd}/${basefile}file\"\n+            set checkfile2 \"${testdd}/${basefile}file\"\n+            if {${sanitize_output} != 0} {\n+                set oldcheckfile1 \"${checkfile1}\"\n+                set oldcheckfile2 \"${checkfile2}\"\n+                set checkfile1 \"${testdd}/${basefile}file.test.nofilename\"\n+                set checkfile2 \"${testdd}/${basefile}file.run.nofilename\"\n+                set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile1} >${checkfile1}} catch_res]\n+                if {${run_rc} == 1} {\n+                    verbose \"15. sed to cleanup filenames (err 1) in pgm stdout failed due to rc=${run_rc} status=${catch_res}\" 1\n+                    if  {${error_msg} == 0} {\n+                        set error_msg \"15. sed to cleanup filenames (err 1) in pgm stdout failed due to rc=${run_rc} status=${catch_res}\"\n+                    }\n+                }\n+                set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile2} | sed -e  \"${fix_progname}\"  >${checkfile2}} catch_res]\n+                if {${run_rc} == 1} {\n+                    verbose \"16. sed to cleanup filenames (err 2) in pgm stdout failed due to rc=${run_rc} status=${catch_res}\" 1\n+                    if  {${error_msg} == 0} {\n+                        set error_msg \"16. sed to cleanup filenames (err 2) in pgm stdout failed due to rc=${run_rc} status=${catch_res}\"\n+                    }\n+                }\n+            }\n+            set diff [diff ${checkfile1} ${checkfile2}]\n+            if {${diff} != 1} {\n+                verbose \"17. ${pgm_actual} ${group_nbr} ${item_nbr} diff stdout file failed rc=${diff}\" 1\n+                if  {${error_msg} == 0} {\n+                    set error_msg \"17. ${pgm_actual} ${group_nbr} ${item_nbr} diff stdout file failed rc=${diff}\"\n+                }\n+            }\n+        }\n+    }\n+    \n+    if {${check_file} >1} {\n+        if  {${tree1} == 0} {\n+            set checkfile1 \"${srcdd}/${outfile}\"\n+            set checkfile2 \"${testdd}/${outfile}\"\n+            if {${sanitize_output} != 0} {\n+                set oldcheckfile1 \"${checkfile1}\"\n+                set oldcheckfile2 \"${checkfile2}\"\n+                set checkfile1 \"${testdd}/${basefile}out.test.nofilename\"\n+                set checkfile2 \"${testdd}/${basefile}out.run.nofilename\"\n+                set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile1} >${checkfile1}} catch_res]\n+                if {${run_rc} == 1} {\n+                    verbose \"18. sed to cleanup filenames (err 1) in pgm output failed due to rc=${run_rc} status=${catch_res}\" 1\n+                    if  {${error_msg} == 0} {\n+                        set error_msg \"18. sed to cleanup filenames (err 1) in pgm output failed due to rc=${run_rc} status=${catch_res}\"\n+                    }\n+                }\n+                set run_rc [catch {eval exec sed -f ${srcdd}/filefix.sed <${oldcheckfile2} | sed -e  \"${fix_progname}\"  >${checkfile2}} catch_res]\n+                if {${run_rc} == 1} {\n+                    verbose \"19. sed to cleanup filenames (err 2) in pgm output failed due to rc=${run_rc} status=${catch_res}\" 1\n+                    if  {${error_msg} == 0} {\n+                        set error_msg \"19. sed to cleanup filenames (err 2) in pgm output failed due to rc=${run_rc} status=${catch_res}\"\n+                    }\n+                }\n+            }\n+            set diff [diff ${checkfile1} ${checkfile2}]\n+            if {${diff} != 1} {\n+                verbose \"20. ${pgm_actual} ${group_nbr} ${item_nbr} diff output file failed rc=${diff}\" 1\n+                if  {${error_msg} == 0} {\n+                    set error_msg \"20. ${pgm_actual} ${group_nbr} ${item_nbr} diff output file failed rc=${diff}\"\n+                }\n+            }\n+        }\n+    }\n+    \n+    if {${check_file} >2} {\n+        set outfile \"a${group_nbr}${pgm_base}o${item_nbr}${suffix}\"\n+        set pgmrun \"${testdd}/a${group_nbr}${pgm_base}o${item_nbr}${suffix}\"\n+        set checkfile1 \"${srcdd}/${outfile}runpgm\"\n+        set checkfile2 \"${testdd}/${outfile}runpgm\"\n+        verbose \"21. exec ${pgmrun} >${checkfile2} 2>${checkfile2}err\" 2\n+        set run_rc [catch {eval exec ${pgmrun} >${checkfile2} 2>${checkfile2}err} catch_res]\n+        if {${run_rc} == 1} {\n+            if {${nonzero_RC_expected} == 0} {\n+                verbose \"22. ${pgm_actual} ${group_nbr} ${item_nbr} failed due to rc=${run_rc} status=${catch_res}\" 1\n+                ${X}fail \"${pgm_base} ${group_nbr} ${item_nbr} run\" \n+                return\n+            } \n+        } else {\n+            if {${nonzero_RC_expected} == 1} {\n+                verbose \"23. ${pgm_actual} ${group_nbr} ${item_nbr} failed - did not produce nonzero return code as expected rc=${run_rc} status=${catch_res}\" 1\n+                ${X}fail \"${pgm_base} ${group_nbr} ${item_nbr} run\" \n+                return\n+            } \n+        }\n+        set diff [diff ${checkfile1} ${checkfile2}]\n+        if {${diff} != 1} {\n+            verbose \"24. ${pgm_actual} ${group_nbr} ${item_nbr} diff run output file failed rc=${diff}\" 1\n+            if  {${error_msg} == 0} {\n+                set error_msg \"24. ${pgm_actual} ${group_nbr} ${item_nbr} diff run output file failed rc=${diff}\"\n+            }\n+        }\n+        set diff [diff ${checkfile1}err ${checkfile2}err]\n+        if {${diff} != 1} {\n+            verbose \"25. ${pgm_actual} ${group_nbr} ${item_nbr} diff run stderr file failed rc=${diff}\" 1\n+            if  {${error_msg} == 0} {\n+                set error_msg \"25. ${pgm_actual} ${group_nbr} ${item_nbr} diff run stderr file failed rc=${diff}\"\n+            }\n+        }\n+    }\n+\n+    if {${error_msg}>0} {\n+        ${X}fail \"${pgm_base} ${group_nbr} ${item_nbr} fail code=${error_msg}\" \n+    } else {\n+        pass \"${pgm_base} ${group_nbr} ${item_nbr}\" \n+    }\n+    return \n+}\n+\n+set extras \"$env(gcc_extras)\"\n+set path $env(PATH)\n+set transform $env(TRANSFORM)\n+set srcdir $env(srcdir)\n+verbose \"source directory ${srcdir}\\n\" 2\n+verbose \"transform ${transform}\\n\" 2\n+set sourcedir \"${srcdir}/testsuite/treelang\"\n+set testdir \"treelang\"\n+\n+set pgm_actual \"\"\n+\n+# srcdd testdd parms group_nbr item_nbr nonzero_RC_expected check_file sanitize_output tree1\n+\n+# ttt\n+\n+#GCC - main C compiler tests via GCC\n+\n+set X \"\"\n+\n+set check_rc [init_utility \"gcc\"]\n+\n+if {${check_rc} == 1} {\n+#\n+#set X \"x\"\n+set X \"\"\n+    run3 \"${sourcedir}\" \"${testdir}\" \" -g -O3 \" 01 01 0 3 0 1 0\n+set X \"\"\n+}\n+"}, {"sha": "18b7e0841f485a5ef5683a12e4156efd3bf54243", "filename": "gcc/treelang/ChangeLog", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,24 @@\n+2002-05-05  Tim Josling  <tej@melbpc.org.au>\n+\n+\t* Updated for gcc3.2 experimental. Major changes throughout.\n+\n+2002-03-31  Tim Josling  <tej@melbpc.org.au>\n+\n+\t* Make-lang.in: Changes so build and check work more reliably\n+\n+2001-07-30  Tim Josling  <tej@melbpc.org.au>\n+\n+\t* root.texi: remove\n+\t* treelang.texi: updates based on feedback\n+\n+2001-06-11  Tim Josling  <tej@melbpc.org.au>\n+\n+\t* all (all) Revamp code to conform to GCC coding standards, fix\n+\ttypos in texi files. \n+\n+2001-05-11  Tim Josling  <tej@melbpc.org.au>\n+\n+        Create the new language.\n+\n+\t\n+\t"}, {"sha": "bd6f7e35fb8150fcf2dea4b12400fb3ab69ba661", "filename": "gcc/treelang/Make-lang.in", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FMake-lang.in?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,297 @@\n+# Top level makefile fragment for TREELANG For GCC. -*- makefile -*-\n+\n+#   Copyright (C) 1994, 1995, 1997, 1998, 1999 2000, 2001, 2002 Free\n+#   Software Foundation, Inc.\n+\n+#This file is part of GCC.\n+\n+#GCC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GCC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GCC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 59 Temple Place - Suite 330,\n+#Boston, MA 02111-1307, USA.\n+\n+# This file provides the language dependent support in the main Makefile.\n+# Each language makefile fragment must provide the following targets:\n+#\n+# foo.all.build, foo.all.cross, foo.start.encap, foo.rest.encap,\n+# foo.info, foo.dvi,\n+# foo.install-normal, foo.install-common, foo.install-info, foo.install-man,\n+# foo.uninstall, foo.distdir,\n+# foo.mostlyclean, foo.clean, foo.distclean, foo.extraclean,\n+# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n+#\n+# where `foo' is the name of the language.\n+#\n+# It should also provide rules for:\n+#\n+# - making any compiler driver (eg: GCC)\n+# - the compiler proper (eg: treelang)\n+# - define the names for selecting the language in LANGUAGES.\n+#\f\n+\n+## note program-prefix and program-suffix options are not supported\n+## just program_transform_name which is a sed script to transform the\n+## names\n+\n+TREELANGSED = sed\n+TREELANGSEDFLAGS = -n\n+\n+# back end compiler libraries etc\n+TREE_BE_LIBS = $(BACKEND) $(LIBIBERTY) $(INTLLIBS) $(LIBS) $(LIBDEPS) \n+GCC_EXTRAS = -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include\n+\n+# ./xgcc is the just built compiler. See GCC_FOR_TARGET in the GCC Makefile.in.\n+# If this can't be found, you probably have not done a bootstrap of GCC,\n+# which you need to do.\n+\n+# GCC_FOR_TREELANG = ./xgcc $(GCC_EXTRAS)\n+\n+TREE_GENERATED = $(srcdir)/treelang/lex.c $(srcdir)/treelang/parse.c\\\n+\t$(srcdir)/treelang/parse.h $(srcdir)/treelang/parse.output $(srcdir)/treelang/TAGS\n+\n+TREE_SOURCE = ${srcdir}/treelang/parse.y ${srcdir}/treelang/lex.l ${srcdir}/treelang/tree1.c ${srcdir}/treelang/treelang.h ${srcdir}/treelang/treetree.c $(srcdir)/treelang/treetree.h\n+\n+TREE_EXES = tree1$(exeext)\n+\n+#no -Wtraditional warnings, allow long long\n+treelang-warn = $(LOOSE_WARN) -pedantic -Wno-long-long -Wmissing-prototypes -Wmissing-declarations\n+\n+#\f\n+# Define the names for selecting treelang in LANGUAGES.\n+\n+.phony: treelang TREELANG\n+\n+treelang TREELANG:treelang.done\n+\n+treelang.done: tree1$(exeext)\n+\t$(STAMP) treelang.done\n+\n+# no preprocessor\n+\n+# core compiler \n+tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o\\\n+\t$(TREE_BE_LIBS) c-convert.o c-typeck.o c-common.o c-decl.o attribs.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n+\ttreelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o c-convert.o\\\n+\tc-typeck.o c-common.o c-decl.o attribs.o $(TREE_BE_LIBS)\n+\n+#\f\n+# Compiling object files from source files.\n+\n+# object file makes\n+\n+treelang/tree1.o: $(srcdir)/treelang/tree1.c $(srcdir)/treelang/treelang.h $(srcdir)/treelang/parse.h\n+\t$(CC) -o $@ -c $(ALL_CFLAGS) $(INCLUDES) $< \n+\n+treelang/treetree.o: $(srcdir)/treelang/treetree.c $(srcdir)/treelang/treetree.h\n+\t$(CC) -o $@ -c $(ALL_CFLAGS) $(INCLUDES) $< \n+\n+treelang/parse.o: $(srcdir)/treelang/parse.c $(srcdir)/treelang/treelang.h $(srcdir)/treelang/treetree.h\n+\t$(CC) -o $@ -c $(ALL_CFLAGS) $(INCLUDES) $< \n+\n+treelang/lex.o: $(srcdir)/treelang/lex.c $(srcdir)/treelang/parse.h $(srcdir)/treelang/treelang.h\n+\t$(CC) -o $@ -c $(ALL_CFLAGS) $(INCLUDES) $< \n+\n+# generated files the files from lex and yacc are put into the source\n+# directory in case someone wants to build but does not have\n+# lex/yacc\n+\n+$(srcdir)/treelang/lex.c: $(srcdir)/treelang/lex.l\n+\t$(LEX) $(LEXFLAGS) -o$(srcdir)/treelang/lex.c $(srcdir)/treelang/lex.l\n+\n+$(srcdir)/treelang/parse.c $(srcdir)/treelang/parse.h: $(srcdir)/treelang/parse.y\n+\t$(BISON) $(BISONFLAGS) -v $(srcdir)/treelang/parse.y\\\n+\t--output=$(srcdir)/treelang/parse.c --defines\n+# -v\n+\n+#\f\n+# Build hooks:\n+\n+treelang.all.build: treelang\n+treelang.all.cross: \n+\t_error_not_here_yet - havent even thought about it - it may even work\n+\n+treelang.start.encap:\n+treelang.rest.encap: \n+\n+.phony:treelang.info\n+treelang.info: $(srcdir)/treelang/treelang.info\n+\n+$(srcdir)/treelang/treelang.info: $(srcdir)/treelang/treelang.texi\n+\tcd $(srcdir)/treelang && $(MAKEINFO) $(MAKEINFOFLAGS) -I../doc/include \\\n+\t-o $(srcdir)/treelang/treelang.info $(srcdir)/treelang/treelang.texi\n+\n+treelang.dvi: $(srcdir)/treelang/treelang.texi\n+\tTEXINPUTS=$(srcdir)/treelang:$(srcdir):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/treelang/treelang.texi; \\\n+\t  texindex treelang.??; \\\n+\t  TEXINPUTS=$(srcdir)/treelang:$(srcdir):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/treelang/treelang.texi; \\\n+\t  mv treelang.dvi treelang;\n+\n+#\f\n+# Install hooks:\n+\n+# Nothing to do here.\n+treelang.install-normal: treelang.install.common\n+\n+# Install \n+.phony:treelang.install.common\n+.phony:treelang.install\n+\n+treelang.install treelang.install.common treelang.install-common: treelang.install.common.done\n+\n+treelang.install.common.done:  installdirs treelang.done \n+\tfor name in $(TREE_EXES); \\\n+\tdo \\\n+\t   if [ -f $$name ] ; then \\\n+\t    name2=\"`echo \\`basename $$name\\` | sed -e '$(program_transform_name)' `\"; \\\n+\t    rm -f $(bindir)/$$name2$(exeext); \\\n+\t    $(INSTALL_PROGRAM) $$name$(exeext) $(bindir)/$$name2$(exeext); \\\n+\t    chmod a+x $(bindir)/$$name2$(exeext); \\\n+\t  fi ; \\\n+\tdone\n+\t$(STAMP) treelang.install.common.done\n+\n+treelang.install-info: $(srcdir)/treelang/treelang.info\n+\tfor name in $(srcdir)/treelang/treelang.info; \\\n+\tdo \\\n+\t   if [ -f $$name ] ; then \\\n+\t    name2=\"`echo \\`basename $$name\\` | sed -e '$(program_transform_name)' `\"; \\\n+\t    rm -f $(libsubdir)/$$name2$(exeext); \\\n+\t    $(INSTALL_PROGRAM) $$name$(exeext) $(libsubdir)/$$name2$(exeext); \\\n+\t    chmod a+x $(libsubdir)/$$name2$(exeext); \\\n+\t  fi ; \\\n+\tdone\n+\n+treelang.install-man: \n+\n+treelang.uninstall:\n+\tfor name in $(TREE_EXES); \\\n+\tdo \\\n+\t  echo $$name; \\\n+\t  name2=\"`echo $$name | sed -e '$(program_transform_name)' `\"; \\\n+\t  echo becomes $$name2; \\\n+\t  echo -rm -rf $(bindir)/$$name2$(exeext); \\\n+\t  rm -rf $(bindir)/$$name2$(exeext); \\\n+\tdone\n+\t-rm treelang.install.common.done\n+\n+#\f\n+# Clean hooks:\n+# A lot of the ancillary files are deleted by the main makefile.\n+# We just have to delete files specific to us.\n+\n+treelang.mostlyclean: \n+\tfor name in $(TREE_EXES); \\\n+\tdo \\\n+\t  echo deleting $$name; \\\n+\t  if [ -f treelang/$$name$(exeext) ] ; then \\\n+\t    rm -f treelang/$$name$(exeext); \\\n+\t  fi ; \\\n+\tdone\n+\t-rm -f treelang/*.o\n+\t-rm treelang.done\n+\n+\n+treelang.clean: treelang.mostlyclean\n+\n+treelang.distclean: treelang.clean\n+\t-rm -f treelang/config.status \n+\t-rm -f treelang/*.output\n+\n+treelang.extraclean: treelang.distclean\n+\n+treelang.maintainer-clean: treelang.extraclean\n+\tfor name in $(TREE_GENERATED); \\\n+\tdo \\\n+\t  if [ -f $(srcdir)/treelang/$$name ] ; then \\\n+             echo deleting $(srcdir)/treelang/$$name; \\\n+\t     rm -f $(srcdir)/treelang/$$name; \\\n+\t  fi ; \\\n+\tdone\n+\t-rm -R $(srcdir)/treelang/*~\n+\n+\n+#\f\n+# Stage hooks:\n+# The main makefile has already created stage?/treelang.\n+\n+treelang.stage1: stage1-start\n+\t-mv treelang/*$(objext) stage1/treelang\n+treelang.stage2: stage2-start\n+\t-mv treelang/*$(objext) stage2/treelang\n+treelang.stage3: stage3-start\n+\t-mv treelang/*$(objext) stage3/treelang\n+treelang.stage4: stage4-start\n+\t-mv treelang/*$(objext) stage4/treelang\n+#\f\n+# Maintenance hooks:\n+\n+# This target creates the files that can be rebuilt, but go in the\n+# distribution anyway.  It then copies the files to the distdir directory.\n+treelang.distdir:\n+#\tnot here yet sorry not sure if this is needed or not???\n+\n+# test hook\n+# the other languages are hard coded in the main makefile.in - that seems to be wrong \n+\n+check: treelang.check\n+\n+TESTSUITEDIR = testsuite\n+\n+treelang.check: $(TESTSUITEDIR)/site.exp\n+\t-mkdir testsuite/treelang \n+\n+# these three files are empty and it seems diff has trouble generating\n+# patch files for new empty files as required for cvs.\n+# STAMP does not cut it here as I need an empty file.\n+\ttouch $(srcdir)/testsuite/treelang/{a01gcco01runpgmerr,a01gcc.out01,a01gcc.out01err}\n+\t-rootme=`pwd`; export rootme; \\\n+\tsrcdir=`cd ${srcdir}; pwd` ; export srcdir ; \\\n+\tcd testsuite; \\\n+\tEXPECT=${EXPECT} ; export EXPECT ; \\\n+\tTRANSFORM=$(program_transform_name); export TRANSFORM; \\\n+\tif [ -f $${rootme}/../expect/expect ] ; then  \\\n+\t   TCL_LIBRARY=`cd .. ; cd ${srcdir}/../tcl/library ; pwd` ; \\\n+\t   export TCL_LIBRARY ; fi ; \\\n+\tPATH=`cd ..;pwd`:$$PATH; export PATH; \\\n+\tgcc_extras=\"-B`cd ..;pwd` -B`cd ..;pwd`/treelang\"; export gcc_extras; \\\n+\t$(RUNTEST) --tool treelang $(RUNTESTFLAGS)\n+\trm $(srcdir)/testsuite/treelang/{a01gcco01runpgmerr,a01gcc.out01,a01gcc.out01err}\n+#\tGCC_EXTRAS=\"$(GCC_EXTRAS)\"; export GCC_EXTRAS; \\\n+\n+# copy the output files from the current test to source ie say the new results are OK\n+treelang.check.fix: force\n+\tsrcdir=`cd ${srcdir}; pwd` ; export srcdir ; \n+\t-cp testsuite/treelang/*.out* t\n+\t-cp testsuite/treelang/*runpgm* t\n+\t-rm -f t/*nofilename\n+\n+treelang.wc: force\n+\twc  ${TREE_SOURCE}\n+\n+#\f\n+\n+# Update the tags table for emacs find label (alt-.) function\n+TAGS: treelang.tags\n+\n+.PHONY: treelang.tags\n+\n+treelang.tags:\n+\tcd $(srcdir)/treelang;\t\t\t\t\t\t\\\n+\tetags -l c ${TREE_SOURCE}\n+\n+.PHONY: treelang.html\n+\n+treelang.html:\n+\tcd $(srcdir)/treelang && texi2html -I ../doc/include -verbose -menu -split_chapter -number treelang.texi\n+#\tmv treelang*.html $(srcdir)/treelang"}, {"sha": "f16eafcf3413b0bfc1ab157114246379772abca3", "filename": "gcc/treelang/README", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FREADME?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,16 @@\n+This is a sample language front end for GCC.\n+\n+This is a replacement for 'toy' which had potential copyright issues,\n+but more importantly it did not exercise very much of GCC. The intent\n+of this language is that it should provide a cookbook of language\n+elements that you can use in any language front end.\n+\n+To this end, treelang is essentially an implementation of a subset of \n+the GCC back end 'tree' interface in syntax.\n+\n+Thanks to Richard Kenner, Joachim Nadler and many others for helping\n+me to understand enough of GCC to do this.\n+\n+Tim Josling\n+May 2001\n+"}, {"sha": "6cf1f4544f9bd6c93969874070162969842ea3e4", "filename": "gcc/treelang/config-lang.in", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fconfig-lang.in?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,37 @@\n+# Top level configure fragment for GNU C++.\n+# Copyright (C) 1994, 1995, 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+#This file is part of GCC.\n+\n+#GCC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GCC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GCC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 59 Temple Place - Suite 330,\n+#Boston, MA 02111-1307, USA.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# compilers\t- value to add to $(COMPILERS)\n+# stagestuff\t- files to add to $(STAGESTUFF)\n+# diff_excludes\t- files to ignore when building diffs between two versions.\n+\n+language=\"treelang\"\n+\n+compilers=\"tree1\\$(exeext)\"\n+\n+stagestuff=\n+\n+diff_excludes=\"-x lex.c -x parse.c -x parse.h\"\n+headers=\n+build_by_default=\"no\""}, {"sha": "2d60c3ef35b16e06f2ae4e62fe896932a462a271", "filename": "gcc/treelang/lang-options.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flang-options.h?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,29 @@\n+/* Definitions for switches for TREELANG.\n+\n+   Copyright (C) 1995, 96-98, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+DEFINE_LANG_NAME (\"treelang\")\n+     \n+/* This is the contribution to the `lang_options' array in gcc.c for\n+   treelang.  */\n+ {\"-fparser-trace\", N_(\"(debug) trace parsing process\")},\n+ {\"-flexer-trace\", N_(\"(debug) trace lexical analysis\")},\n+\n+"}, {"sha": "4bf8e5df927549405790e9ec08d2e2c48d6f8077", "filename": "gcc/treelang/lang-specs.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flang-specs.h?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,63 @@\n+/* Definitions for specs for TREELANG\n+\n+   The format of the specs file is documented in gcc.c\n+\n+   Copyright (C) 1995, 96-98, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* \n+   This is the contribution to the `default_compilers' array in GCC.c for\n+   treelang.  \n+   \n+   This file must compile with 'traditional', so no ANSI string concatenations\n+   \n+*/\n+\n+{\".tree\", \"@treelang\", NULL},\n+{\".TREE\", \"@treelang\", NULL},\n+{\".tre\", \"@treelang\", NULL},\n+{\".TRE\", \"@treelang\", NULL},\n+{\"@treelang\",\n+    \"tree1\\\n+       %{!Q:-quiet}\\\n+       %{d*}\\\n+       %{m*}\\\n+       %{a}\\\n+       %{g*}\\\n+       %{O*}\\\n+       %{W*}\\\n+       %{w}\\\n+       %{ansi}\\\n+       %{v}\\\n+       %{--help:--help}\\\n+       %{pg:-p}\\\n+       %{p}\\\n+       %{f*}\\\n+       %{pg|p:%{fomit-frame-pointer:%e-pg or -p and -fomit-frame-pointer are incompatible}}\\\n+       %{S:%W{o*}%{!o*:-o %b.s}}\\\n+       %{!S:-o %g.s}\\\n+       %i\\n\\\n+       %{!S:as %a\\\n+       %Y\\\n+       %{c:%W{o*}%{!o*:-o %w%b%O}}\\\n+       %{!c:-o %d%w%u%O}\\\n+       %g.s\\\n+       %A\\n}\\\n+       \", NULL\n+},"}, {"sha": "97b06a6b2198f6690a674c9d0b2840ef2e56a138", "filename": "gcc/treelang/lex.l", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Flex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Flex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flex.l?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,294 @@\n+%{ /* -*- c -*- = mode for emacs editor\n+/* \n+\n+   TREELANG lexical analysis\n+\n+   ---------------------------------------------------------------------\n+\n+   Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   \n+   This program is free software; you can redistribute it and/or modify it \n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+   \n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.\n+   \n+   In other words, you are welcome to use, share and improve this program.\n+   You are forbidden to forbid anyone else to use, share and improve\n+   what you give them.   Help stamp out software-hoarding!  \n+   \n+   ---------------------------------------------------------------------\n+   \n+   Written by Tim Josling 1999-2001, based in part on other parts of\n+   the GCC compiler. \n+ \n+*/\n+\n+/* Avoid poisoned malloc problem.  */\n+#undef IN_GCC\n+\n+#if 0\n+/* tree is defined as void* here to avoid any knowledge of tree stuff in this file.  */\n+typedef void *tree;\n+#endif\n+#include <stdio.h>\n+#if 0\n+#include <ctype.h>\n+#endif\n+#include <memory.h>\n+#include \"ansidecl.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"diagnostic.h\"\n+\n+/* Token defs.  */\n+#include \"treelang.h\"\n+#include \"parse.h\"\n+\n+extern int option_lexer_trace;\n+\n+int yylex (void);\n+void update_yylval (int a); \n+\n+static int next_tree_lineno=1;\n+static int next_tree_charno=1;\n+ \n+static void update_lineno_charno (void);\n+static void dump_lex_value (int lexret);\n+ \n+#define SAVE_RETURN(a) {update_yylval (a); if (option_lexer_trace)\\\n+   {fprintf (stderr, \"\\nlexer returning\"); dump_lex_value (a);} return a;}\n+#define NOT_RETURN(a) {update_yylval (a); if (option_lexer_trace)\\\n+   {fprintf (stderr, \"\\nlexer swallowing\"); dump_lex_value (a);}}\n+\n+%}\n+\n+%option nostack\n+%option nounput\n+%option noyywrap\n+%option pointer\n+%option nodefault\n+\n+%%\n+\n+ { \n+   yylval = my_malloc (sizeof (struct token));\n+   ((struct token*)yylval)->lineno = next_tree_lineno;\n+   ((struct token*)yylval)->charno = next_tree_charno;\n+ }\n+\n+[ \\n]+ {\n+  update_lineno_charno ();\n+    NOT_RETURN (WHITESPACE);\n+}\n+  \n+\"//\".*  {\n+  /* Comment.  */\n+    update_lineno_charno ();\n+    NOT_RETURN (COMMENT);\n+}\n+   \n+\"{\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (LEFT_BRACE);\n+}\n+  \n+\"}\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (RIGHT_BRACE);\n+}\n+  \n+\"(\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (LEFT_PARENTHESIS);\n+}\n+  \n+\")\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (RIGHT_PARENTHESIS);\n+}\n+  \n+\",\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (COMMA);\n+}\n+  \n+\";\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (SEMICOLON);\n+}\n+  \n+\"+\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (PLUS);\n+}\n+  \n+\"-\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (MINUS);\n+}\n+  \n+\"=\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (ASSIGN);\n+}\n+  \n+\"==\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (EQUALS);\n+}\n+  \n+[+-]?[0-9]+ {\n+  update_lineno_charno ();\n+  SAVE_RETURN (INTEGER);\n+}\n+  \n+\"external_reference\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (EXTERNAL_REFERENCE);\n+}\n+  \n+\"external_definition\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (EXTERNAL_DEFINITION);\n+}\n+  \n+\"static\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (STATIC);\n+}\n+  \n+\"automatic\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (STATIC);\n+}\n+  \n+\"int\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (INT);\n+}\n+  \n+\"char\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (CHAR);\n+}\n+  \n+\"void\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (VOID);\n+}\n+  \n+\"unsigned\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (UNSIGNED);\n+}\n+  \n+\"return\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (RETURN);\n+}\n+  \n+\"if\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (IF);\n+}\n+  \n+\"else\" {\n+  update_lineno_charno ();\n+  SAVE_RETURN (ELSE);\n+}\n+  \n+[A-Za-z_]+[A-Za-z_0-9]* {\n+  update_lineno_charno ();\n+  update_yylval (NAME); \n+  if (option_lexer_trace) \n+    {\n+      fprintf (stderr, \"\\nlexer returning\"); \n+      dump_lex_value (NAME);\n+    } \n+  return NAME;\n+}\n+  \n+[^\\n]  {\n+  update_lineno_charno ();\n+  fprintf (stderr, \"%s:%i:%i: Unrecognized character %c\\n\", in_fname, \n+           ((struct token*)yylval)->lineno, \n+           ((struct token*)yylval)->charno, yytext[0]);\n+  errorcount++;\n+}\n+\n+%%\n+\n+/* \n+   Update line number (1-) and character number (1-).  Call this\n+   before processing the token.  */\n+\n+static void \n+update_lineno_charno (void)\n+{\n+   /* Update the values we send to caller in case we sometimes don't\n+      tell them about all the 'tokens' eg comments etc.  */\n+   int yyl;\n+   ((struct token*)yylval)->lineno = next_tree_lineno;\n+   ((struct token*)yylval)->charno = next_tree_charno;\n+   for ( yyl = 0; yyl < yyleng; ++yyl ) \n+      {\n+         if ( yytext[yyl] == '\\n' ) \n+            {\n+               ++next_tree_lineno;\n+               next_tree_charno = 1;\n+            } \n+         else \n+           next_tree_charno++;\n+      }\n+}\n+\n+/* Fill in the fields of yylval - the value of the token.  The token\n+   type is A.  */\n+void \n+update_yylval (int a)\n+{\n+  struct token* tok;\n+  tok=yylval;\n+  \n+  tok->category = token_category;\n+  tok->type = a;\n+  tok->length = yyleng;\n+  /* Have to copy yytext as it is just a ptr into the buffer at the\n+     moment.  */\n+  tok->chars = my_malloc (yyleng + 1);\n+  memcpy (tok->chars, yytext, yyleng);\n+}\n+\n+/* Trace the value LEXRET and the position and token details being\n+   returned by the lexical analyser.  */\n+\n+static void\n+dump_lex_value (int lexret) \n+{\n+  int ix;\n+  fprintf (stderr, \" %d l:%d c:%d ln:%d text=\", lexret,\n+         ((struct token*) yylval)->lineno,\n+         ((struct token*) yylval)->charno,\n+         ((struct token*) yylval)->length);\n+  for (ix = 0; ix < yyleng; ix++) \n+    {\n+      fprintf (stderr, \"%c\", yytext[ix]);\n+    }\n+  fprintf (stderr, \" in hex:\");\n+  for (ix = 0; ix < yyleng; ix++) \n+    {\n+      fprintf (stderr, \" %2.2x\", yytext[ix]);\n+    }\n+  fprintf (stderr, \"\\n\");\n+}  \n+"}, {"sha": "f0c0cefa7ad5877b99d5b413f7f2aeabdbd9317d", "filename": "gcc/treelang/parse.y", "status": "added", "additions": 1001, "deletions": 0, "changes": 1001, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,1001 @@\n+%{ /* -*- c -*- emacs mode c */\n+  /* \n+\n+     TREELANG Compiler parser.  \n+\n+     ---------------------------------------------------------------------\n+\n+     Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+     This program is free software; you can redistribute it and/or modify it\n+     under the terms of the GNU General Public License as published by the\n+     Free Software Foundation; either version 2, or (at your option) any\n+     later version.\n+\n+     This program is distributed in the hope that it will be useful,\n+     but WITHOUT ANY WARRANTY; without even the implied warranty of\n+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+     GNU General Public License for more details.\n+\n+     You should have received a copy of the GNU General Public License\n+     along with this program; if not, write to the Free Software\n+     Foundation, 59 Temple Place - Suite 330,\n+     Boston, MA 02111-1307, USA.\n+\n+     In other words, you are welcome to use, share and improve this program.\n+     You are forbidden to forbid anyone else to use, share and improve\n+     what you give them.   Help stamp out software-hoarding!  \n+\n+     ---------------------------------------------------------------------\n+\n+     Written by Tim Josling 1999-2001, based in part on other parts of\n+     the GCC compiler.\n+ \n+   */\n+\n+  /* \n+\n+     Grammar Conflicts\n+     *****************\n+\n+     There are no conflicts in this grammar.  Please keep it that way.\n+\n+   */\n+\n+#undef IN_GCC\n+\n+typedef void *tree;\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"ansidecl.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"diagnostic.h\"\n+\n+#include \"treelang.h\"\n+#include \"treetree.h\"\n+\n+#define YYDEBUG 1\n+#define YYPRINT(file, type, value) print_token (file, type, value) \n+#define YYERROR_VERBOSE YES\n+\n+\n+extern int option_parser_trace;\n+\n+/* Local prototypes.  */\n+\n+static void yyerror (const char *error_message);\n+int yylex (void);\n+int yyparse (void);\n+void print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value);\n+static struct production *reverse_prod_list (struct production *old_first);\n+static void ensure_not_void (unsigned int type, struct token* name);\n+static int check_type_match (int type_num, struct production *exp);\n+static int get_common_type (struct production *type1, struct production *type2);\n+static struct production *make_integer_constant (struct token* value);\n+static void set_storage (struct production *prod);\n+\n+/* File global variables.  */\n+\n+static struct production *current_function=NULL;\n+\n+%}\n+\n+/* Not %raw - seems to have bugs.  */\n+%token_table\n+\n+/* Punctuation.  */\n+%token RIGHT_BRACE\n+%token LEFT_BRACE\n+%token RIGHT_SQUARE_BRACKET\n+%token LEFT_SQUARE_BRACKET\n+%token RIGHT_PARENTHESIS\n+%token LEFT_PARENTHESIS\n+%token SEMICOLON\n+%token ASTERISK\n+%token COMMA\n+%right EQUALS\n+%right ASSIGN\n+%left  PLUS\n+%left  MINUS\n+\n+/* Literals.  */\n+%token INTEGER\n+\n+/* Keywords.  */\n+%token IF\n+%token ELSE\n+%token RETURN\n+%token CHAR\n+%token INT\n+%token UNSIGNED\n+%token VOID\n+%token TYPEDEF\n+%token NAME\n+%token STATIC\n+%token AUTOMATIC\n+%token EXTERNAL_DEFINITION\n+%token EXTERNAL_REFERENCE\n+\n+/* Tokens not passed to parser.  */\n+%token WHITESPACE\n+%token COMMENT\n+\n+/* Pseudo tokens - productions.  */\n+%token PROD_VARIABLE_NAME\n+%token PROD_TYPE_NAME\n+%token PROD_FUNCTION_NAME\n+%token PROD_INTEGER_CONSTANT\n+%token PROD_PLUS_EXPRESSION\n+%token PROD_MINUS_EXPRESSION\n+%token PROD_ASSIGN_EXPRESSION\n+%token PROD_VARIABLE_REFERENCE_EXPRESSION\n+%token PROD_PARAMETER\n+%token PROD_FUNCTION_INVOCATION\n+%expect 0 \n+%% \n+\n+file:\n+/* Nil.   */ {\n+  /* Nothing to do.  */\n+}\n+|declarations {\n+  /* Nothing to do.  */\n+}\n+;\n+\n+\n+declarations:\n+declaration {\n+  /* Nothing to do.  */\n+}\n+| declarations declaration {\n+  /* Nothing to do.  */\n+}\n+;\n+\n+declaration:\n+variable_def {\n+  /* Nothing to do.  */\n+}\n+|function_prototype {\n+  /* Nothing to do.  */\n+}\n+|function {\n+  /* Nothing to do.  */\n+}\n+;\n+\n+variable_def:\n+storage typename NAME init_opt SEMICOLON {\n+  struct token* tok;\n+  struct production *prod;\n+  tok = $3;\n+  prod = make_production (PROD_VARIABLE_NAME, tok);\n+  SYMBOL_TABLE_NAME (prod) = tok;\n+  EXPRESSION_TYPE (prod) = $2;\n+  VAR_INIT (prod) = $4;\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (prod)));\n+  ensure_not_void (NUMERIC_TYPE (prod), tok);\n+  if (insert_tree_name (prod))\n+    {\n+      YYERROR;\n+    }\n+  STORAGE_CLASS_TOKEN (prod) = $1;\n+  set_storage (prod);\n+\n+  if (VAR_INIT (prod))\n+    {\n+      if (! ((struct production*)VAR_INIT (prod))->code)\n+        abort ();\n+    if (STORAGE_CLASS (prod) == EXTERNAL_REFERENCE_STORAGE)\n+      {\n+        fprintf (stderr, \"%s:%i:%i: External reference variables may not have initial value\\n\", in_fname, \n+                tok->lineno, tok->charno);\n+        print_token (stderr, 0, tok);\n+        errorcount++;\n+        YYERROR;\n+      }\n+    }\n+  prod->code = tree_code_create_variable\n+    (STORAGE_CLASS (prod), \n+     ((struct token*)SYMBOL_TABLE_NAME (prod))->chars,\n+     ((struct token*)SYMBOL_TABLE_NAME (prod))->length,\n+     NUMERIC_TYPE (prod),\n+     VAR_INIT (prod)? ((struct production*)VAR_INIT (prod))->code:NULL,\n+     in_fname,\n+     tok->lineno);\n+  if (!prod->code) \n+    abort ();\n+}\n+;\n+\n+storage:\n+STATIC\n+|AUTOMATIC\n+|EXTERNAL_DEFINITION\n+|EXTERNAL_REFERENCE\n+;\n+\n+parameter:\n+typename NAME {\n+  struct token* tok;\n+  struct production *prod;\n+  struct production *prod2;\n+  tok = $2;\n+  prod = make_production (PROD_VARIABLE_NAME, tok);\n+  SYMBOL_TABLE_NAME (prod) = $2;\n+  EXPRESSION_TYPE (prod) = $1;\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (prod)));\n+  ensure_not_void (NUMERIC_TYPE (prod), tok);\n+  if (insert_tree_name (prod))\n+    {\n+      YYERROR;\n+    }\n+  prod2 = make_production (PROD_PARAMETER, tok);\n+  VARIABLE (prod2) = prod;\n+  $$ = prod2;\n+}\n+;\n+\n+function_prototype:\n+storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n+  struct token* tok;\n+  struct production *prod;\n+  struct production *type;\n+  struct tree_parameter_list* first_parms;\n+  struct tree_parameter_list* last_parms;\n+  struct tree_parameter_list* this_parms;\n+  struct production *this_parm;\n+  struct production *this_parm_var;\n+  tok = $3;\n+  prod = make_production (PROD_FUNCTION_NAME, $3);\n+  SYMBOL_TABLE_NAME (prod) = $3;\n+  EXPRESSION_TYPE (prod) = $2;\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (prod)));\n+  PARAMETERS (prod) = reverse_prod_list ($5); \n+  insert_tree_name (prod);\n+  STORAGE_CLASS_TOKEN (prod) = $1;\n+  set_storage (prod);\n+  switch (STORAGE_CLASS (prod))\n+    { \n+    case STATIC_STORAGE:\n+    case EXTERNAL_DEFINITION_STORAGE:\n+      break;\n+      \n+    case AUTOMATIC_STORAGE:\n+      fprintf (stderr, \"%s:%i:%i: A function cannot be automatic\\n\", in_fname, \n+              tok->lineno, tok->charno);\n+      print_token (stderr, 0, tok);\n+      errorcount++;\n+      YYERROR;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+  type = EXPRESSION_TYPE (prod);\n+  /* Create a parameter list in a non-front end specific format.  */\n+  for (first_parms = NULL, last_parms = NULL, this_parm = PARAMETERS (prod);\n+       this_parm;\n+       this_parm = this_parm->next)\n+    {\n+      if (this_parm->category != production_category)\n+        abort ();\n+      this_parm_var = VARIABLE (this_parm);\n+      if (!this_parm_var)\n+        abort ();\n+      if (this_parm_var->category != production_category)\n+        abort ();\n+      this_parms = my_malloc (sizeof (struct tree_parameter_list));\n+      if (!this_parm_var->main_token)\n+        abort ();\n+      this_parms->variable_name = this_parm_var->main_token->chars;\n+      this_parms->type = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (this_parm_var)));\n+      if (last_parms)\n+        {\n+          last_parms->next = this_parms;\n+          last_parms = this_parms;\n+        }\n+      else\n+        {\n+          first_parms = this_parms;\n+          last_parms = this_parms;\n+        }\n+      this_parms->where_to_put_var_tree = & (( (struct production*)VARIABLE (this_parm))->code);\n+    }\n+  FIRST_PARMS (prod) = first_parms;\n+\n+  prod->code = tree_code_create_function_prototype\n+    (tok->chars, STORAGE_CLASS (prod), NUMERIC_TYPE (type),\n+     first_parms, in_fname, tok->lineno);\n+\n+}\n+;\n+\n+function:\n+NAME LEFT_BRACE {\n+  struct production *proto;\n+  struct production search_prod;\n+  struct token* tok;\n+  struct production *this_parm;\n+  tok = $1;\n+  SYMBOL_TABLE_NAME ((&search_prod)) = tok;\n+  current_function = proto = lookup_tree_name (&search_prod);\n+  if (!proto)\n+    {\n+      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\", in_fname, \n+              tok->lineno, tok->charno);\n+      print_token (stderr, 0, tok);\n+      errorcount++;\n+      YYERROR;\n+    }\n+  if (!proto->code)\n+    abort ();\n+  tree_code_create_function_initial\n+    (proto->code, in_fname, tok->lineno,\n+     FIRST_PARMS (current_function));\n+\n+  /* Check all the parameters have code.  */\n+  for (this_parm = PARAMETERS (proto);\n+       this_parm;\n+       this_parm = this_parm->next)\n+    {\n+      if (! (struct production*)VARIABLE (this_parm))\n+        abort ();\n+      if (! (( (struct production*)VARIABLE (this_parm))->code))\n+        abort ();\n+    }\n+}\n+variable_defs_opt statements_opt RIGHT_BRACE {\n+  struct token* tok;\n+  tok = $1;\n+  tree_code_create_function_wrapup (in_fname, tok->lineno);\n+  current_function = NULL;\n+}\n+;\n+\n+variable_defs_opt:\n+/* Nil.   */ {\n+  $$ = 0;\n+}\n+|variable_defs {\n+  $$ = $1;\n+}\n+;\n+\n+statements_opt:\n+/* Nil.   */ {\n+  $$ = 0;\n+}\n+|statements {\n+  $$ = $1;\n+}\n+;\n+\n+variable_defs:\n+variable_def {\n+  /* Nothing to do.  */\n+}\n+|variable_defs variable_def {\n+  /* Nothing to do.  */\n+}\n+;\n+\n+typename:\n+INT {\n+  struct token* tok;\n+  struct production *prod;\n+  tok = $1;\n+  prod = make_production (PROD_TYPE_NAME, tok);\n+  NUMERIC_TYPE (prod) = SIGNED_INT;\n+  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  $$ = prod;\n+}\n+|UNSIGNED INT {\n+  struct token* tok;\n+  struct production *prod;\n+  tok = $1;\n+  prod = make_production (PROD_TYPE_NAME, tok);\n+  NUMERIC_TYPE (prod) = UNSIGNED_INT;\n+  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  $$ = prod;\n+}\n+|CHAR {\n+  struct token* tok;\n+  struct production *prod;\n+  tok = $1;\n+  prod = make_production (PROD_TYPE_NAME, tok);\n+  NUMERIC_TYPE (prod) = SIGNED_CHAR;\n+  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  $$ = prod;\n+}\n+|UNSIGNED CHAR {\n+  struct token* tok;\n+  struct production *prod;\n+  tok = $1;\n+  prod = make_production (PROD_TYPE_NAME, tok);\n+  NUMERIC_TYPE (prod) = UNSIGNED_CHAR;\n+  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  $$ = prod;\n+}\n+|VOID {\n+  struct token* tok;\n+  struct production *prod;\n+  tok = $1;\n+  prod = make_production (PROD_TYPE_NAME, tok);\n+  NUMERIC_TYPE (prod) = VOID_TYPE;\n+  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  $$ = prod;\n+}\n+;\n+\n+parameters:\n+parameter {\n+  /* Nothing to do.  */\n+  $$ = $1;\n+}\n+|parameters COMMA parameter {\n+  struct production *prod1;\n+  prod1 = $3;\n+  prod1->next = $1; /* Insert in reverse order.  */\n+  $$ = prod1;\n+}\n+;\n+\n+statements:\n+statement {\n+  /* Nothing to do.  */\n+}\n+|statements statement {\n+  /* Nothing to do.  */\n+}\n+;\n+\n+statement:\n+expression SEMICOLON {\n+  struct production *exp;\n+  exp = $1;\n+  tree_code_output_expression_statement (exp->code, in_fname, exp->main_token->lineno);\n+}\n+|return SEMICOLON {\n+  /* Nothing to do.  */\n+}\n+|if_statement {\n+  /* Nothing to do.  */\n+}\n+;\n+\n+if_statement:\n+IF LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {\n+  struct token* tok;\n+  struct production *exp;\n+  tok = $1;\n+  exp = $3;\n+  ensure_not_void (NUMERIC_TYPE (exp), exp->main_token);\n+  tree_code_if_start (exp->code, in_fname, tok->lineno);\n+}\n+LEFT_BRACE statements_opt RIGHT_BRACE {\n+  /* Just let the statements flow.  */\n+}\n+ELSE {\n+  struct token* tok;\n+  tok = $1;\n+  tree_code_if_else (in_fname, tok->lineno);\n+}\n+LEFT_BRACE statements_opt RIGHT_BRACE {\n+  struct token* tok;\n+  tok = $12;\n+  tree_code_if_end (in_fname, tok->lineno);\n+}\n+;\n+\n+\n+return:\n+RETURN expression_opt {\n+  struct production *type_prod;\n+  struct token* ret_tok;\n+  ret_tok = $1;\n+  type_prod = EXPRESSION_TYPE (current_function);\n+  if (NUMERIC_TYPE (type_prod) == VOID)\n+    if ($2 == NULL)\n+      tree_code_generate_return (type_prod->code, NULL);\n+    else\n+      {\n+        fprintf (stderr, \"%s:%i:%i: Redundant expression in return\\n\", in_fname, \n+                ret_tok->lineno, ret_tok->charno);\n+        print_token (stderr, 0, ret_tok);\n+        errorcount++;\n+        tree_code_generate_return (type_prod->code, NULL);\n+      }\n+  else\n+    if ($2 == NULL)\n+      {\n+        fprintf (stderr, \"%s:%i:%i: Expression missing in return\\n\", in_fname, \n+                ret_tok->lineno, ret_tok->charno); \n+        print_token (stderr, 0, ret_tok);\n+        errorcount++;\n+      }\n+    else\n+      {\n+        struct production *exp;\n+        exp = $2;\n+        /* Check same type.  */\n+        if (check_type_match (NUMERIC_TYPE (type_prod), $2))\n+          {\n+            if (!type_prod->code)\n+              abort ();\n+            if (!exp->code)\n+              abort ();\n+            /* Generate the code. */\n+            tree_code_generate_return (type_prod->code, exp->code);\n+          }\n+      }\n+}\n+;\n+\n+expression_opt:\n+/* Nil.   */ {\n+  $$ = 0;\n+}\n+|expression {\n+  struct production *exp;\n+  exp = $1;\n+  if (!exp->code)\n+    abort ();\n+  \n+  $$ = $1;\n+}\n+;\n+\n+expression:\n+INTEGER {\n+  $$ = make_integer_constant ($1);\n+}\n+|variable_ref {\n+  $$ = $1;\n+}\n+|expression PLUS expression {\n+  struct token* tok;\n+  struct production *prod;\n+  struct production *op1;\n+  struct production *op2;\n+  tree type;\n+  \n+  op1 = $1;\n+  op2 = $3;\n+  tok = $2;\n+  ensure_not_void (NUMERIC_TYPE (op1), op1->main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  prod = make_production (PROD_PLUS_EXPRESSION, tok);\n+  NUMERIC_TYPE (prod) = get_common_type (op1, op2);\n+  if (!NUMERIC_TYPE (prod))\n+    YYERROR;\n+  else \n+    {\n+      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+      if (!type)\n+        abort ();\n+      OP1 (prod) = $1;\n+      OP2 (prod) = $3;\n+      \n+      prod->code = tree_code_get_expression\n+        (EXP_PLUS, type, op1->code, op2->code, NULL);\n+    }\n+  $$ = prod;\n+}\n+|expression MINUS expression %prec PLUS {\n+  struct token* tok;\n+  struct production *prod;\n+  struct production *op1;\n+  struct production *op2;\n+  tree type;\n+  \n+  op1 = $1;\n+  op2 = $3;\n+  ensure_not_void (NUMERIC_TYPE (op1), op1->main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  tok = $2;\n+  prod = make_production (PROD_PLUS_EXPRESSION, tok);\n+  NUMERIC_TYPE (prod) = get_common_type (op1, op2);\n+  if (!NUMERIC_TYPE (prod))\n+    YYERROR;\n+  else \n+    {\n+      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+      if (!type)\n+        abort ();\n+      OP1 (prod) = $1;\n+      OP2 (prod) = $3;\n+      \n+      prod->code = tree_code_get_expression (EXP_MINUS, \n+                                          type, op1->code, op2->code, NULL);\n+    }\n+  $$ = prod;\n+}\n+|expression EQUALS expression {\n+  struct token* tok;\n+  struct production *prod;\n+  struct production *op1;\n+  struct production *op2;\n+  tree type;\n+  \n+  op1 = $1;\n+  op2 = $3;\n+  ensure_not_void (NUMERIC_TYPE (op1), op1->main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  tok = $2;\n+  prod = make_production (PROD_PLUS_EXPRESSION, tok);\n+  NUMERIC_TYPE (prod) = SIGNED_INT;\n+  if (!NUMERIC_TYPE (prod))\n+    YYERROR;\n+  else \n+    {\n+      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+      if (!type)\n+        abort ();\n+      OP1 (prod) = $1;\n+      OP2 (prod) = $3;\n+      \n+      prod->code = tree_code_get_expression (EXP_EQUALS, \n+                                          type, op1->code, op2->code, NULL);\n+    }\n+  $$ = prod;\n+}\n+|variable_ref ASSIGN expression {\n+  struct token* tok;\n+  struct production *prod;\n+  struct production *op1;\n+  struct production *op2;\n+  tree type;\n+  \n+  op1 = $1;\n+  op2 = $3;\n+  tok = $2;\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  prod = make_production (PROD_ASSIGN_EXPRESSION, tok);\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (op1);\n+  if (!NUMERIC_TYPE (prod))\n+    YYERROR;\n+  else \n+    {\n+      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+      if (!type)\n+        abort ();\n+      OP1 (prod) = $1;\n+      OP2 (prod) = $3;\n+      prod->code = tree_code_get_expression (EXP_ASSIGN, \n+                                          type, op1->code, op2->code, NULL);\n+    }\n+  $$ = prod;\n+}\n+|function_invocation {\n+  $$ = $1;\n+}\n+;\n+\n+function_invocation:\n+NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n+  struct production *prod;\n+  struct token* tok;\n+  struct production search_prod;\n+  struct production *proto;\n+  struct production *exp;\n+  struct production *exp_proto;\n+  struct production *var;\n+  int exp_proto_count;\n+  int exp_count;\n+  tree parms;\n+  tree type;\n+  \n+  tok = $1;\n+  prod = make_production (PROD_FUNCTION_INVOCATION, tok);\n+  SYMBOL_TABLE_NAME (prod) = tok;\n+  PARAMETERS (prod) = reverse_prod_list ($3);\n+  SYMBOL_TABLE_NAME ((&search_prod)) = tok;\n+  proto = lookup_tree_name (&search_prod);\n+  if (!proto)\n+    {\n+      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\", in_fname, \n+              tok->lineno, tok->charno);\n+      print_token (stderr, 0, tok);\n+      errorcount++;\n+      YYERROR;\n+    }\n+  EXPRESSION_TYPE (prod) = EXPRESSION_TYPE (proto);\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (proto);\n+  /* Count the expressions and ensure they match the prototype.  */\n+  for (exp_proto_count = 0, exp_proto = PARAMETERS (proto); \n+       exp_proto; exp_proto = exp_proto->next)\n+    exp_proto_count++;\n+\n+  for (exp_count = 0, exp = PARAMETERS (prod); exp; exp = exp->next)\n+    exp_count++;\n+\n+  if (exp_count !=  exp_proto_count)\n+    {\n+      fprintf (stderr, \"%s:%i:%i: expression count mismatch with prototype\\n\", in_fname, \n+              tok->lineno, tok->charno);\n+      print_token (stderr, 0, tok);\n+      errorcount++;\n+      YYERROR;\n+    }\n+  parms = tree_code_init_parameters ();\n+  for (exp_proto = PARAMETERS (proto), exp = PARAMETERS (prod);\n+       exp_proto;\n+       exp = exp->next, exp_proto = exp_proto->next)\n+  {\n+    if (!exp)\n+      abort ();\n+    if (!exp_proto)\n+      abort ();\n+    if (!exp->code)\n+      abort ();\n+    var = VARIABLE (exp_proto);\n+    if (!var)\n+      abort ();\n+    if (!var->code)\n+      abort ();\n+    parms = tree_code_add_parameter (parms, var->code, exp->code);\n+  }\n+  type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+  prod->code = tree_code_get_expression\n+    (EXP_FUNCTION_INVOCATION, type, proto->code, parms, NULL);\n+  $$ = prod;\n+}\n+;\n+\n+expressions_with_commas:\n+expression {\n+  struct production *exp;\n+  exp = $1;\n+  ensure_not_void (NUMERIC_TYPE (exp), exp->main_token);\n+  $$ = $1;\n+}\n+|expressions_with_commas COMMA expression {\n+  struct production *exp;\n+  exp = $3;\n+  ensure_not_void (NUMERIC_TYPE (exp), exp->main_token);\n+  exp->next = $1; /* Reverse order.  */\n+  $$ = exp;\n+}\n+;\n+\n+variable_ref:\n+NAME {\n+  struct production search_prod;\n+  struct production *prod;\n+  struct production *symbol_table_entry;\n+  struct token* tok;\n+  tree type;\n+\n+  tok = $1;\n+  SYMBOL_TABLE_NAME ((&search_prod)) = tok;\n+  symbol_table_entry = lookup_tree_name (&search_prod);\n+  if (!symbol_table_entry)\n+    {\n+      fprintf (stderr, \"%s:%i:%i: Variable referred to but not defined\\n\", in_fname, \n+              tok->lineno, tok->charno);\n+      print_token (stderr, 0, tok);\n+      errorcount++;\n+      YYERROR;\n+    }\n+\n+  prod = make_production (PROD_VARIABLE_REFERENCE_EXPRESSION, tok);\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (symbol_table_entry);\n+  type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+  if (!NUMERIC_TYPE (prod))\n+    YYERROR;\n+  OP1 (prod) = $1;\n+  \n+  prod->code = tree_code_get_expression (EXP_REFERENCE, type, \n+                                      symbol_table_entry->code, NULL, NULL);\n+  $$ = prod;\n+}\n+;\n+\n+init_opt:\n+/* Nil.   */ {\n+  $$ = 0;\n+}\n+|init {\n+  /* Nothing to do.  */\n+}\n+\n+init:\n+ASSIGN init_element {\n+}\n+;\n+\n+init_element:\n+INTEGER {\n+  $$ = make_integer_constant ($1);\n+}\n+;\n+\n+%%\n+\n+/* Print a token VALUE to file FILE.  Ignore TYPE which is the token\n+   type. */\n+\n+void\n+print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value) \n+{\n+  struct token *tok;\n+  unsigned int  ix;\n+\n+  tok  =  value;\n+  fprintf (file, \"%d \\\"\", tok->lineno);\n+  for (ix  =  0; ix < tok->length; ix++)\n+    fprintf (file, \"%c\", tok->chars[ix]);\n+  fprintf (file, \"\\\"\");\n+}\n+\n+/* Output a message ERROR_MESSAGE from the parser.  */\n+void\n+yyerror (const char *error_message)\n+{\n+  struct token *tok;\n+  \n+  tok = yylval;\n+  if (tok)\n+    {\n+      fprintf (stderr, \"%s:%i:%i: %s\\n\", in_fname, tok->lineno, tok->charno, error_message);\n+      print_token (stderr, 0, tok);\n+    }\n+  else\n+    fprintf (stderr, \"%s\\n\", error_message);\n+  \n+  errorcount++;\n+\n+}\n+\n+/* Reverse the order of a token list, linked by parse_next, old first\n+   token is OLD_FIRST.  */\n+\n+static struct production*\n+reverse_prod_list (struct production *old_first)\n+{\n+  struct production *current;\n+  struct production *next;\n+  struct production *prev = NULL;\n+  \n+  current = old_first;\n+  prev = NULL;\n+\n+  while (current) \n+    {\n+      if (current->category != production_category)\n+        abort ();\n+      next = current->next;\n+      current->next = prev;\n+      prev = current;\n+      current = next; \n+    }\n+  return prev;\n+}\n+\n+/* Ensure TYPE is not VOID. Use NAME as the token for the error location.  */\n+\n+static void\n+ensure_not_void (unsigned int type, struct token* name)\n+{\n+  if (type == VOID)\n+    {\n+      fprintf (stderr, \"%s:%i:%i: Type must not be void in this context\\n\", in_fname, \n+              name->lineno, name->charno);\n+      print_token (stderr, 0, name);\n+      errorcount++;\n+    }\n+}\n+\n+/* Check TYPE1 and TYPE2 which are integral types.  Return the lowest\n+   common type (min is signed int).  */\n+\n+static int \n+get_common_type (struct production *type1, struct production *type2)\n+{\n+  if (NUMERIC_TYPE (type1) == UNSIGNED_INT)\n+    return UNSIGNED_INT;\n+  if (NUMERIC_TYPE (type2) == UNSIGNED_INT)\n+    return UNSIGNED_INT;\n+\n+  return SIGNED_INT;\n+}\n+\n+/* Check type (TYPE_NUM) and expression (EXP) match.  Return the 1 if\n+   OK else 0.  Must be exact match - same name unless it is an\n+   integral type.  */\n+\n+static int \n+check_type_match (int type_num, struct production *exp)\n+{\n+  switch (type_num)\n+    {\n+    case SIGNED_INT:\n+    case UNSIGNED_INT:\n+    case SIGNED_CHAR:\n+    case UNSIGNED_CHAR:\n+      switch (NUMERIC_TYPE (exp))\n+        {\n+        case SIGNED_INT:\n+        case UNSIGNED_INT:\n+        case SIGNED_CHAR:\n+        case UNSIGNED_CHAR:\n+          return 1;\n+          \n+        case VOID:\n+          abort ();\n+      \n+        default: \n+          abort ();\n+        }\n+      break;\n+      \n+    case VOID:\n+      abort ();\n+      \n+    default:\n+      abort ();\n+      \n+    }\n+}\n+\n+/* Make a production for an integer constant VALUE.  */\n+\n+static struct production *\n+make_integer_constant (struct token* value)\n+{\n+  struct token* tok;\n+  struct production *prod;\n+  tok = value;\n+  prod = make_production (PROD_INTEGER_CONSTANT, tok);\n+  if ((tok->chars[0] == (unsigned char)'-')|| (tok->chars[0] == (unsigned char)'+'))\n+    NUMERIC_TYPE (prod) = SIGNED_INT;\n+  else\n+    NUMERIC_TYPE (prod) = UNSIGNED_INT;\n+  prod->code = tree_code_get_integer_value (tok->chars, tok->length);\n+  return prod;\n+}\n+\n+/* Set STORAGE_CLASS in PROD according to CLASS_TOKEN.  */\n+\n+static void\n+set_storage (struct production *prod)\n+{\n+  struct token* stg_class;\n+  stg_class = STORAGE_CLASS_TOKEN (prod);\n+  switch (stg_class->type)\n+    {\n+    case STATIC:\n+      STORAGE_CLASS (prod) = STATIC_STORAGE;\n+      break;\n+      \n+    case AUTOMATIC:\n+      STORAGE_CLASS (prod) = AUTOMATIC_STORAGE;\n+      break;\n+      \n+    case EXTERNAL_DEFINITION:\n+      STORAGE_CLASS (prod) = EXTERNAL_DEFINITION_STORAGE;\n+      break;\n+\n+    case EXTERNAL_REFERENCE:\n+      STORAGE_CLASS (prod) = EXTERNAL_REFERENCE_STORAGE;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Set parse trace.  */\n+\n+void\n+treelang_debug (void)\n+{\n+  if (option_parser_trace)\n+    yydebug = 1;\n+}"}, {"sha": "5067bea22286c4e17010636c4af8716c5216cd20", "filename": "gcc/treelang/tree1.c", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,382 @@\n+  /* \n+\n+    TREELANG Compiler almost main (tree1)\n+    Called by GCC's toplev.c\n+\n+    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+    This program is free software; you can redistribute it and/or modify it\n+    under the terms of the GNU General Public License as published by the\n+    Free Software Foundation; either version 2, or (at your option) any\n+    later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License\n+    along with this program; if not, write to the Free Software\n+    Foundation, 59 Temple Place - Suite 330,\n+    Boston, MA 02111-1307, USA.\n+\n+    In other words, you are welcome to use, share and improve this program.\n+    You are forbidden to forbid anyone else to use, share and improve\n+    what you give them.   Help stamp out software-hoarding!  \n+\n+    ---------------------------------------------------------------------------\n+\n+    Written by Tim Josling 1999, 2000, 2001, based in part on other\n+    parts of the GCC compiler.\n+\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"toplev.h\"\n+\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <ctype.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include \"treelang.h\"\n+#include \"treetree.h\"\n+\n+extern int yyparse (void);\n+/* Linked list of symbols - all must be unique in treelang.  */\n+\n+struct production *symbol_table = NULL;\n+\n+/* Language for usage for messages.  */\n+\n+const char *const language_string = \"TREELANG - sample front end for GCC \";\n+\n+/* Local prototypes.  */\n+\n+void version (void);\n+\n+/* GC routine for symbol table.  */\n+static void symbol_table_ggc (void *m);\n+\n+/* Global variables.  */\n+\n+extern struct cbl_tree_struct_parse_tree_top* parse_tree_top;\n+\n+/* \n+   Options. \n+*/\n+\n+/* Trace the parser.  */\n+unsigned int option_parser_trace = 0;\n+\n+/* Trace the lexical analysis.  */\n+\n+unsigned int option_lexer_trace = 0;\n+\n+/* Warning levels.  */\n+\n+/* Local variables.  */\n+\n+unsigned char *in_fname = NULL;\t/* Input file name.  */\n+\n+/* This is 1 if we have output the version string.  */\n+\n+static int version_done = 0;\n+\n+/* Variable nesting level.  */\n+\n+static unsigned int work_nesting_level = 0;\n+\n+/* Process one switch - called by toplev.c.  */\n+\n+int\n+treelang_decode_option (num_options_left, first_option_left)\n+     int num_options_left ATTRIBUTE_UNUSED; \n+     char** first_option_left;\n+{\n+  \n+  /*\n+    Process options - bear in mind I may get options that are really\n+    meant for someone else (eg the main compiler) so I have to be very\n+    permissive. \n+    \n+  */\n+  \n+  if (first_option_left[0][0] != '-')\n+    return 0; \n+  \n+  switch (first_option_left[0][1]) \n+    {\n+    case '-':\n+      if (!strcmp (first_option_left[0],\"--help\"))\n+        {\n+          if (!version_done)\n+            {\n+              fputs (language_string, stdout);\n+              fputs (version_string, stdout);\n+              fputs (\"\\n\", stdout);\n+              version_done = 1;\n+            }\n+          fprintf (stdout, \"Usage: tree1 [switches] -o output input\\n\");\n+          return 1;\n+        }\n+    case 'v':\n+      if (!strcmp (first_option_left[0],\"-v\"))\n+        {\n+          if (!version_done)\n+            {\n+              fputs (language_string, stdout);\n+              fputs (version_string, stdout);\n+              fputs (\"\\n\", stdout);\n+              version_done = 1;\n+            }\n+          return 1;\n+        }\n+    case 'y':\n+      if (!strcmp (first_option_left[0],\"-y\"))\n+        {\n+          option_lexer_trace = 1;\n+          option_parser_trace = 1;\n+          return 1;\n+        }\n+    case 'f':\n+      if (!strcmp (first_option_left[0],\"-fparser-trace\"))\n+        {\n+          option_parser_trace = 1;\n+          return 1;\n+        }\n+      if (!strcmp (first_option_left[0],\"-flexer-trace\"))\n+        {\n+          option_lexer_trace = 1;\n+          return 1;\n+        }\n+      return 0;\n+\n+    case 'w':\n+      if (!strcmp (first_option_left[0],\"-w\"))\n+        {\n+          /* Tolerate this option but ignore it - we always put out\n+             all warnings.  */\n+          return 1;\n+        }\n+      return 0;\n+\n+    case 'W':\n+      if (!strcmp (first_option_left[0],\"-Wall\"))\n+        {\n+          return 1;\n+        }\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  return 0;\n+\n+}\n+\n+/* Language dependent parser setup.  */\n+\n+const char*\n+treelang_init (const char* filename)\n+{\n+\n+  /* Define my garbage collection routines.  */\n+  ggc_add_root (&symbol_table, 1, \n+                /* Unused size.  */ sizeof (void*), symbol_table_ggc);\n+  /* Note: only storage that has to be kept across functions needs to\n+     be protected from GC.  */\n+  /* Define my garbage collection routines.  */\n+  ggc_add_root (&symbol_table, 1, \n+                /* Unused size.  */ sizeof (void*), symbol_table_ggc);\n+  /* Note: only storage that has to be kept across functions needs to\n+     be protected from GC.  */\n+\n+  /* Set up the declarations needed for this front end.  */\n+\n+  input_filename = \"\";\n+  lineno = 0;\n+\n+  treelang_init_decl_processing ();\n+\n+  /* This error will not happen from GCC as it will always create a\n+     fake input file.  */\n+  if (!filename || (filename[0] == ' ') || (!filename[0])) \n+    {\n+      if (!version_done)\n+        {\n+          fprintf (stderr, \"No input file specified, try --help for help\\n\");\n+          exit (1);\n+        }\n+\n+      in_fname = NULL;\n+      return NULL;\n+    }\n+  yyin = fopen (filename, \"r\");\n+  if (!yyin)\n+    {\n+      fprintf (stderr, \"Unable to open input file %s\\n\", filename);\n+      exit (1);\n+    }\n+  input_filename = filename;\n+  return (char*) (in_fname = (unsigned char*)filename);\n+}\n+\n+/* Language dependent wrapup.  */\n+\n+void \n+treelang_finish (void)\n+{\n+  fclose (yyin);\n+}\n+\n+/* Parse a file.  Debug flag doesn't seem to work. */\n+\n+void\n+treelang_parse_file (int debug_flag ATTRIBUTE_UNUSED)\n+{\n+  treelang_debug ();\n+  yyparse ();\n+}\n+\n+\n+/* Scan the symbol table* M, marking storage used.  */\n+\n+static void\n+symbol_table_ggc (void *m)\n+{\n+  struct production *pp;\n+  pp = * (struct production**)m;\n+  /* Actually it is a pointer to a pointer, to allow reallocation and\n+     relinking.  */\n+  mark_production_used (pp);\n+}\n+\n+/* Mark a production PP as used so it wont be garbage collected.  */\n+\n+void\n+mark_production_used (struct production *pp)\n+{\n+  int sub_ix;\n+ loop:\n+  if (!pp)\n+    return;\n+  ggc_mark (pp);\n+  \n+  if (pp->category == token_category)\n+    {\n+      mark_token_used ((struct token*)pp);\n+      return;\n+    }\n+  if (pp->category != production_category)\n+    abort ();\n+  mark_token_used (pp->main_token);\n+  for (sub_ix = 0; sub_ix < SUB_COUNT; sub_ix++)\n+    mark_production_used (pp->sub[sub_ix]);\n+  /* The macro tests for NULL so I don't need to.  */\n+  ggc_mark_tree (pp->code);\n+  pp = pp->next;\n+  goto loop;\n+}\n+\n+/* Mark a token TT as used so it wont be garbage collected.  */\n+\n+void\n+mark_token_used (struct token* tt)\n+{\n+  if (!tt) \n+    return;\n+  ggc_mark (tt);\n+  if (tt->chars)\n+    ggc_mark (tt->chars);\n+}\n+\n+/* Allocate SIZE bytes and clear them.  */\n+\n+void *\n+my_malloc (size_t size)\n+{\n+  void *mem;\n+  mem = ggc_alloc (size);\n+  if (!mem)\n+    {\n+      fprintf (stderr, \"\\nOut of memory\\n\");\n+      abort ();\n+    }\n+  memset (mem, 0, size);\n+  return mem;\n+}\n+\n+/* Look up a name in PROD->SYMBOL_TABLE_NAME in the symbol table;\n+   return the symbol table entry from the symbol table if found there,\n+   else 0.  */\n+\n+struct production*\n+lookup_tree_name (struct production *prod)\n+{\n+  struct production *this;\n+  struct token* this_tok;\n+  struct token* tok;\n+  tok = SYMBOL_TABLE_NAME (prod);\n+  for (this = symbol_table; this; this = this->next)\n+    {\n+      this_tok = this->main_token;\n+      if (tok->length != this_tok->length) \n+        continue;\n+      if (memcmp (tok->chars, this_tok->chars, this_tok->length))\n+        continue;\n+      if (option_parser_trace)\n+        fprintf (stderr, \"Found symbol %s (%i:%i) as %i \\n\", tok->chars, \n+                tok->lineno, tok->charno, NUMERIC_TYPE (this));\n+      return this;\n+    }\n+  if (option_parser_trace)\n+    fprintf (stderr, \"Not found symbol %s (%i:%i) as %i \\n\", tok->chars, \n+            tok->lineno, tok->charno, tok->type);\n+  return NULL;\n+}\n+\n+/* Insert name PROD into the symbol table.  Return 1 if duplicate, 0 if OK.  */\n+\n+int\n+insert_tree_name (struct production *prod)\n+{\n+  struct token* tok;\n+  tok = SYMBOL_TABLE_NAME (prod);\n+  if (lookup_tree_name (prod))\n+    {\n+      fprintf (stderr, \"%s:%i:%i duplicate name %s\\n\", in_fname, tok->lineno, tok->charno, tok->chars);\n+      errorcount++;\n+      return 1;\n+    }\n+  prod->next = symbol_table;\n+  NESTING_LEVEL (prod) = work_nesting_level;\n+  symbol_table = prod;\n+  return 0;\n+}\n+\n+/* Create a struct productions of type TYPE, main token MAIN_TOK.  */\n+\n+struct production *\n+make_production (int type, struct token* main_tok)\n+{\n+  struct production *prod;\n+  prod = my_malloc (sizeof (struct production));\n+  prod->category = production_category;\n+  prod->type = type;\n+  prod->main_token = main_tok;\n+  return prod;\n+} \n+\n+"}, {"sha": "a265738423f31152fff54213dcc1b22a8c13f17c", "filename": "gcc/treelang/treelang.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreelang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreelang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreelang.h?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,116 @@\n+/* \n+\n+    TREELANG Compiler common definitions (treelang.h)\n+\n+    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+    This program is free software; you can redistribute it and/or modify it\n+    under the terms of the GNU General Public License as published by the\n+    Free Software Foundation; either version 2, or (at your option) any\n+    later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License\n+    along with this program; if not, write to the Free Software\n+    Foundation, 59 Temple Place - Suite 330,\n+    Boston, MA 02111-1307, USA.\n+\n+    In other words, you are welcome to use, share and improve this program.\n+    You are forbidden to forbid anyone else to use, share and improve\n+    what you give them.   Help stamp out software-hoarding!  \n+\n+    ---------------------------------------------------------------------------\n+\n+    Written by Tim Josling 1999, 2000, 2001, based in part on other\n+    parts of the GCC compiler.\n+\n+*/\n+\n+/* Parse structure type.  */\n+enum category_enum \n+{ /* These values less likely to be there by chance unlike 0/1,\n+      make checks more meaningful */\n+  token_category = 111,\n+  production_category = 222\n+};\n+\n+/* Input file name and FILE.  */\n+extern unsigned char* in_fname;\n+extern FILE* yyin;\n+\n+#if 0\n+extern int errorcount; /* In toplev.c.  */\n+#endif\n+\n+struct token\n+{\n+  enum category_enum category; /* Token or production. */\n+  unsigned int type; /* Token type.  */\n+  /* Prior to this point, production must match token.  */\n+  unsigned int lineno;\n+  unsigned int charno;\n+  unsigned int length; /* The value.  */\n+  unsigned char* chars;\n+};\n+\n+struct production\n+{\n+  enum category_enum category; /* Token or Production. */\n+  unsigned int type; /* Production type - a fake token name.  */\n+  /* Prior to this point, production must match token.  */\n+  struct token* main_token; /* Main token for error msgs; variable name token.  */\n+\n+  unsigned int info[2]; /* Extra information.  */\n+#define NESTING_LEVEL(a) a->info[0]  /* Level used for variable definitions.  */\n+#define NUMERIC_TYPE(a)  a->info[1]  /* Numeric type used in type definitions and expressions.  */\n+\n+\n+#define SUB_COUNT 5\n+  void *sub[SUB_COUNT]; /* Sub productions or tokens.  */\n+\n+#define SYMBOL_TABLE_NAME(a) (a->sub[0]) /* Name token.  */\n+\n+#define EXPRESSION_TYPE(a) (a->sub[1]) /* Type identifier.  */\n+\n+#define OP1(a) (a->sub[2]) /* Exp operand1.  */\n+#define PARAMETERS(a) (a->sub[2]) /* Function parameters.  */\n+#define VARIABLE(a) (a->sub[2]) /* Parameter variable ptr.  */\n+#define VAR_INIT(a) (a->sub[2]) /* Variable init.  */\n+\n+#define OP2(a) (a->sub[3]) /* Exp operand2.  */\n+#define FIRST_PARMS(a) (a->sub[3]) /* Function parameters linked via struct tree_parameter_list.  */\n+\n+#define OP3(a) (a->sub[4]) /* Exp operand3.  */\n+#define STORAGE_CLASS_TOKEN(a) (a->sub[4]) /* Storage class token.  */\n+\n+  void *code; /* Back end hook for this item.  */\n+  struct production *next; /* Next in chains of various types.  */\n+\n+  unsigned int flag1:2;\n+#define STORAGE_CLASS(a) a->flag1 /* Values in treetree.h.  */\n+\n+  unsigned int flag2:1;\n+  unsigned int flag3:1;\n+  unsigned int flag4:1;\n+  unsigned int flag5:1;\n+  unsigned int flag6:1;\n+  unsigned int flag7:1;\n+\n+};\n+\n+/* For parser. Alternatively you can define it using %union (bison) or\n+   union. */\n+#define YYSTYPE void *\n+\n+void *my_malloc (size_t size);\n+int insert_tree_name (struct production *prod);\n+struct production *lookup_tree_name (struct production *prod);\n+struct production *make_production (int type, struct token* main_tok);\n+void mark_production_used (struct production * pp);\n+void mark_token_used (struct token* tt);\n+void treelang_debug (void);\n+"}, {"sha": "499f160161bddcaac98ca782198ea674975b8218", "filename": "gcc/treelang/treelang.texi", "status": "added", "additions": 1311, "deletions": 0, "changes": 1311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreelang.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreelang.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreelang.texi?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,1311 @@\n+\\input texinfo  @c -*-texinfo-*-\n+@c %**start of header\n+@setfilename treelang.info\n+\n+@set last-update 2001-07-30\n+@set copyrights-treelang 1995,1996,1997,1998,1999,2000,2001,2002\n+@c DEVELOPMENT is set to indicate an in-development version,\n+@c as compared to a release version.  When making a release\n+@c (e.g. a release branch in the CVS repository for GCC),\n+@c clear this and set the version information correctly.\n+@clear DEVELOPMENT\n+@set version-treelang 1.0\n+@set version-GCC 3.0\n+\n+@set email-general gcc@@gcc.gnu.org\n+@set email-bugs gcc-bugs@@gcc.gnu.org or bug-gcc@@gnu.org\n+@set email-patches gcc-patches@@gcc.gnu.org \n+@set path-treelang gcc/gcc/treelang\n+\n+@set which-treelang GCC-@value{version-GCC}\n+@set which-GCC GCC\n+\n+@set email-josling tej@@melbpc.org.au\n+@set www-josling http://www.geocities.com/timjosling\n+\n+@c This tells @include'd files that they're part of the overall TREELANG doc\n+@c set.  (They might be part of a higher-level doc set too.)\n+@set DOC-TREELANG\n+\n+@c @setfilename usetreelang.info\n+@c @setfilename maintaintreelang.info\n+@c To produce the full manual, use the \"treelang.info\" setfilename, and\n+@c make sure the following do NOT begin with '@c' (and the @clear lines DO)\n+@set INTERNALS\n+@set USING\n+@c To produce a user-only manual, use the \"usetreelang.info\" setfilename, and\n+@c make sure the following does NOT begin with '@c':\n+@c @clear INTERNALS\n+@c To produce a maintainer-only manual, use the \"maintaintreelang.info\" setfilename,\n+@c and make sure the following does NOT begin with '@c':\n+@c @clear USING\n+\n+@c 6/27/96 FSF DO wants smallbook fmt for 1st bound edition. (from gcc.texi)\n+@c @smallbook\n+\n+@c i also commented out the finalout command, so if there *are* any\n+@c overfulls, you'll (hopefully) see the rectangle in the right hand\n+@c margin. -- burley 1999-03-13 (from mew's comment in GCC.texi).\n+@c @finalout\n+\n+@ifset INTERNALS\n+@ifset USING\n+@settitle Using and Maintaining GNU Treelang\n+@end ifset\n+@end ifset\n+@c seems reasonable to assume at least one of INTERNALS or USING is set...\n+@ifclear INTERNALS\n+@settitle Using GNU Treelang\n+@end ifclear\n+@ifclear USING\n+@settitle Maintaining GNU Treelang\n+@end ifclear\n+@c then again, have some fun\n+@ifclear INTERNALS\n+@ifclear USING\n+@settitle Doing Very Little at all with GNU Treelang\n+@end ifclear\n+@end ifclear\n+\n+@syncodeindex fn cp\n+@syncodeindex vr cp\n+@c %**end of header\n+\n+@c Cause even numbered pages to be printed on the left hand side of\n+@c the page and odd numbered pages to be printed on the right hand\n+@c side of the page.  Using this, you can print on both sides of a\n+@c sheet of paper and have the text on the same part of the sheet.\n+\n+@c The text on right hand pages is pushed towards the right hand\n+@c margin and the text on left hand pages is pushed toward the left\n+@c hand margin.\n+@c (To provide the reverse effect, set bindingoffset to -0.75in.)\n+\n+@c @tex\n+@c \\global\\bindingoffset=0.75in\n+@c \\global\\normaloffset =0.75in\n+@c @end tex\n+\n+@ifinfo\n+@dircategory Programming\n+@direntry\n+* treelang: (treelang).                  The GNU Treelang compiler.\n+@end direntry\n+@ifset INTERNALS\n+@ifset USING\n+This file documents the use and the internals of the GNU Treelang\n+(@code{treelang}) compiler. At the moment this manual is not\n+incorporated into the main GCC manual as it is too incomplete. It\n+corresponds to the @value{which-treelang} version of @code{treelang}.\n+@end ifset\n+@end ifset\n+@ifclear USING\n+This file documents the internals of the GNU Treelang (@code{treelang}) compiler.\n+It corresponds to the @value{which-treelang} version of @code{treelang}.\n+@end ifclear\n+@ifclear INTERNALS\n+This file documents the use of the GNU Treelang (@code{treelang}) compiler.\n+It corresponds to the @value{which-treelang} version of @code{treelang}.\n+@end ifclear\n+\n+Published by the Free Software Foundation\n+59 Temple Place - Suite 330\n+Boston, MA 02111-1307 USA\n+\n+Copyright (C) @value{copyrights-treelang} Free Software Foundation, Inc.\n+\n+Permission is granted to copy, distribute and/or modify this document\n+under the terms of the GNU Free Documentation License, Version 1.1 or\n+any later version published by the Free Software Foundation; with the\n+Invariant Sections being ``GNU General Public License'', the Front-Cover\n+texts being (a) (see below), and with the Back-Cover Texts being (b)\n+(see below).  A copy of the license is included in the section entitled\n+``GNU Free Documentation License''.\n+\n+(a) The FSF's Front-Cover Text is:\n+\n+     A GNU Manual\n+\n+(b) The FSF's Back-Cover Text is:\n+\n+     You have freedom to copy and modify this GNU Manual, like GNU\n+     software.  Copies published by the Free Software Foundation raise\n+     funds for GNU development.\n+@end ifinfo\n+\n+treelang was Contributed by Tim Josling (@email{@value{email-josling}}).\n+Inspired by and based on the 'toy' language, written by Richard Kenner.\n+\n+This document was written by Tim Josling, based on the GNU C++\n+documentation.\n+\n+@setchapternewpage odd\n+@c @finalout\n+@titlepage\n+@ifset INTERNALS\n+@ifset USING\n+@center @titlefont{Using and Maintaining GNU Treelang}\n+\n+@end ifset\n+@end ifset\n+@ifclear INTERNALS\n+@title Using GNU Treelang\n+@end ifclear\n+@ifclear USING\n+@title Maintaining GNU Treelang\n+@end ifclear\n+@sp 2\n+@center Tim Josling\n+@sp 3\n+@center Last updated @value{last-update}\n+@sp 1\n+@center for version @value{version-treelang}\n+@page\n+@vskip 0pt plus 1filll\n+Copyright @copyright{} @value{copyrights-treelang} Free Software Foundation, Inc.\n+@sp 2\n+For the @value{which-treelang} Version*\n+@sp 1\n+Published by the Free Software Foundation @*\n+59 Temple Place - Suite 330@*\n+Boston, MA 02111-1307, USA@*\n+@c Last printed ??ber, 19??.@*\n+@c Printed copies are available for $? each.@*\n+@c ISBN ???\n+@sp 1\n+Permission is granted to copy, distribute and/or modify this document\n+under the terms of the GNU Free Documentation License, Version 1.1 or\n+any later version published by the Free Software Foundation; with the\n+Invariant Sections being ``GNU General Public License'', the Front-Cover\n+texts being (a) (see below), and with the Back-Cover Texts being (b)\n+(see below).  A copy of the license is included in the section entitled\n+``GNU Free Documentation License''.\n+\n+(a) The FSF's Front-Cover Text is:\n+\n+     A GNU Manual\n+\n+(b) The FSF's Back-Cover Text is:\n+\n+     You have freedom to copy and modify this GNU Manual, like GNU\n+     software.  Copies published by the Free Software Foundation raise\n+     funds for GNU development.\n+@end titlepage\n+@page\n+\n+@ifinfo\n+\n+@node Top, Copying,, (dir)\n+@top Introduction\n+@cindex Introduction\n+\n+@ifset INTERNALS\n+@ifset USING\n+This manual documents how to run, install and maintain @code{treelang},\n+as well as its new features and incompatibilities,\n+and how to report bugs.\n+It corresponds to the @value{which-treelang} version of @code{treelang}.\n+@end ifset\n+@end ifset\n+\n+@ifclear INTERNALS\n+This manual documents how to run and install @code{treelang},\n+as well as its new features and incompatibilities, and how to report\n+bugs.\n+It corresponds to the @value{which-treelang} version of @code{treelang}.\n+@end ifclear\n+@ifclear USING\n+This manual documents how to maintain @code{treelang}, as well as its\n+new features and incompatibilities, and how to report bugs.  It\n+corresponds to the @value{which-treelang} version of @code{treelang}.\n+@end ifclear\n+\n+@end ifinfo\n+\n+@ifset DEVELOPMENT\n+@emph{Warning:} This document is still under development, and might not\n+accurately reflect the @code{treelang} code base of which it is a part.\n+@end ifset\n+\n+@menu\n+* Copying::                     \n+* Contributors::                \n+* GNU Free Documentation License::                \n+* Funding::                     \n+* Getting Started::             \n+* What is GNU Treelang?::       \n+* Lexical Syntax::              \n+* Parsing Syntax::              \n+* Compiler Overview::           \n+* TREELANG and GCC::            \n+* Compiler::                    \n+* Other Languages::             \n+* treelang internals::          \n+* Open Questions::              \n+* Bugs::                        \n+* Service::                     \n+* Projects::                    \n+* Index::                       \n+\n+@detailmenu\n+ --- The Detailed Node Listing ---\n+\n+Other Languages\n+\n+* Interoperating with C and C++::  \n+\n+treelang internals\n+\n+* treelang files::              \n+* treelang compiler interfaces::  \n+* Hints and tips::              \n+\n+treelang compiler interfaces\n+\n+* treelang driver::             \n+* treelang main compiler::      \n+\n+treelang main compiler\n+\n+* Interfacing to toplev.c::     \n+* Interfacing to the garbage collection::  \n+* Interfacing to the code generation code. ::  \n+\n+Reporting Bugs\n+\n+* Sending Patches::             \n+\n+@end detailmenu\n+@end menu\n+\n+@include gpl.texi\n+\n+@include fdl.texi\n+\n+@node Contributors\n+\n+@unnumbered Contributors to GNU Treelang\n+@cindex contributors\n+@cindex credits\n+\n+Treelang was based on 'toy' by Richard Kenner, and also uses code from\n+the GCC core code tree. Tim Josling first created the language and\n+documentation, based on the GCC Fortran compiler's documentation\n+framework.\n+\n+@itemize @bullet\n+@item\n+The packaging and compiler portions of GNU Treelang are based largely\n+on the GCC compiler.\n+@xref{Contributors,,Contributors to GCC,GCC,Using and Maintaining GCC},\n+for more information.\n+\n+@item\n+There is no specific run-time library for treelang, other than the\n+standard C runtime.\n+\n+@item\n+It would have been difficult to build treelang without access to Joachim\n+Nadler's guide to writing a front end to GCC (written in German). A\n+translation of this document into English is available via the\n+CobolForGCC project or via the documentation links from the GCC home\n+page @uref{http://GCC.gnu.org}.\n+@end itemize\n+\n+@include funding.texi\n+\n+@node Getting Started\n+@chapter Getting Started\n+@cindex getting started\n+@cindex new users\n+@cindex newbies\n+@cindex beginners\n+\n+Treelang is a sample language, useful only to help people understand how\n+to implement a new language front end to GCC. It is not a useful\n+language in itself other than as an example or basis for building a new\n+language. Therefore only language developers are likely to have an\n+interest in it.\n+\n+This manual assumes familiarity with GCC, which you can obtain by using\n+it and by reading the manual @samp{Using and Porting GCC}.\n+\n+To install treelang, follow the GCC installation instructions, \n+taking care to ensure you specify treelang in the configure step.\n+\n+If you're generally curious about the future of\n+@code{treelang}, see @ref{Projects}.\n+If you're curious about its past,\n+see @ref{Contributors}.\n+\n+To see a few of the questions maintainers of @code{treelang} have,\n+and that you might be able to answer,\n+see @ref{Open Questions}.\n+\n+@ifset USING\n+@node What is GNU Treelang?, Lexical Syntax, Getting Started, Top\n+@chapter What is GNU Treelang?\n+@cindex concepts, basic\n+@cindex basic concepts\n+\n+GNU Treelang, or @code{treelang}, is designed initially as a free\n+replacement for, or alternative to, the 'toy' language, but which is\n+amenable to inclusion within the GCC source tree. \n+\n+@code{treelang} is largely a cut down version of C, designed to showcase\n+the features of the GCC code generation back end. Only those features\n+that are directly supported by the GCC code generation back end are\n+implemented. Features are implemented in a manner which is easiest and\n+clearest to implement. Not all or even most code generation back end\n+features are implemented. The intention is to add features incrementally\n+until most features of the GCC back end are implemented in treelang.\n+\n+The main features missing are structures, arrays and pointers.\n+\n+A sample program follows:\n+\n+@example\n+// function prototypes\n+// function 'add' taking two ints and returning an int\n+external_definition int add(int arg1, int arg2);\n+external_definition int subtract(int arg3, int arg4);\n+external_definition int first_nonzero(int arg5, int arg6);\n+external_definition int double_plus_one(int arg7);\n+\n+// function definition\n+add \n+@{\n+// return the sum of arg1 and arg2\n+  return arg1 + arg2;\n+@}\n+\n+        \n+subtract \n+@{\n+  return arg3 - arg4;\n+@}\n+\n+double_plus_one\n+@{\n+// aaa is a variable, of type integer and allocated at the start of the function\n+  automatic int aaa;\n+// set aaa to the value returned from aaa, when passed arg7 and arg7 as the two parameters\n+  aaa=add(arg7, arg7);\n+  aaa=add(aaa, aaa);\n+  aaa=subtract(subtract(aaa, arg7), arg7) + 1;\n+  return aaa;\n+@}\n+\n+first_nonzero\n+@{\n+// C-like if statement\n+  if (arg5)\n+    @{\n+      return arg5;\n+    @}\n+  else\n+    @{\n+    @}\n+  return arg6;\n+@}\n+@end example\n+\n+@node Lexical Syntax, Parsing Syntax, What is GNU Treelang?, Top\n+@chapter Lexical Syntax\n+@cindex Lexical Syntax\n+\n+Treelang programs consist of whitespace, comments, keywords and names.\n+@itemize @bullet\n+\n+@item\n+Whitespace consists of the space character and the end of line\n+character. Tabs are not allowed. Line terminations are as defined by the\n+standard C library. Whitespace is ignored except within comments,\n+and where it separates parts of the program. In the example below, A and\n+B are two separate names separated by whitespace. \n+\n+@smallexample\n+A B\n+@end smallexample\n+\n+@item\n+Comments consist of @samp{//} followed by any characters up to the end\n+of the line. C style comments (/* */) are not supported. For example,\n+the assignment below is followed by a not very helpful comment.\n+\n+@smallexample\n+x=1; // Set X to 1\n+@end smallexample\n+\n+@item\n+Keywords consist of any reserved words or symbols as described\n+later. The list of keywords follows:\n+\n+@smallexample\n+@{ - used to start the statements in a function\n+@} - used to end the statements in a function\n+( - start list of function arguments, or to change the precedence of operators in an expression\n+) - end list or prioritised operators in expression\n+, - used to separate parameters in a function prototype or in a function call \n+; - used to end a statement\n++ - addition\n+- - subtraction\n+= - assignment\n+== - equality test\n+if - begin IF statement\n+else - begin 'else' portion of IF statement\n+static - indicate variable is permanent, or function has file scope only\n+automatic - indicate that variable is allocated for the life of the function\n+external_reference - indicate that variable or function is defined in another file\n+external_definition - indicate that variable or function is to be accessible from other files\n+int - variable is an integer (same as C int) \n+char - variable is a character (same as C char)\n+unsigned - variable is unsigned. If this is not present, the variable is signed\n+return - start function return statement\n+void - used as function type to indicate function returns nothing\n+@end smallexample\n+\n+\n+@item\n+Names consist of any letter or \"_\" followed by any number of letters or\n+numbers or \"_\". \"$\" is not allowed in a name. All names must be globally\n+unique - the same name may not be used twice in any context - and must\n+not be a keyword. Names and keywords are case sensitive. For example:\n+\n+@smallexample\n+a A _a a_ IF_X\n+@end smallexample\n+\n+are all different names.\n+\n+@end itemize\n+\n+@node Parsing Syntax, Compiler Overview, Lexical Syntax, Top\n+@chapter Parsing Syntax\n+@cindex Parsing Syntax\n+\n+Declarations are built up from the lexical elements described above. A\n+file may contain one of more declarations.\n+\n+@itemize @bullet\n+\n+@item\n+declaration: variable declaration OR function prototype OR function declaration\n+\n+@item\n+Function Prototype: storage type NAME ( parameter_list )\n+\n+@smallexample\n+static int add (int a, int b)\n+@end smallexample\n+\n+@item\n+variable_declaration: storage type NAME initial;\n+\n+Example:\n+\n+@smallexample\n+int temp1=1;\n+@end smallexample\n+\n+A variable declaration can be outside a function, or at the start of a function.\n+\n+@item\n+storage: automatic OR static OR external_reference OR external_definition\n+\n+This defines the scope, duration and visibility of a function or variable\n+\n+@enumerate 1\n+\n+@item \n+automatic: This means a variable is allocated at start of function and\n+released when the function returns. This can only be used for variables\n+within functions. It cannot be used for functions.\n+\n+@item \n+static: This means a variable is allocated at start of program and\n+remains allocated until the program as a whole ends. For a function, it\n+means that the function is only visible within the current file.\n+\n+@item\n+external_definition: For a variable, which must be defined outside a\n+function, it means that the variable is visible from other files. For a\n+function, it means that the function is visible from another file.\n+\n+@item\n+external_reference: For a variable, which must be defined outside a\n+function, it means that the variable is defined in another file. For a\n+function, it means that the function is defined in another file.\n+\n+@end enumerate\n+\n+@item\n+type: int OR unsigned int OR char OR unsigned char OR void\n+\n+This defines the data type of a variable or the return type of a function.\n+\n+@enumerate a\n+\n+@item \n+int: The variable is a signed integer. The function returns a signed integer.\n+\n+@item \n+unsigned int: The variable is an unsigned integer. The function returns an unsigned integer.\n+\n+@item \n+char: The variable is a signed character. The function returns a signed character.\n+\n+@item \n+unsigned char: The variable is an unsigned character. The function returns an unsigned character.\n+\n+@end enumerate\n+\n+@item\n+parameter_list OR parameter [, parameter]...\n+\n+@item\n+parameter: variable_declaration ,\n+\n+The variable declarations must not have initialisations.\n+\n+@item \n+initial: = value\n+\n+@item\n+value: integer_constant\n+\n+@smallexample\n+eg 1 +2 -3\n+@end smallexample\n+\n+@item\n+function_declaration: name @{variable_declarations statements @}\n+\n+A function consists of the function name then the declarations (if any)\n+and statements (if any) within one pair of braces.\n+\n+The details of the function arguments come from the function\n+prototype. The function prototype must precede the function declaration\n+in the file.\n+\n+@item\n+statement: if_statement OR expression_statement OR return_statement\n+\n+@item\n+if_statement: if (expression) @{ statements @} else @{ statements @}\n+\n+The first lot of statements is executed if the expression is\n+non-zero. Otherwise the second lot of statements is executed. Either\n+list of statements may be empty, but both sets of braces and the else must be present. \n+\n+@smallexample\n+if (a==b) \n+@{\n+// nothing\n+@}\n+else\n+@{\n+a=b;\n+@}\n+@end smallexample\n+\n+@item\n+expression_statement: expression;\n+\n+The expression is executed and any side effects, such \n+\n+@item\n+return_statement: return expression_opt;\n+\n+Returns from the function. If the function is void, the expression must\n+be absent, and if the function is not void the expression must be\n+present.\n+\n+@item\n+expression: variable OR integer_constant OR expression+expression OR expression-expression\n+ OR expression==expression OR (expression) OR variable=expression OR function_call\n+\n+An expression can be a constant or a variable reference or a\n+function_call. Expressions can be combined as a sum of two expressions\n+or the difference of two expressions, or an equality test of two\n+expresions. An assignment is also an expression. Expresions and operator\n+precedence work as in C.\n+\n+@item\n+function_call: function_name (comma_separated_expressions)\n+\n+This invokes the function, passing to it the values of the expressions\n+as actual parameters.\n+\n+@end itemize\n+\n+@cindex compilers\n+@node Compiler Overview, TREELANG and GCC, Parsing Syntax, Top\n+@chapter Compiler Overview\n+treelang is run as part of the GCC compiler. \n+\n+@itemize @bullet\n+@cindex source code\n+@cindex file, source\n+@cindex code, source\n+@cindex source file\n+@item\n+It reads a user's program, stored in a file and containing instructions\n+written in the appropriate language (Treelang, C, and so on).  This file\n+contains @dfn{source code}.\n+\n+@cindex translation of user programs\n+@cindex machine code\n+@cindex code, machine\n+@cindex mistakes\n+@item\n+It translates the user's program into instructions a computer can carry\n+out more quickly than it takes to translate the instructions in the\n+first place.  These instructions are called @dfn{machine code}---code\n+designed to be efficiently translated and processed by a machine such as\n+a computer.  Humans usually aren't as good writing machine code as they\n+are at writing Treelang or C, because it is easy to make tiny mistakes\n+writing machine code.  When writing Treelang or C, it is easy to make\n+big mistakes. But you can only make one mistake, because the compiler\n+stops after it finds any problem.\n+\n+@cindex debugger\n+@cindex bugs, finding\n+@cindex @code{gdb}, command\n+@cindex commands, @code{gdb}\n+@item\n+It provides information in the generated machine code\n+that can make it easier to find bugs in the program\n+(using a debugging tool, called a @dfn{debugger},\n+such as @code{gdb}).\n+\n+@cindex libraries\n+@cindex linking\n+@cindex @code{ld} command\n+@cindex commands, @code{ld}\n+@item\n+It locates and gathers machine code already generated to perform actions\n+requested by statements in the user's program.  This machine code is\n+organized into @dfn{libraries} and is located and gathered during the\n+@dfn{link} phase of the compilation process.  (Linking often is thought\n+of as a separate step, because it can be directly invoked via the\n+@code{ld} command.  However, the @code{gcc} command, as with most\n+compiler commands, automatically performs the linking step by calling on\n+@code{ld} directly, unless asked to not do so by the user.)\n+\n+@cindex language, incorrect use of\n+@cindex incorrect use of language\n+@item\n+It attempts to diagnose cases where the user's program contains\n+incorrect usages of the language.  The @dfn{diagnostics} produced by the\n+compiler indicate the problem and the location in the user's source file\n+where the problem was first noticed.  The user can use this information\n+to locate and fix the problem.\n+\n+The compiler stops after the first error. There are no plans to fix\n+this, ever, as it would vastly complicate the implementation of treelang\n+to little or no benefit.\n+\n+@cindex diagnostics, incorrect\n+@cindex incorrect diagnostics\n+@cindex error messages, incorrect\n+@cindex incorrect error messages\n+(Sometimes an incorrect usage of the language leads to a situation where\n+the compiler can not make any sense of what it reads---while a human\n+might be able to---and thus ends up complaining about an incorrect\n+``problem'' it encounters that, in fact, reflects a misunderstanding of\n+the programmer's intention.)\n+\n+@cindex warnings\n+@cindex questionable instructions\n+@item\n+There are no warnings in treelang. A program is either correct or in\n+error.\n+@end itemize\n+\n+@cindex components of treelang\n+@cindex @code{treelang}, components of\n+@code{treelang} consists of several components:\n+\n+@cindex @code{gcc}, command\n+@cindex commands, @code{gcc}\n+@itemize @bullet\n+@item\n+A modified version of the @code{gcc} command, which also might be\n+installed as the system's @code{cc} command.\n+(In many cases, @code{cc} refers to the\n+system's ``native'' C compiler, which\n+might be a non-GNU compiler, or an older version\n+of @code{GCC} considered more stable or that is\n+used to build the operating system kernel.)\n+\n+@cindex @code{treelang}, command\n+@cindex commands, @code{treelang}\n+@item\n+The @code{treelang} command itself.\n+\n+@item\n+The @code{libc} run-time library.  This library contains the machine\n+code needed to support capabilities of the Treelang language that are\n+not directly provided by the machine code generated by the\n+@code{treelang} compilation phase. This is the same library that the\n+main c compiler uses (libc).\n+\n+@cindex @code{tree1}, program\n+@cindex programs, @code{tree1}\n+@cindex assembler\n+@cindex @code{as} command\n+@cindex commands, @code{as}\n+@cindex assembly code\n+@cindex code, assembly\n+@item\n+The compiler itself, is internally named @code{tree1}.\n+\n+Note that @code{tree1} does not generate machine code directly---it\n+generates @dfn{assembly code} that is a more readable form\n+of machine code, leaving the conversion to actual machine code\n+to an @dfn{assembler}, usually named @code{as}.\n+@end itemize\n+\n+@code{GCC} is often thought of as ``the C compiler'' only,\n+but it does more than that.\n+Based on command-line options and the names given for files\n+on the command line, @code{gcc} determines which actions to perform, including\n+preprocessing, compiling (in a variety of possible languages), assembling,\n+and linking.\n+\n+@cindex driver, gcc command as\n+@cindex @code{gcc}, command as driver\n+@cindex executable file\n+@cindex files, executable\n+@cindex cc1 program\n+@cindex programs, cc1\n+@cindex preprocessor\n+@cindex cpp program\n+@cindex programs, cpp\n+For example, the command @samp{gcc foo.c} @dfn{drives} the file\n+@file{foo.c} through the preprocessor @code{cpp}, then\n+the C compiler (internally named\n+@code{cc1}), then the assembler (usually @code{as}), then the linker\n+(@code{ld}), producing an executable program named @file{a.out} (on\n+UNIX systems).\n+\n+@cindex treelang program\n+@cindex programs, treelang\n+As another example, the command @samp{gcc foo.tree} would do much the\n+same as @samp{gcc foo.c}, but instead of using the C compiler named\n+@code{cc1}, @code{gcc} would use the treelang compiler (named\n+@code{tree1}). However there is no preprocessor for treelang.\n+\n+@cindex @code{tree1}, program\n+@cindex programs, @code{tree1}\n+In a GNU Treelang installation, @code{gcc} recognizes Treelang source\n+files by name just like it does C and C++ source files.  It knows to use\n+the Treelang compiler named @code{tree1}, instead of @code{cc1} or\n+@code{cc1plus}, to compile Treelang files. If a file's name ends in\n+@code{.tree} then GCC knows that the program is written in treelang. You\n+can also manually override the language.\n+\n+@cindex @code{gcc}, not recognizing Treelang source\n+@cindex unrecognized file format\n+@cindex file format not recognized\n+Non-Treelang-related operation of @code{gcc} is generally\n+unaffected by installing the GNU Treelang version of @code{gcc}.\n+However, without the installed version of @code{gcc} being the\n+GNU Treelang version, @code{gcc} will not be able to compile\n+and link Treelang programs.\n+\n+@cindex printing version information\n+@cindex version information, printing\n+The command @samp{gcc -v x.tree} where @samp{x.tree} is a file which\n+must exist but whose contents are ignored, is a quick way to display\n+version information for the various programs used to compile a typical\n+Treelang source file. \n+\n+The @code{tree1} program represents most of what is unique to GNU\n+Treelang; @code{tree1} is a combination of two rather large chunks of\n+code.\n+\n+@cindex GCC Back End (GBE)\n+@cindex GBE\n+@cindex @code{GCC}, back end\n+@cindex back end, GCC\n+@cindex code generator\n+One chunk is the so-called @dfn{GNU Back End}, or GBE,\n+which knows how to generate fast code for a wide variety of processors.\n+The same GBE is used by the C, C++, and Treelang compiler programs @code{cc1},\n+@code{cc1plus}, and @code{tree1}, plus others.\n+Often the GBE is referred to as the ``GCC back end'' or\n+even just ``GCC''---in this manual, the term GBE is used\n+whenever the distinction is important.\n+\n+@cindex GNU Treelang Front End (TFE)\n+@cindex tree1\n+@cindex @code{treelang}, front end\n+@cindex front end, @code{treelang}\n+The other chunk of @code{tree1} is the majority of what is unique about\n+GNU Treelang---the code that knows how to interpret Treelang programs to\n+determine what they are intending to do, and then communicate that\n+knowledge to the GBE for actual compilation of those programs.  This\n+chunk is called the @dfn{Treelang Front End} (TFE).  The @code{cc1} and\n+@code{cc1plus} programs have their own front ends, for the C and C++\n+languages, respectively.  These fronts ends are responsible for\n+diagnosing incorrect usage of their respective languages by the programs\n+the process, and are responsible for most of the warnings about\n+questionable constructs as well.  (The GBE in principle handles\n+producing some warnings, like those concerning possible references to\n+undefined variables, but these warnings should not occur in treelang\n+programs as the front end is meant to pick them up first).\n+\n+Because so much is shared among the compilers for various languages,\n+much of the behavior and many of the user-selectable options for these\n+compilers are similar.\n+For example, diagnostics (error messages and\n+warnings) are similar in appearance; command-line\n+options like @samp{-Wall} have generally similar effects; and the quality\n+of generated code (in terms of speed and size) is roughly similar\n+(since that work is done by the shared GBE).\n+\n+@node TREELANG and GCC, Compiler, Compiler Overview, Top\n+@chapter Compile Treelang, C, or Other Programs\n+@cindex compiling programs\n+@cindex programs, compiling\n+\n+@cindex @code{gcc}, command\n+@cindex commands, @code{gcc}\n+A GNU Treelang installation includes a modified version of the @code{gcc}\n+command.\n+\n+In a non-Treelang installation, @code{gcc} recognizes C, C++,\n+and Objective-C source files.\n+\n+In a GNU Treelang installation, @code{gcc} also recognizes Treelang source\n+files and accepts Treelang-specific command-line options, plus some\n+command-line options that are designed to cater to Treelang users\n+but apply to other languages as well.\n+\n+@xref{G++ and GCC,,Compile C; C++; or Objective-C,GCC,Using and Porting GCC},\n+for information on the way different languages are handled\n+by the GCC compiler (@code{gcc}).\n+\n+You can use this, combined with the output of the @samp{GCC -v x.tree}\n+command to get the options applicable to treelang. Treelang programs\n+must end with the suffix @samp{.tree}.\n+\n+@cindex preprocessor\n+\n+Treelang programs are not by default run through the C\n+preprocessor by @code{gcc}. There is no reason why they cannot be run through the\n+preprocessor manually, but you would need to prevent the preprocessor\n+from generating #line directives, using the @samp{-P} option, otherwise\n+tree1 will not accept the input.\n+\n+@node Compiler, Other Languages, TREELANG and GCC, Top\n+@chapter The GNU Treelang Compiler\n+\n+The GNU Treelang compiler, @code{treelang}, supports programs written\n+in the GNU Treelang language.\n+\n+@node Other Languages, treelang internals, Compiler, Top\n+@chapter Other Languages\n+\n+@menu\n+* Interoperating with C and C++::  \n+@end menu\n+\n+@node Interoperating with C and C++,  , Other Languages, Other Languages\n+@section Tools and advice for interoperating with C and C++\n+\n+The output of treelang programs looks like C program code to the linker\n+and everybody else, so you should be able to freely mix treelang and C\n+(and C++) code, with one proviso.\n+\n+C promotes small integer types to 'int' when used as function parameters and \n+return values. The treelang compiler does not do this, so if you want to interface\n+to C, you need to specify the promoted value, not the nominal value. \n+\n+@ifset INTERNALS\n+@node treelang internals, Open Questions, Other Languages, Top\n+@chapter treelang internals\n+\n+@menu\n+* treelang files::              \n+* treelang compiler interfaces::  \n+* Hints and tips::              \n+@end menu\n+\n+@node treelang files, treelang compiler interfaces, treelang internals, treelang internals\n+@section treelang files\n+\n+To create a compiler that integrates into GCC, you need create many\n+files. Some of the files are integrated into the main GCC makefile, to\n+build the various parts of the compiler and to run the test\n+suite. Others are incorporated into various GCC programs such as\n+GCC.c. Finally you must provide the actual programs comprising your\n+compiler. \n+\n+@cindex files\n+\n+The files are:\n+\n+@enumerate 1\n+\n+@item\n+COPYING. This is the copyright file, assuming you are going to use the\n+GNU General Public Licence. You probably need to use the GPL because if\n+you use the GCC back end your program and the back end are one program,\n+and the back end is GPLed.\n+\n+This need not be present if the language is incorporated into the main\n+GCC tree, as the main GCC directory has this file. \n+\n+@item\n+COPYING.LIB. This is the copyright file for those parts of your program\n+that are not to be covered by the GPL, but are instead to be covered by\n+the LGPL (Library or Lesser GPL). This licence may be appropriate for\n+the library routines associated with your compiler. These are the\n+routines that are linked with the @emph{output} of the compiler. Using\n+the LGPL for these programs allows programs written using your compiler\n+to be closed source. For example LIBC is under the LGPL. \n+\n+This need not be present if the language is incorporated into the main\n+GCC tree, as the main GCC directory has this file. \n+\n+@item\n+ChangeLog. Record all the changes to your compiler. Use the same format\n+as used in treelang as it is supported by an emacs editing mode and is\n+part of the FSF coding standard. Normally each directory has its own\n+changelog. The FSF standard allows but does not require a meaningful\n+comment on why the changes were made, above and beyond @emph{why} they\n+were made. In the author's opinion it is useful to provide this\n+information.\n+\n+@item\n+treelang.texi. The manual, written in texinfo. Your manual would have a\n+different file name. You need not write it in texinfo if you don't want\n+do, but a lot of GNU software does use texinfo. \n+\n+@cindex Make-lang.in\n+@item\n+Make-lang.in. This file is part of the make file which in incorporated\n+with the GCC make file skeleton (Makefile.in in the GCC directory) to\n+make Makefile, as part of the configuration process.\n+\n+Makefile in turn is the main instruction to actually build\n+everything. The build instructions are held in the main GCC manual and\n+web site so they are not repeated here. \n+\n+There are some comments at the top which will help you understand what\n+you need to do.\n+\n+There are make commands to build things, remove generated files with\n+various degrees of thoroughness, count the lines of code (so you know\n+how much progress you are making), build info and html files from the\n+texinfo source, run the tests etc.\n+\n+@item\n+README. Just a brief informative text file saying what is in this\n+directory. \n+\n+@cindex config-lang.in\n+@item\n+config-lang.in. This file is read by the configuration progress and must\n+be present. You specify the name of your language, the name(s) of the\n+compiler(s) incouding preprocessors you are going to build, whether any,\n+usually generated, files should be excluded from diffs (ie when making\n+diff files to send in patches). Whether the equate 'stagestuff' is used\n+is unknown (???).\n+\n+@cindex lang-options\n+@item\n+lang-options. This file is included into GCC.c, the main GCC driver, and\n+tells it what options your language supports. This is only used to\n+display help (is this true ???).\n+\n+@cindex lang-specs\n+@item\n+lang-specs. This file is also included in GCC.c. It tells GCC.c when to\n+call your programs and what options to send them. The mini-language\n+'specs' is documented in the source of GCC.c. Do not attempt to write a\n+specs file from scratch - use an existing one as the base and enhance\n+it. \n+\n+@item\n+Your texi files. Texinfo can be used to build documentation in HTML,\n+info, dvi and postscript formats. It is a tagged language, is documented\n+in its own manual, and has its own emacs mode.\n+\n+@item\n+Your programs. The relationships between all the programs are explained\n+in the next section. You need to write or use the following programs:\n+\n+@itemize @bullet\n+\n+@item\n+lexer. This breaks the input into words and passes these to the\n+parser. This is lex.l in treelang, which is passed through flex, a lex\n+variant, to produce C code lex.c. Note there is a school of thought that\n+says real men hand code their own lexers, however you may prefer to\n+write far less code and use flex, as was done with treelang.\n+\n+@item\n+parser. This breaks the program into recognizable constructs such as\n+expressions, statements etc. This is parse.y in treelang, which is\n+passed through bison, which is a yacc variant, to produce C code parse.c.\n+\n+@item\n+back end interface. This interfaces to the code generation back end. In\n+treelang, this is tree1.c which mainly interfaces to toplev.c and\n+treetree.c which mainly interfaces to everything else. Many languages\n+mix up the back end interface with the parser, as in the C compiler for\n+example. It is a matter of taste which way to do it, but with treelang\n+it is separated out to make the back end interface cleaner and easier to\n+understand.\n+\n+@item\n+header files. For function prototypes and common data items. One point\n+to note here is that bison can generate a header files with all the\n+numbers is has assigned to the keywords and symbols, and you can include\n+the same header in your lexer. This technique is demonstrated in\n+treelang.\n+\n+@item\n+compiler main file. GCC comes with a program toplev.c which is a\n+perfectly serviceable main program for your compiler. treelang uses\n+toplev.c but other languages have been known to replace it with their\n+own main program. Again this is a matter of taste and how much code you\n+want to write. \n+\n+@end itemize\n+\n+@end enumerate\n+\n+@node treelang compiler interfaces, Hints and tips, treelang files, treelang internals\n+@section treelang compiler interfaces\n+\n+@cindex driver\n+@cindex toplev.c\n+\n+@menu\n+* treelang driver::             \n+* treelang main compiler::      \n+@end menu\n+\n+@node treelang driver, treelang main compiler, treelang compiler interfaces, treelang compiler interfaces\n+@subsection treelang driver\n+\n+The GCC compiler consists of a driver, which then executes the various\n+compiler phases based on the instructions in the specs files. \n+\n+Typically a program's language will be identified from its suffix (eg\n+.tree) for treelang programs.\n+\n+The driver (gcc.c) will then drive (exec) in turn a preprocessor, the main\n+compiler, the assembler and the link editor. Options to GCC allow you to\n+override all of this. In the case of treelang programs there is no\n+preprocessor, and mostly these days the C preprocessor is run within the\n+main C compiler rather than as a separate process, apparently for reasons of speed.\n+\n+You will be using the standard assembler and linkage editor so these are\n+ignored from now on. \n+\n+You have to write your own preprocessor if you want one. This is usually\n+totally language specific. The main point to be aware of is to ensure\n+that you find some way to pass file name and line number information\n+through to the main compiler so that it can tell the back end this\n+information and so the debugger can find the right source line for each\n+piece of code. That is all there is to say about the preprocessor except\n+that the preprocessor will probably not be the slowest part of the\n+compiler and will probably not use the most memory so don't waste too\n+much time tuning it until you know you need to do so.\n+\n+@node treelang main compiler,  , treelang driver, treelang compiler interfaces\n+@subsection treelang main compiler\n+\n+The main compiler for treelang consists of toplev.c from the main GCC\n+compiler, the parser, lexer and back end interface routines, and the\n+back end routines themselves, of which there are many.\n+\n+toplev.c does a lot of work for you and you should almost certainly use it,\n+\n+Writing this code is the hard part of creating a compiler using GCC. The\n+back end interface documentation is incomplete and the interface is\n+complex. \n+\n+There are three main aspects to interfacing to the other GCC code. \n+\n+@menu\n+* Interfacing to toplev.c::     \n+* Interfacing to the garbage collection::  \n+* Interfacing to the code generation code. ::  \n+@end menu\n+\n+@node Interfacing to toplev.c, Interfacing to the garbage collection, treelang main compiler, treelang main compiler\n+@subsubsection Interfacing to toplev.c\n+\n+In treelang this is handled mainly in tree1.c\n+and partly in treetree.c. Peruse toplev.c for details of what you need\n+to do.\n+\n+@node Interfacing to the garbage collection, Interfacing to the code generation code. , Interfacing to toplev.c, treelang main compiler\n+@subsubsection Interfacing to the garbage collection\n+\n+Interfacing to the garbage collection. In treelang this is mainly in\n+tree1.c. \n+\n+Memory allocation in the compiler should be done using the ggc_alloc and\n+kindred routines in ggc*.*. At the end of every 'function' in your language, toplev.c calls\n+the garbage collection several times. The garbage collection calls mark\n+routines which go through the memory which is still used, telling the\n+garbage collection not to free it. Then all the memory not used is\n+freed.\n+\n+What this means is that you need a way to hook into this marking\n+process. This is done by calling ggc_add_root. This provides the address\n+of a callback routine which will be called duing garbage collection and\n+which can call ggc_mark to save the storage. If storage is only\n+used within the parsing of a function, you do not need to provide a way\n+to mark it. \n+\n+Note that you can also call ggc_mark_tree to mark any of the back end\n+internal 'tree' nodes. This routine will follow the branches of the\n+trees and mark all the subordinate structures. This is useful for\n+example when you have created a variable declaaration that will be used\n+across multiple functions, or for a function declaration (from a\n+prototype) that may be used later on. See the next item for more on the\n+tree nodes. \n+\n+@node Interfacing to the code generation code. ,  , Interfacing to the garbage collection, treelang main compiler\n+@subsubsection Interfacing to the code generation code. \n+\n+In treelang this is done in treetree.c. A typedef called 'tree' which is\n+defined in tree.h and tree.def in the GCC directory and largely\n+implemented in tree.c and stmt.c forms the basic interface to the\n+compiler back end.\n+\n+In general you call various tree routines to generate code, either\n+directly or through toplev.c. You build up data structures and\n+expressions in similar ways. \n+\n+You can read some documentation on this which can be found via the GCC\n+main web page. In particular, the documentation produced by Joachim\n+Nadler and translated by Tim Josling can be quite useful. the C compiler\n+also has documentation in the main GCC manual (particularly the current\n+CVS version) which is useful on a lot of the details.\n+\n+In time it is hoped to enhance this document to provide a more\n+comprehensive overview of this topic. The main gap is in explaining how\n+it all works together. \n+\n+@node Hints and tips,  , treelang compiler interfaces, treelang internals\n+@section Hints and tips\n+\n+@itemize @bullet\n+\n+@item\n+TAGS: Use the make ETAGS commands to create TAGS files which can be used in\n+emacs to jump to any symbol quickly. \n+\n+@item\n+GREP: grep is also a useful way to find all uses of a symbol.\n+\n+@item\n+TREE: The main routines to look at are tree.h and tree.def. You will\n+probably want a hardcopy of these. \n+\n+@item\n+SAMPLE: look at the sample interfacing code in treetree.c. You can use\n+gdb to trace through the code and learn about how it all works. \n+\n+@item\n+GDB: the GCC back end works well with gdb. It traps abort() and allows\n+you to trace back what went wrong. \n+\n+@item\n+Error Checking: The compiler back end does some error and consistency\n+checking. Often the result of an error is just no code being\n+generated. You will then need to trace through and find out what is\n+going wrong. The rtl dump files can help here also.\n+\n+@item\n+rtl dump files: The main compiler documents these files which are dumps\n+of the rtl (intermediate code) which is manipulated doing the code\n+generation process. This can provide useful clues about what is going\n+wrong. The rtl 'language' is documented in the main GCC manual.\n+\n+@end itemize\n+\n+@end ifset\n+\n+@node Open Questions, Bugs, treelang internals, Top\n+@chapter Open Questions\n+\n+If you know GCC well, please consider looking at the file treetree.c and\n+resolving any questions marked \"???\".\n+\n+@node Bugs, Service, Open Questions, Top\n+@chapter Reporting Bugs\n+@cindex bugs\n+@cindex reporting bugs\n+\n+You can report bugs to @email{@value{email-bugs}}. Please make\n+sure bugs are real before reporting them. Follow the guidelines in the\n+main GCC manual for submitting bug reports.\n+\n+@menu\n+* Sending Patches::             \n+@end menu\n+\n+@node Sending Patches,  , Bugs, Bugs\n+@section Sending Patches for GNU Treelang\n+\n+If you would like to write bug fixes or improvements for the GNU\n+Treelang compiler, that is very helpful.  Send suggested fixes to\n+@email{@value{email-patches}}.\n+\n+@node Service, Projects, Bugs, Top\n+@chapter How To Get Help with GNU Treelang\n+\n+If you need help installing, using or changing GNU Treelang, there are two\n+ways to find it:\n+\n+@itemize @bullet\n+\n+@item\n+Look in the service directory for someone who might help you for a fee.\n+The service directory is found in the file named @file{SERVICE} in the\n+GCC distribution.\n+\n+@item\n+Send a message to @email{@value{email-general}}.\n+\n+@end itemize\n+\n+@end ifset\n+@ifset INTERNALS\n+\n+@node Projects, Index, Service, Top\n+@chapter Projects\n+@cindex projects\n+\n+If you want to contribute to @code{treelang} by doing research,\n+design, specification, documentation, coding, or testing,\n+the following information should give you some ideas.\n+\n+Send a message to @email{@value{email-general}} if you plan to add a\n+feature.\n+\n+The main requirement for treelang is to add features and to add\n+documentation. Features are things that the GCC back end can do but\n+which are not reflected in treelang. Examples include structures,\n+unions, pointers, arrays.\n+\n+@end ifset\n+\n+@node Index,  , Projects, Top\n+@unnumbered Index\n+\n+@printindex cp\n+@summarycontents\n+@contents\n+@bye"}, {"sha": "07cb1a5e5edd68b498f19771cf3cdeb4f48860d5", "filename": "gcc/treelang/treetree.c", "status": "added", "additions": 1288, "deletions": 0, "changes": 1288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,1288 @@\n+/* \n+\n+    TREELANG Compiler back end interface (treetree.c)\n+    Called by the parser.\n+\n+    If you want a working example of how to write a front end to GCC,\n+    you are in the right place.\n+\n+    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+    2001, 2002 Free Software Foundation, Inc.\n+\n+    This code is based on toy.c written by Richard Kenner. \n+    \n+    It was later modified by Jonathan Bartlett whose changes have all\n+    been removed (by Tim Josling).\n+\n+    Various bits and pieces were cloned from the GCC main tree, as\n+    GCC evolved, for COBOLForGCC, by Tim Josling.\n+\n+    It was adapted to TREELANG by Tim Josling 2001.\n+\n+    ---------------------------------------------------------------------------\n+\n+    This program is free software; you can redistribute it and/or modify it\n+    under the terms of the GNU General Public License as published by the\n+    Free Software Foundation; either version 2, or (at your option) any\n+    later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License\n+    along with this program; if not, write to the Free Software\n+    Foundation, 59 Temple Place - Suite 330,\n+    Boston, MA 02111-1307, USA.\n+\n+    In other words, you are welcome to use, share and improve this program.\n+    You are forbidden to forbid anyone else to use, share and improve\n+    what you give them.   Help stamp out software-hoarding!  \n+\n+    ---------------------------------------------------------------------------\n+\n+ */\n+\n+/*\n+  Assumption: garbage collection is never called implicitly.  It will\n+  not be called 'at any time' when short of memory.  It will only be\n+  called explicitly at the end of each function.  This removes the\n+  need for a *lot* of bother to ensure everything is in the mark trees\n+  at all times.  */\n+\n+  /* Note it is OK to use GCC extensions such as long long in a compiler front end.\n+     This is because the GCC front ends are built using GCC. */\n+\n+/* Standard/OS headers.  */\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include \"safe-ctype.h\"\n+#include <errno.h>\n+#include <stdarg.h>\n+#include <limits.h>\n+#include <string.h>\n+\n+#include <fcntl.h>\n+#include <getopt.h>\n+#include <stdio.h>\n+\n+/* GCC headers.  */\n+\n+#include \"ansidecl.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"c-lex.h\"\n+#include \"c-tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"toplev.h\"\n+#include \"varray.h\"\n+#include \"langhooks-def.h\"\n+#include \"langhooks.h\"\n+\n+#include \"treetree.h\"\n+\n+extern int option_main;\n+extern char **file_names;\n+\n+/* Flags etc required by c code.  */\n+\n+int warn_format = 0;\n+int warn_format_y2k = 0;\n+int warn_format_extra_args = 0;\n+int warn_format_nonliteral = 0;\n+int warn_format_security = 0;\n+\n+/* The front end language hooks (addresses of code for this front\n+   end).  Mostly just use the C routines.  */\n+\n+#undef LANG_HOOKS_TRUTHVALUE_CONVERSION\n+#define LANG_HOOKS_TRUTHVALUE_CONVERSION c_common_truthvalue_conversion\n+#undef LANG_HOOKS_MARK_ADDRESSABLE\n+#define LANG_HOOKS_MARK_ADDRESSABLE c_mark_addressable\n+#undef LANG_HOOKS_SIGNED_TYPE\n+#define LANG_HOOKS_SIGNED_TYPE c_common_signed_type\n+#undef LANG_HOOKS_UNSIGNED_TYPE\n+#define LANG_HOOKS_UNSIGNED_TYPE c_common_unsigned_type\n+#undef LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n+#define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE c_common_signed_or_unsigned_type\n+#undef LANG_HOOKS_TYPE_FOR_MODE\n+#define LANG_HOOKS_TYPE_FOR_MODE c_common_type_for_mode\n+#undef LANG_HOOKS_TYPE_FOR_SIZE\n+#define LANG_HOOKS_TYPE_FOR_SIZE c_common_type_for_size\n+#undef LANG_HOOKS_PARSE_FILE\n+#define LANG_HOOKS_PARSE_FILE treelang_parse_file\n+\n+/* Hook routines and data unique to treelang.  */\n+\n+#undef LANG_HOOKS_INIT\n+#define LANG_HOOKS_INIT treelang_init\n+#undef LANG_HOOKS_NAME\n+#define LANG_HOOKS_NAME\t\"GNU treelang\"\n+#undef LANG_HOOKS_FINISH \n+#define LANG_HOOKS_FINISH\t\ttreelang_finish\n+#undef LANG_HOOKS_DECODE_OPTION\t\n+#define LANG_HOOKS_DECODE_OPTION treelang_decode_option\n+const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+/* Tree code type/name/code tables.  */\n+\n+#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n+\n+const char tree_code_type[] = {\n+#include \"tree.def\"\n+  'x'\n+};\n+#undef DEFTREECODE\n+\n+#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) LENGTH,\n+\n+const unsigned char tree_code_length[] = {\n+#include \"tree.def\"\n+  0\n+};\n+#undef DEFTREECODE\n+\n+#define DEFTREECODE(SYM, NAME, TYPE, LEN) NAME,\n+\n+const char *const tree_code_name[] = {\n+#include \"tree.def\"\n+  \"@@dummy\"\n+};\n+#undef DEFTREECODE\n+\n+/* Number of bits in int and char - accessed by front end.  */\n+\n+unsigned int tree_code_int_size = 0;\n+unsigned int tree_code_char_size = 0;\n+\n+/* In this case there is very little to keep between functions - we\n+   keep the symbol table only and the things that hang off that - see\n+   tree1.c.  Garbage collection is only invoked when we call\n+   rest_of_compilation at the end of a function. */\n+\n+#define ADDROOT(where) ggc_add_root (&where, 1, /* Unused size.  */ sizeof (void*), \\\n+ tree_ggc_storage_always_used);\n+\n+/* Return the tree stuff for this type TYPE_NUM.  */\n+\n+tree \n+tree_code_get_type (int type_num) \n+{\n+  switch (type_num)\n+    {\n+    case SIGNED_CHAR:\n+      return signed_char_type_node;\n+      \n+    case UNSIGNED_CHAR:\n+      return unsigned_char_type_node;\n+\n+    case SIGNED_INT:\n+      return integer_type_node;\n+\n+    case UNSIGNED_INT:\n+      return unsigned_type_node; \n+\n+    case VOID_TYPE:\n+      return void_type_node; \n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Output the code for the start of an if statement.  The test\n+   expression is EXP (true if not zero), and the stmt occurred at line\n+   LINENO in file FILENAME.  */\n+\n+void\n+tree_code_if_start (tree exp, unsigned char* filename, int lineno)\n+{\n+  tree cond_exp;\n+  cond_exp = build (NE_EXPR, \n+                 TREE_TYPE (exp), \n+                 exp, \n+                 build1 (CONVERT_EXPR, TREE_TYPE (exp), integer_zero_node));\n+  emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n+  expand_start_cond (cond_exp, /* Exit-able if non zero.  */ 0);\n+}\n+\n+/* Output the code for the else of an if statement.  The else occurred\n+   at line LINENO in file FILENAME.  */\n+\n+void \n+tree_code_if_else (unsigned char* filename, int lineno)\n+{\n+  emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n+  expand_start_else ();\n+}\n+\n+/* Output the code for the end_if an if statement.  The end_if (final brace) occurred\n+   at line LINENO in file FILENAME.  */\n+\n+void \n+tree_code_if_end (unsigned char* filename, int lineno)\n+{\n+  emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n+  expand_end_cond ();\n+}\n+\n+/* Create a function.  The prototype name is NAME, storage class is\n+   STORAGE_CLASS, type of return variable is RET_TYPE, parameter lists\n+   is PARMS, returns decl for this function.  */\n+\n+tree \n+tree_code_create_function_prototype (unsigned char* chars,\n+                                    unsigned int storage_class,\n+                                    unsigned int ret_type,\n+                                    struct tree_parameter_list* parms,\n+                                    unsigned char* filename,\n+                                    int lineno)\n+{\n+\n+  tree id;\n+  struct tree_parameter_list* parm;\n+  tree type_list = NULL_TREE;\n+  tree type_node;\n+  tree fn_type;\n+  tree fn_decl;\n+\n+  /* Build the type.  */\n+  id = get_identifier ((const char*)chars);\n+  for (parm = parms; parm; parm = parm->next)\n+    {\n+      type_node = get_type_for_numeric_type (parm->type);\n+      type_list = tree_cons (NULL_TREE, type_node, type_list);\n+    }\n+  /* Last parm if null indicates fixed length list (as opposed to\n+     printf style va_* list).  */\n+  type_list = tree_cons (NULL_TREE, void_type_node, type_list);\n+  /* The back end needs them in reverse order.  */\n+  type_list = nreverse (type_list);\n+\n+  type_node = get_type_for_numeric_type (ret_type);\n+  fn_type = build_function_type (type_node, type_list);\n+\n+  id = get_identifier ((const char*)chars);\n+  fn_decl = build_decl (FUNCTION_DECL, id, fn_type);\n+\n+  DECL_CONTEXT (fn_decl) = NULL_TREE; /* Nested functions not supported here.  */\n+  DECL_SOURCE_FILE (fn_decl) = (const char *)filename;\n+ /*  if (lineno > 1000000)\n+    ; */ /* Probably the line # is rubbish because someone forgot to set\n+    the line number - and unfortunately impossible line #s are used as\n+    magic flags at various times. The longest known function for\n+    example is about 550,000 lines (it was written in COBOL).  */\n+  DECL_SOURCE_LINE (fn_decl) = lineno;\n+\n+  TREE_USED (fn_decl) = 1;\n+\n+  /* Real name (optional).  */\n+  SET_DECL_ASSEMBLER_NAME (fn_decl, DECL_NAME (fn_decl));\n+  \n+  TREE_PUBLIC (fn_decl) = 0;\n+  DECL_EXTERNAL (fn_decl) = 0; \n+  TREE_STATIC (fn_decl) = 0; \n+  switch (storage_class)\n+    {\n+    case STATIC_STORAGE:\n+      TREE_PUBLIC (fn_decl) = 0; \n+      break;\n+\n+    case EXTERNAL_DEFINITION_STORAGE:\n+      TREE_PUBLIC (fn_decl) = 1;\n+      TREE_STATIC (fn_decl) = 0; \n+      DECL_EXTERNAL (fn_decl) = 0;\n+      break;\n+  \n+    case EXTERNAL_REFERENCE_STORAGE:\n+      TREE_PUBLIC (fn_decl) = 0; \n+      DECL_EXTERNAL (fn_decl) = 1;\n+      break;\n+\n+\n+    case AUTOMATIC_STORAGE:\n+    default:\n+      abort ();\n+    }\n+\n+  /* Process declaration of function defined elsewhere.  */\n+  rest_of_decl_compilation (fn_decl, NULL, 1, 0);\n+\n+  return fn_decl;\n+}\n+\n+\n+/* Output code for start of function; the decl of the function is in\n+    PREV_SAVED (as created by tree_code_create_function_prototype),\n+    the function is at line number LINENO in file FILENAME.  The\n+    parameter details are in the lists PARMS. Returns nothing.  */\n+void \n+tree_code_create_function_initial (tree prev_saved, \n+                                  unsigned char* filename,\n+                                  int lineno,\n+                                  struct tree_parameter_list* parms)\n+{\n+  tree fn_decl;\n+  tree param_decl;\n+  tree next_param;\n+  tree first_param;\n+  tree parm_decl;\n+  tree parm_list;\n+  tree resultdecl;\n+  struct tree_parameter_list* this_parm; \n+  struct tree_parameter_list* parm;\n+\n+  fn_decl = prev_saved;\n+  if (!fn_decl)\n+    abort ();\n+\n+  /* Output message if not -quiet.  */\n+  announce_function (fn_decl);\n+\n+  /* This has something to do with forcing output also.  */\n+  pushdecl (fn_decl);\n+\n+  /* Set current function for error msgs etc.  */\n+  current_function_decl = fn_decl;\n+  DECL_INITIAL (fn_decl) = error_mark_node;\n+\n+  DECL_SOURCE_FILE (fn_decl) = (const char *)filename;\n+  DECL_SOURCE_LINE (fn_decl) = lineno;\n+\n+  /* Prepare creation of rtl for a new function.  */\n+  \n+  resultdecl = DECL_RESULT (fn_decl) = build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (TREE_TYPE (fn_decl)));\n+  DECL_CONTEXT (DECL_RESULT (fn_decl)) = fn_decl;\n+  DECL_SOURCE_FILE (resultdecl) = (const char *)filename;\n+  DECL_SOURCE_LINE (resultdecl) = lineno;\n+  /* Work out the size. ??? is this needed.  */\n+  layout_decl (DECL_RESULT (fn_decl), 0);\n+\n+  /* Make the argument variable decls.  */\n+  parm_list = NULL_TREE;\n+  for (parm = parms; parm; parm = parm->next)\n+    {\n+      parm_decl = build_decl (PARM_DECL, get_identifier ((const char*) (parm->variable_name)), \n+                           get_type_for_numeric_type (parm->type));\n+      \n+      /* Some languages have different nominal and real types.  */\n+      DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);\n+      if (!DECL_ARG_TYPE (parm_decl))\n+        abort ();\n+      if (!fn_decl)\n+        abort ();\n+      DECL_CONTEXT (parm_decl) = fn_decl;\n+      DECL_SOURCE_FILE (parm_decl) = (const char *)filename;\n+      DECL_SOURCE_LINE (parm_decl) = lineno;\n+      parm_list = chainon (parm_decl, parm_list);\n+    }\n+\n+  /* Back into reverse order as the back end likes them.  */\n+  parm_list = nreverse (parm_list);\n+  \n+  DECL_ARGUMENTS (fn_decl) = parm_list;\n+\n+  /* Save the decls for use when the args are referred to.  */\n+  for (param_decl = DECL_ARGUMENTS (fn_decl),\n+         this_parm = parms;\n+       param_decl;\n+       param_decl = TREE_CHAIN (param_decl),\n+         this_parm = this_parm->next)\n+    {\n+      if (!this_parm)\n+        abort (); /* Too few.  */\n+      *this_parm->where_to_put_var_tree = param_decl;\n+    }\n+  if (this_parm)\n+    abort (); /* Too many.  */\n+\n+  /* Output the decl rtl (not the rtl for the function code).  ???.\n+     If the function is not defined in this file, when should you\n+     execute this?  */\n+  make_decl_rtl (fn_decl, NULL);\n+\n+  /* Use filename/lineno from above.  */\n+  init_function_start (fn_decl, (const char *)filename, lineno); \n+  \n+  /* Create rtl for startup code of function, such as saving registers.  */\n+  \n+  expand_function_start (fn_decl, 0);\n+  \n+  /* Function.c requires a push at the start of the function. that\n+     looks like a bug to me but let's make it happy.  */\n+  \n+  (*lang_hooks.decls.pushlevel) (0);\n+  \n+  /* Create rtl for the start of a new scope.  */\n+  \n+  expand_start_bindings (2);\n+\n+  /* Put the parameters into the symbol table.  */\n+  \n+  for (first_param = param_decl = nreverse (DECL_ARGUMENTS (fn_decl));\n+       param_decl;\n+       param_decl = next_param)\n+    {\n+      next_param = TREE_CHAIN (param_decl);\n+      TREE_CHAIN (param_decl) = NULL;\n+      /* layout_decl (param_decl, 0);  Already done in build_decl tej 13/4/2002.  */\n+      pushdecl (param_decl);\n+      if (DECL_CONTEXT (param_decl) != current_function_decl)\n+        abort ();\n+    }\n+\n+  /* Store back the PARM_DECL nodes.  They appear in the right order.  */\n+  DECL_ARGUMENTS (fn_decl) = getdecls ();\n+\n+  /* Force it to be output, else may be solely inlined.  */\n+  TREE_ADDRESSABLE (fn_decl) = 1;\n+  \n+  /* Stop -O3 from deleting it.  */\n+  TREE_USED (fn_decl) = 1;\n+\n+  /* Add a new level to the debugger symbol table.  */\n+  \n+  (*lang_hooks.decls.pushlevel) (0);\n+  \n+  /* Create rtl for the start of a new scope.  */\n+  \n+  expand_start_bindings (0);\n+  \n+  emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n+}\n+\n+/* Wrapup a function contained in file FILENAME, ending at line LINENO.  */\n+void \n+tree_code_create_function_wrapup (unsigned char* filename,\n+                                 int lineno)\n+{\n+  tree block;\n+  tree fn_decl;\n+\n+  fn_decl = current_function_decl;\n+  \n+  emit_line_note ((const char *)filename, lineno); /* Output the line number information.  */\n+\n+  /* Get completely built level from debugger symbol table.  */\n+  \n+  block = (*lang_hooks.decls.poplevel) (1, 0, 0);\n+  \n+  /* Emit rtl for end of scope.  */\n+  \n+  expand_end_bindings (block, 0, 1);\n+  \n+  /* Emit rtl for end of function.  */\n+  \n+  expand_function_end ((const char *)filename, lineno, 0);\n+  \n+  /* Pop the level.  */\n+\n+  block = (*lang_hooks.decls.poplevel) (1, 0, 1);\n+\n+  /* And attach it to the function.  */\n+  \n+  DECL_INITIAL (fn_decl) = block;\n+  \n+  /* Emit rtl for end of scope.  */\n+  \n+  expand_end_bindings (block, 0, 1);\n+  \n+  /* Call optimization and convert optimized rtl to assembly code.  */\n+  \n+  rest_of_compilation (fn_decl);\n+  \n+  /* We are not inside of any scope now.  */\n+  \n+  current_function_decl = NULL_TREE;\n+}\n+\n+/* \n+   Create a variable. \n+   \n+   The storage class is STORAGE_CLASS (eg LOCAL).   \n+   The name is CHARS/LENGTH.   \n+   The type is EXPRESSION_TYPE (eg UNSIGNED_TYPE).  \n+   The init tree is INIT.  \n+*/\n+\n+tree \n+tree_code_create_variable (unsigned int storage_class,\n+                               unsigned char* chars,\n+                               unsigned int length,\n+                               unsigned int expression_type,\n+                               tree init,\n+                               unsigned char* filename,\n+                               int lineno)\n+{\n+  tree var_type;\n+  tree var_id;\n+  tree var_decl;\n+\n+  /* 1. Build the type.  */\n+  var_type = get_type_for_numeric_type (expression_type);\n+\n+  /* 2. Build the name.  */\n+  if (chars[length] != 0)\n+    abort (); /* Should be null terminated.  */\n+\n+  var_id = get_identifier ((const char*)chars);\n+\n+  /* 3. Build the decl and set up init.  */\n+  var_decl = build_decl (VAR_DECL, var_id, var_type);\n+\n+  /* 3a. Initialization.  */\n+  if (init)\n+    DECL_INITIAL (var_decl) = build1 (CONVERT_EXPR, var_type, init);\n+  else\n+    DECL_INITIAL (var_decl) = NULL_TREE;\n+      \n+  /* 4. Compute size etc.  */\n+  layout_decl (var_decl, 0);\n+      \n+  if (TYPE_SIZE (var_type) == 0)\n+    abort (); /* Did not calculate size.  */\n+\n+  DECL_CONTEXT (var_decl) = current_function_decl;\n+\n+  DECL_SOURCE_FILE (var_decl) = (const char *)filename;\n+  DECL_SOURCE_LINE (var_decl) = lineno;\n+\n+  /* Set the storage mode and whether only visible in the same file.  */\n+  switch (storage_class)\n+    {\n+    case STATIC_STORAGE:\n+      TREE_STATIC (var_decl) = 1;\n+      TREE_PUBLIC (var_decl) = 0;\n+      break;\n+\n+    case AUTOMATIC_STORAGE:\n+      TREE_STATIC (var_decl) = 0;\n+      TREE_PUBLIC (var_decl) = 0;\n+      break;\n+      \n+    case EXTERNAL_DEFINITION_STORAGE:\n+      TREE_STATIC (var_decl) = 0; \n+      TREE_PUBLIC (var_decl) = 1;\n+      break;\n+      \n+    case EXTERNAL_REFERENCE_STORAGE:\n+      DECL_EXTERNAL (var_decl) = 1;\n+      TREE_PUBLIC (var_decl) = 0;\n+      break;\n+      \n+    default:\n+      abort ();\n+    }\n+      \n+  /* This should really only be set if the variable is used.  */\n+  TREE_USED (var_decl) = 1;\n+      \n+  /* Expand declaration and initial value if any.  */\n+  \n+  if (TREE_STATIC (var_decl)) \n+    rest_of_decl_compilation (var_decl, 0, 0, 0);\n+  else\n+    {\n+      expand_decl (var_decl);\n+      if (DECL_INITIAL (var_decl))\n+        expand_decl_init (var_decl);\n+    }\n+  \n+  return pushdecl (copy_node (var_decl));\n+  \n+}\n+\n+\n+/* Generate code for return statement.  Type is in TYPE, expression\n+   is in EXP if present.  */\n+\n+void\n+tree_code_generate_return (tree type, tree exp)\n+{\n+  tree setret;\n+  tree param;\n+\n+  for (param = DECL_ARGUMENTS (current_function_decl);\n+       param;\n+       param = TREE_CHAIN (param))\n+    {\n+      if (DECL_CONTEXT (param) != current_function_decl)\n+        abort ();\n+    }\n+\n+  if (exp)\n+    {\n+      setret = build (MODIFY_EXPR, type, DECL_RESULT (current_function_decl), \n+                     build1 (CONVERT_EXPR, type, exp));\n+      TREE_SIDE_EFFECTS (setret) = 1;\n+      TREE_USED (setret) = 1;\n+      expand_expr_stmt (setret);\n+    }\n+  expand_return (DECL_RESULT (current_function_decl));\n+}\n+\n+/* Output the code for this expression statement CODE.  */\n+\n+\n+void \n+tree_code_output_expression_statement (tree code, \n+                                       unsigned char* filename, int lineno)\n+{\n+  /* Output the line number information.  */\n+  emit_line_note ((const char *)filename, lineno); \n+  TREE_USED (code) = 1;\n+  TREE_SIDE_EFFECTS (code) = 1;\n+  expand_expr_stmt (code);\n+}\n+\n+/* Return a tree for a constant integer value in the token TOK.  No\n+   size checking is done.  */\n+\n+tree \n+tree_code_get_integer_value (unsigned char* chars, unsigned int length)\n+{\n+  long long int val = 0;\n+  unsigned int ix;\n+  unsigned int start = 0;\n+  int negative = 1;\n+  switch (chars[0])\n+    {\n+    case (unsigned char)'-':\n+      negative = -1;\n+      start = 1;\n+      break;\n+\n+    case (unsigned char)'+':\n+      start = 1;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  for (ix = start; ix < length; ix++)\n+    val = val * 10 + chars[ix] - (unsigned char)'0';\n+  val = val*negative;\n+  return build_int_2 (val & 0xffffffff, (val >> 32) & 0xffffffff);\n+}\n+\n+/* Return the tree for an expresssion, type EXP_TYPE (see treetree.h)\n+   with tree type TYPE and with operands1 OP1, OP2 (maybe), OP3 (maybe).  */\n+tree \n+tree_code_get_expression (unsigned int exp_type, \n+                          tree type, tree op1, tree op2, tree op3 ATTRIBUTE_UNUSED)\n+{\n+  tree ret1;\n+  int operator;\n+\n+  switch (exp_type)\n+    {\n+    case EXP_ASSIGN:\n+      if (!op1 || !op2)\n+        abort ();\n+      operator = MODIFY_EXPR;\n+      ret1 = build (operator, type, \n+                 op1, \n+                 build1 (CONVERT_EXPR, type, op2));\n+\n+      break;\n+\n+    case EXP_PLUS:\n+      operator = PLUS_EXPR;\n+      goto binary_expression;\n+      \n+    case EXP_MINUS:\n+      operator = MINUS_EXPR;\n+      goto binary_expression;\n+      \n+    case EXP_EQUALS:\n+      operator = EQ_EXPR;\n+      goto binary_expression;\n+      \n+      /* Expand a binary expression.  Ensure the operands are the right type.  */\n+    binary_expression:\n+      if (!op1 || !op2)\n+        abort ();\n+      ret1  =  build (operator, type, \n+                   build1 (CONVERT_EXPR, type, op1), \n+                   build1 (CONVERT_EXPR, type, op2));\n+      break;\n+\n+      /* Reference to a variable.  This is dead easy, just return the\n+         decl for the variable.  If the TYPE is different than the\n+         variable type, convert it.  */\n+    case EXP_REFERENCE:\n+      if (!op1)\n+        abort ();\n+      if (type == TREE_TYPE (op1))\n+        ret1 = op1;\n+      else\n+        ret1 = build1 (CONVERT_EXPR, type, op1);\n+      break;\n+      \n+    case EXP_FUNCTION_INVOCATION:\n+      if (!op1 || !op2)\n+        abort ();\n+      {\n+        tree fun_ptr;\n+        fun_ptr = build1 (ADDR_EXPR, build_pointer_type (type), op1);\n+        ret1 = build (CALL_EXPR, type, fun_ptr, nreverse (op2));\n+      }\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+  \n+  return ret1;\n+}\n+\n+/* Init parameter list and return empty list.  */\n+\n+tree \n+tree_code_init_parameters (void)\n+{\n+  return NULL_TREE;\n+}\n+\n+/* Add a parameter EXP whose expression type is EXP_PROTO to list\n+   LIST, returning the new list.  */\n+\n+tree \n+tree_code_add_parameter (tree list, tree proto_exp, tree exp)\n+{\n+  tree new_exp;\n+  new_exp = tree_cons (NULL_TREE, \n+                    build1 (CONVERT_EXPR, TREE_TYPE (proto_exp), exp),\n+                    NULL_TREE);\n+  if (!list)\n+    return new_exp;\n+  return chainon (new_exp, list);\n+}\n+\n+/* Get the tree type for this type whose number is NUMERIC_TYPE.  */\n+\n+tree\n+get_type_for_numeric_type (unsigned int numeric_type)\n+{\n+  \n+  int size1;\n+  int sign1;\n+  switch (numeric_type)\n+    {\n+    case VOID_TYPE:\n+      return void_type_node;\n+      \n+    case SIGNED_INT:\n+      size1 = tree_code_int_size;\n+      sign1 = 1;\n+      break;\n+      \n+    case UNSIGNED_INT:\n+      size1 = tree_code_int_size;\n+      sign1 = 0;\n+      break;\n+      \n+    case SIGNED_CHAR:\n+      size1 = tree_code_char_size;\n+      sign1 = 1;\n+      break;\n+      \n+    case UNSIGNED_CHAR:\n+      size1 = tree_code_char_size;\n+      sign1 = 0;\n+      break;\n+      \n+    default:\n+      abort ();\n+    }\n+\n+  return tree_code_get_numeric_type (size1, sign1);\n+  \n+}\n+\n+/* Return tree representing a numeric type of size SIZE1 bits and\n+   signed if SIGN1 !=  0.  */\n+tree \n+tree_code_get_numeric_type (unsigned int size1, unsigned int sign1)\n+{\n+  tree ret1;\n+  if (size1 == tree_code_int_size)\n+    {\n+      if (sign1)\n+        ret1 = integer_type_node;\n+      else\n+        ret1 = unsigned_type_node;\n+    }\n+  else\n+    if (size1 == tree_code_char_size)\n+      {\n+        if (sign1)\n+          ret1 = signed_char_type_node;\n+        else\n+          ret1 = unsigned_char_type_node;\n+      }\n+    else \n+      abort ();\n+  \n+  return ret1;    \n+}\n+\n+/* Garbage Collection.  */\n+\n+/* Callback to mark storage M as used always.  */\n+\n+void\n+tree_ggc_storage_always_used (void * m)\n+{\n+  void **mm; /* Actually M is a pointer to a pointer to the memory.  */\n+  mm = (void**)m;\n+\n+  if (*mm)\n+    ggc_mark (*mm);\n+} \n+\n+/* Following  from c-lang.c.  */\n+\n+/* Tell the c code we are not objective C.  */\n+\n+int\n+maybe_objc_comptypes (tree lhs ATTRIBUTE_UNUSED,\n+                      tree rhs ATTRIBUTE_UNUSED,\n+                      int reflexive ATTRIBUTE_UNUSED)\n+{\n+  return -1;\n+}\n+\n+/* Used by c-typeck.c (build_external_ref), but only for objc.  */\n+\n+tree\n+lookup_objc_ivar (tree id ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+/* Dummy routines called from c code. Save copying c-decl.c, c-common.c etc.  */\n+\n+void\n+check_function_format (int *status ATTRIBUTE_UNUSED,\n+                       tree attrs ATTRIBUTE_UNUSED,\n+                       tree params ATTRIBUTE_UNUSED)\n+{\n+  return;\n+}\n+\n+/* Tell the c code we are not objective C.  */\n+\n+tree\n+maybe_building_objc_message_expr ()\n+{\n+  return 0;\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+build_stmt VPARAMS ((enum tree_code code  ATTRIBUTE_UNUSED, ...))\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+add_stmt (tree t ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+build_return_stmt (tree expr ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* C warning, ignore.  */\n+\n+void\n+pedwarn_c99 VPARAMS ((const char *msgid ATTRIBUTE_UNUSED, ...))\n+{\n+  return;\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+build_case_label (tree low_value ATTRIBUTE_UNUSED,\n+                  tree high_value ATTRIBUTE_UNUSED,\n+                  tree label_decl ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+emit_local_var (tree decl ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+expand_stmt (tree t ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+cpp_reader *\n+cpp_create_reader (enum c_lang lang ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+cpp_post_options (cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+cpp_preprocess_file (cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+const char *\n+init_c_lex (const char *filename ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void init_pragma (void);\n+\n+void\n+init_pragma ()\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+cpp_finish (cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+unsigned int\n+cpp_errors (cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+handle_format_attribute (tree *node ATTRIBUTE_UNUSED,\n+                         tree name ATTRIBUTE_UNUSED,\n+                         tree args ATTRIBUTE_UNUSED,\n+                         int flags ATTRIBUTE_UNUSED,\n+                         bool *no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+handle_format_arg_attribute (tree *node ATTRIBUTE_UNUSED,\n+     tree name ATTRIBUTE_UNUSED,\n+     tree args ATTRIBUTE_UNUSED,\n+     int flags ATTRIBUTE_UNUSED,\n+     bool *no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+int\n+cpp_handle_option (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+     int argc ATTRIBUTE_UNUSED,\n+     char **argv ATTRIBUTE_UNUSED,\n+     int ignore ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+set_Wformat (int setting ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+maybe_objc_check_decl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+gen_aux_info_record (tree fndecl ATTRIBUTE_UNUSED,\n+                     int is_definition ATTRIBUTE_UNUSED,\n+                     int is_implicit ATTRIBUTE_UNUSED,\n+                     int is_prototyped ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang, but it is.   */\n+\n+void\n+c_parse_init ()\n+{\n+  return;\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void maybe_apply_pragma_weak (tree decl);\n+\n+void\n+maybe_apply_pragma_weak (tree decl ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+add_decl_stmt (tree decl ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+maybe_apply_renaming_pragma (tree decl, tree asmname);\n+\n+/* Should not be called for treelang.   */\n+\n+tree\n+maybe_apply_renaming_pragma (tree decl ATTRIBUTE_UNUSED, tree asmname ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+begin_stmt_tree (tree *t ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void\n+finish_stmt_tree (tree *t ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+int\n+defer_fn (tree fn ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+\n+/* Create the predefined scalar types of C,\n+   and some nodes representing standard constants (0, 1, (void *) 0).\n+   Initialize the global binding level.\n+   Make definitions for built-in primitive functions.  */\n+\n+  /* `unsigned long' is the standard type for sizeof.\n+     Note that stddef.h uses `unsigned long',\n+     and this must agree, even if long and int are the same size.  */\n+\n+/* This variable keeps a table for types for each precision so that we\n+   only allocate each of them once.  Signed and unsigned types are\n+   kept separate.  */\n+\n+tree integer_types[itk_none] = { NULL_TREE};\n+\n+/* The reserved keyword table.  */\n+struct resword\n+{\n+  const char *word;\n+  ENUM_BITFIELD(rid) rid : 16;\n+  unsigned int disable   : 16;\n+};\n+\n+static const struct resword reswords[] =\n+{\n+  { \"_Bool\",\t\tRID_BOOL,\t0 },\n+  { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n+  { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n+  { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n+  { \"__alignof\",\tRID_ALIGNOF,\t0 },\n+  { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n+  { \"__asm\",\t\tRID_ASM,\t0 },\n+  { \"__asm__\",\t\tRID_ASM,\t0 },\n+  { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n+  { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n+  { \"__bounded\",\tRID_BOUNDED,\t0 },\n+  { \"__bounded__\",\tRID_BOUNDED,\t0 },\n+  { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, 0 },\n+  { \"__builtin_types_compatible_p\", RID_TYPES_COMPATIBLE_P, 0 },\n+  { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },\n+  { \"__complex\",\tRID_COMPLEX,\t0 },\n+  { \"__complex__\",\tRID_COMPLEX,\t0 },\n+  { \"__const\",\t\tRID_CONST,\t0 },\n+  { \"__const__\",\tRID_CONST,\t0 },\n+  { \"__extension__\",\tRID_EXTENSION,\t0 },\n+  { \"__func__\",\t\tRID_C99_FUNCTION_NAME, 0 },\n+  { \"__imag\",\t\tRID_IMAGPART,\t0 },\n+  { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n+  { \"__inline\",\t\tRID_INLINE,\t0 },\n+  { \"__inline__\",\tRID_INLINE,\t0 },\n+  { \"__label__\",\tRID_LABEL,\t0 },\n+  { \"__ptrbase\",\tRID_PTRBASE,\t0 },\n+  { \"__ptrbase__\",\tRID_PTRBASE,\t0 },\n+  { \"__ptrextent\",\tRID_PTREXTENT,\t0 },\n+  { \"__ptrextent__\",\tRID_PTREXTENT,\t0 },\n+  { \"__ptrvalue\",\tRID_PTRVALUE,\t0 },\n+  { \"__ptrvalue__\",\tRID_PTRVALUE,\t0 },\n+  { \"__real\",\t\tRID_REALPART,\t0 },\n+  { \"__real__\",\t\tRID_REALPART,\t0 },\n+  { \"__restrict\",\tRID_RESTRICT,\t0 },\n+  { \"__restrict__\",\tRID_RESTRICT,\t0 },\n+  { \"__signed\",\t\tRID_SIGNED,\t0 },\n+  { \"__signed__\",\tRID_SIGNED,\t0 },\n+  { \"__typeof\",\t\tRID_TYPEOF,\t0 },\n+  { \"__typeof__\",\tRID_TYPEOF,\t0 },\n+  { \"__unbounded\",\tRID_UNBOUNDED,\t0 },\n+  { \"__unbounded__\",\tRID_UNBOUNDED,\t0 },\n+  { \"__volatile\",\tRID_VOLATILE,\t0 },\n+  { \"__volatile__\",\tRID_VOLATILE,\t0 },\n+  { \"asm\",\t\tRID_ASM,\t0 },\n+  { \"auto\",\t\tRID_AUTO,\t0 },\n+  { \"break\",\t\tRID_BREAK,\t0 },\n+  { \"case\",\t\tRID_CASE,\t0 },\n+  { \"char\",\t\tRID_CHAR,\t0 },\n+  { \"const\",\t\tRID_CONST,\t0 },\n+  { \"continue\",\t\tRID_CONTINUE,\t0 },\n+  { \"default\",\t\tRID_DEFAULT,\t0 },\n+  { \"do\",\t\tRID_DO,\t\t0 },\n+  { \"double\",\t\tRID_DOUBLE,\t0 },\n+  { \"else\",\t\tRID_ELSE,\t0 },\n+  { \"enum\",\t\tRID_ENUM,\t0 },\n+  { \"extern\",\t\tRID_EXTERN,\t0 },\n+  { \"float\",\t\tRID_FLOAT,\t0 },\n+  { \"for\",\t\tRID_FOR,\t0 },\n+  { \"goto\",\t\tRID_GOTO,\t0 },\n+  { \"if\",\t\tRID_IF,\t\t0 },\n+  { \"inline\",\t\tRID_INLINE,\t0 },\n+  { \"int\",\t\tRID_INT,\t0 },\n+  { \"long\",\t\tRID_LONG,\t0 },\n+  { \"register\",\t\tRID_REGISTER,\t0 },\n+  { \"restrict\",\t\tRID_RESTRICT,\t0 },\n+  { \"return\",\t\tRID_RETURN,\t0 },\n+  { \"short\",\t\tRID_SHORT,\t0 },\n+  { \"signed\",\t\tRID_SIGNED,\t0 },\n+  { \"sizeof\",\t\tRID_SIZEOF,\t0 },\n+  { \"static\",\t\tRID_STATIC,\t0 },\n+  { \"struct\",\t\tRID_STRUCT,\t0 },\n+  { \"switch\",\t\tRID_SWITCH,\t0 },\n+  { \"typedef\",\t\tRID_TYPEDEF,\t0 },\n+  { \"typeof\",\t\tRID_TYPEOF,\t0 },\n+  { \"union\",\t\tRID_UNION,\t0 },\n+  { \"unsigned\",\t\tRID_UNSIGNED,\t0 },\n+  { \"void\",\t\tRID_VOID,\t0 },\n+  { \"volatile\",\t\tRID_VOLATILE,\t0 },\n+  { \"while\",\t\tRID_WHILE,\t0 },\n+};\n+#define N_reswords (sizeof reswords / sizeof (struct resword))\n+\n+/* Init enough to allow the C decl code to work, then clean up\n+   afterwards.  */\n+\n+void\n+treelang_init_decl_processing ()\n+{\n+  unsigned int i;\n+  tree id;\n+\n+  /* It is not necessary to register ridpointers as a GC root, because\n+     all the trees it points to are permanently interned in the\n+     get_identifier hash anyway.  */\n+  ridpointers = (tree *) xcalloc ((int) RID_MAX, sizeof (tree));\n+  \n+  for (i = 0; i < N_reswords; i++)\n+    {\n+      id = get_identifier (reswords[i].word);\n+      C_RID_CODE (id) = reswords[i].rid;\n+      C_IS_RESERVED_WORD (id) = 1;\n+      ridpointers [(int) reswords[i].rid] = id;\n+    }\n+\n+  c_init_decl_processing ();\n+\n+  /* ix86_return_pops_args takes the type of these so need to patch\n+     their own type as themselves.  */\n+\n+  for (i = 0; i < itk_none; i++)\n+    {\n+      if (integer_types[i])\n+        TREE_TYPE (integer_types [i]) = integer_types[i];\n+    }\n+\n+  /* Probably these ones too.  */\n+  TREE_TYPE (float_type_node) = float_type_node;\n+  TREE_TYPE (double_type_node) = double_type_node;\n+  TREE_TYPE (long_double_type_node) = long_double_type_node;\n+\n+}\n+\n+/* Save typing debug_tree all the time. Dump a tree T pretty and\n+   concise.  */\n+\n+void dt (tree t);\n+\n+void\n+dt (tree t)\n+{\n+  debug_tree (t);\n+}"}, {"sha": "24b72e385fc77a5a190619d8c229197dc71418b0", "filename": "gcc/treelang/treetree.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreetree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfea11bd14394d177d61efd1f1cc908ce5534b2/gcc%2Ftreelang%2Ftreetree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.h?ref=6cfea11bd14394d177d61efd1f1cc908ce5534b2", "patch": "@@ -0,0 +1,101 @@\n+/* \n+\n+    TREELANG Compiler definitions for interfacing to treetree.c\n+    (compiler back end interface).\n+\n+    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+    This program is free software; you can redistribute it and/or modify it\n+    under the terms of the GNU General Public License as published by the\n+    Free Software Foundation; either version 2, or (at your option) any\n+    later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License\n+    along with this program; if not, write to the Free Software\n+    Foundation, 59 Temple Place - Suite 330,\n+    Boston, MA 02111-1307, USA.\n+\n+    In other words, you are welcome to use, share and improve this program.\n+    You are forbidden to forbid anyone else to use, share and improve\n+    what you give them.   Help stamp out software-hoarding!  \n+\n+    ---------------------------------------------------------------------------\n+\n+    Written by Tim Josling 1999, 2000, 2001, based in part on other\n+    parts of the GCC compiler.\n+\n+ */\n+\n+/* Parameter list passed to back end.  */\n+struct tree_parameter_list \n+{\n+  struct tree_parameter_list* next; /* Next entry.  */\n+  int   type; /* See numeric types below.  */\n+  unsigned char* variable_name; /* Name. */\n+  tree* where_to_put_var_tree; /* Where to save decl.  */\n+};\n+\n+tree tree_code_init_parameters (void);\n+tree tree_code_add_parameter (tree list, tree proto_exp, tree exp);\n+tree tree_code_get_integer_value (unsigned char *chars, unsigned int length);\n+void tree_code_generate_return (tree type, tree exp);\n+void tree_ggc_storage_always_used  (void *m);\n+tree tree_code_get_expression (unsigned int exp_type, tree type, tree op1, tree op2, tree op3);\n+tree tree_code_get_numeric_type (unsigned int size1, unsigned int sign1);\n+void tree_code_create_function_initial (tree prev_saved,\n+                                       unsigned char* filename, int lineno,\n+                                       struct tree_parameter_list* parms);\n+void tree_code_create_function_wrapup (unsigned char* filename, int lineno);\n+tree tree_code_create_function_prototype (unsigned char* chars,\n+                                         unsigned int storage_class,\n+                                         unsigned int ret_type,\n+                                         struct tree_parameter_list* parms,                                 \n+                                         unsigned char* filename,\n+                                         int lineno);\n+tree tree_code_create_variable (unsigned int storage_class,\n+                               unsigned char* chars,\n+                               unsigned int length,\n+                               unsigned int expression_type,\n+                               tree init,\n+                               unsigned char* filename,\n+                               int lineno);\n+void tree_code_output_expression_statement (tree code, unsigned char* filename, int lineno);\n+tree get_type_for_numeric_type (unsigned int numeric_type);\n+void tree_code_if_start (tree exp, unsigned char* filename, int lineno);\n+void tree_code_if_else (unsigned char* filename, int lineno);\n+void tree_code_if_end (unsigned char* filename, int lineno);\n+tree tree_code_get_type (int type_num);\n+void treelang_init_decl_processing (void);\n+void treelang_finish (void);\n+const char * treelang_init (const char* filename);\n+int treelang_decode_option (int, char **);\n+void treelang_parse_file (int debug_flag);\n+void push_var_level (void);\n+void pop_var_level (void);\n+\n+/* Storage modes.  */\n+#define STATIC_STORAGE 0\n+#define AUTOMATIC_STORAGE 1\n+#define EXTERNAL_REFERENCE_STORAGE 2\n+#define EXTERNAL_DEFINITION_STORAGE 3\n+\n+\n+/* Numeric types.  */\n+#define SIGNED_CHAR 1\n+#define UNSIGNED_CHAR 2\n+#define SIGNED_INT 3 \n+#define UNSIGNED_INT 4\n+#define VOID_TYPE 5\n+\n+\n+#define EXP_PLUS 0 /* Addition expression.  */\n+#define EXP_REFERENCE 1 /* Variable reference.  */\n+#define EXP_ASSIGN 2 /* Assignment.  */\n+#define EXP_FUNCTION_INVOCATION 3  /* Call function.  */\n+#define EXP_MINUS 4  /* Subtraction.  */\n+#define EXP_EQUALS 5  /* Equality test.  */"}]}