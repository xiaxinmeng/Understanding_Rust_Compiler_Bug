{"sha": "fc193526f31a0ea8746348e0ee67aa37c6e7a9c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxOTM1MjZmMzFhMGVhODc0NjM0OGUwZWU2N2FhMzdjNmU3YTljNw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-08-01T13:56:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T13:56:13Z"}, "message": "sem_ch8.adb (Analyze_Subprogram_Renaming): Alphabetize globals and move certain variables to the \"local variable\" section.\n\n2014-08-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Alphabetize\n\tglobals and move certain variables to the \"local\n\tvariable\" section. Call Build_Class_Wide_Wrapper when\n\trenaming a default actual subprogram with a class-wide actual.\n\t(Build_Class_Wide_Wrapper): New routine.\n\t(Check_Class_Wide_Actual): Removed.\n\t(Find_Renamed_Entity): Code reformatting.\n\t(Has_Class_Wide_Actual): Alphabetize. Change the\n\tlogic of the predicate as the renamed name may not necessarely\n\tdenote the correct subprogram.\n\nFrom-SVN: r213467", "tree": {"sha": "ea7345c1bd9f32e3164b90482ed6172c57216f76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea7345c1bd9f32e3164b90482ed6172c57216f76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4887624ec89edfe47471a467732b9c85537b3ff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4887624ec89edfe47471a467732b9c85537b3ff5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4887624ec89edfe47471a467732b9c85537b3ff5"}], "stats": {"total": 627, "additions": 447, "deletions": 180}, "files": [{"sha": "6461c13dd457c9195db192038b05a4f73ec86948", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc193526f31a0ea8746348e0ee67aa37c6e7a9c7", "patch": "@@ -1,3 +1,16 @@\n+2014-08-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Alphabetize\n+\tglobals and move certain variables to the \"local\n+\tvariable\" section. Call Build_Class_Wide_Wrapper when\n+\trenaming a default actual subprogram with a class-wide actual.\n+\t(Build_Class_Wide_Wrapper): New routine.\n+\t(Check_Class_Wide_Actual): Removed.\n+\t(Find_Renamed_Entity): Code reformatting.\n+\t(Has_Class_Wide_Actual): Alphabetize. Change the\n+\tlogic of the predicate as the renamed name may not necessarely\n+\tdenote the correct subprogram.\n+\n 2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_ch7.adb: Fix minor oversight in condition."}, {"sha": "01055d2265a57158ed8b65bbb01ad9eda9ac8d52", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 434, "deletions": 180, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc193526f31a0ea8746348e0ee67aa37c6e7a9c7/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=fc193526f31a0ea8746348e0ee67aa37c6e7a9c7", "patch": "@@ -1812,18 +1812,51 @@ package body Sem_Ch8 is\n    ---------------------------------\n \n    procedure Analyze_Subprogram_Renaming (N : Node_Id) is\n-      Formal_Spec : constant Node_Id := Corresponding_Formal_Spec (N);\n-      Is_Actual   : constant Boolean := Present (Formal_Spec);\n-      Inst_Node   : Node_Id                   := Empty;\n+      Formal_Spec : constant Entity_Id        := Corresponding_Formal_Spec (N);\n+      Is_Actual   : constant Boolean          := Present (Formal_Spec);\n       Nam         : constant Node_Id          := Name (N);\n-      New_S       : Entity_Id;\n-      Old_S       : Entity_Id                 := Empty;\n-      Rename_Spec : Entity_Id;\n       Save_AV     : constant Ada_Version_Type := Ada_Version;\n       Save_AVP    : constant Node_Id          := Ada_Version_Pragma;\n       Save_AV_Exp : constant Ada_Version_Type := Ada_Version_Explicit;\n       Spec        : constant Node_Id          := Specification (N);\n \n+      Old_S       : Entity_Id := Empty;\n+      Rename_Spec : Entity_Id;\n+\n+      procedure Build_Class_Wide_Wrapper\n+        (Ren_Id  : out Entity_Id;\n+         Wrap_Id : out Entity_Id);\n+      --  Ada 2012 (AI05-0071): A generic/instance scenario involving a formal\n+      --  type with unknown discriminants and a generic primitive operation of\n+      --  the said type with a box require special processing when the actual\n+      --  is a class-wide type:\n+\n+      --    generic\n+      --       type Formal_Typ (<>) is private;\n+      --       with procedure Prim_Op (Param : Formal_Typ) is <>;\n+      --    package Gen is ...\n+\n+      --    package Inst is new Gen (Actual_Typ'Class);\n+\n+      --  In this case the general renaming mechanism used in the prologue of\n+      --  an instance no longer applies:\n+\n+      --    procedure Prim_Op (Param : Formal_Typ) renames Prim_Op;\n+\n+      --  The above is replaced the following wrapper/renaming combination:\n+\n+      --    procedure Prim_Op (Param : Formal_Typ) is  --  wrapper\n+      --    begin\n+      --       Prim_Op (Param);                        --  primitive\n+      --    end Wrapper;\n+\n+      --    procedure Dummy (Param : Formal_Typ) renames Prim_Op;\n+\n+      --  This transformation applies only if there is no explicit visible\n+      --  class-wide operation at the point of the instantiation. Ren_Id is\n+      --  the entity of the renaming declaration. Wrap_Id is the entity of\n+      --  the generated class-wide wrapper (or Any_Id).\n+\n       procedure Check_Null_Exclusion\n         (Ren : Entity_Id;\n          Sub : Entity_Id);\n@@ -1845,194 +1878,417 @@ package body Sem_Ch8 is\n       --  types: a callable entity freezes its profile, unless it has an\n       --  incomplete untagged formal (RM 13.14(10.2/3)).\n \n+      function Has_Class_Wide_Actual return Boolean;\n+      --  Ada 2012 (AI05-071, AI05-0131): True if N is the renaming for a\n+      --  defaulted formal subprogram where the actual for the controlling\n+      --  formal type is class-wide.\n+\n       function Original_Subprogram (Subp : Entity_Id) return Entity_Id;\n       --  Find renamed entity when the declaration is a renaming_as_body and\n       --  the renamed entity may itself be a renaming_as_body. Used to enforce\n       --  rule that a renaming_as_body is illegal if the declaration occurs\n       --  before the subprogram it completes is frozen, and renaming indirectly\n       --  renames the subprogram itself.(Defect Report 8652/0027).\n \n-      function Check_Class_Wide_Actual return Entity_Id;\n-      --  AI05-0071: In an instance, if the actual for a formal type FT with\n-      --  unknown discriminants is a class-wide type CT, and the generic has\n-      --  a formal subprogram with a box for a primitive operation of FT,\n-      --  then the corresponding actual subprogram denoted by the default is a\n-      --  class-wide operation whose body is a dispatching call. We replace the\n-      --  generated renaming declaration:\n-      --\n-      --    procedure P (X : CT) renames P;\n-      --\n-      --  by a different renaming and a class-wide operation:\n-      --\n-      --    procedure Pr (X : T) renames P;   --  renames primitive operation\n-      --    procedure P (X : CT);             --  class-wide operation\n-      --    ...\n-      --    procedure P (X : CT) is begin Pr (X); end;  -- dispatching call\n-      --\n-      --  This rule only applies if there is no explicit visible class-wide\n-      --  operation at the point of the instantiation.\n-\n-      function Has_Class_Wide_Actual return Boolean;\n-      --  Ada 2012 (AI05-071, AI05-0131): True if N is the renaming for a\n-      --  defaulted formal subprogram when the actual for the controlling\n-      --  formal type is class-wide.\n-\n-      -----------------------------\n-      -- Check_Class_Wide_Actual --\n-      -----------------------------\n+      ------------------------------\n+      -- Build_Class_Wide_Wrapper --\n+      ------------------------------\n \n-      function Check_Class_Wide_Actual return Entity_Id is\n+      procedure Build_Class_Wide_Wrapper\n+        (Ren_Id  : out Entity_Id;\n+         Wrap_Id : out Entity_Id)\n+      is\n          Loc : constant Source_Ptr := Sloc (N);\n \n-         F           : Entity_Id;\n-         Formal_Type : Entity_Id;\n-         Actual_Type : Entity_Id;\n-         New_Body    : Node_Id;\n-         New_Decl    : Node_Id;\n-         Result      : Entity_Id;\n+         function Build_Call\n+           (Subp_Id : Entity_Id;\n+            Params  : List_Id) return Node_Id;\n+         --  Create a dispatching call to invoke routine Subp_Id with actuals\n+         --  built from the parameter specifications of list Params.\n \n-         function Make_Call (Prim_Op : Entity_Id) return Node_Id;\n-         --  Build dispatching call for body of class-wide operation\n+         function Build_Spec (Subp_Id : Entity_Id) return Node_Id;\n+         --  Create a subprogram specification based on the subprogram profile\n+         --  of Subp_Id.\n \n-         function Make_Spec return Node_Id;\n-         --  Create subprogram specification for declaration and body of\n-         --  class-wide operation, using signature of renaming declaration.\n+         function Find_Primitive (Typ : Entity_Id) return Entity_Id;\n+         --  Find a primitive subprogram of type Typ which matches the profile\n+         --  of the renaming declaration.\n \n-         ---------------\n-         -- Make_Call --\n-         ---------------\n+         procedure Interpretation_Error (Subp_Id : Entity_Id);\n+         --  Emit a continuation error message suggesting subprogram Subp_Id as\n+         --  a possible interpretation.\n \n-         function Make_Call (Prim_Op : Entity_Id) return Node_Id is\n-            Actuals : List_Id;\n-            F       : Node_Id;\n+         ----------------\n+         -- Build_Call --\n+         ----------------\n+\n+         function Build_Call\n+           (Subp_Id : Entity_Id;\n+            Params  : List_Id) return Node_Id\n+         is\n+            Actuals  : constant List_Id := New_List;\n+            Call_Ref : constant Node_Id := New_Occurrence_Of (Subp_Id, Loc);\n+            Formal   : Node_Id;\n \n          begin\n-            Actuals := New_List;\n-            F := First (Parameter_Specifications (Specification (New_Decl)));\n-            while Present (F) loop\n+            --  Build the actual parameters of the call\n+\n+            Formal := First (Params);\n+            while Present (Formal) loop\n                Append_To (Actuals,\n-                 Make_Identifier (Loc, Chars (Defining_Identifier (F))));\n-               Next (F);\n+                 Make_Identifier (Loc, Chars (Defining_Identifier (Formal))));\n+\n+               Next (Formal);\n             end loop;\n \n-            if Ekind_In (Prim_Op, E_Function, E_Operator) then\n-               return Make_Simple_Return_Statement (Loc,\n-                  Expression =>\n-                    Make_Function_Call (Loc,\n-                      Name => New_Occurrence_Of (Prim_Op, Loc),\n-                      Parameter_Associations => Actuals));\n+            --  Generate:\n+            --    return Subp_Id (Actuals);\n+\n+            if Ekind_In (Subp_Id, E_Function, E_Operator) then\n+               return\n+                 Make_Simple_Return_Statement (Loc,\n+                   Expression =>\n+                     Make_Function_Call (Loc,\n+                       Name                   => Call_Ref,\n+                       Parameter_Associations => Actuals));\n+\n+            --  Generate:\n+            --    Subp_Id (Actuals);\n+\n             else\n                return\n                  Make_Procedure_Call_Statement (Loc,\n-                      Name => New_Occurrence_Of (Prim_Op, Loc),\n-                      Parameter_Associations => Actuals);\n+                   Name                   => Call_Ref,\n+                   Parameter_Associations => Actuals);\n             end if;\n-         end Make_Call;\n+         end Build_Call;\n \n-         ---------------\n-         -- Make_Spec --\n-         ---------------\n+         ----------------\n+         -- Build_Spec --\n+         ----------------\n \n-         function Make_Spec return Node_Id is\n-            Param_Specs : constant List_Id := Copy_Parameter_List (New_S);\n+         function Build_Spec (Subp_Id : Entity_Id) return Node_Id is\n+            Params  : constant List_Id   := Copy_Parameter_List (Subp_Id);\n+            Spec_Id : constant Entity_Id :=\n+                        Make_Defining_Identifier (Loc, Chars (Subp_Id));\n \n          begin\n-            if Ekind (New_S) = E_Procedure then\n+            if Ekind (Formal_Spec) = E_Procedure then\n                return\n                  Make_Procedure_Specification (Loc,\n-                   Defining_Unit_Name =>\n-                     Make_Defining_Identifier (Loc,\n-                       Chars (Defining_Unit_Name (Spec))),\n-                   Parameter_Specifications => Param_Specs);\n+                   Defining_Unit_Name       => Spec_Id,\n+                   Parameter_Specifications => Params);\n             else\n                return\n-                  Make_Function_Specification (Loc,\n-                    Defining_Unit_Name =>\n-                      Make_Defining_Identifier (Loc,\n-                        Chars (Defining_Unit_Name (Spec))),\n-                    Parameter_Specifications => Param_Specs,\n-                    Result_Definition =>\n-                      New_Copy_Tree (Result_Definition (Spec)));\n+                 Make_Function_Specification (Loc,\n+                   Defining_Unit_Name       => Spec_Id,\n+                   Parameter_Specifications => Params,\n+                   Result_Definition =>\n+                     New_Copy_Tree (Result_Definition (Spec)));\n+            end if;\n+         end Build_Spec;\n+\n+         --------------------\n+         -- Find_Primitive --\n+         --------------------\n+\n+         function Find_Primitive (Typ : Entity_Id) return Entity_Id is\n+            procedure Replace_Parameter_Types (Spec : Node_Id);\n+            --  Given a specification Spec, replace all class-wide parameter\n+            --  types with reference to type Typ.\n+\n+            -----------------------------\n+            -- Replace_Parameter_Types --\n+            -----------------------------\n+\n+            procedure Replace_Parameter_Types (Spec : Node_Id) is\n+               Formal     : Node_Id;\n+               Formal_Id  : Entity_Id;\n+               Formal_Typ : Node_Id;\n+\n+            begin\n+               Formal := First (Parameter_Specifications (Spec));\n+               while Present (Formal) loop\n+                  Formal_Id  := Defining_Identifier (Formal);\n+                  Formal_Typ := Parameter_Type (Formal);\n+\n+                  --  Create a new entity for each class-wide formal to prevent\n+                  --  aliasing with the original renaming. Replace the type of\n+                  --  such a parameter with the candidate type.\n+\n+                  if Nkind (Formal_Typ) = N_Identifier\n+                    and then Is_Class_Wide_Type (Etype (Formal_Typ))\n+                  then\n+                     Set_Defining_Identifier (Formal,\n+                       Make_Defining_Identifier (Loc, Chars (Formal_Id)));\n+\n+                     Set_Parameter_Type (Formal, New_Occurrence_Of (Typ, Loc));\n+                  end if;\n+\n+                  Next (Formal);\n+               end loop;\n+            end Replace_Parameter_Types;\n+\n+            --  Local variables\n+\n+            Alt_Ren  : constant Node_Id := New_Copy_Tree (N);\n+            Alt_Nam  : constant Node_Id := Name (Alt_Ren);\n+            Alt_Spec : constant Node_Id := Specification (Alt_Ren);\n+            Subp_Id  : Entity_Id;\n+\n+         --  Start of processing for Find_Primitive\n+\n+         begin\n+            --  Each attempt to find a suitable primitive of a particular type\n+            --  operates on its own copy of the original renaming. As a result\n+            --  the original renaming is kept decoration and side-effect free.\n+\n+            --  Inherit the overloaded status of the renamed subprogram name\n+\n+            if Is_Overloaded (Nam) then\n+               Set_Is_Overloaded (Alt_Nam);\n+               Save_Interps (Nam, Alt_Nam);\n             end if;\n-         end Make_Spec;\n \n-      --  Start of processing for Check_Class_Wide_Actual\n+            --  The copied renaming is hidden from visibility to prevent the\n+            --  pollution of the enclosing context.\n+\n+            Set_Defining_Unit_Name (Alt_Spec, Make_Temporary (Loc, 'R'));\n+\n+            --  The types of all class-wide parameters must be changed to the\n+            --  candidate type.\n+\n+            Replace_Parameter_Types (Alt_Spec);\n+\n+            --  Try to find a suitable primitive which matches the altered\n+            --  profile of the renaming specification.\n+\n+            Subp_Id :=\n+              Find_Renamed_Entity\n+                (N         => Alt_Ren,\n+                 Nam       => Name (Alt_Ren),\n+                 New_S     => Analyze_Subprogram_Specification (Alt_Spec),\n+                 Is_Actual => Is_Actual);\n+\n+            --  Do not return Any_Id if the resolion of the altered profile\n+            --  failed as this complicates further checks on the caller side,\n+            --  return Empty instead.\n+\n+            if Subp_Id = Any_Id then\n+               return Empty;\n+            else\n+               return Subp_Id;\n+            end if;\n+         end Find_Primitive;\n+\n+         --------------------------\n+         -- Interpretation_Error --\n+         --------------------------\n+\n+         procedure Interpretation_Error (Subp_Id : Entity_Id) is\n+         begin\n+            Error_Msg_Sloc := Sloc (Subp_Id);\n+            Error_Msg_NE\n+              (\"\\\\possible interpretation: & defined #\", Spec, Formal_Spec);\n+         end Interpretation_Error;\n+\n+         --  Local variables\n+\n+         Actual_Typ : Entity_Id := Empty;\n+         --  The actual class-wide type for Formal_Typ\n+\n+         CW_Prim_Op : Entity_Id;\n+         --  The class-wide primitive (if any) which corresponds to the renamed\n+         --  generic formal subprogram.\n+\n+         Formal_Typ : Entity_Id := Empty;\n+         --  The generic formal type (if any) with unknown discriminants\n+\n+         Root_Prim_Op : Entity_Id;\n+         --  The root type primitive (if any) which corresponds to the renamed\n+         --  generic formal subprogram.\n+\n+         Body_Decl : Node_Id;\n+         Formal    : Node_Id;\n+         Prim_Op   : Entity_Id;\n+         Spec_Decl : Node_Id;\n+\n+      --  Start of processing for Build_Class_Wide_Wrapper\n \n       begin\n-         Result := Any_Id;\n-         Formal_Type := Empty;\n-         Actual_Type := Empty;\n-\n-         F := First_Formal (Formal_Spec);\n-         while Present (F) loop\n-            if Has_Unknown_Discriminants (Etype (F))\n-              and then not Is_Class_Wide_Type (Etype (F))\n-              and then Is_Class_Wide_Type (Get_Instance_Of (Etype (F)))\n+         --  Analyze the specification of the renaming in case the generation\n+         --  of the class-wide wrapper fails.\n+\n+         Ren_Id  := Analyze_Subprogram_Specification (Spec);\n+         Wrap_Id := Any_Id;\n+\n+         --  Do not attempt to build a wrapper if the renaming is in error\n+\n+         if Error_Posted (Nam) then\n+            return;\n+         end if;\n+\n+         --  Analyze the renamed name, but do not resolve it. The resolution is\n+         --  completed once a suitable primitive is found.\n+\n+         Analyze (Nam);\n+\n+         --  Step 1: Find the generic formal type with unknown discriminants\n+         --  and its corresponding class-wide actual type from the renamed\n+         --  generic formal subprogram.\n+\n+         Formal := First_Formal (Formal_Spec);\n+         while Present (Formal) loop\n+            if Has_Unknown_Discriminants (Etype (Formal))\n+              and then not Is_Class_Wide_Type (Etype (Formal))\n+              and then Is_Class_Wide_Type (Get_Instance_Of (Etype (Formal)))\n             then\n-               Formal_Type := Etype (F);\n-               Actual_Type := Etype (Get_Instance_Of (Formal_Type));\n+               Formal_Typ := Etype (Formal);\n+               Actual_Typ := Get_Instance_Of (Formal_Typ);\n                exit;\n             end if;\n \n-            Next_Formal (F);\n+            Next_Formal (Formal);\n          end loop;\n \n-         if Present (Formal_Type) then\n+         --  The specification of the generic formal subprogram should always\n+         --  contain a formal type with unknown discriminants whose actual is\n+         --  a class-wide type, otherwise this indicates a failure in routine\n+         --  Has_Class_Wide_Actual.\n \n-            --  Create declaration and body for class-wide operation\n+         pragma Assert (Present (Formal_Typ));\n \n-            New_Decl :=\n-              Make_Subprogram_Declaration (Loc, Specification => Make_Spec);\n+         --  Step 2: Find the proper primitive which corresponds to the renamed\n+         --  generic formal subprogram.\n \n-            New_Body :=\n-              Make_Subprogram_Body (Loc,\n-                Specification => Make_Spec,\n-                Declarations => No_List,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc, New_List));\n+         CW_Prim_Op   := Find_Primitive (Actual_Typ);\n+         Root_Prim_Op := Find_Primitive (Etype (Actual_Typ));\n \n-            --  Modify Spec and create internal name for renaming of primitive\n-            --  operation.\n+         --  The class-wide actual type has two primitives which correspond to\n+         --  the renamed generic formal subprogram:\n \n-            Set_Defining_Unit_Name (Spec, Make_Temporary (Loc, 'R'));\n-            F := First (Parameter_Specifications (Spec));\n-            while Present (F) loop\n-               if Nkind (Parameter_Type (F)) = N_Identifier\n-                 and then Is_Class_Wide_Type (Entity (Parameter_Type (F)))\n+         --    with procedure Prim_Op (Param : Formal_Typ);\n+\n+         --    procedure Prim_Op (Param : Actual_Typ);  --  may be inherited\n+         --    procedure Prim_Op (Param : Actual_Typ'Class);\n+\n+         --  Even though the declaration of the two primitives is legal, a call\n+         --  to either one is ambiguous and therefore illegal.\n+\n+         if Present (CW_Prim_Op) and then Present (Root_Prim_Op) then\n+\n+            --  Deal with abstract primitives\n+\n+            if Is_Abstract_Subprogram (CW_Prim_Op)\n+              or else Is_Abstract_Subprogram (Root_Prim_Op)\n+            then\n+               --  An abstract subprogram cannot act as a generic actual, but\n+               --  the partial parameterization of the instance may hide the\n+               --  true nature of the actual. Emit an error when both options\n+               --  are abstract.\n+\n+               if Is_Abstract_Subprogram (CW_Prim_Op)\n+                 and then Is_Abstract_Subprogram (Root_Prim_Op)\n                then\n-                  Set_Parameter_Type (F, New_Occurrence_Of (Actual_Type, Loc));\n+                  Error_Msg_NE\n+                    (\"abstract subprogram not allowed as generic actual\",\n+                     Spec, Formal_Spec);\n+                  Interpretation_Error (CW_Prim_Op);\n+                  Interpretation_Error (Root_Prim_Op);\n+                  return;\n+\n+               --  Otherwise choose the non-abstract version\n+\n+               elsif Is_Abstract_Subprogram (Root_Prim_Op) then\n+                  Prim_Op := CW_Prim_Op;\n+\n+               else pragma Assert (Is_Abstract_Subprogram (CW_Prim_Op));\n+                  Prim_Op := Root_Prim_Op;\n                end if;\n-               Next (F);\n-            end loop;\n \n-            New_S := Analyze_Subprogram_Specification (Spec);\n-            Result := Find_Renamed_Entity (N, Name (N), New_S, Is_Actual);\n-         end if;\n+            --  If one of the candidate primitives is intrinsic, choose the\n+            --  other (which may also be intrinsic). Preference is given to\n+            --  the primitive of the root type.\n \n-         if Result /= Any_Id then\n-            Insert_Before (N, New_Decl);\n-            Analyze (New_Decl);\n+            elsif Is_Intrinsic_Subprogram (CW_Prim_Op) then\n+               Prim_Op := Root_Prim_Op;\n \n-            --  Add dispatching call to body of class-wide operation\n+            elsif Is_Intrinsic_Subprogram (Root_Prim_Op) then\n+               Prim_Op := CW_Prim_Op;\n \n-            Append (Make_Call (Result),\n-              Statements (Handled_Statement_Sequence (New_Body)));\n+            elsif CW_Prim_Op = Root_Prim_Op then\n+               Prim_Op := Root_Prim_Op;\n \n-            --  The generated body does not freeze. It is analyzed when the\n-            --  generated operation is frozen. This body is only needed if\n-            --  expansion is enabled.\n+            --  Otherwise there are two perfectly good candidates which satisfy\n+            --  the profile of the renamed generic formal subprogram.\n \n-            if Expander_Active then\n-               Append_Freeze_Action (Defining_Entity (New_Decl), New_Body);\n+            else\n+               Error_Msg_NE\n+                 (\"ambiguous actual for generic subprogram &\",\n+                   Spec, Formal_Spec);\n+               Interpretation_Error (CW_Prim_Op);\n+               Interpretation_Error (Root_Prim_Op);\n+               return;\n             end if;\n \n-            Result := Defining_Entity (New_Decl);\n+         elsif Present (CW_Prim_Op) then\n+            Prim_Op := CW_Prim_Op;\n+\n+         elsif Present (Root_Prim_Op) then\n+            Prim_Op := Root_Prim_Op;\n+\n+         --  Otherwise there are no candidate primitives. Let the caller\n+         --  diagnose the error.\n+\n+         else\n+            return;\n          end if;\n \n-         --  Return the class-wide operation if one was created\n+         --  Set the proper entity of the renamed generic formal subprogram\n+         --  and reset its overloaded status now that resolution has finally\n+         --  taken place.\n+\n+         Set_Entity        (Nam, Prim_Op);\n+         Set_Is_Overloaded (Nam, False);\n+\n+         --  Step 3: Create the declaration and the body of the wrapper, insert\n+         --  all the pieces into the tree.\n \n-         return Result;\n-      end Check_Class_Wide_Actual;\n+         Spec_Decl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Build_Spec (Ren_Id));\n+\n+         Body_Decl :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Build_Spec (Ren_Id),\n+             Declarations               => New_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Build_Call\n+                     (Subp_Id => Prim_Op,\n+                      Params  =>\n+                        Parameter_Specifications\n+                          (Specification (Spec_Decl))))));\n+\n+         Insert_Before_And_Analyze (N, Spec_Decl);\n+         Wrap_Id := Defining_Entity (Spec_Decl);\n+\n+         --  The generated body does not freeze and must be analyzed when the\n+         --  class-wide wrapper is frozen. The body is only needed if expansion\n+         --  is enabled.\n+\n+         if Expander_Active then\n+            Append_Freeze_Action (Wrap_Id, Body_Decl);\n+         end if;\n+\n+         --  Step 4: Once the proper actual type and primitive operation are\n+         --  known, hide the renaming declaration from visibility by giving it\n+         --  a dummy name.\n+\n+         Set_Defining_Unit_Name (Spec, Make_Temporary (Loc, 'R'));\n+         Ren_Id := Analyze_Subprogram_Specification (Spec);\n+      end Build_Class_Wide_Wrapper;\n \n       --------------------------\n       -- Check_Null_Exclusion --\n@@ -2118,7 +2374,6 @@ package body Sem_Ch8 is\n                   if Is_Incomplete_Or_Private_Type (Etype (F))\n                     and then No (Underlying_Type (Etype (F)))\n                   then\n-\n                      --  Exclude generic types, or types derived  from them.\n                      --  They will be frozen in the enclosing instance.\n \n@@ -2144,28 +2399,23 @@ package body Sem_Ch8 is\n       ---------------------------\n \n       function Has_Class_Wide_Actual return Boolean is\n-         F_Nam  : Entity_Id;\n-         F_Spec : Entity_Id;\n+         Formal     : Entity_Id;\n+         Formal_Typ : Entity_Id;\n \n       begin\n-         if Is_Actual\n-           and then Nkind (Nam) in N_Has_Entity\n-           and then Present (Entity (Nam))\n-           and then Is_Dispatching_Operation (Entity (Nam))\n-         then\n-            F_Nam  := First_Entity (Entity (Nam));\n-            F_Spec := First_Formal (Formal_Spec);\n-            while Present (F_Nam) and then Present (F_Spec) loop\n-               if Is_Controlling_Formal (F_Nam)\n-                 and then Has_Unknown_Discriminants (Etype (F_Spec))\n-                 and then not Is_Class_Wide_Type (Etype (F_Spec))\n-                 and then Is_Class_Wide_Type (Get_Instance_Of (Etype (F_Spec)))\n+         if Is_Actual then\n+            Formal := First_Formal (Formal_Spec);\n+            while Present (Formal) loop\n+               Formal_Typ := Etype (Formal);\n+\n+               if Has_Unknown_Discriminants (Formal_Typ)\n+                 and then not Is_Class_Wide_Type (Formal_Typ)\n+                 and then Is_Class_Wide_Type (Get_Instance_Of (Formal_Typ))\n                then\n                   return True;\n                end if;\n \n-               Next_Entity (F_Nam);\n-               Next_Formal (F_Spec);\n+               Next_Formal (Formal);\n             end loop;\n          end if;\n \n@@ -2215,11 +2465,16 @@ package body Sem_Ch8 is\n          end if;\n       end Original_Subprogram;\n \n+      --  Local variables\n+\n       CW_Actual : constant Boolean := Has_Class_Wide_Actual;\n       --  Ada 2012 (AI05-071, AI05-0131): True if the renaming is for a\n       --  defaulted formal subprogram when the actual for a related formal\n       --  type is class-wide.\n \n+      Inst_Node : Node_Id := Empty;\n+      New_S     : Entity_Id;\n+\n    --  Start of processing for Analyze_Subprogram_Renaming\n \n    begin\n@@ -2344,9 +2599,8 @@ package body Sem_Ch8 is\n          --  Check whether the renaming is for a defaulted actual subprogram\n          --  with a class-wide actual.\n \n-         if CW_Actual then\n-            New_S := Analyze_Subprogram_Specification (Spec);\n-            Old_S := Check_Class_Wide_Actual;\n+         if CW_Actual and then Box_Present (Inst_Node) then\n+            Build_Class_Wide_Wrapper (New_S, Old_S);\n \n          elsif Is_Entity_Name (Nam)\n            and then Present (Entity (Nam))\n@@ -2623,8 +2877,8 @@ package body Sem_Ch8 is\n          Analyze_Renamed_Character (N, New_S, Present (Rename_Spec));\n          return;\n \n-      --  Only remaining case is where we have a non-entity name, or a\n-      --  renaming of some other non-overloadable entity.\n+      --  Only remaining case is where we have a non-entity name, or a renaming\n+      --  of some other non-overloadable entity.\n \n       elsif not Is_Entity_Name (Nam)\n         or else not Is_Overloadable (Entity (Nam))\n@@ -3939,7 +4193,6 @@ package body Sem_Ch8 is\n       else\n          Pop_Scope;\n       end if;\n-\n    end End_Scope;\n \n    ---------------------\n@@ -5916,31 +6169,11 @@ package body Sem_Ch8 is\n       Old_S := Any_Id;\n       Candidate_Renaming := Empty;\n \n-      if not Is_Overloaded (Nam) then\n-         if Is_Actual and then Present (Enclosing_Instance) then\n-            Old_S := Entity (Nam);\n-\n-         elsif Entity_Matches_Spec (Entity (Nam), New_S) then\n-            Candidate_Renaming := New_S;\n-\n-            if Is_Visible_Operation (Entity (Nam)) then\n-               Old_S := Entity (Nam);\n-            end if;\n-\n-         elsif\n-           Present (First_Formal (Entity (Nam)))\n-             and then Present (First_Formal (New_S))\n-             and then (Base_Type (Etype (First_Formal (Entity (Nam)))) =\n-                       Base_Type (Etype (First_Formal (New_S))))\n-         then\n-            Candidate_Renaming := Entity (Nam);\n-         end if;\n-\n-      else\n+      if Is_Overloaded (Nam) then\n          Get_First_Interp (Nam, Ind, It);\n          while Present (It.Nam) loop\n             if Entity_Matches_Spec (It.Nam, New_S)\n-               and then Is_Visible_Operation (It.Nam)\n+              and then Is_Visible_Operation (It.Nam)\n             then\n                if Old_S /= Any_Id then\n \n@@ -6009,6 +6242,27 @@ package body Sem_Ch8 is\n          if Old_S /= Any_Id then\n             Set_Is_Overloaded (Nam, False);\n          end if;\n+\n+      --  Non-overloaded case\n+\n+      else\n+         if Is_Actual and then Present (Enclosing_Instance) then\n+            Old_S := Entity (Nam);\n+\n+         elsif Entity_Matches_Spec (Entity (Nam), New_S) then\n+            Candidate_Renaming := New_S;\n+\n+            if Is_Visible_Operation (Entity (Nam)) then\n+               Old_S := Entity (Nam);\n+            end if;\n+\n+         elsif Present (First_Formal (Entity (Nam)))\n+           and then Present (First_Formal (New_S))\n+           and then (Base_Type (Etype (First_Formal (Entity (Nam)))) =\n+                     Base_Type (Etype (First_Formal (New_S))))\n+         then\n+            Candidate_Renaming := Entity (Nam);\n+         end if;\n       end if;\n \n       return Old_S;"}]}