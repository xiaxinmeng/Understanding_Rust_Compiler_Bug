{"sha": "1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUzMjUwMGVjYmU4ZGJmNTliZWY0OThlNDZiNDQ3YjNhNmIwZmE2NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-03T13:52:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-03T13:52:59Z"}, "message": "ipa-fnsummary.c (ipa_call_context): New constructor.\n\n\n\t* ipa-fnsummary.c (ipa_call_context): New constructor.\n\t(estimate_node_size_and_time): Turn to ...\n\t(ipa_call_context::estimate_size_and_time): ... this one.\n\t(ipa_call_context::release): New.\n\t* ipa-fnsummary.h (ipa_call_context): New class.\n\t(estimate_node_size_and_time): Remove.\n\t* ipa-inline-analysis.c (do_estimate_edge_time, do_estimate_edge_size,\n\tdo_estimate_edge_hints): Update.\n\nFrom-SVN: r277755", "tree": {"sha": "f086db17aabe356ccc9facab8927901ed949d08d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f086db17aabe356ccc9facab8927901ed949d08d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/comments", "author": null, "committer": null, "parents": [{"sha": "a9a0fd0e2896e1f4987d4be7094e292f46532046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a0fd0e2896e1f4987d4be7094e292f46532046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9a0fd0e2896e1f4987d4be7094e292f46532046"}], "stats": {"total": 190, "additions": 125, "deletions": 65}, "files": [{"sha": "817a33376a08775e72a640c1d5fec958ef718869", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "patch": "@@ -1,3 +1,14 @@\n+2019-11-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (ipa_call_context): New constructor.\n+\t(estimate_node_size_and_time): Turn to ...\n+\t(ipa_call_context::estimate_size_and_time): ... this one.\n+\t(ipa_call_context::release): New.\n+\t* ipa-fnsummary.h (ipa_call_context): New class.\n+\t(estimate_node_size_and_time): Remove.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time, do_estimate_edge_size,\n+\tdo_estimate_edge_hints): Update.\n+\n 2019-11-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* config.in: Regenerate."}, {"sha": "9dc87547faf1a723a0ec83d76ae49a4691c82017", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "patch": "@@ -2940,31 +2940,54 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n     }\n }\n \n+/* Default constructor for ipa call context.\n+   Memory alloction of known_vals, known_contexts\n+   and known_aggs vectors is owned by the caller, but can\n+   be release by ipa_call_context::release.  \n+   \n+   inline_param_summary is owned by the caller.  */\n+ipa_call_context::ipa_call_context (cgraph_node *node,\n+\t\t\t\t    clause_t possible_truths,\n+\t\t\t\t    clause_t nonspec_possible_truths,\n+\t\t\t\t    vec<tree> known_vals,\n+\t\t\t\t    vec<ipa_polymorphic_call_context>\n+\t\t\t\t   \t known_contexts,\n+\t\t\t\t    vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t\t    vec<inline_param_summary>\n+\t\t\t\t   \t inline_param_summary)\n+: m_node (node), m_possible_truths (possible_truths),\n+  m_nonspec_possible_truths (nonspec_possible_truths),\n+  m_inline_param_summary (inline_param_summary),\n+  m_known_vals (known_vals),\n+  m_known_contexts (known_contexts),\n+  m_known_aggs (known_aggs)\n+{\n+}\n+\n+/* Release memory used by known_vals/contexts/aggs vectors.  */\n+\n+void\n+ipa_call_context::release ()\n+{\n+  m_known_vals.release ();\n+  m_known_contexts.release ();\n+  m_known_aggs.release ();\n+}\n \n-/* Estimate size and time needed to execute NODE assuming\n-   POSSIBLE_TRUTHS clause, and KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS\n-   information about NODE's arguments.  If non-NULL use also probability\n-   information present in INLINE_PARAM_SUMMARY vector.\n+/* Estimate size and time needed to execute call in the given context.\n    Additionally detemine hints determined by the context.  Finally compute\n    minimal size needed for the call that is independent on the call context and\n    can be used for fast estimates.  Return the values in RET_SIZE,\n    RET_MIN_SIZE, RET_TIME and RET_HINTS.  */\n \n void\n-estimate_node_size_and_time (struct cgraph_node *node,\n-\t\t\t     clause_t possible_truths,\n-\t\t\t     clause_t nonspec_possible_truths,\n-\t\t\t     vec<tree> known_vals,\n-\t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t     int *ret_size, int *ret_min_size,\n-\t\t\t     sreal *ret_time,\n-\t\t\t     sreal *ret_nonspecialized_time,\n-\t\t\t     ipa_hints *ret_hints,\n-\t\t\t     vec<inline_param_summary>\n-\t\t\t     inline_param_summary)\n+ipa_call_context::estimate_size_and_time (int *ret_size,\n+\t\t\t\t\t  int *ret_min_size,\n+\t\t\t\t\t  sreal *ret_time,\n+\t\t\t\t\t  sreal *ret_nonspecialized_time,\n+\t\t\t\t\t  ipa_hints *ret_hints)\n {\n-  class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get_create (m_node);\n   size_time_entry *e;\n   int size = 0;\n   sreal time = 0;\n@@ -2976,13 +2999,13 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     {\n       bool found = false;\n       fprintf (dump_file, \"   Estimating body: %s/%i\\n\"\n-\t       \"   Known to be false: \", node->name (),\n-\t       node->order);\n+\t       \"   Known to be false: \", m_node->name (),\n+\t       m_node->order);\n \n       for (i = predicate::not_inlined_condition;\n \t   i < (predicate::first_dynamic_condition\n \t\t+ (int) vec_safe_length (info->conds)); i++)\n-\tif (!(possible_truths & (1 << i)))\n+\tif (!(m_possible_truths & (1 << i)))\n \t  {\n \t    if (found)\n \t      fprintf (dump_file, \", \");\n@@ -2991,19 +3014,19 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t  }\n     }\n \n-  estimate_calls_size_and_time (node, &size, &min_size, &time, &hints, possible_truths,\n-\t\t\t\tknown_vals, known_contexts, known_aggs);\n+  estimate_calls_size_and_time (m_node, &size, &min_size, &time, &hints, m_possible_truths,\n+\t\t\t\tm_known_vals, m_known_contexts, m_known_aggs);\n   sreal nonspecialized_time = time;\n \n   for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n     {\n-      bool exec = e->exec_predicate.evaluate (nonspec_possible_truths);\n+      bool exec = e->exec_predicate.evaluate (m_nonspec_possible_truths);\n \n       /* Because predicates are conservative, it can happen that nonconst is 1\n \t but exec is 0.  */\n       if (exec)\n         {\n-          bool nonconst = e->nonconst_predicate.evaluate (possible_truths);\n+          bool nonconst = e->nonconst_predicate.evaluate (m_possible_truths);\n \n \t  gcc_checking_assert (e->time >= 0);\n \t  gcc_checking_assert (time >= 0);\n@@ -3019,16 +3042,16 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t  nonspecialized_time += e->time;\n \t  if (!nonconst)\n \t    ;\n-\t  else if (!inline_param_summary.exists ())\n+\t  else if (!m_inline_param_summary.exists ())\n \t    {\n \t      if (nonconst)\n \t        time += e->time;\n \t    }\n \t  else\n \t    {\n \t      int prob = e->nonconst_predicate.probability \n-\t\t\t\t\t       (info->conds, possible_truths,\n-\t\t\t\t\t        inline_param_summary);\n+\t\t\t\t\t       (info->conds, m_possible_truths,\n+\t\t\t\t\t        m_inline_param_summary);\n \t      gcc_checking_assert (prob >= 0);\n \t      gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n \t      time += e->time * prob / REG_BR_PROB_BASE;\n@@ -3052,14 +3075,14 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     time = nonspecialized_time;\n \n   if (info->loop_iterations\n-      && !info->loop_iterations->evaluate (possible_truths))\n+      && !info->loop_iterations->evaluate (m_possible_truths))\n     hints |= INLINE_HINT_loop_iterations;\n   if (info->loop_stride\n-      && !info->loop_stride->evaluate (possible_truths))\n+      && !info->loop_stride->evaluate (m_possible_truths))\n     hints |= INLINE_HINT_loop_stride;\n   if (info->scc_no)\n     hints |= INLINE_HINT_in_scc;\n-  if (DECL_DECLARED_INLINE_P (node->decl))\n+  if (DECL_DECLARED_INLINE_P (m_node->decl))\n     hints |= INLINE_HINT_declared_inline;\n \n   size = RDIV (size, ipa_fn_summary::size_scale);\n@@ -3101,10 +3124,11 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \n   evaluate_conditions_for_known_args (node, false, known_vals, known_aggs,\n \t\t\t\t      &clause, &nonspec_clause);\n-  estimate_node_size_and_time (node, clause, nonspec_clause,\n-\t\t\t       known_vals, known_contexts,\n-\t\t\t       known_aggs, ret_size, NULL, ret_time,\n-\t\t\t       ret_nonspec_time, hints, vNULL);\n+  ipa_call_context ctx (node, clause, nonspec_clause,\n+\t\t        known_vals, known_contexts,\n+\t\t        known_aggs, vNULL);\n+  ctx.estimate_size_and_time (ret_size, NULL, ret_time,\n+\t\t\t      ret_nonspec_time, hints);\n }\n \n /* Return stack frame offset where frame of NODE is supposed to start inside"}, {"sha": "7638b4502162a5c6df99307e88ad185f07263188", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "patch": "@@ -281,6 +281,47 @@ class ipa_call_summary_t: public fast_call_summary <ipa_call_summary *, va_heap>\n \t\t\t  ipa_call_summary *dst_data);\n };\n \n+/* This object describe a context of call.  That is a summary of known\n+   information about its parameters.  Main purpose of this context is\n+   to give more realistic esitmations of function runtime, size and\n+   inline hints.  */\n+class ipa_call_context\n+{\n+public:\n+  ipa_call_context (cgraph_node *node,\n+      \t\t    clause_t possible_truths,\n+\t\t    clause_t nonspec_possible_truths,\n+\t\t    vec<tree> known_vals,\n+\t\t    vec<ipa_polymorphic_call_context> known_contexts,\n+\t\t    vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t    vec<inline_param_summary> m_inline_param_summary);\n+  void estimate_size_and_time (int *ret_size, int *ret_min_size,\n+\t\t\t       sreal *ret_time,\n+\t\t\t       sreal *ret_nonspecialized_time,\n+\t\t\t       ipa_hints *ret_hints);\n+  void release ();\n+private:\n+  /* Called function.  */\n+  cgraph_node *m_node;\n+  /* Clause describing what predicate conditionals can be satisfied\n+     in this context if function is inlined/specialised.  */\n+  clause_t m_possible_truths;\n+  /* Clause describing what predicate conditionals can be satisfied\n+     in this context if function is kept offline.  */\n+  clause_t m_nonspec_possible_truths;\n+  /* Inline summary maintains info about change probabilities.  */\n+  vec<inline_param_summary> m_inline_param_summary;\n+\n+  /* The following is used only to resolve indirect calls.  */\n+\n+  /* Vector describing known values of parameters.  */\n+  vec<tree> m_known_vals;\n+  /* Vector describing known polymorphic call contexts.  */\n+  vec<ipa_polymorphic_call_context> m_known_contexts;\n+  /* Vector describing known aggregate values.  */\n+  vec<ipa_agg_jump_function_p> m_known_aggs;\n+};\n+\n extern fast_call_summary <ipa_call_summary *, va_heap> *ipa_call_summaries;\n \n /* In ipa-fnsummary.c  */\n@@ -302,25 +343,14 @@ void ipa_update_overall_fn_summary (struct cgraph_node *node);\n void compute_fn_summary (struct cgraph_node *, bool);\n \n \n-void evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n+void evaluate_properties_for_edge (struct cgraph_edge *e,\n+\t       \t\t           bool inline_p,\n \t\t\t\t   clause_t *clause_ptr,\n \t\t\t\t   clause_t *nonspec_clause_ptr,\n \t\t\t\t   vec<tree> *known_vals_ptr,\n \t\t\t\t   vec<ipa_polymorphic_call_context>\n \t\t\t\t   *known_contexts_ptr,\n \t\t\t\t   vec<ipa_agg_jump_function_p> *);\n-void estimate_node_size_and_time (struct cgraph_node *node,\n-\t\t\t\t  clause_t possible_truths,\n-\t\t\t\t  clause_t nonspec_possible_truths,\n-\t\t\t\t  vec<tree> known_vals,\n-\t\t\t\t  vec<ipa_polymorphic_call_context>,\n-\t\t\t\t  vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t\t  int *ret_size, int *ret_min_size,\n-\t\t\t\t  sreal *ret_time,\n-\t\t\t\t  sreal *ret_nonspecialized_time,\n-\t\t\t\t  ipa_hints *ret_hints,\n-\t\t\t\t  vec<inline_param_summary>\n-\t\t\t\t  inline_param_summary);\n \n void ipa_fnsummary_c_finalize (void);\n HOST_WIDE_INT ipa_get_stack_frame_offset (struct cgraph_node *node);"}, {"sha": "5c00c0d1f44ffbf50199b2edd81618184b4403c5", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1532500ecbe8dbf59bef498e46b447b3a6b0fa65/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1532500ecbe8dbf59bef498e46b447b3a6b0fa65", "patch": "@@ -137,9 +137,10 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   evaluate_properties_for_edge (edge, true,\n \t\t\t\t&clause, &nonspec_clause, &known_vals,\n \t\t\t\t&known_contexts, &known_aggs);\n-  estimate_node_size_and_time (callee, clause, nonspec_clause, known_vals,\n-\t\t\t       known_contexts, known_aggs, &size, &min_size,\n-\t\t\t       &time, &nonspec_time, &hints, es->param);\n+  ipa_call_context ctx (callee, clause, nonspec_clause, known_vals,\n+\t\t  \tknown_contexts, known_aggs, es->param);\n+  ctx.estimate_size_and_time (&size, &min_size,\n+\t\t\t      &time, &nonspec_time, &hints);\n \n   /* When we have profile feedback, we can quite safely identify hot\n      edges and for those we disable size limits.  Don't do that when\n@@ -152,9 +153,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \t     : edge->caller->count.ipa ())))\n     hints |= INLINE_HINT_known_hot;\n \n-  known_vals.release ();\n-  known_contexts.release ();\n-  known_aggs.release ();\n+  ctx.release ();\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n \n@@ -207,12 +206,10 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n \t\t\t\t&clause, &nonspec_clause,\n \t\t\t\t&known_vals, &known_contexts,\n \t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, nonspec_clause, known_vals,\n-\t\t\t       known_contexts, known_aggs, &size, NULL, NULL,\n-\t\t\t       NULL, NULL, vNULL);\n-  known_vals.release ();\n-  known_contexts.release ();\n-  known_aggs.release ();\n+  ipa_call_context ctx (callee, clause, nonspec_clause, known_vals,\n+\t\t  \tknown_contexts, known_aggs, vNULL);\n+  ctx.estimate_size_and_time (&size, NULL, NULL, NULL, NULL);\n+  ctx.release ();\n   return size;\n }\n \n@@ -248,12 +245,10 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n \t\t\t\t&clause, &nonspec_clause,\n \t\t\t\t&known_vals, &known_contexts,\n \t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, nonspec_clause, known_vals,\n-\t\t\t       known_contexts, known_aggs, NULL, NULL,\n-\t\t\t       NULL, NULL, &hints, vNULL);\n-  known_vals.release ();\n-  known_contexts.release ();\n-  known_aggs.release ();\n+  ipa_call_context ctx (callee, clause, nonspec_clause, known_vals,\n+\t\t  \tknown_contexts, known_aggs, vNULL);\n+  ctx.estimate_size_and_time (NULL, NULL, NULL, NULL, &hints);\n+  ctx.release ();\n   hints |= simple_edge_hints (edge);\n   return hints;\n }"}]}