{"sha": "8e7aa1f9a319b100c721a7d83294a799a295407c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU3YWExZjlhMzE5YjEwMGM3MjFhN2Q4MzI5NGE3OTlhMjk1NDA3Yw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-08-25T13:33:54Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-08-25T13:33:54Z"}, "message": "expr.h (struct separate_ops, sepops): New type for passing around an exploded simple expression.\n\n        * expr.h (struct separate_ops, sepops): New type for passing\n        around an exploded simple expression.\n        * optabs.c (expand_widen_pattern_expr, expand_vec_shift_expr):\n        Use this structure instead of expression tree.\n        (get_vcond_icode, expand_vec_cond_expr_p): Don't take whole\n        expression, only its type.\n        (expand_vec_cond_expr): Take type and individual operands instead\n        of full expression.\n        * optabs.h (expand_widen_pattern_expr, expand_vec_cond_expr,\n        expand_vec_shift_expr): Change prototype accordingly.\n        * tree-vect-stmts.c (vectorizable_condition): Change call of\n        expand_vec_cond_expr_p to pass only type.\n        * expr.c (do_store_flags): Change prototype and implementation\n        to take an exploded expression.\n        (expand_expr_real_1): New local ops initialized with details\n        of the full expression.  Use it instead of full\n        expression in calls to do_store_flags, expand_vec_cond_expr,\n        expand_widen_pattern_expr and expand_vec_shift_expr.\n\nFrom-SVN: r151079", "tree": {"sha": "21065dda4814644807909923e74947363f96ca60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21065dda4814644807909923e74947363f96ca60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e7aa1f9a319b100c721a7d83294a799a295407c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7aa1f9a319b100c721a7d83294a799a295407c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7aa1f9a319b100c721a7d83294a799a295407c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7aa1f9a319b100c721a7d83294a799a295407c/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf"}], "stats": {"total": 147, "additions": 95, "deletions": 52}, "files": [{"sha": "e99500ba5145f99dcbafac5806df967a550c1049", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e7aa1f9a319b100c721a7d83294a799a295407c", "patch": "@@ -1,3 +1,24 @@\n+2009-08-25  Michael Matz  <matz@suse.de>\n+\n+\t* expr.h (struct separate_ops, sepops): New type for passing\n+\taround an exploded simple expression.\n+\t* optabs.c (expand_widen_pattern_expr, expand_vec_shift_expr):\n+\tUse this structure instead of expression tree.\n+\t(get_vcond_icode, expand_vec_cond_expr_p): Don't take whole\n+\texpression, only its type.\n+\t(expand_vec_cond_expr): Take type and individual operands instead\n+\tof full expression.\n+\t* optabs.h (expand_widen_pattern_expr, expand_vec_cond_expr,\n+\texpand_vec_shift_expr): Change prototype accordingly.\n+\t* tree-vect-stmts.c (vectorizable_condition): Change call of\n+\texpand_vec_cond_expr_p to pass only type.\n+\t* expr.c (do_store_flags): Change prototype and implementation\n+\tto take an exploded expression.\n+\t(expand_expr_real_1): New local ops initialized with details\n+\tof the full expression.  Use it instead of full\n+\texpression in calls to do_store_flags, expand_vec_cond_expr,\n+\texpand_widen_pattern_expr and expand_vec_shift_expr.\n+\n 2009-08-25  Michael Matz  <matz@suse.de>\n \n \t* expr.c (expand_expr_real_1): New local treeop0, treeop1,"}, {"sha": "12d0dc99856d550fe4f2e01c584e0192bc46db83", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8e7aa1f9a319b100c721a7d83294a799a295407c", "patch": "@@ -152,7 +152,7 @@ static int is_aligning_offset (const_tree, const_tree);\n static void expand_operands (tree, tree, rtx, rtx*, rtx*,\n \t\t\t     enum expand_modifier);\n static rtx reduce_to_bit_field_precision (rtx, rtx, tree);\n-static rtx do_store_flag (tree, rtx, enum machine_mode);\n+static rtx do_store_flag (sepops, rtx, enum machine_mode);\n #ifdef PUSH_ROUNDING\n static void emit_single_push_insn (enum machine_mode, rtx, tree);\n #endif\n@@ -7220,6 +7220,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   gimple subexp0_def, subexp1_def;\n   tree top0, top1;\n   location_t loc = EXPR_LOCATION (exp);\n+  struct separate_ops ops;\n   tree treeop0, treeop1, treeop2;\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field\t\t\t  \\\n \t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n@@ -7241,6 +7242,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tcase 1: treeop0 = TREE_OPERAND (exp, 0);\n \tcase 0: break;\n       }\n+  ops.code = code;\n+  ops.type = type;\n+  ops.op0 = treeop0;\n+  ops.op1 = treeop1;\n+  ops.op2 = treeop2;\n+  ops.location = loc;\n \n   ignore = (target == const0_rtx\n \t    || ((CONVERT_EXPR_CODE_P (code)\n@@ -8187,6 +8194,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\tmodifier);\n \n \t      result = copy_rtx (result);\n+\t      /* BLA */\n \t      set_mem_attributes (result, exp, 0);\n \t      return result;\n \t    }\n@@ -9133,7 +9141,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n     case LTGT_EXPR:\n-      temp = do_store_flag (exp,\n+      temp = do_store_flag (&ops,\n \t\t\t    modifier != EXPAND_STACK_PARM ? target : NULL_RTX,\n \t\t\t    tmode != VOIDmode ? tmode : mode);\n       if (temp)\n@@ -9161,6 +9169,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \temit_move_insn (target, const0_rtx);\n \n       op1 = gen_label_rtx ();\n+      /* BLA */\n       jumpifnot (exp, op1);\n \n       if (target)\n@@ -9247,8 +9256,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n        return temp;\n \n     case VEC_COND_EXPR:\n-\ttarget = expand_vec_cond_expr (exp, target);\n-\treturn target;\n+      target = expand_vec_cond_expr (type, treeop0, treeop1, treeop2, target);\n+      return target;\n \n     case MODIFY_EXPR:\n       {\n@@ -9403,7 +9412,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \top2 = expand_normal (oprnd2);\n-\ttarget = expand_widen_pattern_expr (exp, op0, op1, op2,\n+\ttarget = expand_widen_pattern_expr (&ops, op0, op1, op2,\n \t\t\t\t\t    target, unsignedp);\n \treturn target;\n       }\n@@ -9414,7 +9423,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         tree oprnd1 = treeop1;\n \n         expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-        target = expand_widen_pattern_expr (exp, op0, NULL_RTX, op1,\n+        target = expand_widen_pattern_expr (&ops, op0, NULL_RTX, op1,\n                                             target, unsignedp);\n         return target;\n       }\n@@ -9457,7 +9466,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_LSHIFT_EXPR:\n     case VEC_RSHIFT_EXPR:\n       {\n-\ttarget = expand_vec_shift_expr (exp, target);\n+\ttarget = expand_vec_shift_expr (&ops, target);\n \treturn target;\n       }\n \n@@ -9466,7 +9475,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \top0 = expand_normal (treeop0);\n \tthis_optab = optab_for_tree_code (code, type, optab_default);\n-\ttemp = expand_widen_pattern_expr (exp, op0, NULL_RTX, NULL_RTX,\n+\ttemp = expand_widen_pattern_expr (&ops, op0, NULL_RTX, NULL_RTX,\n \t\t\t\t\t  target, unsignedp);\n \tgcc_assert (temp);\n \treturn temp;\n@@ -9481,7 +9490,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t  TREE_TYPE (treeop0),\n \t\t\t\t\t  optab_default);\n \ttemp = expand_widen_pattern_expr\n-\t  (exp, op0, NULL_RTX, NULL_RTX,\n+\t  (&ops, op0, NULL_RTX, NULL_RTX,\n \t   target, TYPE_UNSIGNED (TREE_TYPE (treeop0)));\n \n \tgcc_assert (temp);\n@@ -9495,7 +9504,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttree oprnd1 = treeop1;\n \n \texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-\ttarget = expand_widen_pattern_expr (exp, op0, op1, NULL_RTX,\n+\ttarget = expand_widen_pattern_expr (&ops, op0, op1, NULL_RTX,\n \t\t\t\t\t    target, unsignedp);\n \tgcc_assert (target);\n \treturn target;\n@@ -9740,8 +9749,9 @@ string_constant (tree arg, tree *ptr_offset)\n   return 0;\n }\n \f\n-/* Generate code to calculate EXP using a store-flag instruction\n-   and return an rtx for the result.  EXP is a comparison.\n+/* Generate code to calculate OPS, and exploded expression\n+   using a store-flag instruction and return an rtx for the result.\n+   OPS reflects a comparison.\n \n    If TARGET is nonzero, store the result there if convenient.\n \n@@ -9757,7 +9767,7 @@ string_constant (tree arg, tree *ptr_offset)\n    set/jump/set sequence.  */\n \n static rtx\n-do_store_flag (tree exp, rtx target, enum machine_mode mode)\n+do_store_flag (sepops ops, rtx target, enum machine_mode mode)\n {\n   enum rtx_code code;\n   tree arg0, arg1, type;\n@@ -9766,10 +9776,10 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n   int unsignedp;\n   rtx op0, op1;\n   rtx subtarget = target;\n-  location_t loc = EXPR_LOCATION (exp);\n+  location_t loc = ops->location;\n \n-  arg0 = TREE_OPERAND (exp, 0);\n-  arg1 = TREE_OPERAND (exp, 1);\n+  arg0 = ops->op0;\n+  arg1 = ops->op1;\n \n   /* Don't crash if the comparison was erroneous.  */\n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n@@ -9788,11 +9798,11 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n      when function pointers must be canonicalized before comparisons.  */\n #ifdef HAVE_canonicalize_funcptr_for_compare\n   if (HAVE_canonicalize_funcptr_for_compare\n-      && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n-\t   && (TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+      && ((TREE_CODE (TREE_TYPE (arg0)) == POINTER_TYPE\n+\t   && (TREE_CODE (TREE_TYPE (TREE_TYPE (arg0)))\n \t       == FUNCTION_TYPE))\n-\t  || (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 1))) == POINTER_TYPE\n-\t      && (TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 1))))\n+\t  || (TREE_CODE (TREE_TYPE (arg1)) == POINTER_TYPE\n+\t      && (TREE_CODE (TREE_TYPE (TREE_TYPE (arg1)))\n \t\t  == FUNCTION_TYPE))))\n     return 0;\n #endif\n@@ -9807,7 +9817,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n      tests will not catch constants in the first operand, but constants\n      are rarely passed as the first operand.  */\n \n-  switch (TREE_CODE (exp))\n+  switch (ops->code)\n     {\n     case EQ_EXPR:\n       code = EQ;"}, {"sha": "228a34597beb0ff5af6c01a3e66a51324173a4c5", "filename": "gcc/expr.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=8e7aa1f9a319b100c721a7d83294a799a295407c", "patch": "@@ -267,6 +267,17 @@ do {\t\t\t\t\t\t\t\t\\\n #define STACK_CHECK_MAX_VAR_SIZE (STACK_CHECK_MAX_FRAME_SIZE / 100)\n #endif\n \f\n+/* This structure is used to pass around information about exploded\n+   unary, binary and trinary expressions between expand_expr_real_1 and\n+   friends.  */\n+typedef struct separate_ops\n+{\n+  enum tree_code code;\n+  tree type;\n+  tree op0, op1, op2;\n+  location_t location;\n+} *sepops;\n+\f\n /* Functions from optabs.c, commonly used, and without need for the optabs\n    tables:  */\n "}, {"sha": "61d8bcfe2986780953e0124ee3f6b7abbf5318cd", "filename": "gcc/optabs.c", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8e7aa1f9a319b100c721a7d83294a799a295407c", "patch": "@@ -530,8 +530,8 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n    type-promotion (vec-unpack)  1       oprnd0  -       -  */\n \n rtx\n-expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op, rtx target,\n-                           int unsignedp)\n+expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n+\t\t\t   rtx target, int unsignedp)\n {   \n   tree oprnd0, oprnd1, oprnd2;\n   enum machine_mode wmode = VOIDmode, tmode0, tmode1 = VOIDmode;\n@@ -541,19 +541,19 @@ expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op, rtx target,\n   rtx temp;\n   rtx pat;\n   rtx xop0, xop1, wxop;\n-  int nops = TREE_OPERAND_LENGTH (exp);\n+  int nops = TREE_CODE_LENGTH (ops->code);\n \n-  oprnd0 = TREE_OPERAND (exp, 0);\n+  oprnd0 = ops->op0;\n   tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));\n   widen_pattern_optab =\n-    optab_for_tree_code (TREE_CODE (exp), TREE_TYPE (oprnd0), optab_default);\n+    optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), optab_default);\n   icode = (int) optab_handler (widen_pattern_optab, tmode0)->insn_code;\n   gcc_assert (icode != CODE_FOR_nothing);\n   xmode0 = insn_data[icode].operand[1].mode;\n \n   if (nops >= 2)\n     {\n-      oprnd1 = TREE_OPERAND (exp, 1);\n+      oprnd1 = ops->op1;\n       tmode1 = TYPE_MODE (TREE_TYPE (oprnd1));\n       xmode1 = insn_data[icode].operand[2].mode;\n     }\n@@ -568,7 +568,7 @@ expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op, rtx target,\n     {\n       gcc_assert (tmode1 == tmode0);\n       gcc_assert (op1);\n-      oprnd2 = TREE_OPERAND (exp, 2);\n+      oprnd2 = ops->op2;\n       wmode = TYPE_MODE (TREE_TYPE (oprnd2));\n       wxmode = insn_data[icode].operand[3].mode;\n     }\n@@ -777,19 +777,19 @@ force_expand_binop (enum machine_mode mode, optab binoptab,\n /* Generate insns for VEC_LSHIFT_EXPR, VEC_RSHIFT_EXPR.  */\n \n rtx\n-expand_vec_shift_expr (tree vec_shift_expr, rtx target)\n+expand_vec_shift_expr (sepops ops, rtx target)\n {\n   enum insn_code icode;\n   rtx rtx_op1, rtx_op2;\n   enum machine_mode mode1;\n   enum machine_mode mode2;\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (vec_shift_expr));\n-  tree vec_oprnd = TREE_OPERAND (vec_shift_expr, 0);\n-  tree shift_oprnd = TREE_OPERAND (vec_shift_expr, 1);\n+  enum machine_mode mode = TYPE_MODE (ops->type);\n+  tree vec_oprnd = ops->op0;\n+  tree shift_oprnd = ops->op1;\n   optab shift_optab;\n   rtx pat;\n \n-  switch (TREE_CODE (vec_shift_expr))\n+  switch (ops->code)\n     {\n       case VEC_RSHIFT_EXPR:\n \tshift_optab = vec_shr_optab;\n@@ -6835,60 +6835,62 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n   return gen_rtx_fmt_ee (rcode, VOIDmode, rtx_op0, rtx_op1);\n }\n \n-/* Return insn code for VEC_COND_EXPR EXPR.  */\n+/* Return insn code for TYPE, the type of a VEC_COND_EXPR.  */\n \n static inline enum insn_code\n-get_vcond_icode (tree expr, enum machine_mode mode)\n+get_vcond_icode (tree type, enum machine_mode mode)\n {\n   enum insn_code icode = CODE_FOR_nothing;\n \n-  if (TYPE_UNSIGNED (TREE_TYPE (expr)))\n+  if (TYPE_UNSIGNED (type))\n     icode = vcondu_gen_code[mode];\n   else\n     icode = vcond_gen_code[mode];\n   return icode;\n }\n \n /* Return TRUE iff, appropriate vector insns are available\n-   for vector cond expr expr in VMODE mode.  */\n+   for vector cond expr with type TYPE in VMODE mode.  */\n \n bool\n-expand_vec_cond_expr_p (tree expr, enum machine_mode vmode)\n+expand_vec_cond_expr_p (tree type, enum machine_mode vmode)\n {\n-  if (get_vcond_icode (expr, vmode) == CODE_FOR_nothing)\n+  if (get_vcond_icode (type, vmode) == CODE_FOR_nothing)\n     return false;\n   return true;\n }\n \n-/* Generate insns for VEC_COND_EXPR.  */\n+/* Generate insns for a VEC_COND_EXPR, given its TYPE and its\n+   three operands.  */\n \n rtx\n-expand_vec_cond_expr (tree vec_cond_expr, rtx target)\n+expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n+\t\t      rtx target)\n {\n   enum insn_code icode;\n   rtx comparison, rtx_op1, rtx_op2, cc_op0, cc_op1;\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (vec_cond_expr));\n-  bool unsignedp = TYPE_UNSIGNED (TREE_TYPE (vec_cond_expr));\n+  enum machine_mode mode = TYPE_MODE (vec_cond_type);\n+  bool unsignedp = TYPE_UNSIGNED (vec_cond_type);\n \n-  icode = get_vcond_icode (vec_cond_expr, mode);\n+  icode = get_vcond_icode (vec_cond_type, mode);\n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n   if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n     target = gen_reg_rtx (mode);\n \n   /* Get comparison rtx.  First expand both cond expr operands.  */\n-  comparison = vector_compare_rtx (TREE_OPERAND (vec_cond_expr, 0),\n+  comparison = vector_compare_rtx (op0,\n \t\t\t\t   unsignedp, icode);\n   cc_op0 = XEXP (comparison, 0);\n   cc_op1 = XEXP (comparison, 1);\n   /* Expand both operands and force them in reg, if required.  */\n-  rtx_op1 = expand_normal (TREE_OPERAND (vec_cond_expr, 1));\n+  rtx_op1 = expand_normal (op1);\n   if (!insn_data[icode].operand[1].predicate (rtx_op1, mode)\n       && mode != VOIDmode)\n     rtx_op1 = force_reg (mode, rtx_op1);\n \n-  rtx_op2 = expand_normal (TREE_OPERAND (vec_cond_expr, 2));\n+  rtx_op2 = expand_normal (op2);\n   if (!insn_data[icode].operand[2].predicate (rtx_op2, mode)\n       && mode != VOIDmode)\n     rtx_op2 = force_reg (mode, rtx_op2);"}, {"sha": "af3ea66de8731e855a50f24ae318d6a4a275c9ce", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=8e7aa1f9a319b100c721a7d83294a799a295407c", "patch": "@@ -670,7 +670,7 @@ extern enum insn_code sync_lock_release[NUM_MACHINE_MODES];\n \n /* Define functions given in optabs.c.  */\n \n-extern rtx expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op,\n+extern rtx expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n                                       rtx target, int unsignedp);\n \n extern rtx expand_ternary_op (enum machine_mode mode, optab ternary_optab,\n@@ -772,10 +772,9 @@ extern bool expand_sfix_optab (rtx, rtx, convert_optab);\n bool expand_vec_cond_expr_p (tree, enum machine_mode);\n \n /* Generate code for VEC_COND_EXPR.  */\n-extern rtx expand_vec_cond_expr (tree, rtx);\n-\n+extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n /* Generate code for VEC_LSHIFT_EXPR and VEC_RSHIFT_EXPR.  */\n-extern rtx expand_vec_shift_expr (tree, rtx);\n+extern rtx expand_vec_shift_expr (sepops, rtx);\n \n #define optab_handler(optab,mode) (&(optab)->handlers[(int) (mode)])\n #define convert_optab_handler(optab,mode,mode2) \\"}, {"sha": "0a2ab19a232e2202eede110b29c0542306b0c7a8", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7aa1f9a319b100c721a7d83294a799a295407c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=8e7aa1f9a319b100c721a7d83294a799a295407c", "patch": "@@ -3889,7 +3889,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) \n     {\n       STMT_VINFO_TYPE (stmt_info) = condition_vec_info_type;\n-      return expand_vec_cond_expr_p (op, vec_mode);\n+      return expand_vec_cond_expr_p (TREE_TYPE (op), vec_mode);\n     }\n \n   /* Transform */"}]}