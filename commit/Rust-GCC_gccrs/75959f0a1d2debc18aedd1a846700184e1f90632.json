{"sha": "75959f0a1d2debc18aedd1a846700184e1f90632", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU5NTlmMGExZDJkZWJjMThhZWRkMWE4NDY3MDAxODRlMWY5MDYzMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-03-12T07:14:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-03-12T07:14:56Z"}, "message": "alpha.c (xfloating_ops, [...]): New.\n\n        * config/alpha/alpha.c (xfloating_ops, vax_cvt_ops): New.\n        (alpha_lookup_xfloating_lib_func): Use them, return rtx.\n        (alpha_emit_xfloating_arith): Update to match.\n        (alpha_emit_xfloating_compare): Likewise.\n        (alpha_emit_xfloating_cvt): Likewise.\n        (alpha_emit_xfloating_libcall): Take already built symbol,\n        mark call const.\n        * config/alpha/alpha.md (extendsftf2, extenddftf2): Take\n        op1 in a register.\n\nFrom-SVN: r79371", "tree": {"sha": "7b4d16c5775f4cee44df8500bbabeffc2cca126c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b4d16c5775f4cee44df8500bbabeffc2cca126c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75959f0a1d2debc18aedd1a846700184e1f90632", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75959f0a1d2debc18aedd1a846700184e1f90632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75959f0a1d2debc18aedd1a846700184e1f90632", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75959f0a1d2debc18aedd1a846700184e1f90632/comments", "author": null, "committer": null, "parents": [{"sha": "009368dba64b7288dc9d9a92618de62d2e36dc3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009368dba64b7288dc9d9a92618de62d2e36dc3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009368dba64b7288dc9d9a92618de62d2e36dc3a"}], "stats": {"total": 156, "additions": 76, "deletions": 80}, "files": [{"sha": "1c709f47c0d4fb3be77d8f6cb8f17654b5ac5c13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75959f0a1d2debc18aedd1a846700184e1f90632/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75959f0a1d2debc18aedd1a846700184e1f90632/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75959f0a1d2debc18aedd1a846700184e1f90632", "patch": "@@ -1,3 +1,15 @@\n+2004-03-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (xfloating_ops, vax_cvt_ops): New.\n+\t(alpha_lookup_xfloating_lib_func): Use them, return rtx.\n+\t(alpha_emit_xfloating_arith): Update to match.\n+\t(alpha_emit_xfloating_compare): Likewise.\n+\t(alpha_emit_xfloating_cvt): Likewise.\n+\t(alpha_emit_xfloating_libcall): Take already built symbol,\n+\tmark call const.\n+\t* config/alpha/alpha.md (extendsftf2, extenddftf2): Take\n+\top1 in a register.\n+\n 2004-03-11  Richard Henderson  <rth@redhat.com>\n \n \tPR target/14539"}, {"sha": "37920ad30194610620005280c01f5ddbb3b2e408", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 59, "deletions": 78, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75959f0a1d2debc18aedd1a846700184e1f90632/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75959f0a1d2debc18aedd1a846700184e1f90632/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=75959f0a1d2debc18aedd1a846700184e1f90632", "patch": "@@ -3564,85 +3564,65 @@ alpha_split_conditional_move (enum rtx_code code, rtx dest, rtx cond,\n /* Look up the function X_floating library function name for the\n    given operation.  */\n \n-static const char *\n+struct xfloating_op GTY(())\n+{\n+  const enum rtx_code code;\n+  const char *const GTY((skip(\"\"))) osf_func;\n+  const char *const GTY((skip(\"\"))) vms_func;\n+  rtx libcall;\n+};\n+\n+static GTY(()) struct xfloating_op xfloating_ops[] = \n+{\n+  { PLUS,\t\t\"_OtsAddX\", \"OTS$ADD_X\", 0 },\n+  { MINUS,\t\t\"_OtsSubX\", \"OTS$SUB_X\", 0 },\n+  { MULT,\t\t\"_OtsMulX\", \"OTS$MUL_X\", 0 },\n+  { DIV,\t\t\"_OtsDivX\", \"OTS$DIV_X\", 0 },\n+  { EQ,\t\t\t\"_OtsEqlX\", \"OTS$EQL_X\", 0 },\n+  { NE,\t\t\t\"_OtsNeqX\", \"OTS$NEQ_X\", 0 },\n+  { LT,\t\t\t\"_OtsLssX\", \"OTS$LSS_X\", 0 },\n+  { LE,\t\t\t\"_OtsLeqX\", \"OTS$LEQ_X\", 0 },\n+  { GT,\t\t\t\"_OtsGtrX\", \"OTS$GTR_X\", 0 },\n+  { GE,\t\t\t\"_OtsGeqX\", \"OTS$GEQ_X\", 0 },\n+  { FIX,\t\t\"_OtsCvtXQ\", \"OTS$CVTXQ\", 0 },\n+  { FLOAT,\t\t\"_OtsCvtQX\", \"OTS$CVTQX\", 0 },\n+  { UNSIGNED_FLOAT,\t\"_OtsCvtQUX\", \"OTS$CVTQUX\", 0 },\n+  { FLOAT_EXTEND,\t\"_OtsConvertFloatTX\", \"OTS$CVT_FLOAT_T_X\", 0 },\n+  { FLOAT_TRUNCATE,\t\"_OtsConvertFloatXT\", \"OTS$CVT_FLOAT_X_T\", 0 }\n+};\n+\n+static GTY(()) struct xfloating_op vax_cvt_ops[] =\n+{\n+  { FLOAT_EXTEND,\t\"_OtsConvertFloatGX\", \"OTS$CVT_FLOAT_G_X\", 0 },\n+  { FLOAT_TRUNCATE,\t\"_OtsConvertFloatXG\", \"OTS$CVT_FLOAT_X_G\", 0 }\n+};\n+\n+static rtx\n alpha_lookup_xfloating_lib_func (enum rtx_code code)\n {\n-  struct xfloating_op\n-    {\n-      const enum rtx_code code;\n-      const char *const func;\n-    };\n-\n-  static const struct xfloating_op vms_xfloating_ops[] = \n-    {\n-      { PLUS,\t\t\"OTS$ADD_X\" },\n-      { MINUS,\t\t\"OTS$SUB_X\" },\n-      { MULT,\t\t\"OTS$MUL_X\" },\n-      { DIV,\t\t\"OTS$DIV_X\" },\n-      { EQ,\t\t\"OTS$EQL_X\" },\n-      { NE,\t\t\"OTS$NEQ_X\" },\n-      { LT,\t\t\"OTS$LSS_X\" },\n-      { LE,\t\t\"OTS$LEQ_X\" },\n-      { GT,\t\t\"OTS$GTR_X\" },\n-      { GE,\t\t\"OTS$GEQ_X\" },\n-      { FIX,\t\t\"OTS$CVTXQ\" },\n-      { FLOAT,\t\t\"OTS$CVTQX\" },\n-      { UNSIGNED_FLOAT,\t\"OTS$CVTQUX\" },\n-      { FLOAT_EXTEND,\t\"OTS$CVT_FLOAT_T_X\" },\n-      { FLOAT_TRUNCATE,\t\"OTS$CVT_FLOAT_X_T\" },\n-    };\n-\n-  static const struct xfloating_op osf_xfloating_ops[] = \n-    {\n-      { PLUS,\t\t\"_OtsAddX\" },\n-      { MINUS,\t\t\"_OtsSubX\" },\n-      { MULT,\t\t\"_OtsMulX\" },\n-      { DIV,\t\t\"_OtsDivX\" },\n-      { EQ,\t\t\"_OtsEqlX\" },\n-      { NE,\t\t\"_OtsNeqX\" },\n-      { LT,\t\t\"_OtsLssX\" },\n-      { LE,\t\t\"_OtsLeqX\" },\n-      { GT,\t\t\"_OtsGtrX\" },\n-      { GE,\t\t\"_OtsGeqX\" },\n-      { FIX,\t\t\"_OtsCvtXQ\" },\n-      { FLOAT,\t\t\"_OtsCvtQX\" },\n-      { UNSIGNED_FLOAT,\t\"_OtsCvtQUX\" },\n-      { FLOAT_EXTEND,\t\"_OtsConvertFloatTX\" },\n-      { FLOAT_TRUNCATE,\t\"_OtsConvertFloatXT\" },\n-    };\n-\n-  const struct xfloating_op *ops;\n-  const long n = ARRAY_SIZE (osf_xfloating_ops);\n+  struct xfloating_op *ops = xfloating_ops;\n+  long n = ARRAY_SIZE (xfloating_ops);\n   long i;\n \n-  /* How irritating.  Nothing to key off for the table.  Hardcode\n-     knowledge of the G_floating routines.  */\n-  if (TARGET_FLOAT_VAX)\n+  /* How irritating.  Nothing to key off for the main table.  */\n+  if (TARGET_FLOAT_VAX && (code == FLOAT_EXTEND || code == FLOAT_TRUNCATE))\n     {\n-      if (TARGET_ABI_OPEN_VMS)\n-\t{\n-\t  if (code == FLOAT_EXTEND)\n-\t    return \"OTS$CVT_FLOAT_G_X\";\n-\t  if (code == FLOAT_TRUNCATE)\n-\t    return \"OTS$CVT_FLOAT_X_G\";\n-\t}\n-      else\n-\t{\n-\t  if (code == FLOAT_EXTEND)\n-\t    return \"_OtsConvertFloatGX\";\n-\t  if (code == FLOAT_TRUNCATE)\n-\t    return \"_OtsConvertFloatXG\";\n-\t}\n+      ops = vax_cvt_ops;\n+      n = ARRAY_SIZE (vax_cvt_ops);\n     }\n \n-  if (TARGET_ABI_OPEN_VMS)\n-    ops = vms_xfloating_ops;\n-  else\n-    ops = osf_xfloating_ops;\n-\n-  for (i = 0; i < n; ++i)\n-    if (ops[i].code == code)\n-      return ops[i].func;\n+  for (i = 0; i < n; ++i, ++ops)\n+    if (ops->code == code)\n+      {\n+\trtx func = ops->libcall;\n+\tif (!func)\n+\t  {\n+\t    func = init_one_libfunc (TARGET_ABI_OPEN_VMS\n+\t\t\t\t     ? ops->vms_func : ops->osf_func);\n+\t    ops->libcall = func;\n+\t  }\n+        return func;\n+      }\n \n   abort();\n }\n@@ -3688,15 +3668,15 @@ alpha_compute_xfloating_mode_arg (enum rtx_code code,\n    TFmode arguments are passed in two integer registers (as opposed to\n    indirect); TFmode return values appear in R16+R17. \n \n-   FUNC is the function name to call.\n+   FUNC is the function to call.\n    TARGET is where the output belongs.\n    OPERANDS are the inputs.\n    NOPERANDS is the count of inputs.\n    EQUIV is the expression equivalent for the function.\n */\n \n static void\n-alpha_emit_xfloating_libcall (const char *func, rtx target, rtx operands[],\n+alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n \t\t\t      int noperands, rtx equiv)\n {\n   rtx usage = NULL_RTX, tmp, reg;\n@@ -3750,10 +3730,11 @@ alpha_emit_xfloating_libcall (const char *func, rtx target, rtx operands[],\n       abort ();\n     }\n \n-  tmp = gen_rtx_MEM (QImode, init_one_libfunc (func));\n+  tmp = gen_rtx_MEM (QImode, func);\n   tmp = emit_call_insn (GEN_CALL_VALUE (reg, tmp, const0_rtx,\n \t\t\t\t\tconst0_rtx, const0_rtx));\n   CALL_INSN_FUNCTION_USAGE (tmp) = usage;\n+  CONST_OR_PURE_CALL_P (tmp) = 1;\n \n   tmp = get_insns ();\n   end_sequence ();\n@@ -3766,7 +3747,7 @@ alpha_emit_xfloating_libcall (const char *func, rtx target, rtx operands[],\n void\n alpha_emit_xfloating_arith (enum rtx_code code, rtx operands[])\n {\n-  const char *func;\n+  rtx func;\n   int mode;\n   rtx out_operands[3];\n \n@@ -3786,7 +3767,7 @@ alpha_emit_xfloating_arith (enum rtx_code code, rtx operands[])\n static rtx\n alpha_emit_xfloating_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n-  const char *func;\n+  rtx func;\n   rtx out, operands[2];\n \n   func = alpha_lookup_xfloating_lib_func (code);\n@@ -3810,7 +3791,7 @@ alpha_emit_xfloating_cvt (enum rtx_code orig_code, rtx operands[])\n {\n   int noperands = 1, mode;\n   rtx out_operands[2];\n-  const char *func;\n+  rtx func;\n   enum rtx_code code = orig_code;\n \n   if (code == UNSIGNED_FIX)"}, {"sha": "64c88e323329db5bc793ab20475efc6eeb03fcd2", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75959f0a1d2debc18aedd1a846700184e1f90632/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75959f0a1d2debc18aedd1a846700184e1f90632/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=75959f0a1d2debc18aedd1a846700184e1f90632", "patch": "@@ -2630,9 +2630,12 @@\n    st%- %1,%0\"\n   [(set_attr \"type\" \"fcpys,fld,fst\")])\n \n+;; Use register_operand for operand 1 to prevent compress_float_constant\n+;; from doing something silly.  When optimizing we'll put things back \n+;; together anyway.\n (define_expand \"extendsftf2\"\n   [(use (match_operand:TF 0 \"register_operand\" \"\"))\n-   (use (match_operand:SF 1 \"general_operand\" \"\"))]\n+   (use (match_operand:SF 1 \"register_operand\" \"\"))]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n {\n   rtx tmp = gen_reg_rtx (DFmode);\n@@ -2643,7 +2646,7 @@\n \n (define_expand \"extenddftf2\"\n   [(use (match_operand:TF 0 \"register_operand\" \"\"))\n-   (use (match_operand:DF 1 \"general_operand\" \"\"))]\n+   (use (match_operand:DF 1 \"register_operand\" \"\"))]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n   \"alpha_emit_xfloating_cvt (FLOAT_EXTEND, operands); DONE;\")\n "}]}