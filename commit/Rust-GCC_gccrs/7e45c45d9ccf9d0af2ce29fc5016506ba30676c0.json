{"sha": "7e45c45d9ccf9d0af2ce29fc5016506ba30676c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0NWM0NWQ5Y2NmOWQwYWYyY2UyOWZjNTAxNjUwNmJhMzA2NzZjMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-09T12:43:16Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-09T12:43:16Z"}, "message": "testsuite: Tweak mem-shift-canonical.c\n\nmem-shift-canonical.c started failing after the fix for PR97684.\nWe used to generate things like:\n\n        add     x7, x1, x5, lsl 2       // 54   [c=4 l=4]  *add_lsl_di\n        ld1     {v0.s}[1], [x7] // 18   [c=4 l=4]  aarch64_simd_vec_setv4si/2\n\nwhere the add_lsl_di was generated by LRA.  After PR97684 we generate:\n\n        ldr     s1, [x1, x5, lsl 2]     // 17   [c=4 l=4]  *zero_extendsidi2_aarch64/3\n        ins     v0.s[1], v1.s[0]        // 18   [c=4 l=4]  aarch64_simd_vec_setv4si/0\n\nWhich one is better is an interesting question.  However, it was really\nonly a fluke that we generated the original code.  The pseudo that\nbecomes s1 in the new code above has a REG_EQUIV note:\n\n(insn 17 16 18 3 (set (reg:SI 111 [ MEM[(int *)b_25(D) + ivtmp.9_30 * 4] ])\n        (mem:SI (plus:DI (mult:DI (reg:DI 101 [ ivtmp.9 ])\n                    (const_int 4 [0x4]))\n                (reg/v/f:DI 105 [ b ])) [2 MEM[(int *)b_25(D) + ivtmp.9_30 * 4]+0 S4 A32])) \"gcc/testsuite/gcc.target/aarch64/mem-shift-canonical.c\":21:18 52 {*movsi_aarch64}\n     (expr_list:REG_EQUIV (mem:SI (plus:DI (mult:DI (reg:DI 101 [ ivtmp.9 ])\n                    (const_int 4 [0x4]))\n                (reg/v/f:DI 105 [ b ])) [2 MEM[(int *)b_25(D) + ivtmp.9_30 * 4]+0 S4 A32])\n        (nil)))\n(insn 18 17 19 3 (set (reg:V4SI 109 [ MEM[(int *)a_23(D) + ivtmp.9_30 * 4] ])\n        (vec_merge:V4SI (vec_duplicate:V4SI (reg:SI 111 [ MEM[(int *)b_25(D) + ivtmp.9_30 * 4] ]))\n            (subreg:V4SI (reg:SI 110 [ MEM[(int *)a_23(D) + ivtmp.9_30 * 4] ]) 0)\n            (const_int 2 [0x2]))) \"gcc/testsuite/gcc.target/aarch64/mem-shift-canonical.c\":21:18 1683 {aarch64_simd_vec_setv4si}\n     (expr_list:REG_DEAD (reg:SI 111 [ MEM[(int *)b_25(D) + ivtmp.9_30 * 4] ])\n        (expr_list:REG_DEAD (reg:SI 110 [ MEM[(int *)a_23(D) + ivtmp.9_30 * 4] ])\n            (nil))))\n\nBefore the PR, IRA didn't allocate a register to r111 and so LRA\nrematerialised the REG_EQUIV note inside insn 18, leading to the\nreload.  Now IRA allocates a register instead.\n\nSo I think this is working as expected, in the sense that IRA is now\ndoing what the backend asked it to do.  If the backend prefers the first\nversion (and it might not), it needs to do more than it's currently\ndoing to promote the use of lane loads.  E.g. it should probably have a\ncombine define_split that splits the combination of insn 17 and insn 18\ninto an ADD + an LD1.\n\nI think for now the best thing is to use a different approach to\ntriggering the original bug.  The asm in the new test ICEs with the\nr11-2903 LRA patch reverted and passes with it applied.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/mem-shift-canonical.c: Use an asm instead\n\tof relying on vectorisation.", "tree": {"sha": "a0d4e71a24b5ee19301dbfd187a619bc3e26bf37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0d4e71a24b5ee19301dbfd187a619bc3e26bf37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e45c45d9ccf9d0af2ce29fc5016506ba30676c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e45c45d9ccf9d0af2ce29fc5016506ba30676c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e45c45d9ccf9d0af2ce29fc5016506ba30676c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e45c45d9ccf9d0af2ce29fc5016506ba30676c0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a54db29387c4e936ab99499bf4d3e1649e92800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a54db29387c4e936ab99499bf4d3e1649e92800", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a54db29387c4e936ab99499bf4d3e1649e92800"}], "stats": {"total": 26, "additions": 5, "deletions": 21}, "files": [{"sha": "e3c83e8b32d42a50775180ce7272fdf27b8e58f2", "filename": "gcc/testsuite/gcc.target/aarch64/mem-shift-canonical.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e45c45d9ccf9d0af2ce29fc5016506ba30676c0/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmem-shift-canonical.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e45c45d9ccf9d0af2ce29fc5016506ba30676c0/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmem-shift-canonical.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmem-shift-canonical.c?ref=7e45c45d9ccf9d0af2ce29fc5016506ba30676c0", "patch": "@@ -1,28 +1,12 @@\n-/* This test is a copy of gcc.dg/torture/pr34330.c: here we are looking for\n-   specific patterns being matched in the AArch64 backend.  */\n-\n /* { dg-do compile } */\n-/* { dg-options \"-Os -ftree-vectorize -dp\" } */\n+/* { dg-options \"-O2 -dp\" } */\n /* { dg-require-effective-target lp64 } */\n \n-\n-struct T\n-{\n-  int t;\n-  struct { short s1, s2, s3, s4; } *s;\n-};\n-\n void\n-foo (int *a, int *b, int *c, int *d, struct T *e)\n+f (int x0, int *x1, long x2)\n {\n-  int i;\n-  for (i = 0; i < e->t; i++)\n-    {\n-      e->s[i].s1 = a[i];\n-      e->s[i].s2 = b[i];\n-      e->s[i].s3 = c[i];\n-      e->s[i].s4 = d[i];\n-    }\n+  asm volatile (\"// foo %0 %1\"\n+\t\t:: \"r,w\" (x0), \"Q,m\" (x1[x2]));\n }\n \n-/* { dg-final { scan-assembler-times \"add_lsl_di\" 3 } } */\n+/* { dg-final { scan-assembler-times \"add_lsl_di\" 1 } } */"}]}