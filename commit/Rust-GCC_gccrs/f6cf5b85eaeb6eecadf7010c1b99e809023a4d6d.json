{"sha": "f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZjZjViODVlYWViNmVlY2FkZjcwMTBjMWI5OWU4MDkwMjNhNGQ2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-09T10:22:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-09T10:22:49Z"}, "message": "[multiple changes]\n\n2009-07-09  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-nmsc.adb (Find_Sources): Avoid error messages from gprbuild from\n\tmulti-unit files.\n\n2009-07-09  Thomas Quinot  <quinot@adacore.com>\n\n\t* freeze.adb: Minor reformatting\n\n\t* exp_ch3.adb: Minor comment fix.\n\n\t* sinfo.ads: Minor comment fix\n\n2009-07-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Conditional_Expression): Set Related_Expression.\n\nFrom-SVN: r149411", "tree": {"sha": "b860e9e79571c0cf4c70ae107d8c65d89b8adf69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b860e9e79571c0cf4c70ae107d8c65d89b8adf69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/comments", "author": null, "committer": null, "parents": [{"sha": "7aedb36acbf75714d3b89db8ceebf9209c3dc02f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aedb36acbf75714d3b89db8ceebf9209c3dc02f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aedb36acbf75714d3b89db8ceebf9209c3dc02f"}], "stats": {"total": 310, "additions": 170, "deletions": 140}, "files": [{"sha": "98c4161724c931f607088c2508a8708d222bba08", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "patch": "@@ -1,3 +1,20 @@\n+2009-07-09  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-nmsc.adb (Find_Sources): Avoid error messages from gprbuild from\n+\tmulti-unit files.\n+\n+2009-07-09  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb: Minor reformatting\n+\n+\t* exp_ch3.adb: Minor comment fix.\n+\n+\t* sinfo.ads: Minor comment fix\n+\n+2009-07-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Conditional_Expression): Set Related_Expression.\n+\n 2009-07-09  Ed Schonberg  <schonberg@adacore.com>\n \n \t* freeze.adb (Freeze_Expression): If the expression is the name of a"}, {"sha": "8cacbeb880e809266d22bcfd36c0a200fa1960de", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "patch": "@@ -6014,7 +6014,7 @@ package body Exp_Ch3 is\n             Append_Freeze_Actions (Def_Id, Wrapper_Body_List);\n          end if;\n \n-         --  Create extra actuals for the primitive operations of the type.\n+         --  Create extra formals for the primitive operations of the type.\n          --  This must be done before analyzing the body of the initialization\n          --  procedure, because a self-referential type might call one of these\n          --  primitives in the body of the init_proc itself."}, {"sha": "d25ff36d845893404fbcdc4f7fd60c588d63c368", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "patch": "@@ -4046,8 +4046,8 @@ package body Exp_Ch4 is\n                  Name => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n                  Expression => Relocate_Node (Elsex))));\n \n-         --  Move the SLOC of the parent If statement to the newly created\n-         --  one and change it to the SLOC of the expression which, after\n+         --  Move the SLOC of the parent If statement to the newly created one\n+         --  and change it to the SLOC of the expression which, after\n          --  expansion, will correspond to what is being evaluated.\n \n          if Present (Parent (N))\n@@ -4079,6 +4079,10 @@ package body Exp_Ch4 is\n \n          Insert_Action (N, New_If);\n          Analyze_And_Resolve (N, Typ);\n+\n+         --  Link temporary to original expression, for Codepeer\n+\n+         Set_Related_Expression (Cnn, Original_Node (N));\n       end if;\n    end Expand_N_Conditional_Expression;\n "}, {"sha": "e66dc14f10106e3b3c70d2e41593c159943b66e5", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "patch": "@@ -4014,7 +4014,7 @@ package body Freeze is\n \n       --  For a function, we freeze the entity when the subprogram declaration\n       --  is frozen, but a function call may appear in an initialization proc.\n-      --  before the  declaration  is frozen. We need to generate  the extra\n+      --  before the declaration is frozen. We need to generate the extra\n       --  formals, if any, to ensure that the expansion of the call includes\n       --  the proper actuals.\n \n@@ -4067,12 +4067,12 @@ package body Freeze is\n          return;\n       end if;\n \n-      --  Loop for looking at the right place to insert the freeze nodes\n+      --  Loop for looking at the right place to insert the freeze nodes,\n       --  exiting from the loop when it is appropriate to insert the freeze\n       --  node before the current node P.\n \n-      --  Also checks some special exceptions to the freezing rules. These\n-      --  cases result in a direct return, bypassing the freeze action.\n+      --  Also checks som special exceptions to the freezing rules. These cases\n+      --  result in a direct return, bypassing the freeze action.\n \n       P := N;\n       loop"}, {"sha": "2ff40e407065948caea16d981163f84cb0b4db71", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 141, "deletions": 132, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "patch": "@@ -130,9 +130,8 @@ package body Prj.Nmsc is\n       Key        => Name_Id,\n       Hash       => Hash,\n       Equal      => \"=\");\n-   --  Hash table to store recursive source directories, to avoid looking\n-   --  several times, and to avoid cycles that may be introduced by symbolic\n-   --  links.\n+   --  Hash table stores recursive source directories, to avoid looking several\n+   --  times, and to avoid cycles that may be introduced by symbolic links.\n \n    type Ada_Naming_Exception_Id is new Nat;\n    No_Ada_Naming_Exception : constant Ada_Naming_Exception_Id := 0;\n@@ -428,14 +427,11 @@ package body Prj.Nmsc is\n       Unit                  : out Name_Id;\n       Lang_Kind             : out Language_Kind;\n       Kind                  : out Source_Kind);\n-   --  Check if the file name File_Name conforms to one of the naming\n-   --  schemes of the project.\n-   --\n-   --  If the file does not match one of the naming schemes, set Language\n-   --  to No_Language_Index.\n-   --\n-   --  Filename is the name of the file being investigated. It has been\n-   --  normalized (case-folded). File_Name is the same value.\n+   --  Check if the file name File_Name conforms to one of the naming schemes\n+   --  of the project. If the file does not match one of the naming schemes,\n+   --  set Language to No_Language_Index. Filename is the name of the file\n+   --  being investigated. It has been normalized (case-folded). File_Name is\n+   --  the same value.\n \n    procedure Free_Ada_Naming_Exceptions;\n    --  Free the internal hash tables used for checking naming exceptions\n@@ -445,10 +441,8 @@ package body Prj.Nmsc is\n       In_Tree     : Project_Tree_Ref;\n       Current_Dir : String);\n    --  Get the object directory, the exec directory and the source directories\n-   --  of a project.\n-   --\n-   --  Current_Dir should represent the current directory, and is passed for\n-   --  efficiency to avoid system calls to recompute it.\n+   --  of a project. Current_Dir should represent the current directory, and is\n+   --  passed for efficiency to avoid system calls to recompute it.\n \n    procedure Get_Mains\n      (Project : Project_Id;\n@@ -469,13 +463,12 @@ package body Prj.Nmsc is\n       In_Tree   : Project_Tree_Ref;\n       Proc_Data : in out Processing_Data;\n       Allow_Duplicate_Basenames : Boolean);\n-   --  Process the Source_Files and Source_List_File attributes, and store\n-   --  the list of source files into the Source_Names htable.\n-   --  When these attributes are not defined, find all files matching the\n-   --  naming schemes in the source directories.\n-   --  If Allow_Duplicate_Basenames, then files with the same base names are\n-   --  authorized within a project for source-based languages (never for unit\n-   --  based languages)\n+   --  Process the Source_Files and Source_List_File attributes, and store the\n+   --  list of source files into the Source_Names htable. When these attributes\n+   --  are not defined, find all files matching the naming schemes in the\n+   --  source directories. If Allow_Duplicate_Basenames, then files with the\n+   --  same base names are authorized within a project for source-based\n+   --  languages (never for unit based languages)\n \n    procedure Compute_Unit_Name\n      (File_Name : File_Name_Type;\n@@ -516,18 +509,15 @@ package body Prj.Nmsc is\n       Location         : Source_Ptr := No_Location;\n       Must_Exist       : Boolean := True;\n       Externally_Built : Boolean := False);\n-   --  Locate a directory. Name is the directory name.\n-   --  Relative paths are resolved relative to the project's directory.\n-   --  If the directory does not exist and Setup_Projects\n-   --  is True and Create is a non null string, an attempt is made to create\n-   --  the directory.\n-   --  If the directory does not exist, it is either created if Setup_Projects\n-   --  is False (and then returned), or simply returned without checking for\n-   --  its existence (if Must_Exist is False) or No_Path_Information is\n-   --  returned. In all cases, Dir_Exists indicates whether the directory now\n-   --  exists.\n-   --\n-   --  Create is also used for debugging traces to show which path we are\n+   --  Locate a directory. Name is the directory name. Relative paths are\n+   --  resolved relative to the project's directory. If the directory does not\n+   --  exist and Setup_Projects is True and Create is a non null string, an\n+   --  attempt is made to create the directory. If the directory does not\n+   --  exist, it is either created if Setup_Projects is False (and then\n+   --  returned), or simply returned without checking for its existence (if\n+   --  Must_Exist is False) or No_Path_Information is returned. In all cases,\n+   --  Dir_Exists indicates whether the directory now exists. Create is also\n+   --  used for debugging traces to show which path we are\n    --  computing\n \n    procedure Look_For_Sources\n@@ -643,15 +633,16 @@ package body Prj.Nmsc is\n       Suffix   : File_Name_Type) return Boolean\n    is\n       Min_Prefix_Length : Natural := 0;\n+\n    begin\n       if Suffix = No_File or else Suffix = Empty_File then\n          return False;\n       end if;\n \n       declare\n          Suf : constant String := Get_Name_String (Suffix);\n-      begin\n \n+      begin\n          --  The file name must end with the suffix (which is not an extension)\n          --  For instance a suffix \"configure.in\" must match a file with the\n          --  same name. To avoid dummy cases, though, a suffix starting with\n@@ -701,8 +692,8 @@ package body Prj.Nmsc is\n       Index               : Int       := 0;\n       Source_To_Replace   : Source_Id := No_Source)\n    is\n-      Config   : constant Language_Config := Lang_Id.Config;\n-      UData    : Unit_Index;\n+      Config : constant Language_Config := Lang_Id.Config;\n+      UData  : Unit_Index;\n \n    begin\n       Id := new Source_Data;\n@@ -713,11 +704,14 @@ package body Prj.Nmsc is\n \n          if Lang_Id.Config.Kind = Unit_Based then\n             Write_Str (\" Unit: \");\n+\n             --  ??? in gprclean, it seems we sometimes pass an empty Unit name\n-            --  (see test extended_projects)\n+            --  (see test extended_projects).\n+\n             if Unit /= No_Name then\n                Write_Str (Get_Name_String (Unit));\n             end if;\n+\n             Write_Str (\" Kind: \");\n             Write_Str (Source_Kind'Image (Kind));\n          end if;\n@@ -743,7 +737,7 @@ package body Prj.Nmsc is\n          UData := Units_Htable.Get (In_Tree.Units_HT, Unit);\n \n          if UData = No_Unit_Index then\n-            UData      := new Unit_Data;\n+            UData := new Unit_Data;\n             UData.Name := Unit;\n             Units_Htable.Set (In_Tree.Units_HT, Unit, UData);\n          end if;\n@@ -831,8 +825,8 @@ package body Prj.Nmsc is\n       Compiler_Driver_Mandatory : Boolean;\n       Allow_Duplicate_Basenames : Boolean)\n    is\n-      Specs : Array_Element_Id;\n-      Bodies : Array_Element_Id;\n+      Specs     : Array_Element_Id;\n+      Bodies    : Array_Element_Id;\n       Extending : Boolean := False;\n \n    begin\n@@ -883,8 +877,8 @@ package body Prj.Nmsc is\n             else\n                Error_Msg\n                  (Project, In_Tree,\n-                  \"at least one of Source_Files, Source_Dirs or Languages \" &\n-                  \"must be declared empty for an abstract project\",\n+                  \"at least one of Source_Files, Source_Dirs or Languages \"\n+                    & \"must be declared empty for an abstract project\",\n                   Project.Location);\n             end if;\n          end;\n@@ -940,19 +934,18 @@ package body Prj.Nmsc is\n                (not Extending)\n          then\n             declare\n-               Language      : Language_Ptr;\n-               Source        : Source_Id;\n-               Alt_Lang      : Language_List;\n-               Continuation  : Boolean := False;\n-               Iter          : Source_Iterator;\n+               Language     : Language_Ptr;\n+               Source       : Source_Id;\n+               Alt_Lang     : Language_List;\n+               Continuation : Boolean := False;\n+               Iter         : Source_Iterator;\n \n             begin\n                Language := Project.Languages;\n                while Language /= No_Language_Index loop\n \n-                  --  If there are no sources for this language, check whether\n-                  --  there are sources for which this is an alternate\n-                  --  language.\n+                  --  If there are no sources for this language, check if there\n+                  --  are sources for which this is an alternate language.\n \n                   if Language.First_Source = No_Source then\n                      Iter := For_Each_Source (In_Tree => In_Tree,\n@@ -1141,6 +1134,7 @@ package body Prj.Nmsc is\n          elsif The_Name (Index) = '.' then\n \n             --  First, check if the name before the dot is not a reserved word\n+\n             if Is_Reserved (The_Name (First .. Index - 1)) then\n                return;\n             end if;\n@@ -1716,6 +1710,7 @@ package body Prj.Nmsc is\n             Current_Array    : Array_Data;\n             Element_Id       : Array_Element_Id;\n             Element          : Array_Element;\n+\n          begin\n             --  Process the associative array attribute of package Naming\n \n@@ -2368,6 +2363,8 @@ package body Prj.Nmsc is\n          end loop;\n       end Process_Project_Level_Array_Attributes;\n \n+   --  Start of processing for Check_Configuration\n+\n    begin\n       Process_Project_Level_Simple_Attributes;\n       Process_Project_Level_Array_Attributes;\n@@ -2410,6 +2407,7 @@ package body Prj.Nmsc is\n \n       Lang_Index := Project.Languages;\n       while Lang_Index /= No_Language_Index loop\n+\n          --  For all languages, Compiler_Driver needs to be specified. This is\n          --  only needed if we do intend to compile (not in GPS for instance).\n \n@@ -2559,7 +2557,6 @@ package body Prj.Nmsc is\n          Project_2 := Project;\n          while Project_2 /= No_Project loop\n             Iter := For_Each_Source (In_Tree, Project_2);\n-\n             loop\n                Source := Prj.Element (Iter);\n                exit when Source = No_Source;\n@@ -2835,6 +2832,7 @@ package body Prj.Nmsc is\n             declare\n                Casing_Image : constant String :=\n                                 Get_Name_String (Casing_String.Value);\n+\n             begin\n                if Casing_Image'Length = 0 then\n                   Error_Msg\n@@ -3130,7 +3128,7 @@ package body Prj.Nmsc is\n \n       procedure Check_Naming_Ada_Only is\n          Ada : constant Language_Ptr :=\n-           Get_Language_From_Name (Project, \"ada\");\n+                 Get_Language_From_Name (Project, \"ada\");\n \n          Casing_Defined : Boolean;\n          Sep_Suffix_Loc : Source_Ptr;\n@@ -3250,7 +3248,7 @@ package body Prj.Nmsc is\n          --  For all unit based languages, if any, set the specified value\n          --  of Dot_Replacement, Casing and/or Separate_Suffix. Do not\n          --  systematically overwrite, since the defaults come from the\n-         --  configuration file\n+         --  configuration file.\n \n          if Dot_Replacement /= No_File\n            or else Casing_Defined\n@@ -3407,8 +3405,7 @@ package body Prj.Nmsc is\n                end if;\n             end if;\n \n-            --  If the language was not found in project or the projects it\n-            --  extends\n+            --  If language was not found in project or the projects it extends\n \n             if Lang = null then\n                if Current_Verbosity = High then\n@@ -3714,6 +3711,7 @@ package body Prj.Nmsc is\n             end if;\n \n             if not Dir_Exists then\n+\n                --  Get the absolute name of the library directory that\n                --  does not exist, to report an error.\n \n@@ -3897,6 +3895,7 @@ package body Prj.Nmsc is\n                   Externally_Built => Project.Externally_Built);\n \n                if not Dir_Exists then\n+\n                   --  Get the absolute name of the library ALI directory that\n                   --  does not exist, to report an error.\n \n@@ -3998,8 +3997,7 @@ package body Prj.Nmsc is\n \n                         elsif Current_Verbosity = High then\n \n-                           --  Display the Library ALI directory in high\n-                           --  verbosity.\n+                           --  Display Library ALI directory in high verbosity\n \n                            Write_Attr\n                              (\"Library ALI dir\",\n@@ -4197,9 +4195,15 @@ package body Prj.Nmsc is\n       --  Add a new language to the list of languages for the project.\n       --  Nothing is done if the language has already been defined\n \n+      ------------------\n+      -- Add_Language --\n+      ------------------\n+\n       procedure Add_Language (Name, Display_Name : Name_Id) is\n-         Lang : Language_Ptr := Project.Languages;\n+         Lang : Language_Ptr;\n+\n       begin\n+         Lang := Project.Languages;\n          while Lang /= No_Language_Index loop\n             if Name = Lang.Name then\n                return;\n@@ -4219,10 +4223,11 @@ package body Prj.Nmsc is\n             Lang.Config.Dependency_Kind := ALI_File;\n \n             if Get_Mode = Ada_Only then\n+\n                --  Create a default config for Ada (since there is no\n-               --  configuration file to create it for us)\n-               --  ??? We should do as GPS does and create a dummy config\n-               --  file\n+               --  configuration file to create it for us).\n+\n+               --  ??? We should do as GPS does and create a dummy config file\n \n                Lang.Config.Naming_Data :=\n                  (Dot_Replacement => File_Name_Type\n@@ -4615,6 +4620,7 @@ package body Prj.Nmsc is\n                      if Source /= No_Source then\n                         if Source.Kind = Sep then\n                            Source := No_Source;\n+\n                         elsif Source.Kind = Spec\n                           and then Other_Part (Source) /= No_Source\n                         then\n@@ -4724,8 +4730,8 @@ package body Prj.Nmsc is\n \n          if Lib_Src_Dir.Value /= Empty_String then\n             declare\n-               Dir_Id : constant File_Name_Type :=\n-                          File_Name_Type (Lib_Src_Dir.Value);\n+               Dir_Id     : constant File_Name_Type :=\n+                              File_Name_Type (Lib_Src_Dir.Value);\n                Dir_Exists : Boolean;\n \n             begin\n@@ -4743,6 +4749,7 @@ package body Prj.Nmsc is\n                --  If directory does not exist, report an error\n \n                if not Dir_Exists then\n+\n                   --  Get the absolute name of the library directory that does\n                   --  not exist, to report an error.\n \n@@ -5055,7 +5062,7 @@ package body Prj.Nmsc is\n    begin\n       if Dir'Length > 1\n         and then (Dir (Dir'Last - 1) = Directory_Separator\n-                  or else Dir (Dir'Last - 1) = '/')\n+                   or else Dir (Dir'Last - 1) = '/')\n       then\n          return Dir'Last - 1;\n       else\n@@ -5361,8 +5368,7 @@ package body Prj.Nmsc is\n                   Write_Line (The_Path (The_Path'First .. The_Path_Last));\n                end if;\n \n-               String_Element_Table.Increment_Last\n-                 (In_Tree.String_Elements);\n+               String_Element_Table.Increment_Last (In_Tree.String_Elements);\n                Element :=\n                  (Value         => Canonical_Path,\n                   Display_Value => Non_Canonical_Path,\n@@ -5374,8 +5380,8 @@ package body Prj.Nmsc is\n                --  Case of first source directory\n \n                if Last_Source_Dir = Nil_String then\n-                  Project.Source_Dirs := String_Element_Table.Last\n-                                        (In_Tree.String_Elements);\n+                  Project.Source_Dirs :=\n+                    String_Element_Table.Last (In_Tree.String_Elements);\n \n                   --  Here we already have source directories\n \n@@ -5384,16 +5390,14 @@ package body Prj.Nmsc is\n \n                   In_Tree.String_Elements.Table\n                     (Last_Source_Dir).Next :=\n-                      String_Element_Table.Last\n-                        (In_Tree.String_Elements);\n+                      String_Element_Table.Last (In_Tree.String_Elements);\n                end if;\n \n                --  And register this source directory as the new last\n \n-               Last_Source_Dir  := String_Element_Table.Last\n-                 (In_Tree.String_Elements);\n-               In_Tree.String_Elements.Table (Last_Source_Dir) :=\n-                 Element;\n+               Last_Source_Dir :=\n+                 String_Element_Table.Last (In_Tree.String_Elements);\n+               In_Tree.String_Elements.Table (Last_Source_Dir) := Element;\n \n             elsif Removed and Found then\n                if Prev = Nil_String then\n@@ -5544,10 +5548,10 @@ package body Prj.Nmsc is\n \n          else\n             declare\n-               Path_Name         : Path_Information;\n-               List              : String_List_Id;\n-               Prev              : String_List_Id;\n-               Dir_Exists        : Boolean;\n+               Path_Name  : Path_Information;\n+               List       : String_List_Id;\n+               Prev       : String_List_Id;\n+               Dir_Exists : Boolean;\n \n             begin\n                Locate_Directory\n@@ -5714,8 +5718,7 @@ package body Prj.Nmsc is\n             --  However, even when it doesn't exist, we set it to a default\n             --  value. This is for the benefit of tools that recover from\n             --  errors; for example, these tools could create the non existent\n-            --  directory.\n-            --  We always return an absolute directory name though\n+            --  directory. We always return an absolute directory name though.\n \n             Locate_Directory\n               (Project,\n@@ -5825,8 +5828,8 @@ package body Prj.Nmsc is\n \n       pragma Assert (Source_Dirs.Kind = List, \"Source_Dirs is not a list\");\n \n-      if (not Source_Files.Default) and then\n-        Source_Files.Values = Nil_String\n+      if (not Source_Files.Default)\n+        and then Source_Files.Values = Nil_String\n       then\n          Project.Source_Dirs := Nil_String;\n \n@@ -5841,7 +5844,7 @@ package body Prj.Nmsc is\n       elsif Source_Dirs.Default then\n \n          --  No Source_Dirs specified: the single source directory is the one\n-         --  containing the project file\n+         --  containing the project file.\n \n          String_Element_Table.Append (In_Tree.String_Elements,\n            (Value         => Name_Id (Project.Directory.Name),\n@@ -5850,8 +5853,8 @@ package body Prj.Nmsc is\n             Flag          => False,\n             Next          => Nil_String,\n             Index         => 0));\n-         Project.Source_Dirs := String_Element_Table.Last\n-                                  (In_Tree.String_Elements);\n+         Project.Source_Dirs :=\n+           String_Element_Table.Last (In_Tree.String_Elements);\n \n          if Current_Verbosity = High then\n             Write_Attr\n@@ -6077,8 +6080,8 @@ package body Prj.Nmsc is\n       Unit      : out Name_Id;\n       In_Tree   : Project_Tree_Ref)\n    is\n-      Filename : constant String := Get_Name_String (File_Name);\n-      Last     : Integer := Filename'Last;\n+      Filename : constant String  := Get_Name_String (File_Name);\n+      Last     : Integer          := Filename'Last;\n       Sep_Len  : constant Integer :=\n                    Integer (Length_Of_Name (Naming.Separate_Suffix));\n       Body_Len : constant Integer :=\n@@ -6346,11 +6349,11 @@ package body Prj.Nmsc is\n             Unit_Kind := Spec;\n          else\n             Compute_Unit_Name\n-              (File_Name       => Canonical_File_Name,\n-               Naming          => Lang.Config.Naming_Data,\n-               Kind            => Kind,\n-               Unit            => Unit_Name,\n-               In_Tree         => In_Tree);\n+              (File_Name => Canonical_File_Name,\n+               Naming    => Lang.Config.Naming_Data,\n+               Kind      => Kind,\n+               Unit      => Unit_Name,\n+               In_Tree   => In_Tree);\n \n             case Kind is\n                when Spec       => Unit_Kind := Spec;\n@@ -6594,8 +6597,7 @@ package body Prj.Nmsc is\n       Locally_Removed : Boolean := False;\n \n    begin\n-      --  If Excluded_Source_Files is not declared, check\n-      --  Locally_Removed_Files.\n+      --  If Excluded_Source_Files is not declared, check Locally_Removed_Files\n \n       if Excluded_Sources.Default then\n          Locally_Removed := True;\n@@ -6683,8 +6685,7 @@ package body Prj.Nmsc is\n                      then\n                         Name_Len := Last;\n                         Name_Buffer (1 .. Name_Len) := Line (1 .. Last);\n-                        Canonical_Case_File_Name\n-                          (Name_Buffer (1 .. Name_Len));\n+                        Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n                         Name := Name_Find;\n \n                         --  Check that there is no directory information\n@@ -6726,18 +6727,19 @@ package body Prj.Nmsc is\n       Proc_Data                 : in out Processing_Data;\n       Allow_Duplicate_Basenames : Boolean)\n    is\n-      Sources          : constant Variable_Value :=\n-                           Util.Value_Of\n-                             (Name_Source_Files,\n-                              Project.Decl.Attributes,\n-                              In_Tree);\n+      Sources : constant Variable_Value :=\n+                  Util.Value_Of\n+                    (Name_Source_Files,\n+                    Project.Decl.Attributes,\n+                    In_Tree);\n+\n       Source_List_File : constant Variable_Value :=\n                            Util.Value_Of\n                              (Name_Source_List_File,\n                               Project.Decl.Attributes,\n                               In_Tree);\n-      Name_Loc         : Name_Location;\n \n+      Name_Loc             : Name_Location;\n       Has_Explicit_Sources : Boolean;\n \n    begin\n@@ -6913,12 +6915,21 @@ package body Prj.Nmsc is\n               and then Source.Path = No_Path_Information\n             then\n                if Source.Unit /= No_Unit_Index then\n-                  Error_Msg_Name_1 := Name_Id (Source.Display_File);\n-                  Error_Msg_Name_2 := Name_Id (Source.Unit.Name);\n-                  Error_Msg\n-                    (Project, In_Tree,\n-                     \"source file %% for unit %% not found\",\n-                     No_Location);\n+\n+                  --  ??? Current limitation of gprbuild will display this\n+                  --  error message for multi-unit source files, because not\n+                  --  all instances of the file have had their path fully set.\n+\n+                  if Source.Index = 0\n+                    or else Source.Index = 1\n+                  then\n+                     Error_Msg_Name_1 := Name_Id (Source.Display_File);\n+                     Error_Msg_Name_2 := Name_Id (Source.Unit.Name);\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"source file %% for unit %% not found\",\n+                        No_Location);\n+                  end if;\n                end if;\n \n                Remove_Source (Source, No_Source);\n@@ -7060,10 +7071,9 @@ package body Prj.Nmsc is\n                   --  ??? We could probably optimize the following call: we\n                   --  need to resolve links only once for the directory itself,\n                   --  and then do a single call to readlink() for each file.\n-                  --  Unfortunately that would require a change in\n-                  --  Normalize_Pathname so that it has the option of not\n-                  --  resolving links for its Directory parameter, only for\n-                  --  Name.\n+                  --  Unfortunately that would require Normalize_Pathname to\n+                  --  be changed so that it has the option of not resolving\n+                  --  links for its Directory parameter, only for Name.\n \n                   Path : constant String :=\n                     Normalize_Pathname\n@@ -7447,8 +7457,8 @@ package body Prj.Nmsc is\n                  or else\n                    (Unit = No_Name and then Source.File = File_Name)\n                then\n-                  --  Duplication of file/unit in same project is only\n-                  --  allowed if order of source directories is known.\n+                  --  Duplication of file/unit in same project is only allowed\n+                  --  if order of source directories is known.\n \n                   if Project = Source.Project then\n                      if Unit = No_Name then\n@@ -7585,12 +7595,12 @@ package body Prj.Nmsc is\n \n                      exit when Last = 0;\n \n-                     --  ??? Duplicate system call here, we just did a\n-                     --  a similar one. Maybe Ada.Directories would be more\n-                     --  appropriate here\n+                     --  ??? Duplicate system call here, we just did a a\n+                     --  similar one. Maybe Ada.Directories would be more\n+                     --  appropriate here.\n \n                      if Is_Regular_File\n-                       (Source_Directory & Name (1 .. Last))\n+                          (Source_Directory & Name (1 .. Last))\n                      then\n                         if Current_Verbosity = High then\n                            Write_Str  (\"   Checking \");\n@@ -8126,8 +8136,7 @@ package body Prj.Nmsc is\n                Err_Vars.Error_Msg_File_1 :=\n                  File_Name_Type (UData.File_Names (Unit_Kind).Path.Name);\n                Error_Msg\n-                 (Project, In_Tree,\n-                  \"\\   project file %%, {\", The_Location);\n+                 (Project, In_Tree, \"\\   project file %%, {\", The_Location);\n \n                Err_Vars.Error_Msg_Name_1 := Project.Name;\n                Err_Vars.Error_Msg_File_1 := File_Name_Type (Canonical_Path);\n@@ -8164,17 +8173,17 @@ package body Prj.Nmsc is\n          if To_Record then\n             Files_Htable.Set (Proc_Data.Units, Canonical_File, Project);\n             Add_Source\n-              (Id                  => Source,\n-               In_Tree             => In_Tree,\n-               Project             => Project,\n-               Lang_Id             => Ada_Language,\n-               File_Name           => Canonical_File,\n-               Display_File        => File_Name,\n-               Unit                => Unit_Name,\n-               Path                => (Canonical_Path, Path_Name),\n-               Naming_Exception    => Needs_Pragma,\n-               Kind                => Unit_Kind,\n-               Index               => Unit_Ind);\n+              (Id               => Source,\n+               In_Tree          => In_Tree,\n+               Project          => Project,\n+               Lang_Id          => Ada_Language,\n+               File_Name        => Canonical_File,\n+               Display_File     => File_Name,\n+               Unit             => Unit_Name,\n+               Path             => (Canonical_Path, Path_Name),\n+               Naming_Exception => Needs_Pragma,\n+               Kind             => Unit_Kind,\n+               Index            => Unit_Ind);\n             Source_Recorded := True;\n          end if;\n       end Record_Unit;"}, {"sha": "ad96467e61b37aba5752586850c0b2d92e5870dd", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "patch": "@@ -6460,7 +6460,7 @@ package Sinfo is\n       --  The Ada language does not permit conditional expressions, however\n       --  this is under discussion as a possible extension by the ARG, and we\n       --  have implemented a form of this capability in GNAT under control of\n-      --  the -X switch. The syntax is:\n+      --  the -gnatX switch. The syntax is:\n \n       --  CONDITIONAL_EXPRESSION ::=\n       --    if EXPRESSION then EXPRESSION"}]}