{"sha": "8fceae614f031382bc1fa39f94c7d928b5d81f4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZjZWFlNjE0ZjAzMTM4MmJjMWZhMzlmOTRjN2Q5MjhiNWQ4MWY0ZQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2015-04-24T04:49:34Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2015-04-24T04:49:34Z"}, "message": "re PR rtl-optimization/34503 (Issues with constant/copy propagation implementation in gcse.c)\n\n2015-04-24  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n            Steven Bosscher <steven@gcc.gnu.org>\n\n    gcc/\n    PR rtl-optimization/34503\n    * cprop.c (cprop_reg_p): New.\n    (hash_scan_set): Use above function to check if register can be\n    propagated.\n    (find_avail_set): Return up to two sets, one whose source is a\n    register and one whose source is a constant.  Sets are returned in an\n    array passed as parameter rather than as a return value.\n    (cprop_insn): Use a do while loop rather than a goto.  Try each of the\n    sets returned by find_avail_set, starting with the one whose source is\n    a constant. Use cprop_reg_p to check if register can be propagated.\n    (do_local_cprop): Use cprop_reg_p to check if register can be\n    propagated.\n    (implicit_set_cond_p): Likewise.\n\n    gcc/testsuite/\n    PR rtl-optimization/34503\n    * gcc.target/arm/pr64616.c: New file.\n\nCo-Authored-By: Steven Bosscher <steven@gcc.gnu.org>\n\nFrom-SVN: r222398", "tree": {"sha": "3cadb8317ca0e770ce8c62f746e822584b88cf9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cadb8317ca0e770ce8c62f746e822584b88cf9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fceae614f031382bc1fa39f94c7d928b5d81f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fceae614f031382bc1fa39f94c7d928b5d81f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fceae614f031382bc1fa39f94c7d928b5d81f4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fceae614f031382bc1fa39f94c7d928b5d81f4e/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62d47a882758add1f94f26941c7461ecebcf4b3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d47a882758add1f94f26941c7461ecebcf4b3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62d47a882758add1f94f26941c7461ecebcf4b3e"}], "stats": {"total": 165, "additions": 101, "deletions": 64}, "files": [{"sha": "7f2d944e6438a78acc4b8ebab44ebebe2b19cbba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fceae614f031382bc1fa39f94c7d928b5d81f4e", "patch": "@@ -1,3 +1,20 @@\n+2015-04-24  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\t    Steven Bosscher <steven@gcc.gnu.org>\n+\n+\tPR rtl-optimization/34503\n+\t* cprop.c (cprop_reg_p): New.\n+\t(hash_scan_set): Use above function to check if register can be\n+\tpropagated.\n+\t(find_avail_set): Return up to two sets, one whose source is a\n+\tregister and one whose source is a constant.  Sets are returned in an\n+\tarray passed as parameter rather than as a return value.\n+\t(cprop_insn): Use a do while loop rather than a goto.  Try each of the\n+\tsets returned by find_avail_set, starting with the one whose source is\n+\ta constant. Use cprop_reg_p to check if register can be propagated.\n+\t(do_local_cprop): Use cprop_reg_p to check if register can be\n+\tpropagated.\n+\t(implicit_set_cond_p): Likewise.\n+\n 2015-04-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-icf.c (sem_function::equals_wpa): Compare thunk info."}, {"sha": "845b6444b2eed209ef90c64d1247b7e10335ff12", "filename": "gcc/cprop.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=8fceae614f031382bc1fa39f94c7d928b5d81f4e", "patch": "@@ -285,6 +285,15 @@ cprop_constant_p (const_rtx x)\n   return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));\n }\n \n+/* Determine whether the rtx X should be treated as a register that can\n+   be propagated.  Any pseudo-register is fine.  */\n+\n+static bool\n+cprop_reg_p (const_rtx x)\n+{\n+  return REG_P (x) && !HARD_REGISTER_P (x);\n+}\n+\n /* Scan SET present in INSN and add an entry to the hash TABLE.\n    IMPLICIT is true if it's an implicit set, false otherwise.  */\n \n@@ -295,8 +304,7 @@ hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table,\n   rtx src = SET_SRC (set);\n   rtx dest = SET_DEST (set);\n \n-  if (REG_P (dest)\n-      && ! HARD_REGISTER_P (dest)\n+  if (cprop_reg_p (dest)\n       && reg_available_p (dest, insn)\n       && can_copy_p (GET_MODE (dest)))\n     {\n@@ -321,9 +329,8 @@ hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table,\n \tsrc = XEXP (note, 0), set = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Record sets for constant/copy propagation.  */\n-      if ((REG_P (src)\n+      if ((cprop_reg_p (src)\n \t   && src != dest\n-\t   && ! HARD_REGISTER_P (src)\n \t   && reg_available_p (src, insn))\n \t  || cprop_constant_p (src))\n \tinsert_set_in_table (dest, src, insn, table, implicit);\n@@ -821,15 +828,15 @@ try_replace_reg (rtx from, rtx to, rtx_insn *insn)\n   return success;\n }\n \n-/* Find a set of REGNOs that are available on entry to INSN's block.  Return\n-   NULL no such set is found.  */\n+/* Find a set of REGNOs that are available on entry to INSN's block.  If found,\n+   SET_RET[0] will be assigned a set with a register source and SET_RET[1] a\n+   set with a constant source.  If not found the corresponding entry is set to\n+   NULL.  */\n \n-static struct cprop_expr *\n-find_avail_set (int regno, rtx_insn *insn)\n+static void\n+find_avail_set (int regno, rtx_insn *insn, struct cprop_expr *set_ret[2])\n {\n-  /* SET1 contains the last set found that can be returned to the caller for\n-     use in a substitution.  */\n-  struct cprop_expr *set1 = 0;\n+  set_ret[0] = set_ret[1] = NULL;\n \n   /* Loops are not possible here.  To get a loop we would need two sets\n      available at the start of the block containing INSN.  i.e. we would\n@@ -869,8 +876,10 @@ find_avail_set (int regno, rtx_insn *insn)\n          If the source operand changed, we may still use it for the next\n          iteration of this loop, but we may not use it for substitutions.  */\n \n-      if (cprop_constant_p (src) || reg_not_set_p (src, insn))\n-\tset1 = set;\n+      if (cprop_constant_p (src))\n+\tset_ret[1] = set;\n+      else if (reg_not_set_p (src, insn))\n+\tset_ret[0] = set;\n \n       /* If the source of the set is anything except a register, then\n \t we have reached the end of the copy chain.  */\n@@ -881,10 +890,6 @@ find_avail_set (int regno, rtx_insn *insn)\n \t and see if we have an available copy into SRC.  */\n       regno = REGNO (src);\n     }\n-\n-  /* SET1 holds the last set that was available and anticipatable at\n-     INSN.  */\n-  return set1;\n }\n \n /* Subroutine of cprop_insn that tries to propagate constants into\n@@ -1048,40 +1053,40 @@ cprop_insn (rtx_insn *insn)\n   int changed = 0, changed_this_round;\n   rtx note;\n \n-retry:\n-  changed_this_round = 0;\n-  reg_use_count = 0;\n-  note_uses (&PATTERN (insn), find_used_regs, NULL);\n-\n-  /* We may win even when propagating constants into notes.  */\n-  note = find_reg_equal_equiv_note (insn);\n-  if (note)\n-    find_used_regs (&XEXP (note, 0), NULL);\n-\n-  for (i = 0; i < reg_use_count; i++)\n+  do\n     {\n-      rtx reg_used = reg_use_table[i];\n-      unsigned int regno = REGNO (reg_used);\n-      rtx src;\n-      struct cprop_expr *set;\n+      changed_this_round = 0;\n+      reg_use_count = 0;\n+      note_uses (&PATTERN (insn), find_used_regs, NULL);\n \n-      /* If the register has already been set in this block, there's\n-\t nothing we can do.  */\n-      if (! reg_not_set_p (reg_used, insn))\n-\tcontinue;\n+      /* We may win even when propagating constants into notes.  */\n+      note = find_reg_equal_equiv_note (insn);\n+      if (note)\n+\tfind_used_regs (&XEXP (note, 0), NULL);\n \n-      /* Find an assignment that sets reg_used and is available\n-\t at the start of the block.  */\n-      set = find_avail_set (regno, insn);\n-      if (! set)\n-\tcontinue;\n+      for (i = 0; i < reg_use_count; i++)\n+\t{\n+\t  rtx reg_used = reg_use_table[i];\n+\t  unsigned int regno = REGNO (reg_used);\n+\t  rtx src_cst = NULL, src_reg = NULL;\n+\t  struct cprop_expr *set[2];\n \n-      src = set->src;\n+\t  /* If the register has already been set in this block, there's\n+\t     nothing we can do.  */\n+\t  if (! reg_not_set_p (reg_used, insn))\n+\t    continue;\n \n-      /* Constant propagation.  */\n-      if (cprop_constant_p (src))\n-\t{\n-          if (constprop_register (reg_used, src, insn))\n+\t  /* Find an assignment that sets reg_used and is available\n+\t     at the start of the block.  */\n+\t  find_avail_set (regno, insn, set);\n+\t  if (set[0])\n+\t    src_reg = set[0]->src;\n+\t  if (set[1])\n+\t    src_cst = set[1]->src;\n+\n+\t  /* Constant propagation.  */\n+\t  if (src_cst && cprop_constant_p (src_cst)\n+\t      && constprop_register (reg_used, src_cst, insn))\n \t    {\n \t      changed_this_round = changed = 1;\n \t      global_const_prop_count++;\n@@ -1091,18 +1096,16 @@ cprop_insn (rtx_insn *insn)\n \t\t\t   \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n \t\t  fprintf (dump_file, \"insn %d with constant \",\n \t\t\t   INSN_UID (insn));\n-\t\t  print_rtl (dump_file, src);\n+\t\t  print_rtl (dump_file, src_cst);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t      if (insn->deleted ())\n \t\treturn 1;\n \t    }\n-\t}\n-      else if (REG_P (src)\n-\t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t       && REGNO (src) != regno)\n-\t{\n-\t  if (try_replace_reg (reg_used, src, insn))\n+\t  /* Copy propagation.  */\n+\t  else if (src_reg && cprop_reg_p (src_reg)\n+\t\t   && REGNO (src_reg) != regno\n+\t\t   && try_replace_reg (reg_used, src_reg, insn))\n \t    {\n \t      changed_this_round = changed = 1;\n \t      global_copy_prop_count++;\n@@ -1111,7 +1114,7 @@ cprop_insn (rtx_insn *insn)\n \t\t  fprintf (dump_file,\n \t\t\t   \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n \t\t\t   regno, INSN_UID (insn));\n-\t\t  fprintf (dump_file, \" with reg %d\\n\", REGNO (src));\n+\t\t  fprintf (dump_file, \" with reg %d\\n\", REGNO (src_reg));\n \t\t}\n \n \t      /* The original insn setting reg_used may or may not now be\n@@ -1121,12 +1124,10 @@ cprop_insn (rtx_insn *insn)\n \t\t and made things worse.  */\n \t    }\n \t}\n-\n-      /* If try_replace_reg simplified the insn, the regs found\n-\t by find_used_regs may not be valid anymore.  Start over.  */\n-      if (changed_this_round)\n-\tgoto retry;\n     }\n+  /* If try_replace_reg simplified the insn, the regs found by find_used_regs\n+     may not be valid anymore.  Start over.  */\n+  while (changed_this_round);\n \n   if (changed && DEBUG_INSN_P (insn))\n     return 0;\n@@ -1189,7 +1190,7 @@ do_local_cprop (rtx x, rtx_insn *insn)\n   /* Rule out USE instructions and ASM statements as we don't want to\n      change the hard registers mentioned.  */\n   if (REG_P (x)\n-      && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+      && (cprop_reg_p (x)\n           || (GET_CODE (PATTERN (insn)) != USE\n \t      && asm_noperands (PATTERN (insn)) < 0)))\n     {\n@@ -1205,7 +1206,7 @@ do_local_cprop (rtx x, rtx_insn *insn)\n \n \t  if (cprop_constant_p (this_rtx))\n \t    newcnst = this_rtx;\n-\t  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER\n+\t  if (cprop_reg_p (this_rtx)\n \t      /* Don't copy propagate if it has attached REG_EQUIV note.\n \t\t At this point this only function parameters should have\n \t\t REG_EQUIV notes and if the argument slot is used somewhere\n@@ -1326,9 +1327,8 @@ implicit_set_cond_p (const_rtx cond)\n   if (GET_CODE (cond) != EQ && GET_CODE (cond) != NE)\n     return false;\n \n-  /* The first operand of COND must be a pseudo-reg.  */\n-  if (! REG_P (XEXP (cond, 0))\n-      || HARD_REGISTER_P (XEXP (cond, 0)))\n+  /* The first operand of COND must be a register we can propagate.  */\n+  if (!cprop_reg_p (XEXP (cond, 0)))\n     return false;\n \n   /* The second operand of COND must be a suitable constant.  */"}, {"sha": "bbc0b24ef5edbd28d208996b00f4d4291e0e9df3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fceae614f031382bc1fa39f94c7d928b5d81f4e", "patch": "@@ -1,3 +1,9 @@\n+2015-04-24  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\t    Steven Bosscher <steven@gcc.gnu.org>\n+\n+\tPR rtl-optimization/34503\n+\t* gcc.target/arm/pr64616.c: New file.\n+\n 2015-04-24  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.target/arm/pr42172-1.c: Check str instead of ldr."}, {"sha": "c686ffa8dd36a210249172002a5c3894ff20c970", "filename": "gcc/testsuite/gcc.target/arm/pr64616.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr64616.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fceae614f031382bc1fa39f94c7d928b5d81f4e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr64616.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr64616.c?ref=8fceae614f031382bc1fa39f94c7d928b5d81f4e", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+int f (int);\n+unsigned int glob;\n+\n+void\n+g ()\n+{\n+  while (f (glob));\n+  glob = 5;\n+}\n+\n+/* { dg-final { scan-assembler-times \"ldr\" 2 } } */"}]}