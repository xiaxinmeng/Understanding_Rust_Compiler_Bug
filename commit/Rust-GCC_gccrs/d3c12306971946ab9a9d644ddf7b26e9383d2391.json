{"sha": "d3c12306971946ab9a9d644ddf7b26e9383d2391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNjMTIzMDY5NzE5NDZhYjlhOWQ2NDRkZGY3YjI2ZTkzODNkMjM5MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-08-30T20:04:49Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-08-30T20:04:49Z"}, "message": "Stack usage support\n\n\tStack usage support\n\t* common.opt (-fstack-usage): New option.\n\t* doc/invoke.texi (Debugging options): Document it.\n\t* builtins.c (expand_builtin_apply): Pass TRUE as 4th argument to\n\tallocate_dynamic_stack_space.\n\t(expand_builtin_alloca): Add 4th bool parameter CANNOT_ACCUMULATE\n\tand propagate it to allocate_dynamic_stack_space.\n\t(expand_builtin) <BUILT_IN_ALLOCA>: Adjust for above change.\n\t* calls.c (initialize_argument_information): Pass TRUE as 4th\n\targument to allocate_dynamic_stack_space.\n\t(expand_call): Set current_function_has_unbounded_dynamic_stack_size\n\tto 1 when pushing a variable-sized argument onto the stack.  Pass\n\tTRUE as 4th argument to allocate_dynamic_stack_space.\n\tUpdate current_function_pushed_stack_size.\n\t(emit_library_call_value_1): Likewise.\n\t* explow.c (allocate_dynamic_stack_space): Add 4th bool parameter\n\tCANNOT_ACCUMULATE.  If flag_stack_usage, look into the size and\n\tattempt to find an upper bound.  Remove redundant code for the\n\tSETJMP_VIA_SAVE_AREA case.\n\t* expr.h (allocate_dynamic_stack_space): Add 4th bool parameter.\n\t* function.h (struct stack_usage): New structure.\n\t(current_function_static_stack_size): New macro.\n\t(current_function_dynamic_stack_size): Likewise.\n\t(current_function_pushed_stack_size): Likewise.\n\t(current_function_dynamic_alloc_count): Likewise.\n\t(current_function_has_unbounded_dynamic_stack_size): Likewise.\n\t(current_function_allocates_dynamic_stack_space): Likewise.\n\t(struct function): Add new field 'su'.\n\t* function.c (instantiate_virtual_regs): If SETJMP_VIA_SAVE_AREA,\n\tadd the value of the dynamic offset to the dynamic stack usage.\n\t(gimplify_parameters): Set ALLOCA_FOR_VAR_P on call to BUILT_IN_ALLOCA\n\tfor variable-sized objects.\n\t(prepare_function_start): Allocate cfun->su if flag_stack_usage.\n\t(rest_of_handle_thread_prologue_and_epilogue): Call output_stack_usage.\n\t* gimplify.c (gimplify_decl_expr): Set ALLOCA_FOR_VAR_P on call to\n\tBUILT_IN_ALLOCA for variable-sized objects.\n\t* output.h (output_stack_usage): Declare.\n\t* toplev.c (stack_usage_file): New file pointer.\n\t(output_stack_usage): New function.\n\t(open_auxiliary_file): Likewise.\n\t(lang_dependent_init): Open file if flag_stack_usage is set.\n\t(finalize): Close file if stack_usage_file is not null.\n\t* tree.h (ALLOCA_FOR_VAR_P): New macro.\n\t* config/alpha/alpha.c (compute_frame_size): New function.\n\t(alpha_expand_prologue): Use it.\n\t(alpha_start_function): Likewise.\n\t(alpha_expand_epilogue): Likewise.  Set stack usage info.\n\t* config/i386/i386.c (ix86_expand_prologue): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_prologue): Likewise.\n\t* config/mips/mips.c (mips_expand_prologue): Likewise.\n\t* config/pa/pa.c (hppa_expand_prologue): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n\t* config/sparc/sparc.c (sparc_expand_prologue): Likewise.\ntestsuite/\n\t* lib/gcc-dg.exp (cleanup-stack-usage): New procedure.\n\t* lib/scanasm.exp (scan-stack-usage): Likewise.\n\t(scan-stack-usage-not): Likewise.\n\t* gcc.dg/stack-usage-1.c: New test.\n\t* gcc.target/i386/stack-usage-realign.c: Likewise.\n\nFrom-SVN: r163660", "tree": {"sha": "ca99479811fedf830873973cdd6050ed0d345e29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca99479811fedf830873973cdd6050ed0d345e29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3c12306971946ab9a9d644ddf7b26e9383d2391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3c12306971946ab9a9d644ddf7b26e9383d2391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3c12306971946ab9a9d644ddf7b26e9383d2391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3c12306971946ab9a9d644ddf7b26e9383d2391/comments", "author": null, "committer": null, "parents": [{"sha": "1987baa3aba544cf7dd4d6273e26b54003b96cf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1987baa3aba544cf7dd4d6273e26b54003b96cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1987baa3aba544cf7dd4d6273e26b54003b96cf7"}], "stats": {"total": 667, "additions": 557, "deletions": 110}, "files": [{"sha": "f1b9bcdaa76f15efbacd34375eb4df9941dc0adb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1,3 +1,59 @@\n+2010-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tStack usage support\n+\t* common.opt (-fstack-usage): New option.\n+\t* doc/invoke.texi (Debugging options): Document it.\n+\t* builtins.c (expand_builtin_apply): Pass TRUE as 4th argument to\n+\tallocate_dynamic_stack_space.\n+\t(expand_builtin_alloca): Add 4th bool parameter CANNOT_ACCUMULATE\n+\tand propagate it to allocate_dynamic_stack_space.\n+\t(expand_builtin) <BUILT_IN_ALLOCA>: Adjust for above change.\n+\t* calls.c (initialize_argument_information): Pass TRUE as 4th\n+\targument to allocate_dynamic_stack_space.\n+\t(expand_call): Set current_function_has_unbounded_dynamic_stack_size\n+\tto 1 when pushing a variable-sized argument onto the stack.  Pass\n+\tTRUE as 4th argument to allocate_dynamic_stack_space.\n+\tUpdate current_function_pushed_stack_size.\n+\t(emit_library_call_value_1): Likewise.\n+\t* explow.c (allocate_dynamic_stack_space): Add 4th bool parameter\n+\tCANNOT_ACCUMULATE.  If flag_stack_usage, look into the size and\n+\tattempt to find an upper bound.  Remove redundant code for the\n+\tSETJMP_VIA_SAVE_AREA case.\n+\t* expr.h (allocate_dynamic_stack_space): Add 4th bool parameter.\n+\t* function.h (struct stack_usage): New structure.\n+\t(current_function_static_stack_size): New macro.\n+\t(current_function_dynamic_stack_size): Likewise.\n+\t(current_function_pushed_stack_size): Likewise.\n+\t(current_function_dynamic_alloc_count): Likewise.\n+\t(current_function_has_unbounded_dynamic_stack_size): Likewise.\n+\t(current_function_allocates_dynamic_stack_space): Likewise.\n+\t(struct function): Add new field 'su'.\n+\t* function.c (instantiate_virtual_regs): If SETJMP_VIA_SAVE_AREA,\n+\tadd the value of the dynamic offset to the dynamic stack usage.\n+\t(gimplify_parameters): Set ALLOCA_FOR_VAR_P on call to BUILT_IN_ALLOCA\n+\tfor variable-sized objects.\n+\t(prepare_function_start): Allocate cfun->su if flag_stack_usage.\n+\t(rest_of_handle_thread_prologue_and_epilogue): Call output_stack_usage.\n+\t* gimplify.c (gimplify_decl_expr): Set ALLOCA_FOR_VAR_P on call to\n+\tBUILT_IN_ALLOCA for variable-sized objects.\n+\t* output.h (output_stack_usage): Declare.\n+\t* toplev.c (stack_usage_file): New file pointer.\n+\t(output_stack_usage): New function.\n+\t(open_auxiliary_file): Likewise.\n+\t(lang_dependent_init): Open file if flag_stack_usage is set.\n+\t(finalize): Close file if stack_usage_file is not null.\n+\t* tree.h (ALLOCA_FOR_VAR_P): New macro.\n+\t* config/alpha/alpha.c (compute_frame_size): New function.\n+\t(alpha_expand_prologue): Use it.\n+\t(alpha_start_function): Likewise.\n+\t(alpha_expand_epilogue): Likewise.  Set stack usage info.\n+\t* config/i386/i386.c (ix86_expand_prologue): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_prologue): Likewise.\n+\t* config/mips/mips.c (mips_expand_prologue): Likewise.\n+\t* config/pa/pa.c (hppa_expand_prologue): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n+\t* config/sparc/sparc.c (sparc_expand_prologue): Likewise.\n+\n 2010-08-30  Zdenek Dvorak  <ook@ucw.cz>\n \n \tPR tree-optimization/45427\n@@ -6,7 +62,7 @@\n \t(number_of_iterations_ne): Pass exit_must_be_taken to\n \tnumber_of_iterations_ne_max.\n \n-2010-08-31  Catherine Moore  <clm@codesourcery.com>\n+2010-08-30  Catherine Moore  <clm@codesourcery.com>\n \n \t* config/mips/mips.h (BASE_DRIVER_SELF_SPECS):\n \tInfer -mdspr2 for the the 74K."}, {"sha": "ff1141ff2aeac5964ce834a5c14afda1f2ce5faf", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -132,7 +132,7 @@ static rtx expand_builtin_memset (tree, rtx, enum machine_mode);\n static rtx expand_builtin_memset_args (tree, tree, tree, rtx, enum machine_mode, tree);\n static rtx expand_builtin_bzero (tree);\n static rtx expand_builtin_strlen (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_alloca (tree, rtx);\n+static rtx expand_builtin_alloca (tree, rtx, bool);\n static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);\n static rtx expand_builtin_frame_address (tree, tree);\n static tree stabilize_va_list_loc (location_t, tree, int);\n@@ -1588,8 +1588,10 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n     emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n \n   /* Allocate a block of memory onto the stack and copy the memory\n-     arguments to the outgoing arguments address.  */\n-  allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT);\n+     arguments to the outgoing arguments address.  We can pass TRUE\n+     as the 4th argument because we just saved the stack pointer\n+     and will restore it right after the call.  */\n+  allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT, TRUE);\n \n   /* Set DRAP flag to true, even though allocate_dynamic_stack_space\n      may have already set current_function_calls_alloca to true.\n@@ -4949,12 +4951,13 @@ expand_builtin_frame_address (tree fndecl, tree exp)\n     }\n }\n \n-/* Expand EXP, a call to the alloca builtin.  Return NULL_RTX if\n-   we failed and the caller should emit a normal call, otherwise try to get\n-   the result in TARGET, if convenient.  */\n+/* Expand EXP, a call to the alloca builtin.  Return NULL_RTX if we\n+   failed and the caller should emit a normal call, otherwise try to\n+   get the result in TARGET, if convenient.  CANNOT_ACCUMULATE is the\n+   same as for allocate_dynamic_stack_space.  */\n \n static rtx\n-expand_builtin_alloca (tree exp, rtx target)\n+expand_builtin_alloca (tree exp, rtx target, bool cannot_accumulate)\n {\n   rtx op0;\n   rtx result;\n@@ -4970,7 +4973,8 @@ expand_builtin_alloca (tree exp, rtx target)\n   op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n \n   /* Allocate the desired space.  */\n-  result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n+  result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT,\n+\t\t\t\t\t cannot_accumulate);\n   result = convert_memory_address (ptr_mode, result);\n \n   return result;\n@@ -6009,7 +6013,9 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n \n     case BUILT_IN_ALLOCA:\n-      target = expand_builtin_alloca (exp, target);\n+      /* If the allocation stems from the declaration of a variable-sized\n+\t object, it cannot accumulate.  */\n+      target = expand_builtin_alloca (exp, target, ALLOCA_FOR_VAR_P (exp));\n       if (target)\n \treturn target;\n       break;"}, {"sha": "7b6d113a5ec57cd186eefb6bedd47f8f99562bca", "filename": "gcc/calls.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1095,9 +1095,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t      pending_stack_adjust = 0;\n \t\t    }\n \n+\t\t  /* We can pass TRUE as the 4th argument because we just\n+\t\t     saved the stack pointer and will restore it right after\n+\t\t     the call.  */\n \t\t  copy = gen_rtx_MEM (BLKmode,\n \t\t\t\t      allocate_dynamic_stack_space\n-\t\t\t\t      (size_rtx, NULL_RTX, TYPE_ALIGN (type)));\n+\t\t\t\t      (size_rtx, NULL_RTX,\n+\t\t\t\t       TYPE_ALIGN (type), TRUE));\n \t\t  set_mem_attributes (copy, type, 1);\n \t\t}\n \t      else\n@@ -2492,6 +2496,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t      stack_arg_under_construction = 0;\n \t    }\n \t  argblock = push_block (ARGS_SIZE_RTX (adjusted_args_size), 0, 0);\n+\t  if (flag_stack_usage)\n+\t    current_function_has_unbounded_dynamic_stack_size = 1;\n \t}\n       else\n \t{\n@@ -2653,8 +2659,11 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  stack_usage_map = stack_usage_map_buf;\n \t\t  highest_outgoing_arg_in_use = 0;\n \t\t}\n+\t      /* We can pass TRUE as the 4th argument because we just\n+\t\t saved the stack pointer and will restore it right after\n+\t\t the call.  */\n \t      allocate_dynamic_stack_space (push_size, NULL_RTX,\n-\t\t\t\t\t    BITS_PER_UNIT);\n+\t\t\t\t\t    BITS_PER_UNIT, TRUE);\n \t    }\n \n \t  /* If argument evaluation might modify the stack pointer,\n@@ -2694,6 +2703,19 @@ expand_call (tree exp, rtx target, int ignore)\n \t be deferred during the evaluation of the arguments.  */\n       NO_DEFER_POP;\n \n+      /* Record the maximum pushed stack space size.  We need to delay\n+\t doing it this far to take into account the optimization done\n+\t by combine_pending_stack_adjustment_and_call.  */\n+      if (flag_stack_usage\n+\t  && !ACCUMULATE_OUTGOING_ARGS\n+\t  && pass\n+\t  && adjusted_args_size.var == 0)\n+\t{\n+\t  int pushed = adjusted_args_size.constant + pending_stack_adjust;\n+\t  if (pushed > current_function_pushed_stack_size)\n+\t    current_function_pushed_stack_size = pushed;\n+\t}\n+\n       funexp = rtx_for_function_call (fndecl, addr);\n \n       /* Figure out the register where the value, if any, will come back.  */\n@@ -3551,6 +3573,13 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   if (args_size.constant > crtl->outgoing_args_size)\n     crtl->outgoing_args_size = args_size.constant;\n \n+  if (flag_stack_usage && !ACCUMULATE_OUTGOING_ARGS)\n+    {\n+      int pushed = args_size.constant + pending_stack_adjust;\n+      if (pushed > current_function_pushed_stack_size)\n+\tcurrent_function_pushed_stack_size = pushed;\n+    }\n+\n   if (ACCUMULATE_OUTGOING_ARGS)\n     {\n       /* Since the stack pointer will never be pushed, it is possible for"}, {"sha": "76933a00b44939ceb699cd57d28273cdd0189343", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1281,6 +1281,10 @@ fstack-protector-all\n Common Report RejectNegative Var(flag_stack_protect, 2) VarExists\n Use a stack protection method for every function\n \n+fstack-usage\n+Common RejectNegative Var(flag_stack_usage)\n+Output stack usage information on a per-function basis\n+\n fstrength-reduce\n Common\n Does nothing.  Preserved for backward compatibility."}, {"sha": "3adc8465a7945247258fe838fa09962ea5c235c6", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -7763,6 +7763,30 @@ emit_frame_store (unsigned int regno, rtx base_reg,\n   emit_frame_store_1 (reg, base_reg, frame_bias, base_ofs, reg);\n }\n \n+/* Compute the frame size.  SIZE is the size of the \"naked\" frame\n+   and SA_SIZE is the size of the register save area.  */\n+\n+static HOST_WIDE_INT\n+compute_frame_size (HOST_WIDE_INT size, HOST_WIDE_INT sa_size)\n+{\n+  if (TARGET_ABI_OPEN_VMS)\n+    return ALPHA_ROUND (sa_size \n+\t\t\t+ (alpha_procedure_type == PT_STACK ? 8 : 0)\n+\t\t\t+ size\n+\t\t\t+ crtl->args.pretend_args_size);\n+  else if (TARGET_ABI_UNICOSMK)\n+    /* We have to allocate space for the DSIB if we generate a frame.  */\n+    return ALPHA_ROUND (sa_size\n+\t\t\t+ (alpha_procedure_type == PT_STACK ? 48 : 0))\n+\t   + ALPHA_ROUND (size\n+\t\t\t  + crtl->outgoing_args_size);\n+  else\n+    return ALPHA_ROUND (crtl->outgoing_args_size)\n+\t   + sa_size\n+\t   + ALPHA_ROUND (size\n+\t\t\t  + crtl->args.pretend_args_size);\n+}\n+\n /* Write function prologue.  */\n \n /* On vms we have two kinds of functions:\n@@ -7796,24 +7820,10 @@ alpha_expand_prologue (void)\n   int i;\n \n   sa_size = alpha_sa_size ();\n+  frame_size = compute_frame_size (get_frame_size (), sa_size);\n \n-  frame_size = get_frame_size ();\n-  if (TARGET_ABI_OPEN_VMS)\n-    frame_size = ALPHA_ROUND (sa_size\n-\t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n-\t\t\t      + frame_size\n-\t\t\t      + crtl->args.pretend_args_size);\n-  else if (TARGET_ABI_UNICOSMK)\n-    /* We have to allocate space for the DSIB if we generate a frame.  */\n-    frame_size = ALPHA_ROUND (sa_size\n-\t\t\t      + (alpha_procedure_type == PT_STACK ? 48 : 0))\n-\t\t + ALPHA_ROUND (frame_size\n-\t\t\t\t+ crtl->outgoing_args_size);\n-  else\n-    frame_size = (ALPHA_ROUND (crtl->outgoing_args_size)\n-\t\t  + sa_size\n-\t\t  + ALPHA_ROUND (frame_size\n-\t\t\t\t + crtl->args.pretend_args_size));\n+  if (flag_stack_usage)\n+    current_function_static_stack_size = frame_size;\n \n   if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;\n@@ -8135,23 +8145,7 @@ alpha_start_function (FILE *file, const char *fnname,\n \n   alpha_fnname = fnname;\n   sa_size = alpha_sa_size ();\n-\n-  frame_size = get_frame_size ();\n-  if (TARGET_ABI_OPEN_VMS)\n-    frame_size = ALPHA_ROUND (sa_size\n-\t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n-\t\t\t      + frame_size\n-\t\t\t      + crtl->args.pretend_args_size);\n-  else if (TARGET_ABI_UNICOSMK)\n-    frame_size = ALPHA_ROUND (sa_size\n-\t\t\t      + (alpha_procedure_type == PT_STACK ? 48 : 0))\n-\t\t + ALPHA_ROUND (frame_size\n-\t\t\t      + crtl->outgoing_args_size);\n-  else\n-    frame_size = (ALPHA_ROUND (crtl->outgoing_args_size)\n-\t\t  + sa_size\n-\t\t  + ALPHA_ROUND (frame_size\n-\t\t\t\t + crtl->args.pretend_args_size));\n+  frame_size = compute_frame_size (get_frame_size (), sa_size);\n \n   if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8 + 8 * cfun->machine->uses_condition_handler;\n@@ -8353,23 +8347,7 @@ alpha_expand_epilogue (void)\n   int i;\n \n   sa_size = alpha_sa_size ();\n-\n-  frame_size = get_frame_size ();\n-  if (TARGET_ABI_OPEN_VMS)\n-    frame_size = ALPHA_ROUND (sa_size\n-\t\t\t      + (alpha_procedure_type == PT_STACK ? 8 : 0)\n-\t\t\t      + frame_size\n-\t\t\t      + crtl->args.pretend_args_size);\n-  else if (TARGET_ABI_UNICOSMK)\n-    frame_size = ALPHA_ROUND (sa_size\n-\t\t\t      + (alpha_procedure_type == PT_STACK ? 48 : 0))\n-\t\t + ALPHA_ROUND (frame_size\n-\t\t\t      + crtl->outgoing_args_size);\n-  else\n-    frame_size = (ALPHA_ROUND (crtl->outgoing_args_size)\n-\t\t  + sa_size\n-\t\t  + ALPHA_ROUND (frame_size\n-\t\t\t\t + crtl->args.pretend_args_size));\n+  frame_size = compute_frame_size (get_frame_size (), sa_size);\n \n   if (TARGET_ABI_OPEN_VMS)\n     {"}, {"sha": "2fab2e6f3fd9fa667434aee6e7cb7ca9cd3e4bf6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -9613,6 +9613,29 @@ ix86_expand_prologue (void)\n \n   allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n \n+  if (flag_stack_usage)\n+    {\n+      /* We start to count from ARG_POINTER.  */\n+      HOST_WIDE_INT stack_size = frame.stack_pointer_offset;\n+\n+      /* If it was realigned, take into account the fake frame.  */\n+      if (stack_realign_drap)\n+\t{\n+\t  if (ix86_static_chain_on_stack)\n+\t    stack_size += UNITS_PER_WORD;\n+\n+\t  if (!call_used_regs[REGNO (crtl->drap_reg)])\n+\t    stack_size += UNITS_PER_WORD;\n+\n+\t  /* This over-estimates by 1 minimal-stack-alignment-unit but\n+\t     mitigates that by counting in the new return address slot.  */\n+\t  current_function_dynamic_stack_size\n+\t    += crtl->stack_alignment_needed / BITS_PER_UNIT;\n+\t}\n+\n+      current_function_static_stack_size = stack_size;\n+    }\n+\n   /* The stack has already been decremented by the instruction calling us\n      so we need to probe unconditionally to preserve the protection area.  */\n   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)"}, {"sha": "7f5d929ce36fccec0df79bb4b038720ce7652cc3", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -3097,6 +3097,9 @@ ia64_expand_prologue (void)\n   ia64_compute_frame_size (get_frame_size ());\n   last_scratch_gr_reg = 15;\n \n+  if (flag_stack_usage)\n+    current_function_static_stack_size = current_frame_info.total_size;\n+\n   if (dump_file) \n     {\n       fprintf (dump_file, \"ia64 frame related registers \""}, {"sha": "052e8051d2505386a868598b4dcd00ae791592b3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -10078,6 +10078,9 @@ mips_expand_prologue (void)\n   frame = &cfun->machine->frame;\n   size = frame->total_size;\n \n+  if (flag_stack_usage)\n+    current_function_static_stack_size = size;\n+\n   /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP\n      bytes beforehand; this is enough to cover the register save area\n      without going out of range.  */"}, {"sha": "9c24f01eb81ca8f0729fb10984b8008a514dc17d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -3734,6 +3734,8 @@ hppa_expand_prologue (void)\n     local_fsize += STARTING_FRAME_OFFSET;\n \n   actual_fsize = compute_frame_size (size, &save_fregs);\n+  if (flag_stack_usage)\n+    current_function_static_stack_size = actual_fsize;\n \n   /* Compute a few things we will use often.  */\n   tmpreg = gen_rtx_REG (word_mode, 1);"}, {"sha": "50ee702e3569e58807625da076c5ad8aca1f6bda", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -19716,6 +19716,9 @@ rs6000_emit_prologue (void)\n \t\t\t      && call_used_regs[STATIC_CHAIN_REGNUM]);\n   HOST_WIDE_INT sp_offset = 0;\n \n+  if (flag_stack_usage)\n+    current_function_static_stack_size = info->total_size;\n+\n   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)\n     rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, info->total_size);\n "}, {"sha": "ba034e6d921d01f3043d6a898ef2ccfd08849e60", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -4402,6 +4402,9 @@ sparc_expand_prologue (void)\n   /* Advertise that the data calculated just above are now valid.  */\n   sparc_prologue_data_valid_p = true;\n \n+  if (flag_stack_usage)\n+    current_function_static_stack_size = actual_fsize;\n+\n   if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)\n     sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);\n "}, {"sha": "52f9b39e6ad421c166f7a0ebfbf261d934e7ea0f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -313,7 +313,7 @@ Objective-C and Objective-C++ Dialects}.\n -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol\n--ftest-coverage  -ftime-report -fvar-tracking @gol\n+-fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol\n -fvar-tracking-assignments  -fvar-tracking-assignments-toggle @gol\n -g  -g@var{level}  -gtoggle  -gcoff  -gdwarf-@var{version} @gol\n -ggdb  -gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf @gol\n@@ -4852,6 +4852,39 @@ allocation when it finishes.\n Makes the compiler print some statistics about permanent memory\n allocation before or after interprocedural optimization.\n \n+@item -fstack-usage\n+@opindex fstack-usage\n+Makes the compiler output stack usage information for the program, on a\n+per-function basis.  The filename for the dump is made by appending\n+@file{.su} to the AUXNAME.  AUXNAME is generated from the name of\n+the output file, if explicitly specified and it is not an executable,\n+otherwise it is the basename of the source file.  An entry is made up\n+of three fields:\n+\n+@itemize\n+@item\n+The name of the function.\n+@item\n+A number of bytes.\n+@item\n+One or more qualifiers: @code{static}, @code{dynamic}, @code{bounded}.\n+@end itemize\n+\n+The qualifier @code{static} means that the function manipulates the stack\n+statically: a fixed number of bytes are allocated for the frame on function\n+entry and released on function exit; no stack adjustments are otherwise made\n+in the function.  The second field is this fixed number of bytes.\n+\n+The qualifier @code{dynamic} means that the function manipulates the stack\n+dynamically: in addition to the static allocation described above, stack\n+adjustments are made in the body of the function, for example to push/pop\n+arguments around function calls.  If the qualifier @code{bounded} is also\n+present, the amount of these adjustments is bounded at compile-time and\n+the second field is an upper bound of the total amount of stack used by\n+the function.  If it is not present, the amount of these adjustments is\n+not bounded at compile-time and the second field only represents the\n+bounded part.\n+\n @item -fprofile-arcs\n @opindex fprofile-arcs\n Add code so that program flow @dfn{arcs} are instrumented.  During"}, {"sha": "74f52279e545851ac608c759b452644798595c53", "filename": "gcc/explow.c", "status": "modified", "additions": 85, "deletions": 38, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1114,11 +1114,22 @@ update_nonlocal_goto_save_area (void)\n    SIZE is an rtx representing the size of the area.\n    TARGET is a place in which the address can be placed.\n \n-   KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.  */\n+   KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.\n+\n+   If CANNOT_ACCUMULATE is set to TRUE, the caller guarantees that the\n+   stack space allocated by the generated code cannot be added with itself\n+   in the course of the execution of the function.  It is always safe to\n+   pass FALSE here and the following criterion is sufficient in order to\n+   pass TRUE: every path in the CFG that starts at the allocation point and\n+   loops to it executes the associated deallocation code.  */\n \n rtx\n-allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n+allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n+\t\t\t      bool cannot_accumulate)\n {\n+  HOST_WIDE_INT stack_usage_size = -1;\n+  bool known_align_valid = true;\n+\n   /* If we're asking for zero bytes, it doesn't matter what we point\n      to since we can't dereference it.  But return a reasonable\n      address anyway.  */\n@@ -1128,6 +1139,37 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n   /* Otherwise, show we're calling alloca or equivalent.  */\n   cfun->calls_alloca = 1;\n \n+  /* If stack usage info is requested, look into the size we are passed.\n+     We need to do so this early to avoid the obfuscation that may be\n+     introduced later by the various alignment operations.  */\n+  if (flag_stack_usage)\n+    {\n+      if (GET_CODE (size) == CONST_INT)\n+\tstack_usage_size = INTVAL (size);\n+      else if (GET_CODE (size) == REG)\n+        {\n+\t  /* Look into the last emitted insn and see if we can deduce\n+\t     something for the register.  */\n+\t  rtx insn, set, note;\n+\t  insn = get_last_insn ();\n+\t  if ((set = single_set (insn)) && rtx_equal_p (SET_DEST (set), size))\n+\t    {\n+\t      if (GET_CODE (SET_SRC (set)) == CONST_INT)\n+\t\tstack_usage_size = INTVAL (SET_SRC (set));\n+\t      else if ((note = find_reg_equal_equiv_note (insn))\n+\t\t       && GET_CODE (XEXP (note, 0)) == CONST_INT)\n+\t\tstack_usage_size = INTVAL (XEXP (note, 0));\n+\t    }\n+\t}\n+\n+      /* If the size is not constant, we can't say anything.  */\n+      if (stack_usage_size == -1)\n+\t{\n+\t  current_function_has_unbounded_dynamic_stack_size = 1;\n+\t  stack_usage_size = 0;\n+\t}\n+    }\n+\n   /* Ensure the size is in the proper mode.  */\n   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n     size = convert_to_mode (Pmode, size, 1);\n@@ -1157,10 +1199,17 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n #endif\n \n   if (MUST_ALIGN)\n-    size\n-      = force_operand (plus_constant (size,\n-\t\t\t\t      BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n-\t\t       NULL_RTX);\n+    {\n+      size\n+        = force_operand (plus_constant (size,\n+\t\t\t\t\tBIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n+\t\t\t NULL_RTX);\n+\n+      if (flag_stack_usage)\n+\tstack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;\n+\n+      known_align_valid = false;\n+    }\n \n #ifdef SETJMP_VIA_SAVE_AREA\n   /* If setjmp restores regs from a save area in the stack frame,\n@@ -1174,39 +1223,22 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n      would use reg notes to store the \"optimized\" size and fix things\n      up later.  These days we know this information before we ever\n      start building RTL so the reg notes are unnecessary.  */\n-  if (!cfun->calls_setjmp)\n-    {\n-      int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n-\n-      /* ??? Code below assumes that the save area needs maximal\n-\t alignment.  This constraint may be too strong.  */\n-      gcc_assert (PREFERRED_STACK_BOUNDARY == BIGGEST_ALIGNMENT);\n-\n-      if (CONST_INT_P (size))\n-\t{\n-\t  HOST_WIDE_INT new_size = INTVAL (size) / align * align;\n-\n-\t  if (INTVAL (size) != new_size)\n-\t    size = GEN_INT (new_size);\n-\t}\n-      else\n-\t{\n-\t  /* Since we know overflow is not possible, we avoid using\n-\t     CEIL_DIV_EXPR and use TRUNC_DIV_EXPR instead.  */\n-\t  size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size,\n-\t\t\t\tGEN_INT (align), NULL_RTX, 1);\n-\t  size = expand_mult (Pmode, size,\n-\t\t\t      GEN_INT (align), NULL_RTX, 1);\n-\t}\n-    }\n-  else\n+  if (cfun->calls_setjmp)\n     {\n       rtx dynamic_offset\n \t= expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,\n \t\t\tstack_pointer_rtx, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \n       size = expand_binop (Pmode, add_optab, size, dynamic_offset,\n \t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+      /* The above dynamic offset cannot be computed statically at this\n+\t point, but it will be possible to do so after RTL expansion is\n+\t done.  Record how many times we will need to add it.  */\n+      if (flag_stack_usage)\n+\tcurrent_function_dynamic_alloc_count++;\n+\n+      known_align_valid = false;\n     }\n #endif /* SETJMP_VIA_SAVE_AREA */\n \n@@ -1223,13 +1255,28 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n      insns.  Since this is an extremely rare event, we have no reliable\n      way of knowing which systems have this problem.  So we avoid even\n      momentarily mis-aligning the stack.  */\n+  if (!known_align_valid || known_align % PREFERRED_STACK_BOUNDARY != 0)\n+    {\n+      size = round_push (size);\n \n-  /* If we added a variable amount to SIZE,\n-     we can no longer assume it is aligned.  */\n-#if !defined (SETJMP_VIA_SAVE_AREA)\n-  if (MUST_ALIGN || known_align % PREFERRED_STACK_BOUNDARY != 0)\n-#endif\n-    size = round_push (size);\n+      if (flag_stack_usage)\n+\t{\n+\t  int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+\t  stack_usage_size = (stack_usage_size + align - 1) / align * align;\n+\t}\n+    }\n+\n+  /* The size is supposed to be fully adjusted at this point so record it\n+     if stack usage info is requested.  */\n+  if (flag_stack_usage)\n+    {\n+      current_function_dynamic_stack_size += stack_usage_size;\n+\n+      /* ??? This is gross but the only safe stance in the absence\n+\t of stack usage oriented flow analysis.  */\n+      if (!cannot_accumulate)\n+\tcurrent_function_has_unbounded_dynamic_stack_size = 1;\n+    }\n \n   do_pending_stack_adjust ();\n "}, {"sha": "8631ea70c3af502d11869a3fac5357dacc6c33eb", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -641,9 +641,8 @@ extern void emit_stack_restore (enum save_level, rtx, rtx);\n /* Invoke emit_stack_save for the nonlocal_goto_save_area.  */\n extern void update_nonlocal_goto_save_area (void);\n \n-/* Allocate some space on the stack dynamically and return its address.  An rtx\n-   says how many bytes.  */\n-extern rtx allocate_dynamic_stack_space (rtx, rtx, int);\n+/* Allocate some space on the stack dynamically and return its address.  */\n+extern rtx allocate_dynamic_stack_space (rtx, rtx, int, bool);\n \n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n extern void emit_stack_probe (rtx);"}, {"sha": "670ff80ad3c3a734a640d18c8e9ec7544b118780", "filename": "gcc/function.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1899,6 +1899,18 @@ instantiate_virtual_regs (void)\n   /* Indicate that, from now on, assign_stack_local should use\n      frame_pointer_rtx.  */\n   virtuals_instantiated = 1;\n+\n+  /* See allocate_dynamic_stack_space for the rationale.  */\n+#ifdef SETJMP_VIA_SAVE_AREA\n+  if (flag_stack_usage && cfun->calls_setjmp)\n+    {\n+      int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+      dynamic_offset = (dynamic_offset + align - 1) / align * align;\n+      current_function_dynamic_stack_size\n+\t+= current_function_dynamic_alloc_count * dynamic_offset;\n+    }\n+#endif\n+\n   return 0;\n }\n \n@@ -3586,6 +3598,8 @@ gimplify_parameters (void)\n \n \t\t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t\t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (parm));\n+\t\t  /* The call has been built for a variable-sized object.  */\n+\t\t  ALLOCA_FOR_VAR_P (t) = 1;\n \t\t  t = fold_convert (ptr_type, t);\n \t\t  t = build2 (MODIFY_EXPR, TREE_TYPE (addr), addr, t);\n \t\t  gimplify_and_add (t, &stmts);\n@@ -4365,6 +4379,12 @@ prepare_function_start (void)\n   init_expr ();\n   default_rtl_profile ();\n \n+  if (flag_stack_usage)\n+    {\n+      cfun->su = ggc_alloc_cleared_stack_usage ();\n+      cfun->su->static_stack_size = -1;\n+    }\n+\n   cse_not_expected = ! optimize;\n \n   /* Caller save not needed yet.  */\n@@ -5753,12 +5773,17 @@ rest_of_handle_thread_prologue_and_epilogue (void)\n {\n   if (optimize)\n     cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n   /* On some machines, the prologue and epilogue code, or parts thereof,\n      can be represented as RTL.  Doing so lets us schedule insns between\n      it and the rest of the code and also allows delayed branch\n      scheduling to operate in the epilogue.  */\n-\n   thread_prologue_and_epilogue_insns ();\n+\n+  /* The stack usage info is finalized during prologue expansion.  */\n+  if (flag_stack_usage)\n+    output_stack_usage ();\n+\n   return 0;\n }\n "}, {"sha": "93a9b82601bc9dc37b71950a76ce493c350653cc", "filename": "gcc/function.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -468,6 +468,37 @@ extern GTY(()) struct rtl_data x_rtl;\n    want to do differently.  */\n #define crtl (&x_rtl)\n \n+struct GTY(()) stack_usage\n+{\n+  /* # of bytes of static stack space allocated by the function.  */\n+  HOST_WIDE_INT static_stack_size;\n+\n+  /* # of bytes of dynamic stack space allocated by the function.  This is\n+     meaningful only if has_unbounded_dynamic_stack_size is zero.  */\n+  HOST_WIDE_INT dynamic_stack_size;\n+\n+  /* # of bytes of space pushed onto the stack after the prologue.  If\n+     !ACCUMULATE_OUTGOING_ARGS, it contains the outgoing arguments.  */\n+  int pushed_stack_size;\n+\n+  /* # of dynamic allocations in the function.  */\n+  unsigned int dynamic_alloc_count : 31;\n+\n+  /* Nonzero if the amount of stack space allocated dynamically cannot\n+     be bounded at compile-time.  */\n+  unsigned int has_unbounded_dynamic_stack_size : 1;\n+};\n+\n+#define current_function_static_stack_size (cfun->su->static_stack_size)\n+#define current_function_dynamic_stack_size (cfun->su->dynamic_stack_size)\n+#define current_function_pushed_stack_size (cfun->su->pushed_stack_size)\n+#define current_function_dynamic_alloc_count (cfun->su->dynamic_alloc_count)\n+#define current_function_has_unbounded_dynamic_stack_size \\\n+  (cfun->su->has_unbounded_dynamic_stack_size)\n+#define current_function_allocates_dynamic_stack_space    \\\n+  (current_function_dynamic_stack_size != 0               \\\n+   || current_function_has_unbounded_dynamic_stack_size)\n+\n /* This structure can save all the important global and static variables\n    describing the status of the current function.  */\n \n@@ -486,6 +517,9 @@ struct GTY(()) function {\n   /* The loops in this function.  */\n   struct loops *x_current_loops;\n \n+  /* The stack usage of this function.  */\n+  struct stack_usage *su;\n+\n   /* Value histograms attached to particular statements.  */\n   htab_t GTY((skip)) value_histograms;\n "}, {"sha": "52d83f656fb562d9054b7c54ea82eb8a47b30867", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1329,6 +1329,8 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n \n   t = built_in_decls[BUILT_IN_ALLOCA];\n   t = build_call_expr (t, 1, DECL_SIZE_UNIT (decl));\n+  /* The call has been built for a variable-sized object.  */\n+  ALLOCA_FOR_VAR_P (t) = 1;\n   t = fold_convert (ptr_type, t);\n   t = build2 (MODIFY_EXPR, TREE_TYPE (addr), addr, t);\n "}, {"sha": "8371aa05f835ef0e1a349b009164edae47df4c2d", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -639,6 +639,9 @@ extern int maybe_assemble_visibility (tree);\n \n extern int default_address_cost (rtx, bool);\n \n+/* Output stack usage information.  */\n+extern void output_stack_usage (void);\n+\n /* dbxout helper functions */\n #if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO\n "}, {"sha": "65339bdd5909bdca9c6a9ec6a800184abffb47bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1,3 +1,11 @@\n+2010-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* lib/gcc-dg.exp (cleanup-stack-usage): New procedure.\n+\t* lib/scanasm.exp (scan-stack-usage): Likewise.\n+\t(scan-stack-usage-not): Likewise.\n+\t* gcc.dg/stack-usage-1.c: New test.\n+\t* gcc.target/i386/stack-usage-realign.c: Likewise.\n+\n 2010-08-30  Zdenek Dvorak  <ook@ucw.cz>\n \n \tPR tree-optimization/45427"}, {"sha": "f1748826cc12baee525760b53f41b2013a74bc27", "filename": "gcc/testsuite/gcc.dg/stack-usage-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstack-usage\" } */\n+\n+/* This is aimed at testing basic support for -fstack-usage in the back-ends.\n+   See the SPARC back-end for an example (grep flag_stack_usage in sparc.c).\n+   Once it is implemented, adjust SIZE below so that the stack usage for the\n+   function FOO is reported as 256 or 264 in the stack usage (.su) file.\n+   Then check that this is the actual stack usage in the assembly file.  */\n+\n+#if defined(__i386__)\n+#  define SIZE 248\n+#elif defined(__x86_64__)\n+#  define SIZE 356\n+#elif defined (__sparc__)\n+#  if defined (__arch64__)\n+#    define SIZE 76\n+#  else\n+#    define SIZE 160\n+#  endif\n+#elif defined(__hppa__)\n+#  define SIZE 192\n+#elif defined (__alpha__)\n+#  define SIZE 240\n+#elif defined (__ia64__)\n+#  define SIZE 272\n+#elif defined(__mips__)\n+#  define SIZE 240\n+#elif defined (__powerpc__) || defined (__PPC__) || defined (__ppc__) \\\n+      || defined (__POWERPC__) || defined (PPC) || defined (_IBMR2)\n+#  define SIZE 240\n+#else\n+#  define SIZE 256\n+#endif\n+\n+int foo (void)\n+{\n+  char arr[SIZE];\n+  arr[0] = 1;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-stack-usage \"foo\\t\\(256|264\\)\\tstatic\" } } */\n+/* { dg-final { cleanup-stack-usage } } */"}, {"sha": "30d7835f276384d23eb012644de2dd0ebe15b0b5", "filename": "gcc/testsuite/gcc.target/i386/stack-usage-realign.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-usage-realign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-usage-realign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-usage-realign.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-fstack-usage -msse2 -mforce-drap\" } */\n+\n+typedef int __attribute__((vector_size(16))) vec;\n+\n+vec foo (vec v)\n+{\n+  return v;\n+}\n+\n+int main (void)\n+{\n+  vec V;\n+  V = foo (V);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-stack-usage \"main\\t48\\tdynamic,bounded\" } } */\n+/* { dg-final { cleanup-stack-usage } } */"}, {"sha": "53db283db33cd2591fcad2dbd9526204190b139a", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1,5 +1,5 @@\n-#   Copyright (C) 1997, 1999, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n-#   Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1999, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+#   2010 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -460,6 +460,11 @@ proc cleanup-ipa-dump { suffix } {\n   cleanup-dump \"\\[0-9\\]\\[0-9\\]\\[0-9\\]i.$suffix\"\n }\n \n+# Remove a stack usage file for the current test.\n+proc cleanup-stack-usage { args } {\n+  cleanup-dump \"su\"\n+}\n+\n # Remove all dump files with the provided suffix.\n proc cleanup-dump { suffix } {\n     # This assumes that we are three frames down from dg-test or some other"}, {"sha": "cf8f8a71642791ecda9f7561d542ceb58223734d", "filename": "gcc/testsuite/lib/scanasm.exp", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Flib%2Fscanasm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftestsuite%2Flib%2Fscanasm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscanasm.exp?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -1,4 +1,5 @@\n-# Copyright (C) 2000, 2002, 2003, 2007, 2008 Free Software Foundation, Inc.\n+# Copyright (C) 2000, 2002, 2003, 2007, 2008, 2010\n+# Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -154,6 +155,28 @@ proc scan-file-not { output_file args } {\n     dg-scan \"scan-file-not\" 0 $testcase $output_file $args\n }\n \n+# Look for a pattern in the .su file produced by the compiler.  See\n+# dg-scan for details.\n+\n+proc scan-stack-usage { args } {\n+    upvar 2 name testcase\n+    set testcase [lindex $testcase 0]\n+    set output_file \"[file rootname [file tail $testcase]].su\"\n+\n+    dg-scan \"scan-file\" 1 $testcase $output_file $args\n+}\n+\n+# Check that a pattern is not present in the .su file produced by the\n+# compiler.  See dg-scan for details.\n+\n+proc scan-stack-usage-not { args } {\n+    upvar 2 name testcase\n+    set testcase [lindex $testcase 0]\n+    set output_file \"[file rootname [file tail $testcase]].su\"\n+\n+    dg-scan \"scan-file-not\" 0 $testcase $output_file $args\n+}\n+\n # Call pass if pattern is present given number of times, otherwise fail.\n proc scan-assembler-times { args } {\n     if { [llength $args] < 2 } {"}, {"sha": "8aa18229e94d872dd395c3464d70bc0a71f49bbf", "filename": "gcc/toplev.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -350,6 +350,7 @@ static const param_info lang_independent_params[] = {\n \n FILE *asm_out_file;\n FILE *aux_info_file;\n+FILE *stack_usage_file = NULL;\n FILE *dump_file = NULL;\n const char *dump_file_name;\n \n@@ -1584,6 +1585,88 @@ alloc_for_identifier_to_locale (size_t len)\n   return ggc_alloc_atomic (len);\n }\n \n+/* Output stack usage information.  */\n+void\n+output_stack_usage (void)\n+{\n+  static bool warning_issued = false;\n+  enum stack_usage_kind_type { STATIC = 0, DYNAMIC, DYNAMIC_BOUNDED };\n+  const char *stack_usage_kind_str[] = {\n+    \"static\",\n+    \"dynamic\",\n+    \"dynamic,bounded\"\n+  };\n+  HOST_WIDE_INT stack_usage = current_function_static_stack_size;\n+  enum stack_usage_kind_type stack_usage_kind;\n+  expanded_location loc;\n+  const char *raw_id, *id;\n+\n+  if (stack_usage < 0)\n+    {\n+      if (!warning_issued)\n+\t{\n+\t  warning (0, \"-fstack-usage not supported for this target\");\n+\t  warning_issued = true;\n+\t}\n+      return;\n+    }\n+\n+  stack_usage_kind = STATIC;\n+\n+  /* Add the maximum amount of space pushed onto the stack.  */\n+  if (current_function_pushed_stack_size > 0)\n+    {\n+      stack_usage += current_function_pushed_stack_size;\n+      stack_usage_kind = DYNAMIC_BOUNDED;\n+    }\n+\n+  /* Now on to the tricky part: dynamic stack allocation.  */\n+  if (current_function_allocates_dynamic_stack_space)\n+    {\n+      if (current_function_has_unbounded_dynamic_stack_size)\n+\tstack_usage_kind = DYNAMIC;\n+      else\n+\tstack_usage_kind = DYNAMIC_BOUNDED;\n+\n+      /* Add the size even in the unbounded case, this can't hurt.  */\n+      stack_usage += current_function_dynamic_stack_size;\n+    }\n+\n+  loc = expand_location (DECL_SOURCE_LOCATION (current_function_decl));\n+\n+  /* Strip the scope prefix if any.  */\n+  raw_id = lang_hooks.decl_printable_name (current_function_decl, 2);\n+  id = strrchr (raw_id, '.');\n+  if (id)\n+    id++;\n+  else\n+    id = raw_id;\n+\n+  fprintf (stack_usage_file,\n+\t   \"%s:%d:%d:%s\\t\"HOST_WIDE_INT_PRINT_DEC\"\\t%s\\n\",\n+\t   basename (loc.file),\n+\t   loc.line,\n+\t   loc.column,\n+\t   id,\n+\t   stack_usage,\n+\t   stack_usage_kind_str[stack_usage_kind]);\n+}\n+\n+/* Open an auxiliary output file.  */\n+static FILE *\n+open_auxiliary_file (const char *ext)\n+{\n+  char *filename;\n+  FILE *file;\n+\n+  filename = concat (aux_base_name, \".\", ext, NULL);\n+  file = fopen (filename, \"w\");\n+  if (!file)\n+    fatal_error (\"can't open %s for writing: %m\", filename);\n+  free (filename);\n+  return file;\n+}\n+\n /* Initialization of the front end environment, before command line\n    options are parsed.  Signal handlers, internationalization etc.\n    ARGV0 is main's argv[0].  */\n@@ -2199,6 +2282,10 @@ lang_dependent_init (const char *name)\n \n   init_asm_output (name);\n \n+  /* If stack usage information is desired, open the output file.  */\n+  if (flag_stack_usage)\n+    stack_usage_file = open_auxiliary_file (\"su\");\n+\n   /* This creates various _DECL nodes, so needs to be called after the\n      front end is initialized.  */\n   init_eh ();\n@@ -2280,6 +2367,9 @@ finalize (void)\n \tunlink_if_ordinary (asm_file_name);\n     }\n \n+  if (stack_usage_file)\n+    fclose (stack_usage_file);\n+\n   statistics_fini ();\n   finish_optimization_passes ();\n "}, {"sha": "5d431e687b64b26b4b5aaf9c91d1cf2dd87a7957", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3c12306971946ab9a9d644ddf7b26e9383d2391/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d3c12306971946ab9a9d644ddf7b26e9383d2391", "patch": "@@ -522,7 +522,8 @@ struct GTY(()) tree_common {\n            BLOCK\n            all decls\n \n-       CALL_FROM_THUNK_P in\n+       CALL_FROM_THUNK_P and\n+       ALLOCA_FOR_VAR_P in\n            CALL_EXPR\n \n    side_effects_flag:\n@@ -1329,6 +1330,10 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    thunked-to function.  */\n #define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n \n+/* In a CALL_EXPR, if the function being called is BUILT_IN_ALLOCA, means that\n+   it has been built for the declaration of a variable-sized object.  */\n+#define ALLOCA_FOR_VAR_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n+\n /* In a type, nonzero means that all objects of the type are guaranteed by the\n    language or front-end to be properly aligned, so we can indicate that a MEM\n    of this type is aligned at least to the alignment of the type, even if it"}]}