{"sha": "0160a2c7006d7c456e87acb37132f601a4632109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2MGEyYzcwMDZkN2M0NTZlODdhY2IzNzEzMmY2MDFhNDYzMjEwOQ==", "commit": {"author": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-07-04T07:25:39Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-07-04T07:25:39Z"}, "message": "re PR fortran/31198 (wrong code: Max() with optional arguments)\n\n\tPR fortran/31198\n\n\t* trans-intrinsic.c (trans-intrinsic.c): Handle optional\n\targuments correctly for MIN and MAX intrinsics.\n\n\t* gfortran.dg/min_max_optional_1.f90: New test.\n\t* gfortran.dg/min_max_optional_2.f90: New test.\n\t* gfortran.dg/min_max_optional_3.f90: New test.\n\nFrom-SVN: r126307", "tree": {"sha": "e4ae49bc19dd3192333c573f73ec660a220cec1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4ae49bc19dd3192333c573f73ec660a220cec1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0160a2c7006d7c456e87acb37132f601a4632109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0160a2c7006d7c456e87acb37132f601a4632109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0160a2c7006d7c456e87acb37132f601a4632109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0160a2c7006d7c456e87acb37132f601a4632109/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d5b5e1656f72ea2b232ddd01089673f58970c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d5b5e1656f72ea2b232ddd01089673f58970c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d5b5e1656f72ea2b232ddd01089673f58970c7"}], "stats": {"total": 134, "additions": 125, "deletions": 9}, "files": [{"sha": "77ec5111a4d4ee96ced8d3bf071881f183bb7a77", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0160a2c7006d7c456e87acb37132f601a4632109", "patch": "@@ -1,3 +1,9 @@\n+2007-07-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31198\n+\t* trans-intrinsic.c (trans-intrinsic.c): Handle optional\n+\targuments correctly for MIN and MAX intrinsics.\n+\n 2007-07-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/32545"}, {"sha": "8856f1965af8f4e9bab170bf92344e0cf1e167bb", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0160a2c7006d7c456e87acb37132f601a4632109", "patch": "@@ -1381,12 +1381,51 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n   tree val;\n   tree thencase;\n   tree elsecase;\n-  tree arg;\n+  tree arg, arg1, arg2;\n   tree type;\n+  gfc_actual_arglist *argexpr;\n+  unsigned int i;\n \n   arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg1 = TREE_VALUE (arg);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n   type = gfc_typenode_for_spec (&expr->ts);\n \n+  /* The first and second arguments should be present, if they are\n+     optional dummy arguments.  */\n+  argexpr = expr->value.function.actual;\n+  if (argexpr->expr->expr_type == EXPR_VARIABLE\n+      && argexpr->expr->symtree->n.sym->attr.optional\n+      && TREE_CODE (arg1) == INDIRECT_REF)\n+    {\n+      /* Check the first argument.  */\n+      tree cond;\n+      char *msg;\n+\n+      asprintf (&msg, \"First argument of '%s' intrinsic should be present\",\n+\t\texpr->symtree->n.sym->name);\n+      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (arg1, 0),\n+\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (arg1, 0)), 0));\n+      gfc_trans_runtime_check (cond, msg, &se->pre, &expr->where);\n+      gfc_free (msg);\n+    }\n+\n+  if (argexpr->next->expr->expr_type == EXPR_VARIABLE\n+      && argexpr->next->expr->symtree->n.sym->attr.optional\n+      && TREE_CODE (arg2) == INDIRECT_REF)\n+    {\n+      /* Check the second argument.  */\n+      tree cond;\n+      char *msg;\n+\n+      asprintf (&msg, \"Second argument of '%s' intrinsic should be present\",\n+\t\texpr->symtree->n.sym->name);\n+      cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (arg2, 0),\n+\t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (arg2, 0)), 0));\n+      gfc_trans_runtime_check (cond, msg, &se->pre, &expr->where);\n+      gfc_free (msg);\n+    }\n+\n   limit = TREE_VALUE (arg);\n   if (TREE_TYPE (limit) != type)\n     limit = convert (type, limit);\n@@ -1396,23 +1435,40 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \n   mvar = gfc_create_var (type, \"M\");\n   elsecase = build2_v (MODIFY_EXPR, mvar, limit);\n-  for (arg = TREE_CHAIN (arg); arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+  for (arg = TREE_CHAIN (arg), i = 0, argexpr = argexpr->next;\n+       arg != NULL_TREE; arg = TREE_CHAIN (arg), i++)\n     {\n+      tree cond;\n+\n       val = TREE_VALUE (arg);\n-      if (TREE_TYPE (val) != type)\n-\tval = convert (type, val);\n \n-      /* Only evaluate the argument once.  */\n-      if (TREE_CODE (val) != VAR_DECL && !TREE_CONSTANT (val))\n-        val = gfc_evaluate_now (val, &se->pre);\n+      /* Handle absent optional arguments by ignoring the comparison.  */\n+      if (i > 0 && argexpr->expr->expr_type == EXPR_VARIABLE\n+\t  && argexpr->expr->symtree->n.sym->attr.optional\n+\t  && TREE_CODE (val) == INDIRECT_REF)\n+\tcond = build2 (NE_EXPR, boolean_type_node, TREE_OPERAND (val, 0),\n+\t\t       build_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n+      else\n+      {\n+\tcond = NULL_TREE;\n+\n+\t/* Only evaluate the argument once.  */\n+\tif (TREE_CODE (val) != VAR_DECL && !TREE_CONSTANT (val))\n+\t  val = gfc_evaluate_now (val, &se->pre);\n+      }\n \n       thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n \n-      tmp = build2 (op, boolean_type_node, val, limit);\n+      tmp = build2 (op, boolean_type_node, convert (type, val), limit);\n       tmp = build3_v (COND_EXPR, tmp, thencase, elsecase);\n+\n+      if (cond != NULL_TREE)\n+\ttmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+\n       gfc_add_expr_to_block (&se->pre, tmp);\n       elsecase = build_empty_stmt ();\n       limit = mvar;\n+      argexpr = argexpr->next;\n     }\n   se->expr = mvar;\n }"}, {"sha": "71c389afc87d8d97c443cd88adce2d506dfff0f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0160a2c7006d7c456e87acb37132f601a4632109", "patch": "@@ -1,3 +1,10 @@\n+2007-07-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31198\n+\t* gfortran.dg/min_max_optional_1.f90: New test.\n+\t* gfortran.dg/min_max_optional_2.f90: New test.\n+\t* gfortran.dg/min_max_optional_3.f90: New test.\n+\n 2007-07-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/32545\n@@ -16,7 +23,7 @@\n 2007-07-03  Christopher D. Rickett  <crickett@lanl.gov>\n \n \tPR fortran/32579\n-        * gfortran.dg/iso_c_binding_only.f03: Updated test case.\n+\t* gfortran.dg/iso_c_binding_only.f03: Updated test case.\n \n 2007-07-03  Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "250010dffb966b15b8d096a38da5e552d45b0ad4", "filename": "gcc/testsuite/gfortran.dg/min_max_optional_1.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_1.f90?ref=0160a2c7006d7c456e87acb37132f601a4632109", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+IF (T1(1.0,1.0) .NE. (1.0,1.0) ) CALL ABORT()\n+IF (T1(1.0) .NE. (1.0,0.0)) CALL ABORT()\n+IF (M1(1,2,3) .NE. 3) CALL ABORT()\n+IF (M1(1,2,A4=4) .NE. 4) CALL ABORT()\n+CONTAINS\n+\n+COMPLEX FUNCTION T1(X,Y)\n+  REAL :: X\n+  REAL, OPTIONAL :: Y\n+  T1=CMPLX(X,Y)\n+END FUNCTION T1\n+\n+INTEGER FUNCTION M1(A1,A2,A3,A4)\n+  INTEGER :: A1,A2\n+  INTEGER, OPTIONAL :: A3,A4\n+  M1=MAX(A1,A2,A3,A4)\n+END FUNCTION M1\n+\n+END"}, {"sha": "51e0feee641a8f2f22a20f8f966de96ea42446ec", "filename": "gcc/testsuite/gfortran.dg/min_max_optional_2.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_2.f90?ref=0160a2c7006d7c456e87acb37132f601a4632109", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! { dg-shouldfail \"\" }\n+  program test \n+    if (m1(3,4) /= 4) call abort\n+    if (m1(3) /= 3) call abort\n+    print *, m1() \n+  contains \n+    integer function m1(a1,a2) \n+      integer, optional :: a1,a2 \n+      m1 = max(a2, a1, 1, 2) \n+    end function m1 \n+  end \n+! { dg-output \"First argument of 'max' intrinsic should be present\" }"}, {"sha": "e0e6e29d969d6a11db844b26b27d17565c1e9600", "filename": "gcc/testsuite/gfortran.dg/min_max_optional_3.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0160a2c7006d7c456e87acb37132f601a4632109/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_max_optional_3.f90?ref=0160a2c7006d7c456e87acb37132f601a4632109", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-shouldfail \"\" }\n+  program test \n+    if (m1(1,2,3,4) /= 1) call abort\n+    if (m1(1,2,3) /= 1) call abort\n+    if (m1(1,2) /= 1) call abort\n+    print *, m1(1) \n+    print *, m1() \n+  contains \n+    integer function m1(a1,a2,a3,a4) \n+      integer, optional :: a1,a2,a3,a4 \n+      m1 = min(a1,a2,a3,a4) ! { dg-output \"Second argument of 'min' intrinsic should be present\" }\n+    end function m1 \n+  end "}]}