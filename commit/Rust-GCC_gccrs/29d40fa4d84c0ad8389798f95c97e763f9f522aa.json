{"sha": "29d40fa4d84c0ad8389798f95c97e763f9f522aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkNDBmYTRkODRjMGFkODM4OTc5OGY5NWM5N2U3NjNmOWY1MjJhYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-10T21:28:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-10T21:28:27Z"}, "message": "(expand_divmod): If rem_flag, always force op0 to a register.\n\nFrom-SVN: r6053", "tree": {"sha": "d9cba89ff0f1ac1f0edabd3aa56b8d51b17d59f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9cba89ff0f1ac1f0edabd3aa56b8d51b17d59f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29d40fa4d84c0ad8389798f95c97e763f9f522aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d40fa4d84c0ad8389798f95c97e763f9f522aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29d40fa4d84c0ad8389798f95c97e763f9f522aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d40fa4d84c0ad8389798f95c97e763f9f522aa/comments", "author": null, "committer": null, "parents": [{"sha": "3fc2151db46c5f0e26f773520fe6c8af8c489e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fc2151db46c5f0e26f773520fe6c8af8c489e90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fc2151db46c5f0e26f773520fe6c8af8c489e90"}], "stats": {"total": 7, "additions": 4, "deletions": 3}, "files": [{"sha": "aff18612f9911b4a6dcf37e74a90519a4aefd847", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d40fa4d84c0ad8389798f95c97e763f9f522aa/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d40fa4d84c0ad8389798f95c97e763f9f522aa/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=29d40fa4d84c0ad8389798f95c97e763f9f522aa", "patch": "@@ -2403,8 +2403,9 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n       || code == ROUND_MOD_EXPR || code == ROUND_DIV_EXPR)\n     {\n       /* If we want the remainder, we may need to use OP0, so make sure\n-\t it and ADJUSTED_OP0 are in different registers.  If we want to\n-\t preserve subexpressions, make sure OP0 is in a register.\n+\t it and ADJUSTED_OP0 are in different registers.  We force OP0\n+\t to a register in case it has any queued subexpressions, because\n+\t emit_cmp_insn will call emit_queue.\n \n \t If we don't want the remainder, we aren't going to use OP0 anymore.\n \t However, if we cannot clobber OP0 (and hence ADJUSTED_OP0), we must\n@@ -2414,7 +2415,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t CAN_CLOBBER_OP0 will be zero and we know that OP0 cannot\n \t equal TARGET.  */\n \n-      if (rem_flag && preserve_subexpressions_p ())\n+      if (rem_flag)\n \top0 = force_reg (compute_mode, op0);\n \n       if (! can_clobber_op0)"}]}