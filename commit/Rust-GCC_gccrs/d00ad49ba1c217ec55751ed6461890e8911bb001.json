{"sha": "d00ad49ba1c217ec55751ed6461890e8911bb001", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAwYWQ0OWJhMWMyMTdlYzU1NzUxZWQ2NDYxODkwZTg5MTFiYjAwMQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2004-06-17T18:13:20Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2004-06-17T18:13:20Z"}, "message": "tree-cfg.c (tree_make_forwarder_block): Use SET_PHI_RESULT.\n\n\n2004-06-16  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-cfg.c (tree_make_forwarder_block):  Use SET_PHI_RESULT.\n\t* tree-flow-inline.h (get_use_op_ptr):  Return a use_operand_p.\n\t(get_use_from_ptr, get_def_from_ptr):  New.  Return operand pointers.\n\t(get_def_op_ptr):  Return a def_operand_p instead of a 'tree *'.\n\t(get_v_may_def_result_ptr):  Return a def_operand_p.\n\t(get_v_may_def_op_ptr, get_vuse_op_ptr):   Return a use_operand_p.\n\t(get_v_must_def_op_ptr):  Return a def_operand_p.\n\t(get_phi_result_ptr):  New.  Return a pointer to the result of a PHI.\n\t(get_phi_arg_def_ptr):  New.  Return a pointer to an argument of a PHI.\n\t(phi_element_for_edge):  Remove.\n\t* tree-flow.h (propagate_value, replace_exp):  Change prototype.\n\t(propagate_tree_value):  Add new prototype.\n\t(phi_element_for_edge):  Remove prototype.\n\t* tree-into-ssa.c (mark_def_sites):  Use new operand types.\n\t(prepare_operand_for_rename):  Split into two functions.\n\t(prepare_use_operand_for_rename):  Prepare use operands.\n\t(prepare_def_operand_for_rename):  Prepare def operands.\n\t(rewrite_stmt):  Use new operand types.\n\t(rewrite_operand):  Use new operand types, change parameter type.\n\t* tree-outof-ssa.c (replace_variable):  Split into two functions.\n\t(replace_use_variable):  Rewrite uses.\n\t(replace_def_variable):  Rewrite defs.\n\t(rewrite_trees, rewrite_vars_out_of_ssa):  Use new operand types.\n\t* tree-phinodes.c (make_phi_node, resize_phi_node):  Use new types.\n\t(add_phi_arg, remove_phi_arg_num):  Use new operand types.\n\t* tree-ssa-ccp.c (substitute_and_fold):  Use new operand types.\n\t(ccp_fold, replace_uses_in):  Use new operand types.\n\t* tree-ssa-copy.c (replace_ssa_names):  Rename to replace_ssa_names_ann\n\tand no longer set the value, change parameter type.\n\t(replace_exp_1):  Use new operand types.\n\t(propagate_value):  Change parameter type, use new operand types.\n\t(propagate_tree_value):  Propagate_value without SSA operands.\n\t(replace_exp, cprop_operand, cprop_into_stmt):  Use new operand types.\n\t(cprop_into_successor_phis):  Use new operand types.\n\t* tree-ssa-dom.c (thread_across_edge):  Use new operand types.\n\t(eliminate_redundant_computations):  Use new operand types.\n\t* tree-ssa-dse.c (fix_phi_uses):  Use new operand_types.\n\t(fix_stmt_v_may_defs):  Use new operand_types.\n\t* tree-ssa-live.c (create_ssa_var_map):  Use new operand_types.\n\t(build_tree_conflict_graph):  Use new operand_types.\n\t* tree-ssa-loop.c (duplicate_blocks):  Use PHI_ARG_DEF_FROM_EDGE.\n\t* tree-ssa-operands.c (struct freelist_d):  Remove.\n\t(check_optype_freelist, add_optype_freelist):  Remove.\n\t(allocate_def_optype, allocate_use_optype, allocate_v_may_def_optype,\n\tallocate_vuse_optype, allocate_v_must_def_optype):  Call ggc_alloc.\n\t(free_uses, free_defs, free_vuses, free_v_may_defs, free_v_must_defs):\n\tCall ggc_free instead of add_optype_freelist.\n\t(init_ssa_operands, fini_ssa_operands):  Remove free list code.\n\t(finalize_ssa_defs, finalize_ssa_uses):  Set new use/def operands.\n\t* tree-ssa-operands.h (struct def_optype_d):  Change underlying type.\n\t(struct use_optype_d):  Change underlying type.\n\t(def_operand_p, use_operand_p):  New types for pointers to operands.\n\t(USE_OP, DEF_OP, V_MAY_DEF_RESULT, V_MAY_DEF_OP, VUSE_OP,\n\tV_MUST_DEF_OP):  Use new pointer type instead of dereferencing directly.\n\t(USE_FROM_PTR, DEF_FROM_PTR):  New macros to \"dereference\" operand\n\tpointer types.\n\t(SET_USE, SET_DEF):  New macros to set operands from their pointer.\n\t(SET_USE_OP, SET_DEF_OP, SET_V_MAY_DEF_RESULT, SET_V_MAY_DEF_OP,\n\tSET_VUSE_OP, SET_V_MUST_DEF_OP): New SET routines for operands.\n\t(PHI_RESULT_PTR, PHI_RESULT, SET_PHI_RESULT):  Macros to manage the\n\tPHI result as an operand.\n\t(PHI_ARG_DEF_PTR, PHI_ARG_DEF, SET_PHI_ARG_DEF, PHI_ARG_DEF_FROM_EDGE,\n\tPHI_ARG_DEF_PTR_FROM_EDGE):  Macros to manage the PHI arguments.\n\t* tree-ssa-pre.c (eliminate):  Call propagate_tree_value.\n\t* tree-tailcall.c (independent_of_stmt_p, propagate_through_phis):  Use\n\tPHI_ARG_DEF_FROM_EDGE.\n\t* tree.h (PHI_RESULT):  Renamed to PHI_RESULT_TREE.\n\t(PHI_ARG_DEF):  Renamed to PHI_ARG_DEF_TREE.\n\nFrom-SVN: r83298", "tree": {"sha": "48e225e2383797232dc02a86ef7fbfa79ca1a610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48e225e2383797232dc02a86ef7fbfa79ca1a610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d00ad49ba1c217ec55751ed6461890e8911bb001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d00ad49ba1c217ec55751ed6461890e8911bb001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d00ad49ba1c217ec55751ed6461890e8911bb001", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d00ad49ba1c217ec55751ed6461890e8911bb001/comments", "author": null, "committer": null, "parents": [{"sha": "d7621d3c741403a604eab08b66658d71f3452e8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7621d3c741403a604eab08b66658d71f3452e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7621d3c741403a604eab08b66658d71f3452e8d"}], "stats": {"total": 706, "additions": 434, "deletions": 272}, "files": [{"sha": "3c4f826df78b1e90e31a3cd65d53832b2a0bdd5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -1,3 +1,74 @@\n+2004-06-17  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-cfg.c (tree_make_forwarder_block):  Use SET_PHI_RESULT.\n+\t* tree-flow-inline.h (get_use_op_ptr):  Return a use_operand_p.\n+\t(get_use_from_ptr, get_def_from_ptr):  New.  Return operand pointers.\n+\t(get_def_op_ptr):  Return a def_operand_p instead of a 'tree *'.\n+\t(get_v_may_def_result_ptr):  Return a def_operand_p.\n+\t(get_v_may_def_op_ptr, get_vuse_op_ptr):   Return a use_operand_p.\n+\t(get_v_must_def_op_ptr):  Return a def_operand_p.\n+\t(get_phi_result_ptr):  New.  Return a pointer to the result of a PHI.\n+\t(get_phi_arg_def_ptr):  New.  Return a pointer to an argument of a PHI.\n+\t(phi_element_for_edge):  Remove.\n+\t* tree-flow.h (propagate_value, replace_exp):  Change prototype.\n+\t(propagate_tree_value):  Add new prototype.\n+\t(phi_element_for_edge):  Remove prototype.\n+\t* tree-into-ssa.c (mark_def_sites):  Use new operand types.\n+\t(prepare_operand_for_rename):  Split into two functions.\n+\t(prepare_use_operand_for_rename):  Prepare use operands.\n+\t(prepare_def_operand_for_rename):  Prepare def operands.\n+\t(rewrite_stmt):  Use new operand types.\n+\t(rewrite_operand):  Use new operand types, change parameter type.\n+\t* tree-outof-ssa.c (replace_variable):  Split into two functions.\n+\t(replace_use_variable):  Rewrite uses.\n+\t(replace_def_variable):  Rewrite defs.\n+\t(rewrite_trees, rewrite_vars_out_of_ssa):  Use new operand types.\n+\t* tree-phinodes.c (make_phi_node, resize_phi_node):  Use new types.\n+\t(add_phi_arg, remove_phi_arg_num):  Use new operand types.\n+\t* tree-ssa-ccp.c (substitute_and_fold):  Use new operand types.\n+\t(ccp_fold, replace_uses_in):  Use new operand types.\n+\t* tree-ssa-copy.c (replace_ssa_names):  Rename to replace_ssa_names_ann\n+\tand no longer set the value, change parameter type.\n+\t(replace_exp_1):  Use new operand types.\n+\t(propagate_value):  Change parameter type, use new operand types.\n+\t(propagate_tree_value):  Propagate_value without SSA operands.\n+\t(replace_exp, cprop_operand, cprop_into_stmt):  Use new operand types.\n+\t(cprop_into_successor_phis):  Use new operand types.\n+\t* tree-ssa-dom.c (thread_across_edge):  Use new operand types.\n+\t(eliminate_redundant_computations):  Use new operand types.\n+\t* tree-ssa-dse.c (fix_phi_uses):  Use new operand_types.\n+\t(fix_stmt_v_may_defs):  Use new operand_types.\n+\t* tree-ssa-live.c (create_ssa_var_map):  Use new operand_types.\n+\t(build_tree_conflict_graph):  Use new operand_types.\n+\t* tree-ssa-loop.c (duplicate_blocks):  Use PHI_ARG_DEF_FROM_EDGE.\n+\t* tree-ssa-operands.c (struct freelist_d):  Remove.\n+\t(check_optype_freelist, add_optype_freelist):  Remove.\n+\t(allocate_def_optype, allocate_use_optype, allocate_v_may_def_optype,\n+\tallocate_vuse_optype, allocate_v_must_def_optype):  Call ggc_alloc.\n+\t(free_uses, free_defs, free_vuses, free_v_may_defs, free_v_must_defs):\n+\tCall ggc_free instead of add_optype_freelist.\n+\t(init_ssa_operands, fini_ssa_operands):  Remove free list code.\n+\t(finalize_ssa_defs, finalize_ssa_uses):  Set new use/def operands.\n+\t* tree-ssa-operands.h (struct def_optype_d):  Change underlying type.\n+\t(struct use_optype_d):  Change underlying type.\n+\t(def_operand_p, use_operand_p):  New types for pointers to operands.\n+\t(USE_OP, DEF_OP, V_MAY_DEF_RESULT, V_MAY_DEF_OP, VUSE_OP, \n+\tV_MUST_DEF_OP):  Use new pointer type instead of dereferencing directly.\n+\t(USE_FROM_PTR, DEF_FROM_PTR):  New macros to \"dereference\" operand \n+\tpointer types.\n+\t(SET_USE, SET_DEF):  New macros to set operands from their pointer.\n+\t(SET_USE_OP, SET_DEF_OP, SET_V_MAY_DEF_RESULT, SET_V_MAY_DEF_OP,\n+\tSET_VUSE_OP, SET_V_MUST_DEF_OP): New SET routines for operands.\n+\t(PHI_RESULT_PTR, PHI_RESULT, SET_PHI_RESULT):  Macros to manage the\n+\tPHI result as an operand.\n+\t(PHI_ARG_DEF_PTR, PHI_ARG_DEF, SET_PHI_ARG_DEF, PHI_ARG_DEF_FROM_EDGE,\n+\tPHI_ARG_DEF_PTR_FROM_EDGE):  Macros to manage the PHI arguments.\n+\t* tree-ssa-pre.c (eliminate):  Call propagate_tree_value.\n+\t* tree-tailcall.c (independent_of_stmt_p, propagate_through_phis):  Use\n+\tPHI_ARG_DEF_FROM_EDGE.\n+\t* tree.h (PHI_RESULT):  Renamed to PHI_RESULT_TREE.\n+\t(PHI_ARG_DEF):  Renamed to PHI_ARG_DEF_TREE.\n+\n 2004-06-17  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \tPR tree-optimization/15991"}, {"sha": "25d5b06ef47712ecca3548d1782b629a548692e3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -3747,7 +3747,7 @@ tree_make_forwarder_block (edge fallthru)\n       var = PHI_RESULT (phi);\n       new_phi = create_phi_node (var, bb);\n       SSA_NAME_DEF_STMT (var) = new_phi;\n-      PHI_RESULT (phi) = make_ssa_name (SSA_NAME_VAR (var), phi);\n+      SET_PHI_RESULT (phi, make_ssa_name (SSA_NAME_VAR (var), phi));\n       add_phi_arg (&new_phi, PHI_RESULT (phi), fallthru);\n     }\n "}, {"sha": "fbca4082b76a7ffc18fb75117901c029742dc933", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -272,8 +272,22 @@ get_v_must_def_ops (stmt_ann_t ann)\n   return ann ? ann->v_must_def_ops : NULL;\n }\n \n+/* Return the tree pointer to by USE.  */ \n+static inline tree\n+get_use_from_ptr (use_operand_p use)\n+{ \n+  return *(use.use);\n+} \n+\n+/* Return the tree pointer to by DEF.  */\n+static inline tree\n+get_def_from_ptr (def_operand_p def)\n+{\n+  return *(def.def);\n+}\n+\n /* Return a pointer to the tree that is at INDEX in the USES array.  */\n-static inline tree *\n+static inline use_operand_p\n get_use_op_ptr (use_optype uses, unsigned int index)\n {\n #ifdef ENABLE_CHECKING\n@@ -283,8 +297,8 @@ get_use_op_ptr (use_optype uses, unsigned int index)\n   return uses->uses[index];\n }\n \n-/* Return a pointer to the tree that is at INDEX in the DEFS array.  */\n-static inline tree *\n+/* Return a def_operand_p pointer for element INDEX of DEFS.  */\n+static inline def_operand_p\n get_def_op_ptr (def_optype defs, unsigned int index)\n {\n #ifdef ENABLE_CHECKING\n@@ -295,53 +309,79 @@ get_def_op_ptr (def_optype defs, unsigned int index)\n }\n \n \n-/* Return a pointer to the tree that is the V_MAY_DEF_RESULT for the V_MAY_DEF\n+/* Return the def_operand_p that is the V_MAY_DEF_RESULT for the V_MAY_DEF\n    at INDEX in the V_MAY_DEFS array.  */\n-static inline tree *\n+static inline def_operand_p\n get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n+  def_operand_p op;\n #ifdef ENABLE_CHECKING\n   if (index >= v_may_defs->num_v_may_defs)\n     abort();\n #endif\n-  return &(v_may_defs->v_may_defs[index * 2]);\n+  op.def = &(v_may_defs->v_may_defs[index * 2]);\n+  return op;\n }\n \n-/* Return a pointer to the tree that is the V_MAY_DEF_OP for the V_MAY_DEF at\n+/* Return a use_operand_p that is the V_MAY_DEF_OP for the V_MAY_DEF at\n    INDEX in the V_MAY_DEFS array.  */\n-static inline tree *\n+static inline use_operand_p\n get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n+  use_operand_p op;\n #ifdef ENABLE_CHECKING\n   if (index >= v_may_defs->num_v_may_defs)\n     abort();\n #endif\n-  return &(v_may_defs->v_may_defs[index * 2 + 1]);\n+  op.use = &(v_may_defs->v_may_defs[index * 2 + 1]);\n+  return op;\n }\n \n-/* Return a pointer to the tree that is at INDEX in the VUSES array.  */\n-static inline tree *\n+/* Return a use_operand_p that is at INDEX in the VUSES array.  */\n+static inline use_operand_p\n get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n {\n+  use_operand_p op;\n #ifdef ENABLE_CHECKING\n   if (index >= vuses->num_vuses)\n     abort();\n #endif\n-  return &(vuses->vuses[index]);\n+  op.use = &(vuses->vuses[index]);\n+  return op;\n }\n \n-/* Return a pointer to the tree that is the V_MUST_DEF_OP for the\n+/* Return a def_operand_p that is the V_MUST_DEF_OP for the\n    V_MUST_DEF at INDEX in the V_MUST_DEFS array.  */\n-static inline tree *\n+static inline def_operand_p\n get_v_must_def_op_ptr (v_must_def_optype v_must_defs, unsigned int index)\n {\n+  def_operand_p op;\n #ifdef ENABLE_CHECKING\n   if (index >= v_must_defs->num_v_must_defs)\n     abort();\n #endif\n-  return &(v_must_defs->v_must_defs[index]);\n+  op.def = &(v_must_defs->v_must_defs[index]);\n+  return op;\n }\n \n+/* Return a def_operand_p pointer for the result of PHI.  */\n+static inline def_operand_p\n+get_phi_result_ptr (tree phi)\n+{\n+  def_operand_p op;\n+  op.def = &(PHI_RESULT_TREE (phi));\n+  return op;\n+}\n+\n+/* Return a use_operand_p pointer for argument I of phinode PHI.  */\n+static inline use_operand_p\n+get_phi_arg_def_ptr (tree phi, int i)\n+{\n+  use_operand_p op;\n+  op.use = &(PHI_ARG_DEF_TREE (phi, i));\n+  return op;\n+}\n+ \n /* Mark the beginning of changes to the SSA operands for STMT.  */\n static inline void\n start_ssa_stmt_operands (tree stmt ATTRIBUTE_UNUSED)\n@@ -448,20 +488,6 @@ phi_arg_from_edge (tree phi, edge e)\n   return -1;\n }\n \n-\n-/* Return the phi argument number for an edge.  */\n-static inline struct phi_arg_d *\n-phi_element_for_edge (tree phi, edge e)\n-{\n-  int i;\n-\n-  i = phi_arg_from_edge (phi, e);\n-  if (i != -1)\n-    return &(PHI_ARG_ELT (phi, i));\n-  else\n-    return (struct phi_arg_d *)NULL;\n-}\n-\n /*  -----------------------------------------------------------------------  */\n \n /* Return true if T is an executable statement.  */"}, {"sha": "12b3b0961def7934e4076dd7bfd28a4eae5a84b7", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -580,14 +580,14 @@ extern void dump_dominator_optimization_stats (FILE *);\n extern void debug_dominator_optimization_stats (void);\n \n /* In tree-ssa-copy.c  */\n-extern void propagate_value (tree *, tree);\n-extern void replace_exp (tree *, tree);\n+extern void propagate_value (use_operand_p, tree);\n+extern void propagate_tree_value (tree *, tree);\n+extern void replace_exp (use_operand_p, tree);\n extern bool cprop_into_stmt (tree, varray_type);\n extern void cprop_into_successor_phis (basic_block, varray_type, bitmap);\n \n /* In tree-flow-inline.h  */\n static inline int phi_arg_from_edge (tree, edge);\n-static inline struct phi_arg_d *phi_element_for_edge (tree, edge);\n static inline bool may_propagate_copy (tree, tree);\n static inline bool is_call_clobbered (tree);\n static inline void mark_call_clobbered (tree);"}, {"sha": "0a20d2d8a43ff51829bfa819c5e93be8af3b3b32", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -109,11 +109,12 @@ static void mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n static void compute_global_livein (bitmap, bitmap);\n static void set_def_block (tree, basic_block);\n static void set_livein_block (tree, basic_block);\n-static bool prepare_operand_for_rename (tree *op_p, size_t *uid_p, bool);\n+static bool prepare_use_operand_for_rename (use_operand_p op_p, size_t *uid_p);\n+static bool prepare_def_operand_for_rename (tree def, size_t *uid_p);\n static void insert_phi_nodes (bitmap *);\n static void rewrite_stmt (struct dom_walk_data *, basic_block,\n \t\t\t  block_stmt_iterator);\n-static inline void rewrite_operand (tree *);\n+static inline void rewrite_operand (use_operand_p);\n static void insert_phi_nodes_for (tree, bitmap *, varray_type *);\n static tree get_reaching_def (tree);\n static hashval_t def_blocks_hash (const void *);\n@@ -231,21 +232,21 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   uses = USE_OPS (ann);\n   for (i = 0; i < NUM_USES (uses); i++)\n     {\n-      tree *use_p = USE_OP_PTR (uses, i);\n+      use_operand_p use_p = USE_OP_PTR (uses, i);\n \n-      if (prepare_operand_for_rename (use_p, &uid, true)\n+      if (prepare_use_operand_for_rename (use_p, &uid)\n \t  && !TEST_BIT (kills, uid))\n-\tset_livein_block (*use_p, bb);\n+\tset_livein_block (USE_FROM_PTR (use_p), bb);\n     }\n \t  \n   /* Similarly for virtual uses.  */\n   vuses = VUSE_OPS (ann);\n   for (i = 0; i < NUM_VUSES (vuses); i++)\n     {\n-      tree *use_p = VUSE_OP_PTR (vuses, i);\n+      use_operand_p use_p = VUSE_OP_PTR (vuses, i);\n \n-      if (prepare_operand_for_rename (use_p, &uid, true))\n-\tset_livein_block (*use_p, bb);\n+      if (prepare_use_operand_for_rename (use_p, &uid))\n+\tset_livein_block (USE_FROM_PTR (use_p), bb);\n     }\n \n   /* Note that virtual definitions are irrelevant for computing KILLS\n@@ -256,15 +257,15 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   v_may_defs = V_MAY_DEF_OPS (ann);\n   for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      if (prepare_operand_for_rename (V_MAY_DEF_OP_PTR (v_may_defs, i), \n-                                      &uid, true))\n+      use_operand_p use_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n+      if (prepare_use_operand_for_rename (use_p, &uid))\n \t{\n \t  /* If we do not already have an SSA_NAME for our destination,\n \t     then set the destination to the source.  */\n \t  if (TREE_CODE (V_MAY_DEF_RESULT (v_may_defs, i)) != SSA_NAME)\n-\t    V_MAY_DEF_RESULT (v_may_defs, i) = V_MAY_DEF_OP (v_may_defs, i);\n+\t    SET_V_MAY_DEF_RESULT (v_may_defs, i, USE_FROM_PTR (use_p));\n \t    \n-          set_livein_block (V_MAY_DEF_OP (v_may_defs, i), bb);\n+          set_livein_block (USE_FROM_PTR (use_p), bb);\n \t  set_def_block (V_MAY_DEF_RESULT (v_may_defs, i), bb);\n \t}\n     }\n@@ -273,11 +274,11 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   v_must_defs = V_MUST_DEF_OPS (ann);\n   for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n     {\n-      tree *def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n+      tree def = V_MUST_DEF_OP (v_must_defs, i);\n \n-      if (prepare_operand_for_rename (def_p, &uid, false))\n+      if (prepare_def_operand_for_rename (def, &uid))\n \t{\n-\t  set_def_block (*def_p, bb);\n+\t  set_def_block (def, bb);\n \t  SET_BIT (kills, uid);\n \t}\n     }\n@@ -287,11 +288,11 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   defs = DEF_OPS (ann);\n   for (i = 0; i < NUM_DEFS (defs); i++)\n     {\n-      tree *def_p = DEF_OP_PTR (defs, i);\n+      tree def = DEF_OP (defs, i);\n \n-      if (prepare_operand_for_rename (def_p, &uid, false))\n+      if (prepare_def_operand_for_rename (def, &uid))\n \t{\n-\t  set_def_block (*def_p, bb);\n+\t  set_def_block (def, bb);\n \t  SET_BIT (kills, uid);\n \t}\n     }\n@@ -367,21 +368,16 @@ set_livein_block (tree var, basic_block bb)\n }\n \n \n-/* If the operand pointed to by OP_P needs to be renamed, then\n-\n-     1. If OP_P is used (rather than set), then strip away any SSA_NAME\n-        wrapping the operand.\n-\n-     2. Set *UID_P to the underlying variable's uid.\n-\n-     3. Return true.\n-\n-   Otherwise return false.  */\n+/* If the use operand pointed to by OP_P needs to be renamed, then strip away \n+   any SSA_NAME wrapping the operand, set *UID_P to the underlying variable's \n+   uid, and return true.  Otherwise return false.  If the operand was an \n+   SSA_NAME, change it to the stipped name.  */\n \n static bool\n-prepare_operand_for_rename (tree *op_p, size_t *uid_p, bool is_use)\n+prepare_use_operand_for_rename (use_operand_p op_p, size_t *uid_p)\n {\n-  tree var = (TREE_CODE (*op_p) != SSA_NAME) ? *op_p : SSA_NAME_VAR (*op_p);\n+  tree use = USE_FROM_PTR (op_p);\n+  tree var = (TREE_CODE (use) != SSA_NAME) ? use : SSA_NAME_VAR (use);\n   *uid_p = var_ann (var)->uid;\n \n   /* Ignore variables that don't need to be renamed.  */\n@@ -394,12 +390,28 @@ prepare_operand_for_rename (tree *op_p, size_t *uid_p, bool is_use)\n      By not throwing away SSA_NAMEs on assignments, we avoid a lot of \n      useless churn of SSA_NAMEs without having to overly complicate the\n      renamer.  */\n-  if (TREE_CODE (*op_p) == SSA_NAME && is_use)\n-    *op_p = var;\n+  if (TREE_CODE (use) == SSA_NAME)\n+    SET_USE (op_p, var);\n \n   return true;\n }\n \n+/* If the def variable DEF needs to be renamed, then strip away any SSA_NAME \n+   wrapping the operand, set *UID_P to the underlying variable's uid and return\n+   true.  Otherwise return false.  */\n+\n+static bool\n+prepare_def_operand_for_rename (tree def, size_t *uid_p)\n+{\n+  tree var = (TREE_CODE (def) != SSA_NAME) ? def : SSA_NAME_VAR (def);\n+  *uid_p = var_ann (var)->uid;\n+\n+  /* Ignore variables that don't need to be renamed.  */\n+  if (vars_to_rename && !bitmap_bit_p (vars_to_rename, *uid_p))\n+    return false;\n+\n+  return true;\n+}\n \n /* Helper for insert_phi_nodes.  If VAR needs PHI nodes, insert them\n    at the dominance frontier (DFS) of blocks defining VAR.  */\n@@ -774,14 +786,14 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n   /* Step 2.  Register the statement's DEF and VDEF operands.  */\n   for (i = 0; i < NUM_DEFS (defs); i++)\n     {\n-      tree *def_p = DEF_OP_PTR (defs, i);\n+      def_operand_p def_p = DEF_OP_PTR (defs, i);\n \n-      if (TREE_CODE (*def_p) != SSA_NAME)\n-\t*def_p = make_ssa_name (*def_p, stmt);\n+      if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n+\tSET_DEF (def_p, make_ssa_name (DEF_FROM_PTR (def_p), stmt));\n \n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n-      register_new_def (*def_p, &bd->block_defs);\n+      register_new_def (DEF_FROM_PTR (def_p), &bd->block_defs);\n     }\n \n   /* Register new virtual definitions made by the statement.  */\n@@ -790,8 +802,9 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n       rewrite_operand (V_MAY_DEF_OP_PTR (v_may_defs, i));\n \n       if (TREE_CODE (V_MAY_DEF_RESULT (v_may_defs, i)) != SSA_NAME)\n-\t*V_MAY_DEF_RESULT_PTR (v_may_defs, i)\n-\t  = make_ssa_name (V_MAY_DEF_RESULT (v_may_defs, i), stmt);\n+\tSET_V_MAY_DEF_RESULT (v_may_defs, i,\n+\t\t\t      make_ssa_name (V_MAY_DEF_RESULT (v_may_defs, i), \n+\t\t\t\t\t     stmt));\n \n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n@@ -801,27 +814,28 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n   /* Register new virtual mustdefs made by the statement.  */\n   for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n     {\n-      tree *v_must_def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n+      def_operand_p v_must_def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n \n-      if (TREE_CODE (*v_must_def_p) != SSA_NAME)\n-\t*v_must_def_p = make_ssa_name (*v_must_def_p, stmt);\n+      if (TREE_CODE (DEF_FROM_PTR (v_must_def_p)) != SSA_NAME)\n+\tSET_DEF (v_must_def_p, \n+\t\t make_ssa_name (DEF_FROM_PTR (v_must_def_p), stmt));\n \n       /* FIXME: We shouldn't be registering new mustdefs if the variable\n \t doesn't need to be renamed.  */\n-      register_new_def (*v_must_def_p, &bd->block_defs);\n+      register_new_def (DEF_FROM_PTR (v_must_def_p), &bd->block_defs);\n     }\n     \n }\n \n \n-/* Replace the operand pointed by OP_P with its immediate reaching\n+/* Replace the use operand pointed by OP_P with its immediate reaching\n    definition.  */\n \n static inline void\n-rewrite_operand (tree *op_p)\n+rewrite_operand (use_operand_p op_p)\n {\n-  if (TREE_CODE (*op_p) != SSA_NAME)\n-    *op_p = get_reaching_def (*op_p);\n+  if (TREE_CODE (USE_FROM_PTR (op_p)) != SSA_NAME)\n+    SET_USE (op_p, get_reaching_def (USE_FROM_PTR (op_p)));\n }\n \n "}, {"sha": "28c802381d077dbe9f157fdcb3f8d1fc51e65383", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -116,7 +116,8 @@ static void elim_create (elim_graph, int);\n static void eliminate_phi (edge, int, elim_graph);\n static tree_live_info_p coalesce_ssa_name (var_map, int);\n static void assign_vars (var_map);\n-static bool replace_variable (var_map, tree *, tree *);\n+static bool replace_use_variable (var_map, use_operand_p, tree *);\n+static bool replace_def_variable (var_map, def_operand_p, tree *);\n static void eliminate_virtual_phis (void);\n static void coalesce_abnormal_edges (var_map, conflict_graph, root_var_p);\n static void print_exprs (FILE *, const char *, tree, const char *, tree,\n@@ -922,25 +923,25 @@ assign_vars (var_map map)\n }\n \n \n-/* Replace *P with whatever variable it has been rewritten to based on the \n-   partitions in MAP.  EXPR is an optional expression vector over SSA versions\n-   which is used to replace *P with an expression instead of a variable.  \n+/* Replace use operand P with whatever variable it has been rewritten to based \n+   on the partitions in MAP.  EXPR is an optional expression vector over SSA \n+   versions which is used to replace P with an expression instead of a variable.\n    If the stmt is changed, return true.  */ \n \n static inline bool\n-replace_variable (var_map map, tree *p, tree *expr)\n+replace_use_variable (var_map map, use_operand_p p, tree *expr)\n {\n   tree new_var;\n-  tree var = *p;\n+  tree var = USE_FROM_PTR (p);\n \n   /* Check if we are replacing this variable with an expression.  */\n   if (expr)\n     {\n-      int version = SSA_NAME_VERSION (*p);\n+      int version = SSA_NAME_VERSION (var);\n       if (expr[version])\n         {\n \t  tree new_expr = TREE_OPERAND (expr[version], 1);\n-\t  *p = new_expr;\n+\t  SET_USE (p, new_expr);\n \t  /* Clear the stmt's RHS, or GC might bite us.  */\n \t  TREE_OPERAND (expr[version], 1) = NULL_TREE;\n \t  return true;\n@@ -950,7 +951,43 @@ replace_variable (var_map map, tree *p, tree *expr)\n   new_var = var_to_partition_to_var (map, var);\n   if (new_var)\n     {\n-      *p = new_var;\n+      SET_USE (p, new_var);\n+      set_is_used (new_var);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n+/* Replace def operand DEF_P with whatever variable it has been rewritten to \n+   based on the partitions in MAP.  EXPR is an optional expression vector over\n+   SSA versions which is used to replace DEF_P with an expression instead of a \n+   variable.  If the stmt is changed, return true.  */ \n+\n+static inline bool\n+replace_def_variable (var_map map, def_operand_p def_p, tree *expr)\n+{\n+  tree new_var;\n+  tree var = DEF_FROM_PTR (def_p);\n+\n+  /* Check if we are replacing this variable with an expression.  */\n+  if (expr)\n+    {\n+      int version = SSA_NAME_VERSION (var);\n+      if (expr[version])\n+        {\n+\t  tree new_expr = TREE_OPERAND (expr[version], 1);\n+\t  SET_DEF (def_p, new_expr);\n+\t  /* Clear the stmt's RHS, or GC might bite us.  */\n+\t  TREE_OPERAND (expr[version], 1) = NULL_TREE;\n+\t  return true;\n+\t}\n+    }\n+\n+  new_var = var_to_partition_to_var (map, var);\n+  if (new_var)\n+    {\n+      SET_DEF (def_p, new_var);\n       set_is_used (new_var);\n       return true;\n     }\n@@ -1832,7 +1869,7 @@ rewrite_trees (var_map map, tree *values)\n \t  use_optype uses;\n \t  def_optype defs;\n \t  tree stmt = bsi_stmt (si);\n-\t  tree *use_p = NULL;\n+\t  use_operand_p use_p;\n \t  int remove = 0, is_copy = 0;\n \t  stmt_ann_t ann;\n \n@@ -1850,7 +1887,7 @@ rewrite_trees (var_map map, tree *values)\n \t  for (i = 0; i < num_uses; i++)\n \t    {\n \t      use_p = USE_OP_PTR (uses, i);\n-\t      if (replace_variable (map, use_p, values))\n+\t      if (replace_use_variable (map, use_p, values))\n \t        changed = true;\n \t    }\n \n@@ -1871,18 +1908,16 @@ rewrite_trees (var_map map, tree *values)\n \t    {\n \t      for (i = 0; i < num_defs; i++)\n \t\t{\n-\t\t  tree *def_p = DEF_OP_PTR (defs, i);\n+\t\t  def_operand_p def_p = DEF_OP_PTR (defs, i);\n \n-\t\t  if (replace_variable (map, def_p, NULL))\n+\t\t  if (replace_def_variable (map, def_p, NULL))\n \t\t    changed = true;\n \n \t\t  /* If both SSA_NAMEs coalesce to the same variable,\n \t\t     mark the now redundant copy for removal.  */\n \t\t  if (is_copy\n \t\t      && num_uses == 1\n-\t\t      && use_p\n-\t\t      && def_p\n-\t\t      && (*def_p == *use_p))\n+\t\t      && (DEF_FROM_PTR (def_p) == USE_OP (uses, 0)))\n \t\t    remove = 1;\n \t\t}\n \t      if (changed)\n@@ -2074,7 +2109,7 @@ rewrite_vars_out_of_ssa (bitmap vars)\n \t\t      SSA_NAME_DEF_STMT (new_name) = copy;\n \n \t\t      /* Now make the argument reference our new SSA_NAME.  */\n-\t\t      PHI_ARG_DEF (phi, i) = new_name;\n+\t\t      SET_PHI_ARG_DEF (phi, i, new_name);\n \n \t\t      /* Queue the statement for insertion.  */\n \t\t      bsi_insert_on_edge (PHI_ARG_EDGE (phi, i), copy);"}, {"sha": "dc2a2294e7fea48a0480fae6b0d373fea12a69dc", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -203,9 +203,9 @@ make_phi_node (tree var, int len)\n   TREE_SET_CODE (phi, PHI_NODE);\n   PHI_ARG_CAPACITY (phi) = len;\n   if (TREE_CODE (var) == SSA_NAME)\n-    PHI_RESULT (phi) = var;\n+    SET_PHI_RESULT (phi, var);\n   else\n-    PHI_RESULT (phi) = make_ssa_name (var, phi);\n+    SET_PHI_RESULT (phi, make_ssa_name (var, phi));\n \n   return phi;\n }\n@@ -278,7 +278,7 @@ resize_phi_node (tree *phi, int len)\n                                                                                 \n   for (i = old_len; i < len; i++)\n     {\n-      PHI_ARG_DEF (new_phi, i) = NULL_TREE;\n+      SET_PHI_ARG_DEF (new_phi, i, NULL_TREE);\n       PHI_ARG_EDGE (new_phi, i) = NULL;\n       PHI_ARG_NONZERO (new_phi, i) = false;\n     }\n@@ -365,7 +365,7 @@ add_phi_arg (tree *phi, tree def, edge e)\n       SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (*phi)) = 1;\n     }\n \n-  PHI_ARG_DEF (*phi, i) = def;\n+  SET_PHI_ARG_DEF (*phi, i, def);\n   PHI_ARG_EDGE (*phi, i) = e;\n   PHI_ARG_NONZERO (*phi, i) = false;\n   PHI_NUM_ARGS (*phi)++;\n@@ -408,13 +408,13 @@ remove_phi_arg_num (tree phi, int i)\n      with the element we want to delete.  */\n   if (i != num_elem - 1)\n     {\n-      PHI_ARG_DEF (phi, i) = PHI_ARG_DEF (phi, num_elem - 1);\n+      SET_PHI_ARG_DEF (phi, i, PHI_ARG_DEF (phi, num_elem - 1));\n       PHI_ARG_EDGE (phi, i) = PHI_ARG_EDGE (phi, num_elem - 1);\n       PHI_ARG_NONZERO (phi, i) = PHI_ARG_NONZERO (phi, num_elem - 1);\n     }\n \n   /* Shrink the vector and return.  */\n-  PHI_ARG_DEF (phi, num_elem - 1) = NULL_TREE;\n+  SET_PHI_ARG_DEF (phi, num_elem - 1, NULL_TREE);\n   PHI_ARG_EDGE (phi, num_elem - 1) = NULL;\n   PHI_ARG_NONZERO (phi, num_elem - 1) = false;\n   PHI_NUM_ARGS (phi)--;"}, {"sha": "53a67a63b8562651ae0eb0a94c8d51d7467885e9", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -389,15 +389,16 @@ substitute_and_fold (void)\n \t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n \t    {\n \t      value *new_val;\n-\t      tree *orig_p = &PHI_ARG_DEF (phi, i);\n+\t      use_operand_p orig_p = PHI_ARG_DEF_PTR (phi, i);\n+\t      tree orig = USE_FROM_PTR (orig_p);\n \n-\t      if (! SSA_VAR_P (*orig_p))\n+\t      if (! SSA_VAR_P (orig))\n \t\tbreak;\n \n-\t      new_val = get_value (*orig_p);\n+\t      new_val = get_value (orig);\n \t      if (new_val->lattice_val == CONSTANT\n-\t\t  && may_propagate_copy (*orig_p, new_val->const_val))\n-\t\t*orig_p = new_val->const_val;\n+\t\t  && may_propagate_copy (orig, new_val->const_val))\n+\t\tSET_USE (orig_p, new_val->const_val);\n \t    }\n \t}\n \n@@ -948,7 +949,7 @@ ccp_fold (tree stmt)\n \n \t  /* Restore operands to their original form.  */\n \t  for (i = 0; i < NUM_USES (uses); i++)\n-\t    *(USE_OP_PTR (uses, i)) = orig[i];\n+\t    SET_USE_OP (uses, i, orig[i]);\n \t  free (orig);\n \t}\n     }\n@@ -1422,14 +1423,15 @@ replace_uses_in (tree stmt, bool *replaced_addresses_p)\n   uses = STMT_USE_OPS (stmt);\n   for (i = 0; i < NUM_USES (uses); i++)\n     {\n-      tree *use = USE_OP_PTR (uses, i);\n-      value *val = get_value (*use);\n+      use_operand_p use = USE_OP_PTR (uses, i);\n+      value *val = get_value (USE_FROM_PTR (use));\n \n       if (val->lattice_val == CONSTANT)\n \t{\n-\t  *use = val->const_val;\n+\t  SET_USE (use, val->const_val);\n \t  replaced = true;\n-\t  if (POINTER_TYPE_P (TREE_TYPE (*use)) && replaced_addresses_p)\n+\t  if (POINTER_TYPE_P (TREE_TYPE (USE_FROM_PTR (use))) \n+\t      && replaced_addresses_p)\n \t    *replaced_addresses_p = true;\n \t}\n     }"}, {"sha": "32db3fa3d868589360a87e9ba3bb2eac1e77c4fc", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -54,31 +54,33 @@ Boston, MA 02111-1307, USA.  */\n    replacements of one SSA_NAME with a different SSA_NAME to use the\n    APIs defined in this file.  */\n \n-/* Given two SSA_NAMEs, replace the one pointed to by OP_P with VAR.\n \n-   If *OP_P is a pointer, copy the memory tag used originally by *OP_P into\n+/* Given two SSA_NAMEs, replace the annotations for the one referred to by OP \n+   with VAR's annmoptations.\n+\n+   If OP is a pointer, copy the memory tag used originally by OP into\n    VAR.  This is needed in cases where VAR had never been dereferenced in the\n    program.\n \n    If FOR_PROPAGATION is true, then perform additional checks to ensure\n-   that const/copy propagation of var for *OP_P is valid.  */\n+   that const/copy propagation of var for OP is valid.  */\n    \n static void\n-replace_ssa_names (tree *op_p,\n+replace_ssa_names_ann (tree op,\n \t\t   tree var,\n \t\t   bool for_propagation ATTRIBUTE_UNUSED)\n {\n #if defined ENABLE_CHECKING\n-  if (for_propagation && !may_propagate_copy (*op_p, var))\n+  if (for_propagation && !may_propagate_copy (op, var))\n     abort ();\n #endif\n \n   /* If VAR doesn't have a memory tag, copy the one from the original\n      operand.  Also copy the dereferenced flags.  */\n-  if (POINTER_TYPE_P (TREE_TYPE (*op_p)))\n+  if (POINTER_TYPE_P (TREE_TYPE (op)))\n     {\n       var_ann_t new_ann = var_ann (SSA_NAME_VAR (var));\n-      var_ann_t orig_ann = var_ann (SSA_NAME_VAR (*op_p));\n+      var_ann_t orig_ann = var_ann (SSA_NAME_VAR (op));\n \n       if (new_ann->type_mem_tag == NULL_TREE)\n \tnew_ann->type_mem_tag = orig_ann->type_mem_tag;\n@@ -88,26 +90,25 @@ replace_ssa_names (tree *op_p,\n \tabort ();\n     }\n \n-  *op_p = var;\n-}\n+}   \n+\n \n /* Common code for propagate_value and replace_exp.\n \n-   Replace *OP_P with VAL.  FOR_PROPAGATION indicates if the replacement\n-   is done to propagate a value or not.  */\n+   Replace use operand OP_P with VAL.  FOR_PROPAGATION indicates if the \n+   replacement is done to propagate a value or not.  */\n \n static void\n-replace_exp_1 (tree *op_p, tree val, bool for_propagation)\n+replace_exp_1 (use_operand_p op_p, tree val, bool for_propagation)\n {\n   if (TREE_CODE (val) == SSA_NAME)\n     {\n-      if (TREE_CODE (*op_p) == SSA_NAME)\n-\treplace_ssa_names (op_p, val, for_propagation);\n-      else\n-\t*op_p = val;\n+      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n+\treplace_ssa_names_ann (USE_FROM_PTR (op_p), val, for_propagation);\n+      SET_USE (op_p, val);\n     }\n   else\n-    *op_p = lhd_unsave_expr_now (val);\n+    SET_USE (op_p, lhd_unsave_expr_now (val));\n }\n \n /* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n@@ -117,19 +118,40 @@ replace_exp_1 (tree *op_p, tree val, bool for_propagation)\n    checks to ensure validity of the const/copy propagation.  */\n \n void\n-propagate_value (tree *op_p, tree val)\n+propagate_value (use_operand_p op_p, tree val)\n {\n   replace_exp_1 (op_p, val, true);\n }\n \n+/* Propagate the value VAL (assumed to be a constant or another SSA_NAME)\n+   into the tree pointed by OP_P.\n+\n+   Use this version for const/copy propagation when SSA operands are not \n+   available.  It will perform the additional checks to ensure validity of \n+   the const/copy propagation, but will not update any operand information.\n+   Be sure to mark the stmt as modified.  */\n+\n+void\n+propagate_tree_value (tree *op_p, tree val)\n+{\n+  if (TREE_CODE (val) == SSA_NAME)\n+    {\n+      if (TREE_CODE (*op_p) == SSA_NAME)\n+\treplace_ssa_names_ann (*op_p, val, true);\n+      *op_p = val;\n+    }\n+  else\n+    *op_p = lhd_unsave_expr_now (val);\n+}\n+\n /* Replace *OP_P with value VAL (assumed to be a constant or another SSA_NAME).\n \n    Use this version when not const/copy propagating values.  For example,\n    PRE uses this version when building expressions as they would appear\n    in specific blocks taking into account actions of PHI nodes.  */\n \n void\n-replace_exp (tree *op_p, tree val)\n+replace_exp (use_operand_p op_p, tree val)\n {\n   replace_exp_1 (op_p, val, false);\n }\n@@ -138,15 +160,16 @@ replace_exp (tree *op_p, tree val)\n    CONST_AND_COPIES.  */\n \n static bool\n-cprop_operand (stmt_ann_t ann, tree *op_p, varray_type const_and_copies)\n+cprop_operand (stmt_ann_t ann, use_operand_p op_p, varray_type const_and_copies)\n {\n   bool may_have_exposed_new_symbols = false;\n   tree val;\n+  tree op = USE_FROM_PTR (op_p);\n \n   /* If the operand has a known constant value or it is known to be a\n      copy of some other variable, use the value or copy stored in\n      CONST_AND_COPIES.  */\n-  val = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (*op_p));\n+  val = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (op));\n   if (val)\n     {\n       tree op_type, val_type;\n@@ -156,13 +179,13 @@ cprop_operand (stmt_ann_t ann, tree *op_p, varray_type const_and_copies)\n \t the renamed virtual operand if we later modify this\n \t statement.  Also only allow the new value to be an SSA_NAME\n \t for propagation into virtual operands.  */\n-      if (!is_gimple_reg (*op_p)\n-\t  && (get_virtual_var (val) != get_virtual_var (*op_p)\n+      if (!is_gimple_reg (op)\n+\t  && (get_virtual_var (val) != get_virtual_var (op)\n \t      || TREE_CODE (val) != SSA_NAME))\n \treturn false;\n \n       /* Get the toplevel type of each operand.  */\n-      op_type = TREE_TYPE (*op_p);\n+      op_type = TREE_TYPE (op);\n       val_type = TREE_TYPE (val);\n \n       /* While both types are pointers, get the type of the object\n@@ -180,7 +203,7 @@ cprop_operand (stmt_ann_t ann, tree *op_p, varray_type const_and_copies)\n      if (!lang_hooks.types_compatible_p (op_type, val_type)\n            && TREE_CODE (val) != SSA_NAME)\n \t{\n-\t  val = fold_convert (TREE_TYPE (*op_p), val);\n+\t  val = fold_convert (TREE_TYPE (op), val);\n \t  if (!is_gimple_min_invariant (val)\n \t      && TREE_CODE (val) != SSA_NAME)\n \t    return false;\n@@ -190,14 +213,14 @@ cprop_operand (stmt_ann_t ann, tree *op_p, varray_type const_and_copies)\n \t to their interaction with exception handling and some GCC\n \t extensions.  */\n       if (TREE_CODE (val) == SSA_NAME\n-\t  && !may_propagate_copy (*op_p, val))\n+\t  && !may_propagate_copy (op, val))\n \treturn false;\n \n       /* Dump details.  */\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"  Replaced '\");\n-\t  print_generic_expr (dump_file, *op_p, dump_flags);\n+\t  print_generic_expr (dump_file, op, dump_flags);\n \t  fprintf (dump_file, \"' with %s '\",\n \t\t   (TREE_CODE (val) != SSA_NAME ? \"constant\" : \"variable\"));\n \t  print_generic_expr (dump_file, val, dump_flags);\n@@ -207,7 +230,7 @@ cprop_operand (stmt_ann_t ann, tree *op_p, varray_type const_and_copies)\n       /* If VAL is an ADDR_EXPR or a constant of pointer type, note\n \t that we may have exposed a new symbol for SSA renaming.  */\n       if (TREE_CODE (val) == ADDR_EXPR\n-\t  || (POINTER_TYPE_P (TREE_TYPE (*op_p))\n+\t  || (POINTER_TYPE_P (TREE_TYPE (op))\n \t      && is_gimple_min_invariant (val)))\n \tmay_have_exposed_new_symbols = true;\n \n@@ -241,8 +264,8 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n   num_uses = NUM_USES (uses);\n   for (i = 0; i < num_uses; i++)\n     {\n-      tree *op_p = USE_OP_PTR (uses, i);\n-      if (TREE_CODE (*op_p) == SSA_NAME)\n+      use_operand_p op_p = USE_OP_PTR (uses, i);\n+      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n \t  |= cprop_operand (ann, op_p, const_and_copies);\n     }\n@@ -251,8 +274,8 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n   num_vuses = NUM_VUSES (vuses);\n   for (i = 0; i < num_vuses; i++)\n     {\n-      tree *op_p = VUSE_OP_PTR (vuses, i);\n-      if (TREE_CODE (*op_p) == SSA_NAME)\n+      use_operand_p op_p = VUSE_OP_PTR (vuses, i);\n+      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n \t  |= cprop_operand (ann, op_p, const_and_copies);\n     }\n@@ -261,8 +284,8 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n   num_v_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n   for (i = 0; i < num_v_may_defs; i++)\n     {\n-      tree *op_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n-      if (TREE_CODE (*op_p) == SSA_NAME)\n+      use_operand_p op_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n+      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n \t  |= cprop_operand (ann, op_p, const_and_copies);\n     }\n@@ -317,7 +340,8 @@ cprop_into_successor_phis (basic_block bb,\n \t{\n \t  int i;\n \t  tree new;\n-\t  tree *orig_p;\n+\t  use_operand_p orig_p;\n+\t  tree orig;\n \n \t  /* If the hint is valid (!= phi_num_args), see if it points\n \t     us to the desired phi alternative.  */\n@@ -343,22 +367,23 @@ cprop_into_successor_phis (basic_block bb,\n \n \t  /* The alternative may be associated with a constant, so verify\n \t     it is an SSA_NAME before doing anything with it.  */\n-\t  orig_p = &PHI_ARG_DEF (phi, hint);\n-\t  if (TREE_CODE (*orig_p) != SSA_NAME)\n+\t  orig_p = PHI_ARG_DEF_PTR (phi, hint);\n+\t  orig = USE_FROM_PTR (orig_p);\n+\t  if (TREE_CODE (orig) != SSA_NAME)\n \t    continue;\n \n \t  /* If the alternative is known to have a nonzero value, record\n \t     that fact in the PHI node itself for future use.  */\n-\t  if (bitmap_bit_p (nonzero_vars, SSA_NAME_VERSION (*orig_p)))\n+\t  if (bitmap_bit_p (nonzero_vars, SSA_NAME_VERSION (orig)))\n \t    PHI_ARG_NONZERO (phi, hint) = true;\n \n \t  /* If we have *ORIG_P in our constant/copy table, then replace\n \t     ORIG_P with its value in our constant/copy table.  */\n-\t  new = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (*orig_p));\n+\t  new = VARRAY_TREE (const_and_copies, SSA_NAME_VERSION (orig));\n \t  if (new\n \t      && (TREE_CODE (new) == SSA_NAME\n \t\t  || is_gimple_min_invariant (new))\n-\t      && may_propagate_copy (*orig_p, new))\n+\t      && may_propagate_copy (orig, new))\n \t    propagate_value (orig_p, new);\n \t}\n     }"}, {"sha": "2be24ae1c8d90d8a2522a4e182fd57385a860640", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -700,7 +700,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n   /* Each PHI creates a temporary equivalence, record them.  */\n   for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n     {\n-      tree src = PHI_ARG_DEF (phi, phi_arg_from_edge (phi, e));\n+      tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       tree dst = PHI_RESULT (phi);\n       record_const_or_copy (dst, src, &bd->const_and_copies);\n       register_new_def (dst, &bd->block_defs);\n@@ -761,7 +761,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t      if (TREE_CODE (USE_OP (uses, i)) == SSA_NAME)\n \t\ttmp = get_value_for (USE_OP (uses, i), const_and_copies);\n \t      if (tmp)\n-\t\t*USE_OP_PTR (uses, i) = tmp;\n+\t\tSET_USE_OP (uses, i, tmp);\n \t    }\n \n \t  /* Similarly for virtual uses.  */\n@@ -773,18 +773,18 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t      if (TREE_CODE (VUSE_OP (vuses, i)) == SSA_NAME)\n \t\ttmp = get_value_for (VUSE_OP (vuses, i), const_and_copies);\n \t      if (tmp)\n-\t\tVUSE_OP (vuses, i) = tmp;\n+\t\tSET_VUSE_OP (vuses, i, tmp);\n \t    }\n \n \t  /* Try to lookup the new expression.  */\n \t  cached_lhs = lookup_avail_expr (stmt, NULL, false);\n \n \t  /* Restore the statement's original uses/defs.  */\n \t  for (i = 0; i < NUM_USES (uses); i++)\n-\t    *USE_OP_PTR (uses, i) = uses_copy[i];\n+\t    SET_USE_OP (uses, i, uses_copy[i]);\n \n \t  for (i = 0; i < NUM_VUSES (vuses); i++)\n-\t    VUSE_OP (vuses, i) = vuses_copy[i];\n+\t    SET_VUSE_OP (vuses, i, vuses_copy[i]);\n \n \t  free (uses_copy);\n \t  free (vuses_copy);\n@@ -2386,7 +2386,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n \t      && is_gimple_min_invariant (cached_lhs)))\n \tretval = true;\n \n-      propagate_value (expr_p, cached_lhs);\n+      propagate_tree_value (expr_p, cached_lhs);\n       ann->modified = 1;\n     }\n   return retval;"}, {"sha": "7902e14ff1700509273053061aef08886958979d", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -132,7 +132,7 @@ fix_phi_uses (tree phi, tree stmt)\n \t them with the appropriate V_MAY_DEF_OP.  */\n       for (j = 0; j < PHI_NUM_ARGS (phi); j++)\n \tif (v_may_def == PHI_ARG_DEF (phi, j))\n-\t  PHI_ARG_DEF (phi, j) = V_MAY_DEF_OP (v_may_defs, i);\n+\t  SET_PHI_ARG_DEF (phi, j, V_MAY_DEF_OP (v_may_defs, i));\n     }\n }\n \n@@ -164,8 +164,7 @@ fix_stmt_v_may_defs (tree stmt1, tree stmt2)\n \t  if (v_may_def1 == V_MAY_DEF_RESULT (v_may_defs2, j))\n \t    {\n \t      /* Update.  */\n-\t      *V_MAY_DEF_OP_PTR (v_may_defs1, i) = \n-\t                        V_MAY_DEF_OP (v_may_defs2, j);\n+\t      SET_V_MAY_DEF_OP (v_may_defs1, i, V_MAY_DEF_OP (v_may_defs2, j));\n \t      break;\n \t    }\n \t}"}, {"sha": "6daf6557f0db14eddb131ad3935cccfc8d5bc3c0", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -294,7 +294,7 @@ create_ssa_var_map (int flags)\n {\n   block_stmt_iterator bsi;\n   basic_block bb;\n-  tree *dest, *use;\n+  tree dest, use;\n   tree stmt;\n   stmt_ann_t ann;\n   vuse_optype vuses;\n@@ -351,22 +351,22 @@ create_ssa_var_map (int flags)\n \t  uses = USE_OPS (ann);\n \t  for (x = 0; x < NUM_USES (uses); x++)\n \t    {\n-\t      use = USE_OP_PTR (uses, x);\n-\t      register_ssa_partition (map, *use, true);\n+\t      use = USE_OP (uses, x);\n+\t      register_ssa_partition (map, use, true);\n \n #if defined ENABLE_CHECKING\n-\t      SET_BIT (used_in_real_ops, var_ann (SSA_NAME_VAR (*use))->uid);\n+\t      SET_BIT (used_in_real_ops, var_ann (SSA_NAME_VAR (use))->uid);\n #endif\n \t    }\n \n \t  defs = DEF_OPS (ann);\n \t  for (x = 0; x < NUM_DEFS (defs); x++)\n \t    {\n-\t      dest = DEF_OP_PTR (defs, x);\n-\t      register_ssa_partition (map, *dest, false);\n+\t      dest = DEF_OP (defs, x);\n+\t      register_ssa_partition (map, dest, false);\n \n #if defined ENABLE_CHECKING\n-\t      SET_BIT (used_in_real_ops, var_ann (SSA_NAME_VAR (*dest))->uid);\n+\t      SET_BIT (used_in_real_ops, var_ann (SSA_NAME_VAR (dest))->uid);\n #endif\n \t    }\n \n@@ -1393,22 +1393,22 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \n \t  if (!is_a_copy)\n \t    {\n-\t      tree *var_p;\n+\t      tree var;\n \n \t      defs = DEF_OPS (ann);\n \t      num = NUM_DEFS (defs);\n \t      for (x = 0; x < num; x++)\n \t\t{\n-\t\t  var_p = DEF_OP_PTR (defs, x);\n-\t\t  add_conflicts_if_valid (tpa, graph, map, live, *var_p);\n+\t\t  var = DEF_OP (defs, x);\n+\t\t  add_conflicts_if_valid (tpa, graph, map, live, var);\n \t\t}\n \n \t      uses = USE_OPS (ann);\n \t      num = NUM_USES (uses);\n \t      for (x = 0; x < num; x++)\n \t\t{\n-\t\t  var_p = USE_OP_PTR (uses, x);\n-\t\t  set_if_valid (map, live, *var_p);\n+\t\t  var = USE_OP (uses, x);\n+\t\t  set_if_valid (map, live, var);\n \t\t}\n \t    }\n \t}"}, {"sha": "e0b3d830b84b7496ab6382ac283e12c822ae384a", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -225,7 +225,7 @@ duplicate_blocks (varray_type bbs_to_duplicate)\n \n \t  for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n \t    {\n-\t      tree def = phi_element_for_edge (phi, e)->def;\n+\t      tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t      add_phi_arg (&phi, def, e1);\n \t    }\n \t}"}, {"sha": "9eb0bd12e11f86e8840072bdbb7ebac5240e195e", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 12, "deletions": 78, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -88,65 +88,15 @@ static void add_call_clobber_ops (tree, voperands_t);\n static void add_call_read_ops (tree, voperands_t);\n static void add_stmt_operand (tree *, tree, int, voperands_t);\n \n-\n-struct freelist_d GTY((chain_next (\"%h.next\")))\n-{\n-   struct freelist_d *next;\n-};\n-\n-#define NUM_FREE\t5\n-static GTY ((length (\"NUM_FREE\"))) struct freelist_d optype_freelist[NUM_FREE] = { {0}, {0}, {0}, {0}, {0} };\n-\n-\n-static inline void *\n-check_optype_freelist (size_t num ATTRIBUTE_UNUSED)\n-{\n-  return NULL;\n-#if 0\n-  void *vec = NULL;\n-\n-  if (num <= NUM_FREE && optype_freelist[num - 1].next)\n-    {\n-      vec = (void *)optype_freelist[num - 1].next;\n-      optype_freelist[num - 1].next = optype_freelist[num - 1].next->next;\n-    }\n-  return vec;\n-#endif\n-}\n /* Return a vector of contiguous memory of a specified size.  */\n \n-\n-static inline void\n-add_optype_freelist (void *vec ATTRIBUTE_UNUSED, size_t size ATTRIBUTE_UNUSED)\n-{\n-#if 0\n-  struct freelist_d *ptr;\n-#ifdef ENABLE_CHECKING\n-  if (size == 0)\n-    abort ();\n-#endif\n-\n-  /* if its bigger than one of our lists, simply let it go and let GC \n-     collect it.  */\n-  if (size > NUM_FREE)\n-    return;\n-\n-  ptr = vec;\n-  ptr->next = optype_freelist[size - 1].next;;\n-  optype_freelist[size - 1].next = ptr;\n-#endif\n-}\n-\n-\n static inline def_optype\n allocate_def_optype (unsigned num)\n {\n   def_optype def_ops;\n   unsigned size;\n   size = sizeof (struct def_optype_d) + sizeof (tree *) * (num - 1);\n-  def_ops = check_optype_freelist (num);\n-  if (!def_ops)\n-    def_ops =  ggc_alloc (size);\n+  def_ops =  ggc_alloc (size);\n   def_ops->num_defs = num;\n   return def_ops;\n }\n@@ -157,9 +107,7 @@ allocate_use_optype (unsigned num)\n   use_optype use_ops;\n   unsigned size;\n   size = sizeof (struct use_optype_d) + sizeof (tree *) * (num - 1);\n-  use_ops = check_optype_freelist (num);\n-  if (!use_ops)\n-    use_ops =  ggc_alloc (size);\n+  use_ops =  ggc_alloc (size);\n   use_ops->num_uses = num;\n   return use_ops;\n }\n@@ -170,9 +118,7 @@ allocate_v_may_def_optype (unsigned num)\n   v_may_def_optype v_may_def_ops;\n   unsigned size;\n   size = sizeof (struct v_may_def_optype_d) + sizeof (tree) * ((num * 2) - 1);\n-  v_may_def_ops = check_optype_freelist (num * 2);\n-  if (!v_may_def_ops)\n-    v_may_def_ops =  ggc_alloc (size);\n+  v_may_def_ops =  ggc_alloc (size);\n   v_may_def_ops->num_v_may_defs = num;\n   return v_may_def_ops;\n }\n@@ -183,9 +129,7 @@ allocate_vuse_optype (unsigned num)\n   vuse_optype vuse_ops;\n   unsigned size;\n   size = sizeof (struct vuse_optype_d) + sizeof (tree) * (num - 1);\n-  vuse_ops = check_optype_freelist (num);\n-  if (!vuse_ops)\n-    vuse_ops =  ggc_alloc (size);\n+  vuse_ops =  ggc_alloc (size);\n   vuse_ops->num_vuses = num;\n   return vuse_ops;\n }\n@@ -196,9 +140,7 @@ allocate_v_must_def_optype (unsigned num)\n   v_must_def_optype v_must_def_ops;\n   unsigned size;\n   size = sizeof (struct v_must_def_optype_d) + sizeof (tree *) * (num - 1);\n-  v_must_def_ops = check_optype_freelist (num);\n-  if (!v_must_def_ops)\n-    v_must_def_ops =  ggc_alloc (size);\n+  v_must_def_ops =  ggc_alloc (size);\n   v_must_def_ops->num_v_must_defs = num;\n   return v_must_def_ops;\n }\n@@ -209,7 +151,7 @@ free_uses (use_optype *uses, bool dealloc)\n   if (*uses)\n     {\n       if (dealloc)\n-\tadd_optype_freelist (*uses, (*uses)->num_uses);\n+\tggc_free (*uses);\n       *uses = NULL;\n     }\n }\n@@ -220,7 +162,7 @@ free_defs (def_optype *defs, bool dealloc)\n   if (*defs)\n     {\n       if (dealloc)\n-\tadd_optype_freelist (*defs, (*defs)->num_defs);\n+\tggc_free (*defs);\n       *defs = NULL;\n     }\n }\n@@ -231,7 +173,7 @@ free_vuses (vuse_optype *vuses, bool dealloc)\n   if (*vuses)\n     {\n       if (dealloc)\n-\tadd_optype_freelist (*vuses, (*vuses)->num_vuses);\n+\tggc_free (*vuses);\n       *vuses = NULL;\n     }\n }\n@@ -242,7 +184,7 @@ free_v_may_defs (v_may_def_optype *v_may_defs, bool dealloc)\n   if (*v_may_defs)\n     {\n       if (dealloc)\n-\tadd_optype_freelist (*v_may_defs, (*v_may_defs)->num_v_may_defs);\n+\tggc_free (*v_may_defs);\n       *v_may_defs = NULL;\n     }\n }\n@@ -253,7 +195,7 @@ free_v_must_defs (v_must_def_optype *v_must_defs, bool dealloc)\n   if (*v_must_defs)\n     {\n       if (dealloc)\n-\tadd_optype_freelist (*v_must_defs, (*v_must_defs)->num_v_must_defs);\n+\tggc_free (*v_must_defs);\n       *v_must_defs = NULL;\n     }\n }\n@@ -291,24 +233,16 @@ remove_v_must_defs (tree stmt)\n void\n init_ssa_operands (void)\n {\n-  int x;\n-\n   VARRAY_TREE_PTR_INIT (build_defs, 5, \"build defs\");\n   VARRAY_TREE_PTR_INIT (build_uses, 10, \"build uses\");\n   VARRAY_TREE_INIT (build_v_may_defs, 10, \"build v_may_defs\");\n   VARRAY_TREE_INIT (build_vuses, 10, \"build vuses\");\n   VARRAY_TREE_INIT (build_v_must_defs, 10, \"build v_must_defs\");\n-\n-  for (x = 0; x < NUM_FREE; x++)\n-    optype_freelist[x].next = NULL;\n }\n \n void\n fini_ssa_operands (void)\n {\n-  int x;\n-  for (x = 0; x < NUM_FREE; x++)\n-    optype_freelist[x].next = NULL;\n }\n \n static void\n@@ -330,7 +264,7 @@ finalize_ssa_defs (tree stmt)\n \n   def_ops = allocate_def_optype (num);\n   for (x = 0; x < num ; x++)\n-    def_ops->defs[x] = VARRAY_TREE_PTR (build_defs, x);\n+    def_ops->defs[x].def = VARRAY_TREE_PTR (build_defs, x);\n   VARRAY_POP_ALL (build_defs);\n \n   ann = stmt_ann (stmt);\n@@ -363,7 +297,7 @@ finalize_ssa_uses (tree stmt)\n \n   use_ops = allocate_use_optype (num);\n   for (x = 0; x < num ; x++)\n-    use_ops->uses[x] = VARRAY_TREE_PTR (build_uses, x);\n+    use_ops->uses[x].use = VARRAY_TREE_PTR (build_uses, x);\n   VARRAY_POP_ALL (build_uses);\n \n   ann = stmt_ann (stmt);"}, {"sha": "f34ac162b62448808b22404e36475acedf420abf", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -23,22 +23,39 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Interface to SSA operands.  */\n \n+\n+/* This represents a pointer to a DEF operand.  */\n+typedef struct def_operand_ptr GTY(())\n+{\n+  tree * GTY((skip(\"\"))) def;\n+} def_operand_p;\n+\n+/* This represents a pointer to a USE operand.  */\n+typedef struct use_operand_ptr GTY(())\n+{\n+  tree * GTY((skip(\"\"))) use;\n+} use_operand_p;\n+\n+\n+/* This represents the DEF operands of a stmt.  */\n typedef struct def_optype_d GTY(())\n {\n   unsigned num_defs; \n-  tree * GTY((length(\"%h.num_defs\"), skip(\"\"))) defs[1];\n+  struct def_operand_ptr GTY((length(\"%h.num_defs\"))) defs[1];\n } def_optype_t;\n \n typedef def_optype_t *def_optype;\n \n+/* This represents the USE operands of a stmt.  */\n typedef struct use_optype_d GTY(())\n {\n   unsigned num_uses; \n-  tree * GTY((length(\"%h.num_uses\"), skip(\"\"))) uses[1];\n+  struct use_operand_ptr GTY((length(\"%h.num_uses\"))) uses[1];\n } use_optype_t;\n \n typedef use_optype_t *use_optype;\n \n+/* This represents the MAY_DEFS for a stmt.  */\n typedef struct v_may_def_optype_d GTY(())\n {\n   unsigned num_v_may_defs; \n@@ -47,6 +64,7 @@ typedef struct v_may_def_optype_d GTY(())\n \n typedef v_may_def_optype_t *v_may_def_optype;\n \n+/* This represents the VUSEs for a stmt.  */\n typedef struct vuse_optype_d GTY(()) \n {\n   unsigned num_vuses; \n@@ -55,6 +73,7 @@ typedef struct vuse_optype_d GTY(())\n \n typedef vuse_optype_t *vuse_optype;\n \n+/* This represents the V_MUST_DEFS for a stmt.  */\n typedef struct v_must_def_optype_d GTY(())\n {\n   unsigned num_v_must_defs; \n@@ -63,41 +82,78 @@ typedef struct v_must_def_optype_d GTY(())\n \n typedef v_must_def_optype_t *v_must_def_optype;\n \n+#define USE_FROM_PTR(OP)\tget_use_from_ptr (OP)\n+#define DEF_FROM_PTR(OP)\tget_def_from_ptr (OP)\n+#define SET_USE(OP, V)\t\t((*((OP).use)) = (V))\n+#define SET_DEF(OP, V)\t\t((*((OP).def)) = (V))\n+\n+\n #define USE_OPS(ANN)\t\tget_use_ops (ANN)\n #define STMT_USE_OPS(STMT)\tget_use_ops (stmt_ann (STMT))\n #define NUM_USES(OPS)\t\t((OPS) ? (OPS)->num_uses : 0)\n #define USE_OP_PTR(OPS, I)\tget_use_op_ptr ((OPS), (I))\n-#define USE_OP(OPS, I)\t\t(*(USE_OP_PTR ((OPS), (I))))\n+#define USE_OP(OPS, I)\t\t(USE_FROM_PTR (USE_OP_PTR ((OPS), (I))))\n+#define SET_USE_OP(OPS, I, V)\t(SET_USE (USE_OP_PTR ((OPS), (I)), (V)))\n+\n \n \n #define DEF_OPS(ANN)\t\tget_def_ops (ANN)\n #define STMT_DEF_OPS(STMT)\tget_def_ops (stmt_ann (STMT))\n #define NUM_DEFS(OPS)\t\t((OPS) ? (OPS)->num_defs : 0)\n #define DEF_OP_PTR(OPS, I)\tget_def_op_ptr ((OPS), (I))\n-#define DEF_OP(OPS, I)\t\t(*(DEF_OP_PTR ((OPS), (I))))\n+#define DEF_OP(OPS, I)\t\t(DEF_FROM_PTR (DEF_OP_PTR ((OPS), (I))))\n+#define SET_DEF_OP(OPS, I, V)\t(SET_DEF (DEF_OP_PTR ((OPS), (I)), (V)))\n+\n \n \n #define V_MAY_DEF_OPS(ANN)\t\tget_v_may_def_ops (ANN)\n #define STMT_V_MAY_DEF_OPS(STMT)\tget_v_may_def_ops (stmt_ann(STMT))\n #define NUM_V_MAY_DEFS(OPS)\t\t((OPS) ? (OPS)->num_v_may_defs : 0)\n #define V_MAY_DEF_RESULT_PTR(OPS, I)\tget_v_may_def_result_ptr ((OPS), (I))\n-#define V_MAY_DEF_RESULT(OPS, I)\t(*(V_MAY_DEF_RESULT_PTR ((OPS), (I))))\n+#define V_MAY_DEF_RESULT(OPS, I)\t\t\t\t\t\\\n+\t\t\t    (DEF_FROM_PTR (V_MAY_DEF_RESULT_PTR ((OPS), (I))))\n+#define SET_V_MAY_DEF_RESULT(OPS, I, V)\t\t\t\t\t\\\n+\t\t\t    (SET_DEF (V_MAY_DEF_RESULT_PTR ((OPS), (I)), (V)))\n #define V_MAY_DEF_OP_PTR(OPS, I)\tget_v_may_def_op_ptr ((OPS), (I))\n-#define V_MAY_DEF_OP(OPS, I)\t\t(*(V_MAY_DEF_OP_PTR ((OPS), (I))))\n+#define V_MAY_DEF_OP(OPS, I)\t\t\t\t\t\t\\\n+\t\t\t    (USE_FROM_PTR (V_MAY_DEF_OP_PTR ((OPS), (I))))\n+#define SET_V_MAY_DEF_OP(OPS, I, V)\t\t\t\t\t\\\n+\t\t\t    (SET_USE (V_MAY_DEF_OP_PTR ((OPS), (I)), (V)))\n \n \n #define VUSE_OPS(ANN)\t\tget_vuse_ops (ANN)\n #define STMT_VUSE_OPS(STMT)\tget_vuse_ops (stmt_ann(STMT))\n #define NUM_VUSES(OPS)\t\t((OPS) ? (OPS)->num_vuses : 0)\n #define VUSE_OP_PTR(OPS, I)  \tget_vuse_op_ptr ((OPS), (I))\n-#define VUSE_OP(OPS, I)  \t(*(VUSE_OP_PTR ((OPS), (I))))\n+#define VUSE_OP(OPS, I)  \t(USE_FROM_PTR (VUSE_OP_PTR ((OPS), (I))))\n+#define SET_VUSE_OP(OPS, I, V)\t(SET_USE (VUSE_OP_PTR ((OPS), (I)), (V)))\n \n \n #define V_MUST_DEF_OPS(ANN)\t\tget_v_must_def_ops (ANN)\n #define STMT_V_MUST_DEF_OPS(STMT)\tget_v_must_def_ops (stmt_ann (STMT))\n #define NUM_V_MUST_DEFS(OPS)\t\t((OPS) ? (OPS)->num_v_must_defs : 0)\n #define V_MUST_DEF_OP_PTR(OPS, I)\tget_v_must_def_op_ptr ((OPS), (I))\n-#define V_MUST_DEF_OP(OPS, I)\t\t(*(V_MUST_DEF_OP_PTR ((OPS), (I))))\n+#define V_MUST_DEF_OP(OPS, I)\t\t\t\t\t\t\\\n+\t\t\t\t(DEF_FROM_PTR (V_MUST_DEF_OP_PTR ((OPS), (I))))\n+#define SET_V_MUST_DEF_OP(OPS, I, V)\t\t\t\t\t\\\n+\t\t\t\t(SET_DEF (V_MUST_DEF_OP_PTR ((OPS), (I)), (V)))\n+\n+\n+#define PHI_RESULT_PTR(PHI)\tget_phi_result_ptr (PHI)\n+#define PHI_RESULT(PHI)\t\tDEF_FROM_PTR (PHI_RESULT_PTR (PHI))\n+#define SET_PHI_RESULT(PHI, V)\tSET_DEF (PHI_RESULT_PTR (PHI), (V))\n+\n+#define PHI_ARG_DEF_PTR(PHI, I)\tget_phi_arg_def_ptr ((PHI), (I))\n+#define PHI_ARG_DEF(PHI, I)\tUSE_FROM_PTR (PHI_ARG_DEF_PTR ((PHI), (I)))\n+#define SET_PHI_ARG_DEF(PHI, I, V)\t\t\t\t\t\\\n+\t\t\t\tSET_USE (PHI_ARG_DEF_PTR ((PHI), (I)), (V))\n+#define PHI_ARG_DEF_FROM_EDGE(PHI, E)\t\t\t\t\t\\\n+\t\t\t\tPHI_ARG_DEF ((PHI),\t\t\t\\\n+\t\t\t\t\t     phi_arg_from_edge ((PHI),(E)))\n+#define PHI_ARG_DEF_PTR_FROM_EDGE(PHI, E)\t\t\t\t\\\n+\t\t\t\tPHI_ARG_DEF_PTR ((PHI), \t\t\\\n+\t\t\t\t\t     phi_arg_from_edge ((PHI),(E)))\n+\n \n extern void init_ssa_operands (void);\n extern void fini_ssa_operands (void);"}, {"sha": "5109934c5bc7aab4d1f7382f148fa354c1f04750", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -1907,7 +1907,7 @@ eliminate (void)\n \t\t      print_generic_stmt (dump_file, stmt, 0);\n \t\t    }\n \t\t  pre_stats.eliminations++;\n-                  propagate_value (&TREE_OPERAND (stmt, 1), sprime);\n+                  propagate_tree_value (&TREE_OPERAND (stmt, 1), sprime);\n                   modify_stmt (stmt);\n                 }\n             }"}, {"sha": "5a06cf8e9e1ad7941d75ddd83d103f86e9f8cbae", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -779,7 +779,7 @@ replace_immediate_uses (tree var, tree repl)\n \t  for (j = 0; j < PHI_NUM_ARGS (stmt); j++)\n \t    if (PHI_ARG_DEF (stmt, j) == var)\n \t      {\n-\t\tPHI_ARG_DEF (stmt, j) = repl;\n+\t\tSET_PHI_ARG_DEF (stmt, j, repl);\n \t\tif (TREE_CODE (repl) == SSA_NAME\n \t\t    && PHI_ARG_EDGE (stmt, j)->flags & EDGE_ABNORMAL)\n \t\t  SSA_NAME_OCCURS_IN_ABNORMAL_PHI (repl) = 1;"}, {"sha": "54597bb7973b784068be8dd1976d2a076a168db2", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -237,7 +237,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n       if (!e)\n \tabort ();\n \n-      expr = phi_element_for_edge (at, e)->def;\n+      expr = PHI_ARG_DEF_FROM_EDGE (at, e);\n     }\n \n   /* Unmark the blocks.  */\n@@ -340,7 +340,7 @@ propagate_through_phis (tree var, edge e)\n   tree phi;\n \n   for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n-    if (phi_element_for_edge (phi, e)->def == var)\n+    if (PHI_ARG_DEF_FROM_EDGE (phi, e) == var)\n       return PHI_RESULT (phi);\n \n   return var;"}, {"sha": "128b6a5832d1ff28320288e5a91cd2e8d85d6031", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d00ad49ba1c217ec55751ed6461890e8911bb001/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d00ad49ba1c217ec55751ed6461890e8911bb001", "patch": "@@ -1206,7 +1206,8 @@ struct tree_ssa_name GTY(())\n };\n \f\n /* In a PHI_NODE node.  */\n-#define PHI_RESULT(NODE)\tPHI_NODE_CHECK (NODE)->phi.result\n+#define PHI_RESULT_TREE(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.result\n+#define PHI_ARG_DEF_TREE(NODE, I)\tPHI_NODE_ELT_CHECK (NODE, I).def\n \n /* PHI_NODEs for each basic block are chained together in a single linked\n    list.  The head of the list is linked from the block annotation, and\n@@ -1215,13 +1216,12 @@ struct tree_ssa_name GTY(())\n \n /* Nonzero if the PHI node was rewritten by a previous pass through the\n    SSA renamer.  */\n-#define PHI_REWRITTEN(NODE)\tPHI_NODE_CHECK (NODE)->phi.rewritten\n-#define PHI_NUM_ARGS(NODE)\tPHI_NODE_CHECK (NODE)->phi.num_args\n-#define PHI_ARG_CAPACITY(NODE)\tPHI_NODE_CHECK (NODE)->phi.capacity\n-#define PHI_ARG_ELT(NODE, I)\tPHI_NODE_ELT_CHECK (NODE, I)\n-#define PHI_ARG_EDGE(NODE, I)\tPHI_NODE_ELT_CHECK (NODE, I).e\n-#define PHI_ARG_DEF(NODE, I)\tPHI_NODE_ELT_CHECK (NODE, I).def\n-#define PHI_ARG_NONZERO(NODE, I) PHI_NODE_ELT_CHECK (NODE, I).nonzero\n+#define PHI_REWRITTEN(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.rewritten\n+#define PHI_NUM_ARGS(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.num_args\n+#define PHI_ARG_CAPACITY(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.capacity\n+#define PHI_ARG_ELT(NODE, I)\t\tPHI_NODE_ELT_CHECK (NODE, I)\n+#define PHI_ARG_EDGE(NODE, I)\t\tPHI_NODE_ELT_CHECK (NODE, I).e\n+#define PHI_ARG_NONZERO(NODE, I) \tPHI_NODE_ELT_CHECK (NODE, I).nonzero\n \n struct edge_def;\n "}]}