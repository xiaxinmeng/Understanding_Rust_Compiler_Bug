{"sha": "68dfd979ac149deff93a104e4bb4d7a37ccd2123", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhkZmQ5NzlhYzE0OWRlZmY5M2ExMDRlNGJiNGQ3YTM3Y2NkMjEyMw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-11-16T19:23:15Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-11-16T19:23:15Z"}, "message": "Fix nested function support for the ARM\n\nFrom-SVN: r37503", "tree": {"sha": "d58f3745afa034b83e7ea37a2d5d605868500ef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d58f3745afa034b83e7ea37a2d5d605868500ef8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68dfd979ac149deff93a104e4bb4d7a37ccd2123", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68dfd979ac149deff93a104e4bb4d7a37ccd2123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68dfd979ac149deff93a104e4bb4d7a37ccd2123", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68dfd979ac149deff93a104e4bb4d7a37ccd2123/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cdb3cf85467783c2820506f0e698056a10cd1109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb3cf85467783c2820506f0e698056a10cd1109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb3cf85467783c2820506f0e698056a10cd1109"}], "stats": {"total": 105, "additions": 97, "deletions": 8}, "files": [{"sha": "9866dc4cc7935acd24233c1de409c08637720588", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68dfd979ac149deff93a104e4bb4d7a37ccd2123/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68dfd979ac149deff93a104e4bb4d7a37ccd2123/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68dfd979ac149deff93a104e4bb4d7a37ccd2123", "patch": "@@ -1,3 +1,15 @@\n+2000-11-16  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/arm/arm.c (output_arm_prologue): Note nested functions.\n+\t(arm_expand_prologue): For nested functions preserve the\n+\tstatic chain register during stack frame creation.\n+\n+\t* config/arm/arm.h (STATIC_CHAIN_REGNUM): Change to 12.\n+\t(ARM_INITIAL_FRAME_ELIMINATION_OFFSET): For a nested function\n+\twith a stack frame there is a 4 byte gap between the arg\n+\tpointer and the hard frame pointer (used to preserve the\n+\tstatic chain register during stack frame creation).\n+\n 2000-11-16  DJ Delorie  <dj@redhat.com>\n \n \t* rtl.c (read_rtx): Provide suitable names for unnamed"}, {"sha": "3bb55227ff13e2e7c40ff6004576bd8853fd7902", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68dfd979ac149deff93a104e4bb4d7a37ccd2123/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68dfd979ac149deff93a104e4bb4d7a37ccd2123/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=68dfd979ac149deff93a104e4bb4d7a37ccd2123", "patch": "@@ -6776,6 +6776,9 @@ output_arm_prologue (f, frame_size)\n   if (volatile_func)\n     asm_fprintf (f, \"\\t%@ Volatile function.\\n\");\n \n+  if (current_function_needs_context)\n+    asm_fprintf (f, \"\\t%@ Nested function.\\n\");\n+\n   if (current_function_anonymous_args && current_function_pretend_args_size)\n     store_arg_regs = 1;\n \n@@ -7318,6 +7321,9 @@ arm_expand_prologue ()\n      the call-saved regs.  */\n   int volatile_func = arm_volatile_func ();\n   rtx insn;\n+  rtx ip_rtx;\n+  int fp_offset = 0;\n+      \n \n   /* Naked functions don't have prologues.  */\n   if (arm_naked_function_p (current_function_decl))\n@@ -7345,11 +7351,59 @@ arm_expand_prologue ()\n \tlive_regs_mask |= 1 << LR_REGNUM;\n     }\n \n+  ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);\n+  \n   if (frame_pointer_needed)\n     {\n+      if (current_function_needs_context)\n+\t{\n+\t  /* The Static chain register is the same as the IP register\n+\t     used as a scratch register during stack frame creation.\n+\t     To get around this need to find somewhere to store IP\n+\t     whilst the frame is being created.  We try the following\n+\t     places in order:\n+\t     \n+\t       1. An unused argument register.\n+\t       2. A slot on the stack above the frame.  (This only\n+\t          works if the function is not a varargs function).\n+\t\t  \n+\t     If neither of these places is available, we abort (for now).  */\n+\t  if (regs_ever_live[3] == 0)\n+\t    {\n+\t      insn = gen_rtx_REG (SImode, 3);\n+\t      insn = gen_rtx_SET (SImode, insn, ip_rtx);\n+\t      insn = emit_insn (insn);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\t  \n+\t    }\n+\t  else if (current_function_pretend_args_size == 0)\n+\t    {\n+\t      insn = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);\n+\t      insn = gen_rtx_MEM (SImode, insn);\n+\t      insn = gen_rtx_SET (VOIDmode, insn, ip_rtx);\n+\t      insn = emit_insn (insn);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      fp_offset = 4;\n+\t    }\n+\t  else\n+\t    /* FIXME - the way to handle this situation is to allow\n+\t       the pretend args to be dumped onto the stack, then\n+\t       reuse r3 to save IP.  This would involve moving the\n+\t       copying os SP into IP until after the pretend args\n+\t       have been dumped, but this is not too hard.  */\n+\t    error (\"Unable to find a temporary location for static chanin register\");\n+\t}\n+\n       live_regs_mask |= 0xD800;\n-      insn = emit_insn (gen_movsi (gen_rtx_REG (SImode, IP_REGNUM),\n-\t\t\t\t   stack_pointer_rtx));\n+\n+      if (fp_offset)\n+\t{\n+\t  insn = gen_rtx_PLUS (SImode, stack_pointer_rtx, GEN_INT (fp_offset));\n+\t  insn = gen_rtx_SET  (SImode, ip_rtx, insn);\n+\t}\n+      else\n+\tinsn = gen_movsi (ip_rtx, stack_pointer_rtx);\n+      \n+      insn = emit_insn (insn);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -7426,11 +7480,29 @@ arm_expand_prologue ()\n \n   if (frame_pointer_needed)\n     {\n-      insn = GEN_INT (-(4 + current_function_pretend_args_size));\n-      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n-\t\t\t\t    gen_rtx_REG (SImode, IP_REGNUM),\n-\t\t\t\t    insn));\n+      insn = GEN_INT (-(4 + current_function_pretend_args_size + fp_offset));\n+      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      \n+      if (current_function_needs_context)\n+\t{\n+\t  /* Recover the static chain register.  */\n+\t  if (regs_ever_live [3] == 0)\n+\t    {\n+\t      insn = gen_rtx_REG (SImode, 3);\n+\t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n+\t      insn = emit_insn (insn);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\t  \n+\t    }\n+\t  else /* if (current_function_pretend_args_size == 0) */\n+\t    {\n+\t      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx, GEN_INT (4));\n+\t      insn = gen_rtx_MEM (SImode, insn);\n+\t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n+\t      insn = emit_insn (insn);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\t  \n+\t    }\n+\t}\n     }\n \n   if (amount != const0_rtx)"}, {"sha": "f9d5cd8baabc9017e0a291bfcd598754729f6acc", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68dfd979ac149deff93a104e4bb4d7a37ccd2123/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68dfd979ac149deff93a104e4bb4d7a37ccd2123/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=68dfd979ac149deff93a104e4bb4d7a37ccd2123", "patch": "@@ -891,7 +891,7 @@ extern const char * structure_size_string;\n /* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n    as an invisible last argument (possible since varargs don't exist in\n    Pascal), so the following is not true.  */\n-#define STATIC_CHAIN_REGNUM\t(TARGET_ARM ? 8 : 9)\n+#define STATIC_CHAIN_REGNUM\t(TARGET_ARM ? 12 : 9)\n \n /* Define this to be where the real frame pointer is if it is not possible to\n    work out the offset between the frame pointer and the automatic variables\n@@ -1600,7 +1600,12 @@ typedef struct\n {\t\t\t\t\t\t\t\t\t\\\n   int volatile_func = arm_volatile_func ();\t\t\t\t\\\n   if ((FROM) == ARG_POINTER_REGNUM && (TO) == HARD_FRAME_POINTER_REGNUM)\\\n-    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! current_function_needs_context || ! frame_pointer_needed)\t\\\n+        (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        (OFFSET) = 4;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   else if ((FROM) == FRAME_POINTER_REGNUM\t\t\t\t\\\n \t   && (TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n     (OFFSET) = current_function_outgoing_args_size\t\t\t\\"}]}