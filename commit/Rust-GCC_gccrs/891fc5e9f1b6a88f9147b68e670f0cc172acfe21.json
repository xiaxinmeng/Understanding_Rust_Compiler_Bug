{"sha": "891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkxZmM1ZTlmMWI2YTg4ZjkxNDdiNjhlNjcwZjBjYzE3MmFjZmUyMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-04-27T11:42:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-04-27T11:42:43Z"}, "message": "re PR tree-optimization/31715 (Array calculation done incorrectly)\n\n2007-04-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/31715\n\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): Make\n\tsure to do computation on the offset in an appropriate\n\tsigned type.\n\n\t* gcc.dg/Warray-bounds-4.c: New testcase.\n\nFrom-SVN: r124216", "tree": {"sha": "f5c0aaa63c85a8e22468cb5c55ee2f5e9507d027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5c0aaa63c85a8e22468cb5c55ee2f5e9507d027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c74fb06c66b569a26f93c0d569d4437fdcfd415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c74fb06c66b569a26f93c0d569d4437fdcfd415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c74fb06c66b569a26f93c0d569d4437fdcfd415"}], "stats": {"total": 66, "additions": 53, "deletions": 13}, "files": [{"sha": "0e4f987319076c767004e80f1fa31deb858696f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "patch": "@@ -1,3 +1,10 @@\n+2007-04-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/31715\n+\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): Make\n+\tsure to do computation on the offset in an appropriate\n+\tsigned type.\n+\n 2007-04-27  Richard Sandiford  <richard@codesourcery.com>\n \n \t* reload.h (elimination_target_reg_p): Declare."}, {"sha": "c9e601eb57d9bcd0522f96c930e1f29bae47de76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "patch": "@@ -1,3 +1,8 @@\n+2007-04-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/31715\n+\t* gcc.dg/Warray-bounds-4.c: New testcase.\n+\n 2007-04-26  Ian Lance Taylor  <iant@google.com>\n \n \tPR target/28675"}, {"sha": "71526f27ffd86cb261ff0da1111f26d96d9f6892", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-4.c?ref=891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall\" } */\n+\n+typedef unsigned int DWORD;\n+\n+static void g(DWORD * p, int n)\n+{\n+        int i;\n+\n+        for (i = 0; i < n && !p[n - 1]; i++);  /* { dg-bogus \"subscript is above array bounds\" } */\n+}\n+\n+void f() {\n+        DWORD arr[8];\n+\n+        g(arr, 4);\n+}"}, {"sha": "9c9d847eed6f1b79c4675f54ecf092eaf9d22be8", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891fc5e9f1b6a88f9147b68e670f0cc172acfe21/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "patch": "@@ -1550,7 +1550,7 @@ widen_bitfield (tree val, tree field, tree var)\n static tree\n maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n {\n-  tree min_idx, idx, elt_offset = integer_zero_node;\n+  tree min_idx, idx, idx_type, elt_offset = integer_zero_node;\n   tree array_type, elt_type, elt_size;\n \n   /* If BASE is an ARRAY_REF, we can pick up another offset (this time\n@@ -1578,7 +1578,10 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n   elt_type = TREE_TYPE (array_type);\n   if (!lang_hooks.types_compatible_p (orig_type, elt_type))\n     return NULL_TREE;\n-\t\n+\n+  /* Use signed size type for intermediate computation on the index.  */\n+  idx_type = signed_type_for (size_type_node);\n+\n   /* If OFFSET and ELT_OFFSET are zero, we don't care about the size of the\n      element type (so we can use the alignment if it's not constant).\n      Otherwise, compute the offset as an index by using a division.  If the\n@@ -1589,49 +1592,57 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n       if (TREE_CODE (elt_size) != INTEGER_CST)\n \telt_size = size_int (TYPE_ALIGN (elt_type));\n \n-      idx = integer_zero_node;\n+      idx = build_int_cst (idx_type, 0);\n     }\n   else\n     {\n       unsigned HOST_WIDE_INT lquo, lrem;\n       HOST_WIDE_INT hquo, hrem;\n+      double_int soffset;\n \n+      /* The final array offset should be signed, so we need\n+\t to sign-extend the (possibly pointer) offset here\n+\t and use signed division.  */\n+      soffset = double_int_sext (tree_to_double_int (offset),\n+\t\t\t\t TYPE_PRECISION (TREE_TYPE (offset)));\n       if (TREE_CODE (elt_size) != INTEGER_CST\n-\t  || div_and_round_double (TRUNC_DIV_EXPR, 1,\n-\t\t\t\t   TREE_INT_CST_LOW (offset),\n-\t\t\t\t   TREE_INT_CST_HIGH (offset),\n+\t  || div_and_round_double (TRUNC_DIV_EXPR, 0,\n+\t\t\t\t   soffset.low, soffset.high,\n \t\t\t\t   TREE_INT_CST_LOW (elt_size),\n \t\t\t\t   TREE_INT_CST_HIGH (elt_size),\n \t\t\t\t   &lquo, &hquo, &lrem, &hrem)\n \t  || lrem || hrem)\n \treturn NULL_TREE;\n \n-      idx = build_int_cst_wide (TREE_TYPE (offset), lquo, hquo);\n+      idx = build_int_cst_wide (idx_type, lquo, hquo);\n     }\n \n   /* Assume the low bound is zero.  If there is a domain type, get the\n      low bound, if any, convert the index into that type, and add the\n      low bound.  */\n-  min_idx = integer_zero_node;\n+  min_idx = build_int_cst (idx_type, 0);\n   if (TYPE_DOMAIN (array_type))\n     {\n-      if (TYPE_MIN_VALUE (TYPE_DOMAIN (array_type)))\n-\tmin_idx = TYPE_MIN_VALUE (TYPE_DOMAIN (array_type));\n+      idx_type = TYPE_DOMAIN (array_type);\n+      if (TYPE_MIN_VALUE (idx_type))\n+\tmin_idx = TYPE_MIN_VALUE (idx_type);\n       else\n-\tmin_idx = fold_convert (TYPE_DOMAIN (array_type), min_idx);\n+\tmin_idx = fold_convert (idx_type, min_idx);\n \n       if (TREE_CODE (min_idx) != INTEGER_CST)\n \treturn NULL_TREE;\n \n-      idx = fold_convert (TYPE_DOMAIN (array_type), idx);\n-      elt_offset = fold_convert (TYPE_DOMAIN (array_type), elt_offset);\n+      elt_offset = fold_convert (idx_type, elt_offset);\n     }\n \n   if (!integer_zerop (min_idx))\n     idx = int_const_binop (PLUS_EXPR, idx, min_idx, 0);\n   if (!integer_zerop (elt_offset))\n     idx = int_const_binop (PLUS_EXPR, idx, elt_offset, 0);\n \n+  /* Make sure to possibly truncate late after offsetting.  */\n+  idx = fold_convert (idx_type, idx);\n+\n   return build4 (ARRAY_REF, orig_type, base, idx, NULL_TREE, NULL_TREE);\n }\n "}]}