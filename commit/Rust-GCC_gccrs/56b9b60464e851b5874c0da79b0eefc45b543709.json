{"sha": "56b9b60464e851b5874c0da79b0eefc45b543709", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiOWI2MDQ2NGU4NTFiNTg3NGMwZGE3OWIwZWVmYzQ1YjU0MzcwOQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-05-13T00:05:26Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-05-13T00:05:26Z"}, "message": "retry zero-call-used-regs from zeroed regs\n\ndefault_zero_call_used_regs currently requires all potentially zeroed\nregisters to offer a move opcode that accepts zero as an operand.\n\nThis is not the case e.g. for ARM's r12/ip in Thumb mode, and it was\nnot the case of FP registers on AArch64 as of GCC 10.\n\nThis patch introduces a fallback strategy to zero out registers,\ncopying from registers that have already been zeroed.  Adjacent\nsources to make up wider modes are also supported.\n\nThis does not guarantee that there will be some zeroed-out register to\nuse as the source, but it expands the cases in which the default\nimplementation works out of the box.\n\n\nfor  gcc/ChangeLog\n\n\t* targhooks.c (default_zero_call_used_regs): Retry using\n\tsuccessfully-zeroed registers as sources.", "tree": {"sha": "bce8e12372035acc283d1be2cbe620fa2bc90d39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bce8e12372035acc283d1be2cbe620fa2bc90d39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b9b60464e851b5874c0da79b0eefc45b543709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b9b60464e851b5874c0da79b0eefc45b543709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b9b60464e851b5874c0da79b0eefc45b543709", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b9b60464e851b5874c0da79b0eefc45b543709/comments", "author": null, "committer": null, "parents": [{"sha": "d21963ce7a87db3d4a6921a0fa98b72ea6f4e7f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d21963ce7a87db3d4a6921a0fa98b72ea6f4e7f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d21963ce7a87db3d4a6921a0fa98b72ea6f4e7f5"}], "stats": {"total": 93, "additions": 86, "deletions": 7}, "files": [{"sha": "1947ef26fd6440d599e8b0ac47f2d777ce148960", "filename": "gcc/targhooks.c", "status": "modified", "additions": 86, "deletions": 7, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b9b60464e851b5874c0da79b0eefc45b543709/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b9b60464e851b5874c0da79b0eefc45b543709/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=56b9b60464e851b5874c0da79b0eefc45b543709", "patch": "@@ -1001,6 +1001,13 @@ default_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n {\n   gcc_assert (!hard_reg_set_empty_p (need_zeroed_hardregs));\n \n+  HARD_REG_SET failed;\n+  CLEAR_HARD_REG_SET (failed);\n+  bool progress = false;\n+\n+  /* First, try to zero each register in need_zeroed_hardregs by\n+     loading a zero into it, taking note of any failures in\n+     FAILED.  */\n   for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n       {\n@@ -1010,16 +1017,88 @@ default_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n \trtx_insn *insn = emit_move_insn (regno_reg_rtx[regno], zero);\n \tif (!valid_insn_p (insn))\n \t  {\n-\t    static bool issued_error;\n-\t    if (!issued_error)\n-\t      {\n-\t\tissued_error = true;\n-\t\tsorry (\"%qs not supported on this target\",\n-\t\t\t\"-fzero-call-used-regs\");\n-\t      }\n+\t    SET_HARD_REG_BIT (failed, regno);\n \t    delete_insns_since (last_insn);\n \t  }\n+\telse\n+\t  progress = true;\n       }\n+\n+  /* Now retry with copies from zeroed registers, as long as we've\n+     made some PROGRESS, and registers remain to be zeroed in\n+     FAILED.  */\n+  while (progress && !hard_reg_set_empty_p (failed))\n+    {\n+      HARD_REG_SET retrying = failed;\n+\n+      CLEAR_HARD_REG_SET (failed);\n+      progress = false;\n+\n+      for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (TEST_HARD_REG_BIT (retrying, regno))\n+\t  {\n+\t    machine_mode mode = GET_MODE (regno_reg_rtx[regno]);\n+\t    bool success = false;\n+\t    /* Look for a source.  */\n+\t    for (unsigned int src = 0; src < FIRST_PSEUDO_REGISTER; src++)\n+\t      {\n+\t\t/* If SRC hasn't been zeroed (yet?), skip it.  */\n+\t\tif (! TEST_HARD_REG_BIT (need_zeroed_hardregs, src))\n+\t\t  continue;\n+\t\tif (TEST_HARD_REG_BIT (retrying, src))\n+\t\t  continue;\n+\n+\t\t/* Check that SRC can hold MODE, and that any other\n+\t\t   registers needed to hold MODE in SRC have also been\n+\t\t   zeroed.  */\n+\t\tif (!targetm.hard_regno_mode_ok (src, mode))\n+\t\t  continue;\n+\t\tunsigned n = targetm.hard_regno_nregs (src, mode);\n+\t\tbool ok = true;\n+\t\tfor (unsigned i = 1; ok && i < n; i++)\n+\t\t  ok = (TEST_HARD_REG_BIT (need_zeroed_hardregs, src + i)\n+\t\t\t&& !TEST_HARD_REG_BIT (retrying, src + i));\n+\t\tif (!ok)\n+\t\t  continue;\n+\n+\t\t/* SRC is usable, try to copy from it.  */\n+\t\trtx_insn *last_insn = get_last_insn ();\n+\t\trtx zsrc = gen_rtx_REG (mode, src);\n+\t\trtx_insn *insn = emit_move_insn (regno_reg_rtx[regno], zsrc);\n+\t\tif (!valid_insn_p (insn))\n+\t\t  /* It didn't work, remove any inserts.  We'll look\n+\t\t     for another SRC.  */\n+\t\t  delete_insns_since (last_insn);\n+\t\telse\n+\t\t  {\n+\t\t    /* We're done for REGNO.  */\n+\t\t    success = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\n+\t    /* If nothing worked for REGNO this round, marked it to be\n+\t       retried if we get another round.  */\n+\t    if (!success)\n+\t      SET_HARD_REG_BIT (failed, regno);\n+\t    else\n+\t      /* Take note so as to enable another round if needed.  */\n+\t      progress = true;\n+\t  }\n+    }\n+\n+  /* If any register remained, report it.  */\n+  if (!progress)\n+    {\n+      static bool issued_error;\n+      if (!issued_error)\n+\t{\n+\t  issued_error = true;\n+\t  sorry (\"%qs not supported on this target\",\n+\t\t \"-fzero-call-used-regs\");\n+\t}\n+    }\n+\n   return need_zeroed_hardregs;\n }\n "}]}