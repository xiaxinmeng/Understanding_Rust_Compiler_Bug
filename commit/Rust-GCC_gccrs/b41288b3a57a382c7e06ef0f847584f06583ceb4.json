{"sha": "b41288b3a57a382c7e06ef0f847584f06583ceb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQxMjg4YjNhNTdhMzgyYzdlMDZlZjBmODQ3NTg0ZjA2NTgzY2ViNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-02-16T09:32:56Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2013-02-16T09:32:56Z"}, "message": "[asan] Fix for PR asan/56330\n\ngcc/\n\t* asan.c (get_mem_refs_of_builtin_call): White space and style\n\tcleanup.\n\t(instrument_mem_region_access): Do not forget to always put\n\tinstrumentation of the of 'base' and 'base + len' in a \"if (len !=\n\t0) statement, even for cases where either 'base' or 'base + len'\n\tare not instrumented -- because they have been previously\n\tinstrumented.  Simplify the logic by putting all the statements\n\tinstrument 'base + len' inside a sequence, and then insert that\n\tsequence right before the current insertion point.  Then, to\n\tinstrument 'base + len', just get an iterator on that statement.\n\tAnd do not forget to update the pointer to iterator the function\n\treceived as argument.\n\ngcc/testsuite/\n\n\t* c-c++-common/asan/no-redundant-instrumentation-4.c: New test file.\n\t* c-c++-common/asan/no-redundant-instrumentation-5.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-6.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-7.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-8.c: Likewise.\n\t* c-c++-common/asan/pr56330.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-1.c (test1):\n\tEnsure the size argument of __builtin_memcpy is a constant.\n\nCo-Authored-By: Dodji Seketeli <dodji@redhat.com>\n\nFrom-SVN: r196102", "tree": {"sha": "8d20d0d3ec1ed8a33b52873e900b4acbeff14e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d20d0d3ec1ed8a33b52873e900b4acbeff14e5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b41288b3a57a382c7e06ef0f847584f06583ceb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41288b3a57a382c7e06ef0f847584f06583ceb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41288b3a57a382c7e06ef0f847584f06583ceb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41288b3a57a382c7e06ef0f847584f06583ceb4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d0648ac8ff3df5e4525fe8da00906493742c72c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0648ac8ff3df5e4525fe8da00906493742c72c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d0648ac8ff3df5e4525fe8da00906493742c72c"}], "stats": {"total": 230, "additions": 185, "deletions": 45}, "files": [{"sha": "07d5b8a32f3c928f56f8d1ec0a6ca79585ed5bfc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -1,3 +1,20 @@\n+2013-02-16  Jakub Jelinek  <jakub@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR asan/56330\n+\t* asan.c (get_mem_refs_of_builtin_call): White space and style\n+\tcleanup.\n+\t(instrument_mem_region_access): Do not forget to always put\n+\tinstrumentation of the of 'base' and 'base + len' in a \"if (len !=\n+\t0) statement, even for cases where either 'base' or 'base + len'\n+\tare not instrumented -- because they have been previously\n+\tinstrumented.  Simplify the logic by putting all the statements\n+\tinstrument 'base + len' inside a sequence, and then insert that\n+\tsequence right before the current insertion point.  Then, to\n+\tinstrument 'base + len', just get an iterator on that statement.\n+\tAnd do not forget to update the pointer to iterator the function\n+\treceived as argument.\n+\n 2013-02-15  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/56348"}, {"sha": "67236a92e4897a32dd291192ac3906604fe570c9", "filename": "gcc/asan.c", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -747,20 +747,17 @@ get_mem_refs_of_builtin_call (const gimple call,\n \n       got_reference_p = true;\n     }\n-    else\n-      {\n-\tif (dest)\n-\t  {\n-\t    dst->start = dest;\n-\t    dst->access_size = access_size;\n-\t    *dst_len = NULL_TREE;\n-\t    *dst_is_store = is_store;\n-\t    *dest_is_deref = true;\n-\t    got_reference_p = true;\n-\t  }\n-      }\n+  else if (dest)\n+    {\n+      dst->start = dest;\n+      dst->access_size = access_size;\n+      *dst_len = NULL_TREE;\n+      *dst_is_store = is_store;\n+      *dest_is_deref = true;\n+      got_reference_p = true;\n+    }\n \n-    return got_reference_p;\n+  return got_reference_p;\n }\n \n /* Return true iff a given gimple statement has been instrumented.\n@@ -1535,8 +1532,15 @@ instrument_mem_region_access (tree base, tree len,\n \n   /* If the beginning of the memory region has already been\n      instrumented, do not instrument it.  */\n-  if (has_mem_ref_been_instrumented (base, 1))\n-    goto after_first_instrumentation;\n+  bool start_instrumented = has_mem_ref_been_instrumented (base, 1);\n+\n+  /* If the end of the memory region has already been instrumented, do\n+     not instrument it. */\n+  tree end = asan_mem_ref_get_end (base, len);\n+  bool end_instrumented = has_mem_ref_been_instrumented (end, 1);\n+\n+  if (start_instrumented && end_instrumented)\n+    return;\n \n   if (!is_gimple_constant (len))\n     {\n@@ -1562,37 +1566,39 @@ instrument_mem_region_access (tree base, tree len,\n \n       /* The 'then block' of the 'if (len != 0) condition is where\n \t we'll generate the asan instrumentation code now.  */\n-      gsi = gsi_start_bb (then_bb);\n+      gsi = gsi_last_bb (then_bb);\n     }\n \n-  /* Instrument the beginning of the memory region to be accessed,\n-     and arrange for the rest of the intrumentation code to be\n-     inserted in the then block *after* the current gsi.  */\n-  build_check_stmt (location, base, &gsi, /*before_p=*/true, is_store, 1);\n-\n-  if (then_bb)\n-    /* We are in the case where the length of the region is not\n-       constant; so instrumentation code is being generated in the\n-       'then block' of the 'if (len != 0) condition.  Let's arrange\n-       for the subsequent instrumentation statements to go in the\n-       'then block'.  */\n-    gsi = gsi_last_bb (then_bb);\n-  else\n-    *iter = gsi;\n-\n-  update_mem_ref_hash_table (base, 1);\n+  if (!start_instrumented)\n+    {\n+      /* Instrument the beginning of the memory region to be accessed,\n+\t and arrange for the rest of the intrumentation code to be\n+\t inserted in the then block *after* the current gsi.  */\n+      build_check_stmt (location, base, &gsi, /*before_p=*/true, is_store, 1);\n+\n+      if (then_bb)\n+\t/* We are in the case where the length of the region is not\n+\t   constant; so instrumentation code is being generated in the\n+\t   'then block' of the 'if (len != 0) condition.  Let's arrange\n+\t   for the subsequent instrumentation statements to go in the\n+\t   'then block'.  */\n+\tgsi = gsi_last_bb (then_bb);\n+      else\n+        {\n+          *iter = gsi;\n+\t  /* Don't remember this access as instrumented, if length\n+\t     is unknown.  It might be zero and not being actually\n+\t     instrumented, so we can't rely on it being instrumented.  */\n+          update_mem_ref_hash_table (base, 1);\n+\t}\n+    }\n \n- after_first_instrumentation:\n+  if (end_instrumented)\n+    return;\n \n   /* We want to instrument the access at the end of the memory region,\n      which is at (base + len - 1).  */\n \n-  /* If the end of the memory region has already been instrumented, do\n-     not instrument it. */\n-  tree end = asan_mem_ref_get_end (base, len);\n-  if (has_mem_ref_been_instrumented (end, 1))\n-    return;\n-\n   /* offset = len - 1;  */\n   len = unshare_expr (len);\n   tree offset;\n@@ -1639,8 +1645,6 @@ instrument_mem_region_access (tree base, tree len,\n \t\t\t\t  base, NULL);\n   gimple_set_location (region_end, location);\n   gimple_seq_add_stmt_without_update (&seq, region_end);\n-  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n-  gsi_prev (&gsi);\n \n   /* _2 = _1 + offset;  */\n   region_end =\n@@ -1649,13 +1653,18 @@ instrument_mem_region_access (tree base, tree len,\n \t\t\t\t  gimple_assign_lhs (region_end),\n \t\t\t\t  offset);\n   gimple_set_location (region_end, location);\n-  gsi_insert_after (&gsi, region_end, GSI_NEW_STMT);\n+  gimple_seq_add_stmt_without_update (&seq, region_end);\n+  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n \n   /* instrument access at _2;  */\n+  gsi = gsi_for_stmt (region_end);\n   build_check_stmt (location, gimple_assign_lhs (region_end),\n \t\t    &gsi, /*before_p=*/false, is_store, 1);\n \n-  update_mem_ref_hash_table (end, 1);\n+  if (then_bb == NULL)\n+    update_mem_ref_hash_table (end, 1);\n+\n+  *iter = gsi_for_stmt (gsi_stmt (*iter));\n }\n \n /* Instrument the call (to the builtin strlen function) pointed to by\n@@ -1783,7 +1792,7 @@ instrument_builtin_call (gimple_stmt_iterator *iter)\n \t    }\n \t  else if (src0_len || src1_len || dest_len)\n \t    {\n-\t      if (src0.start)\n+\t      if (src0.start != NULL_TREE)\n \t\tinstrument_mem_region_access (src0.start, src0_len,\n \t\t\t\t\t      iter, loc, /*is_store=*/false);\n \t      if (src1.start != NULL_TREE)"}, {"sha": "1508a65d66cb6ee8b72a74ce2242c59ba70d9b73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -1,3 +1,16 @@\n+2013-02-16  Jakub Jelinek  <jakub@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR asan/56330\n+\t* c-c++-common/asan/no-redundant-instrumentation-4.c: New test file.\n+\t* c-c++-common/asan/no-redundant-instrumentation-5.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-6.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-7.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-8.c: Likewise.\n+\t* c-c++-common/asan/pr56330.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-1.c (test1):\n+\tEnsure the size argument of __builtin_memcpy is a constant.\n+\n 2013-02-15  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "6cf644195d6f7953779d0e9405ccc7ee5dc6f86f", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -45,7 +45,7 @@ test1 ()\n   /* There are 2 calls to __builtin___asan_report_store1 and 2 calls\n      to __builtin___asan_report_load1 to instrument the store to\n      (subset of) the memory region of tab.  */\n-  __builtin_memcpy (&tab[1], foo, sizeof (tab) - 1);\n+  __builtin_memcpy (&tab[1], foo, 3);\n \n   /* This should not generate a __builtin___asan_report_load1 because\n      the reference to tab[1] has been already instrumented above.  */"}, {"sha": "b2e72841b35570549bb0f367e2be0ca68795e0fd", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+void\n+foo  (int *a, char *b, char *c)\n+{\n+  __builtin_memmove (c, b, a[c[0]]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 3 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 1 \"asan0\" } } */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "ead3f582330fb480445457d422182cbfde1afae1", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+void\n+foo  (int *a, char *b, char *c)\n+{\n+  __builtin_memmove (c, b, a[b[0]]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 2 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 2 \"asan0\" } } */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "e4691bc4734fd84618a1aa34358fb12361eacec3", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+void\n+foo  (int *a, char *b, char *c)\n+{\n+  __builtin_memmove (c, b, a[c[0]]);\n+  __builtin_memmove (c, b, a[b[0]]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 5 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 2 \"asan0\" } } */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "075e9cfb86826a14c52c939c2f3c011152cd9a65", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-7.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+char e[200];\n+\n+struct S\n+{\n+  char a[100];\n+  char b[100];\n+} s;\n+\n+int\n+foo  (int *a, char *b, char *c)\n+{\n+  int d = __builtin_memcmp (s.a, e, 100);\n+  d += __builtin_memcmp (s.a, e, 200);\n+  return d;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 6 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-not \"__builtin___asan_report_store\" \"asan0\" } } */\n+/* { dg-final { cleanup-tree-dump \"asan\" } } */"}, {"sha": "38ea7a21d1e532c8b1889649f21a32abaa477a73", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-8.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n+\n+char\n+foo  (int *a, char *b, char *c)\n+{\n+  __builtin_memmove (c, b, a[b[0]]);\n+  return c[0] + b[0];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 3 \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 2 \"asan0\" } } */\n+/* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "25759f4ec9e9faf203ca7c7ef16bf2ff5b26d912", "filename": "gcc/testsuite/c-c++-common/asan/pr56330.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fpr56330.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b41288b3a57a382c7e06ef0f847584f06583ceb4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fpr56330.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fpr56330.c?ref=b41288b3a57a382c7e06ef0f847584f06583ceb4", "patch": "@@ -0,0 +1,24 @@\n+/* PR sanitizer/56330 */\n+/* { dg-do compile } */\n+\n+char e[200];\n+\n+struct S\n+{\n+  char a[100];\n+  char b[100];\n+} s;\n+\n+int\n+foo (void)\n+{\n+  int i = __builtin_memcmp (s.a, e, 100);\n+  i += __builtin_memcmp (s.a, e, 200);\n+  return i;\n+}\n+\n+void\n+bar (int *a, char *b, char *c)\n+{\n+  __builtin_memmove (c, b, a[b[0]]);\n+}"}]}