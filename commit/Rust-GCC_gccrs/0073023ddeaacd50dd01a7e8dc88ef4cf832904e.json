{"sha": "0073023ddeaacd50dd01a7e8dc88ef4cf832904e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA3MzAyM2RkZWFhY2Q1MGRkMDFhN2U4ZGM4OGVmNGNmODMyOTA0ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-28T18:29:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-28T18:29:14Z"}, "message": "i386.md (sse_mov?fcc*): New patterns and splitters.\n\n\t* i386.md (sse_mov?fcc*): New patterns and splitters.\n\t* i386.c (ix86_expand_movcc): Work post-reload; recognize\n\tthe SSE based conditional moves.\n\nFrom-SVN: r40133", "tree": {"sha": "9d2a4701b9448e97a9cf5dd6cb707312e8109265", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d2a4701b9448e97a9cf5dd6cb707312e8109265"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0073023ddeaacd50dd01a7e8dc88ef4cf832904e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0073023ddeaacd50dd01a7e8dc88ef4cf832904e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0073023ddeaacd50dd01a7e8dc88ef4cf832904e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0073023ddeaacd50dd01a7e8dc88ef4cf832904e/comments", "author": null, "committer": null, "parents": [{"sha": "2b04e52b0b64e8e1b31fc477adff21517099f2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b04e52b0b64e8e1b31fc477adff21517099f2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b04e52b0b64e8e1b31fc477adff21517099f2f4"}], "stats": {"total": 296, "additions": 296, "deletions": 0}, "files": [{"sha": "8ed7bbe38889cffa2a724ff59ad3aa4076429b34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0073023ddeaacd50dd01a7e8dc88ef4cf832904e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0073023ddeaacd50dd01a7e8dc88ef4cf832904e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0073023ddeaacd50dd01a7e8dc88ef4cf832904e", "patch": "@@ -1,3 +1,9 @@\n+Wed Feb 28 19:28:06 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (sse_mov?fcc*): New patterns and splitters.\n+\t* i386.c (ix86_expand_movcc): Work post-reload; recognize\n+\tthe SSE based conditional moves.\n+\n Wed Feb 28 19:18:23 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (attribute mode): Add \"TI\"."}, {"sha": "da323ab8450d7e0212f7b87638f1eb2a96bed660", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0073023ddeaacd50dd01a7e8dc88ef4cf832904e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0073023ddeaacd50dd01a7e8dc88ef4cf832904e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0073023ddeaacd50dd01a7e8dc88ef4cf832904e", "patch": "@@ -6016,6 +6016,92 @@ ix86_expand_fp_movcc (operands)\n   rtx tmp;\n   rtx compare_op, second_test, bypass_test;\n \n+  /* For SF/DFmode conditional moves based on comparisons\n+     in same mode, we may want to use SSE min/max instructions.  */\n+  if (((TARGET_SSE && GET_MODE (operands[0]) == SFmode)\n+       || (TARGET_SSE2 && GET_MODE (operands[0]) == DFmode))\n+      && GET_MODE (ix86_compare_op0) == GET_MODE (operands[0])\n+      /* We may be called from the post-reload splitter.  */\n+      && (!REG_P (operands[0])\n+\t  || SSE_REG_P (operands[0])\n+\t  || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n+    {\n+      rtx op0 = ix86_compare_op0, op1 = ix86_compare_op1;\n+      code = GET_CODE (operands[1]);\n+\n+      /* See if we have (cross) match between comparison operands and\n+         conditional move operands.  */\n+      if (rtx_equal_p (operands[2], op1))\n+\t{\n+\t  rtx tmp = op0;\n+\t  op0 = op1;\n+\t  op1 = tmp;\n+\t  code = reverse_condition_maybe_unordered (code);\n+\t}\n+      if (rtx_equal_p (operands[2], op0) && rtx_equal_p (operands[3], op1))\n+\t{\n+\t  /* Check for min operation.  */\n+\t  if (code == LT)\n+\t    {\n+\t       operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);\n+\t       if (memory_operand (op0, VOIDmode))\n+\t\t op0 = force_reg (GET_MODE (operands[0]), op0);\n+\t       if (GET_MODE (operands[0]) == SFmode)\n+\t\t emit_insn (gen_minsf3 (operands[0], op0, op1));\n+\t       else\n+\t\t emit_insn (gen_mindf3 (operands[0], op0, op1));\n+\t       return 1;\n+\t    }\n+\t  /* Check for max operation.  */\n+\t  if (code == GT)\n+\t    {\n+\t       operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);\n+\t       if (memory_operand (op0, VOIDmode))\n+\t\t op0 = force_reg (GET_MODE (operands[0]), op0);\n+\t       if (GET_MODE (operands[0]) == SFmode)\n+\t\t emit_insn (gen_maxsf3 (operands[0], op0, op1));\n+\t       else\n+\t\t emit_insn (gen_maxdf3 (operands[0], op0, op1));\n+\t       return 1;\n+\t    }\n+\t}\n+      /* Manage condition to be sse_comparison_operator.  In case we are\n+\t in non-ieee mode, try to canonicalize the destination operand\n+\t to be first in the comparison - this helps reload to avoid extra\n+\t moves.  */\n+      if (!sse_comparison_operator (operands[1], VOIDmode)\n+\t  || (rtx_equal_p (operands[0], ix86_compare_op1) && !TARGET_IEEE_FP))\n+\t{\n+\t  rtx tmp = ix86_compare_op0;\n+\t  ix86_compare_op0 = ix86_compare_op1;\n+\t  ix86_compare_op1 = tmp;\n+\t  operands[1] = gen_rtx_fmt_ee (swap_condition (GET_CODE (operands[1])),\n+\t\t\t\t\tVOIDmode, ix86_compare_op0,\n+\t\t\t\t\tix86_compare_op1);\n+\t}\n+      /* Similary try to manage result to be first operand of conditional\n+\t move. */\n+      if (rtx_equal_p (operands[0], operands[3]))\n+\t{\n+\t  rtx tmp = operands[2];\n+\t  operands[2] = operands[3];\n+\t  operands[2] = tmp;\n+\t  operands[1] = gen_rtx_fmt_ee (reverse_condition_maybe_unordered\n+\t\t\t\t\t  (GET_CODE (operands[1])),\n+\t\t\t\t\tVOIDmode, ix86_compare_op0,\n+\t\t\t\t\tix86_compare_op1);\n+\t}\n+      if (GET_MODE (operands[0]) == SFmode)\n+\temit_insn (gen_sse_movsfcc (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3],\n+\t\t\t\t    ix86_compare_op0, ix86_compare_op1));\n+      else\n+\temit_insn (gen_sse_movdfcc (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3],\n+\t\t\t\t    ix86_compare_op0, ix86_compare_op1));\n+      return 1;\n+    }\n+\n   /* The floating point conditional move instructions don't directly\n      support conditions resulting from a signed integer comparison.  */\n "}, {"sha": "e6257a738fe63a012bd0cfaa140f8184bf1b1ca7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0073023ddeaacd50dd01a7e8dc88ef4cf832904e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0073023ddeaacd50dd01a7e8dc88ef4cf832904e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0073023ddeaacd50dd01a7e8dc88ef4cf832904e", "patch": "@@ -12481,6 +12481,210 @@\n \t      (const_string \"lea\")))\n    (set_attr \"mode\" \"SI\")])\n \n+;; Placeholder for the conditional moves.  This one is split eighter to SSE\n+;; based moves emulation or to usual cmove sequence.  Little bit unfortunate\n+;; fact is that compares supported by the cmp??ss instructions are exactly\n+;; swapped of those supported by cmove sequence.\n+\n+(define_insn \"sse_movsfcc\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=&x#rf,x#rf,?f#xr,?f#xr,?f#xr,?f#xr,?r#xf,?r#xf,?r#xf,?r#xf\")\n+\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"0#fx,x#fx,f#x,f#x,xm#f,xm#f,f#x,f#x,xm#f,xm#f\")\n+\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm#f,xm#f,f#x,f#x,x#f,x#f,f#x,f#x,x#f,x#f\")])\n+\t\t      (match_operand:SF 2 \"nonimmediate_operand\" \"x#fr,0#fr,f#fx,0#fx,f#fx,0#fx,rm#rx,0#rx,rm#rx,0#rx\")\n+\t\t      (match_operand:SF 3 \"nonimmediate_operand\" \"x#fr,x#fr,0#fx,f#fx,0#fx,f#fx,0#fx,rm#rx,0#rx,rm#rx\")))\n+   (clobber (match_scratch:SF 6 \"=2,&5,X,X,X,X,X,X,X,X\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE\n+   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n+  \"#\")\n+\n+(define_insn \"sse_movdfcc\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=&x#rf,x#rf,?f#xr,?f#xr,?f#xr,?f#xr,?r#xf,?r#xf,?r#xf,?r#xf\")\n+\t(if_then_else:DF (match_operator 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:DF 4 \"nonimmediate_operand\" \"0#fx,x#fx,f#x,f#x,xm#f,xm#f,f#x,f#x,xm#f,xm#f\")\n+\t\t\t (match_operand:DF 5 \"nonimmediate_operand\" \"xm#f,xm#f,f#x,f#x,x#f,x#f,f#x,f#x,x#f,x#f\")])\n+\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"x#fr,0#fr,f#fx,0#fx,f#fx,0#fx,rm#rx,0#rx,rm#rx,0#rx\")\n+\t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"x#fr,x#fr,0#fx,f#fx,0#fx,f#fx,0#fx,rm#rx,0#rx,rm#rx\")))\n+   (clobber (match_scratch:DF 6 \"=2,&5,X,X,X,X,X,X,X,X\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE2\n+   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n+  \"#\")\n+\n+;; For non-sse moves just expand the usual cmove sequence.\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t[(match_operand 4 \"nonimmediate_operand\" \"\")\n+\t\t\t (match_operand 5 \"register_operand\" \"\")])\n+\t\t      (match_operand 2 \"nonimmediate_operand\" \"\")\n+\t\t      (match_operand 3 \"nonimmediate_operand\" \"\")))\n+   (clobber (match_operand 6 \"\" \"\"))\n+   (clobber (reg:CC 17))]\n+  \"!SSE_REG_P (operands[0]) && reload_completed\n+   && VALID_SSE_REG_MODE (GET_MODE (operands[0]))\"\n+  [(const_int 0)]\n+  \"\n+{\n+   ix86_compare_op0 = operands[5];\n+   ix86_compare_op1 = operands[4];\n+   operands[1] = gen_rtx_fmt_ee (swap_condition (GET_CODE (operands[1])),\n+\t\t\t\t VOIDmode, operands[5], operands[4]);\n+   ix86_expand_fp_movcc (operands);\n+   DONE;\n+}\")\n+\n+;; Split SSE based conditional move into seqence:\n+;; cmpCC op0, op4   -  set op0 to 0 or ffffffff depending on the comparison\n+;; and   op2, op0   -  zero op2 if comparison was false\n+;; nand  op0, op3   -  load op3 to op0 if comparison was false\n+;; or\t op2, op0   -  get the non-zero one into the result.\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand 4 \"register_operand\" \"\")\n+\t\t\t (match_operand 5 \"nonimmediate_operand\" \"\")])\n+\t\t      (match_operand 2 \"register_operand\" \"\")\n+\t\t      (match_operand 3 \"register_operand\" \"\")))\n+   (clobber (match_dup 2))\n+   (clobber (reg:CC 17))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  [(set (match_dup 4) (match_op_dup 1 [(match_dup 4) (match_dup 5)]))\n+   (set (subreg:TI (match_dup 2) 0) (and:TI (subreg:TI (match_dup 2) 0)\n+\t\t\t\t\t    (subreg:TI (match_dup 0) 0)))\n+   (set (subreg:TI (match_dup 4) 0) (and:TI (not:TI (subreg:TI (match_dup 0) 0))\n+\t\t\t\t\t    (subreg:TI (match_dup 3) 0)))\n+   (set (subreg:TI (match_dup 0) 0) (ior:TI (subreg:TI (match_dup 6) 0)\n+\t\t\t\t\t    (subreg:TI (match_dup 7) 0)))]\n+  \"\n+{\n+  PUT_MODE (operands[1], GET_MODE (operands[0]));\n+  if (rtx_equal_p (operands[0], operands[4]))\n+    operands[6] = operands[4], operands[7] = operands[2];\n+  else\n+    operands[6] = operands[2], operands[7] = operands[0];\n+}\")\n+\n+;; Special case of conditional move we can handle effectivly.\n+;; Do not brother with the integer/floating point case, since these are\n+;; bot considerably slower, unlike in the generic case.\n+(define_insn \"*sse_movsfcc_const0_1\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm\")])\n+\t\t      (match_operand:SF 2 \"register_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"const0_operand\" \"X\")))]\n+  \"TARGET_SSE\"\n+  \"#\")\n+\n+(define_insn \"*sse_movsfcc_const0_2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm\")])\n+\t\t      (match_operand:SF 2 \"const0_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"X\")))]\n+  \"TARGET_SSE\"\n+  \"#\")\n+\n+(define_insn \"*sse_movsfcc_const0_3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"xm\")\n+\t\t\t (match_operand:SF 5 \"register_operand\" \"0\")])\n+\t\t      (match_operand:SF 2 \"register_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"const0_operand\" \"X\")))]\n+  \"TARGET_SSE\"\n+  \"#\")\n+\n+(define_insn \"*sse_movsfcc_const0_4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"xm\")\n+\t\t\t (match_operand:SF 5 \"register_operand\" \"0\")])\n+\t\t      (match_operand:SF 2 \"const0_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"X\")))]\n+  \"TARGET_SSE\"\n+  \"#\")\n+\n+(define_insn \"*sse_movdfcc_const0_1\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm\")])\n+\t\t      (match_operand:SF 2 \"register_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"const0_operand\" \"X\")))]\n+  \"TARGET_SSE2\"\n+  \"#\")\n+\n+(define_insn \"*sse_movdfcc_const0_2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm\")])\n+\t\t      (match_operand:SF 2 \"const0_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"X\")))]\n+  \"TARGET_SSE2\"\n+  \"#\")\n+\n+(define_insn \"*sse_movdfcc_const0_3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"xm\")\n+\t\t\t (match_operand:SF 5 \"register_operand\" \"0\")])\n+\t\t      (match_operand:SF 2 \"register_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"const0_operand\" \"X\")))]\n+  \"TARGET_SSE2\"\n+  \"#\")\n+\n+(define_insn \"*sse_movdfcc_const0_4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\"\n+\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"xm\")\n+\t\t\t (match_operand:SF 5 \"register_operand\" \"0\")])\n+\t\t      (match_operand:SF 2 \"const0_operand\" \"x\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"X\")))]\n+  \"TARGET_SSE2\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t[(match_operand 4 \"register_operand\" \"\")\n+\t\t\t (match_operand 5 \"nonimmediate_operand\" \"\")])\n+\t\t      (match_operand 2 \"nonmemory_operand\" \"\")\n+\t\t      (match_operand 3 \"nonmemory_operand\" \"\")))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\n+   && (const0_operand (operands[2], GET_MODE (operands[0]))\n+       || const0_operand (operands[3], GET_MODE (operands[0])))\"\n+  [(set (match_dup 0) (match_op_dup 1 [(match_dup 0) (match_dup 5)]))\n+   (set (subreg:TI (match_dup 0) 0) (and:TI (match_dup 6)\n+\t\t\t\t\t    (subreg:TI (match_dup 7) 0)))]\n+  \"\n+{\n+  PUT_MODE (operands[1], GET_MODE (operands[0]));\n+  if (!sse_comparison_operator (operands[1], VOIDmode))\n+    {\n+      rtx tmp = operands[5];\n+      operands[5] = operands[4];\n+      operands[4] = tmp;\n+      PUT_CODE (operands[1], swap_condition (GET_CODE (operands[1])));\n+    }\n+  if (const0_operand (operands[2], GET_MODE (operands[0])))\n+    {\n+      operands[7] = operands[3];\n+      operands[6] = gen_rtx_NOT (TImode, gen_rtx_SUBREG (TImode, operands[0],\n+\t\t\t\t\t\t\t 0));\n+    }\n+  else\n+    {\n+      operands[7] = operands[2];\n+      operands[6] = gen_rtx_SUBREG (TImode, operands[0], 0);\n+    }\n+}\")\n+\n (define_insn \"allocate_stack_worker\"\n   [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"a\")] 3)\n    (set (reg:SI 7) (minus:SI (reg:SI 7) (match_dup 0)))"}]}