{"sha": "c7b8bff73412d6ed24d7aee7a21d42a46e393d68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiOGJmZjczNDEyZDZlZDI0ZDdhZWU3YTIxZDQyYTQ2ZTM5M2Q2OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-04-30T13:18:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-04-30T13:18:59Z"}, "message": "tree-cfg.c (verify_address): Remove base argument, add flag whether to check TREE_ADDRESSABLE and do that.\n\n2018-04-30  Richard Biener  <rguenther@suse.de>\n\n\t* tree-cfg.c (verify_address): Remove base argument, add\n\tflag whether to check TREE_ADDRESSABLE and do that.\n\t(verify_expr): Remove.\n\t(verify_types_in_gimple_reference): Add pieces from verify_expr.\n\t(verify_gimple_assign_single): Likewise.\n\t(verify_gimple_switch): Likewise.\n\t(verify_expr_location_1): Dereference tp once.  Add (disabled)\n\tpiece from verify_expr.\n\t(verify_gimple_in_cfg): Do not call verify_expr on all ops.\n\nFrom-SVN: r259765", "tree": {"sha": "25383cd8246b747f5bccce4d87cdee282a46e7c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25383cd8246b747f5bccce4d87cdee282a46e7c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7b8bff73412d6ed24d7aee7a21d42a46e393d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b8bff73412d6ed24d7aee7a21d42a46e393d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7b8bff73412d6ed24d7aee7a21d42a46e393d68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b8bff73412d6ed24d7aee7a21d42a46e393d68/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6fe3b9fdd591ea8c5590c87bb5aecd922ada6072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe3b9fdd591ea8c5590c87bb5aecd922ada6072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fe3b9fdd591ea8c5590c87bb5aecd922ada6072"}], "stats": {"total": 531, "additions": 183, "deletions": 348}, "files": [{"sha": "af84646286026e46bdbe227c9ee4db4822719a7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b8bff73412d6ed24d7aee7a21d42a46e393d68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b8bff73412d6ed24d7aee7a21d42a46e393d68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7b8bff73412d6ed24d7aee7a21d42a46e393d68", "patch": "@@ -1,3 +1,15 @@\n+2018-04-30  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-cfg.c (verify_address): Remove base argument, add\n+\tflag whether to check TREE_ADDRESSABLE and do that.\n+\t(verify_expr): Remove.\n+\t(verify_types_in_gimple_reference): Add pieces from verify_expr.\n+\t(verify_gimple_assign_single): Likewise.\n+\t(verify_gimple_switch): Likewise.\n+\t(verify_expr_location_1): Dereference tp once.  Add (disabled)\n+\tpiece from verify_expr.\n+\t(verify_gimple_in_cfg): Do not call verify_expr on all ops.\n+\n 2018-04-30  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/linux.h (CLEAR_INSN_CACHE): Define."}, {"sha": "2ada965edd61689af35896ccc7c1536d98a6dc62", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 171, "deletions": 348, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b8bff73412d6ed24d7aee7a21d42a46e393d68/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b8bff73412d6ed24d7aee7a21d42a46e393d68/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c7b8bff73412d6ed24d7aee7a21d42a46e393d68", "patch": "@@ -2982,10 +2982,11 @@ gimple_split_edge (edge edge_in)\n }\n \n \n-/* Verify properties of the address expression T with base object BASE.  */\n+/* Verify properties of the address expression T whose base should be\n+   TREE_ADDRESSABLE if VERIFY_ADDRESSABLE is true.  */\n \n-static tree\n-verify_address (tree t, tree base)\n+static bool \n+verify_address (tree t, bool verify_addressable)\n {\n   bool old_constant;\n   bool old_side_effects;\n@@ -3002,319 +3003,36 @@ verify_address (tree t, tree base)\n   if (old_constant != new_constant)\n     {\n       error (\"constant not recomputed when ADDR_EXPR changed\");\n-      return t;\n+      return true;\n     }\n   if (old_side_effects != new_side_effects)\n     {\n       error (\"side effects not recomputed when ADDR_EXPR changed\");\n-      return t;\n+      return true;\n     }\n \n+  tree base = TREE_OPERAND (t, 0);\n+  while (handled_component_p (base))\n+    base = TREE_OPERAND (base, 0);\n+\n   if (!(VAR_P (base)\n \t|| TREE_CODE (base) == PARM_DECL\n \t|| TREE_CODE (base) == RESULT_DECL))\n-    return NULL_TREE;\n+    return false;\n \n   if (DECL_GIMPLE_REG_P (base))\n     {\n       error (\"DECL_GIMPLE_REG_P set on a variable with address taken\");\n-      return base;\n+      return true;\n     }\n \n-  return NULL_TREE;\n-}\n-\n-/* Callback for walk_tree, check that all elements with address taken are\n-   properly noticed as such.  The DATA is an int* that is 1 if TP was seen\n-   inside a PHI node.  */\n-\n-static tree\n-verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp, x;\n-\n-  if (TYPE_P (t))\n-    *walk_subtrees = 0;\n-\n-  /* Check operand N for being valid GIMPLE and give error MSG if not.  */\n-#define CHECK_OP(N, MSG) \\\n-  do { if (!is_gimple_val (TREE_OPERAND (t, N)))\t\t\\\n-       { error (MSG); return TREE_OPERAND (t, N); }} while (0)\n-\n-  switch (TREE_CODE (t))\n+  if (verify_addressable && !TREE_ADDRESSABLE (base))\n     {\n-    case SSA_NAME:\n-      if (SSA_NAME_IN_FREE_LIST (t))\n-\t{\n-\t  error (\"SSA name in freelist but still referenced\");\n-\t  return *tp;\n-\t}\n-      break;\n-\n-    case PARM_DECL:\n-    case VAR_DECL:\n-    case RESULT_DECL:\n-      {\n-\ttree context = decl_function_context (t);\n-\tif (context != cfun->decl\n-\t    && !SCOPE_FILE_SCOPE_P (context)\n-\t    && !TREE_STATIC (t)\n-\t    && !DECL_EXTERNAL (t))\n-\t  {\n-\t    error (\"Local declaration from a different function\");\n-\t    return t;\n-\t  }\n-      }\n-      break;\n-\n-    case INDIRECT_REF:\n-      error (\"INDIRECT_REF in gimple IL\");\n-      return t;\n-\n-    case MEM_REF:\n-      x = TREE_OPERAND (t, 0);\n-      if (!POINTER_TYPE_P (TREE_TYPE (x))\n-\t  || !is_gimple_mem_ref_addr (x))\n-\t{\n-\t  error (\"invalid first operand of MEM_REF\");\n-\t  return x;\n-\t}\n-      if (!poly_int_tree_p (TREE_OPERAND (t, 1))\n-\t  || !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 1))))\n-\t{\n-\t  error (\"invalid offset operand of MEM_REF\");\n-\t  return TREE_OPERAND (t, 1);\n-\t}\n-      if (TREE_CODE (x) == ADDR_EXPR)\n-\t{\n-\t  tree va = verify_address (x, TREE_OPERAND (x, 0));\n-\t  if (va)\n-\t    return va;\n-\t  x = TREE_OPERAND (x, 0);\n-\t}\n-      walk_tree (&x, verify_expr, data, NULL);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case ASSERT_EXPR:\n-      x = fold (ASSERT_EXPR_COND (t));\n-      if (x == boolean_false_node)\n-\t{\n-\t  error (\"ASSERT_EXPR with an always-false condition\");\n-\t  return *tp;\n-\t}\n-      break;\n-\n-    case MODIFY_EXPR:\n-      error (\"MODIFY_EXPR not expected while having tuples\");\n-      return *tp;\n-\n-    case ADDR_EXPR:\n-      {\n-\ttree tem;\n-\n-\tgcc_assert (is_gimple_address (t));\n-\n-\t/* Skip any references (they will be checked when we recurse down the\n-\t   tree) and ensure that any variable used as a prefix is marked\n-\t   addressable.  */\n-\tfor (x = TREE_OPERAND (t, 0);\n-\t     handled_component_p (x);\n-\t     x = TREE_OPERAND (x, 0))\n-\t  ;\n-\n-\tif ((tem = verify_address (t, x)))\n-\t  return tem;\n-\n-\tif (!(VAR_P (x)\n-\t      || TREE_CODE (x) == PARM_DECL\n-\t      || TREE_CODE (x) == RESULT_DECL))\n-\t  return NULL;\n-\n-\tif (!TREE_ADDRESSABLE (x))\n-\t  {\n-\t    error (\"address taken, but ADDRESSABLE bit not set\");\n-\t    return x;\n-\t  }\n-\n-\tbreak;\n-      }\n-\n-    case COND_EXPR:\n-      gcc_unreachable ();\n-\n-    case NON_LVALUE_EXPR:\n-    case TRUTH_NOT_EXPR:\n-      gcc_unreachable ();\n-\n-    CASE_CONVERT:\n-    case FIX_TRUNC_EXPR:\n-    case FLOAT_EXPR:\n-    case NEGATE_EXPR:\n-    case ABS_EXPR:\n-    case BIT_NOT_EXPR:\n-      gcc_unreachable ();\n-\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-    case BIT_FIELD_REF:\n-      if (!is_gimple_reg_type (TREE_TYPE (t)))\n-\t{\n-\t  error (\"non-scalar BIT_FIELD_REF, IMAGPART_EXPR or REALPART_EXPR\");\n-\t  return t;\n-\t}\n-\n-      if (TREE_CODE (t) == BIT_FIELD_REF)\n-\t{\n-\t  tree t0 = TREE_OPERAND (t, 0);\n-\t  tree t1 = TREE_OPERAND (t, 1);\n-\t  tree t2 = TREE_OPERAND (t, 2);\n-\t  poly_uint64 size, bitpos;\n-\t  if (!poly_int_tree_p (t1, &size)\n-\t      || !poly_int_tree_p (t2, &bitpos)\n-\t      || !types_compatible_p (bitsizetype, TREE_TYPE (t1))\n-\t      || !types_compatible_p (bitsizetype, TREE_TYPE (t2)))\n-\t    {\n-\t      error (\"invalid position or size operand to BIT_FIELD_REF\");\n-\t      return t;\n-\t    }\n-\t  if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t      && maybe_ne (TYPE_PRECISION (TREE_TYPE (t)), size))\n-\t    {\n-\t      error (\"integral result type precision does not match \"\n-\t\t     \"field size of BIT_FIELD_REF\");\n-\t      return t;\n-\t    }\n-\t  else if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t\t   && TYPE_MODE (TREE_TYPE (t)) != BLKmode\n-\t\t   && maybe_ne (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (t))),\n-\t\t\t\tsize))\n-\t    {\n-\t      error (\"mode size of non-integral result does not \"\n-\t\t     \"match field size of BIT_FIELD_REF\");\n-\t      return t;\n-\t    }\n-\t  if (!AGGREGATE_TYPE_P (TREE_TYPE (t0))\n-\t      && maybe_gt (size + bitpos,\n-\t\t\t   tree_to_poly_uint64 (TYPE_SIZE (TREE_TYPE (t0)))))\n-\t    {\n-\t      error (\"position plus size exceeds size of referenced object in \"\n-\t\t     \"BIT_FIELD_REF\");\n-\t      return t;\n-\t    }\n-\t}\n-      t = TREE_OPERAND (t, 0);\n-\n-      /* Fall-through.  */\n-    case COMPONENT_REF:\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n-    case VIEW_CONVERT_EXPR:\n-      /* We have a nest of references.  Verify that each of the operands\n-\t that determine where to reference is either a constant or a variable,\n-\t verify that the base is valid, and then show we've already checked\n-\t the subtrees.  */\n-      while (handled_component_p (t))\n-\t{\n-\t  if (TREE_CODE (t) == COMPONENT_REF && TREE_OPERAND (t, 2))\n-\t    CHECK_OP (2, \"invalid COMPONENT_REF offset operator\");\n-\t  else if (TREE_CODE (t) == ARRAY_REF\n-\t\t   || TREE_CODE (t) == ARRAY_RANGE_REF)\n-\t    {\n-\t      CHECK_OP (1, \"invalid array index\");\n-\t      if (TREE_OPERAND (t, 2))\n-\t\tCHECK_OP (2, \"invalid array lower bound\");\n-\t      if (TREE_OPERAND (t, 3))\n-\t\tCHECK_OP (3, \"invalid array stride\");\n-\t    }\n-\t  else if (TREE_CODE (t) == BIT_FIELD_REF\n-\t\t   || TREE_CODE (t) == REALPART_EXPR\n-\t\t   || TREE_CODE (t) == IMAGPART_EXPR)\n-\t    {\n-\t      error (\"non-top-level BIT_FIELD_REF, IMAGPART_EXPR or \"\n-\t\t     \"REALPART_EXPR\");\n-\t      return t;\n-\t    }\n-\n-\t  t = TREE_OPERAND (t, 0);\n-\t}\n-\n-      if (!is_gimple_min_invariant (t) && !is_gimple_lvalue (t))\n-\t{\n-\t  error (\"invalid reference prefix\");\n-\t  return t;\n-\t}\n-      walk_tree (&t, verify_expr, data, NULL);\n-      *walk_subtrees = 0;\n-      break;\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      gcc_unreachable ();\n-\n-    case POINTER_DIFF_EXPR:\n-      gcc_unreachable ();\n-\n-    case POINTER_PLUS_EXPR:\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case CEIL_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-    case RDIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-    case MIN_EXPR:\n-    case MAX_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case LROTATE_EXPR:\n-    case RROTATE_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case BIT_AND_EXPR:\n-      gcc_unreachable ();\n-\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case UNORDERED_EXPR:\n-    case ORDERED_EXPR:\n-    case UNLT_EXPR:\n-    case UNLE_EXPR:\n-    case UNGT_EXPR:\n-    case UNGE_EXPR:\n-    case UNEQ_EXPR:\n-    case LTGT_EXPR:\n-      /* Reachable via COND_EXPR condition which is GENERIC.  */\n-      CHECK_OP (0, \"invalid operand to binary operator\");\n-      CHECK_OP (1, \"invalid operand to binary operator\");\n-      break;\n-\n-    case CONSTRUCTOR:\n-      if (TREE_CONSTANT (t) && TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n-\t*walk_subtrees = 0;\n-      break;\n-\n-    case CASE_LABEL_EXPR:\n-      if (CASE_CHAIN (t))\n-\t{\n-\t  error (\"invalid CASE_CHAIN\");\n-\t  return t;\n-\t}\n-      break;\n-\n-    default:\n-      break;\n+      error (\"address taken, but ADDRESSABLE bit not set\");\n+      return true;\n     }\n-  return NULL;\n \n-#undef CHECK_OP\n+  return false;\n }\n \n \n@@ -3359,8 +3077,79 @@ verify_types_in_gimple_min_lval (tree expr)\n static bool\n verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n {\n+  if (TREE_CODE (expr) == REALPART_EXPR\n+      || TREE_CODE (expr) == IMAGPART_EXPR\n+      || TREE_CODE (expr) == BIT_FIELD_REF)\n+    {\n+      tree op = TREE_OPERAND (expr, 0);\n+      if (!is_gimple_reg_type (TREE_TYPE (expr)))\n+\t{\n+\t  error (\"non-scalar BIT_FIELD_REF, IMAGPART_EXPR or REALPART_EXPR\");\n+\t  return true;\n+\t}\n+\n+      if (TREE_CODE (expr) == BIT_FIELD_REF)\n+\t{\n+\t  tree t1 = TREE_OPERAND (expr, 1);\n+\t  tree t2 = TREE_OPERAND (expr, 2);\n+\t  poly_uint64 size, bitpos;\n+\t  if (!poly_int_tree_p (t1, &size)\n+\t      || !poly_int_tree_p (t2, &bitpos)\n+\t      || !types_compatible_p (bitsizetype, TREE_TYPE (t1))\n+\t      || !types_compatible_p (bitsizetype, TREE_TYPE (t2)))\n+\t    {\n+\t      error (\"invalid position or size operand to BIT_FIELD_REF\");\n+\t      return true;\n+\t    }\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+\t      && maybe_ne (TYPE_PRECISION (TREE_TYPE (expr)), size))\n+\t    {\n+\t      error (\"integral result type precision does not match \"\n+\t\t     \"field size of BIT_FIELD_REF\");\n+\t      return true;\n+\t    }\n+\t  else if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+\t\t   && TYPE_MODE (TREE_TYPE (expr)) != BLKmode\n+\t\t   && maybe_ne (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (expr))),\n+\t\t\t\tsize))\n+\t    {\n+\t      error (\"mode size of non-integral result does not \"\n+\t\t     \"match field size of BIT_FIELD_REF\");\n+\t      return true;\n+\t    }\n+\t  if (!AGGREGATE_TYPE_P (TREE_TYPE (op))\n+\t      && maybe_gt (size + bitpos,\n+\t\t\t   tree_to_poly_uint64 (TYPE_SIZE (TREE_TYPE (op)))))\n+\t    {\n+\t      error (\"position plus size exceeds size of referenced object in \"\n+\t\t     \"BIT_FIELD_REF\");\n+\t      return true;\n+\t    }\n+\t}\n+\n+      if ((TREE_CODE (expr) == REALPART_EXPR\n+\t   || TREE_CODE (expr) == IMAGPART_EXPR)\n+\t  && !useless_type_conversion_p (TREE_TYPE (expr),\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (op))))\n+\t{\n+\t  error (\"type mismatch in real/imagpart reference\");\n+\t  debug_generic_stmt (TREE_TYPE (expr));\n+\t  debug_generic_stmt (TREE_TYPE (TREE_TYPE (op)));\n+\t  return true;\n+\t}\n+      expr = op;\n+    }\n+\n   while (handled_component_p (expr))\n     {\n+      if (TREE_CODE (expr) == REALPART_EXPR\n+\t  || TREE_CODE (expr) == IMAGPART_EXPR\n+\t  || TREE_CODE (expr) == BIT_FIELD_REF)\n+\t{\n+\t  error (\"non-top-level BIT_FIELD_REF, IMAGPART_EXPR or REALPART_EXPR\");\n+\t  return true;\n+\t}\n+\n       tree op = TREE_OPERAND (expr, 0);\n \n       if (TREE_CODE (expr) == ARRAY_REF\n@@ -3398,25 +3187,22 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n \t  return true;\n \t}\n \n-      if ((TREE_CODE (expr) == REALPART_EXPR\n-\t   || TREE_CODE (expr) == IMAGPART_EXPR)\n-\t  && !useless_type_conversion_p (TREE_TYPE (expr),\n-\t\t\t\t\t TREE_TYPE (TREE_TYPE (op))))\n-\t{\n-\t  error (\"type mismatch in real/imagpart reference\");\n-\t  debug_generic_stmt (TREE_TYPE (expr));\n-\t  debug_generic_stmt (TREE_TYPE (TREE_TYPE (op)));\n-\t  return true;\n-\t}\n-\n-      if (TREE_CODE (expr) == COMPONENT_REF\n-\t  && !useless_type_conversion_p (TREE_TYPE (expr),\n-\t\t\t\t\t TREE_TYPE (TREE_OPERAND (expr, 1))))\n+      if (TREE_CODE (expr) == COMPONENT_REF)\n \t{\n-\t  error (\"type mismatch in component reference\");\n-\t  debug_generic_stmt (TREE_TYPE (expr));\n-\t  debug_generic_stmt (TREE_TYPE (TREE_OPERAND (expr, 1)));\n-\t  return true;\n+\t  if (TREE_OPERAND (expr, 2)\n+\t      && !is_gimple_val (TREE_OPERAND (expr, 2)))\n+\t    {\n+\t      error (\"invalid COMPONENT_REF offset operator\");\n+\t      return true;\n+\t    }\n+\t  if (!useless_type_conversion_p (TREE_TYPE (expr),\n+\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (expr, 1))))\n+\t    {\n+\t      error (\"type mismatch in component reference\");\n+\t      debug_generic_stmt (TREE_TYPE (expr));\n+\t      debug_generic_stmt (TREE_TYPE (TREE_OPERAND (expr, 1)));\n+\t      return true;\n+\t    }\n \t}\n \n       if (TREE_CODE (expr) == VIEW_CONVERT_EXPR)\n@@ -3450,7 +3236,9 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n \n   if (TREE_CODE (expr) == MEM_REF)\n     {\n-      if (!is_gimple_mem_ref_addr (TREE_OPERAND (expr, 0)))\n+      if (!is_gimple_mem_ref_addr (TREE_OPERAND (expr, 0))\n+\t  || (TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR\n+\t      && verify_address (TREE_OPERAND (expr, 0), false)))\n \t{\n \t  error (\"invalid address operand in MEM_REF\");\n \t  debug_generic_stmt (expr);\n@@ -3467,7 +3255,9 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n   else if (TREE_CODE (expr) == TARGET_MEM_REF)\n     {\n       if (!TMR_BASE (expr)\n-\t  || !is_gimple_mem_ref_addr (TMR_BASE (expr)))\n+\t  || !is_gimple_mem_ref_addr (TMR_BASE (expr))\n+\t  || (TREE_CODE (TMR_BASE (expr)) == ADDR_EXPR\n+\t      && verify_address (TMR_BASE (expr), false)))\n \t{\n \t  error (\"invalid address operand in TARGET_MEM_REF\");\n \t  return true;\n@@ -3481,6 +3271,12 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n \t  return true;\n \t}\n     }\n+  else if (TREE_CODE (expr) == INDIRECT_REF)\n+    {\n+      error (\"INDIRECT_REF in gimple IL\");\n+      debug_generic_stmt (expr);\n+      return true;\n+    }\n \n   return ((require_lvalue || !is_gimple_min_invariant (expr))\n \t  && verify_types_in_gimple_min_lval (expr));\n@@ -4579,7 +4375,8 @@ verify_gimple_assign_single (gassign *stmt)\n \t    return true;\n \t  }\n \n-\treturn verify_types_in_gimple_reference (op, true);\n+\treturn (verify_address (rhs1, true)\n+\t\t|| verify_types_in_gimple_reference (op, true));\n       }\n \n     /* tcc_reference  */\n@@ -4719,8 +4516,19 @@ verify_gimple_assign_single (gassign *stmt)\n \t  return true;\n \t}\n       return res;\n-    case OBJ_TYPE_REF:\n+\n     case ASSERT_EXPR:\n+      /* FIXME.  */\n+      rhs1 = fold (ASSERT_EXPR_COND (rhs1));\n+      if (rhs1 == boolean_false_node)\n+\t{\n+\t  error (\"ASSERT_EXPR with an always-false condition\");\n+\t  debug_generic_stmt (rhs1);\n+\t  return true;\n+\t}\n+      break;\n+\n+    case OBJ_TYPE_REF:\n     case WITH_SIZE_EXPR:\n       /* FIXME.  */\n       return res;\n@@ -4845,7 +4653,9 @@ verify_gimple_switch (gswitch *stmt)\n     }\n \n   elt = gimple_switch_label (stmt, 0);\n-  if (CASE_LOW (elt) != NULL_TREE || CASE_HIGH (elt) != NULL_TREE)\n+  if (CASE_LOW (elt) != NULL_TREE\n+      || CASE_HIGH (elt) != NULL_TREE\n+      || CASE_CHAIN (elt) != NULL_TREE)\n     {\n       error (\"invalid default case label in switch statement\");\n       debug_generic_expr (elt);\n@@ -4857,6 +4667,12 @@ verify_gimple_switch (gswitch *stmt)\n     {\n       elt = gimple_switch_label (stmt, i);\n \n+      if (CASE_CHAIN (elt))\n+\t{\n+\t  error (\"invalid CASE_CHAIN\");\n+\t  debug_generic_expr (elt);\n+\t  return true;\n+\t}\n       if (! CASE_LOW (elt))\n \t{\n \t  error (\"invalid case label in switch statement\");\n@@ -5307,34 +5123,56 @@ static tree\n verify_expr_location_1 (tree *tp, int *walk_subtrees, void *data)\n {\n   hash_set<tree> *blocks = (hash_set<tree> *) data;\n+  tree t = *tp;\n \n-  if (VAR_P (*tp) && DECL_HAS_DEBUG_EXPR_P (*tp))\n+  /* ???  This doesn't really belong here but there's no good place to\n+     stick this remainder of old verify_expr.  */\n+  /* ???  This barfs on debug stmts which contain binds to vars with\n+     different function context.  */\n+#if 0\n+  if (VAR_P (t)\n+      || TREE_CODE (t) == PARM_DECL\n+      || TREE_CODE (t) == RESULT_DECL)\n+    {\n+      tree context = decl_function_context (t);\n+      if (context != cfun->decl\n+\t  && !SCOPE_FILE_SCOPE_P (context)\n+\t  && !TREE_STATIC (t)\n+\t  && !DECL_EXTERNAL (t))\n+\t{\n+\t  error (\"local declaration from a different function\");\n+\t  return t;\n+\t}\n+    }\n+#endif\n+\n+  if (VAR_P (t) && DECL_HAS_DEBUG_EXPR_P (t))\n     {\n-      tree t = DECL_DEBUG_EXPR (*tp);\n-      tree addr = walk_tree (&t, verify_expr_no_block, NULL, NULL);\n+      tree x = DECL_DEBUG_EXPR (t);\n+      tree addr = walk_tree (&x, verify_expr_no_block, NULL, NULL);\n       if (addr)\n \treturn addr;\n     }\n-  if ((VAR_P (*tp)\n-       || TREE_CODE (*tp) == PARM_DECL\n-       || TREE_CODE (*tp) == RESULT_DECL)\n-      && DECL_HAS_VALUE_EXPR_P (*tp))\n+  if ((VAR_P (t)\n+       || TREE_CODE (t) == PARM_DECL\n+       || TREE_CODE (t) == RESULT_DECL)\n+      && DECL_HAS_VALUE_EXPR_P (t))\n     {\n-      tree t = DECL_VALUE_EXPR (*tp);\n-      tree addr = walk_tree (&t, verify_expr_no_block, NULL, NULL);\n+      tree x = DECL_VALUE_EXPR (t);\n+      tree addr = walk_tree (&x, verify_expr_no_block, NULL, NULL);\n       if (addr)\n \treturn addr;\n     }\n \n-  if (!EXPR_P (*tp))\n+  if (!EXPR_P (t))\n     {\n       *walk_subtrees = false;\n       return NULL;\n     }\n \n-  location_t loc = EXPR_LOCATION (*tp);\n+  location_t loc = EXPR_LOCATION (t);\n   if (verify_location (blocks, loc))\n-    return *tp;\n+    return t;\n \n   return NULL;\n }\n@@ -5476,21 +5314,6 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t      err2 |= true;\n \t    }\n \n-\t  /* ???  Instead of not checking these stmts at all the walker\n-\t     should know its context via wi.  */\n-\t  if (!is_gimple_debug (stmt)\n-\t      && !is_gimple_omp (stmt))\n-\t    {\n-\t      memset (&wi, 0, sizeof (wi));\n-\t      addr = walk_gimple_op (stmt, verify_expr, &wi);\n-\t      if (addr)\n-\t\t{\n-\t\t  debug_generic_expr (addr);\n-\t\t  inform (gimple_location (stmt), \"in statement\");\n-\t\t  err2 |= true;\n-\t\t}\n-\t    }\n-\n \t  /* If the statement is marked as part of an EH region, then it is\n \t     expected that the statement could throw.  Verify that when we\n \t     have optimizations that simplify statements such that we prove"}]}