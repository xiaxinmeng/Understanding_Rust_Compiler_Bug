{"sha": "f1ba665bc7a42ad95d018ee8365801564328131f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFiYTY2NWJjN2E0MmFkOTVkMDE4ZWU4MzY1ODAxNTY0MzI4MTMxZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-06-28T19:43:01Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-06-28T19:43:01Z"}, "message": "builtins.c: Follow spelling conventions.\n\n\t* builtins.c: Follow spelling conventions.\n\t* cgraph.c: Likewise.\n\t* cpplex.c: Likewise.\n\t* config/arm/arm.c: Likewise.\n\t* config/arm/iwmmxt.md: Likewise.\n\t* config/c4x/c4x-modes.def: Likewise.\n\t* config/c4x/c4x.c: Likewise.\n\t* config/c4x/c4x.h: Likewise.\n\t* config/c4x/c4x.md: Likewise.\n\t* config/i386/i386-interix.h: Likewise.\n\t* config/mips/mips.h: Likewise.\n\nFrom-SVN: r68648", "tree": {"sha": "8826c209bf4a345f661a8cff151f91eaedca2ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8826c209bf4a345f661a8cff151f91eaedca2ba4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1ba665bc7a42ad95d018ee8365801564328131f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba665bc7a42ad95d018ee8365801564328131f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ba665bc7a42ad95d018ee8365801564328131f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba665bc7a42ad95d018ee8365801564328131f/comments", "author": null, "committer": null, "parents": [{"sha": "d55129782532b11e985294cb71265e2f2f78a3e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d55129782532b11e985294cb71265e2f2f78a3e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d55129782532b11e985294cb71265e2f2f78a3e8"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "764a4aa711c596721eda641330da749c086c5283", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -242,9 +242,9 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n    way, because it could contain a zero byte in the middle.\n    TREE_STRING_LENGTH is the size of the character array, not the string.\n \n-   ONLY_VALUE should be non-zero if the result is not going to be emitted\n+   ONLY_VALUE should be nonzero if the result is not going to be emitted\n    into the instruction stream and zero if it is going to be expanded.\n-   E.g. with i++ ? \"foo\" : \"bar\", if ONLY_VALUE is non-zero, constant 3\n+   E.g. with i++ ? \"foo\" : \"bar\", if ONLY_VALUE is nonzero, constant 3\n    is returned, otherwise NULL, since\n    len = c_strlen (src, 1); if (len) expand_expr (len, ...); would not\n    evaluate the side-effects."}, {"sha": "d8908afb40741460603d47ae1c5fca908761aa2d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -373,7 +373,7 @@ cgraph_varpool_hash_node (const PTR p)\n \t\t       (((struct cgraph_varpool_node *) p)->decl));\n }\n \n-/* Returns non-zero if P1 and P2 are equal.  */\n+/* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n eq_cgraph_varpool_node (const PTR p1, const PTR p2)"}, {"sha": "c02e7be901ac78e5970a2dd855a4b97cb7d868e5", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -2094,7 +2094,7 @@ arm_va_arg (tree valist, tree type)\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-      /* This is to stop the combine pass optimising\n+      /* This is to stop the combine pass optimizing\n \t away the alignment adjustment.  */\n       mark_reg_pointer (arg_pointer_rtx, PARM_BOUNDARY);\n     }"}, {"sha": "f9ef5211e2f52cd098ca5a4d8f03c619cc40b702", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -185,7 +185,7 @@\n    (set_attr \"neg_pool_range\" \"*,     *, 244,*,*, 244\")])\n \n ;; This pattern should not be needed.  It is to match a\n-;; wierd case generated by GCC when no optimisations are\n+;; wierd case generated by GCC when no optimizations are\n ;; enabled.  (Try compiling gcc/testsuite/gcc.c-torture/\n ;; compile/simd-5.c at -O0).  The mode for operands[1] is\n ;; deliberately omitted."}, {"sha": "be536e0564563b675c2507d3f5c6dde9e651f95e", "filename": "gcc/config/c4x/c4x-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -25,7 +25,7 @@\n \n    On the C4x, we have a \"no-overflow\" mode which is used when an ADD,\n    SUB, NEG, or MPY insn is used to set the condition code.  This is\n-   to prevent the combiner from optimising away a following CMP of the\n+   to prevent the combiner from optimizing away a following CMP of the\n    result with zero when a signed conditional branch or load insn\n    follows.\n "}, {"sha": "bc677832f936eeb71c3f75425cd1eb7a7afe1ace", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -1692,7 +1692,7 @@ c4x_legitimize_address (orig, mode)\n \n /* Provide the costs of an addressing mode that contains ADDR.\n    If ADDR is not a valid address, its cost is irrelevant.  \n-   This is used in cse and loop optimisation to determine\n+   This is used in cse and loop optimization to determine\n    if it is worthwhile storing a common address into a register. \n    Unfortunately, the C4x address cost depends on other operands.  */\n \n@@ -2437,7 +2437,7 @@ c4x_rptb_insert (insn)\n \n /* We need to use direct addressing for large constants and addresses\n    that cannot fit within an instruction.  We must check for these\n-   after after the final jump optimisation pass, since this may\n+   after after the final jump optimization pass, since this may\n    introduce a local_move insn for a SYMBOL_REF.  This pass\n    must come before delayed branch slot filling since it can generate\n    additional instructions.\n@@ -3642,7 +3642,7 @@ c4x_address_conflict (op0, op1, store0, store1)\n \t cause problems except when writing to a hardware device such\n \t as a FIFO since the second write will be lost.  The user\n \t should flag the hardware location as being volatile so that\n-\t we don't do this optimisation.  While it is unlikely that we\n+\t we don't do this optimization.  While it is unlikely that we\n \t have an aliased address if both locations are not marked\n \t volatile, it is probably safer to flag a potential conflict\n \t if either location is volatile.  */\n@@ -4034,7 +4034,7 @@ legitimize_operands (code, operands, mode)\n       /* During RTL generation, force constants into pseudos so that\n \t they can get hoisted out of loops.  This will tie up an extra\n \t register but can save an extra cycle.  Only do this if loop\n-\t optimisation enabled.  (We cannot pull this trick for add and\n+\t optimization enabled.  (We cannot pull this trick for add and\n \t sub instructions since the flow pass won't find\n \t autoincrements etc.)  This allows us to generate compare\n \t instructions like CMPI R0, *AR0++ where R0 = 42, say, instead"}, {"sha": "3fa2d91ef6e64e57b5f8de0b09116a8ba547de68", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -775,7 +775,7 @@ enum reg_class\n    is defined since the MPY|ADD insns require the classes R0R1_REGS and\n    R2R3_REGS which are used by the function return registers (R0,R1) and\n    the register arguments (R2,R3), respectively.  I'm reluctant to define\n-   this macro since it stomps on many potential optimisations.  Ideally\n+   this macro since it stomps on many potential optimizations.  Ideally\n    it should have a register class argument so that not all the register\n    classes gets penalised for the sake of a naughty few...  For long\n    double arithmetic we need two additional registers that we can use as"}, {"sha": "0957fe9ef7062c7c0c139edacd05c290677efa83", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -3127,9 +3127,9 @@\n ; Unfortunately the C40 doesn't allow cmpi3 7, *ar0++ so the next best\n ; thing would be to get the small constant loaded into a register (say r0)\n ; so that it could be hoisted out of the loop so that we only\n-; would need to do cmpi3 *ar0++, r0.  Now the loop optimisation pass\n+; would need to do cmpi3 *ar0++, r0.  Now the loop optimization pass\n ; comes before the flow pass (which finds autoincrements) so we're stuck.\n-; Ideally, GCC requires another loop optimisation pass (preferably after\n+; Ideally, GCC requires another loop optimization pass (preferably after\n ; reload) so that it can hoist invariants out of loops.\n ; The current solution modifies legitimize_operands () so that small\n ; constants are forced into a pseudo register."}, {"sha": "4d5e202c16aba9fb6203cd2943e801917785a3cb", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -236,7 +236,7 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_NOP_FUN_DLLIMPORT 1\n #define drectve_section()  /* nothing */\n \n-/* Objective C has its own packing rules...\n+/* Objective-C has its own packing rules...\n    Objc tries to parallel the code in stor-layout.c at runtime\t\n    (see libobjc/encoding.c).  This (compile-time) packing info isn't \n    available at runtime, so it's hopeless to try."}, {"sha": "6325d9534a98e9ce3d34d87678b034b28262dfcc", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -3166,7 +3166,7 @@ typedef struct mips_args {\n \n \f\n /* The cost of loading values from the constant pool.  It should be\n-   larger than the cost of any constant we want to synthesise in-line.  */\n+   larger than the cost of any constant we want to synthesize in-line.  */\n \n #define CONSTANT_POOL_COST COSTS_N_INSNS (8)\n "}, {"sha": "c536c768813dc74991ca19b5231337c4965e6e88", "filename": "gcc/cpplex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba665bc7a42ad95d018ee8365801564328131f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f1ba665bc7a42ad95d018ee8365801564328131f", "patch": "@@ -746,7 +746,7 @@ _cpp_get_fresh_line (cpp_reader *pfile)\n    get diagnostics pointing to the correct location.\n \n    Does not handle issues such as token lookahead, multiple-include\n-   optimisation, directives, skipping etc.  This function is only\n+   optimization, directives, skipping etc.  This function is only\n    suitable for use by _cpp_lex_token, and in special cases like\n    lex_expansion_token which doesn't care for any of these issues.\n "}]}