{"sha": "180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgwZWNkNmFhMmZkZTAxZjE2MTY4YmZhNmFkMTc0NTJiYmYyYTMwNg==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2005-02-18T07:50:08Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2005-02-18T07:50:08Z"}, "message": "functional (hash): New function object.\n\n        * include/tr1/functional (hash): New function object.\n        * include/tr1/hashtable: New file.\n        * include/tr1/unordered_set: New file.\n        * include/tr1/unordered_map: New file.\n        * include/Makefile.am: Add three new TR1 headers.\n        * include/Makefile.in: Likewise.\n        * testsuite/tr1/6_containers/unordered/insert/array_syntax.cc: New test.\n        * testsuite/tr1/6_containers/unordered/insert/map_single.cc: New test.\n        * testsuite/tr1/6_containers/unordered/insert/multimap_single.cc: New test.\n        * testsuite/tr1/6_containers/unordered/insert/multiset_single.cc: New test.\n        * testsuite/tr1/6_containers/unordered/insert/set_single.cc: New test.\n        * testsuite/tr1/6_containers/unordered/instantiate/hash.cc: New test.\n        * testsuite/tr1/6_containers/unordered/instantiate/map.cc: New test.\n        * testsuite/tr1/6_containers/unordered/instantiate/multimap.cc: New test.\n        * testsuite/tr1/6_containers/unordered/instantiate/multiset.cc: New test.\n        * testsuite/tr1/6_containers/unordered/instantiate/set.cc: New test.\n\nFrom-SVN: r95219", "tree": {"sha": "46325abc6a748e042ddb37cf45e36d95dec74ff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46325abc6a748e042ddb37cf45e36d95dec74ff7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/comments", "author": null, "committer": null, "parents": [{"sha": "82214ae9ccf71a869b4b22a171de7815dbbaa03e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82214ae9ccf71a869b4b22a171de7815dbbaa03e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82214ae9ccf71a869b4b22a171de7815dbbaa03e"}], "stats": {"total": 2374, "additions": 2369, "deletions": 5}, "files": [{"sha": "0ddd1a52fa6ae4a3e666a93544177004c35b5348", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -1,3 +1,22 @@\n+2005-02-17  Matt Austern  <austern@apple.com>\n+\n+\t* include/tr1/functional (hash): New function object.\n+\t* include/tr1/hashtable: New file.\n+\t* include/tr1/unordered_set: New file.\n+\t* include/tr1/unordered_map: New file.\n+\t* include/Makefile.am: Add three new TR1 headers.\n+\t* include/Makefile.in: Likewise.\n+\t* testsuite/tr1/6_containers/unordered/insert/array_syntax.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/insert/map_single.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/insert/multimap_single.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/insert/multiset_single.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/insert/set_single.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/instantiate/hash.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/instantiate/map.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/instantiate/multimap.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/instantiate/multiset.cc: New test.\n+\t* testsuite/tr1/6_containers/unordered/instantiate/set.cc: New test.\n+\t\n 2005-02-16  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/23_containers/set/modifiers/16728.cc:"}, {"sha": "d7d61b9157fd6307da7f781360561901c0dc1be4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -232,7 +232,10 @@ tr1_headers = \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/type_traits \\\n-\t${tr1_srcdir}/type_traits_fwd.h\n+\t${tr1_srcdir}/type_traits_fwd.h \\\n+\t${tr1_srcdir}/hashtable \\\n+\t${tr1_srcdir}/unordered_set \\\n+\t${tr1_srcdir}/unordered_map\n \n \n # This is the common subset of files that all three \"C\" header models use."}, {"sha": "e73c81ddc47b0eec568498271a2d6511285aac3a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -448,8 +448,10 @@ tr1_headers = \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/type_traits \\\n-\t${tr1_srcdir}/type_traits_fwd.h\n-\n+\t${tr1_srcdir}/type_traits_fwd.h \\\n+\t${tr1_srcdir}/hashtable \\\n+\t${tr1_srcdir}/unordered_set \\\n+\t${tr1_srcdir}/unordered_map\n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)"}, {"sha": "d53c99a9a5d548f63f1562534c0e9b2e9bf39304", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -1,6 +1,6 @@\n // TR1 functional header -*- C++ -*-\n \n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -26,6 +26,7 @@\n #define _TR1_FUNCTIONAL 1\n \n #include \"../functional\"\n+#include <string>\t\t// for std::tr1::hash\n \n namespace std\n {\n@@ -78,8 +79,75 @@ namespace tr1\n   template<typename _Tp>\n     reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t)\n     { return cref(__t.get()); }\n+\n+\n+// Definition of default hash function std::tr1::hash<>.  The types for\n+// which std::tr1::hash<T> is defined is in clause 6.3.3. of the PDTR.\n+\n+  template <typename T> struct hash;\n+\n+  #define tr1_hashtable_define_trivial_hash(T) \t\t\t\t    \\\n+    template <> struct hash<T> {\t\t\t\t\t\t    \\\n+      std::size_t operator()(T val) { return static_cast<std::size_t>(val); } \\\n+    }\t\t\t\t\t\t\t\t\t    \\\n+\n+  tr1_hashtable_define_trivial_hash(bool);\n+  tr1_hashtable_define_trivial_hash(char);\n+  tr1_hashtable_define_trivial_hash(signed char);\n+  tr1_hashtable_define_trivial_hash(unsigned char);\n+  tr1_hashtable_define_trivial_hash(wchar_t);\n+  tr1_hashtable_define_trivial_hash(short);\n+  tr1_hashtable_define_trivial_hash(int);\n+  tr1_hashtable_define_trivial_hash(long);\n+  tr1_hashtable_define_trivial_hash(unsigned short);\n+  tr1_hashtable_define_trivial_hash(unsigned int);\n+  tr1_hashtable_define_trivial_hash(unsigned long);\n+\n+  tr1_hashtable_define_trivial_hash(float);\n+  tr1_hashtable_define_trivial_hash(double);\n+  tr1_hashtable_define_trivial_hash(long double);\n+\n+  #undef tr1_hashtable_define_trivial_hash\n+\n+  template <typename T>\n+    struct hash<T*> {\n+      std::size_t operator()(T* p) const {\n+\treturn reinterpret_cast<std::size_t>(p);\n+      }\n+    };\n+\n+  // ??? We can probably find a better hash function than this (i.e. one\n+  // that vectorizes better and that produces a more uniform distribution).\n+\n+  // XXX String hash probably shouldn't be an inline member function,\n+  // since it's nontrivial.  Once we have the framework for TR1 .cc\n+  // files, this should go in one.\n+\n+  template <>\n+    struct hash<std::string>\n+    {\n+      std::size_t operator()(const std::string& s) const\n+      {\n+\tstd::size_t result = 0;\n+\tfor (std::string::const_iterator i = s.begin(); i != s.end(); ++i)\n+\t  result = (result * 131) + *i;\n+\treturn result;\n+      }\n+    };\n+\n+  template <>\n+    struct hash<std::wstring>\n+    {\n+      std::size_t operator()(const std::wstring& s) const\n+      {\n+\tstd::size_t result = 0;\n+\tfor (std::wstring::const_iterator i = s.begin(); i != s.end(); ++i)\n+\t  result = (result * 131) + *i;\n+\treturn result;\n+      }\n+    };\n+\n }\n }\n \n #endif\n-"}, {"sha": "fb53f70d269376db283767363fae1cf59fb38a7b", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "added", "additions": 1422, "deletions": 0, "changes": 1422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,1422 @@\n+// Internal header for TR1 unordered_set and unordered_map -*- C++ -*-\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+/** @file \n+ *  This is a TR1 C++ Library header. \n+ */\n+\n+// This header file defines std::tr1::hashtable, which is used to\n+// implement std::tr1::unordered_set, std::tr1::unordered_map, \n+// std::tr1::unordered_multiset, and std::tr1::unordered_multimap.\n+// hashtable has many template parameters, partly to accommodate\n+// the differences between those four classes and partly to \n+// accommodate policy choices that go beyond what TR1 calls for.\n+\n+// ??? Arguably this should be Internal::hashtable, not std::tr1::hashtable.\n+\n+// Class template hashtable attempts to encapsulate all reasonable\n+// variation among hash tables that use chaining.  It does not handle\n+// open addressing.\n+\n+// References: \n+// M. Austern, \"A Proposal to Add Hash Tables to the Standard\n+//    Library (revision 4),\" WG21 Document N1456=03-0039, 2003.\n+// D. E. Knuth, The Art of Computer Programming, v. 3, Sorting and Searching.\n+// A. Tavori and V. Dreizin, \"Generic Associative Containers\", 2004.\n+//    ??? Full citation?\n+\n+#ifndef GNU_LIBSTDCXX_TR1_HASHTABLE_\n+#define GNU_LIBSTDCXX_TR1_HASHTABLE_\n+\n+#include <utility>\t\t// For std::pair\n+#include <iterator>\n+#include <cstddef>\n+#include <cstdlib>\n+#include <cmath>\n+#include <tr1/type_traits>\t// For true_type and false_type\n+\n+//----------------------------------------------------------------------\n+// General utilities\n+\n+namespace Internal {\n+template <bool Flag, typename IfTrue, typename IfFalse> struct IF;\n+\n+template <typename IfTrue, typename IfFalse>\n+struct IF <true, IfTrue, IfFalse> { typedef IfTrue type; };\n+ \n+template <typename IfTrue, typename IfFalse>\n+struct IF <false, IfTrue, IfFalse> { typedef IfFalse type; };\n+\n+// Helper function: return distance(first, last) for forward\n+// iterators, or 0 for input iterators.\n+\n+template <class Iterator>\n+inline typename std::iterator_traits<Iterator>::difference_type\n+distance_fw (Iterator first, Iterator last, std::input_iterator_tag)\n+{\n+  return 0;\n+}\n+\n+template <class Iterator>\n+inline typename std::iterator_traits<Iterator>::difference_type\n+distance_fw (Iterator first, Iterator last, std::forward_iterator_tag)\n+{\n+  return std::distance(first, last);\n+}\n+\n+template <class Iterator>\n+inline typename std::iterator_traits<Iterator>::difference_type\n+distance_fw (Iterator first, Iterator last)\n+{\n+  typedef typename std::iterator_traits<Iterator>::iterator_category tag;\n+  return distance_fw(first, last, tag());\n+}\n+\n+} // namespace Internal\n+\n+//----------------------------------------------------------------------\n+// Auxiliary types used for all instantiations of hashtable: nodes\n+// and iterators.\n+\n+// Nodes, used to wrap elements stored in the hash table.  A policy\n+// template parameter of class template hashtable controls whether\n+// nodes also store a hash code. In some cases (e.g. strings) this may\n+// be a performance win.\n+\n+namespace Internal {\n+\n+template <typename Value, bool cache_hash_code> struct hash_node;\n+\n+template <typename Value>\n+struct hash_node<Value, true> {\n+  Value m_v;\n+  std::size_t hash_code;\n+  hash_node* m_next;\n+};\n+\n+template <typename Value>\n+struct hash_node<Value, false> {\n+  Value m_v;\n+  hash_node* m_next;\n+};\n+\n+// Local iterators, used to iterate within a bucket but not between\n+// buckets.\n+\n+template <typename Value, bool cache>\n+struct node_iterator_base {\n+  node_iterator_base(hash_node<Value, cache>* p) : m_cur(p) { }\n+  void incr() { m_cur = m_cur->m_next; }\n+\n+  hash_node<Value, cache>* m_cur;\n+};\n+\n+template <typename Value, bool cache>\n+inline bool operator== (const node_iterator_base<Value, cache>& x,\n+\t\t\tconst node_iterator_base<Value, cache>& y)\n+{\n+  return x.m_cur == y.m_cur;\n+}\n+\n+template <typename Value, bool cache>\n+inline bool operator!= (const node_iterator_base<Value, cache>& x,\n+\t\t\tconst node_iterator_base<Value, cache>& y)\n+{\n+  return x.m_cur != y.m_cur;\n+}\n+\n+template <typename Value, bool is_const, bool cache>\n+struct node_iterator : public node_iterator_base<Value, cache> {\n+  typedef Value                                             value_type;\n+  typedef typename IF<is_const, const Value*, Value*>::type pointer;\n+  typedef typename IF<is_const, const Value&, Value&>::type reference;\n+  typedef std::ptrdiff_t                                    difference_type;\n+  typedef std::forward_iterator_tag                         iterator_category;\n+\n+  explicit node_iterator (hash_node<Value, cache>* p = 0)\n+    : node_iterator_base<Value, cache>(p) { }\n+  node_iterator (const node_iterator<Value, true, cache>& x)\n+    : node_iterator_base<Value, cache>(x.m_cur) { }\n+\n+  reference operator*() const { return this->m_cur->m_v; }\n+  pointer operator->() const { return &this->m_cur->m_v; }\n+\n+  node_iterator& operator++() { this->incr(); return *this; }\n+  node_iterator operator++(int)\n+  { node_iterator tmp(*this); this->incr(); return tmp; }\n+};\n+\n+template <typename Value, bool cache>\n+struct hashtable_iterator_base {\n+  hashtable_iterator_base(hash_node<Value, cache>* node,\n+\t\t\t  hash_node<Value, cache>** bucket)\n+    : m_cur_node (node), m_cur_bucket (bucket)\n+  { }\n+\n+  void incr() {\n+    m_cur_node = m_cur_node->m_next;\n+    if (!m_cur_node)\n+      m_incr_bucket();\n+  }\n+\n+  void m_incr_bucket();\n+\n+  hash_node<Value, cache>* m_cur_node;\n+  hash_node<Value, cache>** m_cur_bucket;\n+};\n+\n+\n+// Global iterators, used for arbitrary iteration within a hash\n+// table.  Larger and more expensive than local iterators.\n+\n+template <typename Value, bool cache>\n+void hashtable_iterator_base<Value, cache>::m_incr_bucket()\n+{\n+  ++m_cur_bucket;\n+\n+  // This loop requires the bucket array to have a non-null sentinel\n+  while (!*m_cur_bucket)\n+    ++m_cur_bucket;\n+  m_cur_node = *m_cur_bucket;\n+}\n+\n+template <typename Value, bool cache>\n+inline bool operator== (const hashtable_iterator_base<Value, cache>& x,\n+\t\t\tconst hashtable_iterator_base<Value, cache>& y)\n+{\n+  return x.m_cur_node == y.m_cur_node;\n+}\n+\n+template <typename Value, bool cache>\n+inline bool operator!= (const hashtable_iterator_base<Value, cache>& x,\n+\t\t\tconst hashtable_iterator_base<Value, cache>& y)\n+{\n+  return x.m_cur_node != y.m_cur_node;\n+}\n+\n+template <typename Value, bool is_const, bool cache>\n+struct hashtable_iterator : public hashtable_iterator_base<Value, cache>\n+{\n+  typedef Value                                             value_type;\n+  typedef typename IF<is_const, const Value*, Value*>::type pointer;\n+  typedef typename IF<is_const, const Value&, Value&>::type reference;\n+  typedef std::ptrdiff_t                                    difference_type;\n+  typedef std::forward_iterator_tag                         iterator_category;\n+\n+  hashtable_iterator (hash_node<Value, cache>* p, hash_node<Value, cache>** b)\n+    : hashtable_iterator_base<Value, cache>(p, b) { }\n+  hashtable_iterator (hash_node<Value, cache>** b)\n+    : hashtable_iterator_base<Value, cache>(*b, b) { }\n+  hashtable_iterator (const hashtable_iterator<Value, true, cache>& x)\n+    : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n+\n+  reference operator*() const { return this->m_cur_node->m_v; }\n+  pointer operator->() const { return &this->m_cur_node->m_v; }\n+\n+  hashtable_iterator& operator++() { this->incr(); return *this; }\n+  hashtable_iterator operator++(int)\n+  { hashtable_iterator tmp(*this); this->incr(); return tmp; }\n+};\n+\n+} // namespace Internal\n+\n+// ----------------------------------------------------------------------\n+// Many of class template hashtable's template parameters are policy\n+// classes.  These are defaults for the policies.\n+\n+namespace Internal {\n+\n+// The two key extraction policies used by the *set and *map variants.\n+template <typename T>\n+struct identity {\n+  T operator()(const T& t) const { return t; }\n+};\n+\n+template <typename Pair>\n+struct extract1st {\n+  typename Pair::first_type operator()(const Pair& p) { return p.first; }\n+};\n+\n+// Default range hashing function: use division to fold a large number\n+// into the range [0, N).\n+struct mod_range_hashing\n+{\n+  typedef std::size_t first_argument_type;\n+  typedef std::size_t second_argument_type;\n+  typedef std::size_t result_type;\n+\n+  result_type operator() (first_argument_type r, second_argument_type N) const\n+    { return r % N; }\n+};\n+\n+// Default ranged hash function H.  In principle it should be a\n+// function object composed from objects of type H1 and H2 such that\n+// h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n+// h1 and h2.  So instead we'll just use a tag to tell class template\n+// hashtable to do that composition.\n+struct default_ranged_hash { };\n+\n+// Default value for rehash policy.  Bucket size is (usually) the\n+// smallest prime that keeps the load factor small enough.\n+\n+struct prime_rehash_policy\n+{\n+  prime_rehash_policy (float z = 1.0);\n+\n+  float max_load_factor() const;\n+\n+  // Return a bucket size no smaller than n.\n+  std::size_t next_bkt (std::size_t n) const;\n+\n+  // Return a bucket count appropriate for n elements\n+  std::size_t bkt_for_elements (std::size_t n) const;\n+\n+  // n_bkt is current bucket count, n_elt is current element count,\n+  // and n_ins is number of elements to be inserted.  Do we need to\n+  // increase bucket count?  If so, return make_pair(true, n), where n\n+  // is the new bucket count.  If not, return make_pair(false, 0).\n+  std::pair<bool, std::size_t>\n+  need_rehash (std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const;\n+\n+  float m_max_load_factor;\n+  float m_growth_factor;\n+  mutable std::size_t m_next_resize;\n+};\n+\n+// XXX This is a hack.  prime_rehash_policy's member functions, and\n+// certainly the list of primes, should be defined in a .cc file.\n+// We're temporarily putting them in a header because we don't have a\n+// place to put TR1 .cc files yet.  There's no good reason for any of\n+// prime_rehash_policy's member functions to be inline, and there's\n+// certainly no good reason for X<> to exist at all.\n+\n+struct lt {\n+  template <typename X, typename Y> bool operator()(X x, Y y) { return x < y; }\n+};\n+\n+template <int dummy>\n+struct X {\n+  static const int n_primes = 256;\n+  static const unsigned long primes[n_primes + 1];\n+};\n+\n+template <int dummy>\n+const int X<dummy>::n_primes;\n+\n+template <int dummy>\n+const unsigned long X<dummy>::primes[n_primes + 1] =\n+  {\n+    2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,\n+    37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,\n+    83ul, 89ul, 97ul, 103ul, 109ul, 113ul, 127ul, 137ul, 139ul, 149ul,\n+    157ul, 167ul, 179ul, 193ul, 199ul, 211ul, 227ul, 241ul, 257ul,\n+    277ul, 293ul, 313ul, 337ul, 359ul, 383ul, 409ul, 439ul, 467ul,\n+    503ul, 541ul, 577ul, 619ul, 661ul, 709ul, 761ul, 823ul, 887ul,\n+    953ul, 1031ul, 1109ul, 1193ul, 1289ul, 1381ul, 1493ul, 1613ul,\n+    1741ul, 1879ul, 2029ul, 2179ul, 2357ul, 2549ul, 2753ul, 2971ul,\n+    3209ul, 3469ul, 3739ul, 4027ul, 4349ul, 4703ul, 5087ul, 5503ul,\n+    5953ul, 6427ul, 6949ul, 7517ul, 8123ul, 8783ul, 9497ul, 10273ul,\n+    11113ul, 12011ul, 12983ul, 14033ul, 15173ul, 16411ul, 17749ul,\n+    19183ul, 20753ul, 22447ul, 24281ul, 26267ul, 28411ul, 30727ul,\n+    33223ul, 35933ul, 38873ul, 42043ul, 45481ul, 49201ul, 53201ul,\n+    57557ul, 62233ul, 67307ul, 72817ul, 78779ul, 85229ul, 92203ul,\n+    99733ul, 107897ul, 116731ul, 126271ul, 136607ul, 147793ul,\n+    159871ul, 172933ul, 187091ul, 202409ul, 218971ul, 236897ul,\n+    256279ul, 277261ul, 299951ul, 324503ul, 351061ul, 379787ul,\n+    410857ul, 444487ul, 480881ul, 520241ul, 562841ul, 608903ul,\n+    658753ul, 712697ul, 771049ul, 834181ul, 902483ul, 976369ul,\n+    1056323ul, 1142821ul, 1236397ul, 1337629ul, 1447153ul, 1565659ul,\n+    1693859ul, 1832561ul, 1982627ul, 2144977ul, 2320627ul, 2510653ul,\n+    2716249ul, 2938679ul, 3179303ul, 3439651ul, 3721303ul, 4026031ul,\n+    4355707ul, 4712381ul, 5098259ul, 5515729ul, 5967347ul, 6456007ul,\n+    6984629ul, 7556579ul, 8175383ul, 8844859ul, 9569143ul, 10352717ul,\n+    11200489ul, 12117689ul, 13109983ul, 14183539ul, 15345007ul,\n+    16601593ul, 17961079ul, 19431899ul, 21023161ul, 22744717ul,\n+    24607243ul, 26622317ul, 28802401ul, 31160981ul, 33712729ul,\n+    36473443ul, 39460231ul, 42691603ul, 46187573ul, 49969847ul,\n+    54061849ul, 58488943ul, 63278561ul, 68460391ul, 74066549ul,\n+    80131819ul, 86693767ul, 93793069ul, 101473717ul, 109783337ul,\n+    118773397ul, 128499677ul, 139022417ul, 150406843ul, 162723577ul,\n+    176048909ul, 190465427ul, 206062531ul, 222936881ul, 241193053ul,\n+    260944219ul, 282312799ul, 305431229ul, 330442829ul, 357502601ul,\n+    386778277ul, 418451333ul, 452718089ul, 489790921ul, 529899637ul,\n+    573292817ul, 620239453ul, 671030513ul, 725980837ul, 785430967ul,\n+    849749479ul, 919334987ul, 994618837ul, 1076067617ul, 1164186217ul,\n+    1259520799ul, 1362662261ul, 1474249943ul, 1594975441ul,\n+    1725587117ul, 1866894511ul, 2019773507ul, 2185171673ul,\n+    2364114217ul, 2557710269ul, 2767159799ul, 2993761039ul,\n+    3238918481ul, 3504151727ul, 3791104843ul, 4101556399ul,\n+    4294967291ul,\n+    4294967291ul // sentinel so we don't have to test result of lower_bound\n+  };\n+\n+inline prime_rehash_policy::prime_rehash_policy (float z)\n+  : m_max_load_factor(z),\n+    m_growth_factor (2.f),\n+    m_next_resize (0)\n+{ }\n+\n+inline float prime_rehash_policy::max_load_factor() const\n+{\n+  return m_max_load_factor;\n+}\n+\n+// Return a prime no smaller than n.\n+inline std::size_t prime_rehash_policy::next_bkt (std::size_t n) const\n+{\n+  const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n+  const unsigned long* p = std::lower_bound (X<0>::primes, last, n);\n+  m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+  return *p;\n+}\n+\n+// Return the smallest prime p such that alpha p >= n, where alpha\n+// is the load factor.\n+inline std::size_t prime_rehash_policy::bkt_for_elements (std::size_t n) const\n+{\n+  const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n+  const float min_bkts = n / m_max_load_factor;\n+  const unsigned long* p = std::lower_bound (X<0>::primes, last, min_bkts, lt());\n+  m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+  return *p;\n+}\n+\n+// Finds the smallest prime p such that alpha p > n_elt + n_ins.\n+// If p > n_bkt, return make_pair(true, p); otherwise return\n+// make_pair(false, 0).  In principle this isn't very different from \n+// bkt_for_elements.\n+\n+// The only tricky part is that we're caching the element count at\n+// which we need to rehash, so we don't have to do a floating-point\n+// multiply for every insertion.\n+\n+inline std::pair<bool, std::size_t>\n+prime_rehash_policy\n+::need_rehash (std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const\n+{\n+  if (n_elt + n_ins > m_next_resize) {\n+    float min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;\n+    if (min_bkts > n_bkt) {\n+      min_bkts = std::max (min_bkts, m_growth_factor * n_bkt);\n+      const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n+      const unsigned long* p = std::lower_bound (X<0>::primes, last, min_bkts, lt());\n+      m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n+      return std::make_pair(true, *p);\n+    }\n+    else {\n+      m_next_resize = static_cast<std::size_t>(std::ceil(n_bkt * m_max_load_factor));\n+      return std::make_pair(false, 0);\n+    }\n+  }\n+  else\n+    return std::make_pair(false, 0);\n+}\n+\n+} // namespace Internal\n+\n+//----------------------------------------------------------------------\n+// Base classes for std::tr1::hashtable.  We define these base classes\n+// because in some cases we want to do different things depending on\n+// the value of a policy class.  In some cases the policy class affects\n+// which member functions and nested typedefs are defined; we handle that\n+// by specializing base class templates.  Several of the base class templates\n+// need to access other members of class template hashtable, so we use\n+// the \"curiously recurring template pattern\" for them.\n+\n+namespace Internal {\n+\n+// class template map_base.  If the hashtable has a value type of the\n+// form pair<T1, T2> and a key extraction policy that returns the\n+// first part of the pair, the hashtable gets a mapped_type typedef.\n+// If it satisfies those criteria and also has unique keys, then it\n+// also gets an operator[].\n+\n+template <typename K, typename V, typename Ex, bool unique, typename Hashtable>\n+struct map_base { };\n+\t  \n+template <typename K, typename Pair, typename Hashtable>\n+struct map_base<K, Pair, extract1st<Pair>, false, Hashtable>\n+{\n+  typedef typename Pair::second_type mapped_type;\n+};\n+\n+template <typename K, typename Pair, typename Hashtable>\n+struct map_base<K, Pair, extract1st<Pair>, true, Hashtable>\n+{\n+  typedef typename Pair::second_type mapped_type;\n+  mapped_type& operator[](const K& k) {\n+    Hashtable* h = static_cast<Hashtable*>(this);\n+    typename Hashtable::iterator it = h->insert(std::make_pair(k, mapped_type())).first;\n+    return it->second;\n+  }\n+};\n+\n+// class template rehash_base.  Give hashtable the max_load_factor\n+// functions iff the rehash policy is prime_rehash_policy.\n+template <typename RehashPolicy, typename Hashtable>\n+struct rehash_base { };\n+\n+template <typename Hashtable>\n+struct rehash_base<prime_rehash_policy, Hashtable>\n+{\n+  float max_load_factor() const {\n+    const Hashtable* This = static_cast<const Hashtable*>(this);\n+    return This->rehash_policy()->max_load_factor();\n+  }\n+\n+  void max_load_factor(float z) {\n+    Hashtable* This = static_cast<Hashtable*>(this);\n+    This->rehash_policy(prime_rehash_policy(z));    \n+  }\n+};\n+\n+// Class template hash_code_base.  Encapsulates two policy issues that\n+// aren't quite orthogonal.\n+//   (1) the difference between using a ranged hash function and using\n+//       the combination of a hash function and a range-hashing function.\n+//       In the former case we don't have such things as hash codes, so\n+//       we have a dummy type as placeholder.\n+//   (2) Whether or not we cache hash codes.  Caching hash codes is\n+//       meaningless if we have a ranged hash function.\n+// We also put the key extraction and equality comparison function \n+// objects here, for convenience.\n+\n+// Primary template: unused except as a hook for specializations.\n+\n+template <typename Key, typename Value,\n+\t  typename ExtractKey, typename Equal,\n+\t  typename H1, typename H2, typename H,\n+\t  bool cache_hash_code>\n+struct hash_code_base;\n+\n+// Specialization: ranged hash function, no caching hash codes.  H1\n+// and H2 are provided but ignored.  We define a dummy hash code type.\n+template <typename Key, typename Value,\n+\t  typename ExtractKey, typename Equal,\n+\t  typename H1, typename H2, typename H>\n+struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, H, false>\n+{\n+protected:\n+  hash_code_base (const ExtractKey& ex, const Equal& eq,\n+\t\t    const H1&, const H2&, const H& h)\n+    : m_extract(ex), m_eq(eq), m_ranged_hash(h) { }\n+\n+  typedef void* hash_code_t;\n+  hash_code_t m_hash_code (const Key& k) { return 0; }\n+  std::size_t bucket_index (const Key& k, hash_code_t, std::size_t N) const\n+    { return m_ranged_hash (k, N); }\n+  std::size_t bucket_index (const hash_node<Value, false>* p, std::size_t N) {\n+    return m_ranged_hash (m_extract (p->m_v), N); \n+  }\n+  \n+  bool compare (const Key& k, hash_code_t, hash_node<Value, false>* n)\n+    { return m_eq (k, m_extract(n->m_v)); }\n+\n+  void copy_code (hash_node<Value, false>*, const hash_node<Value, false>*) { }\n+\n+  void m_swap(hash_code_base& x) {\n+    m_extract.m_swap(x);\n+    m_eq.m_swap(x);\n+    m_ranged_hash.m_swap(x);\n+  }\n+\n+protected:\n+  ExtractKey m_extract;\n+  Equal m_eq;\n+  H m_ranged_hash;\n+};\n+\n+\n+// No specialization for ranged hash function while caching hash codes.\n+// That combination is meaningless, and trying to do it is an error.\n+\n+\n+// Specialization: ranged hash function, cache hash codes.  This\n+// combination is meaningless, so we provide only a declaration\n+// and no definition.\n+\n+template <typename Key, typename Value,\n+\t  typename ExtractKey, typename Equal,\n+\t  typename H1, typename H2, typename H>\n+struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, H, true>;\n+\n+\n+// Specialization: hash function and range-hashing function, no\n+// caching of hash codes.  H is provided but ignored.  Provides\n+// typedef and accessor required by TR1.\n+\n+template <typename Key, typename Value,\n+\t  typename ExtractKey, typename Equal,\n+\t  typename H1, typename H2>\n+struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, default_ranged_hash, false>\n+{\n+  typedef H1 hasher;\n+  hasher hash_function() const { return m_h1; }\n+\n+protected:\n+  hash_code_base (const ExtractKey& ex, const Equal& eq,\n+\t\t  const H1& h1, const H2& h2, const default_ranged_hash&)\n+    : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+\n+  typedef std::size_t hash_code_t;\n+  hash_code_t m_hash_code (const Key& k) { return m_h1(k); }\n+  std::size_t bucket_index (const Key&, hash_code_t c, std::size_t N) const\n+    { return m_h2 (c, N); }\n+  std::size_t bucket_index (const hash_node<Value, false>* p, std::size_t N) {\n+    return m_h2 (m_h1 (m_extract (p->m_v)), N);\n+  }\n+\n+  bool compare (const Key& k, hash_code_t,  hash_node<Value, false>* n)\n+    { return m_eq (k, m_extract(n->m_v)); }\n+\n+  void copy_code (hash_node<Value, false>*, const hash_node<Value, false>*) { }\n+\n+  void m_swap(hash_code_base& x) {\n+    m_extract.m_swap(x);\n+    m_eq.m_swap(x);\n+    m_h1.m_swap(x);\n+    m_h2.m_swap(x);\n+  }\n+\n+protected:\n+  ExtractKey m_extract;\n+  Equal m_eq;\n+  H1 m_h1;\n+  H2 m_h2;\n+};\n+\n+// Specialization: hash function and range-hashing function, \n+// caching hash codes.  H is provided but ignored.  Provides\n+// typedef and accessor required by TR1.\n+template <typename Key, typename Value,\n+\t  typename ExtractKey, typename Equal,\n+\t  typename H1, typename H2>\n+struct hash_code_base <Key, Value, ExtractKey, Equal, H1, H2, default_ranged_hash, true>\n+{\n+  typedef H1 hasher;\n+  hasher hash_function() const { return m_h1; }\n+\n+protected:\n+  hash_code_base (const ExtractKey& ex, const Equal& eq,\n+\t\t    const H1& h1, const H2& h2, const default_ranged_hash&)\n+    : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+\n+  typedef std::size_t hash_code_t;\n+  hash_code_t m_hash_code (const Key& k) { return m_h1(k); }\n+  std::size_t bucket_index (const Key&, hash_code_t c, std::size_t N) const\n+    { return m_h2 (c, N); }\n+\n+  std::size_t bucket_index (const hash_node<Value, true>* p, std::size_t N) {\n+    return m_h2 (p->hash_code, N);\n+  }\n+\n+  bool compare (const Key& k, hash_code_t c,  hash_node<Value, true>* n)\n+    { return c == n->hash_code && m_eq (k, m_extract(n->m_v)); }\n+\n+  void copy_code (hash_node<Value, true>* to, const hash_node<Value, true>* from)\n+    { to->hash_code = from->hash_code; }\n+\n+  void m_swap(hash_code_base& x) {\n+    m_extract.m_swap(x);\n+    m_eq.m_swap(x);\n+    m_h1.m_swap(x);\n+    m_h2.m_swap(x);\n+  }\n+\n+protected:\n+  ExtractKey m_extract;\n+  Equal m_eq;\n+  H1 m_h1;\n+  H2 m_h2;\n+};\n+\n+} // namespace internal\n+\n+namespace std { namespace tr1 {\n+\n+//----------------------------------------------------------------------\n+// Class template hashtable, class definition.\n+\n+// Meaning of class template hashtable's template parameters\n+\n+// Key and Value: arbitrary CopyConstructible types.\n+\n+// Allocator: an allocator type ([lib.allocator.requirements]) whose\n+// value type is Value.\n+\n+// ExtractKey: function object that takes a object of type Value\n+// and returns a value of type Key.\n+\n+// Equal: function object that takes two objects of type k and returns\n+// a bool-like value that is true if the two objects are considered equal.\n+\n+// H1: the hash function.  A unary function object with argument type\n+// Key and result type size_t.  Return values should be distributed\n+// over the entire range [0, numeric_limits<size_t>:::max()].\n+\n+// H2: the range-hashing function (in the terminology of Tavori and\n+// Dreizin).  A binary function object whose argument types and result\n+// type are all size_t.  Given arguments r and N, the return value is\n+// in the range [0, N).\n+\n+// H: the ranged hash function (Tavori and Dreizin). A binary function\n+// whose argument types are Key and size_t and whose result type is\n+// size_t.  Given arguments k and N, the return value is in the range\n+// [0, N).  Default: h(k, N) = h2(h1(k), N).  If H is anything other\n+// than the default, H1 and H2 are ignored.\n+\n+// RehashPolicy: Policy class with three members, all of which govern\n+// the bucket count. n_bkt(n) returns a bucket count no smaller\n+// than n.  bkt_for_elements(n) returns a bucket count appropriate\n+// for an element count of n.  need_rehash(n_bkt, n_elt, n_ins)\n+// determines whether, if the current bucket count is n_bkt and the\n+// current element count is n_elt, we need to increase the bucket\n+// count.  If so, returns make_pair(true, n), where n is the new\n+// bucket count.  If not, returns make_pair(false, <anything>).\n+\n+// ??? Right now it is hard-wired that the number of buckets never\n+// shrinks.  Should we allow RehashPolicy to change that?\n+\n+// cache_hash_code: bool.  true if we store the value of the hash\n+// function along with the value.  This is a time-space tradeoff.\n+// Storing it may improve lookup speed by reducing the number of times\n+// we need to call the Equal function.\n+\n+// mutable_iterators: bool.  true if hashtable::iterator is a mutable\n+// iterator, false if iterator and const_iterator are both const \n+// iterators.  This is true for unordered_map and unordered_multimap,\n+// false for unordered_set and unordered_multiset.\n+\n+// unique_keys: bool.  true if the return value of hashtable::count(k)\n+// is always at most one, false if it may be an arbitrary number.  This\n+// true for unordered_set and unordered_map, false for unordered_multiset\n+// and unordered_multimap.\n+\n+template <typename Key, typename Value, \n+\t  typename Allocator,\n+\t  typename ExtractKey, typename Equal,\n+\t  typename H1, typename H2,\n+\t  typename H, typename RehashPolicy,\n+\t  bool cache_hash_code,\n+\t  bool mutable_iterators,\n+\t  bool unique_keys>\n+class hashtable\n+  : public Internal::rehash_base<RehashPolicy, hashtable<Key, Value, Allocator, ExtractKey, Equal, H1, H2, H, RehashPolicy, cache_hash_code, mutable_iterators, unique_keys> >,\n+    public Internal::hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, cache_hash_code>,\n+    public Internal::map_base<Key, Value, ExtractKey, unique_keys, hashtable<Key, Value, Allocator, ExtractKey, Equal, H1, H2, H, RehashPolicy, cache_hash_code, mutable_iterators, unique_keys> >\n+{\n+public:\n+  typedef Allocator                           allocator_type;\n+  typedef Value                               value_type;\n+  typedef Key                                 key_type;\n+  typedef Equal                               key_equal;\n+  // mapped_type, if present, comes from map_base.\n+  // hasher, if present, comes from hash_code_base.\n+  typedef typename Allocator::difference_type difference_type;\n+  typedef typename Allocator::size_type       size_type;\n+  typedef typename Allocator::reference       reference;\n+  typedef typename Allocator::const_reference const_reference;\n+\n+  typedef Internal::node_iterator<value_type, !mutable_iterators, cache_hash_code>\n+          local_iterator;\n+  typedef Internal::node_iterator<value_type, false,              cache_hash_code>\n+          const_local_iterator;\n+\n+  typedef Internal::hashtable_iterator<value_type, !mutable_iterators, cache_hash_code>\n+          iterator;\n+  typedef Internal::hashtable_iterator<value_type, false,              cache_hash_code>\n+          const_iterator;\n+\n+private:\n+  typedef Internal::hash_node<Value, cache_hash_code>                 node;\n+  typedef typename Allocator::template rebind<node>::other  node_allocator_t;\n+  typedef typename Allocator::template rebind<node*>::other bucket_allocator_t;\n+\n+private:\n+  node_allocator_t m_node_allocator;\n+  node** m_buckets;\n+  size_type m_bucket_count;\n+  size_type m_element_count;\n+  RehashPolicy m_rehash_policy;\n+\n+  node* m_allocate_node (const value_type& v);\n+  void m_deallocate_node (node* n);\n+  void m_deallocate_nodes (node**, size_type);\n+\n+  node** m_allocate_buckets (size_type n);\n+  void m_deallocate_buckets (node**, size_type n);\n+\n+public:\t\t\t\t// Constructor, destructor, assignment, swap\n+  hashtable(size_type bucket_hint,\n+\t    const H1&, const H2&, const H&,\n+\t    const Equal&, const ExtractKey&,\n+\t    const allocator_type&);\n+  \n+  template <typename InIter>\n+  hashtable(InIter first, InIter last,\n+\t    size_type bucket_hint,\n+\t    const H1&, const H2&, const H&,\n+\t    const Equal&, const ExtractKey&,\n+\t    const allocator_type&);\n+  \n+  hashtable(const hashtable&);\n+  hashtable& operator=(const hashtable&);\n+  ~hashtable();\n+\n+  void swap(hashtable&);\n+\n+public:\t\t\t\t// Basic container operations\n+  iterator       begin() {\n+    iterator i(m_buckets);\n+    if (!i.m_cur_node)\n+      i.m_incr_bucket();\n+    return i;\n+  }\n+\n+  const_iterator begin() const {\n+    const_iterator i(m_buckets);\n+    if (!i.m_cur_node)\n+      i.m_incr_bucket();\n+    return i;\n+  }\n+\n+  iterator       end()\n+    { return iterator(m_buckets + m_bucket_count); }\n+  const_iterator end() const\n+    { return const_iterator(m_buckets + m_bucket_count); }\n+\n+  size_type size() const { return m_element_count; }\n+  bool empty() const { return size() == 0; }\n+\n+  allocator_type get_allocator() const { return m_node_allocator; }\n+  size_type max_size() const { return m_node_allocator.max_size(); }\n+\n+public:\t\t\t\t// Bucket operations\n+  size_type bucket_count() const\n+    { return m_bucket_count; }\n+  size_type max_bucket_count() const\n+    { return max_size(); }\n+  size_type bucket_size (size_type n) const\n+    { return std::distance(begin(n), end(n)); }\n+  size_type bucket (const key_type& k) const\n+    { return this->bucket_index (k, this->m_hash_code, this->m_bucket_count); }\n+\n+  local_iterator begin(size_type n)\n+    { return local_iterator(m_buckets[n]); }\n+  local_iterator end(size_type n)\n+    { return local_iterator(0); }\n+  const_local_iterator begin(size_type n) const\n+    { return const_local_iterator(m_buckets[n]); }\n+  const_local_iterator end(size_type n) const\n+    { return const_local_iterator(0); }\n+\n+  float load_factor() const\n+    { return static_cast<float>(size()) / static_cast<float>(bucket_count()); }\n+  // max_load_factor, if present, comes from rehash_base.\n+\n+  // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n+  // useful if RehashPolicy is something other than the default.\n+  const RehashPolicy& rehash_policy() const { return m_rehash_policy; }\n+  void rehash_policy (const RehashPolicy&);\n+\n+public:\t\t\t\t// lookup\n+  iterator       find(const key_type&);\n+  const_iterator find(const key_type& k) const;\n+  size_type count(const key_type& k) const;\n+  std::pair<iterator, iterator> equal_range(const key_type& k);\n+  std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n+\n+private:\t\t\t// Insert and erase helper functions\n+  // ??? This dispatching is a workaround for the fact that we don't\n+  // have partial specialization of member templates; it would be\n+  // better to just specialize insert on unique_keys.  There may be a\n+  // cleaner workaround.\n+  typedef typename Internal::IF<unique_keys, std::pair<iterator, bool>, iterator>::type\n+          Insert_Return_Type;\n+\n+  node* find_node (node* p, const key_type& k, typename hashtable::hash_code_t c);\n+\n+  std::pair<iterator, bool> insert (const value_type&, std::tr1::true_type);\n+  iterator insert (const value_type&, std::tr1::false_type);\n+\n+public:\t\t\t\t// Insert and erase\n+  Insert_Return_Type insert (const value_type& v) \n+  { return this->insert (v, std::tr1::integral_constant<bool, unique_keys>()); }\n+  Insert_Return_Type insert (const_iterator, const value_type& v)\n+    { return this->insert(v); }\n+\n+  template <typename InIter> void insert(InIter first, InIter last);\n+\n+  void erase(const_iterator);\n+  size_type erase(const key_type&);\n+  void erase(const_iterator, const_iterator);\n+  void clear();\n+\n+public:\n+  // Set number of buckets to be apropriate for container of n element.\n+  void rehash (size_type n);\n+\n+private:\n+  // Unconditionally change size of bucket array to n.\n+  void m_rehash (size_type n);\n+};\n+\n+//----------------------------------------------------------------------\n+// Definitions of class template hashtable's out-of-line member functions.\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::node*\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_allocate_node (const value_type& v)\n+{\n+  node* n = m_node_allocator.allocate(1);\n+  try {\n+    get_allocator().construct(&n->m_v, v);\n+    n->m_next = 0;\n+    return n;\n+  }\n+  catch(...) {\n+    m_node_allocator.deallocate(n, 1);\n+    throw;\n+  }\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_deallocate_node (node* n)\n+{\n+  get_allocator().destroy(&n->m_v);\n+  m_node_allocator.deallocate(n, 1);\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::m_deallocate_nodes (node** array, size_type n)\n+{\n+  for (size_type i = 0; i < n; ++i) {\n+    node* p = array[i];\n+    while (p) {\n+      node* tmp = p;\n+      p = p->m_next;\n+      m_deallocate_node (tmp);\n+    }\n+    array[i] = 0;\n+  }\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::node**\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_allocate_buckets (size_type n)\n+{\n+  bucket_allocator_t alloc(m_node_allocator);\n+\n+  // We allocate one extra bucket to hold a sentinel, an arbitrary\n+  // non-null pointer.  Iterator increment relies on this.\n+  node** p = alloc.allocate(n+1);\n+  std::fill(p, p+n, (node*) 0);\n+  p[n] = reinterpret_cast<node*>(0x1000);\n+  return p;\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::m_deallocate_buckets (node** p, size_type n)\n+{\n+  bucket_allocator_t alloc(m_node_allocator);\n+  alloc.deallocate(p, n+1);\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::hashtable(size_type bucket_hint,\n+\t    const H1& h1, const H2& h2, const H& h,\n+\t    const Eq& eq, const Ex& exk,\n+\t    const allocator_type& a)\n+  : Internal::rehash_base<RP,hashtable> (),\n+    Internal::hash_code_base<K,V,Ex,Eq,H1,H2,H,c> (exk, eq, h1, h2, h),\n+    Internal::map_base<K,V,Ex,u,hashtable> (),\n+    m_node_allocator(a),\n+    m_bucket_count (0),\n+    m_element_count (0),\n+    m_rehash_policy ()\n+{\n+  m_bucket_count = m_rehash_policy.next_bkt(bucket_hint);\n+  m_buckets = m_allocate_buckets (m_bucket_count);\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+template <typename InIter>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::hashtable(InIter f, InIter l,\n+\t    size_type bucket_hint,\n+\t    const H1& h1, const H2& h2, const H& h,\n+\t    const Eq& eq, const Ex& exk,\n+\t    const allocator_type& a)\n+  : Internal::rehash_base<RP,hashtable> (),\n+    Internal::hash_code_base<K,V,Ex,Eq,H1,H2,H,c> (exk, eq, h1, h2, h),\n+    Internal::map_base<K,V,Ex,u,hashtable> (),\n+    m_node_allocator(a),\n+    m_bucket_count (0),\n+    m_element_count (0),\n+    m_rehash_policy ()\n+{\n+  m_bucket_count = std::max(m_rehash_policy.next_bkt(bucket_hint),\n+\t\t\t    m_rehash_policy.bkt_for_elements(Internal::distance_fw(f, l)));\n+  m_buckets = m_allocate_buckets (m_bucket_count);\n+  try {\n+    for  (; f != l; ++f)\n+      this->insert (*f);\n+  }\n+  catch(...) {\n+    clear();\n+    m_deallocate_buckets (m_buckets, m_bucket_count);\n+    throw;\n+  }\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::hashtable(const hashtable& ht)\n+  : Internal::rehash_base<RP,hashtable> (ht),\n+    Internal::hash_code_base<K,V,Ex,Eq,H1,H2,H,c> (ht),\n+    Internal::map_base<K,V,Ex,u,hashtable> (ht),\n+    m_node_allocator(ht.get_allocator()),\n+    m_bucket_count (ht.m_bucket_count),\n+    m_element_count (ht.m_element_count),\n+    m_rehash_policy (ht.m_rehash_policy)\n+{\n+  m_buckets = m_allocate_buckets (m_bucket_count);\n+  try {\n+    for (size_t i = 0; i < ht.m_bucket_count; ++i) {\n+      node* n = ht.m_buckets[i];\n+      node** tail = m_buckets + i;\n+      while (n) {\n+\t*tail = m_allocate_node (n);\n+\t(*tail).copy_code_from (n);\n+\ttail = &((*tail)->m_next);\n+\tn = n->m_next;\n+      }\n+    }\n+  }\n+  catch (...) {\n+    clear();\n+    m_deallocate_buckets (m_buckets, m_bucket_count);\n+    throw;\n+  }\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>&\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::operator= (const hashtable& ht)\n+{\n+  hashtable tmp(ht);\n+  this->swap(tmp);\n+  return *this;\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::~hashtable()\n+{\n+  clear();\n+  m_deallocate_buckets(m_buckets, m_bucket_count);\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::swap (hashtable& x)\n+{\n+  // The only base class with member variables is hash_code_base.  We\n+  // define hash_code_base::m_swap because different specializations\n+  // have different members.\n+  Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>::m_swap(x);\n+\n+  // open LWG issue 431\n+  // std::swap(m_node_allocator, x.m_node_allocator);\n+  std::swap (m_rehash_policy, x.m_rehash_policy);\n+  std::swap (m_buckets, x.m_buckets);\n+  std::swap (m_bucket_count, x.m_bucket_count);\n+  std::swap (m_element_count, x.m_element_count);\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::rehash_policy (const RP& pol)\n+{\n+  m_rehash_policy = pol;\n+  size_type n_bkt = pol.bkt_for_elements(m_element_count);\n+  if (n_bkt > m_bucket_count)\n+    m_rehash (n_bkt);\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::find (const key_type& k)\n+{\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  std::size_t n = this->bucket_index (k, code, this->bucket_count);\n+  node* p = find_node (m_buckets[n], k, code);\n+  return p ? iterator(p, m_buckets + n) : this->end();\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::const_iterator\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::find (const key_type& k) const\n+{\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  std::size_t n = this->bucket_index (k, code, this->bucket_count);\n+  node* p = find_node (m_buckets[n], k, code);\n+  return p ? const_iterator(p, m_buckets + n) : this->end();\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::size_type\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::count (const key_type& k) const\n+{\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  std::size_t n = this->bucket_index (k, code, this->bucket_count);\n+  size_t result = 0;\n+  for (node* p = m_buckets[n]; p ; p = p->m_next)\n+    if (this->compare (k, code, p))\n+      ++result;\n+  return result;\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+std::pair<typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator,\n+\t  typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::equal_range (const key_type& k)\n+{\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  std::size_t n = this->bucket_index (k, code, this->bucket_count);\n+  node** head = m_buckets + n;\n+  node* p = find_node (*head, k, code);\n+\n+  if (p) {\n+    node* p1 = p->m_next;\n+    for (; p1 ; p1 = p1->m_next)\n+      if (!this->compare (k, code, p1))\n+\tbreak;\n+    iterator first(p, head);\n+    iterator last(p1, head);\n+    if (!p1)\n+      p1->m_incr_bucket();\n+    return std::make_pair(first, last);\n+  }\n+  else\n+    return std::make_pair (this->end(), this->end());\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+std::pair<typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::const_iterator,\n+\t  typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::const_iterator>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::equal_range (const key_type& k) const\n+{\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  std::size_t n = this->bucket_index (k, code, this->bucket_count);\n+  node** head = m_buckets + n;\n+  node* p = find_node (*head, k, code);\n+\n+  if (p) {\n+    node* p1 = p->m_next;\n+    for (; p1 ; p1 = p1->m_next)\n+      if (!this->compare (k, code, p1))\n+\tbreak;\n+    const_iterator first(p, head);\n+    const_iterator last(p1, head);\n+    if (!p1)\n+      p1->m_incr_bucket();\n+    return std::make_pair(first, last);\n+  }\n+  else\n+    return std::make_pair (this->end(), this->end());\n+}\n+\n+// Find the node whose key compares equal to k, beginning the search\n+// at p (usually the head of a bucket).  Return nil if no node is found.\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::node* \n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::find_node (node* p, const key_type& k, typename hashtable::hash_code_t code)\n+{\n+  for ( ; p ; p = p->m_next)\n+    if (this->compare (k, code, p))\n+      return p;\n+  return false;\n+}\n+\n+// Insert v if no element with its key is already present.\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+std::pair<typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator, bool>\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::insert (const value_type& v, std::tr1::true_type)\n+{\n+  const key_type& k = this->m_extract(v);\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  size_type n = this->bucket_index (k, code, m_bucket_count);\n+\n+  if (node* p = find_node (m_buckets[n], k, code))\n+    return std::make_pair(iterator(p, m_buckets + n), false);\n+\n+  std::pair<bool, size_t> do_rehash\n+    = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n+\n+  // Allocate the new node before doing the rehash so that we don't\n+  // do a rehash if the allocation throws.\n+  node* new_node = m_allocate_node (v);\n+\n+  try {\n+    if (do_rehash.first) {\n+      n = this->bucket_index (k, code, do_rehash.second);\n+      m_rehash(do_rehash.second);\n+    }\n+\n+    new_node->m_next = m_buckets[n];\n+    m_buckets[n] = new_node;\n+    ++m_element_count;\n+    return std::make_pair(iterator (new_node, m_buckets + n), true);\n+  }\n+  catch (...) {\n+    m_deallocate_node (new_node);\n+    throw;\n+  }\n+}\n+\n+// Insert v unconditionally.\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::iterator\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::insert (const value_type& v, std::tr1::false_type)\n+{\n+  std::pair<bool, std::size_t> do_rehash\n+    = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n+  if (do_rehash.first)\n+    m_rehash(do_rehash.second);\n+\n+  const key_type& k = this->m_extract(v);\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  size_type n = this->bucket_index (k, code, m_bucket_count);\n+\n+  node* new_node = m_allocate_node (v);\n+  node* prev = find_node (m_buckets[n], k, code);\n+  if (prev) {\n+    new_node->m_next = prev->m_next;\n+    prev->m_next = new_node;\n+  }\n+  else {\n+    new_node->m_next = m_buckets[n];\n+    m_buckets[n] = new_node;\n+  }\n+\n+  ++m_element_count;\n+  return iterator (new_node, m_buckets + n);\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+template <typename InIter>\n+void \n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::insert(InIter first, InIter last)\n+{\n+  size_type n_elt = Internal::distance_fw (first, last);\n+  std::pair<bool, std::size_t> do_rehash\n+    = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, n_elt);\n+  if (do_rehash.first)\n+    m_rehash(do_rehash.second);\n+\n+  for (; first != last; ++first)\n+    this->insert (*first);\n+}\n+\n+// XXX We're following the TR in giving this a return type of void,\n+// but that ought to change.  The return type should be const_iterator,\n+// and it should return the iterator following the one we've erased.\n+// That would simplify range erase.\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::erase (const_iterator i)\n+{\n+  node* p = i.m_cur_node;\n+  node* cur = *i.m_cur_bucket;\n+  if (cur == p)\n+    *i.m_cur_bucket = cur->m_next;\n+  else {\n+    node* next = cur->m_next;\n+    while (next != p) {\n+      cur = next;\n+      next = cur->m_next;\n+    }\n+    cur->m_next = next->m_next;\n+  }\n+\n+  m_deallocate_node (p);\n+  --m_element_count;\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+typename hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::size_type \n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::erase(const key_type& k)\n+{\n+  typename hashtable::hash_code_t code = this->m_hash_code (k);\n+  size_type n = this->bucket_index (k, code, m_bucket_count);\n+\n+  node** slot = m_buckets + n;\n+  while (*slot && ! this->compare (k, code, *slot))\n+    slot = &((*slot)->m_next);\n+\n+  while (*slot && this->compare (k, code, *slot)) {\n+    node* n = *slot;\n+    *slot = n->m_next;\n+    m_deallocate_node (n);\n+    --m_element_count;\n+  }\n+}\n+\n+// ??? This could be optimized by taking advantage of the bucket\n+// structure, but it's not clear that it's worth doing.  It probably\n+// wouldn't even be an optimization unless the load factor is large.\n+template <typename K, typename V,\n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>\n+::erase(const_iterator first, const_iterator last)\n+{\n+  while (first != last) {\n+    const_iterator next = first;\n+    ++next;\n+    this->erase(first);\n+    first = next;\n+  }\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::clear()\n+{\n+  m_deallocate_nodes (m_buckets, m_bucket_count);\n+  m_element_count = 0;\n+}\n+\n+template <typename K, typename V, \n+\t  typename A, typename Ex, typename Eq,\n+\t  typename H1, typename H2, typename H, typename RP,\n+\t  bool c, bool m, bool u>\n+void\n+hashtable<K,V,A,Ex,Eq,H1,H2,H,RP,c,m,u>::m_rehash (size_type N)\n+{\n+  node** new_array = m_allocate_buckets (N);\n+  try {\n+    for (size_type i = 0; i < m_bucket_count; ++i)\n+      while (node* p = m_buckets[i]) {\n+\tsize_type new_index = this->bucket_index (p, N);\n+\tm_buckets[i] = p->m_next;\n+\tp->m_next = new_array[new_index];\n+\tnew_array[new_index] = p;\n+      }\n+    m_deallocate_buckets (m_buckets, m_bucket_count);\n+    m_bucket_count = N;\n+    m_buckets = new_array;\n+  }\n+  catch (...) {\n+    // A failure here means that a hash function threw an exception.\n+    // We can't restore the previous state without calling the hash\n+    // function again, so the only sensible recovery is to delete\n+    // everything.\n+    m_deallocate_nodes (new_array, N);\n+    m_deallocate_buckets (new_array, N);\n+    m_deallocate_nodes (m_buckets, m_bucket_count);\n+    m_element_count = 0;\n+    throw;\n+  }\n+}\n+\n+} }\t\t\t\t// Namespace std::tr1\n+\n+#endif /* GNU_LIBSTDCXX_TR1_HASHTABLE_ */\n+"}, {"sha": "8a724ebfad3aeecd8f7e3acd0d60fdb889fddce9", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,157 @@\n+// TR1 unordered_map -*- C++ -*-\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+/** @file \n+ *  This is a TR1 C++ Library header. \n+ */\n+\n+#ifndef GNU_LIBSTDCXX_TR1_UNORDERED_MAP_\n+#define GNU_LIBSTDCXX_TR1_UNORDERED_MAP_\n+\n+#include <tr1/hashtable>\n+#include <tr1/functional>\n+#include <tr1/functional>\n+#include <utility>\n+#include <memory>\n+\n+namespace std { namespace tr1 {\n+\n+// XXX When we get typedef templates these class definitions will be unnecessary.\n+\n+template <class Key, class T,\n+\t  class Hash = hash<Key>,\n+\t  class Pred = std::equal_to<Key>,\n+\t  class Alloc = std::allocator<std::pair<const Key, T> >,\n+\t  bool cache_hash_code = false>\n+class unordered_map\n+  : public hashtable <Key, std::pair<const Key, T>,\n+\t\t      Alloc,\n+\t\t      Internal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t      Internal::prime_rehash_policy,\n+\t\t      cache_hash_code, true, true>\n+{\n+  typedef hashtable <Key, std::pair<const Key, T>,\n+\t\t     Alloc,\n+\t\t     Internal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t     Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t     Internal::prime_rehash_policy,\n+\t\t     cache_hash_code, true, true>\n+          Base;\n+\n+public:\n+  typedef typename Base::size_type size_type;\n+  typedef typename Base::hasher hasher;\n+  typedef typename Base::key_equal key_equal;\n+  typedef typename Base::allocator_type allocator_type;\n+\n+  explicit unordered_map(size_type n = 10,\n+\t\t\t const hasher& hf = hasher(),\n+\t\t\t const key_equal& eql = key_equal(),\n+\t\t\t const allocator_type& a = allocator_type())\n+    : Base (n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n+\t    a)\n+  { }\n+\n+  template <typename InputIterator>\n+  unordered_map(InputIterator f, InputIterator l, \n+\t\tsize_type n = 10,\n+\t\tconst hasher& hf = hasher(), \n+\t\tconst key_equal& eql = key_equal(), \n+\t\tconst allocator_type& a = allocator_type())\n+    : Base (f, l,\n+\t    n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n+\t    a)\n+\t    { }\n+};\n+\n+template <class Key, class T,\n+\t  class Hash = hash<Key>,\n+\t  class Pred = std::equal_to<Key>,\n+\t  class Alloc = std::allocator<std::pair<const Key, T> >,\n+\t  bool cache_hash_code = false>\n+class unordered_multimap\n+  : public hashtable <Key, std::pair<const Key, T>,\n+\t\t      Alloc,\n+\t\t      Internal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t      Internal::prime_rehash_policy,\n+\t\t      cache_hash_code, true, false>\n+{\n+  typedef hashtable <Key, std::pair<const Key, T>,\n+\t\t     Alloc,\n+\t\t     Internal::extract1st<std::pair<const Key, T> >, Pred,\n+\t\t     Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t     Internal::prime_rehash_policy,\n+\t\t     cache_hash_code, true, false>\n+          Base;\n+\n+public:\n+  typedef typename Base::size_type size_type;\n+  typedef typename Base::hasher hasher;\n+  typedef typename Base::key_equal key_equal;\n+  typedef typename Base::allocator_type allocator_type;\n+\n+  explicit unordered_multimap(size_type n = 10,\n+\t\t\t      const hasher& hf = hasher(),\n+\t\t\t      const key_equal& eql = key_equal(),\n+\t\t\t      const allocator_type& a = allocator_type())\n+    : Base (n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n+\t    a)\n+  { }\n+\n+\n+  template <typename InputIterator>\n+  unordered_multimap(InputIterator f, InputIterator l, \n+\t\t     typename Base::size_type n = 0,\n+\t\t     const hasher& hf = hasher(), \n+\t\t     const key_equal& eql = key_equal(), \n+\t\t     const allocator_type& a = allocator_type())\n+    : Base (f, l,\n+\t    n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::extract1st<std::pair<const Key, T> >(),\n+\t    a)\n+  { }\n+};\n+\n+template <class Key, class T, class Hash, class Pred, class Alloc, bool cache_hash_code>\n+inline void swap (unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t\t  unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n+{\n+  x.swap(y);\n+}\n+\n+template <class Key, class T, class Hash, class Pred, class Alloc, bool cache_hash_code>\n+inline void swap (unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t\t  unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n+{\n+  x.swap(y);\n+}\n+\n+} }\n+\n+#endif /* GNU_LIBSTDCXX_TR1_UNORDERED_MAP_ */"}, {"sha": "554141cbad5f034fb2abfbb2a0359eca60aacd94", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,151 @@\n+// TR1 unordered_set -*- C++ -*-\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+/** @file \n+ *  This is a TR1 C++ Library header. \n+ */\n+\n+#ifndef GNU_LIBSTDCXX_TR1_UNORDERED_SET_\n+#define GNU_LIBSTDCXX_TR1_UNORDERED_SET_\n+\n+#include <tr1/hashtable>\n+#include <tr1/functional>\n+#include <memory>\n+\n+namespace std { namespace tr1 {\n+\n+// XXX When we get typedef templates these class definitions will be unnecessary.\n+\n+template <class Value,\n+\t  class Hash = hash<Value>,\n+\t  class Pred = std::equal_to<Value>,\n+\t  class Alloc = std::allocator<Value>,\n+\t  bool cache_hash_code = false>\n+class unordered_set\n+  : public hashtable <Value, Value, Alloc,\n+\t\t      Internal::identity<Value>, Pred,\n+\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t      Internal::prime_rehash_policy,\n+\t\t      cache_hash_code, false, true>\n+{\n+  typedef hashtable <Value, Value, Alloc,\n+\t\t      Internal::identity<Value>, Pred,\n+\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t      Internal::prime_rehash_policy,\n+\t\t      cache_hash_code, false, true>\n+          Base;\n+\n+public:\n+  typedef typename Base::size_type size_type;\n+  typedef typename Base::hasher hasher;\n+  typedef typename Base::key_equal key_equal;\n+  typedef typename Base::allocator_type allocator_type;\n+\n+  explicit unordered_set(size_type n = 10,\n+\t\t\t const hasher& hf = hasher(),\n+\t\t\t const key_equal& eql = key_equal(),\n+\t\t\t const allocator_type& a = allocator_type())\n+    : Base (n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::identity<Value>(),\n+\t    a)\n+  { }\n+\n+  template <typename InputIterator>\n+  unordered_set(InputIterator f, InputIterator l, \n+\t\tsize_type n = 10,\n+\t\tconst hasher& hf = hasher(), \n+\t\tconst key_equal& eql = key_equal(), \n+\t\tconst allocator_type& a = allocator_type())\n+    : Base (f, l,\n+\t    n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::identity<Value>(),\n+\t    a)\n+\t    { }\n+};\n+\n+template <class Value,\n+\t  class Hash = hash<Value>,\n+\t  class Pred = std::equal_to<Value>,\n+\t  class Alloc = std::allocator<Value>,\n+\t  bool cache_hash_code = false>\n+class unordered_multiset\n+  : public hashtable <Value, Value, Alloc,\n+\t\t      Internal::identity<Value>, Pred,\n+\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t      Internal::prime_rehash_policy,\n+\t\t      cache_hash_code, false, false>\n+{\n+  typedef hashtable <Value, Value, Alloc,\n+\t\t      Internal::identity<Value>, Pred,\n+\t\t      Hash, Internal::mod_range_hashing, Internal::default_ranged_hash,\n+\t\t      Internal::prime_rehash_policy,\n+\t\t      cache_hash_code, false, false>\n+          Base;\n+\n+public:\n+  typedef typename Base::size_type size_type;\n+  typedef typename Base::hasher hasher;\n+  typedef typename Base::key_equal key_equal;\n+  typedef typename Base::allocator_type allocator_type;\n+\n+  explicit unordered_multiset(size_type n = 10,\n+\t\t\t      const hasher& hf = hasher(),\n+\t\t\t      const key_equal& eql = key_equal(),\n+\t\t\t      const allocator_type& a = allocator_type())\n+    : Base (n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::identity<Value>(),\n+\t    a)\n+  { }\n+\n+\n+  template <typename InputIterator>\n+  unordered_multiset(InputIterator f, InputIterator l, \n+\t\t     typename Base::size_type n = 0,\n+\t\t     const hasher& hf = hasher(), \n+\t\t     const key_equal& eql = key_equal(), \n+\t\t     const allocator_type& a = allocator_type())\n+    : Base (f, l,\n+\t    n,\n+\t    hf, Internal::mod_range_hashing(), Internal::default_ranged_hash(),\n+\t    eql, Internal::identity<Value>(),\n+\t    a)\n+  { }\n+};\n+\n+template <class Value, class Hash, class Pred, class Alloc, bool cache_hash_code>\n+inline void swap (unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t\t  unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n+{\n+  x.swap(y);\n+}\n+\n+template <class Value, class Hash, class Pred, class Alloc, bool cache_hash_code>\n+inline void swap (unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n+\t\t  unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n+{\n+  x.swap(y);\n+}\n+\n+} }\n+\n+#endif /* GNU_LIBSTDCXX_TR1_UNORDERED_SET_ */"}, {"sha": "308e5178c7bd5555850a2bac35ecc4471d009222", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/array_syntax.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Farray_syntax.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Farray_syntax.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Farray_syntax.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do run }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.4 unordered_map\n+// Array version of insert\n+\n+#include <string>\n+#include <iterator>\n+#include <tr1/unordered_map>\n+#include \"testsuite_hooks.h\"\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::tr1::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  m[\"red\"] = 17;\n+  VERIFY(m.size() == 1);\n+  VERIFY(m.begin()->first == \"red\");\n+  VERIFY(m.begin()->second == 17);\n+  VERIFY(m[\"red\"] == 17);\n+\n+  m[\"blue\"] == 9;\n+  VERIFY(m.size() == 2);\n+  VERIFY(m[\"blue\"] == 9);\n+\n+  m[\"red\"] = 5;\n+  VERIFY(m.size() == 2);\n+  VERIFY(m[\"red\"] == 5);\n+  VERIFY(m[\"blue\"] == 9);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0cb60dfb1cddb0ecb7a4041b5eb4b09463ccc85e", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/map_single.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmap_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmap_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmap_single.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do run }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.4 unordered_map\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <tr1/unordered_map>\n+#include \"testsuite_hooks.h\"\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::tr1::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  std::pair<Map::iterator, bool> p = m.insert(Pair(\"abcde\", 3));\n+  VERIFY(p.second);\n+  VERIFY(m.size() == 1);\n+  VERIFY(std::distance(m.begin(), m.end()) == 1);\n+  VERIFY(p.first == m.begin());\n+  VERIFY(p.first->first == \"abcde\");\n+  VERIFY(p.first->second == 3);\n+}\n+\n+void test02()\n+{\n+  typedef std::tr1::unordered_map<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  std::pair<Map::iterator, bool> p1 = m.insert(Pair(\"abcde\", 3));\n+  std::pair<Map::iterator, bool> p2 = m.insert(Pair(\"abcde\", 7));\n+\n+  VERIFY(p1.second);\n+  VERIFY(!p2.second);\n+  VERIFY(m.size() == 1);\n+  VERIFY(p1.first == p2.first);\n+  VERIFY(p1.first->first == \"abcde\");\n+  VERIFY(p2.first->second == 3);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "bfd4056bb9e8435edc71fd994bbc9a205b98b990", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/multimap_single.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmultimap_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmultimap_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmultimap_single.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,78 @@\n+// { dg-do run }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.6 unordered_multimap\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <tr1/unordered_map>\n+#include \"testsuite_hooks.h\"\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::tr1::unordered_multimap<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  Map::iterator i = m.insert(Pair(\"abcde\", 3));\n+  VERIFY(m.size() == 1);\n+  VERIFY(std::distance(m.begin(), m.end()) == 1);\n+  VERIFY(i == m.begin());\n+  VERIFY(i->first == \"abcde\");\n+  VERIFY(i->second == 3);\n+}\n+\n+void test02()\n+{\n+  typedef std::tr1::unordered_multimap<std::string, int> Map;\n+  typedef std::pair<const std::string, int> Pair;\n+\n+  Map m;\n+  VERIFY(m.empty());\n+\n+  m.insert(Pair(\"abcde\", 3));\n+  m.insert(Pair(\"abcde\", 7));\n+\n+  VERIFY(m.size() == 2);\n+  VERIFY(std::distance(m.begin(), m.end()) == 2);\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY(i1->first == \"abcde\");\n+  VERIFY(i2->first == \"abcde\");\n+  VERIFY((i1->second == 3 && i2->second == 7) ||\n+\t (i1->second == 7 && i2->second == 3));\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "a02c12acf187a3051e54037cbdc9efa24df57e03", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/multiset_single.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmultiset_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmultiset_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fmultiset_single.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,69 @@\n+// { dg-do run }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.5 unordered_multiset\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <tr1/unordered_set>\n+#include \"testsuite_hooks.h\"\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::tr1::unordered_multiset<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  Set::iterator i = s.insert(\"abcde\");\n+  VERIFY(s.size() == 1);\n+  VERIFY(std::distance(s.begin(), s.end()) == 1);\n+  VERIFY(i == s.begin());\n+  VERIFY(*i == \"abcde\");\n+}\n+\n+void test02()\n+{\n+  typedef std::tr1::unordered_multiset<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  s.insert(\"abcde\");\n+  Set::iterator i = s.insert(\"abcde\");\n+  VERIFY(s.size() == 2);\n+  VERIFY(std::distance(s.begin(), s.end()) == 2);\n+  VERIFY(*i == \"abcde\");\n+  \n+  Set::iterator i2 = s.begin();\n+  ++i2;\n+  VERIFY(i == s.begin() || i == i2);\n+  VERIFY(*(s.begin()) == \"abcde\" && *i2 == \"abcde\");\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "203185af09757469d09c8ff3960fdf5f3ce90df2", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/set_single.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fset_single.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fset_single.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2Fset_single.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do run }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.3 unordered_set\n+// Single-element insert\n+\n+#include <string>\n+#include <iterator>\n+#include <tr1/unordered_set>\n+#include \"testsuite_hooks.h\"\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::tr1::unordered_set<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  std::pair<Set::iterator, bool> p = s.insert(\"abcde\");\n+  VERIFY(p.second);\n+  VERIFY(s.size() == 1);\n+  VERIFY(std::distance(s.begin(), s.end()) == 1);\n+  VERIFY(p.first == s.begin());\n+  VERIFY(*p.first == \"abcde\");\n+}\n+\n+void test02()\n+{\n+  typedef std::tr1::unordered_set<std::string> Set;\n+  Set s;\n+  VERIFY(s.empty());\n+\n+  std::pair<Set::iterator, bool> p1 = s.insert(\"abcde\");\n+  std::pair<Set::iterator, bool> p2 = s.insert(\"abcde\");  \n+  VERIFY(p1.second);\n+  VERIFY(!p2.second);\n+  VERIFY(s.size() == 1);\n+  VERIFY(p1.first == p2.first);\n+  VERIFY(*p1.first == \"abcde\");\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "05838c5bd157c1c2df166697fc6c0d716b8940b1", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/instantiate/hash.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fhash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fhash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fhash.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do compile }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.3 class template hash\n+\n+#include <string>\n+#include <tr1/functional>\n+\n+int main()\n+{\n+  using namespace std::tr1;\n+\n+  // Verify that we can instantiate hash for every required type.\n+\n+  hash<bool> hb;\n+  hash<char> hc;\n+  hash<signed char> hsc;\n+  hash<unsigned char> huc;\n+  hash<wchar_t> hw;\n+  hash<short> hs;\n+  hash<int> hi;\n+  hash<long> hl;\n+  hash<unsigned short> hus;\n+  hash<unsigned int> hui;\n+  hash<unsigned long> hul;\n+  hash<float> hf;\n+  hash<double> hd;\n+  hash<long double> hld;\n+  hash<void*> hp;\n+  hash<std::string> hstr;\n+  hash<std::wstring> hwstr;\n+}"}, {"sha": "88fe2b08628316be90127dc5d83a7fe9e7f11b9e", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/instantiate/map.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmap.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.4 unordered_map\n+\n+#include <string>\n+#include <tr1/unordered_map>\n+\n+int main()\n+{\n+  using namespace std;\n+  using namespace std::tr1;\n+\n+  unordered_map<string, float> m1;\n+  unordered_map<string, float,\n+                hash<string>, equal_to<string>, \n+                allocator<pair<const string, float> >, true> s2;\n+}"}, {"sha": "8132a318fae505224d4b09ea1ccd1abfa8a06bd4", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/instantiate/multimap.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmultimap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmultimap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmultimap.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.6 unordered_multimap\n+\n+#include <string>\n+#include <tr1/unordered_map>\n+\n+int main()\n+{\n+  using namespace std;\n+  using namespace std::tr1;\n+\n+  unordered_multimap<string, float> m1;\n+  unordered_multimap<string, float,\n+                     hash<string>, equal_to<string>, \n+                     allocator<pair<const string, float> >, true> s2;\n+}"}, {"sha": "902adafcdc39b7f3fbce89d2527281b27e9ccf44", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/instantiate/multiset.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmultiset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmultiset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fmultiset.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.5 unordered_multiset\n+\n+#include <tr1/unordered_set>\n+\n+int main()\n+{\n+  using namespace std;\n+  using namespace std::tr1;\n+\n+  unordered_multiset<int> s1;\n+  unordered_multiset<int, hash<int>, equal_to<int>, allocator<int>, true> s2;\n+}"}, {"sha": "52f3cb45140d1a3e4a924f57a68322e0446f0c3a", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/instantiate/set.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180ecd6aa2fde01f16168bfa6ad17452bbf2a306/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finstantiate%2Fset.cc?ref=180ecd6aa2fde01f16168bfa6ad17452bbf2a306", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+\n+// 2005-2-17  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.3 unordered_set\n+\n+#include <tr1/unordered_set>\n+\n+int main()\n+{\n+  using namespace std;\n+  using namespace std::tr1;\n+\n+  unordered_set<int> s1;\n+  unordered_set<int, hash<int>, equal_to<int>, allocator<int>, true> s2;\n+}"}]}