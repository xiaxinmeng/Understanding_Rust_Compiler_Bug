{"sha": "d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNkMGI5ZTA3ZjY5YmQyMTEyMGViZGVhYzIyZDRlMTk3YjdkZmQxYw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael.morin@tele2.fr", "date": "2008-10-31T15:56:21Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2008-10-31T15:56:21Z"}, "message": "re PR fortran/35840 (ICE for character expression in I/O specifier)\n\n\n2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n\n\tPR fortran/35840\n\t* expr.c (gfc_reduce_init_expr): New function, containing checking code\n\tfrom gfc_match_init_expr, so that checking can be deferred. \n\t(gfc_match_init_expr): Use gfc_reduce_init_expr.\n\t* io.c (check_io_constraints): Use gfc_reduce_init_expr instead of \n\tchecking that the expression is a constant. \n\t* match.h (gfc_reduce_init_expr): Prototype added. \n\n2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n\n\tPR fortran/35840\n\t* gfortran.dg/write_check4.f90: New test.\n\nFrom-SVN: r141497", "tree": {"sha": "811f4814607616ee07e17c7629a183aa38712469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/811f4814607616ee07e17c7629a183aa38712469"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/comments", "author": null, "committer": null, "parents": [{"sha": "0e6834af18d539e4615be54eb2f9262898add8b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6834af18d539e4615be54eb2f9262898add8b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6834af18d539e4615be54eb2f9262898add8b4"}], "stats": {"total": 92, "additions": 70, "deletions": 22}, "files": [{"sha": "f7f763f97671bda6ea52c7f2dfc2384e834e895c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "patch": "@@ -1,3 +1,13 @@\n+2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+\tPR fortran/35840\n+\t* expr.c (gfc_reduce_init_expr): New function, containing checking code\n+\tfrom gfc_match_init_expr, so that checking can be deferred. \n+\t(gfc_match_init_expr): Use gfc_reduce_init_expr.\n+\t* io.c (check_io_constraints): Use gfc_reduce_init_expr instead of \n+\tchecking that the expression is a constant. \n+\t* match.h (gfc_reduce_init_expr): Prototype added. \n+\n 2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n \n \tPR fortran/35820"}, {"sha": "1a5e6db3c952d631da914066a1aade5b6951eddd", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "patch": "@@ -2378,47 +2378,62 @@ check_init_expr (gfc_expr *e)\n   return t;\n }\n \n+/* Reduces a general expression to an initialization expression (a constant).\n+   This used to be part of gfc_match_init_expr.\n+   Note that this function doesn't free the given expression on FAILURE.  */\n \n-/* Match an initialization expression.  We work by first matching an\n-   expression, then reducing it to a constant.  */\n-\n-match\n-gfc_match_init_expr (gfc_expr **result)\n+gfc_try\n+gfc_reduce_init_expr (gfc_expr *expr)\n {\n-  gfc_expr *expr;\n-  match m;\n   gfc_try t;\n \n-  m = gfc_match_expr (&expr);\n-  if (m != MATCH_YES)\n-    return m;\n-\n   gfc_init_expr = 1;\n   t = gfc_resolve_expr (expr);\n   if (t == SUCCESS)\n     t = check_init_expr (expr);\n   gfc_init_expr = 0;\n \n   if (t == FAILURE)\n-    {\n-      gfc_free_expr (expr);\n-      return MATCH_ERROR;\n-    }\n+    return FAILURE;\n \n   if (expr->expr_type == EXPR_ARRAY\n       && (gfc_check_constructor_type (expr) == FAILURE\n-\t  || gfc_expand_constructor (expr) == FAILURE))\n-    {\n-      gfc_free_expr (expr);\n-      return MATCH_ERROR;\n-    }\n+      || gfc_expand_constructor (expr) == FAILURE))\n+    return FAILURE;\n \n   /* Not all inquiry functions are simplified to constant expressions\n      so it is necessary to call check_inquiry again.  */ \n   if (!gfc_is_constant_expr (expr) && check_inquiry (expr, 1) != MATCH_YES\n       && !gfc_in_match_data ())\n     {\n       gfc_error (\"Initialization expression didn't reduce %C\");\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Match an initialization expression.  We work by first matching an\n+   expression, then reducing it to a constant.  */\n+\n+match\n+gfc_match_init_expr (gfc_expr **result)\n+{\n+  gfc_expr *expr;\n+  match m;\n+  gfc_try t;\n+\n+  expr = NULL;\n+\n+  m = gfc_match_expr (&expr);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  t = gfc_reduce_init_expr (expr);\n+  if (t != SUCCESS)\n+    {\n+      gfc_free_expr (expr);\n       return MATCH_ERROR;\n     }\n "}, {"sha": "cb89eddbe16c9e5ed0bd7f4ba464f9eab33b1671", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "patch": "@@ -2973,7 +2973,7 @@ if (condition) \\\n     {\n       static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n \n-      if (dt->asynchronous->expr_type != EXPR_CONSTANT)\n+      if (gfc_reduce_init_expr (dt->asynchronous) != SUCCESS)\n \t{\n \t  gfc_error (\"ASYNCHRONOUS= specifier at %L must be an initialization \"\n \t\t     \"expression\", &dt->asynchronous->where);"}, {"sha": "81bf4213289328fcbe088bdd69c4356e78aa4b0c", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "patch": "@@ -199,6 +199,7 @@ match gfc_match_literal_constant (gfc_expr **, int);\n /* expr.c -- FIXME: this one should be eliminated by moving the\n    matcher to matchexp.c and a call to a new function in expr.c that\n    only makes sure the init expr. is valid.  */\n+gfc_try gfc_reduce_init_expr (gfc_expr *expr);\n match gfc_match_init_expr (gfc_expr **);\n \n /* array.c.  */"}, {"sha": "5d4dd1034becb12a7c37d64e740e1f303e6d6f03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "patch": "@@ -1,4 +1,9 @@\n-2008-10-16  Mikael Morin  <mikael.morin@tele2.fr>\n+2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+\tPR fortran/35840\n+\t* gfortran.dg/write_check4.f90: New test.\n+\n+2008-10-31  Mikael Morin  <mikael.morin@tele2.fr>\n \n \tPR fortran/35820\n \t* gfortran.dg/nested_forall_1.f: New test."}, {"sha": "f418ba8fbf0c9b1d9a6326b7634bf8839b7f6c43", "filename": "gcc/testsuite/gfortran.dg/write_check4.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwrite_check4.f90?ref=d3d0b9e07f69bd21120ebdeac22d4e197b7dfd1c", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+!\n+! PR fortran/35840 \n+!\n+! The asynchronous specifier for a data transfer statement shall be \n+! an initialization expression\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+  character(2) :: no\n+  no = \"no\"\n+  open (unit=10, asynchronous = no)              ! Ok, it isn't a transfer stmt\n+  write(*,*, asynchronous=\"Y\"//\"E\"//trim(\"S  \")) ! Ok, it is an init expr\n+  write(*,*, asynchronous=no)  ! { dg-error \"must be an initialization expression\" } \n+  read (*,*, asynchronous=\"Y\"//\"e\"//trim(\"S  \"))\n+  read (*,*, asynchronous=no)  ! { dg-error \"must be an initialization expression\" }\n+end"}]}