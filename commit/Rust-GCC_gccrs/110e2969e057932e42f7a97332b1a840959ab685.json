{"sha": "110e2969e057932e42f7a97332b1a840959ab685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwZTI5NjllMDU3OTMyZTQyZjdhOTczMzJiMWE4NDA5NTlhYjY4NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T14:46:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T14:46:15Z"}, "message": "[multiple changes]\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (Get_Cursor_Type): Moved to sem_util\n\tfrom sem_ch13, for use elsewhere.\n\t* sem_ch13.adb (Get_Cursor_Type): Moved to sem_util.\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Set properly the\n\tcursor type on the loop variable when the iteration is over o\n\tformal container.\n\n2014-02-19  Vincent Celier  <celier@adacore.com>\n\n\t* prj-conf.adb (Add_Default_GNAT_Naming_Scheme): Add declaration\n\tfor an empty Target (Check_Target): Never fail when an empty\n\ttarget is declared in the configuration project.\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Check_Arg_Is_Local_Name): Argument is local if\n\tthe pragma comes fron a predicate aspect and the context is a\n\trecord declaration within the scope that declares the type.\n\n2014-02-19  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Minor clarifications.\n\t* expander.adb, sem_aggr.adb: Add comments.\n\nFrom-SVN: r207903", "tree": {"sha": "f5fca4a10559895dc76a6a3ab95035437587620d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5fca4a10559895dc76a6a3ab95035437587620d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/110e2969e057932e42f7a97332b1a840959ab685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110e2969e057932e42f7a97332b1a840959ab685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/110e2969e057932e42f7a97332b1a840959ab685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110e2969e057932e42f7a97332b1a840959ab685/comments", "author": null, "committer": null, "parents": [{"sha": "322913f8769f6c7cac6a992debb430757e0e0c05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322913f8769f6c7cac6a992debb430757e0e0c05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/322913f8769f6c7cac6a992debb430757e0e0c05"}], "stats": {"total": 303, "additions": 194, "deletions": 109}, "files": [{"sha": "55b0724a2115267b8fee4e7fce851c6af2ab4b97", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -1,3 +1,29 @@\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.ads, sem_util.adb (Get_Cursor_Type): Moved to sem_util\n+\tfrom sem_ch13, for use elsewhere.\n+\t* sem_ch13.adb (Get_Cursor_Type): Moved to sem_util.\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Set properly the\n+\tcursor type on the loop variable when the iteration is over o\n+\tformal container.\n+\n+2014-02-19  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-conf.adb (Add_Default_GNAT_Naming_Scheme): Add declaration\n+\tfor an empty Target (Check_Target): Never fail when an empty\n+\ttarget is declared in the configuration project.\n+\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Check_Arg_Is_Local_Name): Argument is local if\n+\tthe pragma comes fron a predicate aspect and the context is a\n+\trecord declaration within the scope that declares the type.\n+\n+2014-02-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Minor clarifications.\n+\t* expander.adb, sem_aggr.adb: Add comments.\n+\n 2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb (Check_Arg_Is_Local_Name): For an aspect that"}, {"sha": "f6e65e7a40b75cea8f2cb5580f7058581280ceee", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -89,9 +89,12 @@ package body Expander is\n       --  Full_Analysis flag indicates whether we are performing a complete\n       --  analysis, in which case Full_Analysis = True or a pre-analysis in\n       --  which case Full_Analysis = False. See the spec of Sem for more info\n-      --  on this. Additionally, the GNATprove_Mode flag indicates that a light\n+      --  on this.\n+\n+      --  Additionally, the GNATprove_Mode flag indicates that a light\n       --  expansion for formal verification should be used. This expansion is\n-      --  never done inside generics.\n+      --  never done inside generics, because otherwise, this breaks the name\n+      --  resolution mechanism for generic instances\n \n       --  The second reason for the Expander_Active flag to be False is that\n       --  we are performing a pre-analysis. During pre-analysis all expansion"}, {"sha": "b93d220f4db5c66a70860e30a1f1a203e6429418", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -17523,8 +17523,12 @@ is specifically authorized by the Ada Reference Manual\n This child of @code{Ada.Containers} defines a modified version of the\n Ada 2005 container for doubly linked lists, meant to facilitate formal\n verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014. Note that the API of this unit may\n-be subject to incompatible changes as SPARK 2014 evolves.\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n \n @node Ada.Containers.Formal_Hashed_Maps (a-cfhama.ads)\n @section @code{Ada.Containers.Formal_Hashed_Maps} (@file{a-cfhama.ads})\n@@ -17535,8 +17539,12 @@ be subject to incompatible changes as SPARK 2014 evolves.\n This child of @code{Ada.Containers} defines a modified version of the\n Ada 2005 container for hashed maps, meant to facilitate formal\n verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014. Note that the API of this unit may\n-be subject to incompatible changes as SPARK 2014 evolves.\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n \n @node Ada.Containers.Formal_Hashed_Sets (a-cfhase.ads)\n @section @code{Ada.Containers.Formal_Hashed_Sets} (@file{a-cfhase.ads})\n@@ -17547,8 +17555,12 @@ be subject to incompatible changes as SPARK 2014 evolves.\n This child of @code{Ada.Containers} defines a modified version of the\n Ada 2005 container for hashed sets, meant to facilitate formal\n verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014. Note that the API of this unit may\n-be subject to incompatible changes as SPARK 2014 evolves.\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n \n @node Ada.Containers.Formal_Ordered_Maps (a-cforma.ads)\n @section @code{Ada.Containers.Formal_Ordered_Maps} (@file{a-cforma.ads})\n@@ -17559,8 +17571,12 @@ be subject to incompatible changes as SPARK 2014 evolves.\n This child of @code{Ada.Containers} defines a modified version of the\n Ada 2005 container for ordered maps, meant to facilitate formal\n verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014. Note that the API of this unit may\n-be subject to incompatible changes as SPARK 2014 evolves.\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n \n @node Ada.Containers.Formal_Ordered_Sets (a-cforse.ads)\n @section @code{Ada.Containers.Formal_Ordered_Sets} (@file{a-cforse.ads})\n@@ -17571,8 +17587,12 @@ be subject to incompatible changes as SPARK 2014 evolves.\n This child of @code{Ada.Containers} defines a modified version of the\n Ada 2005 container for ordered sets, meant to facilitate formal\n verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014. Note that the API of this unit may\n-be subject to incompatible changes as SPARK 2014 evolves.\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n \n @node Ada.Containers.Formal_Vectors (a-cofove.ads)\n @section @code{Ada.Containers.Formal_Vectors} (@file{a-cofove.ads})\n@@ -17583,8 +17603,12 @@ be subject to incompatible changes as SPARK 2014 evolves.\n This child of @code{Ada.Containers} defines a modified version of the\n Ada 2005 container for vectors, meant to facilitate formal\n verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014. Note that the API of this unit may\n-be subject to incompatible changes as SPARK 2014 evolves.\n+unit is compatible with SPARK 2014.\n+\n+Note that although this container was designed with formal verification\n+in mind, it may well be generally useful in that it is a simplified more\n+efficient version than the one defined in the standard. In particular it\n+does not have the complex overhead required to detect cursor tampering.\n \n @node Ada.Command_Line.Environment (a-colien.ads)\n @section @code{Ada.Command_Line.Environment} (@file{a-colien.ads})"}, {"sha": "8d35fe25b8d75ed0056d1c7c731c4ca5c21c8d36", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -202,6 +202,10 @@ package body Prj.Conf is\n             Create_Attribute (Name_Library_Auto_Init_Supported, \"false\");\n          end if;\n \n+         --  Declare an empty target\n+\n+         Create_Attribute (Name_Target, \"\");\n+\n          --  Setup Ada support (Ada is the default language here, since this\n          --  is only called when no config file existed initially, ie for\n          --  gnatmake).\n@@ -574,7 +578,8 @@ package body Prj.Conf is\n       OK :=\n         Target = \"\"\n           or else (Tgt_Name /= No_Name\n-                    and then Target = Get_Name_String (Tgt_Name));\n+                   and then (Length_Of_Name (Tgt_Name) = 0\n+                    or else Target = Get_Name_String (Tgt_Name)));\n \n       if not OK then\n          if Autoconf_Specified then"}, {"sha": "aeddc1f7f66c6693f8d70563e0aca61c5b2b93ea", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -455,9 +455,12 @@ package body Sem_Aggr is\n       end if;\n \n       --  This is really expansion activity, so make sure that expansion is\n-      --  on and is allowed. In GNATprove mode, we also want check flags to be\n-      --  added in the tree, so that the formal verification can rely on those\n-      --  to be present.\n+      --  on and is allowed. In GNATprove mode, we also want check flags to\n+      --  be added in the tree, so that the formal verification can rely on\n+      --  those to be present. In GNATprove mode for formal verification, some\n+      --  treatment typically only done during expansion needs to be performed\n+      --  on the tree, but it should not be applied inside generics. Otherwise,\n+      --  this breaks the name resolution mechanism for generic instances.\n \n       if not Expander_Active\n         and (Inside_A_Generic or not Full_Analysis or not GNATprove_Mode)"}, {"sha": "7e2600f6a6c3f587ec73b43a462c80fe56685eeb", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -128,12 +128,6 @@ package body Sem_Ch13 is\n    --  Uint value. If the value is inappropriate, then error messages are\n    --  posted as required, and a value of No_Uint is returned.\n \n-   function Get_Cursor_Type\n-     (Aspect : Node_Id;\n-      Typ    : Entity_Id) return Entity_Id;\n-   --  Find Cursor type in scope of Typ, by locating primitive operation First.\n-   --  For use in resolving the other primitive operations of an Iterable type.\n-\n    function Is_Operational_Item (N : Node_Id) return Boolean;\n    --  A specification for a stream attribute is allowed before the full type\n    --  is declared, as explained in AI-00137 and the corrigendum. Attributes\n@@ -9756,81 +9750,6 @@ package body Sem_Ch13 is\n       end if;\n    end Get_Alignment_Value;\n \n-   ---------------------\n-   -- Get_Cursor_Type --\n-   ---------------------\n-\n-   function Get_Cursor_Type\n-     (Aspect : Node_Id;\n-      Typ    : Entity_Id) return Entity_Id\n-   is\n-      Assoc    : Node_Id;\n-      Func     : Entity_Id;\n-      First_Op : Entity_Id;\n-      Cursor   : Entity_Id;\n-\n-   begin\n-      --  If error already detected, return\n-\n-      if Error_Posted (Aspect) then\n-         return Any_Type;\n-      end if;\n-\n-      --  The cursor type for an Iterable aspect is the return type of a\n-      --  non-overloaded First primitive operation. Locate association for\n-      --  First.\n-\n-      Assoc := First (Component_Associations (Expression (Aspect)));\n-      First_Op  := Any_Id;\n-      while Present (Assoc) loop\n-         if Chars (First (Choices (Assoc))) = Name_First then\n-            First_Op := Expression (Assoc);\n-            exit;\n-         end if;\n-\n-         Next (Assoc);\n-      end loop;\n-\n-      if First_Op = Any_Id then\n-         Error_Msg_N (\"aspect Iterable must specify First operation\", Aspect);\n-         return Any_Type;\n-      end if;\n-\n-      Cursor := Any_Type;\n-\n-      --  Locate function with desired name and profile in scope of type\n-\n-      Func := First_Entity (Scope (Typ));\n-      while Present (Func) loop\n-         if Chars (Func) = Chars (First_Op)\n-           and then Ekind (Func) = E_Function\n-           and then Present (First_Formal (Func))\n-           and then Etype (First_Formal (Func)) = Typ\n-           and then No (Next_Formal (First_Formal (Func)))\n-         then\n-            if Cursor /= Any_Type then\n-               Error_Msg_N\n-                 (\"Operation First for iterable type must be unique\", Aspect);\n-               return Any_Type;\n-\n-            else\n-               Cursor :=  Etype (Func);\n-            end if;\n-         end if;\n-\n-         Next_Entity (Func);\n-      end loop;\n-\n-      --  If not found, no way to resolve remaining primitives.\n-\n-      if Cursor = Any_Type then\n-         Error_Msg_N\n-           (\"No legal primitive operation First for Iterable type\", Aspect);\n-      end if;\n-\n-      return Cursor;\n-   end Get_Cursor_Type;\n-\n    -------------------------------------\n    -- Inherit_Aspects_At_Freeze_Point --\n    -------------------------------------"}, {"sha": "c66b41603bfab389e8cdf1bd0d1ac27a6b628d32", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -1807,7 +1807,10 @@ package body Sem_Ch5 is\n          end if;\n       end if;\n \n-      Typ := Etype (Iter_Name);\n+      --  Get base type of container, for proper retrieval of Cursor type\n+      --  and primitive operations.\n+\n+      Typ := Base_Type (Etype (Iter_Name));\n \n       if Is_Array_Type (Typ) then\n          if Of_Present (N) then\n@@ -1918,17 +1921,25 @@ package body Sem_Ch5 is\n \n             --  The result type of Iterate function is the classwide type of\n             --  the interface parent. We need the specific Cursor type defined\n-            --  in the container package.\n+            --  in the container package. We obtain it by name for a predefined\n+            --  container, or through the Iterable aspect for a formal one.\n \n-            Ent := First_Entity (Scope (Typ));\n-            while Present (Ent) loop\n-               if Chars (Ent) = Name_Cursor then\n-                  Set_Etype (Def_Id, Etype (Ent));\n-                  exit;\n-               end if;\n+            if Has_Aspect (Typ, Aspect_Iterable) then\n+               Set_Etype (Def_Id,\n+                 Get_Cursor_Type\n+                  (Parent (Find_Value_Of_Aspect (Typ, Aspect_Iterable)), Typ));\n \n-               Next_Entity (Ent);\n-            end loop;\n+            else\n+               Ent := First_Entity (Scope (Typ));\n+               while Present (Ent) loop\n+                  if Chars (Ent) = Name_Cursor then\n+                     Set_Etype (Def_Id, Etype (Ent));\n+                     exit;\n+                  end if;\n+\n+                  Next_Entity (Ent);\n+               end loop;\n+            end if;\n          end if;\n       end if;\n "}, {"sha": "1b102b43a9a63d9742c897e365d9e031d8dcdb43", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -3898,6 +3898,18 @@ package body Sem_Prag is\n                then\n                   OK := True;\n \n+               --  If the aspect is a predicate (possibly others ???)  and the\n+               --  context is a record type, this is a discriminant expression\n+               --  within a type declaration, that freezes the predicated\n+               --  subtype.\n+\n+               elsif From_Aspect_Specification (N)\n+                 and then Prag_Id = Pragma_Predicate\n+                 and then Ekind (Current_Scope) = E_Record_Type\n+                 and then Scop = Scope (Current_Scope)\n+               then\n+                  OK := True;\n+\n                --  Default case, just check that the pragma occurs in the scope\n                --  of the entity denoted by the name.\n "}, {"sha": "d21d6488b52c2c876498a3cfd93fa2f0a06f0f02", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -6387,6 +6387,80 @@ package body Sem_Util is\n       return Proper_Body (Unit (Library_Unit (N)));\n    end Get_Body_From_Stub;\n \n+   ---------------------\n+   -- Get_Cursor_Type --\n+   ---------------------\n+\n+   function Get_Cursor_Type\n+     (Aspect : Node_Id;\n+      Typ    : Entity_Id) return Entity_Id\n+   is\n+      Assoc    : Node_Id;\n+      Func     : Entity_Id;\n+      First_Op : Entity_Id;\n+      Cursor   : Entity_Id;\n+\n+   begin\n+      --  If error already detected, return\n+\n+      if Error_Posted (Aspect) then\n+         return Any_Type;\n+      end if;\n+\n+      --  The cursor type for an Iterable aspect is the return type of a\n+      --  non-overloaded First primitive operation. Locate association for\n+      --  First.\n+\n+      Assoc := First (Component_Associations (Expression (Aspect)));\n+      First_Op  := Any_Id;\n+      while Present (Assoc) loop\n+         if Chars (First (Choices (Assoc))) = Name_First then\n+            First_Op := Expression (Assoc);\n+            exit;\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+\n+      if First_Op = Any_Id then\n+         Error_Msg_N (\"aspect Iterable must specify First operation\", Aspect);\n+         return Any_Type;\n+      end if;\n+\n+      Cursor := Any_Type;\n+\n+      --  Locate function with desired name and profile in scope of type\n+\n+      Func := First_Entity (Scope (Typ));\n+      while Present (Func) loop\n+         if Chars (Func) = Chars (First_Op)\n+           and then Ekind (Func) = E_Function\n+           and then Present (First_Formal (Func))\n+           and then Etype (First_Formal (Func)) = Typ\n+           and then No (Next_Formal (First_Formal (Func)))\n+         then\n+            if Cursor /= Any_Type then\n+               Error_Msg_N\n+                 (\"Operation First for iterable type must be unique\", Aspect);\n+               return Any_Type;\n+\n+            else\n+               Cursor :=  Etype (Func);\n+            end if;\n+         end if;\n+\n+         Next_Entity (Func);\n+      end loop;\n+\n+      --  If not found, no way to resolve remaining primitives.\n+\n+      if Cursor = Any_Type then\n+         Error_Msg_N\n+           (\"No legal primitive operation First for Iterable type\", Aspect);\n+      end if;\n+\n+      return Cursor;\n+   end Get_Cursor_Type;\n    -------------------------------\n    -- Get_Default_External_Name --\n    -------------------------------"}, {"sha": "c6d078c70ab9caa79b7f13a713c33daa2fdcea58", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e2969e057932e42f7a97332b1a840959ab685/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=110e2969e057932e42f7a97332b1a840959ab685", "patch": "@@ -777,6 +777,14 @@ package Sem_Util is\n    function Get_Body_From_Stub (N : Node_Id) return Node_Id;\n    --  Return the body node for a stub (subprogram or package)\n \n+   function Get_Cursor_Type\n+     (Aspect : Node_Id;\n+      Typ    : Entity_Id) return Entity_Id;\n+   --  Find Cursor type in scope of formal container Typ, by locating primitive\n+   --  operation First.\n+   --  For use in resolving the other primitive operations of an Iterable type\n+   --  and expanding loops and quantified expressions over formal containers.\n+\n    function Get_Default_External_Name (E : Node_Or_Entity_Id) return Node_Id;\n    --  This is used to construct the string literal node representing a\n    --  default external name, i.e. one that is constructed from the name of an"}]}