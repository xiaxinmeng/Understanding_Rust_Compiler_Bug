{"sha": "6ecbf3001a087e0b12b4361260a6949d77361316", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVjYmYzMDAxYTA4N2UwYjEyYjQzNjEyNjBhNjk0OWQ3NzM2MTMxNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-09T16:50:00Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-09T16:50:00Z"}, "message": "Merge push patterns for memory/nonmemory\n\nFrom-SVN: r8048", "tree": {"sha": "f4e0b89c9cf4b31c9fab488c527dbff2f8164c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4e0b89c9cf4b31c9fab488c527dbff2f8164c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ecbf3001a087e0b12b4361260a6949d77361316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ecbf3001a087e0b12b4361260a6949d77361316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ecbf3001a087e0b12b4361260a6949d77361316", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ecbf3001a087e0b12b4361260a6949d77361316/comments", "author": null, "committer": null, "parents": [{"sha": "68dab18d533159aea711dc362bbee3ebd263a8c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68dab18d533159aea711dc362bbee3ebd263a8c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68dab18d533159aea711dc362bbee3ebd263a8c5"}], "stats": {"total": 248, "additions": 120, "deletions": 128}, "files": [{"sha": "986f7f373031c750b10773eb32dc68b2f2a0171f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 120, "deletions": 128, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ecbf3001a087e0b12b4361260a6949d77361316/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ecbf3001a087e0b12b4361260a6949d77361316/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6ecbf3001a087e0b12b4361260a6949d77361316", "patch": "@@ -1064,15 +1064,15 @@\n   \"\"\n   \"\n {\n-  /* Special case memory->memory moves */\n+  /* Special case memory->memory moves and pushes */\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n+      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], SFmode)))\n     {\n       rtx (*genfunc) PROTO((rtx, rtx));\n       if (push_operand (operands[0], SFmode))\n-\tgenfunc = (TARGET_386) ? gen_movsf_push386 : gen_movsf_push486_mem;\n+\tgenfunc = (TARGET_386) ? gen_movsf_push386 : gen_movsf_push486;\n       else\n \tgenfunc = gen_movsf_mem;\n \n@@ -1110,8 +1110,9 @@\n }\")\n \n (define_insn \"movsf_push486\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:SF 1 \"general_operand\" \"rF,f,m\"))\n+   (clobber (match_scratch:SI 2 \"=X,X,r\"))]\n   \"!TARGET_386\"\n   \"*\n {\n@@ -1134,18 +1135,15 @@\n         output_asm_insn (AS1 (fst%S0,%0), xops);\n       RET;\n     }\n-  return AS1 (push%L1,%1);\n-}\")\n \n-(define_insn \"movsf_push486_mem\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n-\t(match_operand:SF 1 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 2 \"=r\"))]\n-  \"!TARGET_386\"\n-  \"*\n-{\n-  output_asm_insn (AS2 (mov%L2,%1,%2), operands);\n-  return AS1 (push%L2,%2);\n+  else if (GET_CODE (operands[1]) != MEM)\n+    return AS1 (push%L1,%1);\n+\n+  else\n+    {\n+      output_asm_insn (AS2 (mov%L2,%1,%2), operands);\n+      return AS1 (push%L2,%2);\n+    }\n }\")\n \n ;; Special memory<->memory pattern that combine will recreate from the\n@@ -1237,15 +1235,15 @@\n   \"\"\n   \"\n {\n-  /* Special case memory->memory moves */\n+  /* Special case memory->memory moves and pushes */\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n+      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], DFmode)))\n     {\n       rtx (*genfunc) PROTO((rtx, rtx));\n       if (push_operand (operands[0], DFmode))\n-\tgenfunc = (TARGET_386) ? gen_movdf_push386 : gen_movdf_push486_mem;\n+\tgenfunc = (TARGET_386) ? gen_movdf_push386 : gen_movdf_push486;\n       else\n \tgenfunc = gen_movdf_mem;\n \n@@ -1282,8 +1280,10 @@\n }\")\n \n (define_insn \"movdf_push486\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:DF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n+\t(match_operand:DF 1 \"general_operand\" \"rF,f,o,o\"))\n+   (clobber (match_scratch:SI 2 \"=X,X,&r,&r\"))\n+   (clobber (match_scratch:SI 3 \"=X,X,&r,X\"))]\n   \"!TARGET_386\"\n   \"*\n {\n@@ -1304,42 +1304,37 @@\n \n       RET;\n     }\n-  else\n-    return output_move_double (operands);\n-}\")\n-\n-(define_insn \"movdf_push486_mem\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:DF 1 \"general_operand\" \"o,o\"))\n-   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n-   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n-  \"!TARGET_386\"\n-  \"*\n-{\n-  rtx low[1], high[1], xop[4];\n \n-  split_di (&operands[1], 1, low, high);\n-  xop[0] = operands[2];\n-  xop[1] = operands[3];\n-  xop[2] = high[0];\n-  xop[3] = low[0];\n+  else if (GET_CODE (operands[1]) != MEM)\n+    return output_move_double (operands);\n \n-  if (GET_CODE (operands[3]) == REG)\n-    {\t\t\t\t/* 2 scratch registers available */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%1), xop);\n-    }\n   else\n-    {\t\t\t\t/* 1 scratch register */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-    }\n+    {\n+      rtx low[1], high[1], xop[4];\n+\n+      split_di (&operands[1], 1, low, high);\n+      xop[0] = operands[2];\n+      xop[1] = operands[3];\n+      xop[2] = high[0];\n+      xop[3] = low[0];\n+\n+      if (GET_CODE (operands[3]) == REG)\n+\t{\t\t\t/* 2 scratch registers available */\n+\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%1), xop);\n+\t}\n+      else\n+\t{\t\t\t/* 1 scratch register */\n+\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t}\n \n-  RET;\n+      RET;\n+    }\n }\")\n \n (define_insn \"movdf_mem\"\n@@ -1453,15 +1448,15 @@\n   \"\"\n   \"\n {\n-  /* Special case memory->memory moves */\n+  /* Special case memory->memory moves and pushes */\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n+      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], XFmode)))\n     {\n       rtx (*genfunc) PROTO((rtx, rtx));\n       if (push_operand (operands[0], XFmode))\n-\tgenfunc = (TARGET_386) ? gen_movxf_push386 : gen_movxf_push486_mem;\n+\tgenfunc = (TARGET_386) ? gen_movxf_push386 : gen_movxf_push486;\n       else\n \tgenfunc = gen_movxf_mem;\n \n@@ -1496,8 +1491,10 @@\n  }\")\n \n (define_insn \"movxf_push486\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n- \t(match_operand:XF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<,<,<\")\n+ \t(match_operand:XF 1 \"general_operand\" \"rF,f,o,o\"))\n+   (clobber (match_scratch:SI 2 \"=X,X,&r,&r\"))\n+   (clobber (match_scratch:SI 3 \"=X,X,&r,X\"))]\n   \"!TARGET_386\"\n   \"*\n {\n@@ -1516,46 +1513,41 @@\n \n       RET;\n     }\n-  else\n-    return output_move_double (operands);\n- }\")\n \n-(define_insn \"movxf_push486_mem\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:XF 1 \"memory_operand\" \"o,o\"))\n-   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n-   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n-  \"!TARGET_386\"\n-  \"*\n-{\n-  rtx xop[5];\n-\n-  xop[0] = operands[2];\n-  xop[1] = operands[3];\n-  xop[2] = adj_offsettable_operand (operands[1], 8);\n-  xop[3] = adj_offsettable_operand (operands[1], 4);\n-  xop[4] = operands[1];\n+  else if (GET_CODE (operands[1]) != MEM)\n+    return output_move_double (operands);\n \n-  if (GET_CODE (operands[3]) == REG)\n-    {\t\t\t\t/* 2 scratch registers available */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%1), xop);\n-      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-    }\n   else\n-    {\t\t\t\t/* 1 scratch register */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-    }\n+    {\n+      rtx xop[5];\n+\n+      xop[0] = operands[2];\n+      xop[1] = operands[3];\n+      xop[2] = adj_offsettable_operand (operands[1], 8);\n+      xop[3] = adj_offsettable_operand (operands[1], 4);\n+      xop[4] = operands[1];\n+\n+      if (GET_CODE (operands[3]) == REG)\n+\t{\t\t\t/* 2 scratch registers available */\n+\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%1), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t}\n+      else\n+\t{\t\t\t/* 1 scratch register */\n+\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t}\n \n-  RET;\n+      RET;\n+    }\n }\")\n \n (define_insn \"movxf_mem\"\n@@ -1675,15 +1667,15 @@\n   \"\"\n   \"\n {\n-  /* Special case memory->memory moves */\n+  /* Special case memory->memory moves and pushes */\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n+      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], DImode)))\n     {\n       rtx (*genfunc) PROTO((rtx, rtx));\n       if (push_operand (operands[0], DImode))\n-\tgenfunc = (TARGET_386) ? gen_movdi_push386 : gen_movdi_push486_mem;\n+\tgenfunc = (TARGET_386) ? gen_movdi_push386 : gen_movdi_push486;\n       else\n \tgenfunc = gen_movdi_mem;\n \n@@ -1699,43 +1691,43 @@\n   \"* return output_move_double (operands);\")\n \n (define_insn \"movdi_push486\"\n-  [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n-\t(match_operand:DI 1 \"nonmemory_operand\" \"riF\"))]\n-  \"!TARGET_386\"\n-  \"* return output_move_double (operands);\")\n-\n-(define_insn \"movdi_push486_mem\"\n-  [(set (match_operand:DI 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:DI 1 \"memory_operand\" \"o,o\"))\n-   (clobber (match_scratch:SI 2 \"=&r,=&r\"))\n-   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n+  [(set (match_operand:DI 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:DI 1 \"general_operand\" \"riF,o,o\"))\n+   (clobber (match_scratch:SI 2 \"=X,&r,=&r\"))\n+   (clobber (match_scratch:SI 3 \"=X,&r,X\"))]\n   \"!TARGET_386\"\n   \"*\n {\n-  rtx low[1], high[1], xop[4];\n-\n-  split_di (&operands[1], 1, low, high);\n-  xop[0] = operands[2];\n-  xop[1] = operands[3];\n-  xop[2] = high[0];\n-  xop[3] = low[0];\n+  if (GET_CODE (operands[1]) != MEM)\n+    return output_move_double (operands);\n \n-  if (GET_CODE (operands[3]) == REG)\n-    {\t\t\t\t/* 2 scratch registers available */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%1), xop);\n-    }\n   else\n-    {\t\t\t\t/* 1 scratch register */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-      output_asm_insn (AS1 (push%L0,%0), xop);\n-    }\n+    {\n+      rtx low[1], high[1], xop[4];\n+\n+      split_di (&operands[1], 1, low, high);\n+      xop[0] = operands[2];\n+      xop[1] = operands[3];\n+      xop[2] = high[0];\n+      xop[3] = low[0];\n+\n+      if (GET_CODE (operands[3]) == REG)\n+\t{\t\t\t/* 2 scratch registers available */\n+\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%1), xop);\n+\t}\n+      else\n+\t{\t\t\t/* 1 scratch register */\n+\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t  output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n+\t  output_asm_insn (AS1 (push%L0,%0), xop);\n+\t}\n \n-  RET;\n+      RET;\n+    }\n }\")\n \n (define_insn \"movdi_mem\""}]}