{"sha": "e4cd0d726ed65e34cfcb8cd6a265095d89983520", "node_id": "C_kwDOANBUbNoAKGU0Y2QwZDcyNmVkNjVlMzRjZmNiOGNkNmEyNjUwOTVkODk5ODM1MjA", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-02-17T15:40:01Z"}, "committer": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-03-30T11:52:30Z"}, "message": "libproc_macro: Add TokenStream implementation\n\nAdd the TokenStream rust type implementation to libproc_macro. Also\nimplement IntoIter structure to iterator over a TokenStream.\n\nChangeLog:\n\n\t* librust/proc_macro/rust/bridge.rs: Add group and token_stream\n\tmodules.\n\t* librust/proc_macro/rust/group.rs: Add group internal\n\trepresentation.\n\t* librust/proc_macro/rust/lib.rs: Add TokenStream\n\timplementation.\n\t* librust/proc_macro/rust/literal.rs: Make internal\n\timplementation visible in the whole crate.\n\t* librust/proc_macro/rust/token_stream.rs: Implement IntoIter.\n\t* librust/proc_macro/rust/bridge/group.rs: Add Group internals.\n\t* librust/proc_macro/rust/bridge/token_stream.rs: Add\n\tTokenStream internals.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "7c7b2e9d06bb2b455f4061da2ff7c2b6d378f8e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c7b2e9d06bb2b455f4061da2ff7c2b6d378f8e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4cd0d726ed65e34cfcb8cd6a265095d89983520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4cd0d726ed65e34cfcb8cd6a265095d89983520", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4cd0d726ed65e34cfcb8cd6a265095d89983520", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4cd0d726ed65e34cfcb8cd6a265095d89983520/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eedfefb49d1aa8750c52a4893149207cc6ba5dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eedfefb49d1aa8750c52a4893149207cc6ba5dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eedfefb49d1aa8750c52a4893149207cc6ba5dbc"}], "stats": {"total": 103, "additions": 89, "deletions": 14}, "files": [{"sha": "eb7f854bd2bff9ef8faaed3e3234c01c08214fb0", "filename": "librust/proc_macro/rust/bridge.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fbridge.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fbridge.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fbridge.rs?ref=e4cd0d726ed65e34cfcb8cd6a265095d89983520", "patch": "@@ -1,7 +1,9 @@\n+pub mod group;\n pub mod ident;\n pub mod literal;\n pub mod punct;\n pub mod span;\n+pub mod token_stream;\n \n extern \"C\" {\n     fn bridge__is_available() -> bool;"}, {"sha": "6590f8952fa0c3beb40d165f6f3d91f46e341124", "filename": "librust/proc_macro/rust/bridge/group.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fbridge%2Fgroup.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fbridge%2Fgroup.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fbridge%2Fgroup.rs?ref=e4cd0d726ed65e34cfcb8cd6a265095d89983520", "patch": "@@ -0,0 +1,9 @@\n+use bridge;\n+use Delimiter;\n+\n+#[repr(C)]\n+#[derive(Clone)]\n+pub struct Group {\n+    delimiter: Delimiter,\n+    stream: bridge::token_stream::TokenStream,\n+}"}, {"sha": "307ff6bd8b43d8864358f6a02207afe853d062d7", "filename": "librust/proc_macro/rust/bridge/token_stream.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fbridge%2Ftoken_stream.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fbridge%2Ftoken_stream.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fbridge%2Ftoken_stream.rs?ref=e4cd0d726ed65e34cfcb8cd6a265095d89983520", "patch": "@@ -0,0 +1,35 @@\n+use bridge::{group::Group, ident::Ident, literal::Literal, punct::Punct};\n+\n+// TODO: There surely is a better way to achieve this. I don't like this\n+// \"duplication\" of the TokenTree enumeration. But I cannot use the public\n+// one since it's underlying types (public Group, Ident...) are not ffi safe.\n+// Flattening all those struct might be a solution.\n+#[repr(C)]\n+#[derive(Clone)]\n+pub enum TokenTree {\n+    Group(Group),\n+    Ident(Ident),\n+    Punct(Punct),\n+    Literal(Literal),\n+}\n+\n+extern \"C\" {\n+    fn TokenStream__new() -> TokenStream;\n+}\n+\n+#[repr(C)]\n+#[derive(Clone)]\n+pub struct TokenStream {\n+    pub(crate) data: *const TokenTree,\n+    pub(crate) size: u64,\n+}\n+\n+impl TokenStream {\n+    pub fn new() -> Self {\n+        unsafe { TokenStream__new() }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        0 == self.size\n+    }\n+}"}, {"sha": "6512982cc3205df1331ce4dd2e5aa2d6ab63124a", "filename": "librust/proc_macro/rust/group.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fgroup.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fgroup.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fgroup.rs?ref=e4cd0d726ed65e34cfcb8cd6a265095d89983520", "patch": "@@ -1,8 +1,10 @@\n+use bridge;\n use std::fmt;\n use Span;\n use TokenStream;\n \n /// Describes how a sequence of token trees is delimited.\n+#[repr(C)]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Delimiter {\n     /// The sequence is delimited by a parenthesis `(...)`.\n@@ -17,9 +19,7 @@ pub enum Delimiter {\n \n /// A delimited token stream.\n #[derive(Clone)]\n-pub struct Group {\n-    // Internal implementation details\n-}\n+pub struct Group(pub(crate) bridge::group::Group);\n \n impl Group {\n     /// Creates a new `Group`."}, {"sha": "31aa6ea7c75c2f59c68f065f8dbe26e04f86a326", "filename": "librust/proc_macro/rust/lib.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Flib.rs?ref=e4cd0d726ed65e34cfcb8cd6a265095d89983520", "patch": "@@ -34,6 +34,19 @@ pub enum TokenTree {\n     Literal(Literal),\n }\n \n+type InternalTokenTree = bridge::token_stream::TokenTree;\n+\n+impl From<InternalTokenTree> for TokenTree {\n+    fn from(value: InternalTokenTree) -> Self {\n+        match value {\n+            InternalTokenTree::Group(g) => TokenTree::Group(Group(g)),\n+            InternalTokenTree::Ident(i) => TokenTree::Ident(Ident(i)),\n+            InternalTokenTree::Punct(p) => TokenTree::Punct(Punct(p)),\n+            InternalTokenTree::Literal(l) => TokenTree::Literal(Literal(l)),\n+        }\n+    }\n+}\n+\n impl TokenTree {\n     /// Get the [`Span`] for this TokenTree.\n     pub fn span(&self) -> Span {\n@@ -124,21 +137,19 @@ impl error::Error for LexError {}\n /// is both the input and the output of `#[proc_macro]`,\n /// `#[proc_macro_attribute]` and `#[proc_macro_derive]` definitions.\n #[derive(Clone)]\n-pub struct TokenStream {\n-    // Internal implementation details\n-}\n+pub struct TokenStream(bridge::token_stream::TokenStream);\n \n impl TokenStream {\n     // TODO: Add experimental API functions for this type\n \n     /// Creates an empty `TokenStream` containing no token trees.\n     pub fn new() -> Self {\n-        todo!(\"Implement this function\")\n+        TokenStream(bridge::token_stream::TokenStream::new())\n     }\n \n     /// Checks if this `TokenStream` is empty.\n     pub fn is_empty(&self) -> bool {\n-        todo!(\"Implement this function\")\n+        self.0.is_empty()\n     }\n }\n "}, {"sha": "4011201d9986d0323b2508e41f33d5f202674602", "filename": "librust/proc_macro/rust/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fliteral.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Fliteral.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fliteral.rs?ref=e4cd0d726ed65e34cfcb8cd6a265095d89983520", "patch": "@@ -21,7 +21,7 @@ use Span;\n /// Boolean literals like `true` and `false` are `Ident`s and do not belong\n /// here.\n #[derive(Clone)]\n-pub struct Literal(bridge::literal::Literal);\n+pub struct Literal(pub(crate) bridge::literal::Literal);\n \n impl Literal {\n     // TODO: Add experimental API functions for this type"}, {"sha": "c4caf9f9ff8f80273f11e17b42429f675d6a18c4", "filename": "librust/proc_macro/rust/token_stream.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Ftoken_stream.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cd0d726ed65e34cfcb8cd6a265095d89983520/librust%2Fproc_macro%2Frust%2Ftoken_stream.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Ftoken_stream.rs?ref=e4cd0d726ed65e34cfcb8cd6a265095d89983520", "patch": "@@ -1,26 +1,40 @@\n //! Public implementation details for the `TokenStream` type, such as iterators.\n+use bridge;\n+use std::convert::TryInto;\n+\n use TokenStream;\n use TokenTree;\n \n /// An iterator over [`TokenStream`]'s [`TokenTree`]s.\n #[derive(Clone)]\n pub struct IntoIter {\n-    // Internal implementation details\n+    current: *const bridge::token_stream::TokenTree,\n+    end: *const bridge::token_stream::TokenTree,\n }\n \n impl Iterator for IntoIter {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n-        todo!(\"Implement this function\")\n+        if self.current == self.end {\n+            return None;\n+        } else {\n+            let result = self.current;\n+            self.current = unsafe { self.current.add(1) };\n+            Some(unsafe { std::ptr::read(result) }.into())\n+        }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        todo!(\"Implement this function\")\n+        // TODO: I'm not a fan of those casts, once #![feature(ptr_sub_ptr)]\n+        // is implemented we may replace this line by the following:\n+        // self.end.sub_ptr(self.current)\n+        let remaining = self.end as usize - self.current as usize;\n+        (remaining, Some(remaining))\n     }\n \n     fn count(self) -> usize {\n-        todo!(\"Implement this function\")\n+        self.end as usize - self.current as usize\n     }\n }\n \n@@ -29,6 +43,10 @@ impl IntoIterator for TokenStream {\n     type IntoIter = IntoIter;\n \n     fn into_iter(self) -> IntoIter {\n-        todo!(\"Implement this function\")\n+        let capacity = self.0.size.try_into().unwrap();\n+        IntoIter {\n+            current: self.0.data,\n+            end: unsafe { self.0.data.add(capacity) },\n+        }\n     }\n }"}]}