{"sha": "599b9f723e42b0efdf580c45bc03e12dec377edd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5YjlmNzIzZTQyYjBlZmRmNTgwYzQ1YmMwM2UxMmRlYzM3N2VkZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-13T05:12:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-13T05:12:05Z"}, "message": "compiler: compare parse methods when indexing interface types for export\n    \n    This change fixes a bug in which two interface types were being\n    incorrectly commoned (considered identical) in the initial stages of\n    writing out types to export data. The indexer does a walk to collect\n    candidates for export, inserting types into a table to eliminate\n    duplicates; as part of this process a local interface type T1 was\n    being commoned with a different interface type T2. This caused a cycle\n    in the exported type graph due to the way embedded interfaces are\n    handled.\n    \n    The fix was to add a new flag to the Type::is_identical utility\n    routine to request that interface type comparison be done by examining\n    the original parse methods, as opposed to the expanded method set,\n    then use the new flag when creating the hash map for the exporter.\n    \n    Fixes golang/go#30659.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/166638\n\nFrom-SVN: r269634", "tree": {"sha": "5d93e81f1fa20d234f29478a57f4d05cdd341756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d93e81f1fa20d234f29478a57f4d05cdd341756"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/599b9f723e42b0efdf580c45bc03e12dec377edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599b9f723e42b0efdf580c45bc03e12dec377edd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599b9f723e42b0efdf580c45bc03e12dec377edd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599b9f723e42b0efdf580c45bc03e12dec377edd/comments", "author": null, "committer": null, "parents": [{"sha": "f4390da0c537d637e6aa582f68c65bac13396196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4390da0c537d637e6aa582f68c65bac13396196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4390da0c537d637e6aa582f68c65bac13396196"}], "stats": {"total": 52, "additions": 45, "deletions": 7}, "files": [{"sha": "f3c52bfaa864058e8fcc3b8a343b5bc0fe2d710a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=599b9f723e42b0efdf580c45bc03e12dec377edd", "patch": "@@ -1,4 +1,4 @@\n-565b5cd0f49a00ca20941ea042c07ebe6ddf3553\n+946aa5ab2e82d045a2a3b2f18ba2c5b00e957c4b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "963f0bfe842c9453f9883ed16172ed92172d3e28", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=599b9f723e42b0efdf580c45bc03e12dec377edd", "patch": "@@ -60,6 +60,7 @@ class Type_hash_alias_identical\n     return type->hash_for_method(NULL,\n \t\t\t\t (Type::COMPARE_ERRORS\n \t\t\t\t  | Type::COMPARE_TAGS\n+\t\t\t\t  | Type::COMPARE_EMBEDDED_INTERFACES\n \t\t\t\t  | Type::COMPARE_ALIASES));\n   }\n };\n@@ -73,6 +74,7 @@ class Type_alias_identical\n     return Type::are_identical(t1, t2,\n \t\t\t       (Type::COMPARE_ERRORS\n \t\t\t\t| Type::COMPARE_TAGS\n+                                | Type::COMPARE_EMBEDDED_INTERFACES\n \t\t\t\t| Type::COMPARE_ALIASES),\n \t\t\t       NULL);\n   }\n@@ -295,6 +297,16 @@ Find_types_to_prepare::type(Type* type)\n   if (type->is_abstract())\n     return TRAVERSE_SKIP_COMPONENTS;\n \n+  // For interfaces make sure that embedded methods are sorted, since the\n+  // comparison function we use for indexing types relies on it (this call has\n+  // to happen before the set_type_index call below).\n+  if (type->classification() == Type::TYPE_INTERFACE)\n+    {\n+      Interface_type* it = type->interface_type();\n+      if (it != NULL)\n+        it->sort_embedded();\n+    }\n+\n   if (!this->exp_->set_type_index(type))\n     {\n       // We've already seen this type.\n@@ -408,6 +420,9 @@ Export::prepare_types(const std::vector<Named_object*>* exports,\n     {\n       if (!(*p)->is_type())\n \tcontinue;\n+      Interface_type* it = (*p)->type_value()->interface_type();\n+      if (it != NULL)\n+        it->sort_embedded();\n       this->set_type_index((*p)->type_value());\n     }\n "}, {"sha": "e9cbfd8ed1a4b241fe1554abacbf108cc9b0f80b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=599b9f723e42b0efdf580c45bc03e12dec377edd", "patch": "@@ -8808,10 +8808,19 @@ Interface_type::is_identical(const Interface_type* t, int flags) const\n   if (!this->methods_are_finalized_ || !t->methods_are_finalized_)\n     return false;\n \n+  // Consult a flag to see whether we need to compare based on\n+  // parse methods or all methods.\n+  Typed_identifier_list* methods = (((flags & COMPARE_EMBEDDED_INTERFACES) != 0)\n+\t\t\t\t      ? this->parse_methods_\n+                                      : this->all_methods_);\n+  Typed_identifier_list* tmethods = (((flags & COMPARE_EMBEDDED_INTERFACES) != 0)\n+\t\t\t\t       ? t->parse_methods_\n+\t\t\t\t       : t->all_methods_);\n+\n   // We require the same methods with the same types.  The methods\n   // have already been sorted.\n-  if (this->all_methods_ == NULL || t->all_methods_ == NULL)\n-    return this->all_methods_ == t->all_methods_;\n+  if (methods == NULL || tmethods == NULL)\n+    return methods == tmethods;\n \n   if (this->assume_identical(this, t) || t->assume_identical(t, this))\n     return true;\n@@ -8823,11 +8832,11 @@ Interface_type::is_identical(const Interface_type* t, int flags) const\n   ai.next = hold_ai;\n   this->assume_identical_ = &ai;\n \n-  Typed_identifier_list::const_iterator p1 = this->all_methods_->begin();\n+  Typed_identifier_list::const_iterator p1 = methods->begin();\n   Typed_identifier_list::const_iterator p2;\n-  for (p2 = t->all_methods_->begin(); p2 != t->all_methods_->end(); ++p1, ++p2)\n+  for (p2 = tmethods->begin(); p2 != tmethods->end(); ++p1, ++p2)\n     {\n-      if (p1 == this->all_methods_->end())\n+      if (p1 == methods->end())\n \tbreak;\n       if (p1->name() != p2->name()\n \t  || !Type::are_identical(p1->type(), p2->type(), flags, NULL))\n@@ -8836,7 +8845,7 @@ Interface_type::is_identical(const Interface_type* t, int flags) const\n \n   this->assume_identical_ = hold_ai;\n \n-  return p1 == this->all_methods_->end() && p2 == t->all_methods_->end();\n+  return p1 == methods->end() && p2 == tmethods->end();\n }\n \n // Return true if T1 and T2 are assumed to be identical during a type"}, {"sha": "07121dd4756587f43697884b0c1c2199ee965ace", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b9f723e42b0efdf580c45bc03e12dec377edd/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=599b9f723e42b0efdf580c45bc03e12dec377edd", "patch": "@@ -577,6 +577,11 @@ class Type\n   // Compare aliases: treat an alias to T as distinct from T.\n   static const int COMPARE_ALIASES = 4;\n \n+  // When comparing interface types compare the interface embedding heirarchy,\n+  // if any, rather than only comparing method sets. Useful primarily when\n+  // exporting types.\n+  static const int COMPARE_EMBEDDED_INTERFACES = 8;\n+\n   // Return true if two types are identical.  If this returns false,\n   // and REASON is not NULL, it may set *REASON.\n   static bool\n@@ -3165,6 +3170,15 @@ class Interface_type : public Type\n   methods_are_finalized() const\n   { return this->methods_are_finalized_; }\n \n+  // Sort embedded interfaces by name. Needed when we are preparing\n+  // to emit types into the export data.\n+  void\n+  sort_embedded()\n+  {\n+    if (parse_methods_ != NULL)\n+      parse_methods_->sort_by_name();\n+  }\n+\n  protected:\n   int\n   do_traverse(Traverse*);"}]}