{"sha": "bfb9dc7faa9330d05c109e8a40710b752dddea14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZiOWRjN2ZhYTkzMzBkMDVjMTA5ZThhNDA3MTBiNzUyZGRkZWExNA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-07-08T19:00:39Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-08T19:00:39Z"}, "message": "cpplib.h (struct cpp_name): Now struct cpp_string.\n\n\t* cpplib.h (struct cpp_name): Now struct cpp_string.\n\t(CPP_INT, CPP_FLOAT, CPP_NUMBER, CPP_COMMENT,\n\tCPP_HEADER_NAME): Change to type S.\n\t(struct cpp_token): Rename 'name' field to 'str'.  Add 'node'\n\tfield, a cpp_hashnode *.  All references to val.name updated\n\tto use val.str or val.node as appropriate.\n\t(struct cpp_reader): Add spec_nodes field.\n\t(cpp_idcmp): Now cpp_ideq; takes a token * and a char *.\n\n\t* cpphash.h (struct spec_nodes): New.\n\t(enum spell_type): Reorder.  Only SPELL_STRING tokens use\n\tval.str.  All references to 'spelling > SPELL_NONE' updated to\n\tmatch.\n\n\t(CPP_IN_SYSTEM_HEADER): Check pfile->buffer and\n\tpfile->buffer->inc are not NULL before dereferencing them.\n\n\t* cpplex.c (parse_name): Take a pointer to the current token,\n\tplus current position and limit as args; return the new\n\tposition; don't copy the text of a name into the string\n\tbuffer, instead call cpp_lookup and store the node pointer.\n\tIf extending a token, copy out the text of the old into a\n\tscratch buffer, append the new, look that up and store the new\n\tnode pointer.  Inline.\n\t(maybe_paste_with_next): If the result of paste is a NAME,\n\tthen look up the pasted text and store its node pointer.\n\t(lex_line): Adjust for new parse_name interface.\n\tCheck for L\"str\", L'str' using spec_nodes->n_L.\n\t(spell_token): SPELL_IDENT tokens have their spelling in\n\tval.node->name.  Handle SPELL_STRING tokens that don't have\n\tstring delimiters.\n\t(_cpp_expand_name_space,\n\t(can_paste): Check for L ## \"str\" using spec_nodes->n_L.\n\t(cpp_get_token, special_symbol): No need to call cpp_lookup.\n\t(cpp_idcmp): Now cpp_ideq; take a token * and a const char *;\n\treturn 1=equal 0=not, not a tristate.\n\n\t* cpphash.c (var_args_str): Delete.\n\t(find_param): Compare node fields directly.\n\t(is__va_args__): Use CPP_PEDANTIC.  Just compare\n\ttoken->val.node with spec_nodes->n__VA_ARGS__.\n\t(dump_funlike_macro): Don't use var_args_str.\n\n\t* cpplib.c (_cpp_check_directive): Just walk through\n\tspec_nodes->dirs comparing pointers.\n\t(get_define_node, do_pragma_poison, detect_if_not_defined,\n\tparse_ifdef): The identifier has already been looked up.\n\t(do_ifdef, do_ifndef): parse_ifdef won't return a poisoned\n\tnode.\n\t(do_if): Only call detect_if_not_defined at beginning of file.\n\t(_cpp_parse_assertion): Only copy string pointers for\n\tSPELL_STRING tokens.\n\t(pragma_dispatch): Take a node pointer and examine its name\n\tfield.\n\t(_cpp_init_stacks): Also initialize the spec_nodes structure.\n\n\t* cppinit.c (cpp_reader_init): Call _cpp_init_stacks after\n\t_cpp_init_macros.\n\t(cpp_cleanup): Free pfile->spec_nodes.  Call _cpp_cleanup_* in\n\treverse order from the corresponding _cpp_init_* routines.\n\n\t* cppexp.c (parse_number, parse_charconst, parse_defined,\n\tlex): Check val.node->type instead of calling cpp_defined.\n\tUse spec_nodes entries where appropriate.\n\n\t* fix-header.c, scan-decls.c: Update for interface changes.\n\nFrom-SVN: r34926", "tree": {"sha": "a059282fddfed885a943028a39f8275bd50d44e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a059282fddfed885a943028a39f8275bd50d44e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfb9dc7faa9330d05c109e8a40710b752dddea14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb9dc7faa9330d05c109e8a40710b752dddea14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfb9dc7faa9330d05c109e8a40710b752dddea14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb9dc7faa9330d05c109e8a40710b752dddea14/comments", "author": null, "committer": null, "parents": [{"sha": "ffc14f31599c19980371b165a7f6ad2e0a93015c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffc14f31599c19980371b165a7f6ad2e0a93015c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffc14f31599c19980371b165a7f6ad2e0a93015c"}], "stats": {"total": 599, "additions": 334, "deletions": 265}, "files": [{"sha": "67eb6fc952182a108bc8fab1945b3bffedbe58a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -1,3 +1,72 @@\n+2000-07-08  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (struct cpp_name): Now struct cpp_string.\n+\t(CPP_INT, CPP_FLOAT, CPP_NUMBER, CPP_COMMENT,\n+\tCPP_HEADER_NAME): Change to type S.\n+\t(struct cpp_token): Rename 'name' field to 'str'.  Add 'node'\n+\tfield, a cpp_hashnode *.  All references to val.name updated\n+\tto use val.str or val.node as appropriate.\n+\t(struct cpp_reader): Add spec_nodes field.\n+\t(cpp_idcmp): Now cpp_ideq; takes a token * and a char *.\n+\n+\t* cpphash.h (struct spec_nodes): New.\n+\t(enum spell_type): Reorder.  Only SPELL_STRING tokens use\n+\tval.str.  All references to 'spelling > SPELL_NONE' updated to\n+\tmatch.\n+\n+\t(CPP_IN_SYSTEM_HEADER): Check pfile->buffer and\n+\tpfile->buffer->inc are not NULL before dereferencing them.\n+\n+\t* cpplex.c (parse_name): Take a pointer to the current token,\n+\tplus current position and limit as args; return the new\n+\tposition; don't copy the text of a name into the string\n+\tbuffer, instead call cpp_lookup and store the node pointer.\n+\tIf extending a token, copy out the text of the old into a\n+\tscratch buffer, append the new, look that up and store the new\n+\tnode pointer.  Inline.\n+\t(maybe_paste_with_next): If the result of paste is a NAME,\n+\tthen look up the pasted text and store its node pointer.\n+\t(lex_line): Adjust for new parse_name interface.  \n+\tCheck for L\"str\", L'str' using spec_nodes->n_L.\n+\t(spell_token): SPELL_IDENT tokens have their spelling in\n+\tval.node->name.  Handle SPELL_STRING tokens that don't have\n+\tstring delimiters.\n+\t(_cpp_expand_name_space, \n+\t(can_paste): Check for L ## \"str\" using spec_nodes->n_L.\n+\t(cpp_get_token, special_symbol): No need to call cpp_lookup.\n+\t(cpp_idcmp): Now cpp_ideq; take a token * and a const char *;\n+\treturn 1=equal 0=not, not a tristate.\n+\n+\t* cpphash.c (var_args_str): Delete.\n+\t(find_param): Compare node fields directly.\n+\t(is__va_args__): Use CPP_PEDANTIC.  Just compare\n+\ttoken->val.node with spec_nodes->n__VA_ARGS__.\n+\t(dump_funlike_macro): Don't use var_args_str.\n+\n+\t* cpplib.c (_cpp_check_directive): Just walk through\n+\tspec_nodes->dirs comparing pointers.\n+\t(get_define_node, do_pragma_poison, detect_if_not_defined,\n+\tparse_ifdef): The identifier has already been looked up.\n+\t(do_ifdef, do_ifndef): parse_ifdef won't return a poisoned\n+\tnode.\n+\t(do_if): Only call detect_if_not_defined at beginning of file.\n+\t(_cpp_parse_assertion): Only copy string pointers for\n+\tSPELL_STRING tokens.\n+\t(pragma_dispatch): Take a node pointer and examine its name\n+\tfield.\n+\t(_cpp_init_stacks): Also initialize the spec_nodes structure.\n+\n+\t* cppinit.c (cpp_reader_init): Call _cpp_init_stacks after\n+\t_cpp_init_macros. \n+\t(cpp_cleanup): Free pfile->spec_nodes.  Call _cpp_cleanup_* in\n+\treverse order from the corresponding _cpp_init_* routines.\n+\n+\t* cppexp.c (parse_number, parse_charconst, parse_defined,\n+\tlex): Check val.node->type instead of calling cpp_defined.\n+\tUse spec_nodes entries where appropriate.\n+\n+\t* fix-header.c, scan-decls.c: Update for interface changes.\n+\n 2000-07-08  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_move): Fix conditions for"}, {"sha": "7e2c85a0e6a513a428d2d5dffb7341ac3152443f", "filename": "gcc/cppexp.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -137,10 +137,10 @@ parse_number (pfile, tok)\n      const cpp_token *tok;\n {\n   struct op op;\n-  const U_CHAR *start = tok->val.name.text;\n-  const U_CHAR *end = start + tok->val.name.len;\n+  const U_CHAR *start = tok->val.str.text;\n+  const U_CHAR *end = start + tok->val.str.len;\n   const U_CHAR *p = start;\n-  int c, i, nsuff;\n+  int c = 0, i, nsuff;\n   unsigned HOST_WIDEST_INT n = 0, nd, MAX_over_base;\n   int base = 10;\n   int overflow = 0;\n@@ -261,8 +261,8 @@ parse_charconst (pfile, tok)\n   int num_bits;\n   unsigned int width = MAX_CHAR_TYPE_SIZE, mask = MAX_CHAR_TYPE_MASK;\n   int max_chars;\n-  const U_CHAR *ptr = tok->val.name.text;\n-  const U_CHAR *end = ptr + tok->val.name.len;\n+  const U_CHAR *ptr = tok->val.str.text;\n+  const U_CHAR *end = ptr + tok->val.str.len;\n \n   int c = -1;\n \n@@ -304,8 +304,7 @@ parse_charconst (pfile, tok)\n   /* If char type is signed, sign-extend the constant.  */\n   num_bits = num_chars * width;\n       \n-  if (cpp_defined (pfile, U\"__CHAR_UNSIGNED__\",\n-\t\t   sizeof (\"__CHAR_UNSIGNED__\")-1)\n+  if (pfile->spec_nodes->n__CHAR_UNSIGNED__->type != T_VOID\n       || ((result >> (num_bits - 1)) & 1) == 0)\n     op.value = result & ((unsigned HOST_WIDEST_INT) ~0\n \t\t\t >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n@@ -345,9 +344,12 @@ parse_defined (pfile)\n   if (paren && _cpp_get_raw_token (pfile)->type != CPP_CLOSE_PAREN)\n     SYNTAX_ERROR (\"missing close paren after \\\"defined\\\"\");\n \n+  if (tok->val.node->type == T_POISON)\n+    SYNTAX_ERROR2 (\"attempt to use poisoned \\\"%s\\\"\", tok->val.node->name);\n+\n+  op.value = tok->val.node->type != T_VOID;\n   op.unsignedp = 0;\n   op.op = CPP_INT;\n-  op.value = cpp_defined (pfile, tok->val.name.text, tok->val.name.len);\n   return op;\n \n  syntax_error:\n@@ -419,16 +421,15 @@ lex (pfile, skip_evaluation)\n \tSYNTAX_ERROR2 (\"invalid character '\\\\%03o' in #if\", tok->val.aux);\n \n     case CPP_NAME:\n-      if (!cpp_idcmp (tok->val.name.text, tok->val.name.len, \"defined\"))\n+      if (tok->val.node == pfile->spec_nodes->n_defined)\n \treturn parse_defined (pfile);\n \n       op.op = CPP_INT;\n       op.unsignedp = 0;\n       op.value = 0;\n \n       if (CPP_OPTION (pfile, warn_undef) && !skip_evaluation)\n-\tcpp_warning (pfile, \"\\\"%.*s\\\" is not defined\",\n-\t\t     (int) tok->val.name.len, tok->val.name.text);\n+\tcpp_warning (pfile, \"\\\"%s\\\" is not defined\", tok->val.node->name);\n       return op;\n \n     case CPP_HASH:"}, {"sha": "c25a56bcabfd3e4ef8d3a4c8d810fdcc63bf30f6", "filename": "gcc/cpphash.c", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -61,8 +61,6 @@ static int save_expansion PARAMS((cpp_reader *, cpp_toklist *,\n static unsigned int find_param PARAMS ((const cpp_token *,\n \t\t\t\t\tconst cpp_token *));\n \n-static const unsigned char var_args_str[] = \"__VA_ARGS__\";\n-\n /* Calculate hash of a string of length LEN.  */\n unsigned int\n _cpp_calc_hash (str, len)\n@@ -131,7 +129,7 @@ cpp_lookup (pfile, name, len)\n   p = obstack_alloc (pfile->hash_ob, sizeof (cpp_hashnode) + len);\n   new = (cpp_hashnode *)p;\n   p += offsetof (cpp_hashnode, name);\n-  \n+\n   new->type = T_VOID;\n   new->length = len;\n   new->hash = hash;\n@@ -189,9 +187,7 @@ find_param (first, token)\n     if (first->type == CPP_NAME)\n       {\n \tparam++;\n-\tif (first->val.name.len == token->val.name.len\n-\t    && !memcmp (first->val.name.text, token->val.name.text,\n-\t\t\ttoken->val.name.len))\n+\tif (first->val.node == token->val.node)\n \t  return param;\n       }\n \n@@ -206,15 +202,13 @@ is__va_args__ (pfile, token)\n      cpp_reader *pfile;\n      const cpp_token *token;\n {\n-  if (!CPP_OPTION (pfile, pedantic)\n-      || token->val.name.len != sizeof (var_args_str) - 1\n-      || ustrncmp (token->val.name.text, var_args_str,\n-\t\t   sizeof (var_args_str) - 1))\n+  if (!CPP_PEDANTIC (pfile)\n+      || token->val.node != pfile->spec_nodes->n__VA_ARGS__)\n     return 0;\n \n   cpp_pedwarn_with_line (pfile, token->line, token->col,\n        \"\\\"%s\\\" is only valid in the replacement list of a function-like macro\",\n-\t\t       var_args_str);\n+\t\t       token->val.node->name);\n   return 1;\n }\n \n@@ -257,17 +251,16 @@ count_params (pfile, first, list)\n \t  if (is__va_args__ (pfile, token))\n \t    goto out;\n \n-\t  params_len += token->val.name.len + 1;\n+\t  params_len += token->val.node->length + 1;\n \t  prev_ident = 1;\n \t  list->paramc++;\n \n \t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n \t  if (find_param (first, token))\n \t    {\n \t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t\t   \"duplicate macro parameter \\\"%.*s\\\"\",\n-\t\t\t\t   (int) token->val.name.len,\n-\t\t\t\t   token->val.name.text);\n+\t\t\t\t   \"duplicate macro parameter \\\"%s\\\"\",\n+\t\t\t\t   token->val.node->name);\n \t      goto out;\n \t    }\n \t  break;\n@@ -297,19 +290,16 @@ count_params (pfile, first, list)\n \tcase CPP_ELLIPSIS:\n \t  /* Convert ISO-style var_args to named varargs by changing\n \t     the ellipsis into an identifier with name __VA_ARGS__.\n-\t     This simplifies other handling.  We can safely have its\n-\t     text outside list->namebuf because there is no reason to\n-\t     extend the size of the list's namebuf (and thus change\n-\t     the pointer) in do_define.  */\n+\t     This simplifies other handling. */\n \t  if (!prev_ident)\n \t    {\n \t      cpp_token *tok = (cpp_token *) token;\n \n \t      tok->type = CPP_NAME;\n-\t      tok->val.name.len = sizeof (var_args_str) - 1;\n-\t      tok->val.name.text = var_args_str; /* Safe.  */\n+\t      tok->val.node = pfile->spec_nodes->n__VA_ARGS__;\n \t      list->paramc++;\n-\t  \n+\t      params_len += tok->val.node->length + 1;\n+\n \t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n \t\tcpp_pedwarn (pfile,\n \t\t\t     \"C89 does not permit anon varargs macros\");\n@@ -344,9 +334,9 @@ count_params (pfile, first, list)\n       for (temp = first; temp <= token; temp++)\n \tif (temp->type == CPP_NAME)\n \t  {\n-\t    memcpy (buf, temp->val.name.text, temp->val.name.len);\n-\t    buf += temp->val.name.len;\n-\t    *buf++ = '\\0';\n+\t    /* copy null too */\n+\t    memcpy (buf, temp->val.node->name, temp->val.node->length + 1);\n+\t    buf += temp->val.node->length + 1;\n \t  }\n     }\n \n@@ -493,8 +483,8 @@ save_expansion (pfile, list, first, first_param)\n \t    return 1;\n \t}\n       ntokens++;\n-      if (token_spellings[token->type].type > SPELL_NONE)\n-\tlen += token->val.name.len;\n+      if (token_spellings[token->type].type == SPELL_STRING)\n+\tlen += token->val.str.len;\n     }\n \n   /* Allocate space to hold the tokens.  Empty expansions are stored\n@@ -553,11 +543,11 @@ save_expansion (pfile, list, first, first_param)\n \n       /* Copy the token.  */\n       *dest = *token;\n-      if (token_spellings[token->type].type > SPELL_NONE)\n+      if (token_spellings[token->type].type == SPELL_STRING)\n \t{\n-\t  memcpy (buf, token->val.name.text, token->val.name.len);\n-\t  dest->val.name.text = buf;\n-\t  buf += dest->val.name.len;\n+\t  memcpy (buf, token->val.str.text, token->val.str.len);\n+\t  dest->val.str.text = buf;\n+\t  buf += dest->val.str.len;\n \t}\n       dest++;\n     }\n@@ -664,9 +654,9 @@ dump_funlike_macro (pfile, node)\n \tCPP_PUTS(pfile, \", \", 2);\n       else if (list->flags & VAR_ARGS)\n \t{\n-\t  if (!ustrcmp (param, var_args_str))\n-\t    pfile->limit -= sizeof (var_args_str) - 1;\n-\t  CPP_PUTS (pfile, \"...\", 3);\n+\t  if (!ustrcmp (param, U\"__VA_ARGS__\"))\n+\t    pfile->limit -= sizeof (U\"__VA_ARGS__\") - 1;\n+\t  CPP_PUTS_Q (pfile, \"...\", 3);\n \t}\n       param += len + 1;\n     }"}, {"sha": "22481639a672ed3d914d6052782de24759ee6786", "filename": "gcc/cpphash.h", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -25,15 +25,15 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n typedef unsigned char U_CHAR;\n #define U (const U_CHAR *)  /* Intended use: U\"string\" */\n \n-/* Order here matters.  Those beyond SPELL_NONE store their spelling\n-   in the token list, and it's length in the token->val.name.len.  */\n+/* Tokens with SPELL_STRING store their spelling in the token list,\n+   and it's length in the token->val.name.len.  */\n enum spell_type\n {\n   SPELL_OPERATOR = 0,\n   SPELL_CHAR,\n-  SPELL_NONE,\n   SPELL_IDENT,\n-  SPELL_STRING\n+  SPELL_STRING,\n+  SPELL_NONE\n };\n \n struct token_spelling\n@@ -116,6 +116,20 @@ struct include_file\n   time_t  date;                 /* modification date of file, if known */\n };\n \n+/* Special nodes - identifiers with predefined significance.\n+   Note that the array length of dirs[] must be kept in sync with\n+   cpplib.c's dtable[].  */\n+struct spec_nodes\n+{\n+  cpp_hashnode *n_L;\t\t\t/* L\"str\" */\n+  cpp_hashnode *n_defined;\t\t/* #if defined */\n+  cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n+  cpp_hashnode *n__CHAR_UNSIGNED__;\t/* plain char is unsigned */\n+  cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n+  cpp_hashnode *dirs[19];\t\t/* 19 directives counting #sccs */\n+};\n+\n+\n /* The cmacro works like this: If it's NULL, the file is to be\n    included again.  If it's NEVER_REREAD, the file is never to be\n    included again.  Otherwise it is a macro hashnode, and the file is\n@@ -173,7 +187,9 @@ extern unsigned char _cpp_IStable[256];\n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n #define CPP_TRADITIONAL(PFILE) CPP_OPTION (PFILE, traditional)\n-#define CPP_IN_SYSTEM_HEADER(PFILE) (CPP_BUFFER (PFILE)->inc->sysp)\n+#define CPP_IN_SYSTEM_HEADER(PFILE) \\\n+  (CPP_BUFFER (PFILE) && CPP_BUFFER (PFILE)->inc \\\n+   && CPP_BUFFER (PFILE)->inc->sysp)\n #define CPP_PEDANTIC(PF) \\\n   (CPP_OPTION (PF, pedantic) && !CPP_IN_SYSTEM_HEADER (PF))\n #define CPP_WTRADITIONAL(PF) \\"}, {"sha": "0882634b90d075795b58d8c35227bbe02f930696", "filename": "gcc/cppinit.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -421,8 +421,8 @@ cpp_reader_init (pfile)\n   CPP_OPTION (pfile, pending) =\n     (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n \n-  _cpp_init_stacks (pfile);\n   _cpp_init_macros (pfile);\n+  _cpp_init_stacks (pfile);\n   _cpp_init_includes (pfile);\n }\n \n@@ -469,10 +469,13 @@ cpp_cleanup (pfile)\n   if (pfile->deps)\n     deps_free (pfile->deps);\n \n+  if (pfile->spec_nodes)\n+    free (pfile->spec_nodes);\n+\n+  _cpp_free_temp_tokens (pfile);\n+  _cpp_cleanup_includes (pfile);\n   _cpp_cleanup_stacks (pfile);\n   _cpp_cleanup_macros (pfile);\n-  _cpp_cleanup_includes (pfile);\n-  _cpp_free_temp_tokens (pfile);\n }\n \n "}, {"sha": "5b22627c461bd85ae2c29df021c59465afd97996", "filename": "gcc/cpplex.c", "status": "modified", "additions": 114, "deletions": 128, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -73,8 +73,9 @@ static const unsigned char *backslash_start PARAMS ((cpp_reader *,\n static int skip_block_comment PARAMS ((cpp_reader *));\n static int skip_line_comment PARAMS ((cpp_reader *));\n static void skip_whitespace PARAMS ((cpp_reader *, int));\n-static void parse_name PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n-static void parse_number PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n+static const U_CHAR *parse_name PARAMS ((cpp_reader *, cpp_token *,\n+\t\t\t\t   const U_CHAR *, const U_CHAR *));\n+static void parse_number PARAMS ((cpp_reader *, cpp_toklist *, cpp_string *));\n static void parse_string PARAMS ((cpp_reader *, cpp_toklist *, cpp_token *,\n \t\t\t\t  unsigned int));\n static int trigraph_ok PARAMS ((cpp_reader *, const unsigned char *));\n@@ -111,9 +112,9 @@ static void release_temp_tokens\t\tPARAMS ((cpp_reader *));\n static U_CHAR * quote_string PARAMS ((U_CHAR *, const U_CHAR *, unsigned int));\n static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n \n-#define INIT_TOKEN_NAME(list, token) \\\n-  do {(token)->val.name.len = 0; \\\n-      (token)->val.name.text = (list)->namebuf + (list)->name_used; \\\n+#define INIT_TOKEN_STR(list, token) \\\n+  do {(token)->val.str.len = 0; \\\n+      (token)->val.str.text = (list)->namebuf + (list)->name_used; \\\n   } while (0)\n \n #define VALID_SIGN(c, prevc) \\\n@@ -148,8 +149,12 @@ static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n \n /* An upper bound on the number of bytes needed to spell a token,\n    including preceding whitespace.  */\n-#define TOKEN_LEN(token) (5 + (token_spellings[(token)->type].type > \\\n-\t\t               SPELL_NONE ? (token)->val.name.len: 0))\n+#define TOKEN_SPELL(token) token_spellings[(token)->type].type\n+#define TOKEN_LEN(token) (5 + (TOKEN_SPELL(token) == SPELL_STRING\t\\\n+\t\t\t       ? (token)->val.str.len\t\t\t\\\n+\t\t\t       : (TOKEN_SPELL(token) == SPELL_IDENT\t\\\n+\t\t\t\t  ? (token)->val.node->length\t\t\\\n+\t\t\t\t  : 0)))\n \n #define T(e, s) {SPELL_OPERATOR, (const U_CHAR *) s},\n #define I(e, s) {SPELL_IDENT, s},\n@@ -443,8 +448,8 @@ _cpp_glue_header_name (pfile)\n   hdr = get_temp_token (pfile);\n   hdr->type = CPP_HEADER_NAME;\n   hdr->flags = 0;\n-  hdr->val.name.text = buf;\n-  hdr->val.name.len = len;\n+  hdr->val.str.text = buf;\n+  hdr->val.str.len = len;\n   return hdr;\n }\n \n@@ -469,8 +474,8 @@ _cpp_expand_name_space (list, len)\n       unsigned int i;\n \n       for (i = 0; i < list->tokens_used; i++)\n-\tif (token_spellings[list->tokens[i].type].type > SPELL_NONE)\n-\t  list->tokens[i].val.name.text += (list->namebuf - old_namebuf);\n+\tif (token_spellings[list->tokens[i].type].type == SPELL_STRING)\n+\t  list->tokens[i].val.str.text += (list->namebuf - old_namebuf);\n     }\n }\n \n@@ -583,10 +588,11 @@ _cpp_equiv_tokens (a, b)\n       case SPELL_NONE:\n \treturn a->val.aux == b->val.aux; /* arg_no or character.  */\n       case SPELL_IDENT:\n+\treturn a->val.node == b->val.node;\n       case SPELL_STRING:\n-\treturn (a->val.name.len == b->val.name.len\n-\t\t&& !memcmp (a->val.name.text, b->val.name.text,\n-\t\t\t    a->val.name.len));\n+\treturn (a->val.str.len == b->val.str.len\n+\t\t&& !memcmp (a->val.str.text, b->val.str.text,\n+\t\t\t    a->val.str.len));\n       }\n \n   return 0;\n@@ -611,34 +617,19 @@ _cpp_equiv_toklists (a, b)\n }\n \n /* Utility routine:\n-   Compares, in the manner of strcmp(3), the token beginning at TOKEN\n-   and extending for LEN characters to the NUL-terminated string\n-   STRING.  Typical usage:\n \n-   if (! cpp_idcmp (pfile->token_buffer + here, CPP_WRITTEN (pfile) - here,\n-                 \"inline\"))\n-     { ... }\n- */\n+   Compares, the token TOKEN to the NUL-terminated string STRING.\n+   TOKEN must be a CPP_NAME.  Returns 1 for equal, 0 for unequal.  */\n \n int\n-cpp_idcmp (token, len, string)\n-     const U_CHAR *token;\n-     size_t len;\n+cpp_ideq (token, string)\n+     const cpp_token *token;\n      const char *string;\n {\n-  size_t len2 = strlen (string);\n-  int r;\n-\n-  if ((r = memcmp (token, string, MIN (len, len2))))\n-    return r;\n-\n-  /* The longer of the two strings sorts after the shorter.  */\n-  if (len == len2)\n+  if (token->type != CPP_NAME)\n     return 0;\n-  else if (len < len2)\n-    return -1;\n-  else\n-    return 1;\n+\n+  return !ustrcmp (token->val.node->name, (const U_CHAR *)string);\n }\n \n /* Lexing algorithm.\n@@ -965,59 +956,51 @@ skip_whitespace (pfile, in_directive)\n }\n \n /* Parse (append) an identifier.  */\n-static void\n-parse_name (pfile, list, name)\n+static inline const U_CHAR *\n+parse_name (pfile, tok, cur, rlimit)\n      cpp_reader *pfile;\n-     cpp_toklist *list;\n-     cpp_name *name;\n+     cpp_token *tok;\n+     const U_CHAR *cur, *rlimit;\n {\n-  const unsigned char *name_limit;\n-  unsigned char *namebuf;\n-  cpp_buffer *buffer = pfile->buffer;\n-  register const unsigned char *cur = buffer->cur;\n-\n- expanded:\n-  name_limit = list->namebuf + list->name_cap;\n-  namebuf = list->namebuf + list->name_used;\n+  const U_CHAR *name = cur;\n+  unsigned int len;\n \n-  for (; cur < buffer->rlimit && namebuf < name_limit; )\n+  while (cur < rlimit)\n     {\n-      unsigned char c = *namebuf = *cur; /* Copy a single char.  */\n-\n-      if (! is_idchar(c))\n-\tgoto out;\n-      namebuf++;\n-      cur++;\n+      if (! is_idchar (*cur))\n+\tbreak;\n       /* $ is not a legal identifier character in the standard, but is\n \t commonly accepted as an extension.  Don't warn about it in\n \t skipped conditional blocks. */\n-      if (c == '$' && CPP_PEDANTIC (pfile) && ! pfile->skipping)\n+      if (*cur == '$' && CPP_PEDANTIC (pfile) && ! pfile->skipping)\n \t{\n-\t  buffer->cur = cur;\n+\t  CPP_BUFFER (pfile)->cur = cur;\n \t  cpp_pedwarn (pfile, \"'$' character in identifier\");\n \t}\n+      cur++;\n     }\n+  len = cur - name;\n \n-  /* Run out of name space?  */\n-  if (cur < buffer->rlimit)\n+  if (tok->val.node)\n     {\n-      list->name_used = namebuf - list->namebuf;\n-      auto_expand_name_space (list);\n-      goto expanded;\n+      unsigned int oldlen = tok->val.node->length;\n+      U_CHAR *newname = alloca (oldlen + len);\n+      memcpy (newname, tok->val.node->name, oldlen);\n+      memcpy (newname + oldlen, name, len);\n+      len += oldlen;\n+      name = newname;\n     }\n \n- out:\n-  buffer->cur = cur;\n-  name->len = namebuf - name->text;\n-  list->name_used = namebuf - list->namebuf;\n+  tok->val.node = cpp_lookup (pfile, name, len);\n+  return cur;\n }\n \n /* Parse (append) a number.  */\n static void\n parse_number (pfile, list, name)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n-     cpp_name *name;\n+     cpp_string *name;\n {\n   const unsigned char *name_limit;\n   unsigned char *namebuf;\n@@ -1057,7 +1040,7 @@ parse_number (pfile, list, name)\n }\n \n /* Places a string terminated by an unescaped TERMINATOR into a\n-   cpp_name, which should be expandable and thus at the top of the\n+   cpp_string, which should be expandable and thus at the top of the\n    list's stack.  Handles embedded trigraphs, if necessary, and\n    escaped newlines.\n \n@@ -1073,7 +1056,7 @@ parse_string (pfile, list, token, terminator)\n      unsigned int terminator;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  cpp_name *name = &token->val.name;\n+  cpp_string *name = &token->val.str;\n   register const unsigned char *cur = buffer->cur;\n   const unsigned char *name_limit;\n   unsigned char *namebuf;\n@@ -1221,9 +1204,9 @@ save_comment (list, token, from, len, type)\n   if (list->name_used + len > list->name_cap)\n     _cpp_expand_name_space (list, len);\n \n-  INIT_TOKEN_NAME (list, token);\n+  INIT_TOKEN_STR (list, token);\n   token->type = CPP_COMMENT;\n-  token->val.name.len = len;\n+  token->val.str.len = len;\n \n   buffer = list->namebuf + list->name_used;\n   list->name_used += len;\n@@ -1326,21 +1309,21 @@ lex_line (pfile, list)\n \t    prev_dot = PREV_TOKEN_TYPE == CPP_DOT && IMMED_TOKEN ();\n \t    if (prev_dot)\n \t      cur_token--;\n-\t    INIT_TOKEN_NAME (list, cur_token);\n+\t    INIT_TOKEN_STR (list, cur_token);\n \t    /* Prepend an immediately previous CPP_DOT token.  */\n \t    if (prev_dot)\n \t      {\n \t\tif (list->name_cap == list->name_used)\n \t\t  auto_expand_name_space (list);\n \n-\t\tcur_token->val.name.len = 1;\n+\t\tcur_token->val.str.len = 1;\n \t\tlist->namebuf[list->name_used++] = '.';\n \t      }\n \n \t  continue_number:\n \t    cur_token->type = CPP_NUMBER; /* Before parse_number.  */\n \t    buffer->cur = cur;\n-\t    parse_number (pfile, list, &cur_token->val.name);\n+\t    parse_number (pfile, list, &cur_token->val.str);\n \t    cur = buffer->cur;\n \t  }\n \t  /* Check for # 123 form of #line.  */\n@@ -1364,13 +1347,11 @@ lex_line (pfile, list)\n \tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n \tcase 'Y': case 'Z':\n \t  cur--;\t\t     /* Backup character.  */\n-\t  INIT_TOKEN_NAME (list, cur_token);\n+\t  cur_token->val.node = 0;\n \t  cur_token->type = CPP_NAME; /* Identifier, macro etc.  */\n \n \tcontinue_name:\n-\t  buffer->cur = cur;\n-\t  parse_name (pfile, list, &cur_token->val.name);\n-\t  cur = buffer->cur;\n+\t  cur = parse_name (pfile, cur_token, cur, buffer->rlimit);\n \n \t  if (MIGHT_BE_DIRECTIVE ())\n \t    list->directive = _cpp_check_directive (pfile, cur_token,\n@@ -1395,18 +1376,15 @@ lex_line (pfile, list)\n \t  cur_token->type = c == '\\'' ? CPP_CHAR : CPP_STRING;\n \t  /* Do we have a wide string?  */\n \t  if (cur_token[-1].type == CPP_NAME && IMMED_TOKEN ()\n-\t      && cur_token[-1].val.name.len == 1\n-\t      && cur_token[-1].val.name.text[0] == 'L'\n+\t      && cur_token[-1].val.node == pfile->spec_nodes->n_L\n \t      && !CPP_TRADITIONAL (pfile))\n \t    {\n-\t      /* No need for 'L' any more.  */\n-\t      list->name_used--;\n \t      (--cur_token)->type = (c == '\\'' ? CPP_WCHAR : CPP_WSTRING);\n \t    }\n \n \tdo_parse_string:\n \t  /* Here c is one of ' \" or >.  */\n-\t  INIT_TOKEN_NAME (list, cur_token);\n+\t  INIT_TOKEN_STR (list, cur_token);\n \t  buffer->cur = cur;\n \t  parse_string (pfile, list, cur_token, c);\n \t  cur = buffer->cur;\n@@ -1797,7 +1775,7 @@ lex_line (pfile, list)\n     {\n       if (first[1].type == CPP_NAME)\n \tcpp_error (pfile, \"invalid preprocessing directive #%.*s\",\n-\t\t   (int) first[1].val.name.len, first[1].val.name.text);\n+\t\t   (int) first[1].val.node->length, first[1].val.node->name);\n       else\n \tcpp_error (pfile, \"invalid preprocessing directive\");\n     }\n@@ -1900,23 +1878,27 @@ spell_token (pfile, token, buffer)\n       break;\n \n     case SPELL_IDENT:\n-      memcpy (buffer, token->val.name.text, token->val.name.len);\n-      buffer += token->val.name.len;\n+      memcpy (buffer, token->val.node->name, token->val.node->length);\n+      buffer += token->val.node->length;\n       break;\n \n     case SPELL_STRING:\n       {\n-\tunsigned char c;\n-\n \tif (token->type == CPP_WSTRING || token->type == CPP_WCHAR)\n \t  *buffer++ = 'L';\n-\tc = '\\'';\n+\n \tif (token->type == CPP_STRING || token->type == CPP_WSTRING)\n-\t  c = '\"';\n-\t*buffer++ = c;\n-\tmemcpy (buffer, token->val.name.text, token->val.name.len);\n-\tbuffer += token->val.name.len;\n-\t*buffer++ = c;\n+\t  *buffer++ = '\"';\n+\tif (token->type == CPP_CHAR || token->type == CPP_WCHAR)\n+\t  *buffer++ = '\\'';\n+\n+\tmemcpy (buffer, token->val.str.text, token->val.str.len);\n+\tbuffer += token->val.str.len;\n+\t\n+\tif (token->type == CPP_STRING || token->type == CPP_WSTRING)\n+\t  *buffer++ = '\"';\n+\tif (token->type == CPP_CHAR || token->type == CPP_WCHAR)\n+\t  *buffer++ = '\\'';\n       }\n       break;\n \n@@ -2096,7 +2078,7 @@ is_macro_disabled (pfile, expansion, token)\n \t  if (CPP_OPTION (pfile, warn_traditional))\n \t    cpp_warning (pfile,\n \t \"function macro %.*s must be used with arguments in traditional C\",\n-\t\t\t (int) token->val.name.len, token->val.name.text);\n+\t\t\t (int) token->val.node->length, token->val.node->name);\n \t  return 1;\n \t}\n     }\n@@ -2314,8 +2296,8 @@ make_string_token (token, text, len)\n   buf = (U_CHAR *) xmalloc (len * 4);\n   token->type = CPP_STRING;\n   token->flags = 0;\n-  token->val.name.text = buf;\n-  token->val.name.len = quote_string (buf, text, len) - buf;\n+  token->val.str.text = buf;\n+  token->val.str.len = quote_string (buf, text, len) - buf;\n   return token;\n }\n \n@@ -2335,8 +2317,8 @@ alloc_number_token (pfile, number)\n \n   result->type = CPP_NUMBER;\n   result->flags = 0;\n-  result->val.name.text = (U_CHAR *) buf;\n-  result->val.name.len = strlen (buf);\n+  result->val.str.text = (U_CHAR *) buf;\n+  result->val.str.len = strlen (buf);\n   return result;\n }\n \n@@ -2369,10 +2351,10 @@ release_temp_tokens (pfile)\n     {\n       cpp_token *token = pfile->temp_tokens[--pfile->temp_used];\n \n-      if (token_spellings[token->type].type > SPELL_NONE)\n+      if (token_spellings[token->type].type == SPELL_STRING)\n \t{\n-\t  free ((char *) token->val.name.text);\n-\t  token->val.name.text = 0;\n+\t  free ((char *) token->val.str.text);\n+\t  token->val.str.text = 0;\n \t}\n     }\n }\n@@ -2394,9 +2376,9 @@ _cpp_free_temp_tokens (pfile)\n \n   if (pfile->date)\n     {\n-      free ((char *) pfile->date->val.name.text);\n+      free ((char *) pfile->date->val.str.text);\n       free (pfile->date);\n-      free ((char *) pfile->time->val.name.text);\n+      free ((char *) pfile->time->val.str.text);\n       free (pfile->time);\n     }\n }\n@@ -2410,11 +2392,11 @@ duplicate_token (pfile, token)\n   cpp_token *result = get_temp_token (pfile);\n \n   *result = *token;\n-  if (token_spellings[token->type].type > SPELL_NONE)\n+  if (token_spellings[token->type].type == SPELL_STRING)\n     {\n-      U_CHAR *buff = (U_CHAR *) xmalloc (token->val.name.len);\n-      memcpy (buff, token->val.name.text, token->val.name.len);\n-      result->val.name.text = buff;\n+      U_CHAR *buff = (U_CHAR *) xmalloc (token->val.str.len);\n+      memcpy (buff, token->val.str.text, token->val.str.len);\n+      result->val.str.text = buff;\n     }\n   return result;\n }\n@@ -2489,13 +2471,11 @@ can_paste (pfile, token1, token2, digraph)\n     case CPP_NAME:\n       if (b == CPP_NAME)\treturn CPP_NAME;\n       if (b == CPP_NUMBER\n-\t  && is_numstart(token2->val.name.text[0]))\treturn CPP_NAME;\n+\t  && is_numstart(token2->val.str.text[0]))\t return CPP_NAME;\n       if (b == CPP_CHAR\n-\t  && token1->val.name.len == 1\n-\t  && token1->val.name.text[0] == 'L')\treturn CPP_WCHAR;\n+\t  && token1->val.node == pfile->spec_nodes->n_L) return CPP_WCHAR;\n       if (b == CPP_STRING\n-\t  && token1->val.name.len == 1\n-\t  && token1->val.name.text[0] == 'L')\treturn CPP_WSTRING;\n+\t  && token1->val.node == pfile->spec_nodes->n_L) return CPP_WSTRING;\n       break;\n \n     case CPP_NUMBER:\n@@ -2504,7 +2484,7 @@ can_paste (pfile, token1, token2, digraph)\n       if (b == CPP_DOT)\t\treturn CPP_NUMBER;\n       /* Numbers cannot have length zero, so this is safe.  */\n       if ((b == CPP_PLUS || b == CPP_MINUS)\n-\t  && VALID_SIGN ('+', token1->val.name.text[token1->val.name.len - 1]))\n+\t  && VALID_SIGN ('+', token1->val.str.text[token1->val.str.len - 1]))\n \treturn CPP_NUMBER;\n       break;\n \n@@ -2578,15 +2558,21 @@ maybe_paste_with_next (pfile, token)\n       if (type == CPP_NAME || type == CPP_NUMBER)\n \t{\n \t  /* Join spellings.  */\n-\t  U_CHAR *buff, *buff2;\n+\t  U_CHAR *buf, *end;\n \n \t  pasted = get_temp_token (pfile);\n-\t  buff = (U_CHAR *) xmalloc (TOKEN_LEN (token) + TOKEN_LEN (second));\n-\t  buff2 = spell_token (pfile, token, buff);\n-\t  buff2 = spell_token (pfile, second, buff2);\n+\t  buf = (U_CHAR *) alloca (TOKEN_LEN (token) + TOKEN_LEN (second));\n+\t  end = spell_token (pfile, token, buf);\n+\t  end = spell_token (pfile, second, end);\n+\t  *end = '\\0';\n \n-\t  pasted->val.name.text = buff;\n-\t  pasted->val.name.len = buff2 - buff;\n+\t  if (type == CPP_NAME)\n+\t    pasted->val.node = cpp_lookup (pfile, buf, end - buf);\n+\t  else\n+\t    {\n+\t      pasted->val.str.text = uxstrdup (buf);\n+\t      pasted->val.str.len = end - buf;\n+\t    }\n \t}\n       else if (type == CPP_WCHAR || type == CPP_WSTRING)\n \tpasted = duplicate_token (pfile, second);\n@@ -2597,7 +2583,7 @@ maybe_paste_with_next (pfile, token)\n \t}\n \n       pasted->type = type;\n-      pasted->flags = digraph ? DIGRAPH: 0;\n+      pasted->flags = digraph ? DIGRAPH : 0;\n     }\n \n   /* The pasted token gets the whitespace flags and position of the\n@@ -2681,8 +2667,8 @@ stringify_arg (pfile, token)\n     }\n \n   result->type = CPP_STRING;\n-  result->val.name.text = main_buf;\n-  result->val.name.len = buf_used;\n+  result->val.str.text = main_buf;\n+  result->val.str.len = buf_used;\n   restore_macro_expansion (pfile, prev_value);\n   return result;\n }\n@@ -2907,7 +2893,7 @@ cpp_get_token (pfile)\n   if (pfile->no_expand_level == pfile->cur_context || pfile->paste_level)\n     return token;\n  \n-  node = cpp_lookup (pfile, token->val.name.text, token->val.name.len);\n+  node = token->val.node;\n   if (node->type == T_VOID)\n     return token;\n \n@@ -3194,7 +3180,7 @@ special_symbol (pfile, node, token)\n \n #ifdef STDC_0_IN_SYSTEM_HEADERS\n \tif (CPP_IN_SYSTEM_HEADER (pfile)\n-\t    && !cpp_defined (pfile, DSC(\"__STRICT_ANSI__\")))\n+\t    && pfile->spec_nodes->n__STRICT_ANSI__->type == T_VOID)\n \t  stdc = 0;\n #endif\n \tresult = alloc_number_token (pfile, stdc);\n@@ -3217,16 +3203,16 @@ special_symbol (pfile, node, token)\n \t  pfile->time = make_string_token\n \t    ((cpp_token *) xmalloc (sizeof (cpp_token)), DSC(\"12:34:56\"));\n \n-\t  sprintf ((char *) pfile->date->val.name.text, \"%s %2d %4d\",\n+\t  sprintf ((char *) pfile->date->val.str.text, \"%s %2d %4d\",\n \t\t   monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n-\t  sprintf ((char *) pfile->time->val.name.text, \"%02d:%02d:%02d\",\n+\t  sprintf ((char *) pfile->time->val.str.text, \"%02d:%02d:%02d\",\n \t\t   tb->tm_hour, tb->tm_min, tb->tm_sec);\n \t}\n       result = node->type == T_DATE ? pfile->date: pfile->time;\n       break;\n \n     case T_POISON:\n-      cpp_error (pfile, \"attempt to use poisoned \\\"%s\\\".\", node->name);\n+      cpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", node->name);\n       return token;\n \n     default:"}, {"sha": "f6108f468630b342be77795df01639cf2caa00b3", "filename": "gcc/cpplib.c", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -148,8 +148,6 @@ _cpp_check_directive (pfile, token, bol)\n      const cpp_token *token;\n      int bol;\n {\n-  const U_CHAR *name = token->val.name.text;\n-  size_t len = token->val.name.len;\n   unsigned int i;\n \n   /* If we are rescanning preprocessed input, don't obey any directives\n@@ -158,7 +156,7 @@ _cpp_check_directive (pfile, token, bol)\n     return 0;\n \n   for (i = 0; i < N_DIRECTIVES; i++)\n-    if (dtable[i].length == len && !memcmp (dtable[i].name, name, len))\n+    if (pfile->spec_nodes->dirs[i] == token->val.node)\n       {\n \t/* If we are skipping a failed conditional group, all non-conditional\n \t   directives are ignored.  */\n@@ -250,36 +248,33 @@ get_define_node (pfile)\n {\n   cpp_hashnode *node;\n   const cpp_token *token;\n-  const U_CHAR *sym;\n-  unsigned int len;\n \n   /* Skip any -C comments.  */\n   while ((token = cpp_get_token (pfile))->type == CPP_COMMENT)\n     ;\n \n   if (token->type != CPP_NAME)\n     {\n-      cpp_error_with_line (pfile, pfile->token_list.line, token->col,\n+      cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t   \"macro names must be identifiers\");\n       return 0;\n     }\n \n   /* That identifier is not allowed to be \"defined\".  See predefined\n      macro names (6.10.8.4).  */\n-  len = token->val.name.len;\n-  sym = token->val.name.text;\n-  if (str_match (sym, len, \"defined\"))\n+  node = token->val.node;\n+\n+  if (node == pfile->spec_nodes->n_defined)\n     {\n       cpp_error_with_line (pfile, pfile->token_list.line, token->col,\n \t\t\t   \"\\\"defined\\\" is not a legal macro name\");\n       return 0;\n     }\n \n-  node = cpp_lookup (pfile, sym, len);\n   /* Check for poisoned identifiers now.  */\n   if (node->type == T_POISON)\n     {\n-      cpp_error (pfile, \"attempt to use poisoned \\\"%.*s\\\"\", (int) len, sym);\n+      cpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", node->name);\n       return 0;\n     }\n \n@@ -360,7 +355,7 @@ parse_include (pfile, dir, trail, strp, lenp, abp)\n \t  return 1;\n \t}\n     }\n-  if (name->val.name.len == 0)\n+  if (name->val.str.len == 0)\n     {\n       cpp_error (pfile, \"empty file name in #%s\", dir);\n       return 1;\n@@ -369,8 +364,8 @@ parse_include (pfile, dir, trail, strp, lenp, abp)\n   if (!trail && cpp_get_token (pfile)->type != CPP_EOF)\n     cpp_error (pfile, \"junk at end of #%s\", dir);\n \n-  *lenp = name->val.name.len;\n-  *strp = name->val.name.text;\n+  *lenp = name->val.str.len;\n+  *strp = name->val.str.text;\n   *abp = (name->type == CPP_HEADER_NAME);\n   return 0;\n }\n@@ -466,8 +461,8 @@ read_line_number (pfile, num)\n {\n   const cpp_token *tok = cpp_get_token (pfile);\n   enum cpp_ttype type = tok->type;\n-  const U_CHAR *p = tok->val.name.text;\n-  unsigned int len = tok->val.name.len;\n+  const U_CHAR *p = tok->val.str.text;\n+  unsigned int len = tok->val.str.len;\n \n   if (type == CPP_NUMBER && len == 1 && p[0] >= '1' && p[0] <= '4')\n     {\n@@ -526,8 +521,8 @@ do_line (pfile)\n \n   tok = cpp_get_token (pfile);\n   type = tok->type;\n-  str = tok->val.name.text;\n-  len = tok->val.name.len;\n+  str = tok->val.str.text;\n+  len = tok->val.str.len;\n \n   if (type != CPP_NUMBER || strtoul_for_line (str, len, &new_lineno))\n     {\n@@ -542,8 +537,8 @@ do_line (pfile)\n   ip->lineno = new_lineno;\n   tok = cpp_get_token (pfile);\n   type = tok->type;\n-  str = tok->val.name.text;\n-  len = tok->val.name.len;\n+  str = tok->val.str.text;\n+  len = tok->val.str.len;\n \n   if (type == CPP_EOF)\n     goto done;\n@@ -683,8 +678,7 @@ struct pragma_entry\n };\n \n static int pragma_dispatch             \n-    PARAMS ((cpp_reader *, const struct pragma_entry *,\n-\t     const U_CHAR *, size_t));\n+    PARAMS ((cpp_reader *, const struct pragma_entry *, const cpp_hashnode *));\n static int do_pragma_once\t\tPARAMS ((cpp_reader *));\n static int do_pragma_implementation\tPARAMS ((cpp_reader *));\n static int do_pragma_poison\t\tPARAMS ((cpp_reader *));\n@@ -710,12 +704,14 @@ static const struct pragma_entry gcc_pragmas[] =\n   {NULL, NULL}\n };\n \n-static int pragma_dispatch (pfile, table, p, len)\n+static int pragma_dispatch (pfile, table, node)\n      cpp_reader *pfile;\n      const struct pragma_entry *table;\n-     const U_CHAR *p;\n-     size_t len;\n+     const cpp_hashnode *node;\n {\n+  const U_CHAR *p = node->name;\n+  size_t len = node->length;\n+  \n   for (; table->name; table++)\n     if (strlen (table->name) == len && !memcmp (p, table->name, len))\n       return (*table->handler) (pfile);\n@@ -738,8 +734,7 @@ do_pragma (pfile)\n       return 0;\n     }\n \n-  pop = pragma_dispatch (pfile, top_pragmas,\n-\t\t\t tok->val.name.text, tok->val.name.len);\n+  pop = pragma_dispatch (pfile, top_pragmas, tok->val.node);\n   if (!pop)\n     pass_thru_directive (pfile);\n   return 0;\n@@ -757,8 +752,7 @@ do_pragma_gcc (pfile)\n   else if (tok->type != CPP_NAME)\n     return 0;\n   \n-  return pragma_dispatch (pfile, gcc_pragmas,\n-\t\t\t  tok->val.name.text, tok->val.name.len);\n+  return pragma_dispatch (pfile, gcc_pragmas, tok->val.node);\n }\n \n static int\n@@ -799,9 +793,9 @@ do_pragma_implementation (pfile)\n     }\n \n   /* Make a NUL-terminated copy of the string.  */\n-  copy = alloca (tok->val.name.len + 1);\n-  memcpy (copy, tok->val.name.text, tok->val.name.len);\n-  copy[tok->val.name.len] = '\\0';\n+  copy = alloca (tok->val.str.len + 1);\n+  memcpy (copy, tok->val.str.text, tok->val.str.len);\n+  copy[tok->val.str.len] = '\\0';\n   \n   if (cpp_included (pfile, copy))\n     cpp_warning (pfile,\n@@ -837,7 +831,7 @@ do_pragma_poison (pfile)\n \t  return 1;\n \t}\n \n-      hp = cpp_lookup (pfile, tok->val.name.text, tok->val.name.len);\n+      hp = tok->val.node;\n       if (hp->type == T_POISON)\n \t;  /* It is allowed to poison the same identifier twice.  */\n       else\n@@ -943,7 +937,7 @@ detect_if_not_defined (pfile)\n \n   token++;\n   if (token->type != CPP_NAME\n-      || !str_match (token->val.name.text, token->val.name.len, \"defined\"))\n+      || token->val.node != pfile->spec_nodes->n_defined)\n     return 0;\n \n   token++;\n@@ -953,7 +947,7 @@ detect_if_not_defined (pfile)\n   if (token->type != CPP_NAME)\n     return 0;\n \n-  cmacro = cpp_lookup (pfile, token->val.name.text, token->val.name.len);\n+  cmacro = token->val.node;\n \n   if (token[-1].type == CPP_OPEN_PAREN)\n     {\n@@ -977,15 +971,11 @@ parse_ifdef (pfile, name)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n {\n-  const U_CHAR *ident;\n-  unsigned int len;\n   enum cpp_ttype type;\n   const cpp_hashnode *node = 0;\n \n   const cpp_token *token = cpp_get_token (pfile);\n   type = token->type;\n-  ident = token->val.name.text;\n-  len = token->val.name.len;\n \n   if (!CPP_TRADITIONAL (pfile))\n     {\n@@ -998,9 +988,13 @@ parse_ifdef (pfile, name)\n     }\n \n   if (type == CPP_NAME)\n-    node = cpp_lookup (pfile, ident, len);\n+    node = token->val.node;\n   if (node && node->type == T_POISON)\n-    cpp_error (pfile, \"attempt to use poisoned identifier \\\"%s\\\"\", node->name);\n+    {\n+      cpp_error (pfile, \"attempt to use poisoned identifier \\\"%s\\\"\",\n+\t\t node->name);\n+      node = 0;\n+    }\n     \n   return node;\n }\n@@ -1011,17 +1005,12 @@ static int\n do_ifdef (pfile)\n      cpp_reader *pfile;\n {\n-  int def = 0;\n   const cpp_hashnode *node = 0;\n \n   if (! pfile->skipping)\n-    {\n-      node = parse_ifdef (pfile, dtable[T_IFDEF].name);\n-      if (node)\n-\tdef = (node->type != T_VOID && node->type != T_POISON);\n-    }\n+    node = parse_ifdef (pfile, dtable[T_IFDEF].name);\n \n-  push_conditional (pfile, !def, T_IFDEF, 0);\n+  push_conditional (pfile, !(node && node->type != T_VOID), T_IFDEF, 0);\n   return 0;\n }\n \n@@ -1033,18 +1022,16 @@ do_ifndef (pfile)\n      cpp_reader *pfile;\n {\n   int start_of_file = 0;\n-  int def = 0;\n-  const cpp_hashnode *cmacro = 0;\n+  const cpp_hashnode *node = 0;\n \n   if (! pfile->skipping)\n     {\n       start_of_file = (pfile->token_list.flags & BEG_OF_FILE);\n-      cmacro = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n-      if (cmacro)\n-\tdef = cmacro->type != T_VOID;\n+      node = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n     }\n \n-  push_conditional (pfile, def, T_IFNDEF, start_of_file ? cmacro : 0);\n+  push_conditional (pfile, node && node->type != T_VOID,\n+\t\t    T_IFNDEF, start_of_file ? node : 0);\n   return 0;\n }\n \n@@ -1060,7 +1047,8 @@ do_if (pfile)\n \n   if (! pfile->skipping)\n     {\n-      cmacro = detect_if_not_defined (pfile);  \n+      if (pfile->token_list.flags & BEG_OF_FILE)\n+\tcmacro = detect_if_not_defined (pfile);\n       value = _cpp_parse_expr (pfile);\n     }\n   push_conditional (pfile, value == 0, T_IF, cmacro);\n@@ -1294,13 +1282,13 @@ _cpp_parse_assertion (pfile, answerp)\n       dest = &list->tokens[list->tokens_used++];\n       *dest = *token;\n \n-      if (token_spellings[token->type].type > SPELL_NONE)\n+      if (token_spellings[token->type].type == SPELL_STRING)\n \t{\n-\t  _cpp_expand_name_space (list, token->val.name.len);\n-\t  dest->val.name.text = list->namebuf + list->name_used;\n+\t  _cpp_expand_name_space (list, token->val.str.len);\n+\t  dest->val.str.text = list->namebuf + list->name_used;\n \t  memcpy (list->namebuf + list->name_used,\n-\t\t  token->val.name.text, token->val.name.len);\n-\t  list->name_used += token->val.name.len;\n+\t\t  token->val.str.text, token->val.str.len);\n+\t  list->name_used += token->val.str.len;\n \t}\n     }\n \n@@ -1322,12 +1310,12 @@ _cpp_parse_assertion (pfile, answerp)\n \n  lookup_node:\n   *answerp = answer;\n-  len = predicate->val.name.len;\n+  len = predicate->val.node->length;\n   sym = alloca (len + 1);\n \n   /* Prefix '#' to get it out of macro namespace.  */\n   sym[0] = '#';\n-  memcpy (sym + 1, predicate->val.name.text, len);\n+  memcpy (sym + 1, predicate->val.node->name, len);\n   return cpp_lookup (pfile, sym, len + 1);\n \n  error:\n@@ -1586,12 +1574,26 @@ cpp_pop_buffer (pfile)\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n+#define DSC(x) U x, sizeof x - 1\n void\n _cpp_init_stacks (pfile)\n      cpp_reader *pfile;\n {\n+  int i;\n+  struct spec_nodes *s;\n+\n   pfile->buffer_ob = xnew (struct obstack);\n   obstack_init (pfile->buffer_ob);\n+\n+  /* Perhaps not the ideal place to put this.  */\n+  pfile->spec_nodes = s = xnew (struct spec_nodes);\n+  s->n_L                = cpp_lookup (pfile, DSC(\"L\"));\n+  s->n_defined          = cpp_lookup (pfile, DSC(\"defined\"));\n+  s->n__STRICT_ANSI__   = cpp_lookup (pfile, DSC(\"__STRICT_ANSI__\"));\n+  s->n__CHAR_UNSIGNED__ = cpp_lookup (pfile, DSC(\"__CHAR_UNSIGNED__\"));\n+  s->n__VA_ARGS__       = cpp_lookup (pfile, DSC(\"__VA_ARGS__\"));\n+  for (i = 0; i < N_DIRECTIVES; i++)\n+    s->dirs[i] = cpp_lookup (pfile, dtable[i].name, dtable[i].length);\n }\n \n void"}, {"sha": "2868a5bbe623a97c8aa50f89165f2bf3814e71d5", "filename": "gcc/cpplib.h", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -34,7 +34,7 @@ typedef struct cpp_options cpp_options;\n typedef struct cpp_printer cpp_printer;\n typedef struct cpp_token cpp_token;\n typedef struct cpp_toklist cpp_toklist;\n-typedef struct cpp_name cpp_name;\n+typedef struct cpp_string cpp_string;\n typedef struct cpp_hashnode cpp_hashnode;\n \n /* The first two groups, apart from '=', can appear in preprocessor\n@@ -112,18 +112,18 @@ typedef struct cpp_hashnode cpp_hashnode;\n   C(CPP_OTHER,\t\t0)\t/* stray punctuation */    \\\n \\\n   I(CPP_NAME,\t\t0)\t/* word */\t\\\n-  I(CPP_INT,\t\t0)\t/* 23 */\t\\\n-  I(CPP_FLOAT,\t\t0)\t/* 3.14159 */\t\\\n-  I(CPP_NUMBER,\t\t0)\t/* 34_be+ta  */\t\\\n+  S(CPP_INT,\t\t0)\t/* 23 */\t\\\n+  S(CPP_FLOAT,\t\t0)\t/* 3.14159 */\t\\\n+  S(CPP_NUMBER,\t\t0)\t/* 34_be+ta  */\t\\\n   S(CPP_CHAR,\t\t0)\t/* 'char' */\t\\\n   S(CPP_WCHAR,\t\t0)\t/* L'char' */\t\\\n   S(CPP_STRING,\t\t0)\t/* \"string\" */\t\\\n   S(CPP_WSTRING,\t0)\t/* L\"string\" */\t\\\n \\\n-  I(CPP_COMMENT,\t0)\t/* Only if output comments.  */ \\\n+  S(CPP_COMMENT,\t0)\t/* Only if output comments.  */ \\\n   N(CPP_MACRO_ARG,      0)\t/* Macro argument.  */          \\\n   N(CPP_EOF,\t\t0)\t/* End of file.  */\t\t\\\n-  I(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\n+  S(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\n \n #define T(e, s) e,\n #define I(e, s) e,\n@@ -141,8 +141,8 @@ enum cpp_ttype\n #undef C\n #undef N\n \n-/* Payload of a NAME, NUMBER, FLOAT, STRING, or COMMENT token.  */\n-struct cpp_name\n+/* Payload of a NUMBER, FLOAT, STRING, or COMMENT token.  */\n+struct cpp_string\n {\n   unsigned int len;\n   const unsigned char *text;\n@@ -168,7 +168,8 @@ struct cpp_token\n   union\n   {\n     HOST_WIDEST_INT integer;\t/* an integer */\n-    struct cpp_name name;\t/* a string */\n+    struct cpp_hashnode *node;\t/* an identifier */\n+    struct cpp_string str;\t/* a string, or number */\n     unsigned int aux;\t\t/* argument no. for a CPP_MACRO_ARG, or\n \t\t\t\t   character represented by CPP_OTHER.  */\n   } val;\n@@ -558,6 +559,10 @@ struct cpp_reader\n \n   /* True if output_line_command needs to output a newline.  */\n   unsigned char need_newline;\n+\n+  /* Special nodes - identifiers with predefined significance to the\n+     preprocessor.  */\n+  struct spec_nodes *spec_nodes;\n };\n \n /* struct cpp_printer encapsulates state used to convert the stream of\n@@ -693,8 +698,8 @@ extern cpp_buffer *cpp_push_buffer\tPARAMS ((cpp_reader *,\n extern cpp_buffer *cpp_pop_buffer\tPARAMS ((cpp_reader *));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *, cpp_printer *));\n extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *));\n-extern int cpp_idcmp\t\t\tPARAMS ((const unsigned char *,\n-\t\t\t\t\t\t size_t, const char *));\n+extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n+\t\t\t\t\t\t const char *));\n \n /* In cpphash.c */\n extern int cpp_defined\t\t\tPARAMS ((cpp_reader *,"}, {"sha": "1dff108bb21e46187471e9b0b05e497b172f6423", "filename": "gcc/fix-header.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -501,7 +501,7 @@ recognized_extern (name)\n   switch (special_file_handling)\n     {\n     case errno_h:\n-      if (!cpp_idcmp (name->val.name.text, name->val.name.len, \"errno\"))\n+      if (cpp_ideq (name, \"errno\"))\n \tseen_errno = 1, required_other--;\n       break;\n \n@@ -531,8 +531,8 @@ recognized_function (fname, kind, have_arg_list, file_seen)\n     missing_extern_C_count++;\n #endif\n \n-  fn = lookup_std_proto ((const char *)fname->val.name.text,\n-\t\t\t fname->val.name.len);\n+  fn = lookup_std_proto ((const char *)fname->val.node->name,\n+\t\t\t fname->val.node->length);\n \n   /* Remove the function from the list of required function.  */\n   if (fn)\n@@ -653,9 +653,7 @@ read_scan_file (in_fname, argc, argv)\n \t      if (CPP_BUFFER (&scan_in) == buf)\n \t\tbreak;\n \t    }\n-\t  else if (t->type == CPP_NAME && cpp_idcmp (t->val.name.text,\n-\t\t\t\t\t\t     t->val.name.len,\n-\t\t\t\t\t\t     \"_filbuf\") == 0)\n+\t  else if (cpp_ideq (t, \"_filbuf\"))\n \t    seen_filbuf++;\n \t}\n       if (seen_filbuf)"}, {"sha": "b8451b9ec36ece3ce85943224f9ee65ffe8a958b", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb9dc7faa9330d05c109e8a40710b752dddea14/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=bfb9dc7faa9330d05c109e8a40710b752dddea14", "patch": "@@ -193,18 +193,17 @@ scan_decls (pfile, argc, argv)\n \t  break;\n \tcase CPP_NAME:\n \t  /* \"inline\" and \"extern\" are recognized but skipped */\n-\t  if (!cpp_idcmp (token->val.name.text, token->val.name.len, \"inline\"))\n+\t  if (cpp_ideq (token, \"inline\"))\n \t    {\n \t      saw_inline = 1;\n \t    }\n-\t  else if (!cpp_idcmp (token->val.name.text,\n-\t\t\t       token->val.name.len, \"extern\"))\n+\t  else if (cpp_ideq (token, \"extern\"))\n \t    {\n \t      saw_extern = 1;\n \t      token = cpp_get_token (pfile);\n \t      if (token->type == CPP_STRING\n-\t\t  && !cpp_idcmp (token->val.name.text,\n-\t\t\t\t token->val.name.len, \"C\"))\n+\t\t  && token->val.str.len == 1\n+\t\t  && token->val.str.text[0] == 'C')\n \t\t{\n \t\t  current_extern_C = 1;\n \t\t  token = cpp_get_token (pfile);"}]}