{"sha": "19e5389debb03c3623f6a2ce8a8f6f4aa2118901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTllNTM4OWRlYmIwM2MzNjIzZjZhMmNlOGE4ZjZmNGFhMjExODkwMQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2020-03-11T10:52:37Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2020-03-27T21:52:37Z"}, "message": "[RS6000] PR94145, make PLT loads volatile\n\nThe PLT is volatile.  On PowerPC it is a bss style section which the\ndynamic loader initialises to point at resolver stubs (called glink on\nPowerPC64) to support lazy resolution of function addresses.  The\nfirst call to a given function goes via the dynamic loader symbol\nresolver, which updates the PLT entry for that function and calls the\nfunction.  The second call, if there is one and we don't have a\nmulti-threaded race, will use the updated PLT entry and thus avoid\nthe relatively slow symbol resolver path.\n\nCalls via the PLT are like calls via a function pointer, except that\nno initialised function pointer is volatile like the PLT.  All\ninitialised function pointers are resolved at program startup to point\nat the function or are left as NULL.  There is no support for lazy\nresolution of any user visible function pointer.\n\nSo why does any of this matter to gcc?  Well, normally the PLT call\nmechanism happens entirely behind gcc's back, but since we implemented\ninline PLT calls (effectively putting the PLT code stub that loads the\nPLT entry inline and making that code sequence scheduled), the load of\nthe PLT entry is visible to gcc.  That load then is subject to gcc\noptimization, for example in\n\n/* -S -mcpu=future -mpcrel -mlongcall -O2.  */\nint foo (int);\nvoid bar (void)\n{\n  while (foo(0))\n    foo (99);\n}\n\nwe see the PLT load for foo being hoisted out of the loop and stashed\nin a call-saved register.  If that happens to be the first call to\nfoo, then the stashed value is that for the resolver stub, and every\ncall to foo in the loop will then go via the slow resolver path.  Not\na good idea.  Also, if foo turns out to be a local function and the\nlinker replaces the PLT calls with direct calls to foo then gcc has\njust wasted a call-saved register.\n\nThis patch teaches gcc that the PLT loads are volatile.  The change\ndoesn't affect other loads of function pointers and thus has no effect\non normal indirect function calls.  Note that because the\n\"optimization\" this patch prevents can only occur over function calls,\nthe only place gcc can stash PLT loads is in call-saved registers or\nin other memory.  I'm reasonably confident that this change will be\nneutral or positive for the \"ld -z now\" case where the PLT is not\nvolatile, in code where there is any register pressure.  Even if gcc\ncould be taught to recognise cases where the PLT is resolved, you'd\nneed to discount use of registers to cache PLT loads by some factor\ninvolving the chance that those calls would be converted to direct\ncalls.\n\n\tPR target/94145\n\t* config/rs6000/rs6000.c (rs6000_longcall_ref): Use unspec_volatile\n\tfor PLT16_LO and PLT_PCREL.\n\t* config/rs6000/rs6000.md (UNSPEC_PLT16_LO, UNSPEC_PLT_PCREL): Remove.\n\t(UNSPECV_PLT16_LO, UNSPECV_PLT_PCREL): Define.\n\t(pltseq_plt16_lo_, pltseq_plt_pcrel): Use unspec_volatile.", "tree": {"sha": "ec9a8c92760c92b0e6fd966e3276ce90f5e885ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec9a8c92760c92b0e6fd966e3276ce90f5e885ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19e5389debb03c3623f6a2ce8a8f6f4aa2118901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e5389debb03c3623f6a2ce8a8f6f4aa2118901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19e5389debb03c3623f6a2ce8a8f6f4aa2118901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e5389debb03c3623f6a2ce8a8f6f4aa2118901/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54de5afb4a9b2f7296f614820a33ec0e4eb8bf39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54de5afb4a9b2f7296f614820a33ec0e4eb8bf39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54de5afb4a9b2f7296f614820a33ec0e4eb8bf39"}], "stats": {"total": 39, "additions": 25, "deletions": 14}, "files": [{"sha": "3bfe5ff8f69ae5e7eab3a13bb867532ed562ee1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e5389debb03c3623f6a2ce8a8f6f4aa2118901/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e5389debb03c3623f6a2ce8a8f6f4aa2118901/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19e5389debb03c3623f6a2ce8a8f6f4aa2118901", "patch": "@@ -1,3 +1,12 @@\n+2020-03-27  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/94145\n+\t* config/rs6000/rs6000.c (rs6000_longcall_ref): Use unspec_volatile\n+\tfor PLT16_LO and PLT_PCREL.\n+\t* config/rs6000/rs6000.md (UNSPEC_PLT16_LO, UNSPEC_PLT_PCREL): Remove.\n+\t(UNSPECV_PLT16_LO, UNSPECV_PLT_PCREL): Define.\n+\t(pltseq_plt16_lo_, pltseq_plt_pcrel): Use unspec_volatile.\n+\n 2020-03-27  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/94098"}, {"sha": "13851d12551be20997114f42081ebb6b345375ef", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e5389debb03c3623f6a2ce8a8f6f4aa2118901/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e5389debb03c3623f6a2ce8a8f6f4aa2118901/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=19e5389debb03c3623f6a2ce8a8f6f4aa2118901", "patch": "@@ -19283,8 +19283,9 @@ rs6000_longcall_ref (rtx call_ref, rtx arg)\n       if (rs6000_pcrel_p (cfun))\n \t{\n \t  rtx reg = gen_rtx_REG (Pmode, regno);\n-\t  rtx u = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, base, call_ref, arg),\n-\t\t\t\t  UNSPEC_PLT_PCREL);\n+\t  rtx u = gen_rtx_UNSPEC_VOLATILE (Pmode,\n+\t\t\t\t\t   gen_rtvec (3, base, call_ref, arg),\n+\t\t\t\t\t   UNSPECV_PLT_PCREL);\n \t  emit_insn (gen_rtx_SET (reg, u));\n \t  return reg;\n \t}\n@@ -19303,8 +19304,9 @@ rs6000_longcall_ref (rtx call_ref, rtx arg)\n       rtx reg = gen_rtx_REG (Pmode, regno);\n       rtx hi = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, base, call_ref, arg),\n \t\t\t       UNSPEC_PLT16_HA);\n-      rtx lo = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, reg, call_ref, arg),\n-\t\t\t       UNSPEC_PLT16_LO);\n+      rtx lo = gen_rtx_UNSPEC_VOLATILE (Pmode,\n+\t\t\t\t\tgen_rtvec (3, reg, call_ref, arg),\n+\t\t\t\t\tUNSPECV_PLT16_LO);\n       emit_insn (gen_rtx_SET (reg, hi));\n       emit_insn (gen_rtx_SET (reg, lo));\n       return reg;"}, {"sha": "5a8e9de670bd8d34fa8e0aa3138d585e54108e47", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e5389debb03c3623f6a2ce8a8f6f4aa2118901/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e5389debb03c3623f6a2ce8a8f6f4aa2118901/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=19e5389debb03c3623f6a2ce8a8f6f4aa2118901", "patch": "@@ -148,8 +148,6 @@\n    UNSPEC_SI_FROM_SF\n    UNSPEC_PLTSEQ\n    UNSPEC_PLT16_HA\n-   UNSPEC_PLT16_LO\n-   UNSPEC_PLT_PCREL\n   ])\n \n ;;\n@@ -178,6 +176,8 @@\n    UNSPECV_MTFSB1\t\t; Set FPSCR Field bit to 1\n    UNSPECV_SPLIT_STACK_RETURN   ; A camouflaged return\n    UNSPECV_SPEC_BARRIER         ; Speculation barrier\n+   UNSPECV_PLT16_LO\n+   UNSPECV_PLT_PCREL\n   ])\n \n ; The three different kinds of epilogue.\n@@ -10359,10 +10359,10 @@\n \n (define_insn \"*pltseq_plt16_lo_<mode>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n-\t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n-\t\t   (match_operand:P 3 \"\" \"\")]\n-\t\t  UNSPEC_PLT16_LO))]\n+\t(unspec_volatile:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n+\t\t\t    (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n+\t\t\t    (match_operand:P 3 \"\" \"\")]\n+\t\t\t   UNSPECV_PLT16_LO))]\n   \"TARGET_PLTSEQ\"\n {\n   return rs6000_pltseq_template (operands, RS6000_PLTSEQ_PLT16_LO);\n@@ -10382,10 +10382,10 @@\n \n (define_insn \"*pltseq_plt_pcrel<mode>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec:P [(match_operand:P 1 \"\" \"\")\n-\t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n-\t\t   (match_operand:P 3 \"\" \"\")]\n-\t\t  UNSPEC_PLT_PCREL))]\n+\t(unspec_volatile:P [(match_operand:P 1 \"\" \"\")\n+\t\t\t    (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n+\t\t\t    (match_operand:P 3 \"\" \"\")]\n+\t\t\t   UNSPECV_PLT_PCREL))]\n   \"HAVE_AS_PLTSEQ && TARGET_ELF\n    && rs6000_pcrel_p (cfun)\"\n {"}]}