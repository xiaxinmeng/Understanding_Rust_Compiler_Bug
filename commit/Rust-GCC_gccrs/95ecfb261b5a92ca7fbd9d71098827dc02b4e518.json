{"sha": "95ecfb261b5a92ca7fbd9d71098827dc02b4e518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVlY2ZiMjYxYjVhOTJjYTdmYmQ5ZDcxMDk4ODI3ZGMwMmI0ZTUxOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T18:15:54Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T18:15:54Z"}, "message": "loop-unroll.c: Use rtx_insn (also touches basic-block.h)\n\ngcc/\n\t* basic-block.h (basic_block split_edge_and_insert): Strengthen\n\tparam \"insns\" from rtx to rtx_insn *.\n\n\t* loop-unroll.c (struct iv_to_split): Strengthen field \"insn\" from\n\trtx to rtx_insn *.\n\t(struct iv_to_split): Likewise.\n\t(loop_exit_at_end_p): Likewise for local \"insn\".\n\t(split_edge_and_insert): Likewise for param \"insns\".\n\t(compare_and_jump_seq): Likewise for return type, param \"cinsn\",\n\tand locals \"seq\", \"jump\".\n\t(unroll_loop_runtime_iterations): Likewise for locals \"init_code\",\n\t\"branch_code\"; update invocations of compare_and_jump_seq to\n\teliminate NULL_RTX in favor of NULL.\n\t(referenced_in_one_insn_in_loop_p): Strengthen local \"insn\" from\n\trtx to rtx_insn *.\n\t(reset_debug_uses_in_loop): Likewise.\n\t(analyze_insn_to_expand_var): Likewise for param \"insn\".\n\t(analyze_iv_to_split_insn): Likewise.\n\t(analyze_insns_in_loop): Likewise for local \"insn\".\n\t(insert_base_initialization): Likewise for param\n\t\"insn\" and local \"seq\".\n\t(split_iv): Likewise for param \"insn\" and local \"seq\".\n\t(expand_var_during_unrolling): Likewise for param \"insn\".\n\t(insert_var_expansion_initialization): Likewise for local \"seq\".\n\t(combine_var_copies_in_loop_exit): Likewise.\n\t(combine_var_copies_in_loop_exit): Likewise for locals \"seq\" and\n\t\"insn\".\n\t(maybe_strip_eq_note_for_split_iv): Likewise for param \"insn\".\n\t(apply_opt_in_copies): Likewise for locals \"insn\", \"orig_insn\",\n\t\"next\".\n\nFrom-SVN: r214345", "tree": {"sha": "458ca56a251509a7515539b133b43b9fee6bc75d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/458ca56a251509a7515539b133b43b9fee6bc75d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95ecfb261b5a92ca7fbd9d71098827dc02b4e518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ecfb261b5a92ca7fbd9d71098827dc02b4e518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ecfb261b5a92ca7fbd9d71098827dc02b4e518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ecfb261b5a92ca7fbd9d71098827dc02b4e518/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b20d55a519f0e8ad7fcdc071f453c647bfceb9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b20d55a519f0e8ad7fcdc071f453c647bfceb9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b20d55a519f0e8ad7fcdc071f453c647bfceb9b"}], "stats": {"total": 88, "additions": 63, "deletions": 25}, "files": [{"sha": "99f3ed18ac7d658f3eaa77fb3806bb9b687f620e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ecfb261b5a92ca7fbd9d71098827dc02b4e518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ecfb261b5a92ca7fbd9d71098827dc02b4e518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95ecfb261b5a92ca7fbd9d71098827dc02b4e518", "patch": "@@ -1,3 +1,36 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* basic-block.h (basic_block split_edge_and_insert): Strengthen\n+\tparam \"insns\" from rtx to rtx_insn *.\n+\n+\t* loop-unroll.c (struct iv_to_split): Strengthen field \"insn\" from\n+\trtx to rtx_insn *.\n+\t(struct iv_to_split): Likewise.\n+\t(loop_exit_at_end_p): Likewise for local \"insn\".\n+\t(split_edge_and_insert): Likewise for param \"insns\".\n+\t(compare_and_jump_seq): Likewise for return type, param \"cinsn\",\n+\tand locals \"seq\", \"jump\".\n+\t(unroll_loop_runtime_iterations): Likewise for locals \"init_code\",\n+\t\"branch_code\"; update invocations of compare_and_jump_seq to\n+\teliminate NULL_RTX in favor of NULL.\n+\t(referenced_in_one_insn_in_loop_p): Strengthen local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(reset_debug_uses_in_loop): Likewise.\n+\t(analyze_insn_to_expand_var): Likewise for param \"insn\".\n+\t(analyze_iv_to_split_insn): Likewise.\n+\t(analyze_insns_in_loop): Likewise for local \"insn\".\n+\t(insert_base_initialization): Likewise for param\n+\t\"insn\" and local \"seq\".\n+\t(split_iv): Likewise for param \"insn\" and local \"seq\".\n+\t(expand_var_during_unrolling): Likewise for param \"insn\".\n+\t(insert_var_expansion_initialization): Likewise for local \"seq\".\n+\t(combine_var_copies_in_loop_exit): Likewise.\n+\t(combine_var_copies_in_loop_exit): Likewise for locals \"seq\" and\n+\t\"insn\".\n+\t(maybe_strip_eq_note_for_split_iv): Likewise for param \"insn\".\n+\t(apply_opt_in_copies): Likewise for locals \"insn\", \"orig_insn\",\n+\t\"next\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* cfgloop.h (iv_analyze): Strengthen param 1 \"insn\" from rtx to"}, {"sha": "f640f399eec4fa585f7093297b7336edb1e3c34b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ecfb261b5a92ca7fbd9d71098827dc02b4e518/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ecfb261b5a92ca7fbd9d71098827dc02b4e518/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=95ecfb261b5a92ca7fbd9d71098827dc02b4e518", "patch": "@@ -399,7 +399,7 @@ extern unsigned int free_bb_for_insn (void);\n extern void update_bb_for_insn (basic_block);\n \n extern void insert_insn_on_edge (rtx, edge);\n-basic_block split_edge_and_insert (edge, rtx);\n+basic_block split_edge_and_insert (edge, rtx_insn *);\n \n extern void commit_one_edge_insertion (edge e);\n extern void commit_edge_insertions (void);"}, {"sha": "2e35cb1672aab14c5f7bec605f0251d41d8616ab", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ecfb261b5a92ca7fbd9d71098827dc02b4e518/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ecfb261b5a92ca7fbd9d71098827dc02b4e518/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=95ecfb261b5a92ca7fbd9d71098827dc02b4e518", "patch": "@@ -73,7 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n \n struct iv_to_split\n {\n-  rtx insn;\t\t/* The insn in that the induction variable occurs.  */\n+  rtx_insn *insn;\t/* The insn in that the induction variable occurs.  */\n   rtx orig_var;\t\t/* The variable (register) for the IV before split.  */\n   rtx base_var;\t\t/* The variable on that the values in the further\n \t\t\t   iterations are based.  */\n@@ -85,7 +85,7 @@ struct iv_to_split\n \n struct var_to_expand\n {\n-  rtx insn;\t\t           /* The insn in that the variable expansion occurs.  */\n+  rtx_insn *insn;\t           /* The insn in that the variable expansion occurs.  */\n   rtx reg;                         /* The accumulator which is expanded.  */\n   vec<rtx> var_expansions;   /* The copies of the accumulator which is expanded.  */\n   struct var_to_expand *next;\t   /* Next entry in walking order.  */\n@@ -187,10 +187,10 @@ static struct opt_info *analyze_insns_in_loop (struct loop *);\n static void opt_info_start_duplication (struct opt_info *);\n static void apply_opt_in_copies (struct opt_info *, unsigned, bool, bool);\n static void free_opt_info (struct opt_info *);\n-static struct var_to_expand *analyze_insn_to_expand_var (struct loop*, rtx);\n+static struct var_to_expand *analyze_insn_to_expand_var (struct loop*, rtx_insn *);\n static bool referenced_in_one_insn_in_loop_p (struct loop *, rtx, int *);\n static struct iv_to_split *analyze_iv_to_split_insn (rtx_insn *);\n-static void expand_var_during_unrolling (struct var_to_expand *, rtx);\n+static void expand_var_during_unrolling (struct var_to_expand *, rtx_insn *);\n static void insert_var_expansion_initialization (struct var_to_expand *,\n \t\t\t\t\t\t basic_block);\n static void combine_var_copies_in_loop_exit (struct var_to_expand *,\n@@ -319,7 +319,7 @@ static bool\n loop_exit_at_end_p (struct loop *loop)\n {\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (desc->in_edge->dest != loop->latch)\n     return false;\n@@ -1007,7 +1007,7 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n    and NULL is returned instead.  */\n \n basic_block\n-split_edge_and_insert (edge e, rtx insns)\n+split_edge_and_insert (edge e, rtx_insn *insns)\n {\n   basic_block bb;\n \n@@ -1053,11 +1053,12 @@ split_edge_and_insert (edge e, rtx insns)\n    true, with probability PROB.  If CINSN is not NULL, it is the insn to copy\n    in order to create a jump.  */\n \n-static rtx\n+static rtx_insn *\n compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n-\t\t      rtx cinsn)\n+\t\t      rtx_insn *cinsn)\n {\n-  rtx seq, jump, cond;\n+  rtx_insn *seq, *jump;\n+  rtx cond;\n   enum machine_mode mode;\n \n   mode = GET_MODE (op0);\n@@ -1136,7 +1137,8 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n static void\n unroll_loop_runtime_iterations (struct loop *loop)\n {\n-  rtx old_niter, niter, init_code, branch_code, tmp;\n+  rtx old_niter, niter, tmp;\n+  rtx_insn *init_code, *branch_code;\n   unsigned i, j, p;\n   basic_block preheader, *body, swtch, ezc_swtch;\n   sbitmap wont_exit;\n@@ -1253,7 +1255,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       preheader = split_edge (loop_preheader_edge (loop));\n       branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,\n \t\t\t\t\t  block_label (preheader), p,\n-\t\t\t\t\t  NULL_RTX);\n+\t\t\t\t\t  NULL);\n \n       /* We rely on the fact that the compare and jump cannot be optimized out,\n \t and hence the cfg we create is correct.  */\n@@ -1276,7 +1278,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       preheader = split_edge (loop_preheader_edge (loop));\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,\n \t\t\t\t\t  block_label (preheader), p,\n-\t\t\t\t\t  NULL_RTX);\n+\t\t\t\t\t  NULL);\n       gcc_assert (branch_code != NULL_RTX);\n \n       swtch = split_edge_and_insert (single_succ_edge (swtch), branch_code);\n@@ -1684,7 +1686,7 @@ referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg,\n   basic_block *body, bb;\n   unsigned i;\n   int count_ref = 0;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   body = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n@@ -1710,7 +1712,7 @@ reset_debug_uses_in_loop (struct loop *loop, rtx reg, int debug_uses)\n {\n   basic_block *body, bb;\n   unsigned i;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   body = get_loop_body (loop);\n   for (i = 0; debug_uses && i < loop->num_nodes; i++)\n@@ -1755,7 +1757,7 @@ reset_debug_uses_in_loop (struct loop *loop, rtx reg, int debug_uses)\n */\n \n static struct var_to_expand *\n-analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n+analyze_insn_to_expand_var (struct loop *loop, rtx_insn *insn)\n {\n   rtx set, dest, src;\n   struct var_to_expand *ves;\n@@ -2087,10 +2089,10 @@ allocate_basic_variable (struct iv_to_split *ivts)\n    the initial value from INSN.  */\n \n static void\n-insert_base_initialization (struct iv_to_split *ivts, rtx insn)\n+insert_base_initialization (struct iv_to_split *ivts, rtx_insn *insn)\n {\n   rtx expr = copy_rtx (SET_SRC (single_set (insn)));\n-  rtx seq;\n+  rtx_insn *seq;\n \n   start_sequence ();\n   expr = force_operand (expr, ivts->base_var);\n@@ -2106,9 +2108,10 @@ insert_base_initialization (struct iv_to_split *ivts, rtx insn)\n    by base variable + DELTA * step.  */\n \n static void\n-split_iv (struct iv_to_split *ivts, rtx insn, unsigned delta)\n+split_iv (struct iv_to_split *ivts, rtx_insn *insn, unsigned delta)\n {\n-  rtx expr, *loc, seq, incr, var;\n+  rtx expr, *loc, incr, var;\n+  rtx_insn *seq;\n   enum machine_mode mode = GET_MODE (ivts->base_var);\n   rtx src, dest, set;\n \n@@ -2188,7 +2191,7 @@ get_expansion (struct var_to_expand *ve)\n    with a new register.  */\n \n static void\n-expand_var_during_unrolling (struct var_to_expand *ve, rtx insn)\n+expand_var_during_unrolling (struct var_to_expand *ve, rtx_insn *insn)\n {\n   rtx new_reg, set;\n   bool really_new_expansion = false;\n@@ -2246,7 +2249,8 @@ static void\n insert_var_expansion_initialization (struct var_to_expand *ve,\n \t\t\t\t     basic_block place)\n {\n-  rtx seq, var, zero_init;\n+  rtx_insn *seq;\n+  rtx var, zero_init;\n   unsigned i;\n   enum machine_mode mode = GET_MODE (ve->reg);\n   bool honor_signed_zero_p = HONOR_SIGNED_ZEROS (mode);\n@@ -2297,7 +2301,8 @@ static void\n combine_var_copies_in_loop_exit (struct var_to_expand *ve, basic_block place)\n {\n   rtx sum = ve->reg;\n-  rtx expr, seq, var, insn;\n+  rtx expr, var;\n+  rtx_insn *seq, *insn;\n   unsigned i;\n \n   if (ve->var_expansions.length () == 0)\n@@ -2348,7 +2353,7 @@ combine_var_copies_in_loop_exit (struct var_to_expand *ve, basic_block place)\n    any notes attached to them.  So resort to old techniques...  */\n \n static void\n-maybe_strip_eq_note_for_split_iv (struct opt_info *opt_info, rtx insn)\n+maybe_strip_eq_note_for_split_iv (struct opt_info *opt_info, rtx_insn *insn)\n {\n   struct iv_to_split *ivts;\n   rtx note = find_reg_equal_equiv_note (insn);\n@@ -2378,7 +2383,7 @@ apply_opt_in_copies (struct opt_info *opt_info,\n {\n   unsigned i, delta;\n   basic_block bb, orig_bb;\n-  rtx insn, orig_insn, next;\n+  rtx_insn *insn, *orig_insn, *next;\n   struct iv_to_split ivts_templ, *ivts;\n   struct var_to_expand ve_templ, *ves;\n "}]}