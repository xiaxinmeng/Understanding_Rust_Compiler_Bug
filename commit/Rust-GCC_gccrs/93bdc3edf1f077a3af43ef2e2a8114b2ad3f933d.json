{"sha": "93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNiZGMzZWRmMWYwNzdhM2FmNDNlZjJlMmE4MTE0YjJhZDNmOTMzZA==", "commit": {"author": {"name": "Cong Hou", "email": "congh@google.com", "date": "2013-11-14T20:59:47Z"}, "committer": {"name": "Cong Hou", "email": "congh@gcc.gnu.org", "date": "2013-11-14T20:59:47Z"}, "message": "tree-vectorizer.h (struct dr_with_seg_len): Remove the base address field as it can be obtained from dr.\n\n2013-11-14  Cong Hou  <congh@google.com>\n\n    * tree-vectorizer.h (struct dr_with_seg_len): Remove the base\n    address field as it can be obtained from dr.  Rename the struct.\n    * tree-vect-data-refs.c (comp_dr_with_seg_len_pair): Consider\n    steps of data references during sort.\n    (vect_prune_runtime_alias_test_list): Adjust with the change to\n    struct dr_with_seg_len.\n    * tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n    Adjust with the change to struct dr_with_seg_len.\n\n2013-11-14  Cong Hou  <congh@google.com>\n\n    * gcc.dg/vect/vect-alias-check.c: Update.\n\nFrom-SVN: r204822", "tree": {"sha": "5b4788fbe5d619ba4dd0343e1e3048b6b0ca4fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b4788fbe5d619ba4dd0343e1e3048b6b0ca4fd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/comments", "author": null, "committer": null, "parents": [{"sha": "5e94175fa5906a1417a229fe9ec93faa10502583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e94175fa5906a1417a229fe9ec93faa10502583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e94175fa5906a1417a229fe9ec93faa10502583"}], "stats": {"total": 194, "additions": 97, "deletions": 97}, "files": [{"sha": "5286637a72127eba905afbe067eb9c7e049f7b1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "patch": "@@ -1,3 +1,14 @@\n+2013-11-14  Cong Hou  <congh@google.com>\n+\n+\t* tree-vectorizer.h (struct dr_with_seg_len): Remove the base\n+\taddress field as it can be obtained from dr.  Rename the struct.\n+\t* tree-vect-data-refs.c (comp_dr_with_seg_len_pair): Consider\n+\tsteps of data references during sort.\n+\t(vect_prune_runtime_alias_test_list): Adjust with the change to\n+\tstruct dr_with_seg_len.\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n+\tAdjust with the change to struct dr_with_seg_len.\n+\n 2013-11-14  Jeff Law  <law@redhat.com>\n \n \tPR middle-end/59127"}, {"sha": "0dd77c1ce145eca5b44f980692784d197038fd52", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "patch": "@@ -1,3 +1,7 @@\n+2013-11-14  Cong Hou  <congh@google.com>\n+\n+\t* gcc.dg/vect/vect-alias-check.c: Update.\n+\n 2013-11-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/57887"}, {"sha": "c1bffed2f4887b7b8d06243061545aa917b855b0", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check.c?ref=93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "patch": "@@ -1,17 +1,17 @@\n /* { dg-require-effective-target vect_int } */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-vectorize --param=vect-max-version-for-alias-checks=2 -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"--param=vect-max-version-for-alias-checks=2\" } */\n \n-/* A test case showing three potential alias checks between\n-   a[i] and b[i], b[i+7], b[i+14]. With alias checks merging\n-   enabled, those tree checks can be merged into one, and the\n-   loop will be vectorized with vect-max-version-for-alias-checks=2.  */\n+/* A test case showing four potential alias checks between a[i] and b[0], b[1],\n+   b[i+1] and b[i+2].  With alias check merging enabled, those four checks\n+   can be merged into two, and the loop will be vectorized with\n+   vect-max-version-for-alias-checks=2.  */\n \n void foo (int *a, int *b)\n {\n   int i;\n   for (i = 0; i < 1000; ++i)\n-    a[i] = b[i] + b[i+7] + b[i+14];\n+    a[i] = b[0] + b[1] + b[i+1] + b[i+2];\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "2d0c3dc9e2d38ca70a5fcce05abe7b5b706de09f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 55, "deletions": 71, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "patch": "@@ -2623,70 +2623,59 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n }\n \n \n-/* Operator == between two dr_addr_with_seg_len objects.\n+/* Operator == between two dr_with_seg_len objects.\n \n    This equality operator is used to make sure two data refs\n    are the same one so that we will consider to combine the\n    aliasing checks of those two pairs of data dependent data\n    refs.  */\n \n static bool\n-operator == (const dr_addr_with_seg_len& d1,\n-\t     const dr_addr_with_seg_len& d2)\n+operator == (const dr_with_seg_len& d1,\n+\t     const dr_with_seg_len& d2)\n {\n-  return operand_equal_p (d1.basic_addr, d2.basic_addr, 0)\n-\t && compare_tree (d1.offset, d2.offset) == 0\n-\t && compare_tree (d1.seg_len, d2.seg_len) == 0;\n+  return operand_equal_p (DR_BASE_ADDRESS (d1.dr),\n+\t\t\t  DR_BASE_ADDRESS (d2.dr), 0)\n+\t   && compare_tree (d1.offset, d2.offset) == 0\n+\t   && compare_tree (d1.seg_len, d2.seg_len) == 0;\n }\n \n-/* Function comp_dr_addr_with_seg_len_pair.\n+/* Function comp_dr_with_seg_len_pair.\n \n-   Comparison function for sorting objects of dr_addr_with_seg_len_pair_t\n+   Comparison function for sorting objects of dr_with_seg_len_pair_t\n    so that we can combine aliasing checks in one scan.  */\n \n static int\n-comp_dr_addr_with_seg_len_pair (const void *p1_, const void *p2_)\n+comp_dr_with_seg_len_pair (const void *p1_, const void *p2_)\n {\n-  const dr_addr_with_seg_len_pair_t* p1 =\n-    (const dr_addr_with_seg_len_pair_t *) p1_;\n-  const dr_addr_with_seg_len_pair_t* p2 =\n-    (const dr_addr_with_seg_len_pair_t *) p2_;\n-\n-  const dr_addr_with_seg_len &p11 = p1->first,\n-\t\t\t     &p12 = p1->second,\n-\t\t\t     &p21 = p2->first,\n-\t\t\t     &p22 = p2->second;\n-\n-  int comp_res = compare_tree (p11.basic_addr, p21.basic_addr);\n-  if (comp_res != 0)\n+  const dr_with_seg_len_pair_t* p1 = (const dr_with_seg_len_pair_t *) p1_;\n+  const dr_with_seg_len_pair_t* p2 = (const dr_with_seg_len_pair_t *) p2_;\n+\n+  const dr_with_seg_len &p11 = p1->first,\n+\t\t\t&p12 = p1->second,\n+\t\t\t&p21 = p2->first,\n+\t\t\t&p22 = p2->second;\n+\n+  /* For DR pairs (a, b) and (c, d), we only consider to merge the alias checks\n+     if a and c have the same basic address snd step, and b and d have the same\n+     address and step.  Therefore, if any a&c or b&d don't have the same address\n+     and step, we don't care the order of those two pairs after sorting.  */\n+  int comp_res;\n+\n+  if ((comp_res = compare_tree (DR_BASE_ADDRESS (p11.dr),\n+\t\t\t\tDR_BASE_ADDRESS (p21.dr))) != 0)\n     return comp_res;\n-\n-  comp_res = compare_tree (p12.basic_addr, p22.basic_addr);\n-  if (comp_res != 0)\n+  if ((comp_res = compare_tree (DR_BASE_ADDRESS (p12.dr),\n+\t\t\t\tDR_BASE_ADDRESS (p22.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = compare_tree (DR_STEP (p11.dr), DR_STEP (p21.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = compare_tree (DR_STEP (p12.dr), DR_STEP (p22.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = compare_tree (p11.offset, p21.offset)) != 0)\n+    return comp_res;\n+  if ((comp_res = compare_tree (p12.offset, p22.offset)) != 0)\n     return comp_res;\n-\n-  if (TREE_CODE (p11.offset) != INTEGER_CST\n-      || TREE_CODE (p21.offset) != INTEGER_CST)\n-    {\n-      comp_res = compare_tree (p11.offset, p21.offset);\n-      if (comp_res != 0)\n-\treturn comp_res;\n-    }\n-  else if (tree_int_cst_compare (p11.offset, p21.offset) < 0)\n-    return -1;\n-  else if (tree_int_cst_compare (p11.offset, p21.offset) > 0)\n-    return 1;\n-  if (TREE_CODE (p12.offset) != INTEGER_CST\n-      || TREE_CODE (p22.offset) != INTEGER_CST)\n-    {\n-      comp_res = compare_tree (p12.offset, p22.offset);\n-      if (comp_res != 0)\n-\treturn comp_res;\n-    }\n-  else if (tree_int_cst_compare (p12.offset, p22.offset) < 0)\n-    return -1;\n-  else if (tree_int_cst_compare (p12.offset, p22.offset) > 0)\n-    return 1;\n \n   return 0;\n }\n@@ -2721,11 +2710,11 @@ vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n     segment_length = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n   else\n     segment_length = size_binop (MULT_EXPR,\n-                                 fold_convert (sizetype, DR_STEP (dr)),\n-                                 fold_convert (sizetype, length_factor));\n+\t\t\t\t fold_convert (sizetype, DR_STEP (dr)),\n+\t\t\t\t fold_convert (sizetype, length_factor));\n \n   if (vect_supportable_dr_alignment (dr, false)\n-        == dr_explicit_realign_optimized)\n+\t== dr_explicit_realign_optimized)\n     {\n       tree vector_size = TYPE_SIZE_UNIT\n \t\t\t  (STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr))));\n@@ -2747,7 +2736,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n {\n   vec<ddr_p> may_alias_ddrs =\n     LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n-  vec<dr_addr_with_seg_len_pair_t>& comp_alias_ddrs =\n+  vec<dr_with_seg_len_pair_t>& comp_alias_ddrs =\n     LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n   int vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n@@ -2826,36 +2815,29 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n       segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n \n-      dr_addr_with_seg_len_pair_t dr_with_seg_len_pair\n-\t  (dr_addr_with_seg_len\n-\t       (dr_a, DR_BASE_ADDRESS (dr_a),\n-\t\tsize_binop (PLUS_EXPR, DR_OFFSET (dr_a), DR_INIT (dr_a)),\n-\t\tsegment_length_a),\n-\t   dr_addr_with_seg_len\n-\t       (dr_b, DR_BASE_ADDRESS (dr_b),\n-\t\tsize_binop (PLUS_EXPR, DR_OFFSET (dr_b), DR_INIT (dr_b)),\n-\t\tsegment_length_b));\n-\n-      if (compare_tree (dr_with_seg_len_pair.first.basic_addr,\n-\t\t\tdr_with_seg_len_pair.second.basic_addr) > 0)\n+      dr_with_seg_len_pair_t dr_with_seg_len_pair\n+\t  (dr_with_seg_len (dr_a, segment_length_a),\n+\t   dr_with_seg_len (dr_b, segment_length_b));\n+\n+      if (compare_tree (DR_BASE_ADDRESS (dr_a), DR_BASE_ADDRESS (dr_b)) > 0)\n \tswap (dr_with_seg_len_pair.first, dr_with_seg_len_pair.second);\n \n       comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n     }\n \n   /* Second, we sort the collected data ref pairs so that we can scan\n      them once to combine all possible aliasing checks.  */\n-  comp_alias_ddrs.qsort (comp_dr_addr_with_seg_len_pair);\n+  comp_alias_ddrs.qsort (comp_dr_with_seg_len_pair);\n \n   /* Third, we scan the sorted dr pairs and check if we can combine\n      alias checks of two neighbouring dr pairs.  */\n   for (size_t i = 1; i < comp_alias_ddrs.length (); ++i)\n     {\n       /* Deal with two ddrs (dr_a1, dr_b1) and (dr_a2, dr_b2).  */\n-      dr_addr_with_seg_len *dr_a1 = &comp_alias_ddrs[i-1].first,\n-\t\t\t   *dr_b1 = &comp_alias_ddrs[i-1].second,\n-\t\t\t   *dr_a2 = &comp_alias_ddrs[i].first,\n-\t\t\t   *dr_b2 = &comp_alias_ddrs[i].second;\n+      dr_with_seg_len *dr_a1 = &comp_alias_ddrs[i-1].first,\n+\t\t      *dr_b1 = &comp_alias_ddrs[i-1].second,\n+\t\t      *dr_a2 = &comp_alias_ddrs[i].first,\n+\t\t      *dr_b2 = &comp_alias_ddrs[i].second;\n \n       /* Remove duplicate data ref pairs.  */\n       if (*dr_a1 == *dr_a2 && *dr_b1 == *dr_b2)\n@@ -2892,7 +2874,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t      swap (dr_a2, dr_b2);\n \t    }\n \n-\t  if (!operand_equal_p (dr_a1->basic_addr, dr_a2->basic_addr, 0)\n+\t  if (!operand_equal_p (DR_BASE_ADDRESS (dr_a1->dr),\n+\t\t\t\tDR_BASE_ADDRESS (dr_a2->dr),\n+\t\t\t\t0)\n \t      || !host_integerp (dr_a1->offset, 0)\n \t      || !host_integerp (dr_a2->offset, 0))\n \t    continue;\n@@ -2919,8 +2903,8 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n \t  HOST_WIDE_INT\n \t  min_seg_len_b = (TREE_CODE (dr_b1->seg_len) == INTEGER_CST) ?\n-\t\t\t      TREE_INT_CST_LOW (dr_b1->seg_len) :\n-\t\t\t      vect_factor;\n+\t\t\t     TREE_INT_CST_LOW (dr_b1->seg_len) :\n+\t\t\t     vect_factor;\n \n \t  if (diff <= min_seg_len_b\n \t      || (TREE_CODE (dr_a1->seg_len) == INTEGER_CST"}, {"sha": "411adb9afca02904db633c11842f120ea32b4c01", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "patch": "@@ -2245,7 +2245,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n void\n vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n {\n-  vec<dr_addr_with_seg_len_pair_t> comp_alias_ddrs =\n+  vec<dr_with_seg_len_pair_t> comp_alias_ddrs =\n     LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n   tree part_cond_expr;\n \n@@ -2263,15 +2263,15 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n \n   for (size_t i = 0, s = comp_alias_ddrs.length (); i < s; ++i)\n     {\n-      const dr_addr_with_seg_len& dr_a = comp_alias_ddrs[i].first;\n-      const dr_addr_with_seg_len& dr_b = comp_alias_ddrs[i].second;\n+      const dr_with_seg_len& dr_a = comp_alias_ddrs[i].first;\n+      const dr_with_seg_len& dr_b = comp_alias_ddrs[i].second;\n       tree segment_length_a = dr_a.seg_len;\n       tree segment_length_b = dr_b.seg_len;\n \n       tree addr_base_a\n-\t= fold_build_pointer_plus (dr_a.basic_addr, dr_a.offset);\n+\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_a.dr), dr_a.offset);\n       tree addr_base_b\n-\t= fold_build_pointer_plus (dr_b.basic_addr, dr_b.offset);\n+\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_b.dr), dr_b.offset);\n \n       if (dump_enabled_p ())\n \t{"}, {"sha": "0ce78d9508dee67bd114c38e9a7f01dd10c8fee0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=93bdc3edf1f077a3af43ef2e2a8114b2ad3f933d", "patch": "@@ -176,32 +176,33 @@ typedef struct _slp_oprnd_info\n \n \n /* This struct is used to store the information of a data reference,\n-   including the data ref itself, its basic address, the access offset\n-   and the segment length for aliasing checks.  This is used to generate\n-   alias checks.  */\n+   including the data ref itself, the access offset (calculated by summing its\n+   offset and init) and the segment length for aliasing checks.\n+   This is used to merge alias checks.  */\n \n-struct dr_addr_with_seg_len\n+struct dr_with_seg_len\n {\n-  dr_addr_with_seg_len (data_reference* d, tree addr, tree off, tree len)\n-    : dr (d), basic_addr (addr), offset (off), seg_len (len) {}\n+  dr_with_seg_len (data_reference_p d, tree len)\n+    : dr (d),\n+      offset (size_binop (PLUS_EXPR, DR_OFFSET (d), DR_INIT (d))),\n+      seg_len (len) {}\n \n-  data_reference *dr;\n-  tree basic_addr;\n+  data_reference_p dr;\n   tree offset;\n   tree seg_len;\n };\n \n-/* This struct contains two dr_addr_with_seg_len objects with aliasing data\n+/* This struct contains two dr_with_seg_len objects with aliasing data\n    refs.  Two comparisons are generated from them.  */\n \n-struct dr_addr_with_seg_len_pair_t\n+struct dr_with_seg_len_pair_t\n {\n-  dr_addr_with_seg_len_pair_t (const dr_addr_with_seg_len& d1,\n-\t\t\t       const dr_addr_with_seg_len& d2)\n+  dr_with_seg_len_pair_t (const dr_with_seg_len& d1,\n+\t\t\t       const dr_with_seg_len& d2)\n     : first (d1), second (d2) {}\n \n-  dr_addr_with_seg_len first;\n-  dr_addr_with_seg_len second;\n+  dr_with_seg_len first;\n+  dr_with_seg_len second;\n };\n \n \n@@ -306,7 +307,7 @@ typedef struct _loop_vec_info {\n \n   /* Data Dependence Relations defining address ranges together with segment\n      lengths from which the run-time aliasing check is built.  */\n-  vec<dr_addr_with_seg_len_pair_t> comp_alias_ddrs;\n+  vec<dr_with_seg_len_pair_t> comp_alias_ddrs;\n \n   /* Statements in the loop that have data references that are candidates for a\n      runtime (loop versioning) misalignment check.  */"}]}