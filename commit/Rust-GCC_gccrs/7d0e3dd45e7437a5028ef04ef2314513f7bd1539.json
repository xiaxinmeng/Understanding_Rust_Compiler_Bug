{"sha": "7d0e3dd45e7437a5028ef04ef2314513f7bd1539", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QwZTNkZDQ1ZTc0MzdhNTAyOGVmMDRlZjIzMTQ1MTNmN2JkMTUzOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-08T11:09:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-08T11:09:52Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r171", "tree": {"sha": "80d0ac0b2782d0c3cc81a6ddf3e5eef1bada34e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80d0ac0b2782d0c3cc81a6ddf3e5eef1bada34e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d0e3dd45e7437a5028ef04ef2314513f7bd1539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0e3dd45e7437a5028ef04ef2314513f7bd1539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0e3dd45e7437a5028ef04ef2314513f7bd1539", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0e3dd45e7437a5028ef04ef2314513f7bd1539/comments", "author": null, "committer": null, "parents": [{"sha": "c54f9cf994a70d35226b0bf49388afa8fd19c92b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c54f9cf994a70d35226b0bf49388afa8fd19c92b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c54f9cf994a70d35226b0bf49388afa8fd19c92b"}], "stats": {"total": 53, "additions": 27, "deletions": 26}, "files": [{"sha": "05ef62f669bedb92598f0055119fa70e203a766c", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0e3dd45e7437a5028ef04ef2314513f7bd1539/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0e3dd45e7437a5028ef04ef2314513f7bd1539/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=7d0e3dd45e7437a5028ef04ef2314513f7bd1539", "patch": "@@ -145,8 +145,7 @@ static HARD_REG_SET *block_out_reg_set;\n static short *block_number;\n \n /* This is the register file for all register after conversion */\n-static rtx SFmode_reg[FIRST_PSEUDO_REGISTER];\n-static rtx DFmode_reg[FIRST_PSEUDO_REGISTER];\n+static rtx FP_mode_reg[FIRST_PSEUDO_REGISTER][(int) MAX_MACHINE_MODE];\n \n /* ??? set of register to delete after ASM_OPERAND */\n HARD_REG_SET asm_regs;\n@@ -165,8 +164,6 @@ extern rtx find_regno_note ();\n extern rtx emit_jump_insn_before ();\n extern rtx emit_label_after ();\n \n-extern rtx dconst0_rtx;\n-\n /* Forward declarations */\n \n static void find_blocks ();\n@@ -225,15 +222,15 @@ reg_to_stack (first, file)\n   register rtx insn;\n   register int i;\n   int stack_reg_seen = 0;\n+  enum machine_mode mode;\n \n   current_function_returns_real\n     = TREE_CODE (TREE_TYPE (DECL_RESULT (current_function_decl))) == REAL_TYPE;\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      SFmode_reg[i] = gen_rtx (REG, SFmode, i);\n-      DFmode_reg[i] = gen_rtx (REG, DFmode, i);\n-    }\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      FP_mode_reg[i][(int) mode] = gen_rtx (REG, mode, i);\n \n   /* Count the basic blocks.  Also find maximum insn uid.  */\n   {\n@@ -599,7 +596,8 @@ record_reg_life (insn, block, regstack)\n \t       cannot be used on these insns, because they do not appear in\n \t       block_number[]. */\n \n-\t    pat = gen_rtx (SET, VOIDmode, DFmode_reg[reg], dconst0_rtx);\n+\t    pat = gen_rtx (SET, VOIDmode, FP_mode_reg[reg][(int) DFmode],\n+\t\t\t   CONST0_RTX (DFmode));\n \t    init = emit_insn_after (pat, insn);\n \t    PUT_MODE (init, QImode);\n \n@@ -839,7 +837,8 @@ stack_reg_life_analysis (first)\n       {\n \trtx init_rtx;\n \n-\tinit_rtx = gen_rtx (SET, VOIDmode, DFmode_reg[reg], dconst0_rtx);\n+\tinit_rtx = gen_rtx (SET, VOIDmode, FP_mode_reg[reg][(int) DFmode],\n+\t\t\t    CONST0_RTX (DFmode));\n \tblock_begin[0] = emit_insn_after (init_rtx, first);\n \tPUT_MODE (block_begin[0], QImode);\n \n@@ -867,12 +866,10 @@ replace_reg (reg, regno)\n       || ! STACK_REG_P (*reg))\n     abort ();\n \n-  if (GET_MODE (*reg) == DFmode)\n-    *reg = DFmode_reg[regno];\n-  else if (GET_MODE (*reg) == SFmode)\n-    *reg = SFmode_reg[regno];\n-  else\n-    abort ();\n+  if (GET_MODE_CLASS (GET_MODE (*reg)) != MODE_FLOAT)\n+    abort;\n+\n+  *reg = FP_mode_reg[regno][(int) GET_MODE (*reg)];\n }\n \n /* Remove a note of type NOTE, which must be found, for register\n@@ -957,14 +954,14 @@ emit_pop_insn (insn, regstack, reg, when)\n   if (hard_regno < FIRST_STACK_REG)\n     abort ();\n \n-  pop_rtx = gen_rtx (SET, VOIDmode, DFmode_reg[hard_regno],\n-\t\t     DFmode_reg[FIRST_STACK_REG]);\n+  pop_rtx = gen_rtx (SET, VOIDmode, FP_mode_reg[hard_regno][(int) DFmode],\n+\t\t     FP_mode_reg[FIRST_STACK_REG][(int) DFmode]);\n \n   pop_insn = (*when) (pop_rtx, insn);\n   PUT_MODE (pop_insn, VOIDmode);\n \n-  REG_NOTES (pop_insn) = gen_rtx (EXPR_LIST,\n-\t\t\t\t  REG_DEAD, DFmode_reg[FIRST_STACK_REG],\n+  REG_NOTES (pop_insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n+\t\t\t\t  FP_mode_reg[FIRST_STACK_REG][(int) DFmode],\n \t\t\t\t  REG_NOTES (pop_insn));\n \n   regstack->reg[regstack->top - (hard_regno - FIRST_STACK_REG)]\n@@ -997,7 +994,8 @@ emit_hard_swap_insn (insn, regstack, hard_regno, when)\n   if (hard_regno == FIRST_STACK_REG)\n     return;\n \n-  swap_rtx = gen_swapdf (DFmode_reg[hard_regno], DFmode_reg[FIRST_STACK_REG]);\n+  swap_rtx = gen_swapdf (FP_mode_reg[hard_regno][(int) DFmode],\n+\t\t\t FP_mode_reg[FIRST_STACK_REG][(int) DFmode]);\n   swap_insn = (*when) (swap_rtx, insn);\n   PUT_MODE (swap_insn, VOIDmode);\n \n@@ -1526,7 +1524,7 @@ change_stack (insn, old, new)\n \n   for (reg = old->top; reg >= 0; reg--)\n     if (! TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]))\n-      emit_pop_insn (insn, old, DFmode_reg[old->reg[reg]],\n+      emit_pop_insn (insn, old, FP_mode_reg[old->reg[reg]][(int) DFmode],\n \t\t     emit_insn_before);\n \n   if (new->top == -2)\n@@ -1575,7 +1573,8 @@ change_stack (insn, old, new)\n \t      if (reg == -1)\n \t\tabort ();\n \n-\t      emit_swap_insn (insn, old, DFmode_reg[old->reg[reg]],\n+\t      emit_swap_insn (insn, old,\n+\t\t\t      FP_mode_reg[old->reg[reg]][(int) DFmode],\n \t\t\t      emit_insn_before);\n \t    }\n \n@@ -1586,7 +1585,8 @@ change_stack (insn, old, new)\n \t  for (reg = new->top; reg >= 0; reg--)\n \t    if (new->reg[reg] != old->reg[reg])\n \t      {\n-\t\temit_swap_insn (insn, old, DFmode_reg[old->reg[reg]],\n+\t\temit_swap_insn (insn, old,\n+\t\t\t\tFP_mode_reg[old->reg[reg]][(int) DFmode],\n \t\t\t\temit_insn_before);\n \t\tbreak;\n \t      }\n@@ -1791,7 +1791,8 @@ convert_regs ()\n   for (reg = regstack.top; reg >= 0; reg--)\n     if (! current_function_returns_real\n \t|| regstack.reg[reg] != FIRST_STACK_REG)\n-      insn = emit_pop_insn (insn, &regstack, DFmode_reg[regstack.reg[reg]],\n+      insn = emit_pop_insn (insn, &regstack,\n+\t\t\t    FP_mode_reg[regstack.reg[reg]][(int) DFmode],\n \t\t\t    emit_insn_after);\n }\n \f"}]}