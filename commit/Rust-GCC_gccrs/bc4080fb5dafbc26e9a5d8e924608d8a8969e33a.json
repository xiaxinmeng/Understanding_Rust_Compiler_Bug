{"sha": "bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0MDgwZmI1ZGFmYmMyNmU5YTVkOGU5MjQ2MDhkOGE4OTY5ZTMzYQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2019-12-02T04:36:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T14:52:51Z"}, "message": "Added more type no bounds parsing", "tree": {"sha": "e48b3369f92db92b71ddea003b7f27b43aa4834c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e48b3369f92db92b71ddea003b7f27b43aa4834c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2ea9f7e7027a9945744f5f7c126a0618a30c334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ea9f7e7027a9945744f5f7c126a0618a30c334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ea9f7e7027a9945744f5f7c126a0618a30c334"}], "stats": {"total": 273, "additions": 265, "deletions": 8}, "files": [{"sha": "6d058f1ba7823bdf2a11d00a2c3c75b81880b3d0", "filename": "gcc/rust/test3/parse/rust-parse.cc", "status": "modified", "additions": 264, "deletions": 8, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc?ref=bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "patch": "@@ -6184,9 +6184,6 @@ namespace Rust {\n \n     // Parses a type (will further disambiguate any type).\n     AST::Type* Parser::parse_type() {\n-        // TODO\n-        return NULL;\n-\n         /* rules for all types:\n          * NeverType:               '!'\n          * SliceType:               '[' Type ']'\n@@ -6246,6 +6243,13 @@ namespace Rust {\n             case AMP: // does this also include AMP_AMP?\n                 // reference type\n                 return parse_reference_type();\n+            case LIFETIME: {\n+                // probably a lifetime bound, so probably type param bounds in TraitObjectType\n+                ::std::vector< ::std::unique_ptr<AST::TypeParamBound> > bounds\n+                  = parse_type_param_bounds();\n+\n+                return new AST::TraitObjectType(::std::move(bounds));\n+            }\n             case IDENTIFIER:\n             case SUPER:\n             case SELF:\n@@ -6789,7 +6793,8 @@ namespace Rust {\n         // parse inner type (required)\n         AST::Type* inner_type = parse_type();\n         if (inner_type == NULL) {\n-            error_at(lexer.peek_token()->get_locus(), \"failed to parse inner type in slice or array type\");\n+            error_at(\n+              lexer.peek_token()->get_locus(), \"failed to parse inner type in slice or array type\");\n             return NULL;\n         }\n \n@@ -6808,7 +6813,8 @@ namespace Rust {\n                 // parse required array size expression\n                 AST::Expr* size = parse_expr();\n                 if (size == NULL) {\n-                    error_at(lexer.peek_token()->get_locus(), \"failed to parse size expression in array type\");\n+                    error_at(lexer.peek_token()->get_locus(),\n+                      \"failed to parse size expression in array type\");\n                     return NULL;\n                 }\n \n@@ -6820,14 +6826,264 @@ namespace Rust {\n             }\n             default:\n                 // error\n-                error_at(t->get_locus(), \"unrecognised token '%s' in slice or array type after inner type\", t->get_token_description());\n+                error_at(t->get_locus(),\n+                  \"unrecognised token '%s' in slice or array type after inner type\",\n+                  t->get_token_description());\n+                return NULL;\n         }\n     }\n \n     // Parses a type, taking into account type boundary disambiguation.\n     AST::TypeNoBounds* Parser::parse_type_no_bounds() {\n-        // TODO\n-        return NULL;\n+        const_TokenPtr t = lexer.peek_token();\n+        switch (t->get_id()) {\n+            case EXCLAM:\n+                // never type - can't be macro as no path beforehand\n+                lexer.skip_token();\n+                return new AST::NeverType();\n+            case LEFT_SQUARE:\n+                // slice type or array type - requires further disambiguation\n+                return parse_slice_or_array_type();\n+            case LEFT_ANGLE: {\n+                // qualified path in type\n+                AST::QualifiedPathInType path = parse_qualified_path_in_type();\n+                if (path.is_error()) {\n+                    error_at(t->get_locus(), \"failed to parse qualified path in type\");\n+                    return NULL;\n+                }\n+                return new AST::QualifiedPathInType(::std::move(path));\n+            }\n+            case UNDERSCORE:\n+                // inferred type\n+                lexer.skip_token();\n+                return new AST::InferredType();\n+            case ASTERISK:\n+                // raw pointer type\n+                return parse_raw_pointer_type();\n+            case AMP: // does this also include AMP_AMP?\n+                // reference type\n+                return parse_reference_type();\n+            case LIFETIME: {\n+                // probably a lifetime bound, so probably type param bounds in TraitObjectType\n+                // this is not allowed, but detection here for error message\n+                error_at(t->get_locus(), \"lifetime bounds (i.e. in type param bounds, in \"\n+                                         \"TraitObjectType) are not allowed as TypeNoBounds\");\n+                return NULL;\n+            }\n+            case IDENTIFIER:\n+            case SUPER:\n+            case SELF:\n+            case SELF_ALIAS:\n+            case CRATE:\n+            case DOLLAR_SIGN:\n+            case SCOPE_RESOLUTION: {\n+                // macro invocation or type path - requires further disambiguation.\n+                /* for parsing path component of each rule, perhaps parse it as a typepath and\n+                 * attempt conversion to simplepath if a trailing '!' is found */\n+                /* Type path also includes TraitObjectTypeOneBound BUT if it starts with it, it is\n+                 * exactly the same as a TypePath syntactically, so this is a syntactical ambiguity.\n+                 * As such, the parser will parse it as a TypePath.\n+                 * This, however, does not prevent TraitObjectType from starting with a typepath. */\n+\n+                // parse path as type path\n+                AST::TypePath path = parse_type_path();\n+                if (path.is_error()) {\n+                    error_at(\n+                      t->get_locus(), \"failed to parse path as first component of type no bounds\");\n+                    return NULL;\n+                }\n+\n+                // branch on next token\n+                t = lexer.peek_token();\n+                switch (t->get_id()) {\n+                    case EXCLAM: {\n+                        // macro invocation\n+                        // convert to simple path\n+                        AST::SimplePath macro_path = path.as_simple_path();\n+                        if (macro_path.is_empty()) {\n+                            error_at(t->get_locus(),\n+                              \"failed to parse simple path in macro invocation (for type)\");\n+                            return NULL;\n+                        }\n+\n+                        lexer.skip_token();\n+\n+                        AST::DelimTokenTree tok_tree = parse_delim_token_tree();\n+\n+                        return new AST::MacroInvocation(::std::move(macro_path),\n+                          ::std::move(tok_tree), ::std::vector<AST::Attribute>());\n+                    }\n+                    case PLUS: {\n+                        // type param bounds - not allowed, here for error message\n+                        error_at(t->get_locus(),\n+                          \"type param bounds (in TraitObjectType) are not allowed as TypeNoBounds\");\n+                        return NULL;\n+                    }\n+                    default:\n+                        // assume that this is a type path and not an error\n+                        return new AST::TypePath(::std::move(path));\n+                }\n+            }\n+            case LEFT_PAREN:\n+                // tuple type or parenthesised type - requires further disambiguation (the usual)\n+                // ok apparently can be a parenthesised TraitBound too, so could be \n+                // TraitObjectTypeOneBound\n+                return parse_paren_prefixed_type_no_bounds();\n+            case FOR:\n+            case ASYNC:\n+            case CONST:\n+            case UNSAFE:\n+            case EXTERN_TOK:\n+            case FN_TOK:\n+                // bare function type (with no for lifetimes)\n+                return parse_bare_function_type(::std::vector<AST::LifetimeParam>());\n+            case IMPL:\n+                lexer.skip_token();\n+                if (lexer.peek_token()->get_id() == LIFETIME) {\n+                    // cannot be one bound because lifetime prevents it from being traitbound\n+                    // not allowed as type no bounds, only here for error message\n+                    error_at(lexer.peek_token()->get_locus(),\n+                      \"lifetime (probably lifetime bound, in type param bounds, in ImplTraitType) is \"\n+                      \"not allowed in TypeNoBounds\");\n+                    return NULL;\n+                } else {\n+                    // should be trait bound, so parse trait bound\n+                    AST::TraitBound* initial_bound = parse_trait_bound();\n+                    if (initial_bound == NULL) {\n+                        error_at(lexer.peek_token()->get_locus(),\n+                          \"failed to parse ImplTraitTypeOneBound bound\");\n+                        return NULL;\n+                    }\n+\n+                    // ensure not a trait with multiple bounds\n+                    t = lexer.peek_token();\n+                    if (t->get_id() == PLUS) {\n+                        error_at(t->get_locus(), \"plus after trait bound means an ImplTraitType, \"\n+                                                 \"which is not allowed as a TypeNoBounds\");\n+                        return NULL;\n+                    }\n+\n+                    // convert trait bound to value object\n+                    AST::TraitBound value_bound(*initial_bound);\n+                    delete initial_bound;\n+\n+                    return new AST::ImplTraitTypeOneBound(::std::move(value_bound));\n+                }\n+            case DYN:\n+            case QUESTION_MARK: {\n+                // either TraitObjectTypeOneBound\n+                bool has_dyn = false;\n+                if (t->get_id() == DYN) {\n+                    lexer.skip_token();\n+                    has_dyn = true;\n+                }\n+\n+                if (lexer.peek_token()->get_id() == LIFETIME) {\n+                    // means that cannot be TraitObjectTypeOneBound - so here for error message\n+                    error_at(lexer.peek_token()->get_locus(),\n+                      \"lifetime as bound in TraitObjectTypeOneBound \"\n+                      \"is not allowed, so cannot be TypeNoBounds\");\n+                    return NULL;\n+                }\n+\n+                // should be trait bound, so parse trait bound\n+                AST::TraitBound* initial_bound = parse_trait_bound();\n+                if (initial_bound == NULL) {\n+                    error_at(lexer.peek_token()->get_locus(),\n+                      \"failed to parse TraitObjectTypeOneBound initial bound\");\n+                    return NULL;\n+                }\n+\n+                // detect error with plus as next token\n+                t = lexer.peek_token();\n+                if (t->get_id() == PLUS) {\n+                    error_at(t->get_locus(), \"plus after trait bound means a TraitObjectType, \"\n+                                             \"which is not allowed as a TypeNoBounds\");\n+                    return NULL;\n+                }\n+\n+                // convert trait bound to value object\n+                AST::TraitBound value_bound(*initial_bound);\n+                delete initial_bound;\n+\n+                return new AST::TraitObjectTypeOneBound(::std::move(value_bound), has_dyn);\n+            }\n+            default:\n+                error_at(t->get_locus(), \"unrecognised token '%s' in type no bounds\",\n+                  t->get_token_description());\n+                return NULL;\n+        }\n+    }\n+\n+    // Parses a type no bounds beginning with '('.\n+    AST::TypeNoBounds* Parser::parse_paren_prefixed_type_no_bounds() {\n+        /* NOTE: this could probably be parsed without the HACK solution of parse_paren_prefixed_type, but\n+         * I was lazy. So FIXME for future.*/\n+        \n+        /* NOTE: again, syntactical ambiguity of a parenthesised trait bound is considered a trait bound,\n+         * not a parenthesised type, so that it can still be used in type param bounds. */\n+\n+        // skip left delim\n+        lexer.skip_token();\n+        // while next token isn't close delim, parse comma-separated types, saving whether trailing\n+        // comma happens\n+        const_TokenPtr t = lexer.peek_token();\n+        bool trailing_comma = true;\n+        ::std::vector< ::std::unique_ptr<AST::Type> > types;\n+\n+        while (t->get_id() != RIGHT_PAREN) {\n+            AST::Type* type = parse_type();\n+            if (type == NULL) {\n+                error_at(t->get_locus(),\n+                  \"failed to parse type inside parentheses (probably tuple or parenthesised)\");\n+                return NULL;\n+            }\n+            types.push_back(::std::unique_ptr<AST::Type>(type));\n+\n+            t = lexer.peek_token();\n+            if (t->get_id() != COMMA) {\n+                trailing_comma = false;\n+                break;\n+            }\n+            lexer.skip_token();\n+\n+            t = lexer.peek_token();\n+        }\n+\n+        if (!skip_token(RIGHT_PAREN)) {\n+            return NULL;\n+        }\n+\n+        // if only one type and no trailing comma, then not a tuple type\n+        if (types.size() == 1 && !trailing_comma) {\n+            // must be a TraitObjectType (with more than one bound)\n+            if (lexer.peek_token()->get_id() == PLUS) {\n+                // error - this is not allowed for type no bounds\n+                error_at(lexer.peek_token()->get_id(), \"plus (implying TraitObjectType as type param bounds) is not allowed in type no bounds\");\n+                return NULL;\n+            } else {\n+                // release vector pointer\n+                AST::Type* released_ptr = types[0].release();\n+                // HACK: attempt to convert to trait bound. if fails, parenthesised type\n+                AST::TraitBound* converted_bound = released_ptr->to_trait_bound(true);\n+                if (converted_bound == NULL) {\n+                    // parenthesised type\n+                    return new AST::ParenthesisedType(released_ptr);\n+                } else {\n+                    // trait object type (one bound)\n+                    delete released_ptr;\n+\n+                    // get value semantics trait bound\n+                    AST::TraitBound value_bound(*converted_bound);\n+                    delete converted_bound;\n+\n+                    return new AST::TraitObjectTypeOneBound(value_bound);\n+                }\n+            }\n+        } else {\n+            return new AST::TupleType(::std::move(types));\n+        }\n+        // TODO: ensure that this ensures that dynamic dispatch for traits is not lost somehow\n     }\n \n     /* Parses a literal pattern or range pattern. Assumes that literals passed in are valid range"}, {"sha": "caf13d697d37b1aca5cf63ac551c2bdc3ef83842", "filename": "gcc/rust/test3/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h?ref=bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "patch": "@@ -312,6 +312,7 @@ namespace Rust {\n         AST::ReferenceType* parse_reference_type();\n         AST::BareFunctionType* parse_bare_function_type(::std::vector<AST::LifetimeParam> for_lifetimes);\n         AST::Type* parse_paren_prefixed_type();\n+        AST::TypeNoBounds* parse_paren_prefixed_type_no_bounds();\n         AST::Type* parse_for_prefixed_type();\n         AST::MaybeNamedParam parse_maybe_named_param();\n "}]}