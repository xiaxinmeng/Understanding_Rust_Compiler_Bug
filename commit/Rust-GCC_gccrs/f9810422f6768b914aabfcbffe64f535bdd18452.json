{"sha": "f9810422f6768b914aabfcbffe64f535bdd18452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk4MTA0MjJmNjc2OGI5MTRhYWJmY2JmZmU2NGY1MzViZGQxODQ1Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-13T10:05:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-13T12:30:57Z"}, "message": "tree-optimization/100053 - fix predication in VN\n\nThis avoids doing optimistic dominance queries involving\nnon-executable backedges when validating recorded predicated values\nin VN because we have no way to force re-evaluating validity when\noptimistically not executable edges become executable later.\n\n2021-04-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/100053\n\t* tree-ssa-sccvn.c (vn_nary_op_get_predicated_value): Do\n\tnot use optimistic dominance queries for backedges to validate\n\tpredicated values.\n\t(dominated_by_p_w_unex): Add parameter to ignore executable\n\tstate on backedges.\n\t(rpo_elim::eliminate_avail): Adjust.\n\n\t* gcc.dg/torture/pr100053.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-93.c: Likewise.", "tree": {"sha": "96b2f7b6ee006f585366f93b6726acf97a5fe776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96b2f7b6ee006f585366f93b6726acf97a5fe776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9810422f6768b914aabfcbffe64f535bdd18452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9810422f6768b914aabfcbffe64f535bdd18452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9810422f6768b914aabfcbffe64f535bdd18452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9810422f6768b914aabfcbffe64f535bdd18452/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0851ac6df0596df1e3b640e58094cf94ebb790b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0851ac6df0596df1e3b640e58094cf94ebb790b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0851ac6df0596df1e3b640e58094cf94ebb790b8"}], "stats": {"total": 67, "additions": 59, "deletions": 8}, "files": [{"sha": "3d1767513f3a26dac47fa5e5254d943107ff6387", "filename": "gcc/testsuite/gcc.dg/torture/pr100053.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9810422f6768b914aabfcbffe64f535bdd18452/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100053.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9810422f6768b914aabfcbffe64f535bdd18452/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100053.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100053.c?ref=f9810422f6768b914aabfcbffe64f535bdd18452", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+\n+int __attribute__((returns_twice,noipa)) x() { return 0; }\n+void __attribute__((noipa)) ar() {}\n+void __attribute__((noipa)) as() { __builtin_abort (); }\n+int a1, a2, a3;\n+void __attribute__((noipa)) v(int init)\n+{\n+  if (!init) {\n+    as();\n+    if (a1)\n+      goto aq;\n+    x ();\n+  }\n+  ar();\n+aq:\n+  if (!init)\n+    as();\n+}\n+\n+int main()\n+{\n+  v(1);\n+  return 0;\n+}"}, {"sha": "7f66b7ee3f40609210cae6de29da3a279a4190ca", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-93.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9810422f6768b914aabfcbffe64f535bdd18452/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9810422f6768b914aabfcbffe64f535bdd18452/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-93.c?ref=f9810422f6768b914aabfcbffe64f535bdd18452", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n+\n+void bar ();\n+void foo (int pred, int *other)\n+{\n+  *other = 0;\n+  if (*other)\n+    goto cnt;\n+  if (pred)\n+    {\n+      *other = 1;\n+cnt:\n+      if (!pred)\n+        bar ();\n+    }\n+}\n+\n+/* The first VN pass should figure that if (!pred) is false because\n+   if (*other) is and thus the predicate test is redundant.  */\n+/* { dg-final { scan-tree-dump-not \"bar\" \"fre1\" } } */"}, {"sha": "ca0974d72b826254b954eed512989ff8adfec1c2", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9810422f6768b914aabfcbffe64f535bdd18452/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9810422f6768b914aabfcbffe64f535bdd18452/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=f9810422f6768b914aabfcbffe64f535bdd18452", "patch": "@@ -4171,7 +4171,7 @@ vn_nary_op_insert_pieces_predicated (unsigned int length, enum tree_code code,\n }\n \n static bool\n-dominated_by_p_w_unex (basic_block bb1, basic_block bb2);\n+dominated_by_p_w_unex (basic_block bb1, basic_block bb2, bool);\n \n static tree\n vn_nary_op_get_predicated_value (vn_nary_op_t vno, basic_block bb)\n@@ -4180,9 +4180,12 @@ vn_nary_op_get_predicated_value (vn_nary_op_t vno, basic_block bb)\n     return vno->u.result;\n   for (vn_pval *val = vno->u.values; val; val = val->next)\n     for (unsigned i = 0; i < val->n; ++i)\n-      if (dominated_by_p_w_unex (bb,\n-\t\t\t  BASIC_BLOCK_FOR_FN\n-\t\t\t    (cfun, val->valid_dominated_by_p[i])))\n+      /* Do not handle backedge executability optimistically since\n+\t when figuring out whether to iterate we do not consider\n+\t changed predication.  */\n+      if (dominated_by_p_w_unex\n+\t    (bb, BASIC_BLOCK_FOR_FN (cfun, val->valid_dominated_by_p[i]),\n+\t     false))\n \treturn val->result;\n   return NULL_TREE;\n }\n@@ -4482,10 +4485,11 @@ vn_phi_insert (gimple *phi, tree result, bool backedges_varying_p)\n \n \n /* Return true if BB1 is dominated by BB2 taking into account edges\n-   that are not executable.  */\n+   that are not executable.  When ALLOW_BACK is false consider not\n+   executable backedges as executable.  */\n \n static bool\n-dominated_by_p_w_unex (basic_block bb1, basic_block bb2)\n+dominated_by_p_w_unex (basic_block bb1, basic_block bb2, bool allow_back)\n {\n   edge_iterator ei;\n   edge e;\n@@ -4502,7 +4506,8 @@ dominated_by_p_w_unex (basic_block bb1, basic_block bb2)\n     {\n       edge prede = NULL;\n       FOR_EACH_EDGE (e, ei, bb1->preds)\n-\tif (e->flags & EDGE_EXECUTABLE)\n+\tif ((e->flags & EDGE_EXECUTABLE)\n+\t    || (!allow_back && (e->flags & EDGE_DFS_BACK)))\n \t  {\n \t    if (prede)\n \t      {\n@@ -6901,7 +6906,7 @@ rpo_elim::eliminate_avail (basic_block bb, tree op)\n \t     may also be able to \"pre-compute\" (bits of) the next immediate\n \t     (non-)dominator during the RPO walk when marking edges as\n \t     executable.  */\n-\t  if (dominated_by_p_w_unex (bb, abb))\n+\t  if (dominated_by_p_w_unex (bb, abb, true))\n \t    {\n \t      tree leader = ssa_name (av->leader);\n \t      /* Prevent eliminations that break loop-closed SSA.  */"}]}