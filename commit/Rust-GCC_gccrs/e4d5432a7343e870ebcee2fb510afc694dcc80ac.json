{"sha": "e4d5432a7343e870ebcee2fb510afc694dcc80ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRkNTQzMmE3MzQzZTg3MGViY2VlMmZiNTEwYWZjNjk0ZGNjODBhYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-03-16T17:15:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-03-16T17:15:11Z"}, "message": "re PR middle-end/15700 ([unit-at-a-time] Inlining problem leads to miscompilation of glibc)\n\n        PR middle-end/15700\n        * varasm.c (struct alias_pair): Rename from struct output_def_pair.\n        (alias_pairs): Rename from output_defs.\n        (find_decl_and_mark_needed): Split out from assemble_alias.\n        (do_assemble_alias): New.\n        (assemble_output_def): Remove.\n        (finish_aliases_1, finish_aliases_2): New.\n        (process_pending_assemble_output_defs): Remove.\n        (assemble_alias): Defer aliases for which we don't yet have a\n        non-external decl for the target symbol.\n        * passes.c (rest_of_decl_compilation): Register variables with cgraph.\n        * cgraphunit.c (cgraph_finalize_compilation_unit): Use finish_aliases_1.        * toplev.c (compile_file): Use finish_aliases_2 instead of\n        process_pending_assemble_output_defs.\n        * tree.h (finish_aliases_1, finish_aliases_2): Declare.\n        (process_pending_assemble_output_defs): Remove.\n\n        * gcc.c-torture/compile/20040323-1.c: Don't xfail for solaris.\n        (_rtld_global): New.\n        * gcc.dg/weak/weak-3.c (ffoox1f, ffoox1g): Define.\n        * gcc.dg/weak/weak-9.c (notf1, notf2, notf3, notf4): Define.\n\n        * gcc.dg/alias-3.c: New.\n        * gcc.dg/alias-4.c: New.\n        * gcc.dg/alias-5.c: New.\n        * gcc.dg/alias-6.c: New.\n\nFrom-SVN: r96564", "tree": {"sha": "dea6e2717e4d542e86bb9d06e16d59fe24986dbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dea6e2717e4d542e86bb9d06e16d59fe24986dbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4d5432a7343e870ebcee2fb510afc694dcc80ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d5432a7343e870ebcee2fb510afc694dcc80ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4d5432a7343e870ebcee2fb510afc694dcc80ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d5432a7343e870ebcee2fb510afc694dcc80ac/comments", "author": null, "committer": null, "parents": [{"sha": "5f6c8a56a726b191f7a603caa0b7dc65f2e3e5bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6c8a56a726b191f7a603caa0b7dc65f2e3e5bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f6c8a56a726b191f7a603caa0b7dc65f2e3e5bf"}], "stats": {"total": 349, "additions": 228, "deletions": 121}, "files": [{"sha": "d7b1f14df30ccd9b05fe5bcc9efb6cb6e5f8f025", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -1,3 +1,22 @@\n+2005-03-16  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/15700\n+\t* varasm.c (struct alias_pair): Rename from struct output_def_pair.\n+\t(alias_pairs): Rename from output_defs.\n+\t(find_decl_and_mark_needed): Split out from assemble_alias.\n+\t(do_assemble_alias): New.\n+\t(assemble_output_def): Remove.\n+\t(finish_aliases_1, finish_aliases_2): New.\n+\t(process_pending_assemble_output_defs): Remove.\n+\t(assemble_alias): Defer aliases for which we don't yet have a\n+\tnon-external decl for the target symbol.\n+\t* passes.c (rest_of_decl_compilation): Register variables with cgraph.\n+\t* cgraphunit.c (cgraph_finalize_compilation_unit): Use finish_aliases_1.\n+\t* toplev.c (compile_file): Use finish_aliases_2 instead of\n+\tprocess_pending_assemble_output_defs.\n+\t* tree.h (finish_aliases_1, finish_aliases_2): Declare.\n+\t(process_pending_assemble_output_defs): Remove.\n+\n 2005-03-16  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \tFix PR tree-optimization/20489"}, {"sha": "db0aaaf2adac9cd6218fd3faf803b82e3ada505a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -680,6 +680,8 @@ cgraph_finalize_compilation_unit (void)\n {\n   struct cgraph_node *node;\n \n+  finish_aliases_1 ();\n+\n   if (!flag_unit_at_a_time)\n     {\n       cgraph_assemble_pending_functions ();"}, {"sha": "7bb661d0d0ebadc06be0402063938b5f561e2c4d", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -251,6 +251,10 @@ rest_of_decl_compilation (tree decl,\n       debug_hooks->type_decl (decl, !top_level);\n       timevar_pop (TV_SYMOUT);\n     }\n+\n+  /* Let cgraph know about the existance of variables.  */\n+  if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+    cgraph_varpool_node (decl);\n }\n \n /* Called after finishing a record, union or enumeral type.  */"}, {"sha": "466b77e981686ded5e0dbe48e232a84f6e2788d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -1,3 +1,16 @@\n+2005-03-16  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/15700\n+\t* gcc.c-torture/compile/20040323-1.c: Don't xfail for solaris.\n+\t(_rtld_global): New.\n+\t* gcc.dg/weak/weak-3.c (ffoox1f, ffoox1g): Define.\n+\t* gcc.dg/weak/weak-9.c (notf1, notf2, notf3, notf4): Define.\n+\n+\t* gcc.dg/alias-3.c: New.\n+\t* gcc.dg/alias-4.c: New.\n+\t* gcc.dg/alias-5.c: New.\n+\t* gcc.dg/alias-6.c: New.\n+\n 2005-03-15  Geoffrey Keating  <geoffk@apple.com>\n \n \t* gcc.dg/cpp/ucnid-7.c: New."}, {"sha": "b5e1ce4a98cb17bc4f9a3d8d7c566f8eef966a17", "filename": "gcc/testsuite/gcc.c-torture/compile/20040323-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040323-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040323-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040323-1.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -1,7 +1,7 @@\n /* PR middle-end/14694 */\n /* { dg-require-alias \"\" } */\n-/* { dg-xfail-if \"undefined alias\" { \"*-*-solaris2.*\" } { \"*\" } { \"\" } } */\n \n+unsigned int _rtld_global;\n extern unsigned int _rtld_local __attribute__ ((alias (\"_rtld_global\")));\n \n unsigned int"}, {"sha": "3dc25a91c49adc3285418ce6cfb76b22d19c176f", "filename": "gcc/testsuite/gcc.dg/alias-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-3.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"\" } */\n+\n+extern int foo();\n+\n+int baz () { return foo(); }\n+\n+static inline int bar () __attribute__ ((alias (\"foo\"))); /* { dg-error \"aliased to\" } */\n+\n+int main () { return bar (); }"}, {"sha": "0a2633932ef55221dc383fdea5a7c30538fe12d1", "filename": "gcc/testsuite/gcc.dg/alias-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-4.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"-O2 -funit-at-a-time\" } */\n+\n+extern int foo();\n+\n+int baz () { return foo(); }\n+\n+static inline int bar () __attribute__ ((alias (\"foo\"))); /* { dg-error \"aliased to\" } */\n+\n+int main () { return bar (); }"}, {"sha": "56848c9a416436dc50daece5f23fd88d9b3e976f", "filename": "gcc/testsuite/gcc.dg/alias-5.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-5.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do link } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"\" } */\n+\n+static inline int foo () { return 0; }\n+static int bar () __attribute__ ((alias (\"foo\")));\n+int main () { return bar (); }"}, {"sha": "3ba101aa1b4d5a3530b6f50d970710c0720ddfa3", "filename": "gcc/testsuite/gcc.dg/alias-6.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Falias-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-6.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do link } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"-O2 -funit-at-a-time\" } */\n+\n+static inline int foo () { return 0; }\n+static int bar () __attribute__ ((alias (\"foo\")));\n+int main () { return bar (); }"}, {"sha": "2294ebf7b4ee8204e73d9571588e8c64ed0679e5", "filename": "gcc/testsuite/gcc.dg/weak/weak-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Fweak-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Fweak-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Fweak-3.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -52,18 +52,18 @@ void * foo1e (void)\n \n \n extern void * ffoo1f (void);    \n-extern void * ffoox1f (void);\n void * foo1f (void)\n {\n   if (ffoo1f) /* { dg-warning \"\" } */\n     ffoo1f ();\n   return 0;\n }\n+void * ffoox1f (void) { return (void *)0; }\n extern void * ffoo1f (void)  __attribute__((weak, alias (\"ffoox1f\"))); /* { dg-warning \"weak declaration\" \"weak declaration\" } */\n \n \n extern void * ffoo1g (void);\n-extern void * ffoox1g (void);\n+void * ffoox1g (void) { return (void *)0; }\n extern void * ffoo1g (void)  __attribute__((weak, alias (\"ffoox1g\")));\n void * foo1g (void)\n {"}, {"sha": "abbd0201c4642f9db6c0b29bf05aae0e894b26ab", "filename": "gcc/testsuite/gcc.dg/weak/weak-9.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Fweak-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Fweak-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Fweak-9.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -7,10 +7,11 @@\n /* { dg-final { scan-assembler \"weak\\[^ \\t\\]*\\[ \\t\\]_?f2\" } } */\n /* { dg-final { scan-assembler \"weak\\[^ \\t\\]*\\[ \\t\\]_?f3\" } } */\n /* { dg-final { scan-assembler \"weak\\[^ \\t\\]*\\[ \\t\\]_?f4\" } } */\n-/* { dg-final { scan-assembler \"notf1\" } } */\n-/* { dg-final { scan-assembler \"notf2\" } } */\n-/* { dg-final { scan-assembler \"notf3\" } } */\n-/* { dg-final { scan-assembler \"notf4\" } } */\n+\n+void notf1() { }\n+void notf2() { }\n+void notf3() { }\n+void notf4() { }\n \n void f1() __attribute__((weak, alias(\"notf1\")));\n void f2() __attribute__((alias(\"notf2\"), weak));"}, {"sha": "5eb0d0deac96ca22c608fe341b8b12b12420b6ef", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -1009,8 +1009,8 @@ compile_file (void)\n     return;\n \n   lang_hooks.decls.final_write_globals ();\n-\n   cgraph_varpool_assemble_pending_decls ();\n+  finish_aliases_2 ();\n \n   /* This must occur after the loop to output deferred functions.\n      Else the coverage initializer would not be emitted if all the\n@@ -1045,9 +1045,6 @@ compile_file (void)\n      expander can also generate them.  */\n   process_pending_assemble_externals ();\n \n-  /* Flush any pending equate directives.  */\n-  process_pending_assemble_output_defs ();\n-\n   /* Attach a special .ident directive to the end of the file to identify\n      the version of GCC which compiled this code.  The format of the .ident\n      string is patterned after the ones produced by native SVR4 compilers.  */"}, {"sha": "3ad2a5142b8d070a41a7eb20e9f4a5cca06bbdfa", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -3739,7 +3739,8 @@ extern void mark_decl_referenced (tree);\n extern void notice_global_symbol (tree);\n extern void set_user_assembler_name (tree, const char *);\n extern void process_pending_assemble_externals (void);\n-extern void process_pending_assemble_output_defs (void);\n+extern void finish_aliases_1 (void);\n+extern void finish_aliases_2 (void);\n \n /* In stmt.c */\n extern void expand_computed_goto (tree);"}, {"sha": "2f16f7e6057c66f651618c5a5521b86a968edced", "filename": "gcc/varasm.c", "status": "modified", "additions": 143, "deletions": 109, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4d5432a7343e870ebcee2fb510afc694dcc80ac/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e4d5432a7343e870ebcee2fb510afc694dcc80ac", "patch": "@@ -4335,55 +4335,139 @@ globalize_decl (tree decl)\n   targetm.asm_out.globalize_label (asm_out_file, name);\n }\n \n-/* Some targets do not allow a forward or undefined reference in a\n-   ASM_OUTPUT_DEF.  Thus, a mechanism is needed to defer the output of\n-   this assembler code.  The following struct holds the declaration\n-   and target for a deferred output define.  */\n-struct output_def_pair GTY(())\n+/* We have to be able to tell cgraph about the needed-ness of the target\n+   of an alias.  This requires that the decl have been defined.  Aliases\n+   that preceed their definition have to be queued for later processing.  */\n+\n+struct alias_pair GTY(())\n {\n   tree decl;\n   tree target;\n };\n-typedef struct output_def_pair *output_def_pair;\n+typedef struct alias_pair *alias_pair;\n \n /* Define gc'd vector type.  */\n-DEF_VEC_GC_P(output_def_pair);\n+DEF_VEC_GC_P(alias_pair);\n \n-/* Vector of output_def_pair pointers.  */\n-static GTY(()) VEC(output_def_pair) *output_defs;\n+static GTY(()) VEC(alias_pair) *alias_pairs;\n \n-#ifdef ASM_OUTPUT_DEF\n-/* Output the assembler code for a define (equate) using ASM_OUTPUT_DEF\n-   or ASM_OUTPUT_DEF_FROM_DECLS.  The function defines the symbol whose\n-   tree node is DECL to have the value of the tree node TARGET.  */\n+/* Given an assembly name, find the decl it is associated with.  At the\n+   same time, mark it needed for cgraph.  */\n+\n+static tree\n+find_decl_and_mark_needed (tree decl, tree target)\n+{\n+  struct cgraph_node *fnode = NULL;\n+  struct cgraph_varpool_node *vnode = NULL;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      fnode = cgraph_node_for_asm (target);\n+      if (fnode == NULL)\n+\tvnode = cgraph_varpool_node_for_asm (target);\n+    }\n+  else\n+    {\n+      vnode = cgraph_varpool_node_for_asm (target);\n+      if (vnode == NULL)\n+\tfnode = cgraph_node_for_asm (target);\n+    }\n+\n+  if (fnode)\n+    {\n+      cgraph_mark_needed_node (fnode);\n+      return fnode->decl;\n+    }\n+  else if (vnode)\n+    {\n+      cgraph_varpool_mark_needed_node (vnode);\n+      return vnode->decl;\n+    }\n+  else \n+    return NULL_TREE;\n+}\n \n static void\n-assemble_output_def (tree decl ATTRIBUTE_UNUSED, tree target ATTRIBUTE_UNUSED)\n+do_assemble_alias (tree decl, tree target)\n {\n-#ifdef ASM_OUTPUT_DEF_FROM_DECLS\n+  TREE_ASM_WRITTEN (decl) = 1;\n+  TREE_ASM_WRITTEN (DECL_ASSEMBLER_NAME (decl)) = 1;\n+\n+#ifdef ASM_OUTPUT_DEF\n+  /* Make name accessible from other files, if appropriate.  */\n+\n+  if (TREE_PUBLIC (decl))\n+    {\n+      globalize_decl (decl);\n+      maybe_assemble_visibility (decl);\n+    }\n+\n+# ifdef ASM_OUTPUT_DEF_FROM_DECLS\n   ASM_OUTPUT_DEF_FROM_DECLS (asm_out_file, decl, target);\n-#else\n+# else\n   ASM_OUTPUT_DEF (asm_out_file,\n \t\t  IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n \t\t  IDENTIFIER_POINTER (target));\n+# endif\n+#elif defined (ASM_OUTPUT_WEAK_ALIAS) || defined (ASM_WEAKEN_DECL)\n+  {\n+    const char *name;\n+    tree *p, t;\n+\n+    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+# ifdef ASM_WEAKEN_DECL\n+    ASM_WEAKEN_DECL (asm_out_file, decl, name, IDENTIFIER_POINTER (target));\n+# else\n+    ASM_OUTPUT_WEAK_ALIAS (asm_out_file, name, IDENTIFIER_POINTER (target));\n+# endif\n+    /* Remove this function from the pending weak list so that\n+       we do not emit multiple .weak directives for it.  */\n+    for (p = &weak_decls; (t = *p) ; )\n+      if (DECL_ASSEMBLER_NAME (decl) == DECL_ASSEMBLER_NAME (TREE_VALUE (t)))\n+\t*p = TREE_CHAIN (t);\n+      else\n+\tp = &TREE_CHAIN (t);\n+  }\n #endif\n }\n-#endif\n \n-/* Process the vector of pending assembler defines.  */\n+/* First pass of completing pending aliases.  Make sure that cgraph knows\n+   which symbols will be required.  */\n \n void\n-process_pending_assemble_output_defs (void)\n+finish_aliases_1 (void)\n {\n-#ifdef ASM_OUTPUT_DEF\n   unsigned i;\n-  output_def_pair p;\n+  alias_pair p;\n \n-  for (i = 0; VEC_iterate (output_def_pair, output_defs, i, p); i++)\n-    assemble_output_def (p->decl, p->target);\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+    {\n+      tree target_decl;\n+\n+      target_decl = find_decl_and_mark_needed (p->decl, p->target);\n+      if (target_decl == NULL)\n+\terror (\"%J%qD aliased to undefined symbol %qE\",\n+\t       p->decl, p->decl, p->target);\n+      else if (DECL_EXTERNAL (target_decl))\n+\terror (\"%J%qD aliased to external symbol %qE\",\n+\t       p->decl, p->decl, p->target);\n+    }\n+}\n \n-  output_defs = NULL;\n-#endif\n+/* Second pass of completing pending aliases.  Emit the actual assembly.\n+   This happens at the end of compilation and thus it is assured that the\n+   target symbol has been emitted.  */\n+\n+void\n+finish_aliases_2 (void)\n+{\n+  unsigned i;\n+  alias_pair p;\n+\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+    do_assemble_alias (p->decl, p->target);\n+\n+  alias_pairs = NULL;\n }\n \n /* Emit an assembler directive to make the symbol for DECL an alias to\n@@ -4392,101 +4476,51 @@ process_pending_assemble_output_defs (void)\n void\n assemble_alias (tree decl, tree target)\n {\n-  /* We must force creation of DECL_RTL for debug info generation, even though\n-     we don't use it here.  */\n-  make_decl_rtl (decl);\n-\n-#ifdef ASM_OUTPUT_DEF\n-  /* Make name accessible from other files, if appropriate.  */\n+  tree target_decl;\n \n-  if (TREE_PUBLIC (decl))\n+#if !defined (ASM_OUTPUT_DEF)\n+# if !defined(ASM_OUTPUT_WEAK_ALIAS) && !defined (ASM_WEAKEN_DECL)\n+  error (\"%Jalias definitions not supported in this configuration\", decl);\n+  return;\n+# else\n+  if (!DECL_WEAK (decl))\n     {\n-      globalize_decl (decl);\n-      maybe_assemble_visibility (decl);\n+      error (\"%Jonly weak aliases are supported in this configuration\", decl);\n+      return;\n     }\n+# endif\n+#endif\n \n-  if (TARGET_DEFERRED_OUTPUT_DEFS (decl, target))\n-    {\n-      output_def_pair p;\n+  /* We must force creation of DECL_RTL for debug info generation, even though\n+     we don't use it here.  */\n+  make_decl_rtl (decl);\n+  TREE_USED (decl) = 1;\n \n-      p = ggc_alloc (sizeof (struct output_def_pair));\n-      p->decl = decl;\n-      p->target = target;\n-      VEC_safe_push (output_def_pair, output_defs, p);\n-    }\n-  else\n-    assemble_output_def (decl, target);\n-#else /* !ASM_OUTPUT_DEF */\n-#if defined (ASM_OUTPUT_WEAK_ALIAS) || defined (ASM_WEAKEN_DECL)\n-  if (DECL_WEAK (decl))\n-    {\n-      const char *name;\n-      tree *p, t;\n+  /* A quirk of the initial implementation of aliases required that the user\n+     add \"extern\" to all of them.  Which is silly, but now historical.  Do\n+     note that the symbol is in fact locally defined.  */\n+  DECL_EXTERNAL (decl) = 0;\n \n-      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-#ifdef ASM_WEAKEN_DECL\n-      ASM_WEAKEN_DECL (asm_out_file, decl, name, IDENTIFIER_POINTER (target));\n-#else\n-      ASM_OUTPUT_WEAK_ALIAS (asm_out_file, name, IDENTIFIER_POINTER (target));\n-#endif\n-      /* Remove this function from the pending weak list so that\n-\t we do not emit multiple .weak directives for it.  */\n-      for (p = &weak_decls; (t = *p) ; )\n-\tif (DECL_ASSEMBLER_NAME (decl)\n-\t    == DECL_ASSEMBLER_NAME (TREE_VALUE (t)))\n-\t  *p = TREE_CHAIN (t);\n-\telse\n-\t  p = &TREE_CHAIN (t);\n-    }\n+  /* Allow aliases to aliases.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    cgraph_node (decl);\n   else\n-    warning (\"only weak aliases are supported in this configuration\");\n+    cgraph_varpool_node (decl);\n \n-#else\n-  warning (\"alias definitions not supported in this configuration; ignored\");\n-#endif\n-#endif\n-\n-  /* Tell cgraph that the aliased symbol is needed.  We *could* be more\n-     specific and tell cgraph about the relationship between the two\n-     symbols, but given that aliases virtually always exist for a reason,\n-     it doesn't seem worthwhile.  */\n-  if (flag_unit_at_a_time)\n+  /* If the target has already been emitted, we don't have to queue the\n+     alias.  This saves a tad o memory.  */\n+  target_decl = find_decl_and_mark_needed (decl, target);\n+  if (target_decl && TREE_ASM_WRITTEN (target_decl))\n+    do_assemble_alias (decl, target);\n+  else\n     {\n-      struct cgraph_node *fnode = NULL;\n-      struct cgraph_varpool_node *vnode = NULL;\n-\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  fnode = cgraph_node_for_asm (target);\n-\t  if (fnode != NULL)\n-\t    cgraph_mark_needed_node (fnode);\n-\t  else\n-\t    {\n-\t      vnode = cgraph_varpool_node_for_asm (target);\n-\t      if (vnode != NULL)\n-\t\tcgraph_varpool_mark_needed_node (vnode);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  vnode = cgraph_varpool_node_for_asm (target);\n-\t  if (vnode != NULL)\n-\t    cgraph_varpool_mark_needed_node (vnode);\n-\t  else\n-\t    {\n-\t      fnode = cgraph_node_for_asm (target);\n-\t      if (fnode != NULL)\n-\t\tcgraph_mark_needed_node (fnode);\n-\t    }\n-\t}\n+      alias_pair p;\n \n-      if (fnode == NULL && vnode == NULL)\n-\twarning (\"%qD aliased to undefined symbol %qE\", decl, target);\n+      p = ggc_alloc (sizeof (struct alias_pair));\n+      p->decl = decl;\n+      p->target = target;\n+      VEC_safe_push (alias_pair, alias_pairs, p);\n     }\n-\n-  TREE_USED (decl) = 1;\n-  TREE_ASM_WRITTEN (decl) = 1;\n-  TREE_ASM_WRITTEN (DECL_ASSEMBLER_NAME (decl)) = 1;\n }\n \n /* Emit an assembler directive to set symbol for DECL visibility to"}]}