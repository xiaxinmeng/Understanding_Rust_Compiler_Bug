{"sha": "cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IzZDU5N2QxNTQ3NWExMmQzN2EzYzAxZGM3ZjhlMTJkMmM5ZWZmMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-13T07:08:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-13T07:08:24Z"}, "message": "gimple.c (walk_gimple_op): Do not request a pure rvalue on the RHS if the LHS is of a non-renamable type.\n\n\t* gimple.c (walk_gimple_op) <GIMPLE_ASSIGN>: Do not request a pure\n\trvalue on the RHS if the LHS is of a non-renamable type.\n\t* tree-ssa-ccp.c (maybe_fold_offset_to_component_ref): Fold result.\nada/\n\t* gcc-interface/ada-tree.h (TYPE_BY_REFERENCE_P): Delete.\n\t(DECL_CONST_ADDRESS_P): New macro.\n\t(SET_DECL_ORIGINAL_FIELD_TO_FIELD): Likewise.\n\t(SAME_FIELD_P): Likewise.\n\t* gcc-interface/decl.c (constructor_address_p): New static function.\n\t(gnat_to_gnu_entity) <object>: Set DECL_CONST_ADDRESS_P according to\n\tthe return value of above function.\n\t(gnat_to_gnu_entity) <E_Record_Type>: Force BLKmode for all types\n\tpassed by reference.\n\t<E_Record_Subtype>: Likewise.\n\tSet TREE_ADDRESSABLE on the type if it passed by reference.\n\t(make_packable_type): Use SET_DECL_ORIGINAL_FIELD_TO_FIELD.\n\t(create_field_decl_from): Likewise.\n\t(substitute_in_type): Likewise.\n\t(purpose_member_field): Use SAME_FIELD_P.\n\t* gcc-interface/misc.c (must_pass_by_ref): Test TREE_ADDRESSABLE.\n\t* gcc-interface/trans.c (lvalue_required_p): Add ADDRESS_OF_CONSTANT\n\tparameter and adjust recursive calls.\n\t<N_Explicit_Dereference>: New case.\n\t<N_Object_Declaration>: Return 1 if the object is of a class-wide type.\n\tAdjust calls to lvalue_required_p.  Do not return the initializer of a\n\tDECL_CONST_ADDRESS_P constant if an lvalue is required for it.\n\t(call_to_gnu): Delay issuing error message for a misaligned actual and\n\tavoid the associated back-end assertion.  Test TREE_ADDRESSABLE.\n\t(gnat_gimplify_expr) <ADDR_EXPR>: Handle non-static constructors.\n\t* gcc-interface/utils.c (make_dummy_type): Set TREE_ADDRESSABLE if the\n\ttype is passed by reference.\n\t(convert) <CONSTRUCTOR>: Convert in-place in more cases.\n\t* gcc-interface/utils2.c (build_cond_expr): Drop TYPE_BY_REFERENCE_P.\n\t(build_simple_component_ref): Use SAME_FIELD_P.\n\nFrom-SVN: r158254", "tree": {"sha": "bf559cb3cbc9bf9f08b0f715c226ff0bb8c697a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf559cb3cbc9bf9f08b0f715c226ff0bb8c697a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/comments", "author": null, "committer": null, "parents": [{"sha": "b7e757713c17d27acbce6bb2d2dd19f226e2e552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e757713c17d27acbce6bb2d2dd19f226e2e552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e757713c17d27acbce6bb2d2dd19f226e2e552"}], "stats": {"total": 333, "additions": 227, "deletions": 106}, "files": [{"sha": "c011b80865865aea681147c76f4061960c912f46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -1,3 +1,9 @@\n+2010-04-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimple.c (walk_gimple_op) <GIMPLE_ASSIGN>: Do not request a pure\n+\trvalue on the RHS if the LHS is of a non-renamable type.\n+\t* tree-ssa-ccp.c (maybe_fold_offset_to_component_ref): Fold result.\n+\n 2010-04-13  Matthias Klose  <doko@ubuntu.com>\n \n \t* gcc.c (cc1_options): Handle -iplugindir before processing"}, {"sha": "233c8b952fd0848d9e6a47c830dcedcbe3f708ea", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -1,3 +1,36 @@\n+2010-04-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_BY_REFERENCE_P): Delete.\n+\t(DECL_CONST_ADDRESS_P): New macro.\n+\t(SET_DECL_ORIGINAL_FIELD_TO_FIELD): Likewise.\n+\t(SAME_FIELD_P): Likewise.\n+\t* gcc-interface/decl.c (constructor_address_p): New static function.\n+\t(gnat_to_gnu_entity) <object>: Set DECL_CONST_ADDRESS_P according to\n+\tthe return value of above function.\n+\t(gnat_to_gnu_entity) <E_Record_Type>: Force BLKmode for all types\n+\tpassed by reference.\n+\t<E_Record_Subtype>: Likewise.\n+\tSet TREE_ADDRESSABLE on the type if it passed by reference.\n+\t(make_packable_type): Use SET_DECL_ORIGINAL_FIELD_TO_FIELD.\n+\t(create_field_decl_from): Likewise.\n+\t(substitute_in_type): Likewise.\n+\t(purpose_member_field): Use SAME_FIELD_P.\n+\t* gcc-interface/misc.c (must_pass_by_ref): Test TREE_ADDRESSABLE.\n+\t* gcc-interface/trans.c (lvalue_required_p): Add ADDRESS_OF_CONSTANT\n+\tparameter and adjust recursive calls.\n+\t<N_Explicit_Dereference>: New case.\n+\t<N_Object_Declaration>: Return 1 if the object is of a class-wide type.\n+\tAdjust calls to lvalue_required_p.  Do not return the initializer of a\n+\tDECL_CONST_ADDRESS_P constant if an lvalue is required for it.\n+\t(call_to_gnu): Delay issuing error message for a misaligned actual and\n+\tavoid the associated back-end assertion.  Test TREE_ADDRESSABLE.\n+\t(gnat_gimplify_expr) <ADDR_EXPR>: Handle non-static constructors.\n+\t* gcc-interface/utils.c (make_dummy_type): Set TREE_ADDRESSABLE if the\n+\ttype is passed by reference.\n+\t(convert) <CONSTRUCTOR>: Convert in-place in more cases.\n+\t* gcc-interface/utils2.c (build_cond_expr): Drop TYPE_BY_REFERENCE_P.\n+\t(build_simple_component_ref): Use SAME_FIELD_P.\n+\n 2010-04-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Identifier_to_gnu): Use boolean variable."}, {"sha": "5c54c30c375a8fe8d761b738f67173eefd2b02a1", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -102,9 +102,6 @@ do {\t\t\t\t\t\t\t    \\\n    front-end.  */\n #define TYPE_EXTRA_SUBTYPE_P(NODE) TYPE_LANG_FLAG_2 (NODE)\n \n-/* Nonzero for composite types if this is a by-reference type.  */\n-#define TYPE_BY_REFERENCE_P(NODE) TYPE_LANG_FLAG_2 (NODE)\n-\n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is the\n    type for an object whose type includes its template in addition to\n    its value (only true for RECORD_TYPE).  */\n@@ -325,6 +322,10 @@ do {\t\t\t\t\t\t   \\\n    been elaborated and TREE_READONLY is not set on it.  */\n #define DECL_READONLY_ONCE_ELAB(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n \n+/* Nonzero in a CONST_DECL if its value is (essentially) the address of a\n+   constant CONSTRUCTOR.  */\n+#define DECL_CONST_ADDRESS_P(NODE) DECL_LANG_FLAG_0 (CONST_DECL_CHECK (NODE))\n+\n /* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF\n    is needed to access the object.  */\n #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n@@ -369,6 +370,20 @@ do {\t\t\t\t\t\t   \\\n #define SET_DECL_ORIGINAL_FIELD(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE), X)\n \n+/* Set DECL_ORIGINAL_FIELD of FIELD1 to (that of) FIELD2.  */\n+#define SET_DECL_ORIGINAL_FIELD_TO_FIELD(FIELD1, FIELD2)\t\\\n+  SET_DECL_ORIGINAL_FIELD ((FIELD1),\t\t\t\t\\\n+\t\t\t   DECL_ORIGINAL_FIELD (FIELD2)\t\t\\\n+\t\t\t   ? DECL_ORIGINAL_FIELD (FIELD2) : (FIELD2))\n+\n+/* Return true if FIELD1 and FIELD2 represent the same field.  */\n+#define SAME_FIELD_P(FIELD1, FIELD2)\t\t\t\t\t\\\n+  ((FIELD1) == (FIELD2)\t\t\t\t\t\t\t\\\n+   || DECL_ORIGINAL_FIELD (FIELD1) == (FIELD2)\t\t\t\t\\\n+   || (FIELD1) == DECL_ORIGINAL_FIELD (FIELD2)\t\t\t\t\\\n+   || (DECL_ORIGINAL_FIELD (FIELD1)\t\t\t\t\t\\\n+       && (DECL_ORIGINAL_FIELD (FIELD1) == DECL_ORIGINAL_FIELD (FIELD2))))\n+\n /* In a VAR_DECL, points to the object being renamed if the VAR_DECL is a\n    renaming pointer, otherwise 0.  Note that this object is guaranteed to\n    be protected against multiple evaluations.  */"}, {"sha": "a333170cb1671a7204117de81009876ec1afe286", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -138,6 +138,7 @@ static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n static bool cannot_be_superflat_p (Node_Id);\n+static bool constructor_address_p (tree);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n \t\t\t\t  bool, bool, bool, bool, bool);\n static Uint annotate_value (tree);\n@@ -1376,6 +1377,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    DECL_IGNORED_P (gnu_decl) = 1;\n \t  }\n \n+\t/* If this is a constant, even if we don't need a true variable, we\n+\t   may need to avoid returning the initializer in every case.  That\n+\t   can happen for the address of a (constant) constructor because,\n+\t   upon dereferencing it, the constructor will be reinjected in the\n+\t   tree, which may not be valid in every case; see lvalue_required_p\n+\t   for more details.  */\n+\tif (TREE_CODE (gnu_decl) == CONST_DECL)\n+\t  DECL_CONST_ADDRESS_P (gnu_decl) = constructor_address_p (gnu_expr);\n+\n \t/* If this is declared in a block that contains a block with an\n \t   exception handler, we must force this variable in memory to\n \t   suppress an invalid optimization.  */\n@@ -2892,10 +2902,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      false, all_rep, is_unchecked_union,\n \t\t\t      debug_info_p, false);\n \n-\t/* If it is a tagged record force the type to BLKmode to insure that\n-\t   these objects will always be put in memory.  Likewise for limited\n-\t   record types.  */\n-\tif (Is_Tagged_Type (gnat_entity) || Is_Limited_Record (gnat_entity))\n+\t/* If it is passed by reference, force BLKmode to ensure that objects\n++\t   of this type will always be put in memory.  */\n+\tif (Is_By_Reference_Type (gnat_entity))\n \t  SET_TYPE_MODE (gnu_type, BLKmode);\n \n \t/* We used to remove the associations of the discriminants and _Parent\n@@ -3216,8 +3225,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      finish_record_type (gnu_type, gnu_field_list, 2, false);\n \n \t      /* See the E_Record_Type case for the rationale.  */\n-\t      if (Is_Tagged_Type (gnat_entity)\n-\t\t  || Is_Limited_Record (gnat_entity))\n+\t      if (Is_By_Reference_Type (gnat_entity))\n \t\tSET_TYPE_MODE (gnu_type, BLKmode);\n \t      else\n \t\tcompute_record_mode (gnu_type);\n@@ -4388,8 +4396,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  || Is_Class_Wide_Equivalent_Type (gnat_entity))\n \tTYPE_ALIGN_OK (gnu_type) = 1;\n \n-      if (AGGREGATE_TYPE_P (gnu_type) && Is_By_Reference_Type (gnat_entity))\n-\tTYPE_BY_REFERENCE_P (gnu_type) = 1;\n+      /* If the type is passed by reference, objects of this type must be\n+\t fully addressable and cannot be copied.  */\n+      if (Is_By_Reference_Type (gnat_entity))\n+\tTREE_ADDRESSABLE (gnu_type) = 1;\n \n       /* ??? Don't set the size for a String_Literal since it is either\n \t confirming or we don't handle it properly (if the low bound is\n@@ -5397,6 +5407,20 @@ cannot_be_superflat_p (Node_Id gnat_range)\n \n   return (tree_int_cst_lt (gnu_hb, gnu_lb) == 0);\n }\n+\n+/* Return true if GNU_EXPR is (essentially) the address of a CONSTRUCTOR.  */\n+\n+static bool\n+constructor_address_p (tree gnu_expr)\n+{\n+  while (TREE_CODE (gnu_expr) == NOP_EXPR\n+\t || TREE_CODE (gnu_expr) == CONVERT_EXPR\n+\t || TREE_CODE (gnu_expr) == NON_LVALUE_EXPR)\n+    gnu_expr = TREE_OPERAND (gnu_expr, 0);\n+\n+  return (TREE_CODE (gnu_expr) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (gnu_expr, 0)) == CONSTRUCTOR);\n+}\n \f\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n@@ -6033,10 +6057,7 @@ make_packable_type (tree type, bool in_record)\n \t\t\t\t     !DECL_NONADDRESSABLE_P (old_field));\n \n       DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n-      SET_DECL_ORIGINAL_FIELD\n-\t(new_field, (DECL_ORIGINAL_FIELD (old_field)\n-\t\t     ? DECL_ORIGINAL_FIELD (old_field) : old_field));\n-\n+      SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, old_field);\n       if (TREE_CODE (new_type) == QUAL_UNION_TYPE)\n \tDECL_QUALIFIER (new_field) = DECL_QUALIFIER (old_field);\n \n@@ -7253,17 +7274,16 @@ annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref)\n \t\t   UI_From_Int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n }\n \n-/* Return first element of field list whose TREE_PURPOSE is ELEM or whose\n-   DECL_ORIGINAL_FIELD of TREE_PURPOSE is ELEM.  Return NULL_TREE if there\n-   is no such element in the list.  */\n+/* Return first element of field list whose TREE_PURPOSE is the same as ELEM.\n+   Return NULL_TREE if there is no such element in the list.  */\n \n static tree\n purpose_member_field (const_tree elem, tree list)\n {\n   while (list)\n     {\n       tree field = TREE_PURPOSE (list);\n-      if (elem == field || elem == DECL_ORIGINAL_FIELD (field))\n+      if (SAME_FIELD_P (field, elem))\n \treturn list;\n       list = TREE_CHAIN (list);\n     }\n@@ -8035,8 +8055,7 @@ create_field_decl_from (tree old_field, tree field_type, tree record_type,\n     }\n \n   DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n-  t = DECL_ORIGINAL_FIELD (old_field);\n-  SET_DECL_ORIGINAL_FIELD (new_field, t ? t : old_field);\n+  SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, old_field);\n   DECL_DISCRIMINANT_NUMBER (new_field) = DECL_DISCRIMINANT_NUMBER (old_field);\n   TREE_THIS_VOLATILE (new_field) = TREE_THIS_VOLATILE (old_field);\n \n@@ -8372,9 +8391,7 @@ substitute_in_type (tree t, tree f, tree r)\n \t      }\n \n \t    DECL_CONTEXT (new_field) = nt;\n-\t    SET_DECL_ORIGINAL_FIELD (new_field,\n-\t\t\t\t     (DECL_ORIGINAL_FIELD (field)\n-\t\t\t\t      ? DECL_ORIGINAL_FIELD (field) : field));\n+\t    SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, field);\n \n \t    TREE_CHAIN (new_field) = TYPE_FIELDS (nt);\n \t    TYPE_FIELDS (nt) = new_field;"}, {"sha": "8c647d35972a6ee921a668f102219fda8dc1b24c", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -700,7 +700,7 @@ must_pass_by_ref (tree gnu_type)\n      and does not produce compatibility problems with C, since C does\n      not have such objects.  */\n   return (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n-\t  || (AGGREGATE_TYPE_P (gnu_type) && TYPE_BY_REFERENCE_P (gnu_type))\n+\t  || TREE_ADDRESSABLE (gnu_type)\n \t  || (TYPE_SIZE (gnu_type)\n \t      && TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST));\n }"}, {"sha": "97ac2f381080378d93d1ac976efb13fa924095e0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 102, "deletions": 55, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -215,7 +215,7 @@ static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n static void set_expr_location_from_node (tree, Node_Id);\n-static int lvalue_required_p (Node_Id, tree, bool, bool);\n+static int lvalue_required_p (Node_Id, tree, bool, bool, bool);\n \n /* Hooks for debug info back-ends, only supported and used in a restricted set\n    of configurations.  */\n@@ -703,8 +703,9 @@ lvalue_required_for_attribute_p (Node_Id gnat_node)\n /* Return a positive value if an lvalue is required for GNAT_NODE.  GNU_TYPE\n    is the type that will be used for GNAT_NODE in the translated GNU tree.\n    CONSTANT indicates whether the underlying object represented by GNAT_NODE\n-   is constant in the Ada sense, ALIASED whether it is aliased (but the latter\n-   doesn't affect the outcome if CONSTANT is not true).\n+   is constant in the Ada sense.  If it is, ADDRESS_OF_CONSTANT indicates\n+   whether its value is the address of a constant and ALIASED whether it is\n+   aliased.  If it isn't, ADDRESS_OF_CONSTANT and ALIASED are ignored.\n \n    The function climbs up the GNAT tree starting from the node and returns 1\n    upon encountering a node that effectively requires an lvalue downstream.\n@@ -713,7 +714,7 @@ lvalue_required_for_attribute_p (Node_Id gnat_node)\n \n static int\n lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n-\t\t   bool aliased)\n+\t\t   bool address_of_constant, bool aliased)\n {\n   Node_Id gnat_parent = Parent (gnat_node), gnat_temp;\n \n@@ -753,11 +754,13 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \treturn 0;\n \n       aliased |= Has_Aliased_Components (Etype (gnat_node));\n-      return lvalue_required_p (gnat_parent, gnu_type, constant, aliased);\n+      return lvalue_required_p (gnat_parent, gnu_type, constant,\n+\t\t\t\taddress_of_constant, aliased);\n \n     case N_Selected_Component:\n       aliased |= Is_Aliased (Entity (Selector_Name (gnat_parent)));\n-      return lvalue_required_p (gnat_parent, gnu_type, constant, aliased);\n+      return lvalue_required_p (gnat_parent, gnu_type, constant,\n+\t\t\t\taddress_of_constant, aliased);\n \n     case N_Object_Renaming_Declaration:\n       /* We need to make a real renaming only if the constant object is\n@@ -775,8 +778,14 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n     case N_Object_Declaration:\n       /* We cannot use a constructor if this is an atomic object because\n \t the actual assignment might end up being done component-wise.  */\n-      return Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n-\t     && Is_Atomic (Defining_Entity (gnat_parent));\n+      return ((Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n+\t       && Is_Atomic (Defining_Entity (gnat_parent)))\n+\t      /* We don't use a constructor if this is a class-wide object\n+\t\t because the effective type of the object is the equivalent\n+\t\t type of the class-wide subtype and it smashes most of the\n+\t\t data into an array of bytes to which we cannot convert.  */\n+\t      || Ekind ((Etype (Defining_Entity (gnat_parent))))\n+\t\t == E_Class_Wide_Subtype);\n \n     case N_Assignment_Statement:\n       /* We cannot use a constructor if the LHS is an atomic object because\n@@ -790,7 +799,17 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \t go through the conversion.  */\n       return lvalue_required_p (gnat_parent,\n \t\t\t\tget_unpadded_type (Etype (gnat_parent)),\n-\t\t\t\tconstant, aliased);\n+\t\t\t\tconstant, address_of_constant, aliased);\n+\n+   case N_Explicit_Dereference:\n+      /* We look through dereferences for address of constant because we need\n+\t to handle the special cases listed above.  */\n+      if (constant && address_of_constant)\n+\treturn lvalue_required_p (gnat_parent,\n+\t\t\t\t  get_unpadded_type (Etype (gnat_parent)),\n+\t\t\t\t  true, false, true);\n+\n+      /* ... fall through ... */\n \n     default:\n       return 0;\n@@ -895,12 +914,13 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      statement alternative or a record discriminant.  There is no possible\n      volatile-ness short-circuit here since Volatile constants must bei\n      imported per C.6.  */\n-  if (Ekind (gnat_temp) == E_Constant && Is_Scalar_Type (gnat_temp_type)\n+  if (Ekind (gnat_temp) == E_Constant\n+      && Is_Scalar_Type (gnat_temp_type)\n       && !Is_Imported (gnat_temp)\n       && Present (Address_Clause (gnat_temp)))\n     {\n       require_lvalue = lvalue_required_p (gnat_node, gnu_result_type, true,\n-\t\t\t\t\t  Is_Aliased (gnat_temp));\n+\t\t\t\t\t  false, Is_Aliased (gnat_temp));\n       use_constant_initializer = !require_lvalue;\n     }\n \n@@ -999,15 +1019,18 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n     {\n       bool constant_only = (TREE_CODE (gnu_result) == CONST_DECL\n \t\t\t    && !DECL_CONST_CORRESPONDING_VAR (gnu_result));\n-\n-      /* If there is a (corresponding) variable, we only want to return\n-\t the constant value if an lvalue is not required.  Evaluate this\n-\t now if we have not already done so.  */\n-      if (!constant_only && require_lvalue < 0)\n-\trequire_lvalue = lvalue_required_p (gnat_node, gnu_result_type, true,\n-\t\t\t\t\t    Is_Aliased (gnat_temp));\n-\n-      if (constant_only || !require_lvalue)\n+      bool address_of_constant = (TREE_CODE (gnu_result) == CONST_DECL\n+\t\t\t\t  && DECL_CONST_ADDRESS_P (gnu_result));\n+\n+      /* If there is a (corresponding) variable or this is the address of a\n+\t constant, we only want to return the initializer if an lvalue isn't\n+\t required.  Evaluate this now if we have not already done so.  */\n+      if ((!constant_only || address_of_constant) && require_lvalue < 0)\n+\trequire_lvalue\n+\t  = lvalue_required_p (gnat_node, gnu_result_type, true,\n+\t\t\t       address_of_constant, Is_Aliased (gnat_temp));\n+\n+      if ((constant_only && !address_of_constant) || !require_lvalue)\n \tgnu_result = unshare_expr (DECL_INITIAL (gnu_result));\n     }\n \n@@ -2538,29 +2561,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t{\n \t  tree gnu_copy = gnu_name;\n \n-\t  /* If the type is passed by reference, a copy is not allowed.  */\n-\t  if (AGGREGATE_TYPE_P (gnu_formal_type)\n-\t      && TYPE_BY_REFERENCE_P (gnu_formal_type))\n-\t    post_error\n-\t      (\"misaligned actual cannot be passed by reference\", gnat_actual);\n-\n-\t  /* For users of Starlet we issue a warning because the interface\n-\t     apparently assumes that by-ref parameters outlive the procedure\n-\t     invocation.  The code still will not work as intended, but we\n-\t     cannot do much better since low-level parts of the back-end\n-\t     would allocate temporaries at will because of the misalignment\n-\t     if we did not do so here.  */\n-\t  else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n-\t    {\n-\t      post_error\n-\t\t(\"?possible violation of implicit assumption\", gnat_actual);\n-\t      post_error_ne\n-\t\t(\"?made by pragma Import_Valued_Procedure on &\", gnat_actual,\n-\t\t Entity (Name (gnat_node)));\n-\t      post_error_ne (\"?because of misalignment of &\", gnat_actual,\n-\t\t\t     gnat_formal);\n-\t    }\n-\n \t  /* If the actual type of the object is already the nominal type,\n \t     we have nothing to do, except if the size is self-referential\n \t     in which case we'll remove the unpadding below.  */\n@@ -2593,6 +2593,33 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  gnu_name = build1 (SAVE_EXPR, TREE_TYPE (gnu_name), gnu_name);\n \t  TREE_SIDE_EFFECTS (gnu_name) = 1;\n \n+\t  /* If the type is passed by reference, a copy is not allowed.  */\n+\t  if (TREE_ADDRESSABLE (gnu_formal_type))\n+\t    {\n+\t      post_error (\"misaligned actual cannot be passed by reference\",\n+\t\t\t  gnat_actual);\n+\n+\t      /* Avoid the back-end assertion on temporary creation.  */\n+\t      gnu_name = TREE_OPERAND (gnu_name, 0);\n+\t    }\n+\n+\t  /* For users of Starlet we issue a warning because the interface\n+\t     apparently assumes that by-ref parameters outlive the procedure\n+\t     invocation.  The code still will not work as intended, but we\n+\t     cannot do much better since low-level parts of the back-end\n+\t     would allocate temporaries at will because of the misalignment\n+\t     if we did not do so here.  */\n+\t  else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n+\t    {\n+\t      post_error\n+\t\t(\"?possible violation of implicit assumption\", gnat_actual);\n+\t      post_error_ne\n+\t\t(\"?made by pragma Import_Valued_Procedure on &\", gnat_actual,\n+\t\t Entity (Name (gnat_node)));\n+\t      post_error_ne (\"?because of misalignment of &\", gnat_actual,\n+\t\t\t     gnat_formal);\n+\t    }\n+\n \t  /* Set up to move the copy back to the original if needed.  */\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n@@ -5770,21 +5797,41 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n     case ADDR_EXPR:\n       op = TREE_OPERAND (expr, 0);\n \n-      /* If we are taking the address of a constant CONSTRUCTOR, force it to\n-\t be put into static memory.  We know it's going to be readonly given\n-\t the semantics we have and it's required to be in static memory when\n-\t the reference is in an elaboration procedure.  */\n-      if (TREE_CODE (op) == CONSTRUCTOR && TREE_CONSTANT (op))\n+      if (TREE_CODE (op) == CONSTRUCTOR)\n \t{\n-\t  tree new_var = create_tmp_var (TREE_TYPE (op), \"C\");\n-\t  TREE_ADDRESSABLE (new_var) = 1;\n+\t  /* If we are taking the address of a constant CONSTRUCTOR, make sure\n+\t     it is put into static memory.  We know it's going to be read-only\n+\t     given the semantics we have and it must be in static memory when\n+\t     the reference is in an elaboration procedure.  */\n+\t  if (TREE_CONSTANT (op))\n+\t    {\n+\t      tree new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n+\t      TREE_ADDRESSABLE (new_var) = 1;\n+\t      gimple_add_tmp_var (new_var);\n \n-\t  TREE_READONLY (new_var) = 1;\n-\t  TREE_STATIC (new_var) = 1;\n-\t  DECL_INITIAL (new_var) = op;\n+\t      TREE_READONLY (new_var) = 1;\n+\t      TREE_STATIC (new_var) = 1;\n+\t      DECL_INITIAL (new_var) = op;\n+\n+\t      TREE_OPERAND (expr, 0) = new_var;\n+\t      recompute_tree_invariant_for_addr_expr (expr);\n+\t    }\n+\n+\t  /* Otherwise explicitly create the local temporary.  That's required\n+\t     if the type is passed by reference.  */\n+\t  else\n+\t    {\n+\t      tree mod, new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n+\t      TREE_ADDRESSABLE (new_var) = 1;\n+\t      gimple_add_tmp_var (new_var);\n+\n+\t      mod = build2 (INIT_EXPR, TREE_TYPE (new_var), new_var, op);\n+\t      gimplify_and_add (mod, pre_p);\n+\n+\t      TREE_OPERAND (expr, 0) = new_var;\n+\t      recompute_tree_invariant_for_addr_expr (expr);\n+\t    }\n \n-\t  TREE_OPERAND (expr, 0) = new_var;\n-\t  recompute_tree_invariant_for_addr_expr (expr);\n \t  return GS_ALL_DONE;\n \t}\n "}, {"sha": "7353bdc7a82db60f21473adf91af44a480bf7f3a", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -294,8 +294,8 @@ make_dummy_type (Entity_Id gnat_type)\n   TYPE_DUMMY_P (gnu_type) = 1;\n   TYPE_STUB_DECL (gnu_type)\n     = create_type_stub_decl (TYPE_NAME (gnu_type), gnu_type);\n-  if (AGGREGATE_TYPE_P (gnu_type) && Is_By_Reference_Type (gnat_type))\n-    TYPE_BY_REFERENCE_P (gnu_type) = 1;\n+  if (Is_By_Reference_Type (gnat_type))\n+    TREE_ADDRESSABLE (gnu_type) = 1;\n \n   SET_DUMMY_NODE (gnat_underlying, gnu_type);\n \n@@ -3852,11 +3852,14 @@ convert (tree type, tree expr)\n \t  return expr;\n \t}\n \n-      /* Likewise for a conversion between original and packable version, but\n-\t we have to work harder in order to preserve type consistency.  */\n+      /* Likewise for a conversion between original and packable version, or\n+\t conversion between types of the same size and with the same list of\n+\t fields, but we have to work harder to preserve type consistency.  */\n       if (code == ecode\n \t  && code == RECORD_TYPE\n-\t  && TYPE_NAME (type) == TYPE_NAME (etype))\n+\t  && (TYPE_NAME (type) == TYPE_NAME (etype)\n+\t      || tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (etype))))\n+\n \t{\n \t  VEC(constructor_elt,gc) *e = CONSTRUCTOR_ELTS (expr);\n \t  unsigned HOST_WIDE_INT len = VEC_length (constructor_elt, e);\n@@ -3871,10 +3874,14 @@ convert (tree type, tree expr)\n \n \t  FOR_EACH_CONSTRUCTOR_ELT(e, idx, index, value)\n \t    {\n-\t      constructor_elt *elt = VEC_quick_push (constructor_elt, v, NULL);\n-\t      /* We expect only simple constructors.  Otherwise, punt.  */\n-\t      if (!(index == efield || index == DECL_ORIGINAL_FIELD (efield)))\n+\t      constructor_elt *elt;\n+\t      /* We expect only simple constructors.  */\n+\t      if (!SAME_FIELD_P (index, efield))\n+\t\tbreak;\n+\t      /* The field must be the same.  */\n+\t      if (!SAME_FIELD_P (efield, field))\n \t\tbreak;\n+\t      elt = VEC_quick_push (constructor_elt, v, NULL);\n \t      elt->index = field;\n \t      elt->value = convert (TREE_TYPE (field), value);\n "}, {"sha": "dbe83ed7ff8768bda82232acafbfa839d42628f3", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -1293,10 +1293,9 @@ build_cond_expr (tree result_type, tree condition_operand,\n \n   /* If the result type is unconstrained, take the address of the operands and\n      then dereference the result.  Likewise if the result type is passed by\n-     reference because creating a temporary of this type is not allowed.  */\n+     reference, but this is natively handled in the gimplifier.  */\n   if (TREE_CODE (result_type) == UNCONSTRAINED_ARRAY_TYPE\n-      || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (result_type))\n-      || (AGGREGATE_TYPE_P (result_type) && TYPE_BY_REFERENCE_P (result_type)))\n+      || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (result_type)))\n     {\n       result_type = build_pointer_type (result_type);\n       true_operand = build_unary_op (ADDR_EXPR, result_type, true_operand);\n@@ -1588,22 +1587,15 @@ build_simple_component_ref (tree record_variable, tree component,\n       tree new_field;\n \n       /* First loop thru normal components.  */\n-\n       for (new_field = TYPE_FIELDS (record_type); new_field;\n \t   new_field = TREE_CHAIN (new_field))\n-\tif (field == new_field\n-\t    || DECL_ORIGINAL_FIELD (new_field) == field\n-\t    || new_field == DECL_ORIGINAL_FIELD (field)\n-\t    || (DECL_ORIGINAL_FIELD (field)\n-\t\t&& (DECL_ORIGINAL_FIELD (field)\n-\t\t    == DECL_ORIGINAL_FIELD (new_field))))\n+\tif (SAME_FIELD_P (field, new_field))\n \t  break;\n \n       /* Next, loop thru DECL_INTERNAL_P components if we haven't found\n          the component in the first search. Doing this search in 2 steps\n          is required to avoiding hidden homonymous fields in the\n          _Parent field.  */\n-\n       if (!new_field)\n \tfor (new_field = TYPE_FIELDS (record_type); new_field;\n \t     new_field = TREE_CHAIN (new_field))"}, {"sha": "aab6ef25f34210af95d18e8b6c3e7c3a8cca2776", "filename": "gcc/gimple.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -1324,11 +1324,15 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n-      /* Walk the RHS operands.  A formal temporary LHS may use a\n-\t COMPONENT_REF RHS.  */\n+      /* Walk the RHS operands.  If the LHS is of a non-renamable type or\n+         is a register variable, we may use a COMPONENT_REF on the RHS.  */\n       if (wi)\n-\twi->val_only = !is_gimple_reg (gimple_assign_lhs (stmt))\n-                       || !gimple_assign_single_p (stmt);\n+\t{\n+\t  tree lhs = gimple_assign_lhs (stmt);\n+\t  wi->val_only\n+\t    = (is_gimple_reg_type (TREE_TYPE (lhs)) && !is_gimple_reg (lhs))\n+\t      || !gimple_assign_single_p (stmt);\n+\t}\n \n       for (i = 1; i < gimple_num_ops (stmt); i++)\n \t{"}, {"sha": "e6149490774faeec3df7b7bad619b43c22b93bb1", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=cb3d597d15475a12d37a3c01dc7f8e12d2c9eff1", "patch": "@@ -1980,7 +1980,7 @@ maybe_fold_offset_to_component_ref (location_t loc, tree record_type,\n       if (cmp == 0\n \t  && useless_type_conversion_p (orig_type, field_type))\n \t{\n-\t  t = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n+\t  t = fold_build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n \t  return t;\n \t}\n \n@@ -2004,7 +2004,7 @@ maybe_fold_offset_to_component_ref (location_t loc, tree record_type,\n \n       /* If we matched, then set offset to the displacement into\n \t this field.  */\n-      new_base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n+      new_base = fold_build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n       SET_EXPR_LOCATION (new_base, loc);\n \n       /* Recurse to possibly find the match.  */\n@@ -2027,7 +2027,7 @@ maybe_fold_offset_to_component_ref (location_t loc, tree record_type,\n \n   /* If we get here, we've got an aggregate field, and a possibly\n      nonzero offset into them.  Recurse and hope for a valid match.  */\n-  base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n+  base = fold_build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n   SET_EXPR_LOCATION (base, loc);\n \n   t = maybe_fold_offset_to_array_ref (loc, base, offset, orig_type,"}]}