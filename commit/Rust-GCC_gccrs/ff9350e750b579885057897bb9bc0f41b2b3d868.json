{"sha": "ff9350e750b579885057897bb9bc0f41b2b3d868", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5MzUwZTc1MGI1Nzk4ODUwNTc4OTdiYjliYzBmNDFiMmIzZDg2OA==", "commit": {"author": {"name": "Linas Vepstas", "email": "linas@linas.org", "date": "1999-09-08T06:23:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-08T06:23:46Z"}, "message": "Linas Vepstas  <linas@linas.org>\n\n        * README: Add section discussing status of ELF ABI.\n        * i370.c: Fix misc spelling mistakes.\n        (i370_label_scan): Updated notes, exception handling.\n        (i370_function_prolog): Simplify ELF stack handling.\n        * i370.h: (FIXED_REGISTERS): Free up r12 for ELF.\n        (STACK_GROWS_DOWNWARD): ELF stack grows down.\n        (ASM_DECLARE_FUNCTION_NAME): Fix crazy malloc size.\n        * i370.md: (movdi): Add notes.\n        (floatsidf2): Use stack not rtca for scratch float area.\n        (iorsi3): Correct operand constraints.\n        * x-oe: Restore TAROUTOPTS which are used by pax.\n\nFrom-SVN: r29185", "tree": {"sha": "0d6e1340a897078d64693a526d1d6789b8186c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d6e1340a897078d64693a526d1d6789b8186c33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff9350e750b579885057897bb9bc0f41b2b3d868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9350e750b579885057897bb9bc0f41b2b3d868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff9350e750b579885057897bb9bc0f41b2b3d868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9350e750b579885057897bb9bc0f41b2b3d868/comments", "author": {"login": "linas", "id": 94368, "node_id": "MDQ6VXNlcjk0MzY4", "avatar_url": "https://avatars.githubusercontent.com/u/94368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/linas", "html_url": "https://github.com/linas", "followers_url": "https://api.github.com/users/linas/followers", "following_url": "https://api.github.com/users/linas/following{/other_user}", "gists_url": "https://api.github.com/users/linas/gists{/gist_id}", "starred_url": "https://api.github.com/users/linas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/linas/subscriptions", "organizations_url": "https://api.github.com/users/linas/orgs", "repos_url": "https://api.github.com/users/linas/repos", "events_url": "https://api.github.com/users/linas/events{/privacy}", "received_events_url": "https://api.github.com/users/linas/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c802301136abdeabc75c5818e893c439a57f0597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c802301136abdeabc75c5818e893c439a57f0597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c802301136abdeabc75c5818e893c439a57f0597"}], "stats": {"total": 242, "additions": 163, "deletions": 79}, "files": [{"sha": "28ff25d94868e4df7f3173d23410d705188cd2b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff9350e750b579885057897bb9bc0f41b2b3d868", "patch": "@@ -1,3 +1,17 @@\n+Tue Sep  7 23:23:15 1999  Linas Vepstas  <linas@linas.org>\n+\n+\t* README: Add section discussing status of ELF ABI.\n+\t* i370.c: Fix misc spelling mistakes.\n+\t(i370_label_scan): Updated notes, exception handling.\n+\t(i370_function_prolog): Simplify ELF stack handling.\n+\t* i370.h: (FIXED_REGISTERS): Free up r12 for ELF.\n+\t(STACK_GROWS_DOWNWARD): ELF stack grows down.\n+\t(ASM_DECLARE_FUNCTION_NAME): Fix crazy malloc size.\n+\t* i370.md: (movdi): Add notes.\n+\t(floatsidf2): Use stack not rtca for scratch float area.\n+\t(iorsi3): Correct operand constraints.\n+\t* x-oe: Restore TAROUTOPTS which are used by pax.\n+\n Tue Sep  7 22:39:18 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* rs6000.c: Include ggc.h.\n@@ -1317,11 +1331,11 @@ Sat Aug 28 16:24:31 1999  Richard Henderson  <rth@cygnus.com>\n \n Sat Aug 28 16:20:12 1999  Richard Henderson  <rth@cygnus.com>\n \n-        * haifa-sched.c (sched_analyze): Clear LOG_LINKS before calling\n-        sched_analyze_insn.\n-        (sched_analyze_1): Let add_dependence care for not adding dups.\n-        (sched_analyze_2): Likewise.\n-        (add_branch_dependences): Likewise.\n+\t* haifa-sched.c (sched_analyze): Clear LOG_LINKS before calling\n+\tsched_analyze_insn.\n+\t(sched_analyze_1): Let add_dependence care for not adding dups.\n+\t(sched_analyze_2): Likewise.\n+\t(add_branch_dependences): Likewise.\n \n Sat Aug 28 15:58:16 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n "}, {"sha": "56c6342dc64675d91fed1431520d6b17f2ffbac4", "filename": "gcc/config/i370/README", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2FREADME?ref=ff9350e750b579885057897bb9bc0f41b2b3d868", "patch": "@@ -30,9 +30,47 @@ OpenEdition Hints\n The shell script \"install\" is handy for users of OpenEdition.\n \n \n+The ELF ABI\n+-----------\n+This compiler, in conjunction with the gas/binutils assembler, defines\n+a defacto ELF-based ABI for the ESA/390 architecture.  Be warned: this \n+ABI has several major faults.  It should be fixed.  As it is fixed,\n+it is subject to change without warning.  You should not commit to major\n+software systems without further exploring and fixing these problems.\n+Here are some of the problems:\n+\n+-- No support for shared libraries or dynamically loadable objects.\n+   This is because the compiler currently places address literals in \n+   the text section.  Although the GAS assembler supports a syntax for \n+   USING that will place address literals in the data section, this forces\n+   the use of two base registers, one for branches and one for the literal \n+   pool. Work is needed to redesign the function prologue, epilogue and the \n+   base register reloads to minimize the currently excessive use of reserved \n+   registers. \n+\n+   I beleive the best solution would be to add a toc or plt, and extending\n+   the meaning of the USING directive to encompass this.  This would \n+   allow the continued use of the human-readable and familiar practice\n+   of using =A() and =F'' to denote address literals, as opposed to more \n+   difficult jump-table notation.\n+\n+-- the stackframe is almost twice as big as it needs to be.\n+\n+-- currently, r15 is used to return 32-bit values.  Because this is the\n+   last register, it prevents 64-bit ints and small structures from being \n+   returned in registers, forcing return in memory.  It would be more\n+   efficient to use r14 to return 32-bit values, and r14+r15 to return\n+   64-bit values.\n+\n+-- all arguments are currently passed in memory.  It would be more efficient \n+   to pass arguments in registers.\n+\n+\n+\n+\n ChangeLog\n ---------\n-Oct98-Dec98 -- add ELF back end; work on getting ABI more or less correct.\n+Oct98-Dec98 -- add ELF back end; work on getting ABI more or less functional.\n 98.12.05 -- fix numerous MVC bugs\n 99.02.06 -- multiply insn sometimes not generated when needed.\n          -- extendsidi bugs, bad literal values printed"}, {"sha": "c999b5819b81de17fa18b46eb2e9836d2edb7e28", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 42, "deletions": 64, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=ff9350e750b579885057897bb9bc0f41b2b3d868", "patch": "@@ -33,7 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n-#include \"function.h\"\n+/* #include \"function.h\" */\n #include \"flags.h\"\n #include \"recog.h\"\n \n@@ -370,13 +370,13 @@ i370_short_branch (insn)\n /* The i370_label_scan() routine is supposed to loop over\n    all labels and label references in a compilation unit,\n    and determine whether all label refs appear on the same \n-   code page as the label. If they do, thenm we can avoid \n+   code page as the label. If they do, then we can avoid \n    a reload of the base register for that label.\n   \n-   Note that the instruciton addresses used here are only \n+   Note that the instruction addresses used here are only \n    approximate, and make the sizes of the jumps appear\n    farther apart then they will actually be.  This makes \n-   this code far more conservative than it needed to be.\n+   this code far more conservative than it needs to be.\n  */\n \n #define I370_RECORD_LABEL_REF(label,addr) {\t\t\t\t\\\n@@ -470,8 +470,8 @@ i370_label_scan (void)\n    can only lead to horrible results if this were to occur.\n   \n    However, the current situation is not any worse than it was \n-   last week, and so we punt for now.\n- */\n+   last week, and so we punt for now.  */\n+\n                     debug_rtx (insn);\n // abort();\n                     for (j=0; j < XVECLEN (body, 0); j++)\n@@ -483,23 +483,30 @@ i370_label_scan (void)\n                  }\n                else \n                  {\n-/* The following appears during make of _eh in libgcc2.a\n-   while not obviously wrong, its weird, so not obviously \n-   right either ...\n-   (jump_insn:HI 125 124 126 (set (pc)\n-         (mem:SI (plus:SI (reg/v:SI 1 r1)\n-                 (const_int 4)))) 144 {indirect_jump} (nil)\n- */\n+/* XXX hack alert.\n+   Compiling the execption handling (L_eh) in libgcc2.a will trip\n+   up right here, with something that looks like\n+   (set (pc) (mem:SI (plus:SI (reg/v:SI 1 r1) (const_int 4))))\n+      {indirect_jump} \n+   I'm not sure of what leads up to this, but it looks like\n+   the makings of a long jump which will surely get us into trouble\n+   because the base & page registers don't get reloaded.  For now\n+   I'm not sure of what to do ... again we punt ... we are not worse\n+   off than yesterday.  */\n+\n+                    /* print_rtl_single (stdout, insn); */\n                     debug_rtx (insn);\n-//                    abort();\n+                    /* abort(); */\n                     continue;\n                  }\n             }\n-\n-          /* At this point, this jump_insn had better be a plain-old\n-           * ordinary one, grap the label id and go */\n-          if (CODE_LABEL != GET_CODE (label)) abort ();\n-          I370_RECORD_LABEL_REF(label,here);\n+          else\n+            {\n+              /* At this point, this jump_insn had better be a plain-old\n+                 ordinary one, grap the label id and go */\n+              if (CODE_LABEL != GET_CODE (label)) abort ();\n+              I370_RECORD_LABEL_REF(label,here);\n+            }\n         }\n \n       /* Sometimes, we take addresses of labels and use them\n@@ -1364,11 +1371,11 @@ i370_function_prolog (f, l)\n #ifdef TARGET_ELF_ABI\n /*\n    The 370_function_prolog() routine generates the current ELF ABI ES/390 prolog.\n+   It implements a stack that grows downward. \n    It performs the following steps:\n    -- saves the callers non-volatile registers on the callers stack.\n-   -- computes a new stack top and checks for room for the stack.\n-   -- initializes size and backpointer of new stack frame\n-   -- updates stack pointer to point at new frame.\n+   -- subtracts stackframe size from the stack pointer.\n+   -- stores backpointer to old caller stack.\n   \n    XXX hack alert -- if the global var int leaf_function is non-zero, \n    then this is a leaf, and it might be possible to optimize the prologue\n@@ -1413,59 +1420,30 @@ i370_function_prolog (f, frame_size)\n   fprintf (f, \"\\t.long\\t%d\\n\", aligned_size);\n \n   /* FENT == function prologue entry */\n-  fprintf (f, \".LFENT%03d:\\n\\t.balign 2\\n\",   /* FENT%03d DS 0H */\n+  fprintf (f, \"\\t.balign 2\\n.LFENT%03d:\\n\",\n               function_label_index);\n \n-  /* store multiple of registers 14,15,0,...12 at 12 bytes from sp */\n+  /* store multiple registers 14,15,0,...12 at 12 bytes from sp */\n   fprintf (f, \"\\tSTM\\tr14,r12,12(sp)\\n\");\n \n-  /* r11 points to arg list in callers stackframe; was passed in r2 */\n-  fprintf (f, \"\\tLR\\tr11,r2\\n\");\n-\n-  /* r2 == callee stack pointer ; 76(sp) == caller top of stack */\n-  fprintf (f, \"\\tL\\tr2,76(,sp)\\n\");\n-\n-  /* 4(r15) == callee stack length */\n-  fprintf (f, \"\\tL\\tr0,4(,r15)\\n\");\n+  /* r3 == saved callee stack pointer */\n+  fprintf (f, \"\\tLR\\tr3,sp\\n\");\n \n-  /* add callee stack length to caller top of stack */\n-  fprintf (f, \"\\tALR\\tr0,r2\\n\");\n+  /* 4(r15) == stackframe size */\n+  fprintf (f, \"\\tSL\\tsp,4(,r15)\\n\");\n \n-  /* is there enough room for this new stack frame? */\n-  fprintf (f, \"\\tCL\\tr0,12(,rtca)\\n\");\n-  \n-  /* if we've got room, skip next 2 insns */\n-  fprintf (f, \"\\tBNH\\t*+10\\n\");\n-\n-  /* branch to tca to get more stack */\n-  fprintf (f, \"\\tL\\tr15,116(,rtca)\\n\");\n-\n-  /* go */\n-  fprintf (f, \"\\tBASR\\tr14,r15\\n\"); \n-\n-  /* 72(sp) is something that is propagated up from the base of the stack.\n-     We don't use this anywhere, so we could chop this out. For the moment,\n-     Lets keep it; it might be handy someday ... */\n-  fprintf (f, \"\\tL\\tr15,72(,sp)\\n\");\n-\n-  /* store the new top-of-stack at 76(callee_stack) */\n-  fprintf (f, \"\\tSTM\\tr15,r0,72(r2)\\n\");\n-\n-  /* store some PL/1 compatible eyecatcher ???? why bother ??? */\n-  fprintf (f, \"\\tMVI\\t0(r2),0x10\\n\");\n+  /* r11 points to arg list in callers stackframe; was passed in r2 */\n+  fprintf (f, \"\\tLR\\tr11,r2\\n\");\n \n   /* store callee stack pointer at 8(sp) */\n-  fprintf (f, \"\\tST\\tr2,8(,sp)\\n \");\n-\n-  /* store caller sp at 4(callee_sp)  */\n-  fprintf (f, \"\\tST\\tsp,4(,r2)\\n \");\n+  /* fprintf (f, \"\\tST\\tsp,8(,r3)\\n \");  wasted cycles, no one uses this ... */\n \n-  /* load calle_sp into sp  */\n-  fprintf (f, \"\\tLR\\tsp,r2\\n\");\n+  /* backchain -- store caller sp at 4(callee_sp)  */\n+  fprintf (f, \"\\tST\\tr3,4(,sp)\\n \");\n \n   fprintf (f, \"\\t.drop\\tr15\\n\");\n-  /* place contents of the PSW into r3\n-   * that is, place the address of \".\" into r3 */\n+  /* Place contents of the PSW into r3\n+     that is, place the address of \".\" into r3 */\n   fprintf (f, \"\\tBASR\\tr%d,0\\n\", BASE_REGISTER);\n   fprintf (f, \"\\t.using\\t.,r%d\\n\", BASE_REGISTER);\n   function_first = 1;"}, {"sha": "d87369b07fcb99d0674d9dec29721b02f12fdc2d", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=ff9350e750b579885057897bb9bc0f41b2b3d868", "patch": "@@ -187,6 +187,7 @@ extern int mvs_function_name_length;\n #define BASE_REGISTER 3\n #define PAGE_REGISTER 4\n \n+#ifdef TARGET_HLASM\n /* 1 for registers that have pervasive standard uses and are not available\n    for the register allocator.  These are registers that must have fixed,\n    valid values stored in them for the entire length of the subroutine call,\n@@ -249,6 +250,26 @@ extern int mvs_function_name_length;\n    but can be less for certain modes in special long registers.  \n    Note that DCmode (complex double) needs two regs.\n */\n+#endif /* TARGET_HLASM */\n+\n+/* ================= */\n+#ifdef TARGET_ELF_ABI \n+/* The Linux/ELF ABI uses the same register layout as the \n+ * the MVS/OE version, with the following exceptions:\n+ * -- r12 (rtca) is not used.\n+ */\n+\n+#define FIXED_REGISTERS \t\t\t\t\t\t\\\n+{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0 }\n+/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n+\n+#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n+{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }\n+/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n+\n+#endif /* TARGET_ELF_ABI */\n+/* ================= */\n+\n \n #define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\t\\\n   ((REGNO) > 15 ? \t\t\t\t\t\t\t\\\n@@ -327,7 +348,7 @@ extern int mvs_function_name_length;\n             A_t a; a.a=1; a.b=2 a.c=3;\n             return a;\n         } \n-   In the above, the stroage for the return value is in the callers stack, and \n+   In the above, the storage for the return value is in the callers stack, and \n    the R1 points at that mem location.\n  */\n \n@@ -444,7 +465,10 @@ enum reg_class\n \n /* Define this if pushing a word on the stack makes the stack pointer a\n    smaller address.  */\n+/* ------------------------------------------------------------------- */\n \n+/* ================= */\n+#ifdef TARGET_HLASM\n /* #define STACK_GROWS_DOWNWARD */\n \n /* Define this if the nominal address of the stack frame is at the\n@@ -466,6 +490,29 @@ enum reg_class\n /* If we generate an insn to push BYTES bytes, this says how many the stack\n    pointer really advances by.  On the 370, we have no push instruction.  */\n \n+#endif /* TARGET_HLASM */\n+\n+/* ================= */\n+#ifdef TARGET_ELF_ABI \n+\n+/* With ELF/Linux, stack is placed at large virtual addrs and grows down.\n+   But we want the compiler to generate posistive displacements from the \n+   stack pointer, and so we make the frame lie above the stack.  */\n+\n+#define STACK_GROWS_DOWNWARD \n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   This is the offset to the BEGINNING of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n+     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n+\n+#endif /* TARGET_ELF_ABI */\n+/* ================= */\n+\n /* #define PUSH_ROUNDING(BYTES) */\n \n /* Accumulate the outgoing argument count so we can request the right\n@@ -529,7 +576,7 @@ enum reg_class\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n \n-/* The FUNCTION_VALUE macro dDefines how to find the value returned by a \n+/* The FUNCTION_VALUE macro defines how to find the value returned by a \n    function.  VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is NULL.  \n@@ -1559,15 +1606,15 @@ enum reg_class\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  if (strlen (NAME) * 2 > mvs_function_name_length)\t\t\t\\\n+  if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (mvs_function_name)\t\t\t\t\t\t\\\n \tfree (mvs_function_name);\t\t\t\t\t\\\n       mvs_function_name = 0;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   if (!mvs_function_name)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      mvs_function_name_length = strlen (NAME) * 2;\t\t\t\\\n+      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n       mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\"}, {"sha": "a48523eb75ae4810736506085353d692a8302521", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=ff9350e750b579885057897bb9bc0f41b2b3d868", "patch": "@@ -647,7 +647,9 @@ check_label_emit ();\n   else if (REG_P (operands[1]))\n     {\n       mvs_check_page (0, 4, 0);\n-      return \\\"STM\t%1,%N1,%0\\\";\n+      /* can't use stm otherwise stm r6,r7,0(r10,r13) can happen */\n+      return \\\"STM\t%1,%N1,%0\\\"; \n+      /* return \\\"ST\t%1,%0\\;ST\t%N1,4+%0\\\"; */\n     }\n   mvs_check_page (0, 6, 0);\n   return \\\"MVC\t%O0(8,%R0),%W1\\\";\n@@ -1825,8 +1827,6 @@ check_label_emit ();\n ;\n ; floatsidf2 instruction pattern(s).\n ;\n-; Uses the float field of the TCA.\n-;\n \n (define_insn \"floatsidf2\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n@@ -1837,7 +1837,7 @@ check_label_emit ();\n   check_label_emit ();\n   CC_STATUS_INIT;\n   mvs_check_page (0, 16, 8);\n-  return \\\"ST\t%1,508(,12)\\;XI\t508(12),128\\;LD\t%0,504(,12)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n+  return \\\"ST\t%1,144(,13)\\;XI\t144(13),128\\;LD\t%0,140(,13)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n }\"\n    [(set_attr \"length\" \"16\")]\n )\n@@ -3021,7 +3021,7 @@ check_label_emit ();\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"r_or_s_operand\" \"=d,m\")\n \t(ior:SI (match_operand:SI 1 \"r_or_s_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"r_or_s_operand\" \"g,mi\")))]\n+\t\t(match_operand:SI 2 \"r_or_s_operand\" \"g,Si\")))]\n   \"TARGET_CHAR_INSTRUCTIONS\"\n   \"*\n {"}, {"sha": "b6db96adf8b5d7323e9fd3705482bd7f16764bc6", "filename": "gcc/config/i370/x-oe", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fx-oe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff9350e750b579885057897bb9bc0f41b2b3d868/gcc%2Fconfig%2Fi370%2Fx-oe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fx-oe?ref=ff9350e750b579885057897bb9bc0f41b2b3d868", "patch": "@@ -19,3 +19,10 @@ CC=c89\n \n CLIB=-liberty\n LDFLAGS=-L../libiberty\n+\n+# TAR Options\n+# Please note that OpenEdition confuses tar and pax, and \n+# thus uses the non-standard options 'xpf'\n+\n+TAROUTOPTS=xpf\n+"}]}