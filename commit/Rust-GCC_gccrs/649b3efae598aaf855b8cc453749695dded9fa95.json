{"sha": "649b3efae598aaf855b8cc453749695dded9fa95", "node_id": "C_kwDOANBUbNoAKDY0OWIzZWZhZTU5OGFhZjg1NWI4Y2M0NTM3NDk2OTVkZGVkOWZhOTU", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2021-12-15T19:10:06Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-11T13:24:47Z"}, "message": "[Ada] Proof of System.Val_Uns at gold level\n\ngcc/ada/\n\n\t* libgnat/a-tiinau.ads: Use a procedure for the Scan parameter\n\tinstead of a function with side-effects.\n\t* libgnat/a-tiinau.adb: Idem.\n\t* libgnat/a-wtinau.ads: Idem.\n\t* libgnat/a-wtinau.adb: Idem.\n\t* libgnat/a-ztinau.ads: Idem.\n\t* libgnat/a-ztinau.adb: Idem.\n\t* libgnat/s-valint.ads: Change the function with side-effects\n\tScan_Integer into a procedure\n\t* libgnat/s-vallli.ads: Idem.\n\t* libgnat/s-valllli.ads: Idem.\n\t* libgnat/s-vallllu.ads: Add SPARK_Mode and pragma to ignore\n\tassertions in instance.\n\t* libgnat/s-valllu.ads: Idem.\n\t* libgnat/s-valuns.ads: Idem.\n\t* libgnat/s-valuei.ads: Use a procedure for the\n\tScan_Raw_Unsigned parameter instead of a function with\n\tside-effects and change the function with side-effects\n\tScan_Integer into a procedure.\n\t* libgnat/s-valuei.adb: Idem.\n\t* libgnat/s-valuti.ads: Introduce a ghost function that scans an\n\texponent and complete the postcondition of Scan_Exponent to also\n\tdescribe the value of Ptr after the call. Fix the postcondition\n\tof Scan_Underscore. Simplify the definition of\n\tScan_Natural_Ghost.\n\t* libgnat/s-valuti.adb: Idem.\n\t* libgnat/s-valboo.ads, libgnat/s-valboo.adb: Update calls to\n\tFirst_Non_Space_Ghost.\n\t* libgnat/s-valueu.ads: Add functional contracts.\n\t* libgnat/s-valueu.adb: Idem.", "tree": {"sha": "b9315329a73e0dc11072d6346cc5a85cd5f602d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9315329a73e0dc11072d6346cc5a85cd5f602d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/649b3efae598aaf855b8cc453749695dded9fa95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649b3efae598aaf855b8cc453749695dded9fa95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/649b3efae598aaf855b8cc453749695dded9fa95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649b3efae598aaf855b8cc453749695dded9fa95/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "371b4ad7c423891d13f9b855f5fdd469a82f7160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/371b4ad7c423891d13f9b855f5fdd469a82f7160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/371b4ad7c423891d13f9b855f5fdd469a82f7160"}], "stats": {"total": 1181, "additions": 1066, "deletions": 115}, "files": [{"sha": "100c5c41bc6a637907b9ea8358e9f19ece85f5d0", "filename": "gcc/ada/libgnat/a-tiinau.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-tiinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-tiinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiinau.adb?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -54,7 +54,7 @@ package body Ada.Text_IO.Integer_Aux is\n          Load_Integer (File, Buf, Stop);\n       end if;\n \n-      Item := Scan (Buf, Ptr'Access, Stop);\n+      Scan (Buf, Ptr'Access, Stop, Item);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n    end Get;\n \n@@ -71,7 +71,7 @@ package body Ada.Text_IO.Integer_Aux is\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan (From, Pos'Access, From'Last);\n+      Scan (From, Pos'Access, From'Last, Item);\n       Last := Pos - 1;\n \n    exception"}, {"sha": "75eb9157caa19b6c062a032854e5a2d1bdd88734", "filename": "gcc/ada/libgnat/a-tiinau.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-tiinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-tiinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiinau.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -38,8 +38,11 @@\n private generic\n    type Num is (<>);\n \n-   with function Scan\n-     (Str : String; Ptr : not null access Integer; Max : Integer) return Num;\n+   with procedure Scan\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Res : out Num);\n    with procedure Set_Image\n      (V : Num; S : in out String; P : in out Natural);\n    with procedure Set_Image_Width"}, {"sha": "0628cc66ebaff30d6d45df2dadc7951464d48236", "filename": "gcc/ada/libgnat/a-wtinau.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-wtinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-wtinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtinau.adb?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -54,7 +54,7 @@ package body Ada.Wide_Text_IO.Integer_Aux is\n          Load_Integer (File, Buf, Stop);\n       end if;\n \n-      Item := Scan (Buf, Ptr'Access, Stop);\n+      Scan (Buf, Ptr'Access, Stop, Item);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n    end Get;\n \n@@ -71,7 +71,7 @@ package body Ada.Wide_Text_IO.Integer_Aux is\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan (From, Pos'Access, From'Last);\n+      Scan (From, Pos'Access, From'Last, Item);\n       Last := Pos - 1;\n \n    exception"}, {"sha": "37ac2d15dd5d2669cda07a8bb78628ec433ec351", "filename": "gcc/ada/libgnat/a-wtinau.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-wtinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-wtinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtinau.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -38,8 +38,11 @@\n private generic\n    type Num is (<>);\n \n-   with function Scan\n-     (Str : String; Ptr : not null access Integer; Max : Integer) return Num;\n+   with procedure Scan\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Res : out Num);\n    with procedure Set_Image\n      (V : Num; S : in out String; P : in out Natural);\n    with procedure Set_Image_Width"}, {"sha": "d7df8ef757c8db6eadf46a767c7ab5d76469ab89", "filename": "gcc/ada/libgnat/a-ztinau.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-ztinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-ztinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztinau.adb?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -54,7 +54,7 @@ package body Ada.Wide_Wide_Text_IO.Integer_Aux is\n          Load_Integer (File, Buf, Stop);\n       end if;\n \n-      Item := Scan (Buf, Ptr'Access, Stop);\n+      Scan (Buf, Ptr'Access, Stop, Item);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n    end Get;\n \n@@ -71,7 +71,7 @@ package body Ada.Wide_Wide_Text_IO.Integer_Aux is\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan (From, Pos'Access, From'Last);\n+      Scan (From, Pos'Access, From'Last, Item);\n       Last := Pos - 1;\n \n    exception"}, {"sha": "c1871af4cd4d43da7b040eeb616debe423340967", "filename": "gcc/ada/libgnat/a-ztinau.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-ztinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fa-ztinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztinau.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -38,8 +38,11 @@\n private generic\n    type Num is (<>);\n \n-   with function Scan\n-     (Str : String; Ptr : not null access Integer; Max : Integer) return Num;\n+   with procedure Scan\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Res : out Num);\n    with procedure Set_Image\n      (V : Num; S : in out String; P : in out Natural);\n    with procedure Set_Image_Width"}, {"sha": "54b1265f7c559e707615e210f38aa4755b89731e", "filename": "gcc/ada/libgnat/s-valboo.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valboo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valboo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valboo.adb?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -55,7 +55,8 @@ is\n    begin\n       Normalize_String (S, F, L);\n \n-      pragma Assert (F = System.Val_Util.First_Non_Space_Ghost (S));\n+      pragma Assert (F = System.Val_Util.First_Non_Space_Ghost\n+                     (S, Str'First, Str'Last));\n \n       if S (F .. L) = \"TRUE\" then\n          return True;"}, {"sha": "a9afc45a0958b409676dbac3608fae18fe74802d", "filename": "gcc/ada/libgnat/s-valboo.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valboo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valboo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valboo.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -51,7 +51,8 @@ is\n      (not System.Val_Util.Only_Space_Ghost (Str, Str'First, Str'Last)\n         and then\n       (declare\n-         F : constant Positive := System.Val_Util.First_Non_Space_Ghost (Str);\n+         F : constant Positive := System.Val_Util.First_Non_Space_Ghost\n+           (Str, Str'First, Str'Last);\n        begin\n          (F <= Str'Last - 3\n           and then Str (F)     in 't' | 'T'\n@@ -82,7 +83,8 @@ is\n      Pre  => Is_Boolean_Image_Ghost (Str),\n      Post =>\n        Value_Boolean'Result =\n-         (Str (System.Val_Util.First_Non_Space_Ghost (Str)) in 't' | 'T');\n+         (Str (System.Val_Util.First_Non_Space_Ghost\n+            (Str, Str'First, Str'Last)) in 't' | 'T');\n    --  Computes Boolean'Value (Str)\n \n end System.Val_Bool;"}, {"sha": "4fef265e9cf84b312c74e0c90b6b6fe636b8263a", "filename": "gcc/ada/libgnat/s-valint.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valint.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -43,10 +43,11 @@ package System.Val_Int is\n \n    package Impl is new Value_I (Integer, Unsigned, Val_Uns.Scan_Raw_Unsigned);\n \n-   function Scan_Integer\n+   procedure Scan_Integer\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Integer\n+      Max : Integer;\n+      Res : out Integer)\n      renames Impl.Scan_Integer;\n \n    function Value_Integer (Str : String) return Integer"}, {"sha": "ce1d9ee1340f5cba2404a7b149ff5224cdc95bb4", "filename": "gcc/ada/libgnat/s-vallli.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallli.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -46,10 +46,11 @@ package System.Val_LLI is\n               Long_Long_Unsigned,\n               Val_LLU.Scan_Raw_Long_Long_Unsigned);\n \n-   function Scan_Long_Long_Integer\n+   procedure Scan_Long_Long_Integer\n      (Str  : String;\n       Ptr  : not null access Integer;\n-      Max  : Integer) return Long_Long_Integer\n+      Max  : Integer;\n+      Res  : out Long_Long_Integer)\n      renames Impl.Scan_Integer;\n \n    function Value_Long_Long_Integer (Str : String) return Long_Long_Integer"}, {"sha": "176000a406003ed888ffc6fbc02212d79686165e", "filename": "gcc/ada/libgnat/s-valllli.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllli.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -46,10 +46,11 @@ package System.Val_LLLI is\n               Long_Long_Long_Unsigned,\n               Val_LLLU.Scan_Raw_Long_Long_Long_Unsigned);\n \n-   function Scan_Long_Long_Long_Integer\n+   procedure Scan_Long_Long_Long_Integer\n      (Str  : String;\n       Ptr  : not null access Integer;\n-      Max  : Integer) return Long_Long_Long_Integer\n+      Max  : Integer;\n+      Res  : out  Long_Long_Long_Integer)\n      renames Impl.Scan_Integer;\n \n    function Value_Long_Long_Long_Integer"}, {"sha": "c6c9ece5332a72dd98edb1e5803e6af6de53f8e1", "filename": "gcc/ada/libgnat/s-vallllu.ads", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-vallllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-vallllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallllu.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -32,26 +32,40 @@\n --  This package contains routines for scanning modular Long_Long_Unsigned\n --  values for use in Text_IO.Modular_IO, and the Value attribute.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Unsigned_Types;\n with System.Value_U;\n \n-package System.Val_LLLU is\n+package System.Val_LLLU with SPARK_Mode is\n    pragma Preelaborate;\n \n    subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n    package Impl is new Value_U (Long_Long_Long_Unsigned);\n \n-   function Scan_Raw_Long_Long_Long_Unsigned\n+   procedure Scan_Raw_Long_Long_Long_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Long_Long_Long_Unsigned\n+      Max : Integer;\n+      Res : out Long_Long_Long_Unsigned)\n      renames Impl.Scan_Raw_Unsigned;\n \n-   function Scan_Long_Long_Long_Unsigned\n+   procedure Scan_Long_Long_Long_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Long_Long_Long_Unsigned\n+      Max : Integer;\n+      Res : out Long_Long_Long_Unsigned)\n      renames Impl.Scan_Unsigned;\n \n    function Value_Long_Long_Long_Unsigned"}, {"sha": "0a5cb34f04a0adac438c83624309314b6ae9aa23", "filename": "gcc/ada/libgnat/s-valllu.ads", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllu.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -32,26 +32,40 @@\n --  This package contains routines for scanning modular Long_Long_Unsigned\n --  values for use in Text_IO.Modular_IO, and the Value attribute.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Unsigned_Types;\n with System.Value_U;\n \n-package System.Val_LLU is\n+package System.Val_LLU with SPARK_Mode is\n    pragma Preelaborate;\n \n    subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n \n    package Impl is new Value_U (Long_Long_Unsigned);\n \n-   function Scan_Raw_Long_Long_Unsigned\n+   procedure Scan_Raw_Long_Long_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Long_Long_Unsigned\n+      Max : Integer;\n+      Res : out Long_Long_Unsigned)\n      renames Impl.Scan_Raw_Unsigned;\n \n-   function Scan_Long_Long_Unsigned\n+   procedure Scan_Long_Long_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Long_Long_Unsigned\n+      Max : Integer;\n+      Res : out Long_Long_Unsigned)\n      renames Impl.Scan_Unsigned;\n \n    function Value_Long_Long_Unsigned"}, {"sha": "83828d34dd78d66c22d3de4f23a27cc2fc882be7", "filename": "gcc/ada/libgnat/s-valuei.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.adb?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -37,10 +37,11 @@ package body System.Value_I is\n    -- Scan_Integer --\n    ------------------\n \n-   function Scan_Integer\n+   procedure Scan_Integer\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Int\n+      Max : Integer;\n+      Res : out Int)\n    is\n       Uval : Uns;\n       --  Unsigned result\n@@ -59,26 +60,26 @@ package body System.Value_I is\n          Bad_Value (Str);\n       end if;\n \n-      Uval := Scan_Raw_Unsigned (Str, Ptr, Max);\n+      Scan_Raw_Unsigned (Str, Ptr, Max, Uval);\n \n       --  Deal with overflow cases, and also with largest negative number\n \n       if Uval > Uns (Int'Last) then\n          if Minus and then Uval = Uns (-(Int'First)) then\n-            return Int'First;\n+            Res := Int'First;\n          else\n             Bad_Value (Str);\n          end if;\n \n       --  Negative values\n \n       elsif Minus then\n-         return -(Int (Uval));\n+         Res := -(Int (Uval));\n \n       --  Positive values\n \n       else\n-         return Int (Uval);\n+         Res := Int (Uval);\n       end if;\n    end Scan_Integer;\n \n@@ -106,7 +107,7 @@ package body System.Value_I is\n             V : Int;\n             P : aliased Integer := Str'First;\n          begin\n-            V := Scan_Integer (Str, P'Access, Str'Last);\n+            Scan_Integer (Str, P'Access, Str'Last, V);\n             Scan_Trailing_Blanks (Str, P);\n             return V;\n          end;"}, {"sha": "e0a34d9465c94826c9f516f0f8ab674e7bae40f9", "filename": "gcc/ada/libgnat/s-valuei.ads", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -38,19 +38,21 @@ generic\n \n    type Uns is mod <>;\n \n-   with function Scan_Raw_Unsigned\n+   with procedure Scan_Raw_Unsigned\n           (Str : String;\n            Ptr : not null access Integer;\n-           Max : Integer) return Uns;\n+           Max : Integer;\n+           Res : out Uns);\n \n package System.Value_I is\n    pragma Preelaborate;\n \n-   function Scan_Integer\n+   procedure Scan_Integer\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Int;\n-   --  This function scans the string starting at Str (Ptr.all) for a valid\n+      Max : Integer;\n+      Res : out Int);\n+   --  This procedure scans the string starting at Str (Ptr.all) for a valid\n    --  integer according to the syntax described in (RM 3.5(43)). The substring\n    --  scanned extends no further than Str (Max). There are three cases for the\n    --  return:"}, {"sha": "991d4a5f6da6b04a4946b542924c0a2697f4b56a", "filename": "gcc/ada/libgnat/s-valueu.adb", "status": "modified", "additions": 425, "deletions": 11, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.adb?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -29,18 +29,220 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Val_Util; use System.Val_Util;\n-\n package body System.Value_U is\n \n+   --  Ghost code, loop invariants and assertions in this unit are meant for\n+   --  analysis only, not for run-time checking, as it would be too costly\n+   --  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+   pragma Assertion_Policy (Ghost              => Ignore,\n+                            Loop_Invariant     => Ignore,\n+                            Assert             => Ignore,\n+                            Assert_And_Cut     => Ignore,\n+                            Subprogram_Variant => Ignore);\n+\n+   --  Local lemmas\n+\n+   procedure Lemma_Digit_Is_Before_Last\n+     (Str  : String;\n+      P    : Integer;\n+      From : Integer;\n+      To   : Integer)\n+   with Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+       and then P in From .. To\n+       and then Str (P) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F',\n+     Post => P /= Last_Hexa_Ghost (Str (From .. To)) + 1;\n+   --  If the character at position P is a digit, P cannot be the position of\n+   --  of the first non-digit in Str.\n+\n+   procedure Lemma_End_Of_Scan\n+     (Str  : String;\n+      From : Integer;\n+      To   : Integer;\n+      Base : Uns;\n+      Acc  : Uns)\n+   with Ghost,\n+     Pre  => Str'Last /= Positive'Last and then From > To,\n+     Post => Scan_Based_Number_Ghost (Str, From, To, Base, Acc) =\n+       (False, Acc);\n+   --  Unfold the definition of Scan_Based_Number_Ghost on an empty string\n+\n+   procedure Lemma_Scan_Digit\n+     (Str          : String;\n+      P            : Integer;\n+      Lst          : Integer;\n+      Digit        : Uns;\n+      Base         : Uns;\n+      Old_Acc      : Uns;\n+      Acc          : Uns;\n+      Scan_Val     : Uns_Option;\n+      Old_Overflow : Boolean;\n+      Overflow     : Boolean)\n+   with Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then Lst in Str'Range\n+       and then P in Str'First .. Lst\n+       and then Str (P) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+       and then Digit = Hexa_To_Unsigned_Ghost (Str (P))\n+       and then Only_Hexa_Ghost (Str, P, Lst)\n+       and then Base in 2 .. 16\n+       and then (if Digit < Base and then Old_Acc <= Uns'Last / Base\n+                 then Acc = Base * Old_Acc + Digit)\n+       and then (if Digit >= Base\n+                   or else Old_Acc > Uns'Last / Base\n+                   or else (Old_Acc > (Uns'Last - Base + 1) / Base\n+                            and then Acc < Uns'Last / Base)\n+                 then Overflow\n+                 else Overflow = Old_Overflow)\n+       and then\n+         (if not Old_Overflow then\n+           Scan_Val = Scan_Based_Number_Ghost\n+              (Str, P, Lst, Base, Old_Acc)),\n+     Post =>\n+        (if not Overflow then\n+           Scan_Val = Scan_Based_Number_Ghost\n+             (Str, P + 1, Lst, Base, Acc))\n+       and then\n+        (if Overflow then Old_Overflow or else Scan_Val.Overflow);\n+   --  Unfold the definition of Scan_Based_Number_Ghost when the string starts\n+   --  with a digit.\n+\n+   procedure Lemma_Scan_Underscore\n+     (Str      : String;\n+      P        : Integer;\n+      From     : Integer;\n+      To       : Integer;\n+      Lst      : Integer;\n+      Base     : Uns;\n+      Acc      : Uns;\n+      Scan_Val : Uns_Option;\n+      Overflow : Boolean;\n+      Ext      : Boolean)\n+   with Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Lst <= To\n+       and then P in From .. Lst + 1\n+       and then P <= To\n+       and then\n+         (if Ext then\n+            Is_Based_Format_Ghost (Str (From .. To))\n+            and then Lst = Last_Hexa_Ghost (Str (From .. To))\n+          else Is_Natural_Format_Ghost (Str (From .. To))\n+            and then Lst = Last_Number_Ghost (Str (From .. To)))\n+       and then Str (P) = '_'\n+       and then\n+         (if not Overflow then\n+           Scan_Val = Scan_Based_Number_Ghost (Str, P, Lst, Base, Acc)),\n+     Post => P + 1 <= Lst\n+       and then\n+         (if Ext then Str (P + 1) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+          else Str (P + 1) in '0' .. '9')\n+       and then\n+         (if not Overflow then\n+           Scan_Val = Scan_Based_Number_Ghost (Str, P + 1, Lst, Base, Acc));\n+   --  Unfold the definition of Scan_Based_Number_Ghost when the string starts\n+   --  with an underscore.\n+\n+   -----------------------------\n+   -- Local lemma null bodies --\n+   -----------------------------\n+\n+   procedure Lemma_Digit_Is_Before_Last\n+     (Str  : String;\n+      P    : Integer;\n+      From : Integer;\n+      To   : Integer)\n+   is null;\n+\n+   procedure Lemma_End_Of_Scan\n+     (Str          : String;\n+      From         : Integer;\n+      To           : Integer;\n+      Base         : Uns;\n+      Acc          : Uns)\n+   is null;\n+\n+   procedure Lemma_Scan_Underscore\n+     (Str      : String;\n+      P        : Integer;\n+      From     : Integer;\n+      To       : Integer;\n+      Lst      : Integer;\n+      Base     : Uns;\n+      Acc      : Uns;\n+      Scan_Val : Uns_Option;\n+      Overflow : Boolean;\n+      Ext      : Boolean)\n+   is null;\n+\n+   ---------------------\n+   -- Last_Hexa_Ghost --\n+   ---------------------\n+\n+   function Last_Hexa_Ghost (Str : String) return Positive is\n+   begin\n+      for J in Str'Range loop\n+         if Str (J) not in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_' then\n+            return J - 1;\n+         end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Str'First .. J =>\n+              Str (K) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_');\n+      end loop;\n+\n+      return Str'Last;\n+   end Last_Hexa_Ghost;\n+\n+   ----------------------\n+   -- Lemma_Scan_Digit --\n+   ----------------------\n+\n+   procedure Lemma_Scan_Digit\n+     (Str          : String;\n+      P            : Integer;\n+      Lst          : Integer;\n+      Digit        : Uns;\n+      Base         : Uns;\n+      Old_Acc      : Uns;\n+      Acc          : Uns;\n+      Scan_Val     : Uns_Option;\n+      Old_Overflow : Boolean;\n+      Overflow     : Boolean)\n+   is\n+      pragma Unreferenced (Str, P, Lst, Scan_Val, Overflow, Old_Overflow);\n+   begin\n+      if Digit >= Base then\n+         null;\n+\n+      elsif Old_Acc <= (Uns'Last - Base + 1) / Base then\n+         pragma Assert (not Scan_Overflows_Ghost (Digit, Base, Old_Acc));\n+\n+      elsif Old_Acc > Uns'Last / Base then\n+         null;\n+\n+      else\n+         pragma Assert\n+           ((Acc < Uns'Last / Base) =\n+              Scan_Overflows_Ghost (Digit, Base, Old_Acc));\n+      end if;\n+   end Lemma_Scan_Digit;\n+\n    -----------------------\n    -- Scan_Raw_Unsigned --\n    -----------------------\n \n-   function Scan_Raw_Unsigned\n+   procedure Scan_Raw_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Uns\n+      Max : Integer;\n+      Res : out Uns)\n    is\n       P : Integer;\n       --  Local copy of the pointer\n@@ -63,6 +265,40 @@ package body System.Value_U is\n       Digit : Uns;\n       --  Digit value\n \n+      Ptr_Old       : constant Integer := Ptr.all\n+      with Ghost;\n+      Last_Num_Init : constant Integer :=\n+        Last_Number_Ghost (Str (Ptr.all .. Max))\n+      with Ghost;\n+      Init_Val      : constant Uns_Option :=\n+        Scan_Based_Number_Ghost (Str, Ptr.all, Last_Num_Init)\n+      with Ghost;\n+      Starts_As_Based : constant Boolean :=\n+        Last_Num_Init < Max - 1\n+        and then Str (Last_Num_Init + 1) in '#' | ':'\n+        and then Str (Last_Num_Init + 2) in\n+        '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+      with Ghost;\n+      Last_Num_Based  : constant Integer :=\n+        (if Starts_As_Based\n+         then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Max))\n+         else Last_Num_Init)\n+      with Ghost;\n+      Is_Based        : constant Boolean :=\n+        Starts_As_Based\n+        and then Last_Num_Based < Max\n+        and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1)\n+      with Ghost;\n+      Based_Val       : constant Uns_Option :=\n+        (if Starts_As_Based and then not Init_Val.Overflow\n+         then Scan_Based_Number_Ghost\n+           (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n+         else Init_Val)\n+      with Ghost;\n+      First_Exp       : constant Integer :=\n+        (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1)\n+      with Ghost;\n+\n    begin\n       --  We do not tolerate strings with Str'Last = Positive'Last\n \n@@ -85,9 +321,20 @@ package body System.Value_U is\n          Umax10 : constant Uns := Uns'Last / 10;\n          --  Numbers bigger than Umax10 overflow if multiplied by 10\n \n+         Old_Uval     : Uns with Ghost;\n+         Old_Overflow : Boolean with Ghost;\n+\n       begin\n          --  Loop through decimal digits\n          loop\n+            pragma Loop_Invariant (P in P'Loop_Entry .. Last_Num_Init + 1);\n+            pragma Loop_Invariant\n+              (if Overflow then Init_Val.Overflow);\n+            pragma Loop_Invariant\n+              (if not Overflow\n+               then Init_Val = Scan_Based_Number_Ghost\n+                 (Str, P, Last_Num_Init, Acc => Uval));\n+\n             exit when P > Max;\n \n             Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n@@ -96,6 +343,9 @@ package body System.Value_U is\n \n             if Digit > 9 then\n                if Str (P) = '_' then\n+                  Lemma_Scan_Underscore\n+                    (Str, P, Ptr_Old, Max, Last_Num_Init, 10, Uval,\n+                     Init_Val, Overflow, False);\n                   Scan_Underscore (Str, P, Ptr, Max, False);\n                else\n                   exit;\n@@ -104,6 +354,9 @@ package body System.Value_U is\n             --  Accumulate result, checking for overflow\n \n             else\n+               Old_Uval := Uval;\n+               Old_Overflow := Overflow;\n+\n                if Uval <= Umax then\n                   Uval := 10 * Uval + Digit;\n \n@@ -118,11 +371,22 @@ package body System.Value_U is\n                   end if;\n                end if;\n \n+               Lemma_Scan_Digit\n+                 (Str, P, Last_Num_Init, Digit, 10, Old_Uval, Uval, Init_Val,\n+                  Old_Overflow, Overflow);\n+\n                P := P + 1;\n             end if;\n          end loop;\n+         pragma Assert (P = Last_Num_Init + 1);\n+         pragma Assert (Init_Val.Overflow = Overflow);\n       end;\n \n+      pragma Assert_And_Cut\n+        (P = Last_Num_Init + 1\n+         and then Overflow = Init_Val.Overflow\n+         and then (if not Overflow then Init_Val.Value = Uval));\n+\n       Ptr.all := P;\n \n       --  Deal with based case. We recognize either the standard '#' or the\n@@ -153,10 +417,18 @@ package body System.Value_U is\n             UmaxB : constant Uns := Uns'Last / Base;\n             --  Numbers bigger than UmaxB overflow if multiplied by base\n \n+            Old_Uval     : Uns with Ghost;\n+            Old_Overflow : Boolean with Ghost;\n+\n          begin\n+            pragma Assert\n+              (if Str (P) in '0' .. '9' | 'A' .. 'F' | 'a' .. 'f'\n+               then Is_Based_Format_Ghost (Str (P .. Max)));\n+\n             --  Loop to scan out based integer value\n \n             loop\n+\n                --  We require a digit at this stage\n \n                if Str (P) in '0' .. '9' then\n@@ -177,9 +449,32 @@ package body System.Value_U is\n \n                else\n                   Uval := Base;\n+                  Base := 10;\n+                  pragma Assert (Ptr.all = Last_Num_Init + 1);\n+                  pragma Assert (if not Overflow then Uval = Init_Val.Value);\n                   exit;\n                end if;\n \n+               Lemma_Digit_Is_Before_Last (Str, P, Last_Num_Init + 2, Max);\n+\n+               pragma Loop_Invariant (P in P'Loop_Entry .. Last_Num_Based);\n+               pragma Loop_Invariant\n+                 (Str (P) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+                  and then Digit = Hexa_To_Unsigned_Ghost (Str (P)));\n+               pragma Loop_Invariant\n+                 (if Overflow'Loop_Entry then Overflow);\n+               pragma Loop_Invariant\n+                 (if Overflow then\n+                    Overflow'Loop_Entry or else Based_Val.Overflow);\n+               pragma Loop_Invariant\n+                 (if not Overflow\n+                  then Based_Val = Scan_Based_Number_Ghost\n+                    (Str, P, Last_Num_Based, Base, Uval));\n+               pragma Loop_Invariant (Ptr.all = Last_Num_Init + 1);\n+\n+               Old_Uval := Uval;\n+               Old_Overflow := Overflow;\n+\n                --  If digit is too large, just signal overflow and continue.\n                --  The idea here is to keep scanning as long as the input is\n                --  syntactically valid, even if we have detected overflow\n@@ -203,6 +498,10 @@ package body System.Value_U is\n                   end if;\n                end if;\n \n+               Lemma_Scan_Digit\n+                 (Str, P, Last_Num_Based, Digit, Base, Old_Uval, Uval,\n+                  Based_Val, Old_Overflow, Overflow);\n+\n                --  If at end of string with no base char, not a based number\n                --  but we signal Constraint_Error and set the pointer past\n                --  the end of the field, since this is what the ACVC tests\n@@ -219,23 +518,62 @@ package body System.Value_U is\n \n                if Str (P) = Base_Char then\n                   Ptr.all := P + 1;\n+                  pragma Assert (Ptr.all = Last_Num_Based + 2);\n+                  Lemma_End_Of_Scan (Str, P, Last_Num_Based, Base, Uval);\n+                  pragma Assert (if not Overflow then Uval = Based_Val.Value);\n                   exit;\n \n                --  Deal with underscore\n \n                elsif Str (P) = '_' then\n+                  Lemma_Scan_Underscore\n+                    (Str, P, Last_Num_Init + 2, Max, Last_Num_Based, Base,\n+                     Uval, Based_Val, Overflow, True);\n                   Scan_Underscore (Str, P, Ptr, Max, True);\n+                  pragma Assert\n+                    (if not Overflow\n+                     then Based_Val = Scan_Based_Number_Ghost\n+                       (Str, P, Last_Num_Based, Base, Uval));\n                end if;\n-\n             end loop;\n          end;\n+         pragma Assert\n+           (if Starts_As_Based then P = Last_Num_Based + 1\n+            else P = Last_Num_Init + 2);\n+         pragma Assert\n+           (Overflow =\n+              (Init_Val.Overflow\n+               or else Init_Val.Value not in 2 .. 16\n+               or else (Starts_As_Based and then Based_Val.Overflow)));\n       end if;\n \n+      pragma Assert_And_Cut\n+        (Overflow =\n+           (Init_Val.Overflow\n+            or else\n+              (Last_Num_Init < Max - 1\n+               and then Str (Last_Num_Init + 1) in '#' | ':'\n+               and then Init_Val.Value not in 2 .. 16)\n+            or else (Starts_As_Based and then Based_Val.Overflow))\n+         and then\n+           (if not Overflow then\n+                (if Is_Based then Uval = Based_Val.Value\n+                 else Uval = Init_Val.Value))\n+         and then Ptr.all = First_Exp\n+         and then Base in 2 .. 16\n+         and then\n+           (if not Overflow then\n+                (if Is_Based then Base = Init_Val.Value else Base = 10)));\n+\n       --  Come here with scanned unsigned value in Uval. The only remaining\n       --  required step is to deal with exponent if one is present.\n \n       Scan_Exponent (Str, Ptr, Max, Expon);\n \n+      pragma Assert\n+        (if Starts_As_Exponent_Format_Ghost (Str (First_Exp .. Max))\n+         then Expon = Scan_Exponent_Ghost (Str (First_Exp .. Max)));\n+\n       if Expon /= 0 and then Uval /= 0 then\n \n          --  For non-zero value, scale by exponent value. No need to do this\n@@ -246,48 +584,101 @@ package body System.Value_U is\n             UmaxB : constant Uns := Uns'Last / Base;\n             --  Numbers bigger than UmaxB overflow if multiplied by base\n \n+            Res_Val : constant Uns_Option :=\n+              Exponent_Unsigned_Ghost (Uval, Expon, Base)\n+            with Ghost;\n          begin\n             for J in 1 .. Expon loop\n+               pragma Loop_Invariant\n+                 (if Overflow'Loop_Entry then Overflow);\n+               pragma Loop_Invariant\n+                 (if Overflow\n+                  then Overflow'Loop_Entry or else Res_Val.Overflow);\n+               pragma Loop_Invariant\n+                 (if not Overflow\n+                  then Res_Val = Exponent_Unsigned_Ghost\n+                    (Uval, Expon - J + 1, Base));\n+\n+               pragma Assert\n+                 ((Uval > UmaxB) = Scan_Overflows_Ghost (0, Base, Uval));\n+\n                if Uval > UmaxB then\n                   Overflow := True;\n                   exit;\n                end if;\n \n                Uval := Uval * Base;\n             end loop;\n+            pragma Assert\n+              (Overflow = (Init_Val.Overflow\n+               or else\n+                 (Last_Num_Init < Max - 1\n+                  and then Str (Last_Num_Init + 1) in '#' | ':'\n+                  and then Init_Val.Value not in 2 .. 16)\n+               or else (Starts_As_Based and then Based_Val.Overflow)\n+               or else Res_Val.Overflow));\n+            pragma Assert\n+              (Overflow = Raw_Unsigned_Overflows_Ghost (Str, Ptr_Old, Max));\n+            pragma Assert\n+              (Exponent_Unsigned_Ghost (Uval, 0, Base) = (False, Uval));\n+            pragma Assert\n+              (if not Overflow then Uval = Res_Val.Value);\n+            pragma Assert\n+              (if not Overflow then\n+                  Uval = Scan_Raw_Unsigned_Ghost (Str, Ptr_Old, Max));\n          end;\n       end if;\n+      pragma Assert\n+        (if Expon = 0 or else Uval = 0 then\n+            Exponent_Unsigned_Ghost (Uval, Expon, Base) = (False, Uval));\n+      pragma Assert\n+        (Overflow = Raw_Unsigned_Overflows_Ghost (Str, Ptr_Old, Max));\n+      pragma Assert\n+        (if not Overflow then\n+            Uval = Scan_Raw_Unsigned_Ghost (Str, Ptr_Old, Max));\n \n-      --  Return result, dealing with sign and overflow\n+      --  Return result, dealing with overflow\n \n       if Overflow then\n          Bad_Value (Str);\n+         pragma Annotate\n+           (GNATprove, Intentional,\n+            \"call to nonreturning subprogram might be executed\",\n+            \"it is expected that Constraint_Error is raised in case of\"\n+            & \" overflow\");\n       else\n-         return Uval;\n+         Res := Uval;\n       end if;\n    end Scan_Raw_Unsigned;\n \n    -------------------\n    -- Scan_Unsigned --\n    -------------------\n \n-   function Scan_Unsigned\n+   procedure Scan_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Uns\n+      Max : Integer;\n+      Res : out Uns)\n    is\n       Start : Positive;\n       --  Save location of first non-blank character\n \n    begin\n+      pragma Warnings\n+        (Off,\n+         \"\"\"Start\"\" is set by \"\"Scan_Plus_Sign\"\" but not used after the call\");\n       Scan_Plus_Sign (Str, Ptr, Max, Start);\n+      pragma Warnings\n+        (On,\n+         \"\"\"Start\"\" is set by \"\"Scan_Plus_Sign\"\" but not used after the call\");\n \n       if Str (Ptr.all) not in '0' .. '9' then\n          Ptr.all := Start;\n          Bad_Value (Str);\n       end if;\n \n-      return Scan_Raw_Unsigned (Str, Ptr, Max);\n+      Scan_Raw_Unsigned (Str, Ptr, Max, Res);\n    end Scan_Unsigned;\n \n    --------------------\n@@ -313,9 +704,32 @@ package body System.Value_U is\n          declare\n             V : Uns;\n             P : aliased Integer := Str'First;\n+\n+            Non_Blank : constant Positive := First_Non_Space_Ghost\n+              (Str, Str'First, Str'Last)\n+            with Ghost;\n+            Fst_Num   : constant Positive :=\n+              (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank)\n+            with Ghost;\n          begin\n-            V := Scan_Unsigned (Str, P'Access, Str'Last);\n+            pragma Assert\n+              (Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last)));\n+\n+            declare\n+               P_Acc : constant not null access Integer := P'Access;\n+            begin\n+               Scan_Unsigned (Str, P_Acc, Str'Last, V);\n+            end;\n+\n+            pragma Assert\n+              (P = Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last));\n+            pragma Assert\n+              (V = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last));\n+\n             Scan_Trailing_Blanks (Str, P);\n+\n+            pragma Assert\n+              (Is_Value_Unsigned_Ghost (Slide_If_Necessary (Str), V));\n             return V;\n          end;\n       end if;"}, {"sha": "b0e3b1ea6cd71eb29b00759422dee4e387f2b937", "filename": "gcc/ada/libgnat/s-valueu.ads", "status": "modified", "additions": 457, "deletions": 5, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -32,17 +32,337 @@\n --  This package contains routines for scanning modular Unsigned\n --  values for use in Text_IO.Modular_IO, and the Value attribute.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+pragma Warnings (Off, \"postcondition does not mention function result\");\n+--  True postconditions are used to avoid inlining for GNATprove\n+\n+with System.Val_Util; use System.Val_Util;\n+\n generic\n \n    type Uns is mod <>;\n \n package System.Value_U is\n    pragma Preelaborate;\n \n-   function Scan_Raw_Unsigned\n+   type Uns_Option (Overflow : Boolean := False) is record\n+      case Overflow is\n+         when True =>\n+            null;\n+         when False =>\n+            Value : Uns := 0;\n+      end case;\n+   end record with Ghost;\n+\n+   function Only_Hexa_Ghost (Str : String; From, To : Integer) return Boolean\n+   is\n+      (for all J in From .. To =>\n+          Str (J) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_')\n+   with\n+     Ghost,\n+     Pre => From > To or else (From >= Str'First and then To <= Str'Last);\n+   --  Ghost function that returns True if S has only hexadecimal characters\n+   --  from index From to index To.\n+\n+   function Last_Hexa_Ghost (Str : String) return Positive\n+   with\n+     Ghost,\n+     Pre  => Str /= \"\"\n+       and then Str (Str'First) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F',\n+     Post => Last_Hexa_Ghost'Result in Str'Range\n+       and then (if Last_Hexa_Ghost'Result < Str'Last then\n+                   Str (Last_Hexa_Ghost'Result + 1) not in\n+                     '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_')\n+       and then Only_Hexa_Ghost (Str, Str'First, Last_Hexa_Ghost'Result);\n+   --  Ghost function that returns the index of the last character in S that\n+   --  is either an hexadecimal digit or an underscore, which necessarily\n+   --  exists given the precondition on Str.\n+\n+   function Is_Based_Format_Ghost (Str : String) return Boolean\n+   is\n+     (Str /= \"\"\n+        and then Str (Str'First) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+        and then\n+        (declare\n+           L : constant Positive := Last_Hexa_Ghost (Str);\n+         begin\n+           Str (L) /= '_'\n+             and then (for all J in Str'First .. L =>\n+                         (if Str (J) = '_' then Str (J + 1) /= '_'))))\n+   with\n+     Ghost;\n+   --  Ghost function that determines if Str has the correct format for a\n+   --  based number, consisting in a sequence of hexadecimal digits possibly\n+   --  separated by single underscores. It may be followed by other characters.\n+\n+   function Hexa_To_Unsigned_Ghost (X : Character) return Uns is\n+     (case X is\n+         when '0' .. '9' => Character'Pos (X) - Character'Pos ('0'),\n+         when 'a' .. 'f' => Character'Pos (X) - Character'Pos ('a') + 10,\n+         when 'A' .. 'F' => Character'Pos (X) - Character'Pos ('A') + 10,\n+         when others     => raise Program_Error)\n+   with\n+     Ghost,\n+     Pre => X in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+   --  Ghost function that computes the value corresponding to an hexadecimal\n+   --  digit.\n+\n+   function Scan_Overflows_Ghost\n+     (Digit : Uns;\n+      Base  : Uns;\n+      Acc   : Uns) return Boolean\n+   is\n+     (Digit >= Base\n+      or else Acc > Uns'Last / Base\n+      or else Uns'Last - Digit < Base * Acc)\n+   with Ghost;\n+   --  Ghost function which returns True if Digit + Base * Acc overflows or\n+   --  Digit is greater than Base, as this is used by the algorithm for the\n+   --  test of overflow.\n+\n+   function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0) return Uns_Option\n+   with\n+     Ghost,\n+     Subprogram_Variant => (Increases => From),\n+     Pre  => Str'Last /= Positive'Last\n+         and then\n+           (From > To or else (From >= Str'First and then To <= Str'Last))\n+         and then Only_Hexa_Ghost (Str, From, To);\n+   --  Ghost function that recursively computes the based number in Str,\n+   --  assuming Acc has been scanned already and scanning continues at index\n+   --  From.\n+\n+   function Exponent_Unsigned_Ghost\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10) return Uns_Option\n+   with\n+     Ghost,\n+     Subprogram_Variant => (Decreases => Exp);\n+   --  Ghost function that recursively computes Value * Base ** Exp\n+\n+   function Is_Raw_Unsigned_Format_Ghost (Str : String) return Boolean is\n+     (Is_Natural_Format_Ghost (Str)\n+      and then\n+        (declare\n+           Last_Num_Init   : constant Integer := Last_Number_Ghost (Str);\n+           Starts_As_Based : constant Boolean :=\n+             Last_Num_Init < Str'Last - 1\n+             and then Str (Last_Num_Init + 1) in '#' | ':'\n+             and then Str (Last_Num_Init + 2) in\n+               '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+           Last_Num_Based  : constant Integer :=\n+             (if Starts_As_Based\n+              then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n+              else Last_Num_Init);\n+           Is_Based        : constant Boolean :=\n+             Starts_As_Based\n+             and then Last_Num_Based < Str'Last\n+             and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n+           First_Exp       : constant Integer :=\n+             (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n+         begin\n+           (if Starts_As_Based then\n+              Is_Based_Format_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n+              and then Last_Num_Based < Str'Last)\n+            and then Is_Opt_Exponent_Format_Ghost\n+              (Str (First_Exp .. Str'Last))))\n+   with\n+     Ghost,\n+     Pre  => Str'Last /= Positive'Last,\n+     Post => True;\n+   --  Ghost function that determines if Str has the correct format for an\n+   --  unsigned number without a sign character.\n+   --  It is a natural number in base 10, optionally followed by a based\n+   --  number surrounded by delimiters # or :, optionally followed by an\n+   --  exponent part.\n+\n+   function Raw_Unsigned_Overflows_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean\n+   is\n+     (declare\n+        Last_Num_Init   : constant Integer :=\n+          Last_Number_Ghost (Str (From .. To));\n+        Init_Val        : constant Uns_Option :=\n+          Scan_Based_Number_Ghost (Str, From, Last_Num_Init);\n+        Starts_As_Based : constant Boolean :=\n+          Last_Num_Init < To - 1\n+          and then Str (Last_Num_Init + 1) in '#' | ':'\n+          and then Str (Last_Num_Init + 2) in\n+          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+        Last_Num_Based  : constant Integer :=\n+          (if Starts_As_Based\n+           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n+           else Last_Num_Init);\n+        Is_Based        : constant Boolean :=\n+          Starts_As_Based\n+          and then Last_Num_Based < To\n+          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n+        Based_Val       : constant Uns_Option :=\n+          (if Starts_As_Based and then not Init_Val.Overflow\n+           then Scan_Based_Number_Ghost\n+             (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n+           else Init_Val);\n+        First_Exp       : constant Integer :=\n+          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n+        Expon           : constant Natural :=\n+          (if Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n+           then Scan_Exponent_Ghost (Str (First_Exp .. To))\n+           else 0);\n+      begin\n+        Init_Val.Overflow\n+        or else\n+          (Last_Num_Init < To - 1\n+           and then Str (Last_Num_Init + 1) in '#' | ':'\n+           and then Init_Val.Value not in 2 .. 16)\n+        or else\n+          (Starts_As_Based\n+           and then Based_Val.Overflow)\n+        or else\n+          (Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n+           and then\n+             (declare\n+                Base  : constant Uns :=\n+                  (if Is_Based then Init_Val.Value else 10);\n+                Value : constant Uns :=\n+                  (if Is_Based then Based_Val.Value else Init_Val.Value);\n+              begin\n+                Exponent_Unsigned_Ghost\n+                  (Value, Expon, Base).Overflow)))\n+   with\n+     Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9',\n+     Post => True;\n+   --  Ghost function that determines if the computation of the unsigned number\n+   --  represented by Str will overflow. The computation overflows if either:\n+   --    * The computation of the decimal part overflows,\n+   --    * The decimal part is followed by a valid delimiter for a based\n+   --      part, and the number corresponding to the base is not a valid base,\n+   --    * The computation of the based part overflows, or\n+   --    * There is an exponent and the computation of the exponentiation\n+   --      overflows.\n+\n+   function Scan_Raw_Unsigned_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Uns\n+   is\n+     (declare\n+        Last_Num_Init   : constant Integer :=\n+          Last_Number_Ghost (Str (From .. To));\n+        Init_Val        : constant Uns_Option :=\n+          Scan_Based_Number_Ghost (Str, From, Last_Num_Init);\n+        Starts_As_Based : constant Boolean :=\n+          Last_Num_Init < To - 1\n+          and then Str (Last_Num_Init + 1) in '#' | ':'\n+          and then Str (Last_Num_Init + 2) in\n+          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+        Last_Num_Based  : constant Integer :=\n+          (if Starts_As_Based\n+           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n+           else Last_Num_Init);\n+        Is_Based        : constant Boolean :=\n+          Starts_As_Based\n+          and then Last_Num_Based < To\n+          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n+        Based_Val       : constant Uns_Option :=\n+          (if Starts_As_Based and then not Init_Val.Overflow\n+           then Scan_Based_Number_Ghost\n+             (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n+           else Init_Val);\n+        First_Exp       : constant Integer :=\n+          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n+        Expon           : constant Natural :=\n+          (if Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n+           then Scan_Exponent_Ghost (Str (First_Exp .. To))\n+           else 0);\n+        Base            : constant Uns :=\n+          (if Is_Based then Init_Val.Value else 10);\n+        Value           : constant Uns :=\n+          (if Is_Based then Based_Val.Value else Init_Val.Value);\n+      begin\n+        Exponent_Unsigned_Ghost (Value, Expon, Base).Value)\n+   with\n+     Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9'\n+       and then not Raw_Unsigned_Overflows_Ghost (Str, From, To),\n+     Post => True;\n+   --  Ghost function that scans an unsigned number without a sign character\n+\n+   function Raw_Unsigned_Last_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Positive\n+   is\n+     (declare\n+        Last_Num_Init   : constant Integer :=\n+          Last_Number_Ghost (Str (From .. To));\n+        Starts_As_Based : constant Boolean :=\n+          Last_Num_Init < To - 1\n+          and then Str (Last_Num_Init + 1) in '#' | ':'\n+          and then Str (Last_Num_Init + 2) in\n+          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+        Last_Num_Based  : constant Integer :=\n+          (if Starts_As_Based\n+           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n+           else Last_Num_Init);\n+        Is_Based        : constant Boolean :=\n+          Starts_As_Based\n+          and then Last_Num_Based < To\n+          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n+        First_Exp       : constant Integer :=\n+          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n+      begin\n+        (if not Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n+         then First_Exp\n+         elsif Str (First_Exp + 1) in '-' | '+' then\n+           Last_Number_Ghost (Str (First_Exp + 2 .. To)) + 1\n+         else Last_Number_Ghost (Str (First_Exp + 1 .. To)) + 1))\n+   with\n+     Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9',\n+     Post => Raw_Unsigned_Last_Ghost'Result in From .. To + 1;\n+   --  Ghost function that returns the position of the cursor once an unsigned\n+   --  number has been seen.\n+\n+   procedure Scan_Raw_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Uns;\n+      Max : Integer;\n+      Res : out Uns)\n+   with Pre => Str'Last /= Positive'Last\n+     and then Ptr.all in Str'Range\n+     and then Max in Ptr.all .. Str'Last\n+     and then Is_Raw_Unsigned_Format_Ghost (Str (Ptr.all .. Max)),\n+     Post => not Raw_Unsigned_Overflows_Ghost (Str, Ptr.all'Old, Max)\n+     and Res = Scan_Raw_Unsigned_Ghost (Str, Ptr.all'Old, Max)\n+     and Ptr.all = Raw_Unsigned_Last_Ghost (Str, Ptr.all'Old, Max);\n+\n    --  This function scans the string starting at Str (Ptr.all) for a valid\n    --  integer according to the syntax described in (RM 3.5(43)). The substring\n    --  scanned extends no further than Str (Max).  Note: this does not scan\n@@ -106,26 +426,158 @@ package System.Value_U is\n    --  Note: if Str is empty, i.e. if Max is less than Ptr, then this is a\n    --  special case of an all-blank string, and Ptr is unchanged, and hence\n    --  is greater than Max as required in this case.\n+   --  ??? This is not the case. We will read Str (Ptr.all) without checking\n+   --  and increase Ptr.all by one.\n    --\n    --  Note: this routine should not be called with Str'Last = Positive'Last.\n    --  If this occurs Program_Error is raised with a message noting that this\n    --  case is not supported. Most such cases are eliminated by the caller.\n \n-   function Scan_Unsigned\n+   procedure Scan_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Uns;\n+      Max : Integer;\n+      Res : out Uns)\n+   with Pre => Str'Last /= Positive'Last\n+     and then Ptr.all in Str'Range\n+     and then Max in Ptr.all .. Str'Last\n+     and then not Only_Space_Ghost (Str, Ptr.all, Max)\n+     and then\n+       (declare\n+          Non_Blank : constant Positive :=\n+            First_Non_Space_Ghost (Str, Ptr.all, Max);\n+          Fst_Num   : constant Positive :=\n+            (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+        begin\n+          Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Max))),\n+     Post =>\n+       (declare\n+          Non_Blank : constant Positive :=\n+            First_Non_Space_Ghost (Str, Ptr.all'Old, Max);\n+          Fst_Num   : constant Positive :=\n+            (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+        begin\n+          not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Max)\n+          and then Res = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max)\n+          and then Ptr.all = Raw_Unsigned_Last_Ghost (Str, Fst_Num, Max));\n+\n    --  Same as Scan_Raw_Unsigned, except scans optional leading\n    --  blanks, and an optional leading plus sign.\n    --\n    --  Note: if a minus sign is present, Constraint_Error will be raised.\n    --  Note: trailing blanks are not scanned.\n \n+   function Slide_To_1 (Str : String) return String\n+   with Ghost,\n+       Post =>\n+         Only_Space_Ghost (Str, Str'First, Str'Last) =\n+         (for all J in Str'First .. Str'Last =>\n+            Slide_To_1'Result (J - Str'First + 1) = ' ');\n+   --  Slides Str so that it starts at 1\n+\n+   function Slide_If_Necessary (Str : String) return String is\n+     (if Str'Last = Positive'Last then Slide_To_1 (Str) else Str)\n+   with Ghost,\n+       Post =>\n+         Only_Space_Ghost (Str, Str'First, Str'Last) =\n+         Only_Space_Ghost (Slide_If_Necessary'Result,\n+                           Slide_If_Necessary'Result'First,\n+                           Slide_If_Necessary'Result'Last);\n+   --  If Str'Last = Positive'Last then slides Str so that it starts at 1\n+\n+   function Is_Unsigned_Ghost (Str : String) return Boolean is\n+     (declare\n+        Non_Blank : constant Positive := First_Non_Space_Ghost\n+          (Str, Str'First, Str'Last);\n+        Fst_Num   : constant Positive :=\n+          (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+      begin\n+        Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last))\n+          and then not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Str'Last)\n+          and then Only_Space_Ghost\n+             (Str, Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last), Str'Last))\n+   with Ghost,\n+       Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n+       and then Str'Last /= Positive'Last,\n+       Post => True;\n+   --  Ghost function that determines if Str has the correct format for an\n+   --  unsigned number, consisting in some blank characters, an optional\n+   --  + sign, a raw unsigned number which does not overflow and then some\n+   --  more blank characters.\n+\n+   function Is_Value_Unsigned_Ghost (Str : String; Val : Uns) return Boolean is\n+     (declare\n+        Non_Blank : constant Positive := First_Non_Space_Ghost\n+          (Str, Str'First, Str'Last);\n+        Fst_Num   : constant Positive :=\n+          (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+      begin\n+        Val = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last))\n+   with Ghost,\n+       Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n+       and then Str'Last /= Positive'Last\n+       and then Is_Unsigned_Ghost (Str),\n+       Post => True;\n+   --  Ghost function that returns True if Val is the value corresponding to\n+   --  the unsigned number represented by Str.\n+\n    function Value_Unsigned\n-     (Str : String) return Uns;\n+     (Str : String) return Uns\n+   with Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n+     and then Str'Length /= Positive'Last\n+     and then Is_Unsigned_Ghost (Slide_If_Necessary (Str)),\n+     Post =>\n+         Is_Value_Unsigned_Ghost\n+           (Slide_If_Necessary (Str), Value_Unsigned'Result),\n+     Subprogram_Variant => (Decreases => Str'First);\n    --  Used in computing X'Value (Str) where X is a modular integer type whose\n    --  modulus does not exceed the range of System.Unsigned_Types.Unsigned. Str\n    --  is the string argument of the attribute. Constraint_Error is raised if\n    --  the string is malformed, or if the value is out of range.\n \n+private\n+\n+   -----------------------------\n+   -- Exponent_Unsigned_Ghost --\n+   -----------------------------\n+\n+   function Exponent_Unsigned_Ghost\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10) return Uns_Option\n+   is\n+      (if Exp = 0 or Value = 0 then (Overflow => False, Value => Value)\n+       elsif Scan_Overflows_Ghost (0, Base, Value) then (Overflow => True)\n+       else Exponent_Unsigned_Ghost (Value * Base, Exp - 1, Base));\n+\n+   -----------------------------\n+   -- Scan_Based_Number_Ghost --\n+   -----------------------------\n+\n+   function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0) return Uns_Option\n+   is\n+      (if From > To then (Overflow => False, Value => Acc)\n+       elsif Str (From) = '_'\n+       then Scan_Based_Number_Ghost (Str, From + 1, To, Base, Acc)\n+       elsif Scan_Overflows_Ghost\n+         (Hexa_To_Unsigned_Ghost (Str (From)), Base, Acc)\n+       then (Overflow => True)\n+       else Scan_Based_Number_Ghost\n+         (Str, From + 1, To, Base,\n+          Base * Acc + Hexa_To_Unsigned_Ghost (Str (From))));\n+\n+   ----------------\n+   -- Slide_To_1 --\n+   ----------------\n+\n+   function Slide_To_1 (Str : String) return String is\n+      (declare\n+         Res : constant String (1 .. Str'Length) := Str;\n+       begin\n+         Res);\n+\n end System.Value_U;"}, {"sha": "23f73eda4d84efe1af6937e6ebb028780589f3c4", "filename": "gcc/ada/libgnat/s-valuns.ads", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuns.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -32,26 +32,40 @@\n --  This package contains routines for scanning modular Unsigned\n --  values for use in Text_IO.Modular_IO, and the Value attribute.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Unsigned_Types;\n with System.Value_U;\n \n-package System.Val_Uns is\n+package System.Val_Uns with SPARK_Mode is\n    pragma Preelaborate;\n \n    subtype Unsigned is Unsigned_Types.Unsigned;\n \n    package Impl is new Value_U (Unsigned);\n \n-   function Scan_Raw_Unsigned\n+   procedure Scan_Raw_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Unsigned\n+      Max : Integer;\n+      Res : out Unsigned)\n      renames Impl.Scan_Raw_Unsigned;\n \n-   function Scan_Unsigned\n+   procedure Scan_Unsigned\n      (Str : String;\n       Ptr : not null access Integer;\n-      Max : Integer) return Unsigned\n+      Max : Integer;\n+      Res : out Unsigned)\n      renames Impl.Scan_Unsigned;\n \n    function Value_Unsigned"}, {"sha": "4da585adb5f2d1c8589c180dada466e9f4b28532", "filename": "gcc/ada/libgnat/s-valuti.adb", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuti.adb?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -66,14 +66,17 @@ is\n    -- First_Non_Space_Ghost --\n    ---------------------------\n \n-   function First_Non_Space_Ghost (S : String) return Positive is\n+   function First_Non_Space_Ghost\n+     (S        : String;\n+      From, To : Integer) return Positive\n+   is\n    begin\n-      for J in S'Range loop\n+      for J in From .. To loop\n          if S (J) /= ' ' then\n             return J;\n          end if;\n \n-         pragma Loop_Invariant (for all K in S'First .. J => S (K) = ' ');\n+         pragma Loop_Invariant (for all K in From .. J => S (K) = ' ');\n       end loop;\n \n       raise Program_Error;\n@@ -172,6 +175,9 @@ is\n          Exp := 0;\n          return;\n       end if;\n+      pragma Annotate\n+        (CodePeer, False_Positive, \"test always false\",\n+         \"the slice might be empty or not start with an 'e'\");\n \n       --  We have an E/e, see if sign follows\n \n@@ -222,25 +228,18 @@ is\n          pragma Assert (Is_Natural_Format_Ghost (Rest));\n \n          loop\n-            pragma Assert (Str (P) = Rest (P));\n             pragma Assert (Str (P) in '0' .. '9');\n \n             if X < (Integer'Last / 10) then\n                X := X * 10 + (Character'Pos (Str (P)) - Character'Pos ('0'));\n             end if;\n \n             pragma Loop_Invariant (X >= 0);\n-            pragma Loop_Invariant (P in P'Loop_Entry .. Last);\n+            pragma Loop_Invariant (P in Rest'First .. Last);\n             pragma Loop_Invariant (Str (P) in '0' .. '9');\n             pragma Loop_Invariant\n-              (Scan_Natural_Ghost (Rest, P'Loop_Entry, 0)\n-               = (if P = Max\n-                    or else Rest (P + 1) not in '0' .. '9' | '_'\n-                    or else X >= Integer'Last / 10\n-                  then\n-                    X\n-                  else\n-                    Scan_Natural_Ghost (Rest, P + 1, X)));\n+              (Scan_Natural_Ghost (Rest, Rest'First, 0)\n+               = Scan_Natural_Ghost (Rest, P + 1, X));\n \n             P := P + 1;\n \n@@ -252,6 +251,8 @@ is\n                exit when Str (P) not in '0' .. '9';\n             end if;\n          end loop;\n+\n+         pragma Assert (P = Last + 1);\n       end;\n \n       if M then\n@@ -298,7 +299,7 @@ is\n \n       Start := P;\n \n-      pragma Assert (Start = First_Non_Space_Ghost (Str (Ptr.all .. Max)));\n+      pragma Assert (Start = First_Non_Space_Ghost (Str, Ptr.all, Max));\n \n       --  Skip past an initial plus sign\n \n@@ -354,7 +355,7 @@ is\n \n       Start := P;\n \n-      pragma Assert (Start = First_Non_Space_Ghost (Str (Ptr.all .. Max)));\n+      pragma Assert (Start = First_Non_Space_Ghost (Str, Ptr.all, Max));\n \n       --  Remember an initial minus sign\n "}, {"sha": "5c0f2a5d6bdf9463cb800b57e2bc546ab4b49de9", "filename": "gcc/ada/libgnat/s-valuti.ads", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649b3efae598aaf855b8cc453749695dded9fa95/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuti.ads?ref=649b3efae598aaf855b8cc453749695dded9fa95", "patch": "@@ -41,6 +41,8 @@ pragma Assertion_Policy (Pre            => Ignore,\n                          Post           => Ignore,\n                          Contract_Cases => Ignore,\n                          Ghost          => Ignore);\n+pragma Warnings (Off, \"postcondition does not mention function result\");\n+--  True postconditions are used to avoid inlining for GNATprove\n \n with System.Case_Util;\n \n@@ -59,18 +61,23 @@ is\n       (for all J in From .. To => S (J) = ' ')\n    with\n      Ghost,\n-     Pre => From > To or else (From >= S'First and then To <= S'Last);\n+     Pre  => From > To or else (From >= S'First and then To <= S'Last),\n+     Post => True;\n    --  Ghost function that returns True if S has only space characters from\n    --  index From to index To.\n \n-   function First_Non_Space_Ghost (S : String) return Positive\n+   function First_Non_Space_Ghost\n+     (S        : String;\n+      From, To : Integer) return Positive\n    with\n      Ghost,\n-     Pre  => not Only_Space_Ghost (S, S'First, S'Last),\n-     Post => First_Non_Space_Ghost'Result in S'Range\n+     Pre  => From in S'Range\n+       and then To in S'Range\n+       and then not Only_Space_Ghost (S, From, To),\n+     Post => First_Non_Space_Ghost'Result in From .. To\n        and then S (First_Non_Space_Ghost'Result) /= ' '\n        and then Only_Space_Ghost\n-         (S, S'First, First_Non_Space_Ghost'Result - 1);\n+         (S, From, First_Non_Space_Ghost'Result - 1);\n    --  Ghost function that returns the index of the first non-space character\n    --  in S, which necessarily exists given the precondition on S.\n \n@@ -117,14 +124,14 @@ is\n        and then\n          (declare\n             F : constant Positive :=\n-              First_Non_Space_Ghost (Str (Ptr.all .. Max));\n+              First_Non_Space_Ghost (Str, Ptr.all, Max);\n           begin\n             (if Str (F) in '+' | '-' then\n                F <= Max - 1 and then Str (F + 1) /= ' ')),\n      Post =>\n        (declare\n           F : constant Positive :=\n-            First_Non_Space_Ghost (Str (Ptr.all'Old .. Max));\n+            First_Non_Space_Ghost (Str, Ptr.all'Old, Max);\n         begin\n           Minus = (Str (F) = '-')\n             and then Ptr.all = (if Str (F) in '+' | '-' then F + 1 else F)\n@@ -162,14 +169,14 @@ is\n        and then\n          (declare\n             F : constant Positive :=\n-              First_Non_Space_Ghost (Str (Ptr.all .. Max));\n+              First_Non_Space_Ghost (Str, Ptr.all, Max);\n           begin\n             (if Str (F) = '+' then\n                F <= Max - 1 and then Str (F + 1) /= ' ')),\n      Post =>\n        (declare\n           F : constant Positive :=\n-            First_Non_Space_Ghost (Str (Ptr.all'Old .. Max));\n+            First_Non_Space_Ghost (Str, Ptr.all'Old, Max);\n         begin\n           Ptr.all = (if Str (F) = '+' then F + 1 else F)\n             and then Start = F);\n@@ -195,7 +202,7 @@ is\n        and then Only_Number_Ghost (Str, Str'First, Last_Number_Ghost'Result);\n    --  Ghost function that returns the index of the last character in S that\n    --  is either a figure or underscore, which necessarily exists given the\n-   --  precondition on S.\n+   --  precondition on Str.\n \n    function Is_Natural_Format_Ghost (Str : String) return Boolean is\n      (Str /= \"\"\n@@ -215,7 +222,7 @@ is\n \n    function Starts_As_Exponent_Format_Ghost\n      (Str  : String;\n-      Real : Boolean) return Boolean\n+      Real : Boolean := False) return Boolean\n    is\n      (Str'Length > 1\n       and then Str (Str'First) in 'E' | 'e'\n@@ -242,7 +249,7 @@ is\n \n    function Is_Opt_Exponent_Format_Ghost\n      (Str  : String;\n-      Real : Boolean) return Boolean\n+      Real : Boolean := False) return Boolean\n    is\n      (not Starts_As_Exponent_Format_Ghost (Str, Real)\n       or else\n@@ -265,13 +272,35 @@ is\n    with\n      Ghost,\n      Subprogram_Variant => (Increases => P),\n-     Pre => Is_Natural_Format_Ghost (Str)\n-       and then P in Str'First .. Last_Number_Ghost (Str)\n-       and then Acc < Integer'Last / 10;\n+     Pre => Str /= \"\" and then Str (Str'First) in '0' .. '9'\n+       and then Str'Last < Natural'Last\n+       and then P in Str'First .. Last_Number_Ghost (Str) + 1;\n    --  Ghost function that recursively computes the natural number in Str, up\n    --  to the first number greater or equal to Natural'Last / 10, assuming Acc\n    --  has been scanned already and scanning continues at index P.\n \n+   function Scan_Exponent_Ghost\n+     (Str  : String;\n+      Real : Boolean := False)\n+      return Integer\n+   is\n+     (declare\n+        Plus_Sign  : constant Boolean := Str (Str'First + 1) = '+';\n+        Minus_Sign : constant Boolean := Str (Str'First + 1) = '-';\n+        Sign       : constant Boolean := Plus_Sign or Minus_Sign;\n+        Start      : constant Natural :=\n+          (if Sign then Str'First + 2 else Str'First + 1);\n+        Value      : constant Natural :=\n+          Scan_Natural_Ghost (Str (Start .. Str'Last), Start, 0);\n+      begin\n+        (if Minus_Sign then -Value else Value))\n+   with\n+     Ghost,\n+     Pre  => Str'Last < Natural'Last\n+       and then Starts_As_Exponent_Format_Ghost (Str, Real),\n+     Post => (if not Real then Scan_Exponent_Ghost'Result >= 0);\n+   --  Ghost function that scans an exponent\n+\n    procedure Scan_Exponent\n      (Str  : String;\n       Ptr  : not null access Integer;\n@@ -286,17 +315,11 @@ is\n          and then Is_Opt_Exponent_Format_Ghost (Str (Ptr.all .. Max), Real),\n      Post =>\n        (if Starts_As_Exponent_Format_Ghost (Str (Ptr.all'Old .. Max), Real)\n-        then\n-          (declare\n-             Plus_Sign  : constant Boolean := Str (Ptr.all'Old + 1) = '+';\n-             Minus_Sign : constant Boolean := Str (Ptr.all'Old + 1) = '-';\n-             Sign       : constant Boolean := Plus_Sign or Minus_Sign;\n-             Start      : constant Natural :=\n-               (if Sign then Ptr.all'Old + 2 else Ptr.all'Old + 1);\n-             Value      : constant Natural :=\n-               Scan_Natural_Ghost (Str (Start .. Max), Start, 0);\n-           begin\n-             Exp = (if Minus_Sign then -Value else Value))\n+        then Exp = Scan_Exponent_Ghost (Str (Ptr.all'Old .. Max), Real)\n+          and then\n+          (if Str (Ptr.all'Old + 1) in '-' | '+' then\n+             Ptr.all = Last_Number_Ghost (Str (Ptr.all'Old + 2 .. Max)) + 1\n+           else Ptr.all = Last_Number_Ghost (Str (Ptr.all'Old + 1 .. Max)) + 1)\n         else Exp = 0 and Ptr.all = Ptr.all'Old);\n    --  Called to scan a possible exponent. Str, Ptr, Max are as described above\n    --  for Scan_Sign. If Ptr.all < Max and Str (Ptr.all) = 'E' or 'e', then an\n@@ -340,7 +363,7 @@ is\n             Str (P + 1) in '0' .. '9'),\n      Post =>\n        P = P'Old + 1\n-         and then Ptr.all = Ptr.all;\n+         and then Ptr.all'Old = Ptr.all;\n    --  Called if an underscore is encountered while scanning digits. Str (P)\n    --  contains the underscore. Ptr is the pointer to be returned to the\n    --  ultimate caller of the scan routine, Max is the maximum subscript in\n@@ -365,19 +388,20 @@ private\n       Acc : Natural)\n       return Natural\n    is\n-     (if Str (P) = '_' then\n+     (if P > Str'Last\n+        or else Str (P) not in '0' .. '9' | '_'\n+        or else Acc >= Integer'Last / 10\n+      then\n+        Acc\n+      elsif Str (P) = '_' then\n         Scan_Natural_Ghost (Str, P + 1, Acc)\n       else\n         (declare\n            Shift_Acc : constant Natural :=\n-             Acc * 10 + (Character'Pos (Str (P)) - Character'Pos ('0'));\n+             Acc * 10 +\n+               (Integer'(Character'Pos (Str (P))) -\n+                  Integer'(Character'Pos ('0')));\n          begin\n-           (if P = Str'Last\n-              or else Str (P + 1) not in '0' .. '9' | '_'\n-              or else Shift_Acc >= Integer'Last / 10\n-            then\n-              Shift_Acc\n-            else\n-              Scan_Natural_Ghost (Str, P + 1, Shift_Acc))));\n+           Scan_Natural_Ghost (Str, P + 1, Shift_Acc)));\n \n end System.Val_Util;"}]}