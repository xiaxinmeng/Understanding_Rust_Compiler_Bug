{"sha": "600413c4f3d70392285192fb99634bcbeb97f83f", "node_id": "C_kwDOANBUbNoAKDYwMDQxM2M0ZjNkNzAzOTIyODUxOTJmYjk5NjM0YmNiZWI5N2Y4M2Y", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-08-30T09:45:34Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-08-30T10:53:50Z"}, "message": "libsanitizer: merge from master (84a71d5259c2682403cdbd8710592410a2f128ab)", "tree": {"sha": "0586f1cc2feaa4f5a3d632926b08bde261c39786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0586f1cc2feaa4f5a3d632926b08bde261c39786"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/600413c4f3d70392285192fb99634bcbeb97f83f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600413c4f3d70392285192fb99634bcbeb97f83f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600413c4f3d70392285192fb99634bcbeb97f83f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600413c4f3d70392285192fb99634bcbeb97f83f/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd3547ae4279c14a9db883719c9648ed09dc18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdd3547ae4279c14a9db883719c9648ed09dc18a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdd3547ae4279c14a9db883719c9648ed09dc18a"}], "stats": {"total": 3015, "additions": 2132, "deletions": 883}, "files": [{"sha": "3ca670c1184f753c25ec31b1a6b84aff6aa85e5e", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -1,4 +1,4 @@\n-75f9e83ace52773af65dcebca543005ec8a2705d\n+84a71d5259c2682403cdbd8710592410a2f128ab\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "10f7c17991d720447e266584e6494cffee9a6c95", "filename": "libsanitizer/asan/asan_errors.cpp", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_errors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_errors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -279,9 +279,7 @@ void ErrorRssLimitExceeded::Print() {\n void ErrorOutOfMemory::Print() {\n   Decorator d;\n   Printf(\"%s\", d.Error());\n-  Report(\n-      \"ERROR: AddressSanitizer: allocator is out of memory trying to allocate \"\n-      \"0x%zx bytes\\n\", requested_size);\n+  ERROR_OOM(\"allocator is trying to allocate 0x%zx bytes\\n\", requested_size);\n   Printf(\"%s\", d.Default());\n   stack->Print();\n   PrintHintAllocatorCannotReturnNull();"}, {"sha": "2398984332321174144f781b49111d9661e2b654", "filename": "libsanitizer/asan/asan_flags.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -87,7 +87,7 @@ void InitializeFlags() {\n   RegisterCommonFlags(&ubsan_parser);\n #endif\n \n-  if (SANITIZER_MAC) {\n+  if (SANITIZER_APPLE) {\n     // Support macOS MallocScribble and MallocPreScribble:\n     // <https://developer.apple.com/library/content/documentation/Performance/\n     // Conceptual/ManagingMemory/Articles/MallocDebug.html>"}, {"sha": "fad1577d912a5e12661e5a52e88cc882107abdbf", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -83,6 +83,10 @@ ASAN_FLAG(\n     int, sleep_after_init, 0,\n     \"Number of seconds to sleep after AddressSanitizer is initialized. \"\n     \"Useful for debugging purposes (e.g. when one needs to attach gdb).\")\n+ASAN_FLAG(\n+    int, sleep_before_init, 0,\n+    \"Number of seconds to sleep before AddressSanitizer starts initializing. \"\n+    \"Useful for debugging purposes (e.g. when one needs to attach gdb).\")\n ASAN_FLAG(bool, check_malloc_usable_size, true,\n           \"Allows the users to work around the bug in Nvidia drivers prior to \"\n           \"295.*.\")\n@@ -118,7 +122,7 @@ ASAN_FLAG(bool, poison_array_cookie, true,\n // https://github.com/google/sanitizers/issues/309\n // TODO(glider,timurrrr): Fix known issues and enable this back.\n ASAN_FLAG(bool, alloc_dealloc_mismatch,\n-          !SANITIZER_MAC && !SANITIZER_WINDOWS && !SANITIZER_ANDROID,\n+          !SANITIZER_APPLE && !SANITIZER_WINDOWS && !SANITIZER_ANDROID,\n           \"Report errors on malloc/delete, new/free, new/delete[], etc.\")\n \n ASAN_FLAG(bool, new_delete_type_mismatch, true,"}, {"sha": "b780128c9adb431255babc43521f28dc16f4d8af", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -86,10 +86,11 @@ static void ReportGlobal(const Global &g, const char *prefix) {\n       \"odr_indicator=%p\\n\",\n       prefix, (void *)&g, (void *)g.beg, g.size, g.size_with_redzone, g.name,\n       g.module_name, g.has_dynamic_init, (void *)g.odr_indicator);\n-  if (g.location) {\n-    Report(\"  location (%p): name=%s[%p], %d %d\\n\", (void *)g.location,\n-           g.location->filename, (void *)g.location->filename,\n-           g.location->line_no, g.location->column_no);\n+\n+  DataInfo info;\n+  Symbolizer::GetOrInit()->SymbolizeData(g.beg, &info);\n+  if (info.line != 0) {\n+    Report(\"  location: name=%s, %d\\n\", info.file, static_cast<int>(info.line));\n   }\n }\n \n@@ -153,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -198,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);\n@@ -276,19 +296,15 @@ void PrintGlobalNameIfASCII(InternalScopedString *str, const __asan_global &g) {\n               (char *)g.beg);\n }\n \n-static const char *GlobalFilename(const __asan_global &g) {\n-  const char *res = g.module_name;\n-  // Prefer the filename from source location, if is available.\n-  if (g.location) res = g.location->filename;\n-  CHECK(res);\n-  return res;\n-}\n-\n void PrintGlobalLocation(InternalScopedString *str, const __asan_global &g) {\n-  str->append(\"%s\", GlobalFilename(g));\n-  if (!g.location) return;\n-  if (g.location->line_no) str->append(\":%d\", g.location->line_no);\n-  if (g.location->column_no) str->append(\":%d\", g.location->column_no);\n+  DataInfo info;\n+  Symbolizer::GetOrInit()->SymbolizeData(g.beg, &info);\n+\n+  if (info.line != 0) {\n+    str->append(\"%s:%d\", info.file, static_cast<int>(info.line));\n+  } else {\n+    str->append(\"%s\", g.module_name);\n+  }\n }\n \n } // namespace __asan"}, {"sha": "817008253fc0ef55018041afd38b414ada9542bf", "filename": "libsanitizer/asan/asan_interceptors.cpp", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -103,7 +103,7 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   do {                                                                         \\\n     if (asan_init_is_running)                                                  \\\n       return REAL(func)(__VA_ARGS__);                                          \\\n-    if (SANITIZER_MAC && UNLIKELY(!asan_inited))                               \\\n+    if (SANITIZER_APPLE && UNLIKELY(!asan_inited))                               \\\n       return REAL(func)(__VA_ARGS__);                                          \\\n     ENSURE_ASAN_INITED();                                                      \\\n   } while (false)\n@@ -243,15 +243,26 @@ DEFINE_REAL_PTHREAD_FUNCTIONS\n \n #if ASAN_INTERCEPT_SWAPCONTEXT\n static void ClearShadowMemoryForContextStack(uptr stack, uptr ssize) {\n+  // Only clear if we know the stack. This should be true only for contexts\n+  // created with makecontext().\n+  if (!ssize)\n+    return;\n   // Align to page size.\n   uptr PageSize = GetPageSizeCached();\n-  uptr bottom = stack & ~(PageSize - 1);\n+  uptr bottom = RoundDownTo(stack, PageSize);\n+  if (!AddrIsInMem(bottom))\n+    return;\n   ssize += stack - bottom;\n   ssize = RoundUpTo(ssize, PageSize);\n-  static const uptr kMaxSaneContextStackSize = 1 << 22;  // 4 Mb\n-  if (AddrIsInMem(bottom) && ssize && ssize <= kMaxSaneContextStackSize) {\n-    PoisonShadow(bottom, ssize, 0);\n-  }\n+  PoisonShadow(bottom, ssize, 0);\n+}\n+\n+INTERCEPTOR(int, getcontext, struct ucontext_t *ucp) {\n+  // API does not requires to have ucp clean, and sets only part of fields. We\n+  // use ucp->uc_stack to unpoison new stack. We prefer to have zeroes then\n+  // uninitialized bytes.\n+  ResetContextStack(ucp);\n+  return REAL(getcontext)(ucp);\n }\n \n INTERCEPTOR(int, swapcontext, struct ucontext_t *oucp,\n@@ -267,15 +278,18 @@ INTERCEPTOR(int, swapcontext, struct ucontext_t *oucp,\n   uptr stack, ssize;\n   ReadContextStack(ucp, &stack, &ssize);\n   ClearShadowMemoryForContextStack(stack, ssize);\n-#if __has_attribute(__indirect_return__) && \\\n-    (defined(__x86_64__) || defined(__i386__))\n+\n+  // See getcontext interceptor.\n+  ResetContextStack(oucp);\n+\n+#    if __has_attribute(__indirect_return__) && \\\n+        (defined(__x86_64__) || defined(__i386__))\n   int (*real_swapcontext)(struct ucontext_t *, struct ucontext_t *)\n-    __attribute__((__indirect_return__))\n-    = REAL(swapcontext);\n+      __attribute__((__indirect_return__)) = REAL(swapcontext);\n   int res = real_swapcontext(oucp, ucp);\n-#else\n+#    else\n   int res = REAL(swapcontext)(oucp, ucp);\n-#endif\n+#    endif\n   // swapcontext technically does not return, but program may swap context to\n   // \"oucp\" later, that would look as if swapcontext() returned 0.\n   // We need to clear shadow for ucp once again, as it may be in arbitrary\n@@ -355,7 +369,7 @@ INTERCEPTOR(_Unwind_Reason_Code, _Unwind_SjLj_RaiseException,\n INTERCEPTOR(char*, index, const char *string, int c)\n   ALIAS(WRAPPER_NAME(strchr));\n # else\n-#  if SANITIZER_MAC\n+#  if SANITIZER_APPLE\n DECLARE_REAL(char*, index, const char *string, int c)\n OVERRIDE_FUNCTION(index, strchr);\n #  else\n@@ -409,7 +423,7 @@ INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n INTERCEPTOR(char *, strcpy, char *to, const char *from) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, strcpy);\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   if (UNLIKELY(!asan_inited))\n     return REAL(strcpy)(to, from);\n #endif\n@@ -489,7 +503,7 @@ INTERCEPTOR(long, strtol, const char *nptr, char **endptr, int base) {\n INTERCEPTOR(int, atoi, const char *nptr) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, atoi);\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   if (UNLIKELY(!asan_inited)) return REAL(atoi)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n@@ -510,7 +524,7 @@ INTERCEPTOR(int, atoi, const char *nptr) {\n INTERCEPTOR(long, atol, const char *nptr) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, atol);\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   if (UNLIKELY(!asan_inited)) return REAL(atol)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n@@ -563,7 +577,7 @@ static void AtCxaAtexit(void *unused) {\n #if ASAN_INTERCEPT___CXA_ATEXIT\n INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n             void *dso_handle) {\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   if (UNLIKELY(!asan_inited)) return REAL(__cxa_atexit)(func, arg, dso_handle);\n #endif\n   ENSURE_ASAN_INITED();\n@@ -645,6 +659,7 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(longjmp);\n \n #if ASAN_INTERCEPT_SWAPCONTEXT\n+  ASAN_INTERCEPT_FUNC(getcontext);\n   ASAN_INTERCEPT_FUNC(swapcontext);\n #endif\n #if ASAN_INTERCEPT__LONGJMP"}, {"sha": "35727a96497dcbbaaf692b5e8e74efe4259a785c", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -81,12 +81,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else\n@@ -138,7 +133,7 @@ DECLARE_REAL(char*, strncpy, char *to, const char *from, uptr size)\n DECLARE_REAL(uptr, strnlen, const char *s, uptr maxlen)\n DECLARE_REAL(char*, strstr, const char *s1, const char *s2)\n \n-#  if !SANITIZER_MAC\n+#  if !SANITIZER_APPLE\n #    define ASAN_INTERCEPT_FUNC(name)                                        \\\n       do {                                                                   \\\n         if (!INTERCEPT_FUNCTION(name))                                       \\\n@@ -161,7 +156,7 @@ DECLARE_REAL(char*, strstr, const char *s1, const char *s2)\n #  else\n // OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION.\n #    define ASAN_INTERCEPT_FUNC(name)\n-#  endif  // SANITIZER_MAC\n+#  endif  // SANITIZER_APPLE\n \n #endif  // !SANITIZER_FUCHSIA\n "}, {"sha": "bbc5390ceaa40a5a7b43d66e5418aa65f46f40f2", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.h", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -18,26 +18,29 @@\n #include \"asan_mapping.h\"\n #include \"interception/interception.h\"\n \n-DECLARE_REAL(void*, memcpy, void *to, const void *from, uptr size)\n-DECLARE_REAL(void*, memset, void *block, int c, uptr size)\n+DECLARE_REAL(void *, memcpy, void *to, const void *from, uptr size)\n+DECLARE_REAL(void *, memset, void *block, int c, uptr size)\n \n namespace __asan {\n \n // Return true if we can quickly decide that the region is unpoisoned.\n // We assume that a redzone is at least 16 bytes.\n static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n-  if (size == 0) return true;\n-  if (size <= 32)\n-    return !AddressIsPoisoned(beg) &&\n-           !AddressIsPoisoned(beg + size - 1) &&\n-           !AddressIsPoisoned(beg + size / 2);\n-  if (size <= 64)\n-    return !AddressIsPoisoned(beg) &&\n-           !AddressIsPoisoned(beg + size / 4) &&\n-           !AddressIsPoisoned(beg + size - 1) &&\n-           !AddressIsPoisoned(beg + 3 * size / 4) &&\n-           !AddressIsPoisoned(beg + size / 2);\n-  return false;\n+  if (UNLIKELY(size == 0 || size > sizeof(uptr) * ASAN_SHADOW_GRANULARITY))\n+    return !size;\n+\n+  uptr last = beg + size - 1;\n+  uptr shadow_first = MEM_TO_SHADOW(beg);\n+  uptr shadow_last = MEM_TO_SHADOW(last);\n+  uptr uptr_first = RoundDownTo(shadow_first, sizeof(uptr));\n+  uptr uptr_last = RoundDownTo(shadow_last, sizeof(uptr));\n+  if (LIKELY(((*reinterpret_cast<const uptr *>(uptr_first) |\n+               *reinterpret_cast<const uptr *>(uptr_last)) == 0)))\n+    return true;\n+  u8 shadow = AddressIsPoisoned(last);\n+  for (; shadow_first < shadow_last; ++shadow_first)\n+    shadow |= *((u8 *)shadow_first);\n+  return !shadow;\n }\n \n struct AsanInterceptorContext {\n@@ -49,75 +52,68 @@ struct AsanInterceptorContext {\n // that no extra frames are created, and stack trace contains\n // relevant information only.\n // We check all shadow bytes.\n-#define ACCESS_MEMORY_RANGE(ctx, offset, size, isWrite) do {            \\\n-    uptr __offset = (uptr)(offset);                                     \\\n-    uptr __size = (uptr)(size);                                         \\\n-    uptr __bad = 0;                                                     \\\n-    if (__offset > __offset + __size) {                                 \\\n-      GET_STACK_TRACE_FATAL_HERE;                                       \\\n-      ReportStringFunctionSizeOverflow(__offset, __size, &stack);       \\\n-    }                                                                   \\\n-    if (!QuickCheckForUnpoisonedRegion(__offset, __size) &&             \\\n-        (__bad = __asan_region_is_poisoned(__offset, __size))) {        \\\n-      AsanInterceptorContext *_ctx = (AsanInterceptorContext *)ctx;     \\\n-      bool suppressed = false;                                          \\\n-      if (_ctx) {                                                       \\\n-        suppressed = IsInterceptorSuppressed(_ctx->interceptor_name);   \\\n-        if (!suppressed && HaveStackTraceBasedSuppressions()) {         \\\n-          GET_STACK_TRACE_FATAL_HERE;                                   \\\n-          suppressed = IsStackTraceSuppressed(&stack);                  \\\n-        }                                                               \\\n-      }                                                                 \\\n-      if (!suppressed) {                                                \\\n-        GET_CURRENT_PC_BP_SP;                                           \\\n-        ReportGenericError(pc, bp, sp, __bad, isWrite, __size, 0, false);\\\n-      }                                                                 \\\n-    }                                                                   \\\n+#define ACCESS_MEMORY_RANGE(ctx, offset, size, isWrite)                   \\\n+  do {                                                                    \\\n+    uptr __offset = (uptr)(offset);                                       \\\n+    uptr __size = (uptr)(size);                                           \\\n+    uptr __bad = 0;                                                       \\\n+    if (UNLIKELY(__offset > __offset + __size)) {                         \\\n+      GET_STACK_TRACE_FATAL_HERE;                                         \\\n+      ReportStringFunctionSizeOverflow(__offset, __size, &stack);         \\\n+    }                                                                     \\\n+    if (UNLIKELY(!QuickCheckForUnpoisonedRegion(__offset, __size)) &&     \\\n+        (__bad = __asan_region_is_poisoned(__offset, __size))) {          \\\n+      AsanInterceptorContext *_ctx = (AsanInterceptorContext *)ctx;       \\\n+      bool suppressed = false;                                            \\\n+      if (_ctx) {                                                         \\\n+        suppressed = IsInterceptorSuppressed(_ctx->interceptor_name);     \\\n+        if (!suppressed && HaveStackTraceBasedSuppressions()) {           \\\n+          GET_STACK_TRACE_FATAL_HERE;                                     \\\n+          suppressed = IsStackTraceSuppressed(&stack);                    \\\n+        }                                                                 \\\n+      }                                                                   \\\n+      if (!suppressed) {                                                  \\\n+        GET_CURRENT_PC_BP_SP;                                             \\\n+        ReportGenericError(pc, bp, sp, __bad, isWrite, __size, 0, false); \\\n+      }                                                                   \\\n+    }                                                                     \\\n   } while (0)\n \n // memcpy is called during __asan_init() from the internals of printf(...).\n // We do not treat memcpy with to==from as a bug.\n // See http://llvm.org/bugs/show_bug.cgi?id=11763.\n-#define ASAN_MEMCPY_IMPL(ctx, to, from, size)                           \\\n-  do {                                                                  \\\n-    if (UNLIKELY(!asan_inited)) return internal_memcpy(to, from, size); \\\n-    if (asan_init_is_running) {                                         \\\n-      return REAL(memcpy)(to, from, size);                              \\\n-    }                                                                   \\\n-    ENSURE_ASAN_INITED();                                               \\\n-    if (flags()->replace_intrin) {                                      \\\n-      if (to != from) {                                                 \\\n-        CHECK_RANGES_OVERLAP(\"memcpy\", to, size, from, size);           \\\n-      }                                                                 \\\n-      ASAN_READ_RANGE(ctx, from, size);                                 \\\n-      ASAN_WRITE_RANGE(ctx, to, size);                                  \\\n-    }                                                                   \\\n-    return REAL(memcpy)(to, from, size);                                \\\n+#define ASAN_MEMCPY_IMPL(ctx, to, from, size)                 \\\n+  do {                                                        \\\n+    if (LIKELY(replace_intrin_cached)) {                      \\\n+      if (LIKELY(to != from)) {                               \\\n+        CHECK_RANGES_OVERLAP(\"memcpy\", to, size, from, size); \\\n+      }                                                       \\\n+      ASAN_READ_RANGE(ctx, from, size);                       \\\n+      ASAN_WRITE_RANGE(ctx, to, size);                        \\\n+    } else if (UNLIKELY(!asan_inited)) {                      \\\n+      return internal_memcpy(to, from, size);                 \\\n+    }                                                         \\\n+    return REAL(memcpy)(to, from, size);                      \\\n   } while (0)\n \n // memset is called inside Printf.\n-#define ASAN_MEMSET_IMPL(ctx, block, c, size)                           \\\n-  do {                                                                  \\\n-    if (UNLIKELY(!asan_inited)) return internal_memset(block, c, size); \\\n-    if (asan_init_is_running) {                                         \\\n-      return REAL(memset)(block, c, size);                              \\\n-    }                                                                   \\\n-    ENSURE_ASAN_INITED();                                               \\\n-    if (flags()->replace_intrin) {                                      \\\n-      ASAN_WRITE_RANGE(ctx, block, size);                               \\\n-    }                                                                   \\\n-    return REAL(memset)(block, c, size);                                \\\n+#define ASAN_MEMSET_IMPL(ctx, block, c, size) \\\n+  do {                                        \\\n+    if (LIKELY(replace_intrin_cached)) {      \\\n+      ASAN_WRITE_RANGE(ctx, block, size);     \\\n+    } else if (UNLIKELY(!asan_inited)) {      \\\n+      return internal_memset(block, c, size); \\\n+    }                                         \\\n+    return REAL(memset)(block, c, size);      \\\n   } while (0)\n \n-#define ASAN_MEMMOVE_IMPL(ctx, to, from, size)                           \\\n-  do {                                                                   \\\n-    if (UNLIKELY(!asan_inited)) return internal_memmove(to, from, size); \\\n-    ENSURE_ASAN_INITED();                                                \\\n-    if (flags()->replace_intrin) {                                       \\\n-      ASAN_READ_RANGE(ctx, from, size);                                  \\\n-      ASAN_WRITE_RANGE(ctx, to, size);                                   \\\n-    }                                                                    \\\n-    return internal_memmove(to, from, size);                             \\\n+#define ASAN_MEMMOVE_IMPL(ctx, to, from, size) \\\n+  do {                                         \\\n+    if (LIKELY(replace_intrin_cached)) {       \\\n+      ASAN_READ_RANGE(ctx, from, size);        \\\n+      ASAN_WRITE_RANGE(ctx, to, size);         \\\n+    }                                          \\\n+    return internal_memmove(to, from, size);   \\\n   } while (0)\n \n #define ASAN_READ_RANGE(ctx, offset, size) \\\n@@ -136,7 +132,7 @@ static inline bool RangesOverlap(const char *offset1, uptr length1,\n   do {                                                                     \\\n     const char *offset1 = (const char *)_offset1;                          \\\n     const char *offset2 = (const char *)_offset2;                          \\\n-    if (RangesOverlap(offset1, length1, offset2, length2)) {               \\\n+    if (UNLIKELY(RangesOverlap(offset1, length1, offset2, length2))) {     \\\n       GET_STACK_TRACE_FATAL_HERE;                                          \\\n       bool suppressed = IsInterceptorSuppressed(name);                     \\\n       if (!suppressed && HaveStackTraceBasedSuppressions()) {              \\"}, {"sha": "ec29adc7b132ae5381cc71cf1198fa507c9016c6", "filename": "libsanitizer/asan/asan_interceptors_vfork.S", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -6,6 +6,7 @@\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_aarch64.inc.S\"\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_arm.inc.S\"\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_i386.inc.S\"\n+#include \"sanitizer_common/sanitizer_common_interceptors_vfork_loongarch64.inc.S\"\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_riscv64.inc.S\"\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_x86_64.inc.S\"\n #endif"}, {"sha": "b0802a89ddbde5a0a307755805e956e1efd57211", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -53,8 +53,9 @@ extern \"C\" {\n     const char *module_name; // Module name as a C string. This pointer is a\n                              // unique identifier of a module.\n     uptr has_dynamic_init;   // Non-zero if the global has dynamic initializer.\n-    __asan_global_source_location *location;  // Source location of a global,\n-                                              // or NULL if it is unknown.\n+    uptr windows_padding;    // TODO: Figure out how to remove this padding\n+                             // that's simply here to make the MSVC incremental\n+                             // linker happy...\n     uptr odr_indicator;      // The address of the ODR indicator symbol.\n   };\n "}, {"sha": "959fdec26042c873c54397b75be276ecb5e62674", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -106,6 +106,7 @@ void AsanApplyToGlobals(globals_op_fptr op, const void *needle);\n void AsanOnDeadlySignal(int, void *siginfo, void *context);\n \n void ReadContextStack(void *context, uptr *stack, uptr *ssize);\n+void ResetContextStack(void *context);\n void StopInitOrderChecking();\n \n // Wrapper for TLS/TSD.\n@@ -132,6 +133,7 @@ void InstallAtExitCheckLeaks();\n extern int asan_inited;\n // Used to avoid infinite recursion in __asan_init().\n extern bool asan_init_is_running;\n+extern bool replace_intrin_cached;\n extern void (*death_callback)(void);\n // These magic values are written to shadow for better error\n // reporting."}, {"sha": "89450fc120a0411e5e799de79ac7105ee71ef74a", "filename": "libsanitizer/asan/asan_linux.cpp", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -214,11 +214,19 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   *stack = (uptr)ucp->uc_stack.ss_sp;\n   *ssize = ucp->uc_stack.ss_size;\n }\n-#else\n+\n+void ResetContextStack(void *context) {\n+  ucontext_t *ucp = (ucontext_t *)context;\n+  ucp->uc_stack.ss_sp = nullptr;\n+  ucp->uc_stack.ss_size = 0;\n+}\n+#  else\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n-#endif\n+\n+void ResetContextStack(void *context) { UNIMPLEMENTED(); }\n+#  endif\n \n void *AsanDlSymNext(const char *sym) {\n   return dlsym(RTLD_NEXT, sym);"}, {"sha": "a2d5c31a3f7740f3d3398c06968f95a49ffc0a6a", "filename": "libsanitizer/asan/asan_mac.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n@@ -99,6 +99,8 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n+void ResetContextStack(void *context) { UNIMPLEMENTED(); }\n+\n // Support for the following functions from libdispatch on Mac OS:\n //   dispatch_async_f()\n //   dispatch_async()\n@@ -296,4 +298,4 @@ INTERCEPTOR(void, dispatch_source_set_event_handler,\n }\n #endif\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "924d1f12640a7a9fd46ce134f2d5e97a219abf6e", "filename": "libsanitizer/asan/asan_malloc_mac.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_malloc_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_malloc_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"asan_interceptors.h\"\n #include \"asan_report.h\""}, {"sha": "aeadb9d94ebd79226c3c8c84bd6ad07377b6e7b1", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -114,6 +114,13 @@\n // || `[0x0080000000000, 0x008ffffffffff]` || LowShadow  ||\n // || `[0x0000000000000, 0x007ffffffffff]` || LowMem     ||\n //\n+// Default Linux/LoongArch64 (47-bit VMA) mapping:\n+// || `[0x500000000000, 0x7fffffffffff]` || HighMem    ||\n+// || `[0x4a0000000000, 0x4fffffffffff]` || HighShadow ||\n+// || `[0x480000000000, 0x49ffffffffff]` || ShadowGap  ||\n+// || `[0x400000000000, 0x47ffffffffff]` || LowShadow  ||\n+// || `[0x000000000000, 0x3fffffffffff]` || LowMem     ||\n+//\n // Shadow mapping on FreeBSD/x86-64 with SHADOW_OFFSET == 0x400000000000:\n // || `[0x500000000000, 0x7fffffffffff]` || HighMem    ||\n // || `[0x4a0000000000, 0x4fffffffffff]` || HighShadow ||\n@@ -174,26 +181,30 @@\n #else\n #  if SANITIZER_IOS\n #    define ASAN_SHADOW_OFFSET_DYNAMIC\n-#  elif SANITIZER_MAC && defined(__aarch64__)\n+#  elif SANITIZER_APPLE && defined(__aarch64__)\n #    define ASAN_SHADOW_OFFSET_DYNAMIC\n+#  elif SANITIZER_FREEBSD && defined(__aarch64__)\n+#    define ASAN_SHADOW_OFFSET_CONST 0x0000800000000000\n #  elif SANITIZER_RISCV64\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000000d55550000\n #  elif defined(__aarch64__)\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000001000000000\n #  elif defined(__powerpc64__)\n-#    define ASAN_SHADOW_OFFSET_CONST 0x0000020000000000\n+#    define ASAN_SHADOW_OFFSET_CONST 0x0000100000000000\n #  elif defined(__s390x__)\n #    define ASAN_SHADOW_OFFSET_CONST 0x0010000000000000\n #  elif SANITIZER_FREEBSD\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000400000000000\n #  elif SANITIZER_NETBSD\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000400000000000\n-#  elif SANITIZER_MAC\n+#  elif SANITIZER_APPLE\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000100000000000\n #  elif defined(__mips64)\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000002000000000\n #  elif defined(__sparc__)\n #    define ASAN_SHADOW_OFFSET_CONST 0x0000080000000000\n+#  elif SANITIZER_LOONGARCH64\n+#    define ASAN_SHADOW_OFFSET_CONST 0x0000400000000000\n #  elif SANITIZER_WINDOWS64\n #    define ASAN_SHADOW_OFFSET_DYNAMIC\n #  else"}, {"sha": "17280129c758bc5e9fca4aa693e7f49e299ba1ce", "filename": "libsanitizer/asan/asan_new_delete.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -89,7 +89,7 @@ enum class align_val_t: size_t {};\n // delete.\n // To make sure that C++ allocation/deallocation operators are overridden on\n // OS X we need to intercept them using their mangled names.\n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n CXX_OPERATOR_ATTRIBUTE\n void *operator new(size_t size)\n { OPERATOR_NEW_BODY(FROM_NEW, false /*nothrow*/); }\n@@ -115,7 +115,7 @@ CXX_OPERATOR_ATTRIBUTE\n void *operator new[](size_t size, std::align_val_t align, std::nothrow_t const&)\n { OPERATOR_NEW_BODY_ALIGN(FROM_NEW_BR, true /*nothrow*/); }\n \n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n INTERCEPTOR(void *, _Znwm, size_t size) {\n   OPERATOR_NEW_BODY(FROM_NEW, false /*nothrow*/);\n }\n@@ -128,7 +128,7 @@ INTERCEPTOR(void *, _ZnwmRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n   OPERATOR_NEW_BODY(FROM_NEW_BR, true /*nothrow*/);\n }\n-#endif  // !SANITIZER_MAC\n+#endif  // !SANITIZER_APPLE\n \n #define OPERATOR_DELETE_BODY(type) \\\n   GET_STACK_TRACE_FREE;            \\\n@@ -146,7 +146,7 @@ INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n   GET_STACK_TRACE_FREE;                       \\\n   asan_delete(ptr, size, static_cast<uptr>(align), &stack, type);\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n CXX_OPERATOR_ATTRIBUTE\n void operator delete(void *ptr) NOEXCEPT\n { OPERATOR_DELETE_BODY(FROM_NEW); }\n@@ -184,7 +184,7 @@ CXX_OPERATOR_ATTRIBUTE\n void operator delete[](void *ptr, size_t size, std::align_val_t align) NOEXCEPT\n { OPERATOR_DELETE_BODY_SIZE_ALIGN(FROM_NEW_BR); }\n \n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n INTERCEPTOR(void, _ZdlPv, void *ptr)\n { OPERATOR_DELETE_BODY(FROM_NEW); }\n INTERCEPTOR(void, _ZdaPv, void *ptr)\n@@ -193,4 +193,4 @@ INTERCEPTOR(void, _ZdlPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n { OPERATOR_DELETE_BODY(FROM_NEW); }\n INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n { OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n-#endif  // !SANITIZER_MAC\n+#endif  // !SANITIZER_APPLE"}, {"sha": "88f66de5669afa974241673436609b554a97c258", "filename": "libsanitizer/asan/asan_rtl.cpp", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -51,10 +51,9 @@ static void AsanDie() {\n   }\n   if (common_flags()->print_module_map >= 1)\n     DumpProcessMap();\n-  if (flags()->sleep_before_dying) {\n-    Report(\"Sleeping for %d second(s)\\n\", flags()->sleep_before_dying);\n-    SleepForSeconds(flags()->sleep_before_dying);\n-  }\n+\n+  WaitForDebugger(flags()->sleep_before_dying, \"before dying\");\n+\n   if (flags()->unmap_shadow_on_exit) {\n     if (kMidMemBeg) {\n       UnmapOrDie((void*)kLowShadowBeg, kMidMemBeg - kLowShadowBeg);\n@@ -74,6 +73,7 @@ static void CheckUnwind() {\n // -------------------------- Globals --------------------- {{{1\n int asan_inited;\n bool asan_init_is_running;\n+bool replace_intrin_cached;\n \n #if !ASAN_FIXED_MAPPING\n uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;\n@@ -386,6 +386,8 @@ static void AsanInitInternal() {\n   // initialization steps look at flags().\n   InitializeFlags();\n \n+  WaitForDebugger(flags()->sleep_before_init, \"before init\");\n+\n   // Stop performing init at this point if we are being loaded via\n   // dlopen() and the platform supports it.\n   if (SANITIZER_SUPPORTS_INIT_FOR_DLOPEN && UNLIKELY(HandleDlopenInit())) {\n@@ -420,9 +422,6 @@ static void AsanInitInternal() {\n \n   __sanitizer::InitializePlatformEarly();\n \n-  // Re-exec ourselves if we need to set additional env or command line args.\n-  MaybeReexec();\n-\n   // Setup internal allocator callback.\n   SetLowLevelAllocateMinAlignment(ASAN_SHADOW_GRANULARITY);\n   SetLowLevelAllocateCallback(OnLowLevelAllocate);\n@@ -453,6 +452,7 @@ static void AsanInitInternal() {\n \n   // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n   // should be set to 1 prior to initializing the threads.\n+  replace_intrin_cached = flags()->replace_intrin;\n   asan_inited = 1;\n   asan_init_is_running = false;\n \n@@ -497,10 +497,7 @@ static void AsanInitInternal() {\n \n   VReport(1, \"AddressSanitizer Init done\\n\");\n \n-  if (flags()->sleep_after_init) {\n-    Report(\"Sleeping for %d second(s)\\n\", flags()->sleep_after_init);\n-    SleepForSeconds(flags()->sleep_after_init);\n-  }\n+  WaitForDebugger(flags()->sleep_after_init, \"after init\");\n }\n \n // Initialize as requested from some part of ASan runtime library (interceptors,"}, {"sha": "f11df0613d1f4a9e28622819c6790276eb2ebb6b", "filename": "libsanitizer/asan/asan_win.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fasan%2Fasan_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -267,6 +267,8 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n+void ResetContextStack(void *context) { UNIMPLEMENTED(); }\n+\n void AsanOnDeadlySignal(int, void *siginfo, void *context) { UNIMPLEMENTED(); }\n \n bool PlatformUnpoisonStacks() { return false; }"}, {"sha": "bb946c2ffe03a395669ed41045e098758c95e6a2", "filename": "libsanitizer/hwasan/hwasan.cpp", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -218,8 +218,8 @@ void HandleTagMismatch(AccessInfo ai, uptr pc, uptr frame, void *uc,\n                     registers_frame);\n }\n \n-void HwasanTagMismatch(uptr addr, uptr access_info, uptr *registers_frame,\n-                       size_t outsize) {\n+void HwasanTagMismatch(uptr addr, uptr pc, uptr frame, uptr access_info,\n+                       uptr *registers_frame, size_t outsize) {\n   __hwasan::AccessInfo ai;\n   ai.is_store = access_info & 0x10;\n   ai.is_load = !ai.is_store;\n@@ -230,9 +230,7 @@ void HwasanTagMismatch(uptr addr, uptr access_info, uptr *registers_frame,\n   else\n     ai.size = 1 << (access_info & 0xf);\n \n-  HandleTagMismatch(ai, (uptr)__builtin_return_address(0),\n-                    (uptr)__builtin_frame_address(0), nullptr, registers_frame);\n-  __builtin_unreachable();\n+  HandleTagMismatch(ai, pc, frame, nullptr, registers_frame);\n }\n \n Thread *GetCurrentThread() {\n@@ -576,6 +574,12 @@ u8 __hwasan_generate_tag() {\n   return t->GenerateRandomTag();\n }\n \n+void __hwasan_add_frame_record(u64 frame_record_info) {\n+  Thread *t = GetCurrentThread();\n+  if (t)\n+    t->stack_allocations()->push(frame_record_info);\n+}\n+\n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n@@ -594,7 +598,9 @@ void __sanitizer_print_stack_trace() {\n // rest of the mismatch handling code (C++).\n void __hwasan_tag_mismatch4(uptr addr, uptr access_info, uptr *registers_frame,\n                             size_t outsize) {\n-  __hwasan::HwasanTagMismatch(addr, access_info, registers_frame, outsize);\n+  __hwasan::HwasanTagMismatch(addr, (uptr)__builtin_return_address(0),\n+                              (uptr)__builtin_frame_address(0), access_info,\n+                              registers_frame, outsize);\n }\n \n } // extern \"C\""}, {"sha": "ef4055a50ef217d99e5b64f3d79e516c483b0c68", "filename": "libsanitizer/hwasan/hwasan.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -167,8 +167,8 @@ void HandleTagMismatch(AccessInfo ai, uptr pc, uptr frame, void *uc,\n \n // This dispatches to HandleTagMismatch but sets up the AccessInfo, program\n // counter, and frame pointer.\n-void HwasanTagMismatch(uptr addr, uptr access_info, uptr *registers_frame,\n-                       size_t outsize);\n+void HwasanTagMismatch(uptr addr, uptr pc, uptr frame, uptr access_info,\n+                       uptr *registers_frame, size_t outsize);\n \n }  // namespace __hwasan\n \n@@ -181,6 +181,13 @@ typedef unsigned long __hw_sigset_t;\n constexpr size_t kHwRegisterBufSize = 22;\n #  elif defined(__x86_64__)\n constexpr size_t kHwRegisterBufSize = 8;\n+#  elif SANITIZER_RISCV64\n+// saving PC, 12 int regs, sp, 12 fp regs\n+#    ifndef __riscv_float_abi_soft\n+constexpr size_t kHwRegisterBufSize = 1 + 12 + 1 + 12;\n+#    else\n+constexpr size_t kHwRegisterBufSize = 1 + 12 + 1;\n+#    endif\n #  endif\n typedef unsigned long long __hw_register_buf[kHwRegisterBufSize];\n struct __hw_jmp_buf_struct {"}, {"sha": "bae53b565592a2ed1ca1d4aa6184bd8dfdb39c93", "filename": "libsanitizer/hwasan/hwasan_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_allocator.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -24,8 +24,8 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_ring_buffer.h\"\n \n-#if !defined(__aarch64__) && !defined(__x86_64__)\n-#error Unsupported platform\n+#if !defined(__aarch64__) && !defined(__x86_64__) && !(SANITIZER_RISCV64)\n+#  error Unsupported platform\n #endif\n \n namespace __hwasan {"}, {"sha": "b0b37d7a2e2b9193e6bf9f752cc8ab660e998812", "filename": "libsanitizer/hwasan/hwasan_checks.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_checks.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -36,6 +36,15 @@ __attribute__((always_inline)) static void SigTrap(uptr p) {\n       \"int3\\n\"\n       \"nopl %c0(%%rax)\\n\" ::\"n\"(0x40 + X),\n       \"D\"(p));\n+#elif SANITIZER_RISCV64\n+  // Put pointer into x10\n+  // addiw contains immediate of 0x40 + X, where 0x40 is magic number and X\n+  // encodes access size\n+  register uptr x10 asm(\"x10\") = p;\n+  asm volatile(\n+      \"ebreak\\n\"\n+      \"addiw x0, x0, %1\\n\" ::\"r\"(x10),\n+      \"I\"(0x40 + X));\n #else\n   // FIXME: not always sigill.\n   __builtin_trap();\n@@ -56,6 +65,14 @@ __attribute__((always_inline)) static void SigTrap(uptr p, uptr size) {\n       \"int3\\n\"\n       \"nopl %c0(%%rax)\\n\" ::\"n\"(0x40 + X),\n       \"D\"(p), \"S\"(size));\n+#elif SANITIZER_RISCV64\n+  // Put access size into x11\n+  register uptr x10 asm(\"x10\") = p;\n+  register uptr x11 asm(\"x11\") = size;\n+  asm volatile(\n+      \"ebreak\\n\"\n+      \"addiw x0, x0, %2\\n\" ::\"r\"(x10),\n+      \"r\"(x11), \"I\"(0x40 + X));\n #else\n   __builtin_trap();\n #endif\n@@ -71,7 +88,7 @@ __attribute__((always_inline, nodebug)) static bool PossiblyShortTagMatches(\n     return false;\n   if ((ptr & (kShadowAlignment - 1)) + sz > mem_tag)\n     return false;\n-#ifndef __aarch64__\n+#if !defined(__aarch64__) && !(SANITIZER_RISCV64)\n   ptr = UntagAddr(ptr);\n #endif\n   return *(u8 *)(ptr | (kShadowAlignment - 1)) == ptr_tag;"}, {"sha": "c9968a5e36037b1320f4c2ae4cc83cf56a3ba9fc", "filename": "libsanitizer/hwasan/hwasan_exceptions.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_exceptions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_exceptions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_exceptions.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -56,6 +56,8 @@ __hwasan_personality_wrapper(int version, _Unwind_Action actions,\n     uptr fp = get_gr(context, 6); // rbp\n #elif defined(__aarch64__)\n     uptr fp = get_gr(context, 29); // x29\n+#elif SANITIZER_RISCV64\n+    uptr fp = get_gr(context, 8);  // x8\n #else\n #error Unsupported architecture\n #endif"}, {"sha": "967c796c339d0deb593d14a15ebd5ad5b949177f", "filename": "libsanitizer/hwasan/hwasan_fuchsia.cpp", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -15,6 +15,9 @@\n #include \"sanitizer_common/sanitizer_fuchsia.h\"\n #if SANITIZER_FUCHSIA\n \n+#include <zircon/features.h>\n+#include <zircon/syscalls.h>\n+\n #include \"hwasan.h\"\n #include \"hwasan_interface_internal.h\"\n #include \"hwasan_report.h\"\n@@ -182,9 +185,20 @@ void InstallAtExitHandler() {}\n \n void HwasanInstallAtForkHandler() {}\n \n-// TODO(fxbug.dev/81499): Once we finalize the tagged pointer ABI in zircon, we should come back\n-// here and implement the appropriate check that TBI is enabled.\n-void InitializeOsSupport() {}\n+void InitializeOsSupport() {\n+#ifdef __aarch64__\n+  uint32_t features = 0;\n+  CHECK_EQ(zx_system_get_features(ZX_FEATURE_KIND_ADDRESS_TAGGING, &features),\n+           ZX_OK);\n+  if (!(features & ZX_ARM64_FEATURE_ADDRESS_TAGGING_TBI) &&\n+      flags()->fail_without_syscall_abi) {\n+    Printf(\n+        \"FATAL: HWAddressSanitizer requires \"\n+        \"ZX_ARM64_FEATURE_ADDRESS_TAGGING_TBI.\\n\");\n+    Die();\n+  }\n+#endif\n+}\n \n }  // namespace __hwasan\n "}, {"sha": "c67927dc9f60b012b85cbb69c3f5b8838940e0cc", "filename": "libsanitizer/hwasan/hwasan_interceptors.cpp", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -75,6 +75,8 @@ InternalLongjmp(__hw_register_buf env, int retval) {\n   constexpr size_t kSpIndex = 13;\n #    elif defined(__x86_64__)\n   constexpr size_t kSpIndex = 6;\n+#    elif SANITIZER_RISCV64\n+  constexpr size_t kSpIndex = 13;\n #    endif\n \n   // Clear all memory tags on the stack between here and where we're going.\n@@ -131,6 +133,49 @@ InternalLongjmp(__hw_register_buf env, int retval) {\n       \"cmovnz %1,%%rax;\"\n       \"jmp *%%rdx;\" ::\"r\"(env_address),\n       \"r\"(retval_tmp));\n+#    elif SANITIZER_RISCV64\n+  register long int retval_tmp asm(\"x11\") = retval;\n+  register void *env_address asm(\"x10\") = &env[0];\n+  asm volatile(\n+      \"ld     ra,   0<<3(%0);\"\n+      \"ld     s0,   1<<3(%0);\"\n+      \"ld     s1,   2<<3(%0);\"\n+      \"ld     s2,   3<<3(%0);\"\n+      \"ld     s3,   4<<3(%0);\"\n+      \"ld     s4,   5<<3(%0);\"\n+      \"ld     s5,   6<<3(%0);\"\n+      \"ld     s6,   7<<3(%0);\"\n+      \"ld     s7,   8<<3(%0);\"\n+      \"ld     s8,   9<<3(%0);\"\n+      \"ld     s9,   10<<3(%0);\"\n+      \"ld     s10,  11<<3(%0);\"\n+      \"ld     s11,  12<<3(%0);\"\n+#      if __riscv_float_abi_double\n+      \"fld    fs0,  14<<3(%0);\"\n+      \"fld    fs1,  15<<3(%0);\"\n+      \"fld    fs2,  16<<3(%0);\"\n+      \"fld    fs3,  17<<3(%0);\"\n+      \"fld    fs4,  18<<3(%0);\"\n+      \"fld    fs5,  19<<3(%0);\"\n+      \"fld    fs6,  20<<3(%0);\"\n+      \"fld    fs7,  21<<3(%0);\"\n+      \"fld    fs8,  22<<3(%0);\"\n+      \"fld    fs9,  23<<3(%0);\"\n+      \"fld    fs10, 24<<3(%0);\"\n+      \"fld    fs11, 25<<3(%0);\"\n+#      elif __riscv_float_abi_soft\n+#      else\n+#        error \"Unsupported case\"\n+#      endif\n+      \"ld     a4, 13<<3(%0);\"\n+      \"mv     sp, a4;\"\n+      // Return the value requested to return through arguments.\n+      // This should be in x11 given what we requested above.\n+      \"seqz   a0, %1;\"\n+      \"add    a0, a0, %1;\"\n+      \"ret;\"\n+      : \"+r\"(env_address)\n+      : \"r\"(retval_tmp));\n #    endif\n }\n "}, {"sha": "d1ecbb592a2195b1d49991e8a34579db0edd23c2", "filename": "libsanitizer/hwasan/hwasan_interface_internal.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_interface_internal.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -168,6 +168,14 @@ void __hwasan_thread_exit();\n SANITIZER_INTERFACE_ATTRIBUTE\n void __hwasan_print_memory_usage();\n \n+// The compiler will generate this when\n+// `-hwasan-record-stack-history-with-calls` is added as a flag, which will add\n+// frame record information to the stack ring buffer. This is an alternative to\n+// the compiler emitting instructions in the prologue for doing the same thing\n+// by accessing the ring buffer directly.\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __hwasan_add_frame_record(u64 frame_record_info);\n+\n SANITIZER_INTERFACE_ATTRIBUTE\n void *__hwasan_memcpy(void *dst, const void *src, uptr size);\n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "88ccfde007d31aef2f285abd55ba3bd5d9a0ecd8", "filename": "libsanitizer/hwasan/hwasan_linux.cpp", "status": "modified", "additions": 141, "deletions": 42, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -110,15 +110,84 @@ static void InitializeShadowBaseAddress(uptr shadow_size_bytes) {\n       FindDynamicShadowStart(shadow_size_bytes);\n }\n \n-void InitializeOsSupport() {\n+static void MaybeDieIfNoTaggingAbi(const char *message) {\n+  if (!flags()->fail_without_syscall_abi)\n+    return;\n+  Printf(\"FATAL: %s\\n\", message);\n+  Die();\n+}\n+\n #  define PR_SET_TAGGED_ADDR_CTRL 55\n #  define PR_GET_TAGGED_ADDR_CTRL 56\n #  define PR_TAGGED_ADDR_ENABLE (1UL << 0)\n+#  define ARCH_GET_UNTAG_MASK 0x4001\n+#  define ARCH_ENABLE_TAGGED_ADDR 0x4002\n+#  define ARCH_GET_MAX_TAG_BITS 0x4003\n+\n+static bool CanUseTaggingAbi() {\n+#  if defined(__x86_64__)\n+  unsigned long num_bits = 0;\n+  // Check for x86 LAM support. This API is based on a currently unsubmitted\n+  // patch to the Linux kernel (as of August 2022) and is thus subject to\n+  // change. The patch is here:\n+  // https://lore.kernel.org/all/20220815041803.17954-1-kirill.shutemov@linux.intel.com/\n+  //\n+  // arch_prctl(ARCH_GET_MAX_TAG_BITS, &bits) returns the maximum number of tag\n+  // bits the user can request, or zero if LAM is not supported by the hardware.\n+  if (internal_iserror(internal_arch_prctl(ARCH_GET_MAX_TAG_BITS,\n+                                           reinterpret_cast<uptr>(&num_bits))))\n+    return false;\n+  // The platform must provide enough bits for HWASan tags.\n+  if (num_bits < kTagBits)\n+    return false;\n+  return true;\n+#  else\n+  // Check for ARM TBI support.\n+  return !internal_iserror(internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0));\n+#  endif // __x86_64__\n+}\n+\n+static bool EnableTaggingAbi() {\n+#  if defined(__x86_64__)\n+  // Enable x86 LAM tagging for the process.\n+  //\n+  // arch_prctl(ARCH_ENABLE_TAGGED_ADDR, bits) enables tagging if the number of\n+  // tag bits requested by the user does not exceed that provided by the system.\n+  // arch_prctl(ARCH_GET_UNTAG_MASK, &mask) returns the mask of significant\n+  // address bits. It is ~0ULL if either LAM is disabled for the process or LAM\n+  // is not supported by the hardware.\n+  if (internal_iserror(internal_arch_prctl(ARCH_ENABLE_TAGGED_ADDR, kTagBits)))\n+    return false;\n+  unsigned long mask = 0;\n+  // Make sure the tag bits are where we expect them to be.\n+  if (internal_iserror(internal_arch_prctl(ARCH_GET_UNTAG_MASK,\n+                                           reinterpret_cast<uptr>(&mask))))\n+    return false;\n+  // @mask has ones for non-tag bits, whereas @kAddressTagMask has ones for tag\n+  // bits. Therefore these masks must not overlap.\n+  if (mask & kAddressTagMask)\n+    return false;\n+  return true;\n+#  else\n+  // Enable ARM TBI tagging for the process. If for some reason tagging is not\n+  // supported, prctl(PR_SET_TAGGED_ADDR_CTRL, PR_TAGGED_ADDR_ENABLE) returns\n+  // -EINVAL.\n+  if (internal_iserror(internal_prctl(PR_SET_TAGGED_ADDR_CTRL,\n+                                      PR_TAGGED_ADDR_ENABLE, 0, 0, 0)))\n+    return false;\n+  // Ensure that TBI is enabled.\n+  if (internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0) !=\n+      PR_TAGGED_ADDR_ENABLE)\n+    return false;\n+  return true;\n+#  endif // __x86_64__\n+}\n+\n+void InitializeOsSupport() {\n   // Check we're running on a kernel that can use the tagged address ABI.\n-  int local_errno = 0;\n-  if (internal_iserror(internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0),\n-                       &local_errno) &&\n-      local_errno == EINVAL) {\n+  bool has_abi = CanUseTaggingAbi();\n+\n+  if (!has_abi) {\n #  if SANITIZER_ANDROID || defined(HWASAN_ALIASING_MODE)\n     // Some older Android kernels have the tagged pointer ABI on\n     // unconditionally, and hence don't have the tagged-addr prctl while still\n@@ -127,46 +196,22 @@ void InitializeOsSupport() {\n     // case.\n     return;\n #  else\n-    if (flags()->fail_without_syscall_abi) {\n-      Printf(\n-          \"FATAL: \"\n-          \"HWAddressSanitizer requires a kernel with tagged address ABI.\\n\");\n-      Die();\n-    }\n+    MaybeDieIfNoTaggingAbi(\n+        \"HWAddressSanitizer requires a kernel with tagged address ABI.\");\n #  endif\n   }\n \n-  // Turn on the tagged address ABI.\n-  if ((internal_iserror(internal_prctl(PR_SET_TAGGED_ADDR_CTRL,\n-                                       PR_TAGGED_ADDR_ENABLE, 0, 0, 0)) ||\n-       !internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0))) {\n-#  if defined(__x86_64__) && !defined(HWASAN_ALIASING_MODE)\n-    // Try the new prctl API for Intel LAM.  The API is based on a currently\n-    // unsubmitted patch to the Linux kernel (as of May 2021) and is thus\n-    // subject to change.  Patch is here:\n-    // https://lore.kernel.org/linux-mm/20210205151631.43511-12-kirill.shutemov@linux.intel.com/\n-    int tag_bits = kTagBits;\n-    int tag_shift = kAddressTagShift;\n-    if (!internal_iserror(\n-            internal_prctl(PR_SET_TAGGED_ADDR_CTRL, PR_TAGGED_ADDR_ENABLE,\n-                           reinterpret_cast<unsigned long>(&tag_bits),\n-                           reinterpret_cast<unsigned long>(&tag_shift), 0))) {\n-      CHECK_EQ(tag_bits, kTagBits);\n-      CHECK_EQ(tag_shift, kAddressTagShift);\n-      return;\n-    }\n-#  endif  // defined(__x86_64__) && !defined(HWASAN_ALIASING_MODE)\n-    if (flags()->fail_without_syscall_abi) {\n-      Printf(\n-          \"FATAL: HWAddressSanitizer failed to enable tagged address syscall \"\n-          \"ABI.\\nSuggest check `sysctl abi.tagged_addr_disabled` \"\n-          \"configuration.\\n\");\n-      Die();\n-    }\n-  }\n-#  undef PR_SET_TAGGED_ADDR_CTRL\n-#  undef PR_GET_TAGGED_ADDR_CTRL\n-#  undef PR_TAGGED_ADDR_ENABLE\n+  if (EnableTaggingAbi())\n+    return;\n+\n+#  if SANITIZER_ANDROID\n+  MaybeDieIfNoTaggingAbi(\n+      \"HWAddressSanitizer failed to enable tagged address syscall ABI.\\n\"\n+      \"Check the `sysctl abi.tagged_addr_disabled` configuration.\");\n+#  else\n+  MaybeDieIfNoTaggingAbi(\n+      \"HWAddressSanitizer failed to enable tagged address syscall ABI.\\n\");\n+#  endif\n }\n \n bool InitShadow() {\n@@ -358,6 +403,47 @@ static AccessInfo GetAccessInfo(siginfo_t *info, ucontext_t *uc) {\n   const uptr size =\n       size_log == 0xf ? uc->uc_mcontext.gregs[REG_RSI] : 1U << size_log;\n \n+#  elif SANITIZER_RISCV64\n+  // Access type is encoded in the instruction following EBREAK as\n+  // ADDI x0, x0, [0x40 + 0xXY]. For Y == 0xF, access size is stored in\n+  // X11 register. Access address is always in X10 register.\n+  uptr pc = (uptr)uc->uc_mcontext.__gregs[REG_PC];\n+  uint8_t byte1 = *((u8 *)(pc + 0));\n+  uint8_t byte2 = *((u8 *)(pc + 1));\n+  uint8_t byte3 = *((u8 *)(pc + 2));\n+  uint8_t byte4 = *((u8 *)(pc + 3));\n+  uint32_t ebreak = (byte1 | (byte2 << 8) | (byte3 << 16) | (byte4 << 24));\n+  bool isFaultShort = false;\n+  bool isEbreak = (ebreak == 0x100073);\n+  bool isShortEbreak = false;\n+#    if defined(__riscv_compressed)\n+  isFaultShort = ((ebreak & 0x3) != 0x3);\n+  isShortEbreak = ((ebreak & 0xffff) == 0x9002);\n+#    endif\n+  // faulted insn is not ebreak, not our case\n+  if (!(isEbreak || isShortEbreak))\n+    return AccessInfo{};\n+  // advance pc to point after ebreak and reconstruct addi instruction\n+  pc += isFaultShort ? 2 : 4;\n+  byte1 = *((u8 *)(pc + 0));\n+  byte2 = *((u8 *)(pc + 1));\n+  byte3 = *((u8 *)(pc + 2));\n+  byte4 = *((u8 *)(pc + 3));\n+  // reconstruct instruction\n+  uint32_t instr = (byte1 | (byte2 << 8) | (byte3 << 16) | (byte4 << 24));\n+  // check if this is really 32 bit instruction\n+  // code is encoded in top 12 bits, since instruction is supposed to be with\n+  // imm\n+  const unsigned code = (instr >> 20) & 0xffff;\n+  const uptr addr = uc->uc_mcontext.__gregs[10];\n+  const bool is_store = code & 0x10;\n+  const bool recover = code & 0x20;\n+  const unsigned size_log = code & 0xf;\n+  if (size_log > 4 && size_log != 0xf)\n+    return AccessInfo{};  // Not our case\n+  const uptr size =\n+      size_log == 0xf ? uc->uc_mcontext.__gregs[11] : 1U << size_log;\n+\n #  else\n #    error Unsupported architecture\n #  endif\n@@ -376,6 +462,19 @@ static bool HwasanOnSIGTRAP(int signo, siginfo_t *info, ucontext_t *uc) {\n #  if defined(__aarch64__)\n   uc->uc_mcontext.pc += 4;\n #  elif defined(__x86_64__)\n+#  elif SANITIZER_RISCV64\n+  // pc points to EBREAK which is 2 bytes long\n+  uint8_t *exception_source = (uint8_t *)(uc->uc_mcontext.__gregs[REG_PC]);\n+  uint8_t byte1 = (uint8_t)(*(exception_source + 0));\n+  uint8_t byte2 = (uint8_t)(*(exception_source + 1));\n+  uint8_t byte3 = (uint8_t)(*(exception_source + 2));\n+  uint8_t byte4 = (uint8_t)(*(exception_source + 3));\n+  uint32_t faulted = (byte1 | (byte2 << 8) | (byte3 << 16) | (byte4 << 24));\n+  bool isFaultShort = false;\n+#    if defined(__riscv_compressed)\n+  isFaultShort = ((faulted & 0x3) != 0x3);\n+#    endif\n+  uc->uc_mcontext.__gregs[REG_PC] += isFaultShort ? 2 : 4;\n #  else\n #    error Unsupported architecture\n #  endif"}, {"sha": "fe7695891868469394ad63fad12934b3f8f3081e", "filename": "libsanitizer/hwasan/hwasan_report.cpp", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_report.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -746,16 +746,21 @@ void ReportTagMismatch(StackTrace *stack, uptr tagged_addr, uptr access_size,\n }\n \n // See the frame breakdown defined in __hwasan_tag_mismatch (from\n-// hwasan_tag_mismatch_aarch64.S).\n+// hwasan_tag_mismatch_{aarch64,riscv64}.S).\n void ReportRegisters(uptr *frame, uptr pc) {\n   Printf(\"Registers where the failure occurred (pc %p):\\n\", pc);\n \n   // We explicitly print a single line (4 registers/line) each iteration to\n   // reduce the amount of logcat error messages printed. Each Printf() will\n   // result in a new logcat line, irrespective of whether a newline is present,\n   // and so we wish to reduce the number of Printf() calls we have to make.\n+#if defined(__aarch64__)\n   Printf(\"    x0  %016llx  x1  %016llx  x2  %016llx  x3  %016llx\\n\",\n        frame[0], frame[1], frame[2], frame[3]);\n+#elif SANITIZER_RISCV64\n+  Printf(\"    sp  %016llx  x1  %016llx  x2  %016llx  x3  %016llx\\n\",\n+         reinterpret_cast<u8 *>(frame) + 256, frame[1], frame[2], frame[3]);\n+#endif\n   Printf(\"    x4  %016llx  x5  %016llx  x6  %016llx  x7  %016llx\\n\",\n        frame[4], frame[5], frame[6], frame[7]);\n   Printf(\"    x8  %016llx  x9  %016llx  x10 %016llx  x11 %016llx\\n\",\n@@ -770,8 +775,14 @@ void ReportRegisters(uptr *frame, uptr pc) {\n        frame[24], frame[25], frame[26], frame[27]);\n   // hwasan_check* reduces the stack pointer by 256, then __hwasan_tag_mismatch\n   // passes it to this function.\n+#if defined(__aarch64__)\n   Printf(\"    x28 %016llx  x29 %016llx  x30 %016llx   sp %016llx\\n\", frame[28],\n          frame[29], frame[30], reinterpret_cast<u8 *>(frame) + 256);\n+#elif SANITIZER_RISCV64\n+  Printf(\"    x28 %016llx  x29 %016llx  x30 %016llx  x31 %016llx\\n\", frame[28],\n+         frame[29], frame[30], frame[31]);\n+#else\n+#endif\n }\n \n }  // namespace __hwasan"}, {"sha": "f33c4916df130cf70ea0c5607a34ddcef776f518", "filename": "libsanitizer/hwasan/hwasan_setjmp_riscv64.S", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_setjmp_riscv64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_setjmp_riscv64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_setjmp_riscv64.S?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -0,0 +1,97 @@\n+//===-- hwasan_setjmp_riscv64.S -------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of HWAddressSanitizer.\n+// setjmp interceptor for risc-v.\n+// HWAddressSanitizer runtime.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+#include \"builtins/assembly.h\"\n+\n+#if HWASAN_WITH_INTERCEPTORS && defined(__riscv) && (__riscv_xlen == 64)\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n+// We want to save the context of the calling function.\n+// That requires\n+// 1) No modification of the link register by this function.\n+// 2) No modification of the stack pointer by this function.\n+// 3) (no modification of any other saved register, but that's not really going\n+// to occur, and hence isn't as much of a worry).\n+//\n+// There's essentially no way to ensure that the compiler will not modify the\n+// stack pointer when compiling a C function.\n+// Hence we have to write this function in assembly.\n+\n+.section .text\n+.file \"hwasan_setjmp_riscv64.S\"\n+\n+.global __interceptor_setjmp\n+ASM_TYPE_FUNCTION(__interceptor_setjmp)\n+__interceptor_setjmp:\n+  CFI_STARTPROC\n+  addi x11, x0, 0\n+  j    __interceptor_sigsetjmp\n+  CFI_ENDPROC\n+ASM_SIZE(__interceptor_setjmp)\n+\n+.global __interceptor_sigsetjmp\n+ASM_TYPE_FUNCTION(__interceptor_sigsetjmp)\n+__interceptor_sigsetjmp:\n+  CFI_STARTPROC\n+  sd    ra,   0<<3(x10)\n+  sd    s0,   1<<3(x10)\n+  sd    s1,   2<<3(x10)\n+  sd    s2,   3<<3(x10)\n+  sd    s3,   4<<3(x10)\n+  sd    s4,   5<<3(x10)\n+  sd    s5,   6<<3(x10)\n+  sd    s6,   7<<3(x10)\n+  sd    s7,   8<<3(x10)\n+  sd    s8,   9<<3(x10)\n+  sd    s9,   10<<3(x10)\n+  sd    s10,  11<<3(x10)\n+  sd    s11,  12<<3(x10)\n+  sd    sp,   13<<3(x10)\n+#if __riscv_float_abi_double\n+  fsd   fs0,  14<<3(x10)\n+  fsd   fs1,  15<<3(x10)\n+  fsd   fs2,  16<<3(x10)\n+  fsd   fs3,  17<<3(x10)\n+  fsd   fs4,  18<<3(x10)\n+  fsd   fs5,  19<<3(x10)\n+  fsd   fs6,  20<<3(x10)\n+  fsd   fs7,  21<<3(x10)\n+  fsd   fs8,  22<<3(x10)\n+  fsd   fs9,  23<<3(x10)\n+  fsd   fs10, 24<<3(x10)\n+  fsd   fs11, 25<<3(x10)\n+#elif __riscv_float_abi_soft\n+#else\n+# error \"Unsupported case\"\n+#endif\n+  // We always have the second argument to __sigjmp_save (savemask) set, since\n+  // the _setjmp function above has set it for us as `false`.\n+  // This function is defined in hwasan_interceptors.cc\n+  tail __sigjmp_save\n+  CFI_ENDPROC\n+ASM_SIZE(__interceptor_sigsetjmp)\n+\n+\n+.macro WEAK_ALIAS first second\n+  .weak \\second\n+  .equ \\second\\(), \\first\n+.endm\n+\n+WEAK_ALIAS __interceptor_sigsetjmp, __sigsetjmp\n+\n+WEAK_ALIAS __interceptor_setjmp, _setjmp\n+#endif\n+\n+// We do not need executable stack.\n+NO_EXEC_STACK_DIRECTIVE"}, {"sha": "487a042405b60628fc37673fb0b76c395ffe9b3a", "filename": "libsanitizer/hwasan/hwasan_tag_mismatch_riscv64.S", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_tag_mismatch_riscv64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fhwasan%2Fhwasan_tag_mismatch_riscv64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_tag_mismatch_riscv64.S?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -0,0 +1,132 @@\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+// The content of this file is RISCV64-only:\n+#if defined(__riscv) && (__riscv_xlen == 64)\n+\n+// The responsibility of the HWASan entry point in compiler-rt is to primarily\n+// readjust the stack from the callee and save the current register values to\n+// the stack.\n+// This entry point function should be called from a __hwasan_check_* symbol.\n+// These are generated during a lowering pass in the backend, and are found in\n+// RISCVAsmPrinter::EmitHwasanMemaccessSymbols(). Please look there for\n+// further information.\n+// The __hwasan_check_* caller of this function should have expanded the stack\n+// and saved the previous values of x10(arg0), x11(arg1), x1(ra), and x8(fp).\n+// This function will \"consume\" these saved values and treats it as part of its\n+// own stack frame. In this sense, the __hwasan_check_* callee and this function\n+// \"share\" a stack frame. This allows us to omit having unwinding information\n+// (.cfi_*) present in every __hwasan_check_* function, therefore reducing binary size.\n+// This is particularly important as hwasan_check_* instances are duplicated in every\n+// translation unit where HWASan is enabled.\n+// This function calls HwasanTagMismatch to step back into the C++ code that\n+// completes the stack unwinding and error printing. This function is is not\n+// permitted to return.\n+\n+\n+// |              ...                |\n+// |              ...                |\n+// | Previous stack frames...        |\n+// +=================================+\n+// |              ...                |\n+// |                                 |\n+// | Stack frame space for x12 - x31.|\n+// |                                 |\n+// |              ...                |\n+// +---------------------------------+ <-- [SP + 96]\n+// | Saved x11(arg1), as             |\n+// | __hwasan_check_* clobbers it.   |\n+// +---------------------------------+ <-- [SP + 88]\n+// | Saved x10(arg0), as             |\n+// | __hwasan_check_* clobbers it.   |\n+// +---------------------------------+ <-- [SP + 80]\n+// |                                 |\n+// | Stack frame space for x9.       |\n+// +---------------------------------+ <-- [SP + 72]\n+// |                                 |\n+// | Saved x8(fp), as                |\n+// | __hwasan_check_* clobbers it.   |\n+// +---------------------------------+ <-- [SP + 64]\n+// |              ...                |\n+// |                                 |\n+// | Stack frame space for x2 - x7.  |\n+// |                                 |\n+// |              ...                |\n+// +---------------------------------+ <-- [SP + 16]\n+// | Return address (x1) for caller  |\n+// | of __hwasan_check_*.            |\n+// +---------------------------------+ <-- [SP + 8]\n+// | Reserved place for x0, possibly |\n+// | junk, since we don't save it.   |\n+// +---------------------------------+ <-- [x2 / SP]\n+\n+// This function takes two arguments:\n+//   * x10/a0: The data address.\n+//   * x11/a1: The encoded access info for the failing access.\n+\n+.section .text\n+.file \"hwasan_tag_mismatch_riscv64.S\"\n+\n+.global __hwasan_tag_mismatch_v2\n+ASM_TYPE_FUNCTION(__hwasan_tag_mismatch_v2)\n+__hwasan_tag_mismatch_v2:\n+  CFI_STARTPROC\n+\n+  // Set the CFA to be the return address for caller of __hwasan_check_*. Note\n+  // that we do not emit CFI predicates to describe the contents of this stack\n+  // frame, as this proxy entry point should never be debugged. The contents\n+  // are static and are handled by the unwinder after calling\n+  // __hwasan_tag_mismatch. The frame pointer is already correctly setup\n+  // by __hwasan_check_*.\n+  addi fp, sp, 256\n+  CFI_DEF_CFA(fp, 0)\n+  CFI_OFFSET(ra, -248)\n+  CFI_OFFSET(fp, -192)\n+\n+  // Save the rest of the registers into the preallocated space left by\n+  // __hwasan_check.\n+  sd x31, 248(sp)\n+  sd x30, 240(sp)\n+  sd x29, 232(sp)\n+  sd x28, 224(sp)\n+  sd x27, 216(sp)\n+  sd x26, 208(sp)\n+  sd x25, 200(sp)\n+  sd x24, 192(sp)\n+  sd x23, 184(sp)\n+  sd x22, 176(sp)\n+  sd x21, 168(sp)\n+  sd x20, 160(sp)\n+  sd x19, 152(sp)\n+  sd x18, 144(sp)\n+  sd x17, 136(sp)\n+  sd x16, 128(sp)\n+  sd x15, 120(sp)\n+  sd x14, 112(sp)\n+  sd x13, 104(sp)\n+  sd x12, 96(sp)\n+  // sd x11, 88(sp) ; already saved\n+  // sd x10, 80(sp) ; already saved\n+  sd x9, 72(sp)\n+  // sd x8, 64(sp) ; already saved\n+  sd x7, 56(sp)\n+  sd x6, 48(sp)\n+  sd x5, 40(sp)\n+  sd x4, 32(sp)\n+  sd x3, 24(sp)\n+  sd x2, 16(sp)\n+  // sd x1, 8(sp) ; already saved\n+  // sd x0, 0(sp) ; don't store zero register\n+\n+  // Pass the address of the frame to __hwasan_tag_mismatch4, so that it can\n+  // extract the saved registers from this frame without having to worry about\n+  // finding this frame.\n+  mv x12, sp\n+\n+  call __hwasan_tag_mismatch4\n+  CFI_ENDPROC\n+ASM_SIZE(__hwasan_tag_mismatch_v2)\n+\n+#endif  // defined(__riscv) && (__riscv_xlen == 64)\n+\n+// We do not need executable stack.\n+NO_EXEC_STACK_DIRECTIVE"}, {"sha": "d97974ee9074e9eb16a9dc8ae6abce3e23d12614", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -16,7 +16,7 @@\n \n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n \n-#if !SANITIZER_LINUX && !SANITIZER_FREEBSD && !SANITIZER_MAC &&      \\\n+#if !SANITIZER_LINUX && !SANITIZER_FREEBSD && !SANITIZER_APPLE &&      \\\n     !SANITIZER_NETBSD && !SANITIZER_WINDOWS && !SANITIZER_FUCHSIA && \\\n     !SANITIZER_SOLARIS\n #  error \"Interception doesn't work on this operating system.\"\n@@ -88,7 +88,7 @@ typedef __sanitizer::OFF64_T OFF64_T;\n // As it's decided at compile time which functions are to be intercepted on Mac,\n // INTERCEPT_FUNCTION() is effectively a no-op on this system.\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #include <sys/cdefs.h>  // For __DARWIN_ALIAS_C().\n \n // Just a pair of pointers.\n@@ -157,7 +157,7 @@ const interpose_substitution substitution_##func_name[] \\\n # define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n # define REAL(x) __unsanitized_##x\n # define DECLARE_REAL(ret_type, func, ...)\n-#elif !SANITIZER_MAC\n+#elif !SANITIZER_APPLE\n # define PTR_TO_REAL(x) real_##x\n # define REAL(x) __interception::PTR_TO_REAL(x)\n # define FUNC_TYPE(x) x##_type\n@@ -168,12 +168,12 @@ const interpose_substitution substitution_##func_name[] \\\n       extern FUNC_TYPE(func) PTR_TO_REAL(func); \\\n     }\n # define ASSIGN_REAL(dst, src) REAL(dst) = REAL(src)\n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n # define REAL(x) x\n # define DECLARE_REAL(ret_type, func, ...) \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n # define ASSIGN_REAL(x, y)\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n \n #if !SANITIZER_FUCHSIA\n #  define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n@@ -193,7 +193,7 @@ const interpose_substitution substitution_##func_name[] \\\n // macros does its job. In exceptional cases you may need to call REAL(foo)\n // without defining INTERCEPTOR(..., foo, ...). For example, if you override\n // foo with an interceptor for other function.\n-#if !SANITIZER_MAC && !SANITIZER_FUCHSIA\n+#if !SANITIZER_APPLE && !SANITIZER_FUCHSIA\n #  define DEFINE_REAL(ret_type, func, ...)            \\\n     typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n     namespace __interception {                        \\\n@@ -213,7 +213,7 @@ const interpose_substitution substitution_##func_name[] \\\n       __interceptor_##func(__VA_ARGS__);                                \\\n   extern \"C\" INTERCEPTOR_ATTRIBUTE ret_type func(__VA_ARGS__)\n \n-#elif !SANITIZER_MAC\n+#elif !SANITIZER_APPLE\n \n #define INTERCEPTOR(ret_type, func, ...) \\\n   DEFINE_REAL(ret_type, func, __VA_ARGS__) \\\n@@ -226,7 +226,7 @@ const interpose_substitution substitution_##func_name[] \\\n #define INTERCEPTOR_WITH_SUFFIX(ret_type, func, ...) \\\n   INTERCEPTOR(ret_type, func, __VA_ARGS__)\n \n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n \n #define INTERCEPTOR_ZZZ(suffix, ret_type, func, ...) \\\n   extern \"C\" ret_type func(__VA_ARGS__) suffix; \\\n@@ -278,7 +278,7 @@ typedef unsigned long uptr;\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\\n     INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver)\n-#elif SANITIZER_MAC\n+#elif SANITIZER_APPLE\n # include \"interception_mac.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\"}, {"sha": "03eae0fdca0d80cd86bc6ee79690afac747cb8e0", "filename": "libsanitizer/interception/interception_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -13,6 +13,6 @@\n \n #include \"interception.h\"\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "26079518c649b38524e68868b706b722cdd32628", "filename": "libsanitizer/interception/interception_mac.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -11,7 +11,7 @@\n // Mac-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n # error \"interception_mac.h should be included from interception.h only\"\n@@ -24,4 +24,4 @@\n #define INTERCEPT_FUNCTION_VER_MAC(func, symver)\n \n #endif  // INTERCEPTION_MAC_H\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "2a118fb214fffee8ef568f2034fc83d4ea46b8d7", "filename": "libsanitizer/interception/interception_type_test.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_type_test.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_type_test.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_type_test.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -13,7 +13,7 @@\n \n #include \"interception.h\"\n \n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_LINUX || SANITIZER_APPLE\n \n #include <sys/types.h>\n #include <stddef.h>\n@@ -24,7 +24,7 @@ COMPILER_CHECK(sizeof(::SSIZE_T) == sizeof(ssize_t));\n COMPILER_CHECK(sizeof(::PTRDIFF_T) == sizeof(ptrdiff_t));\n COMPILER_CHECK(sizeof(::INTMAX_T) == sizeof(intmax_t));\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n COMPILER_CHECK(sizeof(::OFF64_T) == sizeof(off64_t));\n #endif\n "}, {"sha": "d0db981d519cbbbe7df3d090a8ab7a97a5a5ebda", "filename": "libsanitizer/interception/interception_win.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Finterception%2Finterception_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -1068,4 +1068,4 @@ bool OverrideImportedFunction(const char *module_to_patch,\n \n }  // namespace __interception\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "43928ad294e2c154279ad6b15e46282f57eb763a", "filename": "libsanitizer/lsan/lsan_allocator.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -146,6 +146,8 @@ void GetAllocatorCacheRange(uptr *begin, uptr *end) {\n }\n \n uptr GetMallocUsableSize(const void *p) {\n+  if (!p)\n+    return 0;\n   ChunkMetadata *m = Metadata(p);\n   if (!m) return 0;\n   return m->requested_size;"}, {"sha": "b67d9d7750efc9933bdda39191c32e1296b60db4", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -49,8 +49,7 @@ struct ChunkMetadata {\n   u32 stack_trace_id;\n };\n \n-#if defined(__mips64) || defined(__aarch64__) || defined(__i386__) || \\\n-    defined(__arm__) || SANITIZER_RISCV64 || defined(__hexagon__)\n+#if !SANITIZER_CAN_USE_ALLOCATOR64\n template <typename AddressSpaceViewTy>\n struct AP32 {\n   static const uptr kSpaceBeg = 0;\n@@ -65,7 +64,7 @@ struct AP32 {\n template <typename AddressSpaceView>\n using PrimaryAllocatorASVT = SizeClassAllocator32<AP32<AddressSpaceView>>;\n using PrimaryAllocator = PrimaryAllocatorASVT<LocalAddressSpaceView>;\n-#elif defined(__x86_64__) || defined(__powerpc64__) || defined(__s390x__)\n+#else\n # if SANITIZER_FUCHSIA || defined(__powerpc64__)\n const uptr kAllocatorSpace = ~(uptr)0;\n const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T."}, {"sha": "94bb3cca0083f0d0adc996df4ce7cc16732068b2", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -105,7 +105,7 @@ static const char kStdSuppressions[] =\n     // definition.\n     \"leak:*pthread_exit*\\n\"\n #  endif  // SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT\n-#  if SANITIZER_MAC\n+#  if SANITIZER_APPLE\n     // For Darwin and os_log/os_trace: https://reviews.llvm.org/D35173\n     \"leak:*_os_trace*\\n\"\n #  endif\n@@ -240,7 +240,7 @@ class Decorator : public __sanitizer::SanitizerCommonDecorator {\n   const char *Leak() { return Blue(); }\n };\n \n-static inline bool CanBeAHeapPointer(uptr p) {\n+static inline bool MaybeUserPointer(uptr p) {\n   // Since our heap is located in mmap-ed memory, we can assume a sensible lower\n   // bound on heap addresses.\n   const uptr kMinAddress = 4 * 4096;\n@@ -252,8 +252,8 @@ static inline bool CanBeAHeapPointer(uptr p) {\n #  elif defined(__mips64)\n   return ((p >> 40) == 0);\n #  elif defined(__aarch64__)\n-  unsigned runtimeVMA = (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1);\n-  return ((p >> runtimeVMA) == 0);\n+  // Accept up to 48 bit VMA.\n+  return ((p >> 48) == 0);\n #  else\n   return true;\n #  endif\n@@ -276,7 +276,7 @@ void ScanRangeForPointers(uptr begin, uptr end, Frontier *frontier,\n     pp = pp + alignment - pp % alignment;\n   for (; pp + sizeof(void *) <= end; pp += alignment) {\n     void *p = *reinterpret_cast<void **>(pp);\n-    if (!CanBeAHeapPointer(reinterpret_cast<uptr>(p)))\n+    if (!MaybeUserPointer(reinterpret_cast<uptr>(p)))\n       continue;\n     uptr chunk = PointsIntoChunk(p);\n     if (!chunk)\n@@ -949,7 +949,7 @@ void __lsan_ignore_object(const void *p) {\n   Lock l(&global_mutex);\n   IgnoreObjectResult res = IgnoreObjectLocked(p);\n   if (res == kIgnoreObjectInvalid)\n-    VReport(1, \"__lsan_ignore_object(): no heap object found at %p\", p);\n+    VReport(1, \"__lsan_ignore_object(): no heap object found at %p\\n\", p);\n   if (res == kIgnoreObjectAlreadyIgnored)\n     VReport(1,\n             \"__lsan_ignore_object(): \"\n@@ -1032,13 +1032,11 @@ SANITIZER_INTERFACE_WEAK_DEF(const char *, __lsan_default_options, void) {\n }\n \n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE int\n-__lsan_is_turned_off() {\n+SANITIZER_INTERFACE_WEAK_DEF(int, __lsan_is_turned_off, void) {\n   return 0;\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE const char *\n-__lsan_default_suppressions() {\n+SANITIZER_INTERFACE_WEAK_DEF(const char *, __lsan_default_suppressions, void) {\n   return \"\";\n }\n #endif"}, {"sha": "d7153751faee0fe33c519df24a4973d3056b825c", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -34,11 +34,11 @@\n // is missing. This caused a link error.\n #if SANITIZER_ANDROID && (__ANDROID_API__ < 28 || defined(__arm__))\n #  define CAN_SANITIZE_LEAKS 0\n-#elif (SANITIZER_LINUX || SANITIZER_MAC) && (SANITIZER_WORDSIZE == 64) && \\\n+#elif (SANITIZER_LINUX || SANITIZER_APPLE) && (SANITIZER_WORDSIZE == 64) && \\\n     (defined(__x86_64__) || defined(__mips64) || defined(__aarch64__) ||  \\\n      defined(__powerpc64__) || defined(__s390x__))\n #  define CAN_SANITIZE_LEAKS 1\n-#elif defined(__i386__) && (SANITIZER_LINUX || SANITIZER_MAC)\n+#elif defined(__i386__) && (SANITIZER_LINUX || SANITIZER_APPLE)\n #  define CAN_SANITIZE_LEAKS 1\n #elif defined(__arm__) && SANITIZER_LINUX\n #  define CAN_SANITIZE_LEAKS 1"}, {"sha": "26b623fb1d49ad9342046ffdb6d94944bbcde4c9", "filename": "libsanitizer/lsan/lsan_common_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -15,7 +15,7 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"lsan_common.h\"\n \n-#if CAN_SANITIZE_LEAKS && SANITIZER_MAC\n+#if CAN_SANITIZE_LEAKS && SANITIZER_APPLE\n \n #include \"sanitizer_common/sanitizer_allocator_internal.h\"\n #include \"lsan_allocator.h\"\n@@ -201,4 +201,4 @@ void LockStuffAndStopTheWorld(StopTheWorldCallback callback,\n \n } // namespace __lsan\n \n-#endif // CAN_SANITIZE_LEAKS && SANITIZER_MAC\n+#endif // CAN_SANITIZE_LEAKS && SANITIZER_APPLE"}, {"sha": "3a1b2afdbb74eb5d1cebaeda9399f4d79d51e129", "filename": "libsanitizer/lsan/lsan_interceptors.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -67,7 +67,7 @@ namespace std {\n   enum class align_val_t: size_t;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n INTERCEPTOR(void*, malloc, uptr size) {\n   if (DlsymAlloc::Use())\n     return DlsymAlloc::Allocate(size);\n@@ -116,7 +116,7 @@ INTERCEPTOR(void*, valloc, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n   return lsan_valloc(size, stack);\n }\n-#endif  // !SANITIZER_MAC\n+#endif  // !SANITIZER_APPLE\n \n #if SANITIZER_INTERCEPT_MEMALIGN\n INTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n@@ -242,7 +242,7 @@ INTERCEPTOR(int, mprobe, void *ptr) {\n // libstdc++, each of has its implementation of new and delete.\n // To make sure that C++ allocation/deallocation operators are overridden on\n // OS X we need to intercept them using their mangled names.\n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n \n INTERCEPTOR_ATTRIBUTE\n void *operator new(size_t size) { OPERATOR_NEW_BODY(false /*nothrow*/); }\n@@ -301,7 +301,7 @@ INTERCEPTOR_ATTRIBUTE\n void operator delete[](void *ptr, size_t size, std::align_val_t) NOEXCEPT\n { OPERATOR_DELETE_BODY; }\n \n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n \n INTERCEPTOR(void *, _Znwm, size_t size)\n { OPERATOR_NEW_BODY(false /*nothrow*/); }\n@@ -321,7 +321,7 @@ INTERCEPTOR(void, _ZdlPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n { OPERATOR_DELETE_BODY; }\n \n-#endif  // !SANITIZER_MAC\n+#endif  // !SANITIZER_APPLE\n \n \n ///// Thread initialization and finalization. /////"}, {"sha": "6964a9ba28df52ac82ecbd35c132c5432a1498d8", "filename": "libsanitizer/lsan/lsan_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"interception/interception.h\"\n #include \"lsan.h\"\n@@ -188,4 +188,4 @@ INTERCEPTOR(void, dispatch_source_set_event_handler, dispatch_source_t ds,\n }\n #endif\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "525c30272ccca6295c5f8071951bd44172af3ad3", "filename": "libsanitizer/lsan/lsan_malloc_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_malloc_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Flsan%2Flsan_malloc_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_malloc_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"lsan.h\"\n #include \"lsan_allocator.h\"\n@@ -56,4 +56,4 @@ using namespace __lsan;\n \n #include \"sanitizer_common/sanitizer_malloc_mac.inc\"\n \n-#endif // SANITIZER_MAC\n+#endif // SANITIZER_APPLE"}, {"sha": "129f925e6fb686d465b2b74b9d631c9850865a56", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_report.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -128,8 +128,7 @@ void NORETURN ReportAllocationSizeTooBig(uptr user_size, uptr max_size,\n void NORETURN ReportOutOfMemory(uptr requested_size, const StackTrace *stack) {\n   {\n     ScopedAllocatorErrorReport report(\"out-of-memory\", stack);\n-    Report(\"ERROR: %s: allocator is out of memory trying to allocate 0x%zx \"\n-           \"bytes\\n\", SanitizerToolName, requested_size);\n+    ERROR_OOM(\"allocator is trying to allocate 0x%zx bytes\\n\", requested_size);\n   }\n   Die();\n }"}, {"sha": "e0e2bd01069f24a27e7697125cfc9e8178e3992b", "filename": "libsanitizer/sanitizer_common/sanitizer_chained_origin_depot.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -143,4 +143,6 @@ void ChainedOriginDepot::LockAll() { depot.LockAll(); }\n \n void ChainedOriginDepot::UnlockAll() { depot.UnlockAll(); }\n \n+void ChainedOriginDepot::TestOnlyUnmap() { depot.TestOnlyUnmap(); }\n+\n }  // namespace __sanitizer"}, {"sha": "f9f192b685719eae17a4a1bc7a5a5226bf0d1479", "filename": "libsanitizer/sanitizer_common/sanitizer_chained_origin_depot.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -34,6 +34,7 @@ class ChainedOriginDepot {\n \n   void LockAll();\n   void UnlockAll();\n+  void TestOnlyUnmap();\n \n  private:\n   ChainedOriginDepot(const ChainedOriginDepot &) = delete;"}, {"sha": "82236453157fa3b6be86233a917bb24afc2f3a79", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cpp", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -46,9 +46,15 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n     Die();\n   }\n   recursion_count++;\n-  Report(\"ERROR: %s failed to \"\n-         \"%s 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n-         SanitizerToolName, mmap_type, size, size, mem_type, err);\n+  if (ErrorIsOOM(err)) {\n+    ERROR_OOM(\"failed to %s 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n+              mmap_type, size, size, mem_type, err);\n+  } else {\n+    Report(\n+        \"ERROR: %s failed to \"\n+        \"%s 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n+        SanitizerToolName, mmap_type, size, size, mem_type, err);\n+  }\n #if !SANITIZER_GO\n   DumpProcessMap();\n #endif\n@@ -351,6 +357,13 @@ void SleepForSeconds(unsigned seconds) {\n }\n void SleepForMillis(unsigned millis) { internal_usleep((u64)millis * 1000); }\n \n+void WaitForDebugger(unsigned seconds, const char *label) {\n+  if (seconds) {\n+    Report(\"Sleeping for %u second(s) %s\\n\", seconds, label);\n+    SleepForSeconds(seconds);\n+  }\n+}\n+\n } // namespace __sanitizer\n \n using namespace __sanitizer;"}, {"sha": "08c6062ba067856502ace04bada1ac516fce46f2", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -120,6 +120,11 @@ bool MprotectReadOnly(uptr addr, uptr size);\n \n void MprotectMallocZones(void *addr, int prot);\n \n+#if SANITIZER_WINDOWS\n+// Zero previously mmap'd memory. Currently used only on Windows.\n+bool ZeroMmapFixedRegion(uptr fixed_addr, uptr size) WARN_UNUSED_RESULT;\n+#endif\n+\n #if SANITIZER_LINUX\n // Unmap memory. Currently only used on Linux.\n void UnmapFromTo(uptr from, uptr to);\n@@ -294,6 +299,7 @@ void InitTlsSize();\n uptr GetTlsSize();\n \n // Other\n+void WaitForDebugger(unsigned seconds, const char *label);\n void SleepForSeconds(unsigned seconds);\n void SleepForMillis(unsigned millis);\n u64 NanoTime();\n@@ -310,6 +316,18 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n                                       const char *mmap_type, error_t err,\n                                       bool raw_report = false);\n \n+// Returns true if the platform-specific error reported is an OOM error.\n+bool ErrorIsOOM(error_t err);\n+\n+// This reports an error in the form:\n+//\n+//   `ERROR: {{SanitizerToolName}}: out of memory: {{err_msg}}`\n+//\n+// Downstream tools that read sanitizer output will know that errors starting\n+// in this format are specifically OOM errors.\n+#define ERROR_OOM(err_msg, ...) \\\n+  Report(\"ERROR: %s: out of memory: \" err_msg, SanitizerToolName, __VA_ARGS__)\n+\n // Specific tools may override behavior of \"Die\" function to do tool-specific\n // job.\n typedef void (*DieCallbackType)(void);\n@@ -890,13 +908,13 @@ void WriteToSyslog(const char *buffer);\n #define SANITIZER_WIN_TRACE 0\n #endif\n \n-#if SANITIZER_MAC || SANITIZER_WIN_TRACE\n+#if SANITIZER_APPLE || SANITIZER_WIN_TRACE\n void LogFullErrorReport(const char *buffer);\n #else\n inline void LogFullErrorReport(const char *buffer) {}\n #endif\n \n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_LINUX || SANITIZER_APPLE\n void WriteOneLineToSyslog(const char *s);\n void LogMessageOnPrintf(const char *str);\n #else\n@@ -1003,7 +1021,6 @@ struct SignalContext {\n };\n \n void InitializePlatformEarly();\n-void MaybeReexec();\n \n template <typename Fn>\n class RunOnDestruction {"}, {"sha": "cd9235e503b13c0759969cb5bf0e99f425d512e1", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 126, "deletions": 11, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -203,13 +203,13 @@ extern const short *_tolower_tab_;\n #endif\n \n // Platform-specific options.\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE 0\n #elif SANITIZER_WINDOWS64\n #define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE 0\n #else\n #define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE 1\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n \n #ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n #define COMMON_INTERCEPTOR_INITIALIZE_RANGE(p, size) {}\n@@ -385,9 +385,11 @@ extern const short *_tolower_tab_;\n   if (common_flags()->intercept_strndup) {                                    \\\n     COMMON_INTERCEPTOR_READ_STRING(ctx, s, Min(size, copy_length + 1));       \\\n   }                                                                           \\\n-  COMMON_INTERCEPTOR_COPY_STRING(ctx, new_mem, s, copy_length);               \\\n-  internal_memcpy(new_mem, s, copy_length);                                   \\\n-  new_mem[copy_length] = '\\0';                                                \\\n+  if (new_mem) {                                                              \\\n+    COMMON_INTERCEPTOR_COPY_STRING(ctx, new_mem, s, copy_length);             \\\n+    internal_memcpy(new_mem, s, copy_length);                                 \\\n+    new_mem[copy_length] = '\\0';                                              \\\n+  }                                                                           \\\n   return new_mem;\n #endif\n \n@@ -1334,7 +1336,7 @@ INTERCEPTOR_WITH_SUFFIX(int, fputs, char *s, void *file) {\n   // libc file streams can call user-supplied functions, see fopencookie.\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fputs, s, file);\n-  if (!SANITIZER_MAC || s) {  // `fputs(NULL, file)` is supported on Darwin.\n+  if (!SANITIZER_APPLE || s) {  // `fputs(NULL, file)` is supported on Darwin.\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, s, internal_strlen(s) + 1);\n   }\n   return REAL(fputs)(s, file);\n@@ -1349,7 +1351,7 @@ INTERCEPTOR(int, puts, char *s) {\n   // libc file streams can call user-supplied functions, see fopencookie.\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, puts, s);\n-  if (!SANITIZER_MAC || s) {  // `puts(NULL)` is supported on Darwin.\n+  if (!SANITIZER_APPLE || s) {  // `puts(NULL)` is supported on Darwin.\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, s, internal_strlen(s) + 1);\n   }\n   return REAL(puts)(s);\n@@ -1365,8 +1367,13 @@ INTERCEPTOR(int, prctl, int option, unsigned long arg2, unsigned long arg3,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n   static const int PR_SET_NAME = 15;\n+  static const int PR_SET_VMA = 0x53564d41;\n   static const int PR_SCHED_CORE = 62;\n   static const int PR_SCHED_CORE_GET = 0;\n+  if (option == PR_SET_VMA && arg2 == 0UL) {\n+    char *name = (char *)arg5;\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, internal_strlen(name) + 1);\n+  }\n   int res = REAL(prctl(option, arg2, arg3, arg4, arg5));\n   if (option == PR_SET_NAME) {\n     char buff[16];\n@@ -1952,7 +1959,7 @@ UNUSED static void unpoison_passwd(void *ctx, __sanitizer_passwd *pwd) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_gecos,\n                                      internal_strlen(pwd->pw_gecos) + 1);\n #endif\n-#if SANITIZER_MAC || SANITIZER_FREEBSD || SANITIZER_NETBSD\n+#if SANITIZER_APPLE || SANITIZER_FREEBSD || SANITIZER_NETBSD\n     if (pwd->pw_class)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_class,\n                                      internal_strlen(pwd->pw_class) + 1);\n@@ -2516,13 +2523,61 @@ INTERCEPTOR(int, __b64_pton, char const *src, char *target, SIZE_T targsize) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, target, res);\n   return res;\n }\n-#  define INIT___B64_TO                    \\\n+#define INIT___B64_TO                      \\\n     COMMON_INTERCEPT_FUNCTION(__b64_ntop); \\\n     COMMON_INTERCEPT_FUNCTION(__b64_pton);\n #else  // SANITIZER_INTERCEPT___B64_TO\n #define INIT___B64_TO\n #endif  // SANITIZER_INTERCEPT___B64_TO\n \n+#if SANITIZER_INTERCEPT_DN_COMP_EXPAND\n+#  if __GLIBC_PREREQ(2, 34)\n+// Changed with https://sourceware.org/git/?p=glibc.git;h=640bbdf\n+#    define DN_COMP_INTERCEPTOR_NAME dn_comp\n+#    define DN_EXPAND_INTERCEPTOR_NAME dn_expand\n+#  else\n+#    define DN_COMP_INTERCEPTOR_NAME __dn_comp\n+#    define DN_EXPAND_INTERCEPTOR_NAME __dn_expand\n+#  endif\n+INTERCEPTOR(int, DN_COMP_INTERCEPTOR_NAME, unsigned char *exp_dn,\n+            unsigned char *comp_dn, int length, unsigned char **dnptrs,\n+            unsigned char **lastdnptr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, DN_COMP_INTERCEPTOR_NAME, exp_dn, comp_dn,\n+                           length, dnptrs, lastdnptr);\n+  int res = REAL(DN_COMP_INTERCEPTOR_NAME)(exp_dn, comp_dn, length, dnptrs,\n+                                           lastdnptr);\n+  if (res >= 0) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, comp_dn, res);\n+    if (dnptrs && lastdnptr) {\n+      unsigned char **p = dnptrs;\n+      for (; p != lastdnptr && *p; ++p)\n+        ;\n+      if (p != lastdnptr)\n+        ++p;\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dnptrs, (p - dnptrs) * sizeof(*p));\n+    }\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, DN_EXPAND_INTERCEPTOR_NAME, unsigned char const *base,\n+            unsigned char const *end, unsigned char const *src, char *dest,\n+            int space) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, DN_EXPAND_INTERCEPTOR_NAME, base, end, src,\n+                           dest, space);\n+  // TODO: add read check if __dn_comp intercept added\n+  int res = REAL(DN_EXPAND_INTERCEPTOR_NAME)(base, end, src, dest, space);\n+  if (res >= 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, internal_strlen(dest) + 1);\n+  return res;\n+}\n+#  define INIT_DN_COMP_EXPAND                            \\\n+    COMMON_INTERCEPT_FUNCTION(DN_COMP_INTERCEPTOR_NAME); \\\n+    COMMON_INTERCEPT_FUNCTION(DN_EXPAND_INTERCEPTOR_NAME);\n+#else  // SANITIZER_INTERCEPT_DN_COMP_EXPAND\n+#  define INIT_DN_COMP_EXPAND\n+#endif  // SANITIZER_INTERCEPT_DN_COMP_EXPAND\n \n #if SANITIZER_INTERCEPT_POSIX_SPAWN\n \n@@ -3941,7 +3996,7 @@ INTERCEPTOR(char *, strerror, int errnum) {\n //  * GNU version returns message pointer, which points to either buf or some\n //    static storage.\n #if ((_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE) || \\\n-    SANITIZER_MAC || SANITIZER_ANDROID || SANITIZER_NETBSD ||                 \\\n+    SANITIZER_APPLE || SANITIZER_ANDROID || SANITIZER_NETBSD ||                 \\\n     SANITIZER_FREEBSD\n // POSIX version. Spec is not clear on whether buf is NULL-terminated.\n // At least on OSX, buf contents are valid even when the call fails.\n@@ -3974,7 +4029,7 @@ INTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n   return res;\n }\n #endif //(_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE ||\n-       //SANITIZER_MAC\n+       //SANITIZER_APPLE\n #define INIT_STRERROR_R COMMON_INTERCEPT_FUNCTION(strerror_r);\n #else\n #define INIT_STRERROR_R\n@@ -4943,6 +4998,27 @@ INTERCEPTOR(int, pthread_attr_getaffinity_np, void *attr, SIZE_T cpusetsize,\n #define INIT_PTHREAD_ATTR_GETAFFINITY_NP\n #endif\n \n+#if SANITIZER_INTERCEPT_PTHREAD_GETAFFINITY_NP\n+INTERCEPTOR(int, pthread_getaffinity_np, void *attr, SIZE_T cpusetsize,\n+            void *cpuset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_getaffinity_np, attr, cpusetsize,\n+                           cpuset);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://github.com/google/sanitizers/issues/321.\n+  int res = REAL(pthread_getaffinity_np)(attr, cpusetsize, cpuset);\n+  if (!res && cpusetsize && cpuset)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cpuset, cpusetsize);\n+  return res;\n+}\n+\n+#define INIT_PTHREAD_GETAFFINITY_NP \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_getaffinity_np);\n+#else\n+#define INIT_PTHREAD_GETAFFINITY_NP\n+#endif\n+\n #if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED\n INTERCEPTOR_PTHREAD_MUTEXATTR_GET(pshared, sizeof(int))\n #define INIT_PTHREAD_MUTEXATTR_GETPSHARED \\\n@@ -10308,6 +10384,42 @@ INTERCEPTOR(int, sigaltstack, void *ss, void *oss) {\n #define INIT_SIGALTSTACK\n #endif\n \n+#if SANITIZER_INTERCEPT_PROCCTL\n+INTERCEPTOR(int, procctl, int idtype, u64 id, int cmd, uptr data) {\n+   void *ctx;\n+   COMMON_INTERCEPTOR_ENTER(ctx, procctl, idtype, id, cmd, data);\n+   static const int PROC_REAP_ACQUIRE = 2;\n+   static const int PROC_REAP_RELEASE = 3;\n+   static const int PROC_REAP_STATUS = 4;\n+   static const int PROC_REAP_GETPIDS = 5;\n+   static const int PROC_REAP_KILL = 6;\n+   if (cmd < PROC_REAP_ACQUIRE || cmd > PROC_REAP_KILL) {\n+     COMMON_INTERCEPTOR_READ_RANGE(ctx, (void *)data, sizeof(int));\n+   } else {\n+     // reap_acquire/reap_release bears no arguments.\n+     if (cmd > PROC_REAP_RELEASE) {\n+       unsigned int reapsz;\n+       switch (cmd) {\n+       case PROC_REAP_STATUS:\n+         reapsz = struct_procctl_reaper_status_sz;\n+         break;\n+       case PROC_REAP_GETPIDS:\n+         reapsz = struct_procctl_reaper_pids_sz;\n+         break;\n+       case PROC_REAP_KILL:\n+         reapsz = struct_procctl_reaper_kill_sz;\n+         break;\n+       }\n+       COMMON_INTERCEPTOR_READ_RANGE(ctx, (void *)data, reapsz);\n+     }\n+   }\n+   return REAL(procctl)(idtype, id, cmd, data);\n+}\n+#define INIT_PROCCTL COMMON_INTERCEPT_FUNCTION(procctl)\n+#else\n+#define INIT_PROCCTL\n+#endif\n+\n #if SANITIZER_INTERCEPT_UNAME\n INTERCEPTOR(int, uname, struct utsname *utsname) {\n #if SANITIZER_LINUX\n@@ -10425,6 +10537,7 @@ static void InitializeCommonInterceptors() {\n   INIT_GLOB;\n   INIT_GLOB64;\n   INIT___B64_TO;\n+  INIT_DN_COMP_EXPAND;\n   INIT_POSIX_SPAWN;\n   INIT_WAIT;\n   INIT_WAIT4;\n@@ -10514,6 +10627,7 @@ static void InitializeCommonInterceptors() {\n   INIT_PTHREAD_ATTR_GET_SCHED;\n   INIT_PTHREAD_ATTR_GETINHERITSCHED;\n   INIT_PTHREAD_ATTR_GETAFFINITY_NP;\n+  INIT_PTHREAD_GETAFFINITY_NP;\n   INIT_PTHREAD_MUTEXATTR_GETPSHARED;\n   INIT_PTHREAD_MUTEXATTR_GETTYPE;\n   INIT_PTHREAD_MUTEXATTR_GETPROTOCOL;\n@@ -10665,6 +10779,7 @@ static void InitializeCommonInterceptors() {\n   INIT_QSORT_R;\n   INIT_BSEARCH;\n   INIT_SIGALTSTACK;\n+  INIT_PROCCTL\n   INIT_UNAME;\n   INIT___XUNAME;\n "}, {"sha": "05192485d597170615a06fcb41d967134c92b060", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_loongarch64.inc.S", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_loongarch64.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_loongarch64.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_loongarch64.inc.S?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -0,0 +1,63 @@\n+#if defined(__loongarch_lp64) && defined(__linux__)\n+\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+ASM_HIDDEN(COMMON_INTERCEPTOR_SPILL_AREA)\n+ASM_HIDDEN(_ZN14__interception10real_vforkE)\n+\n+.bss\n+.type _ZN14__interception10real_vforkE, @object\n+.size _ZN14__interception10real_vforkE, 8\n+_ZN14__interception10real_vforkE:\n+        .zero     8\n+\n+.text\n+.globl ASM_WRAPPER_NAME(vfork)\n+ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n+ASM_WRAPPER_NAME(vfork):\n+        // Save ra in the off-stack spill area.\n+        // allocate space on stack\n+        addi.d    $sp, $sp, -16\n+        // store $ra value\n+        st.d      $ra, $sp, 8\n+        bl        COMMON_INTERCEPTOR_SPILL_AREA\n+        // restore previous values from stack\n+        ld.d      $ra, $sp, 8\n+        // adjust stack\n+        addi.d    $sp, $sp, 16\n+        // store $ra by $a0\n+        st.d      $ra, $a0, 0\n+\n+        // Call real vfork. This may return twice. User code that runs between the first and the second return\n+        // may clobber the stack frame of the interceptor; that's why it does not have a frame.\n+        la.local  $a0, _ZN14__interception10real_vforkE\n+        ld.d      $a0, $a0, 0\n+        jirl      $ra, $a0, 0\n+\n+        // adjust stack\n+        addi.d    $sp, $sp, -16\n+        // store $a0 by adjusted stack\n+        st.d      $a0, $sp, 8\n+        // jump to exit label if $a0 is 0\n+        beqz      $a0, .L_exit\n+\n+        // $a0 != 0 => parent process. Clear stack shadow.\n+        // put old $sp to $a0\n+        addi.d    $a0, $sp, 16\n+        bl        %plt(COMMON_INTERCEPTOR_HANDLE_VFORK)\n+\n+.L_exit:\n+        // Restore $ra\n+        bl        COMMON_INTERCEPTOR_SPILL_AREA\n+        ld.d      $ra, $a0, 0\n+        // load value by stack\n+        ld.d      $a0, $sp, 8\n+        // adjust stack\n+        addi.d    $sp, $sp, 16\n+        jr        $ra\n+ASM_SIZE(vfork)\n+\n+.weak vfork\n+.set vfork, ASM_WRAPPER_NAME(vfork)\n+\n+#endif"}, {"sha": "67e77a8777818d687b23c823cf51b5d2c9b7e893", "filename": "libsanitizer/sanitizer_common/sanitizer_common_nolibc.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -28,7 +28,7 @@ void Abort() { internal__exit(1); }\n bool CreateDir(const char *pathname) { return false; }\n #endif // !SANITIZER_WINDOWS\n \n-#if !SANITIZER_WINDOWS && !SANITIZER_MAC\n+#if !SANITIZER_WINDOWS && !SANITIZER_APPLE\n void ListOfModules::init() {}\n void InitializePlatformCommonFlags(CommonFlags *cf) {}\n #endif"}, {"sha": "9d36a40270d5a255d0104c4219bc5ca8947623a5", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_interface.inc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -27,6 +27,16 @@ INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_gep)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_guard)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_guard_init)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_pc_indir)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_load1)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_load2)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_load4)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_load8)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_load16)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_store1)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_store2)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_store4)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_store8)\n+INTERFACE_WEAK_FUNCTION(__sanitizer_cov_store16)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_trace_switch)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_8bit_counters_init)\n INTERFACE_WEAK_FUNCTION(__sanitizer_cov_bool_flag_init)"}, {"sha": "956b48e0b434b2a5fa48adc3c29f722fe48d067f", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep_new.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -259,6 +259,16 @@ SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_div4, void) {}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_div8, void) {}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_gep, void) {}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_trace_pc_indir, void) {}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_load1, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_load2, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_load4, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_load8, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_load16, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_store1, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_store2, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_store4, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_store8, void){}\n+SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_store16, void){}\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_cov_8bit_counters_init,\n                              char* start, char* end) {\n   __sancov::SingletonCounterCoverage::Cov8bitCountersInit(start, end);"}, {"sha": "46c85364cef5603afab7e7613512b04290441d15", "filename": "libsanitizer/sanitizer_common/sanitizer_errno.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -21,7 +21,7 @@\n #include \"sanitizer_errno_codes.h\"\n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_MAC\n+#if SANITIZER_FREEBSD || SANITIZER_APPLE\n #  define __errno_location __error\n #elif SANITIZER_ANDROID || SANITIZER_NETBSD\n #  define __errno_location __errno"}, {"sha": "6148ae56067cae03e7094070062f5ec083454565", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -62,16 +62,19 @@ COMMON_FLAG(\n COMMON_FLAG(const char *, log_suffix, nullptr,\n             \"String to append to log file name, e.g. \\\".txt\\\".\")\n COMMON_FLAG(\n-    bool, log_to_syslog, (bool)SANITIZER_ANDROID || (bool)SANITIZER_MAC,\n+    bool, log_to_syslog, (bool)SANITIZER_ANDROID || (bool)SANITIZER_APPLE,\n     \"Write all sanitizer output to syslog in addition to other means of \"\n     \"logging.\")\n COMMON_FLAG(\n     int, verbosity, 0,\n     \"Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\")\n-COMMON_FLAG(bool, strip_env, 1,\n+COMMON_FLAG(bool, strip_env, true,\n             \"Whether to remove the sanitizer from DYLD_INSERT_LIBRARIES to \"\n-            \"avoid passing it to children. Default is true.\")\n-COMMON_FLAG(bool, detect_leaks, !SANITIZER_MAC, \"Enable memory leak detection.\")\n+            \"avoid passing it to children on Apple platforms. Default is true.\")\n+COMMON_FLAG(bool, verify_interceptors, true,\n+            \"Verify that interceptors are working on Apple platforms. Default \"\n+            \"is true.\")\n+COMMON_FLAG(bool, detect_leaks, !SANITIZER_APPLE, \"Enable memory leak detection.\")\n COMMON_FLAG(\n     bool, leak_check_at_exit, true,\n     \"Invoke leak checking in an atexit handler. Has no effect if \"\n@@ -245,7 +248,7 @@ COMMON_FLAG(bool, decorate_proc_maps, (bool)SANITIZER_ANDROID,\n COMMON_FLAG(int, exitcode, 1, \"Override the program exit status if the tool \"\n                               \"found an error\")\n COMMON_FLAG(\n-    bool, abort_on_error, (bool)SANITIZER_ANDROID || (bool)SANITIZER_MAC,\n+    bool, abort_on_error, (bool)SANITIZER_ANDROID || (bool)SANITIZER_APPLE,\n     \"If set, the tool calls abort() instead of _exit() after printing the \"\n     \"error report.\")\n COMMON_FLAG(bool, suppress_equal_pcs, true,"}, {"sha": "a92e84cb8ecf732a3a2d628c04fb67a4bf9b0fde", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -32,7 +32,7 @@ namespace __sanitizer {\n void NORETURN internal__exit(int exitcode) { _zx_process_exit(exitcode); }\n \n uptr internal_sched_yield() {\n-  zx_status_t status = _zx_nanosleep(0);\n+  zx_status_t status = _zx_thread_legacy_yield(0u);\n   CHECK_EQ(status, ZX_OK);\n   return 0;  // Why doesn't this return void?\n }\n@@ -87,7 +87,6 @@ void GetThreadStackTopAndBottom(bool, uptr *stack_top, uptr *stack_bottom) {\n }\n \n void InitializePlatformEarly() {}\n-void MaybeReexec() {}\n void CheckASLR() {}\n void CheckMPROTECT() {}\n void PlatformPrepareForSandboxing(void *args) {}\n@@ -128,6 +127,8 @@ uptr GetMaxUserVirtualAddress() {\n \n uptr GetMaxVirtualAddress() { return GetMaxUserVirtualAddress(); }\n \n+bool ErrorIsOOM(error_t err) { return err == ZX_ERR_NO_MEMORY; }\n+\n static void *DoAnonymousMmapOrDie(uptr size, const char *mem_type,\n                                   bool raw_report, bool die_for_nomem) {\n   size = RoundUpTo(size, GetPageSize());"}, {"sha": "ad34e5e5ba54ec20e9e334a5844e0c85c40a0fda", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -107,6 +107,26 @@ __sanitizer_cov_trace_gep();\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n __sanitizer_cov_trace_pc_indir();\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_load1();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_load2();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_load4();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_load8();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_load16();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_store1();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_store2();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_store4();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_store8();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_cov_store16();\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n __sanitizer_cov_trace_pc_guard(__sanitizer::u32 *);\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n __sanitizer_cov_trace_pc_guard_init(__sanitizer::u32 *, __sanitizer::u32 *);"}, {"sha": "6b800820ab80b2fa6d79f850d0add5083f103016", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -73,7 +73,7 @@\n // Before Xcode 4.5, the Darwin linker doesn't reliably support undefined\n // weak symbols.  Mac OS X 10.9/Darwin 13 is the first release only supported\n // by Xcode >= 4.5.\n-#elif SANITIZER_MAC && \\\n+#elif SANITIZER_APPLE && \\\n     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090 && !SANITIZER_GO\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n #else\n@@ -139,7 +139,7 @@ namespace __sanitizer {\n typedef unsigned long long uptr;\n typedef signed long long sptr;\n #else\n-#  if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC || SANITIZER_WINDOWS\n+#  if (SANITIZER_WORDSIZE == 64) || SANITIZER_APPLE || SANITIZER_WINDOWS\n typedef unsigned long uptr;\n typedef signed long sptr;\n #  else\n@@ -177,7 +177,7 @@ typedef long pid_t;\n typedef int pid_t;\n #endif\n \n-#if SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_MAC ||             \\\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_APPLE ||             \\\n     (SANITIZER_SOLARIS && (defined(_LP64) || _FILE_OFFSET_BITS == 64)) || \\\n     (SANITIZER_LINUX && !SANITIZER_GLIBC && !SANITIZER_ANDROID) ||        \\\n     (SANITIZER_LINUX && (defined(__x86_64__) || defined(__hexagon__)))\n@@ -187,7 +187,7 @@ typedef uptr OFF_T;\n #endif\n typedef u64  OFF64_T;\n \n-#if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC\n+#if (SANITIZER_WORDSIZE == 64) || SANITIZER_APPLE\n typedef uptr operator_new_size_type;\n #else\n # if defined(__s390__) && !defined(__s390x__)\n@@ -386,13 +386,10 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n enum LinkerInitialized { LINKER_INITIALIZED = 0 };\n \n #if !defined(_MSC_VER) || defined(__clang__)\n-#if SANITIZER_S390_31\n-#define GET_CALLER_PC() \\\n-  (__sanitizer::uptr) __builtin_extract_return_addr(__builtin_return_address(0))\n-#else\n-#define GET_CALLER_PC() (__sanitizer::uptr) __builtin_return_address(0)\n-#endif\n-#define GET_CURRENT_FRAME() (__sanitizer::uptr) __builtin_frame_address(0)\n+#  define GET_CALLER_PC()                              \\\n+    ((__sanitizer::uptr)__builtin_extract_return_addr( \\\n+        __builtin_return_address(0)))\n+#  define GET_CURRENT_FRAME() ((__sanitizer::uptr)__builtin_frame_address(0))\n inline void Trap() {\n   __builtin_trap();\n }\n@@ -401,13 +398,13 @@ extern \"C\" void* _ReturnAddress(void);\n extern \"C\" void* _AddressOfReturnAddress(void);\n # pragma intrinsic(_ReturnAddress)\n # pragma intrinsic(_AddressOfReturnAddress)\n-#define GET_CALLER_PC() (__sanitizer::uptr) _ReturnAddress()\n+#  define GET_CALLER_PC() ((__sanitizer::uptr)_ReturnAddress())\n // CaptureStackBackTrace doesn't need to know BP on Windows.\n-#define GET_CURRENT_FRAME() \\\n-  (((__sanitizer::uptr)_AddressOfReturnAddress()) + sizeof(__sanitizer::uptr))\n+#  define GET_CURRENT_FRAME() \\\n+    (((__sanitizer::uptr)_AddressOfReturnAddress()) + sizeof(__sanitizer::uptr))\n \n extern \"C\" void __ud2(void);\n-# pragma intrinsic(__ud2)\n+#  pragma intrinsic(__ud2)\n inline void Trap() {\n   __ud2();\n }"}, {"sha": "b7fc9444cc66b326c833d2779d928339d027fc32", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -8,7 +8,7 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || \\\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_APPLE || \\\n     SANITIZER_NETBSD\n \n #include \"sanitizer_libignore.h\"\n@@ -125,5 +125,5 @@ void LibIgnore::OnLibraryUnloaded() {\n \n } // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC ||\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_APPLE ||\n         // SANITIZER_NETBSD"}, {"sha": "dc2ea933fadc710916d4bdcfd41a03bd6b3dec0f", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 104, "deletions": 30, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -78,6 +78,10 @@\n #include <sys/personality.h>\n #endif\n \n+#if SANITIZER_LINUX && defined(__loongarch__)\n+#  include <sys/sysmacros.h>\n+#endif\n+\n #if SANITIZER_FREEBSD\n #include <sys/exec.h>\n #include <sys/procctl.h>\n@@ -188,6 +192,8 @@ ScopedBlockSignals::~ScopedBlockSignals() { SetSigProcMask(&saved_, nullptr); }\n #    include \"sanitizer_syscall_linux_arm.inc\"\n #  elif SANITIZER_LINUX && defined(__hexagon__)\n #    include \"sanitizer_syscall_linux_hexagon.inc\"\n+#  elif SANITIZER_LINUX && SANITIZER_LOONGARCH64\n+#    include \"sanitizer_syscall_linux_loongarch64.inc\"\n #  else\n #    include \"sanitizer_syscall_generic.inc\"\n #  endif\n@@ -271,7 +277,7 @@ uptr internal_ftruncate(fd_t fd, uptr size) {\n   return res;\n }\n \n-#if !SANITIZER_LINUX_USES_64BIT_SYSCALLS && SANITIZER_LINUX\n+#if (!SANITIZER_LINUX_USES_64BIT_SYSCALLS || SANITIZER_SPARC) && SANITIZER_LINUX\n static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n   internal_memset(out, 0, sizeof(*out));\n   out->st_dev = in->st_dev;\n@@ -290,6 +296,28 @@ static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n }\n #endif\n \n+#if SANITIZER_LINUX && defined(__loongarch__)\n+static void statx_to_stat(struct statx *in, struct stat *out) {\n+  internal_memset(out, 0, sizeof(*out));\n+  out->st_dev = makedev(in->stx_dev_major, in->stx_dev_minor);\n+  out->st_ino = in->stx_ino;\n+  out->st_mode = in->stx_mode;\n+  out->st_nlink = in->stx_nlink;\n+  out->st_uid = in->stx_uid;\n+  out->st_gid = in->stx_gid;\n+  out->st_rdev = makedev(in->stx_rdev_major, in->stx_rdev_minor);\n+  out->st_size = in->stx_size;\n+  out->st_blksize = in->stx_blksize;\n+  out->st_blocks = in->stx_blocks;\n+  out->st_atime = in->stx_atime.tv_sec;\n+  out->st_atim.tv_nsec = in->stx_atime.tv_nsec;\n+  out->st_mtime = in->stx_mtime.tv_sec;\n+  out->st_mtim.tv_nsec = in->stx_mtime.tv_nsec;\n+  out->st_ctime = in->stx_ctime.tv_sec;\n+  out->st_ctim.tv_nsec = in->stx_ctime.tv_nsec;\n+}\n+#endif\n+\n #if SANITIZER_MIPS64\n // Undefine compatibility macros from <sys/stat.h>\n // so that they would not clash with the kernel_stat\n@@ -341,50 +369,65 @@ static void kernel_stat_to_stat(struct kernel_stat *in, struct stat *out) {\n #endif\n \n uptr internal_stat(const char *path, void *buf) {\n-#if SANITIZER_FREEBSD\n+#  if SANITIZER_FREEBSD\n   return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path, (uptr)buf, 0);\n-#    elif SANITIZER_LINUX\n-#      if SANITIZER_WORDSIZE == 64 || SANITIZER_X32 || \\\n-          (defined(__mips__) && _MIPS_SIM == _ABIN32)\n+#  elif SANITIZER_LINUX\n+#    if defined(__loongarch__)\n+  struct statx bufx;\n+  int res = internal_syscall(SYSCALL(statx), AT_FDCWD, (uptr)path,\n+                             AT_NO_AUTOMOUNT, STATX_BASIC_STATS, (uptr)&bufx);\n+  statx_to_stat(&bufx, (struct stat *)buf);\n+  return res;\n+#    elif (SANITIZER_WORDSIZE == 64 || SANITIZER_X32 ||    \\\n+           (defined(__mips__) && _MIPS_SIM == _ABIN32)) && \\\n+        !SANITIZER_SPARC\n   return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path, (uptr)buf,\n                           0);\n-#      else\n+#    else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(fstatat64), AT_FDCWD, (uptr)path,\n                              (uptr)&buf64, 0);\n   stat64_to_stat(&buf64, (struct stat *)buf);\n   return res;\n-#      endif\n-#    else\n+#    endif\n+#  else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(stat64), path, &buf64);\n   stat64_to_stat(&buf64, (struct stat *)buf);\n   return res;\n-#    endif\n+#  endif\n }\n \n uptr internal_lstat(const char *path, void *buf) {\n-#if SANITIZER_FREEBSD\n+#  if SANITIZER_FREEBSD\n   return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path, (uptr)buf,\n                           AT_SYMLINK_NOFOLLOW);\n-#    elif SANITIZER_LINUX\n-#      if defined(_LP64) || SANITIZER_X32 ||         \\\n-          (defined(__mips__) && _MIPS_SIM == _ABIN32)\n+#  elif SANITIZER_LINUX\n+#    if defined(__loongarch__)\n+  struct statx bufx;\n+  int res = internal_syscall(SYSCALL(statx), AT_FDCWD, (uptr)path,\n+                             AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT,\n+                             STATX_BASIC_STATS, (uptr)&bufx);\n+  statx_to_stat(&bufx, (struct stat *)buf);\n+  return res;\n+#    elif (defined(_LP64) || SANITIZER_X32 ||              \\\n+           (defined(__mips__) && _MIPS_SIM == _ABIN32)) && \\\n+        !SANITIZER_SPARC\n   return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path, (uptr)buf,\n                           AT_SYMLINK_NOFOLLOW);\n-#      else\n+#    else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(fstatat64), AT_FDCWD, (uptr)path,\n                              (uptr)&buf64, AT_SYMLINK_NOFOLLOW);\n   stat64_to_stat(&buf64, (struct stat *)buf);\n   return res;\n-#      endif\n-#    else\n+#    endif\n+#  else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(lstat64), path, &buf64);\n   stat64_to_stat(&buf64, (struct stat *)buf);\n   return res;\n-#    endif\n+#  endif\n }\n \n uptr internal_fstat(fd_t fd, void *buf) {\n@@ -395,9 +438,15 @@ uptr internal_fstat(fd_t fd, void *buf) {\n   int res = internal_syscall(SYSCALL(fstat), fd, &kbuf);\n   kernel_stat_to_stat(&kbuf, (struct stat *)buf);\n   return res;\n-# else\n+#      elif SANITIZER_LINUX && defined(__loongarch__)\n+  struct statx bufx;\n+  int res = internal_syscall(SYSCALL(statx), fd, 0, AT_EMPTY_PATH,\n+                             STATX_BASIC_STATS, (uptr)&bufx);\n+  statx_to_stat(&bufx, (struct stat *)buf);\n+  return res;\n+#      else\n   return internal_syscall(SYSCALL(fstat), fd, (uptr)buf);\n-# endif\n+#      endif\n #else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(fstat64), fd, &buf64);\n@@ -443,15 +492,15 @@ uptr internal_unlink(const char *path) {\n }\n \n uptr internal_rename(const char *oldpath, const char *newpath) {\n-#if defined(__riscv) && defined(__linux__)\n+#  if (defined(__riscv) || defined(__loongarch__)) && defined(__linux__)\n   return internal_syscall(SYSCALL(renameat2), AT_FDCWD, (uptr)oldpath, AT_FDCWD,\n                           (uptr)newpath, 0);\n-#    elif SANITIZER_LINUX\n+#  elif SANITIZER_LINUX\n   return internal_syscall(SYSCALL(renameat), AT_FDCWD, (uptr)oldpath, AT_FDCWD,\n                           (uptr)newpath);\n-#    else\n+#  else\n   return internal_syscall(SYSCALL(rename), (uptr)oldpath, (uptr)newpath);\n-#    endif\n+#  endif\n }\n \n uptr internal_sched_yield() {\n@@ -761,7 +810,14 @@ uptr internal_lseek(fd_t fd, OFF_T offset, int whence) {\n uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5) {\n   return internal_syscall(SYSCALL(prctl), option, arg2, arg3, arg4, arg5);\n }\n-#endif\n+#      if defined(__x86_64__)\n+#        include <asm/unistd_64.h>\n+// Currently internal_arch_prctl() is only needed on x86_64.\n+uptr internal_arch_prctl(int option, uptr arg2) {\n+  return internal_syscall(__NR_arch_prctl, option, arg2);\n+}\n+#      endif\n+#    endif\n \n uptr internal_sigaltstack(const void *ss, void *oss) {\n   return internal_syscall(SYSCALL(sigaltstack), (uptr)ss, (uptr)oss);\n@@ -904,6 +960,10 @@ bool internal_sigismember(__sanitizer_sigset_t *set, int signum) {\n   return k_set->sig[idx] & ((uptr)1 << bit);\n }\n #elif SANITIZER_FREEBSD\n+uptr internal_procctl(int type, int id, int cmd, void *data) {\n+  return internal_syscall(SYSCALL(procctl), type, id, cmd, data);\n+}\n+\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {\n   sigset_t *rset = reinterpret_cast<sigset_t *>(set);\n   sigdelset(rset, signum);\n@@ -1792,7 +1852,7 @@ void *internal_start_thread(void *(*func)(void *), void *arg) { return 0; }\n void internal_join_thread(void *th) {}\n #endif\n \n-#if defined(__aarch64__)\n+#if SANITIZER_LINUX && defined(__aarch64__)\n // Android headers in the older NDK releases miss this definition.\n struct __sanitizer_esr_context {\n   struct _aarch64_ctx head;\n@@ -1813,6 +1873,11 @@ static bool Aarch64GetESR(ucontext_t *ucontext, u64 *esr) {\n   }\n   return false;\n }\n+#elif SANITIZER_FREEBSD && defined(__aarch64__)\n+// FreeBSD doesn't provide ESR in the ucontext.\n+static bool Aarch64GetESR(ucontext_t *ucontext, u64 *esr) {\n+  return false;\n+}\n #endif\n \n using Context = ucontext_t;\n@@ -2038,10 +2103,17 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *bp = ucontext->uc_mcontext.arm_fp;\n   *sp = ucontext->uc_mcontext.arm_sp;\n #elif defined(__aarch64__)\n+# if SANITIZER_FREEBSD\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.mc_gpregs.gp_elr;\n+  *bp = ucontext->uc_mcontext.mc_gpregs.gp_x[29];\n+  *sp = ucontext->uc_mcontext.mc_gpregs.gp_sp;\n+# else\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.pc;\n   *bp = ucontext->uc_mcontext.regs[29];\n   *sp = ucontext->uc_mcontext.sp;\n+# endif\n #elif defined(__hppa__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.sc_iaoq[0];\n@@ -2151,6 +2223,11 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.pc;\n   *bp = ucontext->uc_mcontext.r30;\n   *sp = ucontext->uc_mcontext.r29;\n+#  elif defined(__loongarch__)\n+  ucontext_t *ucontext = (ucontext_t *)context;\n+  *pc = ucontext->uc_mcontext.__pc;\n+  *bp = ucontext->uc_mcontext.__gregs[22];\n+  *sp = ucontext->uc_mcontext.__gregs[3];\n #  else\n #    error \"Unsupported arch\"\n #  endif\n@@ -2162,10 +2239,6 @@ void InitializePlatformEarly() {\n   // Do nothing.\n }\n \n-void MaybeReexec() {\n-  // No need to re-exec on Linux.\n-}\n-\n void CheckASLR() {\n #if SANITIZER_NETBSD\n   int mib[3];\n@@ -2189,7 +2262,8 @@ void CheckASLR() {\n   }\n #elif SANITIZER_FREEBSD\n   int aslr_status;\n-  if (UNLIKELY(procctl(P_PID, 0, PROC_ASLR_STATUS, &aslr_status) == -1)) {\n+  int r = internal_procctl(P_PID, 0, PROC_ASLR_STATUS, &aslr_status);\n+  if (UNLIKELY(r == -1)) {\n     // We're making things less 'dramatic' here since\n     // the cmd is not necessarily guaranteed to be here\n     // just yet regarding FreeBSD release"}, {"sha": "761c57d1b8eb8802c50da49a1bb3c7e9e7b03bac", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -69,6 +69,9 @@ uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp);\n // Linux-only syscalls.\n #if SANITIZER_LINUX\n uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n+#    if defined(__x86_64__)\n+uptr internal_arch_prctl(int option, uptr arg2);\n+#    endif\n // Used only by sanitizer_stoptheworld. Signal handlers that are actually used\n // (like the process-wide error reporting SEGV handler) must use\n // internal_sigaction instead.\n@@ -82,6 +85,7 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n #endif\n int internal_uname(struct utsname *buf);\n #elif SANITIZER_FREEBSD\n+uptr internal_procctl(int type, int id, int cmd, void *data);\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n #elif SANITIZER_NETBSD\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);"}, {"sha": "d74851c43e14e2627d596ee59ce5062f0b348b29", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -421,14 +421,14 @@ __attribute__((unused)) static void GetStaticTlsBoundary(uptr *addr, uptr *size,\n     return;\n   }\n   // Find the maximum consecutive ranges. We consider two modules consecutive if\n-  // the gap is smaller than the alignment. The dynamic loader places static TLS\n-  // blocks this way not to waste space.\n+  // the gap is smaller than the alignment of the latter range. The dynamic\n+  // loader places static TLS blocks this way not to waste space.\n   uptr l = one;\n   *align = ranges[l].align;\n-  while (l != 0 && ranges[l].begin < ranges[l - 1].end + ranges[l - 1].align)\n+  while (l != 0 && ranges[l].begin < ranges[l - 1].end + ranges[l].align)\n     *align = Max(*align, ranges[--l].align);\n   uptr r = one + 1;\n-  while (r != len && ranges[r].begin < ranges[r - 1].end + ranges[r - 1].align)\n+  while (r != len && ranges[r].begin < ranges[r - 1].end + ranges[r].align)\n     *align = Max(*align, ranges[r++].align);\n   *addr = ranges[l].begin;\n   *size = ranges[r - 1].end - ranges[l].begin;\n@@ -822,13 +822,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n "}, {"sha": "1ae69e14b23716784cf86fc72f4b131c9610249a", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 115, "deletions": 96, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -11,7 +11,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #include \"sanitizer_mac.h\"\n #include \"interception/interception.h\"\n \n@@ -38,7 +38,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -71,16 +71,9 @@ extern \"C\" {\n #include <mach/mach_time.h>\n #include <mach/vm_statistics.h>\n #include <malloc/malloc.h>\n-#if defined(__has_builtin) && __has_builtin(__builtin_os_log_format)\n-# include <os/log.h>\n-#else\n-   /* Without support for __builtin_os_log_format, fall back to the older\n-      method.  */\n-# define OS_LOG_DEFAULT 0\n-# define os_log_error(A,B,C) \\\n-  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", (C));\n-#endif\n+#include <os/log.h>\n #include <pthread.h>\n+#include <pthread/introspection.h>\n #include <sched.h>\n #include <signal.h>\n #include <spawn.h>\n@@ -888,6 +881,9 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n #if defined(__x86_64__) || defined(__i386__)\n   ucontext_t *ucontext = static_cast<ucontext_t*>(context);\n   return ucontext->uc_mcontext->__es.__err & 2 /*T_PF_WRITE*/ ? Write : Read;\n+#elif defined(__arm64__)\n+  ucontext_t *ucontext = static_cast<ucontext_t*>(context);\n+  return ucontext->uc_mcontext->__es.__esr & 0x40 /*ISS_DA_WNR*/ ? Write : Read;\n #else\n   return Unknown;\n #endif\n@@ -948,6 +944,9 @@ static void DisableMmapExcGuardExceptions() {\n   set_behavior(mach_task_self(), task_exc_guard_none);\n }\n \n+static void VerifyInterceptorsWorking();\n+static void StripEnv();\n+\n void InitializePlatformEarly() {\n   // Only use xnu_fast_mmap when on x86_64 and the kernel supports it.\n   use_xnu_fast_mmap =\n@@ -958,17 +957,54 @@ void InitializePlatformEarly() {\n #endif\n   if (GetDarwinKernelVersion() >= DarwinKernelVersion(19, 0))\n     DisableMmapExcGuardExceptions();\n+\n+#  if !SANITIZER_GO\n+  MonotonicNanoTime();  // Call to initialize mach_timebase_info\n+  VerifyInterceptorsWorking();\n+  StripEnv();\n+#  endif\n }\n \n #if !SANITIZER_GO\n static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n LowLevelAllocator allocator_for_env;\n \n+static bool ShouldCheckInterceptors() {\n+  // Restrict \"interceptors working?\" check to ASan and TSan.\n+  const char *sanitizer_names[] = {\"AddressSanitizer\", \"ThreadSanitizer\"};\n+  size_t count = sizeof(sanitizer_names) / sizeof(sanitizer_names[0]);\n+  for (size_t i = 0; i < count; i++) {\n+    if (internal_strcmp(sanitizer_names[i], SanitizerToolName) == 0)\n+      return true;\n+  }\n+  return false;\n+}\n+\n+static void VerifyInterceptorsWorking() {\n+  if (!common_flags()->verify_interceptors || !ShouldCheckInterceptors())\n+    return;\n+\n+  // Verify that interceptors really work.  We'll use dlsym to locate\n+  // \"puts\", if interceptors are working, it should really point to\n+  // \"wrap_puts\" within our own dylib.\n+  Dl_info info_puts, info_runtime;\n+  RAW_CHECK(dladdr(dlsym(RTLD_DEFAULT, \"puts\"), &info_puts));\n+  RAW_CHECK(dladdr((void *)__sanitizer_report_error_summary, &info_runtime));\n+  if (internal_strcmp(info_puts.dli_fname, info_runtime.dli_fname) != 0) {\n+    Report(\n+        \"ERROR: Interceptors are not working. This may be because %s is \"\n+        \"loaded too late (e.g. via dlopen). Please launch the executable \"\n+        \"with:\\n%s=%s\\n\",\n+        SanitizerToolName, kDyldInsertLibraries, info_runtime.dli_fname);\n+    RAW_CHECK(\"interceptors not installed\" && 0);\n+  }\n+}\n+\n // Change the value of the env var |name|, leaking the original value.\n // If |name_value| is NULL, the variable is deleted from the environment,\n // otherwise the corresponding \"NAME=value\" string is replaced with\n // |name_value|.\n-void LeakyResetEnv(const char *name, const char *name_value) {\n+static void LeakyResetEnv(const char *name, const char *name_value) {\n   char **env = GetEnviron();\n   uptr name_len = internal_strlen(name);\n   while (*env != 0) {\n@@ -993,100 +1029,28 @@ void LeakyResetEnv(const char *name, const char *name_value) {\n   }\n }\n \n-SANITIZER_WEAK_CXX_DEFAULT_IMPL\n-bool ReexecDisabled() {\n-  return false;\n-}\n-\n-static bool DyldNeedsEnvVariable() {\n-  // If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if\n-  // DYLD_INSERT_LIBRARIES is not set.\n-  return GetMacosAlignedVersion() < MacosVersion(10, 11);\n-}\n-\n-void MaybeReexec() {\n-  // FIXME: This should really live in some \"InitializePlatform\" method.\n-  MonotonicNanoTime();\n+static void StripEnv() {\n+  if (!common_flags()->strip_env)\n+    return;\n \n-  if (ReexecDisabled()) return;\n+  char *dyld_insert_libraries =\n+      const_cast<char *>(GetEnv(kDyldInsertLibraries));\n+  if (!dyld_insert_libraries)\n+    return;\n \n-  // Make sure the dynamic runtime library is preloaded so that the\n-  // wrappers work. If it is not, set DYLD_INSERT_LIBRARIES and re-exec\n-  // ourselves.\n   Dl_info info;\n-  RAW_CHECK(dladdr((void*)((uptr)&__sanitizer_report_error_summary), &info));\n-  char *dyld_insert_libraries =\n-      const_cast<char*>(GetEnv(kDyldInsertLibraries));\n-  uptr old_env_len = dyld_insert_libraries ?\n-      internal_strlen(dyld_insert_libraries) : 0;\n-  uptr fname_len = internal_strlen(info.dli_fname);\n+  RAW_CHECK(dladdr((void *)__sanitizer_report_error_summary, &info));\n   const char *dylib_name = StripModuleName(info.dli_fname);\n-  uptr dylib_name_len = internal_strlen(dylib_name);\n-\n-  bool lib_is_in_env = dyld_insert_libraries &&\n-                       internal_strstr(dyld_insert_libraries, dylib_name);\n-  if (DyldNeedsEnvVariable() && !lib_is_in_env) {\n-    // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n-    // library.\n-    InternalMmapVector<char> program_name(1024);\n-    uint32_t buf_size = program_name.size();\n-    _NSGetExecutablePath(program_name.data(), &buf_size);\n-    char *new_env = const_cast<char*>(info.dli_fname);\n-    if (dyld_insert_libraries) {\n-      // Append the runtime dylib name to the existing value of\n-      // DYLD_INSERT_LIBRARIES.\n-      new_env = (char*)allocator_for_env.Allocate(old_env_len + fname_len + 2);\n-      internal_strncpy(new_env, dyld_insert_libraries, old_env_len);\n-      new_env[old_env_len] = ':';\n-      // Copy fname_len and add a trailing zero.\n-      internal_strncpy(new_env + old_env_len + 1, info.dli_fname,\n-                       fname_len + 1);\n-      // Ok to use setenv() since the wrappers don't depend on the value of\n-      // asan_inited.\n-      setenv(kDyldInsertLibraries, new_env, /*overwrite*/1);\n-    } else {\n-      // Set DYLD_INSERT_LIBRARIES equal to the runtime dylib name.\n-      setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n-    }\n-    VReport(1, \"exec()-ing the program with\\n\");\n-    VReport(1, \"%s=%s\\n\", kDyldInsertLibraries, new_env);\n-    VReport(1, \"to enable wrappers.\\n\");\n-    execv(program_name.data(), *_NSGetArgv());\n-\n-    // We get here only if execv() failed.\n-    Report(\"ERROR: The process is launched without DYLD_INSERT_LIBRARIES, \"\n-           \"which is required for the sanitizer to work. We tried to set the \"\n-           \"environment variable and re-execute itself, but execv() failed, \"\n-           \"possibly because of sandbox restrictions. Make sure to launch the \"\n-           \"executable with:\\n%s=%s\\n\", kDyldInsertLibraries, new_env);\n-    RAW_CHECK(\"execv failed\" && 0);\n-  }\n-\n-  // Verify that interceptors really work.  We'll use dlsym to locate\n-  // \"puts\", if interceptors are working, it should really point to\n-  // \"wrap_puts\" within our own dylib.\n-  Dl_info info_puts;\n-  void *dlopen_addr = dlsym(RTLD_DEFAULT, \"puts\");\n-  RAW_CHECK(dladdr(dlopen_addr, &info_puts));\n-  if (internal_strcmp(info.dli_fname, info_puts.dli_fname) != 0) {\n-    Report(\n-        \"ERROR: Interceptors are not working. This may be because %s is \"\n-        \"loaded too late (e.g. via dlopen). Please launch the executable \"\n-        \"with:\\n%s=%s\\n\",\n-        SanitizerToolName, kDyldInsertLibraries, info.dli_fname);\n-    RAW_CHECK(\"interceptors not installed\" && 0);\n-  }\n-\n+  bool lib_is_in_env = internal_strstr(dyld_insert_libraries, dylib_name);\n   if (!lib_is_in_env)\n     return;\n \n-  if (!common_flags()->strip_env)\n-    return;\n-\n   // DYLD_INSERT_LIBRARIES is set and contains the runtime library. Let's remove\n   // the dylib from the environment variable, because interceptors are installed\n   // and we don't want our children to inherit the variable.\n \n+  uptr old_env_len = internal_strlen(dyld_insert_libraries);\n+  uptr dylib_name_len = internal_strlen(dylib_name);\n   uptr env_name_len = internal_strlen(kDyldInsertLibraries);\n   // Allocate memory to hold the previous env var name, its value, the '='\n   // sign and the '\\0' char.\n@@ -1432,6 +1396,61 @@ u32 GetNumberOfCPUs() {\n \n void InitializePlatformCommonFlags(CommonFlags *cf) {}\n \n+// Pthread introspection hook\n+//\n+// * GCD worker threads are created without a call to pthread_create(), but we\n+//   still need to register these threads (with ThreadCreate/Start()).\n+// * We use the \"pthread introspection hook\" below to observe the creation of\n+//   such threads.\n+// * GCD worker threads don't have parent threads and the CREATE event is\n+//   delivered in the context of the thread itself.  CREATE events for regular\n+//   threads, are delivered on the parent.  We use this to tell apart which\n+//   threads are GCD workers with `thread == pthread_self()`.\n+//\n+static pthread_introspection_hook_t prev_pthread_introspection_hook;\n+static ThreadEventCallbacks thread_event_callbacks;\n+\n+static void sanitizer_pthread_introspection_hook(unsigned int event,\n+                                                 pthread_t thread, void *addr,\n+                                                 size_t size) {\n+  // create -> start -> terminate -> destroy\n+  // * create/destroy are usually (not guaranteed) delivered on the parent and\n+  //   track resource allocation/reclamation\n+  // * start/terminate are guaranteed to be delivered in the context of the\n+  //   thread and give hooks into \"just after (before) thread starts (stops)\n+  //   executing\"\n+  DCHECK(event >= PTHREAD_INTROSPECTION_THREAD_CREATE &&\n+         event <= PTHREAD_INTROSPECTION_THREAD_DESTROY);\n+\n+  if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) {\n+    bool gcd_worker = (thread == pthread_self());\n+    if (thread_event_callbacks.create)\n+      thread_event_callbacks.create((uptr)thread, gcd_worker);\n+  } else if (event == PTHREAD_INTROSPECTION_THREAD_START) {\n+    CHECK_EQ(thread, pthread_self());\n+    if (thread_event_callbacks.start)\n+      thread_event_callbacks.start((uptr)thread);\n+  }\n+\n+  if (prev_pthread_introspection_hook)\n+    prev_pthread_introspection_hook(event, thread, addr, size);\n+\n+  if (event == PTHREAD_INTROSPECTION_THREAD_TERMINATE) {\n+    CHECK_EQ(thread, pthread_self());\n+    if (thread_event_callbacks.terminate)\n+      thread_event_callbacks.terminate((uptr)thread);\n+  } else if (event == PTHREAD_INTROSPECTION_THREAD_DESTROY) {\n+    if (thread_event_callbacks.destroy)\n+      thread_event_callbacks.destroy((uptr)thread);\n+  }\n+}\n+\n+void InstallPthreadIntrospectionHook(const ThreadEventCallbacks &callbacks) {\n+  thread_event_callbacks = callbacks;\n+  prev_pthread_introspection_hook =\n+      pthread_introspection_hook_install(&sanitizer_pthread_introspection_hook);\n+}\n+\n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "f0a97d098eea0e544deb96a50f2e69635e7a665d", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -9,32 +9,12 @@\n // This file is shared between various sanitizers' runtime libraries and\n // provides definitions for OSX-specific functions.\n //===----------------------------------------------------------------------===//\n-#ifndef SANITIZER_MAC_H\n-#define SANITIZER_MAC_H\n+#ifndef SANITIZER_APPLE_H\n+#define SANITIZER_APPLE_H\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_platform.h\"\n-\n-/* TARGET_OS_OSX is not present in SDKs before Darwin16 (macOS 10.12) use\n-   TARGET_OS_MAC (we have no support for iOS in any form for these versions,\n-   so there's no ambiguity).  */\n-#if !defined(TARGET_OS_OSX) && TARGET_OS_MAC\n-# define TARGET_OS_OSX 1\n-#endif\n-\n-/* Other TARGET_OS_xxx are not present on earlier versions, define them to\n-   0 (we have no support for them; they are not valid targets anyway).  */\n-#ifndef TARGET_OS_IOS\n-#define TARGET_OS_IOS 0\n-#endif\n-#ifndef TARGET_OS_TV\n-#define TARGET_OS_TV 0\n-#endif\n-#ifndef TARGET_OS_WATCH\n-#define TARGET_OS_WATCH 0\n-#endif\n-\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #include \"sanitizer_posix.h\"\n \n namespace __sanitizer {\n@@ -82,7 +62,18 @@ char **GetEnviron();\n \n void RestrictMemoryToMaxAddress(uptr max_address);\n \n+using ThreadEventCallback = void (*)(uptr thread);\n+using ThreadCreateEventCallback = void (*)(uptr thread, bool gcd_worker);\n+struct ThreadEventCallbacks {\n+  ThreadCreateEventCallback create;\n+  ThreadEventCallback start;\n+  ThreadEventCallback terminate;\n+  ThreadEventCallback destroy;\n+};\n+\n+void InstallPthreadIntrospectionHook(const ThreadEventCallbacks &callbacks);\n+\n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_MAC\n-#endif  // SANITIZER_MAC_H\n+#endif  // SANITIZER_APPLE\n+#endif  // SANITIZER_APPLE_H"}, {"sha": "b452dc4a49e23581a6213a48ae1a4c60ec5ba065", "filename": "libsanitizer/sanitizer_common/sanitizer_mac_libcdep.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -11,7 +11,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #include \"sanitizer_mac.h\"\n \n #include <sys/mman.h>\n@@ -26,4 +26,4 @@ void RestrictMemoryToMaxAddress(uptr max_address) {\n \n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "fe76b3f8aa05144a8486be515199a97cdb9842b7", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n #error \"This file should only be compiled on Darwin.\"\n #endif\n "}, {"sha": "b1a58e421d81a5e1da1baf5a9960c6265d14182a", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -101,7 +101,7 @@ enum {\n // THREADLOCAL variables they are not usable early on during process init when\n // `__sanitizer::Mutex` is used.\n #define SANITIZER_CHECK_DEADLOCKS \\\n-  (SANITIZER_DEBUG && !SANITIZER_GO && SANITIZER_SUPPORTS_THREADLOCAL && !SANITIZER_MAC)\n+  (SANITIZER_DEBUG && !SANITIZER_GO && SANITIZER_SUPPORTS_THREADLOCAL && !SANITIZER_APPLE)\n \n #if SANITIZER_CHECK_DEADLOCKS\n struct MutexMeta {"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libsanitizer/sanitizer_common/sanitizer_openbsd.cpp", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdd3547ae4279c14a9db883719c9648ed09dc18a/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdd3547ae4279c14a9db883719c9648ed09dc18a/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp?ref=bdd3547ae4279c14a9db883719c9648ed09dc18a"}, {"sha": "32005eef08cd5ed3e12d5199cd5383570862cccc", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -55,8 +55,15 @@\n #  define SANITIZER_SOLARIS 0\n #endif\n \n+// - SANITIZER_APPLE: all Apple code\n+//   - TARGET_OS_OSX: macOS\n+//   - SANITIZER_IOS: devices (iOS and iOS-like)\n+//     - SANITIZER_WATCHOS\n+//     - SANITIZER_TVOS\n+//   - SANITIZER_IOSSIM: simulators (iOS and iOS-like)\n+//   - SANITIZER_DRIVERKIT\n #if defined(__APPLE__)\n-#  define SANITIZER_MAC 1\n+#  define SANITIZER_APPLE 1\n #  include <TargetConditionals.h>\n #  if TARGET_OS_OSX\n #    define SANITIZER_OSX 1\n@@ -68,28 +75,34 @@\n #  else\n #    define SANITIZER_IOS 0\n #  endif\n+#  if TARGET_OS_WATCH\n+#    define SANITIZER_WATCHOS 1\n+#  else\n+#    define SANITIZER_WATCHOS 0\n+#  endif\n+#  if TARGET_OS_TV\n+#    define SANITIZER_TVOS 1\n+#  else\n+#    define SANITIZER_TVOS 0\n+#  endif\n #  if TARGET_OS_SIMULATOR\n #    define SANITIZER_IOSSIM 1\n #  else\n #    define SANITIZER_IOSSIM 0\n #  endif\n+#  if defined(TARGET_OS_DRIVERKIT) && TARGET_OS_DRIVERKIT\n+#    define SANITIZER_DRIVERKIT 1\n+#  else\n+#    define SANITIZER_DRIVERKIT 0\n+#  endif\n #else\n-#  define SANITIZER_MAC 0\n-#  define SANITIZER_IOS 0\n-#  define SANITIZER_IOSSIM 0\n+#  define SANITIZER_APPLE 0\n #  define SANITIZER_OSX 0\n-#endif\n-\n-#if defined(__APPLE__) && TARGET_OS_IPHONE && TARGET_OS_WATCH\n-#  define SANITIZER_WATCHOS 1\n-#else\n+#  define SANITIZER_IOS 0\n #  define SANITIZER_WATCHOS 0\n-#endif\n-\n-#if defined(__APPLE__) && TARGET_OS_IPHONE && TARGET_OS_TV\n-#  define SANITIZER_TVOS 1\n-#else\n #  define SANITIZER_TVOS 0\n+#  define SANITIZER_IOSSIM 0\n+#  define SANITIZER_DRIVERKIT 0\n #endif\n \n #if defined(_WIN32)\n@@ -124,7 +137,7 @@\n #endif\n \n #define SANITIZER_POSIX                                     \\\n-  (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || \\\n+  (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_APPLE || \\\n    SANITIZER_NETBSD || SANITIZER_SOLARIS)\n \n #if __LP64__ || defined(_WIN64)\n@@ -187,6 +200,21 @@\n #  define SANITIZER_S390_64 0\n #endif\n \n+#if defined(__sparc__)\n+#  define SANITIZER_SPARC 1\n+#  if defined(__arch64__)\n+#    define SANITIZER_SPARC32 0\n+#    define SANITIZER_SPARC64 1\n+#  else\n+#    define SANITIZER_SPARC32 1\n+#    define SANITIZER_SPARC64 0\n+#  endif\n+#else\n+#  define SANITIZER_SPARC 0\n+#  define SANITIZER_SPARC32 0\n+#  define SANITIZER_SPARC64 0\n+#endif\n+\n #if defined(__powerpc__)\n #  define SANITIZER_PPC 1\n #  if defined(__powerpc64__)\n@@ -244,6 +272,12 @@\n #  define SANITIZER_RISCV64 0\n #endif\n \n+#if defined(__loongarch_lp64)\n+#  define SANITIZER_LOONGARCH64 1\n+#else\n+#  define SANITIZER_LOONGARCH64 0\n+#endif\n+\n // By default we allow to use SizeClassAllocator64 on 64-bit platform.\n // But in some cases (e.g. AArch64's 39-bit address space) SizeClassAllocator64\n // does not work well and we need to fallback to SizeClassAllocator32.\n@@ -252,7 +286,8 @@\n #ifndef SANITIZER_CAN_USE_ALLOCATOR64\n #  if (SANITIZER_ANDROID && defined(__aarch64__)) || SANITIZER_FUCHSIA\n #    define SANITIZER_CAN_USE_ALLOCATOR64 1\n-#  elif defined(__mips64) || defined(__aarch64__)\n+#  elif defined(__mips64) || defined(__aarch64__) || defined(__i386__) || \\\n+      defined(__arm__) || SANITIZER_RISCV64 || defined(__hexagon__)\n #    define SANITIZER_CAN_USE_ALLOCATOR64 0\n #  else\n #    define SANITIZER_CAN_USE_ALLOCATOR64 (SANITIZER_WORDSIZE == 64)\n@@ -271,7 +306,7 @@\n #elif SANITIZER_RISCV64\n #  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 38)\n #elif defined(__aarch64__)\n-#  if SANITIZER_MAC\n+#  if SANITIZER_APPLE\n #    if SANITIZER_OSX || SANITIZER_IOSSIM\n #      define SANITIZER_MMAP_RANGE_SIZE \\\n         FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)\n@@ -328,7 +363,7 @@\n #  define MSC_PREREQ(version) 0\n #endif\n \n-#if SANITIZER_MAC && defined(__x86_64__)\n+#if SANITIZER_APPLE && defined(__x86_64__)\n #  define SANITIZER_NON_UNIQUE_TYPEINFO 0\n #else\n #  define SANITIZER_NON_UNIQUE_TYPEINFO 1\n@@ -356,7 +391,7 @@\n #  define SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT 0\n #endif\n \n-#if SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_NETBSD || SANITIZER_SOLARIS\n+#if SANITIZER_FREEBSD || SANITIZER_APPLE || SANITIZER_NETBSD || SANITIZER_SOLARIS\n #  define SANITIZER_MADVISE_DONTNEED MADV_FREE\n #else\n #  define SANITIZER_MADVISE_DONTNEED MADV_DONTNEED\n@@ -380,7 +415,7 @@\n // Enable ability to support sanitizer initialization that is\n // compatible with the sanitizer library being loaded via\n // `dlopen()`.\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #  define SANITIZER_SUPPORTS_INIT_FOR_DLOPEN 1\n #else\n #  define SANITIZER_SUPPORTS_INIT_FOR_DLOPEN 0"}, {"sha": "6e3081ec1fcca68ac7d00a3e6b5b29ffdb21974d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -76,7 +76,7 @@\n #define SI_LINUX 0\n #endif\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #define SI_MAC 1\n #define SI_NOT_MAC 0\n #else\n@@ -126,7 +126,7 @@\n #define SI_SOLARIS32 0\n #endif\n \n-#if SANITIZER_POSIX && !SANITIZER_MAC\n+#if SANITIZER_POSIX && !SANITIZER_APPLE\n #define SI_POSIX_NOT_MAC 1\n #else\n #define SI_POSIX_NOT_MAC 0\n@@ -236,6 +236,7 @@\n #define SANITIZER_INTERCEPT_GLOB (SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GLOB64 SI_GLIBC\n #define SANITIZER_INTERCEPT___B64_TO SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_DN_COMP_EXPAND SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_POSIX_SPAWN SI_POSIX\n #define SANITIZER_INTERCEPT_WAIT SI_POSIX\n #define SANITIZER_INTERCEPT_INET SI_POSIX\n@@ -329,8 +330,7 @@\n #define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATFS \\\n   (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n-#define SANITIZER_INTERCEPT_STATFS64 \\\n-  (((SI_MAC && !TARGET_CPU_ARM64) && !SI_IOS) || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_STATFS64 SI_LINUX_NOT_ANDROID && SANITIZER_HAS_STATFS64\n #define SANITIZER_INTERCEPT_STATVFS \\\n   (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n@@ -347,6 +347,7 @@\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_GLIBC\n+#define SANITIZER_INTERCEPT_PTHREAD_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET_SCHED SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED \\\n   (SI_POSIX && !SI_NETBSD)\n@@ -466,7 +467,7 @@\n #define SANITIZER_INTERCEPT_STAT                                        \\\n   (SI_FREEBSD || SI_MAC || SI_ANDROID || SI_NETBSD || SI_SOLARIS ||     \\\n    SI_STAT_LINUX)\n-#define SANITIZER_INTERCEPT_STAT64 SI_STAT_LINUX\n+#define SANITIZER_INTERCEPT_STAT64 SI_STAT_LINUX && SANITIZER_HAS_STAT64\n #define SANITIZER_INTERCEPT_LSTAT (SI_NETBSD || SI_FREEBSD || SI_STAT_LINUX)\n #define SANITIZER_INTERCEPT___XSTAT \\\n   ((!SANITIZER_INTERCEPT_STAT && SI_POSIX) || SI_STAT_LINUX)\n@@ -587,10 +588,11 @@\n // sigaltstack on i386 macOS cannot be intercepted due to setjmp()\n // calling it and assuming that it does not clobber registers.\n #define SANITIZER_INTERCEPT_SIGALTSTACK \\\n-  (SI_POSIX && !(SANITIZER_MAC && SANITIZER_I386))\n+  (SI_POSIX && !(SANITIZER_APPLE && SANITIZER_I386))\n #define SANITIZER_INTERCEPT_UNAME (SI_POSIX && !SI_FREEBSD)\n #define SANITIZER_INTERCEPT___XUNAME SI_FREEBSD\n #define SANITIZER_INTERCEPT_FLOPEN SI_FREEBSD\n+#define SANITIZER_INTERCEPT_PROCCTL SI_FREEBSD\n \n // This macro gives a way for downstream users to override the above\n // interceptor macros irrespective of the platform they are on. They have"}, {"sha": "37e72cd5d45eac92f72c6784ee3518e4ab3e3d99", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -205,6 +205,10 @@ unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n+unsigned struct_procctl_reaper_status_sz = sizeof(struct __sanitizer_procctl_reaper_status);\n+unsigned struct_procctl_reaper_pidinfo_sz = sizeof(struct __sanitizer_procctl_reaper_pidinfo);\n+unsigned struct_procctl_reaper_pids_sz = sizeof(struct __sanitizer_procctl_reaper_pids);\n+unsigned struct_procctl_reaper_kill_sz = sizeof(struct __sanitizer_procctl_reaper_kill);\n const unsigned long __sanitizer_bufsiz = BUFSIZ;\n \n const unsigned IOCTL_NOT_PRESENT = 0;"}, {"sha": "daef1177a2dba6d0c7bf5312f73782009a7fdbe0", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -424,6 +424,38 @@ struct __sanitizer__ttyent {\n   char *ty_group;\n };\n \n+// procctl reaper data for PROCCTL_REAPER flags\n+struct __sanitizer_procctl_reaper_status {\n+  unsigned int rs_flags;\n+  unsigned int rs_children;\n+  unsigned int rs_descendants;\n+  pid_t rs_reaper;\n+  pid_t rs_pid;\n+  unsigned int rs_pad0[15];\n+};\n+\n+struct __sanitizer_procctl_reaper_pidinfo {\n+  pid_t pi_pid;\n+  pid_t pi_subtree;\n+  unsigned int pi_flags;\n+  unsigned int pi_pad0[15];\n+};\n+\n+struct __sanitizer_procctl_reaper_pids {\n+  unsigned int rp_count;\n+  unsigned int rp_pad0[15];\n+  struct __sanitize_procctl_reapper_pidinfo *rp_pids;\n+};\n+\n+struct __sanitizer_procctl_reaper_kill {\n+  int rk_sig;\n+  unsigned int rk_flags;\n+  pid_t rk_subtree;\n+  unsigned int rk_killed;\n+  pid_t rk_fpid;\n+  unsigned int rk_pad[15];\n+};\n+\n #  define IOC_NRBITS 8\n #  define IOC_TYPEBITS 8\n #  if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__)\n@@ -480,6 +512,11 @@ extern unsigned struct_ppp_stats_sz;\n extern unsigned struct_sioc_sg_req_sz;\n extern unsigned struct_sioc_vif_req_sz;\n \n+extern unsigned struct_procctl_reaper_status_sz;\n+extern unsigned struct_procctl_reaper_pidinfo_sz;\n+extern unsigned struct_procctl_reaper_pids_sz;\n+extern unsigned struct_procctl_reaper_kill_sz;\n+\n // ioctl request identifiers\n \n // A special value to mark ioctls that are not present on the target platform,"}, {"sha": "bf0f355847cb13332fac82fb756fe2afa068991a", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -26,10 +26,7 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n #  if defined(__x86_64__) || defined(__mips__) || defined(__hexagon__)\n #    include <sys/stat.h>\n@@ -60,15 +57,10 @@\n \n using namespace __sanitizer;\n \n-namespace __sanitizer {\n-#if !SANITIZER_ANDROID\n-  unsigned struct_statfs64_sz = sizeof(struct statfs64);\n-#endif\n-}  // namespace __sanitizer\n-\n #  if !defined(__powerpc64__) && !defined(__x86_64__) &&                   \\\n       !defined(__aarch64__) && !defined(__mips__) && !defined(__s390__) && \\\n-      !defined(__sparc__) && !defined(__riscv) && !defined(__hexagon__)\n+      !defined(__sparc__) && !defined(__riscv) && !defined(__hexagon__) && \\\n+      !defined(__loongarch__)\n COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));\n #endif\n "}, {"sha": "c85cf1626a75b1b0d43fc6f3026e3b87fb6bcb15", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -23,7 +23,7 @@\n // Must go after undef _FILE_OFFSET_BITS.\n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_LINUX || SANITIZER_APPLE\n // Must go after undef _FILE_OFFSET_BITS.\n #include \"sanitizer_glibc_version.h\"\n \n@@ -51,7 +51,7 @@\n #include <time.h>\n #include <wchar.h>\n #include <regex.h>\n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n #include <utmp.h>\n #endif\n \n@@ -154,7 +154,6 @@ typedef struct user_fpregs elf_fpregset_t;\n #include <linux/serial.h>\n #include <sys/msg.h>\n #include <sys/ipc.h>\n-#include <crypt.h>\n #endif  // SANITIZER_ANDROID\n \n #include <link.h>\n@@ -165,7 +164,7 @@ typedef struct user_fpregs elf_fpregset_t;\n #include <fstab.h>\n #endif // SANITIZER_LINUX\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #include <net/ethernet.h>\n #include <sys/filio.h>\n #include <sys/sockio.h>\n@@ -174,14 +173,19 @@ typedef struct user_fpregs elf_fpregset_t;\n // Include these after system headers to avoid name clashes and ambiguities.\n #  include \"sanitizer_common.h\"\n #  include \"sanitizer_internal_defs.h\"\n+#  include \"sanitizer_platform_interceptors.h\"\n #  include \"sanitizer_platform_limits_posix.h\"\n \n+#if SANITIZER_INTERCEPT_CRYPT_R\n+#include <crypt.h>\n+#endif\n+\n namespace __sanitizer {\n   unsigned struct_utsname_sz = sizeof(struct utsname);\n   unsigned struct_stat_sz = sizeof(struct stat);\n-#if !SANITIZER_IOS && !(SANITIZER_MAC && TARGET_CPU_ARM64)\n+#if SANITIZER_HAS_STAT64\n   unsigned struct_stat64_sz = sizeof(struct stat64);\n-#endif // !SANITIZER_IOS && !(SANITIZER_MAC && TARGET_CPU_ARM64)\n+#endif // SANITIZER_HAS_STAT64\n   unsigned struct_rusage_sz = sizeof(struct rusage);\n   unsigned struct_tm_sz = sizeof(struct tm);\n   unsigned struct_passwd_sz = sizeof(struct passwd);\n@@ -206,14 +210,14 @@ namespace __sanitizer {\n   unsigned struct_regex_sz = sizeof(regex_t);\n   unsigned struct_regmatch_sz = sizeof(regmatch_t);\n \n-#if (SANITIZER_MAC && !TARGET_CPU_ARM64) && !SANITIZER_IOS\n+#if SANITIZER_HAS_STATFS64\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n-#endif // (SANITIZER_MAC && !TARGET_CPU_ARM64) && !SANITIZER_IOS\n+#endif // SANITIZER_HAS_STATFS64\n \n-#if SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_MAC\n+#if SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_APPLE\n   unsigned struct_fstab_sz = sizeof(struct fstab);\n #endif  // SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD ||\n-        // SANITIZER_MAC\n+        // SANITIZER_APPLE\n #if !SANITIZER_ANDROID\n   unsigned struct_statfs_sz = sizeof(struct statfs);\n   unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n@@ -267,15 +271,22 @@ namespace __sanitizer {\n         defined(__powerpc__) || defined(__s390__) || defined(__sparc__) || \\\n         defined(__hexagon__)\n #      define SIZEOF_STRUCT_USTAT 20\n+#    elif defined(__loongarch__)\n+  // Not used. The minimum Glibc version available for LoongArch is 2.36\n+  // so ustat() wrapper is already gone.\n+#      define SIZEOF_STRUCT_USTAT 0\n #    else\n #      error Unknown size of struct ustat\n #    endif\n   unsigned struct_ustat_sz = SIZEOF_STRUCT_USTAT;\n   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);\n   unsigned struct_statvfs64_sz = sizeof(struct statvfs64);\n-  unsigned struct_crypt_data_sz = sizeof(struct crypt_data);\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n+#if SANITIZER_INTERCEPT_CRYPT_R\n+  unsigned struct_crypt_data_sz = sizeof(struct crypt_data);\n+#endif\n+\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_timex_sz = sizeof(struct timex);\n   unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n@@ -302,7 +313,7 @@ namespace __sanitizer {\n   int shmctl_shm_stat = (int)SHM_STAT;\n #endif\n \n-#if !SANITIZER_MAC && !SANITIZER_FREEBSD\n+#if !SANITIZER_APPLE && !SANITIZER_FREEBSD\n   unsigned struct_utmp_sz = sizeof(struct utmp);\n #endif\n #if !SANITIZER_ANDROID\n@@ -510,7 +521,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n #endif  // SANITIZER_GLIBC\n \n-#if !SANITIZER_ANDROID && !SANITIZER_MAC\n+#if !SANITIZER_ANDROID && !SANITIZER_APPLE\n   unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n   unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n #endif\n@@ -1069,7 +1080,7 @@ CHECK_SIZE_AND_OFFSET(mmsghdr, msg_len);\n \n COMPILER_CHECK(sizeof(__sanitizer_dirent) <= sizeof(dirent));\n CHECK_SIZE_AND_OFFSET(dirent, d_ino);\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n CHECK_SIZE_AND_OFFSET(dirent, d_seekoff);\n #elif SANITIZER_FREEBSD\n // There is no 'd_off' field on FreeBSD.\n@@ -1251,7 +1262,7 @@ CHECK_SIZE_AND_OFFSET(passwd, pw_shell);\n CHECK_SIZE_AND_OFFSET(passwd, pw_gecos);\n #endif\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n CHECK_SIZE_AND_OFFSET(passwd, pw_change);\n CHECK_SIZE_AND_OFFSET(passwd, pw_expire);\n CHECK_SIZE_AND_OFFSET(passwd, pw_class);\n@@ -1264,7 +1275,7 @@ CHECK_SIZE_AND_OFFSET(group, gr_passwd);\n CHECK_SIZE_AND_OFFSET(group, gr_gid);\n CHECK_SIZE_AND_OFFSET(group, gr_mem);\n \n-#if HAVE_RPC_XDR_H\n+#if HAVE_RPC_XDR_H && !SANITIZER_APPLE\n CHECK_TYPE_SIZE(XDR);\n CHECK_SIZE_AND_OFFSET(XDR, x_op);\n CHECK_SIZE_AND_OFFSET(XDR, x_ops);\n@@ -1319,4 +1330,4 @@ CHECK_TYPE_SIZE(sem_t);\n COMPILER_CHECK(ARM_VFPREGS_SIZE == ARM_VFPREGS_SIZE_ASAN);\n #endif\n \n-#endif // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_APPLE"}, {"sha": "bd5692ed511b2970bdac0efbb4954cdbdad3c164", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -14,11 +14,26 @@\n #ifndef SANITIZER_PLATFORM_LIMITS_POSIX_H\n #define SANITIZER_PLATFORM_LIMITS_POSIX_H\n \n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_LINUX || SANITIZER_APPLE\n \n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n+#if SANITIZER_APPLE\n+#include <sys/cdefs.h>\n+#if !__DARWIN_ONLY_64_BIT_INO_T\n+#define SANITIZER_HAS_STAT64 1\n+#define SANITIZER_HAS_STATFS64 1\n+#else\n+#define SANITIZER_HAS_STAT64 0\n+#define SANITIZER_HAS_STATFS64 0\n+#endif\n+#else\n+// Must be SANITIZER_LINUX then\n+#define SANITIZER_HAS_STAT64 1\n+#define SANITIZER_HAS_STATFS64 1\n+#endif\n+\n #if defined(__sparc__)\n // FIXME: This can't be included from tsan which does not support sparc yet.\n #include \"sanitizer_glibc_version.h\"\n@@ -29,7 +44,7 @@\n namespace __sanitizer {\n extern unsigned struct_utsname_sz;\n extern unsigned struct_stat_sz;\n-#if !SANITIZER_IOS\n+#if SANITIZER_HAS_STAT64\n extern unsigned struct_stat64_sz;\n #endif\n extern unsigned struct_rusage_sz;\n@@ -49,7 +64,9 @@ extern unsigned struct_itimerspec_sz;\n extern unsigned struct_sigevent_sz;\n extern unsigned struct_stack_t_sz;\n extern unsigned struct_sched_param_sz;\n+#if SANITIZER_HAS_STATFS64\n extern unsigned struct_statfs64_sz;\n+#endif\n extern unsigned struct_regex_sz;\n extern unsigned struct_regmatch_sz;\n \n@@ -106,6 +123,9 @@ const unsigned struct_kernel_stat64_sz = 0;  // RISCV64 does not use stat64\n #    elif defined(__hexagon__)\n const unsigned struct_kernel_stat_sz = 128;\n const unsigned struct_kernel_stat64_sz = 0;\n+#    elif defined(__loongarch__)\n+const unsigned struct_kernel_stat_sz = 128;\n+const unsigned struct_kernel_stat64_sz = 0;\n #    endif\n struct __sanitizer_perf_event_attr {\n   unsigned type;\n@@ -126,7 +146,7 @@ const unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n \n #if SANITIZER_LINUX\n \n-#if defined(__powerpc64__) || defined(__s390__)\n+#if defined(__powerpc64__) || defined(__s390__) || defined(__loongarch__)\n const unsigned struct___old_kernel_stat_sz = 0;\n #elif !defined(__sparc__)\n const unsigned struct___old_kernel_stat_sz = 32;\n@@ -323,7 +343,7 @@ struct __sanitizer_ifaddrs {\n };\n #endif  // !SANITIZER_ANDROID\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n typedef unsigned long __sanitizer_pthread_key_t;\n #else\n typedef unsigned __sanitizer_pthread_key_t;\n@@ -350,7 +370,7 @@ struct __sanitizer_passwd {\n   char *pw_passwd;\n   int pw_uid;\n   int pw_gid;\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   long pw_change;\n   char *pw_class;\n #endif\n@@ -359,7 +379,7 @@ struct __sanitizer_passwd {\n #endif\n   char *pw_dir;\n   char *pw_shell;\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   long pw_expire;\n #endif\n };\n@@ -432,7 +452,7 @@ struct __sanitizer_file_handle {\n };\n #endif\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n struct __sanitizer_msghdr {\n   void *msg_name;\n   unsigned msg_namelen;\n@@ -473,7 +493,7 @@ struct __sanitizer_mmsghdr {\n };\n #endif\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n struct __sanitizer_dirent {\n   unsigned long long d_ino;\n   unsigned long long d_seekoff;\n@@ -558,7 +578,7 @@ typedef unsigned long __sanitizer_sigset_t[16 / sizeof(unsigned long)];\n # else\n typedef unsigned long __sanitizer_sigset_t;\n # endif\n-#elif SANITIZER_MAC\n+#elif SANITIZER_APPLE\n typedef unsigned __sanitizer_sigset_t;\n #elif SANITIZER_LINUX\n struct __sanitizer_sigset_t {\n@@ -730,7 +750,7 @@ struct __sanitizer_addrinfo {\n   int ai_family;\n   int ai_socktype;\n   int ai_protocol;\n-#if SANITIZER_ANDROID || SANITIZER_MAC\n+#if SANITIZER_ANDROID || SANITIZER_APPLE\n   unsigned ai_addrlen;\n   char *ai_canonname;\n   void *ai_addr;\n@@ -756,7 +776,7 @@ struct __sanitizer_pollfd {\n   short revents;\n };\n \n-#if SANITIZER_ANDROID || SANITIZER_MAC\n+#if SANITIZER_ANDROID || SANITIZER_APPLE\n typedef unsigned __sanitizer_nfds_t;\n #else\n typedef unsigned long __sanitizer_nfds_t;\n@@ -856,7 +876,7 @@ extern int shmctl_shm_info;\n extern int shmctl_shm_stat;\n #endif\n \n-#if !SANITIZER_MAC && !SANITIZER_FREEBSD\n+#if !SANITIZER_APPLE && !SANITIZER_FREEBSD\n extern unsigned struct_utmp_sz;\n #endif\n #if !SANITIZER_ANDROID\n@@ -871,7 +891,7 @@ struct __sanitizer_ifconf {\n   union {\n     void *ifcu_req;\n   } ifc_ifcu;\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n } __attribute__((packed));\n #else\n };\n@@ -1024,7 +1044,7 @@ extern unsigned struct_audio_buf_info_sz;\n extern unsigned struct_ppp_stats_sz;\n #endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n-#if !SANITIZER_ANDROID && !SANITIZER_MAC\n+#if !SANITIZER_ANDROID && !SANITIZER_APPLE\n extern unsigned struct_sioc_sg_req_sz;\n extern unsigned struct_sioc_vif_req_sz;\n #endif\n@@ -1465,6 +1485,6 @@ extern const int si_SEGV_ACCERR;\n \n #define SIGACTION_SYMNAME sigaction\n \n-#endif  // SANITIZER_LINUX || SANITIZER_MAC\n+#endif  // SANITIZER_LINUX || SANITIZER_APPLE\n \n #endif"}, {"sha": "b0e32b50c0764e53cb2cc9c3bc33aa34992081e7", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -41,6 +41,8 @@ uptr GetMmapGranularity() {\n   return GetPageSize();\n }\n \n+bool ErrorIsOOM(error_t err) { return err == ENOMEM; }\n+\n void *MmapOrDie(uptr size, const char *mem_type, bool raw_report) {\n   size = RoundUpTo(size, GetPageSizeCached());\n   uptr res = MmapNamed(nullptr, size, PROT_READ | PROT_WRITE,\n@@ -147,7 +149,7 @@ bool MprotectReadOnly(uptr addr, uptr size) {\n   return 0 == internal_mprotect((void *)addr, size, PROT_READ);\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n void MprotectMallocZones(void *addr, int prot) {}\n #endif\n \n@@ -240,7 +242,7 @@ bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n   return true;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n void DumpProcessMap() {\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n   const sptr kBufSize = 4095;"}, {"sha": "46e41c669738cd3833cac3605c7efb883a5c9d67", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -384,7 +384,7 @@ real_pthread_attr_getstack(void *attr, void **addr, size_t *size);\n } // extern \"C\"\n \n int my_pthread_attr_getstack(void *attr, void **addr, uptr *size) {\n-#if !SANITIZER_GO && !SANITIZER_MAC\n+#if !SANITIZER_GO && !SANITIZER_APPLE\n   if (&real_pthread_attr_getstack)\n     return real_pthread_attr_getstack((pthread_attr_t *)attr, addr,\n                                       (size_t *)size);"}, {"sha": "19bad158387c54a22d1d1ddd8883e314b0c9e3c0", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -16,7 +16,7 @@\n #include \"sanitizer_platform.h\"\n \n #if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n-    SANITIZER_MAC || SANITIZER_SOLARIS ||  \\\n+    SANITIZER_APPLE || SANITIZER_SOLARIS ||  \\\n     SANITIZER_FUCHSIA\n \n #include \"sanitizer_common.h\""}, {"sha": "4b0e678197614583b66de6755a63785bd8392f85", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cpp", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -10,7 +10,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #include \"sanitizer_common.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n@@ -136,13 +136,19 @@ void MemoryMappingLayout::LoadFromCache() {\n   // No-op on Mac for now.\n }\n \n+static bool IsDyldHdr(const mach_header *hdr) {\n+  return (hdr->magic == MH_MAGIC || hdr->magic == MH_MAGIC_64) &&\n+         hdr->filetype == MH_DYLINKER;\n+}\n+\n // _dyld_get_image_header() and related APIs don't report dyld itself.\n // We work around this by manually recursing through the memory map\n // until we hit a Mach header matching dyld instead. These recurse\n // calls are expensive, but the first memory map generation occurs\n // early in the process, when dyld is one of the only images loaded,\n-// so it will be hit after only a few iterations.\n-static mach_header *get_dyld_image_header() {\n+// so it will be hit after only a few iterations.  These assumptions don't hold\n+// on macOS 13+ anymore (dyld itself has moved into the shared cache).\n+static mach_header *GetDyldImageHeaderViaVMRegion() {\n   vm_address_t address = 0;\n \n   while (true) {\n@@ -157,17 +163,77 @@ static mach_header *get_dyld_image_header() {\n \n     if (size >= sizeof(mach_header) && info.protection & kProtectionRead) {\n       mach_header *hdr = (mach_header *)address;\n-      if ((hdr->magic == MH_MAGIC || hdr->magic == MH_MAGIC_64) &&\n-          hdr->filetype == MH_DYLINKER) {\n+      if (IsDyldHdr(hdr)) {\n         return hdr;\n       }\n     }\n     address += size;\n   }\n }\n \n+extern \"C\" {\n+struct dyld_shared_cache_dylib_text_info {\n+  uint64_t version;  // current version 2\n+  // following fields all exist in version 1\n+  uint64_t loadAddressUnslid;\n+  uint64_t textSegmentSize;\n+  uuid_t dylibUuid;\n+  const char *path;  // pointer invalid at end of iterations\n+  // following fields all exist in version 2\n+  uint64_t textSegmentOffset;  // offset from start of cache\n+};\n+typedef struct dyld_shared_cache_dylib_text_info\n+    dyld_shared_cache_dylib_text_info;\n+\n+extern bool _dyld_get_shared_cache_uuid(uuid_t uuid);\n+extern const void *_dyld_get_shared_cache_range(size_t *length);\n+extern int dyld_shared_cache_iterate_text(\n+    const uuid_t cacheUuid,\n+    void (^callback)(const dyld_shared_cache_dylib_text_info *info));\n+}  // extern \"C\"\n+\n+static mach_header *GetDyldImageHeaderViaSharedCache() {\n+  uuid_t uuid;\n+  bool hasCache = _dyld_get_shared_cache_uuid(uuid);\n+  if (!hasCache)\n+    return nullptr;\n+\n+  size_t cacheLength;\n+  __block uptr cacheStart = (uptr)_dyld_get_shared_cache_range(&cacheLength);\n+  CHECK(cacheStart && cacheLength);\n+\n+  __block mach_header *dyldHdr = nullptr;\n+  int res = dyld_shared_cache_iterate_text(\n+      uuid, ^(const dyld_shared_cache_dylib_text_info *info) {\n+        CHECK_GE(info->version, 2);\n+        mach_header *hdr =\n+            (mach_header *)(cacheStart + info->textSegmentOffset);\n+        if (IsDyldHdr(hdr))\n+          dyldHdr = hdr;\n+      });\n+  CHECK_EQ(res, 0);\n+\n+  return dyldHdr;\n+}\n+\n const mach_header *get_dyld_hdr() {\n-  if (!dyld_hdr) dyld_hdr = get_dyld_image_header();\n+  if (!dyld_hdr) {\n+    // On macOS 13+, dyld itself has moved into the shared cache.  Looking it up\n+    // via vm_region_recurse_64() causes spins/hangs/crashes.\n+    if (GetMacosAlignedVersion() >= MacosVersion(13, 0)) {\n+      dyld_hdr = GetDyldImageHeaderViaSharedCache();\n+      if (!dyld_hdr) {\n+        VReport(1,\n+                \"Failed to lookup the dyld image header in the shared cache on \"\n+                \"macOS 13+ (or no shared cache in use).  Falling back to \"\n+                \"lookup via vm_region_recurse_64().\\n\");\n+        dyld_hdr = GetDyldImageHeaderViaVMRegion();\n+      }\n+    } else {\n+      dyld_hdr = GetDyldImageHeaderViaVMRegion();\n+    }\n+    CHECK(dyld_hdr);\n+  }\n \n   return dyld_hdr;\n }\n@@ -376,4 +442,4 @@ void MemoryMappingLayout::DumpListOfModules(\n \n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "6f43817aedb159f5168b4165e2beb802f79831bf", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_solaris.cpp", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -9,25 +9,32 @@\n // Information about the process mappings (Solaris-specific parts).\n //===----------------------------------------------------------------------===//\n \n-// Before Solaris 11.4, <procfs.h> doesn't work in a largefile environment.\n-#undef _FILE_OFFSET_BITS\n #include \"sanitizer_platform.h\"\n #if SANITIZER_SOLARIS\n-#include \"sanitizer_common.h\"\n-#include \"sanitizer_procmaps.h\"\n+#  include <fcntl.h>\n+#  include <limits.h>\n+#  include <procfs.h>\n \n-#include <procfs.h>\n-#include <limits.h>\n+#  include \"sanitizer_common.h\"\n+#  include \"sanitizer_procmaps.h\"\n \n namespace __sanitizer {\n \n void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n-  if (!ReadFileToBuffer(\"/proc/self/xmap\", &proc_maps->data,\n-                        &proc_maps->mmaped_size, &proc_maps->len)) {\n-    proc_maps->data = nullptr;\n-    proc_maps->mmaped_size = 0;\n-    proc_maps->len = 0;\n-  }\n+  uptr fd = internal_open(\"/proc/self/xmap\", O_RDONLY);\n+  CHECK_NE(fd, -1);\n+  uptr Size = internal_filesize(fd);\n+  CHECK_GT(Size, 0);\n+\n+  // Allow for additional entries by following mmap.\n+  size_t MmapedSize = Size * 4 / 3;\n+  void *VmMap = MmapOrDie(MmapedSize, \"ReadProcMaps()\");\n+  Size = internal_read(fd, VmMap, MmapedSize);\n+  CHECK_NE(Size, -1);\n+  internal_close(fd);\n+  proc_maps->data = (char *)VmMap;\n+  proc_maps->mmaped_size = MmapedSize;\n+  proc_maps->len = Size;\n }\n \n bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n@@ -49,21 +56,28 @@ bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n     segment->protection |= kProtectionWrite;\n   if ((xmapentry->pr_mflags & MA_EXEC) != 0)\n     segment->protection |= kProtectionExecute;\n+  if ((xmapentry->pr_mflags & MA_SHARED) != 0)\n+    segment->protection |= kProtectionShared;\n \n   if (segment->filename != NULL && segment->filename_size > 0) {\n     char proc_path[PATH_MAX + 1];\n \n-    internal_snprintf(proc_path, sizeof(proc_path), \"/proc/self/path/%s\",\n-                      xmapentry->pr_mapname);\n-    ssize_t sz = internal_readlink(proc_path, segment->filename,\n-                                   segment->filename_size - 1);\n-\n-    // If readlink failed, the map is anonymous.\n-    if (sz == -1) {\n+    // Avoid unnecessary readlink on unnamed entires.\n+    if (xmapentry->pr_mapname[0] == '\\0')\n       segment->filename[0] = '\\0';\n-    } else if ((size_t)sz < segment->filename_size)\n-      // readlink doesn't NUL-terminate.\n-      segment->filename[sz] = '\\0';\n+    else {\n+      internal_snprintf(proc_path, sizeof(proc_path), \"/proc/self/path/%s\",\n+                        xmapentry->pr_mapname);\n+      ssize_t sz = internal_readlink(proc_path, segment->filename,\n+                                     segment->filename_size - 1);\n+\n+      // If readlink failed, the map is anonymous.\n+      if (sz == -1)\n+        segment->filename[0] = '\\0';\n+      else if ((size_t)sz < segment->filename_size)\n+        // readlink doesn't NUL-terminate.\n+        segment->filename[sz] = '\\0';\n+    }\n   }\n \n   data_.current += sizeof(prxmap_t);"}, {"sha": "d24fae98213aa4daa15868afe06d432dcda91417", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -87,8 +87,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -111,24 +111,17 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n-#elif defined(__riscv)\n+#elif defined(__loongarch__) || defined(__riscv)\n     // frame[-1] contains the return address\n     uhwptr pc1 = frame[-1];\n #else\n@@ -143,7 +136,7 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n       trace_buffer[size++] = (uptr) pc1;\n     }\n     bottom = (uptr)frame;\n-#if defined(__riscv)\n+#if defined(__loongarch__) || defined(__riscv)\n     // frame[-2] contain fp of the previous frame\n     uptr new_bp = (uptr)frame[-2];\n #else"}, {"sha": "ee996c3e07eae882dff80d650f11b17673afd31b", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -33,7 +33,7 @@ static const u32 kStackTraceMax = 255;\n // Fast unwind is the only option on Mac for now; we will need to\n // revisit this macro when slow unwind works on Mac, see\n // https://github.com/google/sanitizers/issues/137\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #  define SANITIZER_CAN_SLOW_UNWIND 0\n #else\n # define SANITIZER_CAN_SLOW_UNWIND 1"}, {"sha": "87f5250db648f12d1e61c72b39033d9fd21da9bd", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_mac.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_MAC && (defined(__x86_64__) || defined(__aarch64__) || \\\n+#if SANITIZER_APPLE && (defined(__x86_64__) || defined(__aarch64__) || \\\n                       defined(__i386))\n \n #include <mach/mach.h>\n@@ -29,7 +29,7 @@ typedef struct {\n \n class SuspendedThreadsListMac final : public SuspendedThreadsList {\n  public:\n-  SuspendedThreadsListMac() : threads_(1024) {}\n+  SuspendedThreadsListMac() = default;\n \n   tid_t GetThreadID(uptr index) const override;\n   thread_t GetThread(uptr index) const;\n@@ -176,5 +176,5 @@ PtraceRegistersStatus SuspendedThreadsListMac::GetRegistersAndSP(\n \n } // namespace __sanitizer\n \n-#endif  // SANITIZER_MAC && (defined(__x86_64__) || defined(__aarch64__)) ||\n+#endif  // SANITIZER_APPLE && (defined(__x86_64__) || defined(__aarch64__)) ||\n         //                   defined(__i386))"}, {"sha": "29a08386d0b9f888f0fb6938ac8f463e2bbab435", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_internal.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -90,9 +90,10 @@ class SymbolizerProcess {\n \n   // Customizable by subclasses.\n   virtual bool StartSymbolizerSubprocess();\n-  virtual bool ReadFromSymbolizer(char *buffer, uptr max_length);\n+  virtual bool ReadFromSymbolizer();\n   // Return the environment to run the symbolizer in.\n   virtual char **GetEnvP() { return GetEnviron(); }\n+  InternalMmapVector<char> &GetBuff() { return buffer_; }\n \n  private:\n   virtual bool ReachedEndOfOutput(const char *buffer, uptr length) const {\n@@ -113,8 +114,7 @@ class SymbolizerProcess {\n   fd_t input_fd_;\n   fd_t output_fd_;\n \n-  static const uptr kBufferSize = 16 * 1024;\n-  char buffer_[kBufferSize];\n+  InternalMmapVector<char> buffer_;\n \n   static const uptr kMaxTimesRestarted = 5;\n   static const int kSymbolizerStartupTimeMillis = 10;"}, {"sha": "461fe96613688beb72ba8de03417e46c13970faa", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cpp", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -237,7 +237,7 @@ const LoadedModule *Symbolizer::FindModuleForAddress(uptr address) {\n class LLVMSymbolizerProcess final : public SymbolizerProcess {\n  public:\n   explicit LLVMSymbolizerProcess(const char *path)\n-      : SymbolizerProcess(path, /*use_posix_spawn=*/SANITIZER_MAC) {}\n+      : SymbolizerProcess(path, /*use_posix_spawn=*/SANITIZER_APPLE) {}\n \n  private:\n   bool ReachedEndOfOutput(const char *buffer, uptr length) const override {\n@@ -363,14 +363,21 @@ void ParseSymbolizePCOutput(const char *str, SymbolizedStack *res) {\n   }\n }\n \n-// Parses a two-line string in the following format:\n+// Parses a two- or three-line string in the following format:\n //   <symbol_name>\n //   <start_address> <size>\n-// Used by LLVMSymbolizer and InternalSymbolizer.\n+//   <filename>:<column>\n+// Used by LLVMSymbolizer and InternalSymbolizer. LLVMSymbolizer added support\n+// for symbolizing the third line in D123538, but we support the older two-line\n+// information as well.\n void ParseSymbolizeDataOutput(const char *str, DataInfo *info) {\n   str = ExtractToken(str, \"\\n\", &info->name);\n   str = ExtractUptr(str, \" \", &info->start);\n   str = ExtractUptr(str, \"\\n\", &info->size);\n+  // Note: If the third line isn't present, these calls will set info.{file,\n+  // line} to empty strings.\n+  str = ExtractToken(str, \":\", &info->file);\n+  str = ExtractUptr(str, \"\\n\", &info->line);\n }\n \n static void ParseSymbolizeFrameOutput(const char *str,\n@@ -500,9 +507,9 @@ const char *SymbolizerProcess::SendCommandImpl(const char *command) {\n       return nullptr;\n   if (!WriteToSymbolizer(command, internal_strlen(command)))\n       return nullptr;\n-  if (!ReadFromSymbolizer(buffer_, kBufferSize))\n-      return nullptr;\n-  return buffer_;\n+  if (!ReadFromSymbolizer())\n+    return nullptr;\n+  return buffer_.data();\n }\n \n bool SymbolizerProcess::Restart() {\n@@ -513,31 +520,33 @@ bool SymbolizerProcess::Restart() {\n   return StartSymbolizerSubprocess();\n }\n \n-bool SymbolizerProcess::ReadFromSymbolizer(char *buffer, uptr max_length) {\n-  if (max_length == 0)\n-    return true;\n-  uptr read_len = 0;\n-  while (true) {\n+bool SymbolizerProcess::ReadFromSymbolizer() {\n+  buffer_.clear();\n+  constexpr uptr max_length = 1024;\n+  bool ret = true;\n+  do {\n     uptr just_read = 0;\n-    bool success = ReadFromFile(input_fd_, buffer + read_len,\n-                                max_length - read_len - 1, &just_read);\n+    uptr size_before = buffer_.size();\n+    buffer_.resize(size_before + max_length);\n+    buffer_.resize(buffer_.capacity());\n+    bool ret = ReadFromFile(input_fd_, &buffer_[size_before],\n+                            buffer_.size() - size_before, &just_read);\n+\n+    if (!ret)\n+      just_read = 0;\n+\n+    buffer_.resize(size_before + just_read);\n+\n     // We can't read 0 bytes, as we don't expect external symbolizer to close\n     // its stdout.\n-    if (!success || just_read == 0) {\n+    if (just_read == 0) {\n       Report(\"WARNING: Can't read from symbolizer at fd %d\\n\", input_fd_);\n-      return false;\n-    }\n-    read_len += just_read;\n-    if (ReachedEndOfOutput(buffer, read_len))\n-      break;\n-    if (read_len + 1 == max_length) {\n-      Report(\"WARNING: Symbolizer buffer too small\\n\");\n-      read_len = 0;\n+      ret = false;\n       break;\n     }\n-  }\n-  buffer[read_len] = '\\0';\n-  return true;\n+  } while (!ReachedEndOfOutput(buffer_.data(), buffer_.size()));\n+  buffer_.push_back('\\0');\n+  return ret;\n }\n \n bool SymbolizerProcess::WriteToSymbolizer(const char *buffer, uptr length) {"}, {"sha": "f4f2a036a1e71d2fb3550df822793da9d3c68de2", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_mac.h\"\n@@ -202,4 +202,4 @@ bool AtosSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n \n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "cea244182907a2e4df69540f27c3a88fcb8dc93d", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -15,7 +15,7 @@\n #define SANITIZER_SYMBOLIZER_MAC_H\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"sanitizer_symbolizer_internal.h\"\n \n@@ -42,6 +42,6 @@ class AtosSymbolizer final : public SymbolizerTool {\n \n } // namespace __sanitizer\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n \n #endif // SANITIZER_SYMBOLIZER_MAC_H"}, {"sha": "b223f6cd01e34a5e45f68d4db0b55df8a99788c4", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cpp", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -72,7 +72,6 @@ static swift_demangle_ft swift_demangle_f;\n // symbolication.\n static void InitializeSwiftDemangler() {\n   swift_demangle_f = (swift_demangle_ft)dlsym(RTLD_DEFAULT, \"swift_demangle\");\n-  (void)dlerror(); // Cleanup error message in case of failure\n }\n \n // Attempts to demangle a Swift name. The demangler will return nullptr if a\n@@ -155,7 +154,7 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n   }\n \n   if (use_posix_spawn_) {\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n     fd_t fd = internal_spawn(argv, const_cast<const char **>(GetEnvP()), &pid);\n     if (fd == kInvalidFd) {\n       Report(\"WARNING: failed to spawn external symbolizer (errno: %d)\\n\",\n@@ -165,9 +164,9 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n \n     input_fd_ = fd;\n     output_fd_ = fd;\n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n     UNIMPLEMENTED();\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n   } else {\n     fd_t infd[2] = {}, outfd[2] = {};\n     if (!CreateTwoHighNumberedPipes(infd, outfd)) {\n@@ -225,24 +224,24 @@ class Addr2LineProcess final : public SymbolizerProcess {\n \n   bool ReachedEndOfOutput(const char *buffer, uptr length) const override;\n \n-  bool ReadFromSymbolizer(char *buffer, uptr max_length) override {\n-    if (!SymbolizerProcess::ReadFromSymbolizer(buffer, max_length))\n+  bool ReadFromSymbolizer() override {\n+    if (!SymbolizerProcess::ReadFromSymbolizer())\n       return false;\n-    // The returned buffer is empty when output is valid, but exceeds\n-    // max_length.\n-    if (*buffer == '\\0')\n-      return true;\n+    auto &buff = GetBuff();\n     // We should cut out output_terminator_ at the end of given buffer,\n     // appended by addr2line to mark the end of its meaningful output.\n     // We cannot scan buffer from it's beginning, because it is legal for it\n     // to start with output_terminator_ in case given offset is invalid. So,\n     // scanning from second character.\n-    char *garbage = internal_strstr(buffer + 1, output_terminator_);\n+    char *garbage = internal_strstr(buff.data() + 1, output_terminator_);\n     // This should never be NULL since buffer must end up with\n     // output_terminator_.\n     CHECK(garbage);\n+\n     // Trim the buffer.\n-    garbage[0] = '\\0';\n+    uintptr_t new_size = garbage - buff.data();\n+    GetBuff().resize(new_size);\n+    GetBuff().push_back('\\0');\n     return true;\n   }\n \n@@ -427,13 +426,13 @@ static SymbolizerTool *ChooseExternalSymbolizer(LowLevelAllocator *allocator) {\n     VReport(2, \"Using llvm-symbolizer at user-specified path: %s\\n\", path);\n     return new(*allocator) LLVMSymbolizer(path, allocator);\n   } else if (!internal_strcmp(binary_name, \"atos\")) {\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n     VReport(2, \"Using atos at user-specified path: %s\\n\", path);\n     return new(*allocator) AtosSymbolizer(path, allocator);\n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n     Report(\"ERROR: Using `atos` is only supported on Darwin.\\n\");\n     Die();\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n   } else if (!internal_strcmp(binary_name, \"addr2line\")) {\n     VReport(2, \"Using addr2line at user-specified path: %s\\n\", path);\n     return new(*allocator) Addr2LinePool(path, allocator);\n@@ -446,12 +445,12 @@ static SymbolizerTool *ChooseExternalSymbolizer(LowLevelAllocator *allocator) {\n \n   // Otherwise symbolizer program is unknown, let's search $PATH\n   CHECK(path == nullptr);\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   if (const char *found_path = FindPathToBinary(\"atos\")) {\n     VReport(2, \"Using atos found at: %s\\n\", found_path);\n     return new(*allocator) AtosSymbolizer(found_path, allocator);\n   }\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n   if (const char *found_path = FindPathToBinary(\"llvm-symbolizer\")) {\n     VReport(2, \"Using llvm-symbolizer found at: %s\\n\", found_path);\n     return new(*allocator) LLVMSymbolizer(found_path, allocator);\n@@ -488,10 +487,10 @@ static void ChooseSymbolizerTools(IntrusiveList<SymbolizerTool> *list,\n     list->push_back(tool);\n   }\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n   VReport(2, \"Using dladdr symbolizer.\\n\");\n   list->push_back(new(*allocator) DlAddrSymbolizer());\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n }\n \n Symbolizer *Symbolizer::PlatformInit() {"}, {"sha": "d5c028e3640d221bd87f7166a44e81bd6b8388b5", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -94,7 +94,7 @@ void ReportMmapWriteExec(int prot, int flags) {\n   if ((prot & pflags) != pflags)\n     return;\n \n-#  if SANITIZER_MAC && defined(MAP_JIT)\n+#  if SANITIZER_APPLE && defined(MAP_JIT)\n   if ((flags & MAP_JIT) == MAP_JIT)\n     return;\n #  endif"}, {"sha": "e7f95d33ad0d30756764de1a2dbbc3ba42798505", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_generic.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -13,13 +13,14 @@\n // NetBSD uses libc calls directly\n #if !SANITIZER_NETBSD\n \n-#if SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_SOLARIS\n+#if SANITIZER_FREEBSD || SANITIZER_APPLE || SANITIZER_SOLARIS\n # define SYSCALL(name) SYS_ ## name\n #else\n # define SYSCALL(name) __NR_ ## name\n #endif\n \n-#if defined(__x86_64__) && (SANITIZER_FREEBSD || SANITIZER_MAC)\n+#if (defined(__x86_64__) && (SANITIZER_FREEBSD || SANITIZER_APPLE)) || \\\n+    (defined(__aarch64__) && SANITIZER_FREEBSD)\n # define internal_syscall __syscall\n # else\n # define internal_syscall syscall"}, {"sha": "97ca7f2f3f92bdaeb284884cc52f499a83a4367d", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_loongarch64.inc", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_loongarch64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_loongarch64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_loongarch64.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -0,0 +1,167 @@\n+//===-- sanitizer_syscall_linux_loongarch64.inc -----------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Implementations of internal_syscall and internal_iserror for\n+// Linux/loongarch64.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// About local register variables:\n+// https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html#Local-Register-Variables\n+//\n+// Kernel ABI...\n+//  syscall number is passed in a7\n+//  (http://man7.org/linux/man-pages/man2/syscall.2.html) results are return in\n+//  a0 and a1 (http://man7.org/linux/man-pages/man2/syscall.2.html) arguments\n+//  are passed in: a0-a7 (confirmed by inspecting glibc sources).\n+#define SYSCALL(name) __NR_##name\n+\n+#define INTERNAL_SYSCALL_CLOBBERS \"memory\"\n+\n+static uptr __internal_syscall(u64 nr) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\");\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"=r\"(a0)\n+                   : \"r\"(a7)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall0(n) (__internal_syscall)(n)\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall1(n, a1) (__internal_syscall)(n, (u64)(a1))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall2(n, a1, a2) \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall3(n, a1, a2, a3) \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3,\n+                               u64 arg4) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall4(n, a1, a2, a3, a4) \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n+                               long arg5) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  register u64 a4 asm(\"a4\") = arg5;\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall5(n, a1, a2, a3, a4, a5)                       \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4), \\\n+                       (u64)(a5))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n+                               long arg5, long arg6) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  register u64 a4 asm(\"a4\") = arg5;\n+  register u64 a5 asm(\"a5\") = arg6;\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4), \"r\"(a5)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall6(n, a1, a2, a3, a4, a5, a6)                   \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4), \\\n+                       (u64)(a5), (long)(a6))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n+                               long arg5, long arg6, long arg7) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  register u64 a4 asm(\"a4\") = arg5;\n+  register u64 a5 asm(\"a5\") = arg6;\n+  register u64 a6 asm(\"a6\") = arg7;\n+  __asm__ volatile(\"syscall 0\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4), \"r\"(a5),\n+                     \"r\"(a6)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall7(n, a1, a2, a3, a4, a5, a6, a7)               \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4), \\\n+                       (u64)(a5), (long)(a6), (long)(a7))\n+\n+#define __SYSCALL_NARGS_X(a1, a2, a3, a4, a5, a6, a7, a8, n, ...) n\n+#define __SYSCALL_NARGS(...) \\\n+  __SYSCALL_NARGS_X(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0, )\n+#define __SYSCALL_CONCAT_X(a, b) a##b\n+#define __SYSCALL_CONCAT(a, b) __SYSCALL_CONCAT_X(a, b)\n+#define __SYSCALL_DISP(b, ...) \\\n+  __SYSCALL_CONCAT(b, __SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)\n+\n+#define internal_syscall(...) __SYSCALL_DISP(__internal_syscall, __VA_ARGS__)\n+\n+// Helper function used to avoid clobbering of errno.\n+bool internal_iserror(uptr retval, int *internal_errno) {\n+  if (retval >= (uptr)-4095) {\n+    if (internal_errno)\n+      *internal_errno = -retval;\n+    return true;\n+  }\n+  return false;\n+}"}, {"sha": "72f025a7d307adcd30fd000562c61bc923c5faf9", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -58,7 +58,7 @@ unwind_backtrace_signal_arch_func unwind_backtrace_signal_arch;\n #endif\n \n uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n-#if defined(__arm__) && !SANITIZER_MAC\n+#if defined(__arm__) && !SANITIZER_APPLE\n   uptr val;\n   _Unwind_VRS_Result res = _Unwind_VRS_Get(ctx, _UVRSC_CORE,\n       15 /* r15 = PC */, _UVRSD_UINT32, &val);"}, {"sha": "79ff275660d36399d8cacb6189216ebc90c6d280", "filename": "libsanitizer/sanitizer_common/sanitizer_vector.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -83,8 +83,8 @@ class Vector {\n     }\n     EnsureSize(size);\n     if (old_size < size) {\n-      for (uptr i = old_size; i < size; i++)\n-        internal_memset(&begin_[i], 0, sizeof(begin_[i]));\n+      internal_memset(&begin_[old_size], 0,\n+                      sizeof(begin_[old_size]) * (size - old_size));\n     }\n   }\n "}, {"sha": "e0568c9b62d5ee6c838e2d5d4bf6d3da776416e3", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cpp", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -131,6 +131,11 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n }\n #endif  // #if !SANITIZER_GO\n \n+bool ErrorIsOOM(error_t err) {\n+  // TODO: This should check which `err`s correspond to OOM.\n+  return false;\n+}\n+\n void *MmapOrDie(uptr size, const char *mem_type, bool raw_report) {\n   void *rv = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n   if (rv == 0)\n@@ -229,6 +234,17 @@ void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n   return (void *)mapped_addr;\n }\n \n+// ZeroMmapFixedRegion zero's out a region of memory previously returned from a\n+// call to one of the MmapFixed* helpers. On non-windows systems this would be\n+// done with another mmap, but on windows remapping is not an option.\n+// VirtualFree(DECOMMIT)+VirtualAlloc(RECOMMIT) would also be a way to zero the\n+// memory, but we can't do this atomically, so instead we fall back to using\n+// internal_memset.\n+bool ZeroMmapFixedRegion(uptr fixed_addr, uptr size) {\n+  internal_memset((void*) fixed_addr, 0, size);\n+  return true;\n+}\n+\n bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n   // FIXME: is this really \"NoReserve\"? On Win32 this does not matter much,\n   // but on Win64 it does.\n@@ -1089,10 +1105,6 @@ void InitializePlatformEarly() {\n   // Do nothing.\n }\n \n-void MaybeReexec() {\n-  // No need to re-exec on Windows.\n-}\n-\n void CheckASLR() {\n   // Do nothing\n }"}, {"sha": "2eaff39057bc5efcea8219c0beca47de69a9cd5c", "filename": "libsanitizer/tsan/tsan_dense_alloc.h", "status": "modified", "additions": 73, "deletions": 42, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -85,14 +85,7 @@ class DenseSlabAlloc {\n   }\n \n   void FlushCache(Cache *c) {\n-    if (!c->pos)\n-      return;\n-    SpinMutexLock lock(&mtx_);\n-    while (c->pos) {\n-      IndexT idx = c->cache[--c->pos];\n-      *(IndexT*)Map(idx) = freelist_;\n-      freelist_ = idx;\n-    }\n+    while (c->pos) Drain(c);\n   }\n \n   void InitCache(Cache *c) {\n@@ -106,7 +99,7 @@ class DenseSlabAlloc {\n \n   template <typename Func>\n   void ForEach(Func func) {\n-    SpinMutexLock lock(&mtx_);\n+    Lock lock(&mtx_);\n     uptr fillpos = atomic_load_relaxed(&fillpos_);\n     for (uptr l1 = 0; l1 < fillpos; l1++) {\n       for (IndexT l2 = l1 == 0 ? 1 : 0; l2 < kL2Size; l2++) func(&map_[l1][l2]);\n@@ -115,48 +108,86 @@ class DenseSlabAlloc {\n \n  private:\n   T *map_[kL1Size];\n-  SpinMutex mtx_;\n-  IndexT freelist_ = {0};\n+  Mutex mtx_;\n+  // The freelist is organized as a lock-free stack of batches of nodes.\n+  // The stack itself uses Block::next links, while the batch within each\n+  // stack node uses Block::batch links.\n+  // Low 32-bits of freelist_ is the node index, top 32-bits is ABA-counter.\n+  atomic_uint64_t freelist_ = {0};\n   atomic_uintptr_t fillpos_ = {0};\n   const char *const name_;\n \n-  void Refill(Cache *c) {\n-    SpinMutexLock lock(&mtx_);\n-    if (freelist_ == 0) {\n-      uptr fillpos = atomic_load_relaxed(&fillpos_);\n-      if (fillpos == kL1Size) {\n-        Printf(\"ThreadSanitizer: %s overflow (%zu*%zu). Dying.\\n\",\n-            name_, kL1Size, kL2Size);\n-        Die();\n-      }\n-      VPrintf(2, \"ThreadSanitizer: growing %s: %zu out of %zu*%zu\\n\", name_,\n-              fillpos, kL1Size, kL2Size);\n-      T *batch = (T*)MmapOrDie(kL2Size * sizeof(T), name_);\n-      // Reserve 0 as invalid index.\n-      IndexT start = fillpos == 0 ? 1 : 0;\n-      for (IndexT i = start; i < kL2Size; i++) {\n-        new(batch + i) T;\n-        *(IndexT *)(batch + i) = i + 1 + fillpos * kL2Size;\n-      }\n-      *(IndexT*)(batch + kL2Size - 1) = 0;\n-      freelist_ = fillpos * kL2Size + start;\n-      map_[fillpos] = batch;\n-      atomic_store_relaxed(&fillpos_, fillpos + 1);\n-    }\n-    for (uptr i = 0; i < Cache::kSize / 2 && freelist_ != 0; i++) {\n-      IndexT idx = freelist_;\n+  struct Block {\n+    IndexT next;\n+    IndexT batch;\n+  };\n+\n+  Block *MapBlock(IndexT idx) { return reinterpret_cast<Block *>(Map(idx)); }\n+\n+  static constexpr u64 kCounterInc = 1ull << 32;\n+  static constexpr u64 kCounterMask = ~(kCounterInc - 1);\n+\n+  NOINLINE void Refill(Cache *c) {\n+    // Pop 1 batch of nodes from the freelist.\n+    IndexT idx;\n+    u64 xchg;\n+    u64 cmp = atomic_load(&freelist_, memory_order_acquire);\n+    do {\n+      idx = static_cast<IndexT>(cmp);\n+      if (!idx)\n+        return AllocSuperBlock(c);\n+      Block *ptr = MapBlock(idx);\n+      xchg = ptr->next | (cmp & kCounterMask);\n+    } while (!atomic_compare_exchange_weak(&freelist_, &cmp, xchg,\n+                                           memory_order_acq_rel));\n+    // Unpack it into c->cache.\n+    while (idx) {\n       c->cache[c->pos++] = idx;\n-      freelist_ = *(IndexT*)Map(idx);\n+      idx = MapBlock(idx)->batch;\n     }\n   }\n \n-  void Drain(Cache *c) {\n-    SpinMutexLock lock(&mtx_);\n-    for (uptr i = 0; i < Cache::kSize / 2; i++) {\n+  NOINLINE void Drain(Cache *c) {\n+    // Build a batch of at most Cache::kSize / 2 nodes linked by Block::batch.\n+    IndexT head_idx = 0;\n+    for (uptr i = 0; i < Cache::kSize / 2 && c->pos; i++) {\n       IndexT idx = c->cache[--c->pos];\n-      *(IndexT*)Map(idx) = freelist_;\n-      freelist_ = idx;\n+      Block *ptr = MapBlock(idx);\n+      ptr->batch = head_idx;\n+      head_idx = idx;\n+    }\n+    // Push it onto the freelist stack.\n+    Block *head = MapBlock(head_idx);\n+    u64 xchg;\n+    u64 cmp = atomic_load(&freelist_, memory_order_acquire);\n+    do {\n+      head->next = static_cast<IndexT>(cmp);\n+      xchg = head_idx | (cmp & kCounterMask) + kCounterInc;\n+    } while (!atomic_compare_exchange_weak(&freelist_, &cmp, xchg,\n+                                           memory_order_acq_rel));\n+  }\n+\n+  NOINLINE void AllocSuperBlock(Cache *c) {\n+    Lock lock(&mtx_);\n+    uptr fillpos = atomic_load_relaxed(&fillpos_);\n+    if (fillpos == kL1Size) {\n+      Printf(\"ThreadSanitizer: %s overflow (%zu*%zu). Dying.\\n\", name_, kL1Size,\n+             kL2Size);\n+      Die();\n+    }\n+    VPrintf(2, \"ThreadSanitizer: growing %s: %zu out of %zu*%zu\\n\", name_,\n+            fillpos, kL1Size, kL2Size);\n+    T *batch = (T *)MmapOrDie(kL2Size * sizeof(T), name_);\n+    map_[fillpos] = batch;\n+    // Reserve 0 as invalid index.\n+    for (IndexT i = fillpos ? 0 : 1; i < kL2Size; i++) {\n+      new (batch + i) T;\n+      c->cache[c->pos++] = i + fillpos * kL2Size;\n+      if (c->pos == Cache::kSize)\n+        Drain(c);\n     }\n+    atomic_store_relaxed(&fillpos_, fillpos + 1);\n+    CHECK(c->pos);\n   }\n };\n "}, {"sha": "54c0b0ba4b409a46bb48e2598a14d25dead17e20", "filename": "libsanitizer/tsan/tsan_dispatch_defs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -56,7 +56,7 @@ extern const dispatch_block_t _dispatch_data_destructor_munmap;\n # define DISPATCH_NOESCAPE\n #endif\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n # define SANITIZER_WEAK_IMPORT extern \"C\" __attribute((weak_import))\n #else\n # define SANITIZER_WEAK_IMPORT extern \"C\" __attribute((weak))"}, {"sha": "ab295a69dce17b3b001b65eb0868d2da54fc4d53", "filename": "libsanitizer/tsan/tsan_fd.cpp", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_fd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_fd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -34,6 +34,7 @@ struct FdDesc {\n   atomic_uintptr_t aux_sync;  // FdSync*\n   Tid creation_tid;\n   StackID creation_stack;\n+  bool closed;\n };\n \n struct FdContext {\n@@ -120,6 +121,7 @@ static void init(ThreadState *thr, uptr pc, int fd, FdSync *s,\n   }\n   d->creation_tid = thr->tid;\n   d->creation_stack = CurrentStackId(thr, pc);\n+  d->closed = false;\n   // This prevents false positives on fd_close_norace3.cpp test.\n   // The mechanics of the false positive are not completely clear,\n   // but it happens only if global reset is enabled (flush_memory_ms=1)\n@@ -155,7 +157,7 @@ void FdOnFork(ThreadState *thr, uptr pc) {\n   }\n }\n \n-bool FdLocation(uptr addr, int *fd, Tid *tid, StackID *stack) {\n+bool FdLocation(uptr addr, int *fd, Tid *tid, StackID *stack, bool *closed) {\n   for (int l1 = 0; l1 < kTableSizeL1; l1++) {\n     FdDesc *tab = (FdDesc*)atomic_load(&fdctx.tab[l1], memory_order_relaxed);\n     if (tab == 0)\n@@ -166,6 +168,7 @@ bool FdLocation(uptr addr, int *fd, Tid *tid, StackID *stack) {\n       *fd = l1 * kTableSizeL1 + l2;\n       *tid = d->creation_tid;\n       *stack = d->creation_stack;\n+      *closed = d->closed;\n       return true;\n     }\n   }\n@@ -242,8 +245,9 @@ void FdClose(ThreadState *thr, uptr pc, int fd, bool write) {\n         reinterpret_cast<FdSync *>(\n             atomic_load(&d->aux_sync, memory_order_relaxed)));\n   atomic_store(&d->aux_sync, 0, memory_order_relaxed);\n-  d->creation_tid = kInvalidTid;\n-  d->creation_stack = kInvalidStackID;\n+  d->closed = true;\n+  d->creation_tid = thr->tid;\n+  d->creation_stack = CurrentStackId(thr, pc);\n }\n \n void FdFileCreate(ThreadState *thr, uptr pc, int fd) {"}, {"sha": "dddc1d2ab24b0a070df9aa0ba15c7131e52224a3", "filename": "libsanitizer/tsan/tsan_fd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_fd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_fd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -54,7 +54,7 @@ void FdSocketCreate(ThreadState *thr, uptr pc, int fd);\n void FdSocketAccept(ThreadState *thr, uptr pc, int fd, int newfd);\n void FdSocketConnecting(ThreadState *thr, uptr pc, int fd);\n void FdSocketConnect(ThreadState *thr, uptr pc, int fd);\n-bool FdLocation(uptr addr, int *fd, Tid *tid, StackID *stack);\n+bool FdLocation(uptr addr, int *fd, Tid *tid, StackID *stack, bool *closed);\n void FdOnFork(ThreadState *thr, uptr pc);\n \n uptr File2addr(const char *path);"}, {"sha": "731d776cc893e7a82b57c35178b834ff56751724", "filename": "libsanitizer/tsan/tsan_flags.inc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.inc?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -23,10 +23,6 @@ TSAN_FLAG(bool, enable_annotations, true,\n TSAN_FLAG(bool, suppress_equal_stacks, true,\n           \"Suppress a race report if we've already output another race report \"\n           \"with the same stack.\")\n-TSAN_FLAG(bool, suppress_equal_addresses, true,\n-          \"Suppress a race report if we've already output another race report \"\n-          \"on the same address.\")\n-\n TSAN_FLAG(bool, report_bugs, true,\n           \"Turns off bug reporting entirely (useful for benchmarking).\")\n TSAN_FLAG(bool, report_thread_leaks, true, \"Report thread leaks at exit?\")\n@@ -74,9 +70,9 @@ TSAN_FLAG(int, io_sync, 1,\n TSAN_FLAG(bool, die_after_fork, true,\n           \"Die after multi-threaded fork if the child creates new threads.\")\n TSAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")\n-TSAN_FLAG(bool, ignore_interceptors_accesses, SANITIZER_MAC ? true : false,\n+TSAN_FLAG(bool, ignore_interceptors_accesses, SANITIZER_APPLE ? true : false,\n           \"Ignore reads and writes from all interceptors.\")\n-TSAN_FLAG(bool, ignore_noninstrumented_modules, SANITIZER_MAC ? true : false,\n+TSAN_FLAG(bool, ignore_noninstrumented_modules, SANITIZER_APPLE ? true : false,\n           \"Interceptors should only detect races when called from instrumented \"\n           \"modules.\")\n TSAN_FLAG(bool, shared_ptr_interceptor, true,"}, {"sha": "88d5f0a481196f1846d1fefc2ef078cd917887d1", "filename": "libsanitizer/tsan/tsan_interceptors_libdispatch.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -19,7 +19,7 @@\n #include \"BlocksRuntime/Block.h\"\n #include \"tsan_dispatch_defs.h\"\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n # include <Availability.h>\n #endif\n \n@@ -225,7 +225,7 @@ DISPATCH_INTERCEPT(dispatch_barrier, true)\n \n // dispatch_async_and_wait() and friends were introduced in macOS 10.14.\n // Linking of these interceptors fails when using an older SDK.\n-#if !SANITIZER_MAC || defined(__MAC_10_14)\n+#if !SANITIZER_APPLE || defined(__MAC_10_14)\n // macOS 10.14 is greater than our minimal deployment target.  To ensure we\n // generate a weak reference so the TSan dylib continues to work on older\n // systems, we need to forward declare the intercepted functions as \"weak"}, {"sha": "1ee47bcd1237e365a30f6b25ba1d995d23a3bf80", "filename": "libsanitizer/tsan/tsan_interceptors_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"interception/interception.h\"\n #include \"tsan_interceptors.h\"\n@@ -518,4 +518,4 @@ STDCXX_INTERCEPTOR(void, _ZNSt3__111__call_onceERVmPvPFvS2_E, void *flag,\n \n }  // namespace __tsan\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "17f6b1f472d8fcb823070527073d8dabf3602a39", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -35,7 +35,7 @@\n \n using namespace __tsan;\n \n-#if SANITIZER_FREEBSD || SANITIZER_MAC\n+#if SANITIZER_FREEBSD || SANITIZER_APPLE\n #define stdout __stdoutp\n #define stderr __stderrp\n #endif\n@@ -102,14 +102,14 @@ extern __sanitizer_FILE __sF[];\n #else\n extern __sanitizer_FILE *stdout, *stderr;\n #endif\n-#if !SANITIZER_FREEBSD && !SANITIZER_MAC && !SANITIZER_NETBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_APPLE && !SANITIZER_NETBSD\n const int PTHREAD_MUTEX_RECURSIVE = 1;\n const int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n #else\n const int PTHREAD_MUTEX_RECURSIVE = 2;\n const int PTHREAD_MUTEX_RECURSIVE_NP = 2;\n #endif\n-#if !SANITIZER_FREEBSD && !SANITIZER_MAC && !SANITIZER_NETBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_APPLE && !SANITIZER_NETBSD\n const int EPOLL_CTL_ADD = 1;\n #endif\n const int SIGILL = 4;\n@@ -119,7 +119,7 @@ const int SIGFPE = 8;\n const int SIGSEGV = 11;\n const int SIGPIPE = 13;\n const int SIGTERM = 15;\n-#if defined(__mips__) || SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_NETBSD\n+#if defined(__mips__) || SANITIZER_FREEBSD || SANITIZER_APPLE || SANITIZER_NETBSD\n const int SIGBUS = 10;\n const int SIGSYS = 12;\n #else\n@@ -129,7 +129,7 @@ const int SIGSYS = 31;\n void *const MAP_FAILED = (void*)-1;\n #if SANITIZER_NETBSD\n const int PTHREAD_BARRIER_SERIAL_THREAD = 1234567;\n-#elif !SANITIZER_MAC\n+#elif !SANITIZER_APPLE\n const int PTHREAD_BARRIER_SERIAL_THREAD = -1;\n #endif\n const int MAP_FIXED = 0x10;\n@@ -142,7 +142,7 @@ typedef __sanitizer::u16 mode_t;\n # define F_TLOCK 2      /* Test and lock a region for exclusive use.  */\n # define F_TEST  3      /* Test a region for other processes locks.  */\n \n-#if SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_APPLE || SANITIZER_NETBSD\n const int SA_SIGINFO = 0x40;\n const int SIG_SETMASK = 3;\n #elif defined(__mips__)\n@@ -189,7 +189,7 @@ struct InterceptorContext {\n   // in a single cache line if possible (it's accessed in every interceptor).\n   ALIGNED(64) LibIgnore libignore;\n   __sanitizer_sigaction sigactions[kSigCount];\n-#if !SANITIZER_MAC && !SANITIZER_NETBSD\n+#if !SANITIZER_APPLE && !SANITIZER_NETBSD\n   unsigned finalize_key;\n #endif\n \n@@ -461,7 +461,7 @@ static int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n   return res;\n }\n \n-#if !SANITIZER_MAC && !SANITIZER_NETBSD\n+#if !SANITIZER_APPLE && !SANITIZER_NETBSD\n static void on_exit_callback_installed_at(int status, void *arg) {\n   ThreadState *thr = cur_thread();\n   AtExitCtx *ctx = (AtExitCtx*)arg;\n@@ -553,11 +553,11 @@ static void LongJmp(ThreadState *thr, uptr *env) {\n // FIXME: put everything below into a common extern \"C\" block?\n extern \"C\" void __tsan_setjmp(uptr sp) { SetJmp(cur_thread_init(), sp); }\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, setjmp, void *env);\n TSAN_INTERCEPTOR(int, _setjmp, void *env);\n TSAN_INTERCEPTOR(int, sigsetjmp, void *env);\n-#else  // SANITIZER_MAC\n+#else  // SANITIZER_APPLE\n \n #if SANITIZER_NETBSD\n #define setjmp_symname __setjmp14\n@@ -619,7 +619,7 @@ DEFINE_REAL(int, sigsetjmp_symname, void *env)\n #if !SANITIZER_NETBSD\n DEFINE_REAL(int, __sigsetjmp, void *env)\n #endif\n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE\n \n #if SANITIZER_NETBSD\n #define longjmp_symname __longjmp14\n@@ -658,7 +658,7 @@ TSAN_INTERCEPTOR(void, _longjmp, uptr *env, int val) {\n }\n #endif\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(void*, malloc, uptr size) {\n   if (in_symbolizer())\n     return InternalAlloc(size);\n@@ -816,7 +816,7 @@ TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n #define TSAN_MAYBE_INTERCEPT_MEMALIGN\n #endif\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(void*, aligned_alloc, uptr align, uptr sz) {\n   if (in_symbolizer())\n     return InternalAlloc(sz, nullptr, align);\n@@ -847,7 +847,7 @@ TSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n #define TSAN_MAYBE_INTERCEPT_PVALLOC\n #endif\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {\n   if (in_symbolizer()) {\n     void *p = InternalAlloc(sz, nullptr, align);\n@@ -919,7 +919,7 @@ static void guard_release(ThreadState *thr, uptr pc, atomic_uint32_t *g,\n // these interceptors with INTERFACE_ATTRIBUTE.\n // On OS X, we don't support statically linking, so we just use a regular\n // interceptor.\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n #define STDCXX_INTERCEPTOR TSAN_INTERCEPTOR\n #else\n #define STDCXX_INTERCEPTOR(rettype, name, ...) \\\n@@ -962,7 +962,7 @@ void PlatformCleanUpThreadState(ThreadState *thr) {\n }\n }  // namespace __tsan\n \n-#if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n+#if !SANITIZER_APPLE && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n static void thread_finalize(void *v) {\n   uptr iter = (uptr)v;\n   if (iter > 1) {\n@@ -994,7 +994,7 @@ extern \"C\" void *__tsan_thread_start_func(void *arg) {\n     ThreadState *thr = cur_thread_init();\n     // Thread-local state is not initialized yet.\n     ScopedIgnoreInterceptors ignore;\n-#if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n+#if !SANITIZER_APPLE && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n     ThreadIgnoreBegin(thr, 0);\n     if (pthread_setspecific(interceptor_ctx()->finalize_key,\n                             (void *)GetPthreadDestructorIterations())) {\n@@ -1102,7 +1102,7 @@ TSAN_INTERCEPTOR(int, pthread_detach, void *th) {\n TSAN_INTERCEPTOR(void, pthread_exit, void *retval) {\n   {\n     SCOPED_INTERCEPTOR_RAW(pthread_exit, retval);\n-#if !SANITIZER_MAC && !SANITIZER_ANDROID\n+#if !SANITIZER_APPLE && !SANITIZER_ANDROID\n     CHECK_EQ(thr, &cur_thread_placeholder);\n #endif\n   }\n@@ -1271,7 +1271,7 @@ INTERCEPTOR(int, pthread_cond_clockwait, void *c, void *m,\n #define TSAN_MAYBE_PTHREAD_COND_CLOCKWAIT\n #endif\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n INTERCEPTOR(int, pthread_cond_timedwait_relative_np, void *c, void *m,\n             void *reltime) {\n   void *cond = init_cond(c);\n@@ -1348,7 +1348,7 @@ TSAN_INTERCEPTOR(int, pthread_mutex_trylock, void *m) {\n   return res;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_mutex_timedlock, m, abstime);\n   int res = REAL(pthread_mutex_timedlock)(m, abstime);\n@@ -1359,7 +1359,7 @@ TSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n }\n #endif\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, pthread_spin_init, void *m, int pshared) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_spin_init, m, pshared);\n   int res = REAL(pthread_spin_init)(m, pshared);\n@@ -1442,7 +1442,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_tryrdlock, void *m) {\n   return res;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, pthread_rwlock_timedrdlock, void *m, void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedrdlock, m, abstime);\n   int res = REAL(pthread_rwlock_timedrdlock)(m, abstime);\n@@ -1472,7 +1472,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_trywrlock, void *m) {\n   return res;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, pthread_rwlock_timedwrlock, void *m, void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedwrlock, m, abstime);\n   int res = REAL(pthread_rwlock_timedwrlock)(m, abstime);\n@@ -1490,7 +1490,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {\n   return res;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, pthread_barrier_init, void *b, void *a, unsigned count) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_barrier_init, b, a, count);\n   MemoryAccess(thr, pc, (uptr)b, 1, kAccessWrite);\n@@ -1524,7 +1524,7 @@ TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n     return errno_EINVAL;\n   atomic_uint32_t *a;\n \n-  if (SANITIZER_MAC)\n+  if (SANITIZER_APPLE)\n     a = static_cast<atomic_uint32_t*>((void *)((char *)o + sizeof(long_t)));\n   else if (SANITIZER_NETBSD)\n     a = static_cast<atomic_uint32_t*>\n@@ -1534,7 +1534,7 @@ TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n \n   // Mac OS X appears to use pthread_once() where calling BlockingRegion hooks\n   // result in crashes due to too little stack space.\n-  if (guard_acquire(thr, pc, a, !SANITIZER_MAC)) {\n+  if (guard_acquire(thr, pc, a, !SANITIZER_APPLE)) {\n     (*f)();\n     guard_release(thr, pc, a, kGuardDone);\n   }\n@@ -1661,7 +1661,7 @@ TSAN_INTERCEPTOR(int, dup2, int oldfd, int newfd) {\n   return newfd2;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, dup3, int oldfd, int newfd, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(dup3, oldfd, newfd, flags);\n   int newfd2 = REAL(dup3)(oldfd, newfd, flags);\n@@ -1805,7 +1805,7 @@ TSAN_INTERCEPTOR(int, pipe, int *pipefd) {\n   return res;\n }\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n TSAN_INTERCEPTOR(int, pipe2, int *pipefd, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(pipe2, pipefd, flags);\n   int res = REAL(pipe2)(pipefd, flags);\n@@ -2263,7 +2263,7 @@ TSAN_INTERCEPTOR(int, clone, int (*fn)(void *), void *stack, int flags,\n }\n #endif\n \n-#if !SANITIZER_MAC && !SANITIZER_ANDROID\n+#if !SANITIZER_APPLE && !SANITIZER_ANDROID\n typedef int (*dl_iterate_phdr_cb_t)(__sanitizer_dl_phdr_info *info, SIZE_T size,\n                                     void *data);\n struct dl_iterate_phdr_data {\n@@ -2320,7 +2320,7 @@ struct TsanInterceptorContext {\n   const uptr pc;\n };\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n static void HandleRecvmsg(ThreadState *thr, uptr pc,\n     __sanitizer_msghdr *msg) {\n   int fds[64];\n@@ -2460,7 +2460,7 @@ static void HandleRecvmsg(ThreadState *thr, uptr pc,\n                             off);                                           \\\n   } while (false)\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n #define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) \\\n   HandleRecvmsg(((TsanInterceptorContext *)ctx)->thr, \\\n       ((TsanInterceptorContext *)ctx)->pc, msg)\n@@ -2521,7 +2521,7 @@ int sigaction_impl(int sig, const __sanitizer_sigaction *act,\n     sigactions[sig].sa_flags = *(volatile int const *)&act->sa_flags;\n     internal_memcpy(&sigactions[sig].sa_mask, &act->sa_mask,\n                     sizeof(sigactions[sig].sa_mask));\n-#if !SANITIZER_FREEBSD && !SANITIZER_MAC && !SANITIZER_NETBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_APPLE && !SANITIZER_NETBSD\n     sigactions[sig].sa_restorer = act->sa_restorer;\n #endif\n     internal_memcpy(&newact, act, sizeof(newact));\n@@ -2568,7 +2568,7 @@ struct ScopedSyscall {\n   }\n };\n \n-#if !SANITIZER_FREEBSD && !SANITIZER_MAC\n+#if !SANITIZER_FREEBSD && !SANITIZER_APPLE\n static void syscall_access_range(uptr pc, uptr p, uptr s, bool write) {\n   TSAN_SYSCALL();\n   MemoryAccessRange(thr, pc, p, s, write);\n@@ -2772,7 +2772,7 @@ static void finalize(void *arg) {\n     Die();\n }\n \n-#if !SANITIZER_MAC && !SANITIZER_ANDROID\n+#if !SANITIZER_APPLE && !SANITIZER_ANDROID\n static void unreachable() {\n   Report(\"FATAL: ThreadSanitizer: unreachable called\\n\");\n   Die();\n@@ -2783,7 +2783,7 @@ static void unreachable() {\n SANITIZER_WEAK_ATTRIBUTE void InitializeLibdispatchInterceptors() {}\n \n void InitializeInterceptors() {\n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n   // We need to setup it early, because functions like dlsym() can call it.\n   REAL(memset) = internal_memset;\n   REAL(memcpy) = internal_memcpy;\n@@ -2795,7 +2795,7 @@ void InitializeInterceptors() {\n   InitializeSignalInterceptors();\n   InitializeLibdispatchInterceptors();\n \n-#if !SANITIZER_MAC\n+#if !SANITIZER_APPLE\n   // We can not use TSAN_INTERCEPT to get setjmp addr,\n   // because it does &setjmp and setjmp is not present in some versions of libc.\n   using __interception::InterceptFunction;\n@@ -2948,7 +2948,7 @@ void InitializeInterceptors() {\n   TSAN_MAYBE_INTERCEPT__LWP_EXIT;\n   TSAN_MAYBE_INTERCEPT_THR_EXIT;\n \n-#if !SANITIZER_MAC && !SANITIZER_ANDROID\n+#if !SANITIZER_APPLE && !SANITIZER_ANDROID\n   // Need to setup it, because interceptors check that the function is resolved.\n   // But atexit is emitted directly into the module, so can't be resolved.\n   REAL(atexit) = (int(*)(void(*)()))unreachable;\n@@ -2963,7 +2963,7 @@ void InitializeInterceptors() {\n     Die();\n   }\n \n-#if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n+#if !SANITIZER_APPLE && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n   if (pthread_key_create(&interceptor_ctx()->finalize_key, &thread_finalize)) {\n     Printf(\"ThreadSanitizer: failed to create thread key\\n\");\n     Die();"}, {"sha": "ac844ae8a44a87d61274cebf845c570189b6e518", "filename": "libsanitizer/tsan/tsan_malloc_mac.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"sanitizer_common/sanitizer_errno.h\"\n #include \"tsan_interceptors.h\""}, {"sha": "7c13c7335136b437a8419c013203e4d945147322", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -394,6 +394,7 @@ struct MappingGo48 {\n 0300 0000 0000 - 0700 0000 0000: -\n 0700 0000 0000 - 0770 0000 0000: metainfo (memory blocks and sync objects)\n 07d0 0000 0000 - 8000 0000 0000: -\n+PIE binaries currently not supported, but it should be theoretically possible.\n */\n \n struct MappingGoWindows {\n@@ -587,7 +588,7 @@ ALWAYS_INLINE auto SelectMapping(Arg arg) {\n #else  // SANITIZER_GO\n #  if SANITIZER_IOS && !SANITIZER_IOSSIM\n   return Func::template Apply<MappingAppleAarch64>(arg);\n-#  elif defined(__x86_64__) || SANITIZER_MAC\n+#  elif defined(__x86_64__) || SANITIZER_APPLE\n   return Func::template Apply<Mapping48AddressSpace>(arg);\n #  elif defined(__aarch64__)\n   switch (vmaSize) {"}, {"sha": "807f6be2eee378b82644c8b64965ffb76ec1797f", "filename": "libsanitizer/tsan/tsan_platform_linux.cpp", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -402,7 +402,11 @@ static uptr UnmangleLongJmpSp(uptr mangled_sp) {\n #elif defined(__powerpc__)\n # define LONG_JMP_SP_ENV_SLOT 0\n #elif SANITIZER_FREEBSD\n-# define LONG_JMP_SP_ENV_SLOT 2\n+# ifdef __aarch64__\n+#  define LONG_JMP_SP_ENV_SLOT 1\n+# else\n+#  define LONG_JMP_SP_ENV_SLOT 2\n+# endif\n #elif SANITIZER_LINUX\n # ifdef __aarch64__\n #  define LONG_JMP_SP_ENV_SLOT 13"}, {"sha": "1aac0fb27520ce56eaa8a0de00c67a487d52f5f9", "filename": "libsanitizer/tsan/tsan_platform_mac.cpp", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n \n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n@@ -200,44 +200,26 @@ void WriteMemoryProfile(char *buf, uptr buf_size, u64 uptime_ns) {\n #  if !SANITIZER_GO\n void InitializeShadowMemoryPlatform() { }\n \n-// On OS X, GCD worker threads are created without a call to pthread_create. We\n-// need to properly register these threads with ThreadCreate and ThreadStart.\n-// These threads don't have a parent thread, as they are created \"spuriously\".\n-// We're using a libpthread API that notifies us about a newly created thread.\n-// The `thread == pthread_self()` check indicates this is actually a worker\n-// thread. If it's just a regular thread, this hook is called on the parent\n-// thread.\n-typedef void (*pthread_introspection_hook_t)(unsigned int event,\n-                                             pthread_t thread, void *addr,\n-                                             size_t size);\n-extern \"C\" pthread_introspection_hook_t pthread_introspection_hook_install(\n-    pthread_introspection_hook_t hook);\n-static const uptr PTHREAD_INTROSPECTION_THREAD_CREATE = 1;\n-static const uptr PTHREAD_INTROSPECTION_THREAD_TERMINATE = 3;\n-static pthread_introspection_hook_t prev_pthread_introspection_hook;\n-static void my_pthread_introspection_hook(unsigned int event, pthread_t thread,\n-                                          void *addr, size_t size) {\n-  if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) {\n-    if (thread == pthread_self()) {\n-      // The current thread is a newly created GCD worker thread.\n-      ThreadState *thr = cur_thread();\n-      Processor *proc = ProcCreate();\n-      ProcWire(proc, thr);\n-      ThreadState *parent_thread_state = nullptr;  // No parent.\n-      Tid tid = ThreadCreate(parent_thread_state, 0, (uptr)thread, true);\n-      CHECK_NE(tid, kMainTid);\n-      ThreadStart(thr, tid, GetTid(), ThreadType::Worker);\n-    }\n-  } else if (event == PTHREAD_INTROSPECTION_THREAD_TERMINATE) {\n-    CHECK_EQ(thread, pthread_self());\n+// Register GCD worker threads, which are created without an observable call to\n+// pthread_create().\n+static void ThreadCreateCallback(uptr thread, bool gcd_worker) {\n+  if (gcd_worker) {\n     ThreadState *thr = cur_thread();\n-    if (thr->tctx) {\n-      DestroyThreadState();\n-    }\n+    Processor *proc = ProcCreate();\n+    ProcWire(proc, thr);\n+    ThreadState *parent_thread_state = nullptr;  // No parent.\n+    Tid tid = ThreadCreate(parent_thread_state, 0, (uptr)thread, true);\n+    CHECK_NE(tid, kMainTid);\n+    ThreadStart(thr, tid, GetTid(), ThreadType::Worker);\n   }\n+}\n \n-  if (prev_pthread_introspection_hook != nullptr)\n-    prev_pthread_introspection_hook(event, thread, addr, size);\n+// Destroy thread state for *all* threads.\n+static void ThreadTerminateCallback(uptr thread) {\n+  ThreadState *thr = cur_thread();\n+  if (thr->tctx) {\n+    DestroyThreadState();\n+  }\n }\n #endif\n \n@@ -261,8 +243,11 @@ void InitializePlatform() {\n \n   InitializeThreadStateStorage();\n \n-  prev_pthread_introspection_hook =\n-      pthread_introspection_hook_install(&my_pthread_introspection_hook);\n+  ThreadEventCallbacks callbacks = {\n+      .create = ThreadCreateCallback,\n+      .terminate = ThreadTerminateCallback,\n+  };\n+  InstallPthreadIntrospectionHook(callbacks);\n #endif\n \n   if (GetMacosAlignedVersion() >= MacosVersion(10, 14)) {\n@@ -316,4 +301,4 @@ int call_pthread_cancel_with_cleanup(int (*fn)(void *arg),\n \n }  // namespace __tsan\n \n-#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_APPLE"}, {"sha": "9b03adc16b996faac13a6821201295502afcb1bc", "filename": "libsanitizer/tsan/tsan_report.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -98,7 +98,7 @@ static const char *ReportTypeString(ReportType typ, uptr tag) {\n   UNREACHABLE(\"missing case\");\n }\n \n-#if SANITIZER_MAC\n+#if SANITIZER_APPLE\n static const char *const kInterposedFunctionPrefix = \"wrap_\";\n #else\n static const char *const kInterposedFunctionPrefix = \"__interceptor_\";\n@@ -200,8 +200,9 @@ static void PrintLocation(const ReportLocation *loc) {\n   } else if (loc->type == ReportLocationTLS) {\n     Printf(\"  Location is TLS of %s.\\n\\n\", thread_name(thrbuf, loc->tid));\n   } else if (loc->type == ReportLocationFD) {\n-    Printf(\"  Location is file descriptor %d created by %s at:\\n\",\n-        loc->fd, thread_name(thrbuf, loc->tid));\n+    Printf(\"  Location is file descriptor %d %s by %s at:\\n\", loc->fd,\n+           loc->fd_closed ? \"destroyed\" : \"created\",\n+           thread_name(thrbuf, loc->tid));\n     print_stack = true;\n   }\n   Printf(\"%s\", d.Default());"}, {"sha": "3c88864af147704520748b9b4a45f76d47698550", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -76,6 +76,7 @@ struct ReportLocation {\n   uptr external_tag = 0;\n   Tid tid = kInvalidTid;\n   int fd = 0;\n+  bool fd_closed = false;\n   bool suppressable = false;\n   ReportStack *stack = nullptr;\n };"}, {"sha": "db3d94518b825af11eef2313008967297d1548c5", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 76, "deletions": 23, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -45,7 +45,7 @@ void (*on_initialize)(void);\n int (*on_finalize)(int);\n #endif\n \n-#if !SANITIZER_GO && !SANITIZER_MAC\n+#if !SANITIZER_GO && !SANITIZER_APPLE\n __attribute__((tls_model(\"initial-exec\")))\n THREADLOCAL char cur_thread_placeholder[sizeof(ThreadState)] ALIGNED(\n     SANITIZER_CACHE_LINE_SIZE);\n@@ -197,30 +197,45 @@ static void DoResetImpl(uptr epoch) {\n   }\n \n   DPrintf(\"Resetting shadow...\\n\");\n-  if (!MmapFixedSuperNoReserve(ShadowBeg(), ShadowEnd() - ShadowBeg(),\n-                               \"shadow\")) {\n+  auto shadow_begin = ShadowBeg();\n+  auto shadow_end = ShadowEnd();\n+#if SANITIZER_GO\n+  CHECK_NE(0, ctx->mapped_shadow_begin);\n+  shadow_begin = ctx->mapped_shadow_begin;\n+  shadow_end = ctx->mapped_shadow_end;\n+  VPrintf(2, \"shadow_begin-shadow_end: (0x%zx-0x%zx)\\n\",\n+          shadow_begin, shadow_end);\n+#endif\n+\n+#if SANITIZER_WINDOWS\n+  auto resetFailed =\n+      !ZeroMmapFixedRegion(shadow_begin, shadow_end - shadow_begin);\n+#else\n+  auto resetFailed =\n+      !MmapFixedSuperNoReserve(shadow_begin, shadow_end-shadow_begin, \"shadow\");\n+#endif\n+  if (resetFailed) {\n     Printf(\"failed to reset shadow memory\\n\");\n     Die();\n   }\n   DPrintf(\"Resetting meta shadow...\\n\");\n   ctx->metamap.ResetClocks();\n+  StoreShadow(&ctx->last_spurious_race, Shadow::kEmpty);\n   ctx->resetting = false;\n }\n \n // Clang does not understand locking all slots in the loop:\n // error: expecting mutex 'slot.mtx' to be held at start of each loop\n void DoReset(ThreadState* thr, uptr epoch) SANITIZER_NO_THREAD_SAFETY_ANALYSIS {\n-  {\n-    for (auto& slot : ctx->slots) {\n-      slot.mtx.Lock();\n-      if (UNLIKELY(epoch == 0))\n-        epoch = ctx->global_epoch;\n-      if (UNLIKELY(epoch != ctx->global_epoch)) {\n-        // Epoch can't change once we've locked the first slot.\n-        CHECK_EQ(slot.sid, 0);\n-        slot.mtx.Unlock();\n-        return;\n-      }\n+  for (auto& slot : ctx->slots) {\n+    slot.mtx.Lock();\n+    if (UNLIKELY(epoch == 0))\n+      epoch = ctx->global_epoch;\n+    if (UNLIKELY(epoch != ctx->global_epoch)) {\n+      // Epoch can't change once we've locked the first slot.\n+      CHECK_EQ(slot.sid, 0);\n+      slot.mtx.Unlock();\n+      return;\n     }\n   }\n   DPrintf(\"#%d: DoReset epoch=%lu\\n\", thr ? thr->tid : -1, epoch);\n@@ -370,7 +385,6 @@ Context::Context()\n       }),\n       racy_mtx(MutexTypeRacy),\n       racy_stacks(),\n-      racy_addresses(),\n       fired_suppressions_mtx(MutexTypeFired),\n       slot_mtx(MutexTypeSlots),\n       resetting() {\n@@ -559,18 +573,50 @@ void UnmapShadow(ThreadState *thr, uptr addr, uptr size) {\n #endif\n \n void MapShadow(uptr addr, uptr size) {\n+  // Ensure thead registry lock held, so as to synchronize\n+  // with DoReset, which also access the mapped_shadow_* ctxt fields.\n+  ThreadRegistryLock lock0(&ctx->thread_registry);\n+  static bool data_mapped = false;\n+\n+#if !SANITIZER_GO\n   // Global data is not 64K aligned, but there are no adjacent mappings,\n   // so we can get away with unaligned mapping.\n   // CHECK_EQ(addr, addr & ~((64 << 10) - 1));  // windows wants 64K alignment\n   const uptr kPageSize = GetPageSizeCached();\n   uptr shadow_begin = RoundDownTo((uptr)MemToShadow(addr), kPageSize);\n   uptr shadow_end = RoundUpTo((uptr)MemToShadow(addr + size), kPageSize);\n-  if (!MmapFixedSuperNoReserve(shadow_begin, shadow_end - shadow_begin,\n-                               \"shadow\"))\n+  if (!MmapFixedNoReserve(shadow_begin, shadow_end - shadow_begin, \"shadow\"))\n     Die();\n+#else\n+  uptr shadow_begin = RoundDownTo((uptr)MemToShadow(addr), (64 << 10));\n+  uptr shadow_end = RoundUpTo((uptr)MemToShadow(addr + size), (64 << 10));\n+  VPrintf(2, \"MapShadow for (0x%zx-0x%zx), begin/end: (0x%zx-0x%zx)\\n\",\n+          addr, addr + size, shadow_begin, shadow_end);\n+\n+  if (!data_mapped) {\n+    // First call maps data+bss.\n+    if (!MmapFixedSuperNoReserve(shadow_begin, shadow_end - shadow_begin, \"shadow\"))\n+      Die();\n+  } else {\n+    VPrintf(2, \"ctx->mapped_shadow_{begin,end} = (0x%zx-0x%zx)\\n\",\n+            ctx->mapped_shadow_begin, ctx->mapped_shadow_end);\n+    // Second and subsequent calls map heap.\n+    if (shadow_end <= ctx->mapped_shadow_end)\n+      return;\n+    if (!ctx->mapped_shadow_begin || ctx->mapped_shadow_begin > shadow_begin)\n+       ctx->mapped_shadow_begin = shadow_begin;\n+    if (shadow_begin < ctx->mapped_shadow_end)\n+      shadow_begin = ctx->mapped_shadow_end;\n+    VPrintf(2, \"MapShadow begin/end = (0x%zx-0x%zx)\\n\",\n+            shadow_begin, shadow_end);\n+    if (!MmapFixedSuperNoReserve(shadow_begin, shadow_end - shadow_begin,\n+                                 \"shadow\"))\n+      Die();\n+    ctx->mapped_shadow_end = shadow_end;\n+  }\n+#endif\n \n   // Meta shadow is 2:1, so tread carefully.\n-  static bool data_mapped = false;\n   static uptr mapped_meta_end = 0;\n   uptr meta_begin = (uptr)MemToMeta(addr);\n   uptr meta_end = (uptr)MemToMeta(addr + size);\n@@ -587,8 +633,7 @@ void MapShadow(uptr addr, uptr size) {\n     // Windows wants 64K alignment.\n     meta_begin = RoundDownTo(meta_begin, 64 << 10);\n     meta_end = RoundUpTo(meta_end, 64 << 10);\n-    if (meta_end <= mapped_meta_end)\n-      return;\n+    CHECK_GT(meta_end, mapped_meta_end);\n     if (meta_begin < mapped_meta_end)\n       meta_begin = mapped_meta_end;\n     if (!MmapFixedSuperNoReserve(meta_begin, meta_end - meta_begin,\n@@ -651,9 +696,6 @@ void Initialize(ThreadState *thr) {\n   __tsan::InitializePlatformEarly();\n \n #if !SANITIZER_GO\n-  // Re-exec ourselves if we need to set additional env or command line args.\n-  MaybeReexec();\n-\n   InitializeAllocator();\n   ReplaceSystemMalloc();\n #endif\n@@ -722,8 +764,10 @@ void MaybeSpawnBackgroundThread() {\n int Finalize(ThreadState *thr) {\n   bool failed = false;\n \n+#if !SANITIZER_GO\n   if (common_flags()->print_module_map == 1)\n     DumpProcessMap();\n+#endif\n \n   if (flags()->atexit_sleep_ms > 0 && ThreadCount(thr) > 1)\n     internal_usleep(u64(flags()->atexit_sleep_ms) * 1000);\n@@ -952,6 +996,15 @@ void TraceSwitchPartImpl(ThreadState* thr) {\n       TraceMutexLock(thr, d.write ? EventType::kLock : EventType::kRLock, 0,\n                      d.addr, d.stack_id);\n   }\n+  // Callers of TraceSwitchPart expect that TraceAcquire will always succeed\n+  // after the call. It's possible that TryTraceFunc/TraceMutexLock above\n+  // filled the trace part exactly up to the TracePart::kAlignment gap\n+  // and the next TraceAcquire won't succeed. Skip the gap to avoid that.\n+  EventFunc *ev;\n+  if (!TraceAcquire(thr, &ev)) {\n+    CHECK(TraceSkipGap(thr));\n+    CHECK(TraceAcquire(thr, &ev));\n+  }\n   {\n     Lock lock(&ctx->slot_mtx);\n     // There is a small chance that the slot may be not queued at this point."}, {"sha": "e1e121e2ee073dc711aa79d056d79daedaba2764", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -235,7 +235,7 @@ struct ThreadState {\n } ALIGNED(SANITIZER_CACHE_LINE_SIZE);\n \n #if !SANITIZER_GO\n-#if SANITIZER_MAC || SANITIZER_ANDROID\n+#if SANITIZER_APPLE || SANITIZER_ANDROID\n ThreadState *cur_thread();\n void set_cur_thread(ThreadState *thr);\n void cur_thread_finalize();\n@@ -256,7 +256,7 @@ inline void set_cur_thread(ThreadState *thr) {\n   reinterpret_cast<ThreadState *>(cur_thread_placeholder)->current = thr;\n }\n inline void cur_thread_finalize() { }\n-#  endif  // SANITIZER_MAC || SANITIZER_ANDROID\n+#  endif  // SANITIZER_APPLE || SANITIZER_ANDROID\n #endif  // SANITIZER_GO\n \n class ThreadContext final : public ThreadContextBase {\n@@ -314,9 +314,43 @@ struct Context {\n \n   ThreadRegistry thread_registry;\n \n+  // This is used to prevent a very unlikely but very pathological behavior.\n+  // Since memory access handling is not synchronized with DoReset,\n+  // a thread running concurrently with DoReset can leave a bogus shadow value\n+  // that will be later falsely detected as a race. For such false races\n+  // RestoreStack will return false and we will not report it.\n+  // However, consider that a thread leaves a whole lot of such bogus values\n+  // and these values are later read by a whole lot of threads.\n+  // This will cause massive amounts of ReportRace calls and lots of\n+  // serialization. In very pathological cases the resulting slowdown\n+  // can be >100x. This is very unlikely, but it was presumably observed\n+  // in practice: https://github.com/google/sanitizers/issues/1552\n+  // If this happens, previous access sid+epoch will be the same for all of\n+  // these false races b/c if the thread will try to increment epoch, it will\n+  // notice that DoReset has happened and will stop producing bogus shadow\n+  // values. So, last_spurious_race is used to remember the last sid+epoch\n+  // for which RestoreStack returned false. Then it is used to filter out\n+  // races with the same sid+epoch very early and quickly.\n+  // It is of course possible that multiple threads left multiple bogus shadow\n+  // values and all of them are read by lots of threads at the same time.\n+  // In such case last_spurious_race will only be able to deduplicate a few\n+  // races from one thread, then few from another and so on. An alternative\n+  // would be to hold an array of such sid+epoch, but we consider such scenario\n+  // as even less likely.\n+  // Note: this can lead to some rare false negatives as well:\n+  // 1. When a legit access with the same sid+epoch participates in a race\n+  // as the \"previous\" memory access, it will be wrongly filtered out.\n+  // 2. When RestoreStack returns false for a legit memory access because it\n+  // was already evicted from the thread trace, we will still remember it in\n+  // last_spurious_race. Then if there is another racing memory access from\n+  // the same thread that happened in the same epoch, but was stored in the\n+  // next thread trace part (which is still preserved in the thread trace),\n+  // we will also wrongly filter it out while RestoreStack would actually\n+  // succeed for that second memory access.\n+  RawShadow last_spurious_race;\n+\n   Mutex racy_mtx;\n   Vector<RacyStacks> racy_stacks;\n-  Vector<RacyAddress> racy_addresses;\n   // Number of fired suppressions may be large enough.\n   Mutex fired_suppressions_mtx;\n   InternalMmapVector<FiredSuppression> fired_suppressions;\n@@ -338,6 +372,10 @@ struct Context {\n   uptr trace_part_total_allocated SANITIZER_GUARDED_BY(slot_mtx);\n   uptr trace_part_recycle_finished SANITIZER_GUARDED_BY(slot_mtx);\n   uptr trace_part_finished_excess SANITIZER_GUARDED_BY(slot_mtx);\n+#if SANITIZER_GO\n+  uptr mapped_shadow_begin;\n+  uptr mapped_shadow_end;\n+#endif\n };\n \n extern Context *ctx;  // The one and the only global runtime context."}, {"sha": "8b20984a01000603e533faa824174fedba6269b6", "filename": "libsanitizer/tsan/tsan_rtl_access.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_access.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_access.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_access.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -145,15 +145,6 @@ void TraceTime(ThreadState* thr) {\n   TraceEvent(thr, ev);\n }\n \n-ALWAYS_INLINE RawShadow LoadShadow(RawShadow* p) {\n-  return static_cast<RawShadow>(\n-      atomic_load((atomic_uint32_t*)p, memory_order_relaxed));\n-}\n-\n-ALWAYS_INLINE void StoreShadow(RawShadow* sp, RawShadow s) {\n-  atomic_store((atomic_uint32_t*)sp, static_cast<u32>(s), memory_order_relaxed);\n-}\n-\n NOINLINE void DoReportRace(ThreadState* thr, RawShadow* shadow_mem, Shadow cur,\n                            Shadow old,\n                            AccessType typ) SANITIZER_NO_THREAD_SAFETY_ANALYSIS {"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "c2cff60e2da2e380036b4f06a679f81557c25833", "filename": "libsanitizer/tsan/tsan_rtl_report.cpp", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -281,16 +281,16 @@ void ScopedReportBase::AddLocation(uptr addr, uptr size) {\n   int fd = -1;\n   Tid creat_tid = kInvalidTid;\n   StackID creat_stack = 0;\n-  if (FdLocation(addr, &fd, &creat_tid, &creat_stack)) {\n+  bool closed = false;\n+  if (FdLocation(addr, &fd, &creat_tid, &creat_stack, &closed)) {\n     auto *loc = New<ReportLocation>();\n     loc->type = ReportLocationFD;\n+    loc->fd_closed = closed;\n     loc->fd = fd;\n     loc->tid = creat_tid;\n     loc->stack = SymbolizeStackId(creat_stack);\n     rep_->locs.PushBack(loc);\n-    ThreadContext *tctx = FindThreadByTidLocked(creat_tid);\n-    if (tctx)\n-      AddThread(tctx);\n+    AddThread(creat_tid);\n     return;\n   }\n   MBlock *b = 0;\n@@ -312,8 +312,7 @@ void ScopedReportBase::AddLocation(uptr addr, uptr size) {\n     loc->tid = b->tid;\n     loc->stack = SymbolizeStackId(b->stk);\n     rep_->locs.PushBack(loc);\n-    if (ThreadContext *tctx = FindThreadByTidLocked(b->tid))\n-      AddThread(tctx);\n+    AddThread(b->tid);\n     return;\n   }\n   bool is_stack = false;\n@@ -629,35 +628,6 @@ static bool HandleRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2]) {\n   return false;\n }\n \n-static bool FindRacyAddress(const RacyAddress &ra0) {\n-  for (uptr i = 0; i < ctx->racy_addresses.Size(); i++) {\n-    RacyAddress ra2 = ctx->racy_addresses[i];\n-    uptr maxbeg = max(ra0.addr_min, ra2.addr_min);\n-    uptr minend = min(ra0.addr_max, ra2.addr_max);\n-    if (maxbeg < minend) {\n-      VPrintf(2, \"ThreadSanitizer: suppressing report as doubled (addr)\\n\");\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-static bool HandleRacyAddress(ThreadState *thr, uptr addr_min, uptr addr_max) {\n-  if (!flags()->suppress_equal_addresses)\n-    return false;\n-  RacyAddress ra0 = {addr_min, addr_max};\n-  {\n-    ReadLock lock(&ctx->racy_mtx);\n-    if (FindRacyAddress(ra0))\n-      return true;\n-  }\n-  Lock lock(&ctx->racy_mtx);\n-  if (FindRacyAddress(ra0))\n-    return true;\n-  ctx->racy_addresses.PushBack(ra0);\n-  return false;\n-}\n-\n bool OutputReport(ThreadState *thr, const ScopedReport &srep) {\n   // These should have been checked in ShouldReport.\n   // It's too late to check them here, we have already taken locks.\n@@ -730,6 +700,11 @@ static bool IsFiredSuppression(Context *ctx, ReportType type, uptr addr) {\n   return false;\n }\n \n+static bool SpuriousRace(Shadow old) {\n+  Shadow last(LoadShadow(&ctx->last_spurious_race));\n+  return last.sid() == old.sid() && last.epoch() == old.epoch();\n+}\n+\n void ReportRace(ThreadState *thr, RawShadow *shadow_mem, Shadow cur, Shadow old,\n                 AccessType typ0) {\n   CheckedMutex::CheckNoLocks();\n@@ -750,6 +725,8 @@ void ReportRace(ThreadState *thr, RawShadow *shadow_mem, Shadow cur, Shadow old,\n       ((typ0 & kAccessAtomic) || (typ1 & kAccessAtomic)) &&\n       !(typ0 & kAccessFree) && !(typ1 & kAccessFree))\n     return;\n+  if (SpuriousRace(old))\n+    return;\n \n   const uptr kMop = 2;\n   Shadow s[kMop] = {cur, old};\n@@ -761,8 +738,6 @@ void ReportRace(ThreadState *thr, RawShadow *shadow_mem, Shadow cur, Shadow old,\n   uptr addr_max = max(end0, end1);\n   if (IsExpectedReport(addr_min, addr_max - addr_min))\n     return;\n-  if (HandleRacyAddress(thr, addr_min, addr_max))\n-    return;\n \n   ReportType rep_typ = ReportTypeRace;\n   if ((typ0 & kAccessVptr) && (typ1 & kAccessFree))\n@@ -791,9 +766,13 @@ void ReportRace(ThreadState *thr, RawShadow *shadow_mem, Shadow cur, Shadow old,\n   Lock slot_lock(&ctx->slots[static_cast<uptr>(s[1].sid())].mtx);\n   ThreadRegistryLock l0(&ctx->thread_registry);\n   Lock slots_lock(&ctx->slot_mtx);\n+  if (SpuriousRace(old))\n+    return;\n   if (!RestoreStack(EventType::kAccessExt, s[1].sid(), s[1].epoch(), addr1,\n-                    size1, typ1, &tids[1], &traces[1], mset[1], &tags[1]))\n+                    size1, typ1, &tids[1], &traces[1], mset[1], &tags[1])) {\n+    StoreShadow(&ctx->last_spurious_race, old.raw());\n     return;\n+  }\n \n   if (IsFiredSuppression(ctx, rep_typ, traces[1]))\n     return;"}, {"sha": "77488f8432854235476ef9a7301e61e612ae4caa", "filename": "libsanitizer/tsan/tsan_rtl_thread.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -53,7 +53,7 @@ static void CollectThreadLeaks(ThreadContextBase *tctx_base, void *arg) {\n \n // Disabled on Mac because lldb test TestTsanBasic fails:\n // https://reviews.llvm.org/D112603#3163158\n-#if !SANITIZER_GO && !SANITIZER_MAC\n+#if !SANITIZER_GO && !SANITIZER_APPLE\n static void ReportIgnoresEnabled(ThreadContext *tctx, IgnoreSet *set) {\n   if (tctx->tid == kMainTid) {\n     Printf(\"ThreadSanitizer: main thread finished with ignores enabled\\n\");"}, {"sha": "6b8114ef51325e33b0794d8c641f5b4e7f4d40bd", "filename": "libsanitizer/tsan/tsan_shadow.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_shadow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Ftsan%2Ftsan_shadow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_shadow.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -178,6 +178,16 @@ class Shadow {\n \n static_assert(sizeof(Shadow) == kShadowSize, \"bad Shadow size\");\n \n+ALWAYS_INLINE RawShadow LoadShadow(RawShadow *p) {\n+  return static_cast<RawShadow>(\n+      atomic_load((atomic_uint32_t *)p, memory_order_relaxed));\n+}\n+\n+ALWAYS_INLINE void StoreShadow(RawShadow *sp, RawShadow s) {\n+  atomic_store((atomic_uint32_t *)sp, static_cast<u32>(s),\n+               memory_order_relaxed);\n+}\n+\n }  // namespace __tsan\n \n #endif"}, {"sha": "25cefd46ce27ced7fb6092d8d04b5074c56ebe95", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -50,7 +50,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "410292a0d53878d94f6592676168d5944382f12c", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -76,7 +76,7 @@ enum TypeCheckKind {\n   TCK_DynamicOperation\n };\n \n-const char *TypeCheckKinds[] = {\n+extern const char *const TypeCheckKinds[] = {\n     \"load of\", \"store to\", \"reference binding to\", \"member access within\",\n     \"member call on\", \"constructor call on\", \"downcast of\", \"downcast of\",\n     \"upcast of\", \"cast to virtual base of\", \"_Nonnull binding to\",\n@@ -894,21 +894,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "219fb15de55fe02a4544422095baa0d8532baaa0", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -215,20 +215,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "0317a3d1428c8c52e79d2b4842048c8bfdb14b5d", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -26,7 +26,7 @@ using namespace __sanitizer;\n using namespace __ubsan;\n \n namespace __ubsan {\n-  extern const char *TypeCheckKinds[];\n+  extern const char *const TypeCheckKinds[];\n }\n \n // Returns true if UBSan has printed an error report."}, {"sha": "d2cc2e10bd2f023b8d9aa1685a79a192a6d1e1e8", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -12,7 +12,6 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n     defined(__NetBSD__) || defined(__DragonFly__) ||                           \\\n@@ -22,6 +21,5 @@\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}, {"sha": "dc61e5b939d952b11a2080f43599771e3e454d63", "filename": "libsanitizer/ubsan/ubsan_value.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_value.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600413c4f3d70392285192fb99634bcbeb97f83f/libsanitizer%2Fubsan%2Fubsan_value.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.cpp?ref=600413c4f3d70392285192fb99634bcbeb97f83f", "patch": "@@ -18,9 +18,7 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n \n-// TODO(dliew): Prefer '__APPLE__' here over 'SANITIZER_MAC', as the latter is\n-// unclear. rdar://58124919 tracks using a more obviously portable guard.\n-#if defined(__APPLE__)\n+#if SANITIZER_APPLE\n #include <dlfcn.h>\n #endif\n \n@@ -29,7 +27,7 @@ using namespace __ubsan;\n typedef const char *(*ObjCGetClassNameTy)(void *);\n \n const char *__ubsan::getObjCClassName(ValueHandle Pointer) {\n-#if defined(__APPLE__)\n+#if SANITIZER_APPLE\n   // We need to query the ObjC runtime for some information, but do not want\n   // to introduce a static dependency from the ubsan runtime onto ObjC. Try to\n   // grab a handle to the ObjC runtime used by the process."}]}