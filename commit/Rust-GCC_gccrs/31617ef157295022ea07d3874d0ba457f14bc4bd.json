{"sha": "31617ef157295022ea07d3874d0ba457f14bc4bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE2MTdlZjE1NzI5NTAyMmVhMDdkMzg3NGQwYmE0NTdmMTRiYzRiZA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-04-06T20:03:15Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-04-06T20:03:15Z"}, "message": "params.def (PARAM_SALIAS_MAX_IMPLICIT_FIELDS): New\n\n2005-04-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* params.def (PARAM_SALIAS_MAX_IMPLICIT_FIELDS): New\n\t* params.h (SALIAS_MAX_IMPLICIT_FIELDS): New\n\t* doc/invoke.texi: Documnet salias-max-implicit-fields.\n\t* tree-ssa-alias.c (struct used_part): Add implicit_uses and\n\texplicit_uses members.\n\t(get_or_create_used_part_for): Initialize new fields.\n\t(fieldoff_compare): New function.\n\t(create_overlap_variables_for): Count number of fields, use\n\theuristic to determine whether to create subvars for vars with\n\tonly implicit uses.\n\tSort the field list by offset and avoid creating duplicate SFT's.\n\nFrom-SVN: r97746", "tree": {"sha": "6a06c9e86888c19907695323e00a5fc66d7d3ed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a06c9e86888c19907695323e00a5fc66d7d3ed5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31617ef157295022ea07d3874d0ba457f14bc4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31617ef157295022ea07d3874d0ba457f14bc4bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31617ef157295022ea07d3874d0ba457f14bc4bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31617ef157295022ea07d3874d0ba457f14bc4bd/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e9944320fd51bb3b61bff832f01614156f75cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9944320fd51bb3b61bff832f01614156f75cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9944320fd51bb3b61bff832f01614156f75cb8"}], "stats": {"total": 126, "additions": 116, "deletions": 10}, "files": [{"sha": "aa8bcc5d20de5974c15cbaf40e94df57dff26899", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31617ef157295022ea07d3874d0ba457f14bc4bd", "patch": "@@ -1,3 +1,17 @@\n+2005-04-06  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* params.def (PARAM_SALIAS_MAX_IMPLICIT_FIELDS): New\n+\t* params.h (SALIAS_MAX_IMPLICIT_FIELDS): New\n+\t* doc/invoke.texi: Documnet salias-max-implicit-fields.\n+\t* tree-ssa-alias.c (struct used_part): Add implicit_uses and\n+\texplicit_uses members.\n+\t(get_or_create_used_part_for): Initialize new fields.\n+\t(fieldoff_compare): New function.\n+\t(create_overlap_variables_for): Count number of fields, use\n+\theuristic to determine whether to create subvars for vars with\n+\tonly implicit uses.\n+\tSort the field list by offset and avoid creating duplicate SFT's.\n+\n 2005-04-06  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* c.opt (-F): Remove trailing whitespace from help string."}, {"sha": "e36aa3a2e04cf5ba9d7776affa869016325ddcb0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=31617ef157295022ea07d3874d0ba457f14bc4bd", "patch": "@@ -5445,6 +5445,11 @@ In each case, the @var{value} is an integer.  The allowable choices for\n @var{name} are given in the following table:\n \n @table @gcctabopt\n+@item salias-max-implicit-fields\n+The maximum number of fields in a variable without direct\n+structure accesses for which structure aliasing will consider trying \n+to track each field.  The default is 5\n+\n @item sra-max-structure-size\n The maximum structure size, in bytes, at which the scalar replacement\n of aggregates (SRA) optimization will perform block copies.  The"}, {"sha": "6a90a02bae6c22552701071ad4588d7fd7b68146", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=31617ef157295022ea07d3874d0ba457f14bc4bd", "patch": "@@ -35,6 +35,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Be sure to add an entry to invoke.texi summarizing the parameter.  */\n \n+/* The maximum number of fields in a variable with only implicit uses\n+   for which structure aliasing will consider trying to track each\n+   field.  The default is 5.  */\n+DEFPARAM (PARAM_SALIAS_MAX_IMPLICIT_FIELDS,\n+\t  \"salias-max-implicit-fields\",\n+\t  \"The maximum number of fields in a structure variable without direct structure accesses that GCC will attempt to track separately\",\n+\t  5, 0, 0)\n+   \n /* The maximum structure size at which the scalar replacement of\n    aggregates (SRA) pass will perform block copies.  The default\n    value, 0, implies that GCC will select the most appropriate size"}, {"sha": "0f872d031d09fbd46938b60b3dcefba62ee6e72f", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=31617ef157295022ea07d3874d0ba457f14bc4bd", "patch": "@@ -89,6 +89,8 @@ typedef enum compiler_param\n   (compiler_params[(int) ENUM].value)\n \n /* Macros for the various parameters.  */\n+#define SALIAS_MAX_IMPLICIT_FIELDS \\\n+  PARAM_VALUE (PARAM_SALIAS_MAX_IMPLICIT_FIELDS)\n #define SRA_MAX_STRUCTURE_SIZE \\\n   PARAM_VALUE (PARAM_SRA_MAX_STRUCTURE_SIZE)\n #define SRA_FIELD_STRUCTURE_RATIO \\"}, {"sha": "17bf8c5cb766858b01bd254daeaa3111f23f6bec", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 87, "deletions": 10, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31617ef157295022ea07d3874d0ba457f14bc4bd/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=31617ef157295022ea07d3874d0ba457f14bc4bd", "patch": "@@ -2780,6 +2780,13 @@ typedef struct used_part\n {\n   HOST_WIDE_INT minused;\n   HOST_WIDE_INT maxused;\n+  /* True if we have an explicit use/def of some portion of this variable,\n+     even if it is all of it. i.e. a.b = 5 or temp = a.b.  */\n+  bool explicit_uses;\n+  /* True if we have an implicit use/def of some portion of this\n+     variable.  Implicit uses occur when we can't tell what part we\n+     are referencing, and have to make conservative assumptions.  */\n+  bool implicit_uses;\n } *used_part_t;\n \n /* An array of used_part structures, indexed by variable uid.  */\n@@ -2798,14 +2805,32 @@ get_or_create_used_part_for (size_t uid)\n       up = xcalloc (1, sizeof (struct used_part));\n       up->minused = INT_MAX;\n       up->maxused = 0;\n+      up->explicit_uses = false;\n+      up->implicit_uses = false;\n     }\n   else\n     up = used_portions[uid];\n   return up;\n }\n \n-\t    \n-  \n+/* qsort comparison function for two fieldoff_t's PA and PB */\n+\n+static int \n+fieldoff_compare (const void *pa, const void *pb)\n+{\n+  const fieldoff_t foa = *(fieldoff_t *)pa;\n+  const fieldoff_t fob = *(fieldoff_t *)pb;\n+  HOST_WIDE_INT foasize, fobsize;\n+  if (foa->offset != fob->offset)\n+    return foa->offset - fob->offset;\n+\n+  foasize = TREE_INT_CST_LOW (DECL_SIZE (foa->field));\n+  fobsize = TREE_INT_CST_LOW (DECL_SIZE (fob->field));\n+  if (foasize != fobsize)\n+    return foasize - fobsize;\n+  return 0;\n+}\n+\n /* Given an aggregate VAR, create the subvariables that represent its\n    fields.  */\n \n@@ -2819,13 +2844,18 @@ create_overlap_variables_for (tree var)\n   if (used_portions[uid] == NULL)\n     return;\n \n+  up = used_portions[uid];\n   push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0);\n   if (VEC_length (fieldoff_t, fieldstack) != 0)\n     {\n       subvar_t *subvars;\n       fieldoff_t fo;\n       bool notokay = false;\n+      int fieldcount = 0;\n       int i;\n+      HOST_WIDE_INT lastfooffset = -1;\n+      HOST_WIDE_INT lastfosize = -1;\n+      tree lastfotype = NULL_TREE;\n \n       /* Not all fields have DECL_SIZE set, and those that don't, we don't\n \t know their size, and thus, can't handle.\n@@ -2846,7 +2876,34 @@ create_overlap_variables_for (tree var)\n \t      notokay = true;\n \t      break;\n \t    }\n+          fieldcount++;\n \t}\n+\n+      /* The current heuristic we use is as follows:\n+\t If the variable has no used portions in this function, no\n+\t structure vars are created for it.\n+\t Otherwise,\n+         If the variable has less than SALIAS_MAX_IMPLICIT_FIELDS,\n+\t we always create structure vars for them.\n+\t If the variable has more than SALIAS_MAX_IMPLICIT_FIELDS, and\n+\t some explicit uses, we create structure vars for them.\n+\t If the variable has more than SALIAS_MAX_IMPLICIT_FIELDS, and\n+\t no explicit uses, we do not create structure vars for them.\n+      */\n+      \n+      if (fieldcount >= SALIAS_MAX_IMPLICIT_FIELDS\n+\t  && !up->explicit_uses)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Variable \");\n+\t      print_generic_expr (dump_file, var, 0);\n+\t      fprintf (dump_file, \" has no explicit uses in this function, and is > SALIAS_MAX_IMPLICIT_FIELDS, so skipping\\n\");\n+\t    }\n+\t  notokay = true;\n+\t}\n+      \n+    \n       /* Cleanup after ourselves if we can't create overlap variables.  */\n       if (notokay)\n \t{\n@@ -2860,25 +2917,38 @@ create_overlap_variables_for (tree var)\n \t}\n       /* Otherwise, create the variables.  */\n       subvars = lookup_subvars_for_var (var);\n-      up = used_portions[uid];\n       \n+      qsort (VEC_address (fieldoff_t, fieldstack), \n+\t     VEC_length (fieldoff_t, fieldstack), \n+\t     sizeof (fieldoff_t),\n+\t     fieldoff_compare);\n+\n       while (VEC_length (fieldoff_t, fieldstack) != 0)\n \t{\n-\t  subvar_t sv = ggc_alloc (sizeof (struct subvar));\n+\t  subvar_t sv;\n \t  HOST_WIDE_INT fosize;\n \t  var_ann_t ann;\n+\t  tree currfotype;\n \n \t  fo = VEC_pop (fieldoff_t, fieldstack);\t  \n \t  fosize = TREE_INT_CST_LOW (DECL_SIZE (fo->field));\n-\n-\t  if ((fo->offset <= up->minused\n-\t       && fo->offset + fosize <= up->minused)\n-\t      || fo->offset >= up->maxused)\n+\t  currfotype = TREE_TYPE (fo->field);\n+\n+\t  /* If this field isn't in the used portion,\n+\t     or it has the exact same offset and size as the last\n+\t     field, skip it.  */\n+\n+\t  if (((fo->offset <= up->minused\n+\t\t&& fo->offset + fosize <= up->minused)\n+\t       || fo->offset >= up->maxused)\n+\t      || (fo->offset == lastfooffset\n+\t\t  && fosize == lastfosize\n+\t\t  && currfotype == lastfotype))\n \t    {\n \t      free (fo);\n \t      continue;\n \t    }\n-\n+\t  sv = ggc_alloc (sizeof (struct subvar));\n \t  sv->offset = fo->offset;\n \t  sv->size = fosize;\n \t  sv->next = *subvars;\n@@ -2913,7 +2983,10 @@ create_overlap_variables_for (tree var)\n \t  ann->mem_tag_kind = STRUCT_FIELD; \n \t  ann->type_mem_tag = NULL;  \t\n \t  add_referenced_tmp_var (sv->var);\n-\t    \n+\t  \n+\t  lastfotype = currfotype;\n+\t  lastfooffset = fo->offset;\n+\t  lastfosize = fosize;\n \t  *subvars = sv;\n \t  free (fo);\n \t}\n@@ -2968,6 +3041,7 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t    if ((bitpos + bitsize >= up->maxused))\n \t      up->maxused = bitpos + bitsize;\t    \n \n+\t    up->explicit_uses = true;\n \t    used_portions[uid] = up;\n \n \t    *walk_subtrees = 0;\n@@ -2987,6 +3061,8 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t\tup->minused = 0;\n \t\tup->maxused = TREE_INT_CST_LOW (DECL_SIZE (ref));\n \n+\t\tup->implicit_uses = true;\n+\n \t\tused_portions[uid] = up;\n \n \t\t*walk_subtrees = 0;\n@@ -3010,6 +3086,7 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n  \n \t    up->minused = 0;\n \t    up->maxused = TREE_INT_CST_LOW (DECL_SIZE (var));\n+\t    up->implicit_uses = true;\n \n \t    used_portions[uid] = up;\n \t    *walk_subtrees = 0;"}]}