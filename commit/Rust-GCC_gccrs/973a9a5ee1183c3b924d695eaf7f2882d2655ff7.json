{"sha": "973a9a5ee1183c3b924d695eaf7f2882d2655ff7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczYTlhNWVlMTE4M2MzYjkyNGQ2OTVlYWY3ZjI4ODJkMjY1NWZmNw==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2007-06-01T11:32:07Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2007-06-01T11:32:07Z"}, "message": "libtool.m4 (LT_CMD_MAX_LEN): Try using getconf to set lt_cv_sys_max_cmd_len.\n\n2007-06-01  Steve Ellcey  <sje@cup.hp.com>\n\n\t* libltdl/m4/libtool.m4 (LT_CMD_MAX_LEN): Try using getconf\n\tto set lt_cv_sys_max_cmd_len.\n\nFrom-SVN: r125262", "tree": {"sha": "4741fb6ad8b7059f050e87cab9b9ec9a8cd36251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4741fb6ad8b7059f050e87cab9b9ec9a8cd36251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/973a9a5ee1183c3b924d695eaf7f2882d2655ff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973a9a5ee1183c3b924d695eaf7f2882d2655ff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973a9a5ee1183c3b924d695eaf7f2882d2655ff7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973a9a5ee1183c3b924d695eaf7f2882d2655ff7/comments", "author": null, "committer": null, "parents": [{"sha": "b8637750d37ec0bdd4f11b9d8a6a3f47bea6713f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8637750d37ec0bdd4f11b9d8a6a3f47bea6713f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8637750d37ec0bdd4f11b9d8a6a3f47bea6713f"}], "stats": {"total": 57, "additions": 34, "deletions": 23}, "files": [{"sha": "ae0111374c09ea14cabcd0d66a6354af62e6708c", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973a9a5ee1183c3b924d695eaf7f2882d2655ff7/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973a9a5ee1183c3b924d695eaf7f2882d2655ff7/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=973a9a5ee1183c3b924d695eaf7f2882d2655ff7", "patch": "@@ -1,3 +1,8 @@\n+2007-06-01  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* libltdl/m4/libtool.m4 (LT_CMD_MAX_LEN): Try using getconf\n+\tto set lt_cv_sys_max_cmd_len.\n+\n 2007-05-31  Dorit Nuzman   <dorit@il.ibm.com>\n \n \t* MAINTAINERS (Various Maintainers): Add myself as"}, {"sha": "df40fe83e144be6d23fd96313e2e2f97f70b697a", "filename": "libtool.m4", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973a9a5ee1183c3b924d695eaf7f2882d2655ff7/libtool.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973a9a5ee1183c3b924d695eaf7f2882d2655ff7/libtool.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libtool.m4?ref=973a9a5ee1183c3b924d695eaf7f2882d2655ff7", "patch": "@@ -1439,29 +1439,35 @@ AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n     fi\n     ;;\n   *)\n-    # Make teststring a little bigger before we do anything with it.\n-    # a 1K string should be a reasonable start.\n-    for i in 1 2 3 4 5 6 7 8 ; do\n-      teststring=$teststring$teststring\n-    done\n-    SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n-    # If test is not a shell built-in, we'll probably end up computing a\n-    # maximum length that is only half of the actual maximum length, but\n-    # we can't tell.\n-    while { test \"X\"`$SHELL [$]0 --fallback-echo \"X$teststring$teststring\" 2>/dev/null` \\\n-\t       = \"XX$teststring$teststring\"; } >/dev/null 2>&1 &&\n-\t    test $i != 17 # 1/2 MB should be enough\n-    do\n-      i=`expr $i + 1`\n-      teststring=$teststring$teststring\n-    done\n-    # Only check the string length outside the loop.\n-    lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n-    teststring=\n-    # Add a significant safety factor because C++ compilers can tack on massive\n-    # amounts of additional arguments before passing them to the linker.\n-    # It appears as though 1/2 is a usable value.\n-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n+    lt_cv_sys_max_cmd_len=`getconf ARG_MAX 2> /dev/null`\n+    if test -n $lt_cv_sys_max_cmd_len; then\n+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n+    else\n+      # Make teststring a little bigger before we do anything with it.\n+      # a 1K string should be a reasonable start.\n+      for i in 1 2 3 4 5 6 7 8 ; do\n+        teststring=$teststring$teststring\n+      done\n+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n+      # If test is not a shell built-in, we'll probably end up computing a\n+      # maximum length that is only half of the actual maximum length, but\n+      # we can't tell.\n+      while { test \"X\"`$SHELL [$]0 --fallback-echo \"X$teststring$teststring\" 2>/dev/null` \\\n+\t         = \"XX$teststring$teststring\"; } >/dev/null 2>&1 &&\n+\t      test $i != 17 # 1/2 MB should be enough\n+      do\n+        i=`expr $i + 1`\n+        teststring=$teststring$teststring\n+      done\n+      # Only check the string length outside the loop.\n+      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n+      teststring=\n+      # Add a significant safety factor because C++ compilers can tack on\n+      # massive amounts of additional arguments before passing them to the\n+      # linker.  It appears as though 1/2 is a usable value.\n+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n+    fi\n     ;;\n   esac\n ])"}]}