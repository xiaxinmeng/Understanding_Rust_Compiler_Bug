{"sha": "579847c27262b011e96575c8ac74d0aa118152f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5ODQ3YzI3MjYyYjAxMWU5NjU3NWM4YWM3NGQwYWExMTgxNTJmMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T12:02:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T12:02:54Z"}, "message": "[multiple changes]\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_aggr.adb: Minor reformatting.\n\n2014-01-21  Johannes Kanig  <kanig@adacore.com>\n\n\t* gnat1drv.adb (Gnat1drv) remove obsolete reference to -gnatd.H.\n\n2014-01-21  Bob Duff  <duff@adacore.com>\n\n\t* gnat_ugn.texi: Document the \"checks\" attribute in gnat2xml.\n\n2014-01-21  Steve Baird  <baird@adacore.com>\n\n\t* gnat_rm.texi: Improve description of SPARK_Mode pragma.\n\n2014-01-21  Vincent Celier  <celier@adacore.com>\n\n\t* prj-part.adb (Parse_Single_Project): Accept to extend a project\n\tif it has only be imported by an project being extended. When a\n\tproject that has only been imported by a project being extended\n\tis imported by another project that is not being extended,\n\treset the previous indication, so that it will be an error if\n\tthis project is extended later.\n\t* prj-tree.adb (Create_Project): Include component From_Extended\n\tin table Projects_HT\n\t* prj-tree.ads (Project_Name_And_Node): New Boolean component\n\tFrom_Extended\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.ads, atree.adb: Add Node33 and Set_Node33.\n\t* einfo.ads, einfo.adb (SPARK_Pragma): New field (SPARK_Aux_Pragma):\n\tNew field (SPARK_Pragma_Inherited): New flag\n\t(SPARK_Aux_Pragma_Inherited): New flag (SPARK_Mode_Pragmas):\n\tRemoved.\n\t* lib.ads, lib.adb: Remove SPARK_Mode_Pragma, no longer used.\n\t* opt.ads (SPARK_Mode_Pragma): New global variable.\n\t* sem.ads: Add Save_SPARK_Mode_Pragma field to Scope_Stack_Entry.\n\t* sem_ch3.adb: Use new SPARK_Mode data structures.\n\t* sem_ch6.adb: Set SPARK_Mode fields in subprogram specs and bodies.\n\t* sem_ch7.adb: Set SPARK_Mode fields in package spec and body entities.\n\t* sem_ch8.adb (Push_Scope): Save SPARK_Mode_Pragma.\n\t(Pop_Scope): Restore SPARK_Mode_Pragma.\n\t* sem_prag.adb (Analyze_Pragma, case SPARK_Mode): Rewrite for\n\tnew data structures.\n\n2014-01-21  Arnaud Charlet  <charlet@adacore.com>\n\n\t* back_end.adb: Undo previous change, not needed. Minor reformatting.\n\nFrom-SVN: r206879", "tree": {"sha": "10c2e90273b0abd9492e812836fd945b47b726dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10c2e90273b0abd9492e812836fd945b47b726dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/579847c27262b011e96575c8ac74d0aa118152f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579847c27262b011e96575c8ac74d0aa118152f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579847c27262b011e96575c8ac74d0aa118152f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579847c27262b011e96575c8ac74d0aa118152f0/comments", "author": null, "committer": null, "parents": [{"sha": "376e7d14c0a9b0fe0a53847d792c4e3352855477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/376e7d14c0a9b0fe0a53847d792c4e3352855477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/376e7d14c0a9b0fe0a53847d792c4e3352855477"}], "stats": {"total": 739, "additions": 480, "deletions": 259}, "files": [{"sha": "8e93a326d757d182bb12bab75501b6b94f6916b1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1,3 +1,54 @@\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_aggr.adb: Minor reformatting.\n+\n+2014-01-21  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* gnat1drv.adb (Gnat1drv) remove obsolete reference to -gnatd.H.\n+\n+2014-01-21  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_ugn.texi: Document the \"checks\" attribute in gnat2xml.\n+\n+2014-01-21  Steve Baird  <baird@adacore.com>\n+\n+\t* gnat_rm.texi: Improve description of SPARK_Mode pragma.\n+\n+2014-01-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-part.adb (Parse_Single_Project): Accept to extend a project\n+\tif it has only be imported by an project being extended. When a\n+\tproject that has only been imported by a project being extended\n+\tis imported by another project that is not being extended,\n+\treset the previous indication, so that it will be an error if\n+\tthis project is extended later.\n+\t* prj-tree.adb (Create_Project): Include component From_Extended\n+\tin table Projects_HT\n+\t* prj-tree.ads (Project_Name_And_Node): New Boolean component\n+\tFrom_Extended\n+\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.ads, atree.adb: Add Node33 and Set_Node33.\n+\t* einfo.ads, einfo.adb (SPARK_Pragma): New field (SPARK_Aux_Pragma):\n+\tNew field (SPARK_Pragma_Inherited): New flag\n+\t(SPARK_Aux_Pragma_Inherited): New flag (SPARK_Mode_Pragmas):\n+\tRemoved.\n+\t* lib.ads, lib.adb: Remove SPARK_Mode_Pragma, no longer used.\n+\t* opt.ads (SPARK_Mode_Pragma): New global variable.\n+\t* sem.ads: Add Save_SPARK_Mode_Pragma field to Scope_Stack_Entry.\n+\t* sem_ch3.adb: Use new SPARK_Mode data structures.\n+\t* sem_ch6.adb: Set SPARK_Mode fields in subprogram specs and bodies.\n+\t* sem_ch7.adb: Set SPARK_Mode fields in package spec and body entities.\n+\t* sem_ch8.adb (Push_Scope): Save SPARK_Mode_Pragma.\n+\t(Pop_Scope): Restore SPARK_Mode_Pragma.\n+\t* sem_prag.adb (Analyze_Pragma, case SPARK_Mode): Rewrite for\n+\tnew data structures.\n+\n+2014-01-21  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* back_end.adb: Undo previous change, not needed. Minor reformatting.\n+\n 2014-01-21  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_ch5.adb: Fix comment."}, {"sha": "44cad86f810b3c8035de6a86fe9b5d8a99420646", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -2595,6 +2595,12 @@ package body Atree is\n          return Node_Id (Nodes.Table (N + 5).Field8);\n       end Node32;\n \n+      function Node33 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 5).Field9);\n+      end Node33;\n+\n       function List1 (N : Node_Id) return List_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5336,6 +5342,12 @@ package body Atree is\n          Nodes.Table (N + 5).Field8 := Union_Id (Val);\n       end Set_Node32;\n \n+      procedure Set_Node33 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field9 := Union_Id (Val);\n+      end Set_Node33;\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "94fd5b2bf1acfff0decf22fbb749df84acc3d982", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1209,6 +1209,9 @@ package Atree is\n       function Node32 (N : Node_Id) return Node_Id;\n       pragma Inline (Node32);\n \n+      function Node33 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node33);\n+\n       function List1 (N : Node_Id) return List_Id;\n       pragma Inline (List1);\n \n@@ -2509,6 +2512,9 @@ package Atree is\n       procedure Set_Node32 (N : Node_Id; Val : Node_Id);\n       pragma Inline (Set_Node32);\n \n+      procedure Set_Node33 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node33);\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id);\n       pragma Inline (Set_List1);\n "}, {"sha": "0b8920db0b38a552966ae41c02832c06a51ddbc1", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -183,7 +183,6 @@ package body Back_End is\n    -----------------------------\n \n    procedure Scan_Compiler_Arguments is\n-\n       Next_Arg : Positive;\n       --  Next argument to be scanned\n \n@@ -247,15 +246,14 @@ package body Back_End is\n             elsif Switch_Chars (First .. Last) = \"fdump-scos\" then\n                Opt.Generate_SCO := True;\n                Opt.Generate_SCO_Instance_Table := True;\n-\n             end if;\n          end if;\n       end Scan_Back_End_Switches;\n \n       --  Local variables\n \n       Arg_Count : constant Natural := Natural (save_argc - 1);\n-      Args : Argument_List (1 .. Arg_Count);\n+      Args      : Argument_List (1 .. Arg_Count);\n \n    --  Start of processing for Scan_Compiler_Arguments\n \n@@ -271,7 +269,7 @@ package body Back_End is\n             Argv_Ptr : constant Big_String_Ptr := save_argv (Arg);\n             Argv_Len : constant Nat            := Len_Arg (Arg);\n             Argv     : constant String         :=\n-              Argv_Ptr (1 .. Natural (Argv_Len));\n+                         Argv_Ptr (1 .. Natural (Argv_Len));\n          begin\n             Args (Positive (Arg)) := new String'(Argv);\n          end;\n@@ -289,20 +287,9 @@ package body Back_End is\n             --  flag (that is we have seen a -gnatO), then the next argument\n             --  is the name of the output object file.\n \n-            if Output_File_Name_Present\n-              and then not Output_File_Name_Seen\n-            then\n+            if Output_File_Name_Present and then not Output_File_Name_Seen then\n                if Is_Switch (Argv) then\n                   Fail (\"Object file name missing after -gnatO\");\n-\n-               --  In GNATprove_Mode, such an object file is never written, and\n-               --  the call to Set_Output_Object_File_Name may fail (e.g. when\n-               --  the object file name does not have the expected suffix). So\n-               --  we skip that call when GNATprove_Mode is set.\n-\n-               elsif GNATprove_Mode then\n-                  Output_File_Name_Seen := True;\n-\n                else\n                   Set_Output_Object_File_Name (Argv);\n                   Output_File_Name_Seen := True;\n@@ -320,7 +307,9 @@ package body Back_End is\n                   Search_Directory_Present := False;\n                end if;\n \n-            elsif not Is_Switch (Argv) then -- must be a file name\n+            --  If not a switch, must be a file name\n+\n+            elsif not Is_Switch (Argv) then\n                Add_File (Argv);\n \n             --  We must recognize -nostdinc to suppress visibility on the"}, {"sha": "45088b2d59562541444f742b2a214869ed01bd3a", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 85, "deletions": 9, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -248,9 +248,9 @@ package body Einfo is\n \n    --    Thunk_Entity                    Node31\n \n-   --    SPARK_Mode_Pragmas              Node32\n+   --    SPARK_Pragma                    Node32\n \n-   --    (unused)                        Node33\n+   --    SPARK_Aux_Pragma                Node33\n \n    --    (unused)                        Node34\n \n@@ -554,9 +554,9 @@ package body Einfo is\n    --    May_Inherit_Delayed_Rep_Aspects Flag262\n    --    Has_Visible_Refinement          Flag263\n    --    Has_Body_References             Flag264\n+   --    SPARK_Pragma_Inherited          Flag265\n+   --    SPARK_Aux_Pragma_Inherited      Flag266\n \n-   --    (unused)                        Flag265\n-   --    (unused)                        Flag266\n    --    (unused)                        Flag267\n    --    (unused)                        Flag268\n    --    (unused)                        Flag269\n@@ -2835,7 +2835,25 @@ package body Einfo is\n       return Ureal21 (Id);\n    end Small_Value;\n \n-   function SPARK_Mode_Pragmas (Id : E) return N is\n+   function SPARK_Aux_Pragma (Id : E) return N is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+      return Node33 (Id);\n+   end SPARK_Aux_Pragma;\n+\n+   function SPARK_Aux_Pragma_Inherited (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+      return Flag266 (Id);\n+   end SPARK_Aux_Pragma_Inherited;\n+\n+   function SPARK_Pragma (Id : E) return N is\n    begin\n       pragma Assert\n         (Ekind_In (Id, E_Function,         --  subprogram variants\n@@ -2848,7 +2866,22 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body));\n       return Node32 (Id);\n-   end SPARK_Mode_Pragmas;\n+   end SPARK_Pragma;\n+\n+   function SPARK_Pragma_Inherited (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Function,         --  subprogram variants\n+                       E_Generic_Function,\n+                       E_Generic_Procedure,\n+                       E_Procedure,\n+                       E_Subprogram_Body)\n+           or else\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+      return Flag265 (Id);\n+   end SPARK_Pragma_Inherited;\n \n    function Spec_Entity (Id : E) return E is\n    begin\n@@ -5527,7 +5560,27 @@ package body Einfo is\n       Set_Ureal21 (Id, V);\n    end Set_Small_Value;\n \n-   procedure Set_SPARK_Mode_Pragmas (Id : E; V : N) is\n+   procedure Set_SPARK_Aux_Pragma (Id : E; V : N) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+\n+      Set_Node33 (Id, V);\n+   end Set_SPARK_Aux_Pragma;\n+\n+   procedure Set_SPARK_Aux_Pragma_Inherited (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+\n+      Set_Flag266 (Id, V);\n+   end Set_SPARK_Aux_Pragma_Inherited;\n+\n+   procedure Set_SPARK_Pragma (Id : E; V : N) is\n    begin\n       pragma Assert\n         (Ekind_In (Id, E_Function,         --  subprogram variants\n@@ -5541,7 +5594,23 @@ package body Einfo is\n                        E_Package_Body));\n \n       Set_Node32 (Id, V);\n-   end Set_SPARK_Mode_Pragmas;\n+   end Set_SPARK_Pragma;\n+\n+   procedure Set_SPARK_Pragma_Inherited (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Function,         --  subprogram variants\n+                       E_Generic_Function,\n+                       E_Generic_Procedure,\n+                       E_Procedure,\n+                       E_Subprogram_Body)\n+           or else\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+\n+      Set_Flag265 (Id, V);\n+   end Set_SPARK_Pragma_Inherited;\n \n    procedure Set_Spec_Entity (Id : E; V : E) is\n    begin\n@@ -8227,6 +8296,8 @@ package body Einfo is\n       W (\"Sec_Stack_Needed_For_Return\",     Flag167 (Id));\n       W (\"Size_Depends_On_Discriminant\",    Flag177 (Id));\n       W (\"Size_Known_At_Compile_Time\",      Flag92  (Id));\n+      W (\"SPARK_Aux_Pragma_Inherited\",      Flag266 (Id));\n+      W (\"SPARK_Pragma_Inherited\",          Flag265 (Id));\n       W (\"Static_Elaboration_Desired\",      Flag77  (Id));\n       W (\"Strict_Alignment\",                Flag145 (Id));\n       W (\"Suppress_Elaboration_Warnings\",   Flag148 (Id));\n@@ -9366,7 +9437,7 @@ package body Einfo is\n               E_Package_Body                               |\n               E_Procedure                                  |\n               E_Subprogram_Body                            =>\n-            Write_Str (\"SPARK_Mode_Pragmas\");\n+            Write_Str (\"SPARK_Pragma\");\n \n          when others                                       =>\n             Write_Str (\"Field32??\");\n@@ -9380,6 +9451,11 @@ package body Einfo is\n    procedure Write_Field33_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Generic_Package                            |\n+              E_Package                                    |\n+              E_Package_Body                               =>\n+            Write_Str (\"SPARK_Aux_Pragma\");\n+\n          when others                                       =>\n             Write_Str (\"Field33??\");\n       end case;"}, {"sha": "fc710dad085b420d3a8d4f3d2d118030ff34667b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -3801,10 +3801,35 @@ package Einfo is\n --       Small of the type, either as given in a representation clause, or\n --       as computed (as a power of two) by the compiler.\n \n---    SPARK_Mode_Pragmas (Node32)\n+--    SPARK_Aux_Pragma (Node33)\n+--       Present in package spec and body entities. For a package spec entity\n+--       it relates to the SPARK mode setting for the private part. This field\n+--       points to the N_Pragma node that applies to the private part. This is\n+--       either set with a local SPARK_Mode pragma in the private part or it is\n+--       inherited from the SPARK mode that applies to the rest of the spec.\n+--       For a package body, it similarly applies to the SPARK mode setting for\n+--       the elaboration sequence after the BEGIN. In the case where the pragma\n+--       is inherited, the SPARK_Aux_Pragma_Inherited flag is set in the\n+--       package spec or body entity.\n+\n+--    SPARK_Aux_Pragma_Inherited (Flag266)\n+--       Present in the entities of subprogram specs and bodies as well as\n+--       in package specs and bodies. Set if the SPARK_Aux_Pragma field\n+--       points to a pragma that is inherited, rather than a local one.\n+\n+--    SPARK_Pragma (Node32)\n --       Present in the entities of subprogram specs and bodies as well as in\n---       package specs and bodies. Points to a list of SPARK_Mode pragmas that\n---       apply to the related construct. Add note of what this is used for ???\n+--       package specs and bodies. Points to the N_Pragma node that applies to\n+--       the spec or body. This is either set by a local SPARK_Mode pragma or\n+--       is inherited from the context (from an outer scope for the spec case\n+--       or from the spec for the body case). In the case where it is inherited\n+--       the flag SPARK_Pragma_Inherited is set. Empty if no SPARK_Mode pragma\n+--       is applicable.\n+\n+--    SPARK_Pragma_Inherited (Flag265)\n+--       Present in the entities of subprogram specs and bodies as well as in\n+--       package specs and bodies. Set if the SPARK_Pragma field points to a\n+--       pragma that is inherited, rather than a local one.\n \n --    Spec_Entity (Node19)\n --       Defined in package body entities. Points to corresponding package\n@@ -5455,7 +5480,7 @@ package Einfo is\n    --    Subprograms_For_Type                (Node29)\n    --    Corresponding_Equality              (Node30)   (implicit /= only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n-   --    SPARK_Mode_Pragmas                  (Node32)\n+   --    SPARK_Pragma                        (Node32)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Elaboration_Entity_Required         (Flag174)\n    --    Default_Expressions_Processed       (Flag108)\n@@ -5493,6 +5518,7 @@ package Einfo is\n    --    Return_Present                      (Flag54)\n    --    Returns_By_Ref                      (Flag90)\n    --    Sec_Stack_Needed_For_Return         (Flag167)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Uses_Sec_Stack                      (Flag95)\n    --    Address_Clause                      (synth)\n    --    First_Formal                        (synth)\n@@ -5655,7 +5681,8 @@ package Einfo is\n    --    Package_Instantiation               (Node26)\n    --    Current_Use_Clause                  (Node27)\n    --    Finalizer                           (Node28)   (non-generic case only)\n-   --    SPARK_Mode_Pragmas                  (Node32)\n+   --    SPARK_Aux_Pragma                    (Node33)\n+   --    SPARK_Pragma                        (Node32)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Discard_Names                       (Flag88)\n@@ -5674,6 +5701,8 @@ package Einfo is\n    --    Is_Private_Descendant               (Flag53)\n    --    Is_Visible_Lib_Unit                 (Flag116)\n    --    Renamed_In_Spec                     (Flag231)  (non-generic case only)\n+   --    SPARK_Aux_Pragma_Inherited          (Flag266)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Static_Elaboration_Desired          (Flag77)   (non-generic case only)\n    --    Has_Null_Abstract_State             (synth)\n    --    Is_Wrapper_Package                  (synth)    (non-generic case only)\n@@ -5688,9 +5717,12 @@ package Einfo is\n    --    Scope_Depth_Value                   (Uint22)\n    --    Contract                            (Node24)\n    --    Finalizer                           (Node28)   (non-generic case only)\n-   --    SPARK_Mode_Pragmas                  (Node32)\n+   --    SPARK_Aux_Pragma                    (Node33)\n+   --    SPARK_Pragma                        (Node32)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Has_Anonymous_Master                (Flag253)\n+   --    SPARK_Aux_Pragma_Inherited          (Flag266)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Scope_Depth                         (synth)\n \n    --  E_Private_Type\n@@ -5735,7 +5767,7 @@ package Einfo is\n    --    Extra_Formals                       (Node28)\n    --    Static_Initialization               (Node30)   (init_proc only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n-   --    SPARK_Mode_Pragmas                  (Node32)\n+   --    SPARK_Pragma                        (Node32)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Delay_Cleanups                      (Flag114)\n    --    Discard_Names                       (Flag88)\n@@ -5774,6 +5806,7 @@ package Einfo is\n    --    No_Return                           (Flag113)\n    --    Requires_Overriding                 (Flag213)  (non-generic case only)\n    --    Sec_Stack_Needed_For_Return         (Flag167)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Address_Clause                      (synth)\n    --    First_Formal                        (synth)\n    --    First_Formal_With_Extras            (synth)\n@@ -5907,7 +5940,8 @@ package Einfo is\n    --    Scope_Depth_Value                   (Uint22)\n    --    Contract                            (Node24)\n    --    Extra_Formals                       (Node28)\n-   --    SPARK_Mode_Pragmas                  (Node32)\n+   --    SPARK_Pragma                        (Node32)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Scope_Depth                         (synth)\n \n    --  E_Subprogram_Type\n@@ -6609,7 +6643,10 @@ package Einfo is\n    function Size_Depends_On_Discriminant        (Id : E) return B;\n    function Size_Known_At_Compile_Time          (Id : E) return B;\n    function Small_Value                         (Id : E) return R;\n-   function SPARK_Mode_Pragmas                  (Id : E) return N;\n+   function SPARK_Aux_Pragma                    (Id : E) return N;\n+   function SPARK_Aux_Pragma_Inherited          (Id : E) return B;\n+   function SPARK_Pragma                        (Id : E) return N;\n+   function SPARK_Pragma_Inherited              (Id : E) return B;\n    function Spec_Entity                         (Id : E) return E;\n    function Static_Elaboration_Desired          (Id : E) return B;\n    function Static_Initialization               (Id : E) return N;\n@@ -7232,7 +7269,10 @@ package Einfo is\n    procedure Set_Size_Depends_On_Discriminant    (Id : E; V : B := True);\n    procedure Set_Size_Known_At_Compile_Time      (Id : E; V : B := True);\n    procedure Set_Small_Value                     (Id : E; V : R);\n-   procedure Set_SPARK_Mode_Pragmas              (Id : E; V : N);\n+   procedure Set_SPARK_Aux_Pragma                (Id : E; V : N);\n+   procedure Set_SPARK_Aux_Pragma_Inherited      (Id : E; V : B := True);\n+   procedure Set_SPARK_Pragma                    (Id : E; V : N);\n+   procedure Set_SPARK_Pragma_Inherited          (Id : E; V : B := True);\n    procedure Set_Spec_Entity                     (Id : E; V : E);\n    procedure Set_Static_Elaboration_Desired      (Id : E; V : B);\n    procedure Set_Static_Initialization           (Id : E; V : N);\n@@ -7994,7 +8034,10 @@ package Einfo is\n    pragma Inline (Size_Depends_On_Discriminant);\n    pragma Inline (Size_Known_At_Compile_Time);\n    pragma Inline (Small_Value);\n-   pragma Inline (SPARK_Mode_Pragmas);\n+   pragma Inline (SPARK_Aux_Pragma);\n+   pragma Inline (SPARK_Aux_Pragma_Inherited);\n+   pragma Inline (SPARK_Pragma);\n+   pragma Inline (SPARK_Pragma_Inherited);\n    pragma Inline (Spec_Entity);\n    pragma Inline (Static_Elaboration_Desired);\n    pragma Inline (Static_Initialization);\n@@ -8414,7 +8457,10 @@ package Einfo is\n    pragma Inline (Set_Size_Depends_On_Discriminant);\n    pragma Inline (Set_Size_Known_At_Compile_Time);\n    pragma Inline (Set_Small_Value);\n-   pragma Inline (Set_SPARK_Mode_Pragmas);\n+   pragma Inline (Set_SPARK_Aux_Pragma);\n+   pragma Inline (Set_SPARK_Aux_Pragma_Inherited);\n+   pragma Inline (Set_SPARK_Pragma);\n+   pragma Inline (Set_SPARK_Pragma_Inherited);\n    pragma Inline (Set_Spec_Entity);\n    pragma Inline (Set_Static_Elaboration_Desired);\n    pragma Inline (Set_Static_Initialization);"}, {"sha": "614700182544cc7cee3065134df581e787345b23", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1164,8 +1164,8 @@ package body Exp_Aggr is\n             elsif Is_Access_Type (Ctype) then\n                Append_To (L,\n                   Make_Assignment_Statement (Loc,\n-                     Name => Indexed_Comp,\n-                     Expression => Make_Null (Loc)));\n+                    Name       => Indexed_Comp,\n+                    Expression => Make_Null (Loc)));\n             end if;\n \n             if Needs_Finalization (Ctype) then\n@@ -1205,14 +1205,15 @@ package body Exp_Aggr is\n             --  assignment in a block.\n \n             if Present (Comp_Type)\n-                 and then Needs_Finalization (Comp_Type)\n-                 and then Is_Array_Type (Comp_Type)\n-                 and then Present (Expr)\n+              and then Needs_Finalization (Comp_Type)\n+              and then Is_Array_Type (Comp_Type)\n+              and then Present (Expr)\n             then\n-               A := Make_Block_Statement (Loc,\n-                      Handled_Statement_Sequence =>\n-                        Make_Handled_Sequence_Of_Statements (Loc,\n-                           Statements => New_List (A)));\n+               A :=\n+                 Make_Block_Statement (Loc,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (A)));\n             end if;\n \n             Append_To (L, A);\n@@ -1231,9 +1232,9 @@ package body Exp_Aggr is\n                begin\n                   A :=\n                     Make_OK_Assignment_Statement (Loc,\n-                      Name =>\n+                      Name       =>\n                         Make_Selected_Component (Loc,\n-                          Prefix =>  New_Copy_Tree (Indexed_Comp),\n+                          Prefix        =>  New_Copy_Tree (Indexed_Comp),\n                           Selector_Name =>\n                             New_Reference_To\n                               (First_Tag_Component (Full_Typ), Loc)),"}, {"sha": "e95cbb3671ef4fb358b41cc66bc01d277f6f8589", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -858,34 +858,9 @@ begin\n       Original_Operating_Mode := Operating_Mode;\n       Frontend;\n \n-      --  Exit with errors if the main source could not be parsed. Also, when\n-      --  -gnatd.H is present, the source file is not set.\n+      --  Exit with errors if the main source could not be parsed.\n \n       if Sinput.Main_Source_File = No_Source_File then\n-\n-         --  Handle -gnatd.H debug mode\n-\n-         if Debug_Flag_Dot_HH then\n-\n-            --  For -gnatd.H, lock all the tables to keep the convention that\n-            --  the backend needs to unlock the tables it wants to touch.\n-\n-            Atree.Lock;\n-            Elists.Lock;\n-            Fname.UF.Lock;\n-            Inline.Lock;\n-            Lib.Lock;\n-            Nlists.Lock;\n-            Sem.Lock;\n-            Sinput.Lock;\n-            Namet.Lock;\n-            Stringt.Lock;\n-\n-            --  And all we need to do is to call the back end\n-\n-            Back_End.Call_Back_End (Back_End.Generate_Object);\n-         end if;\n-\n          Errout.Finalize (Last_Call => True);\n          Errout.Output_Messages;\n          Exit_Program (E_Errors);"}, {"sha": "146936ce4ab2ca407ccde661468b18365cf2b097", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -6287,7 +6287,8 @@ an implicit argument of On is assumed.\n \n A SPARK_Mode pragma may be used as a configuration pragma and then has the\n semantics described below. A SPARK_Mode pragma which is not used as a\n-configuration pragma shall not have an argument of Auto.\n+configuration pragma (or an equivalent SPARK_Mode aspect_specification)\n+shall not have an argument of Auto.\n \n A SPARK_Mode pragma can be used as a local pragma only\n in the following contexts:"}, {"sha": "58b7e71ff4e8636e8bdfee8bc33d68d64f9331bb", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -15392,6 +15392,17 @@ attribute:\n mode indicates that the parameter is of mode 'in', 'in out', or 'out'.\n @end itemize\n \n+@noindent\n+All elements other than Not_An_Element have this attribute:\n+\n+@itemize @bullet\n+@item\n+checks is a comma-separated list of run-time checks that are needed\n+for that element. The possible checks are: do_accessibility_check,\n+do_discriminant_check,do_division_check,do_length_check,\n+do_overflow_check,do_range_check,do_storage_check,do_tag_check.\n+@end itemize\n+\n @noindent\n The \"kind\" part of the \"def\" and \"ref\" attributes is taken from the ASIS\n enumeration type Flat_Declaration_Kinds, declared in"}, {"sha": "b43ad98668440973c9878b4f916d0b226123288e", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -166,11 +166,6 @@ package body Lib is\n       return Units.Table (U).Source_Index;\n    end Source_Index;\n \n-   function SPARK_Mode_Pragma (U : Unit_Number_Type) return Node_Id is\n-   begin\n-      return Units.Table (U).SPARK_Mode_Pragma;\n-   end SPARK_Mode_Pragma;\n-\n    function Unit_File_Name (U : Unit_Number_Type) return File_Name_Type is\n    begin\n       return Units.Table (U).Unit_File_Name;\n@@ -259,11 +254,6 @@ package body Lib is\n       Units.Table (U).OA_Setting := C;\n    end Set_OA_Setting;\n \n-   procedure Set_SPARK_Mode_Pragma (U : Unit_Number_Type; N : Node_Id) is\n-   begin\n-      Units.Table (U).SPARK_Mode_Pragma := N;\n-   end Set_SPARK_Mode_Pragma;\n-\n    procedure Set_Unit_Name (U : Unit_Number_Type; N : Unit_Name_Type) is\n    begin\n       Units.Table (U).Unit_Name := N;"}, {"sha": "00959cd29130281af7806b8a718844c77a0362ab", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -371,10 +371,6 @@ package Lib is\n    --      Set when the entry is created by a call to Lib.Load and then cannot\n    --      be changed.\n \n-   --    SPARK_Mode_Pragma\n-   --      Pointer to the configuration pragma SPARK_Mode that applies to the\n-   --      whole unit. Add note of what this is used for ???\n-\n    --    Unit_File_Name\n    --      The name of the source file containing the unit. Set when the entry\n    --      is created by a call to Lib.Load, and then cannot be changed.\n@@ -426,7 +422,6 @@ package Lib is\n    function Munit_Index       (U : Unit_Number_Type) return Nat;\n    function OA_Setting        (U : Unit_Number_Type) return Character;\n    function Source_Index      (U : Unit_Number_Type) return Source_File_Index;\n-   function SPARK_Mode_Pragma (U : Unit_Number_Type) return Node_Id;\n    function Unit_File_Name    (U : Unit_Number_Type) return File_Name_Type;\n    function Unit_Name         (U : Unit_Number_Type) return Unit_Name_Type;\n    --  Get value of named field from given units table entry\n@@ -445,7 +440,6 @@ package Lib is\n    procedure Set_Main_CPU          (U : Unit_Number_Type; P : Int);\n    procedure Set_Main_Priority     (U : Unit_Number_Type; P : Int);\n    procedure Set_OA_Setting        (U : Unit_Number_Type; C : Character);\n-   procedure Set_SPARK_Mode_Pragma (U : Unit_Number_Type; N : Node_Id);\n    procedure Set_Unit_Name         (U : Unit_Number_Type; N : Unit_Name_Type);\n    --  Set value of named field for given units table entry. Note that we\n    --  do not have an entry for each possible field, since some of the fields\n@@ -749,10 +743,8 @@ private\n    pragma Inline (Set_Main_CPU);\n    pragma Inline (Set_Main_Priority);\n    pragma Inline (Set_OA_Setting);\n-   pragma Inline (Set_SPARK_Mode_Pragma);\n    pragma Inline (Set_Unit_Name);\n    pragma Inline (Source_Index);\n-   pragma Inline (SPARK_Mode_Pragma);\n    pragma Inline (Unit_File_Name);\n    pragma Inline (Unit_Name);\n "}, {"sha": "05cea8aa5a7c58529ca68a80a6f2420bcd375ad1", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1,5 +1,5 @@\n ------------------------------------------------------------------------------\n---                                SPARK                                          --\n+--                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n --                                  O P T                                   --\n@@ -1272,6 +1272,11 @@ package Opt is\n    --  GNAT\n    --  Current SPARK mode setting\n \n+   SPARK_Mode_Pragma : Node_Id := Empty;\n+   --  GNAT\n+   --  If the current SPARK_Mode (above) was set by a pragma, this records\n+   --  the pragma that set this mode.\n+\n    SPARK_Switches_File_Name : String_Ptr := null;\n    --  GNAT\n    --  Set to non-null file name by use of the -gnates switch to specify\n@@ -1909,8 +1914,13 @@ package Opt is\n    --  start of analyzing each unit.\n \n    SPARK_Mode_Config : SPARK_Mode_Type := None;\n+   --  GNAT\n    --  The setting of SPARK_Mode from configuration pragmas\n \n+   SPARK_Mode_Pragma_Config : Node_Id := Empty;\n+   --  If a SPARK_Mode pragma appeared in the configuration pragmas (setting\n+   --  SPARK_Mode_Config appropriately), then this points to the N_Pragma node.\n+\n    Use_VADS_Size_Config : Boolean;\n    --  GNAT\n    --  This is the value of the configuration switch that controls the use of\n@@ -2056,6 +2066,7 @@ private\n       Polling_Required               : Boolean;\n       Short_Descriptors              : Boolean;\n       SPARK_Mode                     : SPARK_Mode_Type;\n+      SPARK_Mode_Pragma              : Node_Id;\n       Use_VADS_Size                  : Boolean;\n    end record;\n "}, {"sha": "ffcd69a2733a4ebf56a4a37feac503febdd06157", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1325,11 +1325,20 @@ package body Prj.Part is\n                         \"cannot extend the same project file several times\",\n                         Token_Ptr);\n                   end if;\n-               else\n+               elsif not A_Project_Name_And_Node.From_Extended then\n                   Error_Msg\n                     (Env.Flags,\n                      \"cannot extend an already imported project file\",\n                      Token_Ptr);\n+\n+               else\n+                  --  Register this project as being extended\n+\n+                  A_Project_Name_And_Node.Extended := True;\n+                  Tree_Private_Part.Projects_Htable.Set\n+                    (In_Tree.Projects_HT,\n+                     A_Project_Name_And_Node.Name,\n+                     A_Project_Name_And_Node);\n                end if;\n \n             elsif A_Project_Name_And_Node.Extended then\n@@ -1372,6 +1381,16 @@ package body Prj.Part is\n                      \"cannot import an already extended project file\",\n                      Token_Ptr);\n                end if;\n+\n+            elsif A_Project_Name_And_Node.From_Extended then\n+               --  This project is now imported from a non extending project.\n+               --  Indicate this in has table Projects.HT.\n+\n+               A_Project_Name_And_Node.From_Extended := False;\n+               Tree_Private_Part.Projects_Htable.Set\n+                 (In_Tree.Projects_HT,\n+                  A_Project_Name_And_Node.Name,\n+                  A_Project_Name_And_Node);\n             end if;\n \n             Project := A_Project_Name_And_Node.Node;\n@@ -1933,6 +1952,7 @@ package body Prj.Part is\n                   Node           => Project,\n                   Canonical_Path => Canonical_Path_Name,\n                   Extended       => Extended,\n+                  From_Extended  => From_Extended /= None,\n                   Proj_Qualifier => Project_Qualifier_Of (Project, In_Tree)));\n       end if;\n "}, {"sha": "13abf83f205bd2541b2e42e53f219bdfc6c466d0", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1321,8 +1321,7 @@ package body Prj.Tree is\n    begin\n       pragma Assert\n         (Present (Node)\n-          and then\n-            In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n+          and then In_Tree.Project_Nodes.Table (Node).Kind = N_Term);\n       return In_Tree.Project_Nodes.Table (Node).Field2;\n    end Next_Term;\n \n@@ -1332,18 +1331,17 @@ package body Prj.Tree is\n \n    function Next_Variable\n      (Node    : Project_Node_Id;\n-      In_Tree : Project_Node_Tree_Ref)\n-      return Project_Node_Id\n+      In_Tree : Project_Node_Tree_Ref) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n         (Present (Node)\n           and then\n-           (In_Tree.Project_Nodes.Table (Node).Kind =\n-              N_Typed_Variable_Declaration\n+            (In_Tree.Project_Nodes.Table (Node).Kind =\n+                                                  N_Typed_Variable_Declaration\n                or else\n-            In_Tree.Project_Nodes.Table (Node).Kind =\n-              N_Variable_Declaration));\n+             In_Tree.Project_Nodes.Table (Node).Kind =\n+                                                  N_Variable_Declaration));\n \n       return In_Tree.Project_Nodes.Table (Node).Field3;\n    end Next_Variable;\n@@ -2925,6 +2923,7 @@ package body Prj.Tree is\n                Canonical_Path => No_Path,\n                Node           => Project,\n                Extended       => False,\n+               From_Extended  => False,\n                Proj_Qualifier => Qualifier));\n       end if;\n "}, {"sha": "7859d4a62512e6dd052fa3b1abba1c6e70e72602", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1476,6 +1476,10 @@ package Prj.Tree is\n          Extended : Boolean;\n          --  True when the project is being extended by another project\n \n+         From_Extended : Boolean;\n+         --  True when the project is only imported by projects that are\n+         --  extended.\n+\n          Proj_Qualifier : Project_Qualifier;\n          --  The project qualifier of the project, if any\n       end record;\n@@ -1486,6 +1490,7 @@ package Prj.Tree is\n          Node           => Empty_Node,\n          Canonical_Path => No_Path,\n          Extended       => True,\n+         From_Extended  => False,\n          Proj_Qualifier => Unspecified);\n \n       package Projects_Htable is new GNAT.Dynamic_HTables.Simple_HTable"}, {"sha": "343081803f7c8362cdcf71805de52ada13f1bb4c", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -478,6 +478,9 @@ package Sem is\n       Save_SPARK_Mode : SPARK_Mode_Type;\n       --  Setting of SPARK_Mode on entry to restore on exit\n \n+      Save_SPARK_Mode_Pragma : Node_Id;\n+      --  Setting of SPARK_Mode_Pragma on entry to restore on exit\n+\n       Is_Transient : Boolean;\n       --  Marks transient scopes (see Exp_Ch7 body for details)\n "}, {"sha": "c1b9435394f412dbf3a63c2ed1edf3a329346f4a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -2162,15 +2162,15 @@ package body Sem_Ch3 is\n          --  it is and the mode is Off, the package body is considered to be in\n          --  regular Ada and does not require refinement.\n \n-         elsif Mode_Is_Off (SPARK_Mode_Pragmas (Body_Id)) then\n+         elsif Mode_Is_Off (SPARK_Pragma (Body_Id)) then\n             return False;\n \n          --  The body's SPARK_Mode may be inherited from a similar pragma that\n          --  appears in the private declarations of the spec. The pragma we are\n-         --  interested appears as the second entry in SPARK_Mode_Pragmas.\n+         --  interested appears as the second entry in SPARK_Pragma.\n \n-         elsif Present (SPARK_Mode_Pragmas (Spec_Id))\n-           and then Mode_Is_Off (Next_Pragma (SPARK_Mode_Pragmas (Spec_Id)))\n+         elsif Present (SPARK_Pragma (Spec_Id))\n+           and then Mode_Is_Off (Next_Pragma (SPARK_Pragma (Spec_Id)))\n          then\n             return False;\n "}, {"sha": "078b77124480dcb1f93e520f90c449b9ab4ba0a1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -1186,6 +1186,9 @@ package body Sem_Ch6 is\n             end loop;\n          end;\n \n+         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited (Body_Id, True);\n+\n          Analyze_Declarations (Declarations (N));\n          Check_Completion;\n          Analyze (Handled_Statement_Sequence (N));\n@@ -2923,6 +2926,8 @@ package body Sem_Ch6 is\n             Reference_Body_Formals (Spec_Id, Body_Id);\n          end if;\n \n+         Set_Ekind (Body_Id, E_Subprogram_Body);\n+\n          if Nkind (N) = N_Subprogram_Body_Stub then\n             Set_Corresponding_Spec_Of_Stub (N, Spec_Id);\n \n@@ -2989,9 +2994,17 @@ package body Sem_Ch6 is\n \n             --  Set SPARK_Mode from spec if spec had a SPARK_Mode pragma\n \n-            if Present (SPARK_Mode_Pragmas (Spec_Id)) then\n-               SPARK_Mode :=\n-                 Get_SPARK_Mode_From_Pragma (SPARK_Mode_Pragmas (Spec_Id));\n+            if Present (SPARK_Pragma (Spec_Id)) then\n+               SPARK_Mode_Pragma := SPARK_Pragma (Spec_Id);\n+               SPARK_Mode := Get_SPARK_Mode_From_Pragma (SPARK_Mode_Pragma);\n+               Set_SPARK_Pragma (Body_Id, SPARK_Pragma (Spec_Id));\n+               Set_SPARK_Pragma_Inherited (Body_Id, True);\n+\n+            --  Otherwise set from context\n+\n+            else\n+               Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+               Set_SPARK_Pragma_Inherited (Body_Id, True);\n             end if;\n \n             --  Make sure that the subprogram is immediately visible. For\n@@ -3003,7 +3016,6 @@ package body Sem_Ch6 is\n \n          Set_Corresponding_Body (Unit_Declaration_Node (Spec_Id), Body_Id);\n          Set_Contract (Body_Id, Make_Contract (Sloc (Body_Id)));\n-         Set_Ekind (Body_Id, E_Subprogram_Body);\n          Set_Scope (Body_Id, Scope (Spec_Id));\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Spec_Id));\n \n@@ -3550,8 +3562,9 @@ package body Sem_Ch6 is\n    ------------------------------------\n \n    procedure Analyze_Subprogram_Declaration (N : Node_Id) is\n-      Scop       : constant Entity_Id  := Current_Scope;\n+      Scop       : constant Entity_Id := Current_Scope;\n       Designator : Entity_Id;\n+\n       Is_Completion : Boolean;\n       --  Indicates whether a null procedure declaration is a completion\n \n@@ -3585,6 +3598,9 @@ package body Sem_Ch6 is\n \n       Generate_Definition (Designator);\n \n+      Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Designator, True);\n+\n       if Debug_Flag_C then\n          Write_Str (\"==> subprogram spec \");\n          Write_Name (Chars (Designator));"}, {"sha": "322785afb743eff78144d1a3c61d18b7198d22ad", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -346,13 +346,29 @@ package body Sem_Ch7 is\n \n       Push_Scope (Spec_Id);\n \n-      --  Set SPARK_Mode from spec if package spec had SPARK_Mode pragma\n+      --  Set SPARK_Mode from private part of spec if it has a SPARK pragma.\n+      --  Note that in the default case, SPARK_Aux_Pragma will be a copy of\n+      --  SPARK_Pragma in the spec, so this properly handles the case where\n+      --  there is no explicit SPARK_Pragma mode in the private part.\n \n-      if Present (SPARK_Mode_Pragmas (Spec_Id)) then\n-         SPARK_Mode :=\n-           Get_SPARK_Mode_From_Pragma (SPARK_Mode_Pragmas (Spec_Id));\n+      if Present (SPARK_Pragma (Spec_Id)) then\n+         SPARK_Mode_Pragma := SPARK_Aux_Pragma (Spec_Id);\n+         SPARK_Mode := Get_SPARK_Mode_From_Pragma (SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited (Body_Id, True);\n+\n+      --  Otherwise set from context\n+\n+      else\n+         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma_Inherited (Body_Id, True);\n       end if;\n \n+      --  Set elaboration code SPARK mode the same for now\n+\n+      Set_SPARK_Aux_Pragma (Body_Id, SPARK_Pragma (Body_Id));\n+      Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n+\n       Set_Categorization_From_Pragmas (N);\n \n       Install_Visible_Declarations (Spec_Id);\n@@ -798,6 +814,13 @@ package body Sem_Ch7 is\n       Set_Etype    (Id, Standard_Void_Type);\n       Set_Contract (Id, Make_Contract (Sloc (Id)));\n \n+      --  Inherit spark mode from context for now\n+\n+      Set_SPARK_Pragma               (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Aux_Pragma           (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited     (Id, True);\n+      Set_SPARK_Aux_Pragma_Inherited (Id, True);\n+\n       --  Analyze aspect specifications immediately, since we need to recognize\n       --  things like Pure early enough to diagnose violations during analysis.\n "}, {"sha": "070d38a93c2f37572dbbd3ebe3501c6e2282f1eb", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -7400,6 +7400,7 @@ package body Sem_Ch8 is\n       Check_Policy_List        := SST.Save_Check_Policy_List;\n       Default_Pool             := SST.Save_Default_Storage_Pool;\n       SPARK_Mode               := SST.Save_SPARK_Mode;\n+      SPARK_Mode_Pragma        := SST.Save_SPARK_Mode_Pragma;\n \n       if Debug_Flag_W then\n          Write_Str (\"<-- exiting scope: \");\n@@ -7474,6 +7475,7 @@ package body Sem_Ch8 is\n          SST.Save_Check_Policy_List        := Check_Policy_List;\n          SST.Save_Default_Storage_Pool     := Default_Pool;\n          SST.Save_SPARK_Mode               := SPARK_Mode;\n+         SST.Save_SPARK_Mode_Pragma        := SPARK_Mode_Pragma;\n \n          if Scope_Stack.Last > Scope_Stack.First then\n             SST.Component_Alignment_Default := Scope_Stack.Table"}, {"sha": "937ca4bcfc2ff1d844af3291b6fed27e5f3831d8", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 134, "deletions": 142, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579847c27262b011e96575c8ac74d0aa118152f0/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=579847c27262b011e96575c8ac74d0aa118152f0", "patch": "@@ -18056,116 +18056,58 @@ package body Sem_Prag is\n          --  pragma SPARK_Mode [(On | Off | Auto)];\n \n          when Pragma_SPARK_Mode => SPARK_Mod : declare\n-            procedure Chain_Pragma (Context : Entity_Id; Prag : Node_Id);\n-            --  Associate a SPARK_Mode pragma with the context where it lives.\n-            --  If the context is a package spec or a body, the routine checks\n-            --  the consistency between modes of visible/private declarations\n-            --  and body declarations/statements.\n-\n-            procedure Check_Spark_Mode_Conformance\n-              (Governing_Id : Entity_Id;\n-               New_Id       : Entity_Id);\n-            --  Verify the \"monotonicity\" of SPARK modes between two entities.\n-            --  The order of modes is Off < Auto < On. Governing_Id establishes\n-            --  the mode of the context. New_Id is the desired new mode.\n-\n-            procedure Check_Pragma_Conformance\n-              (Governing_Mode : Node_Id;\n-               New_Mode       : Node_Id);\n-            --  Verify the \"monotonicity\" of two SPARK_Mode pragmas. The order\n-            --  of modes is Off < Auto < On. Governing_Mode is the established\n-            --  mode dictated by the context. New_Mode attempts to redefine the\n-            --  governing mode.\n+            Body_Id : Entity_Id;\n+            Context : Node_Id;\n+            Mode    : Name_Id;\n+            Mode_Id : SPARK_Mode_Type;\n+            Spec_Id : Entity_Id;\n+            Stmt    : Node_Id;\n+\n+            procedure Check_Pragma_Conformance (Old_Pragma : Node_Id);\n+            --  Verify the monotonicity of SPARK modes between the new pragma\n+            --  N, and the old pragma, Old_Pragma, that was inherited. If\n+            --  Old_Pragma is Empty, the call has no effect, otherwise we\n+            --  verify that the new mode is less restrictive than the old mode.\n+            --  For example, if the old mode is ON, then the new mode can be\n+            --  anything. But if the old mode is OFF, then the only allowed\n+            --  new mode is also OFF. If there is no error, this routine also\n+            --  sets SPARK_Mode_Pragma to N, and SPARK_Mode to Mode_Id.\n \n             function Get_SPARK_Mode_Name (Id : SPARK_Mode_Type) return Name_Id;\n             --  Convert a value of type SPARK_Mode_Type to corresponding name\n \n-            ------------------\n-            -- Chain_Pragma --\n-            ------------------\n-\n-            procedure Chain_Pragma (Context : Entity_Id; Prag : Node_Id) is\n-               Existing_Prag : constant Node_Id :=\n-                                 SPARK_Mode_Pragmas (Context);\n-\n-            begin\n-               --  Chain existing pragmas to this one, checking consistency\n-\n-               if Present (Existing_Prag) then\n-                  Check_Pragma_Conformance\n-                    (Governing_Mode => Existing_Prag,\n-                     New_Mode       => Prag);\n-\n-                  Set_Next_Pragma (Prag, Existing_Prag);\n-               end if;\n-\n-               Set_SPARK_Mode_Pragmas (Context, Prag);\n-            end Chain_Pragma;\n-\n-            ----------------------------------\n-            -- Check_Spark_Mode_Conformance --\n-            ----------------------------------\n-\n-            procedure Check_Spark_Mode_Conformance\n-              (Governing_Id : Entity_Id;\n-               New_Id       : Entity_Id)\n-            is\n-               Gov_Prag : constant Node_Id :=\n-                            SPARK_Mode_Pragmas (Governing_Id);\n-               New_Prag : constant Node_Id := SPARK_Mode_Pragmas (New_Id);\n-\n-            begin\n-               --  Nothing to do when one or both entities lack a mode\n-\n-               if No (Gov_Prag) or else No (New_Prag) then\n-                  return;\n-               end if;\n-\n-               --  Do not compare the modes of a package spec and body when the\n-               --  spec mode appears in the private part. In this case the spec\n-               --  mode does not affect the body.\n-\n-               if Ekind_In (Governing_Id, E_Generic_Package, E_Package)\n-                 and then Ekind (New_Id) = E_Package_Body\n-                 and then Is_Private_SPARK_Mode (Gov_Prag)\n-               then\n-                  null;\n-\n-               --  Test the pragmas\n-\n-               else\n-                  Check_Pragma_Conformance\n-                    (Governing_Mode => Gov_Prag,\n-                     New_Mode       => New_Prag);\n-               end if;\n-            end Check_Spark_Mode_Conformance;\n-\n             ------------------------------\n             -- Check_Pragma_Conformance --\n             ------------------------------\n \n-            procedure Check_Pragma_Conformance\n-              (Governing_Mode : Node_Id;\n-               New_Mode       : Node_Id)\n-            is\n-               Gov_M : constant SPARK_Mode_Type :=\n-                         Get_SPARK_Mode_From_Pragma (Governing_Mode);\n-               New_M : constant SPARK_Mode_Type :=\n-                         Get_SPARK_Mode_From_Pragma (New_Mode);\n-\n+            procedure Check_Pragma_Conformance (Old_Pragma : Node_Id) is\n             begin\n-               --  The new mode is less restrictive than the established mode\n+               if Present (Old_Pragma) then\n+                  pragma Assert (Nkind (Old_Pragma) = N_Pragma);\n \n-               if Gov_M < New_M then\n-                  Error_Msg_Name_1 := Get_SPARK_Mode_Name (New_M);\n-                  Error_Msg_N (\"cannot define 'S'P'A'R'K mode %\", New_Mode);\n+                  declare\n+                     Gov_M : constant SPARK_Mode_Type :=\n+                                Get_SPARK_Mode_From_Pragma (Old_Pragma);\n \n-                  Error_Msg_Name_1 := Get_SPARK_Mode_Name (Gov_M);\n-                  Error_Msg_Sloc   := Sloc (Governing_Mode);\n-                  Error_Msg_N\n-                    (\"\\mode is less restrictive than mode % defined #\",\n-                     New_Mode);\n+                  begin\n+                     --  New mode less restrictive than the established mode\n+\n+                     if Gov_M < Mode_Id then\n+                        Error_Msg_Name_1 := Mode;\n+                        Error_Msg_N (\"cannot define 'S'P'A'R'K mode %\", Arg1);\n+\n+                        Error_Msg_Name_1 := Get_SPARK_Mode_Name (SPARK_Mode);\n+                        Error_Msg_Sloc   := Sloc (SPARK_Mode_Pragma);\n+                        Error_Msg_N\n+                          (\"\\mode is less restrictive than mode \"\n+                           & \"% defined #\", Arg1);\n+                        raise Pragma_Exit;\n+                     end if;\n+                  end;\n                end if;\n+\n+               SPARK_Mode_Pragma := N;\n+               SPARK_Mode := Mode_Id;\n             end Check_Pragma_Conformance;\n \n             -------------------------\n@@ -18190,15 +18132,6 @@ package body Sem_Prag is\n                end if;\n             end Get_SPARK_Mode_Name;\n \n-            --  Local variables\n-\n-            Body_Id : Entity_Id;\n-            Context : Node_Id;\n-            Mode    : Name_Id;\n-            Mode_Id : SPARK_Mode_Type;\n-            Spec_Id : Entity_Id;\n-            Stmt    : Node_Id;\n-\n          --  Start of processing for SPARK_Mod\n \n          begin\n@@ -18217,19 +18150,29 @@ package body Sem_Prag is\n \n             Mode_Id := Get_SPARK_Mode_Type (Mode);\n             Context := Parent (N);\n-            SPARK_Mode := Mode_Id;\n \n-            --  The pragma appears in a configuration file\n+            --  The pragma appears in a configuration pragmas file\n \n             if No (Context) then\n                Check_Valid_Configuration_Pragma;\n \n+               if Present (SPARK_Mode_Pragma) then\n+                  Error_Msg_Sloc := Sloc (SPARK_Mode_Pragma);\n+                  Error_Msg_N (\"pragma% duplicates pragma declared#\", N);\n+                  raise Pragma_Exit;\n+               end if;\n+\n+               SPARK_Mode_Pragma := N;\n+               SPARK_Mode := Mode_Id;\n+\n             --  When the pragma is placed before the declaration of a unit, it\n             --  configures the whole unit.\n \n             elsif Nkind (Context) = N_Compilation_Unit then\n                Check_Valid_Configuration_Pragma;\n-                  Set_SPARK_Mode_Pragma (Current_Sem_Unit, N);\n+\n+               SPARK_Mode_Pragma := N;\n+               SPARK_Mode := Mode_Id;\n \n             --  The pragma applies to a [library unit] subprogram or package\n \n@@ -18238,8 +18181,8 @@ package body Sem_Prag is\n \n                if Mode_Id = Auto then\n                   Error_Pragma_Arg\n-                    (\"mode `Auto` can only apply to the configuration variant \"\n-                     & \"of pragma %\", Arg1);\n+                    (\"mode `Auto` is only allowed when pragma % appears as \"\n+                     & \"a configuration pragma\", Arg1);\n                end if;\n \n                --  Verify the placement of the pragma with respect to package\n@@ -18255,22 +18198,39 @@ package body Sem_Prag is\n                         Error_Msg_Name_1 := Pname;\n                         Error_Msg_Sloc   := Sloc (Stmt);\n                         Error_Msg_N (\"pragma% duplicates pragma declared#\", N);\n+                        raise Pragma_Exit;\n                      end if;\n \n                   --  Skip internally generated code\n \n                   elsif not Comes_From_Source (Stmt) then\n                      null;\n \n-                  --  The pragma applies to a package or subprogram declaration\n+                  --  The pragma applies to a package declaration\n \n                   elsif Nkind_In (Stmt, N_Generic_Package_Declaration,\n-                                        N_Generic_Subprogram_Declaration,\n-                                        N_Package_Declaration,\n+                                        N_Package_Declaration)\n+                  then\n+                     Spec_Id := Defining_Unit_Name (Specification (Stmt));\n+                     Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n+\n+                     Set_SPARK_Pragma               (Spec_Id, N);\n+                     Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n+                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n+                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n+\n+                     return;\n+\n+                  --  The pragma applies to a subprogram declaration\n+\n+                  elsif Nkind_In (Stmt, N_Generic_Subprogram_Declaration,\n                                         N_Subprogram_Declaration)\n                   then\n                      Spec_Id := Defining_Unit_Name (Specification (Stmt));\n-                     Chain_Pragma (Spec_Id, N);\n+                     Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n+\n+                     Set_SPARK_Pragma               (Spec_Id, N);\n+                     Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n                      return;\n \n                   --  The pragma does not apply to a legal construct, issue an\n@@ -18304,48 +18264,79 @@ package body Sem_Prag is\n                   end if;\n                end if;\n \n-               --  The pragma is at the top level of a package spec or appears\n-               --  as an aspect on a subprogram.\n-\n-               --    function F ... with SPARK_Mode => ...;\n+               --  The pragma is at the top level of a package spec\n \n                --    package P is\n                --       pragma SPARK_Mode;\n \n-               if Nkind_In (Context, N_Function_Specification,\n-                                     N_Package_Specification,\n-                                     N_Procedure_Specification)\n+               --      or\n+\n+               --    package P is\n+               --      ...\n+               --    private\n+               --      pragma SPARK_Mode;\n+\n+               if Nkind (Context) = N_Package_Specification then\n+                  Spec_Id := Defining_Unit_Name (Context);\n+\n+                  --  Pragma applies to private part\n+\n+                  if List_Containing (N) = Private_Declarations (Context) then\n+                     Check_Pragma_Conformance (SPARK_Aux_Pragma (Spec_Id));\n+                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n+                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, False);\n+\n+                  --  Pragma applies to public part\n+\n+                  else\n+                     Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n+                     Set_SPARK_Pragma               (Spec_Id, N);\n+                     Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n+                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n+                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n+                  end if;\n+\n+               --  The pragma appears as an aspect on a subprogram.\n+\n+               --    function F ... with SPARK_Mode => ...;\n+\n+               elsif Nkind_In (Context, N_Function_Specification,\n+                                        N_Procedure_Specification)\n                then\n                   Spec_Id := Defining_Unit_Name (Context);\n-                  Chain_Pragma (Spec_Id, N);\n+                  Check_Pragma_Conformance (SPARK_Pragma (Spec_Id));\n \n-               --  Pragma is immediately within a package or subprogram body\n+                  Set_SPARK_Pragma           (Spec_Id, N);\n+                  Set_SPARK_Pragma_Inherited (Spec_Id, False);\n \n-               --    function F ... is\n-               --       pragma SPARK_Mode;\n+               --  Pragma is immediately within a package body\n \n                --    package body P is\n                --       pragma SPARK_Mode;\n \n-               elsif Nkind_In (Context, N_Package_Body,\n-                                        N_Subprogram_Body)\n-               then\n+               elsif Nkind (Context) = N_Package_Body then\n                   Spec_Id := Corresponding_Spec (Context);\n+                  Body_Id := Defining_Entity (Context);\n+                  Check_Pragma_Conformance (SPARK_Pragma (Body_Id));\n \n-                  if Nkind (Context) = N_Subprogram_Body then\n-                     Context := Specification (Context);\n-                  end if;\n+                  Set_SPARK_Pragma               (Body_Id, N);\n+                  Set_SPARK_Pragma_Inherited     (Body_Id, False);\n+                  Set_SPARK_Aux_Pragma           (Body_Id, N);\n+                  Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n \n-                  Body_Id := Defining_Entity (Context);\n+               --  Pragma is immediately within a subprogram body\n \n-                  Chain_Pragma (Body_Id, N);\n+               --    function F ... is\n+               --       pragma SPARK_Mode;\n \n-                  --  Verify that the SPARK modes are consistent between\n-                  --  body and spec, if any.\n+               elsif Nkind (Context) = N_Subprogram_Body then\n+                  Spec_Id := Corresponding_Spec (Context);\n+                  Context := Specification (Context);\n+                  Body_Id := Defining_Entity (Context);\n+                  Check_Pragma_Conformance (SPARK_Pragma (Body_Id));\n \n-                  if Present (Spec_Id) then\n-                     Check_Spark_Mode_Conformance (Spec_Id, Body_Id);\n-                  end if;\n+                  Set_SPARK_Pragma           (Body_Id, N);\n+                  Set_SPARK_Pragma_Inherited (Body_Id, False);\n \n                --  The pragma applies to the statements of a package body\n \n@@ -18359,9 +18350,10 @@ package body Sem_Prag is\n                   Context := Parent (Context);\n                   Spec_Id := Corresponding_Spec (Context);\n                   Body_Id := Defining_Unit_Name (Context);\n+                  Check_Pragma_Conformance (SPARK_Aux_Pragma (Body_Id));\n \n-                  Chain_Pragma (Body_Id, N);\n-                  Check_Spark_Mode_Conformance (Spec_Id, Body_Id);\n+                  Set_SPARK_Aux_Pragma           (Body_Id, N);\n+                  Set_SPARK_Aux_Pragma_Inherited (Body_Id, False);\n \n                --  The pragma does not apply to a legal construct, issue error\n "}]}