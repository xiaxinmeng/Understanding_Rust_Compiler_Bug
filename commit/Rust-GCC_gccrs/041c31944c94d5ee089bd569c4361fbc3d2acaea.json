{"sha": "041c31944c94d5ee089bd569c4361fbc3d2acaea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQxYzMxOTQ0Yzk0ZDVlZTA4OWJkNTY5YzQzNjFmYmMzZDJhY2FlYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-04T01:58:21Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-04T01:58:21Z"}, "message": "top level:\n\n2000-07-03  Zack Weinberg  <zack@wolery.cumb.org>\n\n\t* fix-header.c (struct partial_proto): Remove unnecessary fields.\n\t(recognized_extern, recognized_function, read_scan_file):\n\tUpdate for new scheme.\n\t(check_protection): It's still a multiple include guard even\n\tif it doesn't always trigger.\n\t* scan-decls.c (skip_to_closing_brace, scan_decls): Update for\n\tnew scheme.\n\t* scan.h: Declare struct cpp_token.  Update prototypes.\n\n2000-07-03  Neil Booth  <neilb@earthling.net>\n\t    Zack Weinberg  <zack@wolery.cumb.org>\n\n\tComplete overhaul of the lexer and macro expander.\n\n\t* cpphash.c (object_defn, funct_defn, push_macro_expansion,\n\targ, arglist, argdata, reflist, collect_objlike_expansion,\n\tcollect_funlike_expansion, collect_params,\n\twarn_trad_stringify, trad_stringify, duplicate_arg_p, add_pat,\n\tunsafe_chars, macarg, compare_defs, special_symbol,\n\tscan_arguments, stringify, funlike_macroexpand,\n\t_cpp_quote_string, monthnames): Delete.\n\t(cpp_lookup, _cpp_free_definition, dump_funlike_macro,\n\t_cpp_create_definition, _cpp_dump_definition,\n\tdump_hash_helper): Adjust.\n\t(find_param, count_params, parse_define, var_args_str,\n\tcheck_macro_redefinition, save_expansion): New.\n\n\t* cpplex.c (skip_block_comment, skip_line_comment, parse_name,\n        parse_string, output_line_command, trigraph_replace,\n        lex_line, cpp_push_buffer, cpp_pop_buffer, cpp_output_tokens,\n        cpp_scan_buffer_nooutput, cpp_scan_buffer, cpp_free_toklist,\n        cpp_idcmp, _cpp_get_directive_token, _cpp_init_input_buffer,\n\t_cpp_skip_rest_of_line): Modify.\n\n        (maybe_macroexpand, skip_comment, copy_comment, skip_string,\n\tfind_position, null_warning, bump_column, expand_name_space,\n\tpedantic_whitespace, _cpp_output_list, _cpp_slice_toklist,\n\t_cpp_squeeze_toklist, _cpp_scan_until, _cpp_skip_hspace,\n\t_cpp_parse_name, _cpp_lex_token, cpp_get_non_space_token,\n\t_cpp_prescan): Delete.\n\n\t(dump_param_spelling, process_directive, lex_next,\n        is_macro_disabled, stringify_arg, expand_context_stack,\n        output_token, make_string_token, alloc_number_token,\n        special_symbol, duplicate_token, maybe_paste_with_next,\n        can_paste, prevent_macro_expansion, restore_macro_expansion,\n        get_temp_token, release_temp_tokens, quote_string,\n        token_names, token_spellings, _cpp_expand_name_space,\n        _cpp_glue_header_name, _cpp_reserve_name_space,\n        digraph_spellings, trigraph_ok, skip_whitespace, save_comment,\n        placemarker_token, eof_token, cpp_context, macro_args,\n        get_raw_token, parse_arg, parse_args, save_token,\n        push_arg_context, push_macro_context, pop_context,\n        do_pop_context, free_macro_args, _cpp_get_line,\n        _cpp_run_directive): New.\n\n\t* cpplib.c (validate_else, parse_include, push_conditional,\n\tpass_thru_directive, read_line_number, parse_ifdef,\n\tdetect_if_not_defined, _cpp_check_directive, do_define,\n\tdo_undef, do_include, do_import, do_include_next, do_error,\n\tdo_warning, do_ident, do_pragma, pragma_dispatch, gcc_pragmas,\n\ttop_pragmas, do_pragma_gcc, do_pragma_implementation,\n\tdo_pragma_poison, do_pragma_system_header,\n\tdo_pragma_dependency, do_sccs, do_ifdef, do_ifndef, do_else,\n\tdl_elif, do_endif, _cpp_unwind_if_stack, do_assert,\n\tdo_unassert, cpp_define, cpp_undef, cpp_assert, cpp_unassert,\n\tcpp_defined): Update for new scheme.\n\t(strtoul_for_line, get_define_node, dump_macro_name,\n\t_cpp_check_linemarker, _cpp_parse_assertion): New.\n\t(_cpp_handle_directive, do_pragma_default): Delete.\n\n\t* cpphash.h (struct predicate): Now struct answer.\n\t(enum spell_type, struct token_spelling, struct directive,\n\tdirective_handler): New.\n\tUpdate prototypes.  Remove unused macros.\n\t* cpplib.h: Update prototypes.  Remove unused macros,\n\tstructure definitions, and fields.\n\n\t* cpperror.c (print_containing_files, v_message): Adjust.\n\t* cppexp.c (parse_assertion, lex, parse_escape,\n\t_cpp_parse_expr): Adjust.\n\t* cppfiles.c (open_include_file, _cpp_execute_include,\n\t_cpp_compare_file_date, cpp_read_file, read_include_file):\n\tAdjust.\n\t* cppinit.c (dump_special_to_buffer): Delete.\n\t(append_include_chain, merge_include_chains, cpp_reader_init,\n\tcpp_cleanup, initialize_builtins, builtin_array, cpp_start_read,\n\tcpp_finish, handle_option, print_help): Adjust.\n\t* cppmain.c (main): Adjust.\n\ntestsuite:\n2000-07-03  Zack Weinberg  <zack@wolery.cumb.org>\n\n\t* testsuite/gcc.dg/cpp/19951025-1.c: Adjust regexps.\n\t* testsuite/gcc.dg/cpp/19990703-1.c: Likewise.\n\t* testsuite/gcc.dg/cpp/20000625-1.c: Likewise.\n\t* testsuite/gcc.dg/cpp/20000625-2.c: Likewise.\n\n\t* testsuite/gcc.dg/cpp/macro1.c,\n\ttestsuite/gcc.dg/cpp/paste1.c, testsuite/gcc.dg/cpp/paste2.c,\n\ttestsuite/gcc.dg/cpp/paste3.c, testsuite/gcc.dg/cpp/paste4.c,\n\ttestsuite/gcc.dg/cpp/strify1.c,\n\ttestsuite/gcc.dg/cpp/strify2.c: New tests.\n\nFrom-SVN: r34859", "tree": {"sha": "1c91fa44eb386dd706e44d139ed980ea94f05cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c91fa44eb386dd706e44d139ed980ea94f05cae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/041c31944c94d5ee089bd569c4361fbc3d2acaea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041c31944c94d5ee089bd569c4361fbc3d2acaea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041c31944c94d5ee089bd569c4361fbc3d2acaea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041c31944c94d5ee089bd569c4361fbc3d2acaea/comments", "author": null, "committer": null, "parents": [{"sha": "4f647814cefff8ee95ac918a8484d5da8c415825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f647814cefff8ee95ac918a8484d5da8c415825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f647814cefff8ee95ac918a8484d5da8c415825"}], "stats": {"total": 10133, "additions": 4481, "deletions": 5652}, "files": [{"sha": "f9c9b734426f14169a433e72ffb32360424892eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -1,3 +1,95 @@\n+2000-07-03  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* fix-header.c (struct partial_proto): Remove unnecessary fields.\n+\t(recognized_extern, recognized_function, read_scan_file):\n+\tUpdate for new scheme.\n+\t(check_protection): It's still a multiple include guard even\n+\tif it doesn't always trigger.\n+\t* scan-decls.c (skip_to_closing_brace, scan_decls): Update for\n+\tnew scheme.\n+\t* scan.h: Declare struct cpp_token.  Update prototypes.\n+\n+2000-07-03  Neil Booth  <neilb@earthling.net>\n+\t    Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\tComplete overhaul of the lexer and macro expander.\n+\n+\t* cpphash.c (object_defn, funct_defn, push_macro_expansion,\n+\targ, arglist, argdata, reflist, collect_objlike_expansion,\n+\tcollect_funlike_expansion, collect_params,\n+\twarn_trad_stringify, trad_stringify, duplicate_arg_p, add_pat,\n+\tunsafe_chars, macarg, compare_defs, special_symbol,\n+\tscan_arguments, stringify, funlike_macroexpand,\n+\t_cpp_quote_string, monthnames): Delete.\n+\t(cpp_lookup, _cpp_free_definition, dump_funlike_macro,\n+\t_cpp_create_definition, _cpp_dump_definition,\n+\tdump_hash_helper): Adjust.\n+\t(find_param, count_params, parse_define, var_args_str,\n+\tcheck_macro_redefinition, save_expansion): New.\n+\n+\t* cpplex.c (skip_block_comment, skip_line_comment, parse_name,\n+        parse_string, output_line_command, trigraph_replace,\n+        lex_line, cpp_push_buffer, cpp_pop_buffer, cpp_output_tokens,\n+        cpp_scan_buffer_nooutput, cpp_scan_buffer, cpp_free_toklist,\n+        cpp_idcmp, _cpp_get_directive_token, _cpp_init_input_buffer,\n+\t_cpp_skip_rest_of_line): Modify.\n+\n+        (maybe_macroexpand, skip_comment, copy_comment, skip_string,\n+\tfind_position, null_warning, bump_column, expand_name_space,\n+\tpedantic_whitespace, _cpp_output_list, _cpp_slice_toklist,\n+\t_cpp_squeeze_toklist, _cpp_scan_until, _cpp_skip_hspace,\n+\t_cpp_parse_name, _cpp_lex_token, cpp_get_non_space_token,\n+\t_cpp_prescan): Delete.\n+\n+\t(dump_param_spelling, process_directive, lex_next,\n+        is_macro_disabled, stringify_arg, expand_context_stack,\n+        output_token, make_string_token, alloc_number_token,\n+        special_symbol, duplicate_token, maybe_paste_with_next,\n+        can_paste, prevent_macro_expansion, restore_macro_expansion,\n+        get_temp_token, release_temp_tokens, quote_string,\n+        token_names, token_spellings, _cpp_expand_name_space,\n+        _cpp_glue_header_name, _cpp_reserve_name_space,\n+        digraph_spellings, trigraph_ok, skip_whitespace, save_comment,\n+        placemarker_token, eof_token, cpp_context, macro_args,\n+        get_raw_token, parse_arg, parse_args, save_token,\n+        push_arg_context, push_macro_context, pop_context,\n+        do_pop_context, free_macro_args, _cpp_get_line,\n+        _cpp_run_directive): New.\n+\n+\t* cpplib.c (validate_else, parse_include, push_conditional,\n+\tpass_thru_directive, read_line_number, parse_ifdef,\n+\tdetect_if_not_defined, _cpp_check_directive, do_define,\n+\tdo_undef, do_include, do_import, do_include_next, do_error,\n+\tdo_warning, do_ident, do_pragma, pragma_dispatch, gcc_pragmas,\n+\ttop_pragmas, do_pragma_gcc, do_pragma_implementation,\n+\tdo_pragma_poison, do_pragma_system_header,\n+\tdo_pragma_dependency, do_sccs, do_ifdef, do_ifndef, do_else,\n+\tdl_elif, do_endif, _cpp_unwind_if_stack, do_assert,\n+\tdo_unassert, cpp_define, cpp_undef, cpp_assert, cpp_unassert,\n+\tcpp_defined): Update for new scheme.\n+\t(strtoul_for_line, get_define_node, dump_macro_name,\n+\t_cpp_check_linemarker, _cpp_parse_assertion): New.\n+\t(_cpp_handle_directive, do_pragma_default): Delete.\n+\t\n+\t* cpphash.h (struct predicate): Now struct answer.\n+\t(enum spell_type, struct token_spelling, struct directive,\n+\tdirective_handler): New.\n+\tUpdate prototypes.  Remove unused macros.\n+\t* cpplib.h: Update prototypes.  Remove unused macros,\n+\tstructure definitions, and fields.\n+\n+\t* cpperror.c (print_containing_files, v_message): Adjust.\n+\t* cppexp.c (parse_assertion, lex, parse_escape, \n+\t_cpp_parse_expr): Adjust.\n+\t* cppfiles.c (open_include_file, _cpp_execute_include,\n+\t_cpp_compare_file_date, cpp_read_file, read_include_file):\n+\tAdjust.\n+\t* cppinit.c (dump_special_to_buffer): Delete.\n+\t(append_include_chain, merge_include_chains, cpp_reader_init,\n+\tcpp_cleanup, initialize_builtins, builtin_array, cpp_start_read,\n+\tcpp_finish, handle_option, print_help): Adjust.\n+\t* cppmain.c (main): Adjust.\n+\n 2000-07-03  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cppspec.c (lang_specific_driver): Use double quotes in error"}, {"sha": "a2769b6dbdab81a16c3fcd4e7cc59d59a3bceda8", "filename": "gcc/cpperror.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -58,23 +58,27 @@ print_containing_files (pfile, ip)\n       if (first)\n \t{\n \t  first = 0;\n+\t  /* N.B. The current line in each outer source file is one\n+\t     greater than the line of the #include, so we must\n+\t     subtract one to correct for that.  */\n \t  fprintf (stderr,  _(\"In file included from %s:%u\"),\n-\t\t   ip->nominal_fname, CPP_BUF_LINE (ip));\n+\t\t   ip->nominal_fname, CPP_BUF_LINE (ip) - 1);\n \t}\n       else\n \t/* Translators note: this message is used in conjunction\n \t   with \"In file included from %s:%ld\" and some other\n \t   tricks.  We want something like this:\n \n-\t   In file included from sys/select.h:123,\n-\t                    from sys/types.h:234,\n-\t                    from userfile.c:31:\n-\t   bits/select.h:45: <error message here>\n+\t   | In file included from sys/select.h:123,\n+\t   |                  from sys/types.h:234,\n+\t   |                  from userfile.c:31:\n+\t   | bits/select.h:45: <error message here>\n \n+\t   with all the \"from\"s lined up.\n \t   The trailing comma is at the beginning of this message,\n \t   and the trailing colon is not translated.  */\n \tfprintf (stderr, _(\",\\n                 from %s:%u\"),\n-\t\t ip->nominal_fname, CPP_BUF_LINE (ip));\n+\t\t ip->nominal_fname, CPP_BUF_LINE (ip) - 1);\n     }\n   if (first == 0)\n     fputs (\":\\n\", stderr);\n@@ -111,17 +115,14 @@ v_message (pfile, is_error, file, line, col, msg, ap)\n      const char *msg;\n      va_list ap;\n {\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n \n   if (ip)\n     {\n       if (file == NULL)\n \tfile = ip->nominal_fname;\n       if (line == 0)\n-\t{\n-\t  line = CPP_BUF_LINE (ip);\n-\t  col = CPP_BUF_COL (ip);\n-\t}\n+\tline = _cpp_get_line (pfile, &col);\n       print_containing_files (pfile, ip);\n       print_file_and_line (file, line,\n \t\t\t   CPP_OPTION (pfile, show_column) ? col : 0);\n@@ -132,8 +133,12 @@ v_message (pfile, is_error, file, line, col, msg, ap)\n   switch (is_error)\n     {\n     case 0:\n-      fprintf (stderr, _(\"warning: \"));\n-      break;\n+      if (! CPP_OPTION (pfile, warnings_are_errors))\n+\t{\n+\t  fprintf (stderr, _(\"warning: \"));\n+\t  break;\n+\t}\n+      /* else fall through */\n     case 1:\n       if (pfile->errors < CPP_FATAL_LIMIT)\n \tpfile->errors++;"}, {"sha": "392132bd7df8fa40deaca71f9e3c299fa1b865ce", "filename": "gcc/cppexp.c", "status": "modified", "additions": 31, "deletions": 75, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -394,74 +394,22 @@ parse_assertion (pfile)\n      cpp_reader *pfile;\n {\n   struct operation op;\n+  struct answer *answer;\n   cpp_hashnode *hp;\n-  struct predicate *pred;\n-  cpp_toklist query;\n-  enum cpp_ttype type;\n-  U_CHAR *tok;\n-  size_t len;\n-  unsigned int old_written;\n-  int specific = 0;\n-\n-  old_written = CPP_WRITTEN (pfile);\n-  CPP_PUTC (pfile, '#');\n-  pfile->no_macro_expand++;\n-  type = _cpp_get_directive_token (pfile);\n-  if (type == CPP_VSPACE)\n-    SYNTAX_ERROR (\"assertion without predicate\");\n-  else if (type != CPP_NAME)\n-    SYNTAX_ERROR (\"assertion predicate is not an identifier\");\n-\n-  tok = pfile->token_buffer + old_written;\n-  len = CPP_WRITTEN (pfile) - old_written;\n-  hp = cpp_lookup (pfile, tok, len);\n \n-  /* Look ahead for an open paren.  */\n-  _cpp_skip_hspace (pfile);\n-  if (CPP_BUF_PEEK (CPP_BUFFER (pfile)) == '(')\n+  op.op = ERROR;\n+  hp = _cpp_parse_assertion (pfile, &answer);\n+  if (hp)\n     {\n-      if (_cpp_get_directive_token (pfile) != CPP_OPEN_PAREN)\n-\tCPP_ICE (\"impossible token, expecting ( in parse_assertion\");\n-\n-      _cpp_init_toklist (&query, NO_DUMMY_TOKEN);\n-      specific = 1;\n-      if (_cpp_scan_until (pfile, &query, CPP_CLOSE_PAREN) != CPP_CLOSE_PAREN)\n-\tSYNTAX_ERROR (\"missing close paren on assertion answer\");\n-\n-      if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n-\tCPP_ICE (\"impossible token, expecting ) in parse_assertion\");\n-    }\n+      /* If we get here, the syntax is valid.  */\n+      op.op = INT;\n+      op.value = (hp->type == T_ASSERTION &&\n+\t\t  (answer == 0 || *find_answer (hp, &answer->list) != 0));\n \n-  /* If we get here, the syntax is valid.  */\n-  op.op = INT;\n-  op.value = 0;\n-  /* Has this predicate been asserted at all?  */\n-  if (hp->type == T_ASSERTION)\n-    {\n-      if (specific)\n-\t{\n-\t  for (pred = hp->value.pred; pred; pred = pred->next)\n-\t    if (_cpp_equiv_toklists (&query, &pred->answer))\n-\t      {\n-\t\top.value = 1;\n-\t\tbreak;\n-\t      }\n-\t  _cpp_free_toklist (&query);\n-\t}\n-      else\n-\top.value = 1;\n+      if (answer)\n+\tFREE_ANSWER (answer);\n     }\n-\n- out:\n-  pfile->no_macro_expand--;\n-  CPP_SET_WRITTEN (pfile, old_written);\n   return op;\n-\n- syntax_error:\n-  if (specific)\n-    _cpp_free_toklist (&query);\n-  op.op = ERROR;\n-  goto out;\n }\n \n struct token\n@@ -480,8 +428,6 @@ static const struct token tokentab2[] =\n   {\"!=\", NOTEQUAL},\n   {\"<=\", LEQ},\n   {\">=\", GEQ},\n-  {\"++\", ERROR},\n-  {\"--\", ERROR},\n   {NULL, ERROR}\n };\n \n@@ -496,16 +442,20 @@ lex (pfile, skip_evaluation)\n   enum cpp_ttype token;\n   struct operation op;\n   U_CHAR *tok_start, *tok_end;\n-  long old_written;\n+  long old_written = CPP_WRITTEN (pfile);\n \n-  old_written = CPP_WRITTEN (pfile);\n+ retry:\n   token = _cpp_get_directive_token (pfile);\n-\n   tok_start = pfile->token_buffer + old_written;\n   tok_end = CPP_PWRITTEN (pfile);\n   CPP_SET_WRITTEN (pfile, old_written);\n+\n   switch (token)\n     {\n+    case CPP_PLACEMARKER:\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      goto retry;\n+\n     case CPP_EOF: /* Should not happen ...  */\n     case CPP_VSPACE:\n       op.op = 0;\n@@ -524,6 +474,7 @@ lex (pfile, skip_evaluation)\n       return parse_charconst (pfile, tok_start, tok_end);\n \n     case CPP_NAME:\n+      /* FIXME:  could this not overflow the tok_start buffer? */\n       if (!ustrncmp (tok_start, U\"defined\", 7))\n \treturn parse_defined (pfile);\n \n@@ -539,7 +490,16 @@ lex (pfile, skip_evaluation)\n     case CPP_HASH:\n       return parse_assertion (pfile);\n \n-    case CPP_OTHER:\n+    case CPP_AND_AND:\top.op = ANDAND; return op;\n+    case CPP_OR_OR:\top.op = OROR;\treturn op;\n+    case CPP_LSHIFT:\top.op = LSH;\treturn op;\n+    case CPP_RSHIFT:\top.op = RSH;\treturn op;\n+    case CPP_EQ_EQ:\top.op = EQUAL;\treturn op;\n+    case CPP_NOT_EQ:\top.op = NOTEQUAL; return op;\n+    case CPP_LESS_EQ:\top.op = LEQ;\treturn op;\n+    case CPP_GREATER_EQ:op.op = GEQ;\treturn op;\n+\n+    default:\n       /* See if it is a special token of length 2.  */\n       if (tok_start + 2 == tok_end)\n         {\n@@ -553,8 +513,6 @@ lex (pfile, skip_evaluation)\n \t  op.op = toktab->token; \n \t  return op;\n \t}\n-      /* fall through */\n-    default:\n       op.op = *tok_start;\n       return op;\n   }\n@@ -612,7 +570,7 @@ parse_escape (pfile, string_ptr, result_mask)\n     case 'e':\n     case 'E':\n       if (CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"non-ANSI-standard escape sequence, '\\\\%c'\", c);\n+\tcpp_pedwarn (pfile, \"non-ISO-standard escape sequence, '\\\\%c'\", c);\n       return TARGET_ESC;\n     case 'f':\n       return TARGET_FF;\n@@ -844,9 +802,7 @@ _cpp_parse_expr (pfile)\n   char buff[5];\n \n   /* Save parser state and set it to something sane.  */\n-  int save_only_seen_white = pfile->only_seen_white;\n   int save_skipping = pfile->skipping;\n-  pfile->only_seen_white = 0;\n   pfile->skipping = 0;\n \n   /* We've finished when we try to reduce this.  */\n@@ -875,7 +831,8 @@ _cpp_parse_expr (pfile)\n \tcase ERROR:\n \t  goto syntax_error;\n \tdefault:\n-\t  SYNTAX_ERROR (\"invalid character in #if\");\n+\t  SYNTAX_ERROR2 (\"invalid character '%s' in #if\",\n+\t\t\t op_to_str (op.op, buff));\n \n \tpush_immediate:\n \tcase INT:\n@@ -1168,7 +1125,6 @@ _cpp_parse_expr (pfile)\n   if (stack != init_stack)\n     free (stack);\n   CPP_SET_WRITTEN (pfile, old_written);\n-  pfile->only_seen_white = save_only_seen_white;\n   pfile->skipping = save_skipping;\n   return result;\n }"}, {"sha": "66fb7bcb1fdb22933bc0ef9ebd4810785f979fdd", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -180,7 +180,7 @@ open_include_file (pfile, filename)\n #ifdef EACCES\n       if (errno == EACCES)\n \t{\n-\t  cpp_error (pfile, \"included file `%s' exists but is not readable\",\n+\t  cpp_error (pfile, \"included file \\\"%s\\\" exists but is not readable\",\n \t\t     filename);\n \t}\n #endif\n@@ -360,16 +360,16 @@ cpp_make_system_header (pfile, pbuf, flag)\n \n #define PRINT_THIS_DEP(p, b) (CPP_PRINT_DEPS(p) > (b||p->system_include_depth))\n void\n-_cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n+_cpp_execute_include (pfile, f, len, no_reinclude, search_start, angle_brackets)\n      cpp_reader *pfile;\n-     U_CHAR *f;\n+     const U_CHAR *f;\n      unsigned int len;\n      int no_reinclude;\n      struct file_name_list *search_start;\n+     int angle_brackets;\n {\n   struct include_file *inc;\n-  char *fname = (char *)f;\n-  int angle_brackets = fname[0] == '<';\n+  char *fname;\n \n   if (!search_start)\n     {\n@@ -387,9 +387,8 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n       return;\n     }\n \n-  /* Remove quote marks.  */\n-  fname++;\n-  len -= 2;\n+  fname = alloca (len + 1);\n+  memcpy (fname, f, len);\n   fname[len] = '\\0';\n \n   inc = find_include_file (pfile, fname, search_start);\n@@ -470,32 +469,27 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n    if F cannot be located or dated, 1, if it is newer and 0 if older.  */\n \n int\n-_cpp_compare_file_date (pfile, f, len, search_start)\n+_cpp_compare_file_date (pfile, f, len, angle_brackets)\n      cpp_reader *pfile;\n-     U_CHAR *f;\n+     const U_CHAR *f;\n      unsigned int len;\n-     struct file_name_list *search_start;\n+     int angle_brackets;\n {\n-  char *fname = (char *)f;\n-  int angle_brackets = fname[0] == '<';\n+  char *fname;\n+  struct file_name_list *search_start;\n   struct include_file *inc;\n-  struct include_file *current_include = cpp_file_buffer (pfile)->inc;\n+  struct include_file *current_include = CPP_BUFFER (pfile)->inc;\n \n-  if (!search_start)\n-    {\n-      if (angle_brackets)\n-\tsearch_start = CPP_OPTION (pfile, bracket_include);\n-      else if (CPP_OPTION (pfile, ignore_srcdir))\n-\tsearch_start = CPP_OPTION (pfile, quote_include);\n-      else\n-\tsearch_start = CPP_BUFFER (pfile)->actual_dir;\n-    }\n+  if (angle_brackets)\n+    search_start = CPP_OPTION (pfile, bracket_include);\n+  else if (CPP_OPTION (pfile, ignore_srcdir))\n+    search_start = CPP_OPTION (pfile, quote_include);\n+  else\n+    search_start = CPP_BUFFER (pfile)->actual_dir;\n \n-  /* Remove quote marks.  */\n-  fname++;\n-  len -= 2;\n+  fname = alloca (len + 1);\n+  memcpy (fname, f, len);\n   fname[len] = '\\0';\n-  \n   inc = find_include_file (pfile, fname, search_start);\n   \n   if (!inc)\n@@ -534,6 +528,12 @@ cpp_read_file (pfile, fname)\n \n   f = open_include_file (pfile, fname);\n \n+  if (f == NULL)\n+    {\n+      cpp_error_from_errno (pfile, fname);\n+      return 0;\n+    }\n+\n   return read_include_file (pfile, f);\n }\n \n@@ -550,12 +550,17 @@ read_include_file (pfile, inc)\n   cpp_buffer *fp;\n   int fd = inc->fd;\n \n+  /* Ensures we dump our current line before entering an include file.  */\n+  if (CPP_BUFFER (pfile) && pfile->printer)\n+    cpp_output_tokens (pfile, pfile->printer,\n+\t\t       CPP_BUF_LINE (CPP_BUFFER (pfile)));\n+\n   fp = cpp_push_buffer (pfile, NULL, 0);\n \n   if (fp == 0)\n     goto push_fail;\n \n-  if (fstat (fd, &st) < 0)\n+  if (fd < 0 || fstat (fd, &st) < 0)\n     goto perror_fail;\n   \n   inc->date = st.st_mtime;\n@@ -622,9 +627,6 @@ read_include_file (pfile, inc)\n   \n   if (length == 0)\n     inc->cmacro = NEVER_REREAD;\n-  else\n-    /* Temporary - I hope.  */\n-    length = _cpp_prescan (pfile, fp, length);\n \n   fp->rlimit = fp->buf + length;\n   fp->cur = fp->buf;\n@@ -637,13 +639,13 @@ read_include_file (pfile, inc)\n     fp->actual_dir = actual_directory (pfile, inc->name);\n \n   pfile->input_stack_listing_current = 0;\n-  pfile->only_seen_white = 2;\n   return 1;\n \n  perror_fail:\n   cpp_error_from_errno (pfile, inc->name);\n   /* Do not try to read this file again.  */\n-  close (fd);\n+  if (fd != -1)\n+    close (fd);\n   inc->fd = -1;\n   inc->cmacro = NEVER_REREAD;\n  fail:"}, {"sha": "ba812d5e2deec3f328eefcd42edc79b0cf6f06ec", "filename": "gcc/cpphash.c", "status": "modified", "additions": 360, "deletions": 1638, "changes": 1998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -31,172 +31,37 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #undef abort\n \n-/* Structure allocated for every #define.  For a simple replacement\n-   such as\n-   \t#define foo bar\n-\n-   we allocate an object_defn structure; the expansion field points\n-   to the replacement text.  For a function-like macro we allocate a\n-   funct_defn structure; nargs is the number of arguments - it can be zero,\n-   e.g.\n-       #define getchar() getc (stdin)\n-\n-   When there are args, the expansion is the replacement text with the\n-   args squashed out, and the reflist is a list describing how to\n-   build the output from the input: e.g., \"3 chars, then the 1st arg,\n-   then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg\".\n-   The chars here come from the expansion.  Whatever is left of the\n-   expansion after the last arg-occurrence is copied after that arg.\n-   Note that the reflist can be arbitrarily long---\n-   its length depends on the number of times the arguments appear in\n-   the replacement text, not how many args there are.  Example:\n-   #define f(x) x+x+x+x+x+x+x would have replacement text \"++++++\" and\n-   pattern list\n-     { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }\n-   where (x, y) means (nchars, argno).\n-\n-   Note that EMPTY and IDENTITY macros have object_defn structures too,\n-   but they're just used to hold the file, line, and column.  The\n-   expansion field will be NULL.  */\n-\n-struct object_defn\n-{\n-  const U_CHAR *expansion;\n-  unsigned int length;\n-\n-  const char *file;\t\t/* File, line, column of definition */\n-  int line;\n-  int col;\n-};  \n-\n-struct reflist\n-{\n-  const struct reflist *next;\n-  char stringify;\t\t/* nonzero if this arg was preceded by a\n-\t\t\t\t   # operator. */\n-  char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n-  char raw_after;\t\t/* Nonzero if a ## operator after arg. */\n-  char rest_args;\t\t/* Nonzero if this arg. absorbs the rest */\n-  int nchars;\t\t\t/* Number of literal chars to copy before\n-\t\t\t\t   this arg occurrence.  */\n-  int argno;\t\t\t/* Number of arg to substitute (origin-0) */\n-};\n-\n-struct funct_defn\n-{\n-  int nargs;\n-  int length;\t\t\t/* length of expansion string */\n-  const U_CHAR *expansion;\n-  char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n-  const struct reflist *pattern;\n-\n-  /* Names of macro args, concatenated in order with \\0 between\n-     them.  The only use of this is that we warn on redefinition if\n-     this differs between the old and new definitions.  */\n-  U_CHAR *argnames;\n-\n-  const char *file;\t\t/* File, line, column of definition */\n-  int line;\n-  int col;\n-};\n-\n /* This is the second argument to eq_HASHNODE.  */\n struct hashdummy\n {\n   const U_CHAR *name;\n   unsigned short length;\n };\n \n+/* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n+#define HASHSIZE 500\n+\n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n static void del_HASHNODE\t  PARAMS ((void *));\n static cpp_hashnode *make_HASHNODE\t  PARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t   enum node_type, unsigned int));\n-\n-static void dump_funlike_macro\t  PARAMS ((cpp_reader *,\n-\t\t\t\t\t   const struct funct_defn *));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n \n-static void push_macro_expansion PARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t  int, cpp_hashnode *));\n-static int unsafe_chars\t\t PARAMS ((cpp_reader *, int, int));\n-static enum cpp_ttype macarg\t PARAMS ((cpp_reader *, int));\n-static void special_symbol\t PARAMS ((cpp_reader *, cpp_hashnode *));\n-static int compare_defs\t\t PARAMS ((cpp_reader *,\n-\t\t\t\t\t  const struct funct_defn *,\n-\t\t\t\t\t  const struct funct_defn *));\n+static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n \n-/* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n-#define HASHSIZE 500\n-\n-/* The arglist structure is built by collect_params to tell\n-   collect_funlike_expansion where the argument names begin.  That is,\n-   for a define like \"#define f(x,y,z) foo+x-bar*y\", the arglist would\n-   contain pointers to the strings x, y, and z.\n-   collect_funlike_expansion would then build a funct_defn node, with\n-   reflist nodes pointing to the places x, y, and z had appeared.\n-\n-   The arglist is just convenience data passed between these two\n-   routines.  It is not kept around after the current #define has been\n-   processed and entered into the hash table.  */\n+static const cpp_token *count_params PARAMS ((cpp_reader *,\n+\t\t\t\t\t      const cpp_token *,\n+\t\t\t\t\t      cpp_toklist *));\n+static cpp_toklist *parse_define PARAMS((cpp_reader *));\n+static int check_macro_redefinition PARAMS((cpp_reader *, cpp_hashnode *hp,\n+\t\t\t\t\t     const cpp_toklist *));\n+static int save_expansion PARAMS((cpp_reader *, cpp_toklist *,\n+\t\t\t\t  const cpp_token *, const cpp_token *));\n+static unsigned int find_param PARAMS ((const cpp_token *,\n+\t\t\t\t\tconst cpp_token *));\n \n-struct arg\n-{\n-  const U_CHAR *name;\n-  unsigned int len;\n-  char rest_arg;\n-};\n-\n-struct arglist\n-{\n-  U_CHAR *namebuf;\n-  const struct arg *argv;\n-  int argc;\n-};\n-\n-static struct object_defn *\n-collect_objlike_expansion PARAMS ((cpp_reader *, cpp_toklist *));\n-static struct funct_defn *\n-collect_funlike_expansion PARAMS ((cpp_reader *, cpp_toklist *,\n-\t\t\t\t   struct arglist *, unsigned int));\n-static unsigned int collect_params PARAMS ((cpp_reader *, cpp_toklist *,\n-\t\t\t\t\t    struct arglist *));\n-\n-static void warn_trad_stringify\tPARAMS ((cpp_reader *, const U_CHAR *, size_t,\n-\t\t\t\t\t unsigned int, const struct arg *));\n-static unsigned int trad_stringify PARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t    size_t,\n-\t\t\t\t\t    unsigned int, const struct arg *,\n-\t\t\t\t\t    struct reflist **,\n-\t\t\t\t\t    struct reflist **, unsigned int));\n-static int duplicate_arg_p PARAMS ((U_CHAR *, U_CHAR *));\n-static void add_pat PARAMS ((struct reflist **, struct reflist **,\n-\t\t\t     unsigned int, unsigned int, int, int, int, int));\n-\n-/* This structure represents one parsed argument in a macro call.\n-   `raw' points to the argument text as written (`raw_length' is its length).\n-   `expanded' points to the argument's macro-expansion\n-   (its length is `expand_length').\n-   `stringified_length' is the length the argument would have\n-   if stringified.  */\n-\n-/* raw and expanded are relative to ARG_BASE */\n-#define ARG_BASE ((pfile)->token_buffer)\n-\n-struct argdata\n-{\n-  /* Strings relative to pfile->token_buffer */\n-  long raw, expanded, stringified;\n-  int raw_length, expand_length;\n-  int stringified_length;\n-};\n-\n-static void scan_arguments\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t const struct funct_defn *,\n-\t\t\t\t\t struct argdata *, const U_CHAR *));\n-static void stringify\t\tPARAMS ((cpp_reader *, struct argdata *));\n-static void funlike_macroexpand\tPARAMS ((cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t struct argdata *));\n+static const unsigned char var_args_str[] = \"__VA_ARGS__\";\n \n /* Calculate hash of a string of length LEN.  */\n unsigned int\n@@ -297,7 +162,8 @@ cpp_lookup (pfile, name, len)\n     return *slot;\n \n   new = make_HASHNODE (name, len, T_VOID, hash);\n-  new->value.cpval = NULL;\n+  new->value.expansion = NULL;\n+\n   *slot = new;\n   return new;\n }\n@@ -317,1521 +183,419 @@ void\n _cpp_free_definition (h)\n      cpp_hashnode *h;\n {\n-  if (h->type == T_XCONST)\n-    free ((PTR) h->value.cpval);\n-  else if (h->type == T_MACRO)\n-    {\n-      if (h->value.odefn->expansion)\n-\tfree ((PTR) h->value.odefn->expansion);\n-      free ((PTR) h->value.odefn);\n-    }\n-  else if (h->type == T_FMACRO)\n-    {\n-      const struct funct_defn *d = h->value.fdefn;\n-      const struct reflist *ap, *nextap;\n-    \n-      for (ap = d->pattern; ap != NULL; ap = nextap)\n-\t{\n-\t  nextap = ap->next;\n-\t  free ((PTR) ap);\n-\t}\n-      if (d->argnames)\n-\tfree ((PTR) d->argnames);\n-      free ((PTR) d);\n-    }\n-  h->value.cpval = NULL;\n-}\n-\n-/* Create pat nodes.  */\n-\n-static void\n-add_pat (pat, endpat, nchars, argno, raw_before, raw_after, strize, rest)\n-     struct reflist **pat, **endpat;\n-     unsigned int nchars;\n-     unsigned int argno;\n-     int raw_before, raw_after, strize, rest;\n-{\n-  struct reflist *tpat;\n-  tpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n-  tpat->next = NULL;\n-  tpat->raw_before = raw_before;\n-  tpat->raw_after = raw_after;\n-  tpat->stringify = strize;\n-  tpat->rest_args = rest;\n-  tpat->argno = argno;\n-  tpat->nchars = nchars;\n-\n-  if (*endpat == NULL)\n-    *pat = tpat;\n-  else\n-    (*endpat)->next = tpat;\n-  *endpat = tpat;\n-}  \n-\n-/* Issue warnings for macro argument names seen inside strings.  */\n-static void\n-warn_trad_stringify (pfile, p, len, argc, argv)\n-     cpp_reader *pfile;\n-     const U_CHAR *p;\n-     size_t len;\n-     unsigned int argc;\n-     const struct arg *argv;\n-{\n-  const U_CHAR *limit;\n-  unsigned int i;\n-\n-  limit = p + len;\n-  for (;;)\n-    {\n-      while (p < limit && !is_idstart (*p)) p++;\n-      if (p >= limit)\n-\tbreak;\n-\n-      for (i = 0; i < argc; i++)\n-\tif (!ustrncmp (p, argv[i].name, argv[i].len)\n-\t    && ! is_idchar (p[argv[i].len]))\n-\t  {\n-\t    cpp_warning (pfile,\n-\t\t\"macro argument \\\"%s\\\" would be stringified in traditional C\",\n-\t\t\t argv[i].name);\n-\t    break;\n-\t  }\n-      p++;\n-      while (p < limit && is_idchar (*p)) p++;\n-      if (p >= limit)\n-\tbreak;\n-    }\n+  if (h->type == T_MACRO)\n+    _cpp_free_toklist (h->value.expansion);\n+  h->value.expansion = NULL;\n }\n \n-/* Generate pat nodes for macro arguments seen inside strings.  */\n+/* Scans for a given token, returning the parameter number if found,\n+   or 0 if not found.  Scans from FIRST to TOKEN - 1 or the first\n+   CPP_CLOSE_PAREN for TOKEN.  */\n static unsigned int\n-trad_stringify (pfile, base, len, argc, argv, pat, endpat, last)\n-     cpp_reader *pfile;\n-     const U_CHAR *base;\n-     size_t len;\n-     unsigned int argc;\n-     const struct arg *argv;\n-     struct reflist **pat, **endpat;\n-     unsigned int last;\n-{\n-  const U_CHAR *p, *limit;\n-  unsigned int i;\n-\n-  p = base;\n-  limit = base + len;\n-  for (;;)\n-    {\n-    proceed:\n-      while (p < limit && !is_idstart (*p)) p++;\n-      if (p >= limit)\n-\tbreak;\n-\n-      for (i = 0; i < argc; i++)\n-\tif (!ustrncmp (p, argv[i].name, argv[i].len)\n-\t    && ! is_idchar (p[argv[i].len]))\n-\t  {\n-\t    if (CPP_WTRADITIONAL (pfile))\n-\t      cpp_warning (pfile, \"macro argument \\\"%s\\\" is stringified\",\n-\t\t\t   argv[i].name);\n-\t    /* Write out the string up to this point, and add a pat\n-\t       node for the argument.  Note that the argument is NOT\n-\t       stringified.  */\n-\t    CPP_PUTS (pfile, base, p - base);\n-\t    add_pat (pat, endpat, CPP_WRITTEN (pfile) - last, i /* argno */,\n-\t\t     !is_hspace (p[-1]) /* raw_before */,\n-\t\t     !is_hspace (p[argv[i].len]) /* raw_after */,\n-\t\t     0 /* strize */,\n-\t\t     argv[i].rest_arg);\n-\t    last = CPP_WRITTEN (pfile);\n-\t    base = p + argv[i].len;\n-\t    p = base;\n-\t    goto proceed;\n-\t  }\n-      p++;\n-      while (p < limit && is_idchar (*p)) p++;\n-      if (p >= limit)\n-\tbreak;\n-    }\n-  CPP_PUTS (pfile, base, p - base);\n-  return last;\n-}\n-\n-/* Read a replacement list for an object-like macro, and build the\n-   object_defn structure.  LIST contains the replacement list,\n-   beginning at 1.  */\n-static struct object_defn *\n-collect_objlike_expansion (pfile, list)\n-     cpp_reader *pfile;\n-     cpp_toklist *list;\n+find_param (first, token)\n+     const cpp_token *first, *token;\n {\n-  struct object_defn *defn;\n-  unsigned int i;\n-  unsigned int start;\n-  int last_was_paste = 0;\n-  U_CHAR *exp;\n-  size_t len;\n-\n-  /* We copy the expansion text into the token_buffer, then out to\n-     its proper home.  */\n-  start = CPP_WRITTEN (pfile);\n-  CPP_PUTS (pfile, \"\\r \", 2);\n-\n-  for (i = 1; i < list->tokens_used; i++)\n-    {\n-      switch (TOK_TYPE (list, i))\n-\t{\n-\tcase CPP_PASTE:\n-\t  /* ## is not special if it appears right after another ##;\n-\t     nor is it special if -traditional.  */\n-\t  if (last_was_paste || CPP_TRADITIONAL (pfile))\n-\t    break;\n-\t  if (i == 1)\n-\t    cpp_error (pfile, \"`##' at start of macro definition\");\n-\n-\t  last_was_paste = 1;\n-\t  continue;\n-\n-\tdefault:;\n-\t}\n-\n-      if (i > 1 && !last_was_paste && TOK_PREV_WHITE (list, i))\n-\tCPP_PUTC (pfile, ' ');\n-\n-      CPP_PUTS (pfile, TOK_NAME (list, i), TOK_LEN (list, i));\n-      last_was_paste = 0;\n-    }\n-\n-  if (last_was_paste)\n-    cpp_error (pfile, \"`##' at end of macro definition\");\n-\n-  CPP_PUTS (pfile, \"\\r \", 2);\n-  len = CPP_WRITTEN (pfile) - start;\n-  CPP_SET_WRITTEN (pfile, start);\n+  unsigned int param = 0;\n \n-  if (len <= 4)\n-    cpp_ice (pfile, \"empty object-like macro went through full #define\");\n-\n-  exp = (U_CHAR *) xmalloc (len + 1);\n-  memcpy (exp, pfile->token_buffer + start, len);\n-  exp[len] = '\\0';\n-\n-  defn = (struct object_defn *) xmalloc (sizeof (struct object_defn));\n-  defn->length = len;\n-  defn->expansion = exp;\n+  for (; first < token && first->type != CPP_CLOSE_PAREN; first++)\n+    if (first->type == CPP_NAME)\n+      {\n+\tparam++;\n+\tif (first->val.name.len == token->val.name.len\n+\t    && !memcmp (first->val.name.text, token->val.name.text,\n+\t\t\ttoken->val.name.len))\n+\t  return param;\n+      }\n \n-  return defn;\n+  return 0;\n }\n \n-/* Read a replacement list for a function-like macro, and build the\n-   funct_defn structure.  LIST contains the replacement list,\n-   beginning at REPLACEMENT.  ARGLIST specifies the formal parameters\n-   to look for in the text of the definition.  */\n-\n-static struct funct_defn *\n-collect_funlike_expansion (pfile, list, arglist, replacement)\n+/* Counts the parameters to a function like macro, and saves their\n+   spellings if necessary.  Returns the token that we stopped scanning\n+   at; if it's type isn't CPP_CLOSE_PAREN there was an error, which\n+   has been reported.  */\n+static const cpp_token *\n+count_params (pfile, first, list)\n      cpp_reader *pfile;\n+     const cpp_token *first;\n      cpp_toklist *list;\n-     struct arglist *arglist;\n-     unsigned int replacement;\n {\n-  struct funct_defn *defn;\n-  struct reflist *pat = 0, *endpat = 0;\n-  enum cpp_ttype token;\n-  unsigned int start, last;\n-  unsigned int i;\n-  int j, argc;\n-  size_t len;\n-  const struct arg *argv;\n-  const U_CHAR *tok;\n-  U_CHAR *exp;\n-  enum { START = 0, NORM, ARG, STRIZE, PASTE } last_token = START;\n-\n-  argv = arglist->argv;\n-  argc = arglist->argc;\n-\n-  /* We copy the expansion text into the token_buffer, then out to\n-     its proper home.  */\n-  last = start = CPP_WRITTEN (pfile);\n-  CPP_PUTS (pfile, \"\\r \", 2);\n-\n-  for (i = replacement; i < list->tokens_used; i++)\n+  unsigned int params_len = 0, prev_ident = 0;\n+  unsigned int line = pfile->token_list.line;\n+  const cpp_token *token, *temp;\n+\n+  list->paramc = 0;\n+  for (token = first;; token++)\n     {\n-      token = TOK_TYPE (list, i);\n-      tok = TOK_NAME (list, i);\n-      len = TOK_LEN (list, i);\n-      switch (token)\n+      switch (token->type)\n \t{\n-\tcase CPP_HASH:\n-\t  /* # is special in function-like macros with no args.\n-\t     (6.10.3.2 para 1.)  However, it is not special after\n-\t     PASTE. (Implied by 6.10.3.3 para 4.)  Nor is it special\n-\t     if -traditional.  */\n-\t  if (last_token == PASTE || CPP_TRADITIONAL (pfile))\n-\t    break;\n-\t  last_token = STRIZE;\n-\t  continue;\n-\n-\tcase CPP_PASTE:\n-\t  /* ## is not special if it appears right after another ##;\n-\t     nor is it special if -traditional.  */\n-\t  if (last_token == PASTE || CPP_TRADITIONAL (pfile))\n-\t    break;\n-\n-\t  if (last_token == START)\n-\t    cpp_error (pfile, \"`##' at start of macro definition\");\n-\t  else if (last_token == ARG)\n-\t    /* If the last token was an argument, mark it raw_after.  */\n-\t    endpat->raw_after = 1;\n-\t  else if (last_token == STRIZE)\n-\t    /* Oops - that wasn't a stringify operator.  */\n-\t    CPP_PUTC (pfile, '#');\n-\n-\t  last_token = PASTE;\n-\t  continue;\n-\n-\tdefault:;\n-\t}\n+\tcase CPP_EOF:\n+\t  cpp_error_with_line (pfile, line, token->col,\n+\t\t\t       \"missing ')' in macro parameter list\");\n+\t  goto out;\n \n-      if (last_token != PASTE && last_token != START\n-\t  && TOK_PREV_WHITE (list, i))\n-\tCPP_PUTC (pfile, ' ');\n-      if (last_token == ARG && CPP_TRADITIONAL (pfile)\n-\t  && !TOK_PREV_WHITE (list, i))\n-\tendpat->raw_after = 1;\n+\tcase CPP_COMMENT:\n+\t  continue;\t\t/* Ignore -C comments.  */\n \n-      switch (token)\n-\t{\n-\tcase CPP_STRING:\n-\tcase CPP_CHAR:\n-\t  if (argc == 0)\n-\t    goto norm;\n-\t  if (CPP_TRADITIONAL (pfile))\n+\tcase CPP_NAME:\n+\t  if (prev_ident)\n \t    {\n-\t      last = trad_stringify (pfile, tok, len, argc, argv,\n-\t\t\t\t     &pat, &endpat, last);\n-\t      break;\n+\t      cpp_error_with_line (pfile, line, token->col,\n+\t\t\t   \"macro parameters must be comma-separated\");\n+\t      goto out;\n \t    }\n-\t  else\n+\n+\t  /* Constraint 6.10.3.5  */\n+\t  if (token->val.name.len == sizeof (var_args_str) - 1\n+\t      && !ustrncmp (token->val.name.text, var_args_str,\n+\t\t\t    sizeof (var_args_str) - 1))\n \t    {\n-\t      if (CPP_WTRADITIONAL (pfile))\n-\t\twarn_trad_stringify (pfile, tok, len, argc, argv);\n-\t      goto norm;\n+\t      cpp_error_with_line (pfile, line, token->col,\n+\t\t\t\t   \"\\\"%s\\\" is not a valid parameter name\",\n+\t\t\t\t   var_args_str);\n+\t      goto out;\n \t    }\n \n-\tcase CPP_NAME:\n-\t  for (j = 0; j < argc; j++)\n-\t    if (argv[j].len == len\n-\t\t&& !ustrncmp (tok, argv[j].name, argv[j].len))\n-\t      goto addref;\n+\t  params_len += token->val.name.len + 1;\n+\t  prev_ident = 1;\n+\t  list->paramc++;\n \n-\t  /* fall through */\n-\tdefault:\n-\tnorm:\n-\t  if (last_token == STRIZE)\n+\t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n+\t  if (find_param (first, token))\n \t    {\n-\t      /* This is a mandatory diagnostic (6.10.3.2 para 1), but\n-\t\t in assembly language # may have some other\n-\t\t significance we don't know about, so suppress the\n-\t\t warning. */\n-\t      if (! CPP_OPTION (pfile, lang_asm))\n-\t\tcpp_pedwarn (pfile,\n-\t\t\t     \"# is not followed by a macro argument name\");\n-\t      if (TOK_PREV_WHITE (list, i))\n-\t\tCPP_ADJUST_WRITTEN (pfile, -1);\n-\t      if (TOK_PREV_WHITE (list, i-1))\n-\t\tCPP_PUTC (pfile, ' ');\n-\t      CPP_PUTC (pfile, '#');\n-\t      if (TOK_PREV_WHITE (list, i))\n-\t\tCPP_PUTC (pfile, ' ');\n+\t      cpp_error_with_line (pfile, line, token->col,\n+\t\t\t\t   \"duplicate macro parameter \\\"%.*s\\\"\",\n+\t\t\t\t   (int) token->val.name.len,\n+\t\t\t\t   token->val.name.text);\n+\t      goto out;\n \t    }\n-\t  CPP_PUTS (pfile, tok, len);\n-\t  last_token = NORM;\n-\t}\n-      continue;\n-\n-    addref:\n-      {\n-\tint raw_before = (last_token == PASTE\n-\t\t\t  || (CPP_TRADITIONAL (pfile)\n-\t\t\t      && ! TOK_PREV_WHITE (list, j)));\n-      \n-\tadd_pat (&pat, &endpat,\n-\t\t CPP_WRITTEN (pfile) - last /* nchars */, j /* argno */,\n-\t\t raw_before, 0 /* raw_after */,\n-\t\t (last_token == STRIZE), argv[j].rest_arg);\n-      \n-\tlast = CPP_WRITTEN (pfile);\n-      }\n-      last_token = ARG;\n-    }\n+\t  break;\n \n-  if (last_token == STRIZE)\n-    cpp_error (pfile, \"`#' is not followed by a macro argument name\");\n-  else if (last_token == PASTE)\n-    cpp_error (pfile, \"`##' at end of macro definition\");\n-\n-    CPP_PUTS (pfile, \"\\r \", 2);\n-  len = CPP_WRITTEN (pfile) - start;\n-  CPP_SET_WRITTEN (pfile, start);\n-\n-  exp = (U_CHAR *) xmalloc (len + 1);\n-  memcpy (exp, pfile->token_buffer + start, len);\n-  exp[len] = '\\0';\n-\n-  defn = (struct funct_defn *) xmalloc (sizeof (struct funct_defn));\n-  defn->length = len;\n-  defn->expansion = exp;\n-  defn->pattern = pat;\n-  defn->rest_args = argc && argv[argc - 1].rest_arg;\n-  defn->nargs = argc;\n-  defn->argnames = arglist->namebuf;\n-  if (argv)\n-    free ((PTR) argv);\n-  return defn;\n-}\n+\tdefault:\n+\t  cpp_error_with_line (pfile, line, token->col,\n+\t\t\t       \"illegal token in macro parameter list\");\n+\t  goto out;\n \n-/* Is argument NEW, which has just been added to the argument list,\n-   a duplicate of a previous argument name?  */\n-static int\n-duplicate_arg_p (args, new)\n-     U_CHAR *args, *new;\n-{\n-  size_t newlen = ustrlen (new) + 1;\n-  size_t oldlen;\n+\tcase CPP_CLOSE_PAREN:\n+\t  if (prev_ident || list->paramc == 0)\n+\t    goto scanned;\n \n-  while (args < new)\n-    {\n-      oldlen = ustrlen (args) + 1;\n-      if (!memcmp (args, new, MIN (oldlen, newlen)))\n-\treturn 1;\n-      args += oldlen;\n-    }\n-  return 0;\n-}\n+\t  /* Fall through to pick up the error.  */\n+\tcase CPP_COMMA:\n+\t  if (!prev_ident)\n+\t    {\n+\t      cpp_error_with_line (pfile, line, token->col,\n+\t\t\t\t   \"missing parameter name\");\n+\t      goto out;\n+\t    }\n+\t  prev_ident = 0;\n+\t  break;\n \n-static unsigned int\n-collect_params (pfile, list, arglist)\n-     cpp_reader *pfile;\n-     cpp_toklist *list;\n-     struct arglist *arglist;\n-{\n-  struct arg *argv = 0;\n-  const U_CHAR *tok;\n-  U_CHAR *namebuf, *p;\n-  unsigned int len, argslen;\n-  unsigned int argc, a, i, j;\n-\n-  /* The formal parameters list starts at token 1.  */\n-  if (TOK_TYPE (list, 1) != CPP_OPEN_PAREN)\n-    {\n-      cpp_ice (pfile, \"first token = %d not %d in collect_formal_parameters\",\n-\t       TOK_TYPE (list, 1), CPP_OPEN_PAREN);\n-      return 0;\n-    }\n+\tcase CPP_ELLIPSIS:\n+\t  /* Convert ISO-style var_args to named varargs by changing\n+\t     the ellipsis into an identifier with name __VA_ARGS__.\n+\t     This simplifies other handling.  We can safely have its\n+\t     text outside list->namebuf because there is no reason to\n+\t     extend the size of the list's namebuf (and thus change\n+\t     the pointer) in do_define.  */\n+\t  if (!prev_ident)\n+\t    {\n+\t      cpp_token *tok = (cpp_token *) token;\n \n-  /* Scan once and count the number of parameters; also check for\n-     syntax errors here.  */\n-  argc = 0;\n-  argslen = 0;\n-  for (i = 2; i < list->tokens_used; i++)\n-    switch (TOK_TYPE (list, i))\n-      {\n-      case CPP_NAME:\n-\targslen += TOK_LEN (list, i) + 1;\n-\targc++;\n-\tbreak;\n-      case CPP_COMMA:\n-\tbreak;\n-      case CPP_CLOSE_PAREN:\n-\tgoto scanned;\n-      case CPP_VSPACE:\n-      case CPP_EOF:\n-\tcpp_ice (pfile, \"impossible token in macro argument list\");\n-\treturn 0;\n-\n-      default:\n-\tcpp_error_with_line (pfile, list->line, TOK_COL (list, i),\n-\t\t\t     \"illegal token in macro argument list\");\n-\treturn 0;\n-\n-      case CPP_ELLIPSIS:\n-\tif (TOK_TYPE (list, i-1) != CPP_NAME)\n-\t  {\n-\t    argslen += sizeof \"__VA_ARGS__\";\n-\t    argc++;\n-\t  }\n-\ti++;\n-\tif (TOK_TYPE (list, i) != CPP_CLOSE_PAREN)\n-\t  {\n-\t    cpp_error_with_line (pfile, list->line, TOK_COL (list, i),\n-\t\t\t\t \"another parameter follows \\\"...\\\"\");\n-\t    return 0;\n-\t  }\n-\tgoto scanned;\n-      }\n-  cpp_error_with_line (pfile, list->line, TOK_COL (list, i-1),\n-\t\t       \"missing right paren in macro argument list\");\n-  return 0;\n+\t      tok->type = CPP_NAME;\n+\t      tok->val.name.len = sizeof (var_args_str) - 1;\n+\t      tok->val.name.text = var_args_str; /* Safe.  */\n+\t      list->paramc++;\n \n- scanned:\n-  if (argc == 0)\t/* function-like macro, no arguments */\n-    {\n-      arglist->argc = 0;\n-      arglist->argv = 0;\n-      arglist->namebuf = 0;\n-      return i + 1;\n-    }\n-  if (argslen == 0)\n-    {\n-      cpp_ice (pfile, \"collect_params: argc=%d argslen=0\", argc);\n-      return 0;\n+\t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n+\t\tcpp_pedwarn (pfile,\n+\t\t\t     \"C89 does not permit anon varargs macros\");\n+\t    }\n+\t  else if (CPP_PEDANTIC (pfile))\n+\t    cpp_pedwarn (pfile,\n+\t\t\t \"ISO C does not permit named varargs parameters\");\n+\n+\t  list->flags |= VAR_ARGS;\n+\t  token++;\n+\t  if (token->type == CPP_CLOSE_PAREN)\n+\t    goto scanned;\n+\t  cpp_error_with_line (pfile, line, token->col,\n+\t\t\t       \"')' expected after \\\"...\\\"\");\n+\t  goto out;\n+\t}\n     }\n \n-  /* Now allocate space and copy the suckers.  */\n-  argv = (struct arg *) xmalloc (argc * sizeof (struct arg));\n-  namebuf = (U_CHAR *) xmalloc (argslen);\n-  p = namebuf;\n-  a = 0;\n-  for (j = 2; j < i; j++)\n-    switch (TOK_TYPE (list, j))\n-      {\n-      case CPP_NAME:\n-\ttok = TOK_NAME (list, j);\n-\tlen = TOK_LEN (list, j);\n-\tmemcpy (p, tok, len);\n-\tp[len] = '\\0';\n-\tif (duplicate_arg_p (namebuf, p))\n-\t  {\n-\t    cpp_error (pfile, \"duplicate macro argument name \\\"%s\\\"\", tok);\n-\t    a++;\n-\t    break;\n-\t  }\n-\tif (CPP_PEDANTIC (pfile) && CPP_OPTION (pfile, c99)\n-\t    && len == sizeof \"__VA_ARGS__\" - 1\n-\t    && !ustrcmp (p, U\"__VA_ARGS__\"))\n-\t  cpp_pedwarn (pfile,\n-\t\"C99 does not permit use of __VA_ARGS__ as a macro argument name\");\n-\targv[a].len = len;\n-\targv[a].name = p;\n-\targv[a].rest_arg = 0;\n-\tp += len + 1;\n-\ta++;\n-\tbreak;\n-\n-      case CPP_COMMA:\n-\tbreak;\n-\n-      case CPP_ELLIPSIS:\n-\tif (TOK_TYPE (list, j-1) != CPP_NAME)\n-\t  {\n-\t    if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n-\t      cpp_pedwarn (pfile, \"C89 does not permit varargs macros\");\n-\n-\t    argv[a].len = sizeof \"__VA_ARGS__\" - 1;\n-\t    argv[a].name = p;\n-\t    argv[a].rest_arg = 1;\n-\t    strcpy ((char *)p, \"__VA_ARGS__\");\n-\t  }\n-\telse\n+ scanned:\n+  /* Store the null-terminated parameter spellings of a function, to\n+     provide pedantic warnings to satisfy 6.10.3.2, or for use when\n+     dumping macro definitions.  */\n+  if (list->paramc > 0 && pfile->save_parameter_spellings)\n+    {\n+      U_CHAR *buf;\n+\n+      _cpp_reserve_name_space (list, params_len);\n+      list->params_len = list->name_used = params_len;\n+      buf = list->namebuf;\n+      for (temp = first; temp <= token; temp++)\n+\tif (temp->type == CPP_NAME)\n \t  {\n-\t    if (CPP_PEDANTIC (pfile))\n-\t      cpp_pedwarn (pfile,\n-\t\t\t   \"ISO C does not permit named varargs macros\");\n-\t    argv[a-1].rest_arg = 1;\n+\t    memcpy (buf, temp->val.name.text, temp->val.name.len);\n+\t    buf += temp->val.name.len;\n+\t    *buf++ = '\\0';\n \t  }\n-\tbreak;\n-\n-      default:\n-\tcpp_ice (pfile, \"collect_params: impossible token type %d\",\n-\t\t TOK_TYPE (list, j));\n-      }\n+    }\n \n-  arglist->argc = argc;\n-  arglist->argv = argv;\n-  arglist->namebuf = namebuf;\n-  return i + 1;\n+ out:\n+  return token;\n }\n \n-/* Create a definition for a macro.  The replacement text (including\n-   formal parameters if present) is in LIST.  If FUNLIKE is true, this\n-   is a function-like macro.  */\n-\n-int\n-_cpp_create_definition (pfile, list, hp)\n+/* Parses a #define directive.  Returns null pointer on error.  */\n+static cpp_toklist *\n+parse_define (pfile)\n      cpp_reader *pfile;\n-     cpp_toklist *list;\n-     cpp_hashnode *hp;\n {\n-  struct funct_defn *fdefn = 0;\n-  struct object_defn *odefn = 0;\n-  enum node_type ntype;\n-  int ok;\n-\n-  /* Special-case a few simple and common idioms:\n-     #define TOKEN   // nothing\n-     #define TOKEN TOKEN\n-\n-     Might also be good to special-case these:\n-\n-     #define FUNC()  // nothing\n-     #define FUNC(a, b, ...) // nothing\n-     #define FUNC(a, b, c) FUNC(a, b, c)  */\n-\n-  if (list->tokens_used == 1)\n-    ntype = T_EMPTY;    /* Empty definition of object-like macro.  */\n-  else if (list->tokens_used == 2 && TOK_TYPE (list, 1) == CPP_NAME\n-\t   && TOK_LEN (list, 0) == TOK_LEN (list, 1)\n-\t   && !ustrncmp (TOK_NAME (list, 0), TOK_NAME (list, 1),\n-\t\t\t TOK_LEN (list, 0)))\n-    ntype = T_IDENTITY;  /* Object like macro defined to itself.  */\n-\n-  /* The macro is function-like only if the next character,\n-     with no intervening whitespace, is '('.  */\n-  else if (TOK_TYPE (list, 1) == CPP_OPEN_PAREN\n-\t   && ! TOK_PREV_WHITE (list, 1))\n-    {\n-      struct arglist args;\n-      int replacement;\n+  const cpp_token *token, *first_param;\n+  cpp_toklist *list;\n+  int prev_white = 0;\n \n-      replacement = collect_params (pfile, list, &args);\n-      if (replacement == 0)\n-\treturn 0;\n-      fdefn = collect_funlike_expansion (pfile, list, &args, replacement);\n-      if (fdefn == 0)\n-\treturn 0;\n+  while ((token = cpp_get_token (pfile))->type == CPP_COMMENT)\n+    prev_white = 1;\n \n-      ntype = T_FMACRO;\n-    }\n+  /* Allocate the expansion's list.  It will go in the hash table.  */\n+  list = (cpp_toklist *) xmalloc (sizeof (cpp_toklist));\n+  _cpp_init_toklist (list, 0);\n+  first_param = token + 1;\n+  list->paramc = -1;\t\t/* Object-like macro.  */\n \n-  /* Otherwise it is an object-like macro, and C99 requires\n-     whitespace after the name (6.10.3 para 3).  */\n-  else\n+  if (!prev_white && !(token->flags & PREV_WHITE))\n     {\n-      if (! TOK_PREV_WHITE (list, 1))\n-\tcpp_pedwarn (pfile,\n-\t\t     \"The C standard requires whitespace after #define %s\",\n-\t\t     hp->name);\n-\n-      odefn = collect_objlike_expansion (pfile, list);\n-      if (odefn == 0)\n-\treturn 0;\n-\n-      ntype = T_MACRO;\n-    }\n-\n-  if (ntype == T_EMPTY || ntype == T_IDENTITY)\n-    {\n-      odefn = xmalloc (sizeof (struct object_defn));\n-      odefn->length = 0;\n-      odefn->expansion = 0;\n-    }\n-\n-  /* Check for a redefinition, and its legality.  Redefining a macro\n-     of whatever stripe is ok if the definitions are the same.\n-     Redefining a built-in _constant_ (T_CONST or T_XCONST) is ok only\n-     with -D.  Otherwise a redefinition is not ok.  */\n-\n-  switch (hp->type)\n-    {\n-    case T_VOID:  ok = 1; break;\n-    default:\t  ok = 0; break;\n-\n-    case T_MACRO:\n-      ok = (ntype == hp->type\n-\t    && odefn->length == hp->value.odefn->length\n-\t    && !ustrncmp (odefn->expansion, hp->value.odefn->expansion,\n-\t\t\t  odefn->length));\n-      break;\n-    case T_FMACRO:\n-      ok = (ntype == hp->type\n-\t    && !compare_defs (pfile, fdefn, hp->value.fdefn));\n-      break;\n-    case T_IDENTITY:\n-    case T_EMPTY:\n-      ok = (ntype == hp->type);\n-      break;\n-    case T_CONST:\n-    case T_XCONST:\n-      ok = ! pfile->done_initializing;\n-      break;\n-    }\n-\n-  /* Print the warning or error if it's not ok.  */\n-  if (! ok)\n-    {\n-      cpp_pedwarn (pfile, \"\\\"%s\\\" redefined\", hp->name);\n-      if (pfile->done_initializing)\n+      if (token->type == CPP_OPEN_PAREN)\n \t{\n-\t  const char *file;\n-\t  unsigned int line, col;\n-\t  if (hp->type == T_FMACRO)\n-\t    {\n-\t      file = hp->value.fdefn->file;\n-\t      line = hp->value.fdefn->line;\n-\t      col  = hp->value.fdefn->col;\n-\t    }\n-\t  else\n-\t    {\n-\t      file = hp->value.odefn->file;\n-\t      line = hp->value.odefn->line;\n-\t      col  = hp->value.odefn->col;\n-\t    }\n-\tcpp_pedwarn_with_file_and_line (pfile, file, line, col,\n-\t\t\t\"this is the location of the previous definition\");\n+\t  token = count_params (pfile, first_param, list);\n+\t  if (token->type != CPP_CLOSE_PAREN)\n+\t    goto error;\n+\t  token++;\n \t}\n+      else if (token->type != CPP_EOF)\n+\tcpp_pedwarn (pfile,\n+\t\t     \"ISO C requires whitespace after the macro name\");\n     }\n \n-  /* And replace the old definition (if any).  */\n-\n-  _cpp_free_definition (hp);\n-\n-  hp->type = ntype;\n-  if (ntype == T_FMACRO)\n+  if (save_expansion (pfile, list, token, first_param))\n     {\n-      fdefn->file = CPP_BUFFER (pfile)->nominal_fname;\n-      fdefn->line = list->line;\n-      fdefn->col  = TOK_COL (list, 0);\n-      hp->value.fdefn = fdefn;\n-    }\n-  else\n-    {\n-      odefn->file = CPP_BUFFER (pfile)->nominal_fname;\n-      odefn->line = list->line;\n-      odefn->col  = TOK_COL (list, 0);\n-      hp->value.odefn = odefn;\n-    }\n-  return 1;\n-}\n-\n-/*\n- * Parse a macro argument and append the info on PFILE's token_buffer.\n- * REST_ARGS means to absorb the rest of the args.\n- * Return nonzero to indicate a syntax error.\n- */\n-\n-static enum cpp_ttype\n-macarg (pfile, rest_args)\n-     cpp_reader *pfile;\n-     int rest_args;\n-{\n-  int paren = 0;\n-  enum cpp_ttype token;\n-\n-  /* Try to parse as much of the argument as exists at this\n-     input stack level.  */\n-  for (;;)\n-    {\n-      token = cpp_get_token (pfile);\n-      switch (token)\n-\t{\n-\tcase CPP_EOF:\n-\t  /* We've hit end of file; this is an error.\n-\t     Caller will report it.  */\n-\t  return token;\n-\tcase CPP_OPEN_PAREN:\n-\t  paren++;\n-\t  break;\n-\tcase CPP_CLOSE_PAREN:\n-\t  if (--paren < 0)\n-\t    goto found;\n-\t  break;\n-\tcase CPP_COMMA:\n-\t  /* if we've returned to lowest level and\n-\t     we aren't absorbing all args */\n-\t  if (paren == 0 && rest_args == 0)\n-\t    goto found;\n-\t  break;\n-\tfound:\n-\t  /* Remove ',' or ')' from argument buffer.  */\n-\t  CPP_ADJUST_WRITTEN (pfile, -1);\n-\t  return token;\n-\tdefault:;\n-\t}\n+    error:\n+      _cpp_free_toklist (list);\n+      list = 0;\n     }\n-}\n-\f\n-\n-static const char * const monthnames[] =\n-{\n-  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n-  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n-};\n-\n-/* Place into PFILE a quoted string representing the string SRC.\n-   Caller must reserve enough space in pfile->token_buffer.  */\n-\n-void\n-_cpp_quote_string (pfile, src)\n-     cpp_reader *pfile;\n-     const U_CHAR *src;\n-{\n-  U_CHAR c;\n-\n-  CPP_PUTC_Q (pfile, '\\\"');\n-  for (;;)\n-    switch ((c = *src++))\n-      {\n-      default:\n-        if (ISPRINT (c))\n-\t  CPP_PUTC_Q (pfile, c);\n-\telse\n-\t  {\n-\t    sprintf ((char *)CPP_PWRITTEN (pfile), \"\\\\%03o\", c);\n-\t    CPP_ADJUST_WRITTEN (pfile, 4);\n-\t  }\n-\tbreak;\n \n-      case '\\\"':\n-      case '\\\\':\n-\tCPP_PUTC_Q (pfile, '\\\\');\n-\tCPP_PUTC_Q (pfile, c);\n-\tbreak;\n-      \n-      case '\\0':\n-\tCPP_PUTC_Q (pfile, '\\\"');\n-\treturn;\n-      }\n+  return list;\n }\n \n-/*\n- * expand things like __FILE__.  Place the expansion into the output\n- * buffer *without* rescanning.\n- */\n-\n-#define DSC(str) (const U_CHAR *)str, sizeof str - 1\n-static void\n-special_symbol (pfile, hp)\n-     cpp_reader *pfile;\n-     cpp_hashnode *hp;\n-{\n-  const U_CHAR *buf;\n-  cpp_buffer *ip;\n-  size_t len;\n-\n-  switch (hp->type)\n-    {\n-    case T_FILE:\n-    case T_BASE_FILE:\n-      ip = cpp_file_buffer (pfile);\n-      if (ip == NULL)\n-\t{\n-\t  CPP_PUTS (pfile, \"\\\"\\\"\", 2);\n-\t  return;\n-\t}\n-      if (hp->type == T_BASE_FILE)\n-\twhile (CPP_PREV_BUFFER (ip) != NULL)\n-\t  ip = CPP_PREV_BUFFER (ip);\n-\n-      buf = (const U_CHAR *) ip->nominal_fname;\n-      len = ustrlen (buf);\n-      CPP_RESERVE (pfile, 3 + 4 * len);\n-      _cpp_quote_string (pfile, buf);\n-      return;\n-\n-    case T_INCLUDE_LEVEL:\n-      {\n-\tint true_indepth = 0;\n-\tip = cpp_file_buffer (pfile);\n-\twhile (ip)\n-\t  {\n-\t    true_indepth++;\n-\t    ip = CPP_PREV_BUFFER (ip);\n-\t  }\n-\n-\tCPP_RESERVE (pfile, 10);\n-\tsprintf ((char *)CPP_PWRITTEN (pfile), \"%d\", true_indepth);\n-\tlen = ustrlen (CPP_PWRITTEN (pfile));\n-\tCPP_ADJUST_WRITTEN (pfile, len);\n-\treturn;\n-      }\n-\n-    case T_STDC:\n-#ifdef STDC_0_IN_SYSTEM_HEADERS\n-      ip = cpp_file_buffer (pfile);\n-      if (ip && ip->inc->sysp\n-\t  && !cpp_defined (pfile, DSC(\"__STRICT_ANSI__\")))\n-\t{\n-\t  CPP_PUTC (pfile, '0');\n-\t  return;\n-\t}\n-#endif\n-    constant:\n-      buf = hp->value.cpval;\n-      if (!buf || *buf == '\\0')\n-\treturn;\n-\n-      len = ustrlen (buf);\n-      CPP_PUTS (pfile, buf, len);\n-      return;\n-\n-    case T_SPECLINE:\n-      ip = cpp_file_buffer (pfile);\n-      if (ip == NULL)\n-\t{\n-\t  CPP_PUTC (pfile, '0');\n-\t  return;\n-\t}\n-      CPP_RESERVE (pfile, 10);\n-      sprintf ((char *)CPP_PWRITTEN (pfile), \"%u\", CPP_BUF_LINE (ip));\n-      len = ustrlen (CPP_PWRITTEN (pfile));\n-      CPP_ADJUST_WRITTEN (pfile, len);\n-      return;\n-\n-    case T_DATE:\n-    case T_TIME:\n-      /* Generate both __DATE__ and __TIME__, stuff them into their\n-\t respective hash nodes, and mark the nodes T_XCONST so we\n-\t don't have to do this again.  We don't generate these strings\n-\t at init time because time() and localtime() are very slow on\n-\t some systems.  */\n-      {\n-\ttime_t tt = time (NULL);\n-\tstruct tm *tb = localtime (&tt);\n-\tcpp_hashnode *d, *t;\n-\n-\tif (hp->type == T_DATE)\n-\t  d = hp, t = cpp_lookup (pfile, DSC(\"__TIME__\"));\n-\telse\n-\t  t = hp, d = cpp_lookup (pfile, DSC(\"__DATE__\"));\n-\n-\td->value.cpval = xmalloc (sizeof \"'Oct 11 1347'\");\n-\tsprintf ((char *)d->value.cpval, \"\\\"%s %2d %4d\\\"\",\n-\t\t monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n-\td->type = T_XCONST;\n-\n-\tt->value.cpval = xmalloc (sizeof \"'12:34:56'\");\n-\tsprintf ((char *)t->value.cpval, \"\\\"%02d:%02d:%02d\\\"\",\n-\t\t tb->tm_hour, tb->tm_min, tb->tm_sec);\n-\tt->type = T_XCONST;\n-\tgoto constant;\n-      }\n-\n-    case T_POISON:\n-      cpp_error (pfile, \"attempt to use poisoned `%s'.\", hp->name);\n-      CPP_PUTC (pfile, '0');\n-      break;\n-\n-    default:\n-      cpp_ice (pfile, \"invalid special hash type\");\n-      return;\n-    }\n-}\n-#undef DSC\n-\n-/* Expand a macro call.\n-   HP points to the symbol that is the macro being called.\n-   Put the result of expansion onto the input stack\n-   so that subsequent input by our caller will use it.\n-\n-   If macro wants arguments, caller has already verified that\n-   an argument list follows; arguments come from the input stack.  */\n-\n-void\n-_cpp_macroexpand (pfile, hp)\n+static int\n+check_macro_redefinition (pfile, hp, list2)\n      cpp_reader *pfile;\n      cpp_hashnode *hp;\n+     const cpp_toklist *list2;\n {\n-  const struct funct_defn *defn;\n-  struct argdata *args;\n-  unsigned int old_written;\n-  int i;\n-\n-  /* Object like macro - most common case.  */\n-  if (hp->type == T_MACRO)\n-    {\n-      push_macro_expansion (pfile, hp->value.odefn->expansion,\n-\t\t\t    hp->value.odefn->length, hp);\n-      return;\n-    }\n-\n-  /* Or might it be a constant string?  */\n-  if (hp->type == T_CONST || hp->type == T_XCONST)\n-    {\n-      const U_CHAR *cpval = hp->value.cpval;\n-      if (cpval && *cpval != '\\0')\n-\tpush_macro_expansion (pfile, cpval, ustrlen (cpval), hp);\n-      return;\n-    }\n-\n-  /* Or a special symbol?  */\n-  if (hp->type != T_FMACRO)\n-    {\n-      U_CHAR *xbuf;\n-      unsigned int len;\n-\n-      old_written = CPP_WRITTEN (pfile);\n-      special_symbol (pfile, hp);\n-      len = CPP_WRITTEN (pfile) - old_written;\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      if (len == 0)\n-\treturn;\n-\n-      xbuf = (U_CHAR *) xmalloc (len + 1);\n-      memcpy (xbuf, CPP_PWRITTEN (pfile), len);\n-      xbuf[len] = '\\0';\n-      push_macro_expansion (pfile, xbuf, len, hp);\n-      return;\n-    }\n-\n-  /* Okay, it's a full-on function-like macro...  */\n-  old_written = CPP_WRITTEN (pfile);\n-  defn = hp->value.fdefn;\n-\n-  args = alloca (MAX (defn->nargs, 1) * sizeof (struct argdata));\n-  for (i = 0; i < MAX (defn->nargs, 1); i++)\n-    {\n-      args[i].raw = args[i].expanded = 0;\n-      args[i].raw_length = 0;\n-      args[i].expand_length = args[i].stringified_length = -1;\n-    }\n+  const cpp_toklist *list1;\n \n-  pfile->output_escapes++;\n-  scan_arguments (pfile, defn, args, hp->name);\n+  if (hp->type != T_MACRO)\n+    return ! pfile->done_initializing;\n \n-  /* If macro wants zero args, we parsed the arglist for checking only.\n-     Read directly from the macro definition.  */\n-  if (defn->nargs == 0 || defn->pattern == 0)\n-    {\n-      /* If the defn is the empty string, don't bother pushing it.  */\n-      if (defn->length > 4)\n-\tpush_macro_expansion (pfile, defn->expansion, defn->length, hp);\n-    }\n-  else\n-    funlike_macroexpand (pfile, hp, args);\n+  /* Clear the whitespace and BOL flags of the first tokens.  They get\n+     altered during macro expansion, but is not significant here.  */\n+  list1  = hp->value.expansion;\n+  list1->tokens[0].flags &= ~(PREV_WHITE|BOL);\n+  list2->tokens[0].flags &= ~(PREV_WHITE|BOL);\n \n-  CPP_SET_WRITTEN (pfile, old_written);\n-  pfile->output_escapes--;\n-}\n+  if (!_cpp_equiv_toklists (list1, list2))\n+    return 0;\n \n-static void\n-scan_arguments (pfile, defn, args, name)\n-     cpp_reader *pfile;\n-     const struct funct_defn *defn;\n-     struct argdata *args;\n-     const U_CHAR *name;\n-{\n-  enum cpp_ttype token;\n-  unsigned int start_line, start_column;\n-  unsigned int nargs = defn->nargs;\n-  unsigned int i;\n-  \n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n-  if (ip)\n-    {\n-      start_line = CPP_BUF_LINE (ip);\n-      start_column = CPP_BUF_COL (ip);\n-    }\n-  else\n-    start_line = start_column = 0;\n-\n-  /* Parse all the macro args that are supplied.  I counts them.  The\n-     first NARGS args are stored in ARGS.  The rest are discarded.  If\n-     rest_args is set then we assume macarg absorbed the rest of the\n-     args.  */\n-  i = 0;\n-\n-  /* Skip over the opening parenthesis.  */\n-  CPP_OPTION (pfile, discard_comments)++;\n-  pfile->no_macro_expand++;\n-  pfile->no_directives++;\n-\n-  token = cpp_get_non_space_token (pfile);\n-  if (token != CPP_OPEN_PAREN)\n-    cpp_ice (pfile, \"macroexpand: unexpected token %d (wanted LPAREN)\",\n-\t     token);\n-  CPP_ADJUST_WRITTEN (pfile, -1);\n-\n-  token = CPP_EOF;\n-  do\n-    {\n-      if (i < MAX (nargs, 1))\n-\t{\n-\t  args[i].raw = CPP_WRITTEN (pfile);\n-\t  token = macarg (pfile, (i == nargs - 1 && defn->rest_args));\n-\t  args[i].raw_length = CPP_WRITTEN (pfile) - args[i].raw;\n-\t}\n-      else\n-\ttoken = macarg (pfile, 0);\n-      if (token == CPP_EOF)\n-\tcpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t     \"unterminated macro call\");\n-      i++;\n-    }\n-  while (token == CPP_COMMA);\n-  CPP_OPTION (pfile, discard_comments)--;\n-  pfile->no_macro_expand--;\n-  pfile->no_directives--;\n-  if (token != CPP_CLOSE_PAREN)\n-    return;\n-\n-  /* foo ( ) is equivalent to foo () unless foo takes exactly one\n-     argument, in which case the former is allowed and the latter\n-     is not.  XXX C99 is silent on this rule, but it seems\n-     inconsistent to me.  */\n-  if (i == 1 && nargs == 0)\n-    {\n-      register U_CHAR *bp = ARG_BASE + args[0].raw;\n-      register U_CHAR *lim = bp + args[0].raw_length;\n-      while (bp != lim && is_space(*bp))\n-\tbp++;\n-      if (bp == lim)\n-\ti = 0;\n-    }\n+  if (CPP_OPTION (pfile, pedantic)\n+      && list1->paramc > 0\n+      && (list1->params_len != list2->params_len\n+\t  || memcmp (list1->namebuf, list2->namebuf, list1->params_len)))\n+    return 0;\n \n-  /* Don't output an error message if we have already output one for\n-     a parse error above.  */\n-  if (nargs == 0 && i > 0)\n-    {\n-      cpp_error (pfile, \"arguments given to macro `%s'\", name);\n-    }\n-  else if (i < nargs)\n-    {\n-      /* traditional C allows foo() if foo wants one argument.  */\n-      if (nargs == 1 && i == 0 && CPP_TRADITIONAL (pfile))\n-\t;\n-      /* the rest args token is allowed to absorb 0 tokens */\n-      else if (i == nargs - 1 && defn->rest_args)\n-\t;\n-      else if (i == 0)\n-\tcpp_error (pfile, \"macro `%s' used without args\", name);\n-      else if (i == 1)\n-\tcpp_error (pfile, \"macro `%s' used with just one arg\", name);\n-      else\n-\tcpp_error (pfile, \"macro `%s' used with only %d args\", name, i);\n-    }\n-  else if (i > nargs)\n-    {\n-      cpp_error (pfile, \"macro `%s' used with too many (%d) args\", name, i);\n-    }\n+  return 1;\n }\n \n-static void\n-stringify (pfile, arg)\n+/* Copy the tokens of the expansion.  Change the type of macro\n+   arguments from CPP_NAME to CPP_MACRO_ARG.  Remove #'s that\n+   represent stringification, flagging the CPP_MACRO_ARG it operates\n+   on STRINGIFY.  Remove ##'s, flagging the token on its immediate\n+   left PASTE_LEFT.  Returns non-zero on error.  */\n+static int\n+save_expansion (pfile, list, first, first_param)\n      cpp_reader *pfile;\n-     struct argdata *arg;\n+     cpp_toklist *list;\n+     const cpp_token *first;\n+     const cpp_token *first_param;\n {\n-  int arglen = arg->raw_length;\n-  int escaped = 0;\n-  int in_string = 0;\n-  int c;\n-  int i;\n-  /* Initially need_space is -1.  Otherwise, 1 means the previous\n-     character was a space, but we suppressed it; 0 means the previous\n-     character was a non-space.  */\n-  int need_space = -1;\n-  i = 0;\n-  arg->stringified = CPP_WRITTEN (pfile);\n-  CPP_PUTC (pfile, '\\\"');\t/* insert beginning quote */\n-  for (; i < arglen; i++)\n+  const cpp_token *token;\n+  cpp_token *dest;\n+  unsigned int len, ntokens;\n+  unsigned char *buf;\n+      \n+  /* Count tokens in expansion.  We drop paste tokens, and stringize\n+     tokens, so don't count them.  */\n+  ntokens = len = 0;\n+  for (token = first; token->type != CPP_EOF; token++)\n     {\n-      c = (ARG_BASE + arg->raw)[i];\n+      const char *msg;\n \n-      if (!in_string)\n+      if (token->type == CPP_PASTE)\n \t{\n-\t  /* Delete \"\\r \" and \"\\r-\" escapes.  */\n-\t  if (c == '\\r')\n-\t    {\n-\t      i++;\n-\t      continue;\n-\t    }\n-\t  /* Internal sequences of whitespace are replaced by one\n-\t     space except within a string or char token. */\n-\t  else if (is_space(c))\n+\t  /* Token-paste ##, but is a normal token if traditional.  */\n+\t  if (! CPP_TRADITIONAL (pfile))\n \t    {\n-\t      if (need_space == 0)\n-\t\tneed_space = 1;\n+\t      msg = \"\\\"##\\\" cannot appear at either end of a macro expansion\";\n+\t      /* Constraint 6.10.3.3.1  */\n+\t      if (token == first || token[1].type == CPP_EOF)\n+\t\tgoto error;\n \t      continue;\n \t    }\n-\t  else if (need_space > 0)\n-\t    CPP_PUTC (pfile, ' ');\n-\t  need_space = 0;\n \t}\n-\n-      if (escaped)\n-\tescaped = 0;\n-      else\n+      else if (token->type == CPP_HASH)\n \t{\n-\t  if (c == '\\\\')\n-\t    escaped = 1;\n-\t  if (in_string)\n+\t  /* Stringifying #, but is a normal character if traditional,\n+\t     or in object-like macros.  Constraint 6.10.3.2.1.  */\n+\t  if (list->paramc >= 0 && ! CPP_TRADITIONAL (pfile))\n \t    {\n-\t      if (c == in_string)\n-\t\tin_string = 0;\n+\t      if (token[1].type == CPP_NAME\n+\t\t  && find_param (first_param, token + 1))\n+\t\tcontinue;\n+\t      if (! CPP_OPTION (pfile, lang_asm))\n+\t\t{\n+\t\t  msg = \"'#' is not followed by a macro parameter\";\n+\t\terror:\n+\t\t  cpp_error_with_line (pfile, token->line, token->col, msg);\n+\t\t  return 1;\n+\t\t}\n \t    }\n-\t  else if (c == '\\\"' || c == '\\'')\n-\t    in_string = c;\n-\t}\n-\n-      /* Escape these chars */\n-      if (c == '\\\"' || (in_string && c == '\\\\'))\n-\tCPP_PUTC (pfile, '\\\\');\n-      if (ISPRINT (c))\n-\tCPP_PUTC (pfile, c);\n-      else\n-\t{\n-\t  CPP_RESERVE (pfile, 4);\n-\t  sprintf ((char *) CPP_PWRITTEN (pfile), \"\\\\%03o\", (unsigned int) c);\n-\t  CPP_ADJUST_WRITTEN (pfile, 4);\n \t}\n+      ntokens++;\n+      if (token_spellings[token->type].type > SPELL_NONE)\n+\tlen += token->val.name.len;\n     }\n-  CPP_PUTC (pfile, '\\\"');\t/* insert ending quote */\n-  arg->stringified_length  = CPP_WRITTEN (pfile) - arg->stringified;\n-}\n \n-static void\n-funlike_macroexpand (pfile, hp, args)\n-     cpp_reader *pfile;\n-     cpp_hashnode *hp;\n-     struct argdata *args;\n-{\n-  const struct funct_defn *defn = hp->value.fdefn;\n-  register U_CHAR *xbuf;\n-  int xbuf_len;\n-  const U_CHAR *exp = defn->expansion;\n-  int offset;\t/* offset in expansion, copied a piece at a time */\n-  int totlen;\t/* total amount of exp buffer filled so far */\n-  const struct reflist *ap, *last_ap;\n-  int i;\n-\n-  /* Compute length in characters of the macro's expansion.\n-     Also count number of times each arg is used.  */\n-  xbuf_len = defn->length;\n-  for (ap = defn->pattern; ap != NULL; ap = ap->next)\n-    {\n-      if (ap->stringify)\n-\t{\n-\t  /* Stringify if it hasn't already been */\n-\t  if (args[ap->argno].stringified_length < 0)\n-\t    stringify (pfile, &args[ap->argno]);\n-\t  xbuf_len += args[ap->argno].stringified_length;\n-\t}\n-      else if (ap->raw_before || ap->raw_after)\n-\t/* Add 4 for two \\r-space markers to prevent\n-\t   token concatenation.  */\n-\txbuf_len += args[ap->argno].raw_length + 4;\n-      else\n-\t{\n-\t  /* We have an ordinary (expanded) occurrence of the arg.\n-\t     So compute its expansion, if we have not already.  */\n-\t  if (args[ap->argno].expand_length < 0)\n-\t    {\n-\t      args[ap->argno].expanded = CPP_WRITTEN (pfile);\n-\t      _cpp_expand_to_buffer (pfile, ARG_BASE + args[ap->argno].raw,\n-\t\t\t\t     args[ap->argno].raw_length);\n+  /* Allocate space to hold the tokens.  Empty expansions are stored\n+     as a single placemarker token.  */\n+  if (ntokens == 0)\n+    ntokens++;\n+  _cpp_expand_token_space (list, ntokens);\n+  if (len > 0)\n+    _cpp_expand_name_space (list, len);\n \n-\t      args[ap->argno].expand_length\n-\t\t= CPP_WRITTEN (pfile) - args[ap->argno].expanded;\n-\t    }\n+  dest = list->tokens;\n+  buf = list->namebuf + list->name_used;\n+  for (token = first; token->type != CPP_EOF; token++)\n+    {\n+      unsigned int param_no;\n \n-\t  /* Add 4 for two \\r-space markers to prevent\n-\t     token concatenation.  */\n-\t  xbuf_len += args[ap->argno].expand_length + 4;\n-\t}\n-    }\n+      switch (token->type)\n+\t{\n+\tcase CPP_NAME:\n+\t  if (list->paramc == -1)\n+\t    break;\n \n-  xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n+\t  /* Check if the name is a macro parameter.  */\n+\t  param_no = find_param (first_param, token);\n+\t  if (param_no == 0)\n+\t    break;\n+\t  dest->val.aux = param_no - 1;\n \n-  /* Generate in XBUF the complete expansion with arguments\n-     substituted in.  TOTLEN is the total size generated so far.\n-     OFFSET is the index in the definition of where we are copying\n-     from.  */\n-  offset = totlen = 0;\n-  for (last_ap = NULL, ap = defn->pattern; ap != NULL;\n-       last_ap = ap, ap = ap->next)\n-    {\n-      register struct argdata *arg = &args[ap->argno];\n-      int count_before = totlen;\n-\n-      /* Add chars to XBUF.  */\n-      i = ap->nchars;\n-      memcpy (&xbuf[totlen], &exp[offset], i);\n-      totlen += i;\n-      offset += i;\n-\n-      /* If followed by an empty rest arg with concatenation,\n-\t delete the last run of nonwhite chars.  */\n-      if (arg->raw_length == 0 && totlen > count_before\n-\t  && ((ap->rest_args && ap->raw_before)\n-\t      || (last_ap != NULL && last_ap->rest_args\n-\t\t  && last_ap->raw_after)))\n-\t{\n-\t  /* Delete final whitespace.  */\n-\t  while (totlen > count_before && is_space(xbuf[totlen - 1]))\n-\t    totlen--;\n+\t  dest->type = CPP_MACRO_ARG;\n+\t  if (token[-1].type == CPP_HASH && ! CPP_TRADITIONAL (pfile))\n+\t    dest->flags = token[-1].flags | STRINGIFY_ARG;\n+\t  else\n+\t    dest->flags = token->flags;  /* Particularly PREV_WHITE.  */\n \n-\t  /* Delete the nonwhites before them.  */\n-\t  while (totlen > count_before && !is_space(xbuf[totlen - 1]))\n-\t    totlen--;\n-\t}\n+\t  if ((int) param_no == list->paramc && list->flags & VAR_ARGS\n+\t      && dest != list->tokens && dest[-1].flags & PASTE_LEFT)\n+\t    dest[-1].flags |= GNU_VARARGS;\n+\t  dest++;\n+\t  continue;\n \n-      if (ap->stringify != 0)\n-\t{\n-\t  memcpy (xbuf + totlen, ARG_BASE + arg->stringified,\n-\t\t  arg->stringified_length);\n-\t  totlen += arg->stringified_length;\n-\t}\n-      else if (ap->raw_before || ap->raw_after)\n-\t{\n-\t  U_CHAR *p1 = ARG_BASE + arg->raw;\n-\t  U_CHAR *l1 = p1 + arg->raw_length;\n-\t  if (ap->raw_before)\n-\t    {\n-\t      /* Arg is concatenated before: delete leading whitespace,\n-\t\t whitespace markers, and no-reexpansion markers.  */\n-\t      while (p1 < l1)\n-\t\t{\n-\t\t  if (is_space(p1[0]))\n-\t\t    p1++;\n-\t\t  else if (p1[0] == '\\r')\n-\t\t    p1 += 2;\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\t    }\n-\t  if (ap->raw_after)\n+\tcase CPP_PASTE:\n+\t  if (! CPP_TRADITIONAL (pfile))\n \t    {\n-\t      /* Arg is concatenated after: delete trailing whitespace,\n-\t\t whitespace markers, and no-reexpansion markers.  */\n-\t      while (p1 < l1)\n-\t\t{\n-\t\t  if (is_space(l1[-1]))\n-\t\t    l1--;\n-\t\t  else if (l1[-1] == '\\r')\n-\t\t    l1--;\n-\t\t  else if (l1[-1] == '-')\n-\t\t    {\n-\t\t      if (l1 != p1 + 1 && l1[-2] == '\\r')\n-\t\t\tl1 -= 2;\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\t}\n+\t      dest[-1].flags |= PASTE_LEFT;\n+\t      continue;\n \t    }\n+\t  break;\n \n-\t  /* Delete any no-reexpansion marker that precedes\n-\t     an identifier at the beginning of the argument. */\n-\t  if (p1 + 2 <= l1 && p1[0] == '\\r' && p1[1] == '-')\n-\t    p1 += 2;\n+\tcase CPP_HASH:\n+\t  /* Stringifying #.  Constraint 6.10.3.2.1  */\n+\t  if (list->paramc >= 0 && ! CPP_TRADITIONAL (pfile)\n+\t      && token[1].type == CPP_NAME\n+\t      && find_param (first_param, token + 1))\n+\t    continue;\n+\t  break;\n \n-\t  memcpy (xbuf + totlen, p1, l1 - p1);\n-\t  totlen += l1 - p1;\n+\tdefault:\n+\t  break;\n \t}\n-      else\n-\t{\n-\t  U_CHAR *expanded = ARG_BASE + arg->expanded;\n-\t  if (!ap->raw_before && totlen > 0 && arg->expand_length\n-\t      && unsafe_chars (pfile, xbuf[totlen - 1], expanded[0]))\n-\t    {\n-\t      xbuf[totlen++] = '\\r';\n-\t      xbuf[totlen++] = ' ';\n-\t    }\n-\n-\t  memcpy (xbuf + totlen, expanded, arg->expand_length);\n-\t  totlen += arg->expand_length;\n \n-\t  if (!ap->raw_after && totlen > 0 && offset < defn->length\n-\t      && unsafe_chars (pfile, xbuf[totlen - 1], exp[offset]))\n-\t    {\n-\t      xbuf[totlen++] = '\\r';\n-\t      xbuf[totlen++] = ' ';\n-\t    }\n+      /* Copy the token.  */\n+      *dest = *token;\n+      if (token_spellings[token->type].type > SPELL_NONE)\n+\t{\n+\t  memcpy (buf, token->val.name.text, token->val.name.len);\n+\t  dest->val.name.text = buf;\n+\t  buf += dest->val.name.len;\n \t}\n+      dest++;\n     }\n \n-  /* if there is anything left of the definition\n-     after handling the arg list, copy that in too.  */\n-\n-  for (i = offset; i < defn->length; i++)\n-    xbuf[totlen++] = exp[i];\n-  xbuf[totlen] = 0;\n-\n-  if (totlen > xbuf_len)\n-    /* Just die - we've trashed the heap at this point.  */\n-    abort ();\n-  \n-  /* Now put the expansion on the input stack\n-     so our caller will commence reading from it.  */\n-  push_macro_expansion (pfile, xbuf, totlen, hp);\n-\n-  /* Overload buffer->mapped to indicate that xbuf needs to be freed.  */\n-  CPP_BUFFER (pfile)->mapped = 1;\n-}\n-\n-/* Return 1 iff a token ending in C1 followed directly by a token C2\n-   could cause mis-tokenization.  */\n-\n-static int\n-unsafe_chars (pfile, c1, c2)\n-     cpp_reader *pfile;\n-     int c1, c2;\n-{\n-  /* If c2 is EOF, that's always safe.  */\n-  if (c2 == EOF)\n-    return 0;\n-\n-  switch (c1)\n+  if (dest == list->tokens)\n     {\n-    case EOF:\n-      /* We don't know what the previous character was.  We do know\n-\t that it can't have been an idchar (or else it would have been\n-\t pasted with the idchars of the macro name), and there are a\n-\t number of second characters for which it doesn't matter what\n-\t the first was.  */\n-      if (is_idchar (c2) || c2 == '\\'' || c2 == '\\\"'\n-\t  || c2 == '(' || c2 == '[' || c2 == '{'\n-\t  || c2 == ')' || c2 == ']' || c2 == '}')\n-\treturn 0;\n-      return 1;\n-\n-    case '+':  case '-':\n-      if (c2 == c1 || c2 == '=')\n-\treturn 1;\n-      goto letter;\n-\n-    case 'e':  case 'E':  case 'p':  case 'P':\n-      if (c2 == '-' || c2 == '+')\n-\treturn 1;\t\t/* could extend a pre-processing number */\n-      goto letter;\n-\n-    case '$':\n-      if (CPP_OPTION (pfile, dollars_in_ident))\n-\tgoto letter;\n-      return 0;\n-\n-    case 'L':\n-      if (c2 == '\\'' || c2 == '\\\"')\n-\treturn 1;\t\t/* Could turn into L\"xxx\" or L'xxx'.  */\n-      goto letter;\n-\n-    case '.':  case '0':  case '1':  case '2':  case '3':\n-    case '4':  case '5':  case '6':  case '7':  case '8':  case '9':\n-    case '_':  case 'a':  case 'b':  case 'c':  case 'd':  case 'f':\n-    case 'g':  case 'h':  case 'i':  case 'j':  case 'k':  case 'l':\n-    case 'm':  case 'n':  case 'o':  case 'q':  case 'r':  case 's':\n-    case 't':  case 'u':  case 'v':  case 'w':  case 'x':  case 'y':\n-    case 'z':  case 'A':  case 'B':  case 'C':  case 'D':  case 'F':\n-    case 'G':  case 'H':  case 'I':  case 'J':  case 'K':  case 'M':\n-    case 'N':  case 'O':  case 'Q':  case 'R':  case 'S':  case 'T':\n-    case 'U':  case 'V':  case 'W':  case 'X':  case 'Y':  case 'Z':\n-    letter:\n-    /* We're in the middle of either a name or a pre-processing number.  */\n-      return (is_idchar(c2) || c2 == '.');\n-\n-    case '<':  case '>':  case '!':  case '%':  case '#':  case ':':\n-    case '^':  case '&':  case '|':  case '*':  case '/':  case '=':\n-      return (c2 == c1 || c2 == '=');\n+      dest->type = CPP_PLACEMARKER;\n+      dest->flags = 0;\n     }\n+\n+  list->tokens_used = ntokens;\n+  list->line = pfile->token_list.line;\n+  list->file = pfile->token_list.file;\n+  list->name_used = len;\n+\n   return 0;\n }\n \n-static void\n-push_macro_expansion (pfile, xbuf, len, hp)\n+int\n+_cpp_create_definition (pfile, hp)\n      cpp_reader *pfile;\n-     const U_CHAR *xbuf;\n-     int len;\n      cpp_hashnode *hp;\n {\n-  cpp_buffer *mbuf;\n-  int advance_cur = 0;\n-\n-  /* The first chars of the expansion should be a \"\\r \" added by\n-     collect_expansion.  This is to prevent accidental token-pasting\n-     between the text preceding the macro invocation, and the macro\n-     expansion text.\n-\n-     We would like to avoid adding unneeded spaces (for the sake of\n-     tools that use cpp, such as imake).  In some common cases we can\n-     tell that it is safe to omit the space.  */\n-\n-  if (xbuf[0] == '\\r' && xbuf[1] == ' '\n-      && !unsafe_chars (pfile, EOF, xbuf[2]))\n-    advance_cur = 1;\n-\n-  /* Likewise, avoid the extra space at the end of the macro expansion\n-     if this is safe.  We can do a better job here since we can know\n-     what the next char will be.  */\n-  if (len >= 3 && xbuf[len-2] == '\\r' && xbuf[len-1] == ' '\n-      && !unsafe_chars (pfile, xbuf[len-3], CPP_BUF_PEEK (CPP_BUFFER (pfile))))\n-    len -= 2;\n-\n-  /* If the total expansion is \"\\r \\r \", we must not trim both escapes.  */\n-  if (len == 2 && advance_cur)\n-    advance_cur = 0;\n-\n-  mbuf = cpp_push_buffer (pfile, xbuf, len);\n-  if (mbuf == NULL)\n-    return;\n-  if (advance_cur)\n-    mbuf->cur += 2;\n-  mbuf->macro = hp;\n-  mbuf->has_escapes = 1;\n-\n-  /* In C89, a macro cannot be expanded recursively.  Traditional C\n-     permits it, but any use in an object-like macro must lead to\n-     infinite recursion, so always follow C89 in object-like macros.\n-     Likewise, in a function-like macro it must cause infinite\n-     recursion unless we are actually doing something with the\n-     arguments.\n-\n-     Even that criterion is too weak.  The only example known where\n-     macro recursion isn't infinite is:\n-\t#define bar(x,y) foo(x(y, 0))\n-\tbar(bar, baz)\n-     which expands to foo(bar(baz, 0)) in C89 and\n-     foo(foo(baz(0, 0)) in K+R.  This looks pathological to me.\n-     If someone has a real-world example I would love to see it.  */\n-  if (hp->type != T_FMACRO\n-      || hp->value.fdefn->nargs == 0\n-      || hp->value.fdefn->pattern == 0\n-      || !CPP_TRADITIONAL (pfile))\n-    hp->disabled = 1;\n-}\n+  cpp_toklist *list;\n \n-/* Return zero if two funct_defns are isomorphic.  */\n+  list = parse_define (pfile);\n+  if (!list)\n+    return 0;\n \n-static int\n-compare_defs (pfile, d1, d2)\n-     cpp_reader *pfile;\n-     const struct funct_defn *d1, *d2;\n-{\n-  const struct reflist *a1, *a2;\n-\n-  if (d1->nargs != d2->nargs)\n-    return 1;\n-  if (ustrcmp (d1->expansion, d2->expansion))\n-    return 1;\n-  if (CPP_PEDANTIC (pfile)\n-      && d1->argnames && d2->argnames)\n+  /* Check for a redefinition.  Redefinition of a macro is allowed if\n+     and only if the old and new definitions are the same.\n+     (6.10.3 paragraph 2). */\n+\n+  if (hp->type != T_VOID)\n     {\n-      U_CHAR *arg1 = d1->argnames;\n-      U_CHAR *arg2 = d2->argnames;\n-      size_t len;\n-      int i = d1->nargs;\n-      while (i--)\n+      if (!check_macro_redefinition (pfile, hp, list))\n \t{\n-\t  len = ustrlen (arg1) + 1;\n-\t  if (ustrcmp (arg1, arg2))\n-\t    return 1;\n-\t  arg1 += len;\n-\t  arg2 += len;\n+\t  cpp_pedwarn (pfile, \"\\\"%s\\\" redefined\", hp->name);\n+\t  if (pfile->done_initializing && hp->type == T_MACRO)\n+\t    cpp_pedwarn_with_file_and_line (pfile,\n+\t\t\t\t\t    hp->value.expansion->file,\n+\t\t\t\t\t    hp->value.expansion->line, 1,\n+\t\t\t    \"this is the location of the previous definition\");\n \t}\n+      _cpp_free_definition (hp);\n     }\n-  for (a1 = d1->pattern, a2 = d2->pattern; a1 && a2;\n-       a1 = a1->next, a2 = a2->next)\n-    {\n-      if (a1->nchars != a2->nchars\n-\t  || a1->argno != a2->argno\n-\t  || a1->stringify != a2->stringify\n-\t  || a1->raw_before != a2->raw_before\n-\t  || a1->raw_after != a2->raw_after)\n-\treturn 1;\n-    }\n-  if (a1 != a2)\n-    return 1;\n \n-  return 0;\n+  /* Enter definition in hash table.  */\n+  hp->type = T_MACRO;\n+  hp->value.expansion = list;\n+\n+  return 1;\n }\n \n /* Dump the definition of macro MACRO on stdout.  The format is suitable\n@@ -1846,97 +610,56 @@ _cpp_dump_definition (pfile, hp)\n   CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" - 1);\n   CPP_PUTS_Q (pfile, hp->name, hp->length);\n \n-  if (hp->type == T_EMPTY)\n-    /* do nothing */;\n-  else if (hp->type == T_FMACRO)\n-    dump_funlike_macro (pfile, hp->value.fdefn);\n-  else\n+  if (hp->type == T_MACRO)\n     {\n-      CPP_PUTC_Q (pfile, ' ');\n-\n-      if (hp->type == T_IDENTITY)\n-\tCPP_PUTS (pfile, hp->name, hp->length);\n-      else if (hp->type == T_MACRO)\n+      if (hp->value.expansion->paramc >= 0)\n+\tdump_funlike_macro (pfile, hp);\n+      else\n \t{\n-\t  /* The first and last two characters of a macro expansion are\n-\t     always \"\\r \"; this needs to be trimmed out.\n-\t     So we need length-4 chars of space, plus one for the NUL.  */\n-\t  CPP_RESERVE (pfile, hp->value.odefn->length - 4 + 1);\n-\t  CPP_PUTS_Q (pfile, hp->value.odefn->expansion + 2,\n-\t\t      hp->value.odefn->length - 4);\n+\t  const cpp_toklist *list = hp->value.expansion;\n+\t  list->tokens[0].flags &= ~BOL;\n+\t  list->tokens[0].flags |= PREV_WHITE;\n+\t  _cpp_dump_list (pfile, list, list->tokens, 1);\n \t}\n-      else\n-\tcpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n     }\n+  else\n+    cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n+\n   if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n     CPP_PUTC (pfile, '\\n');\n }\n \n static void\n-dump_funlike_macro (pfile, defn)\n+dump_funlike_macro (pfile, node)\n      cpp_reader *pfile;\n-     const struct funct_defn *defn;\n+     cpp_hashnode *node;\n {\n-  const struct reflist *r;\n-  const U_CHAR **argv = (const U_CHAR **) alloca (defn->nargs *\n-\t\t\t\t\t\t  sizeof(const U_CHAR *));\n-  int *argl = (int *) alloca (defn->nargs * sizeof(int));\n-  const U_CHAR *x;\n-  int i;\n-\n-  /* First extract the argument list. */\n-  x = defn->argnames;\n-  for (i = 0; i < defn->nargs; i++)\n-    {\n-      argv[i] = x;\n-      argl[i] = ustrlen (x);\n-      x += argl[i] + 1;\n-    }\n-      \n-  /* Now print out the argument list. */\n+  int i = 0;\n+  const cpp_toklist * list = node->value.expansion;\n+  const U_CHAR *param;\n+\n+  param = list->namebuf;\n   CPP_PUTC_Q (pfile, '(');\n-  for (i = 0; i < defn->nargs; i++)\n+  for (i = 0; i++ < list->paramc;)\n     {\n-      CPP_RESERVE (pfile, argl[i] + 2);\n-      if (!(i == defn->nargs-1 && defn->rest_args\n-\t    && !ustrcmp (argv[i], U\"__VA_ARGS__\")))\n-\tCPP_PUTS_Q (pfile, argv[i], argl[i]);\n-      if (i < defn->nargs-1)\n-\tCPP_PUTS_Q (pfile, \", \", 2);\n-    }\n-  if (defn->rest_args)\n-    CPP_PUTS (pfile, \"...\", 3);\n-  CPP_PUTS (pfile, \") \", 2);\n+      unsigned int len;\n \n-  /* Now the definition. */\n-  x = defn->expansion;\n-  for (r = defn->pattern; r; r = r->next)\n-    {\n-      i = r->nchars;\n-      if (*x == '\\r') x += 2, i -= 2;\n-      /* i chars for macro text, plus the length of the macro\n-\t argument name, plus one for a stringify marker, plus two for\n-\t each concatenation marker. */\n-      CPP_RESERVE (pfile,\n-\t\t   i + argl[r->argno] + r->stringify\n-\t\t   + (r->raw_before + r->raw_after) * 2);\n-\n-      if (i > 0) CPP_PUTS_Q (pfile, x, i);\n-      if (r->raw_before)\n-\tCPP_PUTS_Q (pfile, \"##\", 2);\n-      if (r->stringify)\n-\tCPP_PUTC_Q (pfile, '#');\n-      CPP_PUTS_Q (pfile, argv[r->argno], argl[r->argno]);\n-      if (r->raw_after && !(r->next && r->next->nchars == 0\n-\t\t\t    && r->next->raw_before))\n-\tCPP_PUTS_Q (pfile, \"##\", 2);\n-\n-      x += i;\n+      len = ustrlen (param);\n+      CPP_PUTS (pfile, param, len);\n+      if (i < list->paramc)\n+\tCPP_PUTS(pfile, \", \", 2);\n+      else if (list->flags & VAR_ARGS)\n+\t{\n+\t  if (!ustrcmp (param, var_args_str))\n+\t    pfile->limit -= sizeof (var_args_str) - 1;\n+\t  CPP_PUTS (pfile, \"...\", 3);\n+\t}\n+      param += len + 1;\n     }\n-\n-  i = defn->length - (x - defn->expansion) - 2;\n-  if (*x == '\\r') x += 2, i -= 2;\n-  if (i > 0) CPP_PUTS (pfile, x, i);\n+  CPP_PUTC (pfile, ')');\n+  list->tokens[0].flags &= ~BOL;\n+  list->tokens[0].flags |= PREV_WHITE;\n+  _cpp_dump_list (pfile, list, list->tokens, 1);\n }\n \n /* Dump out the hash table.  */\n@@ -1948,8 +671,7 @@ dump_hash_helper (h, p)\n   cpp_hashnode *hp = (cpp_hashnode *)*h;\n   cpp_reader *pfile = (cpp_reader *)p;\n \n-  if (hp->type == T_MACRO || hp->type == T_FMACRO\n-      || hp->type == T_IDENTITY || hp->type == T_EMPTY)\n+  if (hp->type == T_MACRO)\n     _cpp_dump_definition (pfile, hp);\n   return 1;\n }"}, {"sha": "f7c130b79d50c55fec7499a617556f802a43f04f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 85, "deletions": 77, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -25,11 +25,60 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n typedef unsigned char U_CHAR;\n #define U (const U_CHAR *)  /* Intended use: U\"string\" */\n \n-/* Structure used for assertion predicates.  */\n-struct predicate\n+/* Order here matters.  Those beyond SPELL_NONE store their spelling\n+   in the token list, and it's length in the token->val.name.len.  */\n+enum spell_type\n {\n-  struct predicate *next;\n-  struct cpp_toklist answer;\n+  SPELL_OPERATOR = 0,\n+  SPELL_CHAR,\n+  SPELL_NONE,\n+  SPELL_IDENT,\n+  SPELL_STRING\n+};\n+\n+struct token_spelling\n+{\n+  ENUM_BITFIELD(spell_type) type : CHAR_BIT;\n+  const U_CHAR *spelling;\n+};\n+\n+extern const struct token_spelling token_spellings[];\n+\n+/* Chained list of answers to an assertion.  */\n+struct answer\n+{\n+  struct answer *next;\n+  cpp_toklist list;\n+};\n+#define FREE_ANSWER(answer) do {_cpp_free_toklist (&answer->list); \\\n+\t\t\t\tfree (answer); } while (0)\n+\n+/* Values for the origin field of struct directive.  KANDR directives\n+   come from traditional (K&R) C.  STDC89 directives come from the\n+   1989 C standard.  EXTENSION directives are extensions.  */\n+#define KANDR\t\t0\n+#define STDC89\t\t1\n+#define EXTENSION\t2\n+\n+/* Values for the flags field of struct directive.  COND indicates a\n+   conditional.  EXPAND means that macros are to be expanded on the\n+   directive line.  INCL means to treat \"...\" and <...> as\n+   q-char-sequence and h-char-sequence respectively.  COMMENTS means\n+   preserve comments in the directive if -C.  */\n+#define COND\t\t(1 << 0)\n+#define EXPAND   \t(1 << 1)\n+#define INCL\t\t(1 << 2)\n+#define COMMENTS\t(1 << 3)\n+\n+/* Defines one #-directive, including how to handle it.  */\n+typedef int (*directive_handler) PARAMS ((cpp_reader *));\n+struct directive\n+{\n+  directive_handler handler;\t/* Function to handle directive.  */\n+  const U_CHAR *name;\t\t/* Name of directive.  */\n+  unsigned short length;\t/* Length of name.  */\n+  unsigned char origin;\t\t/* Origin of directive.  */\n+  unsigned char flags;\t        /* Flags describing this directive.  */\n };\n \n /* List of directories to look for include files in. */\n@@ -105,12 +154,6 @@ extern unsigned char _cpp_IStable[256];\n \n /* Macros.  */\n \n-/* One character lookahead in the input buffer.  Note that if this\n-   returns EOF, it does *not* necessarily mean the file's end has been\n-   reached.  */\n-#define CPP_BUF_PEEK(BUFFER) \\\n-  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur : EOF)\n-\n /* Make sure PFILE->token_buffer has space for at least N more characters. */\n #define CPP_RESERVE(PFILE, N) \\\n   (CPP_WRITTEN (PFILE) + (size_t)(N) > (PFILE)->token_buffer_size \\\n@@ -127,117 +170,82 @@ extern unsigned char _cpp_IStable[256];\n /* Append character CH to PFILE's output buffer.  Make space if need be. */\n #define CPP_PUTC(PFILE, CH) (CPP_RESERVE (PFILE, 1), CPP_PUTC_Q (PFILE, CH))\n \n-/* Advance the current line by one. */\n-#define CPP_BUMP_BUFFER_LINE(PBUF) ((PBUF)->lineno++,\\\n-\t\t\t\t    (PBUF)->line_base = (PBUF)->cur)\n-#define CPP_BUMP_LINE(PFILE) CPP_BUMP_BUFFER_LINE(CPP_BUFFER(PFILE))\n-#define CPP_BUMP_BUFFER_LINE_CUR(PBUF, CUR) ((PBUF)->lineno++,\\\n-\t\t\t\t             (PBUF)->line_base = CUR)\n-#define CPP_BUMP_LINE_CUR(PFILE, CUR) \\\n-                            CPP_BUMP_BUFFER_LINE_CUR(CPP_BUFFER(PFILE), CUR)\n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n-\n-/* Are we in column 1 right now?  Used mainly for -traditional handling\n-   of directives.  */\n-#define CPP_IN_COLUMN_1(PFILE) \\\n-(CPP_BUFFER (PFILE)->cur - CPP_BUFFER (PFILE)->line_base == 1)\n-\n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n #define CPP_TRADITIONAL(PFILE) CPP_OPTION (PFILE, traditional)\n-#define CPP_IN_SYSTEM_HEADER(PFILE) (cpp_file_buffer (PFILE)->inc->sysp)\n+#define CPP_IN_SYSTEM_HEADER(PFILE) (CPP_BUFFER (PFILE)->inc->sysp)\n #define CPP_PEDANTIC(PF) \\\n   (CPP_OPTION (PF, pedantic) && !CPP_IN_SYSTEM_HEADER (PF))\n #define CPP_WTRADITIONAL(PF) \\\n   (CPP_OPTION (PF, warn_traditional) && !CPP_IN_SYSTEM_HEADER (PF))\n \n-/* CPP_IS_MACRO_BUFFER is true if the buffer contains macro expansion.\n-   (Note that it is false while we're expanding macro *arguments*.) */\n-#define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->macro != NULL)\n-\n-/* Remember the current position of PFILE so it may be returned to\n-   after looking ahead a bit.\n-\n-   Note that when you set a mark, you _must_ return to that mark.  You\n-   may not forget about it and continue parsing.  You may not pop a\n-   buffer with an active mark.  You may not call CPP_BUMP_LINE while a\n-   mark is active.  */\n-#define CPP_SET_BUF_MARK(IP)   ((IP)->mark = (IP)->cur)\n-#define CPP_GOTO_BUF_MARK(IP)  ((IP)->cur = (IP)->mark,\t(IP)->mark = 0)\n-#define CPP_SET_MARK(PFILE)  CPP_SET_BUF_MARK(CPP_BUFFER(PFILE))\n-#define CPP_GOTO_MARK(PFILE) CPP_GOTO_BUF_MARK(CPP_BUFFER(PFILE))\n-\n-/* ACTIVE_MARK_P is true if there's a live mark in the buffer.  */\n-#define ACTIVE_MARK_P(PFILE) (CPP_BUFFER (PFILE)->mark != 0)\n-\n-/* Are mark and point adjacent characters?  Used mostly to deal with\n-   the somewhat annoying semantic of #define.  */\n-#define ADJACENT_TO_MARK(PFILE) \\\n- (CPP_BUFFER(PFILE)->cur - CPP_BUFFER(PFILE)->mark == 1)\n-\n /* Flags for _cpp_init_toklist.  */\n #define DUMMY_TOKEN     0\n #define NO_DUMMY_TOKEN\t1\n \n /* In cpphash.c */\n extern unsigned int _cpp_calc_hash\tPARAMS ((const U_CHAR *, size_t));\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n-extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_toklist *,\n-\t\t\t\t\t\t cpp_hashnode *));\n+extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n-extern void _cpp_quote_string\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n-extern void _cpp_macroexpand\t\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_init_macro_hash\tPARAMS ((cpp_reader *));\n extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n extern void _cpp_simplify_pathname\tPARAMS ((char *));\n-extern void _cpp_execute_include\tPARAMS ((cpp_reader *, U_CHAR *,\n+extern void _cpp_execute_include\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t\t unsigned int, int,\n-\t\t\t\t\t\t struct file_name_list *));\n-extern int _cpp_compare_file_date       PARAMS ((cpp_reader *, U_CHAR *,\n-                                                 unsigned int,\n-                                                 struct file_name_list *));\n+\t\t\t\t\t\t struct file_name_list *,\n+\t\t\t\t\t\t int));\n+extern int _cpp_compare_file_date       PARAMS ((cpp_reader *, const U_CHAR *,\n+                                                 unsigned int, int));\n extern void _cpp_init_include_table\tPARAMS ((cpp_reader *));\n extern const char *_cpp_fake_include\tPARAMS ((cpp_reader *, const char *));\n \n /* In cppexp.c */\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n \n /* In cpplex.c */\n-extern void _cpp_parse_name\t\tPARAMS ((cpp_reader *, int));\n extern void _cpp_skip_rest_of_line\tPARAMS ((cpp_reader *));\n-extern void _cpp_skip_hspace\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_expand_to_buffer\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char *, int));\n-extern int _cpp_parse_assertion\t\tPARAMS ((cpp_reader *));\n-extern enum cpp_ttype _cpp_lex_token\tPARAMS ((cpp_reader *));\n-extern ssize_t _cpp_prescan\t\tPARAMS ((cpp_reader *, cpp_buffer *,\n-\t\t\t\t\t\t ssize_t));\n+extern void _cpp_free_temp_tokens\tPARAMS ((cpp_reader *));\n extern void _cpp_init_input_buffer\tPARAMS ((cpp_reader *));\n extern void _cpp_grow_token_buffer\tPARAMS ((cpp_reader *, long));\n extern enum cpp_ttype _cpp_get_directive_token\n \t\t\t\t\tPARAMS ((cpp_reader *));\n-extern enum cpp_ttype _cpp_get_define_token\n-\t\t\t\t\tPARAMS ((cpp_reader *));\n-extern enum cpp_ttype _cpp_scan_until\tPARAMS ((cpp_reader *, cpp_toklist *,\n-\t\t\t\t\t\t enum cpp_ttype));\n extern void _cpp_init_toklist\t\tPARAMS ((cpp_toklist *, int));\n extern void _cpp_clear_toklist\t\tPARAMS ((cpp_toklist *));\n-extern void _cpp_free_toklist\t\tPARAMS ((cpp_toklist *));\n-extern void _cpp_slice_toklist\t\tPARAMS ((cpp_toklist *,\n-\t\t\t\t\t\t const cpp_token *,\n-\t\t\t\t\t\t const cpp_token *));\n-extern void _cpp_squeeze_toklist\tPARAMS ((cpp_toklist *));\n+extern void _cpp_free_toklist\t\tPARAMS ((const cpp_toklist *));\n extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const cpp_token *));\n extern int _cpp_equiv_toklists\t\tPARAMS ((const cpp_toklist *,\n \t\t\t\t\t\t const cpp_toklist *));\n extern void _cpp_expand_token_space\tPARAMS ((cpp_toklist *, unsigned int));\n+extern void _cpp_reserve_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n+extern void _cpp_expand_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n+extern void _cpp_dump_list\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const cpp_toklist *,\n+\t\t\t\t\t\t const cpp_token *, int));\n+extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n+\t\t\t\t\t\t const cpp_token *));\n+extern void _cpp_run_directive\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const struct directive *,\n+\t\t\t\t\t\t const char *, size_t));\n+extern unsigned int _cpp_get_line\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t unsigned int *));\n+extern const cpp_token *_cpp_get_raw_token PARAMS ((cpp_reader *));\n+extern void _cpp_push_token PARAMS ((cpp_reader *, const cpp_token*));\n+extern const cpp_token *_cpp_glue_header_name PARAMS ((cpp_reader *));\n \n /* In cpplib.c */\n-extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));\n+extern const struct directive *_cpp_check_directive\n+\t\t\tPARAMS ((cpp_reader *, const cpp_token *, int));\n+extern const struct directive *_cpp_check_linemarker\n+\t\t\tPARAMS ((cpp_reader *, const cpp_token *, int));\n extern void _cpp_unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n-extern void _cpp_check_directive        PARAMS ((cpp_toklist *, cpp_token *));\n+extern cpp_hashnode * _cpp_parse_assertion PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t    struct answer **));\n+extern struct answer** find_answer\tPARAMS ((cpp_hashnode *,\n+\t\t\t\t\t\t const cpp_toklist *));\n \n /* Utility routines and macros.  */\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))"}, {"sha": "f50bcc1f916b806733feb9792940150833f5bbd1", "filename": "gcc/cppinit.c", "status": "modified", "additions": 80, "deletions": 71, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -215,8 +215,6 @@ static void append_include_chain\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t char *, int, int));\n static void merge_include_chains\tPARAMS ((cpp_reader *));\n \n-static void dump_special_to_buffer\tPARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t\t size_t));\n static void initialize_dependency_output PARAMS ((cpp_reader *));\n static void initialize_standard_includes PARAMS ((cpp_reader *));\n static void new_pending_directive\t\tPARAMS ((struct cpp_pending *,\n@@ -345,7 +343,7 @@ append_include_chain (pfile, pend, dir, path, cxx_aware)\n       if (errno != ENOENT)\n \tcpp_notice_from_errno (pfile, dir);\n       else if (CPP_OPTION (pfile, verbose))\n-\tfprintf (stderr, _(\"ignoring nonexistent directory `%s'\\n\"), dir);\n+\tfprintf (stderr, _(\"ignoring nonexistent directory \\\"%s\\\"\\n\"), dir);\n       return;\n     }\n \n@@ -442,7 +440,7 @@ merge_include_chains (pfile)\n \t    && cur->dev == other->dev)\n           {\n \t    if (CPP_OPTION (pfile, verbose))\n-\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t      fprintf (stderr, _(\"ignoring duplicate directory \\\"%s\\\"\\n\"),\n \t\t       cur->name);\n \n \t    prev->next = cur->next;\n@@ -462,7 +460,7 @@ merge_include_chains (pfile)\n \t    && cur->dev == other->dev)\n           {\n \t    if (CPP_OPTION (pfile, verbose))\n-\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t      fprintf (stderr, _(\"ignoring duplicate directory \\\"%s\\\"\\n\"),\n \t\t       cur->name);\n \n \t    prev->next = cur->next;\n@@ -481,7 +479,7 @@ merge_include_chains (pfile)\n \t  if (quote == qtail)\n \t    {\n \t      if (CPP_OPTION (pfile, verbose))\n-\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\tfprintf (stderr, _(\"ignoring duplicate directory \\\"%s\\\"\\n\"),\n \t\t\t quote->name);\n \n \t      free (quote->name);\n@@ -495,7 +493,7 @@ merge_include_chains (pfile)\n \t\t  cur = cur->next;\n \t      cur->next = brack;\n \t      if (CPP_OPTION (pfile, verbose))\n-\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\tfprintf (stderr, _(\"ignoring duplicate directory \\\"%s\\\"\\n\"),\n \t\t\t qtail->name);\n \n \t      free (qtail->name);\n@@ -513,24 +511,6 @@ merge_include_chains (pfile)\n }\n \n \n-/* Write out a #define command for the special named MACRO_NAME\n-   to PFILE's token_buffer.  */\n-\n-static void\n-dump_special_to_buffer (pfile, macro_name, macro_len)\n-     cpp_reader *pfile;\n-     const U_CHAR *macro_name;\n-     size_t macro_len;\n-{\n-  static const char define_directive[] = \"#define \";\n-  CPP_RESERVE (pfile, sizeof(define_directive) + macro_len);\n-  CPP_PUTS_Q (pfile, define_directive, sizeof(define_directive)-1);\n-  CPP_PUTS_Q (pfile, macro_name, macro_len);\n-  CPP_PUTC_Q (pfile, ' ');\n-  _cpp_expand_to_buffer (pfile, macro_name, macro_len);\n-  CPP_PUTC (pfile, '\\n');\n-}\n-\n /* Initialize a cpp_reader structure. */\n void\n cpp_reader_init (pfile)\n@@ -545,6 +525,7 @@ cpp_reader_init (pfile)\n   CPP_OPTION (pfile, dollars_in_ident) = 1;\n   CPP_OPTION (pfile, cplusplus_comments) = 1;\n   CPP_OPTION (pfile, warn_import) = 1;\n+  CPP_OPTION (pfile, warn_paste) = 1;\n   CPP_OPTION (pfile, discard_comments) = 1;\n   CPP_OPTION (pfile, show_column) = 1;\n   CPP_OPTION (pfile, tabstop) = 8;\n@@ -596,44 +577,37 @@ cpp_cleanup (pfile)\n       pfile->token_buffer = NULL;\n     }\n \n-  if (pfile->input_buffer)\n-    {\n-      free (pfile->input_buffer);\n-      pfile->input_buffer = NULL;\n-      pfile->input_buffer_len = 0;\n-    }\n-\n   if (pfile->deps)\n     deps_free (pfile->deps);\n \n   htab_delete (pfile->hashtab);\n   splay_tree_delete (pfile->all_include_files);\n+  _cpp_free_temp_tokens (pfile);\n }\n \n \n /* This structure defines one built-in macro.  A node of type TYPE will\n    be entered in the macro hash table under the name NAME, with value\n-   VALUE (if any).  FLAGS tweaks the behavior a little:\n-   DUMP\t\twrite debug info for this macro\n+   VALUE (if any).  Two values are not compile time constants, so we tag\n+   them in the FLAGS field instead:\n    VERS\t\tvalue is the global version_string, quoted\n    ULP\t\tvalue is the global user_label_prefix\n  */\n \n struct builtin\n {\n   const U_CHAR *name;\n-  const U_CHAR *value;\n+  const char *value;\n   unsigned short type;\n   unsigned short flags;\n   unsigned int len;\n };\n-#define DUMP 0x01\n-#define VERS 0x02\n-#define ULP  0x04\n+#define VERS 0x01\n+#define ULP  0x02\n \n-#define B(n, t)       { U n,   0, t,       0,      sizeof n - 1 }\n-#define C(n, v)       { U n, U v, T_CONST, DUMP,   sizeof n - 1 }\n-#define X(n, v, t, f) { U n, U v, t,       DUMP|f, sizeof n - 1 }\n+#define B(n, t)       { U n, 0, t,       0, sizeof n - 1 }\n+#define C(n, v)       { U n, v, T_MACRO, 0, sizeof n - 1 }\n+#define X(n, f)       { U n, 0, T_MACRO, f, sizeof n - 1 }\n static const struct builtin builtin_array[] =\n {\n   B(\"__TIME__\",\t\t T_TIME),\n@@ -642,10 +616,10 @@ static const struct builtin builtin_array[] =\n   B(\"__BASE_FILE__\",\t T_BASE_FILE),\n   B(\"__LINE__\",\t\t T_SPECLINE),\n   B(\"__INCLUDE_LEVEL__\", T_INCLUDE_LEVEL),\n+  B(\"__STDC__\",\t\t T_STDC),\n \n-  X(\"__VERSION__\",\t\t0,   T_XCONST, VERS),\n-  X(\"__USER_LABEL_PREFIX__\",\t0,   T_CONST,  ULP),\n-  X(\"__STDC__\",\t\t\t\"1\", T_STDC,   0),\n+  X(\"__VERSION__\",\t\tVERS),\n+  X(\"__USER_LABEL_PREFIX__\",\tULP),\n   C(\"__REGISTER_PREFIX__\",\tREGISTER_PREFIX),\n   C(\"__HAVE_BUILTIN_SETJMP__\",\t\"1\"),\n #ifndef NO_BUILTIN_SIZE_TYPE\n@@ -671,35 +645,47 @@ initialize_builtins (pfile)\n      cpp_reader *pfile;\n {\n   const struct builtin *b;\n-  const U_CHAR *val;\n-  cpp_hashnode *hp;\n   for(b = builtin_array; b < builtin_array_end; b++)\n     {\n-      if (b->type == T_STDC && CPP_TRADITIONAL (pfile))\n-\tcontinue;\n-\n-      if (b->flags & ULP)\n-\tval = (const U_CHAR *) user_label_prefix;\n-      else if (b->flags & VERS)\n+      if (b->type == T_MACRO)\n \t{\n-\t  val = (const U_CHAR *) xmalloc (strlen (version_string) + 3);\n-\t  sprintf ((char *)val, \"\\\"%s\\\"\", version_string);\n+\t  const char *val;\n+\t  char *str;\n+\n+\t  if (b->flags & VERS)\n+\t    {\n+\t      /* Allocate enough space for 'name=\"value\"\\0'.  */\n+\t      str = xmalloc (b->len + strlen (version_string) + 4);\n+\t      sprintf (str, \"%s=\\\"%s\\\"\", b->name, version_string);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (b->flags & ULP)\n+\t\tval = user_label_prefix;\n+\t      else\n+\t\tval = b->value;\n+\n+\t      /* Allocate enough space for \"name=value\\0\".  */\n+\t      str = xmalloc (b->len + strlen (val) + 2);\n+\t      sprintf(str, \"%s=%s\", b->name, val);\n+\t    }\n+\t  cpp_define (pfile, str);\n \t}\n       else\n-\tval = b->value;\n-\n-      hp = cpp_lookup (pfile, b->name, b->len);\n-      hp->value.cpval = val;\n-      hp->type = b->type;\n+\t{\n+\t  cpp_hashnode *hp;\n+\t  \n+\t  if (b->type == T_STDC && CPP_TRADITIONAL (pfile))\n+\t    continue;\n \n-      if ((b->flags & DUMP) && CPP_OPTION (pfile, debug_output))\n-\tdump_special_to_buffer (pfile, b->name, b->len);\n+\t  hp = cpp_lookup (pfile, b->name, b->len);\n+\t  hp->type = b->type;\n+\t}\n     }\n }\n-#undef DUMP\n-#undef STDC\n #undef VERS\n #undef ULP\n+#undef builtin_array_end\n \n /* Another subroutine of cpp_start_read.  This one sets up to do\n    dependency-file output. */\n@@ -889,6 +875,13 @@ cpp_start_read (pfile, print, fname)\n   if (CPP_OPTION (pfile, cplusplus))\n     CPP_OPTION (pfile, warn_traditional) = 0;\n \n+  /* Do not warn about illegal token pasting if -traditional,\n+     -lang-fortran, or -lang-asm.  */\n+  if (CPP_OPTION (pfile, traditional)\n+      || CPP_OPTION (pfile, lang_fortran)\n+      || CPP_OPTION (pfile, lang_asm))\n+    CPP_OPTION (pfile, warn_paste) = 0;\n+\n   /* Set this if it hasn't been set already. */\n   if (user_label_prefix == NULL)\n     user_label_prefix = USER_LABEL_PREFIX;\n@@ -898,6 +891,16 @@ cpp_start_read (pfile, print, fname)\n   if (CPP_OPTION (pfile, preprocessed))\n     pfile->no_macro_expand++;\n \n+  /* Figure out if we need to save function macro parameter spellings.\n+     We don't use CPP_PEDANTIC() here because that depends on whether\n+     or not the current file is a system header, and there is no\n+     current file yet.  */\n+  pfile->save_parameter_spellings =\n+    CPP_OPTION (pfile, pedantic)\n+    || CPP_OPTION (pfile, debug_output)\n+    || CPP_OPTION (pfile, dump_macros) == dump_definitions\n+    || CPP_OPTION (pfile, dump_macros) == dump_only;\n+\n   /* Set up the IStable.  This doesn't do anything if we were compiled\n      with a compiler that supports C99 designated initializers.  */\n   init_IStable ();\n@@ -946,13 +949,12 @@ cpp_start_read (pfile, print, fname)\n      as line 0.  */\n \n   CPP_BUFFER (pfile)->lineno = 0;\n-\n   if (print)\n     {\n-      print->lineno = 0;\n       print->last_fname = CPP_BUFFER (pfile)->nominal_fname;\n       print->last_id = pfile->include_depth;\n       print->written = CPP_WRITTEN (pfile);\n+      print->lineno = 0;\n     }\n \n   /* Install __LINE__, etc.  */\n@@ -968,10 +970,13 @@ cpp_start_read (pfile, print, fname)\n       p = q;\n     }\n   pfile->done_initializing = 1;\n-  pfile->only_seen_white = 2;\n+\n+  /* Now flush any output recorded during initialization, and advance\n+     to line 1 of the main input file.  */\n   CPP_BUFFER (pfile)->lineno = 1;\n+\n   if (print && ! CPP_OPTION (pfile, no_output))\n-    cpp_output_tokens (pfile, print);\n+    cpp_output_tokens (pfile, print, 1);\n \n   /* The -imacros files can be scanned now, but the -include files\n      have to be pushed onto the include stack and processed later,\n@@ -992,7 +997,7 @@ cpp_start_read (pfile, print, fname)\n     {\n       if (cpp_read_file (pfile, p->arg)\n \t  && print && ! CPP_OPTION (pfile, no_output))\n-\tcpp_output_tokens (pfile, print);\n+\tcpp_output_tokens (pfile, print, 1);  /* record entry to file */\n       q = p->next;\n       free (p);\n       p = q;\n@@ -1073,7 +1078,7 @@ cpp_finish (pfile, print)\n   /* Flush any pending output.  */\n   if (print)\n     {\n-      cpp_output_tokens (pfile, print);\n+      cpp_output_tokens (pfile, print, print->lineno);\n       if (ferror (print->outf) || fclose (print->outf))\n \tcpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n     }\n@@ -1753,6 +1758,8 @@ handle_option (pfile, argc, argv)\n \t    CPP_OPTION (pfile, warn_undef) = 1;\n \t  else if (!strcmp (argv[i], \"-Wimport\"))\n \t    CPP_OPTION (pfile, warn_import) = 1;\n+\t  else if (!strcmp (argv[i], \"-Wpaste\"))\n+\t    CPP_OPTION (pfile, warn_paste) = 1;\n \t  else if (!strcmp (argv[i], \"-Werror\"))\n \t    CPP_OPTION (pfile, warnings_are_errors) = 1;\n \t  else if (!strcmp (argv[i], \"-Wno-traditional\"))\n@@ -1767,6 +1774,8 @@ handle_option (pfile, argc, argv)\n \t    CPP_OPTION (pfile, warn_undef) = 0;\n \t  else if (!strcmp (argv[i], \"-Wno-import\"))\n \t    CPP_OPTION (pfile, warn_import) = 0;\n+\t  else if (!strcmp (argv[i], \"-Wno-paste\"))\n+\t    CPP_OPTION (pfile, warn_paste) = 0;\n \t  else if (!strcmp (argv[i], \"-Wno-error\"))\n \t    CPP_OPTION (pfile, warnings_are_errors) = 0;\n \t  break;\n@@ -1836,10 +1845,10 @@ Switches:\\n\\\n                              (dirs specified with -isystem will still be used)\\n\\\n   -nostdinc++               Do not search system include directories for C++\\n\\\n   -o <file>                 Put output into <file>\\n\\\n-  -pedantic                 Issue all warnings demanded by strict ANSI C\\n\\\n+  -pedantic                 Issue all warnings demanded by strict ISO C\\n\\\n   -pedantic-errors          Issue -pedantic warnings as errors instead\\n\\\n   -traditional              Follow K&R pre-processor behaviour\\n\\\n-  -trigraphs                Support ANSI C trigraphs\\n\\\n+  -trigraphs                Support ISO C trigraphs\\n\\\n   -lang-c                   Assume that the input sources are in C\\n\\\n   -lang-c89                 Assume that the input sources are in C89\\n\\\n   -lang-c++                 Assume that the input sources are in C++\\n\\"}, {"sha": "a45336d1158db26806ef2a0ee1b60bdf598b8764", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2616, "deletions": 2601, "changes": 5217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea"}, {"sha": "9e8c4c7318d208c5f6036672d41dc09629a334a2", "filename": "gcc/cpplib.c", "status": "modified", "additions": 677, "deletions": 884, "changes": 1561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -27,54 +27,41 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"symcat.h\"\n \n-/* `struct directive' defines one #-directive, including how to handle it.  */\n-\n-struct directive\n-{\n-  directive_handler func;\t/* Function to handle directive.  */\n-  const U_CHAR *name;\t\t/* Name of directive.  */\n-  unsigned short length;\t/* Length of name.  */\n-  unsigned short flags;\t        /* Flags describing this directive.  */\n-};\n-\n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n \n struct if_stack\n {\n   struct if_stack *next;\n-  int lineno;\t\t\t/* line number where condition started */\n+  unsigned int lineno;\t\t/* line number where condition started */\n+  unsigned int colno;\t\t/* and column */\n   int was_skipping;\t\t/* value of pfile->skipping before this if */\n   const cpp_hashnode *cmacro;\t/* macro name for #ifndef around entire file */\n   int type;\t\t\t/* type of last directive seen in this group */\n };\n \n /* Forward declarations.  */\n \n-static void validate_else\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static unsigned int parse_include\tPARAMS ((cpp_reader *, const U_CHAR *, int));\n-static void push_conditional\t\tPARAMS ((cpp_reader *, int, int,\n-\t\t\t\t\t\t const cpp_hashnode *));\n-static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n-\t\t\t\t\t\t cpp_reader *, int));\n-static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n-static const cpp_hashnode *parse_ifdef\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static const cpp_hashnode *detect_if_not_defined PARAMS ((cpp_reader *));\n-\n-/* Values for the flags field of the table below.  KANDR and COND\n-   directives come from traditional (K&R) C.  The difference is, if we\n-   care about it while skipping a failed conditional block, its origin\n-   is COND.  STDC89 directives come from the 1989 C standard.\n-   EXTENSION directives are extensions, with origins noted below.  */\n+static void validate_else\tPARAMS ((cpp_reader *, const U_CHAR *));\n+static int parse_include\tPARAMS ((cpp_reader *, const U_CHAR *, int,\n+\t\t\t\t\t const U_CHAR **, unsigned int *,\n+\t\t\t\t\t int *));\n+static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n+\t\t\t\t\t const cpp_hashnode *));\n+static void pass_thru_directive\tPARAMS ((cpp_reader *));\n+static int read_line_number\tPARAMS ((cpp_reader *, int *));\n+static int strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n+\t\t\t\t\t unsigned long *));\n \n-#define KANDR       0\n-#define COND        1\n-#define STDC89      2\n-#define EXTENSION   3\n+static const cpp_hashnode *parse_ifdef\tPARAMS ((cpp_reader *, const U_CHAR *));\n+static const cpp_hashnode *detect_if_not_defined\n+\t\t\t\t\tPARAMS ((cpp_reader *));\n+static cpp_hashnode *get_define_node\tPARAMS ((cpp_reader *));\n+static void dump_macro_name PARAMS ((cpp_reader *, cpp_hashnode *));\n \n-#define ORIGIN_MASK 3\n-#define ORIGIN(f) ((f) & ORIGIN_MASK)\n-#define TRAD_DIRECT_P(f) (ORIGIN (f) == KANDR || ORIGIN (f) == COND)\n+/* Utility.  */\n+#define str_match(sym, len, str) \\\n+((len) == (sizeof (str) - 1) && !ustrncmp ((sym), U(str), sizeof (str) - 1))\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n@@ -88,31 +75,31 @@ static const cpp_hashnode *detect_if_not_defined PARAMS ((cpp_reader *));\n \n /* #sccs is not always recognized.  */\n #ifdef SCCS_DIRECTIVE\n-# define SCCS_ENTRY D(sccs, T_SCCS, EXTENSION)\t\t/*     0 - SVR2? */\n+# define SCCS_ENTRY D(sccs, T_SCCS, EXTENSION, 0)\n #else\n # define SCCS_ENTRY /* nothing */\n #endif\n \n-#define DIRECTIVE_TABLE\t\t\t\t\t\t\t \\\n-D(define,\tT_DEFINE = 0,\tKANDR)\t\t           /* 270554 */ \\\n-D(include,\tT_INCLUDE,\tKANDR | SYNTAX_INCLUDE)    /*  52262 */ \\\n-D(endif,\tT_ENDIF,\tCOND)\t\t           /*  45855 */ \\\n-D(ifdef,\tT_IFDEF,\tCOND)\t\t\t   /*  22000 */ \\\n-D(if,\t\tT_IF,\t\tCOND)\t\t\t   /*  18162 */ \\\n-D(else,\t\tT_ELSE,\t\tCOND)\t\t\t    /*  9863 */ \\\n-D(ifndef,\tT_IFNDEF,\tCOND)\t\t\t    /*  9675 */ \\\n-D(undef,\tT_UNDEF,\tKANDR)\t\t\t    /*  4837 */ \\\n-D(line,\t\tT_LINE,\t\tKANDR)\t\t\t    /*  2465 */ \\\n-D(elif,\t\tT_ELIF,\t\tCOND)\t\t\t    /*   610 */ \\\n-D(error,\tT_ERROR,\tSTDC89)\t\t\t    /*   475 */ \\\n-D(pragma,\tT_PRAGMA,\tSTDC89)\t\t\t    /*   195 */ \\\n-D(warning,\tT_WARNING,\tEXTENSION)\t\t    /*    22 GNU */ \\\n-D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION | SYNTAX_INCLUDE) /*    19 GNU */ \\\n-D(ident,\tT_IDENT,\tEXTENSION)\t\t    /*    11 SVR4 */ \\\n-D(import,\tT_IMPORT,\tEXTENSION | SYNTAX_INCLUDE) /*     0 ObjC */ \\\n-D(assert,\tT_ASSERT,\tEXTENSION)  \t\t    /*     0 SVR4 */ \\\n-D(unassert,\tT_UNASSERT,\tEXTENSION)  \t\t    /*     0 SVR4 */ \\\n-SCCS_ENTRY\n+#define DIRECTIVE_TABLE\t\t\t\t\t\t\t\\\n+D(define,\tT_DEFINE = 0,\tKANDR,     COMMENTS)\t   /* 270554 */ \\\n+D(include,\tT_INCLUDE,\tKANDR,     EXPAND | INCL)  /*  52262 */ \\\n+D(endif,\tT_ENDIF,\tKANDR,     COND)\t   /*  45855 */ \\\n+D(ifdef,\tT_IFDEF,\tKANDR,     COND)\t   /*  22000 */ \\\n+D(if,\t\tT_IF,\t\tKANDR,     COND | EXPAND)  /*  18162 */ \\\n+D(else,\t\tT_ELSE,\t\tKANDR,     COND)\t   /*   9863 */ \\\n+D(ifndef,\tT_IFNDEF,\tKANDR,     COND)\t   /*   9675 */ \\\n+D(undef,\tT_UNDEF,\tKANDR,     0)\t\t   /*   4837 */ \\\n+D(line,\t\tT_LINE,\t\tKANDR,     EXPAND)    \t   /*   2465 */ \\\n+D(elif,\t\tT_ELIF,\t\tKANDR,     COND | EXPAND)  /*    610 */ \\\n+D(error,\tT_ERROR,\tSTDC89,    0)\t\t   /*    475 */ \\\n+D(pragma,\tT_PRAGMA,\tSTDC89,    0)\t\t   /*    195 */ \\\n+D(warning,\tT_WARNING,\tEXTENSION, 0)\t\t   /*     22 GNU   */ \\\n+D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION, EXPAND | INCL)  /*     19 GNU   */ \\\n+D(ident,\tT_IDENT,\tEXTENSION, 0)\t\t   /*     11 SVR4  */ \\\n+D(import,\tT_IMPORT,\tEXTENSION, EXPAND | INCL)  /*      0 ObjC  */ \\\n+D(assert,\tT_ASSERT,\tEXTENSION, 0)  \t\t   /*      0 SVR4  */ \\\n+D(unassert,\tT_UNASSERT,\tEXTENSION, 0)  \t\t   /*      0 SVR4  */ \\\n+SCCS_ENTRY\t\t\t\t\t\t   /*      0 SVR2? */\n \n /* Use the table to generate a series of prototypes, an enum for the\n    directive names, and an array of directive handlers.  */\n@@ -122,11 +109,11 @@ SCCS_ENTRY\n    pointers to functions returning void.  */\n \n /* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n-#define D(name, t, f) static int CONCAT2(do_,name) PARAMS ((cpp_reader *));\n+#define D(name, t, o, f) static int CONCAT2(do_,name) PARAMS ((cpp_reader *));\n DIRECTIVE_TABLE\n #undef D\n \n-#define D(n, tag, f) tag,\n+#define D(n, tag, o, f) tag,\n enum\n {\n   DIRECTIVE_TABLE\n@@ -135,9 +122,9 @@ enum\n #undef D\n \n /* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n-#define D(name, t, flags) \\\n+#define D(name, t, origin, flags) \\\n { CONCAT2(do_,name), (const U_CHAR *) STRINGX(name), \\\n-  sizeof STRINGX(name) - 1, flags },\n+  sizeof STRINGX(name) - 1, origin, flags },\n static const struct directive dtable[] =\n {\n DIRECTIVE_TABLE\n@@ -147,312 +134,253 @@ DIRECTIVE_TABLE\n \n /* Check if a token's name matches that of a known directive.  Put in\n    this file to save exporting dtable and other unneeded information.  */\n-void\n-_cpp_check_directive (list, token)\n-     cpp_toklist *list;\n-     cpp_token *token;\n+const struct directive *\n+_cpp_check_directive (pfile, token, bol)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+     int bol;\n {\n   const U_CHAR *name = token->val.name.text;\n   size_t len = token->val.name.len;\n   unsigned int i;\n \n-  list->dirno = -1;\n-  list->flags &= ~SYNTAX_INCLUDE;\n+  /* If we are rescanning preprocessed input, don't obey any directives\n+     other than # nnn.  */\n+  if (CPP_OPTION (pfile, preprocessed))\n+    return 0;\n \n   for (i = 0; i < N_DIRECTIVES; i++)\n-    if (dtable[i].length == len && !ustrncmp (dtable[i].name, name, len)) \n+    if (dtable[i].length == len && !memcmp (dtable[i].name, name, len))\n       {\n-\tlist->dirno = i;\n-\tif (dtable[i].flags & SYNTAX_INCLUDE)\n-\t  list->flags |= SYNTAX_INCLUDE;\n-\tbreak;\n+\t/* If we are skipping a failed conditional group, all non-conditional\n+\t   directives are ignored.  */\n+\tif (pfile->skipping && !(dtable[i].flags & COND))\n+\t  return 0;\n+\n+\t/* In -traditional mode, a directive is ignored unless its #\n+\t   is in column 1.  */\n+\tif (!bol && dtable[i].origin == KANDR && CPP_WTRADITIONAL (pfile))\n+\t  cpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n+\t\t       dtable[i].name);\n+\t      \n+\tif (!bol && CPP_TRADITIONAL (pfile))\n+\t  return 0;\n+\n+\t/* Issue -pedantic warnings for extended directives.   */\n+\tif (CPP_PEDANTIC (pfile) && dtable[i].origin == EXTENSION)\n+\t  cpp_pedwarn (pfile, \"ISO C does not allow #%s\", dtable[i].name);\n+\n+\t/* -Wtraditional gives warnings about directives with inappropriate\n+\t   indentation of #.  */\n+\tif (bol && dtable[i].origin != KANDR && CPP_WTRADITIONAL (pfile))\n+\t  cpp_warning (pfile,\n+\t\t    \"suggest hiding #%s from traditional C with an indented #\",\n+\t\t       dtable[i].name);\n+\n+\treturn &dtable[i];\n       }\n-}\n \n-/* Handle a possible # directive.\n-   '#' has already been read.  */\n+  return 0;\n+}\n \n-int\n-_cpp_handle_directive (pfile)\n+const struct directive *\n+_cpp_check_linemarker (pfile, token, bol)\n      cpp_reader *pfile;\n+     const cpp_token *token ATTRIBUTE_UNUSED;\n+     int bol;\n {\n-  int i;\n-  int hash_at_bol;\n-  unsigned int len;\n-  U_CHAR *ident;\n-  long old_written = CPP_WRITTEN (pfile);\n-  enum cpp_ttype tok;\n-\n-  if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-    {\n-      cpp_ice (pfile, \"handle_directive called on macro buffer\");\n-      return 0;\n-    }\n-\n-  /* -traditional directives are recognized only with the # in column 1.  */\n-  hash_at_bol = CPP_IN_COLUMN_1 (pfile);\n-\n-  /* Scan the next token, then pretend we didn't.  */\n-  CPP_SET_MARK (pfile);\n-  pfile->no_macro_expand++;\n-  tok = _cpp_get_directive_token (pfile);\n-  pfile->no_macro_expand--;\n-\n-  ident = pfile->token_buffer + old_written;\n-  len = CPP_PWRITTEN (pfile) - ident;\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  CPP_GOTO_MARK (pfile);\n-\n   /* # followed by a number is equivalent to #line.  Do not recognize\n      this form in assembly language source files or skipped\n      conditional groups.  Complain about this form if we're being\n      pedantic, but not if this is regurgitated input (preprocessed or\n      fed back in by the C++ frontend).  */\n-  if (tok == CPP_NUMBER)\n-    {\n-      if (pfile->skipping || CPP_OPTION (pfile, lang_asm))\n-\treturn 0;\n-\n-      if (CPP_PEDANTIC (pfile)\n-\t  && CPP_BUFFER (pfile)->inc\n-\t  && ! CPP_OPTION (pfile, preprocessed))\n-\tcpp_pedwarn (pfile, \"# followed by integer\");\n-      i = T_LINE;\n-      goto process_directive;\n-    }\n+  if (pfile->skipping || CPP_OPTION (pfile, lang_asm))\n+    return 0;\n \n-  /* If we are rescanning preprocessed input, don't obey any directives\n-     other than # nnn.  */\n-  else if (CPP_OPTION (pfile, preprocessed))\n+  if (CPP_PEDANTIC (pfile) && CPP_BUFFER (pfile)->inc\n+      && ! CPP_OPTION (pfile, preprocessed))\n+    cpp_pedwarn (pfile, \"# followed by integer\");\n+\n+  /* In -traditional mode, a directive is ignored unless its #\n+     is in column 1.  */\n+  if (!bol && CPP_WTRADITIONAL (pfile))\n+    cpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n+\t\t dtable[T_LINE].name);\n+\t      \n+  if (!bol && CPP_TRADITIONAL (pfile))\n     return 0;\n+  \n+  return &dtable[T_LINE];\n+}  \n \n-  /* A line of just # becomes blank.  */\n-  else if (tok == CPP_VSPACE)\n-    return 1;\n+static void\n+dump_macro_name (pfile, node)\n+     cpp_reader *pfile;\n+     cpp_hashnode *node;\n+{\n+  CPP_PUTS (pfile, \"#define \", sizeof \"#define \" - 1);\n+  CPP_PUTS (pfile, node->name, node->length);\n+}\n \n-  /* A NAME token might in fact be a directive!  */\n-  else if (tok == CPP_NAME)\n-    {\n-      for (i = 0; i < N_DIRECTIVES; i++)\n-\t{\n-\t  if (dtable[i].length == len\n-\t      && !ustrncmp (dtable[i].name, ident, len)) \n-\t    goto real_directive;\n-\t}\n-      /* Don't complain about invalid directives in assembly source,\n-\t we don't know where the comments are, and # may introduce\n-\t assembler pseudo-ops.  Don't complain about invalid directives\n-\t in skipped conditional groups (6.10 p4). */\n-      if (!pfile->skipping && !CPP_OPTION (pfile, lang_asm))\n-\tcpp_error (pfile, \"invalid preprocessing directive #%.*s\",\n-\t\t   (int) len, ident);\n-      return 0;\n-    }\n-  /* And anything else means the # wasn't a directive marker.   */\n-  else\n-    return 0;\n+/* Pass the current directive through to the output file.  */\n+static void\n+pass_thru_directive (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* XXX This output may be genuinely needed even when there is no\n+     printer.  */\n+  if (! pfile->printer)\n+    return;\n+  /* Flush first (temporary).  */\n+  cpp_output_tokens (pfile, pfile->printer, pfile->token_list.line);\n+  _cpp_dump_list (pfile, &pfile->token_list, pfile->first_directive_token, 1);\n+}\n \n- real_directive:\n+static cpp_hashnode *\n+get_define_node (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_hashnode *node;\n+  const cpp_token *token;\n+  const U_CHAR *sym;\n+  unsigned int len;\n \n-  /* If we are skipping a failed conditional group, all non-conditional\n-     directives are ignored.  */\n-  if (pfile->skipping && ORIGIN (dtable[i].flags) != COND)\n-    return 0;\n+  /* Skip any -C comments.  */\n+  while ((token = cpp_get_token (pfile))->type == CPP_COMMENT)\n+    ;\n \n-  /* In -traditional mode, a directive is ignored unless its # is in\n-     column 1.  */\n-  if (CPP_TRADITIONAL (pfile) && !hash_at_bol)\n+  if (token->type != CPP_NAME)\n     {\n-      if (CPP_WTRADITIONAL (pfile))\n-\tcpp_warning (pfile, \"ignoring #%s because of its indented #\",\n-\t\t     dtable[i].name);\n+      cpp_error_with_line (pfile, pfile->token_list.line, token->col,\n+\t\t\t   \"macro names must be identifiers\");\n       return 0;\n     }\n \n-  /* no_directives is set when we are parsing macro arguments.  Directives\n-     in macro arguments are undefined behavior (C99 6.10.3.11); this\n-     implementation chooses to make them hard errors.  */\n-  if (pfile->no_directives)\n+  /* That identifier is not allowed to be \"defined\".  See predefined\n+     macro names (6.10.8.4).  */\n+  len = token->val.name.len;\n+  sym = token->val.name.text;\n+  if (str_match (sym, len, \"defined\"))\n     {\n-      cpp_error (pfile, \"#%s may not be used inside a macro argument\",\n-\t\t dtable[i].name);\n-      _cpp_skip_rest_of_line (pfile);\n-      return 1;\n+      cpp_error_with_line (pfile, pfile->token_list.line, token->col,\n+\t\t\t   \"\\\"defined\\\" is not a legal macro name\");\n+      return 0;\n     }\n \n-  /* Issue -pedantic warnings for extended directives.   */\n-  if (CPP_PEDANTIC (pfile) && ORIGIN (dtable[i].flags) == EXTENSION)\n-    cpp_pedwarn (pfile, \"ISO C does not allow #%s\", dtable[i].name);\n-\n-  /* -Wtraditional gives warnings about directives with inappropriate\n-     indentation of #.  */\n-  if (CPP_WTRADITIONAL (pfile))\n+  node = cpp_lookup (pfile, sym, len);\n+  /* Check for poisoned identifiers now.  */\n+  if (node->type == T_POISON)\n     {\n-      if (!hash_at_bol && TRAD_DIRECT_P (dtable[i].flags))\n-\tcpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n-\t\t     dtable[i].name);\n-      else if (hash_at_bol && ! TRAD_DIRECT_P (dtable[i].flags))\n-\tcpp_warning (pfile,\n-\t\t\"suggest hiding #%s from traditional C with an indented #\",\n-\t\t     dtable[i].name);\n+      cpp_error (pfile, \"attempt to use poisoned \\\"%.*s\\\"\", (int) len, sym);\n+      return 0;\n     }\n \n-  /* Unfortunately, it's necessary to scan the directive name again,\n-     now we know we're going to consume it.  FIXME.  */\n-\n-  pfile->no_macro_expand++;\n-  _cpp_get_directive_token (pfile);\n-  pfile->no_macro_expand--;\n-  CPP_SET_WRITTEN (pfile, old_written);\n-\n- process_directive:\n-  (void) (*dtable[i].func) (pfile);\n-  return 1;\n-}\n-\n-/* Pass a directive through to the output file.\n-   BUF points to the contents of the directive, as a contiguous string.\n-   LEN is the length of the string pointed to by BUF.\n-   KEYWORD is the keyword-table entry for the directive.  */\n-\n-static void\n-pass_thru_directive (buf, len, pfile, keyword)\n-     const U_CHAR *buf;\n-     size_t len;\n-     cpp_reader *pfile;\n-     int keyword;\n-{\n-  const struct directive *kt = &dtable[keyword];\n-  register unsigned klen = kt->length;\n-\n-  CPP_RESERVE (pfile, 1 + klen + len);\n-  CPP_PUTC_Q (pfile, '#');\n-  CPP_PUTS_Q (pfile, kt->name, klen);\n-  if (len != 0 && buf[0] != ' ')\n-    CPP_PUTC_Q (pfile, ' ');\n-  CPP_PUTS_Q (pfile, buf, len);\n+  return node;\n }\n \n /* Process a #define command.  */\n-\n static int\n do_define (pfile)\n      cpp_reader *pfile;\n {\n   cpp_hashnode *node;\n-  int len;\n-  const U_CHAR *sym;\n-  cpp_toklist *list = &pfile->directbuf;\n \n-  pfile->no_macro_expand++;\n-  CPP_OPTION (pfile, discard_comments)++;\n+  if ((node = get_define_node (pfile)))\n+    if (_cpp_create_definition (pfile, node))\n+      {\n+\tif (CPP_OPTION (pfile, debug_output)\n+\t    || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n+\t  _cpp_dump_definition (pfile, node);\n+\telse if (CPP_OPTION (pfile, dump_macros) == dump_names)\n+\t  dump_macro_name (pfile, node);\n+      }\n+  return 0;\n+}\n+\n+/* Remove the definition of a symbol from the symbol table.  */\n+static int\n+do_undef (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_hashnode *node = get_define_node (pfile);  \n \n-  _cpp_scan_until (pfile, list, CPP_VSPACE);\n+  if (cpp_get_token (pfile)->type != CPP_EOF)\n+    cpp_pedwarn (pfile, \"junk on line after #undef\");\n \n-  /* First token on the line must be a NAME.  There may not be any\n-     tokens in the list (if we had #define all by itself on a line).  */\n-  if (list->tokens_used == 0\n-      || TOK_TYPE (list, 0) != CPP_NAME)\n+  /* 6.10.3.5 paragraph 2: [#undef] is ignored if the specified identifier\n+     is not currently defined as a macro name.  */\n+  if (node && node->type != T_VOID)\n     {\n-      cpp_error_with_line (pfile, list->line, TOK_COL (list, 0),\n-\t\t\t   \"#define must be followed by an identifier\");\n-      goto out;\n-    }\n+      /* If we are generating additional info for debugging (with -g) we\n+\t need to pass through all effective #undef commands.  */\n+      if (CPP_OPTION (pfile, debug_output)\n+\t  || CPP_OPTION (pfile, dump_macros) == dump_definitions\n+\t  || CPP_OPTION (pfile, dump_macros) == dump_names)\n+\tpass_thru_directive (pfile);\n \n-  sym = TOK_NAME (list, 0);\n-  len = TOK_LEN (list, 0);\n+      if (node->type != T_MACRO)\n+\tcpp_warning (pfile, \"undefining \\\"%s\\\"\", node->name);\n \n-  /* That NAME is not allowed to be \"defined\".  (Not clear if the\n-     standard requires this.)  */\n-  if (len == 7 && !ustrncmp (sym, U\"defined\", 7))\n-    {\n-      cpp_error_with_line (pfile, list->line, TOK_COL (list, 0),\n-\t\t\t   \"\\\"defined\\\" is not a legal macro name\");\n-      goto out;\n+      _cpp_free_definition (node);\n+      node->type = T_VOID;\n     }\n \n-  node = cpp_lookup (pfile, sym, len);\n-  /* Check for poisoned identifiers now.  All other checks\n-     are done in cpphash.c.  */\n-  if (node->type == T_POISON)\n-    {\n-      cpp_error (pfile, \"redefining poisoned `%.*s'\", len, sym);\n-      goto out;\n-    }\n-    \n-  if (_cpp_create_definition (pfile, list, node) == 0)\n-    goto out;\n-\n-  if (CPP_OPTION (pfile, debug_output)\n-      || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n-    _cpp_dump_definition (pfile, node);\n-  else if (CPP_OPTION (pfile, dump_macros) == dump_names)\n-    pass_thru_directive (sym, len, pfile, T_DEFINE);\n-\n- out:\n-  pfile->no_macro_expand--;\n-  CPP_OPTION (pfile, discard_comments)--;\n   return 0;\n }\n \n+\n /* Handle #include and #import.  */\n \n-static unsigned int\n-parse_include (pfile, name, trail)\n+static int\n+parse_include (pfile, dir, trail, strp, lenp, abp)\n      cpp_reader *pfile;\n-     const U_CHAR *name;\n+     const U_CHAR *dir;\n      int trail;\n+     const U_CHAR **strp;\n+     unsigned int *lenp;\n+     int *abp;\n {\n-  long old_written = CPP_WRITTEN (pfile);\n-  enum cpp_ttype token;\n-  int len;\n-\n-  pfile->parsing_include_directive++;\n-  token = _cpp_get_directive_token (pfile);\n-  pfile->parsing_include_directive--;\n+  const cpp_token *name = cpp_get_token (pfile);\n \n-  len = CPP_WRITTEN (pfile) - old_written;\n-\n-  if (token != CPP_STRING)\n+  if (name->type != CPP_STRING && name->type != CPP_HEADER_NAME)\n     {\n-      cpp_error (pfile, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\", name);\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      _cpp_skip_rest_of_line (pfile);\n-      return 0;\n+      if (name->type == CPP_LESS)\n+\tname = _cpp_glue_header_name (pfile);\n+      else\n+\t{\n+\t  cpp_error (pfile, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\", dir);\n+\t  return 1;\n+\t}\n     }\n-\n-  if (!trail && _cpp_get_directive_token (pfile) != CPP_VSPACE)\n+  if (name->val.name.len == 0)\n     {\n-      cpp_error (pfile, \"junk at end of #%s\", name);\n-      _cpp_skip_rest_of_line (pfile);\n+      cpp_error (pfile, \"empty file name in #%s\", dir);\n+      return 1;\n     }\n \n-  CPP_SET_WRITTEN (pfile, old_written);\n-\n-  if (len == 0)\n-    cpp_error (pfile, \"empty file name in #%s\", name);\n+  if (!trail && cpp_get_token (pfile)->type != CPP_EOF)\n+    cpp_error (pfile, \"junk at end of #%s\", dir);\n \n-  return len;\n+  *lenp = name->val.name.len;\n+  *strp = name->val.name.text;\n+  *abp = (name->type == CPP_HEADER_NAME);\n+  return 0;\n }\n \n static int\n do_include (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int len;\n-  U_CHAR *token;\n+  const U_CHAR *str;\n+  int ab;\n \n-  len = parse_include (pfile, dtable[T_INCLUDE].name, 0);\n-  if (len == 0)\n+  if (parse_include (pfile, dtable[T_INCLUDE].name, 0, &str, &len, &ab))\n     return 0;\n-  token = (U_CHAR *) alloca (len + 1);\n-  memcpy (token, CPP_PWRITTEN (pfile), len);\n-  token[len] = '\\0';\n-  \n-  if (CPP_OPTION (pfile, dump_includes))\n-    pass_thru_directive (token, len, pfile, T_INCLUDE);\n \n-  _cpp_execute_include (pfile, token, len, 0, 0);\n+  _cpp_execute_include (pfile, str, len, 0, 0, ab);\n+  if (CPP_OPTION (pfile, dump_includes))\n+    pass_thru_directive (pfile);\n   return 0;\n }\n \n@@ -461,7 +389,8 @@ do_import (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int len;\n-  U_CHAR *token;\n+  const U_CHAR *str;\n+  int ab;\n \n   if (CPP_OPTION (pfile, warn_import)\n       && !CPP_IN_SYSTEM_HEADER (pfile) && !pfile->import_warning)\n@@ -471,17 +400,12 @@ do_import (pfile)\n \t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n-  len = parse_include (pfile, dtable[T_IMPORT].name, 0);\n-  if (len == 0)\n+  if (parse_include (pfile, dtable[T_IMPORT].name, 0, &str, &len, &ab))\n     return 0;\n-  token = (U_CHAR *) alloca (len + 1);\n-  memcpy (token, CPP_PWRITTEN (pfile), len);\n-  token[len] = '\\0';\n-  \n-  if (CPP_OPTION (pfile, dump_includes))\n-    pass_thru_directive (token, len, pfile, T_IMPORT);\n \n-  _cpp_execute_include (pfile, token, len, 1, 0);\n+  _cpp_execute_include (pfile, str, len, 1, 0, ab);\n+  if (CPP_OPTION (pfile, dump_includes))\n+    pass_thru_directive (pfile);\n   return 0;\n }\n \n@@ -490,32 +414,35 @@ do_include_next (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int len;\n-  U_CHAR *token;\n+  const U_CHAR *str;\n   struct file_name_list *search_start = 0;\n+  int ab;\n \n-  len = parse_include (pfile, dtable[T_INCLUDE_NEXT].name, 0);\n-  if (len == 0)\n+  if (parse_include (pfile, dtable[T_INCLUDE_NEXT].name, 0, &str, &len, &ab))\n     return 0;\n-  token = (U_CHAR *) alloca (len + 1);\n-  memcpy (token, CPP_PWRITTEN (pfile), len);\n-  token[len] = '\\0';\n-  \n-  if (CPP_OPTION (pfile, dump_includes))\n-    pass_thru_directive (token, len, pfile, T_INCLUDE_NEXT);\n \n-  /* For #include_next, skip in the search path past the dir in which the\n-     containing file was found.  Treat files specified using an absolute path\n-     as if there are no more directories to search.  Treat the primary source\n-     file like any other included source, but generate a warning.  */\n+  /* For #include_next, skip in the search path past the dir in which\n+     the current file was found.  If this is the last directory in the\n+     search path, don't include anything.  If the current file was\n+     specified with an absolute path, use the normal search logic.  If\n+     this is the primary source file, use the normal search logic and\n+     generate a warning.  */\n   if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)))\n     {\n       if (CPP_BUFFER (pfile)->inc->foundhere)\n-\tsearch_start = CPP_BUFFER (pfile)->inc->foundhere->next;\n+\t{\n+\t  search_start = CPP_BUFFER (pfile)->inc->foundhere->next;\n+\t  if (!search_start)\n+\t    return 0;\n+\t}\n     }\n   else\n     cpp_warning (pfile, \"#include_next in primary source file\");\n \n-  _cpp_execute_include (pfile, token, len, 0, search_start);\n+  _cpp_execute_include (pfile, str, len, 0, search_start, ab);\n+  if (CPP_OPTION (pfile, dump_includes))\n+    pass_thru_directive (pfile);\n+\n   return 0;\n }\n \n@@ -529,27 +456,47 @@ read_line_number (pfile, num)\n      cpp_reader *pfile;\n      int *num;\n {\n-  long save_written = CPP_WRITTEN (pfile);\n-  U_CHAR *p;\n-  enum cpp_ttype token = _cpp_get_directive_token (pfile);\n-  p = pfile->token_buffer + save_written;\n+  const cpp_token *tok = cpp_get_token (pfile);\n+  enum cpp_ttype type = tok->type;\n+  const U_CHAR *p = tok->val.name.text;\n+  unsigned int len = tok->val.name.len;\n \n-  if (token == CPP_NUMBER && p + 1 == CPP_PWRITTEN (pfile)\n-      && p[0] >= '1' && p[0] <= '4')\n+  if (type == CPP_NUMBER && len == 1 && p[0] >= '1' && p[0] <= '4')\n     {\n       *num = p[0] - '0';\n-      CPP_SET_WRITTEN (pfile, save_written);\n       return 1;\n     }\n   else\n     {\n-      if (token != CPP_VSPACE && token != CPP_EOF)\n+      if (type != CPP_VSPACE && type != CPP_EOF)\n \tcpp_error (pfile, \"invalid format #line\");\n-      CPP_SET_WRITTEN (pfile, save_written);\n       return 0;\n     }\n }\n \n+/* Another subroutine of do_line.  Convert a number in STR, of length\n+   LEN, to binary; store it in NUMP, and return 0 if the number was\n+   legal, 1 if not.  Temporary, hopefully.  */\n+static int\n+strtoul_for_line (str, len, nump)\n+     const U_CHAR *str;\n+     unsigned int len;\n+     unsigned long *nump;\n+{\n+  unsigned long reg = 0;\n+  U_CHAR c;\n+  while (len--)\n+    {\n+      c = *str++;\n+      if (!ISDIGIT (c))\n+\treturn 1;\n+      reg *= 10;\n+      reg += c - '0';\n+    }\n+  *nump = reg;\n+  return 0;\n+}\n+\n /* Interpret #line command.\n    Note that the filename string (if any) is treated as if it were an\n    include filename.  That means no escape handling.  */\n@@ -559,156 +506,92 @@ do_line (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n-  unsigned int new_lineno;\n-  long old_written = CPP_WRITTEN (pfile);\n-  enum cpp_ttype token;\n-  char *x;\n-\n-  token = _cpp_get_directive_token (pfile);\n+  unsigned long new_lineno, old_lineno;\n+  /* C99 raised the minimum limit on #line numbers.  */\n+  unsigned int cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n+  int action_number = 0;\n+  enum cpp_ttype type;\n+  const U_CHAR *str;\n+  char *fname;\n+  unsigned int len;\n+  const cpp_token *tok;\n \n-  if (token != CPP_NUMBER)\n-    {\n-      cpp_error (pfile, \"token after #line is not an integer\");\n-      goto bad_line_directive;\n-    }\n+  tok = cpp_get_token (pfile);\n+  type = tok->type;\n+  str = tok->val.name.text;\n+  len = tok->val.name.len;\n \n-  CPP_PUTC (pfile, '\\0');  /* not terminated for us */\n-  new_lineno = strtoul ((const char *) (pfile->token_buffer + old_written),\n-\t\t\t&x, 10);\n-  if (x[0] != '\\0')\n+  if (type != CPP_NUMBER || strtoul_for_line (str, len, &new_lineno))\n     {\n-      cpp_error (pfile, \"token after #line is not an integer\");\n-      goto bad_line_directive;\n+      cpp_error (pfile, \"token after #line is not a positive integer\");\n+      goto done;\n     }      \n-  CPP_SET_WRITTEN (pfile, old_written);\n-\n-  if (CPP_PEDANTIC (pfile) && (new_lineno <= 0 || new_lineno > 32767))\n-    cpp_pedwarn (pfile, \"line number out of range in #line\");\n \n-  token = _cpp_get_directive_token (pfile);\n+  if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n+    cpp_pedwarn (pfile, \"line number out of range\");\n \n-  if (token == CPP_STRING)\n-    {\n-      U_CHAR *fname = pfile->token_buffer + old_written + 1;\n-      U_CHAR *end_name = CPP_PWRITTEN (pfile) - 1;\n-      int action_number = 0;\n-\n-      if (read_line_number (pfile, &action_number))\n-\t{\n-\t  if (CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile, \"garbage at end of #line\");\n+  old_lineno = ip->lineno;\n+  ip->lineno = new_lineno;\n+  tok = cpp_get_token (pfile);\n+  type = tok->type;\n+  str = tok->val.name.text;\n+  len = tok->val.name.len;\n \n-\t  /* This is somewhat questionable: change the buffer stack\n-\t     depth so that output_line_command thinks we've stacked\n-\t     another buffer. */\n-\t  if (action_number == 1)\n-\t    {\n-\t      pfile->buffer_stack_depth++;\n-\t      cpp_make_system_header (pfile, ip, 0);\n-\t      read_line_number (pfile, &action_number);\n-\t    }\n-\t  else if (action_number == 2)\n-\t    {\n-\t      pfile->buffer_stack_depth--;\n-\t      cpp_make_system_header (pfile, ip, 0);\n-\t      read_line_number (pfile, &action_number);\n-\t    }\n-\t  if (action_number == 3)\n-\t    {\n-\t      cpp_make_system_header (pfile, ip, 1);\n-\t      read_line_number (pfile, &action_number);\n-\t    }\n-\t  if (action_number == 4)\n-\t    {\n-\t      cpp_make_system_header (pfile, ip, 2);\n-\t      read_line_number (pfile, &action_number);\n-\t    }\n-\t}\n-      \n-      *end_name = '\\0';\n-      \n-      if (strcmp ((const char *)fname, ip->nominal_fname))\n-\t{\n-\t  if (!strcmp ((const char *)fname, ip->inc->name))\n-\t    ip->nominal_fname = ip->inc->name;\n-\t  else\n-\t    ip->nominal_fname = _cpp_fake_include (pfile, (const char *)fname);\n-\t}\n-    }\n-  else if (token != CPP_VSPACE && token != CPP_EOF)\n+  if (type == CPP_VSPACE || type == CPP_EOF)\n+    goto done;\n+  else if (type != CPP_STRING)\n     {\n       cpp_error (pfile, \"second token after #line is not a string\");\n-      goto bad_line_directive;\n+      ip->lineno = old_lineno;  /* malformed #line should have no effect */\n+      goto done;\n     }\n \n-  /* The Newline at the end of this line remains to be processed.\n-     To put the next line at the specified line number,\n-     we must store a line number now that is one less.  */\n-  ip->lineno = new_lineno - 1;\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  return 0;\n-\n- bad_line_directive:\n-  _cpp_skip_rest_of_line (pfile);\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  return 0;\n-}\n+  fname = alloca (len + 1);\n+  memcpy (fname, str, len);\n+  fname[len] = '\\0';\n+    \n+  if (strcmp (fname, ip->nominal_fname))\n+    {\n+      if (!strcmp (fname, ip->inc->name))\n+\tip->nominal_fname = ip->inc->name;\n+      else\n+\tip->nominal_fname = _cpp_fake_include (pfile, fname);\n+    }\n \n-/* Remove the definition of a symbol from the symbol table.\n-   According to the C standard, it is not an error to undef\n-   something that has no definitions. */\n-static int\n-do_undef (pfile)\n-     cpp_reader *pfile;\n-{\n-  int len;\n-  cpp_hashnode *hp;\n-  U_CHAR *name;\n-  long here = CPP_WRITTEN (pfile);\n-  enum cpp_ttype token;\n+  if (read_line_number (pfile, &action_number) == 0)\n+    return 0;\n \n-  pfile->no_macro_expand++;\n-  token = _cpp_get_directive_token (pfile);\n-  pfile->no_macro_expand--;\n+  if (CPP_PEDANTIC (pfile))\n+    cpp_pedwarn (pfile, \"garbage at end of #line\");\n \n-  if (token != CPP_NAME)\n+  /* This is somewhat questionable: change the buffer stack\n+     depth so that output_line_command thinks we've stacked\n+     another buffer. */\n+  if (action_number == 1)\n     {\n-      cpp_error (pfile, \"token after #undef is not an identifier\");\n-      _cpp_skip_rest_of_line (pfile);\n-      return 0;\n+      pfile->buffer_stack_depth++;\n+      cpp_make_system_header (pfile, ip, 0);\n+      read_line_number (pfile, &action_number);\n     }\n-  len = CPP_WRITTEN (pfile) - here;\n-\n-  token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_VSPACE)\n-  {\n-      cpp_pedwarn (pfile, \"junk on line after #undef\");\n-      _cpp_skip_rest_of_line (pfile);\n-  }\n-\n-  name = pfile->token_buffer + here;\n-  CPP_SET_WRITTEN (pfile, here);\n-\n-  hp = cpp_lookup (pfile, name, len);\n-  if (hp->type == T_VOID)\n-    ; /* Not defined in the first place - do nothing.  */\n-  else if (hp->type == T_POISON)\n-    cpp_error (pfile, \"cannot undefine poisoned \\\"%s\\\"\", hp->name);\n-  else\n+  else if (action_number == 2)\n     {\n-      /* If we are generating additional info for debugging (with -g) we\n-\t need to pass through all effective #undef commands.  */\n-      if (CPP_OPTION (pfile, debug_output))\n-\tpass_thru_directive (hp->name, len, pfile, T_UNDEF);\n-\n-      if (hp->type != T_MACRO && hp->type != T_FMACRO\n-\t  && hp->type != T_EMPTY && hp->type != T_IDENTITY)\n-\tcpp_warning (pfile, \"undefining `%s'\", hp->name);\n-\n-      _cpp_free_definition (hp);\n-      hp->type = T_VOID;\n+      pfile->buffer_stack_depth--;\n+      cpp_make_system_header (pfile, ip, 0);\n+      read_line_number (pfile, &action_number);\n     }\n+  if (action_number == 3)\n+    {\n+      cpp_make_system_header (pfile, ip, 1);\n+      read_line_number (pfile, &action_number);\n+    }\n+  if (action_number == 4)\n+    {\n+      cpp_make_system_header (pfile, ip, 2);\n+      read_line_number (pfile, &action_number);\n+    }\n+   return 0;\n \n+ done:\n   return 0;\n }\n \n@@ -722,14 +605,14 @@ static int\n do_error (pfile)\n      cpp_reader *pfile;\n {\n-  const U_CHAR *text, *limit;\n+  U_CHAR *text, *limit;\n \n-  _cpp_skip_hspace (pfile);\n-  text = CPP_BUFFER (pfile)->cur;\n-  _cpp_skip_rest_of_line (pfile);\n-  limit = CPP_BUFFER (pfile)->cur;\n+  text = pfile->limit;\n+  _cpp_dump_list (pfile, &pfile->token_list, pfile->first_directive_token, 0);\n+  limit = pfile->limit;\n+  pfile->limit = text;\n+  cpp_error (pfile, \"%.*s\", (int)(limit - text), text);\n \n-  cpp_error (pfile, \"#error %.*s\", (int)(limit - text), text);\n   return 0;\n }\n \n@@ -742,14 +625,13 @@ static int\n do_warning (pfile)\n      cpp_reader *pfile;\n {\n-  const U_CHAR *text, *limit;\n+  U_CHAR *text, *limit;\n \n-  _cpp_skip_hspace (pfile);\n-  text = CPP_BUFFER (pfile)->cur;\n-  _cpp_skip_rest_of_line (pfile);\n-  limit = CPP_BUFFER (pfile)->cur;\n-\n-  cpp_warning (pfile, \"#warning %.*s\", (int)(limit - text), text);\n+  text = pfile->limit;\n+  _cpp_dump_list (pfile, &pfile->token_list, pfile->first_directive_token, 0);\n+  limit = pfile->limit;\n+  pfile->limit = text;\n+  cpp_warning (pfile, \"%.*s\", (int)(limit - text), text);\n   return 0;\n }\n \n@@ -759,21 +641,17 @@ static int\n do_ident (pfile)\n      cpp_reader *pfile;\n {\n-  long old_written = CPP_WRITTEN (pfile);\n-\n-  CPP_PUTS (pfile, \"#ident \", 7);\n-\n   /* Next token should be a string constant.  */\n-  if (_cpp_get_directive_token (pfile) == CPP_STRING)\n+  if (cpp_get_token (pfile)->type == CPP_STRING)\n     /* And then a newline.  */\n-    if (_cpp_get_directive_token (pfile) == CPP_VSPACE)\n-      /* Good - ship it.  */\n-      return 0;\n+    if (cpp_get_token (pfile)->type == CPP_VSPACE)\n+      {\n+\t/* Good - ship it.  */\n+\tpass_thru_directive (pfile);\n+\treturn 0;\n+      }\n \n   cpp_error (pfile, \"invalid #ident\");\n-  _cpp_skip_rest_of_line (pfile);\n-  CPP_SET_WRITTEN (pfile, old_written);  /* discard directive */\n-\n   return 0;\n }\n \n@@ -792,17 +670,17 @@ do_ident (pfile)\n    They return 1 if the token buffer is to be popped, 0 if not. */\n struct pragma_entry\n {\n-  char const *name;\n+  const char *name;\n   int (*handler) PARAMS ((cpp_reader *));\n };\n \n static int pragma_dispatch             \n-    PARAMS ((cpp_reader *, const struct pragma_entry *, U_CHAR *, size_t));\n+    PARAMS ((cpp_reader *, const struct pragma_entry *,\n+\t     const U_CHAR *, size_t));\n static int do_pragma_once\t\tPARAMS ((cpp_reader *));\n static int do_pragma_implementation\tPARAMS ((cpp_reader *));\n static int do_pragma_poison\t\tPARAMS ((cpp_reader *));\n static int do_pragma_system_header\tPARAMS ((cpp_reader *));\n-static int do_pragma_default\t\tPARAMS ((cpp_reader *));\n static int do_pragma_gcc                PARAMS ((cpp_reader *));\n static int do_pragma_dependency         PARAMS ((cpp_reader *));\n \n@@ -811,9 +689,8 @@ static const struct pragma_entry top_pragmas[] =\n   {\"once\", do_pragma_once},\n   {\"implementation\", do_pragma_implementation},\n   {\"poison\", do_pragma_poison},\n-  {\"system_header\", do_pragma_system_header},\n   {\"GCC\", do_pragma_gcc},\n-  {NULL, do_pragma_default}\n+  {NULL, NULL}\n };\n \n static const struct pragma_entry gcc_pragmas[] =\n@@ -822,96 +699,58 @@ static const struct pragma_entry gcc_pragmas[] =\n   {\"poison\", do_pragma_poison},\n   {\"system_header\", do_pragma_system_header},\n   {\"dependency\", do_pragma_dependency},\n-  {NULL, do_pragma_default}\n+  {NULL, NULL}\n };\n \n static int pragma_dispatch (pfile, table, p, len)\n      cpp_reader *pfile;\n      const struct pragma_entry *table;\n-     U_CHAR *p;\n+     const U_CHAR *p;\n      size_t len;\n {\n   for (; table->name; table++)\n     if (strlen (table->name) == len && !memcmp (p, table->name, len))\n       return (*table->handler) (pfile);\n-  return (*table->handler) (pfile);\n+  return 0;\n }\n \n static int\n do_pragma (pfile)\n      cpp_reader *pfile;\n {\n-  long here, key;\n-  U_CHAR *buf;\n+  const cpp_token *tok;\n   int pop;\n-  enum cpp_ttype token;\n-  size_t  len;\n-\n-  here = CPP_WRITTEN (pfile);\n-  CPP_PUTS (pfile, \"#pragma \", 8);\n \n-  key = CPP_WRITTEN (pfile);\n-  pfile->no_macro_expand++;\n-  token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_NAME)\n+  tok = cpp_get_token (pfile);\n+  if (tok->type == CPP_EOF)\n+    return 0;\n+  else if (tok->type != CPP_NAME)\n     {\n-      if (token == CPP_VSPACE)\n-\tgoto empty;\n-      else\n-\tgoto skip;\n+      cpp_error (pfile, \"malformed #pragma directive\");\n+      return 0;\n     }\n \n-  buf = pfile->token_buffer + key;\n-  len = CPP_WRITTEN (pfile) - key;\n-  CPP_PUTC (pfile, ' ');\n-\n-  pop = pragma_dispatch (pfile, top_pragmas, buf, len);\n-\n-  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n-    goto skip;\n-\n-  if (pop)\n-    CPP_SET_WRITTEN (pfile, here);\n-  pfile->no_macro_expand--;\n-  return 0;\n-\n- skip:\n-  cpp_error (pfile, \"malformed #pragma directive\");\n-  _cpp_skip_rest_of_line (pfile);\n- empty:\n-  CPP_SET_WRITTEN (pfile, here);\n-  pfile->no_macro_expand--;\n-  return 0;\n-}\n-\n-static int\n-do_pragma_default (pfile)\n-     cpp_reader *pfile;\n-{\n-  while (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n-    CPP_PUTC (pfile, ' ');\n+  pop = pragma_dispatch (pfile, top_pragmas,\n+\t\t\t tok->val.name.text, tok->val.name.len);\n+  if (!pop)\n+    pass_thru_directive (pfile);\n   return 0;\n }\n \n static int\n do_pragma_gcc (pfile)\n      cpp_reader *pfile;\n {\n-  long key;\n-  enum cpp_ttype token;\n-  U_CHAR *buf;\n-  size_t  len;\n-  \n-  key = CPP_WRITTEN (pfile);\n-  token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_NAME)\n-    return token == CPP_VSPACE;\n-\n-  buf = pfile->token_buffer + key;\n-  len = CPP_WRITTEN (pfile) - key;\n-  CPP_PUTC (pfile, ' ');\n+  const cpp_token *tok;\n+\n+  tok = cpp_get_token (pfile);\n+  if (tok->type == CPP_EOF)\n+    return 1;\n+  else if (tok->type != CPP_NAME)\n+    return 0;\n   \n-  return pragma_dispatch (pfile, gcc_pragmas, buf, len);\n+  return pragma_dispatch (pfile, gcc_pragmas,\n+\t\t\t  tok->val.name.text, tok->val.name.len);\n }\n \n static int\n@@ -939,27 +778,22 @@ do_pragma_implementation (pfile)\n {\n   /* Be quiet about `#pragma implementation' for a file only if it hasn't\n      been included yet.  */\n-  enum cpp_ttype token;\n-  long written = CPP_WRITTEN (pfile);\n-  U_CHAR *name;\n+  const cpp_token *tok = cpp_get_token (pfile);\n   char *copy;\n-  size_t len;\n \n-  token = _cpp_get_directive_token (pfile);\n-  if (token == CPP_VSPACE)\n+  if (tok->type == CPP_EOF)\n     return 0;\n-  else if (token != CPP_STRING)\n+  else if (tok->type != CPP_STRING\n+\t   || cpp_get_token (pfile)->type != CPP_EOF)\n     {\n       cpp_error (pfile, \"malformed #pragma implementation\");\n       return 1;\n     }\n \n-  /* Trim the leading and trailing quote marks from the string.  */\n-  name = pfile->token_buffer + written + 1;\n-  len = CPP_PWRITTEN (pfile) - name;\n-  copy = alloca (len);\n-  memcpy (copy, name, len - 1);\n-  copy[len - 1] = '\\0';\n+  /* Make a NUL-terminated copy of the string.  */\n+  copy = alloca (tok->val.name.len + 1);\n+  memcpy (copy, tok->val.name.text, tok->val.name.len);\n+  copy[tok->val.name.len] = '\\0';\n   \n   if (cpp_included (pfile, copy))\n     cpp_warning (pfile,\n@@ -974,11 +808,8 @@ do_pragma_poison (pfile)\n {\n   /* Poison these symbols so that all subsequent usage produces an\n      error message.  */\n-  U_CHAR *p;\n+  const cpp_token *tok;\n   cpp_hashnode *hp;\n-  long written;\n-  size_t len;\n-  enum cpp_ttype token;\n   int writeit;\n \n   /* As a rule, don't include #pragma poison commands in output,  \n@@ -989,31 +820,25 @@ do_pragma_poison (pfile)\n \n   for (;;)\n     {\n-      written = CPP_WRITTEN (pfile);\n-      token = _cpp_get_directive_token (pfile);\n-      if (token == CPP_VSPACE)\n+      tok = cpp_get_token (pfile);\n+      if (tok->type == CPP_EOF)\n \tbreak;\n-      if (token != CPP_NAME)\n+      if (tok->type != CPP_NAME)\n \t{\n \t  cpp_error (pfile, \"invalid #pragma poison directive\");\n-\t  _cpp_skip_rest_of_line (pfile);\n \t  return 1;\n \t}\n \n-      p = pfile->token_buffer + written;\n-      len = CPP_PWRITTEN (pfile) - p;\n-      hp = cpp_lookup (pfile, p, len);\n+      hp = cpp_lookup (pfile, tok->val.name.text, tok->val.name.len);\n       if (hp->type == T_POISON)\n \t;  /* It is allowed to poison the same identifier twice.  */\n       else\n \t{\n \t  if (hp->type != T_VOID)\n-\t    cpp_warning (pfile, \"poisoning existing macro `%s'\", hp->name);\n+\t    cpp_warning (pfile, \"poisoning existing macro \\\"%s\\\"\", hp->name);\n \t  _cpp_free_definition (hp);\n \t  hp->type = T_POISON;\n \t}\n-      if (writeit)\n-\tCPP_PUTC (pfile, ' ');\n     }\n   return !writeit;\n }\n@@ -1028,7 +853,7 @@ static int\n do_pragma_system_header (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n   if (CPP_PREV_BUFFER (ip) == NULL)\n     cpp_warning (pfile, \"#pragma system_header outside include file\");\n   else\n@@ -1044,43 +869,46 @@ static int\n do_pragma_dependency (pfile)\n      cpp_reader *pfile;\n {\n-  U_CHAR *original_name, *name;\n-  unsigned len;\n-  int ordering;\n-  \n-  len = parse_include (pfile, (const U_CHAR *)\"pragma dependency\", 1);\n-  original_name = (U_CHAR *) alloca (len + 1);\n-  name = (U_CHAR *) alloca (len + 1);\n-  memcpy (original_name, CPP_PWRITTEN (pfile), len);\n-  memcpy (name, CPP_PWRITTEN (pfile), len);\n-  original_name[len] = name[len] = 0;\n-  \n-  ordering = _cpp_compare_file_date (pfile, name, len, 0);\n+  const U_CHAR *name;\n+  unsigned int len;\n+  int ordering, ab;\n+  char left, right;\n+ \n+  if (parse_include (pfile, U\"pragma dependency\", 1, &name, &len, &ab))\n+    return 1;\n+\n+  left = ab ? '<' : '\"';\n+  right = ab ? '>' : '\"';\n+ \n+  ordering = _cpp_compare_file_date (pfile, name, len, ab);\n   if (ordering < 0)\n-    cpp_warning (pfile, \"cannot find source %s\", original_name);\n+    cpp_warning (pfile, \"cannot find source %c%s%c\", left, name, right);\n   else if (ordering > 0)\n     {\n-      const U_CHAR *text, *limit;\n-      _cpp_skip_hspace (pfile);\n-      text = CPP_BUFFER (pfile)->cur;\n-      _cpp_skip_rest_of_line (pfile);\n-      limit = CPP_BUFFER (pfile)->cur;\n+      const cpp_token *msg = cpp_get_token (pfile);\n       \n-      cpp_warning (pfile, \"current file is older than %s\", original_name);\n-      if (limit != text)\n-        cpp_warning (pfile, \"%.*s\", (int)(limit - text), text);\n+      cpp_warning (pfile, \"current file is older than %c%s%c\",\n+\t\t   left, name, right);\n+      if (msg->type != CPP_EOF)\n+\t{\n+\t  U_CHAR *text, *limit;\n+\n+\t  text = pfile->limit;\n+\t  _cpp_dump_list (pfile, &pfile->token_list, msg, 0);\n+\t  limit = pfile->limit;\n+\t  pfile->limit = text;\n+\t  cpp_warning (pfile, \"%.*s\", (int)(limit - text), text);\n+\t}\n     }\n-  _cpp_skip_rest_of_line (pfile);\n   return 1;\n }\n \n /* Just ignore #sccs, on systems where we define it at all.  */\n #ifdef SCCS_DIRECTIVE\n static int\n do_sccs (pfile)\n-     cpp_reader *pfile;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  _cpp_skip_rest_of_line (pfile);\n   return 0;\n }\n #endif\n@@ -1096,117 +924,76 @@ static const cpp_hashnode *\n detect_if_not_defined (pfile)\n      cpp_reader *pfile;\n {\n-  const cpp_hashnode *cmacro = 0;\n-  enum cpp_ttype token;\n-  unsigned int base_offset;\n-  unsigned int token_offset;\n-  unsigned int need_rparen = 0;\n-  unsigned int token_len;\n-\n-  if (pfile->skipping || pfile->only_seen_white != 2)\n-    return NULL;\n-\n-  /* Save state required for restore.  */\n-  pfile->no_macro_expand++;\n-  CPP_SET_MARK (pfile);\n-  base_offset = CPP_WRITTEN (pfile);\n-\n-  /* Look for `!', */\n-  if (_cpp_get_directive_token (pfile) != CPP_OTHER\n-      || CPP_WRITTEN (pfile) != (size_t) base_offset + 1\n-      || CPP_PWRITTEN (pfile)[-1] != '!')\n-    goto restore;\n-\n-  /* ...then `defined', */\n-  token_offset = CPP_WRITTEN (pfile);\n-  token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_NAME)\n-    goto restore;\n-  if (ustrncmp (pfile->token_buffer + token_offset, U\"defined\", 7))\n-    goto restore;\n-\n-  /* ...then an optional '(' and the name, */\n-  token_offset = CPP_WRITTEN (pfile);\n-  token = _cpp_get_directive_token (pfile);\n-  if (token == CPP_OPEN_PAREN)\n-    {\n-      token_offset = CPP_WRITTEN (pfile);\n-      need_rparen = 1;\n-      token = _cpp_get_directive_token (pfile);\n-    }\n-  if (token != CPP_NAME)\n-    goto restore;\n+  const cpp_token *token;\n+  cpp_hashnode *cmacro = 0;\n+\n+  /* We are guaranteed that tokens are consecutive and end in CPP_EOF.  */\n+  token = pfile->first_directive_token + 2;\n+\n+  if (token->type != CPP_NOT)\n+    return 0;\n \n-  token_len = CPP_WRITTEN (pfile) - token_offset;\n+  token++;\n+  if (token->type != CPP_NAME\n+      || !str_match (token->val.name.text, token->val.name.len, \"defined\"))\n+    return 0;\n+\n+  token++;\n+  if (token->type == CPP_OPEN_PAREN)\n+    token++;\n \n-  /* ...then the ')', if necessary, */\n-  if (need_rparen && _cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n-    goto restore;\n+  if (token->type != CPP_NAME)\n+    return 0;\n \n-  /* ...and make sure there's nothing else on the line.  */\n-  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n-    goto restore;\n+  cmacro = cpp_lookup (pfile, token->val.name.text, token->val.name.len);\n \n-  /* We have a legitimate controlling macro for this header.  */\n-  cmacro = cpp_lookup (pfile, pfile->token_buffer + token_offset, token_len);\n+  if (token[-1].type == CPP_OPEN_PAREN)\n+    {\n+      token++;\n+      if (token->type != CPP_CLOSE_PAREN)\n+\treturn 0;\n+    }\n \n- restore:\n-  CPP_SET_WRITTEN (pfile, base_offset);\n-  pfile->no_macro_expand--;\n-  CPP_GOTO_MARK (pfile);\n+  token++;\n+  if (token->type != CPP_EOF)\n+    return 0;\n \n   return cmacro;\n }\n \n-/* Parse an #ifdef or #ifndef directive.  Returns 1 for defined, 0 for\n-   not defined; the macro tested is left in the token buffer (but\n-   popped).  */\n+/* Parse an #ifdef or #ifndef directive.  Returns the hash node of the\n+   macro being tested, and issues various error messages.  */\n \n static const cpp_hashnode *\n parse_ifdef (pfile, name)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n {\n-  U_CHAR *ident;\n+  const U_CHAR *ident;\n   unsigned int len;\n-  enum cpp_ttype token;\n-  long old_written = CPP_WRITTEN (pfile);\n+  enum cpp_ttype type;\n   const cpp_hashnode *node = 0;\n \n-  pfile->no_macro_expand++;\n-  token = _cpp_get_directive_token (pfile);\n-  pfile->no_macro_expand--;\n-\n-  ident = pfile->token_buffer + old_written;\n-  len = CPP_WRITTEN (pfile) - old_written;\n+  const cpp_token *token = cpp_get_token (pfile);\n+  type = token->type;\n+  ident = token->val.name.text;\n+  len = token->val.name.len;\n \n-  if (token == CPP_VSPACE)\n+  if (!CPP_TRADITIONAL (pfile))\n     {\n-      if (! CPP_TRADITIONAL (pfile))\n+      if (type == CPP_EOF)\n \tcpp_pedwarn (pfile, \"#%s with no argument\", name);\n-      goto done;\n-    }\n-  else if (token == CPP_NAME)\n-    {\n-      node = cpp_lookup (pfile, ident, len);\n-    }\n-  else\n-    {\n-      if (! CPP_TRADITIONAL (pfile))\n-\tcpp_error (pfile, \"#%s with invalid argument\", name);\n+      else if (type != CPP_NAME)\n+\tcpp_pedwarn (pfile, \"#%s with invalid argument\", name);\n+      else if (cpp_get_token (pfile)->type != CPP_EOF)\n+\tcpp_pedwarn (pfile, \"garbage at end of #%s\", name);\n     }\n \n-  if (!CPP_TRADITIONAL (pfile))\n-    {\n-      if (_cpp_get_directive_token (pfile) == CPP_VSPACE)\n-\tgoto done;\n-      \n-      cpp_pedwarn (pfile, \"garbage at end of #%s\", name);\n-    }\n-  _cpp_skip_rest_of_line (pfile);\n-  \n- done:\n-  CPP_SET_WRITTEN (pfile, old_written); /* Pop */\n+  if (type == CPP_NAME)\n+    node = cpp_lookup (pfile, ident, len);\n+  if (node && node->type == T_POISON)\n+    cpp_error (pfile, \"attempt to use poisoned identifier \\\"%s\\\"\", node->name);\n+    \n   return node;\n }\n \n@@ -1217,14 +1004,15 @@ do_ifdef (pfile)\n      cpp_reader *pfile;\n {\n   int def = 0;\n-  const cpp_hashnode *node = parse_ifdef (pfile, dtable[T_IFDEF].name);\n-  if (node)\n+  const cpp_hashnode *node = 0;\n+\n+  if (! pfile->skipping)\n     {\n-      if (node->type == T_POISON)\n-\tcpp_error (pfile, \"attempt to use poisoned `%s'\", node->name);\n-      else\n-\tdef = (node->type != T_VOID);\n+      node = parse_ifdef (pfile, dtable[T_IFDEF].name);\n+      if (node)\n+\tdef = (node->type != T_VOID && node->type != T_POISON);\n     }\n+\n   push_conditional (pfile, !def, T_IFDEF, 0);\n   return 0;\n }\n@@ -1236,21 +1024,19 @@ static int\n do_ifndef (pfile)\n      cpp_reader *pfile;\n {\n-  int start_of_file;\n+  int start_of_file = 0;\n   int def = 0;\n-  const cpp_hashnode *cmacro;\n+  const cpp_hashnode *cmacro = 0;\n \n-  start_of_file = pfile->only_seen_white == 2;\n-  cmacro = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n-  if (cmacro)\n+  if (! pfile->skipping)\n     {\n-      if (cmacro->type == T_POISON)\n-\tcpp_error (pfile, \"attempt to use poisoned `%s'\", cmacro->name);\n-      else\n-\tdef = (cmacro->type != T_VOID);\n+      start_of_file = (pfile->token_list.flags & BEG_OF_FILE);\n+      cmacro = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n+      if (cmacro)\n+\tdef = cmacro->type != T_VOID;\n     }\n-  push_conditional (pfile, def, T_IFNDEF,\n-\t\t    start_of_file ? cmacro : 0);\n+\n+  push_conditional (pfile, def, T_IFNDEF, start_of_file ? cmacro : 0);\n   return 0;\n }\n \n@@ -1282,7 +1068,6 @@ do_else (pfile)\n      cpp_reader *pfile;\n {\n   struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n-\n   validate_else (pfile, dtable[T_ELSE].name);\n \n   if (ifs == NULL)\n@@ -1293,13 +1078,13 @@ do_else (pfile)\n   if (ifs->type == T_ELSE)\n     {\n       cpp_error (pfile, \"#else after #else\");\n-      cpp_error_with_line (pfile, ifs->lineno, 1, \"the conditional began here\");\n+      cpp_error_with_line (pfile, ifs->lineno, ifs->colno,\n+\t\t\t   \"the conditional began here\");\n     }\n \n   /* #ifndef can't have its special treatment for containing the whole file\n      if it has a #else clause.  */\n   ifs->cmacro = 0;\n-\n   ifs->type = T_ELSE;\n   if (! ifs->was_skipping)\n     {\n@@ -1330,24 +1115,24 @@ do_elif (pfile)\n   if (ifs->type == T_ELSE)\n     {\n       cpp_error (pfile, \"#elif after #else\");\n-      cpp_error_with_line (pfile, ifs->lineno, 1, \"the conditional began here\");\n+      cpp_error_with_line (pfile, ifs->lineno, ifs->colno,\n+\t\t\t   \"the conditional began here\");\n     }\n \n   ifs->type = T_ELIF;\n   if (ifs->was_skipping)\n-    _cpp_skip_rest_of_line (pfile);\n-  else if (pfile->skipping != 1)\n+    return 0;  /* Don't evaluate a nested #if */\n+\n+  if (pfile->skipping != 1)\n     {\n-      _cpp_skip_rest_of_line (pfile);\n       pfile->skipping = 2;  /* one block succeeded, so don't do any others */\n+      return 0;\n     }\n-  else\n-    pfile->skipping = ! _cpp_parse_expr (pfile);\n \n+  pfile->skipping = ! _cpp_parse_expr (pfile);\n   return 0;\n }\n \n-\n /* #endif pops the if stack and resets pfile->skipping.  */\n \n static int\n@@ -1370,6 +1155,7 @@ do_endif (pfile)\n   return 0;\n }\n \n+\n /* Push an if_stack entry and set pfile->skipping accordingly.\n    If this is a #ifndef starting at the beginning of a file,\n    CMACRO is the macro name tested by the #ifndef.  */\n@@ -1384,7 +1170,7 @@ push_conditional (pfile, skip, type, cmacro)\n   struct if_stack *ifs;\n \n   ifs = (struct if_stack *) xmalloc (sizeof (struct if_stack));\n-  ifs->lineno = CPP_BUFFER (pfile)->lineno;\n+  ifs->lineno = _cpp_get_line (pfile, &ifs->colno);\n   ifs->next = CPP_BUFFER (pfile)->if_stack;\n   ifs->cmacro = cmacro;\n   ifs->was_skipping = pfile->skipping;\n@@ -1404,19 +1190,11 @@ validate_else (pfile, directive)\n      cpp_reader *pfile;\n      const U_CHAR *directive;\n {\n-  if (CPP_PEDANTIC (pfile))\n-    {\n-      long old_written = CPP_WRITTEN (pfile);\n-      pfile->no_macro_expand++;\n-      if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n-\tcpp_pedwarn (pfile, \"ISO C forbids text after #%s\", directive);\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      pfile->no_macro_expand--;\n-    }\n-  _cpp_skip_rest_of_line (pfile);\n+  if (CPP_PEDANTIC (pfile) && cpp_get_token (pfile)->type != CPP_EOF)\n+    cpp_pedwarn (pfile, \"ISO C forbids text after #%s\", directive);\n }\n \n-/* Called when we reach the end of a macro buffer.  Walk back up the\n+/* Called when we reach the end of a file.  Walk back up the\n    conditional stack till we reach its level at entry to this file,\n    issuing error messages.  Then force skipping off.  */\n void\n@@ -1428,181 +1206,218 @@ _cpp_unwind_if_stack (pfile, pbuf)\n \n   for (ifs = pbuf->if_stack; ifs; ifs = nifs)\n     {\n-      cpp_error_with_line (pfile, ifs->lineno, 1, \"unterminated #%s\",\n+      cpp_error_with_line (pfile, ifs->lineno, ifs->colno, \"unterminated #%s\",\n \t\t\t   dtable[ifs->type].name);\n       nifs = ifs->next;\n       free (ifs);\n     }\n   pfile->skipping = 0;\n }\n \n-#define WARNING(msgid) do { cpp_warning(pfile, msgid); goto error; } while (0)\n-#define ERROR(msgid) do { cpp_error(pfile, msgid); goto error; } while (0)\n-#define ICE(msgid) do { cpp_ice(pfile, msgid); goto error; } while (0)\n-static int\n-do_assert (pfile)\n+/* Parses an assertion, returning a pointer to the hash node of the\n+   predicate, or 0 on error.  If an answer was supplied, it is\n+   allocated and placed in ANSWERP, otherwise it is set to 0.  We use\n+   _cpp_get_raw_token, since we cannot assume tokens are consecutive\n+   in a #if statement (we may be in a macro), and we don't want to\n+   macro expand.  */\n+cpp_hashnode *\n+_cpp_parse_assertion (pfile, answerp)\n      cpp_reader *pfile;\n+     struct answer **answerp;\n {\n-  long old_written;\n+  struct answer *answer = 0;\n+  cpp_toklist *list;\n   U_CHAR *sym;\n-  size_t len;\n-  cpp_hashnode *hp;\n-  struct predicate *pred = 0;\n-  enum cpp_ttype type;\n+  const cpp_token *token, *predicate;\n+  const struct directive *d = pfile->token_list.directive;\n+  unsigned int len = 0;\n \n-  old_written = CPP_WRITTEN (pfile);\n-  pfile->no_macro_expand++;\n+  predicate = _cpp_get_raw_token (pfile);\n+  if (predicate->type == CPP_EOF)\n+    {\n+      cpp_error (pfile, \"assertion without predicate\");\n+      return 0;\n+    }\n+  else if (predicate->type != CPP_NAME)\n+    {\n+      cpp_error (pfile, \"predicate must be an identifier\");\n+      return 0;\n+    }\n \n-  CPP_PUTC (pfile, '#');\t/* force token out of macro namespace */\n-  type = _cpp_get_directive_token (pfile);\n-  if (type == CPP_VSPACE)\n-    ERROR (\"#assert without predicate\");\n-  else if (type != CPP_NAME)\n-    ERROR (\"assertion predicate is not an identifier\");\n+  token = _cpp_get_raw_token (pfile);\n+  if (token->type != CPP_OPEN_PAREN)\n+    {\n+      /* #unassert and #if are OK without predicate.  */\n+      if (d == &dtable[T_UNASSERT])\n+\t{\n+\t  if (token->type == CPP_EOF)\n+\t    goto lookup_node;\n+\t}\n+      else if (d != &dtable[T_ASSERT])\n+\t{\n+\t  _cpp_push_token (pfile, token);\n+\t  goto lookup_node;\n+\t}\n+      cpp_error (pfile, \"missing '(' after predicate\");\n+      return 0;\n+    }\n \n-  sym = pfile->token_buffer + old_written;\n-  len = CPP_WRITTEN (pfile) - old_written;\n-  hp = cpp_lookup (pfile, sym, len);\n+  /* Allocate a struct answer, and copy the answer to it.  */\n+  answer = (struct answer *) xmalloc (sizeof (struct answer));\n+  list = &answer->list;\n+  _cpp_init_toklist (list, NO_DUMMY_TOKEN);\n \n-  if (_cpp_get_directive_token (pfile) != CPP_OPEN_PAREN)\n-    ERROR (\"missing token-sequence in #assert\");\n+  for (;;)\n+    {\n+      cpp_token *dest;\n \n-  pred = (struct predicate *) xmalloc (sizeof (struct predicate));\n-  _cpp_init_toklist (&pred->answer, NO_DUMMY_TOKEN);\n+      token = _cpp_get_raw_token (pfile);\n \n-  if (_cpp_scan_until (pfile, &pred->answer, CPP_CLOSE_PAREN)\n-      != CPP_CLOSE_PAREN)\n-    ERROR (\"missing close paren in #assert\");\n+      if (token->type == CPP_EOF)\n+\t{\n+\t  cpp_error (pfile, \"missing ')' to complete answer\");\n+\t  goto error;\n+\t}\n+      if (token->type == CPP_CLOSE_PAREN)\n+\tbreak;\n \n-  if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n-    ICE (\"impossible token, expecting ) in do_assert\");\n+      /* Copy the token.  */\n+      _cpp_expand_token_space (list, 1);\n+      dest = &list->tokens[list->tokens_used++];\n+      *dest = *token;\n \n-  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n-    ERROR (\"junk at end of #assert\");\n+      if (token_spellings[token->type].type > SPELL_NONE)\n+\t{\n+\t  _cpp_expand_name_space (list, token->val.name.len);\n+\t  dest->val.name.text = list->namebuf + list->name_used;\n+\t  memcpy (list->namebuf + list->name_used,\n+\t\t  token->val.name.text, token->val.name.len);\n+\t  list->name_used += token->val.name.len;\n+\t}\n+    }\n \n-  if (hp->type == T_ASSERTION)\n+  if (list->tokens_used == 0)\n     {\n-      /* Check for reassertion.  */\n-      const struct predicate *old;\n-\n-      for (old = hp->value.pred; old; old = old->next)\n-\tif (_cpp_equiv_toklists (&pred->answer, &old->answer))\n-\t  /* We used to warn about this, but SVR4 cc doesn't, so let's\n-\t     match that (also consistent with #define).  goto error will\n-\t     clean up.  */\n-\t  goto error;\n-      pred->next = hp->value.pred;\n+      cpp_error (pfile, \"predicate's answer is empty\");\n+      goto error;\n     }\n-  else\n+\n+  /* Drop whitespace at start.  */\n+  list->tokens[0].flags &= ~PREV_WHITE;\n+\n+  if ((d == &dtable[T_ASSERT] || d == &dtable[T_UNASSERT])\n+      && token[1].type != CPP_EOF)\n     {\n-      hp->type = T_ASSERTION;\n-      pred->next = 0;\n+      cpp_error (pfile, \"junk at end of assertion\");\n+      goto error;\n     }\n-  \n-  _cpp_squeeze_toklist (&pred->answer);\n-  hp->value.pred = pred;\n-  pfile->no_macro_expand--;\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  return 0;\n+\n+ lookup_node:\n+  *answerp = answer;\n+  len = predicate->val.name.len + 1;\n+  sym = alloca (len);\n+\n+  /* Prefix '#' to get it out of macro namespace.  */\n+  sym[0] = '#';\n+  memcpy (sym + 1, predicate->val.name.text, len);\n+  return cpp_lookup (pfile, sym, len);\n \n  error:\n-  _cpp_skip_rest_of_line (pfile);\n-  pfile->no_macro_expand--;\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  if (pred)\n-    {\n-      _cpp_free_toklist (&pred->answer);\n-      free (pred);\n-    }\n+  FREE_ANSWER (answer);\n   return 0;\n }\n \n-static int\n-do_unassert (pfile)\n-     cpp_reader *pfile;\n+/* Returns a pointer to the pointer to the answer in the answer chain,\n+   or a pointer to NULL if the answer is not in the chain.  */\n+struct answer **\n+find_answer (node, candidate)\n+     cpp_hashnode *node;\n+     const cpp_toklist *candidate;\n {\n-  long old_written;\n-  U_CHAR *sym;\n-  size_t len;\n-  cpp_hashnode *hp;\n-  cpp_toklist ans;\n-  enum cpp_ttype type;\n-  int specific = 0;\n+  struct answer **result;\n \n-  old_written = CPP_WRITTEN (pfile);\n-  pfile->no_macro_expand++;\n+  for (result = &node->value.answers; *result; result = &(*result)->next)\n+    if (_cpp_equiv_toklists (&(*result)->list, candidate))\n+      break;\n \n-  CPP_PUTC (pfile, '#');\t/* force token out of macro namespace */\n-  if (_cpp_get_directive_token (pfile) != CPP_NAME)\n-    ERROR (\"#unassert must be followed by an identifier\");\n-\n-  sym = pfile->token_buffer + old_written;\n-  len = CPP_WRITTEN (pfile) - old_written;\n-  hp = cpp_lookup (pfile, sym, len);\n+  return result;\n+}\n \n-  type = _cpp_get_directive_token (pfile);\n-  if (type == CPP_OPEN_PAREN)\n+#define WARNING(msgid) do { cpp_warning(pfile, msgid); goto error; } while (0)\n+#define ERROR(msgid) do { cpp_error(pfile, msgid); goto error; } while (0)\n+#define ICE(msgid) do { cpp_ice(pfile, msgid); goto error; } while (0)\n+static int\n+do_assert (pfile)\n+     cpp_reader *pfile;\n+{\n+  struct answer *new_answer;\n+  cpp_hashnode *node;\n+  \n+  node = _cpp_parse_assertion (pfile, &new_answer);\n+  if (node)\n     {\n-      specific = 1;\n-      _cpp_init_toklist (&ans, NO_DUMMY_TOKEN);\n-\n-      if (_cpp_scan_until (pfile, &ans, CPP_CLOSE_PAREN)\n-\t  != CPP_CLOSE_PAREN)\n-\tERROR (\"missing close paren in #unassert\");\n-\n-      if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n-\tICE (\"impossible token, expecting ) in do_unassert\");\n+      new_answer->next = 0;\n+      new_answer->list.line = pfile->token_list.line;\n+      new_answer->list.file = pfile->token_list.file;\n \n-      type = _cpp_get_directive_token (pfile);\n+      if (node->type == T_ASSERTION)\n+\t{\n+\t  if (*find_answer (node, &new_answer->list))\n+\t    goto err;\n+\t  new_answer->next = node->value.answers;\n+\t}\n+      node->type = T_ASSERTION;\n+      node->value.answers = new_answer;\n     }\n+  return 0;\n \n-  if (type != CPP_VSPACE)\n-    ERROR (\"junk at end of #unassert\");\n-\n-  if (hp->type != T_ASSERTION)\n-    /* Not an error to #unassert something that isn't asserted.\n-       goto error to clean up.  */\n-    goto error;\n+ err:\n+  cpp_warning (pfile, \"\\\"%.*s\\\" re-asserted\",\n+\t       node->length - 1, node->name + 1);\n+  FREE_ANSWER (new_answer);\n+  return 0;\n+}\n \n-  if (specific)\n-    {\n-      /* Find this specific answer and remove it.  */\n-      struct predicate *o, *p;\n-\n-      for (p = NULL, o = hp->value.pred; o; p = o, o = o->next)\n-\tif (_cpp_equiv_toklists (&ans, &o->answer))\n-\t  {\n-\t    if (p)\n-\t      p->next = o->next;\n-\t    else\n-\t      hp->value.pred = o->next;\n-\n-\t    _cpp_free_toklist (&o->answer);\n-\t    free (o);\n-\t    break;\n-\t  }\n-    }\n-  else\n+static int\n+do_unassert (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_hashnode *node;\n+  struct answer *answer, *temp, *next;\n+  \n+  node = _cpp_parse_assertion (pfile, &answer);\n+  if (node)\n     {\n-      struct predicate *o, *p;\n-      for (o = hp->value.pred; o; o = p)\n+      /* It isn't an error to #unassert something that isn't asserted.  */\n+      if (node->type == T_ASSERTION)\n \t{\n-\t  p = o->next;\n-\t  _cpp_free_toklist ((cpp_toklist *) &o->answer);\n-\t  free (o);\n+\t  if (answer)\n+\t    {\n+\t      struct answer **p = find_answer (node, &answer->list);\n+\n+\t      temp = *p;\n+\t      if (temp)\n+\t\t{\n+\t\t  *p = temp->next;\n+\t\t  FREE_ANSWER (temp);\n+\t\t}\n+\t      if (node->value.answers == 0)\n+\t\tnode->type = T_VOID;\n+\t    }\n+\t  else\n+\t    {\n+\t      for (temp = node->value.answers; temp; temp = next)\n+\t\t{\n+\t\t  next = temp->next;\n+\t\t  FREE_ANSWER (temp);\n+\t\t}\n+\t      node->type = T_VOID;\n+\t    }\n \t}\n-      hp->value.pred = NULL;\n-    }\n \n-  if (hp->value.pred == NULL)\n-    hp->type = T_VOID;  /* Last answer for this predicate deleted.  */\n-\n- error:\n-  _cpp_skip_rest_of_line (pfile);\n-  pfile->no_macro_expand--;\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  if (specific)\n-    _cpp_free_toklist (&ans);\n+      if (answer)\n+\tFREE_ANSWER (answer);\n+    }\n   return 0;\n }\n \n@@ -1643,11 +1458,7 @@ cpp_define (pfile, str)\n       strcpy (&buf[count-4], \" 1\\n\");\n     }\n \n-  if (cpp_push_buffer (pfile, (U_CHAR *)buf, count - 1) != NULL)\n-    {\n-      do_define (pfile);\n-      cpp_pop_buffer (pfile);\n-    }\n+  _cpp_run_directive (pfile, &dtable[T_DEFINE], buf, count - 1);\n }\n \n /* Process MACRO as if it appeared as the body of an #undef.  */\n@@ -1656,17 +1467,7 @@ cpp_undef (pfile, macro)\n      cpp_reader *pfile;\n      const char *macro;\n {\n-  /* Copy the string so we can append a newline.  */\n-  size_t len = strlen (macro);\n-  char *buf = (char *) alloca (len + 2);\n-  memcpy (buf, macro, len);\n-  buf[len]     = '\\n';\n-  buf[len + 1] = '\\0';\n-  if (cpp_push_buffer (pfile, (U_CHAR *)buf, len + 1) != NULL)\n-    {\n-      do_undef (pfile);\n-      cpp_pop_buffer (pfile);\n-    }\n+  _cpp_run_directive (pfile, &dtable[T_UNDEF], macro, strlen (macro));\n }\n \n /* Process the string STR as if it appeared as the body of a #assert. */\n@@ -1675,11 +1476,7 @@ cpp_assert (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  if (cpp_push_buffer (pfile, (const U_CHAR *)str, strlen (str)) != NULL)\n-    {\n-      do_assert (pfile);\n-      cpp_pop_buffer (pfile);\n-    }\n+  _cpp_run_directive (pfile, &dtable[T_ASSERT], str, strlen (str));\n }\n \n /* Process STR as if it appeared as the body of an #unassert. */\n@@ -1688,11 +1485,7 @@ cpp_unassert (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  if (cpp_push_buffer (pfile, (const U_CHAR *)str, strlen (str)) != NULL)\n-    {\n-      do_unassert (pfile);\n-      cpp_pop_buffer (pfile);\n-    }\n+  _cpp_run_directive (pfile, &dtable[T_UNASSERT], str, strlen (str));\n }  \n \n /* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n@@ -1705,7 +1498,7 @@ cpp_defined (pfile, id, len)\n   cpp_hashnode *hp = cpp_lookup (pfile, id, len);\n   if (hp->type == T_POISON)\n     {\n-      cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n+      cpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", hp->name);\n       return 0;\n     }\n   return (hp->type != T_VOID);"}, {"sha": "2040f307d00d22ac72641e3ed30375e0f8af6010", "filename": "gcc/cpplib.h", "status": "modified", "additions": 99, "deletions": 113, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -108,7 +108,8 @@ typedef struct cpp_hashnode cpp_hashnode;\n   T(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n   T(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n   T(CPP_MAX,\t\t\">?\")\t\t\t\\\n-  C(CPP_OTHER,\t\t0)\t/* stray punctuation */ \\\n+  T(CPP_PLACEMARKER,\t\"\")\t/* Placemarker token.  */  \\\n+  C(CPP_OTHER,\t\t0)\t/* stray punctuation */    \\\n \\\n   I(CPP_NAME,\t\t0)\t/* word */\t\\\n   I(CPP_INT,\t\t0)\t/* 23 */\t\\\n@@ -121,15 +122,11 @@ typedef struct cpp_hashnode cpp_hashnode;\n \\\n   I(CPP_COMMENT,\t0)\t/* Only if output comments.  */ \\\n   N(CPP_MACRO_ARG,      0)\t/* Macro argument.  */          \\\n-  N(CPP_SUBLIST,        0)\t/* Sublist.  */                 \\\n   N(CPP_EOF,\t\t0)\t/* End of file.  */\t\t\\\n-  N(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\t\\\n+  I(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\t\\\n \\\n   /* Obsolete - will be removed when no code uses them still.  */\t\\\n-  T(CPP_VSPACE,\t\t\"\\n\")\t/* End of line.  */\t\t\\\n-  N(CPP_HSPACE,\t\t0)\t/* Horizontal white space.  */\t\\\n-  N(CPP_DIRECTIVE,\t0)\t/* #define and the like */\t\\\n-  N(CPP_MACRO,\t\t0)\t/* Like a NAME, but expanded.  */\n+  T(CPP_VSPACE,\t\t\"\\n\")\t/* End of line.  */\n \n #define T(e, s) e,\n #define I(e, s) e,\n@@ -154,49 +151,42 @@ struct cpp_name\n   const unsigned char *text;\n };\n \n-/* Accessor macros for token lists - all expect you have a\n-   list and an index.  */\n-\n-#define TOK_TYPE(l_, i_)   ((l_)->tokens[i_].type)\n-#define TOK_FLAGS(l_, i_)  ((l_)->tokens[i_].flags)\n-#define TOK_AUX(l_, i_)    ((l_)->tokens[i_].aux)\n-#define TOK_COL(l_, i_)    ((l_)->tokens[i_].col)\n-#define TOK_INT(l_, i_)    ((l_)->tokens[i_].val.integer)\n-#define TOK_NAME(l_, i_)   ((l_)->tokens[i_].val.name.text)\n-#define TOK_LEN(l_, i_)    ((l_)->tokens[i_].val.name.len)\n-\n-#define TOK_PREV_WHITE(l_, i_) (TOK_FLAGS(l_, i_) & PREV_WHITESPACE)\n-\n /* Flags for the cpp_token structure.  */\n-#define PREV_WHITESPACE     1\t/* If whitespace before this token.  */\n-#define BOL\t\t    2   /* Beginning of line.  */\n-#define DIGRAPH             4\t/* If it was a digraph.  */\n-#define UNSIGNED_INT        8   /* If int preprocessing token unsigned.  */\n+#define PREV_WHITE\t(1 << 0) /* If whitespace before this token.  */\n+#define BOL\t\t(1 << 1) /* Beginning of logical line.  */\n+#define DIGRAPH         (1 << 2) /* If it was a digraph.  */\n+#define STRINGIFY_ARG\t(1 << 3) /* If macro argument to be stringified.  */\n+#define PASTE_LEFT\t(1 << 4) /* If on LHS of a ## operator.  */\n+#define PASTED\t\t(1 << 5) /* The result of a ## operator.  */\n+#define GNU_VARARGS\t(1 << 6) /* GNU ## kludge.   */\n \n /* A preprocessing token.  This has been carefully packed and should\n-   occupy 16 bytes on both 32- and 64-bit hosts.  */\n+   occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n struct cpp_token\n {\n-  unsigned short col;\t\t\t/* starting column of this token */\n-  ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* node type */\n-  unsigned char flags;\t\t\t/* flags - see above */\n-  unsigned int aux;\t\t\t/* CPP_OTHER character.  Hash of a\n-\t\t\t\t\t   NAME, or something - see uses\n-\t\t\t\t\t   in the code */\n+  unsigned int line;\t\t/* starting line number of this token */\n+  unsigned short col;\t\t/* starting column of this token */\n+  ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n+  unsigned char flags;\t\t/* flags - see above */\n+\n   union\n   {\n-    struct cpp_name name;\t\t/* a string */\n-    HOST_WIDEST_INT integer;\t\t/* an integer */\n+    HOST_WIDEST_INT integer;\t/* an integer */\n+    struct cpp_name name;\t/* a string */\n+    unsigned int aux;\t\t/* argument no. for a CPP_MACRO_ARG, or\n+\t\t\t\t   character represented by CPP_OTHER.  */\n   } val;\n };\n \n-/* General flags.  */\n-#define LIST_OFFSET    (1 << 0)\n-\n-/* Directive flags.  */\n-#define SYNTAX_INCLUDE (1 << 8)\n+/* cpp_toklist flags.  */\n+#define LIST_OFFSET     (1 << 0)\n+#define VAR_ARGS\t(1 << 1)\n+#define BEG_OF_FILE\t(1 << 2)\n \n-typedef int (*directive_handler) PARAMS ((cpp_reader *));\n+struct directive;\t\t/* These are deliberately incomplete.  */\n+struct answer;\n+struct macro_args;\n+struct cpp_context;\n \n struct cpp_toklist\n {\n@@ -208,11 +198,15 @@ struct cpp_toklist\n   unsigned int name_used;\t/* _bytes_ used */\n   unsigned int name_cap;\t/* _bytes_ allocated */\n \n+  /* If the list represents a directive, this points to it.  */\n+  const struct directive *directive;\n+\n+  const char *file;\t\t/* in file name */\n   unsigned int line;\t\t/* starting line number */\n \n-  /* The handler to call after lexing the rest of this line.\n-     -1 for none */\n-  short dirno;\n+  unsigned short params_len;\t/* length of macro parameter names.  */\n+\n+  short int paramc;\t\t/* no. of macro params (-1 = obj-like).  */\n \n   /* Per-list flags, see above */\n   unsigned short flags;\n@@ -224,53 +218,33 @@ struct cpp_buffer\n   const unsigned char *rlimit; /* end of valid data */\n   const unsigned char *buf;\t /* entire buffer */\n   const unsigned char *line_base; /* start of current line */\n-  const unsigned char *mark;  /* Saved position for lengthy backtrack. */\n \n   struct cpp_buffer *prev;\n \n   /* Filename specified with #line command.  */\n   const char *nominal_fname;\n+\n   /* Actual directory of this file, used only for \"\" includes */\n   struct file_name_list *actual_dir;\n \n   /* Pointer into the include table.  Used for include_next and\n      to record control macros. */\n   struct include_file *inc;\n \n-  /* If the buffer is the expansion of a macro, this points to the\n-     macro's hash table entry.  */\n-  struct cpp_hashnode *macro;\n-\n   /* Value of if_stack at start of this file.\n      Used to prohibit unmatched #endif (etc) in an include file.  */\n   struct if_stack *if_stack;\n \n   /* Line number at line_base (above). */\n   unsigned int lineno;\n \n-  /* True if buffer contains escape sequences.\n-     Currently there are two kinds:\n-     \"\\r-\" means following identifier should not be macro-expanded.\n-     \"\\r \" means a token-separator.  This turns into \" \" in final output\n-          if not stringizing and needed to separate tokens; otherwise nothing.\n-     Any other two-character sequence beginning with \\r is an error.\n-\n-     If this is NOT set, then \\r is a one-character escape meaning backslash\n-     newline.  This is guaranteed not to occur in the middle of a token.\n-     The two interpretations of \\r do not conflict, because the two-character\n-     escapes are used only in macro buffers, and backslash-newline is removed\n-     from macro expansion text in collect_expansion and/or macarg.  */\n-  char has_escapes;\n-\n   /* True if we have already warned about C++ comments in this file.\n      The warning happens only for C89 extended mode with -pedantic on,\n      or for -Wtraditional, and only once per file (otherwise it would\n      be far too noisy).  */\n   char warned_cplusplus_comments;\n \n-  /* In a file buffer, true if this buffer's data is mmapped\n-     (currently never the case).  In a macro buffer, true if this\n-     buffer's data must be freed.  */\n+  /* True if this buffer's data is mmapped.  */\n   char mapped;\n };\n \n@@ -354,7 +328,7 @@ struct cpp_options\n   /* Nonzero means don't copy comments into the output file.  */\n   unsigned char discard_comments;\n \n-  /* Nonzero means process the ANSI trigraph sequences.  */\n+  /* Nonzero means process the ISO trigraph sequences.  */\n   unsigned char trigraphs;\n \n   /* Nonzero means print the names of included files rather than the\n@@ -396,6 +370,10 @@ struct cpp_options\n      with the # indented from the beginning of the line.  */\n   unsigned char warn_traditional;\n \n+  /* Nonzero means warn if ## is applied to two tokens that cannot be\n+     pasted together.  */\n+  unsigned char warn_paste;\n+\n   /* Nonzero means turn warnings into errors.  */\n   unsigned char warnings_are_errors;\n \n@@ -417,7 +395,7 @@ struct cpp_options\n   /* Zero means dollar signs are punctuation. */\n   unsigned char dollars_in_ident;\n \n-  /* Nonzero means try to imitate old fashioned non-ANSI preprocessor.  */\n+  /* Nonzero means try to imitate old fashioned non-ISO preprocessor.  */\n   unsigned char traditional;\n \n   /* Nonzero means warn if undefined identifiers are evaluated in an #if.  */\n@@ -460,19 +438,18 @@ struct cpp_options\n   unsigned char show_column;\n };\n \n-\n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n    Applying cpp_get_token repeatedly yields a stream of pre-processor\n    tokens.  Usually, there is only one cpp_reader object active. */\n \n struct cpp_reader\n {\n+  /* HACK FIXME.  Maybe make into cpp_printer printer later.  */\n+  cpp_printer *printer;\n+\n   /* Top of buffer stack.  */\n   cpp_buffer *buffer;\n \n-  /* Token list used by get_directive_token.  */\n-  cpp_toklist directbuf;\n-\n   /* A buffer used for both for cpp_get_token's output, and also internally. */\n   unsigned char *token_buffer;\n   /* Allocated size of token_buffer.  CPP_RESERVE allocates space.  */\n@@ -483,8 +460,9 @@ struct cpp_reader\n   /* Error counter for exit code */\n   unsigned int errors;\n \n-  /* Line where a newline was first seen in a string constant.  */\n+  /* Line and column where a newline was first seen in a string constant.  */\n   unsigned int multiline_string_line;\n+  unsigned int multiline_string_column;\n \n   /* Current depth in #include directives that use <...>.  */\n   unsigned int system_include_depth;\n@@ -509,19 +487,46 @@ struct cpp_reader\n      for include files.  (Altered as we get more of them.)  */\n   unsigned int max_include_len;\n \n+  /* Potential controlling macro for the current buffer.  This is only\n+     live between the #endif and the end of file, and there can only\n+     be one at a time, so it is per-reader not per-buffer.  */\n   const cpp_hashnode *potential_control_macro;\n \n   /* Token column position adjustment owing to tabs in whitespace.  */\n   unsigned int col_adjust;\n \n+  /* Token list used to store logical lines with new lexer.  */\n+  cpp_toklist token_list;\n+\n+  /* Temporary token store.  */\n+  cpp_token **temp_tokens;\n+  unsigned int temp_cap;\n+  unsigned int temp_alloced;\n+  unsigned int temp_used;\n+\n+  /* Date and time tokens.  Calculated together if either is requested.  */\n+  cpp_token *date;\n+  cpp_token *time;\n+\n+  /* The # of a the current directive. It may not be first in line if\n+     we append, and finding it is tedious.  */\n+  const cpp_token *first_directive_token;\n+\n+  /* Context stack.  Used for macro expansion and for determining\n+     which macros are disabled.  */\n+  unsigned int context_cap;\n+  unsigned int cur_context;\n+  unsigned int no_expand_level;\n+  unsigned int paste_level;\n+  struct cpp_context *contexts;\n+\n+  /* Current arguments when scanning arguments. Used for pointer\n+     fix-up.  */\n+  struct macro_args *args;\n+\n   /* Buffer of -M output.  */\n   struct deps *deps;\n \n-  /* A buffer used only by read_and_prescan (in cppfiles.c), which is\n-     allocated once per cpp_reader object to keep it off the stack.  */\n-  unsigned char *input_buffer;\n-  size_t input_buffer_len;\n-\n   /* User visible options.  */\n   struct cpp_options opts;\n \n@@ -532,31 +537,24 @@ struct cpp_reader\n   /* If non-zero, macros are not expanded.  */\n   unsigned char no_macro_expand;\n \n-  /* If non-zero, directives cause a hard error.  Used when parsing\n-     macro arguments.  */\n-  unsigned char no_directives;\n-\n   /* We're printed a warning recommending against using #import.  */\n   unsigned char import_warning;\n \n-  /* If true, characters between '<' and '>' are a single (string) token.  */\n-  unsigned char parsing_include_directive;\n-\n-  /* True if escape sequences (as described for has_escapes in\n-     parse_buffer) should be emitted.  */\n-  unsigned char output_escapes;\n-\n-  /* 0: Have seen non-white-space on this line.\n-     1: Only seen white space so far on this line.\n-     2: Only seen white space so far in this file.  */\n-  unsigned char only_seen_white;\n-\n   /* True after cpp_start_read completes.  Used to inhibit some\n      warnings while parsing the command line.  */\n   unsigned char done_initializing;\n \n   /* True if we are skipping a failed conditional group.  */\n   unsigned char skipping;\n+\n+  /* Do we need to save paramter spellings.  */\n+  unsigned char save_parameter_spellings;\n+\n+  /* If we're in lex_line.  */\n+  unsigned char in_lex_line;\n+\n+  /* True if output_line_command needs to output a newline.  */\n+  unsigned char need_newline;\n };\n \n /* struct cpp_printer encapsulates state used to convert the stream of\n@@ -611,13 +609,8 @@ enum node_type\n   T_INCLUDE_LEVEL, /* `__INCLUDE_LEVEL__' */\n   T_TIME,\t   /* `__TIME__' */\n   T_STDC,\t   /* `__STDC__' */\n-  T_CONST,\t   /* Constant string, used by `__SIZE_TYPE__' etc */\n-  T_XCONST,\t   /* Ditto, but the string is malloced memory */\n   T_POISON,\t   /* poisoned identifier */\n-  T_MACRO,\t   /* object-like macro */\n-  T_FMACRO,\t   /* function-like macro */\n-  T_IDENTITY,\t   /* macro defined to itself */\n-  T_EMPTY,\t   /* macro defined to nothing */\n+  T_MACRO,\t   /* a macro, either object-like or function-like */\n   T_ASSERTION\t   /* predicate for #assert */\n };\n \n@@ -634,35 +627,28 @@ struct cpp_hashnode\n   ENUM_BITFIELD(node_type) type : 8;\t/* node type */\n   char disabled;\t\t\t/* macro turned off for rescan? */\n \n-  union {\n-    const unsigned char *cpval;\t\t/* some predefined macros */\n-    const struct object_defn *odefn;\t/* #define foo bar */\n-    const struct funct_defn *fdefn;\t/* #define foo(x) bar(x) */\n-    struct predicate *pred;\t\t/* #assert */\n+  union\n+  {\n+    const cpp_toklist *expansion;\t/* a macro's replacement list.  */\n+    struct answer *answers;\t\t/* answers to an assertion.  */\n   } value;\n \n   union tree_node *fe_value;\t\t/* front end value */\n \n   const unsigned char name[1];\t\t/* name[length] */\n };\n \n-\n-\n-extern void _cpp_lex_file PARAMS((cpp_reader *));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n-extern enum cpp_ttype cpp_get_token PARAMS ((cpp_reader *));\n-extern enum cpp_ttype cpp_get_non_space_token PARAMS ((cpp_reader *));\n-\n extern void cpp_reader_init PARAMS ((cpp_reader *));\n extern cpp_printer *cpp_printer_init PARAMS ((cpp_reader *, cpp_printer *));\n extern int cpp_start_read PARAMS ((cpp_reader *, cpp_printer *, const char *));\n-extern void cpp_output_tokens PARAMS ((cpp_reader *, cpp_printer *));\n-extern void cpp_output_list PARAMS ((cpp_reader *, cpp_printer *,\n-\t\t\t\t     const cpp_toklist *));\n+extern void cpp_output_tokens PARAMS ((cpp_reader *, cpp_printer *,\n+\t\t\t\t       unsigned int));\n extern void cpp_finish PARAMS ((cpp_reader *, cpp_printer *));\n extern void cpp_cleanup PARAMS ((cpp_reader *));\n \n-extern cpp_buffer *cpp_file_buffer PARAMS((cpp_reader *));\n+extern const cpp_token *cpp_get_token PARAMS ((cpp_reader *));\n+\n extern void cpp_define PARAMS ((cpp_reader *, const char *));\n extern void cpp_assert PARAMS ((cpp_reader *, const char *));\n extern void cpp_undef  PARAMS ((cpp_reader *, const char *));"}, {"sha": "5239f8d74d57058bfdc708c806ef05298e409d3b", "filename": "gcc/cppmain.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -68,6 +68,7 @@ main (argc, argv)\n   print = cpp_printer_init (pfile, &parse_out);\n   if (! print)\n     return (FATAL_EXIT_CODE);\n+  pfile->printer = print;\n \n   if (! cpp_start_read (pfile, print, CPP_OPTION (pfile, in_fname)))\n     return (FATAL_EXIT_CODE);"}, {"sha": "6ff458a1102018936bbd5e1716268df83c5cbed0", "filename": "gcc/fix-header.c", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -432,8 +432,6 @@ write_lbrac ()\n struct partial_proto\n {\n   struct partial_proto *next;\n-  char *fname;\t/* name of function */\n-  char *rtype;\t/* return type */\n   struct fn_decl *fn;\n   int line_seen;\n };\n@@ -497,15 +495,13 @@ recognized_macro (fname)\n }\n \n void\n-recognized_extern (name, name_length, type, type_length)\n-     const char *name;\n-     const char *type ATTRIBUTE_UNUSED;\n-     int name_length, type_length ATTRIBUTE_UNUSED;\n+recognized_extern (name)\n+     const cpp_token *name;\n {\n   switch (special_file_handling)\n     {\n     case errno_h:\n-      if (name_length == 5 && strncmp (name, \"errno\", 5) == 0 && !seen_errno)\n+      if (!cpp_idcmp (name->val.name.text, name->val.name.len, \"errno\"))\n \tseen_errno = 1, required_other--;\n       break;\n \n@@ -515,25 +511,17 @@ recognized_extern (name, name_length, type, type_length)\n }\n \n /* Called by scan_decls if it saw a function definition for a function\n-   named FNAME, with return type RTYPE, and argument list ARGS,\n-   in source file FILE_SEEN on line LINE_SEEN.\n-   KIND is 'I' for an inline function;\n-   'F' if a normal function declaration preceded by 'extern \"C\"'\n-   (or nested inside 'extern \"C\"' braces); or\n+   named FNAME, in source file FILE_SEEN on line LINE_SEEN.  KIND is\n+   'I' for an inline function; 'F' if a normal function declaration\n+   preceded by 'extern \"C\"' (or nested inside 'extern \"C\"' braces); or\n    'f' for other function declarations.  */\n \n void\n-recognized_function (fname, fname_length,\n-\t\t     kind, rtype, rtype_length,\n-\t\t     have_arg_list, file_seen, line_seen)\n-     const char *fname;\n-     int fname_length;\n+recognized_function (fname, kind, have_arg_list, file_seen)\n+     const cpp_token *fname;\n      int kind; /* One of 'f' 'F' or 'I' */\n-     const char *rtype;\n-     int rtype_length;\n      int have_arg_list;\n      const char *file_seen;\n-     int line_seen;\n {\n   struct partial_proto *partial;\n   int i;\n@@ -543,7 +531,8 @@ recognized_function (fname, fname_length,\n     missing_extern_C_count++;\n #endif\n \n-  fn = lookup_std_proto (fname, fname_length);\n+  fn = lookup_std_proto ((const char *)fname->val.name.text,\n+\t\t\t fname->val.name.len);\n \n   /* Remove the function from the list of required function.  */\n   if (fn)\n@@ -577,20 +566,15 @@ recognized_function (fname, fname_length,\n   partial_count++;\n   partial = (struct partial_proto *)\n     obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));\n-  partial->fname = obstack_alloc (&scan_file_obstack, fname_length + 1);\n-  bcopy (fname, partial->fname, fname_length);\n-  partial->fname[fname_length] = 0;\n-  partial->rtype = obstack_alloc (&scan_file_obstack, rtype_length + 1);\n-  sprintf (partial->rtype, \"%.*s\", rtype_length, rtype);\n-  partial->line_seen = line_seen;\n+  partial->line_seen = fname->line;\n   partial->fn = fn;\n   fn->partial = partial;\n   partial->next = partial_proto_list;\n   partial_proto_list = partial;\n   if (verbose)\n     {\n       fprintf (stderr, \"(%s: %s non-prototype function declaration.)\\n\",\n-\t       inc_filename, partial->fname);\n+\t       inc_filename, fn->fname);\n     }\n }\n \n@@ -646,19 +630,12 @@ read_scan_file (in_fname, argc, argv)\n   for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)\n     check_macro_names (&scan_in, cur_symbols->names);\n \n-  if (verbose && (scan_in.errors + warnings) > 0)\n-    fprintf (stderr, \"(%s: %d errors and %d warnings from cpp)\\n\",\n-\t     inc_filename, scan_in.errors, warnings);\n-  if (scan_in.errors)\n-    exit (SUCCESS_EXIT_CODE);\n-\n   /* Traditionally, getc and putc are defined in terms of _filbuf and _flsbuf.\n      If so, those functions are also required.  */\n   if (special_file_handling == stdio_h\n       && (fn = lookup_std_proto (\"_filbuf\", 7)) != NULL)\n     {\n       static const unsigned char getchar_call[] = \"getchar();\";\n-      int old_written = CPP_WRITTEN (&scan_in);\n       int seen_filbuf = 0;\n       cpp_buffer *buf = CPP_BUFFER (&scan_in);\n       if (cpp_push_buffer (&scan_in, getchar_call,\n@@ -668,14 +645,17 @@ read_scan_file (in_fname, argc, argv)\n       /* Scan the macro expansion of \"getchar();\".  */\n       for (;;)\n \t{\n-\t  enum cpp_ttype token = cpp_get_token (&scan_in);\n-\t  int length = CPP_WRITTEN (&scan_in) - old_written;\n-\t  unsigned char *id = scan_in.token_buffer + old_written;\n-\t  \n-\t  CPP_SET_WRITTEN (&scan_in, old_written);\n-\t  if (token == CPP_EOF && CPP_BUFFER (&scan_in) == buf)\n-\t    break;\n-\t  if (token == CPP_NAME && cpp_idcmp (id, length, \"_filbuf\") == 0)\n+\t  const cpp_token *t = cpp_get_token (&scan_in);\n+\n+\t  if (t->type == CPP_EOF)\n+\t    {\n+\t      cpp_pop_buffer (&scan_in);\n+\t      if (CPP_BUFFER (&scan_in) == buf)\n+\t\tbreak;\n+\t    }\n+\t  else if (t->type == CPP_NAME && cpp_idcmp (t->val.name.text,\n+\t\t\t\t\t\t     t->val.name.len,\n+\t\t\t\t\t\t     \"_filbuf\") == 0)\n \t    seen_filbuf++;\n \t}\n       if (seen_filbuf)\n@@ -1030,8 +1010,6 @@ check_protection (ifndef_line, endif_line)\n \t}\n       else if (!strcmp (buf.base, \"define\"))\n \t{\n-\t  if (if_nesting != 1)\n-\t    goto skip_to_eol;\n \t  c = inf_skip_spaces (c);\n \t  c = inf_scan_ident (&buf, c);\n \t  if (buf.base[0] > 0 && strcmp (buf.base, protect_name) == 0)"}, {"sha": "969b208df5b2f11b24c328ddcc1060676b68851d", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 62, "deletions": 97, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -45,7 +45,7 @@ skip_to_closing_brace (pfile)\n   int nesting = 1;\n   for (;;)\n     {\n-      enum cpp_ttype token = cpp_get_token (pfile);\n+      enum cpp_ttype token = cpp_get_token (pfile)->type;\n       if (token == CPP_EOF)\n \tbreak;\n       if (token == CPP_OPEN_BRACE)\n@@ -84,24 +84,17 @@ scan_decls (pfile, argc, argv)\n      char **argv ATTRIBUTE_UNUSED;\n {\n   int saw_extern, saw_inline;\n-  int start_written;\n-  /* If declarator_start is non-zero, it marks the start of the current\n-     declarator.  If it is zero, we are either still parsing the\n-     decl-specs, or prev_id_start marks the start of the declarator.  */\n-  int declarator_start;\n-  int prev_id_start, prev_id_end = 0;\n-  enum cpp_ttype token;\n+  const cpp_token *prev_id;\n+  const cpp_token *token;\n \n  new_statement:\n-  CPP_SET_WRITTEN (pfile, 0);\n-  start_written = 0;\n   token = cpp_get_token (pfile);\n \n  handle_statement:\n   current_extern_C = 0;\n   saw_extern = 0;\n   saw_inline = 0;\n-  if (token == CPP_OPEN_BRACE)\n+  if (token->type == CPP_OPEN_BRACE)\n     {\n       /* Pop an 'extern \"C\"' nesting level, if appropriate.  */\n       if (extern_C_braces_length\n@@ -110,120 +103,112 @@ scan_decls (pfile, argc, argv)\n       brace_nesting--;\n       goto new_statement;\n     }\n-  if (token == CPP_OPEN_BRACE)\n+  if (token->type == CPP_OPEN_BRACE)\n     {\n       brace_nesting++;\n       goto new_statement;\n     }\n-  if (token == CPP_EOF)\n+  if (token->type == CPP_EOF)\n     {\n+      cpp_pop_buffer (pfile);\n       if (CPP_BUFFER (pfile) == NULL)\n \treturn 0;\n-      else\n-\tgoto new_statement;\n+\n+      goto new_statement;\n     }\n-  if (token == CPP_SEMICOLON)\n+  if (token->type == CPP_SEMICOLON)\n     goto new_statement;\n-  if (token != CPP_NAME)\n+  if (token->type != CPP_NAME)\n     goto new_statement;\n \n-  prev_id_start = 0;\n-  declarator_start = 0;\n+  prev_id = 0;\n   for (;;)\n     {\n-      switch (token)\n+      switch (token->type)\n \t{\n+\tdefault:\n+\t  goto handle_statement;\n+\tcase CPP_MULT:\n+\tcase CPP_AND:\n+\tcase CPP_PLACEMARKER:\n+\t  /* skip */\n+\t  break;\n+\n+\tcase CPP_COMMA:\n+\tcase CPP_SEMICOLON:\n+\t  if (prev_id && saw_extern)\n+\t    {\n+\t      recognized_extern (prev_id);\n+\t    }\n+\t  if (token->type == CPP_COMMA)\n+\t    break;\n+\t  /* ... fall through ...  */\n+\tcase CPP_OPEN_BRACE:  case CPP_CLOSE_BRACE:\n+\t  goto new_statement;\n+\t  \n+\tcase CPP_EOF:\n+\t  cpp_pop_buffer (pfile);\n+\t  if (CPP_BUFFER (pfile) == NULL)\n+\t    return 0;\n+\t  break;\n+\n \tcase CPP_OPEN_PAREN:\n \t  /* Looks like this is the start of a formal parameter list.  */\n-\t  if (prev_id_start)\n+\t  if (prev_id)\n \t    {\n \t      int nesting = 1;\n \t      int have_arg_list = 0;\n-\t      cpp_buffer *fbuf = cpp_file_buffer (pfile);\n-\t      unsigned int func_lineno = CPP_BUF_LINE (fbuf);\n \t      for (;;)\n \t\t{\n \t\t  token = cpp_get_token (pfile);\n-\t\t  if (token == CPP_OPEN_PAREN)\n+\t\t  if (token->type == CPP_OPEN_PAREN)\n \t\t    nesting++;\n-\t\t  else if (token == CPP_CLOSE_PAREN)\n+\t\t  else if (token->type == CPP_CLOSE_PAREN)\n \t\t    {\n \t\t      nesting--;\n \t\t      if (nesting == 0)\n \t\t\tbreak;\n \t\t    }\n-\t\t  else if (token == CPP_EOF)\n+\t\t  else if (token->type == CPP_EOF)\n \t\t    break;\n-\t\t  else if (token == CPP_NAME || token == CPP_ELLIPSIS)\n+\t\t  else if (token->type == CPP_NAME\n+\t\t\t   || token->type == CPP_ELLIPSIS)\n \t\t    have_arg_list = 1;\n \t\t}\n-\t      recognized_function (pfile->token_buffer + prev_id_start,\n-\t\t\t\t   prev_id_end - prev_id_start,\n+\t      recognized_function (prev_id, \n \t\t\t\t   (saw_inline ? 'I'\n \t\t\t\t    : in_extern_C_brace || current_extern_C\n-\t\t\t\t    ? 'F' : 'f'),\n-\t\t\t\t   pfile->token_buffer, prev_id_start,\n-\t\t\t\t   have_arg_list,\n-\t\t\t\t   fbuf->nominal_fname, func_lineno);\n-\t      token = cpp_get_non_space_token (pfile);\n-\t      if (token == CPP_OPEN_BRACE)\n+\t\t\t\t    ? 'F' : 'f'), have_arg_list,\n+\t\t\t\t   CPP_BUFFER (pfile)->nominal_fname);\n+\t      token = cpp_get_token (pfile);\n+\t      if (token->type == CPP_OPEN_BRACE)\n \t\t{\n \t\t  /* skip body of (normally) inline function */\n \t\t  skip_to_closing_brace (pfile);\n \t\t  goto new_statement;\n \t\t}\n-\t      goto maybe_handle_comma;\n+\t      if (token->type == CPP_SEMICOLON)\n+\t\tgoto new_statement;\n \t    }\n \t  break;\n-\tcase CPP_OTHER:\n-\t  if (CPP_WRITTEN (pfile) == (size_t) start_written + 1\n-\t      && (CPP_PWRITTEN (pfile)[-1] == '*'\n-\t\t  || CPP_PWRITTEN (pfile)[-1] == '&'))\n-\t    declarator_start = start_written;\n-\t  else\n-\t    goto handle_statement;\n-\t  break;\n-\tcase CPP_COMMA:\n-\tcase CPP_SEMICOLON:\n-\t  if (prev_id_start && saw_extern)\n-\t    {\n-\t      recognized_extern (pfile->token_buffer + prev_id_start,\n-\t\t\t\t prev_id_end - prev_id_start,\n-\t\t\t\t pfile->token_buffer,\n-\t\t\t\t prev_id_start);\n-\t    }\n-\t  /* ... fall through ...  */\n-\tmaybe_handle_comma:\n-\t  if (token != CPP_COMMA)\n-\t    goto new_statement;\n-\n-\t  /* Handle multiple declarators in a single declaration,\n-\t     as in:  extern char *strcpy (), *strcat (), ... ; */\n-\t  if (declarator_start == 0)\n-\t    declarator_start = prev_id_start;\n-\t  CPP_SET_WRITTEN (pfile, declarator_start);\n-\t  break;\n \tcase CPP_NAME:\n \t  /* \"inline\" and \"extern\" are recognized but skipped */\n-\t  if (!cpp_idcmp (pfile->token_buffer,\n-\t\t\t  CPP_WRITTEN (pfile), \"inline\"))\n+\t  if (!cpp_idcmp (token->val.name.text, token->val.name.len, \"inline\"))\n \t    {\n \t      saw_inline = 1;\n-\t      CPP_SET_WRITTEN (pfile, start_written);\n \t    }\n-\t  else if (!cpp_idcmp (pfile->token_buffer,\n-\t\t\t       CPP_WRITTEN (pfile), \"extern\"))\n+\t  else if (!cpp_idcmp (token->val.name.text,\n+\t\t\t       token->val.name.len, \"extern\"))\n \t    {\n \t      saw_extern = 1;\n-\t      CPP_SET_WRITTEN (pfile, start_written);\n-\t      token = cpp_get_non_space_token (pfile);\n-\t      if (token == CPP_STRING\n-\t\t  && strcmp (pfile->token_buffer, \"\\\"C\\\"\") == 0)\n+\t      token = cpp_get_token (pfile);\n+\t      if (token->type == CPP_STRING\n+\t\t  && !cpp_idcmp (token->val.name.text,\n+\t\t\t\t token->val.name.len, \"C\"))\n \t\t{\n-\t\t  CPP_SET_WRITTEN (pfile, start_written);\n \t\t  current_extern_C = 1;\n-\t\t  token = cpp_get_non_space_token (pfile);\n-\t\t  if (token == CPP_OPEN_BRACE)\n+\t\t  token = cpp_get_token (pfile);\n+\t\t  if (token->type == CPP_OPEN_BRACE)\n \t\t    {\n \t\t      brace_nesting++;\n \t\t      extern_C_braces[extern_C_braces_length++]\n@@ -236,29 +221,9 @@ scan_decls (pfile, argc, argv)\n \t      break;\n \t    }\n \t  /* This may be the name of a variable or function.  */\n-\t  prev_id_start = start_written;\n-\t  prev_id_end = CPP_WRITTEN (pfile);\n-\t  break;\n-\n-\tcase CPP_OPEN_BRACE:  case CPP_CLOSE_BRACE:  case CPP_DIRECTIVE:\n-\t  goto new_statement;  /* handle_statement? */\n-\t  \n-\tcase CPP_EOF:\n-\t  if (CPP_BUFFER (pfile) == NULL)\n-\t    return 0;\n-\t  /* else fall through */\n-\n-\tcase CPP_HSPACE:  case CPP_VSPACE:  case CPP_COMMENT:\n-\t  /* Skip initial white space.  */\n-\t  if (start_written == 0)\n-\t    CPP_SET_WRITTEN (pfile, 0);\n+\t  prev_id = token;\n \t  break;\n-\n-\t default:\n-\t  prev_id_start = 0;\n \t}\n-\n-      start_written = CPP_WRITTEN (pfile);\n       token = cpp_get_token (pfile);\n     }\n }"}, {"sha": "e86109603a4744185a6bbae4df680c670700a5e4", "filename": "gcc/scan.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -50,6 +50,8 @@ struct fn_decl\n   struct partial_proto *partial;\n };\n \n+struct cpp_token;\n+\n extern int lineno;\n extern void sstring_append _PARAMS((sstring *, sstring *));\n extern void make_sstring_space _PARAMS((sstring *, int));\n@@ -58,8 +60,9 @@ extern int scan_ident _PARAMS((FILE *, sstring *, int));\n extern int scan_string _PARAMS((FILE *, sstring *, int));\n extern int read_upto _PARAMS((FILE *, sstring *, int));\n extern unsigned long hash _PARAMS((const char *));\n-extern void recognized_function _PARAMS((const char *, int, int, const char *, int, int, const char *, int));\n-extern void recognized_extern _PARAMS((const char *, int, const char *, int));\n+extern void recognized_function _PARAMS((const struct cpp_token *, int, int,\n+\t\t\t\t\t const char *));\n+extern void recognized_extern _PARAMS((const struct cpp_token *));\n extern unsigned int hashstr _PARAMS((const char *, unsigned int));\n \n struct cpp_reader;"}, {"sha": "1231daba1abf858d1e059f3cd37d617b7db16235", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -1,3 +1,16 @@\n+2000-07-03  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* testsuite/gcc.dg/cpp/19951025-1.c: Adjust regexps.\n+\t* testsuite/gcc.dg/cpp/19990703-1.c: Likewise.\n+\t* testsuite/gcc.dg/cpp/20000625-1.c: Likewise.\n+\t* testsuite/gcc.dg/cpp/20000625-2.c: Likewise.\n+\n+\t* testsuite/gcc.dg/cpp/macro1.c,\n+\ttestsuite/gcc.dg/cpp/paste1.c, testsuite/gcc.dg/cpp/paste2.c,\n+\ttestsuite/gcc.dg/cpp/paste3.c, testsuite/gcc.dg/cpp/paste4.c,\n+\ttestsuite/gcc.dg/cpp/strify1.c,\n+\ttestsuite/gcc.dg/cpp/strify2.c: New tests.\n+\n 2000-07-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/20000703-1.c: New test."}, {"sha": "283b5f53f1abaaee40c164ebcdc31aee6f6ecf9b", "filename": "gcc/testsuite/gcc.dg/cpp/19951025-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -1,4 +1,4 @@\n /* { dg-do preprocess } */\n /* { dg-error \"include expects\" \"\" { target *-*-* } 4 } */\n-/* { dg-warning \"no newline\" \"\" { target *-*-* } 5 } */\n+/* { dg-error \"newline at end\" \"\" { target *-*-* } 4 } */\n #include /\\"}, {"sha": "c3ac2330055bc736e5f3b502a2e07b177fb58190", "filename": "gcc/testsuite/gcc.dg/cpp/19990703-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19990703-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19990703-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19990703-1.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -14,7 +14,7 @@\n int\n main(void)\n {\n-    char *x = SP1(0,MZ);\n+    char *x = SP1(0,MZ);  /* { dg-warning \"valid preprocessing token\" \"\" } */\n     char *y = \"0-0\";  /* should be the expansion of SP1(0,MZ) */\n \n     if(strcmp(x, y))"}, {"sha": "ddfdb99459222953047c7e876c75efae4b3285c1", "filename": "gcc/testsuite/gcc.dg/cpp/20000625-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F20000625-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F20000625-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F20000625-1.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -11,6 +11,6 @@ main(void)\n {\n   goto socket;\n \n-  ENTRY(socket)\n+  ENTRY(socket) /* { dg-warning \"valid preprocessing token\" \"\" } */\n     return 0;\n }"}, {"sha": "e0dd35c45954cfd55ec0977850eb0af76d6c44d6", "filename": "gcc/testsuite/gcc.dg/cpp/20000625-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F20000625-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F20000625-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F20000625-2.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -7,6 +7,7 @@\n #define xstr(x) #x\n \n const char a[] = str(symbol_version(getrlimit, GLIBC_2.0));\n+/* { dg-warning \"valid preprocessing token\" \"\" { target *-*-* } 9 } */\n const char b[] = str(getrlimit@GLIBC_2.0);\n const char c[] = \"getrlimit@GLIBC_2.0\";\n "}, {"sha": "60347ed4b605cd9d384025eda20345c70583a4b3", "filename": "gcc/testsuite/gcc.dg/cpp/macro1.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro1.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do run } */\n+\n+/* Tests various macros are correctly expanded.  */\n+\n+extern int puts (const char *);\n+extern void abort (void);\n+#define err(str) do { puts(str); abort(); } while (0)\n+\n+#define j(x, y) x + y\n+#define k(x, y) j(x + 2, y +\n+\n+int q(int x)\t\t{return x + 40;}\n+int B(int x)\t\t{return x + 20;}\n+int foo(int x)\t\t{return x + 10;}\n+int bar(int x, int y)\t{return x + y;}\n+int baz(int x, int y)\t{return x + y;}\n+int toupper(int x)\t{return x + 32;}\n+\n+int main (int argc, char *argv[])\n+{\n+#define q(x) x\n+  if (q(q)(2) != 42)\n+    err (\"q\");\n+\n+#define A(x) B(x)\n+  if (A(A(2)) != 42)\n+    err (\"A\");\n+\n+#define E(x) A x\n+#define F (22)\n+  if (E(F) != 42)\n+    err (\"E(F)\");\n+\n+#define COMMA ,\n+#define NASTY(a) j(a 37)\n+  if (NASTY (5 COMMA) != 42)\n+    err (\"NASTY\");\n+\n+#define bar(x, y) foo(x(y, 0))\n+#define apply(x, y) foo(x(y, 22))\n+#define bam bar\n+  if (bar(bar, 32) != 42)\t/* foo(bar(32, 0)).  */\n+    err (\"bar bar\");\n+  if (bar(bam, 32) != 42)\t/* Same.  */\n+    err (\"bar bam\");\n+  if (apply(bar, baz) != 42)\t/* foo(foo(baz(22, 0))).  */\n+    err (\"apply bar baz\");\n+\n+#define __tobody(c, f) f (c)\n+#define toupper(c) __tobody (c, toupper)\n+  if (toupper (10) != 42)\t/* toupper (10). */\n+    err (\"toupper\");\n+\n+  /* This looks like it has too many ')', but it hasn't.  */\n+  if (k(1, 4) 35) != 42)\n+    err (\"k\");\n+\n+    /*#define B(x) Z B(x)\n+#define XEXP(RTX, N)  RTX->fld[N].rtx\n+#define PATTERN(INSN) XEXP(INSN, 3)\n+#define COST(X) XEXP (XEXP (x, 0), 0)\n+#define M(a) OK M (a)\n+#define stpcpy(a) M(a)\n+#define C(x) A(x)\n+XEXP (PATTERN (insn), i);\n+XEXP (XEXP (insn, 3), i);\n+COST (b)*/\n+\n+  return 0;\n+}"}, {"sha": "7b07f740c8045a50925dec8a4667674f8b679259", "filename": "gcc/testsuite/gcc.dg/cpp/paste1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste1.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -0,0 +1,10 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Test operator ## semantics.  */\n+\n+#define bad1 ## owt\t/* { dg-error \"cannot\" \"## at objlike start\" } */\n+#define bad2 owt ##\t/* { dg-error \"cannot\" \"## at objlike end\" } */\n+#define bad3(x) ## x\t/* { dg-error \"cannot\" \"## at funlike start\" } */\n+#define bad4(x) x ##\t/* { dg-error \"cannot\" \"## at funlike end\" } */"}, {"sha": "1ce13a5945a71fd0c91f9a265ae748f5dcd4689f", "filename": "gcc/testsuite/gcc.dg/cpp/paste2.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste2.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -0,0 +1,115 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+/* Test ## behaviour and corner cases thoroughly.  The macro expander\n+   failed many of these during development.  */\n+\n+#include <string.h>\n+\n+#ifndef __WCHAR_TYPE__\n+#define __WCHAR_TYPE__ int\n+#endif\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+extern int puts (const char *);\n+extern void abort (void);\n+#define err(str) do { puts(str); abort(); } while (0)\n+\n+#define EMPTY\n+#define str(x) #x\n+#define xstr(x) str(x)\n+#define glue(x, y) x ## y\n+#define xglue(x, y) glue (x, y)\n+#define glue3(x, y, z) x ## y ## z\n+#define glue_var(x, ...) x ## __VA_ARGS__\n+\n+#define __muldi3 __NDW(mul, 3 = 50)\n+#define __NDW(a,b) __ ## a ## di ## b\n+#define m3 NDW()\n+#define NDW(x) m3 ## x = 50\n+#define five 5\n+#define fifty int fif ## ty\n+\n+/* Defines a function called glue, returning what it is passed.  */\n+int glue (glue,) (int x)\n+{\n+  return x;\n+}\n+\n+int main ()\n+{\n+  /* m3 and __muldi3 would sometimes cause an infinite loop.  Ensure\n+     we only expand fifty once.  */\n+  fifty = 50, m3, __muldi3;\n+\n+  /* General glue and macro expanding test.  */\n+  int five0 = xglue (glue (fi, ve), 0);\n+\n+  /* Tests only first and last tokens are pasted, and pasting to form\n+     the != operator.  Should expand to: if (five0 != 50).  */\n+  if (glue3 (fi, ve0 !,= glue (EMPTY 5, 0)))\n+    err (\"five0 != 50\");\n+\n+  /* Test varags pasting, and pasting to form the >> operator.  */\n+  if (glue_var(50 >, > 1 != 25))\n+    err (\"Operator >> pasting\");\n+\n+  /* The LHS should not attempt to expand twice, and thus becomes a\n+     call to the function glue, but the RHS should fully expand.  */\n+  if (glue (gl, ue) (12) != glue (xgl, ue) (1, 2))\n+    err (\"Recursive macros\");\n+\n+  /* Test placemarker pasting.  The glued lines should all appear\n+     neatly in the same column and below each other, though we don't\n+     test that here.  */\n+  {\n+    int glue3(a, b, ) = 1, glue3(a,,) = 1;\n+    glue3(a, , b)++;\n+    glue3(, a, b)++;\n+    glue3(,a,)++;\n+    glue3(,,a)++;\n+    if (a != 3 || ab != 3 glue3(,,))\n+      err (\"Placemarker pasting\");\n+  }\n+\n+  /* Test that macros in arguments are not expanded.  */\n+  {\n+    int glue (EMPTY,1) = 123, glue (T, EMPTY) = 123;\n+    if (EMPTY1 != 123 || TEMPTY != 123)\n+      err (\"Pasted arguments macro expanding\");\n+  }\n+\n+  /* Test various paste combinations.  */\n+  {\n+    const wchar_t* wc_array = glue(L, \"wide string\");\n+    wchar_t wc = glue(L, 'w');\n+    const char * hh = xstr(xglue(glue(%, :), glue(%, :)));\n+    int array glue (<, :) 1 glue (:, >) = glue(<, %) 1 glue(%, >);\n+    int x = 4;\n+\n+    if (array[0] != 1)\n+      err (\"Digraph pasting\");\n+\n+    x glue (>>, =) 1;\t\t/* 2 */\n+    x glue (<<, =) 1;\t\t/* 4 */\n+    x glue (*, =) 2;\t\t/* 8 */\n+    x glue (+, =) 100;\t\t/* 108 */\n+    x glue (-, =) 50;\t\t/* 58 */\n+    x glue (/, =) 2;\t\t/* 29 */\n+    x glue (%, =) 20;\t\t/* 9 */\n+    x glue (&, =) 254;\t\t/* 8 */\n+    x glue (|, =) 16;\t\t/* 24 */\n+    x glue (^, =) 18;\t\t/* 10 */\n+    \n+    if (x != 10 || 0 glue (>, =) 1 glue (|, |) 1 glue (<, =) 0)\n+      err (\"Various operator pasting\");\n+    if (strcmp (hh, \"%:%:\"))\n+      err (\"Pasted digraph spelling\");\n+    if ((glue (., 0) glue (=, =) .0) + (glue3 (1.0e, +, 1) == 10.0) != 2)\n+      err (\"Pasted numbers\");\n+  }\n+\n+  return 0;\n+}"}, {"sha": "0c9c52de3d2eb1b9feda7c9e81db4245dd49c968", "filename": "gcc/testsuite/gcc.dg/cpp/paste3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste3.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -0,0 +1,14 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do compile } */\n+\n+#define plus +\n+\n+void foo()\n+{\n+  int a, b = 1;\n+\n+  /* The correct \"a = 1 + ++b\" will compile.\n+     The incorrect \"a = 1 +++b\" won't.  */\n+  a = 1 plus++b;\n+}"}, {"sha": "fac1d436ffe54b24b082ecf32e8c80e253a8f74d", "filename": "gcc/testsuite/gcc.dg/cpp/paste4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste4.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -0,0 +1,14 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+/* { dg-do compile } */\n+\n+/* Since 1.0e and + form the pasted token, 1 is a separate token and\n+   so should be output with a preceding space.  The old preprocessor\n+   gets this wrong.  */\n+\n+#define glue(x, y) x ## y\n+\n+int main ()\n+{\n+  double d = glue (1.0e, +1); /* { dg-error \"floating const|parse error\" } */\n+  return 0;\n+}"}, {"sha": "35355401aeb47b33ffee7af38a58fb0073e41638", "filename": "gcc/testsuite/gcc.dg/cpp/strify1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify1.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -0,0 +1,10 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Test operator # semantics.  */\n+\n+#define OK1 #\t\t/* No problem.  */\n+#define OK2(x) x#x\t/* No problem.  */\n+#define bad1(x) #\t/* { dg-error \"followed by a macro parameter\" \"#1\" } */\n+#define bad2(x) #y\t/* { dg-error \"followed by a macro parameter\" \"#2\" } */"}, {"sha": "ddde976feae6b53298ddb7954f20d23cc729b278", "filename": "gcc/testsuite/gcc.dg/cpp/strify2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041c31944c94d5ee089bd569c4361fbc3d2acaea/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify2.c?ref=041c31944c94d5ee089bd569c4361fbc3d2acaea", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+/* Tests a whole bunch of things are correctly stringified.  */\n+\n+extern int strcmp (const char *, const char *);\n+extern int puts (const char *);\n+extern void abort (void);\n+#define err(str) do { puts(str); abort(); } while (0)\n+\n+#define str(x) #x\n+#define xstr(x) str(x)\n+#define strvar(...) #__VA_ARGS__\n+\n+int main (int argc, char *argv[])\n+{\n+  str (\\);\t\t\t/* { dg-warning \"valid string\" \"str(\\)\" } */\n+  str (\\\\\\);\t\t\t/* { dg-warning \"valid string\" \"str(\\\\\\)\" } */\n+\n+  /* This also serves as a useful test of the value of __INCLUDE_LEVEL.  */\n+  if (strcmp (xstr (__INCLUDE_LEVEL__), \"0\"))\n+    err (\"macro expansion\");\n+\n+  if (strcmp(str (__INCLUDE_LEVEL__), \"__INCLUDE_LEVEL__\"))\n+    err (\"macro name\");\n+\n+  if (strcmp(str (\"s\\n\"), \"\\\"s\\\\n\\\"\"))\n+    err (\"quoted string\");\n+\n+  if (strcmp (str (a \ufffd b), \"a \\200 b\"))\n+    err (\"unprintable char\");\n+\n+  if (strcmp (str (\ta    b@ c   ), \"a b@ c\"))\n+    err (\"internal whitespace\");\n+\n+  if (strcmp (str(a \\n), \"a \\n\"))\n+    err (\"backslash token\");\n+\n+  if (strcmp (strvar (foo, bar), \"foo, bar\"))\n+    err (\"variable arguments\");\n+\n+  return 0;\n+}"}]}