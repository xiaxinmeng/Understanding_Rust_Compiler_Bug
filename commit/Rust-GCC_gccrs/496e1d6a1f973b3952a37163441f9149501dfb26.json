{"sha": "496e1d6a1f973b3952a37163441f9149501dfb26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk2ZTFkNmExZjk3M2IzOTUyYTM3MTYzNDQxZjkxNDk1MDFkZmIyNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-07-02T08:21:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-07-02T08:24:26Z"}, "message": "Change EH pointer encodings to PC relative on Windows\n\nA big difference between ELF and PE-COFF is that, with the latter, you can\nbuild position-independent executables or DLLs without generating PIC; as\na  matter of fact, flag_pic has historically been forced to 0 for 32-bit:\n\n/* Don't allow flag_pic to propagate since gas may produce invalid code\n   otherwise.  */\n\n\\\ndo {\n        \\\n  flag_pic = TARGET_64BIT ? 1 : 0; \\\n} while (0)\n\nThe reason is that the linker builds a .reloc section that collects the\nabsolute relocations in the generated binary, and the loader uses them to\nrelocate it at load time if need be (e.g. if --dynamicbase is enabled).\n\nUp to binutils 2.35, the GNU linker didn't build the .reloc section for\nexecutables and defaulted to --enable-auto-image-base for DLLs, which means\nthat DLLs had an essentially unique load address and, therefore, need not\nbe relocated by the loader in most cases.\n\nWith binutils 2.36 and later, the GNU linker builds a .reloc section for\nexecutables (thus making them PIE), --enable-auto-image-base is disabled\nand --dynamicbase is enabled by default, which means that essentially all\nthe binaries are relocated at load time.\n\nThis badly breaks the 32-bit compiler configured to use DWARF-2 EH because\nthe loader corrupts the .eh_frame section when processing the relocations\ncontained in the .reloc section.\n\ngcc/\n\t* config/i386/i386.c (asm_preferred_eh_data_format): Always use the\n\tPIC encodings for PE-COFF targets.", "tree": {"sha": "5a269c1a72c464fa6c056b0842e383526547e20c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a269c1a72c464fa6c056b0842e383526547e20c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/496e1d6a1f973b3952a37163441f9149501dfb26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496e1d6a1f973b3952a37163441f9149501dfb26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496e1d6a1f973b3952a37163441f9149501dfb26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496e1d6a1f973b3952a37163441f9149501dfb26/comments", "author": null, "committer": null, "parents": [{"sha": "f7cad1a0ffe9f003ec347521dfd33f320f4c2b04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7cad1a0ffe9f003ec347521dfd33f320f4c2b04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7cad1a0ffe9f003ec347521dfd33f320f4c2b04"}], "stats": {"total": 6, "additions": 5, "deletions": 1}, "files": [{"sha": "cff269092929d8535219c2904e27320782aa6286", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496e1d6a1f973b3952a37163441f9149501dfb26/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496e1d6a1f973b3952a37163441f9149501dfb26/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=496e1d6a1f973b3952a37163441f9149501dfb26", "patch": "@@ -21930,10 +21930,12 @@ ix86_stack_protect_fail (void)\n    After all, the relocation needed is the same as for the call insn.\n    Whether or not a particular assembler allows us to enter such, I\n    guess we'll have to see.  */\n+\n int\n asm_preferred_eh_data_format (int code, int global)\n {\n-  if (flag_pic)\n+  /* PE-COFF is effectively always -fPIC because of the .reloc section.  */\n+  if (flag_pic || TARGET_PECOFF)\n     {\n       int type = DW_EH_PE_sdata8;\n       if (!TARGET_64BIT\n@@ -21942,9 +21944,11 @@ asm_preferred_eh_data_format (int code, int global)\n \ttype = DW_EH_PE_sdata4;\n       return (global ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | type;\n     }\n+\n   if (ix86_cmodel == CM_SMALL\n       || (ix86_cmodel == CM_MEDIUM && code))\n     return DW_EH_PE_udata4;\n+\n   return DW_EH_PE_absptr;\n }\n \f"}]}