{"sha": "61502ca83754695ad954c8872379ae566f8e21e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE1MDJjYTgzNzU0Njk1YWQ5NTRjODg3MjM3OWFlNTY2ZjhlMjFlOQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-02-11T15:16:46Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-02-11T15:16:46Z"}, "message": "cgraph.c: Fix comment typos.\n\n\t* cgraph.c: Fix comment typos.\n\t* cgraph.h: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* ipa-cp.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* ipa-ref.c: Likewise.\n\t* ipa-reference.c: Likewise.\n\nFrom-SVN: r170052", "tree": {"sha": "fb74d6c5685edc7c6aad61bcc6ec5436740ac374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb74d6c5685edc7c6aad61bcc6ec5436740ac374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61502ca83754695ad954c8872379ae566f8e21e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61502ca83754695ad954c8872379ae566f8e21e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61502ca83754695ad954c8872379ae566f8e21e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61502ca83754695ad954c8872379ae566f8e21e9/comments", "author": null, "committer": null, "parents": [{"sha": "d50c5e0c692b85447c059144c5ccff0f67c07854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50c5e0c692b85447c059144c5ccff0f67c07854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d50c5e0c692b85447c059144c5ccff0f67c07854"}], "stats": {"total": 130, "additions": 71, "deletions": 59}, "files": [{"sha": "51920030ab883dbe9a0a41f3398c0d3acb7b9b70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -1,3 +1,15 @@\n+2011-02-11  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* cgraph.c: Fix comment typos.\n+\t* cgraph.h: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* ipa-cp.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* ipa-ref.c: Likewise.\n+\t* ipa-reference.c: Likewise.\n+\n 2011-02-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/47684"}, {"sha": "dd7eeadc705dabc7ee19e2865baf8bf2b44a334c", "filename": "gcc/cgraph.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -164,28 +164,28 @@ static GTY(()) struct cgraph_asm_node *cgraph_asm_last_node;\n    them, to support -fno-toplevel-reorder.  */\n int cgraph_order;\n \n-/* List of hooks trigerred on cgraph_edge events.  */\n+/* List of hooks triggered on cgraph_edge events.  */\n struct cgraph_edge_hook_list {\n   cgraph_edge_hook hook;\n   void *data;\n   struct cgraph_edge_hook_list *next;\n };\n \n-/* List of hooks trigerred on cgraph_node events.  */\n+/* List of hooks triggered on cgraph_node events.  */\n struct cgraph_node_hook_list {\n   cgraph_node_hook hook;\n   void *data;\n   struct cgraph_node_hook_list *next;\n };\n \n-/* List of hooks trigerred on events involving two cgraph_edges.  */\n+/* List of hooks triggered on events involving two cgraph_edges.  */\n struct cgraph_2edge_hook_list {\n   cgraph_2edge_hook hook;\n   void *data;\n   struct cgraph_2edge_hook_list *next;\n };\n \n-/* List of hooks trigerred on events involving two cgraph_nodes.  */\n+/* List of hooks triggered on events involving two cgraph_nodes.  */\n struct cgraph_2node_hook_list {\n   cgraph_2node_hook hook;\n   void *data;\n@@ -588,7 +588,7 @@ cgraph_same_body_alias (tree alias, tree decl)\n }\n \n /* Add thunk alias into callgraph.  The alias declaration is ALIAS and it\n-   alises DECL with an adjustments made into the first parameter.\n+   aliases DECL with an adjustments made into the first parameter.\n    See comments in thunk_adjust for detail on the parameters.  */\n \n struct cgraph_node *\n@@ -937,7 +937,7 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n         /* It is possible that clones already contain the edge while\n \t   master didn't.  Either we promoted indirect call into direct\n \t   call in the clone or we are processing clones of unreachable\n-\t   master where edges has been rmeoved.  */\n+\t   master where edges has been removed.  */\n \tif (edge)\n \t  cgraph_set_call_stmt (edge, stmt);\n \telse if (!cgraph_edge (node, stmt))\n@@ -997,7 +997,7 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n      have not been loaded yet.  */\n   if (call_stmt)\n     {\n-      /* This is a rather expensive check possibly trigerring\n+      /* This is a rather expensive check possibly triggering\n \t construction of call stmt hashtable.  */\n       gcc_checking_assert (!cgraph_edge (caller, call_stmt));\n \n@@ -1252,7 +1252,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n   if (!new_call && !old_call)\n     return;\n   /* See if we turned indirect call into direct call or folded call to one builtin\n-     into different bultin.  */\n+     into different builtin.  */\n   if (old_call != new_call)\n     {\n       struct cgraph_edge *e = cgraph_edge (node, old_stmt);\n@@ -1973,7 +1973,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n           fprintf (f, \" %s/%i\", cgraph_node_name (n), n->uid);\n \t  if (n->thunk.thunk_p)\n \t    {\n-\t      fprintf (f, \" (thunk of %s fixed ofset %i virtual value %i has \"\n+\t      fprintf (f, \" (thunk of %s fixed offset %i virtual value %i has \"\n \t\t       \"virtual offset %i\",\n \t      \t       lang_hooks.decl_printable_name (n->thunk.alias, 2),\n \t\t       (int)n->thunk.fixed_offset,\n@@ -2411,8 +2411,8 @@ cgraph_function_body_availability (struct cgraph_node *node)\n     avail = AVAIL_LOCAL;\n   else if (!node->local.externally_visible)\n     avail = AVAIL_AVAILABLE;\n-  /* Inline functions are safe to be analyzed even if their sybol can\n-     be overwritten at runtime.  It is not meaningful to enfore any sane\n+  /* Inline functions are safe to be analyzed even if their symbol can\n+     be overwritten at runtime.  It is not meaningful to enforce any sane\n      behaviour on replacing inline function by different body.  */\n   else if (DECL_DECLARED_INLINE_P (node->decl))\n     avail = AVAIL_AVAILABLE;\n@@ -2706,9 +2706,9 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n       if (edge->caller != node)\n \t{\n           only_called_at_startup &= edge->caller->only_called_at_startup;\n-\t  /* It makes snese to put main() together with the static constructors.\n+\t  /* It makes sense to put main() together with the static constructors.\n \t     It will be executed for sure, but rest of functions called from\n-\t     main are definitly not at startup only.  */\n+\t     main are definitely not at startup only.  */\n \t  if (MAIN_NAME_P (DECL_NAME (edge->caller->decl)))\n \t    only_called_at_startup = 0;\n           only_called_at_exit &= edge->caller->only_called_at_exit;\n@@ -2843,7 +2843,7 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n   return true;\n }\n \n-/* Return true when function NODE can be excpected to be removed\n+/* Return true when function NODE can be expected to be removed\n    from program when direct calls in this compilation unit are removed.\n \n    As a special case COMDAT functions are\n@@ -2852,7 +2852,7 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n    unit)\n \n    This function behaves as cgraph_only_called_directly_p because eliminating\n-   all uses of COMDAT function does not make it neccesarily disappear from\n+   all uses of COMDAT function does not make it necessarily disappear from\n    the program unless we are compiling whole program or we do LTO.  In this\n    case we know we win since dynamic linking will not really discard the\n    linkonce section.  */\n@@ -2874,7 +2874,7 @@ cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node\n }\n \n /* Return true when RESOLUTION indicate that linker will use\n-   the symbol from non-LTo object files.  */\n+   the symbol from non-LTO object files.  */\n \n bool\n resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)"}, {"sha": "34881502fb3a797b9983e78455f4f1ccbb5f2542", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -944,7 +944,7 @@ varpool_can_remove_if_no_refs (struct varpool_node *node)\n /* Return true when all references to VNODE must be visible in ipa_ref_list.\n    i.e. if the variable is not externally visible or not used in some magic\n    way (asm statement or such).\n-   The magic uses are all sumarized in force_output flag.  */\n+   The magic uses are all summarized in force_output flag.  */\n \n static inline bool\n varpool_all_refs_explicit_p (struct varpool_node *vnode)"}, {"sha": "7a10ef44e6b48dca332837ce4a35a811150bca90", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -364,7 +364,7 @@ cgraph_finalize_function (tree decl, bool nested)\n       || DECL_STATIC_CONSTRUCTOR (decl)\n       || DECL_STATIC_DESTRUCTOR (decl)\n       /* COMDAT virtual functions may be referenced by vtable from\n-\t other compilatoin unit.  Still we want to devirtualize calls\n+\t other compilation unit.  Still we want to devirtualize calls\n \t to those so we need to analyze them.\n \t FIXME: We should introduce may edges for this purpose and update\n \t their handling in unreachable function removal and inliner too.  */\n@@ -431,7 +431,7 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n \t  != compute_call_stmt_bb_frequency (e->caller->decl,\n \t\t\t\t\t     gimple_bb (e->call_stmt))))\n     {\n-      error (\"caller edge frequency %i does not match BB freqency %i\",\n+      error (\"caller edge frequency %i does not match BB frequency %i\",\n \t     e->frequency,\n \t     compute_call_stmt_bb_frequency (e->caller->decl,\n \t\t\t\t\t     gimple_bb (e->call_stmt)));\n@@ -1550,7 +1550,7 @@ cgraph_expand_function (struct cgraph_node *node)\n       \t   alias && alias->next; alias = alias->next)\n         ;\n       /* Walk aliases in the order they were created; it is possible that\n-         thunks reffers to the aliases made earlier.  */\n+         thunks refers to the aliases made earlier.  */\n       for (; alias; alias = next)\n         {\n \t  next = alias->previous;\n@@ -2328,7 +2328,7 @@ cgraph_materialize_all_clones (void)\n \t        {\n \t\t  if (cgraph_dump_file)\n \t\t    {\n-\t\t      fprintf (cgraph_dump_file, \"clonning %s to %s\\n\",\n+\t\t      fprintf (cgraph_dump_file, \"cloning %s to %s\\n\",\n \t\t\t       cgraph_node_name (node->clone_of),\n \t\t\t       cgraph_node_name (node));\n \t\t      if (node->clone.tree_map)"}, {"sha": "0ef640bcde9df886679b6ece478bd8f99bb51aa8", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -50,7 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n    with the value 3.\n \n    The algorithm used is based on \"Interprocedural Constant Propagation\", by\n-   Challahan David, Keith D Cooper, Ken Kennedy, Linda Torczon, Comp86, pg\n+   David Callahan, Keith D Cooper, Ken Kennedy, Linda Torczon, Comp86, pg\n    152-161\n \n    The optimization is divided into three stages:\n@@ -469,7 +469,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Not considering %s for cloning; body is overwrittable.\\n\",\n+        fprintf (dump_file, \"Not considering %s for cloning; body is overwritable.\\n\",\n  \t         cgraph_node_name (node));\n       return false;\n     }\n@@ -521,7 +521,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n \n   /* When profile is available and function is hot, propagate into it even if\n      calls seems cold; constant propagation can improve function's speed\n-     significandly.  */\n+     significantly.  */\n   if (max_count)\n     {\n       if (direct_call_sum > node->count * 90 / 100)\n@@ -614,8 +614,8 @@ build_const_val (struct ipcp_lattice *lat, tree tree_type)\n    FIXME: This code is wrong.  Since the callers can be also clones and\n    the clones are not scaled yet, the sums gets unrealistically high.\n    To properly compute the counts, we would need to do propagation across\n-   callgraph (as external call to A might imply call to non-clonned B\n-   if A's clone calls clonned B).  */\n+   callgraph (as external call to A might imply call to non-cloned B\n+   if A's clone calls cloned B).  */\n static void\n ipcp_compute_node_scale (struct cgraph_node *node)\n {\n@@ -1127,7 +1127,7 @@ ipcp_estimate_growth (struct cgraph_node *node)\n     else\n       need_original = true;\n \n-  /* If we will be able to fully replace orignal node, we never increase\n+  /* If we will be able to fully replace original node, we never increase\n      program size.  */\n   if (!need_original)\n     return 0;\n@@ -1148,7 +1148,7 @@ ipcp_estimate_growth (struct cgraph_node *node)\n       }\n \n   /* We make just very simple estimate of savings for removal of operand from\n-     call site.  Precise cost is dificult to get, as our size metric counts\n+     call site.  Precise cost is difficult to get, as our size metric counts\n      constants and moves as free.  Generally we are looking for cases that\n      small function is called very many times.  */\n   growth = node->local.inline_summary.self_size\n@@ -1380,7 +1380,7 @@ ipcp_insert_stage (void)\n \n       new_size += growth;\n \n-      /* Look if original function becomes dead after clonning.  */\n+      /* Look if original function becomes dead after cloning.  */\n       for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n \tif (cs->caller == node || ipcp_need_redirect_p (cs))\n \t  break;\n@@ -1555,7 +1555,7 @@ static bool\n cgraph_gate_cp (void)\n {\n   /* FIXME: We should remove the optimize check after we ensure we never run\n-     IPA passes when not optimizng.  */\n+     IPA passes when not optimizing.  */\n   return flag_ipa_cp && optimize;\n }\n "}, {"sha": "d611d11fe20fade5d0365f9a0b1f37cd00ac5f7c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -333,7 +333,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n   ncalls_inlined++;\n \n   /* FIXME: We should remove the optimize check after we ensure we never run\n-     IPA passes when not optimizng.  */\n+     IPA passes when not optimizing.  */\n   if (flag_indirect_inlining && optimize)\n     return ipa_propagate_indirect_call_infos (curr, new_edges);\n   else\n@@ -528,7 +528,7 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n \n   if (dump)\n     {\n-      fprintf (dump_file, \"    Badness calculcation for %s -> %s\\n\",\n+      fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n \t       cgraph_node_name (edge->caller),\n \t       cgraph_node_name (edge->callee));\n       fprintf (dump_file, \"      growth %i, time %i-%i, size %i-%i\\n\",\n@@ -653,7 +653,7 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n       /* fibheap_replace_key only decrease the keys.\n \t When we increase the key we do not update heap\n \t and instead re-insert the element once it becomes\n-\t a minium of heap.  */\n+\t a minimum of heap.  */\n       if (badness < n->key)\n \t{\n \t  fibheap_replace_key (heap, n, badness);\n@@ -1006,7 +1006,7 @@ add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n    All inline candidates are put into prioritized heap based on estimated\n    growth of the overall number of instructions and then update the estimates.\n \n-   INLINED and INLINED_CALEES are just pointers to arrays large enough\n+   INLINED and INLINED_CALLEES are just pointers to arrays large enough\n    to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */\n \n static void\n@@ -1118,7 +1118,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t ??? When the frequencies are taken into account we might not need this\n \t restriction.\n \n-\t We need to be cureful here, in some testcases, e.g. directivec.c in\n+\t We need to be careful here, in some testcases, e.g. directives.c in\n \t libcpp, we can estimate self recursive function to have negative growth\n \t for inlining completely.\n \t */\n@@ -1815,7 +1815,7 @@ struct gimple_opt_pass pass_early_inline =\n    0 - means not eliminated\n    1 - half of statements goes away\n    2 - for sure it is eliminated.\n-   We are not terribly sophisficated, basically looking for simple abstraction\n+   We are not terribly sophisticated, basically looking for simple abstraction\n    penalty wrappers.  */\n \n static int\n@@ -1999,7 +1999,7 @@ compute_inline_parameters (struct cgraph_node *node)\n     {\n       struct cgraph_edge *e;\n \n-      /* Functions calling builtlin_apply can not change signature.  */\n+      /* Functions calling builtin_apply can not change signature.  */\n       for (e = node->callees; e; e = e->next_callee)\n \tif (DECL_BUILT_IN (e->callee->decl)\n \t    && DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n@@ -2046,7 +2046,7 @@ struct gimple_opt_pass pass_inline_parameters =\n  }\n };\n \n-/* This function performs intraprocedural analyzis in NODE that is required to\n+/* This function performs intraprocedural analysis in NODE that is required to\n    inline indirect calls.  */\n static void\n inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n@@ -2068,7 +2068,7 @@ analyze_function (struct cgraph_node *node)\n \n   compute_inline_parameters (node);\n   /* FIXME: We should remove the optimize check after we ensure we never run\n-     IPA passes when not optimizng.  */\n+     IPA passes when not optimizing.  */\n   if (flag_indirect_inlining && optimize)\n     inline_indirect_intraprocedural_analysis (node);\n \n@@ -2114,7 +2114,7 @@ inline_transform (struct cgraph_node *node)\n   struct cgraph_edge *e;\n   bool inline_p = false;\n \n-  /* FIXME: Currently the passmanager is adding inline transform more than once to some\n+  /* FIXME: Currently the pass manager is adding inline transform more than once to some\n      clones.  This needs revisiting after WPA cleanups.  */\n   if (cfun->after_inlining)\n     return 0;"}, {"sha": "82599f1d10cffd04cb4b273d55bbb24e77782acf", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -416,7 +416,7 @@ stmt_may_be_vtbl_ptr_store (gimple stmt)\n   return true;\n }\n \n-/* Callbeck of walk_aliased_vdefs and a helper function for\n+/* Callback of walk_aliased_vdefs and a helper function for\n    detect_type_change to check whether a particular statement may modify\n    the virtual table pointer, and if possible also determine the new type of\n    the (sub-)object.  It stores its result into DATA, which points to a\n@@ -679,7 +679,7 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n     }\n }\n \n-/* Given OP whch is passed as an actual argument to a called function,\n+/* Given OP which is passed as an actual argument to a called function,\n    determine if it is possible to construct a KNOWN_TYPE jump function for it\n    and if so, create one and store it to JFUNC.  */\n \n@@ -899,7 +899,7 @@ fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n   jfunc->value.member_cst.delta = delta;\n }\n \n-/* If RHS is an SSA_NAMe and it is defined by a simple copy assign statement,\n+/* If RHS is an SSA_NAME and it is defined by a simple copy assign statement,\n    return the rhs of its defining statement.  */\n \n static inline tree\n@@ -1516,7 +1516,7 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n }\n \n /* Initialize the array describing properties of of formal parameters of NODE,\n-   analyze their uses and and compute jump functions associated witu actual\n+   analyze their uses and and compute jump functions associated with actual\n    arguments of calls from within NODE.  */\n \n void\n@@ -1546,7 +1546,7 @@ ipa_analyze_node (struct cgraph_node *node)\n }\n \n \n-/* Update the jump function DST when the call graph edge correspondng to SRC is\n+/* Update the jump function DST when the call graph edge corresponding to SRC is\n    is being inlined, knowing that DST is of type ancestor and src of known\n    type.  */\n \n@@ -1704,7 +1704,7 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n }\n \n /* Try to find a destination for indirect edge IE that corresponds to a\n-   virtuall call based on a formal parameter which is described by jump\n+   virtual call based on a formal parameter which is described by jump\n    function JFUNC and if it can be determined, make it direct and return the\n    direct edge.  Otherwise, return NULL.  */\n \n@@ -2054,7 +2054,7 @@ ipa_unregister_cgraph_hooks (void)\n   node_duplication_hook_holder = NULL;\n }\n \n-/* Allocate all necessary data strucutures necessary for indirect inlining.  */\n+/* Allocate all necessary data structures necessary for indirect inlining.  */\n \n void\n ipa_create_all_structures_for_iinln (void)\n@@ -2783,7 +2783,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     ipa_write_indirect_edge_info (ob, e);\n }\n \n-/* Srtream in NODE info from IB.  */\n+/* Stream in NODE info from IB.  */\n \n static void\n ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n@@ -2919,7 +2919,7 @@ ipa_prop_read_jump_functions (void)\n }\n \n /* After merging units, we can get mismatch in argument counts.\n-   Also decl merging might've rendered parameter lists obsolette.\n+   Also decl merging might've rendered parameter lists obsolete.\n    Also compute called_with_variable_arg info.  */\n \n void"}, {"sha": "3b4cc02f12c68e2e24b76e0a01169d62e1f8a9af", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -423,7 +423,7 @@ worse_state (enum pure_const_state_e *state, bool *looping,\n   *looping = MAX (*looping, looping2);\n }\n \n-/* Recognize special cases of builtins that are by themself not pure or const\n+/* Recognize special cases of builtins that are by themselves not pure or const\n    but function using them is.  */\n static bool\n special_builtin_state (enum pure_const_state_e *state, bool *looping,\n@@ -547,7 +547,7 @@ check_call (funct_state local, gimple call, bool ipa)\n         fprintf (dump_file, \"    Recursive call can loop.\\n\");\n       local->looping = true;\n     }\n-  /* Either calle is unknown or we are doing local analysis.\n+  /* Either callee is unknown or we are doing local analysis.\n      Look to see if there are any bits available for the callee (such as by\n      declaration or because it is builtin) and process solely on the basis of\n      those bits. */\n@@ -771,7 +771,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n       if (mark_dfs_back_edges ())\n         {\n \t  /* Preheaders are needed for SCEV to work.\n-\t     Simple lateches and recorded exits improve chances that loop will\n+\t     Simple latches and recorded exits improve chances that loop will\n \t     proved to be finite in testcases such as in loop-15.c and loop-24.c  */\n \t  loop_optimizer_init (LOOPS_NORMAL\n \t\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n@@ -916,7 +916,7 @@ generate_summary (void)\n \n      We process AVAIL_OVERWRITABLE functions.  We can not use the results\n      by default, but the info can be used at LTO with -fwhole-program or\n-     when function got clonned and the clone is AVAILABLE.  */\n+     when function got cloned and the clone is AVAILABLE.  */\n \n   for (node = cgraph_nodes; node; node = node->next)\n     if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n@@ -1545,7 +1545,7 @@ skip_function_for_local_pure_const (struct cgraph_node *node)\n   if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Function is not available or overwrittable; not analyzing.\\n\");\n+        fprintf (dump_file, \"Function is not available or overwritable; not analyzing.\\n\");\n       return true;\n     }\n   return false;"}, {"sha": "db70e6e96af2efce76f1464135d6f3d873f7c79f", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -197,7 +197,7 @@ ipa_dump_refering (FILE * file, struct ipa_ref_list *list)\n   fprintf (file, \"\\n\");\n }\n \n-/* Clone all references from SRC to DEST_NODE or DEST_VARPOL_NODE.  */\n+/* Clone all references from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n \n void\n ipa_clone_references (struct cgraph_node *dest_node,\n@@ -215,7 +215,7 @@ ipa_clone_references (struct cgraph_node *dest_node,\n \t\t\t  ref->use, ref->stmt);\n }\n \n-/* Clone all refering from SRC to DEST_NODE or DEST_VARPOL_NODE.  */\n+/* Clone all refering from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n \n void\n ipa_clone_refering (struct cgraph_node *dest_node,"}, {"sha": "f874a2e80efc9d0676bb3d62151a1a892de1a73b", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61502ca83754695ad954c8872379ae566f8e21e9/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=61502ca83754695ad954c8872379ae566f8e21e9", "patch": "@@ -86,7 +86,7 @@ struct ipa_reference_global_vars_info_d\n   bitmap statics_written;\n };\n \n-/* Information we save about every function after ipa-reference is completted.  */\n+/* Information we save about every function after ipa-reference is completed.  */\n \n struct ipa_reference_optimization_summary_d\n {\n@@ -658,7 +658,7 @@ propagate (void)\n       read_all = false;\n       write_all = false;\n \n-      /* When function is overwrittable, we can not assume anything.  */\n+      /* When function is overwritable, we can not assume anything.  */\n       if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n         read_write_all_from_decl (node, &read_all, &write_all);\n \n@@ -691,7 +691,7 @@ propagate (void)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s/%i\\n\",\n \t\t      cgraph_node_name (w), w->uid);\n-\t  /* When function is overwrittable, we can not assume anything.  */\n+\t  /* When function is overwritable, we can not assume anything.  */\n \t  if (cgraph_function_body_availability (w) <= AVAIL_OVERWRITABLE)\n \t    read_write_all_from_decl (w, &read_all, &write_all);\n "}]}