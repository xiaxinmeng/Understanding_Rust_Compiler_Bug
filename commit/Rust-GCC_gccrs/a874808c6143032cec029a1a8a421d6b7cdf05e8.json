{"sha": "a874808c6143032cec029a1a8a421d6b7cdf05e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg3NDgwOGM2MTQzMDMyY2VjMDI5YTFhOGE0MjFkNmI3Y2RmMDVlOA==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2018-04-26T13:26:48Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2018-04-26T13:26:48Z"}, "message": "[nvptx] Verify bar.sync position\n\n2018-04-26  Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/84952\n\t* config/nvptx/nvptx.c (verify_neutering_jumps)\n\t(verify_neutering_labels): New function\n\t(nvptx_single): Use verify_neutering_jumps and verify_neutering_labels.\n\nFrom-SVN: r259677", "tree": {"sha": "484227c55f64850e5770e86d006af79728688d29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/484227c55f64850e5770e86d006af79728688d29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a874808c6143032cec029a1a8a421d6b7cdf05e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a874808c6143032cec029a1a8a421d6b7cdf05e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a874808c6143032cec029a1a8a421d6b7cdf05e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a874808c6143032cec029a1a8a421d6b7cdf05e8/comments", "author": null, "committer": null, "parents": [{"sha": "6beefdbdf33d56fe0d327688b85dc0cd25ce7a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6beefdbdf33d56fe0d327688b85dc0cd25ce7a06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6beefdbdf33d56fe0d327688b85dc0cd25ce7a06"}], "stats": {"total": 143, "additions": 141, "deletions": 2}, "files": [{"sha": "e0e06a092ef645a63577e15f4477e0eb8f6dcc38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a874808c6143032cec029a1a8a421d6b7cdf05e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a874808c6143032cec029a1a8a421d6b7cdf05e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a874808c6143032cec029a1a8a421d6b7cdf05e8", "patch": "@@ -1,3 +1,10 @@\n+2018-04-26  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/84952\n+\t* config/nvptx/nvptx.c (verify_neutering_jumps)\n+\t(verify_neutering_labels): New function\n+\t(nvptx_single): Use verify_neutering_jumps and verify_neutering_labels.\n+\n 2018-04-26  Tom de Vries  <tom@codesourcery.com>\n \n \tPR target/84025"}, {"sha": "a0c7bc1c5cd0b6ce23faa6c4a9386188a594e028", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 134, "deletions": 2, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a874808c6143032cec029a1a8a421d6b7cdf05e8/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a874808c6143032cec029a1a8a421d6b7cdf05e8/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=a874808c6143032cec029a1a8a421d6b7cdf05e8", "patch": "@@ -4010,6 +4010,119 @@ needs_neutering_p (rtx_insn *insn)\n     }\n }\n \n+/* Verify position of VECTOR_{JUMP,LABEL} and WORKER_{JUMP,LABEL} in FROM.  */\n+\n+static bool\n+verify_neutering_jumps (basic_block from,\n+\t\t\trtx_insn *vector_jump, rtx_insn *worker_jump,\n+\t\t\trtx_insn *vector_label, rtx_insn *worker_label)\n+{\n+  basic_block bb = from;\n+  rtx_insn *insn = BB_HEAD (bb);\n+  bool seen_worker_jump = false;\n+  bool seen_vector_jump = false;\n+  bool seen_worker_label = false;\n+  bool seen_vector_label = false;\n+  bool worker_neutered = false;\n+  bool vector_neutered = false;\n+  while (true)\n+    {\n+      if (insn == worker_jump)\n+\t{\n+\t  seen_worker_jump = true;\n+\t  worker_neutered = true;\n+\t  gcc_assert (!vector_neutered);\n+\t}\n+      else if (insn == vector_jump)\n+\t{\n+\t  seen_vector_jump = true;\n+\t  vector_neutered = true;\n+\t}\n+      else if (insn == worker_label)\n+\t{\n+\t  seen_worker_label = true;\n+\t  gcc_assert (worker_neutered);\n+\t  worker_neutered = false;\n+\t}\n+      else if (insn == vector_label)\n+\t{\n+\t  seen_vector_label = true;\n+\t  gcc_assert (vector_neutered);\n+\t  vector_neutered = false;\n+\t}\n+      else if (INSN_P (insn))\n+\tswitch (recog_memoized (insn))\n+\t  {\n+\t  case CODE_FOR_nvptx_barsync:\n+\t    gcc_assert (!vector_neutered && !worker_neutered);\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n+      if (insn != BB_END (bb))\n+\tinsn = NEXT_INSN (insn);\n+      else if (JUMP_P (insn) && single_succ_p (bb)\n+\t       && !seen_vector_jump && !seen_worker_jump)\n+\t{\n+\t  bb = single_succ (bb);\n+\t  insn = BB_HEAD (bb);\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  gcc_assert (!(vector_jump && !seen_vector_jump));\n+  gcc_assert (!(worker_jump && !seen_worker_jump));\n+\n+  if (seen_vector_label || seen_worker_label)\n+    {\n+      gcc_assert (!(vector_label && !seen_vector_label));\n+      gcc_assert (!(worker_label && !seen_worker_label));\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Verify position of VECTOR_LABEL and WORKER_LABEL in TO.  */\n+\n+static void\n+verify_neutering_labels (basic_block to, rtx_insn *vector_label,\n+\t\t\t rtx_insn *worker_label)\n+{\n+  basic_block bb = to;\n+  rtx_insn *insn = BB_END (bb);\n+  bool seen_worker_label = false;\n+  bool seen_vector_label = false;\n+  while (true)\n+    {\n+      if (insn == worker_label)\n+\t{\n+\t  seen_worker_label = true;\n+\t  gcc_assert (!seen_vector_label);\n+\t}\n+      else if (insn == vector_label)\n+\tseen_vector_label = true;\n+      else if (INSN_P (insn))\n+\tswitch (recog_memoized (insn))\n+\t  {\n+\t  case CODE_FOR_nvptx_barsync:\n+\t    gcc_assert (!seen_vector_label && !seen_worker_label);\n+\t    break;\n+\t  }\n+\n+      if (insn != BB_HEAD (bb))\n+\tinsn = PREV_INSN (insn);\n+      else\n+\tbreak;\n+    }\n+\n+  gcc_assert (!(vector_label && !seen_vector_label));\n+  gcc_assert (!(worker_label && !seen_worker_label));\n+}\n+\n /* Single neutering according to MASK.  FROM is the incoming block and\n    TO is the outgoing block.  These may be the same block. Insert at\n    start of FROM:\n@@ -4095,11 +4208,15 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)\n   unsigned mode;\n   rtx_insn *before = tail;\n   rtx_insn *neuter_start = NULL;\n+  rtx_insn *worker_label = NULL, *vector_label = NULL;\n+  rtx_insn *worker_jump = NULL, *vector_jump = NULL;\n   for (mode = GOMP_DIM_WORKER; mode <= GOMP_DIM_VECTOR; mode++)\n     if (GOMP_DIM_MASK (mode) & skip_mask)\n       {\n \trtx_code_label *label = gen_label_rtx ();\n \trtx pred = cfun->machine->axis_predicate[mode - GOMP_DIM_WORKER];\n+\trtx_insn **mode_jump = mode == GOMP_DIM_VECTOR ? &vector_jump : &worker_jump;\n+\trtx_insn **mode_label = mode == GOMP_DIM_VECTOR ? &vector_label : &worker_label;\n \n \tif (!pred)\n \t  {\n@@ -4116,17 +4233,27 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)\n \t  neuter_start = emit_insn_after (br, neuter_start);\n \telse\n \t  neuter_start = emit_insn_before (br, head);\n+\t*mode_jump = neuter_start;\n \n \tLABEL_NUSES (label)++;\n+\trtx_insn *label_insn;\n \tif (tail_branch)\n-\t  before = emit_label_before (label, before);\n+\t  {\n+\t    label_insn = emit_label_before (label, before);\n+\t    before = label_insn;\n+\t  }\n \telse\n \t  {\n-\t    rtx_insn *label_insn = emit_label_after (label, tail);\n+\t    label_insn = emit_label_after (label, tail);\n \t    if ((mode == GOMP_DIM_VECTOR || mode == GOMP_DIM_WORKER)\n \t\t&& CALL_P (tail) && find_reg_note (tail, REG_NORETURN, NULL))\n \t      emit_insn_after (gen_exit (), label_insn);\n \t  }\n+\n+\tif (mode == GOMP_DIM_VECTOR)\n+\t  vector_label = label_insn;\n+\telse\n+\t  worker_label = label_insn;\n       }\n \n   /* Now deal with propagating the branch condition.  */\n@@ -4226,6 +4353,11 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)\n \t\t\t\t UNSPEC_BR_UNIFIED);\n       validate_change (tail, recog_data.operand_loc[0], unsp, false);\n     }\n+\n+  bool seen_label = verify_neutering_jumps (from, vector_jump, worker_jump,\n+\t\t\t\t\t    vector_label, worker_label);\n+  if (!seen_label)\n+    verify_neutering_labels (to, vector_label, worker_label);\n }\n \n /* PAR is a parallel that is being skipped in its entirety according to"}]}