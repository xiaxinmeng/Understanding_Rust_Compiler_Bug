{"sha": "a949941cf79dc2bee4e741ce3928e11c4053f257", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0OTk0MWNmNzlkYzJiZWU0ZTc0MWNlMzkyOGUxMWM0MDUzZjI1Nw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-09T21:18:15Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-09T21:18:15Z"}, "message": "cpphash.c: Move cpp_defined here from cpplib.c.\n\n        * cpphash.c: Move cpp_defined here from cpplib.c.\n        * cpplib.c: Update comments, move cpp_defined to cpphash.c.\n        * cpplex.c (_cpp_lex_token): Don't leave the lexer at EOL.\n        * cppmacro.c (cpp_get_token): Update comments, no need now\n        to catch the CPP_EOF meaning EOL case.\n\nFrom-SVN: r37345", "tree": {"sha": "faf4076c83d65bd44e0d82d85813fd94e77029cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faf4076c83d65bd44e0d82d85813fd94e77029cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a949941cf79dc2bee4e741ce3928e11c4053f257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a949941cf79dc2bee4e741ce3928e11c4053f257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a949941cf79dc2bee4e741ce3928e11c4053f257", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a949941cf79dc2bee4e741ce3928e11c4053f257/comments", "author": null, "committer": null, "parents": [{"sha": "9a0662b4d5ca89808c149d69d271068ae0e54560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0662b4d5ca89808c149d69d271068ae0e54560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0662b4d5ca89808c149d69d271068ae0e54560"}], "stats": {"total": 121, "additions": 57, "deletions": 64}, "files": [{"sha": "3db1d11ed18a41fadede4ab4c2ce924ea232f552", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a949941cf79dc2bee4e741ce3928e11c4053f257", "patch": "@@ -1,3 +1,11 @@\n+2000-11-09  Neil Booth  <neilb@earthling.net>\n+\n+\t* cpphash.c: Move cpp_defined here from cpplib.c.\n+\t* cpplib.c: Update comments, move cpp_defined to cpphash.c.\n+\t* cpplex.c (_cpp_lex_token): Don't leave the lexer at EOL.\n+\t* cppmacro.c (cpp_get_token): Update comments, no need now\n+\tto catch the CPP_EOF meaning EOL case.\n+\n 2000-11-08  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* config/sparc/sparc.c (sparc_va_arg): When the required alignment"}, {"sha": "4804c8fec50c091a50c7975275c47efeab630395", "filename": "gcc/cpphash.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=a949941cf79dc2bee4e741ce3928e11c4053f257", "patch": "@@ -281,3 +281,16 @@ cpp_forall_identifiers (pfile, cb, v)\n     }\n   while (++p < limit);\n }\n+\n+/* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n+int\n+cpp_defined (pfile, id, len)\n+     cpp_reader *pfile;\n+     const U_CHAR *id;\n+     int len;\n+{\n+  cpp_hashnode *hp = cpp_lookup (pfile, id, len);\n+\n+  /* If it's of type NT_MACRO, it cannot be poisoned.  */\n+  return hp->type == NT_MACRO;\n+}"}, {"sha": "9aff13d82b24ad2eb54efd2c0ae96d2d507d4136", "filename": "gcc/cpplex.c", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=a949941cf79dc2bee4e741ce3928e11c4053f257", "patch": "@@ -846,8 +846,7 @@ _cpp_lex_token (pfile, result)\n   cppchar_t c;\n   cpp_buffer *buffer;\n   const unsigned char *comment_start;\n-  unsigned char was_skip_newlines = pfile->state.skip_newlines;\n-  unsigned char newline_in_args = 0;\n+  unsigned char bol = pfile->state.skip_newlines;\n \n  done_directive:\n   buffer = pfile->buffer;\n@@ -884,33 +883,23 @@ _cpp_lex_token (pfile, result)\n       goto next_char2;\n \n     case '\\n': case '\\r':\n-      /* Don't let directives spill over to the next line.  */\n-      if (pfile->state.in_directive)\n-\tbuffer->read_ahead = c;\n-      else\n+      if (!pfile->state.in_directive)\n \t{\n \t  handle_newline (buffer, c);\n-\n+\t  bol = 1;\n \t  pfile->lexer_pos.output_line = buffer->lineno;\n \n-\t  /* Skip newlines in macro arguments (except in directives).  */\n+\t  /* Newlines in arguments are white space (6.10.3.10).\n+             Otherwise, clear any white space flag.  */\n \t  if (pfile->state.parsing_args)\n-\t    {\n-\t      /* Set the whitespace flag.   */\n-\t      newline_in_args = 1;\n-\t      result->flags |= PREV_WHITE;\n-\t      goto next_char;\n-\t    }\n-\n-\t  if (was_skip_newlines)\n-\t    {\n-\t      /* Clear any whitespace flag.   */\n-\t      result->flags &= ~PREV_WHITE;\n-\t      goto next_char;\n-\t    }\n+\t    result->flags |= PREV_WHITE;\n+\t  else\n+\t    result->flags &= ~PREV_WHITE;\n+\t  goto next_char;\n \t}\n \n-      /* Next we're at BOL, so skip new lines.  */\n+      /* Don't let directives spill over to the next line.  */\n+      buffer->read_ahead = c;\n       pfile->state.skip_newlines = 1;\n       result->type = CPP_EOF;\n       break;\n@@ -1172,12 +1161,16 @@ _cpp_lex_token (pfile, result)\n \tc = get_effective_char (buffer);\n \n       if (c == '#')\n-\tACCEPT_CHAR (CPP_PASTE);\n-      else\n \t{\n-\t  result->type = CPP_HASH;\n-\tdo_hash:\n-\t  if (newline_in_args)\n+\t  ACCEPT_CHAR (CPP_PASTE);\n+\t  break;\n+\t}\n+\n+      result->type = CPP_HASH;\n+    do_hash:\n+      if (bol)\n+\t{\n+\t  if (pfile->state.parsing_args)\n \t    {\n \t      /* 6.10.3 paragraph 11: If there are sequences of\n \t\t preprocessing tokens within the list of arguments that\n@@ -1200,11 +1193,11 @@ _cpp_lex_token (pfile, result)\n \t      if (pfile->lexer_pos.col == 1)\n \t\tresult->flags &= ~PREV_WHITE;\n \t    }\n-\t  else if (was_skip_newlines)\n+\t  else\n \t    {\n \t      /* This is the hash introducing a directive.  */\n \t      if (_cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n-\t\tgoto done_directive; /* was_skip_newlines still 1.  */\n+\t\tgoto done_directive; /* bol still 1.  */\n \t      /* This is in fact an assembler #.  */\n \t    }\n \t}"}, {"sha": "fb34680862535becf4ec662addb1ac9ea86f8f33", "filename": "gcc/cpplib.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a949941cf79dc2bee4e741ce3928e11c4053f257", "patch": "@@ -1,4 +1,4 @@\n-/* CPP Library.\n+/* CPP Library. (Directive handling.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n@@ -837,12 +837,7 @@ do_ident (pfile)\n    to the front end.  C99 defines three pragmas and says that no macro\n    expansion is to be performed on them; whether or not macro\n    expansion happens for other pragmas is implementation defined.\n-   This implementation never macro-expands the text after #pragma.\n-\n-   We currently do not support the _Pragma operator.  Support for that\n-   has to be coordinated with the front end.  Proposed implementation:\n-   both #pragma blah blah and _Pragma(\"blah blah\") become\n-   __builtin_pragma(blah blah) and we teach the parser about that.  */\n+   This implementation never macro-expands the text after #pragma.  */\n \n /* Sub-handlers for the pragmas needing treatment here.\n    They return 1 if the token buffer is to be popped, 0 if not. */\n@@ -1700,19 +1695,6 @@ handle_assertion (pfile, str, type)\n   run_directive (pfile, type, str, count, 0);\n }\n \n-/* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n-int\n-cpp_defined (pfile, id, len)\n-     cpp_reader *pfile;\n-     const U_CHAR *id;\n-     int len;\n-{\n-  cpp_hashnode *hp = cpp_lookup (pfile, id, len);\n-\n-  /* If it's of type NT_MACRO, it cannot be poisoned.  */\n-  return hp->type == NT_MACRO;\n-}\n-\n /* Allocate a new cpp_buffer for PFILE, and push it on the input\n    buffer stack.  If BUFFER != NULL, then use the LENGTH characters in\n    BUFFER as the new input buffer.  Return the new buffer, or NULL on"}, {"sha": "ec3590ea7e6ca5f9e09d91b1f093a8b44538f0fa", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a949941cf79dc2bee4e741ce3928e11c4053f257/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=a949941cf79dc2bee4e741ce3928e11c4053f257", "patch": "@@ -902,9 +902,10 @@ _cpp_pop_context (pfile)\n }\n \n /* Internal routine to return a token, either from an in-progress\n-   macro expansion, or from the source file as appropriate.  Handles\n-   macros, so tokens returned are post-expansion.  Does not filter\n-   CPP_PLACEMARKER tokens.  Returns CPP_EOF at EOL and EOF.  */\n+   macro expansion, or from the source file as appropriate.\n+   Transparently enters included files.  Handles macros, so tokens\n+   returned are post-expansion.  Does not filter CPP_PLACEMARKER\n+   tokens.  Returns CPP_EOF at EOL and EOF.  */\n void\n _cpp_get_token (pfile, token)\n      cpp_reader *pfile;\n@@ -929,6 +930,7 @@ _cpp_get_token (pfile, token)\n \t      _cpp_pop_context (pfile);\n \t      continue;\n \t    }\n+\t  /* End of argument pre-expansion.  */\n \t  token->type = CPP_EOF;\n \t  token->flags = 0;\n \t}\n@@ -981,12 +983,13 @@ _cpp_get_token (pfile, token)\n \n /* External interface to get a token.  Tokens are returned after macro\n    expansion and directives have been handled, as a continuous stream.\n-   Transparently enters included files.  CPP_EOF indicates end of\n-   original source file.  Filters out CPP_PLACEMARKER tokens.\n+   Compared to the function above, CPP_EOF means EOF, and placemarker\n+   tokens are filtered out.  Also, it skips tokens if we're skipping,\n+   and saves tokens to lookahead.\n \n-   For the benefit of #pragma callbacks which may want to get the\n-   pragma's tokens, returns CPP_EOF to indicate end-of-directive in\n-   this case.  */\n+   CPP_EOF indicates end of original source file.  For the benefit of\n+   #pragma callbacks which may want to get the pragma's tokens,\n+   returns CPP_EOF to indicate end-of-directive in this case.  */\n void\n cpp_get_token (pfile, token)\n      cpp_reader *pfile;\n@@ -997,13 +1000,7 @@ cpp_get_token (pfile, token)\n       _cpp_get_token (pfile, token);\n \n       if (token->type == CPP_EOF)\n-\t{\n-\t  /* In directives we should pass through EOLs for the callbacks.  */\n-\t  if (pfile->buffer->cur == pfile->buffer->rlimit\n-\t      || pfile->state.in_directive || pfile->state.parsing_args)\n-\t    break;\n-\t  continue;\n-\t}\n+\tbreak;\n       /* We are not merging the PREV_WHITE of CPP_PLACEMARKERS.  I\n          don't think it really matters.  */\n       else if (pfile->skipping || token->type == CPP_PLACEMARKER)"}]}