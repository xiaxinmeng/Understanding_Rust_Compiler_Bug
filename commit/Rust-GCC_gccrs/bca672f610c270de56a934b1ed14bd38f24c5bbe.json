{"sha": "bca672f610c270de56a934b1ed14bd38f24c5bbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNhNjcyZjYxMGMyNzBkZTU2YTkzNGIxZWQxNGJkMzhmMjRjNWJiZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-06-09T06:18:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-06-09T06:18:38Z"}, "message": "re PR c++/53602 (Libre Office causes an internal compiler error)\n\nPR c++/53602\n\nFrom-SVN: r188358", "tree": {"sha": "f4ed1461ee6f6e5ff50293f27a1c7c19876677e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4ed1461ee6f6e5ff50293f27a1c7c19876677e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bca672f610c270de56a934b1ed14bd38f24c5bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca672f610c270de56a934b1ed14bd38f24c5bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bca672f610c270de56a934b1ed14bd38f24c5bbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca672f610c270de56a934b1ed14bd38f24c5bbe/comments", "author": null, "committer": null, "parents": [{"sha": "65c2e636b5c1051b9186c56e0ff30ded8ae0ec28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65c2e636b5c1051b9186c56e0ff30ded8ae0ec28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65c2e636b5c1051b9186c56e0ff30ded8ae0ec28"}], "stats": {"total": 365, "additions": 365, "deletions": 0}, "files": [{"sha": "1bb9cf4faaf67812e89cba86aec248d511593bf8", "filename": "gcc/testsuite/g++.dg/torture/pr53602.C", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bca672f610c270de56a934b1ed14bd38f24c5bbe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr53602.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bca672f610c270de56a934b1ed14bd38f24c5bbe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr53602.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr53602.C?ref=bca672f610c270de56a934b1ed14bd38f24c5bbe", "patch": "@@ -0,0 +1,365 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++11\" }\n+\n+namespace std\n+{\n+  template <class, class>\n+  struct pair\n+  {\n+  };\n+  struct input_iterator_tag\n+  {\n+  };\n+  struct forward_iterator_tag : public input_iterator_tag\n+  {\n+  };\n+  template <typename, typename _Tp, typename = _Tp>\n+  struct iterator\n+  {\n+  };\n+}\n+namespace __gnu_cxx\n+{\n+  template <typename _Tp>\n+  struct new_allocator\n+  {\n+    typedef _Tp pointer;\n+    typedef _Tp value_type;\n+    template <typename _Tp1>\n+    struct rebind\n+    {\n+      typedef new_allocator <_Tp1> other;\n+    };\n+  };\n+}\n+namespace std\n+{\n+  template <typename _Tp>\n+  struct allocator : public __gnu_cxx::new_allocator <_Tp>\n+  {\n+  };\n+}\n+extern \"C\"\n+{\n+  struct rtl_String;\n+  void rtl_string_release (rtl_String *) throw ();\n+  void rtl_string_newFromStr (rtl_String * *, const char *) throw ();\n+}\n+namespace std\n+{\n+  template <typename, typename, typename> struct binary_function;\n+  template <typename _Tp>\n+  struct equal_to : public binary_function <_Tp, _Tp, bool>\n+  {\n+  };\n+}\n+namespace rtl\n+{\n+  struct OString\n+  {\n+    rtl_String * pData;\n+    OString (const char *value)\n+    {\n+      rtl_string_newFromStr (&pData, value);\n+    }\n+     ~OString ()\n+    {\n+      rtl_string_release (pData);\n+    }\n+  };\n+  struct OStringHash;\n+}\n+namespace boost\n+{\n+  template <class> struct hash;\n+  namespace unordered\n+  {\n+    template <class T, class = boost::hash <T>, class = std::equal_to <T>, class = std::allocator <T>>class unordered_set;\n+  }\n+  using boost::unordered::unordered_set;\n+  namespace detail\n+  {\n+    template <bool>\n+    struct if_true\n+    {\n+      template <class, class F>\n+      struct then\n+      {\n+\ttypedef F type;\n+      };\n+    };\n+  }\n+  template <class, class> struct pointer_to_other;\n+  template <class T, class U>\n+  struct pointer_to_other <T *, U>\n+  {\n+    typedef U type;\n+  };\n+  namespace unordered\n+  {\n+    namespace detail\n+    {\n+      template <typename T, T> struct integral_constant\n+      {\n+      };\n+      struct choice9\n+      {\n+\ttypedef char (&type)[9];\n+      };\n+      struct choice8:choice9\n+      {\n+      };\n+      struct choice7:choice8\n+      {\n+      };\n+      struct choice6:choice7\n+      {\n+      };\n+      struct choice5:choice6\n+      {\n+      };\n+      struct choice4:choice5\n+      {\n+      };\n+      struct choice3:choice4\n+      {\n+      };\n+      struct choice2:choice3\n+      {\n+      };\n+      struct choice1:choice2\n+      {\n+      };\n+      choice1 choose ();\n+      template <typename Alloc, typename T>\n+      struct rebind_wrap\n+      {\n+\ttypedef typename Alloc::template rebind <T>::other type;\n+      };\n+      template <typename, typename T2>\n+      struct sfinae:T2\n+      {\n+      };\n+      template <typename Tp, typename Default>\n+      struct default_type_pointer\n+      {\n+\ttemplate <typename X>\n+\tstatic boost::unordered::detail::sfinae <typename X::pointer, choice1> test (choice1);\n+\tstruct DefaultWrap\n+\t{\n+\t  typedef Default pointer;\n+\t};\n+\tenum { value = (1 == sizeof (test <Tp> (choose ()))) };\n+\ttypedef typename boost::detail::if_true <value>::template then <Tp, DefaultWrap>::type::pointer type;\n+      };\n+      template <typename Tp, typename Default>\n+      struct default_type_const_pointer\n+      {\n+\ttemplate <typename>\n+\tstatic choice2::type test (choice2);\n+\tstruct DefaultWrap\n+\t{\n+\t};\n+\tenum { value = (1 == sizeof (test <Tp> (choose ()))) };\n+\ttypedef typename boost::detail::if_true <value>::template then <Tp, DefaultWrap> type;\n+      };\n+      struct default_type_propagate_on_container_swap\n+      {\n+\tstruct DefaultWrap\n+\t{\n+\t};\n+      };\n+      template <typename Alloc>\n+      struct allocator_traits\n+      {\n+\ttypedef typename Alloc::value_type value_type;\n+\ttypedef typename default_type_pointer <Alloc, value_type *>::type pointer;\n+\ttemplate <typename T>\n+\tstruct pointer_to_other : boost::pointer_to_other <pointer, T>\n+\t{\n+\t};\n+\ttypedef typename default_type_const_pointer <Alloc, typename pointer_to_other <value_type>::type>::type const_pointer;\n+      };\n+    }\n+    namespace detail\n+    {\n+      struct move_tag\n+      {\n+      };\n+      template <typename> struct table;\n+      template <typename NodeAlloc>\n+      struct node_constructor\n+      {\n+\tvoid construct_value ()\n+\t{\n+\t}\n+      };\n+      struct ptr_bucket\n+      {\n+\tptr_bucket ()\n+\t{\n+\t}\n+      };\n+      template <typename A, typename Bucket, typename Node>\n+      struct buckets\n+      {\n+\ttypedef Node node;\n+\ttypedef Bucket bucket;\n+\ttypedef typename boost::unordered::detail::rebind_wrap <A, node>::type node_allocator;\n+\ttypedef typename boost::unordered::detail::rebind_wrap <A, bucket>::type bucket_allocator;\n+\ttypedef boost::unordered::detail::allocator_traits <node_allocator> node_allocator_traits;\n+\ttypedef boost::unordered::detail::allocator_traits <bucket_allocator> bucket_allocator_traits;\n+\ttypedef typename node_allocator_traits::pointer node_pointer;\n+\ttypedef typename node_allocator_traits::const_pointer const_node_pointer;\n+\ttypedef typename bucket_allocator_traits::pointer bucket_pointer;\n+\ttypedef boost::unordered::detail::node_constructor <node_allocator> node_constructor;\n+\tbucket_pointer buckets_;\n+\tunsigned size_;\n+\ttemplate <typename Types>\n+\tbuckets (boost::unordered::detail::table <Types>, boost::unordered::detail::move_tag) : buckets_ (), size_ ()\n+\t{\n+\t}\n+      };\n+      struct functions\n+      {\n+      };\n+    }\n+  }\n+  namespace detail\n+  {\n+    template <class Category, class T, class, class, class>\n+    struct iterator_base:std::iterator <Category, T>\n+    {\n+    };\n+  }\n+  template <class Category, class T, class Distance, class Pointer = T, class Reference = T>\n+  struct iterator:boost::detail::iterator_base <Category, T, Distance, Pointer, Reference>\n+  {\n+  };\n+  namespace unordered\n+  {\n+    namespace iterator_detail\n+    {\n+      template <typename, typename NodePointer, typename Value> struct c_iterator:public boost::iterator <std::forward_iterator_tag, Value, int>\n+      {\n+\tfriend bool operator== (c_iterator, c_iterator)\n+\t{\n+\t}\n+      };\n+    }\n+    namespace detail\n+    {\n+      template <typename ValueType>\n+      struct value_base\n+      {\n+\ttypedef ValueType value_type;\n+\tvalue_type value ()\n+\t{\n+\t}\n+      };\n+      template <typename Types>\n+      struct table:boost::unordered::detail::buckets <typename Types::allocator, typename Types::bucket, typename Types::key_equal>\n+      {\n+\ttypedef typename Types::value_type value_type;\n+\ttypedef boost::unordered::detail::buckets <typename Types::allocator, typename Types::bucket, typename Types::node> buckets;\n+\ttypedef typename buckets::node_pointer node_pointer;\n+\ttypedef typename buckets::const_node_pointer const_node_pointer;\n+\ttypedef boost::unordered::iterator_detail::c_iterator <const_node_pointer, node_pointer, value_type> c_iterator;\n+\tunsigned max_size ()\n+\t{\n+\t}\n+      };\n+      template <typename> struct table_impl;\n+      template <typename T>\n+      struct ptr_node : boost::unordered::detail::value_base <T>, boost::unordered::detail::ptr_bucket\n+      {\n+\tboost::unordered::detail::ptr_bucket bucket_base;\n+\tunsigned hash_;\n+\tptr_node () : bucket_base (), hash_ ()\n+\t{\n+\t}\n+      };\n+      template <typename A, typename T, typename, typename> struct pick_node2\n+      {\n+      };\n+      template <typename A, typename T> struct pick_node2 <A, T, boost::unordered::detail::ptr_node <T> *, boost::unordered::detail::ptr_bucket *>\n+      {\n+\ttypedef boost::unordered::detail::ptr_node <T> node;\n+\ttypedef boost::unordered::detail::ptr_bucket bucket;\n+      };\n+      template <typename A, typename T> struct pick_node\n+      {\n+\ttypedef boost::unordered::detail::allocator_traits <typename boost::unordered::detail::rebind_wrap <A, boost::unordered::detail::ptr_node <T>>::type> tentative_node_traits;\n+\ttypedef boost::unordered::detail::allocator_traits <typename boost::unordered::detail::rebind_wrap <A, boost::unordered::detail::ptr_bucket>::type> tentative_bucket_traits;\n+\ttypedef pick_node2 <A, T, typename tentative_node_traits::pointer, typename tentative_bucket_traits::pointer> pick;\n+\ttypedef typename pick::node node;\n+\ttypedef typename pick::bucket bucket;\n+      };\n+      template <typename A, typename T, typename H, typename P>\n+      struct set\n+      {\n+\ttypedef boost::unordered::detail::set <A, T, H, P> types;\n+\ttypedef T value_type;\n+\ttypedef P key_equal;\n+\ttypedef typename boost::unordered::detail::rebind_wrap <A, value_type>::type allocator;\n+\ttypedef boost::unordered::detail::pick_node <allocator, value_type> pick;\n+\ttypedef typename pick::node node;\n+\ttypedef typename pick::bucket bucket;\n+\ttypedef boost::unordered::detail::table_impl <types> table;\n+      };\n+      template <typename Types>\n+      struct table_impl : boost::unordered::detail::table <Types>\n+      {\n+\ttypedef boost::unordered::detail::table <Types> table;\n+\ttypedef typename table::node_constructor node_constructor;\n+\ttable_impl () : table ()\n+\t{\n+\t}\n+\ttemplate <class InputIt>\n+\tvoid insert_range_impl2 (node_constructor, InputIt)\n+\t{\n+\t}\n+      };\n+    }\n+    template <class T, class H, class P, class A>\n+    struct unordered_set\n+    {\n+      typedef T key_type;\n+      typedef T value_type;\n+      typedef boost::unordered::detail::set <A, T, H, P> types;\n+      typedef typename types::table table;\n+      typedef typename table::c_iterator const_iterator;\n+      typedef typename table::c_iterator iterator;\n+      table table_;\n+      bool empty ()\n+      {\n+\treturn table_.size_;\n+      }\n+      iterator end ()\n+      {\n+      }\n+      std::pair <iterator, bool> insert (value_type)\n+      {\n+      }\n+      unsigned erase (const key_type &);\n+      const_iterator find (const key_type);\n+    };\n+    template <class T, class H, class P, class A>\n+    unsigned unordered_set <T, H, P, A>::erase (const key_type &)\n+    {\n+    }\n+  }\n+}\n+using namespace::rtl;\n+namespace skeletonmaker\n+{\n+  void\n+  checkDefaultInterfaces (boost::unordered_set <OString, OStringHash> interfaces,\n+\t\t\t  boost::unordered_set <OStringHash> services, OString)\n+  {\n+    if (services.empty ())\n+      interfaces.erase (\"com.sun.star.lang.XServiceInfo\");\n+    else if (interfaces.find (\"com.sun.star.lang.XServiceInfo\") == interfaces.end ())\n+      interfaces.insert (\"com.sun.star.lang.XServiceInfo\");\n+  }\n+}"}]}