{"sha": "de41e41c4289c76cfbc3153411638eefac8104a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0MWU0MWM0Mjg5Yzc2Y2ZiYzMxNTM0MTE2MzhlZWZhYzgxMDRhMQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@redhat.com", "date": "2001-11-09T14:57:50Z"}, "committer": {"name": "Catherine Moore", "email": "clm@gcc.gnu.org", "date": "2001-11-09T14:57:50Z"}, "message": "m32r.c: Add support for m32rx processor.\n\n        * m32r.c: Add support for m32rx processor.\n        * m32r.h: Ditto.\n        * m32r.md: Ditto.\n        * t-m32r: Ditto.\n        * m32r-protos.h: Add prototypes for m32rx functions.\n        * doc/invoke.texi: Document -m32rx option.\n\nCo-Authored-By: Andrew MacLeod <amacleod@redhat.com>\nCo-Authored-By: Catherine Moore <clm@redhat.com>\nCo-Authored-By: Michael Meissner <meissner@redhat.com>\nCo-Authored-By: Nick Clifton <nickc@redhat.com>\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r46881", "tree": {"sha": "26096eb78709ecc00a9a89bfd146f7b77bf98a18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26096eb78709ecc00a9a89bfd146f7b77bf98a18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de41e41c4289c76cfbc3153411638eefac8104a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de41e41c4289c76cfbc3153411638eefac8104a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de41e41c4289c76cfbc3153411638eefac8104a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de41e41c4289c76cfbc3153411638eefac8104a1/comments", "author": null, "committer": null, "parents": [{"sha": "a3d87e92eb015631e52c1408798ae4cf29d4703c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d87e92eb015631e52c1408798ae4cf29d4703c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d87e92eb015631e52c1408798ae4cf29d4703c"}], "stats": {"total": 233, "additions": 219, "deletions": 14}, "files": [{"sha": "ddb272eeb52831d434bd7a384c21acbb8870155d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de41e41c4289c76cfbc3153411638eefac8104a1", "patch": "@@ -1,3 +1,17 @@\n+2001-11-09 Ben Elliston  <bje@redhat.com>\n+\t   Michael Meissner  <meissner@redhat.com>\n+           Andrew MacLeod  <amacleod@redhat.com>\n+\t   Richard Henderson  <rth@redhat.com>\n+\t   Nick Clifton  <nickc@redhat.com>\n+\t   Catherine Moore  <clm@redhat.com>\n+\n+\t* m32r.c: Add support for m32rx processor.\n+\t* m32r.h: Ditto.\n+\t* m32r.md: Ditto.\n+\t* t-m32r: Ditto.\n+\t* m32r-protos.h: Add prototypes for m32rx functions.\n+\t* doc/invoke.texi: Document -m32rx option.\n+\n 2001-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.md (movdf): Avoid calling validize_mem during"}, {"sha": "8b51ea16b85f9eed9142a812ce56c0764c44d284", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=de41e41c4289c76cfbc3153411638eefac8104a1", "patch": "@@ -90,6 +90,8 @@ extern int    m32r_block_immediate_operand \tPARAMS ((rtx, Mmode));\n extern int    extend_operand\t\t\tPARAMS ((rtx, Mmode));\n extern int    reg_or_eq_int16_operand\t\tPARAMS ((rtx, Mmode));\n extern int    int8_operand\t\t\tPARAMS ((rtx, Mmode));\n+extern int    reg_or_zero_operand               PARAMS ((rtx, Mmode));\n+\n #endif /* HAVE_MACHINE_MODES */\n \n #ifdef TREE_CODE"}, {"sha": "9ff0081ede09d39c92bdb406aa24eed2a182f2b0", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=de41e41c4289c76cfbc3153411638eefac8104a1", "patch": "@@ -171,7 +171,7 @@ unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] =\n {\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, S_MODES, S_MODES, S_MODES,\n-  S_MODES, C_MODES, A_MODES\n+  S_MODES, C_MODES, A_MODES, A_MODES\n };\n \n unsigned int m32r_mode_class [NUM_MACHINE_MODES];\n@@ -462,6 +462,10 @@ m32r_encode_section_info (decl)\n \n       strcpy (newstr + 1, str);\n       *newstr = prefix;\n+      /* Note - we cannot leave the string in the ggc_alloc'ed space.\n+         It must reside in the stringtable's domain.  */\n+      newstr = (char *) ggc_alloc_string (newstr, len + 2);\n+\n       XSTR (XEXP (rtl, 0), 0) = newstr;\n     }\n }\n@@ -734,6 +738,22 @@ reg_or_cmp_int16_operand (op, mode)\n   return CMP_INT16_P (INTVAL (op));\n }\n \n+/* Return true if OP is a register or the constant 0.  */\n+\n+int\n+reg_or_zero_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  return INTVAL (op) == 0;\n+}\n+\n /* Return true if OP is a const_int requiring two instructions to load.  */\n \n int"}, {"sha": "8d15250e98bca2d989c43c585f7afbd867a60fed", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=de41e41c4289c76cfbc3153411638eefac8104a1", "patch": "@@ -40,6 +40,58 @@ Boston, MA 02111-1307, USA.  */\n #undef ENDFILE_SPEC\n #undef SUBTARGET_SWITCHES\n \f\n+\n+/* M32R/X overrides.  */\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (m32r/x)\");\n+\n+/* Additional flags for the preprocessor.  */\n+#define CPP_CPU_SPEC \"%{m32rx:-D__M32RX__} %{m32r:-U__M32RX__}\"\n+\n+/* Assembler switches.  */\n+#define ASM_CPU_SPEC \\\n+\"%{m32r} %{m32rx} %{!O0: %{O*: -O}} --no-warn-explicit-parallel-conflicts\"\n+\n+/* Use m32rx specific crt0/crtinit/crtfini files.  */\n+#define STARTFILE_CPU_SPEC \"%{!shared:crt0.o%s} %{m32rx:m32rx/crtinit.o%s} %{!m32rx:crtinit.o%s}\"\n+#define ENDFILE_CPU_SPEC \"-lgloss %{m32rx:m32rx/crtfini.o%s} %{!m32rx:crtfini.o%s}\"\n+\n+/* Extra machine dependent switches.  */\n+#define SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n+    { \"32rx\",\t\t\tTARGET_M32RX_MASK, \"Compile for the m32rx\" },\t\\\n+    { \"32r\",\t\t\t-TARGET_M32RX_MASK, \"\" },\n+\n+/* Define this macro as a C expression for the initializer of an array of\n+   strings to tell the driver program which options are defaults for this\n+   target and thus do not need to be handled specially when using\n+   `MULTILIB_OPTIONS'.  */\n+#define SUBTARGET_MULTILIB_DEFAULTS , \"m32r\"\n+\n+/* Number of additional registers the subtarget defines.  */\n+#define SUBTARGET_NUM_REGISTERS 1\n+\n+/* 1 for registers that cannot be allocated.  */\n+#define SUBTARGET_FIXED_REGISTERS , 1\n+\n+/* 1 for registers that are not available across function calls.  */\n+#define SUBTARGET_CALL_USED_REGISTERS , 1\n+\n+/* Order to allocate model specific registers.  */\n+#define SUBTARGET_REG_ALLOC_ORDER , 19\n+\n+/* Registers which are accumulators.  */\n+#define SUBTARGET_REG_CLASS_ACCUM 0x80000\n+\n+/* All registers added.  */\n+#define SUBTARGET_REG_CLASS_ALL SUBTARGET_REG_CLASS_ACCUM\n+\n+/* Additional accumulator registers.  */\n+#define SUBTARGET_ACCUM_P(REGNO) ((REGNO) == 19)\n+\n+/* Define additional register names.  */\n+#define SUBTARGET_REGISTER_NAMES , \"a1\"\n+/* end M32R/X overrides.  */\n+\n /* Print subsidiary information on the compiler version in use.  */\n #ifndef\tTARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (m32r)\")\n@@ -161,6 +213,12 @@ extern int target_flags;\n /* Target machine to compile for.  */\n #define TARGET_M32R \t\t1\n \n+/* Support extended instruction set.  */\n+#define TARGET_M32RX_MASK       (1 << 5)\n+#define TARGET_M32RX            (target_flags & TARGET_M32RX_MASK)\n+#undef  TARGET_M32R\n+#define TARGET_M32R             (! TARGET_M32RX)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -513,7 +571,7 @@ extern enum m32r_sdata m32r_sdata;\n    16    - arg pointer\n    17    - carry flag\n    18\t - accumulator\n-\n+   19    - accumulator 1 in the m32r/x\n    By default, the extension registers are not available.  */\n \n #ifndef SUBTARGET_FIXED_REGISTERS\n@@ -2051,6 +2109,7 @@ enum m32r_function_type\n    matched by the predicate.  The list should have a trailing comma.  */\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+{ \"reg_or_zero_operand\",        { REG, SUBREG, CONST_INT }},            \\\n { \"conditional_move_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n { \"carry_compare_operand\",\t{ EQ, NE }},\t\t\t\t\\\n { \"eqne_comparison_operator\",\t{ EQ, NE }},\t\t\t\t\\"}, {"sha": "470a05da232d006b882f9c7a64aadcf4aac33d36", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 101, "deletions": 8, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=de41e41c4289c76cfbc3153411638eefac8104a1", "patch": "@@ -69,6 +69,26 @@\n (define_attr \"m32r\" \"no,yes\"\n   (const (symbol_ref \"(TARGET_M32R != 0)\")))\n \n+(define_attr \"m32rx\" \"no,yes\"\n+  (const (symbol_ref \"(TARGET_M32RX != 0)\")))\n+\n+(define_attr \"m32rx_pipeline\" \"either,s,o,long,m32r\"\n+  (cond [(eq_attr \"m32rx\" \"no\")\n+         (const_string \"m32r\")\n+\n+         (eq_attr \"insn_size\" \"!short\")\n+         (const_string \"long\")]\n+\n+        (cond [(eq_attr \"type\" \"int2\")\n+               (const_string \"either\")\n+\n+               (eq_attr \"type\" \"load2,store2,shift2,uncond_branch,branch,call\")\n+               (const_string \"o\")\n+\n+               (eq_attr \"type\" \"mul2\")\n+               (const_string \"s\")]\n+\n+              (const_string \"long\"))))\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -218,6 +238,36 @@\n   3 0\n   [(eq_attr \"insn_size\" \"short\")])\n \n+(define_function_unit \"left\" 1 1\n+  (and (eq_attr \"m32rx_pipeline\" \"o,either\")\n+       (eq_attr \"type\" \"!load2\"))\n+  1 0\n+  [(eq_attr \"insn_size\" \"long\")])\n+\n+(define_function_unit \"left\" 1 1\t;; load delay of 1 clock for mem execution + 1 clock for WB\n+  (and (eq_attr \"m32rx_pipeline\" \"o,either\")\n+       (eq_attr \"type\" \"load2\"))\n+  3 0\n+  [(eq_attr \"insn_size\" \"long\")])\n+\n+(define_function_unit \"right\" 1 1\n+  (eq_attr \"m32rx_pipeline\" \"s,either\")\n+  1 0\n+  [(eq_attr \"insn_size\" \"long\")])\n+\n+(define_function_unit \"long\" 1 1\n+  (and (eq_attr \"m32rx\" \"yes\")\n+       (and (eq_attr \"insn_size\" \"long\")\n+\t    (eq_attr \"type\" \"!load4,load8\")))\n+  2 0\n+  [(eq_attr \"insn_size\" \"short\")])\n+\n+(define_function_unit \"long\" 1 1\t;; load delay of 1 clock for mem execution + 1 clock for WB\n+  (and (eq_attr \"m32rx\" \"yes\")\n+       (and (eq_attr \"insn_size\" \"long\")\n+\t    (eq_attr \"type\" \"load4,load8\")))\n+  3 0\n+  [(eq_attr \"insn_size\" \"short\")])\n \f\n ;; Expand prologue as RTL\n (define_expand \"prologue\"\n@@ -1126,14 +1176,25 @@\n   DONE;\n }\")\n \n+(define_insn \"cmp_eqsi_zero_insn\"\n+  [(set (reg:SI 17)\n+        (eq:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+               (match_operand:SI 1 \"reg_or_zero_operand\" \"r,P\")))]\n+  \"TARGET_M32RX\"\n+  \"@\n+   cmpeq %0, %1\n+   cmpz  %0\"\n+  [(set_attr \"type\" \"int4\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; The cmp_xxx_insn patterns set the condition bit to the result of the\n ;; comparison.  There isn't a \"compare equal\" instruction so cmp_eqsi_insn\n ;; is quite inefficient.  However, it is rarely used.\n \n (define_insn \"cmp_eqsi_insn\"\n   [(set (reg:SI 17)\n-\t(eq:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t       (match_operand:SI 1 \"reg_or_cmp_int16_operand\" \"r,P\")))\n+        (eq:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+               (match_operand:SI 1 \"reg_or_cmp_int16_operand\" \"r,P\")))\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n   \"\"\n   \"*\n@@ -1157,8 +1218,8 @@\n \n (define_insn \"cmp_ltsi_insn\"\n   [(set (reg:SI 17)\n-\t(lt:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t       (match_operand:SI 1 \"reg_or_int16_operand\" \"r,J\")))]\n+        (lt:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+               (match_operand:SI 1 \"reg_or_int16_operand\" \"r,J\")))]\n   \"\"\n   \"@\n    cmp %0,%1\n@@ -1168,15 +1229,16 @@\n \n (define_insn \"cmp_ltusi_insn\"\n   [(set (reg:SI 17)\n-\t(ltu:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t        (match_operand:SI 1 \"reg_or_int16_operand\" \"r,J\")))]\n+        (ltu:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+                (match_operand:SI 1 \"reg_or_int16_operand\" \"r,J\")))]\n   \"\"\n   \"@\n    cmpu %0,%1\n    cmpui %0,%#%1\"\n   [(set_attr \"type\" \"int2,int4\")\n    (set_attr \"length\" \"2,4\")])\n \n+\n ;; reg == small constant comparisons are best handled by putting the result\n ;; of the comparison in a tmp reg and then using beqz/bnez.\n ;; ??? The result register doesn't contain 0/STORE_FLAG_VALUE,\n@@ -1448,7 +1510,7 @@\n   \"\"\n   \"*\n {\n-  const char *br,*invbr;\n+  char *br,*invbr;\n   char asmtext[40];\n \n   switch (GET_CODE (operands[1]))\n@@ -1495,7 +1557,7 @@\n   \"\"\n   \"*\n {\n-  const char *br,*invbr;\n+  char *br,*invbr;\n   char asmtext[40];\n \n   switch (GET_CODE (operands[1]))\n@@ -1550,6 +1612,14 @@\n   if (! register_operand (op1, mode))\n     op1 = force_reg (mode, op1);\n \n+  if (TARGET_M32RX)\n+    {\n+      if (! reg_or_zero_operand (op2, mode))\n+        op2 = force_reg (mode, op2);\n+\n+      emit_insn (gen_seq_insn_m32rx (op0, op1, op2));\n+      DONE;\n+    }\n   if (GET_CODE (op2) == CONST_INT && INTVAL (op2) == 0)\n     {\n       emit_insn (gen_seq_zero_insn (op0, op1));\n@@ -1563,6 +1633,29 @@\n   DONE;\n }\")\n \n+(define_insn \"seq_insn_m32rx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t       (match_operand:SI 2 \"reg_or_zero_operand\" \"rP\")))\n+   (clobber (reg:SI 17))]\n+  \"TARGET_M32RX\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"reg_or_zero_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"TARGET_M32RX\"\n+  [(set (reg:SI 17)\n+\t(eq:SI (match_dup 1)\n+\t       (match_dup 2)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))]\n+  \"\")\n+\n (define_insn \"seq_zero_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(eq:SI (match_operand:SI 1 \"register_operand\" \"r\")"}, {"sha": "e7d56affeff19c8edb280aa1d2c1d8b48d6bec0c", "filename": "gcc/config/m32r/t-m32r", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Ft-m32r", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fconfig%2Fm32r%2Ft-m32r", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Ft-m32r?ref=de41e41c4289c76cfbc3153411638eefac8104a1", "patch": "@@ -36,17 +36,30 @@ crtfini.o: $(srcdir)/config/m32r/initfini.c $(GCC_PASSES) $(CONFIG_H)\n \t  -DCRT_FINI -finhibit-size-directive -fno-inline-functions \\\n \t  -g0 -mmodel=medium -c $(srcdir)/config/m32r/initfini.c -o crtfini.o\n \n+m32rx:\n+\tmkdir $@\n+\n+m32rx/crtinit.o: m32rx $(srcdir)/config/m32r/initfini.c $(GCC_PASSES) $(CONFIG_H)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n+\t-DCRT_INIT -finhibit-size-directive -fno-inline-functions \\\n+\t-g0 -mmodel=medium -c $(srcdir)/config/m32r/initfini.c -m32rx \\\n+\t-o m32rx/crtinit.o\n+\n+m32rx/crtfini.o: m32rx $(srcdir)/config/m32r/initfini.c $(GCC_PASSES) $(CONFIG_H)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n+\t-DCRT_FINI -finhibit-size-directive -fno-inline-functions \\\n+\t-g0 -mmodel=medium -c $(srcdir)/config/m32r/initfini.c -m32rx \\\n+\t-o m32rx/crtfini.o\n \n # -mmodel={small,medium} requires separate libraries.\n # We don't build libraries for the large model, instead we use the medium\n # libraries.  The only difference is that the large model can handle jumps\n # more than 26 signed bits away.\n \n-MULTILIB_OPTIONS = mmodel=small/mmodel=medium\n-MULTILIB_DIRNAMES = small medium\n+MULTILIB_OPTIONS = mmodel=small/mmodel=medium m32r/m32rx\n+MULTILIB_DIRNAMES = small medium m32r m32rx\n MULTILIB_MATCHES = mmodel?medium=mmodel?large\n \n-\n # Set MULTILIB_EXTRA_OPTS so shipped libraries have small data in .sdata and\n # SHN_M32R_SCOMMON.\n # This is important for objects referenced in system header files."}, {"sha": "059464a3467b647c711f71fc6fa7f4ddac6dad0d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de41e41c4289c76cfbc3153411638eefac8104a1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=de41e41c4289c76cfbc3153411638eefac8104a1", "patch": "@@ -402,7 +402,7 @@ in the following sections.\n \n @emph{M32R/D Options}\n @gccoptlist{\n--mcode-model=@var{model-type}  -msdata=@var{sdata-type} @gol\n+-mm32rx -mcode-model=@var{model-type}  -msdata=@var{sdata-type} @gol\n -G @var{num}}\n \n @emph{M88K Options}\n@@ -6227,6 +6227,10 @@ This option makes symbolic debugging impossible.\n These @option{-m} options are defined for Mitsubishi M32R/D architectures:\n \n @table @gcctabopt\n+@item -mm32rx\n+@opindex mm32rx\n+Generate code for the M32R/X.  The default is to generate code for the M32R.\n+\n @item -mcode-model=small\n @opindex mcode-model=small\n Assume all objects live in the lower 16MB of memory (so that their addresses"}]}