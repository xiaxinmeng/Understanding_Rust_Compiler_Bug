{"sha": "dee4682a7ad30b0e642d755e02168d7db25c6d67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlNDY4MmE3YWQzMGIwZTY0MmQ3NTVlMDIxNjhkN2RiMjVjNmQ2Nw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-04-06T09:20:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:20:11Z"}, "message": "exp_ch13.adb (Expand_External_Tag_Definition): Replace call to the run-time subprogram Set_External_Tag by call to...\n\n2007-04-06  Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch13.adb (Expand_External_Tag_Definition): Replace call to the\n\trun-time subprogram Set_External_Tag by call to Build_Set_External_Tag.\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): Don't perform a run-time\n\taccessibility on class-wide allocators if the allocator occurs at the\n\tsame scope level as the allocator's type. The check is guaranteed to\n\tsucceed in that case, even when the expression originates from a\n\tparameter of the containing subprogram.\n\t(Expand_N_Op_Eq): Do nothing in case of dispatching call if compiling\n\tunder No_Dispatching_Calls restriction. During the semantic analysis\n\twe already notified such violation.\n\t(Tagged_Membership): Constant folding. There is no need to check\n\tthe tag at run-time if the type of the right operand is non\n\tclass-wide abstract.\n\tReplace call to Is_Ancestor by call to Is_Parent\n\tto support concurrent types with interface types.\n\t(Expand_N_Allocator): Add an assertion associated with the generation\n\tof the master_id.\n\t(Expand_N_Slice): Do not enable range check to nodes associated\n\twith the frontend expansion of the dispatch table.\n\t(Is_Local_Access_Discriminant): Subsidiary function to\n\tExpand_N_Allocator.\n\t(Tagged_Membership): Replace generation of call to the run-time\n\tsubprogram CW_Membership by call to Build_CW_Membership.\n\t(Expand_Allocator_Expression): Replace generation of call to the\n\trun-time subprogram Get_Access_Level by call to Build_Get_Access_Level.\n\n\t* exp_disp.ads, exp_disp.adb (Make_DT): Code reorganization to\n\tinitialize most the TSD components by means of an aggregate.\n\tModify the declaration of the object containing the TSD\n\tbecause we now expand code that has a higher level of abstraction.\n\tThe TSD has a discriminant containing the Inheritance Depth Level,\n\tvalue that is used in the membership test but also to fix the size\n\tof the table of ancestors.\n\t(Expand_Interface_Conversion): Insert function body at the closest place\n\tto the conversion expression, to prevent access-before-elaboration\n\terrors in the backend.\n\tCode improved to reduce the size of the dispatch table if\n\tcompiling under restriction No_Dispatching_Calls plus code cleanup.\n\tCode reorganization plus removal of calls to Set_Num_Prim_Ops\n\t(Make_Secondary_DT): Remove call to Set_Num_Prim_Ops.\n\t(Expand_Dispatching_Call): Minor code reorganization plus addition of\n\tcode to return immediately if compiling under No_Dispatching_Calls\n\trestriction.\n\t(Set_All_DT_Position): Remove code associated with the old CPP pragmas.\n\tCPP_Virtual and CPP_Vtable are no longer supported.\n\t(Expand_Interface_Conversion): Add missing support for interface type\n\tderivations.\n\t(Expand_Interface_Actuals): Replace calls to Is_Ancestor by calls to\n\tIs_Parent to support concurrent types with interfaces.\n\t(Init_Predefined_Interface_Primitives): Removed.\n\t(Make_Secondary_DT): Modified to support concurrent record types.\n\t(Set_All_DT_Position): Modified to support concurrent record types.\n\t(Ada_Actions, Action_Is_Proc, Action_Nb_Arg): Remove entries associated\n\twith Get_External_Tag, Inherit_TSD, Set_External_Tag.\n\t(Ada_Actions, Action_Is_Proc, Action_Nb_Arg): Remove entry associated\n\twith CW_Membership.\n\t(Ada_Actions, Action_Is_Proc, Action_Nb_Arg): Remove entries associated\n\twith Get_Access_Level, Get_Predefined_Prim_Op_Address,\n\tGet_Prim_Op_Address Get_RC_Offset, Get_Remotely_Callable, Inherit_DT,\n\tSet_Access_Level, Set_Expanded_Name, Set_Predefined_Prim_Op_Address,\n\tSet_Prim_Op_Address, Set_RC_Offset, Set_Remotely_Callable, Set_TSD.\n\t(Expand_Dispatching_Call): Replace generation of call to the run-time\n\tsubprograms Get_Predefined_Prim_Op_Address and Get_Prim_Op_Address by\n\tcalls to Build_Get_Predefined_Prim_Op_Address, and Build_Get_Prim_Op_\n\tAddress.\n\t(Fill_DT_Entry, Fill_Secondary_DT_Entry): Replace generation of call to\n\tthe run-time subprograms Set_Predefined_Prim_Op_Address and Set_Prim_\n\tOp_Address by calls to Build_Set_Predefined_Prim_Op_Address, and\n\tBuild_Set_Prim_Op_Address.\n\t(Get_Remotely_Callable): Subprogram removed.\n\t(Init_Predefined_Interface_Primitives): Replace generation of call to\n\tthe run-time subprograms Inherit_DT by call to Build_Inherit_Predefined_\n\tPrims.\n\n\t* sem_elab.adb (Set_Elaboration_Constraint): Replace the call to\n\tFirst (Parameter_Associations ()) with the call to First_Actual that\n\treturns an actual parameter expression for both named and positional\n\tassociations.\n\n\t* sem_disp.adb (Check_Dispatching_Call): In case of dispatching call\n\tcheck violation of restriction No_Dispatching_Calls.\n\t(Check_Controlling_Type): A formal of a tagged incomplete type is a\n\tcontrolling argument.\n\n\t* exp_util.ads, exp_util.adb (Type_May_Have_Bit_Aligned_Components): Use\n\tFirst/Next_Component_Or_Discriminant\n\t(Insert_Actions): Add entries for new N_Push and N_Pop nodes\n\t(Find_Implemented_Interface): Removed. All the calls to this subprogram\n\tspecify Any_Limited_Interface, and this functionality is already\n\tprovided by the function Has_Abstract_Interfaces.\n\t(Find_Interface, Find_Interface_Tag, Find_Interface_ADT): Modified to\n\tsupport concurrent types implementing interfaces.\n\t(Find_Implemented_Interface): Removed. All the calls to this subprogram\n\tspecify kind Any_Limited_Interface, and this functionality is already\n\tprovided by the function Has_Abstract_Interfaces.\n\t(Remove_Side_Effects): replace Controlled_Type by\n\tCW_Or_Controlled_Type whenever the issue is related to\n\tusing or not the secondary stack.\n\n\t* par-ch12.adb (P_Formal_Type_Definition): Update calls to\n\tP_Interface_Type_Definition to fulfill the new interface (the formal\n\tIs_Synchronized is no longer required).\n\n\t* Make-lang.in (GNAT_ADA_OBJS): Addition of exp_atag.o\n\tUpdate dependencies.\n\n\t* exp_atag.ads, exp_atag.adb: New file\n\nFrom-SVN: r123562", "tree": {"sha": "c3f2bb77ee7464518c0c0018ae8c01b2611f32d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3f2bb77ee7464518c0c0018ae8c01b2611f32d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee4682a7ad30b0e642d755e02168d7db25c6d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee4682a7ad30b0e642d755e02168d7db25c6d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee4682a7ad30b0e642d755e02168d7db25c6d67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee4682a7ad30b0e642d755e02168d7db25c6d67/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5277cab69bcf175da5fb53b32ae24a61401e610e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5277cab69bcf175da5fb53b32ae24a61401e610e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5277cab69bcf175da5fb53b32ae24a61401e610e"}], "stats": {"total": 4517, "additions": 2531, "deletions": 1986}, "files": [{"sha": "91240ed000aa8bc76a5e2dac41d5b50a3f838b0f", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 653, "deletions": 607, "changes": 1260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67"}, {"sha": "8756136a15afc314dfb9cd06aba1823eb3630422", "filename": "gcc/ada/exp_atag.adb", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -0,0 +1,688 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ A T A G                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Exp_Util; use Exp_Util;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Rtsfind;  use Rtsfind;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+\n+package body Exp_Atag is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Build_Predefined_DT\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id;\n+   --  Build code that displaces the Tag to reference the dispatch table\n+   --  containing the predefined primitives.\n+   --\n+   --  Generates: To_Tag (To_Address (Tag_Node) - DT_Prologue_Size);\n+   pragma Inline (Build_Predefined_DT);\n+\n+   function Build_Typeinfo_Offset (Loc : Source_Ptr) return Node_Id;\n+   --  Build code that gives access to the distance from the tag to the\n+   --  Typeinfo component of the dispatch table.\n+   --\n+   --  Generates: DT_Typeinfo_Ptr_Size\n+   pragma Inline (Build_Typeinfo_Offset);\n+\n+   function Build_TSD (Loc : Source_Ptr; Tag_Node : Node_Id) return Node_Id;\n+   --  Build code that retrieves the address of the record containing the Type\n+   --  Specific Data generated by GNAT.\n+   --\n+   --  Generate: To_Type_Specific_Data_Ptr\n+   --              (To_Address_Ptr (To_Address (Tag) - Typeinfo_Offset).all);\n+   pragma Inline (Build_TSD);\n+\n+   function RTE_Tag_Node return Entity_Id;\n+   --  Returns the entity associated with Ada.Tags.Tag\n+   pragma Inline (RTE_Tag_Node);\n+\n+   -------------------------\n+   -- Build_CW_Membership --\n+   -------------------------\n+\n+   function Build_CW_Membership\n+     (Loc          : Source_Ptr;\n+      Obj_Tag_Node : Node_Id;\n+      Typ_Tag_Node : Node_Id) return Node_Id\n+   is\n+      function Build_Pos return Node_Id;\n+      --  Generate TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n+\n+      function Build_Pos return Node_Id is\n+      begin\n+         return\n+            Make_Op_Subtract (Loc,\n+              Left_Opnd =>\n+                Make_Selected_Component (Loc,\n+                  Prefix => Build_TSD (Loc, Duplicate_Subexpr (Obj_Tag_Node)),\n+                  Selector_Name =>\n+                    New_Reference_To (RTE_Record_Component (RE_Idepth), Loc)),\n+\n+              Right_Opnd =>\n+                Make_Selected_Component (Loc,\n+                  Prefix => Build_TSD (Loc, Duplicate_Subexpr (Typ_Tag_Node)),\n+                  Selector_Name =>\n+                    New_Reference_To (RTE_Record_Component (RE_Idepth), Loc)));\n+      end Build_Pos;\n+\n+   --  Start of processing for Build_CW_Membership\n+\n+   begin\n+      return\n+        Make_And_Then (Loc,\n+           Left_Opnd =>\n+             Make_Op_Ge (Loc,\n+               Left_Opnd  => Build_Pos,\n+               Right_Opnd => Make_Integer_Literal (Loc, Uint_0)),\n+\n+           Right_Opnd =>\n+             Make_Op_Eq (Loc,\n+               Left_Opnd =>\n+                 Make_Indexed_Component (Loc,\n+                   Prefix =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => Build_TSD (Loc, Obj_Tag_Node),\n+                       Selector_Name =>\n+                         New_Reference_To\n+                           (RTE_Record_Component (RE_Tags_Table), Loc)),\n+                   Expressions =>\n+                     New_List (Build_Pos)),\n+\n+               Right_Opnd => Typ_Tag_Node));\n+   end Build_CW_Membership;\n+\n+   ----------------------------\n+   -- Build_Get_Access_Level --\n+   ----------------------------\n+\n+   function Build_Get_Access_Level\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Selected_Component (Loc,\n+          Prefix => Build_TSD (Loc, Tag_Node),\n+          Selector_Name =>\n+            New_Reference_To\n+              (RTE_Record_Component (RE_Access_Level), Loc));\n+   end Build_Get_Access_Level;\n+\n+   ------------------------------------------\n+   -- Build_Get_Predefined_Prim_Op_Address --\n+   ------------------------------------------\n+\n+   function Build_Get_Predefined_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+         Make_Indexed_Component (Loc,\n+           Prefix =>\n+             Make_Selected_Component (Loc,\n+               Prefix =>\n+                 Build_Predefined_DT (Loc, Tag_Node),\n+\n+               Selector_Name =>\n+                 New_Reference_To\n+                   (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+\n+           Expressions =>\n+             New_List (Position_Node));\n+   end Build_Get_Predefined_Prim_Op_Address;\n+\n+   -------------------------------\n+   -- Build_Get_Prim_Op_Address --\n+   -------------------------------\n+\n+   function Build_Get_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Indexed_Component (Loc,\n+          Prefix =>\n+            Make_Selected_Component (Loc,\n+              Prefix =>\n+                Unchecked_Convert_To\n+                  (RTE_Tag_Node, Tag_Node),\n+              Selector_Name =>\n+                New_Reference_To\n+                  (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+\n+          Expressions => New_List (Position_Node));\n+   end Build_Get_Prim_Op_Address;\n+\n+   -------------------------\n+   -- Build_Get_RC_Offset --\n+   -------------------------\n+\n+   function Build_Get_RC_Offset\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Selected_Component (Loc,\n+          Prefix => Build_TSD (Loc, Tag_Node),\n+          Selector_Name =>\n+            New_Reference_To\n+              (RTE_Record_Component (RE_RC_Offset), Loc));\n+   end Build_Get_RC_Offset;\n+\n+   ---------------------------------\n+   -- Build_Get_Remotely_Callable --\n+   ---------------------------------\n+\n+   function Build_Get_Remotely_Callable\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Selected_Component (Loc,\n+          Prefix => Build_TSD (Loc, Tag_Node),\n+          Selector_Name =>\n+            New_Reference_To\n+              (RTE_Record_Component (RE_Remotely_Callable), Loc));\n+   end Build_Get_Remotely_Callable;\n+\n+   ------------------------------------\n+   -- Build_Inherit_Predefined_Prims --\n+   ------------------------------------\n+\n+   function Build_Inherit_Predefined_Prims\n+     (Loc          : Source_Ptr;\n+      Old_Tag_Node : Node_Id;\n+      New_Tag_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Assignment_Statement (Loc,\n+          Name =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Selected_Component (Loc,\n+                  Prefix =>\n+                    Build_Predefined_DT (Loc, New_Tag_Node),\n+                  Selector_Name =>\n+                    New_Reference_To\n+                      (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+\n+              Discrete_Range => Make_Range (Loc,\n+                Make_Integer_Literal (Loc, Uint_1),\n+                New_Reference_To (RTE (RE_Default_Prim_Op_Count), Loc))),\n+\n+          Expression =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Selected_Component (Loc,\n+                  Prefix        => Build_Predefined_DT (Loc, Old_Tag_Node),\n+                  Selector_Name =>\n+                    New_Reference_To\n+                      (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+              Discrete_Range =>\n+                Make_Range (Loc,\n+                  Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                  High_Bound =>\n+                    New_Reference_To (RTE (RE_Default_Prim_Op_Count), Loc))));\n+\n+   end Build_Inherit_Predefined_Prims;\n+\n+   -------------------------\n+   -- Build_Inherit_Prims --\n+   -------------------------\n+\n+   function Build_Inherit_Prims\n+     (Loc          : Source_Ptr;\n+      Old_Tag_Node : Node_Id;\n+      New_Tag_Node : Node_Id;\n+      Num_Prims    : Nat) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Assignment_Statement (Loc,\n+          Name =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Selected_Component (Loc,\n+                  Prefix =>\n+                    Unchecked_Convert_To (RTE_Tag_Node, New_Tag_Node),\n+                  Selector_Name =>\n+                    New_Reference_To\n+                      (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+              Discrete_Range =>\n+                Make_Range (Loc,\n+                Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                High_Bound => Make_Integer_Literal (Loc, Num_Prims))),\n+\n+          Expression =>\n+            Make_Slice (Loc,\n+              Prefix =>\n+                Make_Selected_Component (Loc,\n+                  Prefix =>\n+                    Unchecked_Convert_To (RTE_Tag_Node, Old_Tag_Node),\n+                  Selector_Name =>\n+                    New_Reference_To\n+                      (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+              Discrete_Range =>\n+                Make_Range (Loc,\n+                Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                High_Bound => Make_Integer_Literal (Loc, Num_Prims))));\n+   end Build_Inherit_Prims;\n+\n+   -------------------\n+   -- Build_New_TSD --\n+   -------------------\n+\n+   function Build_New_TSD\n+     (Loc          : Source_Ptr;\n+      New_Tag_Node : Node_Id) return List_Id\n+   is\n+   begin\n+      return New_List (\n+         Make_Assignment_Statement (Loc,\n+           Name =>\n+             Make_Indexed_Component (Loc,\n+               Prefix =>\n+                 Make_Selected_Component (Loc,\n+                   Prefix => Build_TSD (Loc, Duplicate_Subexpr (New_Tag_Node)),\n+                   Selector_Name =>\n+                     New_Reference_To\n+                       (RTE_Record_Component (RE_Tags_Table), Loc)),\n+               Expressions => New_List (Make_Integer_Literal (Loc, Uint_0))),\n+\n+           Expression => New_Tag_Node));\n+   end Build_New_TSD;\n+\n+   -----------------------\n+   -- Build_Inherit_TSD --\n+   -----------------------\n+\n+   function Build_Inherit_TSD\n+     (Loc               : Source_Ptr;\n+      Old_Tag_Node      : Node_Id;\n+      New_Tag_Node      : Node_Id;\n+      I_Depth           : Nat;\n+      Parent_Num_Ifaces : Nat) return Node_Id\n+   is\n+      function Build_Iface_Table_Ptr (Tag_Node : Node_Id) return Node_Id;\n+      --  Generates: Interface_Data_Ptr! (TSD (Tag).Ifaces_Table_Ptr).all\n+\n+      ----------------------------\n+      --  Build_Iface_Table_Ptr --\n+      ----------------------------\n+\n+      function Build_Iface_Table_Ptr (Tag_Node : Node_Id) return Node_Id is\n+      begin\n+         return\n+            Unchecked_Convert_To (RTE (RE_Interface_Data_Ptr),\n+              Make_Selected_Component (Loc,\n+                Prefix => Tag_Node,\n+                Selector_Name =>\n+                  New_Reference_To\n+                    (RTE_Record_Component (RE_Ifaces_Table_Ptr), Loc)));\n+      end Build_Iface_Table_Ptr;\n+\n+      --  Local variables\n+\n+      L       : constant List_Id := New_List;\n+      Old_TSD : Node_Id;\n+      New_TSD : Node_Id;\n+\n+   --  Start of processing for Build_Inherit_TSD\n+\n+   begin\n+      Old_TSD :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc, New_Internal_Name ('T')),\n+          Object_Definition =>\n+            New_Reference_To (RTE (RE_Type_Specific_Data_Ptr), Loc),\n+          Expression =>\n+            Build_TSD (Loc, Duplicate_Subexpr (Old_Tag_Node)));\n+\n+      New_TSD :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc, New_Internal_Name ('T')),\n+          Object_Definition =>\n+            New_Reference_To (RTE (RE_Type_Specific_Data_Ptr), Loc),\n+          Expression =>\n+            Build_TSD (Loc, Duplicate_Subexpr (New_Tag_Node)));\n+\n+      Append_List_To (L, New_List (\n+\n+         --  Copy the table of ancestors of the parent\n+         --    TSD (New_Tag).Tags_Table (1 .. I_Depth) :=\n+         --      TSD (Old_Tag).Tags_Table (0 .. I_Depth - 1);\n+\n+         Make_Assignment_Statement (Loc,\n+           Name =>\n+             Make_Slice (Loc,\n+               Prefix =>\n+                 Make_Selected_Component (Loc,\n+                   Prefix =>\n+                     Make_Explicit_Dereference (Loc,\n+                       New_Reference_To (Defining_Identifier (New_TSD), Loc)),\n+                   Selector_Name =>\n+                     New_Reference_To\n+                       (RTE_Record_Component (RE_Tags_Table), Loc)),\n+               Discrete_Range => Make_Range (Loc,\n+                 Make_Integer_Literal (Loc, Uint_1),\n+                 Make_Integer_Literal (Loc, I_Depth))),\n+\n+           Expression =>\n+             Make_Slice (Loc,\n+               Prefix =>\n+                 Make_Selected_Component (Loc,\n+                   Prefix =>\n+                     Make_Explicit_Dereference (Loc,\n+                       New_Reference_To (Defining_Identifier (Old_TSD), Loc)),\n+                   Selector_Name =>\n+                     New_Reference_To\n+                       (RTE_Record_Component (RE_Tags_Table), Loc)),\n+               Discrete_Range => Make_Range (Loc,\n+                 Make_Integer_Literal (Loc, Uint_0),\n+                 Make_Integer_Literal (Loc, I_Depth - 1))))));\n+\n+         --  Copy the table of interfaces of the parent\n+\n+         --  if not System.\"=\" (TSD (Old_Tag).Ifaces_Table_Ptr,\n+         --                       System.Null_Address)\n+         --  then\n+         --     New_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces):=\n+         --       Old_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces);\n+         --  end if;\n+\n+         --  The table of interfaces is not available under certified run-time\n+\n+         if RTE_Record_Component_Available (RE_Nb_Ifaces) then\n+            Append_To (L,\n+              Make_If_Statement (Loc,\n+                Condition =>\n+                  Make_Op_Not (Loc,\n+                    Right_Opnd =>\n+                      Make_Op_Eq (Loc,\n+                        Left_Opnd =>\n+                          Make_Selected_Component (Loc,\n+                            Prefix =>\n+                              Make_Explicit_Dereference (Loc,\n+                                New_Reference_To\n+                                  (Defining_Identifier (Old_TSD), Loc)),\n+                            Selector_Name =>\n+                              New_Reference_To\n+                                (RTE_Record_Component (RE_Ifaces_Table_Ptr),\n+                                 Loc)),\n+                        Right_Opnd =>\n+                          New_Reference_To (RTE (RE_Null_Address), Loc))),\n+\n+                Then_Statements => New_List (\n+                  Make_Assignment_Statement (Loc,\n+                    Name =>\n+                      Make_Slice (Loc,\n+                        Prefix =>\n+                          Make_Selected_Component (Loc,\n+                            Prefix =>\n+                              Build_Iface_Table_Ptr\n+                                (New_Reference_To\n+                                  (Defining_Identifier (New_TSD), Loc)),\n+                            Selector_Name =>\n+                              New_Reference_To\n+                                (RTE_Record_Component (RE_Ifaces_Table), Loc)),\n+\n+                        Discrete_Range => Make_Range (Loc,\n+                          Make_Integer_Literal (Loc, Uint_1),\n+                          Make_Integer_Literal (Loc, Parent_Num_Ifaces))),\n+\n+                    Expression =>\n+                      Make_Slice (Loc,\n+                        Prefix =>\n+                          Make_Selected_Component (Loc,\n+                            Prefix =>\n+                              Build_Iface_Table_Ptr\n+                                (New_Reference_To\n+                                  (Defining_Identifier (Old_TSD), Loc)),\n+                            Selector_Name =>\n+                              New_Reference_To\n+                                (RTE_Record_Component (RE_Ifaces_Table), Loc)),\n+\n+                        Discrete_Range => Make_Range (Loc,\n+                          Make_Integer_Literal (Loc, Uint_1),\n+                          Make_Integer_Literal (Loc, Parent_Num_Ifaces)))))));\n+         end if;\n+\n+         --  TSD (New_Tag).Tags_Table (0) := New_Tag;\n+\n+         Append_To (L,\n+            Make_Assignment_Statement (Loc,\n+              Name =>\n+                Make_Indexed_Component (Loc,\n+                  Prefix =>\n+                    Make_Selected_Component (Loc,\n+                      Prefix =>\n+                        Make_Explicit_Dereference (Loc,\n+                          New_Reference_To\n+                            (Defining_Identifier (New_TSD), Loc)),\n+                      Selector_Name =>\n+                        New_Reference_To\n+                          (RTE_Record_Component (RE_Tags_Table), Loc)),\n+                  Expressions =>\n+                    New_List (Make_Integer_Literal (Loc, Uint_0))),\n+\n+              Expression => New_Tag_Node));\n+\n+      return\n+        Make_Block_Statement (Loc,\n+          Declarations => New_List (\n+            Old_TSD,\n+            New_TSD),\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc, L));\n+\n+   end Build_Inherit_TSD;\n+\n+   -------------------------\n+   -- Build_Predefined_DT --\n+   -------------------------\n+\n+   function Build_Predefined_DT\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Unchecked_Convert_To (RTE_Tag_Node,\n+          Make_Function_Call (Loc,\n+            Name =>\n+              Make_Expanded_Name (Loc,\n+                Chars         => Name_Op_Subtract,\n+                Prefix        =>\n+                  New_Reference_To (RTU_Entity (System_Storage_Elements), Loc),\n+                Selector_Name =>\n+                  Make_Identifier (Loc,\n+                    Chars => Name_Op_Subtract)),\n+\n+            Parameter_Associations => New_List (\n+              Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n+              New_Reference_To (RTE (RE_DT_Prologue_Size), Loc))));\n+   end Build_Predefined_DT;\n+\n+   ----------------------------\n+   -- Build_Set_External_Tag --\n+   ----------------------------\n+\n+   function Build_Set_External_Tag\n+     (Loc        : Source_Ptr;\n+      Tag_Node   : Node_Id;\n+      Value_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+         Make_Assignment_Statement (Loc,\n+           Name =>\n+             Make_Selected_Component (Loc,\n+               Prefix => Build_TSD (Loc, Tag_Node),\n+               Selector_Name =>\n+                 New_Reference_To\n+                   (RTE_Record_Component (RO_TA_External_Tag), Loc)),\n+\n+           Expression =>\n+             Unchecked_Convert_To (RTE (RE_Cstring_Ptr), Value_Node));\n+   end Build_Set_External_Tag;\n+\n+   ------------------------------------------\n+   -- Build_Set_Predefined_Prim_Op_Address --\n+   ------------------------------------------\n+\n+   function Build_Set_Predefined_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id;\n+      Address_Node  : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+         Make_Assignment_Statement (Loc,\n+           Name       => Build_Get_Predefined_Prim_Op_Address\n+                          (Loc, Tag_Node, Position_Node),\n+           Expression => Address_Node);\n+   end Build_Set_Predefined_Prim_Op_Address;\n+\n+   -------------------------------\n+   -- Build_Set_Prim_Op_Address --\n+   -------------------------------\n+\n+   function Build_Set_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id;\n+      Address_Node  : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+         Make_Assignment_Statement (Loc,\n+           Name       => Build_Get_Prim_Op_Address (Loc,\n+                           Tag_Node, Position_Node),\n+           Expression => Address_Node);\n+   end Build_Set_Prim_Op_Address;\n+\n+   -------------------\n+   -- Build_Set_TSD --\n+   -------------------\n+\n+   function Build_Set_TSD\n+     (Loc        : Source_Ptr;\n+      Tag_Node   : Node_Id;\n+      Value_Node : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+         Make_Assignment_Statement (Loc,\n+           Name =>\n+             Make_Explicit_Dereference (Loc,\n+               Prefix => Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       Make_Expanded_Name (Loc,\n+                         Chars => Name_Op_Subtract,\n+                         Prefix =>\n+                           New_Reference_To\n+                             (RTU_Entity (System_Storage_Elements), Loc),\n+                         Selector_Name =>\n+                           Make_Identifier (Loc,\n+                             Chars => Name_Op_Subtract)),\n+\n+                     Parameter_Associations => New_List (\n+                       Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n+                       Build_Typeinfo_Offset (Loc))))),\n+\n+           Expression => Value_Node);\n+   end Build_Set_TSD;\n+\n+   ---------------\n+   -- Build_TSD --\n+   ---------------\n+\n+   function Build_TSD (Loc : Source_Ptr; Tag_Node : Node_Id) return Node_Id is\n+   begin\n+      return\n+        Unchecked_Convert_To (RTE (RE_Type_Specific_Data_Ptr),\n+          Make_Explicit_Dereference (Loc,\n+            Prefix => Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n+                Make_Function_Call (Loc,\n+                  Name =>\n+                    Make_Expanded_Name (Loc,\n+                      Chars => Name_Op_Subtract,\n+                      Prefix =>\n+                        New_Reference_To\n+                          (RTU_Entity (System_Storage_Elements), Loc),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc,\n+                          Chars => Name_Op_Subtract)),\n+\n+                  Parameter_Associations => New_List (\n+                    Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n+                    Build_Typeinfo_Offset (Loc))))));\n+   end Build_TSD;\n+\n+   ---------------------------\n+   -- Build_Typeinfo_Offset --\n+   ---------------------------\n+\n+   function Build_Typeinfo_Offset (Loc : Source_Ptr) return Node_Id is\n+   begin\n+      return New_Reference_To (RTE (RE_DT_Typeinfo_Ptr_Size), Loc);\n+   end Build_Typeinfo_Offset;\n+\n+   ---------------\n+   --  Tag_Node --\n+   ---------------\n+\n+   function RTE_Tag_Node return Entity_Id is\n+      E : constant Entity_Id := RTE (RE_Tag);\n+   begin\n+      if Atree.Present (Full_View (E)) then\n+         return Full_View (E);\n+      else\n+         return E;\n+      end if;\n+   end RTE_Tag_Node;\n+end Exp_Atag;"}, {"sha": "8eb456b061206a1289b0006f293f83ef4166c575", "filename": "gcc/ada/exp_atag.ads", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -0,0 +1,182 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ A T A G                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines involved in the frontend expansion of\n+--  subprograms of package Ada.Tags\n+\n+with Types; use Types;\n+\n+package Exp_Atag is\n+\n+   function Build_CW_Membership\n+     (Loc          : Source_Ptr;\n+      Obj_Tag_Node : Node_Id;\n+      Typ_Tag_Node : Node_Id) return Node_Id;\n+   --  Build code that returns true if Obj_Tag is in Typ_Tag'Class. Each\n+   --  dispatch table contains a reference to a table of ancestors (stored\n+   --  in the first part of the Tags_Table) and a count of the level of\n+   --  inheritance \"Idepth\". Obj is in Typ'Class if Typ'Tag is in the table\n+   --  of ancestors that are contained in the dispatch table referenced by\n+   --  Obj'Tag. Knowing the level of inheritance of both types, this can be\n+   --  computed in constant time by the formula:\n+   --\n+   --   TSD (Obj'tag).Tags_Table (TSD (Obj'tag).Idepth - TSD (Typ'tag).Idepth)\n+   --     = Typ'tag\n+\n+   function Build_Get_Access_Level\n+     (Loc      : Source_Ptr;\n+      Tag_Node : Node_Id) return Node_Id;\n+   --  Build code that retrieves the accessibility level of the tagged type.\n+   --\n+   --  Generates: TSD (Tag).Access_Level\n+\n+   function Build_Get_Predefined_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id) return Node_Id;\n+   --  Given a pointer to a dispatch table (T) and a position in the DT, build\n+   --  code that gets the address of the predefined virtual function stored in\n+   --  it (used for dispatching calls).\n+   --\n+   --  Generates: Predefined_DT (Tag).D (Position);\n+\n+   function Build_Get_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id) return Node_Id;\n+   --  Build code that retrieves the address of the virtual function stored in\n+   --  a given position of the dispatch table (used for dispatching calls).\n+   --\n+   --  Generates: To_Tag (Tag).D (Position);\n+\n+   function Build_Get_RC_Offset\n+     (Loc        : Source_Ptr;\n+      Tag_Node   : Node_Id) return Node_Id;\n+   --  Build code that retrieves the Offset of the implicit record controller\n+   --  when the object has controlled components. O otherwise.\n+   --\n+   --  Generates: TSD (T).RC_Offset;\n+\n+   function Build_Get_Remotely_Callable\n+     (Loc        : Source_Ptr;\n+      Tag_Node   : Node_Id) return Node_Id;\n+   --  Build code that retrieves the value previously saved by Set_Remotely\n+   --  Callable\n+   --\n+   --  Generates: TSD (Tag).Remotely_Callable\n+\n+   function Build_Inherit_Predefined_Prims\n+     (Loc              : Source_Ptr;\n+      Old_Tag_Node     : Node_Id;\n+      New_Tag_Node     : Node_Id) return Node_Id;\n+   --  Build code that inherits the predefined primitives of the parent.\n+   --\n+   --  Generates: Predefined_DT (New_T).D (All_Predefined_Prims) :=\n+   --               Predefined_DT (Old_T).D (All_Predefined_Prims);\n+\n+   function Build_Inherit_Prims\n+     (Loc          : Source_Ptr;\n+      Old_Tag_Node : Node_Id;\n+      New_Tag_Node : Node_Id;\n+      Num_Prims    : Nat) return Node_Id;\n+   --  Build code that inherits Num_Prims user-defined primitives from the\n+   --  dispatch table of the parent type.\n+   --\n+   --  Generates:\n+   --    New_Tag.Prims_Ptr (1 .. Num_Prims) :=\n+   --      Old_Tag.Prims_Ptr (1 .. Num_Prims);\n+\n+   function Build_Inherit_TSD\n+     (Loc               : Source_Ptr;\n+      Old_Tag_Node      : Node_Id;\n+      New_Tag_Node      : Node_Id;\n+      I_Depth           : Nat;\n+      Parent_Num_Ifaces : Nat) return Node_Id;\n+   --  Generates code that initializes the TSD of a type knowing the tag,\n+   --  inheritance depth, and number of interface types of the parent type.\n+   --\n+   --  Generates:\n+   --     --  Copy the table of ancestors of the parent\n+   --\n+   --     TSD (New_Tag).Tags_Table (1 .. I_Depth) :=\n+   --       TSD (Old_Tag).Tags_Table (0 .. I_Depth - 1);\n+   --\n+   --     --  Copy the table of interfaces of the parent\n+   --\n+   --     if TSD (Old_Tag).Ifaces_Table_Ptr /= null then\n+   --        New_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces):=\n+   --          Old_Iface_Table_Ptr.Table (1 .. Parent_Num_Ifaces);\n+   --     end if;\n+   --\n+   --     TSD (New_Tag).Tags_Table (0) := New_Tag;\n+\n+   function Build_New_TSD\n+     (Loc          : Source_Ptr;\n+      New_Tag_Node : Node_Id) return List_Id;\n+   --  Build code that initializes the TSD of a root type.\n+   --  Generates: TSD (New_Tag).Tags_Table (0) := New_Tag;\n+\n+   function Build_Set_External_Tag\n+     (Loc        : Source_Ptr;\n+      Tag_Node   : Node_Id;\n+      Value_Node : Node_Id) return Node_Id;\n+   --  Build code that saves the address of the string containing the external\n+   --  tag in the dispatch table.\n+   --\n+   --  Generates: TSD (Tag).External_Tag := Cstring_Ptr! (Value);\n+\n+   function Build_Set_Predefined_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id;\n+      Address_Node  : Node_Id) return Node_Id;\n+   --  Build code that saves the address of a virtual function in a given\n+   --  Position of the portion of the dispatch table associated with the\n+   --  predefined primitives of Tag (used for overriding).\n+   --\n+   --  Generates: Predefined_DT (Tag).D (Position) := Value\n+\n+   function Build_Set_Prim_Op_Address\n+     (Loc           : Source_Ptr;\n+      Tag_Node      : Node_Id;\n+      Position_Node : Node_Id;\n+      Address_Node  : Node_Id) return Node_Id;\n+   --  Build code that saves the address of a virtual function in a given\n+   --  Position of the dispatch table associated with the Tag (used for\n+   --  overriding).\n+   --\n+   --  Generates: Tag.D (Position) := Value\n+\n+   function Build_Set_TSD\n+     (Loc        : Source_Ptr;\n+      Tag_Node   : Node_Id;\n+      Value_Node : Node_Id) return Node_Id;\n+   --  Build code that saves the address of the record containing the Type\n+   --  Specific Data generated by GNAT.\n+   --\n+   --  Generates: To_Addr_Ptr (To_Address (Tag) - K_Typeinfo).all := Value\n+\n+end Exp_Atag;"}, {"sha": "9f905a909d788f45a0ea09727d6e753aa2b79358", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -27,6 +27,7 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Imgv; use Exp_Imgv;\n@@ -211,16 +212,16 @@ package body Exp_Ch13 is\n             Make_String_Literal (Loc, Strval => New_Val)));\n \n       Append_Freeze_Actions (Ent, New_List (\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Reference_To (RTE (RE_Set_External_Tag), Loc),\n-          Parameter_Associations => New_List (\n+\n+        Build_Set_External_Tag (Loc,\n+          Tag_Node =>\n             Make_Attribute_Reference (Loc,\n               Attribute_Name => Name_Tag,\n               Prefix         => New_Occurrence_Of (Ent, Loc)),\n-\n+          Value_Node =>\n             Make_Attribute_Reference (Loc,\n               Attribute_Name => Name_Address,\n-              Prefix         => New_Occurrence_Of (E, Loc)))),\n+              Prefix         => New_Occurrence_Of (E, Loc))),\n \n         Make_Procedure_Call_Statement (Loc,\n           Name => New_Reference_To (RTE (RE_Register_Tag), Loc),"}, {"sha": "f8dc4caa2efa6cc631398ec8b0e6e7ab38f52eea", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 837, "deletions": 1090, "changes": 1927, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -30,6 +30,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Tss;  use Exp_Tss;\n@@ -154,10 +155,10 @@ package body Exp_Disp is\n       ------------------------------------------------\n \n       procedure Build_Common_Dispatching_Select_Statements\n-        (Loc   : Source_Ptr;\n-         Typ   : Entity_Id;\n+        (Loc    : Source_Ptr;\n+         Typ    : Entity_Id;\n          DT_Ptr : Entity_Id;\n-         Stmts : List_Id)\n+         Stmts  : List_Id)\n       is\n       begin\n          --  Generate:\n@@ -305,115 +306,49 @@ package body Exp_Disp is\n    package SEU renames Select_Expansion_Utilities;\n \n    Ada_Actions : constant array (DT_Access_Action) of RE_Id :=\n-      (CW_Membership                  => RE_CW_Membership,\n-       IW_Membership                  => RE_IW_Membership,\n-       DT_Entry_Size                  => RE_DT_Entry_Size,\n-       DT_Prologue_Size               => RE_DT_Prologue_Size,\n-       Get_Access_Level               => RE_Get_Access_Level,\n+      (IW_Membership                  => RE_IW_Membership,\n        Get_Entry_Index                => RE_Get_Entry_Index,\n-       Get_External_Tag               => RE_Get_External_Tag,\n-       Get_Predefined_Prim_Op_Address => RE_Get_Predefined_Prim_Op_Address,\n-       Get_Prim_Op_Address            => RE_Get_Prim_Op_Address,\n        Get_Prim_Op_Kind               => RE_Get_Prim_Op_Kind,\n-       Get_RC_Offset                  => RE_Get_RC_Offset,\n-       Get_Remotely_Callable          => RE_Get_Remotely_Callable,\n        Get_Tagged_Kind                => RE_Get_Tagged_Kind,\n-       Inherit_DT                     => RE_Inherit_DT,\n-       Inherit_TSD                    => RE_Inherit_TSD,\n        Register_Interface_Tag         => RE_Register_Interface_Tag,\n        Register_Tag                   => RE_Register_Tag,\n-       Set_Access_Level               => RE_Set_Access_Level,\n        Set_Entry_Index                => RE_Set_Entry_Index,\n-       Set_Expanded_Name              => RE_Set_Expanded_Name,\n-       Set_External_Tag               => RE_Set_External_Tag,\n-       Set_Interface_Table            => RE_Set_Interface_Table,\n        Set_Offset_Index               => RE_Set_Offset_Index,\n        Set_OSD                        => RE_Set_OSD,\n-       Set_Predefined_Prim_Op_Address => RE_Set_Predefined_Prim_Op_Address,\n-       Set_Prim_Op_Address            => RE_Set_Prim_Op_Address,\n        Set_Prim_Op_Kind               => RE_Set_Prim_Op_Kind,\n-       Set_RC_Offset                  => RE_Set_RC_Offset,\n-       Set_Remotely_Callable          => RE_Set_Remotely_Callable,\n        Set_Signature                  => RE_Set_Signature,\n        Set_SSD                        => RE_Set_SSD,\n-       Set_TSD                        => RE_Set_TSD,\n-       Set_Tagged_Kind                => RE_Set_Tagged_Kind,\n-       TSD_Entry_Size                 => RE_TSD_Entry_Size,\n-       TSD_Prologue_Size              => RE_TSD_Prologue_Size);\n+       Set_Tagged_Kind                => RE_Set_Tagged_Kind);\n \n    Action_Is_Proc : constant array (DT_Access_Action) of Boolean :=\n-      (CW_Membership                  => False,\n-       IW_Membership                  => False,\n-       DT_Entry_Size                  => False,\n-       DT_Prologue_Size               => False,\n-       Get_Access_Level               => False,\n+      (IW_Membership                  => False,\n        Get_Entry_Index                => False,\n-       Get_External_Tag               => False,\n-       Get_Predefined_Prim_Op_Address => False,\n-       Get_Prim_Op_Address            => False,\n        Get_Prim_Op_Kind               => False,\n-       Get_RC_Offset                  => False,\n-       Get_Remotely_Callable          => False,\n        Get_Tagged_Kind                => False,\n-       Inherit_DT                     => True,\n-       Inherit_TSD                    => True,\n        Register_Interface_Tag         => True,\n        Register_Tag                   => True,\n-       Set_Access_Level               => True,\n        Set_Entry_Index                => True,\n-       Set_Expanded_Name              => True,\n-       Set_External_Tag               => True,\n-       Set_Interface_Table            => True,\n        Set_Offset_Index               => True,\n        Set_OSD                        => True,\n-       Set_Predefined_Prim_Op_Address => True,\n-       Set_Prim_Op_Address            => True,\n        Set_Prim_Op_Kind               => True,\n-       Set_RC_Offset                  => True,\n-       Set_Remotely_Callable          => True,\n        Set_Signature                  => True,\n        Set_SSD                        => True,\n-       Set_TSD                        => True,\n-       Set_Tagged_Kind                => True,\n-       TSD_Entry_Size                 => False,\n-       TSD_Prologue_Size              => False);\n+       Set_Tagged_Kind                => True);\n \n    Action_Nb_Arg : constant array (DT_Access_Action) of Int :=\n-      (CW_Membership                  => 2,\n-       IW_Membership                  => 2,\n-       DT_Entry_Size                  => 0,\n-       DT_Prologue_Size               => 0,\n-       Get_Access_Level               => 1,\n+      (IW_Membership                  => 2,\n        Get_Entry_Index                => 2,\n-       Get_External_Tag               => 1,\n-       Get_Predefined_Prim_Op_Address => 2,\n-       Get_Prim_Op_Address            => 2,\n        Get_Prim_Op_Kind               => 2,\n-       Get_RC_Offset                  => 1,\n-       Get_Remotely_Callable          => 1,\n        Get_Tagged_Kind                => 1,\n-       Inherit_DT                     => 3,\n-       Inherit_TSD                    => 2,\n        Register_Interface_Tag         => 3,\n        Register_Tag                   => 1,\n-       Set_Access_Level               => 2,\n        Set_Entry_Index                => 3,\n-       Set_Expanded_Name              => 2,\n-       Set_External_Tag               => 2,\n-       Set_Interface_Table            => 2,\n        Set_Offset_Index               => 3,\n        Set_OSD                        => 2,\n-       Set_Predefined_Prim_Op_Address => 3,\n-       Set_Prim_Op_Address            => 3,\n        Set_Prim_Op_Kind               => 3,\n-       Set_RC_Offset                  => 2,\n-       Set_Remotely_Callable          => 2,\n        Set_Signature                  => 2,\n        Set_SSD                        => 2,\n-       Set_TSD                        => 2,\n-       Set_Tagged_Kind                => 2,\n-       TSD_Entry_Size                 => 0,\n-       TSD_Prologue_Size              => 0);\n+       Set_Tagged_Kind                => 2);\n \n    function Default_Prim_Op_Position (E : Entity_Id) return Uint;\n    --  Ada 2005 (AI-251): Returns the fixed position in the dispatch table\n@@ -550,7 +485,18 @@ package body Exp_Disp is\n    --  Start of processing for Expand_Dispatching_Call\n \n    begin\n-      Check_Restriction (No_Dispatching_Calls, Call_Node);\n+      --  Expand_Dispatching_Call is called directly from the semantics,\n+      --  so we need a check to see whether expansion is active before\n+      --  proceeding. In addition, there is no need to expand the call\n+      --  if we are compiling under restriction No_Dispatching_Calls;\n+      --  the semantic analyzer has previously notified the violation\n+      --  of this restriction.\n+\n+      if not Expander_Active\n+        or else Restriction_Active (No_Dispatching_Calls)\n+      then\n+         return;\n+      end if;\n \n       --  Set subprogram. If this is an inherited operation that was\n       --  overridden, the body that is being called is its alias.\n@@ -564,14 +510,6 @@ package body Exp_Disp is\n          Subp := Alias (Subp);\n       end if;\n \n-      --  Expand_Dispatching_Call is called directly from the semantics,\n-      --  so we need a check to see whether expansion is active before\n-      --  proceeding.\n-\n-      if not Expander_Active then\n-         return;\n-      end if;\n-\n       --  Definition of the class-wide type and the tagged type\n \n       --  If the controlling argument is itself a tag rather than a tagged\n@@ -606,19 +544,19 @@ package body Exp_Disp is\n          Eq_Prim_Op := Find_Prim_Op (Typ, Name_Op_Eq);\n       end if;\n \n-      --  Why do we check the Root_Type instead of Typ???\n-\n-      if Is_CPP_Class (Root_Type (Typ)) then\n-\n-         --  Create a new parameter list with the displaced 'this'\n+      --  Dispatching call to C++ primitive. Create a new parameter list\n+      --  with no tag checks.\n \n+      if Is_CPP_Class (Typ) then\n          New_Params := New_List;\n          Param := First_Actual (Call_Node);\n          while Present (Param) loop\n             Append_To (New_Params, Relocate_Node (Param));\n             Next_Actual (Param);\n          end loop;\n \n+      --  Dispatching call to Ada primitive\n+\n       elsif Present (Param_List) then\n \n          --  Generate the Tag checks when appropriate\n@@ -805,6 +743,22 @@ package body Exp_Disp is\n       then\n          Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n \n+      --  Extract the tag from an unchecked type conversion. Done to avoid\n+      --  the expansion of additional code just to obtain the value of such\n+      --  tag because the current management of interface type conversions\n+      --  generates in some cases this unchecked type conversion with the\n+      --  tag of the object (see Expand_Interface_Conversion).\n+\n+      elsif Nkind (Ctrl_Arg) = N_Unchecked_Type_Conversion\n+        and then\n+          (Etype (Expression (Ctrl_Arg)) = RTE (RE_Tag)\n+            or else\n+              (RTE_Available (RE_Interface_Tag)\n+                and then\n+                  Etype (Expression (Ctrl_Arg)) = RTE (RE_Interface_Tag)))\n+      then\n+         Controlling_Tag := Duplicate_Subexpr (Expression (Ctrl_Arg));\n+\n       --  Ada 2005 (AI-251): Abstract interface class-wide type\n \n       elsif Is_Interface (Etype (Ctrl_Arg))\n@@ -819,42 +773,27 @@ package body Exp_Disp is\n              Selector_Name => New_Reference_To (DTC_Entity (Subp), Loc));\n       end if;\n \n-      --  Generate:\n-      --   Subp_Ptr_Typ!(Get_Prim_Op_Address (Ctrl._Tag, pos));\n+      --  Handle dispatching calls to predefined primitives\n \n       if Is_Predefined_Dispatching_Operation (Subp)\n         or else Is_Predefined_Dispatching_Alias (Subp)\n       then\n          New_Call_Name :=\n            Unchecked_Convert_To (Subp_Ptr_Typ,\n-             Make_DT_Access_Action (Typ,\n-               Action => Get_Predefined_Prim_Op_Address,\n-               Args => New_List (\n-\n-               --  Vptr\n-\n-                 Unchecked_Convert_To (RTE (RE_Tag),\n-                   Controlling_Tag),\n+             Build_Get_Predefined_Prim_Op_Address (Loc,\n+               Tag_Node => Controlling_Tag,\n+               Position_Node => Make_Integer_Literal (Loc,\n+                                  DT_Position (Subp))));\n \n-               --  Position\n-\n-                 Make_Integer_Literal (Loc, DT_Position (Subp)))));\n+      --  Handle dispatching calls to user-defined primitives\n \n       else\n          New_Call_Name :=\n            Unchecked_Convert_To (Subp_Ptr_Typ,\n-             Make_DT_Access_Action (Typ,\n-               Action => Get_Prim_Op_Address,\n-               Args => New_List (\n-\n-               --  Vptr\n-\n-                 Unchecked_Convert_To (RTE (RE_Tag),\n-                   Controlling_Tag),\n-\n-               --  Position\n-\n-                 Make_Integer_Literal (Loc, DT_Position (Subp)))));\n+             Build_Get_Prim_Op_Address (Loc,\n+               Tag_Node      => Controlling_Tag,\n+               Position_Node => Make_Integer_Literal (Loc,\n+                                  DT_Position (Subp))));\n       end if;\n \n       if Nkind (Call_Node) = N_Function_Call then\n@@ -946,17 +885,14 @@ package body Exp_Disp is\n       Iface_Typ   : Entity_Id           := Etype (N);\n       Iface_Tag   : Entity_Id;\n       New_Itype   : Entity_Id;\n-      P           : Node_Id;\n \n    begin\n       pragma Assert (Nkind (Operand) /= N_Attribute_Reference);\n \n-      --  Ada 2005 (AI-345): Handle task interfaces\n+      --  Ada 2005 (AI-345): Handle synchronized interface type derivations\n \n-      if Ekind (Operand_Typ) = E_Task_Type\n-        or else Ekind (Operand_Typ) = E_Protected_Type\n-      then\n-         Operand_Typ := Corresponding_Record_Type (Operand_Typ);\n+      if Is_Concurrent_Type (Operand_Typ) then\n+         Operand_Typ := Base_Type (Corresponding_Record_Type (Operand_Typ));\n       end if;\n \n       --  Handle access types to interfaces\n@@ -1145,24 +1081,10 @@ package body Exp_Disp is\n                                    New_Occurrence_Of (Iface_Tag, Loc)),\n                              Attribute_Name => Name_Address))))))));\n \n-         --  Insert the new declaration in the nearest enclosing scope\n-         --  that has declarations.\n-\n-         P := N;\n-         while not Has_Declarations (Parent (P)) loop\n-            P := Parent (P);\n-         end loop;\n-\n-         if Is_List_Member (P) then\n-            Insert_Before (P, Func);\n-\n-         elsif Nkind (Parent (P)) = N_Package_Specification then\n-            Append_To (Visible_Declarations (Parent (P)), Func);\n-\n-         else\n-            Append_To (Declarations (Parent (P)), Func);\n-         end if;\n+         --  Place function body before the expression containing\n+         --  the conversion\n \n+         Insert_Action (N, Func);\n          Analyze (Func);\n \n          if Is_Access_Type (Etype (Expression (N))) then\n@@ -1282,7 +1204,7 @@ package body Exp_Disp is\n             --  the interface primitives are located in the primary dispatch\n             --  table.\n \n-            elsif Is_Ancestor (Formal_Typ, Actual_Typ) then\n+            elsif Is_Parent (Formal_Typ, Actual_Typ) then\n                null;\n \n             else\n@@ -1334,7 +1256,7 @@ package body Exp_Disp is\n             --  derivation of the interface (because in this case the interface\n             --  primitives are located in the primary dispatch table)\n \n-            elsif Is_Ancestor (Formal_DDT, Actual_DDT) then\n+            elsif Is_Parent (Formal_DDT, Actual_DDT) then\n                null;\n \n             else\n@@ -1646,32 +1568,23 @@ package body Exp_Disp is\n         or else Is_Predefined_Dispatching_Alias (Prim)\n       then\n          return\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Predefined_Prim_Op_Address,\n-             Args   => New_List (\n-               Unchecked_Convert_To (RTE (RE_Tag),\n-                 New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n-\n-               Make_Integer_Literal (Loc, Pos),                    -- Position\n+           Build_Set_Predefined_Prim_Op_Address (Loc,\n+             Tag_Node      => New_Reference_To (DT_Ptr, Loc),\n+             Position_Node => Make_Integer_Literal (Loc, Pos),\n+             Address_Node  => Make_Attribute_Reference (Loc,\n+                                Prefix => New_Reference_To (Prim, Loc),\n+                                Attribute_Name => Name_Address));\n \n-               Make_Attribute_Reference (Loc,                      -- Value\n-                 Prefix          => New_Reference_To (Prim, Loc),\n-                 Attribute_Name  => Name_Address)));\n       else\n          pragma Assert (Pos /= Uint_0 and then Pos <= DT_Entry_Count (Tag));\n \n          return\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Prim_Op_Address,\n-             Args   => New_List (\n-               Unchecked_Convert_To (RTE (RE_Tag),\n-                 New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n-\n-               Make_Integer_Literal (Loc, Pos),                    -- Position\n-\n-               Make_Attribute_Reference (Loc,                      -- Value\n-                 Prefix          => New_Reference_To (Prim, Loc),\n-                 Attribute_Name  => Name_Address)));\n+           Build_Set_Prim_Op_Address (Loc,\n+             Tag_Node      => New_Reference_To (DT_Ptr, Loc),\n+             Position_Node => Make_Integer_Literal (Loc, Pos),\n+             Address_Node  => Make_Attribute_Reference (Loc,\n+                                Prefix => New_Reference_To (Prim, Loc),\n+                                Attribute_Name => Name_Address));\n       end if;\n    end Fill_DT_Entry;\n \n@@ -1685,7 +1598,6 @@ package body Exp_Disp is\n       Thunk_Id     : Entity_Id;\n       Iface_DT_Ptr : Entity_Id) return Node_Id\n    is\n-      Typ        : constant Entity_Id := Scope (DTC_Entity (Alias (Prim)));\n       Iface_Prim : constant Entity_Id := Abstract_Interface_Alias (Prim);\n       Pos        : constant Uint      := DT_Position (Iface_Prim);\n       Tag        : constant Entity_Id :=\n@@ -1696,99 +1608,28 @@ package body Exp_Disp is\n         or else Is_Predefined_Dispatching_Alias (Prim)\n       then\n          return\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Predefined_Prim_Op_Address,\n-             Args   => New_List (\n-               Unchecked_Convert_To (RTE (RE_Tag),\n-                 New_Reference_To (Iface_DT_Ptr, Loc)),            -- DTptr\n-\n-               Make_Integer_Literal (Loc, Pos),                    -- Position\n-\n-               Make_Attribute_Reference (Loc,                      -- Value\n+           Build_Set_Predefined_Prim_Op_Address (Loc,\n+             Tag_Node =>\n+               New_Reference_To (Iface_DT_Ptr, Loc),\n+             Position_Node =>\n+               Make_Integer_Literal (Loc, Pos),\n+             Address_Node =>\n+               Make_Attribute_Reference (Loc,\n                  Prefix          => New_Reference_To (Thunk_Id, Loc),\n-                 Attribute_Name  => Name_Address)));\n+                 Attribute_Name  => Name_Address));\n       else\n          pragma Assert (Pos /= Uint_0 and then Pos <= DT_Entry_Count (Tag));\n \n          return\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Prim_Op_Address,\n-             Args   => New_List (\n-               Unchecked_Convert_To (RTE (RE_Tag),\n-                 New_Reference_To (Iface_DT_Ptr, Loc)),            -- DTptr\n-\n-               Make_Integer_Literal (Loc, Pos),                    -- Position\n-\n-               Make_Attribute_Reference (Loc,                      -- Value\n-                 Prefix          => New_Reference_To (Thunk_Id, Loc),\n-                 Attribute_Name  => Name_Address)));\n+           Build_Set_Prim_Op_Address (Loc,\n+             Tag_Node      => New_Reference_To (Iface_DT_Ptr, Loc),\n+             Position_Node => Make_Integer_Literal (Loc, Pos),\n+             Address_Node  => Make_Attribute_Reference (Loc,\n+                                Prefix => New_Reference_To (Thunk_Id, Loc),\n+                                Attribute_Name => Name_Address));\n       end if;\n    end Fill_Secondary_DT_Entry;\n \n-   ---------------------------\n-   -- Get_Remotely_Callable --\n-   ---------------------------\n-\n-   function Get_Remotely_Callable (Obj : Node_Id) return Node_Id is\n-      Loc : constant Source_Ptr := Sloc (Obj);\n-   begin\n-      return Make_DT_Access_Action\n-        (Typ    => Etype (Obj),\n-         Action => Get_Remotely_Callable,\n-         Args   => New_List (\n-           Make_Selected_Component (Loc,\n-             Prefix        => Obj,\n-             Selector_Name => Make_Identifier (Loc, Name_uTag))));\n-   end Get_Remotely_Callable;\n-\n-   ------------------------------------------\n-   -- Init_Predefined_Interface_Primitives --\n-   ------------------------------------------\n-\n-   function Init_Predefined_Interface_Primitives\n-     (Typ : Entity_Id) return List_Id\n-   is\n-      Loc    : constant Source_Ptr := Sloc (Typ);\n-      DT_Ptr : constant Node_Id :=\n-                 Node (First_Elmt (Access_Disp_Table (Typ)));\n-      Result : constant List_Id := New_List;\n-      AI     : Elmt_Id;\n-\n-   begin\n-      --  No need to inherit primitives if we have an abstract interface\n-      --  type or a concurrent type.\n-\n-      if Is_Interface (Typ)\n-        or else Is_Concurrent_Record_Type (Typ)\n-        or else Restriction_Active (No_Dispatching_Calls)\n-      then\n-         return Result;\n-      end if;\n-\n-      AI := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n-      while Present (AI) loop\n-\n-         --  All the secondary tables inherit the dispatch table entries\n-         --  associated with predefined primitives.\n-\n-         --  Generate:\n-         --    Inherit_DT (T'Tag, Iface'Tag, 0);\n-\n-         Append_To (Result,\n-           Make_DT_Access_Action (Typ,\n-             Action => Inherit_DT,\n-             Args   => New_List (\n-               Node1 => New_Reference_To (DT_Ptr, Loc),\n-               Node2 => Unchecked_Convert_To (RTE (RE_Tag),\n-                          New_Reference_To (Node (AI), Loc)),\n-               Node3 => Make_Integer_Literal (Loc, Uint_0))));\n-\n-         Next_Elmt (AI);\n-      end loop;\n-\n-      return Result;\n-   end Init_Predefined_Interface_Primitives;\n-\n    -------------------------------------\n    -- Is_Predefined_Dispatching_Alias --\n    -------------------------------------\n@@ -2651,6 +2492,8 @@ package body Exp_Disp is\n       Name_TSD    : constant Name_Id := New_External_Name (Tname, 'B');\n       Name_Exname : constant Name_Id := New_External_Name (Tname, 'E');\n       Name_No_Reg : constant Name_Id := New_External_Name (Tname, 'F');\n+\n+      --  The following external name is only generated if Typ has interfaces\n       Name_ITable : Name_Id;\n \n       DT     : constant Node_Id := Make_Defining_Identifier (Loc, Name_DT);\n@@ -2659,58 +2502,76 @@ package body Exp_Disp is\n       TSD    : constant Node_Id := Make_Defining_Identifier (Loc, Name_TSD);\n       Exname : constant Node_Id := Make_Defining_Identifier (Loc, Name_Exname);\n       No_Reg : constant Node_Id := Make_Defining_Identifier (Loc, Name_No_Reg);\n-      ITable : Node_Id;\n-\n-      Generalized_Tag   : constant Entity_Id := RTE (RE_Tag);\n-      AI                : Elmt_Id;\n-      I_Depth           : Int;\n-      Nb_Prim           : Int;\n-      Num_Ifaces        : Int;\n-      Old_Tag1          : Node_Id;\n-      Old_Tag2          : Node_Id;\n-      Parent_Num_Ifaces : Int;\n-      Size_Expr_Node    : Node_Id;\n-      TSD_Num_Entries   : Int;\n \n-      Empty_DT          : Boolean := False;\n-\n-      Ancestor_Ifaces   : Elist_Id;\n-      Typ_Ifaces        : Elist_Id;\n+      Generalized_Tag    : constant Entity_Id := RTE (RE_Tag);\n+      Ancestor_Ifaces    : Elist_Id;\n+      AI                 : Elmt_Id;\n+      Has_Dispatch_Table : Boolean := True;\n+      I_Depth            : Nat := 0;\n+      ITable             : Node_Id;\n+      Iface_Table_Node   : Node_Id;\n+      Nb_Prim            : Nat := 0;\n+      Null_Parent_Tag    : Boolean := False;\n+      Num_Ifaces         : Nat := 0;\n+      Old_Tag1           : Node_Id;\n+      Old_Tag2           : Node_Id;\n+      Parent             : Entity_Id;\n+      Parent_Num_Ifaces  : Nat := 0;\n+      Remotely_Callable  : Entity_Id;\n+      RC_Offset_Node     : Node_Id;\n+      Size_Expr_Node     : Node_Id;\n+      Typ_Ifaces         : Elist_Id;\n+      TSD_Aggr_List      : List_Id;\n \n    begin\n       if not RTE_Available (RE_Tag) then\n          Error_Msg_CRT (\"tagged types\", Typ);\n          return New_List;\n       end if;\n \n-      --  Calculate the size of the DT and the TSD. First we count the number\n-      --  of interfaces implemented by the ancestors\n+      --  Ensure that the unit System_Storage_Elements is loaded. This is\n+      --  required to properly expand the routines of Ada.Tags\n+\n+      if not RTU_Loaded (System_Storage_Elements)\n+        and then not Present (RTE (RE_Storage_Offset))\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Ada_Version >= Ada_05 then\n+\n+         --  Count the interface types of the parents\n+\n+         Parent := Empty;\n+\n+         if Typ /= Etype (Typ) then\n+            Parent := Etype (Typ);\n+\n+         elsif Is_Concurrent_Record_Type (Typ) then\n+            Parent := Etype (First (Abstract_Interface_List (Typ)));\n+         end if;\n+\n+         if Present (Parent) then\n+            Collect_Abstract_Interfaces (Parent, Ancestor_Ifaces);\n \n-      Parent_Num_Ifaces := 0;\n-      Num_Ifaces        := 0;\n+            AI := First_Elmt (Ancestor_Ifaces);\n+            while Present (AI) loop\n+               Parent_Num_Ifaces := Parent_Num_Ifaces + 1;\n+               Next_Elmt (AI);\n+            end loop;\n+         end if;\n \n-      --  Count the abstract interfaces of the ancestors\n+         --  Count the additional interfaces implemented by Typ\n \n-      if Typ /= Etype (Typ) then\n-         Collect_Abstract_Interfaces (Etype (Typ), Ancestor_Ifaces);\n+         Collect_Abstract_Interfaces (Typ, Typ_Ifaces);\n \n-         AI := First_Elmt (Ancestor_Ifaces);\n+         AI := First_Elmt (Typ_Ifaces);\n          while Present (AI) loop\n-            Parent_Num_Ifaces := Parent_Num_Ifaces + 1;\n+            Num_Ifaces := Num_Ifaces + 1;\n             Next_Elmt (AI);\n          end loop;\n       end if;\n \n-      --  Count the number of additional interfaces implemented by Typ\n-\n-      Collect_Abstract_Interfaces (Typ, Typ_Ifaces);\n-\n-      AI := First_Elmt (Typ_Ifaces);\n-      while Present (AI) loop\n-         Num_Ifaces := Num_Ifaces + 1;\n-         Next_Elmt (AI);\n-      end loop;\n-\n       --  Count ancestors to compute the inheritance depth. For private\n       --  extensions, always go to the full view in order to compute the\n       --  real inheritance depth.\n@@ -2735,31 +2596,19 @@ package body Exp_Disp is\n          end loop;\n       end;\n \n-      --  Abstract interfaces don't need the DT. We reserve a single entry\n-      --  for its DT because at run-time the pointer to this dummy DT will\n-      --  be used as the tag of this abstract interface type. The table of\n-      --  interfaces is required to give support to AI-405\n-\n-      if Is_Interface (Typ) then\n-         Empty_DT := True;\n-         Nb_Prim  := 1;\n-         TSD_Num_Entries := 0;\n+      --  Calculate the number of primitives of the dispatch table and the\n+      --  size of the Type_Specific_Data record.\n \n-      else\n-         TSD_Num_Entries := I_Depth + 1;\n-         Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n+      --  Abstract interfaces don't need the dispatch table. In addition,\n+      --  compiling with restriction No_Dispatching_Calls we do not generate\n+      --  the dispatch table.\n \n-         --  If the number of primitives of Typ is 0 (or we are compiling\n-         --  with the No_Dispatching_Calls restriction) we reserve a dummy\n-         --  single entry for its DT because at run-time the pointer to this\n-         --  dummy DT will be used as the tag of this tagged type.\n+      Has_Dispatch_Table :=\n+        not Is_Interface (Typ)\n+          and then not Restriction_Active (No_Dispatching_Calls);\n \n-         if Nb_Prim = 0\n-           or else Restriction_Active (No_Dispatching_Calls)\n-         then\n-            Empty_DT := True;\n-            Nb_Prim  := 1;\n-         end if;\n+      if Has_Dispatch_Table then\n+         Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n       end if;\n \n       --  Dispatch table and related entities are allocated statically\n@@ -2792,18 +2641,49 @@ package body Exp_Disp is\n \n       --  Generate code to create the storage for the Dispatch_Table object:\n \n-      --   DT : Storage_Array (1..DT_Prologue_Size+nb_prim*DT_Entry_Size);\n+      --   DT : Storage_Array (1 .. Size_Expr);\n       --   for DT'Alignment use Address'Alignment\n \n-      Size_Expr_Node :=\n-        Make_Op_Add (Loc,\n-          Left_Opnd  => Make_DT_Access_Action (Typ, DT_Prologue_Size, No_List),\n-          Right_Opnd =>\n-            Make_Op_Multiply (Loc,\n-              Left_Opnd  =>\n-                Make_DT_Access_Action (Typ, DT_Entry_Size, No_List),\n-              Right_Opnd =>\n-                Make_Integer_Literal (Loc, Nb_Prim)));\n+      --  Under No_Dispatching_Calls the size of the table is small just\n+      --  containing:\n+      --   1) the pointer to the TSD\n+      --   2) a dummy entry used as the Tag of the type (see a-tags.ads).\n+\n+      if not Has_Dispatch_Table then\n+         Size_Expr_Node :=\n+           New_Reference_To (RTE (RE_DT_Min_Prologue_Size), Loc);\n+\n+      --  If the object has no primitives we ensure that the table will\n+      --  have at least a dummy entry which will be used as the Tag.\n+\n+      --   Size_Expr := DT_Prologue_Size + DT_Entry_Size\n+\n+      elsif Nb_Prim = 0 then\n+         Size_Expr_Node :=\n+           Make_Op_Add (Loc,\n+             Left_Opnd  =>\n+               New_Reference_To (RTE (RE_DT_Prologue_Size), Loc),\n+             Right_Opnd =>\n+               New_Reference_To (RTE (RE_DT_Entry_Size), Loc));\n+\n+      --  Common case. The dispatch table has space to save the pointers to\n+      --  all the predefined primitives, the C++ ABI header of the DT, and\n+      --  the pointers to the primitives of Typ. That is,\n+\n+      --   Size_Expr := DT_Prologue_Size + nb_prim * DT_Entry_Size\n+\n+      else\n+         Size_Expr_Node :=\n+           Make_Op_Add (Loc,\n+             Left_Opnd  =>\n+               New_Reference_To (RTE (RE_DT_Prologue_Size), Loc),\n+             Right_Opnd =>\n+               Make_Op_Multiply (Loc,\n+                 Left_Opnd  =>\n+                   New_Reference_To (RTE (RE_DT_Entry_Size), Loc),\n+                 Right_Opnd =>\n+                   Make_Integer_Literal (Loc, Nb_Prim)));\n+      end if;\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n@@ -2836,181 +2716,312 @@ package body Exp_Disp is\n       --  prologue containing Offset_To_Top, and Typeinfo_Ptr. Hence, we move\n       --  down the pointer to the real base of the vtable\n \n-      Append_To (Result,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => DT_Ptr,\n-          Constant_Present    => True,\n-          Object_Definition   => New_Reference_To (Generalized_Tag, Loc),\n-          Expression          =>\n-            Unchecked_Convert_To (Generalized_Tag,\n-              Make_Op_Add (Loc,\n-                Left_Opnd =>\n-                  Unchecked_Convert_To (RTE (RE_Storage_Offset),\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix         => New_Reference_To (DT, Loc),\n-                      Attribute_Name => Name_Address)),\n-                Right_Opnd =>\n-                  Make_DT_Access_Action (Typ,\n-                    DT_Prologue_Size, No_List)))));\n-\n-      --  Generate code to define the boolean that controls registration, in\n-      --  order to avoid multiple registrations for tagged types defined in\n-      --  multiple-called scopes.\n+      if not Has_Dispatch_Table then\n+         Append_To (Result,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => DT_Ptr,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Generalized_Tag, Loc),\n+             Expression          =>\n+               Unchecked_Convert_To (Generalized_Tag,\n+                 Make_Op_Add (Loc,\n+                   Left_Opnd =>\n+                     Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => New_Reference_To (DT, Loc),\n+                         Attribute_Name => Name_Address)),\n+                   Right_Opnd =>\n+                     New_Reference_To (RTE (RE_DT_Typeinfo_Ptr_Size), Loc)))));\n \n-      Append_To (Result,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => No_Reg,\n-          Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n-          Expression          => New_Reference_To (Standard_True, Loc)));\n+      else\n+         Append_To (Result,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => DT_Ptr,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Generalized_Tag, Loc),\n+             Expression          =>\n+               Unchecked_Convert_To (Generalized_Tag,\n+                 Make_Op_Add (Loc,\n+                   Left_Opnd =>\n+                     Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => New_Reference_To (DT, Loc),\n+                         Attribute_Name => Name_Address)),\n+                   Right_Opnd =>\n+                     New_Reference_To (RTE (RE_DT_Prologue_Size), Loc)))));\n+      end if;\n \n-      --  Set Access_Disp_Table field to be the dispatch table pointer\n+      --  Save the tag in the Access_Disp_Table attribute\n \n       if No (Access_Disp_Table (Typ)) then\n          Set_Access_Disp_Table (Typ, New_Elmt_List);\n       end if;\n \n       Prepend_Elmt (DT_Ptr, Access_Disp_Table (Typ));\n \n-      --  Generate code to create the storage for the type specific data object\n-      --  with enough space to store the tags of the ancestors plus the tags\n-      --  of all the implemented interfaces (as described in a-tags.adb).\n-\n-      --   TSD: Storage_Array\n-      --     (1..TSD_Prologue_Size+TSD_Num_Entries*TSD_Entry_Size);\n-      --   for TSD'Alignment use Address'Alignment\n-\n-      Size_Expr_Node :=\n-        Make_Op_Add (Loc,\n-          Left_Opnd  =>\n-            Make_DT_Access_Action (Typ, TSD_Prologue_Size, No_List),\n-          Right_Opnd =>\n-            Make_Op_Multiply (Loc,\n-              Left_Opnd  =>\n-                Make_DT_Access_Action (Typ, TSD_Entry_Size, No_List),\n-              Right_Opnd =>\n-                Make_Integer_Literal (Loc, TSD_Num_Entries)));\n+      --  Generate code to define the boolean that controls registration, in\n+      --  order to avoid multiple registrations for tagged types defined in\n+      --  multiple-called scopes.\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n-          Defining_Identifier => TSD,\n-          Aliased_Present     => True,\n-          Object_Definition   =>\n-            Make_Subtype_Indication (Loc,\n-              Subtype_Mark => New_Reference_To (RTE (RE_Storage_Array), Loc),\n-              Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n-                Constraints => New_List (\n-                  Make_Range (Loc,\n-                    Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                    High_Bound => Size_Expr_Node))))));\n-\n-      Append_To (Result,\n-        Make_Attribute_Definition_Clause (Loc,\n-          Name       => New_Reference_To (TSD, Loc),\n-          Chars      => Name_Alignment,\n-          Expression =>\n-            Make_Attribute_Reference (Loc,\n-              Prefix => New_Reference_To (RTE (RE_Integer_Address), Loc),\n-              Attribute_Name => Name_Alignment)));\n+          Defining_Identifier => No_Reg,\n+          Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n+          Expression          => New_Reference_To (Standard_True, Loc)));\n \n       --  Generate:\n       --    Set_Signature (DT_Ptr, Value);\n \n-      if RTE_Available (RE_Set_Signature) then\n+      if Has_Dispatch_Table\n+        and then RTE_Available (RE_Set_Signature)\n+      then\n          if Is_Interface (Typ) then\n             Append_To (Elab_Code,\n               Make_DT_Access_Action (Typ,\n                 Action => Set_Signature,\n                 Args   => New_List (\n-                  New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n+                  New_Reference_To (DT_Ptr, Loc),\n                   New_Reference_To (RTE (RE_Abstract_Interface), Loc))));\n \n          else\n             Append_To (Elab_Code,\n               Make_DT_Access_Action (Typ,\n                 Action => Set_Signature,\n                 Args   => New_List (\n-                  New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n+                  New_Reference_To (DT_Ptr, Loc),\n                   New_Reference_To (RTE (RE_Primary_DT), Loc))));\n          end if;\n       end if;\n \n-      --  Generate code to put the Address of the TSD in the dispatch table\n-      --    Set_TSD (DT_Ptr, TSD);\n+      --  Generate: Exname : constant String := full_qualified_name (typ);\n+      --  The type itself may be an anonymous parent type, so use the first\n+      --  subtype to have a user-recognizable name.\n \n-      Append_To (Elab_Code,\n-        Make_DT_Access_Action (Typ,\n-          Action => Set_TSD,\n-          Args   => New_List (\n-            New_Reference_To (DT_Ptr, Loc),                  -- DTptr\n-              Make_Attribute_Reference (Loc,                 -- Value\n-                Prefix          => New_Reference_To (TSD, Loc),\n-                Attribute_Name  => Name_Address))));\n+      Append_To (Result,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Exname,\n+          Constant_Present    => True,\n+          Object_Definition   => New_Reference_To (Standard_String, Loc),\n+          Expression =>\n+            Make_String_Literal (Loc,\n+              Full_Qualified_Name (First_Subtype (Typ)))));\n \n-      --  Set the pointer to the Interfaces_Table (if any). Otherwise the\n-      --  corresponding access component is set to null.\n+      --  Calculate the value of the RC_Offset component. These are the\n+      --  valid valiues and their meaning:\n+      --   >0: For simple types with controlled components is\n+      --         type._record_controller'position\n+      --    0: For types with no controlled components\n+      --   -1: For complex types with controlled components where the position\n+      --       of the record controller is not statically computable but there\n+      --       are controlled components at this level. The _Controller field\n+      --       is available right after the _parent.\n+      --   -2: There are no controlled components at this level. We need to\n+      --       get the position from the parent.\n \n-      if Num_Ifaces = 0 then\n-         if RTE_Available (RE_Set_Interface_Table) then\n-            Append_To (Elab_Code,\n-              Make_DT_Access_Action (Typ,\n-                Action => Set_Interface_Table,\n-                Args   => New_List (\n-                  New_Reference_To (DT_Ptr, Loc),                    -- DTptr\n-                  New_Reference_To (RTE (RE_Null_Address), Loc))));  -- null\n+      if Is_Interface (Typ)\n+        or else not Has_Controlled_Component (Typ)\n+      then\n+         RC_Offset_Node := Make_Integer_Literal (Loc, 0);\n+\n+      elsif Etype (Typ) /= Typ\n+        and then Has_Discriminants (Etype (Typ))\n+      then\n+         if Has_New_Controlled_Component (Typ) then\n+            RC_Offset_Node := Make_Integer_Literal (Loc, -1);\n+         else\n+            RC_Offset_Node := Make_Integer_Literal (Loc, -2);\n          end if;\n+      else\n+         RC_Offset_Node :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix =>\n+               Make_Selected_Component (Loc,\n+                 Prefix => New_Reference_To (Typ, Loc),\n+                 Selector_Name =>\n+                   New_Reference_To (Controller_Component (Typ), Loc)),\n+             Attribute_Name => Name_Position);\n+\n+         --  This is not proper Ada code to use the attribute 'Position\n+         --  on something else than an object but this is supported by\n+         --  the back end (see comment on the Bit_Component attribute in\n+         --  sem_attr). So we avoid semantic checking here.\n+\n+         --  Is this documented in sinfo.ads??? it should be!\n+\n+         Set_Analyzed (RC_Offset_Node);\n+         Set_Etype (Prefix (RC_Offset_Node), RTE (RE_Record_Controller));\n+         Set_Etype (Prefix (Prefix (RC_Offset_Node)), Typ);\n+         Set_Etype (Selector_Name (Prefix (RC_Offset_Node)),\n+           RTE (RE_Record_Controller));\n+         Set_Etype (RC_Offset_Node, RTE (RE_Storage_Offset));\n+      end if;\n \n-      --  Generate the Interface_Table object and set the access\n-      --  component if the TSD to it.\n+      --  Set the pointer to the Interfaces_Table (if any). Otherwise the\n+      --  corresponding access component is set to null. The table of\n+      --  interfaces is required for AI-405\n \n-      elsif RTE_Available (RE_Set_Interface_Table) then\n-         Append_To (Result,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => ITable,\n-             Aliased_Present     => True,\n-             Object_Definition   =>\n-               Make_Subtype_Indication (Loc,\n-                 Subtype_Mark => New_Reference_To\n-                   (RTE (RE_Interface_Data), Loc),\n-                 Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n-                   Constraints => New_List (\n-                     Make_Integer_Literal (Loc,\n-                       Num_Ifaces))))));\n+      if RTE_Record_Component_Available (RE_Ifaces_Table_Ptr) then\n+         if Num_Ifaces = 0 then\n+            Iface_Table_Node :=\n+              New_Reference_To (RTE (RE_Null_Address), Loc);\n \n-         Append_To (Elab_Code,\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Interface_Table,\n-             Args   => New_List (\n-               New_Reference_To (DT_Ptr, Loc),               -- DTptr\n-               Make_Attribute_Reference (Loc,                -- Value\n-                 Prefix         => New_Reference_To (ITable, Loc),\n-                 Attribute_Name => Name_Address))));\n+         --  Generate the Interface_Table object.\n+\n+         else\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => ITable,\n+                Aliased_Present     => True,\n+                Object_Definition   =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark => New_Reference_To\n+                      (RTE (RE_Interface_Data), Loc),\n+                    Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n+                      Constraints => New_List (\n+                        Make_Integer_Literal (Loc,\n+                          Num_Ifaces))))));\n+\n+            Iface_Table_Node :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Reference_To (ITable, Loc),\n+                Attribute_Name => Name_Address);\n+         end if;\n       end if;\n \n-      --  Generate:\n-      --    Set_Num_Prim_Ops (T'Tag, Nb_Prim)\n+      --  Generate: Set_Remotely_Callable (DT_Ptr, Status); where Status is\n+      --  described in E.4 (18)\n \n-      if RTE_Available (RE_Set_Num_Prim_Ops) then\n-         if not Is_Interface (Typ) then\n-            if Empty_DT then\n-               Append_To (Elab_Code,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n-                   Parameter_Associations => New_List (\n-                     New_Reference_To (DT_Ptr, Loc),\n-                     Make_Integer_Literal (Loc, Uint_0))));\n-            else\n-               Append_To (Elab_Code,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n-                   Parameter_Associations => New_List (\n-                     New_Reference_To (DT_Ptr, Loc),\n-                     Make_Integer_Literal (Loc, Nb_Prim))));\n-            end if;\n-         end if;\n+      Remotely_Callable :=\n+        Boolean_Literals\n+          (Is_Pure (Typ)\n+             or else Is_Shared_Passive (Typ)\n+             or else\n+               ((Is_Remote_Types (Typ)\n+                   or else Is_Remote_Call_Interface (Typ))\n+                and then Original_View_In_Visible_Part (Typ))\n+             or else not Comes_From_Source (Typ));\n \n+      --  Generate code to create the storage for the type specific data object\n+      --  with enough space to store the tags of the ancestors plus the tags\n+      --  of all the implemented interfaces (as described in a-tags.adb).\n+\n+      --   TSD : Type_Specific_Data (I_Depth) :=\n+      --           (Idepth        => I_Depth,\n+      --            Access_Level  => Type_Access_Level (Typ),\n+      --            Expanded_Name => Cstring_Ptr!(Exname'Address))\n+      --            [ External_Tag  => Cstring_Ptr!(Exname'Address)) ]\n+      --            RC_Offset     => <<integer-value>>,\n+      --            Remotely_Callable => <<boolean-value>>\n+      --            [ Ifaces_Table_Ptr => <<access-value>> ]\n+      --            others => <>);\n+      --   for TSD'Alignment use Address'Alignment\n+\n+      TSD_Aggr_List := New_List (\n+        Make_Component_Association (Loc,\n+          Choices => New_List (\n+            New_Occurrence_Of (RTE_Record_Component (RE_Idepth), Loc)),\n+          Expression => Make_Integer_Literal (Loc, I_Depth)),\n+\n+        Make_Component_Association (Loc,\n+          Choices => New_List (\n+            New_Occurrence_Of (RTE_Record_Component (RE_Access_Level), Loc)),\n+          Expression => Make_Integer_Literal (Loc, Type_Access_Level (Typ))),\n+\n+        Make_Component_Association (Loc,\n+          Choices => New_List (\n+            New_Occurrence_Of\n+              (RTE_Record_Component (RE_Expanded_Name), Loc)),\n+          Expression =>\n+            Unchecked_Convert_To (RTE (RE_Cstring_Ptr),\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (Exname, Loc),\n+                Attribute_Name => Name_Address))));\n+\n+      if not Has_External_Tag_Rep_Clause (Typ) then\n+\n+         --  Should be the external name not the qualified name???\n+\n+         Append_To (TSD_Aggr_List,\n+           Make_Component_Association (Loc,\n+             Choices => New_List (\n+               New_Occurrence_Of\n+                 (RTE_Record_Component (RE_External_Tag), Loc)),\n+             Expression =>\n+               Unchecked_Convert_To (RTE (RE_Cstring_Ptr),\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => New_Reference_To (Exname, Loc),\n+                   Attribute_Name => Name_Address))));\n+      end if;\n+\n+      Append_List_To (TSD_Aggr_List, New_List (\n+        Make_Component_Association (Loc,\n+          Choices => New_List (\n+            New_Occurrence_Of (RTE_Record_Component (RE_RC_Offset), Loc)),\n+          Expression => RC_Offset_Node),\n+\n+        Make_Component_Association (Loc,\n+          Choices => New_List (\n+            New_Occurrence_Of\n+             (RTE_Record_Component (RE_Remotely_Callable), Loc)),\n+          Expression => New_Occurrence_Of (Remotely_Callable, Loc))));\n+\n+      if RTE_Record_Component_Available (RE_Ifaces_Table_Ptr) then\n+         Append_To (TSD_Aggr_List,\n+           Make_Component_Association (Loc,\n+             Choices => New_List (\n+               New_Occurrence_Of\n+                (RTE_Record_Component (RE_Ifaces_Table_Ptr), Loc)),\n+             Expression => Iface_Table_Node));\n+      end if;\n+\n+      Append_To (TSD_Aggr_List,\n+        Make_Component_Association (Loc,\n+          Choices     => New_List (Make_Others_Choice (Loc)),\n+          Expression  => Empty,\n+          Box_Present => True));\n+\n+      --  Save the expanded name in the dispatch table\n+\n+      Append_To (Result,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => TSD,\n+          Aliased_Present     => True,\n+          Object_Definition   =>\n+            Make_Subtype_Indication (Loc,\n+              Subtype_Mark => New_Reference_To (\n+                RTE (RE_Type_Specific_Data), Loc),\n+              Constraint =>\n+                Make_Index_Or_Discriminant_Constraint (Loc,\n+                  Constraints => New_List (\n+                    Make_Integer_Literal (Loc, I_Depth)))),\n+          Expression => Make_Aggregate (Loc,\n+            Component_Associations => TSD_Aggr_List)));\n+\n+      Append_To (Result,\n+        Make_Attribute_Definition_Clause (Loc,\n+          Name       => New_Reference_To (TSD, Loc),\n+          Chars      => Name_Alignment,\n+          Expression =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix => New_Reference_To (RTE (RE_Integer_Address), Loc),\n+              Attribute_Name => Name_Alignment)));\n+\n+      --  Generate code to put the Address of the TSD in the dispatch table\n+\n+      Append_To (Elab_Code,\n+        Build_Set_TSD (Loc,\n+          Tag_Node => New_Reference_To (DT_Ptr, Loc),\n+          Value_Node =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix          => New_Reference_To (TSD, Loc),\n+              Attribute_Name  => Name_Address)));\n+\n+      --  Generate extra code required for synchronized interfaces\n+\n+      if RTE_Available (RE_Set_Tagged_Kind) then\n          if Ada_Version >= Ada_05\n            and then not Is_Interface  (Typ)\n-           and then not Is_Abstract   (Typ)\n+           and then not Is_Abstract_Type   (Typ)\n            and then not Is_Controlled (Typ)\n            and then not Restriction_Active (No_Dispatching_Calls)\n          then\n@@ -3029,13 +3040,12 @@ package body Exp_Disp is\n             --  of the table is constrained by the number of non-predefined\n             --  primitive operations.\n \n-            if not Empty_DT\n+            if Has_Dispatch_Table\n               and then Is_Concurrent_Record_Type (Typ)\n-              and then Implements_Interface (\n-                         Typ          => Typ,\n-                         Kind         => Any_Limited_Interface,\n-                         Check_Parent => True)\n+              and then Has_Abstract_Interfaces (Typ)\n             then\n+               --  No need to generate this code if Nb_Prim = 0 ???\n+\n                Append_To (Result,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => SSD,\n@@ -3063,46 +3073,10 @@ package body Exp_Disp is\n          end if;\n       end if;\n \n-      --  Generate: Exname : constant String := full_qualified_name (typ);\n-      --  The type itself may be an anonymous parent type, so use the first\n-      --  subtype to have a user-recognizable name.\n-\n-      Append_To (Result,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Exname,\n-          Constant_Present    => True,\n-          Object_Definition   => New_Reference_To (Standard_String, Loc),\n-          Expression =>\n-            Make_String_Literal (Loc,\n-              Full_Qualified_Name (First_Subtype (Typ)))));\n-\n-      --  Generate: Set_Expanded_Name (DT_Ptr, exname'Address);\n-\n-      Append_To (Elab_Code,\n-        Make_DT_Access_Action (Typ,\n-          Action => Set_Expanded_Name,\n-          Args   => New_List (\n-            Node1 => New_Reference_To (DT_Ptr, Loc),\n-            Node2 =>\n-              Make_Attribute_Reference (Loc,\n-                Prefix => New_Reference_To (Exname, Loc),\n-                Attribute_Name => Name_Address))));\n-\n-      if not Is_Interface (Typ) then\n-         --  Generate: Set_Access_Level (DT_Ptr, <type's accessibility level>);\n-\n-         Append_To (Elab_Code,\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_Access_Level,\n-             Args   => New_List (\n-               Node1 => New_Reference_To (DT_Ptr, Loc),\n-               Node2 => Make_Integer_Literal (Loc, Type_Access_Level (Typ)))));\n-      end if;\n-\n       --  If the ancestor is a CPP_Class type we inherit the dispatch tables\n       --  in the init proc, and we don't need to fill them in here.\n \n-      if Is_CPP_Class (Etype (Typ)) and then not Debug_Flag_QQ then\n+      if Is_CPP_Class (Etype (Typ)) then\n          null;\n \n          --  Otherwise we fill in the dispatch tables here\n@@ -3112,6 +3086,8 @@ package body Exp_Disp is\n            or else Is_CPP_Class (Etype (Typ))\n            or else Is_Interface (Typ)\n          then\n+            Null_Parent_Tag := True;\n+\n             Old_Tag1 :=\n               Unchecked_Convert_To (Generalized_Tag,\n                 Make_Integer_Literal (Loc, 0));\n@@ -3132,27 +3108,34 @@ package body Exp_Disp is\n            and then not Is_Interface (Typ)\n            and then not Restriction_Active (No_Dispatching_Calls)\n          then\n-            --  Generate: Inherit_DT (parent'tag, DT_Ptr, nb_prim of parent);\n+            --  Inherit the dispatch table\n \n             if not Is_Interface (Etype (Typ)) then\n                if Restriction_Active (No_Dispatching_Calls) then\n-                  Append_To (Elab_Code,\n-                    Make_DT_Access_Action (Typ,\n-                      Action => Inherit_DT,\n-                      Args   => New_List (\n-                        Node1 => Old_Tag1,\n-                        Node2 => New_Reference_To (DT_Ptr, Loc),\n-                        Node3 => Make_Integer_Literal (Loc, Uint_0))));\n+                  null;\n+\n                else\n-                  Append_To (Elab_Code,\n-                    Make_DT_Access_Action (Typ,\n-                      Action => Inherit_DT,\n-                      Args   => New_List (\n-                        Node1 => Old_Tag1,\n-                        Node2 => New_Reference_To (DT_Ptr, Loc),\n-                        Node3 => Make_Integer_Literal (Loc,\n-                                   DT_Entry_Count\n-                                     (First_Tag_Component (Etype (Typ)))))));\n+                  if not Null_Parent_Tag then\n+                     declare\n+                        Nb_Prims : constant Int :=\n+                                     UI_To_Int (DT_Entry_Count\n+                                       (First_Tag_Component (Etype (Typ))));\n+                     begin\n+                        Append_To (Elab_Code,\n+                          Build_Inherit_Predefined_Prims (Loc,\n+                            Old_Tag_Node => Old_Tag1,\n+                            New_Tag_Node =>\n+                              New_Reference_To (DT_Ptr, Loc)));\n+\n+                        if Nb_Prims /= 0 then\n+                           Append_To (Elab_Code,\n+                             Build_Inherit_Prims (Loc,\n+                               Old_Tag_Node => Old_Tag2,\n+                               New_Tag_Node => New_Reference_To (DT_Ptr, Loc),\n+                               Num_Prims    => Nb_Prims));\n+                        end if;\n+                     end;\n+                  end if;\n                end if;\n             end if;\n \n@@ -3207,21 +3190,41 @@ package body Exp_Disp is\n                         loop\n                            if Is_Tag (E) and then Chars (E) /= Name_uTag then\n                               if not Is_Interface (Etype (Typ)) then\n-                                 Append_To (Elab_Code,\n-                                   Make_DT_Access_Action (Typ,\n-                                     Action => Inherit_DT,\n-                                     Args   => New_List (\n-                                       Node1 => Unchecked_Convert_To\n-                                                  (RTE (RE_Tag),\n-                                                   New_Reference_To\n-                                                     (Node (Sec_DT_Ancestor),\n-                                                      Loc)),\n-                                       Node2 => Unchecked_Convert_To\n-                                                  (RTE (RE_Tag),\n-                                                   New_Reference_To\n-                                                     (Node (Sec_DT_Typ), Loc)),\n-                                       Node3 => Make_Integer_Literal (Loc,\n-                                                  DT_Entry_Count (E)))));\n+\n+                                 --  Inherit the dispatch table\n+\n+                                 declare\n+                                    Num_Prims : constant Int :=\n+                                                UI_To_Int (DT_Entry_Count (E));\n+                                 begin\n+                                    Append_To (Elab_Code,\n+                                      Build_Inherit_Predefined_Prims (Loc,\n+                                        Old_Tag_Node =>\n+                                          Unchecked_Convert_To (RTE (RE_Tag),\n+                                             New_Reference_To\n+                                               (Node (Sec_DT_Ancestor), Loc)),\n+                                        New_Tag_Node =>\n+                                          Unchecked_Convert_To (RTE (RE_Tag),\n+                                            New_Reference_To\n+                                              (Node (Sec_DT_Typ), Loc))));\n+\n+                                    if Num_Prims /= 0 then\n+                                       Append_To (Elab_Code,\n+                                         Build_Inherit_Prims (Loc,\n+                                           Old_Tag_Node =>\n+                                             Unchecked_Convert_To\n+                                               (RTE (RE_Tag),\n+                                                New_Reference_To\n+                                                  (Node (Sec_DT_Ancestor),\n+                                                   Loc)),\n+                                           New_Tag_Node =>\n+                                             Unchecked_Convert_To\n+                                              (RTE (RE_Tag),\n+                                               New_Reference_To\n+                                                 (Node (Sec_DT_Typ), Loc)),\n+                                           Num_Prims => Num_Prims));\n+                                    end if;\n+                                 end;\n                               end if;\n \n                               Next_Elmt (Sec_DT_Ancestor);\n@@ -3253,157 +3256,68 @@ package body Exp_Disp is\n          --    Inherit_TSD (parent'tag, DT_Ptr);\n \n          if not Is_Interface (Typ) then\n-            Append_To (Elab_Code,\n-              Make_DT_Access_Action (Typ,\n-                Action => Inherit_TSD,\n-                Args   => New_List (\n-                  Node1 => Old_Tag2,\n-                  Node2 => New_Reference_To (DT_Ptr, Loc))));\n-         end if;\n-      end if;\n-\n-      if not Is_Interface (Typ) then\n-\n-         --  For types with no controlled components, generate:\n-         --    Set_RC_Offset (DT_Ptr, 0);\n-\n-         --  For simple types with controlled components, generate:\n-         --    Set_RC_Offset (DT_Ptr, type._record_controller'position);\n-\n-         --  For complex types with controlled components where the position\n-         --  of the record controller is not statically computable, if there\n-         --  are controlled components at this level, generate:\n-         --    Set_RC_Offset (DT_Ptr, -1);\n-         --  to indicate that the _controller field is right after the _parent\n-\n-         --  Or if there are no controlled components at this level, generate:\n-         --    Set_RC_Offset (DT_Ptr, -2);\n-         --  to indicate that we need to get the position from the parent.\n-\n-         declare\n-            Position : Node_Id;\n-\n-         begin\n-            if not Has_Controlled_Component (Typ) then\n-               Position := Make_Integer_Literal (Loc, 0);\n-\n-            elsif Etype (Typ) /= Typ\n-              and then Has_Discriminants (Etype (Typ))\n+            if Typ = Etype (Typ)\n+              or else Is_CPP_Class (Etype (Typ))\n             then\n-               if Has_New_Controlled_Component (Typ) then\n-                  Position := Make_Integer_Literal (Loc, -1);\n-               else\n-                  Position := Make_Integer_Literal (Loc, -2);\n-               end if;\n-            else\n-               Position :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix => New_Reference_To (Typ, Loc),\n-                       Selector_Name =>\n-                         New_Reference_To (Controller_Component (Typ), Loc)),\n-                   Attribute_Name => Name_Position);\n-\n-               --  This is not proper Ada code to use the attribute 'Position\n-               --  on something else than an object but this is supported by\n-               --  the back end (see comment on the Bit_Component attribute in\n-               --  sem_attr). So we avoid semantic checking here.\n-\n-               --  Is this documented in sinfo.ads??? it should be!\n-\n-               Set_Analyzed (Position);\n-               Set_Etype (Prefix (Position), RTE (RE_Record_Controller));\n-               Set_Etype (Prefix (Prefix (Position)), Typ);\n-               Set_Etype (Selector_Name (Prefix (Position)),\n-                 RTE (RE_Record_Controller));\n-               Set_Etype (Position, RTE (RE_Storage_Offset));\n-            end if;\n+               --  New_TSD (DT_Ptr);\n \n-            Append_To (Elab_Code,\n-              Make_DT_Access_Action (Typ,\n-                Action => Set_RC_Offset,\n-                Args   => New_List (\n-                  Node1 => New_Reference_To (DT_Ptr, Loc),\n-                  Node2 => Position)));\n-         end;\n-\n-         --  Generate: Set_Remotely_Callable (DT_Ptr, Status); where Status is\n-         --  described in E.4 (18)\n-\n-         declare\n-            Status : Entity_Id;\n-\n-         begin\n-            Status :=\n-              Boolean_Literals\n-                (Is_Pure (Typ)\n-                   or else Is_Shared_Passive (Typ)\n-                   or else\n-                     ((Is_Remote_Types (Typ)\n-                         or else Is_Remote_Call_Interface (Typ))\n-                      and then Original_View_In_Visible_Part (Typ))\n-                   or else not Comes_From_Source (Typ));\n-\n-            Append_To (Elab_Code,\n-              Make_DT_Access_Action (Typ,\n-                Action => Set_Remotely_Callable,\n-                Args   => New_List (\n-                  New_Occurrence_Of (DT_Ptr, Loc),\n-                  New_Occurrence_Of (Status, Loc))));\n-         end;\n-\n-         if RTE_Available (RE_Set_Offset_To_Top) then\n-            --  Generate:\n-            --    Set_Offset_To_Top (0, DT_Ptr, True, 0, null);\n+               Append_List_To (Elab_Code,\n+                 Build_New_TSD (Loc,\n+                   New_Tag_Node => New_Reference_To (DT_Ptr, Loc)));\n+            else\n+               --  Inherit_TSD (parent'tag, DT_Ptr);\n \n-            Append_To (Elab_Code,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n-                Parameter_Associations => New_List (\n-                  New_Reference_To (RTE (RE_Null_Address), Loc),\n-                  New_Reference_To (DT_Ptr, Loc),\n-                  New_Occurrence_Of (Standard_True, Loc),\n-                  Make_Integer_Literal (Loc, Uint_0),\n-                  New_Reference_To (RTE (RE_Null_Address), Loc))));\n+               Append_To (Elab_Code,\n+                 Build_Inherit_TSD (Loc,\n+                   Old_Tag_Node =>\n+                     New_Reference_To\n+                       (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))),\n+                        Loc),\n+                   New_Tag_Node      => New_Reference_To (DT_Ptr, Loc),\n+                   I_Depth           => I_Depth,\n+                   Parent_Num_Ifaces => Parent_Num_Ifaces));\n+            end if;\n          end if;\n       end if;\n \n-      --  Generate: Set_External_Tag (DT_Ptr, exname'Address);\n-      --  Should be the external name not the qualified name???\n+      if not Is_Interface (Typ)\n+        and then RTE_Available (RE_Set_Offset_To_Top)\n+      then\n+         --  Generate:\n+         --    Set_Offset_To_Top (0, DT_Ptr, True, 0, null);\n \n-      if not Has_External_Tag_Rep_Clause (Typ) then\n          Append_To (Elab_Code,\n-           Make_DT_Access_Action (Typ,\n-             Action => Set_External_Tag,\n-             Args   => New_List (\n-               Node1 => New_Reference_To (DT_Ptr, Loc),\n-               Node2 =>\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Reference_To (Exname, Loc),\n-                   Attribute_Name => Name_Address))));\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n+             Parameter_Associations => New_List (\n+               New_Reference_To (RTE (RE_Null_Address), Loc),\n+               New_Reference_To (DT_Ptr, Loc),\n+               New_Occurrence_Of (Standard_True, Loc),\n+               Make_Integer_Literal (Loc, Uint_0),\n+               New_Reference_To (RTE (RE_Null_Address), Loc))));\n+      end if;\n \n-         --  Generate code to register the Tag in the External_Tag hash\n-         --  table for the pure Ada type only.\n+      --  Generate code to register the Tag in the External_Tag hash table for\n+      --  the pure Ada type only.\n \n-         --        Register_Tag (Dt_Ptr);\n+      --        Register_Tag (Dt_Ptr);\n \n-         --  Skip this if routine not available, or in No_Run_Time mode\n-         --  or Typ is an abstract interface type (because the table to\n-         --  register it is not available in the abstract type but in\n-         --  types implementing this interface)\n+      --  Skip this if routine not available, or in No_Run_Time mode or Typ is\n+      --  an abstract interface type (because the table to register it is not\n+      --  available in the abstract type but in types implementing this\n+      --  interface)\n \n-         if not No_Run_Time_Mode\n-           and then RTE_Available (RE_Register_Tag)\n-           and then Is_RTE (Generalized_Tag, RE_Tag)\n-           and then not Is_Interface (Typ)\n-         then\n-            Append_To (Elab_Code,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Register_Tag), Loc),\n-                Parameter_Associations =>\n-                  New_List (New_Reference_To (DT_Ptr, Loc))));\n-         end if;\n+      if not Has_External_Tag_Rep_Clause (Typ)\n+        and then not No_Run_Time_Mode\n+        and then RTE_Available (RE_Register_Tag)\n+        and then Is_RTE (RTE (RE_Tag), RE_Tag)\n+        and then not Is_Interface (Typ)\n+      then\n+         Append_To (Elab_Code,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Register_Tag), Loc),\n+             Parameter_Associations =>\n+               New_List (New_Reference_To (DT_Ptr, Loc))));\n       end if;\n \n       --  Generate:\n@@ -3422,20 +3336,20 @@ package body Exp_Disp is\n           Condition       => New_Reference_To (No_Reg, Loc),\n           Then_Statements => Elab_Code));\n \n-      --  Ada 2005 (AI-251): Register the tag of the interfaces into\n-      --  the table of implemented interfaces.\n+      --  Ada 2005 (AI-251): Register the tag of the interfaces into the table\n+      --  of interfaces.\n \n       if Num_Ifaces > 0 then\n          declare\n-            Position : Int;\n+            Position : Nat;\n \n          begin\n             --  If the parent is an interface we must generate code to register\n             --  all its interfaces; otherwise this code is not needed because\n             --  Inherit_TSD has already inherited such interfaces.\n \n-            if Etype (Typ) /= Typ\n-              and then Is_Interface (Etype (Typ))\n+            if Is_Concurrent_Record_Type (Typ)\n+              or else (Etype (Typ) /= Typ and then Is_Interface (Etype (Typ)))\n             then\n                Position := 1;\n \n@@ -3553,7 +3467,7 @@ package body Exp_Disp is\n    procedure Make_Secondary_DT\n      (Typ             : Entity_Id;\n       Ancestor_Typ    : Entity_Id;\n-      Suffix_Index    : Int;\n+      Suffix_Index    : Nat;\n       Iface           : Entity_Id;\n       AI_Tag          : Entity_Id;\n       Acc_Disp_Tables : in out Elist_Id;\n@@ -3566,7 +3480,7 @@ package body Exp_Disp is\n       Iface_DT        : Node_Id;\n       Iface_DT_Ptr    : Node_Id;\n       Name_DT_Ptr     : Name_Id;\n-      Nb_Prim         : Int;\n+      Nb_Prim         : Nat;\n       OSD             : Entity_Id;\n       Size_Expr_Node  : Node_Id;\n       Tname           : Name_Id;\n@@ -3613,15 +3527,12 @@ package body Exp_Disp is\n \n       Size_Expr_Node :=\n         Make_Op_Add (Loc,\n-          Left_Opnd  => Make_DT_Access_Action (Etype (AI_Tag),\n-                          DT_Prologue_Size,\n-                          No_List),\n+          Left_Opnd  =>\n+            New_Reference_To (RTE (RE_DT_Prologue_Size), Loc),\n           Right_Opnd =>\n             Make_Op_Multiply (Loc,\n               Left_Opnd  =>\n-                Make_DT_Access_Action (Etype (AI_Tag),\n-                                       DT_Entry_Size,\n-                                       No_List),\n+                New_Reference_To (RTE (RE_DT_Entry_Size), Loc),\n               Right_Opnd =>\n                 Make_Integer_Literal (Loc, Nb_Prim)));\n \n@@ -3669,8 +3580,7 @@ package body Exp_Disp is\n                       Prefix         => New_Reference_To (Iface_DT, Loc),\n                       Attribute_Name => Name_Address)),\n                 Right_Opnd =>\n-                  Make_DT_Access_Action (Etype (AI_Tag),\n-                    DT_Prologue_Size, No_List)))));\n+                  New_Reference_To (RTE (RE_DT_Prologue_Size), Loc)))));\n \n       --  Note: Offset_To_Top will be initialized by the init subprogram\n \n@@ -3732,32 +3642,9 @@ package body Exp_Disp is\n               Prefix         => New_Reference_To (OSD, Loc),\n               Attribute_Name => Name_Address))));\n \n-      --  Generate:\n-      --    Set_Num_Prim_Ops (T'Tag, Nb_Prim)\n-\n-      if RTE_Available (RE_Set_Num_Prim_Ops) then\n-         if Empty_DT then\n-            Append_To (Result,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n-                Parameter_Associations => New_List (\n-                  Unchecked_Convert_To (RTE (RE_Tag),\n-                    New_Reference_To (Iface_DT_Ptr, Loc)),\n-                  Make_Integer_Literal (Loc, Uint_0))));\n-         else\n-            Append_To (Result,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Set_Num_Prim_Ops), Loc),\n-                Parameter_Associations => New_List (\n-                  Unchecked_Convert_To (RTE (RE_Tag),\n-                    New_Reference_To (Iface_DT_Ptr, Loc)),\n-                  Make_Integer_Literal (Loc, Nb_Prim))));\n-         end if;\n-      end if;\n-\n       if Ada_Version >= Ada_05\n-        and then not Is_Interface  (Typ)\n-        and then not Is_Abstract   (Typ)\n+        and then not Is_Interface (Typ)\n+        and then not Is_Abstract_Type (Typ)\n         and then not Is_Controlled (Typ)\n         and then RTE_Available (RE_Set_Tagged_Kind)\n         and then not Restriction_Active (No_Dispatching_Calls)\n@@ -3775,10 +3662,7 @@ package body Exp_Disp is\n \n          if not Empty_DT\n            and then Is_Concurrent_Record_Type (Typ)\n-           and then Implements_Interface (\n-                      Typ          => Typ,\n-                      Kind         => Any_Limited_Interface,\n-                      Check_Parent => True)\n+           and then Has_Abstract_Interfaces (Typ)\n          then\n             declare\n                Prim       : Entity_Id;\n@@ -3839,7 +3723,7 @@ package body Exp_Disp is\n       Prim_Als  : Entity_Id;\n       Prim_Elmt : Elmt_Id;\n       Prim_Pos  : Uint;\n-      Nb_Prim   : Int := 0;\n+      Nb_Prim   : Nat := 0;\n \n       type Examined_Array is array (Int range <>) of Boolean;\n \n@@ -4192,482 +4076,345 @@ package body Exp_Disp is\n       --  Local variables\n \n       Parent_Typ : constant Entity_Id := Etype (Typ);\n-      Root_Typ   : constant Entity_Id := Root_Type (Typ);\n       First_Prim : constant Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n       The_Tag    : constant Entity_Id := First_Tag_Component (Typ);\n \n       Adjusted   : Boolean := False;\n       Finalized  : Boolean := False;\n \n-      Count_Prim : Int;\n-      DT_Length  : Int;\n-      Nb_Prim    : Int;\n-      Parent_EC  : Int;\n+      Count_Prim : Nat;\n+      DT_Length  : Nat;\n+      Nb_Prim    : Nat;\n       Prim       : Entity_Id;\n       Prim_Elmt  : Elmt_Id;\n \n    --  Start of processing for Set_All_DT_Position\n \n    begin\n-      --  Get Entry_Count of the parent\n-\n-      if Parent_Typ /= Typ\n-        and then DT_Entry_Count (First_Tag_Component (Parent_Typ)) /= No_Uint\n-      then\n-         Parent_EC := UI_To_Int (DT_Entry_Count\n-                                   (First_Tag_Component (Parent_Typ)));\n-      else\n-         Parent_EC := 0;\n-      end if;\n-\n-      --  C++ Case, check that pragma CPP_Class, CPP_Virtual and CPP_Vtable\n-      --  give a coherent set of information\n-\n-      if Is_CPP_Class (Root_Typ) and then Debug_Flag_QQ then\n-\n-         --  Compute the number of primitive operations in the main Vtable\n-         --  Set their position:\n-         --    - where it was set if overriden or inherited\n-         --    - after the end of the parent vtable otherwise\n-\n-         Prim_Elmt := First_Prim;\n-         Nb_Prim := 0;\n-         while Present (Prim_Elmt) loop\n-            Prim := Node (Prim_Elmt);\n-\n-            if not Is_CPP_Class (Typ) then\n-               Set_DTC_Entity (Prim, The_Tag);\n-\n-            elsif Present (Alias (Prim)) then\n-               Set_DTC_Entity (Prim, DTC_Entity (Alias (Prim)));\n-               Set_DT_Position (Prim, DT_Position (Alias (Prim)));\n+      --  Set the DT_Position for each primitive operation. Perform some\n+      --  sanity checks to avoid to build completely inconsistant dispatch\n+      --  tables.\n \n-            elsif No (DTC_Entity (Prim)) and then Is_CPP_Class (Typ) then\n-                  Error_Msg_NE (\"is a primitive operation of&,\" &\n-                    \" pragma Cpp_Virtual required\", Prim, Typ);\n-            end if;\n-\n-            if DTC_Entity (Prim) = The_Tag then\n+      --  First stage: Set the DTC entity of all the primitive operations\n+      --  This is required to properly read the DT_Position attribute in\n+      --  the latter stages.\n \n-               --  Get the slot from the parent subprogram if any\n+      Prim_Elmt  := First_Prim;\n+      Count_Prim := 0;\n+      while Present (Prim_Elmt) loop\n+         Prim := Node (Prim_Elmt);\n \n-               declare\n-                  H : Entity_Id;\n+         --  Predefined primitives have a separate dispatch table\n \n-               begin\n-                  H := Homonym (Prim);\n-                  while Present (H) loop\n-                     if Present (DTC_Entity (H))\n-                       and then Root_Type (Scope (DTC_Entity (H))) = Root_Typ\n-                     then\n-                        Set_DT_Position (Prim, DT_Position (H));\n-                        exit;\n-                     end if;\n-\n-                     H := Homonym (H);\n-                  end loop;\n-               end;\n+         if not (Is_Predefined_Dispatching_Operation (Prim)\n+                   or else Is_Predefined_Dispatching_Alias (Prim))\n+         then\n+            Count_Prim := Count_Prim + 1;\n+         end if;\n \n-               --  Otherwise take the canonical slot after the end of the\n-               --  parent Vtable\n+         --  Ada 2005 (AI-251)\n \n-               if DT_Position (Prim) = No_Uint then\n-                  Nb_Prim := Nb_Prim + 1;\n-                  Set_DT_Position (Prim, UI_From_Int (Parent_EC + Nb_Prim));\n-\n-               elsif UI_To_Int (DT_Position (Prim)) > Parent_EC then\n-                  Nb_Prim := Nb_Prim + 1;\n-               end if;\n-            end if;\n+         if Present (Abstract_Interface_Alias (Prim))\n+           and then Is_Interface\n+                      (Find_Dispatching_Type\n+                        (Abstract_Interface_Alias (Prim)))\n+         then\n+            Set_DTC_Entity (Prim,\n+               Find_Interface_Tag\n+                 (T => Typ,\n+                  Iface => Find_Dispatching_Type\n+                            (Abstract_Interface_Alias (Prim))));\n+         else\n+            Set_DTC_Entity (Prim, The_Tag);\n+         end if;\n \n-            Next_Elmt (Prim_Elmt);\n-         end loop;\n+         --  Clear any previous value of the DT_Position attribute. In this\n+         --  way we ensure that the final position of all the primitives is\n+         --  stablished by the following stages of this algorithm.\n \n-         --  Check that the declared size of the Vtable is bigger or equal\n-         --  than the number of primitive operations (if bigger it means that\n-         --  some of the c++ virtual functions were not imported, that is\n-         --  allowed).\n+         Set_DT_Position (Prim, No_Uint);\n \n-         if DT_Entry_Count (The_Tag) = No_Uint\n-           or else not Is_CPP_Class (Typ)\n-         then\n-            Set_DT_Entry_Count (The_Tag, UI_From_Int (Parent_EC + Nb_Prim));\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n \n-         elsif UI_To_Int (DT_Entry_Count (The_Tag)) < Parent_EC + Nb_Prim then\n-            Error_Msg_N (\"not enough room in the Vtable for all virtual\"\n-              & \" functions\", The_Tag);\n-         end if;\n+      declare\n+         Fixed_Prim : array (Int range 0 .. Count_Prim) of Boolean\n+                        := (others => False);\n+         E : Entity_Id;\n \n-         --  Check that Positions are not duplicate nor outside the range of\n-         --  the Vtable.\n+         procedure Set_Fixed_Prim (Pos : Nat);\n+         --  Sets to true an element of the Fixed_Prim table to indicate\n+         --  that this entry of the dispatch table of Typ is occupied.\n \n-         declare\n-            Size : constant Int := UI_To_Int (DT_Entry_Count (The_Tag));\n-            Pos  : Int;\n-            Prim_Pos_Table : array (1 .. Size) of Entity_Id :=\n-                                                        (others => Empty);\n+         --------------------\n+         -- Set_Fixed_Prim --\n+         --------------------\n \n+         procedure Set_Fixed_Prim (Pos : Nat) is\n          begin\n-            Prim_Elmt := First_Prim;\n-            while Present (Prim_Elmt) loop\n-               Prim := Node (Prim_Elmt);\n+            pragma Assert (Pos >= 0 and then Pos <= Count_Prim);\n+            Fixed_Prim (Pos) := True;\n+         exception\n+            when Constraint_Error =>\n+               raise Program_Error;\n+         end Set_Fixed_Prim;\n \n-               if DTC_Entity (Prim) = The_Tag then\n-                  Pos := UI_To_Int (DT_Position (Prim));\n+      begin\n+         --  Second stage: Register fixed entries\n \n-                  if Pos not in Prim_Pos_Table'Range then\n-                     Error_Msg_N\n-                       (\"position not in range of virtual table\", Prim);\n+         Nb_Prim   := 0;\n+         Prim_Elmt := First_Prim;\n+         while Present (Prim_Elmt) loop\n+            Prim := Node (Prim_Elmt);\n \n-                  elsif Present (Prim_Pos_Table (Pos)) then\n-                     Error_Msg_NE (\"cannot be at the same position in the\"\n-                       & \" vtable than&\", Prim, Prim_Pos_Table (Pos));\n+            --  Predefined primitives have a separate table and all its\n+            --  entries are at predefined fixed positions.\n \n-                  else\n-                     Prim_Pos_Table (Pos) := Prim;\n-                  end if;\n-               end if;\n+            if Is_Predefined_Dispatching_Operation (Prim) then\n+               Set_DT_Position (Prim, Default_Prim_Op_Position (Prim));\n \n-               Next_Elmt (Prim_Elmt);\n-            end loop;\n-         end;\n-\n-         --  Generate listing showing the contents of the dispatch tables\n+            elsif Is_Predefined_Dispatching_Alias (Prim) then\n+               E := Alias (Prim);\n+               while Present (Alias (E)) loop\n+                  E := Alias (E);\n+               end loop;\n \n-         if Debug_Flag_ZZ then\n-            Write_DT (Typ);\n-         end if;\n+               Set_DT_Position (Prim, Default_Prim_Op_Position (E));\n \n-      --  For regular Ada tagged types, just set the DT_Position for\n-      --  each primitive operation. Perform some sanity checks to avoid\n-      --  to build completely inconsistant dispatch tables.\n+            --  Overriding primitives of ancestor abstract interfaces\n \n-      --  Note that the _Size primitive is always set at position 1 in order\n-      --  to comply with the needs of Ada.Tags.Parent_Size (see documentation\n-      --  in Ada.Tags).\n+            elsif Present (Abstract_Interface_Alias (Prim))\n+              and then Is_Parent\n+                         (Find_Dispatching_Type\n+                           (Abstract_Interface_Alias (Prim)),\n+                          Typ)\n+            then\n+               pragma Assert (DT_Position (Prim) = No_Uint\n+                 and then Present (DTC_Entity\n+                                    (Abstract_Interface_Alias (Prim))));\n \n-      else\n-         --  First stage: Set the DTC entity of all the primitive operations\n-         --  This is required to properly read the DT_Position attribute in\n-         --  the latter stages.\n+               E := Abstract_Interface_Alias (Prim);\n+               Set_DT_Position (Prim, DT_Position (E));\n \n-         Prim_Elmt  := First_Prim;\n-         Count_Prim := 0;\n-         while Present (Prim_Elmt) loop\n-            Prim := Node (Prim_Elmt);\n+               pragma Assert\n+                 (DT_Position (Alias (Prim)) = No_Uint\n+                    or else DT_Position (Alias (Prim)) = DT_Position (E));\n+               Set_DT_Position (Alias (Prim), DT_Position (E));\n+               Set_Fixed_Prim (UI_To_Int (DT_Position (Prim)));\n \n-            --  Predefined primitives have a separate dispatch table\n+            --  Overriding primitives must use the same entry as the\n+            --  overriden primitive\n \n-            if not (Is_Predefined_Dispatching_Operation (Prim)\n-                      or else Is_Predefined_Dispatching_Alias (Prim))\n+            elsif not Present (Abstract_Interface_Alias (Prim))\n+              and then Present (Alias (Prim))\n+              and then Find_Dispatching_Type (Alias (Prim)) /= Typ\n+              and then Is_Parent\n+                         (Find_Dispatching_Type (Alias (Prim)), Typ)\n+              and then Present (DTC_Entity (Alias (Prim)))\n             then\n-               Count_Prim := Count_Prim + 1;\n-            end if;\n-\n-            --  Ada 2005 (AI-251)\n+               E := Alias (Prim);\n+               Set_DT_Position (Prim, DT_Position (E));\n \n-            if Present (Abstract_Interface_Alias (Prim))\n-              and then Is_Interface\n-                         (Find_Dispatching_Type\n-                           (Abstract_Interface_Alias (Prim)))\n-            then\n-               Set_DTC_Entity (Prim,\n-                  Find_Interface_Tag\n-                    (T => Typ,\n-                     Iface => Find_Dispatching_Type\n-                               (Abstract_Interface_Alias (Prim))));\n-            else\n-               Set_DTC_Entity (Prim, The_Tag);\n+               if not Is_Predefined_Dispatching_Alias (E) then\n+                  Set_Fixed_Prim (UI_To_Int (DT_Position (E)));\n+               end if;\n             end if;\n \n-            --  Clear any previous value of the DT_Position attribute. In this\n-            --  way we ensure that the final position of all the primitives is\n-            --  stablished by the following stages of this algorithm.\n-\n-            Set_DT_Position (Prim, No_Uint);\n-\n             Next_Elmt (Prim_Elmt);\n          end loop;\n \n-         declare\n-            Fixed_Prim : array (Int range 0 .. Count_Prim) of Boolean\n-                           := (others => False);\n-            E : Entity_Id;\n+         --  Third stage: Fix the position of all the new primitives\n+         --  Entries associated with primitives covering interfaces\n+         --  are handled in a latter round.\n \n-            procedure Set_Fixed_Prim (Pos : Int);\n-            --  Sets to true an element of the Fixed_Prim table to indicate\n-            --  that this entry of the dispatch table of Typ is occupied.\n-\n-            --------------------\n-            -- Set_Fixed_Prim --\n-            --------------------\n-\n-            procedure Set_Fixed_Prim (Pos : Int) is\n-            begin\n-               pragma Assert (Pos >= 0 and then Pos <= Count_Prim);\n-               Fixed_Prim (Pos) := True;\n-            exception\n-               when Constraint_Error =>\n-                  raise Program_Error;\n-            end Set_Fixed_Prim;\n-\n-         begin\n-            --  Second stage: Register fixed entries\n-\n-            Nb_Prim   := 0;\n-            Prim_Elmt := First_Prim;\n-            while Present (Prim_Elmt) loop\n-               Prim := Node (Prim_Elmt);\n-\n-               --  Predefined primitives have a separate table and all its\n-               --  entries are at predefined fixed positions.\n-\n-               if Is_Predefined_Dispatching_Operation (Prim) then\n-                  Set_DT_Position (Prim, Default_Prim_Op_Position (Prim));\n-\n-               elsif Is_Predefined_Dispatching_Alias (Prim) then\n-                  E := Alias (Prim);\n-                  while Present (Alias (E)) loop\n-                     E := Alias (E);\n-                  end loop;\n-\n-                  Set_DT_Position (Prim, Default_Prim_Op_Position (E));\n-\n-               --  Overriding primitives of ancestor abstract interfaces\n-\n-               elsif Present (Abstract_Interface_Alias (Prim))\n-                 and then Is_Ancestor\n-                           (Find_Dispatching_Type\n-                             (Abstract_Interface_Alias (Prim)),\n-                            Typ)\n-               then\n-                  pragma Assert (DT_Position (Prim) = No_Uint\n-                    and then Present (DTC_Entity\n-                                       (Abstract_Interface_Alias (Prim))));\n-\n-                  E := Abstract_Interface_Alias (Prim);\n-                  Set_DT_Position (Prim, DT_Position (E));\n-\n-                  pragma Assert\n-                    (DT_Position (Alias (Prim)) = No_Uint\n-                       or else DT_Position (Alias (Prim)) = DT_Position (E));\n-                  Set_DT_Position (Alias (Prim), DT_Position (E));\n-                  Set_Fixed_Prim (UI_To_Int (DT_Position (Prim)));\n-\n-               --  Overriding primitives must use the same entry as the\n-               --  overriden primitive\n-\n-               elsif not Present (Abstract_Interface_Alias (Prim))\n-                 and then Present (Alias (Prim))\n-                 and then Find_Dispatching_Type (Alias (Prim)) /= Typ\n-                 and then Is_Ancestor\n-                            (Find_Dispatching_Type (Alias (Prim)), Typ)\n-                 and then Present (DTC_Entity (Alias (Prim)))\n-               then\n-                  E := Alias (Prim);\n-                  Set_DT_Position (Prim, DT_Position (E));\n+         Prim_Elmt := First_Prim;\n+         while Present (Prim_Elmt) loop\n+            Prim := Node (Prim_Elmt);\n \n-                  if not Is_Predefined_Dispatching_Alias (E) then\n-                     Set_Fixed_Prim (UI_To_Int (DT_Position (E)));\n-                  end if;\n-               end if;\n+            --  Skip primitives previously set entries\n \n-               Next_Elmt (Prim_Elmt);\n-            end loop;\n-\n-            --  Third stage: Fix the position of all the new primitives\n-            --  Entries associated with primitives covering interfaces\n-            --  are handled in a latter round.\n+            if DT_Position (Prim) /= No_Uint then\n+               null;\n \n-            Prim_Elmt := First_Prim;\n-            while Present (Prim_Elmt) loop\n-               Prim := Node (Prim_Elmt);\n+            --  Primitives covering interface primitives are handled later\n \n-               --  Skip primitives previously set entries\n+            elsif Present (Abstract_Interface_Alias (Prim)) then\n+               null;\n \n-               if DT_Position (Prim) /= No_Uint then\n-                  null;\n+            else\n+               --  Take the next available position in the DT\n \n-               --  Primitives covering interface primitives are handled later\n+               loop\n+                  Nb_Prim := Nb_Prim + 1;\n+                  pragma Assert (Nb_Prim <= Count_Prim);\n+                  exit when not Fixed_Prim (Nb_Prim);\n+               end loop;\n \n-               elsif Present (Abstract_Interface_Alias (Prim)) then\n-                  null;\n+               Set_DT_Position (Prim, UI_From_Int (Nb_Prim));\n+               Set_Fixed_Prim (Nb_Prim);\n+            end if;\n \n-               else\n-                  --  Take the next available position in the DT\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+      end;\n \n-                  loop\n-                     Nb_Prim := Nb_Prim + 1;\n-                     pragma Assert (Nb_Prim <= Count_Prim);\n-                     exit when not Fixed_Prim (Nb_Prim);\n-                  end loop;\n+      --  Fourth stage: Complete the decoration of primitives covering\n+      --  interfaces (that is, propagate the DT_Position attribute\n+      --  from the aliased primitive)\n \n-                  Set_DT_Position (Prim, UI_From_Int (Nb_Prim));\n-                  Set_Fixed_Prim (Nb_Prim);\n-               end if;\n+      Prim_Elmt := First_Prim;\n+      while Present (Prim_Elmt) loop\n+         Prim := Node (Prim_Elmt);\n \n-               Next_Elmt (Prim_Elmt);\n-            end loop;\n-         end;\n+         if DT_Position (Prim) = No_Uint\n+           and then Present (Abstract_Interface_Alias (Prim))\n+         then\n+            pragma Assert (Present (Alias (Prim))\n+              and then Find_Dispatching_Type (Alias (Prim)) = Typ);\n \n-         --  Fourth stage: Complete the decoration of primitives covering\n-         --  interfaces (that is, propagate the DT_Position attribute\n-         --  from the aliased primitive)\n+            --  Check if this entry will be placed in the primary DT\n \n-         Prim_Elmt := First_Prim;\n-         while Present (Prim_Elmt) loop\n-            Prim := Node (Prim_Elmt);\n-\n-            if DT_Position (Prim) = No_Uint\n-              and then Present (Abstract_Interface_Alias (Prim))\n+            if Is_Parent (Find_Dispatching_Type\n+                           (Abstract_Interface_Alias (Prim)),\n+                          Typ)\n             then\n-               pragma Assert (Present (Alias (Prim))\n-                 and then Find_Dispatching_Type (Alias (Prim)) = Typ);\n-\n-               --  Check if this entry will be placed in the primary DT\n-\n-               if Is_Ancestor (Find_Dispatching_Type\n-                                 (Abstract_Interface_Alias (Prim)),\n-                               Typ)\n-               then\n-                  pragma Assert (DT_Position (Alias (Prim)) /= No_Uint);\n-                  Set_DT_Position (Prim, DT_Position (Alias (Prim)));\n+               pragma Assert (DT_Position (Alias (Prim)) /= No_Uint);\n+               Set_DT_Position (Prim, DT_Position (Alias (Prim)));\n \n-               --  Otherwise it will be placed in the secondary DT\n+            --  Otherwise it will be placed in the secondary DT\n \n-               else\n-                  pragma Assert\n-                    (DT_Position (Abstract_Interface_Alias (Prim)) /= No_Uint);\n-                  Set_DT_Position (Prim,\n-                    DT_Position (Abstract_Interface_Alias (Prim)));\n-               end if;\n+            else\n+               pragma Assert\n+                 (DT_Position (Abstract_Interface_Alias (Prim)) /= No_Uint);\n+               Set_DT_Position (Prim,\n+                 DT_Position (Abstract_Interface_Alias (Prim)));\n             end if;\n+         end if;\n \n-            Next_Elmt (Prim_Elmt);\n-         end loop;\n-\n-         --  Generate listing showing the contents of the dispatch tables.\n-         --  This action is done before some further static checks because\n-         --  in case of critical errors caused by a wrong dispatch table\n-         --  we need to see the contents of such table.\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n \n-         if Debug_Flag_ZZ then\n-            Write_DT (Typ);\n-         end if;\n+      --  Generate listing showing the contents of the dispatch tables.\n+      --  This action is done before some further static checks because\n+      --  in case of critical errors caused by a wrong dispatch table\n+      --  we need to see the contents of such table.\n \n-         --  Final stage: Ensure that the table is correct plus some further\n-         --  verifications concerning the primitives.\n+      if Debug_Flag_ZZ then\n+         Write_DT (Typ);\n+      end if;\n \n-         Prim_Elmt := First_Prim;\n-         DT_Length := 0;\n-         while Present (Prim_Elmt) loop\n-            Prim := Node (Prim_Elmt);\n+      --  Final stage: Ensure that the table is correct plus some further\n+      --  verifications concerning the primitives.\n \n-            --  At this point all the primitives MUST have a position\n-            --  in the dispatch table\n+      Prim_Elmt := First_Prim;\n+      DT_Length := 0;\n+      while Present (Prim_Elmt) loop\n+         Prim := Node (Prim_Elmt);\n \n-            if DT_Position (Prim) = No_Uint then\n-               raise Program_Error;\n-            end if;\n+         --  At this point all the primitives MUST have a position\n+         --  in the dispatch table\n \n-            --  Calculate real size of the dispatch table\n+         if DT_Position (Prim) = No_Uint then\n+            raise Program_Error;\n+         end if;\n \n-            if not (Is_Predefined_Dispatching_Operation (Prim)\n-                      or else Is_Predefined_Dispatching_Alias (Prim))\n-              and then UI_To_Int (DT_Position (Prim)) > DT_Length\n-            then\n-               DT_Length := UI_To_Int (DT_Position (Prim));\n-            end if;\n+         --  Calculate real size of the dispatch table\n \n-            --  Ensure that the asignated position to non-predefined\n-            --  dispatching operations in the dispatch table is correct.\n+         if not (Is_Predefined_Dispatching_Operation (Prim)\n+                   or else Is_Predefined_Dispatching_Alias (Prim))\n+           and then UI_To_Int (DT_Position (Prim)) > DT_Length\n+         then\n+            DT_Length := UI_To_Int (DT_Position (Prim));\n+         end if;\n \n-            if not (Is_Predefined_Dispatching_Operation (Prim)\n-                      or else Is_Predefined_Dispatching_Alias (Prim))\n-            then\n-               Validate_Position (Prim);\n-            end if;\n+         --  Ensure that the asignated position to non-predefined\n+         --  dispatching operations in the dispatch table is correct.\n \n-            if Chars (Prim) = Name_Finalize then\n-               Finalized := True;\n-            end if;\n+         if not (Is_Predefined_Dispatching_Operation (Prim)\n+                   or else Is_Predefined_Dispatching_Alias (Prim))\n+         then\n+            Validate_Position (Prim);\n+         end if;\n \n-            if Chars (Prim) = Name_Adjust then\n-               Adjusted := True;\n-            end if;\n+         if Chars (Prim) = Name_Finalize then\n+            Finalized := True;\n+         end if;\n \n-            --  An abstract operation cannot be declared in the private part\n-            --  for a visible abstract type, because it could never be over-\n-            --  ridden. For explicit declarations this is checked at the\n-            --  point of declaration, but for inherited operations it must\n-            --  be done when building the dispatch table.\n+         if Chars (Prim) = Name_Adjust then\n+            Adjusted := True;\n+         end if;\n \n-            --  Ada 2005 (AI-251): Hidden entities associated with abstract\n-            --  interface primitives are not taken into account because the\n-            --  check is done with the aliased primitive.\n+         --  An abstract operation cannot be declared in the private part\n+         --  for a visible abstract type, because it could never be over-\n+         --  ridden. For explicit declarations this is checked at the\n+         --  point of declaration, but for inherited operations it must\n+         --  be done when building the dispatch table.\n+\n+         --  Ada 2005 (AI-251): Hidden entities associated with abstract\n+         --  interface primitives are not taken into account because the\n+         --  check is done with the aliased primitive.\n+\n+         if Is_Abstract_Type (Typ)\n+           and then Is_Abstract_Subprogram (Prim)\n+           and then Present (Alias (Prim))\n+           and then not Present (Abstract_Interface_Alias (Prim))\n+           and then Is_Derived_Type (Typ)\n+           and then In_Private_Part (Current_Scope)\n+           and then\n+             List_Containing (Parent (Prim)) =\n+               Private_Declarations\n+                (Specification (Unit_Declaration_Node (Current_Scope)))\n+           and then Original_View_In_Visible_Part (Typ)\n+         then\n+            --  We exclude Input and Output stream operations because\n+            --  Limited_Controlled inherits useless Input and Output\n+            --  stream operations from Root_Controlled, which can\n+            --  never be overridden.\n \n-            if Is_Abstract (Typ)\n-              and then Is_Abstract (Prim)\n-              and then Present (Alias (Prim))\n-              and then not Present (Abstract_Interface_Alias (Prim))\n-              and then Is_Derived_Type (Typ)\n-              and then In_Private_Part (Current_Scope)\n-              and then\n-                List_Containing (Parent (Prim)) =\n-                  Private_Declarations\n-                   (Specification (Unit_Declaration_Node (Current_Scope)))\n-              and then Original_View_In_Visible_Part (Typ)\n+            if not Is_TSS (Prim, TSS_Stream_Input)\n+                 and then\n+               not Is_TSS (Prim, TSS_Stream_Output)\n             then\n-               --  We exclude Input and Output stream operations because\n-               --  Limited_Controlled inherits useless Input and Output\n-               --  stream operations from Root_Controlled, which can\n-               --  never be overridden.\n-\n-               if not Is_TSS (Prim, TSS_Stream_Input)\n-                    and then\n-                  not Is_TSS (Prim, TSS_Stream_Output)\n-               then\n-                  Error_Msg_NE\n-                    (\"abstract inherited private operation&\" &\n-                     \" must be overridden ('R'M 3.9.3(10))\",\n-                    Parent (Typ), Prim);\n-               end if;\n+               Error_Msg_NE\n+                 (\"abstract inherited private operation&\" &\n+                  \" must be overridden ('R'M 3.9.3(10))\",\n+                 Parent (Typ), Prim);\n             end if;\n+         end if;\n \n-            Next_Elmt (Prim_Elmt);\n-         end loop;\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n \n-         --  Additional check\n+      --  Additional check\n \n-         if Is_Controlled (Typ) then\n-            if not Finalized then\n-               Error_Msg_N\n-                 (\"controlled type has no explicit Finalize method?\", Typ);\n+      if Is_Controlled (Typ) then\n+         if not Finalized then\n+            Error_Msg_N\n+              (\"controlled type has no explicit Finalize method?\", Typ);\n \n-            elsif not Adjusted then\n-               Error_Msg_N\n-                 (\"controlled type has no explicit Adjust method?\", Typ);\n-            end if;\n+         elsif not Adjusted then\n+            Error_Msg_N\n+              (\"controlled type has no explicit Adjust method?\", Typ);\n          end if;\n+      end if;\n \n-         --  Set the final size of the Dispatch Table\n+      --  Set the final size of the Dispatch Table\n \n-         Set_DT_Entry_Count (The_Tag, UI_From_Int (DT_Length));\n+      Set_DT_Entry_Count (The_Tag, UI_From_Int (DT_Length));\n \n-         --  The derived type must have at least as many components as its\n-         --  parent (for root types, the Etype points back to itself\n-         --  and the test should not fail)\n+      --  The derived type must have at least as many components as its\n+      --  parent (for root types, the Etype points back to itself\n+      --  and the test should not fail)\n \n-         --  This test fails compiling the partial view of a tagged type\n-         --  derived from an interface which defines the overriding subprogram\n-         --  in the private part. This needs further investigation???\n+      --  This test fails compiling the partial view of a tagged type\n+      --  derived from an interface which defines the overriding subprogram\n+      --  in the private part. This needs further investigation???\n \n-         if not Has_Private_Declaration (Typ) then\n-            pragma Assert (\n-              DT_Entry_Count (The_Tag) >=\n-              DT_Entry_Count (First_Tag_Component (Parent_Typ)));\n-            null;\n-         end if;\n+      if not Has_Private_Declaration (Typ) then\n+         pragma Assert (\n+           DT_Entry_Count (The_Tag) >=\n+           DT_Entry_Count (First_Tag_Component (Parent_Typ)));\n+         null;\n       end if;\n    end Set_All_DT_Position;\n \n@@ -4719,7 +4466,7 @@ package body Exp_Disp is\n       --  won't be able to declare objects of that type.\n \n       else\n-         Set_Is_Abstract (Typ);\n+         Set_Is_Abstract_Type (Typ);\n       end if;\n    end Set_Default_Constructor;\n \n@@ -4737,7 +4484,7 @@ package body Exp_Disp is\n \n       --  Abstract kinds\n \n-      if Is_Abstract (T) then\n+      if Is_Abstract_Type (T) then\n          if Is_Limited_Record (T) then\n             return New_Reference_To (RTE (RE_TK_Abstract_Limited_Tagged), Loc);\n          else\n@@ -4862,7 +4609,7 @@ package body Exp_Disp is\n             Write_Int (UI_To_Int (DT_Position (Prim)));\n          end if;\n \n-         if Is_Abstract (Prim) then\n+         if Is_Abstract_Subprogram (Prim) then\n             Write_Str (\" is abstract;\");\n \n          --  Check if this is a null primitive"}, {"sha": "7314ae255e3af8313e53f7aa6c69b5aef4994677", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -168,46 +168,24 @@ package Exp_Disp is\n    --    Exp_Disp.Set_All_DT_Position      - direct   use\n \n    type DT_Access_Action is\n-      (CW_Membership,\n-       IW_Membership,\n-       DT_Entry_Size,\n-       DT_Prologue_Size,\n-       Get_Access_Level,\n+      (IW_Membership,\n        Get_Entry_Index,\n-       Get_External_Tag,\n-       Get_Predefined_Prim_Op_Address,\n-       Get_Prim_Op_Address,\n        Get_Prim_Op_Kind,\n-       Get_RC_Offset,\n-       Get_Remotely_Callable,\n        Get_Tagged_Kind,\n-       Inherit_DT,\n-       Inherit_TSD,\n        Register_Interface_Tag,\n        Register_Tag,\n-       Set_Access_Level,\n        Set_Entry_Index,\n-       Set_Expanded_Name,\n-       Set_External_Tag,\n-       Set_Interface_Table,\n        Set_Offset_Index,\n        Set_OSD,\n-       Set_Predefined_Prim_Op_Address,\n-       Set_Prim_Op_Address,\n        Set_Prim_Op_Kind,\n-       Set_RC_Offset,\n-       Set_Remotely_Callable,\n        Set_Signature,\n        Set_SSD,\n-       Set_TSD,\n-       Set_Tagged_Kind,\n-       TSD_Entry_Size,\n-       TSD_Prologue_Size);\n+       Set_Tagged_Kind);\n \n    procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n    --  Expand the call to the operation through the dispatch table and perform\n-   --  the required tag checks when appropriate. For CPP types the call is\n-   --  done through the Vtable (tag checks are not relevant)\n+   --  the required tag checks when appropriate. For CPP types tag checks are\n+   --  not relevant.\n \n    procedure Expand_Interface_Actuals (Call_Node : Node_Id);\n    --  Ada 2005 (AI-251): Displace all the actuals corresponding to class-wide\n@@ -245,15 +223,6 @@ package Exp_Disp is\n    --  the secondary dispatch table of Prim's controlling type with Thunk_Id's\n    --  address.\n \n-   function Get_Remotely_Callable (Obj : Node_Id) return Node_Id;\n-   --  Return an expression that holds True if the object can be transmitted\n-   --  onto another partition according to E.4 (18)\n-\n-   function Init_Predefined_Interface_Primitives\n-     (Typ : Entity_Id) return List_Id;\n-   --  Ada 2005 (AI-251): Initialize the entries associated with predefined\n-   --  primitives in all the secondary dispatch tables of Typ.\n-\n    function Make_DT_Access_Action\n      (Typ    : Entity_Id;\n       Action : DT_Access_Action;\n@@ -333,7 +302,7 @@ package Exp_Disp is\n    procedure Make_Secondary_DT\n      (Typ             : Entity_Id;\n       Ancestor_Typ    : Entity_Id;\n-      Suffix_Index    : Int;\n+      Suffix_Index    : Nat;\n       Iface           : Entity_Id;\n       AI_Tag          : Entity_Id;\n       Acc_Disp_Tables : in out Elist_Id;"}, {"sha": "5e938aa1fc8678733b957a2ba905c74c44570a51", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 130, "deletions": 190, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -1303,145 +1303,6 @@ package body Exp_Util is\n       end if;\n    end Expand_Subtype_From_Expr;\n \n-   --------------------------------\n-   -- Find_Implemented_Interface --\n-   --------------------------------\n-\n-   --  Given the following code (XXX denotes irrelevant value):\n-\n-   --     type Limd_Iface is limited interface;\n-   --     type Prot_Iface is protected interface;\n-   --     type Sync_Iface is synchronized interface;\n-\n-   --     type Parent_Subtype is new Limd_Iface and Sync_Iface with ...\n-   --     type Child_Subtype is new Parent_Subtype and Prot_Iface with ...\n-\n-   --  The following calls will return the following values:\n-\n-   --     Find_Implemented_Interface\n-   --       (Child_Subtype, Synchronized_Interface, False)    -> Empty\n-\n-   --     Find_Implemented_Interface\n-   --       (Child_Subtype, Synchronized_Interface, True)     -> Sync_Iface\n-\n-   --     Find_Implemented_Interface\n-   --       (Child_Subtype, Any_Synchronized_Interface, XXX)  -> Prot_Iface\n-\n-   --     Find_Implemented_Interface\n-   --       (Child_Subtype, Any_Limited_Interface, XXX)       -> Prot_Iface\n-\n-   function Find_Implemented_Interface\n-     (Typ          : Entity_Id;\n-      Kind         : Interface_Kind;\n-      Check_Parent : Boolean := False) return Entity_Id\n-   is\n-      Iface_Elmt : Elmt_Id;\n-\n-      function Interface_In_Kind\n-        (I    : Entity_Id;\n-         Kind : Interface_Kind) return Boolean;\n-      --  Determine whether an interface falls into a specified kind\n-\n-      -----------------------\n-      -- Interface_In_Kind --\n-      -----------------------\n-\n-      function Interface_In_Kind\n-        (I    : Entity_Id;\n-         Kind : Interface_Kind) return Boolean is\n-      begin\n-         if Is_Limited_Interface (I)\n-           and then (Kind = Any_Interface\n-             or else Kind = Any_Limited_Interface\n-             or else Kind = Limited_Interface)\n-         then\n-            return True;\n-\n-         elsif Is_Protected_Interface (I)\n-           and then (Kind = Any_Interface\n-             or else Kind = Any_Limited_Interface\n-             or else Kind = Any_Synchronized_Interface\n-             or else Kind = Protected_Interface)\n-         then\n-            return True;\n-\n-         elsif Is_Synchronized_Interface (I)\n-           and then (Kind = Any_Interface\n-             or else Kind = Any_Limited_Interface\n-             or else Kind = Synchronized_Interface)\n-         then\n-            return True;\n-\n-         elsif Is_Task_Interface (I)\n-           and then (Kind = Any_Interface\n-             or else Kind = Any_Limited_Interface\n-             or else Kind = Any_Synchronized_Interface\n-             or else Kind = Task_Interface)\n-         then\n-            return True;\n-\n-         --  Regular interface. This should be the last kind to check since\n-         --  all of the previous cases have their Is_Interface flags set.\n-\n-         elsif Is_Interface (I)\n-           and then (Kind = Any_Interface\n-             or else Kind = Iface)\n-         then\n-            return True;\n-\n-         else\n-            return False;\n-         end if;\n-      end Interface_In_Kind;\n-\n-   --  Start of processing for Find_Implemented_Interface\n-\n-   begin\n-      if not Is_Tagged_Type (Typ) then\n-         return Empty;\n-      end if;\n-\n-      --  Implementations of the form:\n-      --    Typ is new Interface ...\n-\n-      if Is_Interface (Etype (Typ))\n-        and then Interface_In_Kind (Etype (Typ), Kind)\n-      then\n-         return Etype (Typ);\n-      end if;\n-\n-      --  Implementations of the form:\n-      --     Typ is new Typ_Parent and Interface ...\n-\n-      if Present (Abstract_Interfaces (Typ)) then\n-         Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n-         while Present (Iface_Elmt) loop\n-            if Interface_In_Kind (Node (Iface_Elmt), Kind) then\n-               return Node (Iface_Elmt);\n-            end if;\n-\n-            Iface_Elmt := Next_Elmt (Iface_Elmt);\n-         end loop;\n-      end if;\n-\n-      --  Typ is a derived type and may implement a limited interface\n-      --  through its parent subtype. Check the parent subtype as well\n-      --  as any interfaces explicitly implemented at this level.\n-\n-      if Check_Parent\n-        and then Ekind (Typ) = E_Record_Type\n-        and then Present (Parent_Subtype (Typ))\n-      then\n-         return Find_Implemented_Interface (\n-           Parent_Subtype (Typ), Kind, Check_Parent);\n-      end if;\n-\n-      --  Typ does not implement a limited interface either at this level or\n-      --  in any of its parent subtypes.\n-\n-      return Empty;\n-   end Find_Implemented_Interface;\n-\n    ------------------------\n    -- Find_Interface_ADT --\n    ------------------------\n@@ -1466,9 +1327,22 @@ package body Exp_Util is\n          AI      : Node_Id;\n \n       begin\n-         --  Climb to the ancestor (if any) handling private types\n+         pragma Assert (Typ /= Iface);\n+\n+         --  Climb to the ancestor (if any) handling synchronized interface\n+         --  derivations and private types\n+\n+         if Is_Concurrent_Record_Type (Typ) then\n+            declare\n+               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n+\n+            begin\n+               if Is_Non_Empty_List (Iface_List) then\n+                  Find_Secondary_Table (Etype (First (Iface_List)));\n+               end if;\n+            end;\n \n-         if Present (Full_View (Etype (Typ))) then\n+         elsif Present (Full_View (Etype (Typ))) then\n             if Full_View (Etype (Typ)) /= Typ then\n                Find_Secondary_Table (Full_View (Etype (Typ)));\n             end if;\n@@ -1477,13 +1351,10 @@ package body Exp_Util is\n             Find_Secondary_Table (Etype (Typ));\n          end if;\n \n-         --  If we already found it there is nothing else to do\n-\n-         if Found then\n-            return;\n-         end if;\n+         --  Traverse the list of interfaces implemented by the type\n \n-         if Present (Abstract_Interfaces (Typ))\n+         if not Found\n+           and then Present (Abstract_Interfaces (Typ))\n            and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n          then\n             AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n@@ -1501,9 +1372,11 @@ package body Exp_Util is\n          end if;\n       end Find_Secondary_Table;\n \n-   --  Start of processing for Find_Interface_Tag\n+   --  Start of processing for Find_Interface_ADT\n \n    begin\n+      pragma Assert (Is_Interface (Iface));\n+\n       --  Handle private types\n \n       if Has_Private_Declaration (Typ)\n@@ -1520,12 +1393,14 @@ package body Exp_Util is\n \n       --  Handle task and protected types implementing interfaces\n \n-      if Ekind (Typ) = E_Protected_Type\n-        or else Ekind (Typ) = E_Task_Type\n-      then\n+      if Is_Concurrent_Type (Typ) then\n          Typ := Corresponding_Record_Type (Typ);\n       end if;\n \n+      pragma Assert\n+        (not Is_Class_Wide_Type (Typ)\n+          and then Ekind (Typ) /= E_Incomplete_Type);\n+\n       ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n       pragma Assert (Present (Node (ADT)));\n       Find_Secondary_Table (Typ);\n@@ -1538,13 +1413,21 @@ package body Exp_Util is\n    ------------------------\n \n    function Find_Interface_Tag\n-     (T      : Entity_Id;\n-      Iface  : Entity_Id) return Entity_Id\n+     (T     : Entity_Id;\n+      Iface : Entity_Id) return Entity_Id\n    is\n       AI_Tag : Entity_Id;\n-      Found  : Boolean := False;\n+      Found  : Boolean   := False;\n       Typ    : Entity_Id := T;\n \n+      Is_Primary_Tag : Boolean := False;\n+\n+      Is_Sync_Typ : Boolean := False;\n+      --  In case of non concurrent-record-types each parent-type has the\n+      --  tags associated with the interface types that are not implemented\n+      --  by the ancestors; concurrent-record-types have their whole list of\n+      --  interface tags (and this case requires some special management).\n+\n       procedure Find_Tag (Typ : Entity_Id);\n       --  Internal subprogram used to recursively climb to the ancestors\n \n@@ -1561,15 +1444,32 @@ package body Exp_Util is\n          --  therefore shares the main tag.\n \n          if Typ = Iface then\n-            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n-            AI_Tag := First_Tag_Component (Typ);\n+            if Is_Sync_Typ then\n+               Is_Primary_Tag := True;\n+            else\n+               pragma Assert\n+                 (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+               AI_Tag := First_Tag_Component (Typ);\n+            end if;\n+\n             Found  := True;\n             return;\n          end if;\n \n+         --  Handle synchronized interface derivations\n+\n+         if Is_Concurrent_Record_Type (Typ) then\n+            declare\n+               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n+            begin\n+               if Is_Non_Empty_List (Iface_List) then\n+                  Find_Tag (Etype (First (Iface_List)));\n+               end if;\n+            end;\n+\n          --  Climb to the root type handling private types\n \n-         if Present (Full_View (Etype (Typ))) then\n+         elsif Present (Full_View (Etype (Typ))) then\n             if Full_View (Etype (Typ)) /= Typ then\n                Find_Tag (Full_View (Etype (Typ)));\n             end if;\n@@ -1586,9 +1486,12 @@ package body Exp_Util is\n          then\n             --  Skip the tag associated with the primary table\n \n-            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n-            AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n-            pragma Assert (Present (AI_Tag));\n+            if not Is_Sync_Typ then\n+               pragma Assert\n+                 (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+               AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n+               pragma Assert (Present (AI_Tag));\n+            end if;\n \n             AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n             while Present (AI_Elmt) loop\n@@ -1641,9 +1544,25 @@ package body Exp_Util is\n          Typ := Non_Limited_View (Typ);\n       end if;\n \n-      Find_Tag (Typ);\n-      pragma Assert (Found);\n-      return AI_Tag;\n+      if not Is_Concurrent_Record_Type (Typ) then\n+         Find_Tag (Typ);\n+         pragma Assert (Found);\n+         return AI_Tag;\n+\n+      --  Concurrent record types\n+\n+      else\n+         Is_Sync_Typ := True;\n+         AI_Tag      := Next_Tag_Component (First_Tag_Component (Typ));\n+         Find_Tag (Typ);\n+         pragma Assert (Found);\n+\n+         if Is_Primary_Tag then\n+            return First_Tag_Component (Typ);\n+         else\n+            return AI_Tag;\n+         end if;\n+      end if;\n    end Find_Interface_Tag;\n \n    --------------------\n@@ -1659,6 +1578,12 @@ package body Exp_Util is\n       Iface  : Entity_Id;\n       Typ    : Entity_Id := T;\n \n+      Is_Sync_Typ : Boolean := False;\n+      --  In case of non concurrent-record-types each parent-type has the\n+      --  tags associated with the interface types that are not implemented\n+      --  by the ancestors; concurrent-record-types have their whole list of\n+      --  interface tags (and this case requires some special management).\n+\n       procedure Find_Iface (Typ : Entity_Id);\n       --  Internal subprogram used to recursively climb to the ancestors\n \n@@ -1672,7 +1597,21 @@ package body Exp_Util is\n       begin\n          --  Climb to the root type\n \n-         if Etype (Typ) /= Typ then\n+         --  Handle sychronized interface derivations\n+\n+         if Is_Concurrent_Record_Type (Typ) then\n+            declare\n+               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n+            begin\n+               if Is_Non_Empty_List (Iface_List) then\n+                  Find_Iface (Etype (First (Iface_List)));\n+               end if;\n+            end;\n+\n+         --  Handle the common case\n+\n+         elsif Etype (Typ) /= Typ then\n+            pragma Assert (not Present (Full_View (Etype (Typ))));\n             Find_Iface (Etype (Typ));\n          end if;\n \n@@ -1684,9 +1623,12 @@ package body Exp_Util is\n          then\n             --  Skip the tag associated with the primary table\n \n-            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n-            AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n-            pragma Assert (Present (AI_Tag));\n+            if not Is_Sync_Typ then\n+               pragma Assert\n+                 (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+               AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n+               pragma Assert (Present (AI_Tag));\n+            end if;\n \n             AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n             while Present (AI_Elmt) loop\n@@ -1736,6 +1678,11 @@ package body Exp_Util is\n          Typ := Non_Limited_View (Typ);\n       end if;\n \n+      if Is_Concurrent_Record_Type (Typ) then\n+         Is_Sync_Typ := True;\n+         AI_Tag      := Next_Tag_Component (First_Tag_Component (Typ));\n+      end if;\n+\n       Find_Iface (Typ);\n       pragma Assert (Found);\n       return Iface;\n@@ -1780,6 +1727,10 @@ package body Exp_Util is\n       return Node (Prim);\n    end Find_Prim_Op;\n \n+   ------------------\n+   -- Find_Prim_Op --\n+   ------------------\n+\n    function Find_Prim_Op\n      (T    : Entity_Id;\n       Name : TSS_Name_Type) return Entity_Id\n@@ -2177,18 +2128,6 @@ package body Exp_Util is\n       return Count;\n    end Homonym_Number;\n \n-   --------------------------\n-   -- Implements_Interface --\n-   --------------------------\n-\n-   function Implements_Interface\n-     (Typ          : Entity_Id;\n-      Kind         : Interface_Kind;\n-      Check_Parent : Boolean := False) return Boolean is\n-   begin\n-      return Find_Implemented_Interface (Typ, Kind, Check_Parent) /= Empty;\n-   end Implements_Interface;\n-\n    ------------------------------\n    -- In_Unconditional_Context --\n    ------------------------------\n@@ -2747,10 +2686,16 @@ package body Exp_Util is\n                N_Package_Specification                  |\n                N_Parameter_Association                  |\n                N_Parameter_Specification                |\n+               N_Pop_Constraint_Error_Label             |\n+               N_Pop_Program_Error_Label                |\n+               N_Pop_Storage_Error_Label                |\n                N_Pragma_Argument_Association            |\n                N_Procedure_Specification                |\n                N_Protected_Body                         |\n                N_Protected_Definition                   |\n+               N_Push_Constraint_Error_Label            |\n+               N_Push_Program_Error_Label               |\n+               N_Push_Storage_Error_Label               |\n                N_Qualified_Expression                   |\n                N_Range                                  |\n                N_Range_Constraint                       |\n@@ -4485,7 +4430,7 @@ package body Exp_Util is\n       elsif Nkind (Exp) = N_Unchecked_Type_Conversion\n         and then not Safe_Unchecked_Type_Conversion (Exp)\n       then\n-         if Controlled_Type (Exp_Type) then\n+         if CW_Or_Controlled_Type (Exp_Type) then\n \n             --  Use a renaming to capture the expression, rather than create\n             --  a controlled temporary.\n@@ -5124,20 +5069,15 @@ package body Exp_Util is\n             E : Entity_Id;\n \n          begin\n-            E := First_Entity (Typ);\n+            E := First_Component_Or_Discriminant (Typ);\n             while Present (E) loop\n-               if Ekind (E) = E_Component\n-                 or else Ekind (E) = E_Discriminant\n+               if Component_May_Be_Bit_Aligned (E)\n+                 or else Type_May_Have_Bit_Aligned_Components (Etype (E))\n                then\n-                  if Component_May_Be_Bit_Aligned (E)\n-                    or else\n-                      Type_May_Have_Bit_Aligned_Components (Etype (E))\n-                  then\n-                     return True;\n-                  end if;\n+                  return True;\n                end if;\n \n-               Next_Entity (E);\n+               Next_Component_Or_Discriminant (E);\n             end loop;\n \n             return False;"}, {"sha": "dee5927b39dcb74401aa532d8f242e7f69dc8d9b", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -33,21 +33,6 @@ with Types;   use Types;\n \n package Exp_Util is\n \n-   --  An enumeration type used to capture all the possible interface\n-   --  kinds and their hierarchical relation. These values are used in\n-   --  Find_Implemented_Interface and Implements_Interface.\n-\n-   type Interface_Kind is (\n-     Any_Interface,               --  Any interface\n-     Any_Limited_Interface,       --  Only limited interfaces\n-     Any_Synchronized_Interface,  --  Only synchronized interfaces\n-\n-     Iface,                       --  Individual kinds\n-     Limited_Interface,\n-     Protected_Interface,\n-     Synchronized_Interface,\n-     Task_Interface);\n-\n    -----------------------------------------------\n    -- Handling of Actions Associated with Nodes --\n    -----------------------------------------------\n@@ -363,16 +348,6 @@ package Exp_Util is\n    --  Ada 2005 (AI-251): Given a type T implementing the interface Iface,\n    --  return the record component containing the tag of Iface.\n \n-   function Find_Implemented_Interface\n-     (Typ          : Entity_Id;\n-      Kind         : Interface_Kind;\n-      Check_Parent : Boolean := False) return Entity_Id;\n-   --  Ada 2005 (AI-345): Find a designated kind of interface implemented by\n-   --  Typ or any parent subtype. Return the first encountered interface that\n-   --  correspond to the selected class. Return Empty if no such interface is\n-   --  found. Use Check_Parent to climb a potential derivation chain and\n-   --  examine the parent subtypes for any implementation.\n-\n    function Find_Prim_Op (T : Entity_Id; Name : Name_Id) return Entity_Id;\n    --  Find the first primitive operation of type T whose name is 'Name'.\n    --  This function allows the use of a primitive operation which is not\n@@ -444,14 +419,6 @@ package Exp_Util is\n    --  chain, counting only entries in the curren scope. If an entity is not\n    --  overloaded, the returned number will be one.\n \n-   function Implements_Interface\n-     (Typ          : Entity_Id;\n-      Kind         : Interface_Kind;\n-      Check_Parent : Boolean := False) return Boolean;\n-   --  Ada 2005 (AI-345): Determine whether Typ implements a designated kind\n-   --  of interface. Use Check_Parent to climb a potential derivation chain\n-   --  and examine the parent subtypes for any implementation.\n-\n    function Inside_Init_Proc return Boolean;\n    --  Returns True if current scope is within an init proc\n "}, {"sha": "84be97a708da6a1e5e000bb36c47de26121a432c", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -635,8 +635,7 @@ package body Ch12 is\n             return P_Formal_Floating_Point_Definition;\n \n          when Tok_Interface => --  Ada 2005 (AI-251)\n-            return P_Interface_Type_Definition (Abstract_Present => False,\n-                                                Is_Synchronized => False);\n+            return P_Interface_Type_Definition (Abstract_Present => False);\n \n          when Tok_Left_Paren =>\n             return P_Formal_Discrete_Type_Definition;\n@@ -646,9 +645,8 @@ package body Ch12 is\n             Scan; --  past LIMITED\n \n             if Token = Tok_Interface then\n-               Typedef_Node := P_Interface_Type_Definition\n-                                (Abstract_Present => False,\n-                                 Is_Synchronized  => False);\n+               Typedef_Node :=\n+                 P_Interface_Type_Definition (Abstract_Present => False);\n                Set_Limited_Present (Typedef_Node);\n                return Typedef_Node;\n \n@@ -720,9 +718,8 @@ package body Ch12 is\n                --  Interface\n \n                else\n-                  Typedef_Node := P_Interface_Type_Definition\n-                                    (Abstract_Present => False,\n-                                     Is_Synchronized  => True);\n+                  Typedef_Node :=\n+                    P_Interface_Type_Definition (Abstract_Present => False);\n \n                   case Saved_Token is\n                      when Tok_Task =>"}, {"sha": "5d81004dace49ddf320ff18ad99b3a7fb565b89e", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -204,6 +204,12 @@ package body Sem_Disp is\n                Tagged_Type := Base_Type (Designated_Type (T));\n             end if;\n \n+         --  Ada 2005 : an incomplete type can be tagged. An operation with\n+         --  an access parameter of the type is dispatching.\n+\n+         elsif Scope (Designated_Type (T)) = Current_Scope then\n+            Tagged_Type := Designated_Type (T);\n+\n          --  Ada 2005 (AI-50217)\n \n          elsif From_With_Type (Designated_Type (T))\n@@ -231,13 +237,13 @@ package body Sem_Disp is\n                and then (not Is_Generic_Type (Tagged_Type)\n                           or else not Comes_From_Source (Subp)))\n         or else\n-          (Is_Formal_Subprogram (Subp) and then Is_Abstract (Subp))\n+          (Is_Formal_Subprogram (Subp) and then Is_Abstract_Subprogram (Subp))\n         or else\n           (Nkind (Parent (Parent (Subp))) = N_Subprogram_Renaming_Declaration\n             and then\n               Present (Corresponding_Formal_Spec (Parent (Parent (Subp))))\n             and then\n-              Is_Abstract (Subp))\n+              Is_Abstract_Subprogram (Subp))\n       then\n          return Tagged_Type;\n \n@@ -274,11 +280,11 @@ package body Sem_Disp is\n          Par  : Node_Id;\n \n       begin\n-         if Is_Abstract (Subp)\n+         if Is_Abstract_Subprogram (Subp)\n            and then No (Controlling_Argument (N))\n          then\n             if Present (Alias (Subp))\n-              and then not Is_Abstract (Alias (Subp))\n+              and then not Is_Abstract_Subprogram (Alias (Subp))\n               and then No (DTC_Entity (Subp))\n             then\n                --  Private overriding of inherited abstract operation,\n@@ -428,6 +434,7 @@ package body Sem_Disp is\n             --  Mark call as a dispatching call\n \n             Set_Controlling_Argument (N, Control);\n+            Check_Restriction (No_Dispatching_Calls, N);\n \n             --  Ada 2005 (AI-318-02): Check current implementation restriction\n             --  that a dispatching call cannot be made to a primitive function\n@@ -481,7 +488,7 @@ package body Sem_Disp is\n                            (Expression (Original_Node (Actual)))));\n                   end if;\n \n-                  if Present (Func) and then Is_Abstract (Func) then\n+                  if Present (Func) and then Is_Abstract_Subprogram (Func) then\n                      Error_Msg_N (\n                        \"call to abstract function must be dispatching\", N);\n                   end if;\n@@ -1080,7 +1087,8 @@ package body Sem_Disp is\n                --  a descendant type and inherits a nonabstract version.\n \n                if Etype (Subp) /= Tagged_Type then\n-                  Set_Is_Abstract (Old_Subp, Is_Abstract (Alias (Subp)));\n+                  Set_Is_Abstract_Subprogram\n+                    (Old_Subp, Is_Abstract_Subprogram (Alias (Subp)));\n                end if;\n             end if;\n          end if;\n@@ -1315,7 +1323,8 @@ package body Sem_Disp is\n       then\n          --  Ada 2005 (AI-251): Update the attribute alias of all the aliased\n          --  entities of the overriden primitive to reference New_Op, and also\n-         --  propagate them the new value of the attribute Is_Abstract.\n+         --  propagate them the new value of the attribute\n+         --  Is_Abstract_Subprogram.\n \n          Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n          while Present (Elmt) loop\n@@ -1328,12 +1337,13 @@ package body Sem_Disp is\n               and then Alias (Prim) = Prev_Op\n             then\n                Set_Alias (Prim, New_Op);\n-               Set_Is_Abstract (Prim, Is_Abstract (New_Op));\n+               Set_Is_Abstract_Subprogram\n+                 (Prim, Is_Abstract_Subprogram (New_Op));\n \n                --  Ensure that this entity will be expanded to fill the\n                --  corresponding entry in its dispatch table.\n \n-               if not Is_Abstract (Prim) then\n+               if not Is_Abstract_Subprogram (Prim) then\n                   Set_Has_Delayed_Freeze (Prim);\n                end if;\n             end if;"}, {"sha": "e3f72e4f112a1b90579e72a03a1d25f32710bc73", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4682a7ad30b0e642d755e02168d7db25c6d67/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=dee4682a7ad30b0e642d755e02168d7db25c6d67", "patch": "@@ -2443,15 +2443,13 @@ package body Sem_Elab is\n                      Chars (Subp) = Name_Initialize\n                        and then Comes_From_Source (Subp)\n                        and then Present (Parameter_Associations (Call))\n-                       and then Is_Controlled\n-                         (Etype (First (Parameter_Associations (Call))));\n+                       and then Is_Controlled (Etype (First_Actual (Call)));\n    begin\n       --  If the unit is mentioned in a with_clause of the current\n       --  unit, it is visible, and we can set the elaboration flag.\n \n       if Is_Immediately_Visible (Scop)\n-        or else\n-          (Is_Child_Unit (Scop) and then Is_Visible_Child_Unit (Scop))\n+        or else (Is_Child_Unit (Scop) and then Is_Visible_Child_Unit (Scop))\n       then\n          Activate_Elaborate_All_Desirable (Call, Scop);\n          Set_Suppress_Elaboration_Warnings (Scop, True);\n@@ -2482,10 +2480,10 @@ package body Sem_Elab is\n       if Is_Init_Proc (Subp)\n         or else Init_Call\n       then\n-         --  The initialization call is on an object whose type is not\n-         --  declared in the same scope as the subprogram. The type of\n-         --  the object must be a subtype of the type of operation. This\n-         --  object is the first actual in the call.\n+         --  The initialization call is on an object whose type is not declared\n+         --  in the same scope as the subprogram. The type of the object must\n+         --  be a subtype of the type of operation. This object is the first\n+         --  actual in the call.\n \n          declare\n             Typ : constant Entity_Id :="}]}