{"sha": "c7728805a7107444683290cd629d13f089130a0d", "node_id": "C_kwDOANBUbNoAKGM3NzI4ODA1YTcxMDc0NDQ2ODMyOTBjZDYyOWQxM2YwODkxMzBhMGQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-02-28T10:38:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-02-28T10:38:46Z"}, "message": "ubsan: Honor -fstrict-flex-arrays= in -fsanitize=bounds [PR108894]\n\nWhile this isn't really a regression, the -fstrict-flex-arrays*\noption is new in GCC 13 and so I think we should make -fsanitize=bounds\nplay with it well from the beginning.\n\nThe current behavior is that -fsanitize=bounds considers all trailing\narrays as flexible member-like arrays and both -fsanitize=bounds and\n-fsanitize=bounds-strict because of a bug don't even instrument\n[0] arrays at all, not as trailing nor when followed by other members.\n\nI think -fstrict-flex-arrays* options can be considered as language\nmode changing options, by default flexible member-like arrays are\nhandled like flexible arrays, but that option can change the set of\nthe arrays which are treated like that.  So, -fsanitize=bounds should\nchange with that on what is considered acceptable and what isn't.\nWhile -fsanitize=bounds-strict should reject them all always to\ncontinue previous behavior.\n\nThe following patch implements that.  To support [0] array instrumentation,\nI had to change the meaning of the bounds argument to .UBSAN_BOUNDS,\npreviously it was the TYPE_MAX_VALUE of the domain unless ignore_off_by_one\n(used for taking address of the array element rather than accessing it;\nin that case 1 is added to the bound argument) and the later lowered checks\nwere if (index > bound) report_failure ().\nThe problem with that is that for [0] arrays where (at least for C++)\nthe max value is all ones, for accesses that condition will be never true;\nfor addresses of elements it was working (in C++) correctly before.\nThis patch changes it to add 1 + ignore_off_by_one, so -1 becomes 0 or\n1 for &array_ref and changing the lowering to be if (index >= bound)\nreport_failure ().  Furthermore, as C represents the [0] arrays with\nNULL TYPE_MAX_VALUE, I treated those like the C++ ones.\n\n2023-02-28  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR sanitizer/108894\ngcc/\n\t* ubsan.cc (ubsan_expand_bounds_ifn): Emit index >= bound\n\tcomparison rather than index > bound.\n\t* gimple-fold.cc (gimple_fold_call): Use tree_int_cst_lt\n\trather than tree_int_cst_le for IFN_UBSAN_BOUND comparison.\n\t* doc/invoke.texi (-fsanitize=bounds): Document that whether\n\tflexible array member-like arrays are instrumented or not depends\n\ton -fstrict-flex-arrays* options of strict_flex_array attributes.\n\t(-fsanitize=bounds-strict): Document that flexible array members\n\tare not instrumented.\ngcc/c-family/\n\t* c-common.h (c_strict_flex_array_level_of): Declare.\n\t* c-common.cc (c_strict_flex_array_level_of): New function,\n\tmoved and renamed from c-decl.cc's strict_flex_array_level_of.\n\t* c-ubsan.cc (ubsan_instrument_bounds): Fix comment typo.  For\n\tC check c_strict_flex_array_level_of whether a trailing array\n\tshould be treated as flexible member like.  Handle C [0] arrays.\n\tAdd 1 + index_off_by_one rather than index_off_by_one to bounds\n\tand use tree_int_cst_lt rather than tree_int_cst_le for idx vs.\n\tbounds comparison.\ngcc/c/\n\t* c-decl.cc (strict_flex_array_level_of): Move to c-common.cc\n\tand rename to c_strict_flex_array_level_of.\n\t(is_flexible_array_member_p): Adjust caller.\ngcc/testsuite/\n\t* gcc.dg/ubsan/bounds-4.c: New test.\n\t* gcc.dg/ubsan/bounds-4a.c: New test.\n\t* gcc.dg/ubsan/bounds-4b.c: New test.\n\t* gcc.dg/ubsan/bounds-4c.c: New test.\n\t* gcc.dg/ubsan/bounds-4d.c: New test.\n\t* g++.dg/ubsan/bounds-1.C: New test.", "tree": {"sha": "ec08b75320097bdd5f0ce0625918d71d68337420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec08b75320097bdd5f0ce0625918d71d68337420"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7728805a7107444683290cd629d13f089130a0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7728805a7107444683290cd629d13f089130a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7728805a7107444683290cd629d13f089130a0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7728805a7107444683290cd629d13f089130a0d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41c02eeb309b3be58683be8f9961f3894b6fb4c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c02eeb309b3be58683be8f9961f3894b6fb4c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c02eeb309b3be58683be8f9961f3894b6fb4c7"}], "stats": {"total": 266, "additions": 223, "deletions": 43}, "files": [{"sha": "05468219e81760eeaa2ceb51a4f764f72af5fd7e", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -9501,4 +9501,33 @@ c_common_finalize_early_debug (void)\n       (*debug_hooks->early_global_decl) (cnode->decl);\n }\n \n+/* Get the LEVEL of the strict_flex_array for the ARRAY_FIELD based on the\n+   values of attribute strict_flex_array and the flag_strict_flex_arrays.  */\n+unsigned int\n+c_strict_flex_array_level_of (tree array_field)\n+{\n+  gcc_assert (TREE_CODE (array_field) == FIELD_DECL);\n+  unsigned int strict_flex_array_level = flag_strict_flex_arrays;\n+\n+  tree attr_strict_flex_array\n+    = lookup_attribute (\"strict_flex_array\", DECL_ATTRIBUTES (array_field));\n+  /* If there is a strict_flex_array attribute attached to the field,\n+     override the flag_strict_flex_arrays.  */\n+  if (attr_strict_flex_array)\n+    {\n+      /* Get the value of the level first from the attribute.  */\n+      unsigned HOST_WIDE_INT attr_strict_flex_array_level = 0;\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (tree_fits_uhwi_p (attr_strict_flex_array));\n+      attr_strict_flex_array_level = tree_to_uhwi (attr_strict_flex_array);\n+\n+      /* The attribute has higher priority than flag_struct_flex_array.  */\n+      strict_flex_array_level = attr_strict_flex_array_level;\n+    }\n+  return strict_flex_array_level;\n+}\n+\n #include \"gt-c-family-c-common.h\""}, {"sha": "e128e3e7379dda3f95011d4fa382312209963eb1", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -907,6 +907,7 @@ extern tree fold_for_warn (tree);\n extern tree c_common_get_narrower (tree, int *);\n extern bool get_attribute_operand (tree, unsigned HOST_WIDE_INT *);\n extern void c_common_finalize_early_debug (void);\n+extern unsigned int c_strict_flex_array_level_of (tree);\n extern bool c_option_is_from_cpp_diagnostics (int);\n \n /* Used by convert_and_check; in front ends.  */"}, {"sha": "3e24198d7bb58a03210210a67c26f3d57977866f", "filename": "gcc/c-family/c-ubsan.cc", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc-family%2Fc-ubsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc-family%2Fc-ubsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.cc?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -354,7 +354,7 @@ ubsan_instrument_return (location_t loc)\n    that gets expanded in the sanopt pass, and make an array dimension\n    of it.  ARRAY is the array, *INDEX is an index to the array.\n    Return NULL_TREE if no instrumentation is emitted.\n-   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n+   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside an ADDR_EXPR.  */\n \n tree\n ubsan_instrument_bounds (location_t loc, tree array, tree *index,\n@@ -363,13 +363,25 @@ ubsan_instrument_bounds (location_t loc, tree array, tree *index,\n   tree type = TREE_TYPE (array);\n   tree domain = TYPE_DOMAIN (type);\n \n-  if (domain == NULL_TREE || TYPE_MAX_VALUE (domain) == NULL_TREE)\n+  if (domain == NULL_TREE)\n     return NULL_TREE;\n \n   tree bound = TYPE_MAX_VALUE (domain);\n-  if (ignore_off_by_one)\n-    bound = fold_build2 (PLUS_EXPR, TREE_TYPE (bound), bound,\n-\t\t\t build_int_cst (TREE_TYPE (bound), 1));\n+  if (!bound)\n+    {\n+      /* Handle C [0] arrays, which have TYPE_MAX_VALUE NULL, like\n+\t C++ [0] arrays which have TYPE_MIN_VALUE 0 TYPE_MAX_VALUE -1.  */\n+      if (!c_dialect_cxx ()\n+\t  && COMPLETE_TYPE_P (type)\n+\t  && integer_zerop (TYPE_SIZE (type)))\n+\tbound = build_int_cst (TREE_TYPE (TYPE_MIN_VALUE (domain)), -1);\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n+  bound = fold_build2 (PLUS_EXPR, TREE_TYPE (bound), bound,\n+\t\t       build_int_cst (TREE_TYPE (bound),\n+\t\t       1 + ignore_off_by_one));\n \n   /* Detect flexible array members and suchlike, unless\n      -fsanitize=bounds-strict.  */\n@@ -392,6 +404,45 @@ ubsan_instrument_bounds (location_t loc, tree array, tree *index,\n \t  if (next)\n \t    /* Not a last element.  Instrument it.  */\n \t    break;\n+\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (cref, 1))) == ARRAY_TYPE\n+\t      && !c_dialect_cxx ())\n+\t    {\n+\t      unsigned l\n+\t\t= c_strict_flex_array_level_of (TREE_OPERAND (cref, 1));\n+\t      tree type2 = TREE_TYPE (TREE_OPERAND (cref, 1));\n+\t      if (TYPE_DOMAIN (type2) != NULL_TREE)\n+\t\t{\n+\t\t  tree max = TYPE_MAX_VALUE (TYPE_DOMAIN (type2));\n+\t\t  if (max == NULL_TREE)\n+\t\t    {\n+\t\t      /* C [0] */\n+\t\t      if (COMPLETE_TYPE_P (type2)\n+\t\t\t  && integer_zerop (TYPE_SIZE (type2))\n+\t\t\t  && l == 3)\n+\t\t\tnext = TREE_OPERAND (cref, 1);\n+\t\t    }\n+\t\t  else if (TREE_CODE (max) == INTEGER_CST)\n+\t\t    {\n+\t\t      if (c_dialect_cxx ()\n+\t\t\t  && integer_all_onesp (max))\n+\t\t\t{\n+\t\t\t  /* C++ [0] */\n+\t\t\t  if (l == 3)\n+\t\t\t    next = TREE_OPERAND (cref, 1);\n+\t\t\t}\n+\t\t      else if (integer_zerop (max))\n+\t\t\t{\n+\t\t\t  /* C/C++ [1] */\n+\t\t\t  if (l >= 2)\n+\t\t\t    next = TREE_OPERAND (cref, 1);\n+\t\t\t}\n+\t\t      else if (l >= 1)\n+\t\t\tnext = TREE_OPERAND (cref, 1);\n+\t\t    }\n+\t\t}\n+\t      if (next)\n+\t\tbreak;\n+\t    }\n \t  /* Ok, this is the last field of the structure/union.  But the\n \t     aggregate containing the field must be the last field too,\n \t     recursively.  */\n@@ -413,7 +464,7 @@ ubsan_instrument_bounds (location_t loc, tree array, tree *index,\n   if (idx\n       && TREE_CODE (bound) == INTEGER_CST\n       && tree_int_cst_sgn (idx) >= 0\n-      && tree_int_cst_le (idx, bound))\n+      && tree_int_cst_lt (idx, bound))\n     return NULL_TREE;\n \n   *index = save_expr (*index);"}, {"sha": "91599658be9650a887e88774a5dc0c5502bb2301", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -9050,35 +9050,6 @@ finish_incomplete_vars (tree incomplete_vars, bool toplevel)\n     }\n }\n \n-/* Get the LEVEL of the strict_flex_array for the ARRAY_FIELD based on the\n-   values of attribute strict_flex_array and the flag_strict_flex_arrays.  */\n-static unsigned int\n-strict_flex_array_level_of (tree array_field)\n-{\n-  gcc_assert (TREE_CODE (array_field) == FIELD_DECL);\n-  unsigned int strict_flex_array_level = flag_strict_flex_arrays;\n-\n-  tree attr_strict_flex_array\n-    = lookup_attribute (\"strict_flex_array\", DECL_ATTRIBUTES (array_field));\n-  /* If there is a strict_flex_array attribute attached to the field,\n-     override the flag_strict_flex_arrays.  */\n-  if (attr_strict_flex_array)\n-    {\n-      /* Get the value of the level first from the attribute.  */\n-      unsigned HOST_WIDE_INT attr_strict_flex_array_level = 0;\n-      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n-      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n-      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n-      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n-      gcc_assert (tree_fits_uhwi_p (attr_strict_flex_array));\n-      attr_strict_flex_array_level = tree_to_uhwi (attr_strict_flex_array);\n-\n-      /* The attribute has higher priority than flag_struct_flex_array.  */\n-      strict_flex_array_level = attr_strict_flex_array_level;\n-    }\n-  return strict_flex_array_level;\n-}\n-\n /* Determine whether the FIELD_DECL X is a flexible array member according to\n    the following info:\n   A. whether the FIELD_DECL X is the last field of the DECL_CONTEXT;\n@@ -9105,7 +9076,7 @@ is_flexible_array_member_p (bool is_last_field,\n   bool is_one_element_array = one_element_array_type_p (TREE_TYPE (x));\n   bool is_flexible_array = flexible_array_member_type_p (TREE_TYPE (x));\n \n-  unsigned int strict_flex_array_level = strict_flex_array_level_of (x);\n+  unsigned int strict_flex_array_level = c_strict_flex_array_level_of (x);\n \n   switch (strict_flex_array_level)\n     {"}, {"sha": "0045661cc5df99177e7502fdc5948cdc77a4fd73", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -16831,14 +16831,17 @@ a++;\n @item -fsanitize=bounds\n This option enables instrumentation of array bounds.  Various out of bounds\n accesses are detected.  Flexible array members, flexible array member-like\n-arrays, and initializers of variables with static storage are not instrumented.\n+arrays, and initializers of variables with static storage are not\n+instrumented, with the exception of flexible array member-like arrays\n+for which @code{-fstrict-flex-arrays} or @code{-fstrict-flex-arrays=}\n+options or @code{strict_flex_array} attributes say they shouldn't be treated\n+like flexible array member-like arrays.\n \n @opindex fsanitize=bounds-strict\n @item -fsanitize=bounds-strict\n This option enables strict instrumentation of array bounds.  Most out of bounds\n-accesses are detected, including flexible array members and flexible array\n-member-like arrays.  Initializers of variables with static storage are not\n-instrumented.\n+accesses are detected, including flexible array member-like arrays.\n+Initializers of variables with static storage are not instrumented.\n \n @opindex fsanitize=alignment\n @item -fsanitize=alignment"}, {"sha": "f2b3e4bebc3a567730003087369c0b80826afcb7", "filename": "gcc/gimple-fold.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fgimple-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fgimple-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.cc?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -5624,7 +5624,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t      {\n \t\tindex = fold_convert (TREE_TYPE (bound), index);\n \t\tif (TREE_CODE (index) == INTEGER_CST\n-\t\t    && tree_int_cst_le (index, bound))\n+\t\t    && tree_int_cst_lt (index, bound))\n \t\t  {\n \t\t    replace_call_with_value (gsi, NULL_TREE);\n \t\t    return true;"}, {"sha": "e0bfe9e4f0f7c1014e2bd54050c774ff54b0a737", "filename": "gcc/testsuite/g++.dg/ubsan/bounds-1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fbounds-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fbounds-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fbounds-1.C?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -0,0 +1,8 @@\n+// PR sanitizer/108894\n+// { dg-do run }\n+// { dg-options \"-fsanitize=bounds -fsanitize-recover=bounds\" }\n+// { dg-output \"index 15 out of bounds for type 'int \\\\\\[15\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"\\[^\\n\\r]*index 0 out of bounds for type 'int \\\\\\[\\[0-9x]*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"\\[^\\n\\r]*index 16 out of bounds for type 'int \\\\\\[15\\\\\\]'\" }\n+\n+#include \"../../gcc.dg/ubsan/bounds-4.c\""}, {"sha": "d1580d36d13b3b04c3c6928d506d2e654cb1a68f", "filename": "gcc/testsuite/gcc.dg/ubsan/bounds-4.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4.c?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -0,0 +1,79 @@\n+/* PR sanitizer/108894 */\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -fsanitize-recover=bounds\" } */\n+/* { dg-output \"index 15 out of bounds for type 'int \\\\\\[15\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 0 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 16 out of bounds for type 'int \\\\\\[15\\\\\\]'\" } */\n+\n+struct A { int a; int b[]; };\n+struct B { int a; int b[0]; };\n+struct C { int a; int b[1]; };\n+struct D { int a; int b[2]; };\n+struct E { int a; int b[42]; };\n+struct F { int a; int b[0]; int c[2]; };\n+struct G { int a; int b[15]; int c[2]; };\n+\n+__attribute__((noipa)) int\n+foo (struct A *a)\n+{\n+  return a->b[14];\n+}\n+\n+__attribute__((noipa)) int\n+bar (struct B *a)\n+{\n+  return a->b[0];\n+}\n+\n+__attribute__((noipa)) int\n+baz (struct C *a)\n+{\n+  return a->b[1];\n+}\n+\n+__attribute__((noipa)) int\n+qux (struct D *a)\n+{\n+  return a->b[2];\n+}\n+\n+__attribute__((noipa)) int\n+corge (struct E *a)\n+{\n+  return a->b[14];\n+}\n+\n+__attribute__((noipa)) int\n+freddy (struct F *a)\n+{\n+  return a->b[0];\n+}\n+\n+__attribute__((noipa)) int\n+garply (struct G *a)\n+{\n+  return a->b[15];\n+}\n+\n+__attribute__((noipa)) int\n+waldo (struct G *a)\n+{\n+  return a->b[16];\n+}\n+\n+int\n+main ()\n+{\n+  union { struct A a; struct B b; struct C c;\n+\t  struct D d; struct E e; struct F f; } u;\n+  struct G g;\n+  u.e.a = 42;\n+  __builtin_memset (u.e.b, 0, sizeof (u.e.b));\n+  __builtin_memset (&g, 0, sizeof (g));\n+  int r = garply (&g);\n+  r += foo (&u.a) + bar (&u.b) + baz (&u.c);\n+  r += qux (&u.d) + corge (&u.e) + freddy (&u.f);\n+  r += waldo (&g);\n+  if (r != 0)\n+    __builtin_abort ();\n+}"}, {"sha": "412e5fd0445620abac345cd33e4c7cf9b5d30ddc", "filename": "gcc/testsuite/gcc.dg/ubsan/bounds-4a.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4a.c?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -0,0 +1,8 @@\n+/* PR sanitizer/108894 */\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -fsanitize-recover=bounds -fstrict-flex-arrays=0\" } */\n+/* { dg-output \"index 15 out of bounds for type 'int \\\\\\[15\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 0 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 16 out of bounds for type 'int \\\\\\[15\\\\\\]'\" } */\n+\n+#include \"bounds-4.c\""}, {"sha": "3ca4106c10bd4ece53bdf4ce60030807672b7df5", "filename": "gcc/testsuite/gcc.dg/ubsan/bounds-4b.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4b.c?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -0,0 +1,9 @@\n+/* PR sanitizer/108894 */\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -fsanitize-recover=bounds -fstrict-flex-arrays=1\" } */\n+/* { dg-output \"index 15 out of bounds for type 'int \\\\\\[15\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 2 out of bounds for type 'int \\\\\\[2\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 0 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 16 out of bounds for type 'int \\\\\\[15\\\\\\]'\" } */\n+\n+#include \"bounds-4.c\""}, {"sha": "8f846d60011e08d0bce1b8eeb2b41305fba88d83", "filename": "gcc/testsuite/gcc.dg/ubsan/bounds-4c.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4c.c?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -0,0 +1,10 @@\n+/* PR sanitizer/108894 */\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -fsanitize-recover=bounds -fstrict-flex-arrays=2\" } */\n+/* { dg-output \"index 15 out of bounds for type 'int \\\\\\[15\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 1 out of bounds for type 'int \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 2 out of bounds for type 'int \\\\\\[2\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 0 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 16 out of bounds for type 'int \\\\\\[15\\\\\\]'\" } */\n+\n+#include \"bounds-4.c\""}, {"sha": "b2d979fe8c1bb2703fcbfd12b4bb605ca5432a6e", "filename": "gcc/testsuite/gcc.dg/ubsan/bounds-4d.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fbounds-4d.c?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -0,0 +1,11 @@\n+/* PR sanitizer/108894 */\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -fsanitize-recover=bounds -fstrict-flex-arrays=3\" } */\n+/* { dg-output \"index 15 out of bounds for type 'int \\\\\\[15\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 0 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 1 out of bounds for type 'int \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 2 out of bounds for type 'int \\\\\\[2\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 0 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 16 out of bounds for type 'int \\\\\\[15\\\\\\]'\" } */\n+\n+#include \"bounds-4.c\""}, {"sha": "08c1127c8bdbce5ea224cc4f366a14aa135d5212", "filename": "gcc/ubsan.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fubsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7728805a7107444683290cd629d13f089130a0d/gcc%2Fubsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.cc?ref=c7728805a7107444683290cd629d13f089130a0d", "patch": "@@ -721,7 +721,7 @@ ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n \n   gimple_stmt_iterator gsi_orig = *gsi;\n \n-  /* Create condition \"if (index > bound)\".  */\n+  /* Create condition \"if (index >= bound)\".  */\n   basic_block then_bb, fallthru_bb;\n   gimple_stmt_iterator cond_insert_point\n     = create_cond_insert_point (gsi, false, false, true,\n@@ -730,7 +730,7 @@ ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n   index = force_gimple_operand_gsi (&cond_insert_point, index,\n \t\t\t\t    true, NULL_TREE,\n \t\t\t\t    false, GSI_NEW_STMT);\n-  gimple *g = gimple_build_cond (GT_EXPR, index, bound, NULL_TREE, NULL_TREE);\n+  gimple *g = gimple_build_cond (GE_EXPR, index, bound, NULL_TREE, NULL_TREE);\n   gimple_set_location (g, loc);\n   gsi_insert_after (&cond_insert_point, g, GSI_NEW_STMT);\n "}]}