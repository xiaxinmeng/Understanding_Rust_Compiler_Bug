{"sha": "a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlOWIxMjQ4Y2Q3ZjY2NmJmODE0MWM2Y2U3NWY2Y2IzZTdhYTU3OA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-06T21:01:14Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-07-06T21:01:14Z"}, "message": "(fold, COND_EXPR case): All simplified results must go through pedantic_non_lvalue.\n\n(fold, COND_EXPR case):  All simplified results\nmust go through pedantic_non_lvalue.\n(pedantic_non_lvalue): New function.\n\nFrom-SVN: r4867", "tree": {"sha": "6c3441a5bcc2532b83538ce9546c4abe750bd082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c3441a5bcc2532b83538ce9546c4abe750bd082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578/comments", "author": null, "committer": null, "parents": [{"sha": "f0d568b76d5b247b44d359de70215929899db5a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d568b76d5b247b44d359de70215929899db5a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d568b76d5b247b44d359de70215929899db5a5"}], "stats": {"total": 63, "additions": 44, "deletions": 19}, "files": [{"sha": "de5630bf0f30d1e0e77b287e358056bca99e0a77", "filename": "gcc/fold-const.c", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a5e9b1248cd7f666bf8141c6ce75f6cb3e7aa578", "patch": "@@ -1672,6 +1672,19 @@ non_lvalue (x)\n   TREE_CONSTANT (result) = TREE_CONSTANT (x);\n   return result;\n }\n+\n+/* When pedantic, return an expr equal to X but certainly not valid as a\n+   pedantic lvalue.  Otherwise, return X.  */\n+\n+tree\n+pedantic_non_lvalue (x)\n+     tree x;\n+{\n+  if (pedantic)\n+    return non_lvalue (x);\n+  else\n+    return x;\n+}\n \f\n /* Given a tree comparison code, return the code that is the logical inverse\n    of the given code.  It is not safe to do this for floating-point\n@@ -4454,10 +4467,13 @@ fold (expr)\n       return t1;\n \n     case COND_EXPR:\n+      /* Pedantic ANSI C says that a conditional expression is never an lvalue,\n+\t so all simple results must be passed through pedantic_non_lvalue.  */\n       if (TREE_CODE (arg0) == INTEGER_CST)\n-\treturn TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1));\n+\treturn pedantic_non_lvalue\n+\t  (TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1)));\n       else if (operand_equal_p (arg1, TREE_OPERAND (expr, 2), 0))\n-\treturn omit_one_operand (type, arg1, arg0);\n+\treturn pedantic_non_lvalue (omit_one_operand (type, arg1, arg0));\n \n       /* If the second operand is zero, invert the comparison and swap\n \t the second and third operands.  Likewise if the second operand\n@@ -4507,16 +4523,19 @@ fold (expr)\n \t    switch (comp_code)\n \t      {\n \t      case EQ_EXPR:\n-\t\treturn fold (build1 (NEGATE_EXPR, type, arg1));\n+\t\treturn pedantic_non_lvalue\n+\t\t  (fold (build1 (NEGATE_EXPR, type, arg1)));\n \t      case NE_EXPR:\n-\t\treturn convert (type, arg1);\n+\t\treturn pedantic_non_lvalue (convert (type, arg1));\n \t      case GE_EXPR:\n \t      case GT_EXPR:\n-\t\treturn fold (build1 (ABS_EXPR, type, arg1));\n+\t\treturn pedantic_non_lvalue\n+\t\t  (fold (build1 (ABS_EXPR, type, arg1)));\n \t      case LE_EXPR:\n \t      case LT_EXPR:\n-\t\treturn fold (build1 (NEGATE_EXPR, type,\n-\t\t\t\t     fold (build1 (ABS_EXPR, type, arg1))));\n+\t\treturn pedantic_non_lvalue\n+\t\t  (fold (build1 (NEGATE_EXPR, type,\n+\t\t\t\t fold (build1 (ABS_EXPR, type, arg1)))));\n \t      }\n \n \t  /* If this is A != 0 ? A : 0, this is simply A.  For ==, it is\n@@ -4525,9 +4544,9 @@ fold (expr)\n \t  if (integer_zerop (TREE_OPERAND (arg0, 1)) && integer_zerop (arg2))\n \t    {\n \t      if (comp_code == NE_EXPR)\n-\t\treturn convert (type, arg1);\n+\t\treturn pedantic_non_lvalue (convert (type, arg1));\n \t      else if (comp_code == EQ_EXPR)\n-\t\treturn convert (type, integer_zero_node);\n+\t\treturn pedantic_non_lvalue (convert (type, integer_zero_node));\n \t    }\n \n \t  /* If this is A op B ? A : B, this is either A, B, min (A, B),\n@@ -4538,15 +4557,17 @@ fold (expr)\n \t    switch (comp_code)\n \t      {\n \t      case EQ_EXPR:\n-\t\treturn convert (type, arg2);\n+\t\treturn pedantic_non_lvalue (convert (type, arg2));\n \t      case NE_EXPR:\n-\t\treturn convert (type, arg1);\n+\t\treturn pedantic_non_lvalue (convert (type, arg1));\n \t      case LE_EXPR:\n \t      case LT_EXPR:\n-\t\treturn fold (build (MIN_EXPR, type, arg1, arg2));\n+\t\treturn pedantic_non_lvalue\n+\t\t  (fold (build (MIN_EXPR, type, arg1, arg2)));\n \t      case GE_EXPR:\n \t      case GT_EXPR:\n-\t\treturn fold (build (MAX_EXPR, type, arg1, arg2));\n+\t\treturn pedantic_non_lvalue\n+\t\t  (fold (build (MAX_EXPR, type, arg1, arg2)));\n \t      }\n \n \t  /* If this is A op C1 ? A : C2 with C1 and C2 constant integers,\n@@ -4572,7 +4593,8 @@ fold (expr)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n \t\t\t\t\t\t     integer_one_node, 0), 1))\n-\t\t  return fold (build (MIN_EXPR, type, arg1, arg2));\n+\t\t  return pedantic_non_lvalue\n+\t\t    (fold (build (MIN_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \n \t      case LE_EXPR:\n@@ -4581,7 +4603,8 @@ fold (expr)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n \t\t\t\t\t\t     integer_one_node, 0), 1))\n-\t\t  return fold (build (MIN_EXPR, type, arg1, arg2));\n+\t\t  return pedantic_non_lvalue\n+\t\t    (fold (build (MIN_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \n \t      case GT_EXPR:\n@@ -4590,7 +4613,8 @@ fold (expr)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n \t\t\t\t\t\t     integer_one_node, 0), 1))\n-\t\t  return fold (build (MAX_EXPR, type, arg1, arg2));\n+\t\t  return pedantic_non_lvalue\n+\t\t    (fold (build (MAX_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \n \t      case GE_EXPR:\n@@ -4599,7 +4623,8 @@ fold (expr)\n \t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n \t\t\t\t\t\t     integer_one_node, 0), 1))\n-\t\t  return fold (build (MAX_EXPR, type, arg1, arg2));\n+\t\t  return pedantic_non_lvalue\n+\t\t    (fold (build (MAX_EXPR, type, arg1, arg2)));\n \t\tbreak;\n \t      }\n \t}\n@@ -4612,7 +4637,7 @@ fold (expr)\n \t     a COND, which will recurse.  In that case, the COND_EXPR\n \t     is probably the best choice, so leave it alone.  */\n \t  && type == TREE_TYPE (arg0))\n-\treturn arg0;\n+\treturn pedantic_non_lvalue (arg0);\n \n \n       /* Look for expressions of the form A & 2 ? 2 : 0.  The result of this\n@@ -4625,7 +4650,7 @@ fold (expr)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == BIT_AND_EXPR\n \t  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1),\n \t\t\t      arg1, 1))\n-\treturn convert (type, TREE_OPERAND (arg0, 0));\n+\treturn pedantic_non_lvalue (convert (type, TREE_OPERAND (arg0, 0)));\n \n       return t;\n "}]}