{"sha": "515456820e0468b848ff5905d6d8439a47036fdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1NDU2ODIwZTA0NjhiODQ4ZmY1OTA1ZDZkODQzOWE0NzAzNmZkYw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-05-11T13:48:55Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-05-11T13:48:55Z"}, "message": "split tree_type\n\nsplit tree_type\ngcc/ada/\n\t* gcc-interface/ada-tree.h (TYPE_OBJECT_RECORD_TYPE): Use TYPE_MINVAL.\n\t(TYPE_GCC_MIN_VALUE): Use TYPE_MINVAL.\n\t(TYPE_GCC_MAX_VALUE): Use TYPE_MAXVAL.\n\ngcc/cp/\n\t* cp-tree.h (TYPENAME_TYPE_FULLNAME, TYPEOF_TYPE_EXPR): Use\n\tTYPE_VALUES_RAW.\n\t(UNDERLYING_TYPE_TYPE, DECLTYPE_TYPE_EXPR): Likewise.\n\t(DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P): Likewise.\n\t(TEMPLATE_TYPE_PARM_INDEX): Likewise.\n\ngcc/\n\t* ggc-page.c (extra_order_size_table): Use struct\n\ttree_type_non_common.\n\t* lto-streamer-in.c (unpack_ts_type_value_fields): Rename to...\n\t(unpack_ts_type_common_value_fields): ...this.  Update comment.\n\t(unpack_value_fields): Adjust for renaming.\n\t(lto_input_ts_type_tree_pointers): Split into...\n\t(lto_input_ts_type_common_tree_pointer): ...this and...\n\t(lto_input_ts_type_non_common_tree_pointers): ...this.\n\t(lto_input_tree_pointers): Adjust for above split.\n\t* lto-streamer-out.c (pack_ts_type_value_fields): Rename to...\n\t(pack_ts_type_common_value_fields): ...this.  Update comment.\n\t(lto_output_ts_type_tree_pointers): Split into...\n\t(lto_output_ts_type_common_tree_pointers): ...this and...\n\t(lto_output_ts_type_non_common_tree_pointers): ...this.\n\t(lto_output_tree_pointers): Adjust for above split.\n\t* lto-streamer.c (check_handled_ts_structures): Mark TS_TYPE_COMMON,\n\tTS_TYPE_WITH_LANG_SPECIFIC, and TS_TYPE_NON_COMMON as handled.\n\t* stor-layout.c (vector_type_mode): Adjust location of mode field.\n\t* tree.h (MARK_TS_TYPE_COMMON, MARK_TS_TYPE_WITH_LANG_SPECIFIC):\n\tDefine.\n\t(struct tree_type): Split into...\n\t(struct tree_type_common: ...this and...\n\t(struct tree_type_with_lang_specific): ...this and...\n\t(struct tree_type_non_common): ...this.  Adjust accessor macros\n\taccordingly.\n\t(TYPE_VALUES_RAW): Define.\n\t(union tree_node): Update for above changes.\n\t* tree.c (tree_node_structure_for_code) [tcc_type]: Return\n\tTS_TYPE_NON_COMMON.\n\t(initialize_tree_contains_struct) [TS_TYPE]: Use TS_TYPE_COMMON.\n\tAdd TS_TYPE_WITH_LANG_SPECIFIC and TS_TYPE_NON_COMMON.\n\t(tree_code_size) [tcc_type]: Use struct tree_type_non_common.\n\t* treestructu.def (TS_TYPE): Remove.\n\t(TS_TYPE_COMMON, TS_TYPE_WITH_LANG_SPECIFIC, TS_TYPE_NON_COMMON):\n\tDefine.\n\ngcc/java/\n\t* java-tree.h (TYPE_ARGUMENT_SIGNATURE): Use TYPE_MINVAL.\n\ngcc/lto/\n\t* lto.c (lto_ft_type): Use TYPE_MINVAL and TYPE_MAXVAL.  Adjust\n\tlocation of binfo field.\n\t(lto_fixup_prevailing_decls): Likewise.\n\ngcc/objc/\n\t* objc-act.h (CLASS_NAME, CLASS_SUPER_NAME): Use proper accessors.\n\t(CLASS_NST_METHODS, CLASS_CLS_METHODS): Likewise.\n\t(PROTOCOL_NAME, PROTOCOL_NST_METHODS, PROTOCOL_CLS_METHODS): Likewise.\n\nFrom-SVN: r173658", "tree": {"sha": "9e6dc2ef0a353ee5307b5cc9dd22f5a40e3da76e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e6dc2ef0a353ee5307b5cc9dd22f5a40e3da76e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/515456820e0468b848ff5905d6d8439a47036fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515456820e0468b848ff5905d6d8439a47036fdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/515456820e0468b848ff5905d6d8439a47036fdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515456820e0468b848ff5905d6d8439a47036fdc/comments", "author": null, "committer": null, "parents": [{"sha": "b03c30822bba445ae68699bd7e9efa8f8e07070a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03c30822bba445ae68699bd7e9efa8f8e07070a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b03c30822bba445ae68699bd7e9efa8f8e07070a"}], "stats": {"total": 458, "additions": 306, "deletions": 152}, "files": [{"sha": "d4db4ef00a83143a912b5059fee5060d3c71b5d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1,3 +1,41 @@\n+2011-05-11  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* ggc-page.c (extra_order_size_table): Use struct\n+\ttree_type_non_common.\n+\t* lto-streamer-in.c (unpack_ts_type_value_fields): Rename to...\n+\t(unpack_ts_type_common_value_fields): ...this.  Update comment.\n+\t(unpack_value_fields): Adjust for renaming.\n+\t(lto_input_ts_type_tree_pointers): Split into...\n+\t(lto_input_ts_type_common_tree_pointer): ...this and...\n+\t(lto_input_ts_type_non_common_tree_pointers): ...this.\n+\t(lto_input_tree_pointers): Adjust for above split.\n+\t* lto-streamer-out.c (pack_ts_type_value_fields): Rename to...\n+\t(pack_ts_type_common_value_fields): ...this.  Update comment.\n+\t(lto_output_ts_type_tree_pointers): Split into...\n+\t(lto_output_ts_type_common_tree_pointers): ...this and...\n+\t(lto_output_ts_type_non_common_tree_pointers): ...this.\n+\t(lto_output_tree_pointers): Adjust for above split.\n+\t* lto-streamer.c (check_handled_ts_structures): Mark TS_TYPE_COMMON,\n+\tTS_TYPE_WITH_LANG_SPECIFIC, and TS_TYPE_NON_COMMON as handled.\n+\t* stor-layout.c (vector_type_mode): Adjust location of mode field.\n+\t* tree.h (MARK_TS_TYPE_COMMON, MARK_TS_TYPE_WITH_LANG_SPECIFIC):\n+\tDefine.\n+\t(struct tree_type): Split into...\n+\t(struct tree_type_common: ...this and...\n+\t(struct tree_type_with_lang_specific): ...this and...\n+\t(struct tree_type_non_common): ...this.  Adjust accessor macros\n+\taccordingly.\n+\t(TYPE_VALUES_RAW): Define.\n+\t(union tree_node): Update for above changes.\n+\t* tree.c (tree_node_structure_for_code) [tcc_type]: Return\n+\tTS_TYPE_NON_COMMON.\n+\t(initialize_tree_contains_struct) [TS_TYPE]: Use TS_TYPE_COMMON.\n+\tAdd TS_TYPE_WITH_LANG_SPECIFIC and TS_TYPE_NON_COMMON.\n+\t(tree_code_size) [tcc_type]: Use struct tree_type_non_common.\n+\t* treestructu.def (TS_TYPE): Remove.\n+\t(TS_TYPE_COMMON, TS_TYPE_WITH_LANG_SPECIFIC, TS_TYPE_NON_COMMON):\n+\tDefine.\n+\n 2011-05-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/48159"}, {"sha": "ad727685c13641657acd590ff4ca06885342c058", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1,3 +1,9 @@\n+2011-05-11  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_OBJECT_RECORD_TYPE): Use TYPE_MINVAL.\n+\t(TYPE_GCC_MIN_VALUE): Use TYPE_MINVAL.\n+\t(TYPE_GCC_MAX_VALUE): Use TYPE_MAXVAL.\n+\n 2011-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (intrin_arglists_compatible_p): Remove spaces."}, {"sha": "588c852cd95bb3ede3051da82760ac53e4b05e7a", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -174,21 +174,21 @@ do {\t\t\t\t\t\t\t \\\n    this is a conflict on the minval field, but there doesn't seem to be\n    simple fix, so we'll live with this kludge for now.  */\n #define TYPE_OBJECT_RECORD_TYPE(NODE) \\\n-  (TREE_CHECK2 ((NODE), UNCONSTRAINED_ARRAY_TYPE, ENUMERAL_TYPE)->type.minval)\n+  (TYPE_MINVAL (TREE_CHECK2 ((NODE), UNCONSTRAINED_ARRAY_TYPE, ENUMERAL_TYPE)))\n \n /* For numerical types, this is the GCC lower bound of the type.  The GCC\n    type system is based on the invariant that an object X of a given type\n    cannot hold at run time a value smaller than its lower bound; otherwise\n    the behavior is undefined.  The optimizer takes advantage of this and\n    considers that the assertion X >= LB is always true.  */\n-#define TYPE_GCC_MIN_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.minval)\n+#define TYPE_GCC_MIN_VALUE(NODE) (TYPE_MINVAL (NUMERICAL_TYPE_CHECK (NODE)))\n \n /* For numerical types, this is the GCC upper bound of the type.  The GCC\n    type system is based on the invariant that an object X of a given type\n    cannot hold at run time a value larger than its upper bound; otherwise\n    the behavior is undefined.  The optimizer takes advantage of this and\n    considers that the assertion X <= UB is always true.  */\n-#define TYPE_GCC_MAX_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.maxval)\n+#define TYPE_GCC_MAX_VALUE(NODE) (TYPE_MAXVAL (NUMERICAL_TYPE_CHECK (NODE)))\n \n /* For a FUNCTION_TYPE, if the subprogram has parameters passed by copy in/\n    copy out, this is the list of nodes used to specify the return values of"}, {"sha": "6a27cbb36b8fbe310ea2bba0ab2977cb6781dfbc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1,3 +1,11 @@\n+2011-05-11  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* cp-tree.h (TYPENAME_TYPE_FULLNAME, TYPEOF_TYPE_EXPR): Use\n+\tTYPE_VALUES_RAW.\n+\t(UNDERLYING_TYPE_TYPE, DECLTYPE_TYPE_EXPR): Likewise.\n+\t(DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P): Likewise.\n+\t(TEMPLATE_TYPE_PARM_INDEX): Likewise.\n+\n 2011-05-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/48930"}, {"sha": "220273650aa3964a5be093e733d64f9d22d42270", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -2936,7 +2936,8 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    this is an IDENTIFIER_NODE, and the same as the DECL_NAME on the\n    corresponding TYPE_DECL.  However, this may also be a\n    TEMPLATE_ID_EXPR if we had something like `typename X::Y<T>'.  */\n-#define TYPENAME_TYPE_FULLNAME(NODE) (TYPENAME_TYPE_CHECK (NODE))->type.values\n+#define TYPENAME_TYPE_FULLNAME(NODE) \\\n+  (TYPE_VALUES_RAW (TYPENAME_TYPE_CHECK (NODE)))\n \n /* True if a TYPENAME_TYPE was declared as an \"enum\".  */\n #define TYPENAME_IS_ENUM_P(NODE) \\\n@@ -3374,20 +3375,20 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define PTRMEM_CST_MEMBER(NODE) (((ptrmem_cst_t)PTRMEM_CST_CHECK (NODE))->member)\n \n /* The expression in question for a TYPEOF_TYPE.  */\n-#define TYPEOF_TYPE_EXPR(NODE) (TYPEOF_TYPE_CHECK (NODE))->type.values\n+#define TYPEOF_TYPE_EXPR(NODE) (TYPE_VALUES_RAW (TYPEOF_TYPE_CHECK (NODE)))\n \n /* The type in question for an UNDERLYING_TYPE.  */\n #define UNDERLYING_TYPE_TYPE(NODE) \\\n-  (UNDERLYING_TYPE_CHECK (NODE))->type.values\n+  (TYPE_VALUES_RAW (UNDERLYING_TYPE_CHECK (NODE)))\n \n /* The expression in question for a DECLTYPE_TYPE.  */\n-#define DECLTYPE_TYPE_EXPR(NODE) (DECLTYPE_TYPE_CHECK (NODE))->type.values\n+#define DECLTYPE_TYPE_EXPR(NODE) (TYPE_VALUES_RAW (DECLTYPE_TYPE_CHECK (NODE)))\n \n /* Whether the DECLTYPE_TYPE_EXPR of NODE was originally parsed as an\n    id-expression or a member-access expression. When false, it was\n    parsed as a full expression.  */\n #define DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P(NODE) \\\n-  (DECLTYPE_TYPE_CHECK (NODE))->type.string_flag\n+  (DECLTYPE_TYPE_CHECK (NODE))->type_common.string_flag\n \n /* These flags indicate that we want different semantics from normal\n    decltype: lambda capture just drops references, lambda return also does\n@@ -4358,9 +4359,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n \n /* These macros are for accessing the fields of TEMPLATE_TYPE_PARM,\n    TEMPLATE_TEMPLATE_PARM and BOUND_TEMPLATE_TEMPLATE_PARM nodes.  */\n-#define TEMPLATE_TYPE_PARM_INDEX(NODE)\t\t\t\t\t \\\n-  (TREE_CHECK3 ((NODE), TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM,\t\\\n-\t\tBOUND_TEMPLATE_TEMPLATE_PARM))->type.values\n+#define TEMPLATE_TYPE_PARM_INDEX(NODE)\t\t\t\t\t\\\n+  (TYPE_VALUES_RAW (TREE_CHECK3 ((NODE), TEMPLATE_TYPE_PARM,\t\t\\\n+\t\t\t\t TEMPLATE_TEMPLATE_PARM,\t\t\\\n+\t\t\t\t BOUND_TEMPLATE_TEMPLATE_PARM)))\n #define TEMPLATE_TYPE_IDX(NODE) \\\n   (TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n #define TEMPLATE_TYPE_LEVEL(NODE) \\"}, {"sha": "624f02971e559aedcd688dd7f5c6eba7e562733c", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -196,7 +196,7 @@ static const size_t extra_order_size_table[] = {\n   sizeof (struct tree_field_decl),\n   sizeof (struct tree_parm_decl),\n   sizeof (struct tree_var_decl),\n-  sizeof (struct tree_type),\n+  sizeof (struct tree_type_non_common),\n   sizeof (struct function),\n   sizeof (struct basic_block_def),\n   sizeof (struct cgraph_node),"}, {"sha": "b96bf14cad765ae6e15085e4105d50ec4dd9a2d6", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1,3 +1,7 @@\n+2011-05-11  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* java-tree.h (TYPE_ARGUMENT_SIGNATURE): Use TYPE_MINVAL.\n+\n 2011-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* java-tree.h (global_bindings_p): Adjust prototype."}, {"sha": "700132164ea66a1b3d88764cef4dea79c80f6c56", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1331,7 +1331,7 @@ extern tree *type_map;\n \n /* If FUNCTION_TYPE or METHOD_TYPE: cache for build_java_argument_signature. */\n #define TYPE_ARGUMENT_SIGNATURE(TYPE) \\\n-  (TREE_CHECK2 (TYPE, FUNCTION_TYPE, METHOD_TYPE)->type.minval)\n+  (TYPE_MINVAL (TREE_CHECK2 (TYPE, FUNCTION_TYPE, METHOD_TYPE)))\n \n /* Given an array type, give the type of the elements. */\n /* FIXME this use of TREE_TYPE conflicts with something or other. */"}, {"sha": "d3a9dd2235b915caf5d8b690d51c8066c4cc4f9b", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1745,11 +1745,11 @@ unpack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n }\n \n \n-/* Unpack all the non-pointer fields of the TS_TYPE structure\n+/* Unpack all the non-pointer fields of the TS_TYPE_COMMON structure\n    of expression EXPR from bitpack BP.  */\n \n static void\n-unpack_ts_type_value_fields (struct bitpack_d *bp, tree expr)\n+unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n {\n   enum machine_mode mode;\n \n@@ -1821,8 +1821,8 @@ unpack_value_fields (struct bitpack_d *bp, tree expr)\n   if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n     unpack_ts_function_decl_value_fields (bp, expr);\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n-    unpack_ts_type_value_fields (bp, expr);\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    unpack_ts_type_common_value_fields (bp, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n     unpack_ts_block_value_fields (bp, expr);\n@@ -2099,13 +2099,37 @@ lto_input_ts_function_decl_tree_pointers (struct lto_input_block *ib,\n }\n \n \n-/* Read all pointer fields in the TS_TYPE structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n+/* Read all pointer fields in the TS_TYPE_COMMON structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the file\n+   being read.  */\n+\n+static void\n+lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\tstruct data_in *data_in, tree expr)\n+{\n+  TYPE_SIZE (expr) = lto_input_tree (ib, data_in);\n+  TYPE_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n+  TYPE_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n+  TYPE_NAME (expr) = lto_input_tree (ib, data_in);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+     reconstructed during fixup.  */\n+  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+     during fixup.  */\n+  TYPE_MAIN_VARIANT (expr) = lto_input_tree (ib, data_in);\n+  TYPE_CONTEXT (expr) = lto_input_tree (ib, data_in);\n+  /* TYPE_CANONICAL gets re-computed during type merging.  */\n+  TYPE_CANONICAL (expr) = NULL_TREE;\n+  TYPE_STUB_DECL (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+/* Read all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n    file being read.  */\n \n static void\n-lto_input_ts_type_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t struct data_in *data_in, tree expr)\n+lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t    struct data_in *data_in,\n+\t\t\t\t\t    tree expr)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n     TYPE_VALUES (expr) = lto_input_tree (ib, data_in);\n@@ -2117,24 +2141,11 @@ lto_input_ts_type_tree_pointers (struct lto_input_block *ib,\n \t   || TREE_CODE (expr) == METHOD_TYPE)\n     TYPE_ARG_TYPES (expr) = lto_input_tree (ib, data_in);\n \n-  TYPE_SIZE (expr) = lto_input_tree (ib, data_in);\n-  TYPE_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n-  TYPE_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n-  TYPE_NAME (expr) = lto_input_tree (ib, data_in);\n-  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO nor\n-     TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO.  */\n   if (!POINTER_TYPE_P (expr))\n     TYPE_MINVAL (expr) = lto_input_tree (ib, data_in);\n   TYPE_MAXVAL (expr) = lto_input_tree (ib, data_in);\n-  TYPE_MAIN_VARIANT (expr) = lto_input_tree (ib, data_in);\n-  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n-     during fixup.  */\n   if (RECORD_OR_UNION_TYPE_P (expr))\n     TYPE_BINFO (expr) = lto_input_tree (ib, data_in);\n-  TYPE_CONTEXT (expr) = lto_input_tree (ib, data_in);\n-  /* TYPE_CANONICAL gets re-computed during type merging.  */\n-  TYPE_CANONICAL (expr) = NULL_TREE;\n-  TYPE_STUB_DECL (expr) = lto_input_tree (ib, data_in);\n }\n \n \n@@ -2370,8 +2381,11 @@ lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n   if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n     lto_input_ts_function_decl_tree_pointers (ib, data_in, expr);\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n-    lto_input_ts_type_tree_pointers (ib, data_in, expr);\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    lto_input_ts_type_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    lto_input_ts_type_non_common_tree_pointers (ib, data_in, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n     lto_input_ts_list_tree_pointers (ib, data_in, expr);"}, {"sha": "da1983c8ca7535f9015ae6faf2c8545bd032976c", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -488,11 +488,11 @@ pack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n }\n \n \n-/* Pack all the non-pointer fields of the TS_TYPE structure\n+/* Pack all the non-pointer fields of the TS_TYPE_COMMON structure\n    of expression EXPR into bitpack BP.  */\n \n static void\n-pack_ts_type_value_fields (struct bitpack_d *bp, tree expr)\n+pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n {\n   bp_pack_value (bp, TYPE_PRECISION (expr), 10);\n   bp_pack_value (bp, TYPE_MODE (expr), 8);\n@@ -560,8 +560,8 @@ pack_value_fields (struct bitpack_d *bp, tree expr)\n   if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n     pack_ts_function_decl_value_fields (bp, expr);\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n-    pack_ts_type_value_fields (bp, expr);\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    pack_ts_type_common_value_fields (bp, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n     pack_ts_block_value_fields (bp, expr);\n@@ -949,13 +949,36 @@ lto_output_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n }\n \n \n-/* Write all pointer fields in the TS_TYPE structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n+/* Write all pointer fields in the TS_TYPE_COMMON structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n \n static void\n-lto_output_ts_type_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t  bool ref_p)\n+lto_output_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, TYPE_SIZE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_SIZE_UNIT (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_ATTRIBUTES (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_NAME (expr), ref_p);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+     reconstructed during fixup.  */\n+  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+     during fixup.  */\n+  lto_output_tree_or_ref (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_CONTEXT (expr), ref_p);\n+  /* TYPE_CANONICAL is re-computed during type merging, so no need\n+     to stream it here.  */\n+  lto_output_tree_or_ref (ob, TYPE_STUB_DECL (expr), ref_p);\n+}\n+\n+/* Write all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_type_non_common_tree_pointers (struct output_block *ob,\n+\t\t\t\t\t     tree expr, bool ref_p)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n     lto_output_tree_or_ref (ob, TYPE_VALUES (expr), ref_p);\n@@ -967,24 +990,11 @@ lto_output_ts_type_tree_pointers (struct output_block *ob, tree expr,\n \t   || TREE_CODE (expr) == METHOD_TYPE)\n     lto_output_tree_or_ref (ob, TYPE_ARG_TYPES (expr), ref_p);\n \n-  lto_output_tree_or_ref (ob, TYPE_SIZE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_SIZE_UNIT (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_ATTRIBUTES (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_NAME (expr), ref_p);\n-  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO nor\n-     TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO.  */\n   if (!POINTER_TYPE_P (expr))\n     lto_output_tree_or_ref (ob, TYPE_MINVAL (expr), ref_p);\n   lto_output_tree_or_ref (ob, TYPE_MAXVAL (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n-  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n-     during fixup.  */\n   if (RECORD_OR_UNION_TYPE_P (expr))\n     lto_output_tree_or_ref (ob, TYPE_BINFO (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_CONTEXT (expr), ref_p);\n-  /* TYPE_CANONICAL is re-computed during type merging, so no need\n-     to stream it here.  */\n-  lto_output_tree_or_ref (ob, TYPE_STUB_DECL (expr), ref_p);\n }\n \n \n@@ -1183,8 +1193,11 @@ lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n   if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n     lto_output_ts_function_decl_tree_pointers (ob, expr, ref_p);\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n-    lto_output_ts_type_tree_pointers (ob, expr, ref_p);\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    lto_output_ts_type_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    lto_output_ts_type_non_common_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n     lto_output_ts_list_tree_pointers (ob, expr, ref_p);"}, {"sha": "bca654b1739e28562844b2b81e056d55d58a2c5f", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -292,7 +292,9 @@ check_handled_ts_structures (void)\n   handled_p[TS_CONST_DECL] = true;\n   handled_p[TS_TYPE_DECL] = true;\n   handled_p[TS_FUNCTION_DECL] = true;\n-  handled_p[TS_TYPE] = true;\n+  handled_p[TS_TYPE_COMMON] = true;\n+  handled_p[TS_TYPE_WITH_LANG_SPECIFIC] = true;\n+  handled_p[TS_TYPE_NON_COMMON] = true;\n   handled_p[TS_LIST] = true;\n   handled_p[TS_VEC] = true;\n   handled_p[TS_EXP] = true;"}, {"sha": "c1577aab15a3994957cb5347c2565be2d55f5986", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1,3 +1,9 @@\n+2011-05-11  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* lto.c (lto_ft_type): Use TYPE_MINVAL and TYPE_MAXVAL.  Adjust\n+\tlocation of binfo field.\n+\t(lto_fixup_prevailing_decls): Likewise.\n+\n 2011-05-10  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* lto-lang.c (def_fn_type): Don't call build_function_type, call"}, {"sha": "a5c7474851529e45d42a9df3f536e6fe81b8a596", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -385,11 +385,11 @@ lto_ft_type (tree t)\n \n   /* Accessors are for derived node types only. */\n   if (!POINTER_TYPE_P (t))\n-    LTO_FIXUP_TREE (t->type.minval);\n-  LTO_FIXUP_TREE (t->type.maxval);\n+    LTO_FIXUP_TREE (TYPE_MINVAL (t));\n+  LTO_FIXUP_TREE (TYPE_MAXVAL (t));\n \n   /* Accessor is for derived node types only. */\n-  LTO_FIXUP_TREE (t->type.binfo);\n+  LTO_FIXUP_TREE (t->type_non_common.binfo);\n \n   LTO_FIXUP_TREE (TYPE_CONTEXT (t));\n \n@@ -2079,9 +2079,9 @@ lto_fixup_prevailing_decls (tree t)\n       LTO_NO_PREVAIL (TYPE_ATTRIBUTES (t));\n       LTO_NO_PREVAIL (TYPE_NAME (t));\n \n-      LTO_SET_PREVAIL (t->type.minval);\n-      LTO_SET_PREVAIL (t->type.maxval);\n-      LTO_SET_PREVAIL (t->type.binfo);\n+      LTO_SET_PREVAIL (TYPE_MINVAL (t));\n+      LTO_SET_PREVAIL (TYPE_MAXVAL (t));\n+      LTO_SET_PREVAIL (t->type_non_common.binfo);\n \n       LTO_SET_PREVAIL (TYPE_CONTEXT (t));\n "}, {"sha": "363e61166833fa194a629cd34fe8b73778515975", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -1,3 +1,9 @@\n+2011-05-11  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* objc-act.h (CLASS_NAME, CLASS_SUPER_NAME): Use proper accessors.\n+\t(CLASS_NST_METHODS, CLASS_CLS_METHODS): Likewise.\n+\t(PROTOCOL_NAME, PROTOCOL_NST_METHODS, PROTOCOL_CLS_METHODS): Likewise.\n+\n 2011-05-05  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* objc-runtime-shared-support.h (get_arg_type_list): Delete."}, {"sha": "99551a80256311a43484f2d125bbb15d42323fc5", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -152,24 +152,24 @@ typedef enum objc_property_assign_semantics {\n    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,\n    PROTOCOL_INTERFACE_TYPE */\n /* CLASS_NAME is the name of the class.  */\n-#define CLASS_NAME(CLASS) ((CLASS)->type.name)\n+#define CLASS_NAME(CLASS) (TYPE_NAME (CLASS))\n /* CLASS_SUPER_NAME is the name of the superclass, or, in the case of\n    categories, it is the name of the category itself.  */\n-#define CLASS_SUPER_NAME(CLASS) (TYPE_CHECK (CLASS)->type.context)\n+#define CLASS_SUPER_NAME(CLASS) (TYPE_CONTEXT (CLASS))\n #define CLASS_IVARS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 0)\n #define CLASS_RAW_IVARS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 1)\n-#define CLASS_NST_METHODS(CLASS) ((CLASS)->type.minval)\n-#define CLASS_CLS_METHODS(CLASS) ((CLASS)->type.maxval)\n+#define CLASS_NST_METHODS(CLASS) (TYPE_MINVAL (CLASS))\n+#define CLASS_CLS_METHODS(CLASS) (TYPE_MAXVAL (CLASS))\n #define CLASS_STATIC_TEMPLATE(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 2)\n #define CLASS_CATEGORY_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 3)\n #define CLASS_PROTOCOL_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 4)\n #define TOTAL_CLASS_RAW_IVARS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 5)\n #define CLASS_HAS_EXCEPTION_ATTR(CLASS) (TYPE_LANG_FLAG_0 (CLASS))\n \n-#define PROTOCOL_NAME(CLASS) ((CLASS)->type.name)\n+#define PROTOCOL_NAME(CLASS) (TYPE_NAME (CLASS))\n #define PROTOCOL_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 0)\n-#define PROTOCOL_NST_METHODS(CLASS) ((CLASS)->type.minval)\n-#define PROTOCOL_CLS_METHODS(CLASS) ((CLASS)->type.maxval)\n+#define PROTOCOL_NST_METHODS(CLASS) (TYPE_MINVAL (CLASS))\n+#define PROTOCOL_CLS_METHODS(CLASS) (TYPE_MAXVAL (CLASS))\n #define PROTOCOL_FORWARD_DECL(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 1)\n #define PROTOCOL_DEFINED(CLASS) TREE_USED (CLASS)\n #define PROTOCOL_OPTIONAL_CLS_METHODS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 2)"}, {"sha": "55c1e30e475bc0f38bb0f9ca7fdfc8b464e69d7a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -2088,12 +2088,12 @@ vector_type_mode (const_tree t)\n \n   gcc_assert (TREE_CODE (t) == VECTOR_TYPE);\n \n-  mode = t->type.mode;\n+  mode = t->type_common.mode;\n   if (VECTOR_MODE_P (mode)\n       && (!targetm.vector_mode_supported_p (mode)\n \t  || !have_regs_of_mode[mode]))\n     {\n-      enum machine_mode innermode = TREE_TYPE (t)->type.mode;\n+      enum machine_mode innermode = TREE_TYPE (t)->type_common.mode;\n \n       /* For integers, try mapping it to a same-sized scalar mode.  */\n       if (GET_MODE_CLASS (innermode) == MODE_INT)"}, {"sha": "c38d24bf12e9abe4893194a57dd4b0a034dc61e2", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -303,7 +303,7 @@ tree_node_structure_for_code (enum tree_code code)\n \t  }\n       }\n     case tcc_type:\n-      return TS_TYPE;\n+      return TS_TYPE_NON_COMMON;\n     case tcc_reference:\n     case tcc_comparison:\n     case tcc_unary:\n@@ -385,7 +385,7 @@ initialize_tree_contains_struct (void)\n \n \tcase TS_IDENTIFIER:\n \tcase TS_DECL_MINIMAL:\n-\tcase TS_TYPE:\n+\tcase TS_TYPE_COMMON:\n \tcase TS_LIST:\n \tcase TS_VEC:\n \tcase TS_EXP:\n@@ -398,6 +398,14 @@ initialize_tree_contains_struct (void)\n \t  MARK_TS_COMMON (code);\n \t  break;\n \n+\tcase TS_TYPE_WITH_LANG_SPECIFIC:\n+\t  MARK_TS_TYPE_COMMON (code);\n+\t  break;\n+\n+\tcase TS_TYPE_NON_COMMON:\n+\t  MARK_TS_TYPE_WITH_LANG_SPECIFIC (code);\n+\t  break;\n+\n \tcase TS_DECL_COMMON:\n \t  MARK_TS_DECL_MINIMAL (code);\n \t  break;\n@@ -639,7 +647,7 @@ tree_code_size (enum tree_code code)\n       }\n \n     case tcc_type:  /* a type node */\n-      return sizeof (struct tree_type);\n+      return sizeof (struct tree_type_non_common);\n \n     case tcc_reference:   /* a reference */\n     case tcc_expression:  /* an expression */"}, {"sha": "805fe0694fc082935ea20252b8402cfa17a12d4e", "filename": "gcc/tree.h", "status": "modified", "additions": 117, "deletions": 72, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -68,6 +68,18 @@ extern unsigned char tree_contains_struct[MAX_TREE_CODES][64];\n     tree_contains_struct[C][TS_COMMON] = 1;\t\t\\\n   } while (0)\n \n+#define MARK_TS_TYPE_COMMON(C)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    MARK_TS_COMMON (C);\t\t\t\t\t\\\n+    tree_contains_struct[C][TS_TYPE_COMMON] = 1;\t\\\n+  } while (0)\n+\n+#define MARK_TS_TYPE_WITH_LANG_SPECIFIC(C)\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    MARK_TS_TYPE_COMMON (C);\t\t\t\t\\\n+    tree_contains_struct[C][TS_TYPE_WITH_LANG_SPECIFIC] = 1;\t\\\n+  } while (0)\n+\n #define MARK_TS_DECL_MINIMAL(C)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n     MARK_TS_COMMON (C);\t\t\t\t\t\\\n@@ -2110,39 +2122,24 @@ struct GTY(()) tree_block {\n    type.  Note also that some of the front-ends also overload these fields,\n    so they must be checked as well.  */\n \n-#define TYPE_UID(NODE) (TYPE_CHECK (NODE)->type.uid)\n-#define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type.size)\n-#define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)\n-#define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)\n-#define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type.values)\n-#define TYPE_FIELDS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.values)\n-#define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type.values)\n-#define TYPE_METHODS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.maxval)\n-#define TYPE_VFIELD(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.minval)\n-#define TYPE_ARG_TYPES(NODE) (FUNC_OR_METHOD_CHECK (NODE)->type.values)\n-#define TYPE_METHOD_BASETYPE(NODE) (FUNC_OR_METHOD_CHECK (NODE)->type.maxval)\n-#define TYPE_OFFSET_BASETYPE(NODE) (OFFSET_TYPE_CHECK (NODE)->type.maxval)\n-#define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)->type.pointer_to)\n-#define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)->type.reference_to)\n-#define TYPE_NEXT_PTR_TO(NODE) (POINTER_TYPE_CHECK (NODE)->type.minval)\n-#define TYPE_NEXT_REF_TO(NODE) (REFERENCE_TYPE_CHECK (NODE)->type.minval)\n-#define TYPE_MIN_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.minval)\n-#define TYPE_MAX_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.maxval)\n-#define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type.precision)\n-#define TYPE_NAME(NODE) (TYPE_CHECK (NODE)->type.name)\n-#define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type.next_variant)\n-#define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n-#define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type.context)\n-#define TYPE_MAXVAL(NODE) (TYPE_CHECK (NODE)->type.maxval)\n-#define TYPE_MINVAL(NODE) (TYPE_CHECK (NODE)->type.minval)\n+#define TYPE_UID(NODE) (TYPE_CHECK (NODE)->type_common.uid)\n+#define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type_common.size)\n+#define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type_common.size_unit)\n+#define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)->type_common.pointer_to)\n+#define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)->type_common.reference_to)\n+#define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type_common.precision)\n+#define TYPE_NAME(NODE) (TYPE_CHECK (NODE)->type_common.name)\n+#define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type_common.next_variant)\n+#define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type_common.main_variant)\n+#define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type_common.context)\n \n /* Vector types need to check target flags to determine type.  */\n extern enum machine_mode vector_type_mode (const_tree);\n #define TYPE_MODE(NODE) \\\n   (TREE_CODE (TYPE_CHECK (NODE)) == VECTOR_TYPE \\\n-   ? vector_type_mode (NODE) : (NODE)->type.mode)\n+   ? vector_type_mode (NODE) : (NODE)->type_common.mode)\n #define SET_TYPE_MODE(NODE, MODE) \\\n-  (TYPE_CHECK (NODE)->type.mode = (MODE))\n+  (TYPE_CHECK (NODE)->type_common.mode = (MODE))\n \n /* The \"canonical\" type for this type node, which is used by frontends to\n    compare the type for equality with another type.  If two types are\n@@ -2160,7 +2157,7 @@ extern enum machine_mode vector_type_mode (const_tree);\n    to each other without a conversion.  The middle-end also makes sure\n    to assign the same alias-sets to the type partition with equal\n    TYPE_CANONICAL of their unqualified variants.  */\n-#define TYPE_CANONICAL(NODE) (TYPE_CHECK (NODE)->type.canonical)\n+#define TYPE_CANONICAL(NODE) (TYPE_CHECK (NODE)->type_common.canonical)\n /* Indicates that the type node requires structural equality\n    checks.  The compiler will need to look at the composition of the\n    type to determine whether it is equal to another type, rather than\n@@ -2172,35 +2169,28 @@ extern enum machine_mode vector_type_mode (const_tree);\n    type node requires structural equality.  */\n #define SET_TYPE_STRUCTURAL_EQUALITY(NODE) (TYPE_CANONICAL (NODE) = NULL_TREE)\n \n-#define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n #define TYPE_IBIT(NODE) (GET_MODE_IBIT (TYPE_MODE (NODE)))\n #define TYPE_FBIT(NODE) (GET_MODE_FBIT (TYPE_MODE (NODE)))\n \n-/* For record and union types, information about this type, as a base type\n-   for itself.  */\n-#define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK(NODE)->type.binfo)\n-\n-/* For non record and union types, used in a language-dependent way.  */\n-#define TYPE_LANG_SLOT_1(NODE) (NOT_RECORD_OR_UNION_CHECK(NODE)->type.binfo)\n-\n /* The (language-specific) typed-based alias set for this type.\n    Objects whose TYPE_ALIAS_SETs are different cannot alias each\n    other.  If the TYPE_ALIAS_SET is -1, no alias set has yet been\n    assigned to this type.  If the TYPE_ALIAS_SET is 0, objects of this\n    type can alias objects of any type.  */\n-#define TYPE_ALIAS_SET(NODE) (TYPE_CHECK (NODE)->type.alias_set)\n+#define TYPE_ALIAS_SET(NODE) (TYPE_CHECK (NODE)->type_common.alias_set)\n \n /* Nonzero iff the typed-based alias set for this type has been\n    calculated.  */\n-#define TYPE_ALIAS_SET_KNOWN_P(NODE) (TYPE_CHECK (NODE)->type.alias_set != -1)\n+#define TYPE_ALIAS_SET_KNOWN_P(NODE) \\\n+  (TYPE_CHECK (NODE)->type_common.alias_set != -1)\n \n /* A TREE_LIST of IDENTIFIER nodes of the attributes that apply\n    to this type.  */\n-#define TYPE_ATTRIBUTES(NODE) (TYPE_CHECK (NODE)->type.attributes)\n+#define TYPE_ATTRIBUTES(NODE) (TYPE_CHECK (NODE)->type_common.attributes)\n \n /* The alignment necessary for objects of this type.\n    The value is an int, measured in bits.  */\n-#define TYPE_ALIGN(NODE) (TYPE_CHECK (NODE)->type.align)\n+#define TYPE_ALIGN(NODE) (TYPE_CHECK (NODE)->type_common.align)\n \n /* 1 if the alignment for this type was requested by \"aligned\" attribute,\n    0 if it is the default for this type.  */\n@@ -2221,7 +2211,8 @@ extern enum machine_mode vector_type_mode (const_tree);\n /* In a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, it means the type\n    has BLKmode only because it lacks the alignment requirement for\n    its size.  */\n-#define TYPE_NO_FORCE_BLK(NODE) (TYPE_CHECK (NODE)->type.no_force_blk_flag)\n+#define TYPE_NO_FORCE_BLK(NODE) \\\n+  (TYPE_CHECK (NODE)->type_common.no_force_blk_flag)\n \n /* In an INTEGER_TYPE, it means the type represents a size.  We use\n    this both for validity checking and to permit optimizations that\n@@ -2232,7 +2223,7 @@ extern enum machine_mode vector_type_mode (const_tree);\n    properties.  Expressions whose type have TYPE_IS_SIZETYPE set are\n    always actual sizes.  */\n #define TYPE_IS_SIZETYPE(NODE) \\\n-  (INTEGER_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n+  (INTEGER_TYPE_CHECK (NODE)->type_common.no_force_blk_flag)\n \n /* Nonzero in a type considered volatile as a whole.  */\n #define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->base.volatile_flag)\n@@ -2242,7 +2233,7 @@ extern enum machine_mode vector_type_mode (const_tree);\n \n /* If nonzero, this type is `restrict'-qualified, in the C sense of\n    the term.  */\n-#define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type.restrict_flag)\n+#define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type_common.restrict_flag)\n \n /* If nonzero, type's name shouldn't be emitted into debug info.  */\n #define TYPE_NAMELESS(NODE) (TYPE_CHECK (NODE)->base.nameless_flag)\n@@ -2287,13 +2278,13 @@ enum cv_qualifier\n    | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT))\n \n /* These flags are available for each language front end to use internally.  */\n-#define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type.lang_flag_0)\n-#define TYPE_LANG_FLAG_1(NODE) (TYPE_CHECK (NODE)->type.lang_flag_1)\n-#define TYPE_LANG_FLAG_2(NODE) (TYPE_CHECK (NODE)->type.lang_flag_2)\n-#define TYPE_LANG_FLAG_3(NODE) (TYPE_CHECK (NODE)->type.lang_flag_3)\n-#define TYPE_LANG_FLAG_4(NODE) (TYPE_CHECK (NODE)->type.lang_flag_4)\n-#define TYPE_LANG_FLAG_5(NODE) (TYPE_CHECK (NODE)->type.lang_flag_5)\n-#define TYPE_LANG_FLAG_6(NODE) (TYPE_CHECK (NODE)->type.lang_flag_6)\n+#define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_0)\n+#define TYPE_LANG_FLAG_1(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_1)\n+#define TYPE_LANG_FLAG_2(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_2)\n+#define TYPE_LANG_FLAG_3(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_3)\n+#define TYPE_LANG_FLAG_4(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_4)\n+#define TYPE_LANG_FLAG_5(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_5)\n+#define TYPE_LANG_FLAG_6(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_6)\n \n /* Used to keep track of visited nodes in tree traversals.  This is set to\n    0 by copy_node and make_node.  */\n@@ -2302,22 +2293,16 @@ enum cv_qualifier\n /* If set in an ARRAY_TYPE, indicates a string type (for languages\n    that distinguish string from array of char).\n    If set in a INTEGER_TYPE, indicates a character type.  */\n-#define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type.string_flag)\n-\n-/* If non-NULL, this is an upper bound of the size (in bytes) of an\n-   object of the given ARRAY_TYPE.  This allows temporaries to be\n-   allocated.  */\n-#define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \\\n-  (ARRAY_TYPE_CHECK (ARRAY_TYPE)->type.maxval)\n+#define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type_common.string_flag)\n \n /* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n #define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n   (((unsigned HOST_WIDE_INT) 1) \\\n-   << VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.precision)\n+   << VECTOR_TYPE_CHECK (VECTOR_TYPE)->type_common.precision)\n \n /* Set precision to n when we have 2^n sub-parts of the vector.  */\n #define SET_TYPE_VECTOR_SUBPARTS(VECTOR_TYPE, X) \\\n-  (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.precision = exact_log2 (X))\n+  (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type_common.precision = exact_log2 (X))\n \n /* Nonzero in a VECTOR_TYPE if the frontends should not emit warnings\n    about missing conversions to other vector types of the same size.  */\n@@ -2327,20 +2312,20 @@ enum cv_qualifier\n /* Indicates that objects of this type must be initialized by calling a\n    function when they are created.  */\n #define TYPE_NEEDS_CONSTRUCTING(NODE) \\\n-  (TYPE_CHECK (NODE)->type.needs_constructing_flag)\n+  (TYPE_CHECK (NODE)->type_common.needs_constructing_flag)\n \n /* Indicates that a UNION_TYPE object should be passed the same way that\n    the first union alternative would be passed, or that a RECORD_TYPE\n    object should be passed the same way that the first (and only) member\n    would be passed.  */\n #define TYPE_TRANSPARENT_AGGR(NODE) \\\n-  (RECORD_OR_UNION_CHECK (NODE)->type.transparent_aggr_flag)\n+  (RECORD_OR_UNION_CHECK (NODE)->type_common.transparent_aggr_flag)\n \n /* For an ARRAY_TYPE, indicates that it is not permitted to take the\n    address of a component of the type.  This is the counterpart of\n    DECL_NONADDRESSABLE_P for arrays, see the definition of this flag.  */\n #define TYPE_NONALIASED_COMPONENT(NODE) \\\n-  (ARRAY_TYPE_CHECK (NODE)->type.transparent_aggr_flag)\n+  (ARRAY_TYPE_CHECK (NODE)->type_common.transparent_aggr_flag)\n \n /* Indicated that objects of this type should be laid out in as\n    compact a way as possible.  */\n@@ -2350,7 +2335,7 @@ enum cv_qualifier\n    Values are: 0 (unknown), 1 (false), 2 (true).  Never access\n    this field directly.  */\n #define TYPE_CONTAINS_PLACEHOLDER_INTERNAL(NODE) \\\n-  (TYPE_CHECK (NODE)->type.contains_placeholder_bits)\n+  (TYPE_CHECK (NODE)->type_common.contains_placeholder_bits)\n \n /* The debug output functions use the symtab union field to store\n    information specific to the debugging format.  The different debug\n@@ -2361,15 +2346,18 @@ enum cv_qualifier\n \n /* Symtab field as an integer.  Used by stabs generator in dbxout.c to\n    hold the type's number in the generated stabs.  */\n-#define TYPE_SYMTAB_ADDRESS(NODE) (TYPE_CHECK (NODE)->type.symtab.address)\n+#define TYPE_SYMTAB_ADDRESS(NODE) \\\n+  (TYPE_CHECK (NODE)->type_common.symtab.address)\n \n /* Symtab field as a string.  Used by COFF generator in sdbout.c to\n    hold struct/union type tag names.  */\n-#define TYPE_SYMTAB_POINTER(NODE) (TYPE_CHECK (NODE)->type.symtab.pointer)\n+#define TYPE_SYMTAB_POINTER(NODE) \\\n+  (TYPE_CHECK (NODE)->type_common.symtab.pointer)\n \n /* Symtab field as a pointer to a DWARF DIE.  Used by DWARF generator\n    in dwarf2out.c to point to the DIE generated for the type.  */\n-#define TYPE_SYMTAB_DIE(NODE) (TYPE_CHECK (NODE)->type.symtab.die)\n+#define TYPE_SYMTAB_DIE(NODE) \\\n+  (TYPE_CHECK (NODE)->type_common.symtab.die)\n \n /* The garbage collector needs to know the interpretation of the\n    symtab field.  These constants represent the different types in the\n@@ -2381,9 +2369,8 @@ enum cv_qualifier\n \n struct die_struct;\n \n-struct GTY(()) tree_type {\n+struct GTY(()) tree_type_common {\n   struct tree_common common;\n-  tree values;\n   tree size;\n   tree size_unit;\n   tree attributes;\n@@ -2417,16 +2404,70 @@ struct GTY(()) tree_type {\n     struct die_struct * GTY ((tag (\"TYPE_SYMTAB_IS_DIE\"))) die;\n   } GTY ((desc (\"debug_hooks->tree_type_symtab_field\"))) symtab;\n   tree name;\n-  tree minval;\n-  tree maxval;\n   tree next_variant;\n   tree main_variant;\n-  tree binfo;\n   tree context;\n   tree canonical;\n+};\n+\n+#define TYPE_LANG_SPECIFIC(NODE) \\\n+  (TYPE_CHECK (NODE)->type_with_lang_specific.lang_specific)\n+\n+struct GTY(()) tree_type_with_lang_specific {\n+  struct tree_type_common common;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_type *lang_specific;\n };\n+\n+#define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type_non_common.values)\n+#define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type_non_common.values)\n+#define TYPE_FIELDS(NODE) \\\n+  (RECORD_OR_UNION_CHECK (NODE)->type_non_common.values)\n+#define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type_non_common.values)\n+#define TYPE_ARG_TYPES(NODE) \\\n+  (FUNC_OR_METHOD_CHECK (NODE)->type_non_common.values)\n+#define TYPE_VALUES_RAW(NODE) (TYPE_CHECK(NODE)->type_non_common.values)\n+\n+#define TYPE_METHODS(NODE) \\\n+  (RECORD_OR_UNION_CHECK (NODE)->type_non_common.maxval)\n+#define TYPE_VFIELD(NODE) \\\n+  (RECORD_OR_UNION_CHECK (NODE)->type_non_common.minval)\n+#define TYPE_METHOD_BASETYPE(NODE) \\\n+  (FUNC_OR_METHOD_CHECK (NODE)->type_non_common.maxval)\n+#define TYPE_OFFSET_BASETYPE(NODE) \\\n+  (OFFSET_TYPE_CHECK (NODE)->type_non_common.maxval)\n+#define TYPE_MAXVAL(NODE) (TYPE_CHECK (NODE)->type_non_common.maxval)\n+#define TYPE_MINVAL(NODE) (TYPE_CHECK (NODE)->type_non_common.minval)\n+#define TYPE_NEXT_PTR_TO(NODE) \\\n+  (POINTER_TYPE_CHECK (NODE)->type_non_common.minval)\n+#define TYPE_NEXT_REF_TO(NODE) \\\n+  (REFERENCE_TYPE_CHECK (NODE)->type_non_common.minval)\n+#define TYPE_MIN_VALUE(NODE) \\\n+  (NUMERICAL_TYPE_CHECK (NODE)->type_non_common.minval)\n+#define TYPE_MAX_VALUE(NODE) \\\n+  (NUMERICAL_TYPE_CHECK (NODE)->type_non_common.maxval)\n+\n+/* If non-NULL, this is an upper bound of the size (in bytes) of an\n+   object of the given ARRAY_TYPE_NON_COMMON.  This allows temporaries to be\n+   allocated.  */\n+#define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \\\n+  (ARRAY_TYPE_CHECK (ARRAY_TYPE)->type_non_common.maxval)\n+\n+/* For record and union types, information about this type, as a base type\n+   for itself.  */\n+#define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK(NODE)->type_non_common.binfo)\n+\n+/* For non record and union types, used in a language-dependent way.  */\n+#define TYPE_LANG_SLOT_1(NODE) \\\n+  (NOT_RECORD_OR_UNION_CHECK(NODE)->type_non_common.binfo)\n+\n+struct GTY(()) tree_type_non_common {\n+  struct tree_type_with_lang_specific with_lang_specific;\n+  tree values;\n+  tree minval;\n+  tree maxval;\n+  tree binfo;\n+};\n \f\n /* Define accessor macros for information about type inheritance\n    and basetypes.\n@@ -3584,7 +3625,11 @@ union GTY ((ptr_alias (union lang_tree_node),\n   struct tree_function_decl GTY ((tag (\"TS_FUNCTION_DECL\"))) function_decl;\n   struct tree_translation_unit_decl GTY ((tag (\"TS_TRANSLATION_UNIT_DECL\")))\n     translation_unit_decl;\n-  struct tree_type GTY ((tag (\"TS_TYPE\"))) type;\n+  struct tree_type_common GTY ((tag (\"TS_TYPE_COMMON\"))) type_common;\n+  struct tree_type_with_lang_specific GTY ((tag (\"TS_TYPE_WITH_LANG_SPECIFIC\")))\n+    type_with_lang_specific;\n+  struct tree_type_non_common GTY ((tag (\"TS_TYPE_NON_COMMON\")))\n+    type_non_common;\n   struct tree_list GTY ((tag (\"TS_LIST\"))) list;\n   struct tree_vec GTY ((tag (\"TS_VEC\"))) vec;\n   struct tree_exp GTY ((tag (\"TS_EXP\"))) exp;"}, {"sha": "1e5f32d2ee915394b665930ba1f9a3180531511c", "filename": "gcc/treestruct.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515456820e0468b848ff5905d6d8439a47036fdc/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=515456820e0468b848ff5905d6d8439a47036fdc", "patch": "@@ -54,7 +54,9 @@ DEFTREESTRUCT(TS_CONST_DECL, \"const decl\")\n DEFTREESTRUCT(TS_TYPE_DECL, \"label decl\")\n DEFTREESTRUCT(TS_FUNCTION_DECL, \"function decl\")\n DEFTREESTRUCT(TS_TRANSLATION_UNIT_DECL, \"translation-unit decl\")\n-DEFTREESTRUCT(TS_TYPE, \"type\")\n+DEFTREESTRUCT(TS_TYPE_COMMON, \"type common\")\n+DEFTREESTRUCT(TS_TYPE_WITH_LANG_SPECIFIC, \"type with lang-specific\")\n+DEFTREESTRUCT(TS_TYPE_NON_COMMON, \"type non-common\")\n DEFTREESTRUCT(TS_LIST, \"list\")\n DEFTREESTRUCT(TS_VEC, \"vec\")\n DEFTREESTRUCT(TS_EXP, \"exp\")"}]}