{"sha": "fffbab82e7fd15ef695159746a0ce7b9ac906778", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmYmFiODJlN2ZkMTVlZjY5NTE1OTc0NmEwY2U3YjlhYzkwNjc3OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:10:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:10:28Z"}, "message": "[17/77] Add an int_mode_for_size helper function\n\nThis patch adds a wrapper around mode_for_size for cases in which\nthe mode class is MODE_INT (the commonest case).  The return type\ncan then be an opt_scalar_int_mode instead of a machine_mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (int_mode_for_size): New function.\n\t* builtins.c (set_builtin_user_assembler_name): Use int_mode_for_size\n\tinstead of mode_for_size.\n\t* calls.c (save_fixed_argument_area): Likewise.  Make use of BLKmode\n\texplicit.\n\t* combine.c (expand_field_assignment): Use int_mode_for_size\n\tinstead of mode_for_size.\n\t(make_extraction): Likewise.\n\t(simplify_shift_const_1): Likewise.\n\t(simplify_comparison): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t* emit-rtl.c (init_derived_machine_modes): Likewise.\n\t* expmed.c (flip_storage_order): Likewise.\n\t(convert_extracted_bit_field): Likewise.\n\t* expr.c (copy_blkmode_from_reg): Likewise.\n\t* graphite-isl-ast-to-gimple.c (max_mode_int_precision): Likewise.\n\t* internal-fn.c (expand_mul_overflow): Likewise.\n\t* lower-subreg.c (simple_move): Likewise.\n\t* optabs-libfuncs.c (init_optabs): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\t* tree.c (vector_type_mode): Likewise.\n\t* tree-ssa-strlen.c (handle_builtin_memcmp): Likewise.\n\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Likewise.\n\t* tree-vect-generic.c (expand_vector_parallel): Likewise.\n\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n\t(vectorizable_store): Likewise.\n\ngcc/ada/\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use int_mode_for_size\n\tinstead of mode_for_size.\n\t(gnat_to_gnu_subprog_type): Likewise.\n\t* gcc-interface/utils.c (make_type_from_size): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251469", "tree": {"sha": "1029fb2ff65fd47b432f0cdae4a809c11325b13b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1029fb2ff65fd47b432f0cdae4a809c11325b13b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fffbab82e7fd15ef695159746a0ce7b9ac906778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffbab82e7fd15ef695159746a0ce7b9ac906778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fffbab82e7fd15ef695159746a0ce7b9ac906778", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffbab82e7fd15ef695159746a0ce7b9ac906778/comments", "author": null, "committer": null, "parents": [{"sha": "bf862c537bfd76233e3938cb3811f0fa2d27de25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf862c537bfd76233e3938cb3811f0fa2d27de25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf862c537bfd76233e3938cb3811f0fa2d27de25"}], "stats": {"total": 202, "additions": 124, "deletions": 78}, "files": [{"sha": "a9d5ea22c0064db84c26845b0ee5e9efffa10eae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -1,3 +1,35 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (int_mode_for_size): New function.\n+\t* builtins.c (set_builtin_user_assembler_name): Use int_mode_for_size\n+\tinstead of mode_for_size.\n+\t* calls.c (save_fixed_argument_area): Likewise.  Make use of BLKmode\n+\texplicit.\n+\t* combine.c (expand_field_assignment): Use int_mode_for_size\n+\tinstead of mode_for_size.\n+\t(make_extraction): Likewise.\n+\t(simplify_shift_const_1): Likewise.\n+\t(simplify_comparison): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n+\t* emit-rtl.c (init_derived_machine_modes): Likewise.\n+\t* expmed.c (flip_storage_order): Likewise.\n+\t(convert_extracted_bit_field): Likewise.\n+\t* expr.c (copy_blkmode_from_reg): Likewise.\n+\t* graphite-isl-ast-to-gimple.c (max_mode_int_precision): Likewise.\n+\t* internal-fn.c (expand_mul_overflow): Likewise.\n+\t* lower-subreg.c (simple_move): Likewise.\n+\t* optabs-libfuncs.c (init_optabs): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\t* tree.c (vector_type_mode): Likewise.\n+\t* tree-ssa-strlen.c (handle_builtin_memcmp): Likewise.\n+\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Likewise.\n+\t* tree-vect-generic.c (expand_vector_parallel): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n+\t(vectorizable_store): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "633ca11e4cede5aab5a1197ad6d570706dcbf041", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -1,3 +1,12 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use int_mode_for_size\n+\tinstead of mode_for_size.\n+\t(gnat_to_gnu_subprog_type): Likewise.\n+\t* gcc-interface/utils.c (make_type_from_size): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "1b88e25bbf991c5ea60a01c29281de101da41c57", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -3625,11 +3625,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t/* True if we make a dummy type here.  */\n \tbool made_dummy = false;\n \t/* The mode to be used for the pointer type.  */\n-\tmachine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n+\tscalar_int_mode p_mode;\n \t/* The GCC type used for the designated type.  */\n \ttree gnu_desig_type = NULL_TREE;\n \n-\tif (!targetm.valid_pointer_mode (p_mode))\n+\tif (!int_mode_for_size (esize, 0).exists (&p_mode)\n+\t    || !targetm.valid_pointer_mode (p_mode))\n \t  p_mode = ptr_mode;\n \n \t/* If either the designated type or its full view is an unconstrained\n@@ -5939,12 +5940,11 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t      unsigned int size\n \t\t= TREE_INT_CST_LOW (TYPE_SIZE (gnu_cico_return_type));\n \t      unsigned int i = BITS_PER_UNIT;\n-\t      machine_mode mode;\n+\t      scalar_int_mode mode;\n \n \t      while (i < size)\n \t\ti <<= 1;\n-\t      mode = mode_for_size (i, MODE_INT, 0);\n-\t      if (mode != BLKmode)\n+\t      if (int_mode_for_size (i, 0).exists (&mode))\n \t\t{\n \t\t  SET_TYPE_MODE (gnu_cico_return_type, mode);\n \t\t  SET_TYPE_ALIGN (gnu_cico_return_type,"}, {"sha": "bc916bbb974771418587d518f0c12d37df1c6d4f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -1166,8 +1166,9 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \t may need to return the thin pointer.  */\n       if (TYPE_FAT_POINTER_P (type) && size < POINTER_SIZE * 2)\n \t{\n-\t  machine_mode p_mode = mode_for_size (size, MODE_INT, 0);\n-\t  if (!targetm.valid_pointer_mode (p_mode))\n+\t  scalar_int_mode p_mode;\n+\t  if (!int_mode_for_size (size, 0).exists (&p_mode)\n+\t      || !targetm.valid_pointer_mode (p_mode))\n \t    p_mode = ptr_mode;\n \t  return\n \t    build_pointer_type_for_mode"}, {"sha": "ab6a3c0bf1f256ffcdcbe0369d9132ab3d16f795", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -10365,9 +10365,9 @@ set_builtin_user_assembler_name (tree decl, const char *asmspec)\n   if (DECL_FUNCTION_CODE (decl) == BUILT_IN_FFS\n       && INT_TYPE_SIZE < BITS_PER_WORD)\n     {\n+      scalar_int_mode mode = int_mode_for_size (INT_TYPE_SIZE, 0).require ();\n       set_user_assembler_libfunc (\"ffs\", asmspec);\n-      set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n-\t\t\t \"ffs\");\n+      set_optab_libfunc (ffs_optab, mode, \"ffs\");\n     }\n }\n "}, {"sha": "d5bd5049cb94fd57aafe1b20bbe152d9f6880ddc", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -1047,12 +1047,15 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n \t*high_to_save = high;\n \n \tnum_to_save = high - low + 1;\n-\tsave_mode = mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n \n \t/* If we don't have the required alignment, must do this\n \t   in BLKmode.  */\n-\tif ((low & (MIN (GET_MODE_SIZE (save_mode),\n-\t\t\t BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\tscalar_int_mode imode;\n+\tif (int_mode_for_size (num_to_save * BITS_PER_UNIT, 1).exists (&imode)\n+\t    && (low & (MIN (GET_MODE_SIZE (imode),\n+\t\t\t    BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)) == 0)\n+\t  save_mode = imode;\n+\telse\n \t  save_mode = BLKmode;\n \n \tif (ARGS_GROW_DOWNWARD)"}, {"sha": "a717ca5644d5176d57db352f28818827feb9f3d0", "filename": "gcc/combine.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -7306,19 +7306,16 @@ expand_field_assignment (const_rtx x)\n       /* Don't attempt bitwise arithmetic on non scalar integer modes.  */\n       if (! SCALAR_INT_MODE_P (compute_mode))\n \t{\n-\t  machine_mode imode;\n-\n \t  /* Don't do anything for vector or complex integral types.  */\n \t  if (! FLOAT_MODE_P (compute_mode))\n \t    break;\n \n \t  /* Try to find an integral mode to pun with.  */\n-\t  imode = mode_for_size (GET_MODE_BITSIZE (compute_mode), MODE_INT, 0);\n-\t  if (imode == BLKmode)\n+\t  if (!int_mode_for_size (GET_MODE_BITSIZE (compute_mode), 0)\n+\t      .exists (&compute_mode))\n \t    break;\n \n-\t  compute_mode = imode;\n-\t  inner = gen_lowpart (imode, inner);\n+\t  inner = gen_lowpart (compute_mode, inner);\n \t}\n \n       /* Compute a mask of LEN bits, if we can do this on the host machine.  */\n@@ -7389,7 +7386,6 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   machine_mode wanted_inner_reg_mode = word_mode;\n   machine_mode pos_mode = word_mode;\n   machine_mode extraction_mode = word_mode;\n-  machine_mode tmode = mode_for_size (len, MODE_INT, 1);\n   rtx new_rtx = 0;\n   rtx orig_pos_rtx = pos_rtx;\n   HOST_WIDE_INT orig_pos;\n@@ -7437,7 +7433,8 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      For MEM, we can avoid an extract if the field starts on an appropriate\n      boundary and we can change the mode of the memory reference.  */\n \n-  if (tmode != BLKmode\n+  scalar_int_mode tmode;\n+  if (int_mode_for_size (len, 1).exists (&tmode)\n       && ((pos_rtx == 0 && (pos % BITS_PER_WORD) == 0\n \t   && !MEM_P (inner)\n \t   && (pos == 0 || REG_P (inner))\n@@ -10444,8 +10441,8 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t      && ! mode_dependent_address_p (XEXP (varop, 0),\n \t\t\t\t\t     MEM_ADDR_SPACE (varop))\n \t      && ! MEM_VOLATILE_P (varop)\n-\t      && (tmode = mode_for_size (GET_MODE_BITSIZE (mode) - count,\n-\t\t\t\t\t MODE_INT, 1)) != BLKmode)\n+\t      && (int_mode_for_size (GET_MODE_BITSIZE (mode) - count, 1)\n+\t\t  .exists (&tmode)))\n \t    {\n \t      new_rtx = adjust_address_nv (varop, tmode,\n \t\t\t\t       BYTES_BIG_ENDIAN ? 0\n@@ -12371,7 +12368,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t\t\t   & GET_MODE_MASK (mode))\n \t\t\t\t  + 1)) >= 0\n \t      && const_op >> i == 0\n-\t      && (tmode = mode_for_size (i, MODE_INT, 1)) != BLKmode)\n+\t      && int_mode_for_size (i, 1).exists (&tmode))\n \t    {\n \t      op0 = gen_lowpart_or_truncate (tmode, XEXP (op0, 0));\n \t      continue;\n@@ -12531,8 +12528,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && CONST_INT_P (XEXP (op0, 1))\n \t      && GET_CODE (XEXP (op0, 0)) == ASHIFT\n \t      && XEXP (op0, 1) == XEXP (XEXP (op0, 0), 1)\n-\t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n-\t\t\t\t\t MODE_INT, 1)) != BLKmode\n+\t      && (int_mode_for_size (mode_width - INTVAL (XEXP (op0, 1)), 1)\n+\t\t  .exists (&tmode))\n \t      && (((unsigned HOST_WIDE_INT) const_op\n \t\t   + (GET_MODE_MASK (tmode) >> 1) + 1)\n \t\t  <= GET_MODE_MASK (tmode)))\n@@ -12550,8 +12547,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && CONST_INT_P (XEXP (XEXP (op0, 0), 1))\n \t      && GET_CODE (XEXP (XEXP (op0, 0), 0)) == ASHIFT\n \t      && XEXP (op0, 1) == XEXP (XEXP (XEXP (op0, 0), 0), 1)\n-\t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n-\t\t\t\t\t MODE_INT, 1)) != BLKmode\n+\t      && (int_mode_for_size (mode_width - INTVAL (XEXP (op0, 1)), 1)\n+\t\t  .exists (&tmode))\n \t      && (((unsigned HOST_WIDE_INT) const_op\n \t\t   + (GET_MODE_MASK (tmode) >> 1) + 1)\n \t\t  <= GET_MODE_MASK (tmode)))"}, {"sha": "34492f32e67db7a4d86c6d24ddb9a351df566354", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -594,7 +594,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n           && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n           && TYPE_PRECISION (TREE_TYPE (exp)) <= HOST_BITS_PER_WIDE_INT\n           && (i = tree_floor_log2 (TREE_OPERAND (exp, 1))) >= 0\n-          && (mode = mode_for_size (i + 1, MODE_INT, 0)) != BLKmode\n+\t  && int_mode_for_size (i + 1, 0).exists (&mode)\n           && (type = lang_hooks.types.type_for_mode (mode, 1)) != 0\n           && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n           && have_insn_for (COMPARE, TYPE_MODE (type)))"}, {"sha": "fdee0096dbb36291785fefe8c57fb96db47eb467", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -15251,13 +15251,12 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t      || GET_MODE_BITSIZE (mode) == HOST_BITS_PER_DOUBLE_INT))\n \t{\n \t  dw_die_ref type_die = base_type_for_mode (mode, 1);\n-\t  machine_mode amode;\n+\t  scalar_int_mode amode;\n \t  if (type_die == NULL)\n \t    return NULL;\n-\t  amode = mode_for_size (DWARF2_ADDR_SIZE * BITS_PER_UNIT,\n-\t\t\t\t MODE_INT, 0);\n \t  if (INTVAL (rtl) >= 0\n-\t      && amode != BLKmode\n+\t      && (int_mode_for_size (DWARF2_ADDR_SIZE * BITS_PER_UNIT, 0)\n+\t\t  .exists (&amode))\n \t      && trunc_int_for_mode (INTVAL (rtl), amode) == INTVAL (rtl)\n \t      /* const DW_OP_convert <XXX> vs.\n \t\t DW_OP_const_type <XXX, 1, const>.  */"}, {"sha": "3785eca50145e898a55767514924ea65745a4f9f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -5879,8 +5879,7 @@ init_derived_machine_modes (void)\n \n   byte_mode = opt_byte_mode.require ();\n   word_mode = opt_word_mode.require ();\n-  ptr_mode = as_a <scalar_int_mode> (mode_for_size (POINTER_SIZE,\n-\t\t\t\t\t\t    MODE_INT, 0));\n+  ptr_mode = int_mode_for_size (POINTER_SIZE, 0).require ();\n }\n \n /* Create some permanent unique rtl objects shared between all functions.  */"}, {"sha": "4c39096460ba366879af21f3223e5829e7a2a1ee", "filename": "gcc/expmed.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -364,7 +364,7 @@ check_reverse_float_storage_order_support (void)\n rtx\n flip_storage_order (machine_mode mode, rtx x)\n {\n-  machine_mode int_mode;\n+  scalar_int_mode int_mode;\n   rtx result;\n \n   if (mode == QImode)\n@@ -384,16 +384,13 @@ flip_storage_order (machine_mode mode, rtx x)\n   if (__builtin_expect (reverse_storage_order_supported < 0, 0))\n     check_reverse_storage_order_support ();\n \n-  if (SCALAR_INT_MODE_P (mode))\n-    int_mode = mode;\n-  else\n+  if (!is_a <scalar_int_mode> (mode, &int_mode))\n     {\n       if (FLOAT_MODE_P (mode)\n \t  && __builtin_expect (reverse_float_storage_order_supported < 0, 0))\n \tcheck_reverse_float_storage_order_support ();\n \n-      int_mode = mode_for_size (GET_MODE_PRECISION (mode), MODE_INT, 0);\n-      if (int_mode == BLKmode)\n+      if (!int_mode_for_size (GET_MODE_PRECISION (mode), 0).exists (&int_mode))\n \t{\n \t  sorry (\"reverse storage order for %smode\", GET_MODE_NAME (mode));\n \t  return x;\n@@ -1429,11 +1426,10 @@ convert_extracted_bit_field (rtx x, machine_mode mode,\n      value via a SUBREG.  */\n   if (!SCALAR_INT_MODE_P (tmode))\n     {\n-      machine_mode smode;\n-\n-      smode = mode_for_size (GET_MODE_BITSIZE (tmode), MODE_INT, 0);\n-      x = convert_to_mode (smode, x, unsignedp);\n-      x = force_reg (smode, x);\n+      scalar_int_mode int_mode\n+\t= int_mode_for_size (GET_MODE_BITSIZE (tmode), 0).require ();\n+      x = convert_to_mode (int_mode, x, unsignedp);\n+      x = force_reg (int_mode, x);\n       return gen_lowpart (tmode, x);\n     }\n "}, {"sha": "ac6f959af1293cc2f7bfe477b18542a26650ce38", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -2671,9 +2671,9 @@ copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n   copy_mode = word_mode;\n   if (MEM_P (target))\n     {\n-      machine_mode mem_mode = mode_for_size (bitsize, MODE_INT, 1);\n-      if (mem_mode != BLKmode)\n-\tcopy_mode = mem_mode;\n+      opt_scalar_int_mode mem_mode = int_mode_for_size (bitsize, 1);\n+      if (mem_mode.exists ())\n+\tcopy_mode = mem_mode.require ();\n     }\n   else if (REG_P (target) && GET_MODE_BITSIZE (tmode) < BITS_PER_WORD)\n     copy_mode = tmode;"}, {"sha": "964d6c9755399a7f452e10f9d2be3f43a26127bf", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -61,7 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n    should use isl to derive the optimal type for each subexpression.  */\n \n static int max_mode_int_precision =\n-  GET_MODE_PRECISION (mode_for_size (MAX_FIXED_MODE_SIZE, MODE_INT, 0));\n+  GET_MODE_PRECISION (int_mode_for_size (MAX_FIXED_MODE_SIZE, 0).require ());\n static int graphite_expression_type_precision = 128 <= max_mode_int_precision ?\n \t\t\t\t\t\t128 : max_mode_int_precision;\n "}, {"sha": "017a469f2be53a171fe161db4398257cf3fffc5c", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -1459,7 +1459,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     {\n       struct separate_ops ops;\n       int prec = GET_MODE_PRECISION (mode);\n-      machine_mode hmode = mode_for_size (prec / 2, MODE_INT, 1);\n+      scalar_int_mode hmode;\n       machine_mode wmode;\n       ops.op0 = make_tree (type, op0);\n       ops.op1 = make_tree (type, op1);\n@@ -1495,7 +1495,8 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t       profile_probability::very_likely ());\n \t    }\n \t}\n-      else if (hmode != BLKmode && 2 * GET_MODE_PRECISION (hmode) == prec)\n+      else if (int_mode_for_size (prec / 2, 1).exists (&hmode)\n+\t       && 2 * GET_MODE_PRECISION (hmode) == prec)\n \t{\n \t  rtx_code_label *large_op0 = gen_label_rtx ();\n \t  rtx_code_label *small_op0_large_op1 = gen_label_rtx ();"}, {"sha": "bdec0aa4cc0ce024ce9cc0c6f41728595ff4719b", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -349,8 +349,7 @@ simple_move (rtx_insn *insn, bool speed_p)\n      size.  */\n   mode = GET_MODE (SET_DEST (set));\n   if (!SCALAR_INT_MODE_P (mode)\n-      && (mode_for_size (GET_MODE_SIZE (mode) * BITS_PER_UNIT, MODE_INT, 0)\n-\t  == BLKmode))\n+      && !int_mode_for_size (GET_MODE_BITSIZE (mode), 0).exists ())\n     return NULL_RTX;\n \n   /* Reject PARTIAL_INT modes.  They are used for processor specific"}, {"sha": "dcbfa0f4a3b8829ddea8ef07ecec5352b0e6c090", "filename": "gcc/machmode.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -557,6 +557,16 @@ extern const unsigned char mode_complex[NUM_MACHINE_MODES];\n \n extern machine_mode mode_for_size (unsigned int, enum mode_class, int);\n \n+/* Return the machine mode to use for a MODE_INT of SIZE bits, if one\n+   exists.  If LIMIT is nonzero, modes wider than MAX_FIXED_MODE_SIZE\n+   will not be used.  */\n+\n+inline opt_scalar_int_mode\n+int_mode_for_size (unsigned int size, int limit)\n+{\n+  return dyn_cast <scalar_int_mode> (mode_for_size (size, MODE_INT, limit));\n+}\n+\n /* Return the machine mode to use for a MODE_FLOAT of SIZE bits, if one\n    exists.  */\n "}, {"sha": "151a473a66b61f328a5c852dff1712ad676cd0d7", "filename": "gcc/optabs-libfuncs.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Foptabs-libfuncs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Foptabs-libfuncs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-libfuncs.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -858,8 +858,10 @@ init_optabs (void)\n   /* The ffs function operates on `int'.  Fall back on it if we do not\n      have a libgcc2 function for that width.  */\n   if (INT_TYPE_SIZE < BITS_PER_WORD)\n-    set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n-\t\t       \"ffs\");\n+    {\n+      scalar_int_mode mode = int_mode_for_size (INT_TYPE_SIZE, 0).require ();\n+      set_optab_libfunc (ffs_optab, mode, \"ffs\");\n+    }\n \n   /* Explicitly initialize the bswap libfuncs since we need them to be\n      valid for things other than word_mode.  */"}, {"sha": "83e98b6c8d682aadc7c83df8c6f445cd2912a2b9", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -1493,12 +1493,11 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  && XEXP (XEXP (op, 0), 1) == XEXP (op, 1)\n \t  && GET_MODE_BITSIZE (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n \t{\n-\t  machine_mode tmode\n-\t    = mode_for_size (GET_MODE_BITSIZE (GET_MODE (op))\n-\t\t\t     - INTVAL (XEXP (op, 1)), MODE_INT, 1);\n+\t  scalar_int_mode tmode;\n \t  gcc_assert (GET_MODE_BITSIZE (mode)\n \t\t      > GET_MODE_BITSIZE (GET_MODE (op)));\n-\t  if (tmode != BLKmode)\n+\t  if (int_mode_for_size (GET_MODE_BITSIZE (GET_MODE (op))\n+\t\t\t\t - INTVAL (XEXP (op, 1)), 1).exists (&tmode))\n \t    {\n \t      rtx inner =\n \t\trtl_hooks.gen_lowpart_no_emit (tmode, XEXP (XEXP (op, 0), 0));\n@@ -1610,10 +1609,9 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  && XEXP (XEXP (op, 0), 1) == XEXP (op, 1)\n \t  && GET_MODE_PRECISION (GET_MODE (op)) > INTVAL (XEXP (op, 1)))\n \t{\n-\t  machine_mode tmode\n-\t    = mode_for_size (GET_MODE_PRECISION (GET_MODE (op))\n-\t\t\t     - INTVAL (XEXP (op, 1)), MODE_INT, 1);\n-\t  if (tmode != BLKmode)\n+\t  scalar_int_mode tmode;\n+\t  if (int_mode_for_size (GET_MODE_PRECISION (GET_MODE (op))\n+\t\t\t\t - INTVAL (XEXP (op, 1)), 1).exists (&tmode))\n \t    {\n \t      rtx inner =\n \t\trtl_hooks.gen_lowpart_no_emit (tmode, XEXP (XEXP (op, 0), 0));"}, {"sha": "1269fa8a2bca18fdfead090dd9cdda75d5f2d4a9", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -2122,8 +2122,8 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n       unsigned align1 = get_pointer_alignment (arg1);\n       unsigned align2 = get_pointer_alignment (arg2);\n       unsigned align = MIN (align1, align2);\n-      machine_mode mode = mode_for_size (leni, MODE_INT, 1);\n-      if (mode != BLKmode\n+      scalar_int_mode mode;\n+      if (int_mode_for_size (leni, 1).exists (&mode)\n \t  && (align >= leni || !SLOW_UNALIGNED_ACCESS (mode, align)))\n \t{\n \t  location_t loc = gimple_location (stmt2);"}, {"sha": "070c707fdaf2a3778a3eee8abcd7d036c9c5b9cb", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -60,15 +60,14 @@ static bool\n vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n \t\t\t      tree vectype, unsigned HOST_WIDE_INT count)\n {\n-  machine_mode mode, array_mode;\n+  machine_mode mode;\n+  scalar_int_mode array_mode;\n   bool limit_p;\n \n   mode = TYPE_MODE (vectype);\n   limit_p = !targetm.array_mode_supported_p (mode, count);\n-  array_mode = mode_for_size (count * GET_MODE_BITSIZE (mode),\n-\t\t\t      MODE_INT, limit_p);\n-\n-  if (array_mode == BLKmode)\n+  if (!int_mode_for_size (count * GET_MODE_BITSIZE (mode),\n+\t\t\t  limit_p).exists (&array_mode))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "e88a58fd0b20408a75d5e4f599455e3c1046e207", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -288,7 +288,6 @@ expand_vector_parallel (gimple_stmt_iterator *gsi, elem_op_func f, tree type,\n \t\t\tenum tree_code code)\n {\n   tree result, compute_type;\n-  machine_mode mode;\n   int n_words = tree_to_uhwi (TYPE_SIZE_UNIT (type)) / UNITS_PER_WORD;\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n \n@@ -312,7 +311,8 @@ expand_vector_parallel (gimple_stmt_iterator *gsi, elem_op_func f, tree type,\n   else\n     {\n       /* Use a single scalar operation with a mode no wider than word_mode.  */\n-      mode = mode_for_size (tree_to_uhwi (TYPE_SIZE (type)), MODE_INT, 0);\n+      scalar_int_mode mode\n+\t= int_mode_for_size (tree_to_uhwi (TYPE_SIZE (type)), 0).require ();\n       compute_type = lang_hooks.types.type_for_mode (mode, 1);\n       result = f (gsi, compute_type, a, b, NULL_TREE, NULL_TREE, code, type);\n       warning_at (loc, OPT_Wvector_operation_performance,"}, {"sha": "3d5e6ada2e4822b3e065d5782d0a20935e087f95", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -6040,7 +6040,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t     supported.  */\n \t\t  unsigned lsize\n \t\t    = group_size * GET_MODE_BITSIZE (elmode);\n-\t\t  elmode = mode_for_size (lsize, MODE_INT, 0);\n+\t\t  elmode = int_mode_for_size (lsize, 0).require ();\n \t\t  vmode = mode_for_vector (elmode, nunits / group_size);\n \t\t  /* If we can't construct such a vector fall back to\n \t\t     element extracts from the original vector type and\n@@ -7086,7 +7086,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t     to a larger load.  */\n \t\t  unsigned lsize\n \t\t    = group_size * TYPE_PRECISION (TREE_TYPE (vectype));\n-\t\t  elmode = mode_for_size (lsize, MODE_INT, 0);\n+\t\t  elmode = int_mode_for_size (lsize, 0).require ();\n \t\t  vmode = mode_for_vector (elmode, nunits / group_size);\n \t\t  /* If we can't construct such a vector fall back to\n \t\t     element loads of the original vector type.  */"}, {"sha": "cbb770f66938d2c4fc8bcaea2fcd31f468504793", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffbab82e7fd15ef695159746a0ce7b9ac906778/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fffbab82e7fd15ef695159746a0ce7b9ac906778", "patch": "@@ -12639,10 +12639,11 @@ vector_type_mode (const_tree t)\n       /* For integers, try mapping it to a same-sized scalar mode.  */\n       if (GET_MODE_CLASS (innermode) == MODE_INT)\n \t{\n-\t  mode = mode_for_size (TYPE_VECTOR_SUBPARTS (t)\n-\t\t\t\t* GET_MODE_BITSIZE (innermode), MODE_INT, 0);\n-\n-\t  if (mode != VOIDmode && have_regs_of_mode[mode])\n+\t  unsigned int size = (TYPE_VECTOR_SUBPARTS (t)\n+\t\t\t       * GET_MODE_BITSIZE (innermode));\n+\t  scalar_int_mode mode;\n+\t  if (int_mode_for_size (size, 0).exists (&mode)\n+\t      && have_regs_of_mode[mode])\n \t    return mode;\n \t}\n "}]}