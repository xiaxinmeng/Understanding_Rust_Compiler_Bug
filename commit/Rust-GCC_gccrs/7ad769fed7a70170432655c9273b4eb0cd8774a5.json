{"sha": "7ad769fed7a70170432655c9273b4eb0cd8774a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FkNzY5ZmVkN2E3MDE3MDQzMjY1NWM5MjczYjRlYjBjZDg3NzRhNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-09-02T18:40:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-09-02T18:40:47Z"}, "message": "mips.c (mips_classify_symbol, [...]): (mips_restore_gp, mips_set_return_address, mips_expand_prologue)\n\n\t* config/mips/mips.c (mips_classify_symbol, mips_fetch_insns):\n\t(mips_restore_gp, mips_set_return_address, mips_expand_prologue)\n\t(mips16_fp_args, mips_avoid_hazard): Replace abort with gcc_assert.\n\t(build_mips16_call_stub): Likewise.  Remove daft CALL_INSN checks.\n\t(mips_issue_rate): Remove unreachable abort.\n\t(mips_symbolic_constant_p, mips_symbolic_address_p, mips_symbol_insns)\n\t(mips_output_move, mips_relational_operand_ok_p, mips_arg_info)\n\t(mips_block_move_straight, print_operand_address, mips_file_start)\n\t(mips_initial_elimination_offset, mips16_fp_args, dump_constants_1)\n\t(mips_output_conditional_branch, mips_expand_builtin_direct)\n\t(mips_expand_builtin_compare): Replace abort with gcc_unreachable.\n\t* config/mips/mips.md (rotr<mode>3, consttable_float): Replace abort\n\twith gcc_assert.\n\nFrom-SVN: r86977", "tree": {"sha": "98be89e8f35e8e2caef6b141ddb9a78e958750a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98be89e8f35e8e2caef6b141ddb9a78e958750a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ad769fed7a70170432655c9273b4eb0cd8774a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad769fed7a70170432655c9273b4eb0cd8774a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ad769fed7a70170432655c9273b4eb0cd8774a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad769fed7a70170432655c9273b4eb0cd8774a5/comments", "author": null, "committer": null, "parents": [{"sha": "4c97f95a5b31d4ab0826bfb8af36fbcf9e6a4098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c97f95a5b31d4ab0826bfb8af36fbcf9e6a4098", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c97f95a5b31d4ab0826bfb8af36fbcf9e6a4098"}], "stats": {"total": 96, "additions": 46, "deletions": 50}, "files": [{"sha": "28617588d479cf103277eeab8aab085c817fed99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad769fed7a70170432655c9273b4eb0cd8774a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad769fed7a70170432655c9273b4eb0cd8774a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ad769fed7a70170432655c9273b4eb0cd8774a5", "patch": "@@ -1,3 +1,19 @@\n+2004-09-02  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_classify_symbol, mips_fetch_insns):\n+\t(mips_restore_gp, mips_set_return_address, mips_expand_prologue)\n+\t(mips16_fp_args, mips_avoid_hazard): Replace abort with gcc_assert.\n+\t(build_mips16_call_stub): Likewise.  Remove daft CALL_INSN checks.\n+\t(mips_issue_rate): Remove unreachable abort.\n+\t(mips_symbolic_constant_p, mips_symbolic_address_p, mips_symbol_insns)\n+\t(mips_output_move, mips_relational_operand_ok_p, mips_arg_info)\n+\t(mips_block_move_straight, print_operand_address, mips_file_start)\n+\t(mips_initial_elimination_offset, mips16_fp_args, dump_constants_1)\n+\t(mips_output_conditional_branch, mips_expand_builtin_direct)\n+\t(mips_expand_builtin_compare): Replace abort with gcc_unreachable.\n+\t* config/mips/mips.md (rotr<mode>3, consttable_float): Replace abort\n+\twith gcc_assert.\n+\n 2004-09-02  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (*lea_high64): Change split condition to"}, {"sha": "5f7e149e167a7bc9c531225e489a7f34995f5872", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad769fed7a70170432655c9273b4eb0cd8774a5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad769fed7a70170432655c9273b4eb0cd8774a5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7ad769fed7a70170432655c9273b4eb0cd8774a5", "patch": "@@ -810,8 +810,7 @@ mips_classify_symbol (rtx x)\n       return SYMBOL_GENERAL;\n     }\n \n-  if (GET_CODE (x) != SYMBOL_REF)\n-    abort ();\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n \n   if (CONSTANT_POOL_ADDRESS_P (x))\n     {\n@@ -973,7 +972,7 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n     case SYMBOL_GOTOFF_LOADGP:\n       return false;\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n \n@@ -1077,7 +1076,7 @@ mips_symbolic_address_p (enum mips_symbol_type symbol_type,\n     case SYMBOL_64_LOW:\n       return true;\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n \n@@ -1204,7 +1203,7 @@ mips_symbol_insns (enum mips_symbol_type type)\n       /* Check whether the offset is a 16- or 32-bit value.  */\n       return mips_split_p[type] ? 2 : 1;\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Return true if X is a legitimate $sp-based address for mode MDOE.  */\n@@ -1362,9 +1361,7 @@ mips_const_insns (rtx x)\n int\n mips_fetch_insns (rtx x)\n {\n-  if (GET_CODE (x) != MEM)\n-    abort ();\n-\n+  gcc_assert (GET_CODE (x) == MEM);\n   return mips_address_insns (XEXP (x, 0), GET_MODE (x));\n }\n \n@@ -2407,7 +2404,7 @@ mips_output_move (rtx dest, rtx src)\n       retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (REGNO (src));\n       return retval;\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \f\n /* Restore $gp from its save slot.  Valid only when using o32 or\n@@ -2418,8 +2415,7 @@ mips_restore_gp (void)\n {\n   rtx address, slot;\n \n-  if (!TARGET_ABICALLS || !TARGET_OLDABI)\n-    abort ();\n+  gcc_assert (TARGET_ABICALLS && TARGET_OLDABI);\n \n   address = mips_add_offset (pic_offset_table_rtx,\n \t\t\t     frame_pointer_needed\n@@ -2469,7 +2465,7 @@ mips_relational_operand_ok_p (enum rtx_code code, rtx cmp1)\n       return sleu_operand (cmp1, VOIDmode);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2839,8 +2835,7 @@ mips_set_return_address (rtx address, rtx scratch)\n   rtx slot_address;\n \n   compute_frame_size (get_frame_size ());\n-  if (((cfun->machine->frame.mask >> 31) & 1) == 0)\n-    abort ();\n+  gcc_assert ((cfun->machine->frame.mask >> 31) & 1);\n   slot_address = mips_add_offset (scratch, stack_pointer_rtx,\n \t\t\t\t  cfun->machine->frame.gp_sp_offset);\n \n@@ -2887,7 +2882,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n \t{\n \t  rtx part = adjust_address (src, BLKmode, offset);\n \t  if (!mips_expand_unaligned_load (regs[i], part, bits, 0))\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n     }\n \n@@ -2899,7 +2894,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n       {\n \trtx part = adjust_address (dest, BLKmode, offset);\n \tif (!mips_expand_unaligned_store (part, regs[i], bits, 0))\n-\t  abort ();\n+\t  gcc_unreachable ();\n       }\n \n   /* Mop up any left-over bytes.  */\n@@ -3115,7 +3110,7 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Now decide whether the argument must go in an even-numbered register.\n@@ -4998,7 +4993,7 @@ print_operand_address (FILE *file, rtx x)\n \toutput_addr_const (file, x);\n \treturn;\n       }\n-  abort ();\n+  gcc_unreachable ();\n }\n \f\n /* When using assembler macros, keep track of all of small-data externs\n@@ -5215,7 +5210,7 @@ mips_file_start (void)\n \tcase ABI_O64:  abi_string = \"abiO64\"; break;\n \tcase ABI_EABI: abi_string = TARGET_64BIT ? \"eabi64\" : \"eabi32\"; break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       /* Note - we use fprintf directly rather than called named_section()\n \t because in this way we can avoid creating an allocated section.  We\n@@ -5845,7 +5840,7 @@ mips_initial_elimination_offset (int from, int to)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (TARGET_MIPS16 && to == HARD_FRAME_POINTER_REGNUM)\n@@ -6155,9 +6150,7 @@ mips_expand_prologue (void)\n \t\t from the stack pointer, so use the frame pointer as a\n \t\t temporary.  We should always be using a frame pointer\n \t\t in this case anyway.  */\n-\t      if (!frame_pointer_needed)\n-\t\tabort ();\n-\n+\t      gcc_assert (frame_pointer_needed);\n \t      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n \t      emit_insn (gen_sub3_insn (hard_frame_pointer_rtx,\n \t\t\t\t\thard_frame_pointer_rtx,\n@@ -7088,8 +7081,7 @@ mips16_fp_args (FILE *file, int fp_code, int from_fp_p)\n   unsigned int f;\n \n   /* This code only works for the original 32 bit ABI and the O64 ABI.  */\n-  if (!TARGET_OLDABI)\n-    abort ();\n+  gcc_assert (TARGET_OLDABI);\n \n   if (from_fp_p)\n     s = \"mfc1\";\n@@ -7128,7 +7120,7 @@ mips16_fp_args (FILE *file, int fp_code, int from_fp_p)\n \t    }\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       ++gparg;\n       ++fparg;\n@@ -7285,13 +7277,12 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \n   /* This code will only work for o32 and o64 abis.  The other ABI's\n      require more sophisticated support.  */\n-  if (!TARGET_OLDABI)\n-    abort ();\n+  gcc_assert (TARGET_OLDABI);\n \n   /* We can only handle SFmode and DFmode floating point return\n      values.  */\n-  if (fpret && GET_MODE (retval) != SFmode && GET_MODE (retval) != DFmode)\n-    abort ();\n+  if (fpret)\n+    gcc_assert (GET_MODE (retval) == SFmode || GET_MODE (retval) == DFmode);\n \n   /* If we're calling via a function pointer, then we must always call\n      via a stub.  There are magic stubs provided in libgcc.a for each\n@@ -7324,8 +7315,6 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n       insn = emit_call_insn (insn);\n \n       /* Put the register usage information on the CALL.  */\n-      if (GET_CODE (insn) != CALL_INSN)\n-\tabort ();\n       CALL_INSN_FUNCTION_USAGE (insn) =\n \tgen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t   gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 2)),\n@@ -7526,9 +7515,6 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \tinsn = gen_call_value_internal (retval, fn, arg_size);\n       insn = emit_call_insn (insn);\n \n-      if (GET_CODE (insn) != CALL_INSN)\n-\tabort ();\n-\n       CALL_INSN_FUNCTION_USAGE (insn) =\n \tgen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t   gen_rtx_USE (VOIDmode, gen_rtx_REG (word_mode, 18)),\n@@ -7648,7 +7634,7 @@ dump_constants_1 (enum machine_mode mode, rtx value, rtx insn)\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -8211,8 +8197,7 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n \n       case HAZARD_DELAY:\n \tset = single_set (insn);\n-\tif (set == 0)\n-\t  abort ();\n+\tgcc_assert (set != 0);\n \t*delayed_reg = SET_DEST (set);\n \tbreak;\n       }\n@@ -8706,7 +8691,7 @@ mips_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* NOTREACHED */\n@@ -9241,9 +9226,6 @@ mips_issue_rate (void)\n     default:\n       return 1;\n     }\n-\n-  abort ();\n-\n }\n \n /* Implements TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD.  This should\n@@ -9591,7 +9573,7 @@ mips_expand_builtin_direct (enum insn_code icode, rtx target, tree arglist)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return target;\n }\n@@ -9665,7 +9647,7 @@ mips_expand_builtin_compare (enum mips_builtin_type builtin_type,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If the comparison sets more than one register, we define the result"}, {"sha": "df32a546d6ccf5609e0a4d06b78adbfecf53b235", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad769fed7a70170432655c9273b4eb0cd8774a5/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad769fed7a70170432655c9273b4eb0cd8774a5/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=7ad769fed7a70170432655c9273b4eb0cd8774a5", "patch": "@@ -4272,10 +4272,9 @@ beq\\t%2,%.,1b\\;\\\n \t\t      (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n   \"ISA_HAS_ROTR_<MODE>\"\n {\n-  if ((GET_CODE (operands[2]) == CONST_INT)\n-      && (INTVAL (operands[2]) < 0\n-\t  || INTVAL (operands[2]) >= GET_MODE_BITSIZE (<MODE>mode)))\n-    abort ();\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    gcc_assert (INTVAL (operands[2]) >= 0\n+\t\t&& INTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode));\n \n   return \"<d>ror\\t%0,%1,%2\";\n }\n@@ -5479,8 +5478,7 @@ beq\\t%2,%.,1b\\;\\\n {\n   REAL_VALUE_TYPE d;\n \n-  if (GET_CODE (operands[0]) != CONST_DOUBLE)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == CONST_DOUBLE);\n   REAL_VALUE_FROM_CONST_DOUBLE (d, operands[0]);\n   assemble_real (d, GET_MODE (operands[0]),\n \t\t GET_MODE_BITSIZE (GET_MODE (operands[0])));"}]}