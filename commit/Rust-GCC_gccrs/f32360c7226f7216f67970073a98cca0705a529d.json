{"sha": "f32360c7226f7216f67970073a98cca0705a529d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMyMzYwYzcyMjZmNzIxNmY2Nzk3MDA3M2E5OGNjYTA3MDVhNTI5ZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2003-04-09T18:50:03Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-04-09T18:50:03Z"}, "message": "ia64.c (issue_nops_and_insn): Add new parameter.\n\n2003-04-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* config/ia64/ia64.c (issue_nops_and_insn): Add new parameter.\n\tCheck that asm insn starts on a new cycle.  Add nops after asm\n\tinsn to end bundle.\n\t(bundling): Move insn type evaluation from the loop.  Call\n\tissue_nops_and_insn with the new parameter.  Ignore changing\n\tposition for nops after asm insn.\n\nFrom-SVN: r65401", "tree": {"sha": "3942bd88d857980010d227c303951b270c597edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3942bd88d857980010d227c303951b270c597edb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f32360c7226f7216f67970073a98cca0705a529d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32360c7226f7216f67970073a98cca0705a529d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32360c7226f7216f67970073a98cca0705a529d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32360c7226f7216f67970073a98cca0705a529d/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0913e4b49e38718e767bc4e4575a8271ee484efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0913e4b49e38718e767bc4e4575a8271ee484efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0913e4b49e38718e767bc4e4575a8271ee484efb"}], "stats": {"total": 106, "additions": 68, "deletions": 38}, "files": [{"sha": "21a0249031543e3ee1a970c600d55c152de09a6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32360c7226f7216f67970073a98cca0705a529d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32360c7226f7216f67970073a98cca0705a529d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f32360c7226f7216f67970073a98cca0705a529d", "patch": "@@ -1,3 +1,12 @@\n+2003-04-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.c (issue_nops_and_insn): Add new parameter.\n+\tCheck that asm insn starts on a new cycle.  Add nops after asm\n+\tinsn to end bundle.\n+\t(bundling): Move insn type evaluation from the loop.  Call\n+\tissue_nops_and_insn with the new parameter.  Ignore changing\n+\tposition for nops after asm insn.\n+\n 2003-04-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* optabs.c: Comment that gen_add2_insn and others may actually"}, {"sha": "bbcd90dcae0d1fb82dccf54046f3aec36d279280", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 59, "deletions": 38, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32360c7226f7216f67970073a98cca0705a529d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32360c7226f7216f67970073a98cca0705a529d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f32360c7226f7216f67970073a98cca0705a529d", "patch": "@@ -230,7 +230,7 @@ static void finish_bundle_state_table PARAMS ((void));\n static int try_issue_nops PARAMS ((struct bundle_state *, int));\n static int try_issue_insn PARAMS ((struct bundle_state *, rtx));\n static void issue_nops_and_insn PARAMS ((struct bundle_state *, int,\n-\t\t\t\t\t rtx, int));\n+\t\t\t\t\t rtx, int, int));\n static int get_max_pos PARAMS ((state_t));\n static int get_template PARAMS ((state_t, int));\n \n@@ -6316,17 +6316,18 @@ try_issue_insn (curr_state, insn)\n \n /* The following function tries to issue BEFORE_NOPS_NUM nops and INSN\n    starting with ORIGINATOR without advancing processor cycle.  If\n-   TRY_BUNDLE_END_P is TRUE, the function also tries to issue nops to\n-   fill all bundle. If it was successful, the function creates new\n-   bundle state and insert into the hash table and into\n-   `index_to_bundle_states'.  */\n+   TRY_BUNDLE_END_P is TRUE, the function also/only (if\n+   ONLY_BUNDLE_END_P is TRUE) tries to issue nops to fill all bundle.\n+   If it was successful, the function creates new bundle state and\n+   insert into the hash table and into `index_to_bundle_states'.  */\n \n static void\n-issue_nops_and_insn (originator, before_nops_num, insn, try_bundle_end_p)\n+issue_nops_and_insn (originator, before_nops_num, insn, try_bundle_end_p,\n+\t\t     only_bundle_end_p)\n      struct bundle_state *originator;\n      int before_nops_num;\n      rtx insn;\n-     int try_bundle_end_p;\n+     int try_bundle_end_p, only_bundle_end_p;\n {\n   struct bundle_state *curr_state;\n \n@@ -6365,9 +6366,10 @@ issue_nops_and_insn (originator, before_nops_num, insn, try_bundle_end_p)\n \treturn;\n       if (!try_issue_insn (curr_state, insn))\n \treturn;\n-      if (GET_CODE (PATTERN (insn)) != ASM_INPUT\n-\t  && asm_noperands (PATTERN (insn)) < 0)\n-\tcurr_state->accumulated_insns_num++;\n+      curr_state->accumulated_insns_num++;\n+      if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t  || asm_noperands (PATTERN (insn)) >= 0)\n+\tabort ();\n       if (ia64_safe_type (insn) == TYPE_L)\n \tcurr_state->accumulated_insns_num++;\n     }\n@@ -6380,18 +6382,25 @@ issue_nops_and_insn (originator, before_nops_num, insn, try_bundle_end_p)\n \treturn;\n       if (!try_issue_insn (curr_state, insn))\n \treturn;\n-      if (GET_CODE (PATTERN (insn)) != ASM_INPUT\n-\t  && asm_noperands (PATTERN (insn)) < 0)\n-\tcurr_state->accumulated_insns_num++;\n-      if (ia64_safe_type (insn) == TYPE_L)\n+      curr_state->accumulated_insns_num++;\n+      if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t  || asm_noperands (PATTERN (insn)) >= 0)\n+\t{\n+\t  /* Finish bundle containing asm insn.  */\n+\t  curr_state->after_nops_num\n+\t    = 3 - curr_state->accumulated_insns_num % 3;\n+\t  curr_state->accumulated_insns_num\n+\t    += 3 - curr_state->accumulated_insns_num % 3;\n+\t}\n+      else if (ia64_safe_type (insn) == TYPE_L)\n \tcurr_state->accumulated_insns_num++;\n     }\n   if (ia64_safe_type (insn) == TYPE_B)\n     curr_state->branch_deviation\n       += 2 - (curr_state->accumulated_insns_num - 1) % 3;\n   if (try_bundle_end_p && curr_state->accumulated_insns_num % 3 != 0)\n     {\n-      if (insert_bundle_state (curr_state))\n+      if (!only_bundle_end_p && insert_bundle_state (curr_state))\n \t{\n \t  state_t dfa_state;\n \t  struct bundle_state *curr_state1;\n@@ -6538,7 +6547,7 @@ bundling (dump, verbose, prev_head_insn, tail)\n   struct bundle_state *curr_state, *next_state, *best_state;\n   rtx insn, next_insn;\n   int insn_num;\n-  int i, bundle_end_p;\n+  int i, bundle_end_p, only_bundle_end_p, asm_p;\n   int pos, max_pos, template0, template1;\n   rtx b;\n   rtx nop;\n@@ -6602,6 +6611,7 @@ bundling (dump, verbose, prev_head_insn, tail)\n \t  || GET_CODE (PATTERN (insn)) == USE\n \t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n \tabort ();\n+      type = ia64_safe_type (insn);\n       next_insn = get_next_important_insn (NEXT_INSN (insn), tail);\n       insn_num++;\n       index_to_bundle_states [insn_num] = NULL;\n@@ -6610,20 +6620,28 @@ bundling (dump, verbose, prev_head_insn, tail)\n \t   curr_state = next_state)\n \t{\n \t  pos = curr_state->accumulated_insns_num % 3;\n-\t  type = ia64_safe_type (insn);\n \t  next_state = curr_state->next;\n+\t  /* Finish the current bundle in order to start a subsequent\n+\t     asm insn in a new bundle.  */\n+\t  only_bundle_end_p\n+\t    = (next_insn != NULL_RTX\n+\t       && INSN_CODE (insn) == CODE_FOR_insn_group_barrier\n+\t       && ia64_safe_type (next_insn) == TYPE_UNKNOWN);\n \t  bundle_end_p\n-\t    = (next_insn == NULL_RTX\n+\t    = (only_bundle_end_p || next_insn == NULL_RTX\n \t       || (GET_MODE (next_insn) == TImode\n \t\t   && INSN_CODE (insn) != CODE_FOR_insn_group_barrier));\n \t  if (type == TYPE_F || type == TYPE_B || type == TYPE_L\n \t      || type == TYPE_S\n \t      /* We need to insert 2 Nops for cases like M_MII.  */\n \t      || (type == TYPE_M && ia64_tune == PROCESSOR_ITANIUM\n \t\t  && !bundle_end_p && pos == 1))\n-\t    issue_nops_and_insn (curr_state, 2, insn, bundle_end_p);\n-\t  issue_nops_and_insn (curr_state, 1, insn, bundle_end_p);\n-\t  issue_nops_and_insn (curr_state, 0, insn, bundle_end_p);\n+\t    issue_nops_and_insn (curr_state, 2, insn, bundle_end_p,\n+\t\t\t\t only_bundle_end_p);\n+\t  issue_nops_and_insn (curr_state, 1, insn, bundle_end_p,\n+\t\t\t       only_bundle_end_p);\n+\t  issue_nops_and_insn (curr_state, 0, insn, bundle_end_p,\n+\t\t\t       only_bundle_end_p);\n \t}\n       if (index_to_bundle_states [insn_num] == NULL)\n \tabort ();\n@@ -6680,6 +6698,8 @@ bundling (dump, verbose, prev_head_insn, tail)\n        curr_state = curr_state->originator)\n     {\n       insn = curr_state->insn;\n+      asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t       || asm_noperands (PATTERN (insn)) >= 0);\n       insn_num++;\n       if (verbose >= 2 && dump)\n \t{\n@@ -6724,23 +6744,24 @@ bundling (dump, verbose, prev_head_insn, tail)\n \t  template1 = get_template (curr_state->dfa_state, 3);\n \t  pos += 3;\n \t}\n-      for (i = 0; i < curr_state->after_nops_num; i++)\n-\t{\n-\t  nop = gen_nop ();\n-\t  emit_insn_after (nop, insn);\n-\t  pos--;\n-\t  if (pos < 0)\n-\t    abort ();\n-\t  if (pos % 3 == 0)\n-\t    {\n-\t      if (template0 < 0)\n-\t\tabort ();\n-\t      b = gen_bundle_selector (GEN_INT (template0));\n-\t      ia64_emit_insn_before (b, nop);\n-\t      template0 = template1;\n-\t      template1 = -1;\n-\t    }\n-\t}\n+      if (!asm_p)\n+\tfor (i = 0; i < curr_state->after_nops_num; i++)\n+\t  {\n+\t    nop = gen_nop ();\n+\t    emit_insn_after (nop, insn);\n+\t    pos--;\n+\t    if (pos < 0)\n+\t      abort ();\n+\t    if (pos % 3 == 0)\n+\t      {\n+\t\tif (template0 < 0)\n+\t\t  abort ();\n+\t\tb = gen_bundle_selector (GEN_INT (template0));\n+\t\tia64_emit_insn_before (b, nop);\n+\t\ttemplate0 = template1;\n+\t\ttemplate1 = -1;\n+\t      }\n+\t  }\n       if (INSN_CODE (insn) != CODE_FOR_insn_group_barrier\n \t  && GET_CODE (PATTERN (insn)) != ASM_INPUT\n \t  && asm_noperands (PATTERN (insn)) < 0)"}]}