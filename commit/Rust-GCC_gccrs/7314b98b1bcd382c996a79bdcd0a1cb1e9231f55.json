{"sha": "7314b98b1bcd382c996a79bdcd0a1cb1e9231f55", "node_id": "C_kwDOANBUbNoAKDczMTRiOThiMWJjZDM4MmM5OTZhNzliZGNkMGExY2IxZTkyMzFmNTU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-27T08:16:52Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-11-07T08:59:26Z"}, "message": "unswitch most profitable condition first\n\nWhen doing the loop unswitching re-org we promised to followup\nwith improvements on the cost modeling.  The following makes sure we\ntry to unswitch on the most profitable condition first.  As most profitable\nwe pick the condition leading to the edge with the highest profile count.\n\nNote the profile is only applied when picking the first unswitching\nopportunity since the profile counts are not updated with earlier\nunswitchings in mind.  Further opportunities are picked in DFS order.\n\n\t* tree-ssa-loop-unswitch.cc (unswitch_predicate::count): New.\n\t(unswitch_predicate::unswitch_predicate): Initialize count.\n\t(init_loop_unswitch_info): First collect candidates and\n\tdetermine the outermost loop to unswitch.\n\t(tree_ssa_unswitch_loops): First perform all guard hoisting,\n\tthen perform unswitching on innermost loop predicates.\n\t(find_unswitching_predicates_for_bb): Keep track of the\n\tmost profitable predicate to unswitch on.\n\t(tree_unswitch_single_loop): Unswitch given predicate if\n\tnot NULL.", "tree": {"sha": "043054286439775617248db7b0273c3741fba8ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/043054286439775617248db7b0273c3741fba8ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7314b98b1bcd382c996a79bdcd0a1cb1e9231f55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7314b98b1bcd382c996a79bdcd0a1cb1e9231f55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7314b98b1bcd382c996a79bdcd0a1cb1e9231f55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7314b98b1bcd382c996a79bdcd0a1cb1e9231f55/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8fb90eb3949bfb101bd6f50f24a029e10119591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fb90eb3949bfb101bd6f50f24a029e10119591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8fb90eb3949bfb101bd6f50f24a029e10119591"}], "stats": {"total": 66, "additions": 54, "deletions": 12}, "files": [{"sha": "dfe75f52f12a6c006affcf0a58c98b997edc5a7d", "filename": "gcc/tree-ssa-loop-unswitch.cc", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7314b98b1bcd382c996a79bdcd0a1cb1e9231f55/gcc%2Ftree-ssa-loop-unswitch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7314b98b1bcd382c996a79bdcd0a1cb1e9231f55/gcc%2Ftree-ssa-loop-unswitch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.cc?ref=7314b98b1bcd382c996a79bdcd0a1cb1e9231f55", "patch": "@@ -118,6 +118,7 @@ struct unswitch_predicate\n     if (!false_range.varying_p ()\n \t&& !false_range.undefined_p ())\n       false_range.invert ();\n+    count = e->count ();\n     num = predicates->length ();\n     predicates->safe_push (this);\n   }\n@@ -126,14 +127,16 @@ struct unswitch_predicate\n   unswitch_predicate (gcond *stmt)\n     : switch_p (false)\n   {\n-    if (EDGE_SUCC (gimple_bb (stmt), 0)->flags & EDGE_TRUE_VALUE)\n+    basic_block bb = gimple_bb (stmt);\n+    if (EDGE_SUCC (bb, 0)->flags & EDGE_TRUE_VALUE)\n       edge_index = 0;\n     else\n       edge_index = 1;\n     lhs = gimple_cond_lhs (stmt);\n     tree rhs = gimple_cond_rhs (stmt);\n     enum tree_code code = gimple_cond_code (stmt);\n     condition = build2 (code, boolean_type_node, lhs, rhs);\n+    count = EDGE_SUCC (bb, 0)->count ().max (EDGE_SUCC (bb, 1)->count ());\n     if (irange::supports_p (TREE_TYPE (lhs)))\n       {\n \tauto range_op = range_op_handler (code, TREE_TYPE (lhs));\n@@ -180,6 +183,9 @@ struct unswitch_predicate\n   /* Index of the edge the predicate belongs to in the successor vector.  */\n   int edge_index;\n \n+  /* The profile count of this predicate.  */\n+  profile_count count;\n+\n   /* Whether the predicate was created from a switch statement.  */\n   bool switch_p;\n \n@@ -206,10 +212,14 @@ static class loop *tree_unswitch_loop (class loop *, edge, tree);\n static bool tree_unswitch_single_loop (class loop *, dump_user_location_t,\n \t\t\t\t       predicate_vector &predicate_path,\n \t\t\t\t       unsigned loop_size, unsigned &budget,\n-\t\t\t\t       int ignored_edge_flag, bitmap);\n+\t\t\t\t       int ignored_edge_flag, bitmap,\n+\t\t\t\t       unswitch_predicate * = NULL,\n+\t\t\t\t       basic_block = NULL);\n static void\n find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n-\t\t\t\t    vec<unswitch_predicate *> &candidates);\n+\t\t\t\t    vec<unswitch_predicate *> &candidates,\n+\t\t\t\t    unswitch_predicate *&hottest,\n+\t\t\t\t    basic_block &hottest_bb);\n static bool tree_unswitch_outer_loop (class loop *);\n static edge find_loop_guard (class loop *, vec<gimple *>&);\n static bool empty_bb_without_guard_p (class loop *, basic_block,\n@@ -242,7 +252,8 @@ set_predicates_for_bb (basic_block bb, vec<unswitch_predicate *> predicates)\n    Return total number of instructions in the loop.  */\n \n static unsigned\n-init_loop_unswitch_info (class loop *loop)\n+init_loop_unswitch_info (class loop *loop, unswitch_predicate *&hottest,\n+\t\t\t basic_block &hottest_bb)\n {\n   unsigned total_insns = 0;\n \n@@ -259,13 +270,16 @@ init_loop_unswitch_info (class loop *loop)\n       total_insns += insns;\n     }\n \n+  hottest = NULL;\n+  hottest_bb = NULL;\n   /* Find all unswitching candidates.  */\n   for (unsigned i = 0; i != loop->num_nodes; i++)\n     {\n       /* Find a bb to unswitch on.  */\n       vec<unswitch_predicate *> candidates;\n       candidates.create (1);\n-      find_unswitching_predicates_for_bb (bbs[i], loop, candidates);\n+      find_unswitching_predicates_for_bb (bbs[i], loop, candidates,\n+\t\t\t\t\t  hottest, hottest_bb);\n       if (!candidates.is_empty ())\n \tset_predicates_for_bb (bbs[i], candidates);\n       else\n@@ -329,7 +343,10 @@ tree_ssa_unswitch_loops (function *fun)\n \t  unswitch_predicate::predicates = new vec<unswitch_predicate *> ();\n \n \t  /* Unswitch innermost loop.  */\n-\t  unsigned int loop_size = init_loop_unswitch_info (loop);\n+\t  unswitch_predicate *hottest;\n+\t  basic_block hottest_bb;\n+\t  unsigned int loop_size = init_loop_unswitch_info (loop, hottest,\n+\t\t\t\t\t\t\t    hottest_bb);\n \t  unsigned int budget = loop_size + param_max_unswitch_insns;\n \n \t  predicate_vector predicate_path;\n@@ -338,7 +355,8 @@ tree_ssa_unswitch_loops (function *fun)\n \t  changed_unswitch\n \t    |= tree_unswitch_single_loop (loop, loc, predicate_path,\n \t\t\t\t\t  loop_size, budget,\n-\t\t\t\t\t  ignored_edge_flag, handled);\n+\t\t\t\t\t  ignored_edge_flag, handled,\n+\t\t\t\t\t  hottest, hottest_bb);\n \t  predicate_path.release ();\n \n \t  for (auto predlist : bb_predicates)\n@@ -449,7 +467,9 @@ is_maybe_undefined (const tree name, gimple *stmt, class loop *loop)\n \n static void\n find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n-\t\t\t\t    vec<unswitch_predicate *> &candidates)\n+\t\t\t\t    vec<unswitch_predicate *> &candidates,\n+\t\t\t\t    unswitch_predicate *&hottest,\n+\t\t\t\t    basic_block &hottest_bb)\n {\n   gimple *last, *def;\n   tree use;\n@@ -489,6 +509,14 @@ find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n \n       unswitch_predicate *predicate = new unswitch_predicate (stmt);\n       candidates.safe_push (predicate);\n+      /* If we unswitch on this predicate we isolate both paths, so\n+\t pick the highest count for updating of the hottest predicate\n+\t to unswitch on first.  */\n+      if (!hottest || predicate->count > hottest->count)\n+\t{\n+\t  hottest = predicate;\n+\t  hottest_bb = bb;\n+\t}\n     }\n   else if (gswitch *stmt = safe_dyn_cast <gswitch *> (last))\n     {\n@@ -561,6 +589,11 @@ find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n \t\t\t\t\t  edge_index, e,\n \t\t\t\t\t  edge_range[edge_index]);\n \t      candidates.safe_push (predicate);\n+\t      if (!hottest || predicate->count > hottest->count)\n+\t\t{\n+\t\t  hottest = predicate;\n+\t\t  hottest_bb = bb;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -888,13 +921,15 @@ evaluate_loop_insns_for_predicate (class loop *loop,\n \n /* Unswitch single LOOP.  PREDICATE_PATH contains so far used predicates\n    for unswitching.  BUDGET is number of instruction for which we can increase\n-   the loop and is updated when unswitching occurs.  */\n+   the loop and is updated when unswitching occurs.  If HOTTEST is not\n+   NULL then pick this candidate as the one to unswitch on.  */\n \n static bool\n tree_unswitch_single_loop (class loop *loop, dump_user_location_t loc,\n \t\t\t   predicate_vector &predicate_path,\n \t\t\t   unsigned loop_size, unsigned &budget,\n-\t\t\t   int ignored_edge_flag, bitmap handled)\n+\t\t\t   int ignored_edge_flag, bitmap handled,\n+\t\t\t   unswitch_predicate *hottest, basic_block hottest_bb)\n {\n   class loop *nloop;\n   bool changed = false;\n@@ -939,8 +974,15 @@ tree_unswitch_single_loop (class loop *loop, dump_user_location_t loc,\n \t}\n       return false;\n     };\n-  /* Check predicates of reachable blocks.  */\n-  evaluate_bbs (loop, NULL, ignored_edge_flag, check_predicates);\n+\n+  if (hottest)\n+    {\n+      predicate = hottest;\n+      predicate_bb = hottest_bb;\n+    }\n+  else\n+    /* Check predicates of reachable blocks.  */\n+    evaluate_bbs (loop, NULL, ignored_edge_flag, check_predicates);\n \n   if (predicate != NULL)\n     {"}]}