{"sha": "4aa74bd346b862ac34704642f0483a057cfe73a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFhNzRiZDM0NmI4NjJhYzM0NzA0NjQyZjA0ODNhMDU3Y2ZlNzNhMw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-11-26T14:33:41Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-11-26T14:33:41Z"}, "message": "2003-11-26  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/DatagramSocket.java\n\t(impl): Made private.\n\t(bound): New private member variable.\n\t(DatagramSocket): Fixed documentation, use getImpl().\n\t(getImpl): New package-private method.\n\t(isClosed): Use getImpl().\n\t(getLocalAddress): Completed documentation, use getImpl().\n\t(getLocalPort): Use getImpl().\n\t(getSoTimeout): Likewise.\n\t(setSoTimeout): Likewise.\n\t(getSendBufferSize): Likewise.\n\t(setSendBufferSize): Likewise.\n\t(getReceiveBufferSize): Likewise.\n\t(setReceiveBufferSize): Likewise.\n\t(connect): Likewise.\n\t(disconnect): Likewise.\n\t(receive): Likewise.\n\t(send): Likewise.\n\t(setReuseAddress): Likewise.\n\t(setTrafficClass): Likewise.\n\t(bind): Added message to exception.\n\t(isClosed): Completed documentation.\n\t(getChannel): Likewise.\n\t(connect): Added missing exception, refined exception message.\n\t(isBound): Completed documentation, just return bound.\n\t(isConnected): Completed documentation.\n\t(getRemoteSocketAddress): Likewise.\n\t(getReuseAddress): Completed documentation, use getImpl().\n\t(setSoBroadcast): Likewise.\n\t(getSoBroadcast): Likewise.\n\t(getTrafficClass): Likewise.\n\t(getLocalSocketAddress): Simplified.\n\t* java/net/MulticastSocket.java\n\t(MulticastSocket): Removed comment not applying anymore.\n\t(getInterface): Use getImpl().\n\t(getTTL): Likewise.\n\t(getTimeToLive): Likewise.\n\t(setInterface): Likewise.\n\t(setNetworkInterface): Likewise.\n\t(getNetworkInterface): Likewise.\n\t(setLoopback): Likewise.\n\t(getLoopback): Likewise.\n\t(setTTL): Likewise.\n\t(setTimeToLive): Likewise.\n\t(joinGroup): Likewise.\n\t(leaveGroup): Likewise.\n\t(send): Likewise.\n\nFrom-SVN: r73951", "tree": {"sha": "6357f88efab2b52d021092786f834f66d4006f2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6357f88efab2b52d021092786f834f66d4006f2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4aa74bd346b862ac34704642f0483a057cfe73a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aa74bd346b862ac34704642f0483a057cfe73a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aa74bd346b862ac34704642f0483a057cfe73a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aa74bd346b862ac34704642f0483a057cfe73a3/comments", "author": null, "committer": null, "parents": [{"sha": "88096b2a59c659f94df962aca5f49d58602bbc8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88096b2a59c659f94df962aca5f49d58602bbc8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88096b2a59c659f94df962aca5f49d58602bbc8a"}], "stats": {"total": 335, "additions": 222, "deletions": 113}, "files": [{"sha": "9d13b76945a2ff1021bd89906297cec792412422", "filename": "libjava/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aa74bd346b862ac34704642f0483a057cfe73a3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aa74bd346b862ac34704642f0483a057cfe73a3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4aa74bd346b862ac34704642f0483a057cfe73a3", "patch": "@@ -1,3 +1,53 @@\n+2003-11-26  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/DatagramSocket.java\n+\t(impl): Made private.\n+\t(bound): New private member variable.\n+\t(DatagramSocket): Fixed documentation, use getImpl().\n+\t(getImpl): New package-private method.\n+\t(isClosed): Use getImpl().\n+\t(getLocalAddress): Completed documentation, use getImpl().\n+\t(getLocalPort): Use getImpl().\n+\t(getSoTimeout): Likewise.\n+\t(setSoTimeout): Likewise.\n+\t(getSendBufferSize): Likewise.\n+\t(setSendBufferSize): Likewise.\n+\t(getReceiveBufferSize): Likewise.\n+\t(setReceiveBufferSize): Likewise.\n+\t(connect): Likewise.\n+\t(disconnect): Likewise.\n+\t(receive): Likewise.\n+\t(send): Likewise.\n+\t(setReuseAddress): Likewise.\n+\t(setTrafficClass): Likewise.\n+\t(bind): Added message to exception.\n+\t(isClosed): Completed documentation.\n+\t(getChannel): Likewise.\n+\t(connect): Added missing exception, refined exception message.\n+\t(isBound): Completed documentation, just return bound.\n+\t(isConnected): Completed documentation.\n+\t(getRemoteSocketAddress): Likewise.\n+\t(getReuseAddress): Completed documentation, use getImpl().\n+\t(setSoBroadcast): Likewise.\n+\t(getSoBroadcast): Likewise.\n+\t(getTrafficClass): Likewise.\n+\t(getLocalSocketAddress): Simplified.\n+\t* java/net/MulticastSocket.java\n+\t(MulticastSocket): Removed comment not applying anymore.\n+\t(getInterface): Use getImpl().\n+\t(getTTL): Likewise.\n+\t(getTimeToLive): Likewise.\n+\t(setInterface): Likewise.\n+\t(setNetworkInterface): Likewise.\n+\t(getNetworkInterface): Likewise.\n+\t(setLoopback): Likewise.\n+\t(getLoopback): Likewise.\n+\t(setTTL): Likewise.\n+\t(setTimeToLive): Likewise.\n+\t(joinGroup): Likewise.\n+\t(leaveGroup): Likewise.\n+\t(send): Likewise.\n+\n 2003-11-26  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/Socket.java"}, {"sha": "df397bf7c612ec962c00f7e5229997a31aefa535", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 149, "deletions": 86, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aa74bd346b862ac34704642f0483a057cfe73a3/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aa74bd346b862ac34704642f0483a057cfe73a3/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=4aa74bd346b862ac34704642f0483a057cfe73a3", "patch": "@@ -72,7 +72,12 @@\n   /**\n    * This is the implementation object used by this socket.\n    */\n-  DatagramSocketImpl impl;\n+  private DatagramSocketImpl impl;\n+\n+  /**\n+   * True if socket implementation was created.\n+   */\n+  private boolean implCreated;\n \n   /**\n    * This is the address we are \"connected\" to\n@@ -84,6 +89,11 @@\n    */\n   private int remotePort = -1;\n \n+  /**\n+   * True if socket is bound.\n+   */\n+  private boolean bound;\n+\n   /**\n    * Creates a <code>DatagramSocket</code> from a specified \n    * <code>DatagramSocketImpl</code> instance\n@@ -151,8 +161,7 @@ public DatagramSocket(int port, InetAddress addr) throws SocketException\n    * Initializes a new instance of <code>DatagramSocket</code> that binds to \n    * the specified local port and address.\n    *\n-   * @param port The local port number to bind to.\n-   * @param laddr The local address to bind to.\n+   * @param address The local address and port number to bind to.\n    *\n    * @exception SecurityException If a security manager exists and its\n    * <code>checkListen</code> method doesn't allow the operation.\n@@ -177,7 +186,6 @@ public DatagramSocket (SocketAddress address) throws SocketException\n \t    propVal + \"DatagramSocketImpl\");\n \t  impl = new PlainDatagramSocketImpl();\n \t}\n-    impl.create();\n \n     if (address == null)\n       return;\n@@ -200,36 +208,66 @@ public DatagramSocket (SocketAddress address) throws SocketException\n     \n     try\n       {\n-        impl.bind(port, addr);\n+        getImpl().bind(port, addr);\n       }\n     catch (SocketException exception)\n       {\n-        impl.close();\n+        getImpl().close();\n         throw exception;\n       }\n     catch (RuntimeException exception)\n       {\n-        impl.close();\n+        getImpl().close();\n         throw exception;\n       }\n     catch (Error error)\n       {\n-        impl.close();\n+        getImpl().close();\n         throw error;\n       }\n   }\n   \n+  // This needs to be accessible from java.net.MulticastSocket\n+  DatagramSocketImpl getImpl()\n+    throws SocketException\n+  {\n+    try\n+      {\n+\tif (!implCreated)\n+\t  {\n+\t    impl.create();\n+\t    implCreated = true;\n+\t  }\n+\n+\treturn impl;\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow new SocketException(e.getMessage());\n+      }\n+  }\n+  \n   /**\n    * Closes this datagram socket.\n    */\n   public void close()\n   {\n     if (!isClosed())\n       {\n-        impl.close();\n-        impl = null;\n-        remoteAddress = null;\n-        remotePort = -1;\n+\ttry\n+\t  {\n+\t    getImpl().close();\n+\t  }\n+\tcatch (SocketException e)\n+\t  {\n+\t    // Ignore this case, just close the socket in finally clause.\n+\t  }\n+\tfinally\n+\t  {\n+\t    remoteAddress = null;\n+\t    remotePort = -1;\n+\t    impl = null;\n+\t  }\n       }\n   }\n \n@@ -264,6 +302,8 @@ public int getPort()\n   /**\n    * Returns the local address this datagram socket is bound to.\n    * \n+   * @return The local address is the socket is bound or null\n+   *\n    * @since 1.1\n    */\n   public InetAddress getLocalAddress()\n@@ -275,7 +315,7 @@ public InetAddress getLocalAddress()\n     \n     try\n       {\n-\tlocalAddr = (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);\n+\tlocalAddr = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);\n \n \tSecurityManager s = System.getSecurityManager();\n \tif (s != null)\n@@ -287,6 +327,7 @@ public InetAddress getLocalAddress()\n       }\n     catch (SocketException e)\n       {\n+\t// This cannot happen as we are bound.\n         return null;\n       }\n \n@@ -303,7 +344,15 @@ public int getLocalPort()\n     if (isClosed())\n       return -1;\n \t      \n-    return impl.getLocalPort();\n+    try\n+      {\n+\treturn getImpl().getLocalPort();\n+      }\n+    catch (SocketException e)\n+      {\n+\t// This cannot happen as we are bound.\n+\treturn 0;\n+      }\n   }\n \n   /**\n@@ -321,12 +370,12 @@ public synchronized int getSoTimeout() throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n+    Object buf = getImpl().getOption(SocketOptions.SO_TIMEOUT);\n \n-    if (timeout instanceof Integer) \n-      return ((Integer)timeout).intValue();\n-    else\n-      return 0;\n+    if (buf instanceof Integer) \n+      return ((Integer) buf).intValue();\n+\n+    throw new SocketException(\"unexpected type\");\n   }\n \n   /**\n@@ -348,7 +397,7 @@ public synchronized void setSoTimeout(int timeout) throws SocketException\n     if (timeout < 0)\n       throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n \n-    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n+    getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n   /**\n@@ -366,13 +415,13 @@ public int getSendBufferSize() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n+    \n+    Object buf = getImpl().getOption(SocketOptions.SO_SNDBUF);\n \n-    Object obj = impl.getOption(SocketOptions.SO_SNDBUF);\n+    if (buf instanceof Integer)\n+      return ((Integer) buf).intValue();\n \n-    if (obj instanceof Integer)\n-      return(((Integer)obj).intValue());\n-    else\n-      throw new SocketException(\"Unexpected type\");\n+    throw new SocketException(\"unexpected type\");\n   }\n \n   /**\n@@ -395,7 +444,7 @@ public void setSendBufferSize(int size) throws SocketException\n     if (size < 0)\n       throw new IllegalArgumentException(\"Buffer size is less than 0\");\n   \n-    impl.setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n+    getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n   }\n \n   /**\n@@ -414,12 +463,12 @@ public int getReceiveBufferSize() throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Object obj = impl.getOption(SocketOptions.SO_RCVBUF);\n+    Object buf = getImpl().getOption(SocketOptions.SO_RCVBUF);\n   \n-    if (obj instanceof Integer)\n-      return(((Integer)obj).intValue());\n-    else \n-      throw new SocketException(\"Unexpected type\");\n+    if (buf instanceof Integer)\n+      return ((Integer) buf).intValue();\n+\n+    throw new SocketException(\"unexpected type\");\n   }\n \n   /**\n@@ -442,7 +491,7 @@ public void setReceiveBufferSize(int size) throws SocketException\n     if (size < 0)\n       throw new IllegalArgumentException(\"Buffer size is less than 0\");\n \n-    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n+    getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n   }\n \n   /**\n@@ -475,7 +524,7 @@ public void connect(InetAddress address, int port)\n \n     try\n       {\n-        impl.connect (address, port);\n+        getImpl().connect (address, port);\n         remoteAddress = address;\n         remotePort = port;\n       }\n@@ -494,9 +543,22 @@ public void connect(InetAddress address, int port)\n    */\n   public void disconnect()\n   {\n-    impl.disconnect();\n-    remoteAddress = null;\n-    remotePort = -1;\n+    if (!isConnected())\n+      return;\n+\n+    try\n+      {\n+\tgetImpl().disconnect();\n+      }\n+    catch (SocketException e)\n+      {\n+\t// This cannot happen as we are connected.\n+      }\n+    finally\n+      {\n+\tremoteAddress = null;\n+\tremotePort = -1;\n+      }\n   }\n \n   /**\n@@ -532,7 +594,7 @@ public synchronized void receive(DatagramPacket p) throws IOException\n         && !getChannel().isBlocking ())\n       throw new IllegalBlockingModeException ();\n \n-    impl.receive(p);\n+    getImpl().receive(p);\n \n     SecurityManager s = System.getSecurityManager();\n     if (s != null && isConnected ())\n@@ -585,7 +647,7 @@ public void send(DatagramPacket p) throws IOException\n         && !getChannel().isBlocking ())\n       throw new IllegalBlockingModeException ();\n \n-    impl.send(p);\n+    getImpl().send(p);\n   }\n \n   /**\n@@ -607,20 +669,23 @@ public void bind (SocketAddress address)\n       throw new SocketException(\"socket is closed\");\n     \n     if (! (address instanceof InetSocketAddress))\n-      throw new IllegalArgumentException ();\n+      throw new IllegalArgumentException(\"unsupported address type\");\n \n     InetSocketAddress tmp = (InetSocketAddress) address;\n \n     SecurityManager s = System.getSecurityManager ();\n     if (s != null)\n       s.checkListen(tmp.getPort ());\n \n-    impl.bind (tmp.getPort (), tmp.getAddress ());\n+    getImpl().bind (tmp.getPort (), tmp.getAddress ());\n+    bound = true;\n   }\n \n   /**\n    * Checks if the datagram socket is closed.\n    *\n+   * @return True if socket is closed, false otherwise.\n+   * \n    * @since 1.4\n    */\n   public boolean isClosed()\n@@ -631,6 +696,8 @@ public boolean isClosed()\n   /**\n    * Returns the datagram channel assoziated with this datagram socket.\n    * \n+   * @return The associated <code>DatagramChannel</code> object or null\n+   * \n    * @since 1.4\n    */\n   public DatagramChannel getChannel()\n@@ -651,37 +718,32 @@ public DatagramChannel getChannel()\n   public void connect (SocketAddress address) throws SocketException\n   {\n     if (isClosed())\n+      throw new SocketException(\"socket is closed\");\n     \n     if ( !(address instanceof InetSocketAddress) )\n-      throw new IllegalArgumentException (\n-\t\t      \"SocketAddress is not InetSocketAddress\");\n+      throw new IllegalArgumentException(\"unsupported address type\");\n \n     InetSocketAddress tmp = (InetSocketAddress) address;\n-    connect( tmp.getAddress(), tmp.getPort());\n+    connect(tmp.getAddress(), tmp.getPort());\n   }\n   \n   /**\n    * Returns the binding state of the socket.\n    * \n+   * @return True if socket bound, false otherwise.\n+   * \n    * @since 1.4\n    */\n   public boolean isBound()\n   {\n-    try\n-      {\n-        Object bindaddr = impl.getOption (SocketOptions.SO_BINDADDR);\n-      }\n-    catch (SocketException e)\n-      {\n-        return false;\n-      }\n-\n-    return true;\n+    return bound;\n   }\n \n   /**\n    * Returns the connection state of the socket.\n    * \n+   * @return True if socket is connected, false otherwise.\n+   * \n    * @since 1.4\n    */\n   public boolean isConnected()\n@@ -693,6 +755,8 @@ public boolean isConnected()\n    * Returns the SocketAddress of the host this socket is conneted to\n    * or null if this socket is not connected.\n    * \n+   * @return The socket address of the remote host if connected or null\n+   * \n    * @since 1.4\n    */\n   public SocketAddress getRemoteSocketAddress()\n@@ -704,25 +768,18 @@ public SocketAddress getRemoteSocketAddress()\n   }\n \n   /**\n-   * Returns the local SocketAddress this socket is bound to\n-   * or null if it is not bound.\n+   * Returns the local SocketAddress this socket is bound to.\n+   *\n+   * @return The local SocketAddress or null if the socket is not bound.\n    * \n    * @since 1.4\n    */\n   public SocketAddress getLocalSocketAddress()\n   {\n-    InetAddress addr;\n+    if (!isBound())\n+      return null;\n     \n-    try\n-      {\n-        addr = (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);\n-      }\n-    catch (SocketException e)\n-      {\n-        return null;\n-      }\n-\n-    return new InetSocketAddress (addr, impl.localPort);\n+    return new InetSocketAddress (getLocalAddress(), getLocalPort());\n   }\n \n   /**\n@@ -739,12 +796,14 @@ public void setReuseAddress(boolean on) throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    impl.setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));\n+    getImpl().setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));\n   }\n \n   /**\n    * Checks if SO_REUSEADDR is enabled.\n    *\n+   * @return True if SO_REUSEADDR is set on the socket, false otherwise.\n+   *\n    * @exception SocketException If an error occurs.\n    * \n    * @since 1.4\n@@ -754,34 +813,36 @@ public boolean getReuseAddress() throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Object obj = impl.getOption (SocketOptions.SO_REUSEADDR);\n+    Object buf = getImpl().getOption (SocketOptions.SO_REUSEADDR);\n   \n-    if (obj instanceof Boolean)\n-      return(((Boolean) obj).booleanValue ());\n-    else \n-      throw new SocketException (\"Unexpected type\");\n+    if (buf instanceof Boolean)\n+      return ((Boolean) buf).booleanValue();\n+\n+    throw new SocketException(\"unexpected type\");\n   }\n \n   /**\n    * Enables/Disables SO_BROADCAST\n    * \n-   * @param on Whether or not to have SO_BROADCAST turned on\n+   * @param enable True if SO_BROADCAST should be enabled, false otherwise.\n    *\n    * @exception SocketException If an error occurs\n    *\n    * @since 1.4\n    */\n-  public void setBroadcast(boolean on) throws SocketException\n+  public void setBroadcast(boolean enable) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    impl.setOption (SocketOptions.SO_BROADCAST, new Boolean (on));\n+    getImpl().setOption(SocketOptions.SO_BROADCAST, new Boolean(enable));\n   }\n \n   /**\n    * Checks if SO_BROADCAST is enabled\n    * \n+   * @return Whether SO_BROADCAST is set\n+   *\n    * @exception SocketException If an error occurs\n    * \n    * @since 1.4\n@@ -791,12 +852,12 @@ public boolean getBroadcast() throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Object obj = impl.getOption (SocketOptions.SO_BROADCAST);\n+    Object buf = getImpl().getOption(SocketOptions.SO_BROADCAST);\n   \n-    if (obj instanceof Boolean)\n-      return ((Boolean) obj).booleanValue ();\n-    else \n-      throw new SocketException (\"Unexpected type\");\n+    if (buf instanceof Boolean)\n+      return ((Boolean) buf).booleanValue();\n+\n+    throw new SocketException(\"unexpected type\");\n   }\n \n   /**\n@@ -820,12 +881,14 @@ public void setTrafficClass(int tc)\n     if (tc < 0 || tc > 255)\n       throw new IllegalArgumentException();\n \n-    impl.setOption (SocketOptions.IP_TOS, new Integer (tc));\n+    getImpl().setOption (SocketOptions.IP_TOS, new Integer (tc));\n   }\n   \n   /**\n    * Returns the current traffic class\n    * \n+   * @return The current traffic class.\n+   *\n    * @see DatagramSocket#setTrafficClass(int tc)\n    *\n    * @exception SocketException If an error occurs\n@@ -836,13 +899,13 @@ public int getTrafficClass() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n+    \n+    Object buf = getImpl().getOption(SocketOptions.IP_TOS);\n \n-    Object obj = impl.getOption(SocketOptions.IP_TOS);\n+    if (buf instanceof Integer)\n+      return ((Integer) buf).intValue();\n \n-    if (obj instanceof Integer)\n-      return ((Integer) obj).intValue ();\n-    else\n-      throw new SocketException (\"Unexpected type\");\n+    throw new SocketException(\"unexpected type\");\n   }\n   \n   /**"}, {"sha": "12afc2f50c3d0d4442b2a6af27fdf004d25bb8ef", "filename": "libjava/java/net/MulticastSocket.java", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aa74bd346b862ac34704642f0483a057cfe73a3/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aa74bd346b862ac34704642f0483a057cfe73a3/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=4aa74bd346b862ac34704642f0483a057cfe73a3", "patch": "@@ -67,10 +67,6 @@\n  */\n public class MulticastSocket extends DatagramSocket\n {\n-  // FIXME: the local addr bound to the multicast socket can be reused;\n-  // unlike unicast sockets.  It binds to any available network interface.\n-  // See p.1159 JCL book.\n-\n   /**\n    * Create a MulticastSocket that this not bound to any address\n    *\n@@ -128,7 +124,7 @@ public InetAddress getInterface() throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    return (InetAddress) impl.getOption(SocketOptions.IP_MULTICAST_IF);\n+    return (InetAddress) getImpl().getOption(SocketOptions.IP_MULTICAST_IF);\n   }\n \n   /**\n@@ -152,7 +148,7 @@ public byte getTTL() throws IOException\n     // Use getTTL here rather than getTimeToLive in case we're using an impl\n     // other than the default PlainDatagramSocketImpl and it doesn't have\n     // getTimeToLive yet.\n-    return impl.getTTL();\n+    return getImpl().getTTL();\n   }\n \n   /**\n@@ -170,7 +166,7 @@ public int getTimeToLive() throws IOException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    return impl.getTimeToLive();\n+    return getImpl().getTimeToLive();\n   }\n \n   /**\n@@ -187,7 +183,7 @@ public void setInterface(InetAddress addr) throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    impl.setOption(SocketOptions.IP_MULTICAST_IF, addr);\n+    getImpl().setOption(SocketOptions.IP_MULTICAST_IF, addr);\n   }\n \n   /**\n@@ -210,10 +206,10 @@ public void setNetworkInterface(NetworkInterface netIf)\n     Enumeration e = netIf.getInetAddresses ();\n \n     if (!e.hasMoreElements ())\n-      throw new SocketException (\"MulticastSocket: Error\");\n+      throw new SocketException(\"no network devices found\");\n \n     InetAddress address = (InetAddress) e.nextElement ();\n-    impl.setOption (SocketOptions.IP_MULTICAST_IF, address);\n+    getImpl().setOption (SocketOptions.IP_MULTICAST_IF, address);\n   }\n \n   /**\n@@ -234,7 +230,7 @@ public NetworkInterface getNetworkInterface()\n       throw new SocketException(\"socket is closed\");\n \n     InetAddress address =\n-\t    (InetAddress) impl.getOption (SocketOptions.IP_MULTICAST_IF);\n+      (InetAddress) getImpl().getOption (SocketOptions.IP_MULTICAST_IF);\n     NetworkInterface netIf = NetworkInterface.getByInetAddress (address);\n \n     return netIf;\n@@ -259,7 +255,7 @@ public void setLoopbackMode(boolean disable) throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    impl.setOption (SocketOptions.IP_MULTICAST_LOOP, new Boolean (disable));\n+    getImpl().setOption (SocketOptions.IP_MULTICAST_LOOP, new Boolean (disable));\n   }\n \n   /**\n@@ -274,12 +270,12 @@ public boolean getLoopbackMode() throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Object obj = impl.getOption (SocketOptions.IP_MULTICAST_LOOP);\n+    Object buf = getImpl().getOption (SocketOptions.IP_MULTICAST_LOOP);\n \n-    if (obj instanceof Boolean)\n-      return ((Boolean) obj).booleanValue ();\n-    else\n-      throw new SocketException (\"Unexpected type\");\n+    if (buf instanceof Boolean)\n+      return ((Boolean) buf).booleanValue();\n+    \n+    throw new SocketException(\"unexpected type\");\n   }\n \n   /**\n@@ -302,7 +298,7 @@ public void setTTL(byte ttl) throws IOException\n     // Use setTTL here rather than setTimeToLive in case we're using an impl\n     // other than the default PlainDatagramSocketImpl and it doesn't have\n     // setTimeToLive yet.\n-    impl.setTTL(ttl);\n+    getImpl().setTTL(ttl);\n   }\n \n   /**\n@@ -323,7 +319,7 @@ public void setTimeToLive(int ttl) throws IOException\n     if (ttl <= 0 || ttl > 255)\n       throw new IllegalArgumentException(\"Invalid ttl: \" + ttl);\n \n-    impl.setTimeToLive(ttl);\n+    getImpl().setTimeToLive(ttl);\n   }\n \n   /**\n@@ -347,7 +343,7 @@ public void joinGroup(InetAddress mcastaddr) throws IOException\n     if (s != null)\n       s.checkMulticast(mcastaddr);\n \n-    impl.join(mcastaddr);\n+    getImpl().join(mcastaddr);\n   }\n \n   /**\n@@ -371,7 +367,7 @@ public void leaveGroup(InetAddress mcastaddr) throws IOException\n     if (s != null)\n       s.checkMulticast(mcastaddr);\n \n-    impl.leave(mcastaddr);\n+    getImpl().leave(mcastaddr);\n   }\n \n   /**\n@@ -410,7 +406,7 @@ public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n     if (s != null)\n       s.checkMulticast (tmp.getAddress ());\n \n-    impl.joinGroup (mcastaddr, netIf);\n+    getImpl().joinGroup (mcastaddr, netIf);\n   }\n   \n   /**\n@@ -445,7 +441,7 @@ public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n     if (s != null)\n       s.checkMulticast (tmp.getAddress ());\n \n-    impl.leaveGroup (mcastaddr, netIf);\n+    getImpl().leaveGroup (mcastaddr, netIf);\n   }\n   \n   /**\n@@ -479,9 +475,9 @@ public synchronized void send(DatagramPacket p, byte ttl) throws IOException\n           s.checkConnect(addr.getHostAddress(), p.getPort());\n       }\n \n-    int oldttl = impl.getTimeToLive();\n-    impl.setTimeToLive(((int) ttl) & 0xFF);\n-    impl.send(p);\n-    impl.setTimeToLive(oldttl);\n+    int oldttl = getImpl().getTimeToLive();\n+    getImpl().setTimeToLive(((int) ttl) & 0xFF);\n+    getImpl().send(p);\n+    getImpl().setTimeToLive(oldttl);\n   }\n } // class MulticastSocket"}]}