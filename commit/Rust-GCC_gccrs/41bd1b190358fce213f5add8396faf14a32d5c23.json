{"sha": "41bd1b190358fce213f5add8396faf14a32d5c23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFiZDFiMTkwMzU4ZmNlMjEzZjVhZGQ4Mzk2ZmFmMTRhMzJkNWMyMw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-05-03T07:22:53Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-07-09T16:41:55Z"}, "message": "Darwin, X86: Adjust call clobbers to allow for lazy-binding [PR 100152].\n\nWe allow public functions defined in a TU to bind locally for PIC\ncode (the default) on 64bit Mach-O.\n\nIf such functions are not inlined, we cannot tell at compile-time if\nthey might be called via the lazy symbol resolver (this can depend on\noptions given at link-time).  Therefore, we must assume that the lazy\nresolver could be used which clobbers R11 and R10.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/ChangeLog:\n\n\tPR target/100152\n\t* config/i386/i386-expand.c (ix86_expand_call): If a call is\n\tto a non-local-binding, or local but to a public symbol, then\n\tassume that it might be indirected via the lazy symbol binder.\n\tMark R10 and R10 as clobbered in that case.", "tree": {"sha": "f6991a6ee2bfe85c65d08cc973b8a7452de4862d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6991a6ee2bfe85c65d08cc973b8a7452de4862d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41bd1b190358fce213f5add8396faf14a32d5c23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41bd1b190358fce213f5add8396faf14a32d5c23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41bd1b190358fce213f5add8396faf14a32d5c23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41bd1b190358fce213f5add8396faf14a32d5c23/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54258e22b0846aaa6bd3265f592feb161eecda75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54258e22b0846aaa6bd3265f592feb161eecda75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54258e22b0846aaa6bd3265f592feb161eecda75"}], "stats": {"total": 16, "additions": 15, "deletions": 1}, "files": [{"sha": "69ea79e6123b76679ee6ef197566c7015fc8aa69", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bd1b190358fce213f5add8396faf14a32d5c23/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bd1b190358fce213f5add8396faf14a32d5c23/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=41bd1b190358fce213f5add8396faf14a32d5c23", "patch": "@@ -8410,6 +8410,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n     pop = NULL;\n   gcc_assert (!TARGET_64BIT || !pop);\n \n+  rtx addr = XEXP (fnaddr, 0);\n   if (TARGET_MACHO && !TARGET_64BIT)\n     {\n #if TARGET_MACHO\n@@ -8422,7 +8423,6 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       /* Static functions and indirect calls don't need the pic register.  Also,\n \t check if PLT was explicitly avoided via no-plt or \"noplt\" attribute, making\n \t it an indirect call.  */\n-      rtx addr = XEXP (fnaddr, 0);\n       if (flag_pic\n \t  && GET_CODE (addr) == SYMBOL_REF\n \t  && !SYMBOL_REF_LOCAL_P (addr))\n@@ -8585,6 +8585,20 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t}\n     }\n \n+  if (TARGET_MACHO && TARGET_64BIT && !sibcall\n+      && ((GET_CODE (addr) == SYMBOL_REF && !SYMBOL_REF_LOCAL_P (addr))\n+\t  || !fndecl || TREE_PUBLIC (fndecl)))\n+    {\n+      /* We allow public functions defined in a TU to bind locally for PIC\n+\t code (the default) on 64bit Mach-O.\n+\t If such functions are not inlined, we cannot tell at compile-time if\n+\t they will be called via the lazy symbol resolver (this can depend on\n+\t options given at link-time).  Therefore, we must assume that the lazy\n+\t resolver could be used which clobbers R11 and R10.  */\n+      clobber_reg (&use, gen_rtx_REG (DImode, R11_REG));\n+      clobber_reg (&use, gen_rtx_REG (DImode, R10_REG));\n+    }\n+\n   if (vec_len > 1)\n     call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (vec_len, vec));\n   rtx_insn *call_insn = emit_call_insn (call);"}]}