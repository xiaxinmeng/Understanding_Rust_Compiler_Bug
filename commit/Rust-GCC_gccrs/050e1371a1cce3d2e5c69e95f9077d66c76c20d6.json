{"sha": "050e1371a1cce3d2e5c69e95f9077d66c76c20d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwZTEzNzFhMWNjZTNkMmU1YzY5ZTk1ZjkwNzdkNjZjNzZjMjBkNg==", "commit": {"author": {"name": "Aditya Kumar", "email": "hiraditya@msn.com", "date": "2015-07-20T18:02:49Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-07-20T18:02:49Z"}, "message": "Refactor graphite-isl-ast-to-gimple.c\n\nRefactor graphite-isl-ast-to-gimple.c:\nRefactor so that each function can access 'region'. This will help\nmaintain a parameter rename_map within a region. No functional change intended.\nThis patch will be followed by another set of patches\nwhere translate_isl_ast_to_gimple::region is used to keep parameters which need\nrenaming. Since we are planning to remove limit_scops, we now have to maintain a\nset of parameters which needs renaming. This refactoring helps avoid passing\n`region' to all the functions in this file.\n\nIt passes bootstrap and regtest.\n\ngcc/ChangeLog:\n\n2015-07-19  Aditya Kumar  <hiraditya@msn.com>\n\n        * graphite-isl-ast-to-gimple.c:\n\tRefactor so that each function can access 'region'. This will help\n\tmaintain a parameter rename_map within a region.\n\nFrom-SVN: r226014", "tree": {"sha": "831ac1ab7bab2f7c6f763a8aacbf15920b32b776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/831ac1ab7bab2f7c6f763a8aacbf15920b32b776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/050e1371a1cce3d2e5c69e95f9077d66c76c20d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050e1371a1cce3d2e5c69e95f9077d66c76c20d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/050e1371a1cce3d2e5c69e95f9077d66c76c20d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050e1371a1cce3d2e5c69e95f9077d66c76c20d6/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a051317b739c58ac84f9e7c60135bd457e94bc19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a051317b739c58ac84f9e7c60135bd457e94bc19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a051317b739c58ac84f9e7c60135bd457e94bc19"}], "stats": {"total": 212, "additions": 180, "deletions": 32}, "files": [{"sha": "618c62d42cf012175b3727a8e289f62fe1b1aa31", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 180, "deletions": 32, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050e1371a1cce3d2e5c69e95f9077d66c76c20d6/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050e1371a1cce3d2e5c69e95f9077d66c76c20d6/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=050e1371a1cce3d2e5c69e95f9077d66c76c20d6", "patch": "@@ -125,9 +125,142 @@ void ivs_params_clear (ivs_params &ip)\n     }\n }\n \n-static tree\n-gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *,\n-\t\t\t\t    ivs_params &ip);\n+class translate_isl_ast_to_gimple\n+{\n+ public:\n+  translate_isl_ast_to_gimple (sese r)\n+    : region (r)\n+  { }\n+\n+  /* Translates an ISL AST node NODE to GCC representation in the\n+     context of a SESE.  */\n+  edge translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n+\t\t\t  edge next_e, ivs_params &ip);\n+\n+  /* Translates an isl_ast_node_for to Gimple.  */\n+  edge translate_isl_ast_node_for (loop_p context_loop,\n+\t\t\t\t   __isl_keep isl_ast_node *node,\n+\t\t\t\t   edge next_e, ivs_params &ip);\n+\n+  /* Create the loop for a isl_ast_node_for.\n+\n+     - NEXT_E is the edge where new generated code should be attached.  */\n+  edge translate_isl_ast_for_loop (loop_p context_loop,\n+\t\t\t\t   __isl_keep isl_ast_node *node_for,\n+\t\t\t\t   edge next_e,\n+\t\t\t\t   tree type, tree lb, tree ub,\n+\t\t\t\t   ivs_params &ip);\n+\n+  /* Translates an isl_ast_node_if to Gimple.  */\n+  edge translate_isl_ast_node_if (loop_p context_loop,\n+\t\t\t\t  __isl_keep isl_ast_node *node,\n+\t\t\t\t  edge next_e, ivs_params &ip);\n+\n+  /* Translates an isl_ast_node_user to Gimple.\n+\n+     FIXME: We should remove iv_map.create (loop->num + 1), if it is\n+     possible.  */\n+  edge translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n+\t\t\t\t    edge next_e, ivs_params &ip);\n+\n+  /* Translates an isl_ast_node_block to Gimple.  */\n+  edge translate_isl_ast_node_block (loop_p context_loop,\n+\t\t\t\t     __isl_keep isl_ast_node *node,\n+\t\t\t\t     edge next_e, ivs_params &ip);\n+\n+  /* Converts a unary isl_ast_expr_op expression E to a GCC expression tree of\n+     type TYPE.  */\n+  tree unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n+\t\t\t ivs_params &ip);\n+\n+  /* Converts a binary isl_ast_expr_op expression E to a GCC expression tree of\n+     type TYPE.  */\n+  tree binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n+\t\t\t  ivs_params &ip);\n+\n+  /* Converts a ternary isl_ast_expr_op expression E to a GCC expression tree of\n+     type TYPE.  */\n+  tree ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n+\t\t\t   ivs_params &ip);\n+\n+  /* Converts an isl_ast_expr_op expression E with unknown number of arguments\n+     to a GCC expression tree of type TYPE.  */\n+  tree nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n+\t\t\tivs_params &ip);\n+\n+  /* Converts an ISL AST expression E back to a GCC expression tree of\n+     type TYPE.  */\n+  tree gcc_expression_from_isl_expression (tree type,\n+\t\t\t\t\t   __isl_take isl_ast_expr *,\n+\t\t\t\t\t   ivs_params &ip);\n+\n+  /* Return the tree variable that corresponds to the given isl ast identifier\n+     expression (an isl_ast_expr of type isl_ast_expr_id).\n+\n+     FIXME: We should replace blind conversation of id's type with derivation\n+     of the optimal type when we get the corresponding isl support.  Blindly\n+     converting type sizes may be problematic when we switch to smaller\n+     types.  */\n+  tree gcc_expression_from_isl_ast_expr_id (tree type,\n+\t\t\t\t\t    __isl_keep isl_ast_expr *expr_id,\n+\t\t\t\t\t    ivs_params &ip);\n+\n+  /* Converts an isl_ast_expr_int expression E to a GCC expression tree of\n+     type TYPE.  */\n+  tree gcc_expression_from_isl_expr_int (tree type,\n+\t\t\t\t\t __isl_take isl_ast_expr *expr);\n+\n+  /* Converts an isl_ast_expr_op expression E to a GCC expression tree of\n+     type TYPE.  */\n+  tree gcc_expression_from_isl_expr_op (tree type,\n+\t\t\t\t\t__isl_take isl_ast_expr *expr,\n+\t\t\t\t\tivs_params &ip);\n+\n+  /* Creates a new LOOP corresponding to isl_ast_node_for.  Inserts an\n+     induction variable for the new LOOP.  New LOOP is attached to CFG\n+     starting at ENTRY_EDGE.  LOOP is inserted into the loop tree and\n+     becomes the child loop of the OUTER_LOOP.  NEWIVS_INDEX binds\n+     ISL's scattering name to the induction variable created for the\n+     loop of STMT.  The new induction variable is inserted in the NEWIVS\n+     vector and is of type TYPE.  */\n+  struct loop *graphite_create_new_loop (edge entry_edge,\n+\t\t\t\t\t __isl_keep isl_ast_node *node_for,\n+\t\t\t\t\t loop_p outer, tree type,\n+\t\t\t\t\t tree lb, tree ub, ivs_params &ip);\n+\n+  /* All loops generated by create_empty_loop_on_edge have the form of\n+     a post-test loop:\n+\n+     do\n+\n+     {\n+     body of the loop;\n+     } while (lower bound < upper bound);\n+\n+     We create a new if region protecting the loop to be executed, if\n+     the execution count is zero (lower bound > upper bound).  */\n+  edge graphite_create_new_loop_guard (edge entry_edge,\n+\t\t\t\t       __isl_keep isl_ast_node *node_for,\n+\t\t\t\t       tree *type,\n+\t\t\t\t       tree *lb, tree *ub, ivs_params &ip);\n+\n+  /* Creates a new if region corresponding to ISL's cond.  */\n+  edge graphite_create_new_guard (edge entry_edge,\n+\t\t\t\t  __isl_take isl_ast_expr *if_cond,\n+\t\t\t\t  ivs_params &ip);\n+\n+  /* Inserts in iv_map a tuple (OLD_LOOP->num, NEW_NAME) for the induction\n+     variables of the loops around GBB in SESE.\n+\n+     FIXME: Instead of using a vec<tree> that maps each loop id to a possible\n+     chrec, we could consider using a map<int, tree> that maps loop ids to the\n+     corresponding tree expressions.  */\n+  void build_iv_mapping (vec<tree> iv_map, gimple_bb_p gbb,\n+\t\t\t __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n+\t\t\t sese region);\n+private:\n+  sese region;\n+};\n \n /* Return the tree variable that corresponds to the given isl ast identifier\n    expression (an isl_ast_expr of type isl_ast_expr_id).\n@@ -137,7 +270,8 @@ gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *,\n    converting type sizes may be problematic when we switch to smaller\n    types.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n gcc_expression_from_isl_ast_expr_id (tree type,\n \t\t\t\t     __isl_keep isl_ast_expr *expr_id,\n \t\t\t\t     ivs_params &ip)\n@@ -148,15 +282,16 @@ gcc_expression_from_isl_ast_expr_id (tree type,\n   res = ip.find (tmp_isl_id);\n   isl_id_free (tmp_isl_id);\n   gcc_assert (res != ip.end () &&\n-              \"Could not map isl_id to tree expression\");\n+\t      \"Could not map isl_id to tree expression\");\n   isl_ast_expr_free (expr_id);\n   return fold_convert (type, res->second);\n }\n \n /* Converts an isl_ast_expr_int expression E to a GCC expression tree of\n    type TYPE.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n {\n   gcc_assert (isl_ast_expr_get_type (expr) == isl_ast_expr_int);\n@@ -177,7 +312,8 @@ gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n /* Converts a binary isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n@@ -239,7 +375,8 @@ binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n /* Converts a ternary isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   gcc_assert (isl_ast_expr_get_op_type (expr) == isl_ast_op_minus);\n@@ -260,7 +397,8 @@ ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n /* Converts a unary isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   gcc_assert (isl_ast_expr_get_op_type (expr) == isl_ast_op_minus);\n@@ -273,7 +411,8 @@ unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n /* Converts an isl_ast_expr_op expression E with unknown number of arguments\n    to a GCC expression tree of type TYPE.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   enum tree_code op_code;\n@@ -303,11 +442,11 @@ nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n   return res;\n }\n \n-\n /* Converts an isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t\t ivs_params &ip)\n {\n@@ -358,7 +497,8 @@ gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,\n /* Converts an ISL AST expression E back to a GCC expression tree of\n    type TYPE.  */\n \n-static tree\n+tree\n+translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t\t    ivs_params &ip)\n {\n@@ -388,7 +528,8 @@ gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *expr,\n    loop of STMT.  The new induction variable is inserted in the NEWIVS\n    vector and is of type TYPE.  */\n \n-static struct loop *\n+struct loop *\n+translate_isl_ast_to_gimple::\n graphite_create_new_loop (edge entry_edge, __isl_keep isl_ast_node *node_for,\n \t\t\t  loop_p outer, tree type, tree lb, tree ub,\n \t\t\t  ivs_params &ip)\n@@ -412,15 +553,12 @@ graphite_create_new_loop (edge entry_edge, __isl_keep isl_ast_node *node_for,\n   return loop;\n }\n \n-static edge\n-translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n-\t\t   edge next_e, ivs_params &ip);\n-\n /* Create the loop for a isl_ast_node_for.\n \n    - NEXT_E is the edge where new generated code should be attached.  */\n \n-static edge\n+edge\n+translate_isl_ast_to_gimple::\n translate_isl_ast_for_loop (loop_p context_loop,\n \t\t\t    __isl_keep isl_ast_node *node_for, edge next_e,\n \t\t\t    tree type, tree lb, tree ub,\n@@ -524,7 +662,8 @@ get_upper_bound (__isl_keep isl_ast_node *node_for)\n    We create a new if region protecting the loop to be executed, if\n    the execution count is zero (lower bound > upper bound).  */\n \n-static edge\n+edge\n+translate_isl_ast_to_gimple::\n graphite_create_new_loop_guard (edge entry_edge,\n \t\t\t\t__isl_keep isl_ast_node *node_for, tree *type,\n \t\t\t\ttree *lb, tree *ub, ivs_params &ip)\n@@ -566,7 +705,8 @@ graphite_create_new_loop_guard (edge entry_edge,\n \n /* Translates an isl_ast_node_for to Gimple. */\n \n-static edge\n+edge\n+translate_isl_ast_to_gimple::\n translate_isl_ast_node_for (loop_p context_loop, __isl_keep isl_ast_node *node,\n \t\t\t    edge next_e, ivs_params &ip)\n {\n@@ -588,20 +728,21 @@ translate_isl_ast_node_for (loop_p context_loop, __isl_keep isl_ast_node *node,\n    chrec, we could consider using a map<int, tree> that maps loop ids to the\n    corresponding tree expressions.  */\n \n-static void\n+void\n+translate_isl_ast_to_gimple::\n build_iv_mapping (vec<tree> iv_map, gimple_bb_p gbb,\n \t\t  __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n \t\t  sese region)\n {\n   gcc_assert (isl_ast_expr_get_type (user_expr) == isl_ast_expr_op &&\n-              isl_ast_expr_get_op_type (user_expr) == isl_ast_op_call);\n+\t      isl_ast_expr_get_op_type (user_expr) == isl_ast_op_call);\n   int i;\n   isl_ast_expr *arg_expr;\n   for (i = 1; i < isl_ast_expr_get_op_n_arg (user_expr); i++)\n     {\n       arg_expr = isl_ast_expr_get_op_arg (user_expr, i);\n       tree type =\n-        build_nonstandard_integer_type (graphite_expression_type_precision, 0);\n+\tbuild_nonstandard_integer_type (graphite_expression_type_precision, 0);\n       tree t = gcc_expression_from_isl_expression (type, arg_expr, ip);\n       loop_p old_loop = gbb_loop_at_index (gbb, region, i - 1);\n       iv_map[old_loop->num] = t;\n@@ -613,7 +754,8 @@ build_iv_mapping (vec<tree> iv_map, gimple_bb_p gbb,\n \n    FIXME: We should remove iv_map.create (loop->num + 1), if it is possible.  */\n \n-static edge\n+edge\n+translate_isl_ast_to_gimple::\n translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n \t\t\t     edge next_e, ivs_params &ip)\n {\n@@ -650,7 +792,8 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n \n /* Translates an isl_ast_node_block to Gimple. */\n \n-static edge\n+edge\n+translate_isl_ast_to_gimple::\n translate_isl_ast_node_block (loop_p context_loop,\n \t\t\t      __isl_keep isl_ast_node *node,\n \t\t\t      edge next_e, ivs_params &ip)\n@@ -670,7 +813,8 @@ translate_isl_ast_node_block (loop_p context_loop,\n  \n /* Creates a new if region corresponding to ISL's cond.  */\n \n-static edge\n+edge\n+translate_isl_ast_to_gimple::\n graphite_create_new_guard (edge entry_edge, __isl_take isl_ast_expr *if_cond,\n \t\t\t   ivs_params &ip)\n {\n@@ -683,7 +827,8 @@ graphite_create_new_guard (edge entry_edge, __isl_take isl_ast_expr *if_cond,\n \n /* Translates an isl_ast_node_if to Gimple.  */\n \n-static edge\n+edge\n+translate_isl_ast_to_gimple::\n translate_isl_ast_node_if (loop_p context_loop,\n \t\t\t   __isl_keep isl_ast_node *node,\n \t\t\t   edge next_e, ivs_params &ip)\n@@ -708,9 +853,10 @@ translate_isl_ast_node_if (loop_p context_loop,\n /* Translates an ISL AST node NODE to GCC representation in the\n    context of a SESE.  */\n \n-static edge\n-translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n-\t\t   edge next_e, ivs_params &ip)\n+edge\n+translate_isl_ast_to_gimple::translate_isl_ast (loop_p context_loop,\n+\t\t\t\t\t\t__isl_keep isl_ast_node *node,\n+\t\t\t\t\t\tedge next_e, ivs_params &ip)\n {\n   switch (isl_ast_node_get_type (node))\n     {\n@@ -1050,7 +1196,9 @@ graphite_regenerate_ast_isl (scop_p scop)\n \n   context_loop = SESE_ENTRY (region)->src->loop_father;\n \n-  translate_isl_ast (context_loop, root_node, if_region->true_region->entry,\n+  translate_isl_ast_to_gimple t (region);\n+\n+  t.translate_isl_ast (context_loop, root_node, if_region->true_region->entry,\n \t\t     ip);\n \n   mark_virtual_operands_for_renaming (cfun);"}]}