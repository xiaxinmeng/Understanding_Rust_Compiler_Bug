{"sha": "d78b70959f334699bf556e9b8d4e0a8c12a64b46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc4YjcwOTU5ZjMzNDY5OWJmNTU2ZTliOGQ0ZTBhOGMxMmE2NGI0Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-21T13:46:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-21T13:46:18Z"}, "message": "cfgloop.h (loop_iterator::~loop_iterator): Remove.\n\n2019-11-21  Richard Biener  <rguenther@suse.de>\n\n\t* cfgloop.h (loop_iterator::~loop_iterator): Remove.\n\t(loop_iterator::to_visit): Use an auto_vec with internal storage.\n\t(loop_iterator::loop_iterator): Adjust.\n\t* cfganal.c (compute_dominance_frontiers_1): Fold into...\n\t(compute_dominance_frontiers): ... this.  Hoist invariant\n\tget_immediate_dominator call.\n\t(compute_idf): Use a work-set instead of a work-list for more\n\toptimal iteration order and duplicate avoidance.\n\t* tree-into-ssa.c (mark_phi_for_rewrite): Avoid re-allocating\n\tthe vector all the time, instead pre-allocate the vector only\n\tonce.\n\t(delete_update_ssa): Simplify.\n\t* vec.h (va_heap::release): Disable -Wfree-nonheap-object around it.\n\nFrom-SVN: r278550", "tree": {"sha": "bbeb4dbda1117ae17d50415a6053d914cf30f236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbeb4dbda1117ae17d50415a6053d914cf30f236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d78b70959f334699bf556e9b8d4e0a8c12a64b46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78b70959f334699bf556e9b8d4e0a8c12a64b46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d78b70959f334699bf556e9b8d4e0a8c12a64b46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78b70959f334699bf556e9b8d4e0a8c12a64b46/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2a05fdfd4798192493c582ec6528c975bfa9b0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a05fdfd4798192493c582ec6528c975bfa9b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a05fdfd4798192493c582ec6528c975bfa9b0c"}], "stats": {"total": 114, "additions": 60, "deletions": 54}, "files": [{"sha": "8bb076320fffa7e2f9e90860d20c6a96b383e2cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d78b70959f334699bf556e9b8d4e0a8c12a64b46", "patch": "@@ -1,3 +1,19 @@\n+2019-11-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* cfgloop.h (loop_iterator::~loop_iterator): Remove.\n+\t(loop_iterator::to_visit): Use an auto_vec with internal storage.\n+\t(loop_iterator::loop_iterator): Adjust.\n+\t* cfganal.c (compute_dominance_frontiers_1): Fold into...\n+\t(compute_dominance_frontiers): ... this.  Hoist invariant\n+\tget_immediate_dominator call.\n+\t(compute_idf): Use a work-set instead of a work-list for more\n+\toptimal iteration order and duplicate avoidance.\n+\t* tree-into-ssa.c (mark_phi_for_rewrite): Avoid re-allocating\n+\tthe vector all the time, instead pre-allocate the vector only\n+\tonce.\n+\t(delete_update_ssa): Simplify.\n+\t* vec.h (va_heap::release): Disable -Wfree-nonheap-object around it.\n+\n 2019-11-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/91355"}, {"sha": "039769d3a9726aa507bcf51637466d2da6b5d57b", "filename": "gcc/cfganal.c", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=d78b70959f334699bf556e9b8d4e0a8c12a64b46", "patch": "@@ -1326,45 +1326,34 @@ dfs_enumerate_from (basic_block bb, int reverse,\n    of the dominance frontiers, no more, no less.\n */\n \n-\n-static void\n-compute_dominance_frontiers_1 (bitmap_head *frontiers)\n+void\n+compute_dominance_frontiers (bitmap_head *frontiers)\n {\n+  timevar_push (TV_DOM_FRONTIERS);\n+\n   edge p;\n   edge_iterator ei;\n   basic_block b;\n   FOR_EACH_BB_FN (b, cfun)\n     {\n       if (EDGE_COUNT (b->preds) >= 2)\n \t{\n+\t  basic_block domsb = get_immediate_dominator (CDI_DOMINATORS, b);\n \t  FOR_EACH_EDGE (p, ei, b->preds)\n \t    {\n \t      basic_block runner = p->src;\n-\t      basic_block domsb;\n \t      if (runner == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t\tcontinue;\n \n-\t      domsb = get_immediate_dominator (CDI_DOMINATORS, b);\n \t      while (runner != domsb)\n \t\t{\n-\t\t  if (!bitmap_set_bit (&frontiers[runner->index],\n-\t\t\t\t       b->index))\n+\t\t  if (!bitmap_set_bit (&frontiers[runner->index], b->index))\n \t\t    break;\n-\t\t  runner = get_immediate_dominator (CDI_DOMINATORS,\n-\t\t\t\t\t\t    runner);\n+\t\t  runner = get_immediate_dominator (CDI_DOMINATORS, runner);\n \t\t}\n \t    }\n \t}\n     }\n-}\n-\n-\n-void\n-compute_dominance_frontiers (bitmap_head *frontiers)\n-{\n-  timevar_push (TV_DOM_FRONTIERS);\n-\n-  compute_dominance_frontiers_1 (frontiers);\n \n   timevar_pop (TV_DOM_FRONTIERS);\n }\n@@ -1385,25 +1374,26 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n   unsigned bb_index, i;\n   bitmap phi_insertion_points;\n \n-  /* Each block can appear at most twice on the work-stack.  */\n-  auto_vec<int> work_stack (2 * n_basic_blocks_for_fn (cfun));\n   phi_insertion_points = BITMAP_ALLOC (NULL);\n \n-  /* Seed the work list with all the blocks in DEF_BLOCKS.  We use\n-     vec::quick_push here for speed.  This is safe because we know that\n-     the number of definition blocks is no greater than the number of\n-     basic blocks, which is the initial capacity of WORK_STACK.  */\n-  EXECUTE_IF_SET_IN_BITMAP (def_blocks, 0, bb_index, bi)\n-    work_stack.quick_push (bb_index);\n+  /* Seed the work set with all the blocks in DEF_BLOCKS.  */\n+  auto_bitmap work_set;\n+  bitmap_copy (work_set, def_blocks);\n+  bitmap_tree_view (work_set);\n \n-  /* Pop a block off the worklist, add every block that appears in\n+  /* Pop a block off the workset, add every block that appears in\n      the original block's DF that we have not already processed to\n-     the worklist.  Iterate until the worklist is empty.   Blocks\n-     which are added to the worklist are potential sites for\n+     the workset.  Iterate until the workset is empty.   Blocks\n+     which are added to the workset are potential sites for\n      PHI nodes.  */\n-  while (work_stack.length () > 0)\n+  while (!bitmap_empty_p (work_set))\n     {\n-      bb_index = work_stack.pop ();\n+      /* The dominance frontier of a block is blocks after it so iterating\n+         on earlier blocks first is better.\n+\t ???  Basic blocks are by no means guaranteed to be ordered in\n+\t optimal order for this iteration.  */\n+      bb_index = bitmap_first_set_bit (work_set);\n+      bitmap_clear_bit (work_set, bb_index);\n \n       /* Since the registration of NEW -> OLD name mappings is done\n \t separately from the call to update_ssa, when updating the SSA\n@@ -1416,7 +1406,7 @@ compute_idf (bitmap def_blocks, bitmap_head *dfs)\n       EXECUTE_IF_AND_COMPL_IN_BITMAP (&dfs[bb_index], phi_insertion_points,\n \t                              0, i, bi)\n \t{\n-\t  work_stack.quick_push (i);\n+\t  bitmap_set_bit (work_set, i);\n \t  bitmap_set_bit (phi_insertion_points, i);\n \t}\n     }"}, {"sha": "e3590d712b0f543c08ed5142bd6dc84f811c8ef9", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=d78b70959f334699bf556e9b8d4e0a8c12a64b46", "patch": "@@ -661,15 +661,14 @@ class loop_iterator\n {\n public:\n   loop_iterator (function *fn, loop_p *loop, unsigned flags);\n-  ~loop_iterator ();\n \n   inline loop_p next ();\n \n   /* The function we are visiting.  */\n   function *fn;\n \n   /* The list of loops to visit.  */\n-  vec<int> to_visit;\n+  auto_vec<int, 16> to_visit;\n \n   /* The index of the actual loop.  */\n   unsigned idx;\n@@ -702,12 +701,11 @@ loop_iterator::loop_iterator (function *fn, loop_p *loop, unsigned flags)\n   this->fn = fn;\n   if (!loops_for_fn (fn))\n     {\n-      this->to_visit.create (0);\n       *loop = NULL;\n       return;\n     }\n \n-  this->to_visit.create (number_of_loops (fn));\n+  this->to_visit.reserve_exact (number_of_loops (fn));\n   mn = (flags & LI_INCLUDE_ROOT) ? 0 : 1;\n \n   if (flags & LI_ONLY_INNERMOST)\n@@ -769,12 +767,6 @@ loop_iterator::loop_iterator (function *fn, loop_p *loop, unsigned flags)\n   *loop = this->next ();\n }\n \n-inline\n-loop_iterator::~loop_iterator ()\n-{\n-  this->to_visit.release ();\n-}\n-\n #define FOR_EACH_LOOP(LOOP, FLAGS) \\\n   for (loop_iterator li(cfun, &(LOOP), FLAGS); \\\n        (LOOP); \\"}, {"sha": "e2c937703b769f54c7600a2a5839b3d43cb23cba", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=d78b70959f334699bf556e9b8d4e0a8c12a64b46", "patch": "@@ -940,14 +940,18 @@ mark_phi_for_rewrite (basic_block bb, gphi *phi)\n   if (!blocks_with_phis_to_rewrite)\n     return;\n \n-  bitmap_set_bit (blocks_with_phis_to_rewrite, idx);\n-\n-  n = (unsigned) last_basic_block_for_fn (cfun) + 1;\n-  if (phis_to_rewrite.length () < n)\n-    phis_to_rewrite.safe_grow_cleared (n);\n+  if (bitmap_set_bit (blocks_with_phis_to_rewrite, idx))\n+    {\n+      n = (unsigned) last_basic_block_for_fn (cfun) + 1;\n+      if (phis_to_rewrite.length () < n)\n+\tphis_to_rewrite.safe_grow_cleared (n);\n \n-  phis = phis_to_rewrite[idx];\n-  phis.reserve (10);\n+      phis = phis_to_rewrite[idx];\n+      gcc_assert (!phis.exists ());\n+      phis.create (10);\n+    }\n+  else\n+    phis = phis_to_rewrite[idx];\n \n   phis.safe_push (phi);\n   phis_to_rewrite[idx] = phis;\n@@ -2937,11 +2941,7 @@ delete_update_ssa (void)\n \n   if (blocks_with_phis_to_rewrite)\n     EXECUTE_IF_SET_IN_BITMAP (blocks_with_phis_to_rewrite, 0, i, bi)\n-      {\n-\tvec<gphi *> phis = phis_to_rewrite[i];\n-\tphis.release ();\n-\tphis_to_rewrite[i].create (0);\n-      }\n+      phis_to_rewrite[i].release ();\n \n   BITMAP_FREE (blocks_with_phis_to_rewrite);\n   BITMAP_FREE (blocks_to_update);"}, {"sha": "8070021223a6acc9a8329a0d5f63722c37339d30", "filename": "gcc/vec.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d78b70959f334699bf556e9b8d4e0a8c12a64b46/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=d78b70959f334699bf556e9b8d4e0a8c12a64b46", "patch": "@@ -295,6 +295,11 @@ va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact\n }\n \n \n+#if GCC_VERSION >= 4007\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wfree-nonheap-object\"\n+#endif\n+\n /* Free the heap space allocated for vector V.  */\n \n template<typename T>\n@@ -312,6 +317,9 @@ va_heap::release (vec<T, va_heap, vl_embed> *&v)\n   v = NULL;\n }\n \n+#if GCC_VERSION >= 4007\n+#pragma GCC diagnostic pop\n+#endif\n \n /* Allocator type for GC vectors.  Notice that we need the structure\n    declaration even if GC is not enabled.  */"}]}