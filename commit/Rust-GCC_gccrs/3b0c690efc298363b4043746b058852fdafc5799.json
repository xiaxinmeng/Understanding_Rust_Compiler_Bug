{"sha": "3b0c690efc298363b4043746b058852fdafc5799", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IwYzY5MGVmYzI5ODM2M2I0MDQzNzQ2YjA1ODg1MmZkYWZjNTc5OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2010-08-04T15:50:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-08-04T15:50:10Z"}, "message": "c-ada-spec.c (dump_ada_template): Mark underlying instance type as visited.\n\n\t* c-ada-spec.c (dump_ada_template): Mark underlying instance type as\n\tvisited.\n\t(dump_generic_ada_node): Code clean up. Use TREE_VISITED flag to\n\tdecide whether a type has already been declared/seen.\n\tDo not go to the original type.\n\t(dump_nested_types): New parameter forward.\n\tGenerate forward declaration if needed and mark type as visited.\n\t(print_ada_declaration): Call dump_nested_types if not already done.\n\tMark types as visited.\n\nFrom-SVN: r162868", "tree": {"sha": "c5e2853f537f5deab584b38d7d37a62b66a386d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5e2853f537f5deab584b38d7d37a62b66a386d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b0c690efc298363b4043746b058852fdafc5799", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0c690efc298363b4043746b058852fdafc5799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0c690efc298363b4043746b058852fdafc5799", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0c690efc298363b4043746b058852fdafc5799/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55e3bc4cec7595280c4a69b258cafd887b6d9684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e3bc4cec7595280c4a69b258cafd887b6d9684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e3bc4cec7595280c4a69b258cafd887b6d9684"}], "stats": {"total": 84, "additions": 54, "deletions": 30}, "files": [{"sha": "66554e31ee250658830712296cf07a3819b8a27b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c690efc298363b4043746b058852fdafc5799/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c690efc298363b4043746b058852fdafc5799/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3b0c690efc298363b4043746b058852fdafc5799", "patch": "@@ -1,3 +1,15 @@\n+2010-08-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* c-ada-spec.c (dump_ada_template): Mark underlying instance type as\n+\tvisited.\n+\t(dump_generic_ada_node): Code clean up. Use TREE_VISITED flag to\n+\tdecide whether a type has already been declared/seen.\n+\tDo not go to the original type.\n+\t(dump_nested_types): New parameter forward.\n+\tGenerate forward declaration if needed and mark type as visited.\n+\t(print_ada_declaration): Call dump_nested_types if not already done.\n+\tMark types as visited.\n+\n 2010-08-03  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c.opt (-print-pch-checksum): Remove option."}, {"sha": "d8910a8d78787c7c3833cfbc85c0054361f54c9b", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0c690efc298363b4043746b058852fdafc5799/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0c690efc298363b4043746b058852fdafc5799/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=3b0c690efc298363b4043746b058852fdafc5799", "patch": "@@ -1688,6 +1688,7 @@ dump_ada_template (pretty_printer *buffer, tree t,\n       spc += INDENT_INCR;\n       newline_and_indent (buffer, spc);\n \n+      TREE_VISITED (get_underlying_decl (instance)) = 1;\n       pp_string (buffer, \"type \");\n       dump_generic_ada_node (buffer, instance, t, cpp_check, spc, false, true);\n       package_prefix = true;\n@@ -1994,7 +1995,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t\t  /* For now, handle all access-to-access or\n \t\t     access-to-unknown-structs as opaque system.address.  */\n \n-\t\t  tree typ = TYPE_NAME (TREE_TYPE (node));\n+\t\t  tree type_name = TYPE_NAME (TREE_TYPE (node));\n \t\t  const_tree typ2 = !type ||\n \t\t    DECL_P (type) ? type : TYPE_NAME (type);\n \t\t  const_tree underlying_type =\n@@ -2008,7 +2009,13 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t\t\t      || !TYPE_FIELDS (TREE_TYPE (underlying_type))))\n \t\t      /* Pointer to opaque structure.  */\n \n-\t\t      || (typ && typ2\n+\t\t      || (!typ2\n+\t\t\t  && !TREE_VISITED (underlying_type)\n+\t\t\t  && !TREE_VISITED (type_name)\n+\t\t\t  && !is_tagged_type (TREE_TYPE (node))\n+\t\t\t  && DECL_SOURCE_FILE (underlying_type)\n+\t\t\t       == source_file_base)\n+\t\t      || (type_name && typ2\n \t\t\t  && DECL_P (underlying_type)\n \t\t\t  && DECL_P (typ2)\n \t\t\t  && decl_sloc (underlying_type, true)\n@@ -2066,28 +2073,10 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type,\n \t\t    }\n \n \t\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (node))\n-\t\t      && TYPE_NAME (TREE_TYPE (node)))\n-\t\t    {\n-\t\t      tree name = TYPE_NAME (TREE_TYPE (node));\n-\t\t      tree tmp;\n-\n-\t\t      if (TREE_CODE (name) == TYPE_DECL\n-\t\t\t  && DECL_ORIGINAL_TYPE (name)\n-\t\t\t  && TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (name)))\n-\t\t\t{\n-\t\t\t  tmp = TYPE_NAME (TREE_TYPE (TYPE_STUB_DECL\n-\t\t\t    (DECL_ORIGINAL_TYPE (name))));\n-\n-\t\t\t  if (tmp == NULL_TREE)\n-\t\t\t    tmp = TYPE_NAME (TREE_TYPE (node));\n-\t\t\t}\n-\t\t      else\n-\t\t\ttmp = TYPE_NAME (TREE_TYPE (node));\n-\n-\t\t      dump_generic_ada_node\n-\t\t\t(buffer, tmp,\n-\t\t\t TREE_TYPE (node), cpp_check, spc, is_access, true);\n-\t\t    }\n+\t\t      && type_name != NULL_TREE)\n+\t\t    dump_generic_ada_node\n+\t\t      (buffer, type_name,\n+\t\t       TREE_TYPE (node), cpp_check, spc, is_access, true);\n \t\t  else\n \t\t    dump_generic_ada_node\n \t\t      (buffer, TREE_TYPE (node), TREE_TYPE (node),\n@@ -2265,11 +2254,13 @@ print_ada_methods (pretty_printer *buffer, tree node,\n }\n \n /* Dump in BUFFER anonymous types nested inside T's definition.\n-   PARENT is the parent node of T.  CPP_CHECK is used to perform C++ queries on\n+   PARENT is the parent node of T.\n+   FORWARD indicates whether a forward declaration of T should be generated.\n+   CPP_CHECK is used to perform C++ queries on\n    nodes.  SPC is the indentation level.  */\n \n static void\n-dump_nested_types (pretty_printer *buffer, tree t, tree parent,\n+dump_nested_types (pretty_printer *buffer, tree t, tree parent, bool forward,\n \t\t   int (*cpp_check)(tree, cpp_operation), int spc)\n {\n   tree field, outer, decl;\n@@ -2285,6 +2276,16 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent,\n   if (outer == NULL_TREE)\n     return;\n \n+  if (forward)\n+    {\n+      pp_string (buffer, \"type \");\n+      dump_generic_ada_node\n+\t(buffer, t, t, cpp_check, spc, false, true);\n+      pp_semicolon (buffer);\n+      newline_and_indent (buffer, spc);\n+      TREE_VISITED (t) = 1;\n+    }\n+\n   field = TYPE_FIELDS (outer);\n   while (field)\n     {\n@@ -2345,7 +2346,7 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent,\n \n \t      case UNION_TYPE:\n \t\tTREE_VISITED (t) = 1;\n-\t\tdump_nested_types (buffer, field, t, cpp_check, spc);\n+\t\tdump_nested_types (buffer, field, t, false, cpp_check, spc);\n \n \t\tpp_string (buffer, \"type \");\n \n@@ -2400,7 +2401,7 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent,\n \t\t  }\n \n \t\tTREE_VISITED (t) = 1;\n-\t\tdump_nested_types (buffer, field, t, cpp_check, spc);\n+\t\tdump_nested_types (buffer, field, t, false, cpp_check, spc);\n \t\tpp_string (buffer, \"type \");\n \n \t\tif (TYPE_NAME (TREE_TYPE (field)))\n@@ -2436,6 +2437,8 @@ dump_nested_types (pretty_printer *buffer, tree t, tree parent,\n \t}\n       field = TREE_CHAIN (field);\n     }\n+\n+  TREE_VISITED (t) = 1;\n }\n \n /* Dump in BUFFER destructor spec corresponding to T.  */\n@@ -2496,7 +2499,8 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \n       if (orig && TYPE_STUB_DECL (orig))\n \t{\n-\t  tree typ = TREE_TYPE (TYPE_STUB_DECL (orig));\n+\t  tree stub = TYPE_STUB_DECL (orig);\n+\t  tree typ = TREE_TYPE (stub);\n \n \t  if (TYPE_NAME (typ))\n \t    {\n@@ -2515,6 +2519,11 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t\t}\n \t      else\n \t\t{\n+\t\t  if (!TREE_VISITED (stub)\n+\t\t      && DECL_SOURCE_FILE (stub) == source_file_base)\n+\t\t    dump_nested_types\n+\t\t      (buffer, stub, stub, true, cpp_check, spc);\n+\n \t\t  pp_string (buffer, \"subtype \");\n \t\t  dump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n \t\t  pp_string (buffer, \" is \");\n@@ -2588,14 +2597,15 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t      {\n \t\tpp_string (buffer, \"--  skipped anonymous struct \");\n \t\tdump_generic_ada_node (buffer, t, type, 0, spc, false, true);\n+\t\tTREE_VISITED (t) = 1;\n \t\treturn 1;\n \t      }\n \n \t    if (orig && TYPE_NAME (orig) && orig != TREE_TYPE (t))\n \t      pp_string (buffer, \"subtype \");\n \t    else\n \t      {\n-\t\tdump_nested_types (buffer, t, t, cpp_check, spc);\n+\t\tdump_nested_types (buffer, t, t, false, cpp_check, spc);\n \n \t\tif (TYPE_METHODS (TREE_TYPE (t))\n \t\t    || has_static_fields (TREE_TYPE (t)))\n@@ -2640,6 +2650,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t  default:\n \t    pp_string (buffer, \"subtype \");\n \t}\n+      TREE_VISITED (t) = 1;\n     }\n   else\n     {\n@@ -2884,6 +2895,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type,\n \t    }\n \t}\n \n+      TREE_VISITED (t) = 1; \n       if (is_interface)\n \t{\n \t  pp_string (buffer, \"limited interface;  -- \");"}]}