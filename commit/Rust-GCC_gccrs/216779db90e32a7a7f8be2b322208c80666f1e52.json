{"sha": "216779db90e32a7a7f8be2b322208c80666f1e52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE2Nzc5ZGI5MGUzMmE3YTdmOGJlMmIzMjIyMDhjODA2NjZmMWU1Mg==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2019-10-28T10:04:31Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@gcc.gnu.org", "date": "2019-10-28T10:04:31Z"}, "message": "Move jump threading before reload\n\nr266734 has introduced a new instance of jump threading pass in order to\ntake advantage of opportunities that combine opens up.  It was perceived\nback then that it was beneficial to delay it after reload, since that\nmight produce even more such opportunities.\n\nUnfortunately jump threading interferes with hot/cold partitioning.  In\nthe code from PR92007, it converts the following\n\n  +-------------------------- 2/HOT ------------------------+\n  |                                                         |\n  v                                                         v\n3/HOT --> 5/HOT --> 8/HOT --> 11/COLD --> 6/HOT --EH--> 16/HOT\n            |                               ^\n            |                               |\n            +-------------------------------+\n\ninto the following:\n\n  +---------------------- 2/HOT ------------------+\n  |                                               |\n  v                                               v\n3/HOT --> 8/HOT --> 11/COLD --> 6/COLD --EH--> 16/HOT\n\nThis makes hot bb 6 dominated by cold bb 11, and because of this\nfixup_partitions makes bb 6 cold as well, which in turn makes EH edge\n6->16 a crossing one.  Not only can't we have crossing EH edges, we are\nalso not allowed to introduce new crossing edges after reload in\ngeneral, since it might require extra registers on some targets.\n\nTherefore, move the jump threading pass between combine and hot/cold\npartitioning.  Building SPEC 2006 and SPEC 2017 with the old and the new\ncode indicates that:\n\n* When doing jump threading right after reload, 3889 edges are threaded.\n* When doing jump threading right after combine, 3918 edges are\n  threaded.\n\nThis means this change will not introduce performance regressions.\n\ngcc/ChangeLog:\n\n2019-10-28  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\tPR rtl-optimization/92007\n\t* cfgcleanup.c (thread_jump): Add an assertion that we don't\n\tcall it after reload if hot/cold partitioning has been done.\n\t(class pass_postreload_jump): Rename to\n\tpass_jump_after_combine.\n\t(make_pass_postreload_jump): Rename to\n\tmake_pass_jump_after_combine.\n\t* passes.def(pass_postreload_jump): Move before reload, rename\n\tto pass_jump_after_combine.\n\t* tree-pass.h (make_pass_postreload_jump): Rename to\n\tmake_pass_jump_after_combine.\n\ngcc/testsuite/ChangeLog:\n\n2019-10-28  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\tPR rtl-optimization/92007\n\t* g++.dg/opt/pr92007.C: New test (from Arseny Solokha).\n\nFrom-SVN: r277507", "tree": {"sha": "d74628b35ba0dcb86e89d6029f2d3c4c549e4bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d74628b35ba0dcb86e89d6029f2d3c4c549e4bb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/216779db90e32a7a7f8be2b322208c80666f1e52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/216779db90e32a7a7f8be2b322208c80666f1e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/216779db90e32a7a7f8be2b322208c80666f1e52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/216779db90e32a7a7f8be2b322208c80666f1e52/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a0236f8ca9d239bb62ef54c9273e6ca3f068f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0236f8ca9d239bb62ef54c9273e6ca3f068f87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0236f8ca9d239bb62ef54c9273e6ca3f068f87"}], "stats": {"total": 77, "additions": 66, "deletions": 11}, "files": [{"sha": "594738abc611d7c403744e7d10a13af224802d2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=216779db90e32a7a7f8be2b322208c80666f1e52", "patch": "@@ -1,3 +1,17 @@\n+2019-10-28  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\tPR rtl-optimization/92007\n+\t* cfgcleanup.c (thread_jump): Add an assertion that we don't\n+\tcall it after reload if hot/cold partitioning has been done.\n+\t(class pass_postreload_jump): Rename to\n+\tpass_jump_after_combine.\n+\t(make_pass_postreload_jump): Rename to\n+\tmake_pass_jump_after_combine.\n+\t* passes.def(pass_postreload_jump): Move before reload, rename\n+\tto pass_jump_after_combine.\n+\t* tree-pass.h (make_pass_postreload_jump): Rename to\n+\tmake_pass_jump_after_combine.\n+\n 2019-10-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/92242"}, {"sha": "835f7d79ea41409dca188b2362bb5cce4b6e99c3", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=216779db90e32a7a7f8be2b322208c80666f1e52", "patch": "@@ -259,6 +259,10 @@ thread_jump (edge e, basic_block b)\n   bool failed = false;\n   reg_set_iterator rsi;\n \n+  /* Jump threading may cause fixup_partitions to introduce new crossing edges,\n+     which is not allowed after reload.  */\n+  gcc_checking_assert (!reload_completed || !crtl->has_bb_partition);\n+\n   if (b->flags & BB_NONTHREADABLE_BLOCK)\n     return NULL;\n \n@@ -3280,10 +3284,10 @@ make_pass_jump (gcc::context *ctxt)\n \f\n namespace {\n \n-const pass_data pass_data_postreload_jump =\n+const pass_data pass_data_jump_after_combine =\n {\n   RTL_PASS, /* type */\n-  \"postreload_jump\", /* name */\n+  \"jump_after_combine\", /* name */\n   OPTGROUP_NONE, /* optinfo_flags */\n   TV_JUMP, /* tv_id */\n   0, /* properties_required */\n@@ -3293,20 +3297,20 @@ const pass_data pass_data_postreload_jump =\n   0, /* todo_flags_finish */\n };\n \n-class pass_postreload_jump : public rtl_opt_pass\n+class pass_jump_after_combine : public rtl_opt_pass\n {\n public:\n-  pass_postreload_jump (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_postreload_jump, ctxt)\n+  pass_jump_after_combine (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_jump_after_combine, ctxt)\n   {}\n \n   /* opt_pass methods: */\n   virtual unsigned int execute (function *);\n \n-}; // class pass_postreload_jump\n+}; // class pass_jump_after_combine\n \n unsigned int\n-pass_postreload_jump::execute (function *)\n+pass_jump_after_combine::execute (function *)\n {\n   cleanup_cfg (flag_thread_jumps ? CLEANUP_THREADING : 0);\n   return 0;\n@@ -3315,9 +3319,9 @@ pass_postreload_jump::execute (function *)\n } // anon namespace\n \n rtl_opt_pass *\n-make_pass_postreload_jump (gcc::context *ctxt)\n+make_pass_jump_after_combine (gcc::context *ctxt)\n {\n-  return new pass_postreload_jump (ctxt);\n+  return new pass_jump_after_combine (ctxt);\n }\n \n namespace {"}, {"sha": "798a391bd351110d05b89fc6ccc424fd871198a4", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=216779db90e32a7a7f8be2b322208c80666f1e52", "patch": "@@ -439,6 +439,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_ud_rtl_dce);\n       NEXT_PASS (pass_combine);\n       NEXT_PASS (pass_if_after_combine);\n+      NEXT_PASS (pass_jump_after_combine);\n       NEXT_PASS (pass_partition_blocks);\n       NEXT_PASS (pass_outof_cfg_layout_mode);\n       NEXT_PASS (pass_split_all_insns);\n@@ -455,7 +456,6 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_reload);\n       NEXT_PASS (pass_postreload);\n       PUSH_INSERT_PASSES_WITHIN (pass_postreload)\n-\t  NEXT_PASS (pass_postreload_jump);\n \t  NEXT_PASS (pass_postreload_cse);\n \t  NEXT_PASS (pass_gcse2);\n \t  NEXT_PASS (pass_split_after_reload);"}, {"sha": "128679ae408669e71975734632eb3a2e854a091a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=216779db90e32a7a7f8be2b322208c80666f1e52", "patch": "@@ -1,3 +1,8 @@\n+2019-10-28  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\tPR rtl-optimization/92007\n+\t* g++.dg/opt/pr92007.C: New test (from Arseny Solokha).\n+\n 2019-10-28  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR fortran/91863"}, {"sha": "9434cc929dde7a069f0482f0bd0920d08de5c447", "filename": "gcc/testsuite/g++.dg/opt/pr92007.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr92007.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr92007.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr92007.C?ref=216779db90e32a7a7f8be2b322208c80666f1e52", "patch": "@@ -0,0 +1,32 @@\n+// PR rtl-optimization/92007\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-tree-dominator-opts -fno-tree-forwprop --param max-cse-insns=0 -Wno-return-type -std=gnu++98 -freorder-blocks-and-partition\" }\n+\n+void\n+sb (int *);\n+\n+class d4 {\n+public:\n+  ~d4();\n+  void gb ();\n+  int op () { return no; }\n+  int wl () { return tf; }\n+  bool ee () try { gb (); } catch (...) { return false; }\n+  bool b1 () { return (tf == no) ? false : ee (); }\n+\n+private:\n+  int no, tf;\n+};\n+\n+void\n+hs (int *v9)\n+{\n+  d4 p6;\n+\n+  p6.gb ();\n+  if (p6.op () > p6.wl ())\n+    {\n+      p6.b1 ();\n+      sb (v9);\n+    }\n+}"}, {"sha": "a987661530eafabc5f5eb5a4fae27dab8b2e54fb", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/216779db90e32a7a7f8be2b322208c80666f1e52/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=216779db90e32a7a7f8be2b322208c80666f1e52", "patch": "@@ -564,6 +564,7 @@ extern rtl_opt_pass *make_pass_stack_ptr_mod (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_initialize_regs (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_combine (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_if_after_combine (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_jump_after_combine (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_ree (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_partition_blocks (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_match_asm_constraints (gcc::context *ctxt);\n@@ -581,7 +582,6 @@ extern rtl_opt_pass *make_pass_clean_state (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_branch_prob (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_value_profile_transformations (gcc::context\n \t\t\t\t\t\t\t      *ctxt);\n-extern rtl_opt_pass *make_pass_postreload_jump (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_postreload_cse (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_gcse2 (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_split_after_reload (gcc::context *ctxt);"}]}