{"sha": "98934fac3bd8fd149387164ac3ee97795a5e6825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg5MzRmYWMzYmQ4ZmQxNDkzODcxNjRhYzNlZTk3Nzk1YTVlNjgyNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-01T19:54:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-01T19:54:36Z"}, "message": "compiler: add slice initializers to the GC root list\n    \n    As of https://golang.org/cl/32917 we can put slice initializers in the\n    .data section.  The program can still change the values in those\n    slices.  That means that if the slice elements can contain pointers,\n    we need to register the entire initializer as a GC root.\n    \n    This would be straightforward except that we only have a Bexpression\n    for the slice initializer, not an Expression.  So introduce a\n    Backend_expression type that wraps a Bexpression as an Expression.\n    \n    The test case for this is https://golang.org/cl/33790.\n    \n    Reviewed-on: https://go-review.googlesource.com/33792\n\nFrom-SVN: r243129", "tree": {"sha": "02dada663e5216cc65990a964cf7659d5178e50a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02dada663e5216cc65990a964cf7659d5178e50a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98934fac3bd8fd149387164ac3ee97795a5e6825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98934fac3bd8fd149387164ac3ee97795a5e6825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98934fac3bd8fd149387164ac3ee97795a5e6825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98934fac3bd8fd149387164ac3ee97795a5e6825/comments", "author": null, "committer": null, "parents": [{"sha": "0269650d4a53dfdde90e90db701ee6233a61f837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0269650d4a53dfdde90e90db701ee6233a61f837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0269650d4a53dfdde90e90db701ee6233a61f837"}], "stats": {"total": 133, "additions": 128, "deletions": 5}, "files": [{"sha": "5529002b09003123e03f0a4c7d833589e9c1824a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=98934fac3bd8fd149387164ac3ee97795a5e6825", "patch": "@@ -1,4 +1,4 @@\n-97b949f249515a61d3c09e9e06f08c8af189e967\n+b7bad96ce0af50a1129eaab9aa110d68a601917b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "9740d324a865b963f7dbff989f7b57abda47a8aa", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=98934fac3bd8fd149387164ac3ee97795a5e6825", "patch": "@@ -4295,6 +4295,20 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t\t\t\t\t\t      true, copy_to_heap, false,\n \t\t\t\t\t\t      bexpr);\n \t  bexpr = gogo->backend()->var_expression(implicit, loc);\n+\n+\t  // If we are not copying a slice initializer to the heap,\n+\t  // then it can be changed by the program, so if it can\n+\t  // contain pointers we must register it as a GC root.\n+\t  if (this->is_slice_init_\n+\t      && !copy_to_heap\n+\t      && this->expr_->type()->has_pointer())\n+\t    {\n+\t      Bexpression* root =\n+\t\tgogo->backend()->var_expression(implicit, loc);\n+\t      root = gogo->backend()->address_expression(root, loc);\n+\t      Type* type = Type::make_pointer_type(this->expr_->type());\n+\t      gogo->add_gc_root(Expression::make_backend(root, type, loc));\n+\t    }\n \t}\n       else if ((this->expr_->is_composite_literal()\n \t\t|| this->expr_->string_expression() != NULL)\n@@ -15433,6 +15447,28 @@ Expression::make_compound(Expression* init, Expression* expr, Location location)\n   return new Compound_expression(init, expr, location);\n }\n \n+// Class Backend_expression.\n+\n+int\n+Backend_expression::do_traverse(Traverse*)\n+{\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+void\n+Backend_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << \"backend_expression<\";\n+  ast_dump_context->dump_type(this->type_);\n+  ast_dump_context->ostream() << \">\";\n+}\n+\n+Expression*\n+Expression::make_backend(Bexpression* bexpr, Type* type, Location location)\n+{\n+  return new Backend_expression(bexpr, type, location);\n+}\n+\n // Import an expression.  This comes at the end in order to see the\n // various class definitions.\n "}, {"sha": "f31d4a6d0077b65a15fbd1ff526e50cd8d4292f5", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=98934fac3bd8fd149387164ac3ee97795a5e6825", "patch": "@@ -137,7 +137,8 @@ class Expression\n     EXPRESSION_STRUCT_FIELD_OFFSET,\n     EXPRESSION_LABEL_ADDR,\n     EXPRESSION_CONDITIONAL,\n-    EXPRESSION_COMPOUND\n+    EXPRESSION_COMPOUND,\n+    EXPRESSION_BACKEND\n   };\n \n   Expression(Expression_classification, Location);\n@@ -485,6 +486,10 @@ class Expression\n   static Expression*\n   make_compound(Expression*, Expression*, Location);\n \n+  // Make a backend expression.\n+  static Expression*\n+  make_backend(Bexpression*, Type*, Location);\n+\n   // Return the expression classification.\n   Expression_classification\n   classification() const\n@@ -3825,6 +3830,54 @@ class Compound_expression : public Expression\n   Expression* expr_;\n };\n \n+// A backend expression.  This is a backend expression wrapped in an\n+// Expression, for convenience during backend generation.\n+\n+class Backend_expression : public Expression\n+{\n+ public:\n+  Backend_expression(Bexpression* bexpr, Type* type, Location location)\n+    : Expression(EXPRESSION_BACKEND, location), bexpr_(bexpr), type_(type)\n+  {}\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  // For now these are always valid static initializers.  If that\n+  // changes we can change this.\n+  bool\n+  do_is_static_initializer() const\n+  { return true; }\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Backend_expression(this->bexpr_, this->type_, this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*)\n+  { return this->bexpr_; }\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The backend expression we are wrapping.\n+  Bexpression* bexpr_;\n+  // The type of the expression;\n+  Type* type_;\n+};\n+\n // A numeric constant.  This is used both for untyped constants and\n // for constants that have a type.\n "}, {"sha": "d685bcaeef668a5f37debbb13c68f601083f13ab", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=98934fac3bd8fd149387164ac3ee97795a5e6825", "patch": "@@ -54,7 +54,9 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n     interface_types_(),\n     specific_type_functions_(),\n     specific_type_functions_are_written_(false),\n-    named_types_are_converted_(false)\n+    named_types_are_converted_(false),\n+    analysis_sets_(),\n+    gc_roots_()\n {\n   const Location loc = Linemap::predeclared_location();\n \n@@ -750,10 +752,9 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n \n   Expression_list* roots_init = new Expression_list();\n \n-  size_t i = 0;\n   for (std::vector<Named_object*>::const_iterator p = var_gc.begin();\n        p != var_gc.end();\n-       ++p, ++i)\n+       ++p)\n     {\n       Expression_list* init = new Expression_list();\n \n@@ -772,6 +773,27 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n       roots_init->push_back(root_ctor);\n     }\n \n+  for (std::vector<Expression*>::const_iterator p = this->gc_roots_.begin();\n+       p != this->gc_roots_.end();\n+       ++p)\n+    {\n+      Expression_list *init = new Expression_list();\n+\n+      Expression* expr = *p;\n+      Location eloc = expr->location();\n+      init->push_back(expr);\n+\n+      Type* type = expr->type()->points_to();\n+      go_assert(type != NULL);\n+      Expression* size =\n+\tExpression::make_type_info(type, Expression::TYPE_INFO_SIZE);\n+      init->push_back(size);\n+\n+      Expression* root_ctor =\n+\tExpression::make_struct_composite_literal(root_type, init, eloc);\n+      roots_init->push_back(root_ctor);\n+    }\n+\n   // The list ends with a NULL entry.\n \n   Expression_list* null_init = new Expression_list();"}, {"sha": "7ddb3ce3cedf13b64635ca2dc386f5d298ed1bb0", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98934fac3bd8fd149387164ac3ee97795a5e6825/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=98934fac3bd8fd149387164ac3ee97795a5e6825", "patch": "@@ -19,6 +19,7 @@ class Typed_identifier;\n class Typed_identifier_list;\n class Function_type;\n class Expression;\n+class Expression_list;\n class Statement;\n class Temporary_statement;\n class Block;\n@@ -556,6 +557,15 @@ class Gogo\n   specific_type_functions_are_written() const\n   { return this->specific_type_functions_are_written_; }\n \n+  // Add a pointer that needs to be added to the list of objects\n+  // traversed by the garbage collector.  This should be an expression\n+  // of pointer type that points to static storage.  It's not\n+  // necessary to add global variables to this list, just global\n+  // variable initializers that would otherwise not be seen.\n+  void\n+  add_gc_root(Expression* expr)\n+  { this->gc_roots_.push_back(expr); }\n+\n   // Traverse the tree.  See the Traverse class.\n   void\n   traverse(Traverse*);\n@@ -892,6 +902,8 @@ class Gogo\n   // A list containing groups of possibly mutually recursive functions to be\n   // considered during escape analysis.\n   std::vector<Analysis_set> analysis_sets_;\n+  // A list of objects to add to the GC roots.\n+  std::vector<Expression*> gc_roots_;\n };\n \n // A block of statements."}]}