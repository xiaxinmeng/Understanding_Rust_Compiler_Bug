{"sha": "6d459e2baebdc8206fba20befccf8ee13a0366f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ0NTllMmJhZWJkYzgyMDZmYmEyMGJlZmNjZjhlZTEzYTAzNjZmMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-07-20T09:48:03Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-07-20T09:48:03Z"}, "message": "bfin-protos.h (bfin_longcall_p): Declare.\n\n\t* config/bfin/bfin-protos.h (bfin_longcall_p): Declare.\n\t* config/bfin/predicates.md (symbol_ref_operand): New.\n\t(call_insn_operand): Delete.  All callers changed to use\n\tregister_no_elim_operand.\n\t* config/bfin/bfin.c (init_cumulative_args): Initialize the new\n\tcall_cookie field.\n\t(function_arg): Use it to generate the call's operand 2.\n\t(bfin_longcall_p): New function.\n\t(bfin_expand_call): Extra arg \"cookie\".  All callers and declaration\n\tchanged.  Emit extra USE in the pattern.  Use bfin_longcall_p to\n\tdetermine if the address needs to be in a REG.\n\t(bfin_handle_longcall_attribute): New function.\n\t(bfin_attribute_table): Add \"longcall\" and \"shortcall\".\n\t* config/bfin/bfin.h (CALL_NORMAL, CALL_LONG, CALL_SHORT): New macros.\n\t(CUMULATIVE_ARGS): New member call_cookie.\n\t(PREDICATE_CODES): Add symbol_ref_operand.\n\t* config/bfin/bfin.md (call, call_value, sibcall, sibcall_value): Add\n\textra USE to the pattern.\n\t(call_symbol, sibcall_symbol, call_value_symbol, sibcall_value_symbol):\n\tNew patterns, split off call_insn, sibcall_insn, call_value_insn and\n\tsibcall_value_insn; now the new patterns handle direct calls and the\n\told ones indirect calls.\n\t* doc/extend.texi: Mention Blackfin in longcall/shortcall docs.\n\nFrom-SVN: r102191", "tree": {"sha": "f25b02efbca3753d97500a06c643689dce3058d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f25b02efbca3753d97500a06c643689dce3058d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d459e2baebdc8206fba20befccf8ee13a0366f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d459e2baebdc8206fba20befccf8ee13a0366f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d459e2baebdc8206fba20befccf8ee13a0366f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d459e2baebdc8206fba20befccf8ee13a0366f2/comments", "author": null, "committer": null, "parents": [{"sha": "67135ef48c6a53e06305d1038c4855e887568989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67135ef48c6a53e06305d1038c4855e887568989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67135ef48c6a53e06305d1038c4855e887568989"}], "stats": {"total": 299, "additions": 229, "deletions": 70}, "files": [{"sha": "5704cca606acfb648d45266085c0c6fea724b358", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d459e2baebdc8206fba20befccf8ee13a0366f2", "patch": "@@ -1,3 +1,29 @@\n+2005-07-20  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin-protos.h (bfin_longcall_p): Declare.\n+\t* config/bfin/predicates.md (symbol_ref_operand): New.\n+\t(call_insn_operand): Delete.  All callers changed to use\n+\tregister_no_elim_operand.\n+\t* config/bfin/bfin.c (init_cumulative_args): Initialize the new\n+\tcall_cookie field.\n+\t(function_arg): Use it to generate the call's operand 2.\n+\t(bfin_longcall_p): New function.\n+\t(bfin_expand_call): Extra arg \"cookie\".  All callers and declaration\n+\tchanged.  Emit extra USE in the pattern.  Use bfin_longcall_p to\n+\tdetermine if the address needs to be in a REG.\n+\t(bfin_handle_longcall_attribute): New function.\n+\t(bfin_attribute_table): Add \"longcall\" and \"shortcall\".\n+\t* config/bfin/bfin.h (CALL_NORMAL, CALL_LONG, CALL_SHORT): New macros.\n+\t(CUMULATIVE_ARGS): New member call_cookie.\n+\t(PREDICATE_CODES): Add symbol_ref_operand.\n+\t* config/bfin/bfin.md (call, call_value, sibcall, sibcall_value): Add\n+\textra USE to the pattern.\n+\t(call_symbol, sibcall_symbol, call_value_symbol, sibcall_value_symbol):\n+\tNew patterns, split off call_insn, sibcall_insn, call_value_insn and\n+\tsibcall_value_insn; now the new patterns handle direct calls and the\n+\told ones indirect calls.\n+\t* doc/extend.texi: Mention Blackfin in longcall/shortcall docs.\n+\n 2005-07-20  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* doc/trouble.texi: Update section on handling of empty loops."}, {"sha": "7f69a6899b2209bb72bd0079b734080acdda4d36", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=6d459e2baebdc8206fba20befccf8ee13a0366f2", "patch": "@@ -45,7 +45,8 @@ extern int effective_address_32bit_p (rtx, Mmode);\n extern int symbolic_reference_mentioned_p (rtx);\n extern rtx bfin_gen_compare (rtx, Mmode);\n extern void expand_move (rtx *, Mmode);\n-extern void bfin_expand_call (rtx, rtx, rtx, int);\n+extern void bfin_expand_call (rtx, rtx, rtx, rtx, int);\n+extern bool bfin_longcall_p (rtx, int);\n extern bool bfin_expand_strmov (rtx, rtx, rtx, rtx);\n \n extern void conditional_register_usage (void);"}, {"sha": "c4ee58b4ae59ea2961ff1348bb698d51883abb2e", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 84, "deletions": 14, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=6d459e2baebdc8206fba20befccf8ee13a0366f2", "patch": "@@ -1146,7 +1146,7 @@ print_operand (FILE *file, rtx x, char code)\n */\n \n void\n-init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype ATTRIBUTE_UNUSED,\n+init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t      rtx libname ATTRIBUTE_UNUSED)\n {\n   static CUMULATIVE_ARGS zero_cum;\n@@ -1158,6 +1158,13 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype ATTRIBUTE_UNUSED,\n   cum->nregs = max_arg_registers;\n   cum->arg_regs = arg_regs;\n \n+  cum->call_cookie = CALL_NORMAL;\n+  /* Check for a longcall attribute.  */\n+  if (fntype && lookup_attribute (\"shortcall\", TYPE_ATTRIBUTES (fntype)))\n+    cum->call_cookie |= CALL_SHORT;\n+  else if (fntype && lookup_attribute (\"longcall\", TYPE_ATTRIBUTES (fntype)))\n+    cum->call_cookie |= CALL_LONG;\n+\n   return;\n }\n \n@@ -1211,6 +1218,10 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   int bytes\n     = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n \n+  if (mode == VOIDmode)\n+    /* Compute operand 2 of the call insn.  */\n+    return GEN_INT (cum->call_cookie);\n+\n   if (bytes == -1)\n     return NULL_RTX;\n \n@@ -1508,37 +1519,59 @@ split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n     }\n }\n \f\n+bool\n+bfin_longcall_p (rtx op, int call_cookie)\n+{\n+  gcc_assert (GET_CODE (op) == SYMBOL_REF);\n+  if (call_cookie & CALL_SHORT)\n+    return 0;\n+  if (call_cookie & CALL_LONG)\n+    return 1;\n+  if (TARGET_LONG_CALLS)\n+    return 1;\n+  return 0;\n+}\n+\n /* Expand a call instruction.  FNADDR is the call target, RETVAL the return value.\n+   COOKIE is a CONST_INT holding the call_cookie prepared init_cumulative_args.\n    SIBCALL is nonzero if this is a sibling call.  */\n \n void\n-bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, int sibcall)\n+bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx cookie, int sibcall)\n {\n   rtx use = NULL, call;\n+  rtx callee = XEXP (fnaddr, 0);\n+  rtx pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (sibcall ? 3 : 2));\n+\n+  /* In an untyped call, we can get NULL for operand 2.  */\n+  if (cookie == NULL_RTX)\n+    cookie = const0_rtx;\n \n   /* Static functions and indirect calls don't need the pic register.  */\n   if (flag_pic\n-      && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n-      && ! SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))\n+      && GET_CODE (callee) == SYMBOL_REF\n+      && !SYMBOL_REF_LOCAL_P (callee))\n     use_reg (&use, pic_offset_table_rtx);\n \n-  if (! call_insn_operand (XEXP (fnaddr, 0), Pmode))\n+  if ((!register_no_elim_operand (callee, Pmode)\n+       && GET_CODE (callee) != SYMBOL_REF)\n+      || (GET_CODE (callee) == SYMBOL_REF\n+\t  && (flag_pic\n+\t      || bfin_longcall_p (callee, INTVAL (cookie)))))\n     {\n-      fnaddr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));\n-      fnaddr = gen_rtx_MEM (Pmode, fnaddr);\n+      callee = copy_to_mode_reg (Pmode, callee);\n+      fnaddr = gen_rtx_MEM (Pmode, callee);\n     }\n   call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);\n \n   if (retval)\n     call = gen_rtx_SET (VOIDmode, retval, call);\n+\n+  XVECEXP (pat, 0, 0) = call;\n+  XVECEXP (pat, 0, 1) = gen_rtx_USE (VOIDmode, cookie);\n   if (sibcall)\n-    {\n-      rtx pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n-      XVECEXP (pat, 0, 0) = call;\n-      XVECEXP (pat, 0, 1) = gen_rtx_RETURN (VOIDmode);\n-      call = pat;\n-    }\n-  call = emit_call_insn (call);\n+    XVECEXP (pat, 0, 2) = gen_rtx_RETURN (VOIDmode);\n+  call = emit_call_insn (pat);\n   if (use)\n     CALL_INSN_FUNCTION_USAGE (call) = use;\n }\n@@ -2668,9 +2701,44 @@ bfin_comp_type_attributes (tree type1, tree type2)\n       != !lookup_attribute (\"kspisusp\", TYPE_ATTRIBUTES (type2)))\n     return 0;\n \n+  if (!lookup_attribute (\"longcall\", TYPE_ATTRIBUTES (type1))\n+      != !lookup_attribute (\"longcall\", TYPE_ATTRIBUTES (type2)))\n+    return 0;\n+\n   return 1;\n }\n \n+/* Handle a \"longcall\" or \"shortcall\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+bfin_handle_longcall_attribute (tree *node, tree name, \n+\t\t\t\ttree args ATTRIBUTE_UNUSED, \n+\t\t\t\tint flags ATTRIBUTE_UNUSED, \n+\t\t\t\tbool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n+    {\n+      warning (OPT_Wattributes, \"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  if ((strcmp (IDENTIFIER_POINTER (name), \"longcall\") == 0\n+       && lookup_attribute (\"shortcall\", TYPE_ATTRIBUTES (*node)))\n+      || (strcmp (IDENTIFIER_POINTER (name), \"shortcall\") == 0\n+\t  && lookup_attribute (\"longcall\", TYPE_ATTRIBUTES (*node))))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"can't apply both longcall and shortcall attributes to the same function\");\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Table of valid machine attributes.  */\n const struct attribute_spec bfin_attribute_table[] =\n {\n@@ -2681,6 +2749,8 @@ const struct attribute_spec bfin_attribute_table[] =\n   { \"nesting\", 0, 0, false, true,  true, NULL },\n   { \"kspisusp\", 0, 0, false, true,  true, NULL },\n   { \"saveall\", 0, 0, false, true,  true, NULL },\n+  { \"longcall\",  0, 0, false, true,  true,  bfin_handle_longcall_attribute },\n+  { \"shortcall\", 0, 0, false, true,  true,  bfin_handle_longcall_attribute },\n   { NULL, 0, 0, false, false, false, NULL }\n };\n \f"}, {"sha": "cfc6f5bc50b98669ccfeea33d2460129771b5409", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=6d459e2baebdc8206fba20befccf8ee13a0366f2", "patch": "@@ -530,10 +530,16 @@ typedef enum {\n \n #define FUNCTION_ARG_REGISTERS { REG_R0, REG_R1, REG_R2, -1 }\n \n+/* Flags for the call/call_value rtl operations set up by function_arg */\n+#define CALL_NORMAL\t\t0x00000000\t/* no special processing */\n+#define CALL_LONG\t\t0x00000001\t/* always call indirect */\n+#define CALL_SHORT\t\t0x00000002\t/* always call by symbol */\n+\n typedef struct {\n   int words;\t\t\t/* # words passed so far */\n   int nregs;\t\t\t/* # registers available for passing */\n   int *arg_regs;\t\t/* array of register -1 terminated */\n+  int call_cookie;\t\t/* Do special things for this call */\n } CUMULATIVE_ARGS;\n \n /* Define where to put the arguments to a function."}, {"sha": "d0c93b4b42fab5c7630646d6c69e5a1deb8e1a83", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 103, "deletions": 43, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=6d459e2baebdc8206fba20befccf8ee13a0366f2", "patch": "@@ -1304,80 +1304,140 @@\n ;;  Call instructions..\n \n (define_expand \"call\"\n-  [(call (match_operand:SI 0 \"\" \"\")\n-\t (match_operand 1 \"\" \"\"))]\n+  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))])]\n   \"\"\n-  \"bfin_expand_call (NULL_RTX, operands[0], operands[1], 0); DONE;\")\n+{\n+  bfin_expand_call (NULL_RTX, operands[0], operands[1], operands[2], 0);\n+  DONE;\n+})\n \n (define_expand \"sibcall\"\n   [(parallel [(call (match_operand:SI 0 \"\" \"\")\n \t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n \t      (return)])]\n   \"\"\n-  \"bfin_expand_call (NULL_RTX, operands[0], operands[1], 1); DONE;\")\n+{\n+  bfin_expand_call (NULL_RTX, operands[0], operands[1], operands[2], 1);\n+  DONE;\n+})\n \n (define_expand \"call_value\"\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-         (call (match_operand:SI 1 \"\" \"\")\n-\t       (match_operand 2 \"\" \"\")))]\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t   (call (match_operand:SI 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))])]\n   \"\"\n-  \"bfin_expand_call (operands[0], operands[1], operands[2], 0); DONE;\")\n+{\n+  bfin_expand_call (operands[0], operands[1], operands[2], operands[3], 0);\n+  DONE;\n+})\n \n (define_expand \"sibcall_value\"\n   [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n \t\t   (call (match_operand:SI 1 \"\" \"\")\n \t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))\n \t      (return)])]\n   \"\"\n-  \"bfin_expand_call (operands[0], operands[1], operands[2], 1); DONE;\")\n+{\n+  bfin_expand_call (operands[0], operands[1], operands[2], operands[3], 1);\n+  DONE;\n+})\n \n-(define_insn \"*call_insn\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"a,Q\"))\n-\t (match_operand 1 \"general_operand\" \"g,g\"))]\n+(define_insn \"*call_symbol\"\n+  [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"Q\"))\n+\t (match_operand 1 \"general_operand\" \"g\"))\n+   (use (match_operand 2 \"\" \"\"))]\n   \"! SIBLING_CALL_P (insn)\n-   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n-  \"@\n-  call (%0);\n-  call %G0;\"\n+   && !flag_pic\n+   && GET_CODE (operands[0]) == SYMBOL_REF\n+   && !bfin_longcall_p (operands[0], INTVAL (operands[2]))\"\n+  \"call %G0;\"\n   [(set_attr \"type\" \"call\")\n-   (set_attr \"length\" \"2,4\")])\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn \"*sibcall_insn\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"z,Q\"))\n-\t (match_operand 1 \"general_operand\" \"g,g\"))\n+(define_insn \"*sibcall_symbol\"\n+  [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"Q\"))\n+\t (match_operand 1 \"general_operand\" \"g\"))\n+   (use (match_operand 2 \"\" \"\"))\n    (return)]\n   \"SIBLING_CALL_P (insn)\n-   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n-  \"@\n-  jump (%0);\n-  jump.l %G0;\"\n+   && !flag_pic\n+   && GET_CODE (operands[0]) == SYMBOL_REF\n+   && !bfin_longcall_p (operands[0], INTVAL (operands[2]))\"\n+  \"jump.l %G0;\"\n   [(set_attr \"type\" \"br\")\n-   (set_attr \"length\" \"2,4\")])\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn \"*call_value_insn\"\n-  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n-        (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"a,Q\"))\n-\t      (match_operand 2 \"general_operand\" \"g,g\")))]\n+(define_insn \"*call_value_symbol\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+        (call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"Q\"))\n+\t      (match_operand 2 \"general_operand\" \"g\")))\n+   (use (match_operand 3 \"\" \"\"))]\n   \"! SIBLING_CALL_P (insn)\n-   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n-  \"@\n-  call (%1);\n-  call %G1;\"\n+   && !flag_pic\n+   && GET_CODE (operands[1]) == SYMBOL_REF\n+   && !bfin_longcall_p (operands[1], INTVAL (operands[3]))\"\n+  \"call %G1;\"\n   [(set_attr \"type\" \"call\")\n-   (set_attr \"length\" \"2,4\")])\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn \"*sibcall_value_insn\"\n-  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n-         (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"z,Q\"))\n-\t       (match_operand 2 \"general_operand\" \"g,g\")))\n+(define_insn \"*sibcall_value_symbol\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+         (call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"Q\"))\n+\t       (match_operand 2 \"general_operand\" \"g\")))\n+   (use (match_operand 3 \"\" \"\"))\n    (return)]\n   \"SIBLING_CALL_P (insn)\n-   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n-  \"@\n-  jump (%1);\n-  jump.l %G1;\"\n+   && !flag_pic\n+   && GET_CODE (operands[1]) == SYMBOL_REF\n+   && !bfin_longcall_p (operands[1], INTVAL (operands[3]))\"\n+  \"jump.l %G1;\"\n+  [(set_attr \"type\" \"br\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*call_insn\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_no_elim_operand\" \"a\"))\n+\t (match_operand 1 \"general_operand\" \"g\"))\n+   (use (match_operand 2 \"\" \"\"))]\n+  \"! SIBLING_CALL_P (insn)\"\n+  \"call (%0);\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*sibcall_insn\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_no_elim_operand\" \"z\"))\n+\t (match_operand 1 \"general_operand\" \"g\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (return)]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"jump (%0);\"\n+  [(set_attr \"type\" \"br\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*call_value_insn\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+        (call (mem:SI (match_operand:SI 1 \"register_no_elim_operand\" \"a\"))\n+\t      (match_operand 2 \"general_operand\" \"g\")))\n+   (use (match_operand 3 \"\" \"\"))]\n+  \"! SIBLING_CALL_P (insn)\"\n+  \"call (%1);\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*sibcall_value_insn\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+         (call (mem:SI (match_operand:SI 1 \"register_no_elim_operand\" \"z\"))\n+\t       (match_operand 2 \"general_operand\" \"g\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (return)]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"jump (%1);\"\n   [(set_attr \"type\" \"br\")\n-   (set_attr \"length\" \"2,4\")])\n+   (set_attr \"length\" \"2\")])\n \n ;; Block move patterns\n "}, {"sha": "bf9972f76670a5abe9de5ab1bbf90002ac524f3c", "filename": "gcc/config/bfin/predicates.md", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=6d459e2baebdc8206fba20befccf8ee13a0366f2", "patch": "@@ -106,6 +106,10 @@\n   (ior (match_code \"const_int,const_double\")\n        (match_operand 0 \"symbolic_operand\")))\n \n+;; Returns 1 if OP is a SYMBOL_REF.\n+(define_predicate \"symbol_ref_operand\"\n+  (match_code \"symbol_ref\"))\n+\n ;; True for any non-virtual or eliminable register.  Used in places where\n ;; instantiation of such a register may cause the pattern to not be recognized.\n (define_predicate \"register_no_elim_operand\"\n@@ -119,14 +123,6 @@\n \t       && REGNO (op) <= LAST_VIRTUAL_REGISTER));\n })\n \n-;; Test for a valid operand for a call instruction.  Don't allow the\n-;; arg pointer register or virtual regs since they may decay into\n-;; reg + const, which the patterns can't handle.\n-;; We only allow SYMBOL_REF if !flag_pic.\n-(define_predicate \"call_insn_operand\"\n-  (ior (and (match_test \"!flag_pic && !TARGET_LONG_CALLS\") (match_code \"symbol_ref\"))\n-       (match_operand 0 \"register_no_elim_operand\")))\n-\n ;; Test for an operator valid in a conditional branch\n (define_predicate \"bfin_cbranch_operator\"\n   (match_code \"eq,ne\"))"}, {"sha": "c5d4fd833004ce6a9f47976c454d658dae23882c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d459e2baebdc8206fba20befccf8ee13a0366f2/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6d459e2baebdc8206fba20befccf8ee13a0366f2", "patch": "@@ -1932,12 +1932,12 @@ instruction directly.\n \n @item longcall/shortcall\n @cindex functions called via pointer on the RS/6000 and PowerPC\n-On the RS/6000 and PowerPC, the @code{longcall} attribute causes the\n-compiler to always call this function via a pointer, just as it would if\n+On the Blackfin, RS/6000 and PowerPC, the @code{longcall} attribute causes\n+the compiler to always call this function via a pointer, just as it would if\n the @option{-mlongcall} option had been specified.  The @code{shortcall}\n attribute causes the compiler not to do this.  These attributes override\n-both the @option{-mlongcall} switch and the @code{#pragma longcall}\n-setting.\n+both the @option{-mlongcall} switch and, on the RS/6000 and PowerPC, the\n+@code{#pragma longcall} setting.\n \n @xref{RS/6000 and PowerPC Options}, for more information on whether long\n calls are necessary."}]}