{"sha": "e2abde5f35ace69607e6664daa9765f50635ad1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJhYmRlNWYzNWFjZTY5NjA3ZTY2NjRkYWE5NzY1ZjUwNjM1YWQxZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-08-31T12:52:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-08-31T12:52:17Z"}, "message": "builtins.c (fold_builtin_memory_op): Use the alias oracle to query if the memory regions for memmove overlap.\n\n2009-08-31  Richard Guenther  <rguenther@suse.de>\n\n\t* builtins.c (fold_builtin_memory_op): Use the alias oracle\n\tto query if the memory regions for memmove overlap.\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Relax the\n\tasserts on pointers, instead deal with odd trees.\n\t(ptr_derefs_may_alias_p): Likewise.\n\t(refs_may_alias_p_1): Constructor bases also never alias.\n\nFrom-SVN: r151241", "tree": {"sha": "07b7dc4c38ed99480adb1d8ac12e3fa86d3742c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07b7dc4c38ed99480adb1d8ac12e3fa86d3742c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2abde5f35ace69607e6664daa9765f50635ad1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2abde5f35ace69607e6664daa9765f50635ad1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2abde5f35ace69607e6664daa9765f50635ad1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2abde5f35ace69607e6664daa9765f50635ad1d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2fbd4117c6872453531aa88123f0ea8efdf1b4df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbd4117c6872453531aa88123f0ea8efdf1b4df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbd4117c6872453531aa88123f0ea8efdf1b4df"}], "stats": {"total": 97, "additions": 27, "deletions": 70}, "files": [{"sha": "928235524fabd8b82e52dc9ac95869fc854e3003", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2abde5f35ace69607e6664daa9765f50635ad1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2abde5f35ace69607e6664daa9765f50635ad1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2abde5f35ace69607e6664daa9765f50635ad1d", "patch": "@@ -1,3 +1,12 @@\n+2009-08-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* builtins.c (fold_builtin_memory_op): Use the alias oracle\n+\tto query if the memory regions for memmove overlap.\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Relax the\n+\tasserts on pointers, instead deal with odd trees.\n+\t(ptr_derefs_may_alias_p): Likewise.\n+\t(refs_may_alias_p_1): Constructor bases also never alias.\n+\n 2009-08-31  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/install.texi (Final install): Adjust reference on where to"}, {"sha": "ed97d485167c60a43e9c4ddc95475bd3733f4d06", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 51, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2abde5f35ace69607e6664daa9765f50635ad1d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2abde5f35ace69607e6664daa9765f50635ad1d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e2abde5f35ace69607e6664daa9765f50635ad1d", "patch": "@@ -8990,6 +8990,8 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \n       if (endp == 3)\n \t{\n+\t  ao_ref srcref, destref;\n+\n \t  src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n \t  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n \n@@ -9012,62 +9014,16 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t    }\n \n \t  /* If *src and *dest can't overlap, optimize into memcpy as well.  */\n-\t  srcvar = build_fold_indirect_ref_loc (loc, src);\n-\t  destvar = build_fold_indirect_ref_loc (loc, dest);\n-\t  if (srcvar\n-\t      && !TREE_THIS_VOLATILE (srcvar)\n-\t      && destvar\n-\t      && !TREE_THIS_VOLATILE (destvar))\n+\t  ao_ref_init_from_ptr_and_size (&srcref, src, len);\n+\t  ao_ref_init_from_ptr_and_size (&destref, dest, len);\n+\t  if (!refs_may_alias_p_1 (&srcref, &destref, false))\n \t    {\n-\t      tree src_base, dest_base, fn;\n-\t      HOST_WIDE_INT src_offset = 0, dest_offset = 0;\n-\t      HOST_WIDE_INT size = -1;\n-\t      HOST_WIDE_INT maxsize = -1;\n-\n-\t      src_base = srcvar;\n-\t      if (handled_component_p (src_base))\n-\t\tsrc_base = get_ref_base_and_extent (src_base, &src_offset,\n-\t\t\t\t\t\t    &size, &maxsize);\n-\t      dest_base = destvar;\n-\t      if (handled_component_p (dest_base))\n-\t\tdest_base = get_ref_base_and_extent (dest_base, &dest_offset,\n-\t\t\t\t\t\t     &size, &maxsize);\n-\t      if (host_integerp (len, 1))\n-\t\t{\n-\t\t  maxsize = tree_low_cst (len, 1);\n-\t\t  if (maxsize\n-\t\t      > INTTYPE_MAXIMUM (HOST_WIDE_INT) / BITS_PER_UNIT)\n-\t\t    maxsize = -1;\n-\t\t  else\n-\t\t    maxsize *= BITS_PER_UNIT;\n-\t\t}\n-\t      else\n-\t\tmaxsize = -1;\n-\t      if (SSA_VAR_P (src_base)\n-\t\t  && SSA_VAR_P (dest_base))\n-\t\t{\n-\t\t  if (operand_equal_p (src_base, dest_base, 0)\n-\t\t      && ranges_overlap_p (src_offset, maxsize,\n-\t\t\t\t\t   dest_offset, maxsize))\n-\t\t    return NULL_TREE;\n-\t\t}\n-\t      else if (TREE_CODE (src_base) == INDIRECT_REF\n-\t\t       && TREE_CODE (dest_base) == INDIRECT_REF)\n-\t\t{\n-\t\t  if (! operand_equal_p (TREE_OPERAND (src_base, 0),\n-\t\t\t\t\t TREE_OPERAND (dest_base, 0), 0)\n-\t\t      || ranges_overlap_p (src_offset, maxsize,\n-\t\t\t\t\t   dest_offset, maxsize))\n-\t\t    return NULL_TREE;\n-\t\t}\n-\t      else\n-\t\treturn NULL_TREE;\n-\n-\t      fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+\t      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n \t      if (!fn)\n \t\treturn NULL_TREE;\n \t      return build_call_expr_loc (loc, fn, 3, dest, src, len);\n \t    }\n+\n \t  return NULL_TREE;\n \t}\n "}, {"sha": "14f1fb47006f422d0d42672a9dd5d216afd3c60b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2abde5f35ace69607e6664daa9765f50635ad1d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2abde5f35ace69607e6664daa9765f50635ad1d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e2abde5f35ace69607e6664daa9765f50635ad1d", "patch": "@@ -168,12 +168,9 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n {\n   struct ptr_info_def *pi;\n \n-  gcc_assert ((TREE_CODE (ptr) == SSA_NAME\n-\t       || TREE_CODE (ptr) == ADDR_EXPR\n-\t       || TREE_CODE (ptr) == INTEGER_CST)\n-\t      && (TREE_CODE (decl) == VAR_DECL\n-\t\t  || TREE_CODE (decl) == PARM_DECL\n-\t\t  || TREE_CODE (decl) == RESULT_DECL));\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL\n+\t      || TREE_CODE (decl) == PARM_DECL\n+\t      || TREE_CODE (decl) == RESULT_DECL);\n \n   /* Non-aliased variables can not be pointed to.  */\n   if (!may_be_aliased (decl))\n@@ -197,9 +194,9 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n \treturn true;\n     }\n \n-  /* We can end up with dereferencing constant pointers.\n+  /* We can end up with dereferencing non-SSA name pointers.\n      Just bail out in this case.  */\n-  if (TREE_CODE (ptr) == INTEGER_CST)\n+  if (TREE_CODE (ptr) != SSA_NAME)\n     return true;\n \n   /* If we do not have useful points-to information for this pointer\n@@ -220,13 +217,6 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n {\n   struct ptr_info_def *pi1, *pi2;\n \n-  gcc_assert ((TREE_CODE (ptr1) == SSA_NAME\n-\t       || TREE_CODE (ptr1) == ADDR_EXPR\n-\t       || TREE_CODE (ptr1) == INTEGER_CST)\n-\t      && (TREE_CODE (ptr2) == SSA_NAME\n-\t\t  || TREE_CODE (ptr2) == ADDR_EXPR\n-\t\t  || TREE_CODE (ptr2) == INTEGER_CST));\n-\n   /* ADDR_EXPR pointers either just offset another pointer or directly\n      specify the pointed-to set.  */\n   if (TREE_CODE (ptr1) == ADDR_EXPR)\n@@ -254,10 +244,10 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n \treturn true;\n     }\n \n-  /* We can end up with dereferencing constant pointers.\n+  /* We can end up with dereferencing non-SSA name pointers.\n      Just bail out in this case.  */\n-  if (TREE_CODE (ptr1) == INTEGER_CST\n-      || TREE_CODE (ptr2) == INTEGER_CST)\n+  if (TREE_CODE (ptr1) != SSA_NAME \n+      || TREE_CODE (ptr2) != SSA_NAME)\n     return true;\n \n   /* We may end up with two empty points-to solutions for two same pointers.\n@@ -781,7 +771,9 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   if (TREE_CODE (base1) == SSA_NAME\n       || TREE_CODE (base2) == SSA_NAME\n       || is_gimple_min_invariant (base1)\n-      || is_gimple_min_invariant (base2))\n+      || is_gimple_min_invariant (base2)\n+      || TREE_CODE (base1) == CONSTRUCTOR\n+      || TREE_CODE (base2) == CONSTRUCTOR)\n     return false;\n \n   /* Defer to simple offset based disambiguation if we have"}]}