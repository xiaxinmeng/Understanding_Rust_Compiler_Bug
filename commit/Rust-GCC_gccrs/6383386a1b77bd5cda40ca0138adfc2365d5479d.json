{"sha": "6383386a1b77bd5cda40ca0138adfc2365d5479d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM4MzM4NmExYjc3YmQ1Y2RhNDBjYTAxMzhhZGZjMjM2NWQ1NDc5ZA==", "commit": {"author": {"name": "Felix Yang", "email": "felix.yang@huawei.com", "date": "2014-10-30T21:37:45Z"}, "committer": {"name": "Sterling Augustine", "email": "sterling@gcc.gnu.org", "date": "2014-10-30T21:37:45Z"}, "message": "Add zero-cost loops for xtensa port.\n\n2014-10-10  Felix Yang  <felix.yang@huawei.com>\n\n\t* config/xtensa/xtensa.h (TARGET_LOOPS): New Macro.\n\t* config/xtensa/xtensa.c: Include dumpfile.h and hw-doloop.h.\n\t(xtensa_reorg, xtensa_reorg_loops): New.\n\t(xtensa_can_use_doloop_p, xtensa_invalid_within_doloop): New.\n\t(hwloop_optimize, hwloop_fail, hwloop_pattern_reg): New.\n\t(xtensa_emit_loop_end): Emit the zero-overhead loop end label.\n\t(xtensa_doloop_hooks): Define.\n\t* config/xtensa/xtensa.md (doloop_end, loop_end): New\n\t(zero_cost_loop_start): Rewritten.\n\t(zero_cost_loop_end): Likewise.\n\nFrom-SVN: r216945", "tree": {"sha": "5b54fa65e69a2cb65d5ef27190e65af9c15593b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b54fa65e69a2cb65d5ef27190e65af9c15593b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6383386a1b77bd5cda40ca0138adfc2365d5479d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6383386a1b77bd5cda40ca0138adfc2365d5479d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6383386a1b77bd5cda40ca0138adfc2365d5479d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6383386a1b77bd5cda40ca0138adfc2365d5479d/comments", "author": null, "committer": null, "parents": [{"sha": "77893d0b7564bdab6e32d1efeda825c5b64c53b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77893d0b7564bdab6e32d1efeda825c5b64c53b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77893d0b7564bdab6e32d1efeda825c5b64c53b1"}], "stats": {"total": 384, "additions": 363, "deletions": 21}, "files": [{"sha": "28ae55217563e6b54dfd0782ddf219196140ada7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6383386a1b77bd5cda40ca0138adfc2365d5479d", "patch": "@@ -1,3 +1,16 @@\n+2014-10-10  Felix Yang  <felix.yang@huawei.com>\n+\n+\t* config/xtensa/xtensa.h (TARGET_LOOPS): New Macro.\n+\t* config/xtensa/xtensa.c: Include dumpfile.h and hw-doloop.h.\n+\t(xtensa_reorg, xtensa_reorg_loops): New.\n+\t(xtensa_can_use_doloop_p, xtensa_invalid_within_doloop): New.\n+\t(hwloop_optimize, hwloop_fail, hwloop_pattern_reg): New.\n+\t(xtensa_emit_loop_end): Emit the zero-overhead loop end label.\n+\t(xtensa_doloop_hooks): Define.\n+\t* config/xtensa/xtensa.md (doloop_end, loop_end): New\n+\t(zero_cost_loop_start): Rewritten.\n+\t(zero_cost_loop_end): Likewise.\n+\n 2014-10-30  Steve Ellcey  <sellcey@imgtec.com>\n \n \t* config.gcc (mips*-*-linux*): Combine 32 and 64 bit cases."}, {"sha": "159a1a7646830510e5db35649024fc143a0921ab", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 248, "deletions": 1, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=6383386a1b77bd5cda40ca0138adfc2365d5479d", "patch": "@@ -74,6 +74,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"df.h\"\n #include \"builtins.h\"\n+#include \"dumpfile.h\"\n+#include \"hw-doloop.h\"\n #include \"rtl-iter.h\"\n \n \n@@ -200,6 +202,10 @@ static reg_class_t xtensa_secondary_reload (bool, rtx, reg_class_t,\n \n static bool constantpool_address_p (const_rtx addr);\n static bool xtensa_legitimate_constant_p (machine_mode, rtx);\n+static void xtensa_reorg (void);\n+static bool xtensa_can_use_doloop_p (const widest_int &, const widest_int &,\n+                                     unsigned int, bool);\n+static const char *xtensa_invalid_within_doloop (const rtx_insn *);\n \n static bool xtensa_member_type_forces_blk (const_tree,\n \t\t\t\t\t   machine_mode mode);\n@@ -326,6 +332,15 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P xtensa_legitimate_constant_p\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG xtensa_reorg\n+\n+#undef TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P xtensa_can_use_doloop_p\n+\n+#undef TARGET_INVALID_WITHIN_DOLOOP\n+#define TARGET_INVALID_WITHIN_DOLOOP xtensa_invalid_within_doloop\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -1690,7 +1705,7 @@ xtensa_emit_loop_end (rtx_insn *insn, rtx *operands)\n         }\n     }\n \n-  output_asm_insn (\"# loop end for %0\", operands);\n+  output_asm_insn (\"%1_LEND:\", operands);\n }\n \n \n@@ -3720,4 +3735,236 @@ xtensa_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n   return !xtensa_tls_referenced_p (x);\n }\n \n+/* Implement TARGET_CAN_USE_DOLOOP_P.  */\n+\n+static bool\n+xtensa_can_use_doloop_p (const widest_int &, const widest_int &,\n+                         unsigned int loop_depth, bool entered_at_top)\n+{\n+  /* Considering limitations in the hardware, only use doloop\n+     for innermost loops which must be entered from the top.  */\n+  if (loop_depth > 1 || !entered_at_top)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* NULL if INSN insn is valid within a low-overhead loop.\n+   Otherwise return why doloop cannot be applied.  */\n+\n+static const char *\n+xtensa_invalid_within_doloop (const rtx_insn *insn)\n+{\n+  if (CALL_P (insn))\n+    return \"Function call in the loop.\";\n+\n+  if (JUMP_P (insn) && INSN_CODE (insn) == CODE_FOR_return)\n+    return \"Return from a call instruction in the loop.\";\n+\n+  return NULL;\n+}\n+\n+/* Optimize LOOP.  */\n+\n+static bool\n+hwloop_optimize (hwloop_info loop)\n+{\n+  int i;\n+  edge entry_edge;\n+  basic_block entry_bb;\n+  rtx iter_reg;\n+  rtx_insn *insn, *seq, *entry_after;\n+\n+  if (loop->depth > 1)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d is not innermost\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  if (!loop->incoming_dest)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d has more than one entry\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  if (loop->incoming_dest != loop->head)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d is not entered from head\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  if (loop->has_call || loop->has_asm)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d has invalid insn\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Scan all the blocks to make sure they don't use iter_reg.  */\n+  if (loop->iter_reg_used || loop->iter_reg_used_outside)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d uses iterator\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Check if start_label appears before doloop_end.  */\n+  insn = loop->start_label;\n+  while (insn && insn != loop->loop_end)\n+    insn = NEXT_INSN (insn);\n+\n+  if (!insn)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d start_label not before loop_end\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Get the loop iteration register.  */\n+  iter_reg = loop->iter_reg;\n+\n+  gcc_assert (REG_P (iter_reg));\n+\n+  entry_edge = NULL;\n+\n+  FOR_EACH_VEC_SAFE_ELT (loop->incoming, i, entry_edge)\n+    if (entry_edge->flags & EDGE_FALLTHRU)\n+      break;\n+\n+  if (entry_edge == NULL)\n+    return false;\n+\n+  /* Place the zero_cost_loop_start instruction before the loop.  */\n+  entry_bb = entry_edge->src;\n+\n+  start_sequence ();\n+\n+  insn = emit_insn (gen_zero_cost_loop_start (loop->iter_reg,\n+                                              loop->start_label,\n+                                              loop->iter_reg));\n+\n+  seq = get_insns ();\n+\n+  if (!single_succ_p (entry_bb) || vec_safe_length (loop->incoming) > 1)\n+    {\n+      basic_block new_bb;\n+      edge e;\n+      edge_iterator ei;\n+\n+      emit_insn_before (seq, BB_HEAD (loop->head));\n+      seq = emit_label_before (gen_label_rtx (), seq);\n+      new_bb = create_basic_block (seq, insn, entry_bb);\n+      FOR_EACH_EDGE (e, ei, loop->incoming)\n+        {\n+          if (!(e->flags & EDGE_FALLTHRU))\n+            redirect_edge_and_branch_force (e, new_bb);\n+          else\n+            redirect_edge_succ (e, new_bb);\n+        }\n+\n+      make_edge (new_bb, loop->head, 0);\n+    }\n+  else\n+    {\n+      entry_after = BB_END (entry_bb);\n+      while (DEBUG_INSN_P (entry_after)\n+             || (NOTE_P (entry_after)\n+                 && NOTE_KIND (entry_after) != NOTE_INSN_BASIC_BLOCK))\n+        entry_after = PREV_INSN (entry_after);\n+\n+      emit_insn_after (seq, entry_after);\n+    }\n+\n+  end_sequence ();\n+\n+  return true;\n+}\n+\n+/* A callback for the hw-doloop pass.  Called when a loop we have discovered\n+   turns out not to be optimizable; we have to split the loop_end pattern into\n+   a subtract and a test.  */\n+\n+static void\n+hwloop_fail (hwloop_info loop)\n+{\n+  rtx test;\n+  rtx_insn *insn = loop->loop_end;\n+\n+  emit_insn_before (gen_addsi3 (loop->iter_reg,\n+                                loop->iter_reg,\n+                                constm1_rtx),\n+                    loop->loop_end);\n+\n+  test = gen_rtx_NE (VOIDmode, loop->iter_reg, const0_rtx);\n+  insn = emit_jump_insn_before (gen_cbranchsi4 (test,\n+                                                loop->iter_reg, const0_rtx,\n+                                                loop->start_label),\n+                                loop->loop_end);\n+\n+  JUMP_LABEL (insn) = loop->start_label;\n+  LABEL_NUSES (loop->start_label)++;\n+  delete_insn (loop->loop_end);\n+}\n+\n+/* A callback for the hw-doloop pass.  This function examines INSN; if\n+   it is a doloop_end pattern we recognize, return the reg rtx for the\n+   loop counter.  Otherwise, return NULL_RTX.  */\n+\n+static rtx\n+hwloop_pattern_reg (rtx_insn *insn)\n+{\n+  rtx reg;\n+\n+  if (!JUMP_P (insn) || recog_memoized (insn) != CODE_FOR_loop_end)\n+    return NULL_RTX;\n+\n+  reg = SET_DEST (XVECEXP (PATTERN (insn), 0, 1));\n+  if (!REG_P (reg))\n+    return NULL_RTX;\n+\n+  return reg;\n+}\n+\n+\n+static struct hw_doloop_hooks xtensa_doloop_hooks =\n+{\n+  hwloop_pattern_reg,\n+  hwloop_optimize,\n+  hwloop_fail\n+};\n+\n+/* Run from machine_dependent_reorg, this pass looks for doloop_end insns\n+   and tries to rewrite the RTL of these loops so that proper Xtensa\n+   hardware loops are generated.  */\n+\n+static void\n+xtensa_reorg_loops (void)\n+{\n+  reorg_loops (false, &xtensa_doloop_hooks);\n+}\n+\n+/* Implement the TARGET_MACHINE_DEPENDENT_REORG pass.  */\n+\n+static void\n+xtensa_reorg (void)\n+{\n+  /* We are freeing block_for_insn in the toplev to keep compatibility\n+     with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n+  compute_bb_for_insn ();\n+\n+  df_analyze ();\n+\n+  /* Doloop optimization.  */\n+  xtensa_reorg_loops ();\n+}\n+\n #include \"gt-xtensa.h\""}, {"sha": "f0f7690c5d48854b80eb33fd39b3d8483959e19e", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=6383386a1b77bd5cda40ca0138adfc2365d5479d", "patch": "@@ -65,6 +65,7 @@ extern unsigned xtensa_current_frame_size;\n #define TARGET_S32C1I\t\tXCHAL_HAVE_S32C1I\n #define TARGET_ABSOLUTE_LITERALS XSHAL_USE_ABSOLUTE_LITERALS\n #define TARGET_THREADPTR\tXCHAL_HAVE_THREADPTR\n+#define TARGET_LOOPS\t        XCHAL_HAVE_LOOPS\n \n #define TARGET_DEFAULT \\\n   ((XCHAL_HAVE_L32R\t? 0 : MASK_CONST16) |\t\t\t\t\\"}, {"sha": "285aa745d50329db8edec0aa4dc3053abf75b08f", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 101, "deletions": 20, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6383386a1b77bd5cda40ca0138adfc2365d5479d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=6383386a1b77bd5cda40ca0138adfc2365d5479d", "patch": "@@ -35,6 +35,8 @@\n   (UNSPEC_TLS_CALL\t9)\n   (UNSPEC_TP\t\t10)\n   (UNSPEC_MEMW\t\t11)\n+  (UNSPEC_LSETUP_START  12)\n+  (UNSPEC_LSETUP_END    13)\n \n   (UNSPECV_SET_FP\t1)\n   (UNSPECV_ENTRY\t2)\n@@ -1279,41 +1281,120 @@\n    (set_attr \"length\"\t\"3\")])\n \n \n+;; Zero-overhead looping support.\n+\n ;; Define the loop insns used by bct optimization to represent the\n-;; start and end of a zero-overhead loop (in loop.c).  This start\n-;; template generates the loop insn; the end template doesn't generate\n-;; any instructions since loop end is handled in hardware.\n+;; start and end of a zero-overhead loop.  This start template generates\n+;; the loop insn; the end template doesn't generate any instructions since\n+;; loop end is handled in hardware.\n \n (define_insn \"zero_cost_loop_start\"\n   [(set (pc)\n-\t(if_then_else (eq (match_operand:SI 0 \"register_operand\" \"a\")\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (reg:SI 19)\n-\t(plus:SI (match_dup 0) (const_int -1)))]\n-  \"\"\n-  \"loopnez\\t%0, %l1\"\n+        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"2\")\n+                          (const_int 1))\n+                      (label_ref (match_operand 1 \"\" \"\"))\n+                      (pc)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=a\")\n+        (plus (match_dup 0)\n+              (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_LSETUP_START)]\n+  \"TARGET_LOOPS && optimize\"\n+  \"loop\\t%0, %l1_LEND\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"3\")])\n \n (define_insn \"zero_cost_loop_end\"\n   [(set (pc)\n-\t(if_then_else (ne (reg:SI 19) (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (reg:SI 19)\n-\t(plus:SI (reg:SI 19) (const_int -1)))]\n-  \"\"\n-{\n-    xtensa_emit_loop_end (insn, operands);\n-    return \"\";\n+        (if_then_else (ne (match_operand:SI 0 \"nonimmediate_operand\" \"2,2\")\n+                          (const_int 1))\n+                      (label_ref (match_operand 1 \"\" \"\"))\n+                      (pc)))\n+   (set (match_operand:SI 2 \"nonimmediate_operand\" \"=a,m\")\n+        (plus (match_dup 0)\n+              (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n+   (clobber (match_scratch:SI 3 \"=X,&r\"))]\n+  \"TARGET_LOOPS && optimize\"\n+  \"#\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"0\")])\n+\n+(define_insn \"loop_end\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"2\")\n+                          (const_int 1))\n+                      (label_ref (match_operand 1 \"\" \"\"))\n+                      (pc)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=a\")\n+        (plus (match_dup 0)\n+              (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_LSETUP_END)]\n+  \"TARGET_LOOPS && optimize\"\n+{\n+  xtensa_emit_loop_end (insn, operands);\n+  return \"\";\n }\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"0\")])\n \n+(define_split\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+                          (const_int 1))\n+                      (label_ref (match_operand 1 \"\" \"\"))\n+                      (pc)))\n+   (set (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n+        (plus:SI (match_dup 0)\n+                 (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n+   (clobber (match_scratch 3))]\n+  \"TARGET_LOOPS && optimize && reload_completed\"\n+  [(const_int 0)]\n+{\n+  if (!REG_P (operands[0]))\n+    {\n+      rtx test;\n+\n+      /* Fallback into a normal conditional branch insn.  */\n+      emit_move_insn (operands[3], operands[0]);\n+      emit_insn (gen_addsi3 (operands[3], operands[3], constm1_rtx));\n+      emit_move_insn (operands[0], operands[3]);\n+      test = gen_rtx_NE (VOIDmode, operands[3], const0_rtx);\n+      emit_jump_insn (gen_cbranchsi4 (test, operands[3],\n+                                      const0_rtx, operands[1]));\n+    }\n+  else\n+    {\n+      emit_jump_insn (gen_loop_end (operands[0], operands[1], operands[2]));\n+    }\n+\n+  DONE;\n+})\n+\n+; operand 0 is the loop count pseudo register\n+; operand 1 is the label to jump to at the top of the loop\n+(define_expand \"doloop_end\"\n+  [(parallel [(set (pc) (if_then_else\n+                          (ne (match_operand:SI 0 \"\" \"\")\n+                              (const_int 1))\n+                          (label_ref (match_operand 1 \"\" \"\"))\n+                          (pc)))\n+              (set (match_dup 0)\n+                   (plus:SI (match_dup 0)\n+                            (const_int -1)))\n+              (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n+              (clobber (match_dup 2))])] ; match_scratch\n+  \"TARGET_LOOPS && optimize\"\n+{\n+  /* The loop optimizer doesn't check the predicates... */\n+  if (GET_MODE (operands[0]) != SImode)\n+    FAIL;\n+  operands[2] = gen_rtx_SCRATCH (SImode);\n+})\n+\n \f\n ;; Setting a register from a comparison.\n "}]}