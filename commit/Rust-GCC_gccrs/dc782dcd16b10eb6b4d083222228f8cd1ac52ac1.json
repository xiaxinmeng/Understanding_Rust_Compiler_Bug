{"sha": "dc782dcd16b10eb6b4d083222228f8cd1ac52ac1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM3ODJkY2QxNmIxMGViNmI0ZDA4MzIyMjIyOGY4Y2QxYWM1MmFjMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-03-05T05:59:55Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-03-05T05:59:55Z"}, "message": "rtlanal.c (replace_reg): Remove.\n\n\t* rtlanal.c (replace_reg): Remove.\n\t* rtl.h: Remove the prototype for replace_reg.\n\nFrom-SVN: r111730", "tree": {"sha": "3ac484d3889a176c446b3e80e4f3680dd5482d7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ac484d3889a176c446b3e80e4f3680dd5482d7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1/comments", "author": null, "committer": null, "parents": [{"sha": "3c491cab150587a6349ca9680b5bf2cc055a8137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c491cab150587a6349ca9680b5bf2cc055a8137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c491cab150587a6349ca9680b5bf2cc055a8137"}], "stats": {"total": 106, "additions": 5, "deletions": 101}, "files": [{"sha": "a5f0a1809e1b6bef71e2d271086172832ec8c23d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc782dcd16b10eb6b4d083222228f8cd1ac52ac1", "patch": "@@ -1,3 +1,8 @@\n+2006-03-05  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* rtlanal.c (replace_reg): Remove.\n+\t* rtl.h: Remove the prototype for replace_reg.\n+\n 2006-03-05  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* regclass.c (reg_scan_update): Remove."}, {"sha": "47d7b0d8922ad93e012102808efe6f713cc4bb57", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=dc782dcd16b10eb6b4d083222228f8cd1ac52ac1", "patch": "@@ -1723,7 +1723,6 @@ extern int may_trap_after_code_motion_p (rtx);\n extern int may_trap_or_fault_p (rtx);\n extern int inequality_comparisons_p (rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);\n-extern rtx replace_regs (rtx, rtx *, unsigned int, int);\n extern int replace_label (rtx *, void *);\n extern int rtx_referenced_p (rtx, rtx);\n extern bool tablejump_p (rtx, rtx *, rtx *);"}, {"sha": "9292a4bb9bb35725f473406c8f7f46930c7144ce", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc782dcd16b10eb6b4d083222228f8cd1ac52ac1/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=dc782dcd16b10eb6b4d083222228f8cd1ac52ac1", "patch": "@@ -2371,106 +2371,6 @@ replace_rtx (rtx x, rtx from, rtx to)\n   return x;\n }\n \f\n-/* Throughout the rtx X, replace many registers according to REG_MAP.\n-   Return the replacement for X (which may be X with altered contents).\n-   REG_MAP[R] is the replacement for register R, or 0 for don't replace.\n-   NREGS is the length of REG_MAP; regs >= NREGS are not mapped.\n-\n-   We only support REG_MAP entries of REG or SUBREG.  Also, hard registers\n-   should not be mapped to pseudos or vice versa since validate_change\n-   is not called.\n-\n-   If REPLACE_DEST is 1, replacements are also done in destinations;\n-   otherwise, only sources are replaced.  */\n-\n-rtx\n-replace_regs (rtx x, rtx *reg_map, unsigned int nregs, int replace_dest)\n-{\n-  enum rtx_code code;\n-  int i;\n-  const char *fmt;\n-\n-  if (x == 0)\n-    return x;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case SCRATCH:\n-    case PC:\n-    case CC0:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return x;\n-\n-    case REG:\n-      /* Verify that the register has an entry before trying to access it.  */\n-      if (REGNO (x) < nregs && reg_map[REGNO (x)] != 0)\n-\t{\n-\t  /* SUBREGs can't be shared.  Always return a copy to ensure that if\n-\t     this replacement occurs more than once then each instance will\n-\t     get distinct rtx.  */\n-\t  if (GET_CODE (reg_map[REGNO (x)]) == SUBREG)\n-\t    return copy_rtx (reg_map[REGNO (x)]);\n-\t  return reg_map[REGNO (x)];\n-\t}\n-      return x;\n-\n-    case SUBREG:\n-      /* Prevent making nested SUBREGs.  */\n-      if (REG_P (SUBREG_REG (x)) && REGNO (SUBREG_REG (x)) < nregs\n-\t  && reg_map[REGNO (SUBREG_REG (x))] != 0\n-\t  && GET_CODE (reg_map[REGNO (SUBREG_REG (x))]) == SUBREG)\n-\t{\n-\t  rtx map_val = reg_map[REGNO (SUBREG_REG (x))];\n-\t  return simplify_gen_subreg (GET_MODE (x), map_val,\n-\t\t\t\t      GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t      SUBREG_BYTE (x));\n-\t}\n-      break;\n-\n-    case SET:\n-      if (replace_dest)\n-\tSET_DEST (x) = replace_regs (SET_DEST (x), reg_map, nregs, 0);\n-\n-      else if (MEM_P (SET_DEST (x))\n-\t       || GET_CODE (SET_DEST (x)) == STRICT_LOW_PART)\n-\t/* Even if we are not to replace destinations, replace register if it\n-\t   is CONTAINED in destination (destination is memory or\n-\t   STRICT_LOW_PART).  */\n-\tXEXP (SET_DEST (x), 0) = replace_regs (XEXP (SET_DEST (x), 0),\n-\t\t\t\t\t       reg_map, nregs, 0);\n-      else if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT)\n-\t/* Similarly, for ZERO_EXTRACT we replace all operands.  */\n-\tbreak;\n-\n-      SET_SRC (x) = replace_regs (SET_SRC (x), reg_map, nregs, 0);\n-      return x;\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tXEXP (x, i) = replace_regs (XEXP (x, i), reg_map, nregs, replace_dest);\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    XVECEXP (x, i, j) = replace_regs (XVECEXP (x, i, j), reg_map,\n-\t\t\t\t\t      nregs, replace_dest);\n-\t}\n-    }\n-  return x;\n-}\n-\n /* Replace occurrences of the old label in *X with the new one.\n    DATA is a REPLACE_LABEL_DATA containing the old and new labels.  */\n "}]}