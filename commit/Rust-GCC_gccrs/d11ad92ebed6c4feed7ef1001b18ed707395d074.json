{"sha": "d11ad92ebed6c4feed7ef1001b18ed707395d074", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDExYWQ5MmViZWQ2YzRmZWVkN2VmMTAwMWIxOGVkNzA3Mzk1ZDA3NA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-08-26T20:32:48Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-08-26T20:32:48Z"}, "message": "88 Cygnus<->FSF merge\n\nFrom-SVN: r12674", "tree": {"sha": "bab1c93d6daf3259c2fe093e7eea00d62511ec1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bab1c93d6daf3259c2fe093e7eea00d62511ec1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d11ad92ebed6c4feed7ef1001b18ed707395d074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11ad92ebed6c4feed7ef1001b18ed707395d074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11ad92ebed6c4feed7ef1001b18ed707395d074", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11ad92ebed6c4feed7ef1001b18ed707395d074/comments", "author": null, "committer": null, "parents": [{"sha": "9d8757d442d3690c6f12e7378bdb2c6aeda3ccfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d8757d442d3690c6f12e7378bdb2c6aeda3ccfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d8757d442d3690c6f12e7378bdb2c6aeda3ccfb"}], "stats": {"total": 2459, "additions": 1388, "deletions": 1071}, "files": [{"sha": "8527738c94ffc10bd1b57ee7be847f9417486f32", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 1043, "deletions": 927, "changes": 1970, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074"}, {"sha": "9cb80b3a9201487dfee175066a8f417b5bdc6a75", "filename": "gcc/cp/call.c", "status": "modified", "additions": 190, "deletions": 49, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -2924,16 +2924,20 @@ struct z_candidate {\n #define PBOOL_RANK 4\n #define USER_RANK 5\n #define ELLIPSIS_RANK 6\n+#define BAD_RANK 7\n \n #define ICS_RANK(NODE)\t\t\t\t\\\n-  (ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK\t\\\n+  (ICS_BAD_FLAG (NODE) ? BAD_RANK   \\\n+   : ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK\t\\\n    : ICS_USER_FLAG (NODE) ? USER_RANK\t\t\\\n    : ICS_STD_RANK (NODE))\n \n #define ICS_STD_RANK(NODE) TREE_COMPLEXITY (NODE)\n \n #define ICS_USER_FLAG(NODE) TREE_LANG_FLAG_0 (NODE)\n #define ICS_ELLIPSIS_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+#define ICS_THIS_FLAG(NODE) TREE_LANG_FLAG_2 (NODE)\n+#define ICS_BAD_FLAG(NODE) TREE_LANG_FLAG_3 (NODE)\n \n #define USER_CONV_FN(NODE) TREE_OPERAND (NODE, 1)\n \n@@ -2947,7 +2951,7 @@ int\n null_ptr_cst_p (t)\n      tree t;\n {\n-  if (t == null_pointer_node\n+  if (t == null_node\n       || integer_zerop (t) && INTEGRAL_TYPE_P (TREE_TYPE (t)))\n     return 1;\n   /* Remove this eventually.  */\n@@ -2984,6 +2988,7 @@ build_conv (code, type, from)\n     }\n   ICS_STD_RANK (t) = rank;\n   ICS_USER_FLAG (t) = ICS_USER_FLAG (from);\n+  ICS_BAD_FLAG (t) = ICS_BAD_FLAG (from);\n   return t;\n }\n \n@@ -3037,18 +3042,19 @@ standard_conversion (to, from, expr)\n     {\n       enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n       enum tree_code utcode = TREE_CODE (TREE_TYPE (to));\n+      tree nconv = NULL_TREE;\n \n       if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (from)),\n \t\t     TYPE_MAIN_VARIANT (TREE_TYPE (to)), 1))\n-\t/* OK for now */;\n+\tnconv = conv;\n       else if (utcode == VOID_TYPE && ufcode != OFFSET_TYPE\n \t       && ufcode != FUNCTION_TYPE)\n \t{\n \t  from = build_pointer_type\n \t    (cp_build_type_variant (void_type_node,\n \t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n \t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from))));\n-\t  conv = build_conv (PTR_CONV, from, conv);\n+\t  nconv = build_conv (PTR_CONV, from, conv);\n \t}\n       else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n \t{\n@@ -3062,10 +3068,8 @@ standard_conversion (to, from, expr)\n \t    {\n \t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n \t      from = build_pointer_type (from);\n-\t      conv = build_conv (PMEM_CONV, from, conv);\n+\t      nconv = build_conv (PMEM_CONV, from, conv);\n \t    }\n-\t  else\n-\t    return 0;\n \t}\n       else if (IS_AGGR_TYPE (TREE_TYPE (from))\n \t       && IS_AGGR_TYPE (TREE_TYPE (to)))\n@@ -3076,22 +3080,23 @@ standard_conversion (to, from, expr)\n \t\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n \t\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from)));\n \t      from = build_pointer_type (from);\n-\t      conv = build_conv (PTR_CONV, from, conv);\n+\t      nconv = build_conv (PTR_CONV, from, conv);\n \t    }\n-\t  else\n-\t    return 0;\n \t}\n-      else\n-\treturn 0;\n \n-      if (! comptypes (from, to, 1))\n+      if (nconv && comptypes (from, to, 1))\n+\tconv = nconv;\n+      else if (nconv && comp_ptr_ttypes (TREE_TYPE (to), TREE_TYPE (from)))\n+\tconv = build_conv (QUAL_CONV, to, nconv);\n+      else if (ptr_reasonably_similar (TREE_TYPE (to), TREE_TYPE (from)))\n \t{\n-\t  if (! comp_ptr_ttypes (TREE_TYPE (to), TREE_TYPE (from)))\n-\t    return 0;\n-\n-\t  from = to;\n-\t  conv = build_conv (QUAL_CONV, from, conv);\n+\t  conv = build_conv (PTR_CONV, to, conv);\n+\t  ICS_BAD_FLAG (conv) = 1;\n \t}\n+      else\n+\treturn 0;\n+\n+      from = to;\n     }\n   else if (TYPE_PTRMEMFUNC_P (to) && TYPE_PTRMEMFUNC_P (from))\n     {\n@@ -3214,6 +3219,14 @@ reference_binding (rto, from, expr, flags)\n \t}\n     }\n \n+  if (! conv)\n+    {\n+      conv = standard_conversion\n+\t(TYPE_MAIN_VARIANT (to), strip_top_quals (from), expr);\n+      if (conv)\n+\tICS_BAD_FLAG (conv) = 1;\n+    }\t\n+\n   return conv;\n }\n \n@@ -3330,10 +3343,17 @@ add_function_candidate (candidates, fn, arglist, flags)\n \t  ICS_ELLIPSIS_FLAG (t) = 1;\n \t}\n \n+      if (i == 0 && t && TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n+\t  && ! DECL_CONSTRUCTOR_P (fn))\n+\tICS_THIS_FLAG (t) = 1;\n+\n       TREE_VEC_ELT (convs, i) = t;\n       if (! t)\n \tbreak;\n \n+      if (ICS_BAD_FLAG (t))\n+\tviable = -1;\n+\n       if (parmnode)\n \tparmnode = TREE_CHAIN (parmnode);\n       argnode = TREE_CHAIN (argnode);\n@@ -3387,12 +3407,9 @@ add_conv_candidate (candidates, fn, obj, arglist)\n   for (i = 0; i < len; ++i)\n     {\n       tree arg = i == 0 ? obj : TREE_VALUE (argnode);\n-      tree argtype = TREE_TYPE (arg);\n+      tree argtype = lvalue_type (arg);\n       tree t;\n \n-      argtype = cp_build_type_variant\n-\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n-\n       if (i == 0)\n \tt = implicit_conversion (totype, argtype, arg, flags);\n       else if (parmnode == void_list_node)\n@@ -3409,6 +3426,9 @@ add_conv_candidate (candidates, fn, obj, arglist)\n       if (! t)\n \tbreak;\n \n+      if (ICS_BAD_FLAG (t))\n+\tviable = -1;\n+\n       if (i == 0)\n \tcontinue;\n \n@@ -3492,6 +3512,8 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n \t  /* We need something for printing the candidate.  */\n \t  t = build1 (IDENTITY_CONV, types[i], NULL_TREE);\n \t}\n+      else if (ICS_BAD_FLAG (t))\n+\tviable = 0;\n       TREE_VEC_ELT (convs, i) = t;\n     }\n \n@@ -3954,9 +3976,7 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n   for (i = 0; i < 3; ++i)\n     {\n       if (args[i])\n-\targtypes[i]  = cp_build_type_variant\n-\t  (TREE_TYPE (args[i]), TREE_READONLY (args[i]),\n-\t   TREE_THIS_VOLATILE (args[i]));\n+\targtypes[i]  = lvalue_type (args[i]);\n       else\n \targtypes[i] = NULL_TREE;\n     }\n@@ -4117,7 +4137,7 @@ any_viable (cands)\n      struct z_candidate *cands;\n {\n   for (; cands; cands = cands->next)\n-    if (cands->viable)\n+    if (pedantic ? cands->viable == 1 : cands->viable)\n       return 1;\n   return 0;\n }\n@@ -4130,7 +4150,7 @@ splice_viable (cands)\n \n   for (; *p; )\n     {\n-      if ((*p)->viable)\n+      if (pedantic ? (*p)->viable == 1 : (*p)->viable)\n \tp = &((*p)->next);\n       else\n \t*p = (*p)->next;\n@@ -4170,7 +4190,8 @@ print_z_candidates (candidates)\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n \t}\n       else\n-\tcp_error_at (\"%s %+D\", str, candidates->fn);\n+\tcp_error_at (\"%s %+D%s\", str, candidates->fn,\n+\t\t     candidates->viable == -1 ? \" <bad>\" : \"\");\n       str = \"               \"; \n     }\n }\n@@ -4232,6 +4253,8 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t    candidates = add_function_candidate (candidates, fn, args, flags);\n \t    candidates->second_conv = ics;\n \t    candidates->basetype_path = TREE_PURPOSE (convs);\n+\t    if (candidates->viable == 1 && ICS_BAD_FLAG (ics))\n+\t      candidates->viable = -1;\n \t  }\n     }\n \n@@ -4400,7 +4423,7 @@ build_object_call (obj, args)\n \n   if (! any_viable (candidates))\n     {\n-      cp_error (\"no match for call to `(%T) (%A)\", TREE_TYPE (obj), args);\n+      cp_error (\"no match for call to `(%T) (%A)'\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -4437,22 +4460,22 @@ op_error (code, code2, arg1, arg2, arg3, problem)\n     {\n     case COND_EXPR:\n       cp_error (\"%s for `%T ? %T : %T'\", problem,\n-\t\tTREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n+\t\terror_type (arg1), error_type (arg2), error_type (arg3));\n       break;\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      cp_error (\"%s for `%T%s'\", problem, TREE_TYPE (arg1), opname);\n+      cp_error (\"%s for `%T%s'\", problem, error_type (arg1), opname);\n       break;\n     case ARRAY_REF:\n       cp_error (\"%s for `%T[%T]'\", problem,\n-\t\tTREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t\terror_type (arg1), error_type (arg2));\n       break;\n     default:\n       if (arg2)\n \tcp_error (\"%s for `%T %s %T'\", problem,\n-\t\t  TREE_TYPE (arg1), opname, TREE_TYPE (arg2));\n+\t\t  error_type (arg1), opname, error_type (arg2));\n       else\n-\tcp_error (\"%s for `%s%T'\", problem, opname, TREE_TYPE (arg1));\n+\tcp_error (\"%s for `%s%T'\", problem, opname, error_type (arg1));\n     }\n }\n \n@@ -4467,7 +4490,9 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   enum tree_code code2 = NOP_EXPR;\n   tree templates = NULL_TREE;\n \n-  if (arg1 == error_mark_node)\n+  if (arg1 == error_mark_node\n+      || arg2 == error_mark_node\n+      || arg3 == error_mark_node)\n     return error_mark_node;\n \n   if (code == MODIFY_EXPR)\n@@ -4717,6 +4742,26 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t LOOKUP_NORMAL);\n     }\n \n+  /* Check for comparison of different enum types.  */\n+  switch (code)\n+    {\n+    case GT_EXPR:\n+    case LT_EXPR:\n+    case GE_EXPR:\n+    case LE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      if (flag_int_enum_equivalence == 0 \n+\t  && TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE \n+\t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE \n+\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n+\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n+\t{\n+\t  cp_warning (\"comparison between `%#T' and `%#T'\", \n+\t\t      TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t}\n+    }\n+\n   arg1 = convert_from_reference\n     (convert_like (TREE_VEC_ELT (cand->convs, 0), arg1));\n   if (arg2)\n@@ -4786,7 +4831,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     }\n }\n \n-void\n+static void\n enforce_access (basetype_path, function)\n      tree basetype_path, function;\n {\n@@ -4814,6 +4859,26 @@ static tree\n convert_like (convs, expr)\n      tree convs, expr;\n {\n+  if (ICS_BAD_FLAG (convs))\n+    {\n+      tree t = convs; \n+      for (; t; t = TREE_OPERAND (t, 0))\n+\t{\n+\t  if (TREE_CODE (t) == USER_CONV)\n+\t    {\n+\t      expr = convert_like (t, expr);\n+\t      break;\n+\t    }\n+\t  else if (TREE_CODE (t) == AMBIG_CONV)\n+\t    return convert_like (t, expr);\n+\t  else if (TREE_CODE (t) == IDENTITY_CONV)\n+\t    break;\n+\t}\n+      return convert_for_initialization\n+\t(NULL_TREE, TREE_TYPE (convs), expr, LOOKUP_NORMAL,\n+\t \"conversion\", NULL_TREE, 0);\n+    }\n+\n   switch (TREE_CODE (convs))\n     {\n     case USER_CONV:\n@@ -4917,6 +4982,7 @@ build_over_call (fn, convs, args, flags)\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   tree conv, arg, val;\n   int i = 0;\n+  int is_method = 0;\n \n   if (args && TREE_CODE (args) != TREE_LIST)\n     args = build_tree_list (NULL_TREE, args);\n@@ -4940,19 +5006,56 @@ build_over_call (fn, convs, args, flags)\n   /* Bypass access control for 'this' parameter.  */\n   else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n     {\n+      tree parmtype = TREE_VALUE (parm);\n+      tree argtype = TREE_TYPE (TREE_VALUE (arg));\n+      if (ICS_BAD_FLAG (TREE_VEC_ELT (convs, i)))\n+\t{\n+\t  int dv = (TYPE_VOLATILE (TREE_TYPE (parmtype))\n+\t\t    < TYPE_VOLATILE (TREE_TYPE (argtype)));\n+\t  int dc = (TYPE_READONLY (TREE_TYPE (parmtype))\n+\t\t    < TYPE_READONLY (TREE_TYPE (argtype)));\n+\t  char *p = (dv && dc ? \"const and volatile\" :\n+\t\t     dc ? \"const\" : dv ? \"volatile\" : \"\");\n+\n+\t  cp_pedwarn (\"passing `%T' as `this' argument of `%#D' discards %s\",\n+\t\t      TREE_TYPE (argtype), fn, p);\n+\t}\n       converted_args = tree_cons\n \t(NULL_TREE, convert_force (TREE_VALUE (parm), TREE_VALUE (arg), CONV_C_CAST),\n \t converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n       ++i;\n+      is_method = 1;\n     }\n \n   for (; conv = TREE_VEC_ELT (convs, i), arg && parm;\n        parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg), ++i)\n     {\n       tree type = TREE_VALUE (parm);\n-      val = convert_like (conv, TREE_VALUE (arg));\n+\n+      if (ICS_BAD_FLAG (conv))\n+\t{\n+\t  tree t = conv;\n+\t  val = TREE_VALUE (arg);\n+\n+\t  for (; t; t = TREE_OPERAND (t, 0))\n+\t    {\n+\t      if (TREE_CODE (t) == USER_CONV\n+\t\t  || TREE_CODE (t) == AMBIG_CONV)\n+\t\t{\n+\t\t  val = convert_like (t, val);\n+\t\t  break;\n+\t\t}\n+\t      else if (TREE_CODE (t) == IDENTITY_CONV)\n+\t\tbreak;\n+\t    }\n+\t  val = convert_for_initialization\n+\t    (NULL_TREE, type, val, LOOKUP_NORMAL,\n+\t     \"argument passing\", fn, i - is_method);\n+\t}\n+      else\n+\tval = convert_like (conv, TREE_VALUE (arg));\n \n #ifdef PROMOTE_PROTOTYPES\n       if ((TREE_CODE (type) == INTEGER_TYPE\n@@ -5035,6 +5138,10 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n   tree basetype, mem_args, fns, instance_ptr;\n   tree pretty_name;\n \n+  for (fns = args; fns; fns = TREE_CHAIN (fns))\n+    if (TREE_VALUE (fns) == error_mark_node)\n+      return error_mark_node;\n+\n   if (instance == NULL_TREE)\n     basetype = BINFO_TYPE (basetype_path);\n   else\n@@ -5122,7 +5229,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \n   if (cand == 0)\n     {\n-      cp_error (\"call of overloaded `%D(%A)' is ambiguous\");\n+      cp_error (\"call of overloaded `%D(%A)' is ambiguous\", pretty_name, args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -5197,18 +5304,55 @@ compare_ics (ics1, ics2)\n {\n   tree main1, main2;\n \n+  if (TREE_CODE (ics1) == QUAL_CONV)\n+    main1 = TREE_OPERAND (ics1, 0);\n+  else\n+    main1 = ics1;\n+\n+  if (TREE_CODE (ics2) == QUAL_CONV)\n+    main2 = TREE_OPERAND (ics2, 0);\n+  else\n+    main2 = ics2;\n+\n+  /* Conversions for `this' are PTR_CONVs, but we compare them as though\n+     they were REF_BINDs.  */\n+  if (ICS_THIS_FLAG (ics1))\n+    {\n+      ics1 = build_conv (REF_BIND, TREE_TYPE (ics1), main1);\n+      TREE_OPERAND (ics1, 0) = TREE_OPERAND (main1, 0);\n+      main1 = ics1;\n+    }\n+  if (ICS_THIS_FLAG (ics2))\n+    {\n+      ics2 = build_conv (REF_BIND, TREE_TYPE (ics2), main2);\n+      TREE_OPERAND (ics2, 0) = TREE_OPERAND (main2, 0);\n+      main2 = ics2;\n+    }\n+\n   if (ICS_RANK (ics1) > ICS_RANK (ics2))\n     return -1;\n   else if (ICS_RANK (ics1) < ICS_RANK (ics2))\n     return 1;\n \n+  if (ICS_RANK (ics1) == BAD_RANK)\n+    {\n+      if (ICS_USER_FLAG (ics1) > ICS_USER_FLAG (ics2)\n+\t  || ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n+\treturn -1;\n+      else if (ICS_USER_FLAG (ics1) < ICS_USER_FLAG (ics2)\n+\t       || ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n+\treturn 1;\n+\n+      /* else fall through */\n+    }\n+\n   /* User-defined  conversion sequence U1 is a better conversion sequence\n      than another user-defined conversion sequence U2 if they contain the\n      same user-defined conversion operator or constructor and if the sec-\n      ond standard conversion sequence of U1 is  better  than  the  second\n      standard conversion sequence of U2.  */\n \n-  if (ICS_RANK (ics1) == USER_RANK)\n+  if (ICS_USER_FLAG (ics1))\n     {\n       tree t1, t2;\n \n@@ -5235,16 +5379,6 @@ compare_ics (ics1, ics2)\n      conversion.  */\n #endif\n \n-  if (TREE_CODE (ics1) == QUAL_CONV)\n-    main1 = TREE_OPERAND (ics1, 0);\n-  else\n-    main1 = ics1;\n-\n-  if (TREE_CODE (ics2) == QUAL_CONV)\n-    main2 = TREE_OPERAND (ics2, 0);\n-  else\n-    main2 = ics2;\n-\n   if (TREE_CODE (main1) != TREE_CODE (main2))\n     return 0;\n \n@@ -5410,6 +5544,13 @@ joust (cand1, cand2)\n   int winner = 0;\n   int i, off1 = 0, off2 = 0, len;\n \n+  /* Candidates that involve bad conversions are always worse than those\n+     that don't.  */\n+  if (cand1->viable > cand2->viable)\n+    return 1;\n+  if (cand1->viable < cand2->viable)\n+    return -1;\n+\n   /* a viable function F1\n      is defined to be a better function than another viable function F2  if\n      for  all arguments i, ICSi(F1) is not a worse conversion sequence than"}, {"sha": "441fe6931304f7d208e39fb32e4c95bca3ab42dc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -1520,6 +1520,8 @@ extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n extern tree integer_two_node, integer_three_node;\n extern tree boolean_type_node, boolean_true_node, boolean_false_node;\n \n+extern tree null_node;\n+\n /* in pt.c  */\n \n extern tree current_template_parms;\n@@ -2410,6 +2412,8 @@ extern tree break_out_target_exprs\t\tPROTO((tree));\n extern tree get_type_decl\t\t\tPROTO((tree));\n extern tree vec_binfo_member\t\t\tPROTO((tree, tree));\n extern tree hack_decl_function_context \t\tPROTO((tree));\n+extern tree lvalue_type\t\t\t\tPROTO((tree));\n+extern tree error_type\t\t\t\tPROTO((tree));\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));"}, {"sha": "46a6f90a23356f5b86eb2618041f1c61e0d52049", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -341,6 +341,11 @@ tree static_aggregates;\n tree integer_zero_node;\n tree null_pointer_node;\n \n+/* The value for __null (NULL), either of type `void *' or, with -ansi,\n+   an integer type of the same size.  */\n+\n+tree null_node;\n+\n /* A node for the integer constants 1, 2, and 3.  */\n \n tree integer_one_node, integer_two_node, integer_three_node;\n@@ -4911,7 +4916,14 @@ init_decl_processing ()\n   void_list_node = build_tree_list (NULL_TREE, void_type_node);\n   TREE_PARMLIST (void_list_node) = 1;\n \n+  null_pointer_node = build_int_2 (0, 0);\n   TREE_TYPE (null_pointer_node) = build_pointer_type (void_type_node);\n+  layout_type (TREE_TYPE (null_pointer_node));\n+     \n+  if (flag_ansi)\n+    TREE_TYPE (null_node) = type_for_size (POINTER_SIZE, 0);\n+  else\n+    TREE_TYPE (null_node) = build_pointer_type (void_type_node);\n \n   /* Used for expressions that do nothing, but are not errors.  */\n   void_zero_node = build_int_2 (0, 0);\n@@ -11086,7 +11098,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n      It doesn't matter whether it's inline or not.  */\n   else if (interface_unknown == 0\n \t   && (! DECL_TEMPLATE_INSTANTIATION (decl1)\n-\t       || flag_external_templates))\n+\t       || flag_alt_external_templates))\n     {\n       if (DECL_THIS_INLINE (decl1) || DECL_TEMPLATE_INSTANTIATION (decl1)\n \t  || current_template_parms)"}, {"sha": "2a080f93af1528feedcf6376efdc36681c752a01", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 42, "deletions": 58, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -128,11 +128,7 @@ int flag_ansi;\n /* Nonzero means do argument matching for overloading according to the\n    ANSI rules, rather than what g++ used to believe to be correct.  */\n \n-#ifdef NEW_OVER\n int flag_ansi_overloading = 1;\n-#else\n-int flag_ansi_overloading;\n-#endif\n \n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n@@ -2481,6 +2477,31 @@ mark_vtable_entries (decl)\n     }\n }\n \n+/* Set DECL up to have the closest approximation of \"initialized common\"\n+   linkage available.  */\n+\n+void\n+comdat_linkage (decl)\n+     tree decl;\n+{\n+  TREE_PUBLIC (decl) = 0;\n+\n+#ifdef DECL_ONE_ONLY\n+  if (SUPPORTS_ONE_ONLY)\n+    {\n+      DECL_ONE_ONLY (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n+    }\n+#endif\n+\n+  if (flag_weak)\n+    {\n+      DECL_WEAK (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n+    }\n+\n+}\n+\n /* Set TREE_PUBLIC and/or DECL_EXTERN on the vtable DECL,\n    based on TYPE and other static flags.\n \n@@ -2532,21 +2553,7 @@ import_export_vtable (decl, type, final)\n \n       if (final || ! found)\n \t{\n-#ifdef DECL_ONE_ONLY\n-\t  if (SUPPORTS_ONE_ONLY)\n-\t    {\n-\t      TREE_PUBLIC (decl) = 1;\n-\t      DECL_ONE_ONLY (decl) = 1;\n-\t    }\n-\t  else\n-#endif\n-\t  if (flag_weak)\n-\t    {\n-\t      TREE_PUBLIC (decl) = 1;\n-\t      DECL_WEAK (decl) = 1;\n-\t    }\n-\t  else\n-\t    TREE_PUBLIC (decl) = 0;\n+\t  comdat_linkage (decl);\n \t  DECL_EXTERNAL (decl) = 0;\n \t}\n       else\n@@ -2764,17 +2771,7 @@ import_export_decl (decl)\n \t  && (flag_implicit_templates || DECL_THIS_INLINE (decl)))\n \t{\n \t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    {\n-#ifdef DECL_ONE_ONLY\n-\t      if (SUPPORTS_ONE_ONLY)\n-\t\tDECL_ONE_ONLY (decl) = 1;\n-\t      else\n-#endif\n-\t      if (flag_weak)\n-\t\tDECL_WEAK (decl) = 1;\n-\t      else\n-\t\tTREE_PUBLIC (decl) = 0;\n-\t    }\n+\t    comdat_linkage (decl);\n \t  /* Dynamically initialized vars go into common.  */\n \t  else if (DECL_INITIAL (decl) == NULL_TREE\n \t\t   || DECL_INITIAL (decl) == error_mark_node)\n@@ -2784,14 +2781,18 @@ import_export_decl (decl)\n \t      DECL_COMMON (decl) = 1;\n \t      DECL_INITIAL (decl) = error_mark_node;\n \t    }\n+\t  else\n+\t    {\n+\t      /* Statically initialized vars are weak or comdat, if\n+                 supported.  */\n #ifdef DECL_ONE_ONLY\n-\t  else if (SUPPORTS_ONE_ONLY)\n-\t    DECL_ONE_ONLY (decl) = 1;\n+\t      if (SUPPORTS_ONE_ONLY)\n+\t\tDECL_ONE_ONLY (decl) = 1;\n #endif\n-\t  /* Statically initialized vars are weak or comdat, if supported.  */\n-\t  else if (flag_weak)\n-\t    DECL_WEAK (decl) = 1;\n-\t  /* else leave vars public so multiple defs will break.  */\n+\t      if (flag_weak)\n+\t\tDECL_WEAK (decl) = 1;\n+\t      /* else leave vars public so multiple defs will break.  */\n+\t    }\n \t}\n       else\n \tDECL_NOT_REALLY_EXTERN (decl) = 0;\n@@ -2805,46 +2806,29 @@ import_export_decl (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n \t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n \t}\n-#ifdef DECL_ONE_ONLY\n-      else if (SUPPORTS_ONE_ONLY)\n-\tDECL_ONE_ONLY (decl) = 1;\n-#endif\n-      else if (flag_weak)\n-\tDECL_WEAK (decl) = 1;\n       else\n-\tTREE_PUBLIC (decl) = 0;\n+\tcomdat_linkage (decl);\n     }\n   /* tinfo function */\n   else if (DECL_ARTIFICIAL (decl) && DECL_MUTABLE_P (decl))\n     {\n       tree ctype = TREE_TYPE (DECL_NAME (decl));\n-      if (IS_AGGR_TYPE (ctype) && CLASSTYPE_INTERFACE_KNOWN (ctype))\n+      if (IS_AGGR_TYPE (ctype) && CLASSTYPE_INTERFACE_KNOWN (ctype)\n+\t  && TYPE_VIRTUAL_P (ctype))\n \t{\n \t  DECL_NOT_REALLY_EXTERN (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n \t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n \t}\n       else if (TYPE_BUILT_IN (ctype) && ctype == TYPE_MAIN_VARIANT (ctype))\n \tDECL_NOT_REALLY_EXTERN (decl) = 0;\n-#ifdef DECL_ONE_ONLY\n-      else if (SUPPORTS_ONE_ONLY)\n-\tDECL_ONE_ONLY (decl) = 1;\n-#endif\n-      else if (flag_weak)\n-\tDECL_WEAK (decl) = 1;\n       else\n-\tTREE_PUBLIC (decl) = 0;\n+\tcomdat_linkage (decl);\n     } \n   else if (DECL_C_STATIC (decl))\n     TREE_PUBLIC (decl) = 0;\n-#ifdef DECL_ONE_ONLY\n-  else if (SUPPORTS_ONE_ONLY)\n-    DECL_ONE_ONLY (decl) = 1;\n-#endif\n-  else if (flag_weak)\n-    DECL_WEAK (decl) = 1;\n   else\n-    TREE_PUBLIC (decl) = 0;\n+    comdat_linkage (decl);\n \n   DECL_INTERFACE_KNOWN (decl) = 1;\n }"}, {"sha": "755b54b8bd5cbbb61257437d8bb26fb62090c11f", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -1547,7 +1547,7 @@ args_as_string (p, v)\n   OB_INIT ();\n   for (; p; p = TREE_CHAIN (p))\n     {\n-      dump_type (TREE_TYPE (TREE_VALUE (p)), v);\n+      dump_type (error_type (TREE_VALUE (p)), v);\n       if (TREE_CHAIN (p))\n \tOB_PUTS (\", \");\n     }"}, {"sha": "16e5b20d12089beadccd4de2a6f48135b308783c", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -592,6 +592,7 @@ do_unwind (inner_throw_label)\n   temp = gen_reg_rtx (Pmode);\n   emit_move_insn (temp, inner_throw_label);\n   emit_move_insn (return_val_rtx, plus_constant (temp, -8));\n+  emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, 31)));\n   easy_expand_asm (\"ret\");\n   easy_expand_asm (\"restore\");\n   emit_barrier ();"}, {"sha": "67df087bac12aa86e0ac0f1c612031a863b06c0a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -3261,7 +3261,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n   tree type = TREE_TYPE (TREE_TYPE (base));\n   tree size;\n \n-  maxindex = convert (integer_type_node, maxindex);\n+  maxindex = convert (ptrdiff_type_node, maxindex);\n   if (maxindex == error_mark_node)\n     return error_mark_node;\n \n@@ -3318,7 +3318,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t\t  goto done_init;\n \t\t}\n \n-\t      iterator = get_temp_regvar (integer_type_node,\n+\t      iterator = get_temp_regvar (ptrdiff_type_node,\n \t\t\t\t\t  build_int_2 (host_i, 0));\n \t      init = NULL_TREE;\n \t      goto init_by_default;\n@@ -3340,7 +3340,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n     {\n       tree itype;\n \n-      iterator = get_temp_regvar (integer_type_node, maxindex);\n+      iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n \n     init_by_default:\n \n@@ -3424,7 +3424,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t\t\t   build (PLUS_EXPR, build_pointer_type (type), base2, size), 0, 0);\n       expand_loop_continue_here ();\n       expand_exit_loop_if_false (0, build (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t   build (PREDECREMENT_EXPR, integer_type_node, iterator, integer_one_node), minus_one));\n+\t\t\t\t\t   build (PREDECREMENT_EXPR, ptrdiff_type_node, iterator, integer_one_node), minus_one));\n \n       if (obey_regdecls)\n \t{"}, {"sha": "cb3ba83d0cb01ace4a9bc3b034dc6336949cee34", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -673,8 +673,8 @@ init_lex ()\n   TREE_TYPE (signature_type_node) = signature_type_node;\n   ridpointers[(int) RID_SIGNATURE] = signature_type_node;\n \n-  null_pointer_node = build_int_2 (0, 0);\n-  ridpointers[RID_NULL] = null_pointer_node;\n+  null_node = build_int_2 (0, 0);\n+  ridpointers[RID_NULL] = null_node;\n \n   opname_tab[(int) COMPONENT_REF] = \"->\";\n   opname_tab[(int) MEMBER_REF] = \"->*\";\n@@ -1692,6 +1692,9 @@ cons_up_default_function (type, full_name, kind)\n   if (fn == void_type_node)\n     return fn;\n \n+  if (kind > 2)\n+    SET_DECL_ARTIFICIAL (TREE_CHAIN (DECL_ARGUMENTS (fn)));\n+\n #if 0\n   if (processing_template_defn)\n     {"}, {"sha": "eb9ed924ee980b17a8138381cac3acf73b1bc897", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -1713,15 +1713,7 @@ make_thunk (function, delta)\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n       DECL_EXTERNAL (thunk) = 1;\n-#ifdef DECL_ONE_ONLY\n-      if (SUPPORTS_ONE_ONLY)\n-\t{\n-\t  DECL_ONE_ONLY (thunk) = 1;\n-\t  TREE_PUBLIC (thunk) = 1;\n-\t}\n-      else\n-#endif\n-\tTREE_PUBLIC (thunk) = 0;\n+      comdat_linkage (thunk);\n       /* So that finish_file can write out any thunks that need to be: */\n       pushdecl_top_level (thunk);\n     }"}, {"sha": "5ffcb1b7d5f09a8d1143646bf41290eb58ae9bfc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -1240,6 +1240,8 @@ instantiate_class_template (type)\n   TYPE_HAS_CONVERSION (type) = TYPE_HAS_CONVERSION (pattern);\n   TYPE_USES_COMPLEX_INHERITANCE (type)\n     = TYPE_USES_COMPLEX_INHERITANCE (pattern);\n+  TYPE_USES_MULTIPLE_INHERITANCE (type)\n+    = TYPE_USES_MULTIPLE_INHERITANCE (pattern);\n   TYPE_USES_VIRTUAL_BASECLASSES (type)\n     = TYPE_USES_VIRTUAL_BASECLASSES (pattern);\n   TYPE_PACKED (type) = TYPE_PACKED (pattern);\n@@ -1627,8 +1629,10 @@ tsubst (t, args, nargs, in_decl)\n \tif (TREE_STATIC (r))\n \t  DECL_ASSEMBLER_NAME (r)\n \t    = build_static_name (DECL_CONTEXT (r), DECL_NAME (r));\n-\tDECL_INITIAL (r) = tsubst_expr\n-\t  (DECL_INITIAL (t), args, nargs, in_decl);\n+\n+\t/* Don't try to expand the initializer until someone tries to use\n+\t   this variable; otherwise we run into circular dependencies.  */\n+\tDECL_INITIAL (r) = NULL_TREE;\n \n \tDECL_RTL (r) = 0;\n \tDECL_SIZE (r) = 0;\n@@ -3283,6 +3287,14 @@ instantiate_decl (d)\n \timport_export_decl (d);\n     }\n \n+  /* We need to set up DECL_INITIAL regardless of pattern_defined if the\n+     variable is a static const initialized in the class body.  */\n+  if (TREE_CODE (d) == VAR_DECL\n+      && ! DECL_INITIAL (d) && DECL_INITIAL (pattern))\n+    DECL_INITIAL (d) = tsubst_expr\n+      (DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n+       TREE_VEC_LENGTH (args), tmpl);\n+\n   if (! pattern_defined\n       || (TREE_CODE (d) == FUNCTION_DECL && ! DECL_INLINE (d)\n \t  && (! DECL_INTERFACE_KNOWN (d)\n@@ -3308,6 +3320,12 @@ instantiate_decl (d)\n   td = tsubst (pattern, &TREE_VEC_ELT (args, 0), TREE_VEC_LENGTH (args), tmpl);\n   DECL_TEMPLATE_INFO (pattern) = save_ti;\n \n+  /* And set up DECL_INITIAL, since tsubst doesn't.  */\n+  if (TREE_CODE (td) == VAR_DECL)\n+    DECL_INITIAL (td) = tsubst_expr\n+      (DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n+       TREE_VEC_LENGTH (args), tmpl);\n+\n   /* Convince duplicate_decls to use the DECL_ARGUMENTS from the new decl.  */\n   if (TREE_CODE (d) == FUNCTION_DECL)\n     DECL_INITIAL (td) = error_mark_node;"}, {"sha": "a09d5cd8ac87063e852183dadf9077a7c70a4972", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -2105,3 +2105,31 @@ make_temp_vec (len)\n   pop_obstacks ();\n   return node;\n }\n+\n+/* The type of ARG when used as an lvalue.  */\n+\n+tree\n+lvalue_type (arg)\n+     tree arg;\n+{\n+  return cp_build_type_variant\n+    (TREE_TYPE (arg), TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n+}\n+\n+/* The type of ARG for printing error messages; denote lvalues with\n+   reference types.  */\n+\n+tree\n+error_type (arg)\n+     tree arg;\n+{\n+  tree type = TREE_TYPE (arg);\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    ;\n+  else if (real_lvalue_p (arg))\n+    type = build_reference_type (lvalue_type (arg));\n+  else if (IS_AGGR_TYPE (type))\n+    type = lvalue_type (arg);\n+\n+  return type;\n+}"}, {"sha": "5f176c0d5e446f3143abc5acd52f41fbd59dc774", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11ad92ebed6c4feed7ef1001b18ed707395d074/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d11ad92ebed6c4feed7ef1001b18ed707395d074", "patch": "@@ -1792,7 +1792,8 @@ build_component_ref (datum, component, basetype_path, protect)\n        hierarchy, the compiler will abort (because vptr lookups are\n        not supposed to be ambiguous.  */\n     field = CLASSTYPE_VFIELD (basetype);\n-  else if (TREE_CODE (component) == FIELD_DECL)\n+  else if (TREE_CODE (component) == FIELD_DECL\n+\t   || TREE_CODE (component) == TYPE_DECL)\n     {\n       field = component;\n     }\n@@ -4829,16 +4830,14 @@ build_conditional_expr (ifexp, op1, op2)\n \tpedwarn (\"ANSI C++ forbids conditional expr with only one void side\");\n       result_type = void_type_node;\n     }\n+  else if (code1 == POINTER_TYPE && null_ptr_cst_p (op2))\n+    result_type = qualify_type (type1, type2);\n+  else if (code2 == POINTER_TYPE && null_ptr_cst_p (op1))\n+    result_type = qualify_type (type2, type1);\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n     {\n       if (comp_target_types (type1, type2, 1))\n \tresult_type = common_type (type1, type2);\n-      else if (integer_zerop (op1) && TREE_TYPE (type1) == void_type_node\n-\t       && TREE_CODE (orig_op1) != NOP_EXPR)\n-\tresult_type = qualify_type (type2, type1);\n-      else if (integer_zerop (op2) && TREE_TYPE (type2) == void_type_node\n-\t       && TREE_CODE (orig_op2) != NOP_EXPR)\n-\tresult_type = qualify_type (type1, type2);\n       else if (TYPE_MAIN_VARIANT (TREE_TYPE (type1)) == void_type_node)\n \t{\n \t  if (pedantic && TREE_CODE (type2) == FUNCTION_TYPE)\n@@ -4883,20 +4882,12 @@ build_conditional_expr (ifexp, op1, op2)\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n-      if (!integer_zerop (op2))\n-\tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n-      else\n-\top2 = null_pointer_node;\n-\n+      pedwarn (\"pointer/integer type mismatch in conditional expression\");\n       result_type = type1;\n     }\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n-      if (!integer_zerop (op1))\n-\tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n-      else\n-\top1 = null_pointer_node;\n-\n+      pedwarn (\"pointer/integer type mismatch in conditional expression\");\n       result_type = type2;\n     }\n \n@@ -6376,7 +6367,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t      return error_mark_node;\n \t    }\n \n-\t  if (ctt < 0)\n+\t  if (ctt < 0 && TYPE_MAIN_VARIANT (ttl) != TYPE_MAIN_VARIANT (ttr))\n \t    cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n \t\t\trhstype, type);\n \n@@ -7269,6 +7260,10 @@ comp_ptr_ttypes_real (to, from, constp)\n       if (TREE_CODE (to) != TREE_CODE (from))\n \treturn 0;\n \n+      if (TREE_CODE (from) == OFFSET_TYPE\n+\t  && TYPE_OFFSET_BASETYPE (from) == TYPE_OFFSET_BASETYPE (to))\n+\t  continue;\n+\n       /* Const and volatile mean something different for function types,\n \t so the usual checks are not appropriate.  */\n       if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n@@ -7299,3 +7294,26 @@ comp_ptr_ttypes (to, from)\n {\n   return comp_ptr_ttypes_real (to, from, 1);\n }\n+\n+/* Returns 1 if to and from are (possibly multi-level) pointers to the same\n+   type or inheritance-related types, regardless of cv-quals.  */\n+\n+int\n+ptr_reasonably_similar (to, from)\n+     tree to, from;\n+{\n+  for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n+    {\n+      if (TREE_CODE (to) != TREE_CODE (from))\n+\treturn 0;\n+\n+      if (TREE_CODE (from) == OFFSET_TYPE\n+\t  && comptypes (TYPE_OFFSET_BASETYPE (to),\n+\t\t\tTYPE_OFFSET_BASETYPE (from), -1))\n+\tcontinue;\n+\n+      if (TREE_CODE (to) != POINTER_TYPE)\n+\treturn comptypes\n+\t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), -1);\n+    }\n+}"}]}