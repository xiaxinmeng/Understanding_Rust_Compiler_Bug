{"sha": "8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMwODZjOWM2ZWNlZWQwYzhkMWRiZDg0NjMyNzJlMTg1NGU1YjRlNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-30T05:18:36Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-30T05:18:36Z"}, "message": "re PR fortran/28885 (ICE passing components of array of derived type)\n\n2006-08-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28885\n\tREGRESSION FIX\n\t* trans-expr.c (gfc_conv_aliased_arg): Ensure that the temp\n\tdeclaration is retained for INTENT(OUT) arguments.\n\n\tPR fortran/28873\n\tREGRESSION FIX\n\tPR fortran/20067\n\t* resolve.c (resolve_generic_f): Make error message more\n\tcomprehensible.\n\t(resolve_generic_s): Restructure search for specific procedures\n\tto be similar to resolve_generic_f and change to similar error\n\tmessage.  Ensure that symbol reference is refreshed, in case\n\tthe search produces a NULL.\n\t(resolve_specific_s): Restructure search, as above and as\n\tresolve_specific_f. Ensure that symbol reference is refreshed,\n\tin case the search produces a NULL.\n\n\tPR fortran/25077\n\tPR fortran/25102\n\t* interface.c (check_operator_interface): Throw error if the\n\tinterface assignment tries to change intrinsic type assigments\n\tor has less than two arguments.  Also, it is an error if an\n\tinterface operator contains an alternate return.\n\n\tPR fortran/24866\n\t* parse.c (gfc_fixup_sibling_symbols): Do not modify the symbol\n\tif it is a dummy in the contained namespace.\n\n\n2006-08-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28885\n\t* gfortran.dg/aliasing_dummy_2.f90: New test.\n\n\tPR fortran/20067\n\t* gfortran.dg/generic_5.f90: Change error message.\n\n\tPR fortran/28873\n\t* gfortran.dg/generic_6.f90: New test.\n\n\tPR fortran/25077\n\t* gfortran.dg/redefined_intrinsic_assignment.f90: New test.\n\n\tPR fortran/25102\n\t* gfortran.dg/invalid_interface_assignment.f90: New test.\n\n\tPR fortran/24866\n\t* gfortran.dg/module_proc_external_dummy.f90: New test.\n\nFrom-SVN: r116578", "tree": {"sha": "d537dbcb1097607a1a3c621891ffa482aa77638d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d537dbcb1097607a1a3c621891ffa482aa77638d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/comments", "author": null, "committer": null, "parents": [{"sha": "a2ef097954b08063f1100d45c3d8499ac9fc46f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ef097954b08063f1100d45c3d8499ac9fc46f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ef097954b08063f1100d45c3d8499ac9fc46f8"}], "stats": {"total": 285, "additions": 253, "deletions": 32}, "files": [{"sha": "ce38af8ecb1a7730acf0530e235bb8ce2d44846e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -1,3 +1,34 @@\n+2006-08-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28885\n+\tREGRESSION FIX\n+\t* trans-expr.c (gfc_conv_aliased_arg): Ensure that the temp\n+\tdeclaration is retained for INTENT(OUT) arguments.\n+\n+\tPR fortran/28873\n+\tREGRESSION FIX\n+\tPR fortran/20067\n+\t* resolve.c (resolve_generic_f): Make error message more\n+\tcomprehensible.\n+\t(resolve_generic_s): Restructure search for specific procedures\n+\tto be similar to resolve_generic_f and change to similar error\n+\tmessage.  Ensure that symbol reference is refreshed, in case\n+\tthe search produces a NULL.\n+\t(resolve_specific_s): Restructure search, as above and as\n+\tresolve_specific_f. Ensure that symbol reference is refreshed,\n+\tin case the search produces a NULL.\n+\n+\tPR fortran/25077\n+\tPR fortran/25102\n+\t* interface.c (check_operator_interface): Throw error if the\n+\tinterface assignment tries to change intrinsic type assigments\n+\tor has less than two arguments.  Also, it is an error if an\n+\tinterface operator contains an alternate return.\n+\n+\tPR fortran/24866\n+\t* parse.c (gfc_fixup_sibling_symbols): Do not modify the symbol\n+\tif it is a dummy in the contained namespace.\n+\n 2006-08-29  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/28866"}, {"sha": "47fc79b746b47149c5fd5845cb9b471de10b8696", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -503,7 +503,12 @@ check_operator_interface (gfc_interface * intr, gfc_intrinsic_op operator)\n   for (formal = intr->sym->formal; formal; formal = formal->next)\n     {\n       sym = formal->sym;\n-\n+      if (sym == NULL)\n+\t{\n+\t  gfc_error (\"Alternate return cannot appear in operator \"\n+\t\t     \"interface at %L\", &intr->where);\n+\t  return;\n+\t}\n       if (args == 0)\n \t{\n \t  t1 = sym->ts.type;\n@@ -531,6 +536,24 @@ check_operator_interface (gfc_interface * intr, gfc_intrinsic_op operator)\n \t     &intr->where);\n \t  return;\n \t}\n+      if (args != 2)\n+\t{\n+\t  gfc_error\n+\t    (\"Assignment operator interface at %L must have two arguments\",\n+\t     &intr->where);\n+\t  return;\n+\t}\n+      if (sym->formal->sym->ts.type != BT_DERIVED\n+\t    && sym->formal->next->sym->ts.type != BT_DERIVED\n+\t    && (sym->formal->sym->ts.type == sym->formal->next->sym->ts.type\n+\t\t  || (gfc_numeric_ts (&sym->formal->sym->ts)\n+\t\t\t&& gfc_numeric_ts (&sym->formal->next->sym->ts))))\n+\t{\n+\t  gfc_error\n+\t    (\"Assignment operator interface at %L must not redefine \"\n+\t     \"an INTRINSIC type assignment\", &intr->where);\n+\t  return;\n+\t}\n     }\n   else\n     {"}, {"sha": "9ac7e45b12bc8598975c721c2a3b7bd3cee85d19", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -2706,8 +2706,9 @@ gfc_fixup_sibling_symbols (gfc_symbol * sym, gfc_namespace * siblings)\n   for (ns = siblings; ns; ns = ns->sibling)\n     {\n       gfc_find_sym_tree (sym->name, ns, 0, &st);\n-      if (!st)\n-        continue;\n+\n+      if (!st || (st->n.sym->attr.dummy && ns == st->n.sym->ns))\n+\tcontinue;\n \n       old_sym = st->n.sym;\n       if ((old_sym->attr.flavor == FL_PROCEDURE"}, {"sha": "f1606b19622dd16664b082e713a71810b59a0583", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -1181,7 +1181,7 @@ resolve_generic_f (gfc_expr * expr)\n \n   if (!gfc_generic_intrinsic (expr->symtree->n.sym->name))\n     {\n-      gfc_error (\"Generic function '%s' at %L is not an intrinsic function\",\n+      gfc_error (\"There is no specific function for the generic '%s' at %L\",\n \t\t expr->symtree->n.sym->name, &expr->where);\n       return FAILURE;\n     }\n@@ -1614,31 +1614,31 @@ resolve_generic_s (gfc_code * c)\n \n   sym = c->symtree->n.sym;\n \n-  m = resolve_generic_s0 (c, sym);\n-  if (m == MATCH_YES)\n-    return SUCCESS;\n-  if (m == MATCH_ERROR)\n-    return FAILURE;\n-\n-  if (sym->ns->parent != NULL && !sym->attr.use_assoc)\n+  for (;;)\n     {\n+      m = resolve_generic_s0 (c, sym);\n+      if (m == MATCH_YES)\n+\treturn SUCCESS;\n+      else if (m == MATCH_ERROR)\n+\treturn FAILURE;\n+\n+generic:\n+      if (sym->ns->parent == NULL)\n+\tbreak;\n       gfc_find_symbol (sym->name, sym->ns->parent, 1, &sym);\n-      if (sym != NULL)\n-\t{\n-\t  m = resolve_generic_s0 (c, sym);\n-\t  if (m == MATCH_YES)\n-\t    return SUCCESS;\n-\t  if (m == MATCH_ERROR)\n-\t    return FAILURE;\n-\t}\n+\n+      if (sym == NULL)\n+\tbreak;\n+      if (!generic_sym (sym))\n+\tgoto generic;\n     }\n \n   /* Last ditch attempt.  */\n-\n+  sym = c->symtree->n.sym;\n   if (!gfc_generic_intrinsic (sym->name))\n     {\n       gfc_error\n-\t(\"Generic subroutine '%s' at %L is not an intrinsic subroutine\",\n+\t(\"There is no specific subroutine for the generic '%s' at %L\",\n \t sym->name, &c->loc);\n       return FAILURE;\n     }\n@@ -1708,23 +1708,24 @@ resolve_specific_s (gfc_code * c)\n \n   sym = c->symtree->n.sym;\n \n-  m = resolve_specific_s0 (c, sym);\n-  if (m == MATCH_YES)\n-    return SUCCESS;\n-  if (m == MATCH_ERROR)\n-    return FAILURE;\n-\n-  gfc_find_symbol (sym->name, sym->ns->parent, 1, &sym);\n-\n-  if (sym != NULL)\n+  for (;;)\n     {\n       m = resolve_specific_s0 (c, sym);\n       if (m == MATCH_YES)\n \treturn SUCCESS;\n       if (m == MATCH_ERROR)\n \treturn FAILURE;\n+\n+      if (sym->ns->parent == NULL)\n+\tbreak;\n+\n+      gfc_find_symbol (sym->name, sym->ns->parent, 1, &sym);\n+\n+      if (sym == NULL)\n+\tbreak;\n     }\n \n+  sym = c->symtree->n.sym;\n   gfc_error (\"Unable to resolve the specific subroutine '%s' at %L\",\n \t     sym->name, &c->loc);\n "}, {"sha": "37bf782f7bdf3360a2728635074858678fd73195", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -1707,6 +1707,12 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n       gcc_assert (rse.ss == gfc_ss_terminator);\n       gfc_trans_scalarizing_loops (&loop, &body);\n     }\n+  else\n+    {\n+      /* Make sure that the temporary declaration survives.  */\n+      tmp = gfc_finish_block (&body);\n+      gfc_add_expr_to_block (&loop.pre, tmp);\n+    }\n \n   /* Add the post block after the second loop, so that any\n      freeing of allocated memory is done at the right time.  */"}, {"sha": "4fe14fcd1b3aaa805ad445fe5c339e672c055de1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -1,3 +1,23 @@\n+2006-08-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28885\n+\t* gfortran.dg/aliasing_dummy_2.f90: New test.\n+\n+\tPR fortran/20067\n+\t* gfortran.dg/generic_5.f90: Change error message.\n+\n+\tPR fortran/28873\n+\t* gfortran.dg/generic_6.f90: New test.\n+\n+\tPR fortran/25077\n+\t* gfortran.dg/redefined_intrinsic_assignment.f90: New test.\n+\n+\tPR fortran/25102\n+\t* gfortran.dg/invalid_interface_assignment.f90: New test.\n+\n+\tPR fortran/24866\n+\t* gfortran.dg/module_proc_external_dummy.f90: New test.\n+\n 2006-08-29  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/28349"}, {"sha": "3a3856f68d742fefc9a59b1f2de45b0dacbbaf89", "filename": "gcc/testsuite/gfortran.dg/aliasing_dummy_2.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_dummy_2.f90?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! This tests the fix for PR28885, in which multiple calls to a procedure\n+! with different components of an array of derived types for an INTENT(OUT)\n+! argument caused an ICE internal compiler error.  This came about because\n+! the compiler would lose the temporary declaration with each subsequent\n+! call of the procedure.\n+!\n+! Reduced from the contribution by Drew McCormack  <drewmccormack@mac.com>\n+!\n+program test\n+  type t\n+    integer :: i\n+    integer :: j\n+  end type\n+  type (t) :: a(5) \n+  call sub('one',a%j)\n+  call sub('two',a%i)\n+contains\n+  subroutine sub(key,a)\n+    integer, intent(out)    :: a(:) \n+    character(*),intent(in) :: key\n+    a = 1   \n+  end subroutine\n+end program "}, {"sha": "cb720980341a58249d277328be4ba003235a5613", "filename": "gcc/testsuite/gfortran.dg/generic_5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_5.f90?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -23,7 +23,7 @@ MODULE provoke_ice\n CONTAINS\n   SUBROUTINE provoke\n     USE ice_gfortran\n-    CALL ice(23.0)   ! { dg-error \"is not an intrinsic subroutine\" }\n+    CALL ice(23.0)   ! { dg-error \"no specific subroutine\" }\n   END SUBROUTINE\n END MODULE\n-\n+! { dg-final { cleanup-modules \"ice_gfortran provoke_ice\" } }"}, {"sha": "9d08ac223e49ee41810cc2872ffc4f4def9c58e3", "filename": "gcc/testsuite/gfortran.dg/generic_6.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_6.f90?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+! Tests the patch for PR28873, in which the call create () would cause an\n+! error because resolve.c(resolve_generic_s) was failing to look in the\n+! parent namespace for a matching specific subroutine. This, in fact, was\n+! a regression due to the fix for PR28201.\n+!\n+! Contributed by Drew McCormack  <drewmccormack@mac.com> \n+!\n+module A\n+  private \n+  interface create\n+    module procedure create1 \n+  end interface\n+  public :: create\n+contains\n+  subroutine create1\n+    print *, \"module A\"\n+  end subroutine\n+end module\n+\n+module B\n+  private \n+  interface create\n+    module procedure create1 \n+  end interface\n+  public :: create\n+contains\n+  subroutine create1(a)\n+    integer a\n+    print *, \"module B\"\n+  end subroutine\n+end module\n+\n+module C\n+  use A\n+  private\n+  public useCreate\n+contains\n+  subroutine useCreate\n+    use B\n+    call create()\n+    call create(1)\n+  end subroutine\n+end module\n+\n+  use c\n+  call useCreate\n+end\n+! { dg-final { cleanup-modules \"A B C\" } }"}, {"sha": "d29163d8de6927f77d6f4f784361383fddee52c1", "filename": "gcc/testsuite/gfortran.dg/invalid_interface_assignment.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Finvalid_interface_assignment.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Finvalid_interface_assignment.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finvalid_interface_assignment.f90?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! Tests the fix for PR25102, which did not diagnose the aberrant interface\n+! assignement below.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+MODULE TT\n+ TYPE data_type\n+   INTEGER :: I\n+ END TYPE data_type\n+ INTERFACE ASSIGNMENT (=)\n+   MODULE PROCEDURE set   ! { dg-error \"Alternate return cannot appear\" }\n+ END INTERFACE\n+CONTAINS\n+  PURE SUBROUTINE set(x1,*)\n+    TYPE(data_type), INTENT(OUT) :: x1\n+    x1%i=0\n+  END SUBROUTINE set\n+END MODULE"}, {"sha": "08f61b05f6f3a8486680f697b61d62d245cf5692", "filename": "gcc/testsuite/gfortran.dg/module_proc_external_dummy.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_proc_external_dummy.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_proc_external_dummy.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_proc_external_dummy.f90?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! This tests the fix for PR24866 in which the reference to the external str, in\n+! sub_module, would get mixed up with the module procedure, str, thus\n+! causing an ICE.  This is a completed version of the reporter's testcase; ie\n+! it adds a main program and working subroutines to allow a check for\n+! correct functioning.\n+!\n+! Contributed by Uttam Pawar  <uttamp@us.ibm.com>\n+!\n+   subroutine sub()\n+     print *, \"external sub\"\n+   end subroutine sub\n+\n+module test_module\n+ contains\n+   subroutine sub_module(str)\n+     external :: str\n+     call str ()\n+   end subroutine sub_module\n+   subroutine str()\n+     print *, \"module str\"\n+   end subroutine str\n+end module test_module\n+\n+   use test_module\n+   external sub\n+   call sub_module (sub)\n+   call sub_module (str)\n+end"}, {"sha": "915f92e39827f6a91ce8696a1ef285c2ab26b980", "filename": "gcc/testsuite/gfortran.dg/redefined_intrinsic_assignment.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fredefined_intrinsic_assignment.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7/gcc%2Ftestsuite%2Fgfortran.dg%2Fredefined_intrinsic_assignment.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fredefined_intrinsic_assignment.f90?ref=8c086c9c6eceed0c8d1dbd8463272e1854e5b4e7", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! Tests the fix for PR25077 in which no diagnostic was produced\n+! for the redefinition of an intrinsic type assignment.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+MODULE M1\n+ IMPLICIT NONE\n+ INTERFACE ASSIGNMENT(=)\n+  MODULE PROCEDURE T1 ! { dg-error \"redefine an INTRINSIC type assignment\" }\n+ END INTERFACE\n+CONTAINS\n+ SUBROUTINE T1(I,J)\n+   INTEGER, INTENT(OUT)  :: I\n+   INTEGER, INTENT(IN)  :: J\n+   I=-J\n+ END SUBROUTINE T1\n+END MODULE M1"}]}