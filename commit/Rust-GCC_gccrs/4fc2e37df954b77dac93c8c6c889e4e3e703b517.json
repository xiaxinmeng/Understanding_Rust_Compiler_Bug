{"sha": "4fc2e37df954b77dac93c8c6c889e4e3e703b517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjMmUzN2RmOTU0Yjc3ZGFjOTNjOGM2Yzg4OWU0ZTNlNzAzYjUxNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-10-13T20:22:07Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-10-13T20:22:07Z"}, "message": "re PR rtl-optimization/54871 (gfortran.dg/vector_subscript_1.f90 FAILs)\n\n\tPR rtl-optimization/54871\n\t* loop-iv.c (simplify_using_initial_values): When scanning previous\n\tbasic blocks, prune the recorded conditions if the current insn was\n\tnot used to make a replacement.\n\n\t* loop-unroll.c (decide_unroll_constant_iterations): Clean up message.\n\t(unroll_loop_constant_iterations): Clarify head comment.\n\t(decide_unroll_runtime_iterations): Clean up message.\n\t(unroll_loop_runtime_iterations): Clarify head comment.\n\t(decide_peel_simple): Clean up message.\n\t(peel_loop_simple): Clarify head comment.\n\t(decide_unroll_stupid): Clean up message.\n\t(unroll_loop_stupid): Clarify head comment.\n\nFrom-SVN: r192426", "tree": {"sha": "65baa180a86b2d42af9b66e92cc76a26e4c508b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65baa180a86b2d42af9b66e92cc76a26e4c508b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc2e37df954b77dac93c8c6c889e4e3e703b517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc2e37df954b77dac93c8c6c889e4e3e703b517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc2e37df954b77dac93c8c6c889e4e3e703b517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc2e37df954b77dac93c8c6c889e4e3e703b517/comments", "author": null, "committer": null, "parents": [{"sha": "258ef00780344ea3565b3276a60343529e94acc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258ef00780344ea3565b3276a60343529e94acc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258ef00780344ea3565b3276a60343529e94acc3"}], "stats": {"total": 91, "additions": 61, "deletions": 30}, "files": [{"sha": "d80612418b96249cc2675ffc2142d33272b7357b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2e37df954b77dac93c8c6c889e4e3e703b517/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2e37df954b77dac93c8c6c889e4e3e703b517/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fc2e37df954b77dac93c8c6c889e4e3e703b517", "patch": "@@ -1,3 +1,19 @@\n+2012-10-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/54871\n+\t* loop-iv.c (simplify_using_initial_values): When scanning previous\n+\tbasic blocks, prune the recorded conditions if the current insn was\n+\tnot used to make a replacement.\n+\n+\t* loop-unroll.c (decide_unroll_constant_iterations): Clean up message.\n+\t(unroll_loop_constant_iterations): Clarify head comment.\n+\t(decide_unroll_runtime_iterations): Clean up message.\n+\t(unroll_loop_runtime_iterations): Clarify head comment.\n+\t(decide_peel_simple): Clean up message.\n+\t(peel_loop_simple): Clarify head comment.\n+\t(decide_unroll_stupid): Clean up message.\n+\t(unroll_loop_stupid): Clarify head comment.\n+\n 2012-10-13  Andreas Schwab  <schwab@linux-m68k.org>\n \n \tPR gcov-profile/44728"}, {"sha": "4619c626b7b249a91572370414695be4d0db779d", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2e37df954b77dac93c8c6c889e4e3e703b517/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2e37df954b77dac93c8c6c889e4e3e703b517/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=4fc2e37df954b77dac93c8c6c889e4e3e703b517", "patch": "@@ -2004,11 +2004,30 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t\t}\n \t    }\n \t  else\n-\t    /* If we did not use this insn to make a replacement, any overlap\n-\t       between stores in this insn and our expression will cause the\n-\t       expression to become invalid.  */\n-\t    if (for_each_rtx (expr, altered_reg_used, this_altered))\n-\t      goto out;\n+\t    {\n+\t      rtx *pnote, *pnote_next;\n+\n+\t      /* If we did not use this insn to make a replacement, any overlap\n+\t\t between stores in this insn and our expression will cause the\n+\t\t expression to become invalid.  */\n+\t      if (for_each_rtx (expr, altered_reg_used, this_altered))\n+\t\tgoto out;\n+\n+\t      /* Likewise for the conditions.  */\n+\t      for (pnote = &cond_list; *pnote; pnote = pnote_next)\n+\t\t{\n+\t\t  rtx note = *pnote;\n+\t\t  rtx old_cond = XEXP (note, 0);\n+\n+\t\t  pnote_next = &XEXP (note, 1);\n+\t\t  if (for_each_rtx (&old_cond, altered_reg_used, this_altered))\n+\t\t    {\n+\t\t      *pnote = *pnote_next;\n+\t\t      pnote_next = pnote;\n+\t\t      free_EXPR_LIST_node (note);\n+\t\t    }\n+\t\t}\n+\t    }\n \n \t  if (CONSTANT_P (*expr))\n \t    goto out;"}, {"sha": "5350ee0881574288b5b725fdb93cc4b3c68d9a52", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc2e37df954b77dac93c8c6c889e4e3e703b517/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc2e37df954b77dac93c8c6c889e4e3e703b517/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=4fc2e37df954b77dac93c8c6c889e4e3e703b517", "patch": "@@ -602,26 +602,21 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n \t}\n     }\n \n-  if (dump_file)\n-    fprintf (dump_file, \";; max_unroll %d (%d copies, initial %d).\\n\",\n-\t     best_unroll + 1, best_copies, nunroll);\n-\n   loop->lpt_decision.decision = LPT_UNROLL_CONSTANT;\n   loop->lpt_decision.times = best_unroll;\n \n   if (dump_file)\n-    fprintf (dump_file,\n-\t     \";; Decided to unroll the constant times rolling loop, %d times.\\n\",\n-\t     loop->lpt_decision.times);\n+    fprintf (dump_file, \";; Decided to unroll the loop %d times (%d copies).\\n\",\n+\t     loop->lpt_decision.times, best_copies);\n }\n \n-/* Unroll LOOP with constant number of iterations LOOP->LPT_DECISION.TIMES + 1\n-   times.  The transformation does this:\n+/* Unroll LOOP with constant number of iterations LOOP->LPT_DECISION.TIMES times.\n+   The transformation does this:\n \n    for (i = 0; i < 102; i++)\n      body;\n \n-   ==>\n+   ==>  (LOOP->LPT_DECISION.TIMES == 3)\n \n    i = 0;\n    body; i++;\n@@ -671,7 +666,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n \t of exit condition have continuous body after unrolling.  */\n \n       if (dump_file)\n-\tfprintf (dump_file, \";; Condition on beginning of loop.\\n\");\n+\tfprintf (dump_file, \";; Condition at beginning of loop.\\n\");\n \n       /* Peel exit_mod iterations.  */\n       RESET_BIT (wont_exit, 0);\n@@ -713,7 +708,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n \t the loop tests the condition at the end of loop body.  */\n \n       if (dump_file)\n-\tfprintf (dump_file, \";; Condition on end of loop.\\n\");\n+\tfprintf (dump_file, \";; Condition at end of loop.\\n\");\n \n       /* We know that niter >= max_unroll + 2; so we do not need to care of\n \t case when we would exit before reaching the loop.  So just peel\n@@ -896,9 +891,7 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n   loop->lpt_decision.times = i - 1;\n \n   if (dump_file)\n-    fprintf (dump_file,\n-\t     \";; Decided to unroll the runtime computable \"\n-\t     \"times rolling loop, %d times.\\n\",\n+    fprintf (dump_file, \";; Decided to unroll the loop %d times.\\n\",\n \t     loop->lpt_decision.times);\n }\n \n@@ -949,14 +942,14 @@ split_edge_and_insert (edge e, rtx insns)\n   return bb;\n }\n \n-/* Unroll LOOP for that we are able to count number of iterations in runtime\n-   LOOP->LPT_DECISION.TIMES + 1 times.  The transformation does this (with some\n+/* Unroll LOOP for which we are able to count number of iterations in runtime\n+   LOOP->LPT_DECISION.TIMES times.  The transformation does this (with some\n    extra care for case n < 0):\n \n    for (i = 0; i < n; i++)\n      body;\n \n-   ==>\n+   ==>  (LOOP->LPT_DECISION.TIMES == 3)\n \n    i = 0;\n    mod = n % 4;\n@@ -1314,20 +1307,23 @@ decide_peel_simple (struct loop *loop, int flags)\n   loop->lpt_decision.times = npeel;\n \n   if (dump_file)\n-    fprintf (dump_file, \";; Decided to simply peel the loop, %d times.\\n\",\n+    fprintf (dump_file, \";; Decided to simply peel the loop %d times.\\n\",\n \t     loop->lpt_decision.times);\n }\n \n-/* Peel a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:\n+/* Peel a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation does this:\n+\n    while (cond)\n      body;\n \n-   ==>\n+   ==>  (LOOP->LPT_DECISION.TIMES == 3)\n \n    if (!cond) goto end;\n    body;\n    if (!cond) goto end;\n    body;\n+   if (!cond) goto end;\n+   body;\n    while (cond)\n      body;\n    end: ;\n@@ -1464,16 +1460,16 @@ decide_unroll_stupid (struct loop *loop, int flags)\n   loop->lpt_decision.times = i - 1;\n \n   if (dump_file)\n-    fprintf (dump_file,\n-\t     \";; Decided to unroll the loop stupidly, %d times.\\n\",\n+    fprintf (dump_file, \";; Decided to unroll the loop stupidly %d times.\\n\",\n \t     loop->lpt_decision.times);\n }\n \n-/* Unroll a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:\n+/* Unroll a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation does this:\n+\n    while (cond)\n      body;\n \n-   ==>\n+   ==>  (LOOP->LPT_DECISION.TIMES == 3)\n \n    while (cond)\n      {"}]}