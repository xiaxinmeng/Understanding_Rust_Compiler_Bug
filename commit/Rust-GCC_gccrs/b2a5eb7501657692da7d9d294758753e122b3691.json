{"sha": "b2a5eb7501657692da7d9d294758753e122b3691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJhNWViNzUwMTY1NzY5MmRhN2Q5ZDI5NDc1ODc1M2UxMjJiMzY5MQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-07-29T18:14:16Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-07-29T18:14:16Z"}, "message": "re PR fortran/45004 ([OOP] Segfault with allocatable scalars and move_alloc)\n\n2010-07-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45004\n\t* trans-stmt.h (gfc_trans_class_init_assign): New prototype.\n\t(gfc_trans_class_assign): Modified prototype.\n\t* trans.h (gfc_conv_intrinsic_move_alloc): New prototype.\n\t* trans-expr.c (gfc_trans_class_init_assign): Split off from ...\n\t(gfc_trans_class_assign): ... here. Modified actual arguments.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_move_alloc): New function to\n\thandle the MOVE_ALLOC intrinsic with scalar and class arguments.\n\t* trans.c (trans_code): Call 'gfc_conv_intrinsic_move_alloc'.\n\n\n2010-07-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45004\n\t* gfortran.dg/move_alloc_2.f90: New.\n\nFrom-SVN: r162688", "tree": {"sha": "a67dba99dceef9faa3716776308033df861b23c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a67dba99dceef9faa3716776308033df861b23c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2a5eb7501657692da7d9d294758753e122b3691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a5eb7501657692da7d9d294758753e122b3691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2a5eb7501657692da7d9d294758753e122b3691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a5eb7501657692da7d9d294758753e122b3691/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3378ceac91930adf5d5f2f95ca2874c14b6f6f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3378ceac91930adf5d5f2f95ca2874c14b6f6f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3378ceac91930adf5d5f2f95ca2874c14b6f6f1"}], "stats": {"total": 175, "additions": 136, "deletions": 39}, "files": [{"sha": "f22ed116f2980a47b87087b168c3e2b6d2ca6aad", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -1,3 +1,15 @@\n+2010-07-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45004\n+\t* trans-stmt.h (gfc_trans_class_init_assign): New prototype.\n+\t(gfc_trans_class_assign): Modified prototype.\n+\t* trans.h (gfc_conv_intrinsic_move_alloc): New prototype.\n+\t* trans-expr.c (gfc_trans_class_init_assign): Split off from ...\n+\t(gfc_trans_class_assign): ... here. Modified actual arguments.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_move_alloc): New function to\n+\thandle the MOVE_ALLOC intrinsic with scalar and class arguments.\n+\t* trans.c (trans_code): Call 'gfc_conv_intrinsic_move_alloc'.\n+\n 2010-07-29  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/42051"}, {"sha": "53df2ae894fb38cecf31cb105a5e44aeb0748856", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -5671,57 +5671,65 @@ void gfc_trans_assign_vtab_procs (stmtblock_t *block, gfc_symbol *dt,\n }\n \n \n+/* Special case for initializing a CLASS variable on allocation.\n+   A MEMCPY is needed to copy the full data of the dynamic type,\n+   which may be different from the declared type.  */\n+\n+tree\n+gfc_trans_class_init_assign (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree tmp, memsz;\n+  gfc_se dst,src;\n+  \n+  gfc_start_block (&block);\n+  \n+  gfc_init_se (&dst, NULL);\n+  gfc_init_se (&src, NULL);\n+  gfc_add_component_ref (code->expr1, \"$data\");\n+  gfc_conv_expr (&dst, code->expr1);\n+  gfc_conv_expr (&src, code->expr2);\n+  gfc_add_block_to_block (&block, &src.pre);\n+  memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr2->ts));\n+  tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz);\n+  gfc_add_expr_to_block (&block, tmp);\n+  \n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* Translate an assignment to a CLASS object\n    (pointer or ordinary assignment).  */\n \n tree\n-gfc_trans_class_assign (gfc_code *code)\n+gfc_trans_class_assign (gfc_expr *expr1, gfc_expr *expr2, gfc_exec_op op)\n {\n   stmtblock_t block;\n   tree tmp;\n   gfc_expr *lhs;\n   gfc_expr *rhs;\n \n   gfc_start_block (&block);\n-  \n-  if (code->op == EXEC_INIT_ASSIGN)\n-    {\n-      /* Special case for initializing a CLASS variable on allocation.\n-\t A MEMCPY is needed to copy the full data of the dynamic type,\n-\t which may be different from the declared type.  */\n-      gfc_se dst,src;\n-      tree memsz;\n-      gfc_init_se (&dst, NULL);\n-      gfc_init_se (&src, NULL);\n-      gfc_add_component_ref (code->expr1, \"$data\");\n-      gfc_conv_expr (&dst, code->expr1);\n-      gfc_conv_expr (&src, code->expr2);\n-      gfc_add_block_to_block (&block, &src.pre);\n-      memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr2->ts));\n-      tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz);\n-      gfc_add_expr_to_block (&block, tmp);\n-      return gfc_finish_block (&block);\n-    }\n \n-  if (code->expr2->ts.type != BT_CLASS)\n+  if (expr2->ts.type != BT_CLASS)\n     {\n       /* Insert an additional assignment which sets the '$vptr' field.  */\n-      lhs = gfc_copy_expr (code->expr1);\n+      lhs = gfc_copy_expr (expr1);\n       gfc_add_component_ref (lhs, \"$vptr\");\n-      if (code->expr2->ts.type == BT_DERIVED)\n+      if (expr2->ts.type == BT_DERIVED)\n \t{\n \t  gfc_symbol *vtab;\n \t  gfc_symtree *st;\n-\t  vtab = gfc_find_derived_vtab (code->expr2->ts.u.derived);\n+\t  vtab = gfc_find_derived_vtab (expr2->ts.u.derived);\n \t  gcc_assert (vtab);\n-\t  gfc_trans_assign_vtab_procs (&block, code->expr2->ts.u.derived, vtab);\n+\t  gfc_trans_assign_vtab_procs (&block, expr2->ts.u.derived, vtab);\n \t  rhs = gfc_get_expr ();\n \t  rhs->expr_type = EXPR_VARIABLE;\n \t  gfc_find_sym_tree (vtab->name, NULL, 1, &st);\n \t  rhs->symtree = st;\n \t  rhs->ts = vtab->ts;\n \t}\n-      else if (code->expr2->expr_type == EXPR_NULL)\n+      else if (expr2->expr_type == EXPR_NULL)\n \trhs = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n       else\n \tgcc_unreachable ();\n@@ -5734,15 +5742,15 @@ gfc_trans_class_assign (gfc_code *code)\n     }\n \n   /* Do the actual CLASS assignment.  */\n-  if (code->expr2->ts.type == BT_CLASS)\n-    code->op = EXEC_ASSIGN;\n+  if (expr2->ts.type == BT_CLASS)\n+    op = EXEC_ASSIGN;\n   else\n-    gfc_add_component_ref (code->expr1, \"$data\");\n+    gfc_add_component_ref (expr1, \"$data\");\n \n-  if (code->op == EXEC_ASSIGN)\n-    tmp = gfc_trans_assign (code);\n-  else if (code->op == EXEC_POINTER_ASSIGN)\n-    tmp = gfc_trans_pointer_assign (code);\n+  if (op == EXEC_ASSIGN)\n+    tmp = gfc_trans_assignment (expr1, expr2, false, true);\n+  else if (op == EXEC_POINTER_ASSIGN)\n+    tmp = gfc_trans_pointer_assignment (expr1, expr2);\n   else\n     gcc_unreachable();\n "}, {"sha": "a576076076fa349b9dac2e7f6af81ca7a4959ff1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -5559,4 +5559,42 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n     }\n }\n \n+\n+tree\n+gfc_conv_intrinsic_move_alloc (gfc_code *code)\n+{\n+  if (code->ext.actual->expr->rank == 0)\n+    {\n+      /* Scalar arguments: Generate pointer assignments.  */\n+      gfc_expr *from, *to;\n+      stmtblock_t block;\n+      tree tmp;\n+\n+      from = code->ext.actual->expr;\n+      to = code->ext.actual->next->expr;\n+\n+      gfc_start_block (&block);\n+\n+      if (to->ts.type == BT_CLASS)\n+\ttmp = gfc_trans_class_assign (to, from, EXEC_POINTER_ASSIGN);\n+      else\n+\ttmp = gfc_trans_pointer_assignment (to, from);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      if (from->ts.type == BT_CLASS)\n+\ttmp = gfc_trans_class_assign (from, gfc_get_null_expr (NULL),\n+\t\t\t\t      EXEC_POINTER_ASSIGN);\n+      else\n+\ttmp = gfc_trans_pointer_assignment (from,\n+\t\t\t\t\t    gfc_get_null_expr (NULL));\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      return gfc_finish_block (&block);\n+    }\n+  else\n+    /* Array arguments: Generate library code.  */\n+    return gfc_trans_call (code, false, NULL_TREE, NULL_TREE, false);\n+}\n+\n+\n #include \"gt-fortran-trans-intrinsic.h\""}, {"sha": "8b77750c589ff33ba8e42b92ea5f63adad1fd44d", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -32,7 +32,8 @@ tree gfc_trans_code_cond (gfc_code *, tree);\n tree gfc_trans_assign (gfc_code *);\n tree gfc_trans_pointer_assign (gfc_code *);\n tree gfc_trans_init_assign (gfc_code *);\n-tree gfc_trans_class_assign (gfc_code *code);\n+tree gfc_trans_class_init_assign (gfc_code *);\n+tree gfc_trans_class_assign (gfc_expr *, gfc_expr *, gfc_exec_op);\n \n /* trans-stmt.c */\n tree gfc_trans_cycle (gfc_code *);"}, {"sha": "e266be89c0c3a5f176c2c62357b808a358a695e6", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -1093,7 +1093,7 @@ trans_code (gfc_code * code, tree cond)\n \n \tcase EXEC_ASSIGN:\n \t  if (code->expr1->ts.type == BT_CLASS)\n-\t    res = gfc_trans_class_assign (code);\n+\t    res = gfc_trans_class_assign (code->expr1, code->expr2, code->op);\n \t  else\n \t    res = gfc_trans_assign (code);\n \t  break;\n@@ -1104,14 +1104,14 @@ trans_code (gfc_code * code, tree cond)\n \n \tcase EXEC_POINTER_ASSIGN:\n \t  if (code->expr1->ts.type == BT_CLASS)\n-\t    res = gfc_trans_class_assign (code);\n+\t    res = gfc_trans_class_assign (code->expr1, code->expr2, code->op);\n \t  else\n \t    res = gfc_trans_pointer_assign (code);\n \t  break;\n \n \tcase EXEC_INIT_ASSIGN:\n \t  if (code->expr1->ts.type == BT_CLASS)\n-\t    res = gfc_trans_class_assign (code);\n+\t    res = gfc_trans_class_init_assign (code);\n \t  else\n \t    res = gfc_trans_init_assign (code);\n \t  break;\n@@ -1157,8 +1157,12 @@ trans_code (gfc_code * code, tree cond)\n \t    if (code->resolved_isym\n \t\t&& code->resolved_isym->id == GFC_ISYM_MVBITS)\n \t      is_mvbits = true;\n-\t    res = gfc_trans_call (code, is_mvbits, NULL_TREE,\n-\t\t\t\t  NULL_TREE, false);\n+\t    if (code->resolved_isym\n+\t\t&& code->resolved_isym->id == GFC_ISYM_MOVE_ALLOC)\n+\t      res = gfc_conv_intrinsic_move_alloc (code);\n+\t    else\n+\t      res = gfc_trans_call (code, is_mvbits, NULL_TREE,\n+\t\t\t\t    NULL_TREE, false);\n \t  }\n \t  break;\n "}, {"sha": "3c80ce7f26c96f2d5abd5f6154bb67f127317a56", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -338,6 +338,8 @@ void gfc_conv_intrinsic_function (gfc_se *, gfc_expr *);\n /* Does an intrinsic map directly to an external library call.  */\n int gfc_is_intrinsic_libcall (gfc_expr *);\n \n+tree gfc_conv_intrinsic_move_alloc (gfc_code *);\n+\n /* Used to call ordinary functions/subroutines\n    and procedure pointer components.  */\n int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,"}, {"sha": "060b87976b17010b1c5387857f0025f4f4b3ab3c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -1,3 +1,8 @@\n+2010-07-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45004\n+\t* gfortran.dg/move_alloc_2.f90: New.\n+\n 2010-07-29  Xinliang David Li  <davidxl@google.com>\n \tPR tree-optimization/45121\n \t* c-c++-common/uninit-17.c: Fix expected output."}, {"sha": "5dabca849db17f1192ab2937cbe970ee38b19814", "filename": "gcc/testsuite/gfortran.dg/move_alloc_2.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2a5eb7501657692da7d9d294758753e122b3691/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_2.f90?ref=b2a5eb7501657692da7d9d294758753e122b3691", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+!\n+! PR 45004: [OOP] Segfault with allocatable scalars and move_alloc\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+\n+program bug18\n+\n+  type foo\n+    integer :: i\n+  end type foo\n+\n+  type bar\n+    class(foo), allocatable :: bf\n+  end type bar\n+\n+  class(foo), allocatable :: afab\n+  type(bar) :: bb\n+\n+  allocate(foo :: afab)\n+  afab%i = 8\n+  call move_alloc(afab, bb%bf)\n+  if (.not. allocated(bb%bf)) call abort()\n+  if (allocated(afab)) call abort()\n+  if (bb%bf%i/=8) call abort()\n+\n+end program bug18"}]}