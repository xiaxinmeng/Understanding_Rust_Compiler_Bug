{"sha": "981c7dcef835c914783cd456ee18a29611afe4db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxYzdkY2VmODM1YzkxNDc4M2NkNDU2ZWUxOGEyOTYxMWFmZTRkYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-17T21:01:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-17T21:01:34Z"}, "message": "h8300-protos.h: Remove prototypes for general_operand_src...\n\n\t* config/h8300/h8300-protos.h: Remove prototypes for\n\tgeneral_operand_src, general_operand_dst, single_one_operand,\n\tsingle_zero_operand, call_insn_operand,\n\ttwo_insn_adds_subs_operand, small_call_insn_operand,\n\tjump_address_operand, bit_operand, bit_memory_operand,\n\tstack_pointer_operand, const_int_gt_2_operand,\n\tconst_int_ge_8_operand, const_int_qi_operand,\n\tconst_int_hi_operand, incdec_operand, bit_operator,\n\tnshift_operator, eqne_operator, gtle_operator,\n\tgtuleu_operator, iorxor_operator.\n\tAdd prototypes for h8sx_shift_type h8sx_classify_shift and\n\th8300_ldm_stm_parallel.\n\t* config/h8300/h8300.c (h8sx_shift_type,): Move to\n\th8300-protos.h.\n\t(SYMBOL_FLAG_FUNCVEC_FUNCTION, SYMBOL_FLAG_EIGHTBIT_DATA,\n\tSYMBOL_FLAG_TINY_DATA): Move to h8300.h.\n\t(h8300_ldm_stm_parallel): Make it extern.\n\t(h8300_ldm_parallel, h8300_stm_parallel,\n\th8300_return_parallel, general_operand_src,\n\tgeneral_operand_dst, h8300_dst_operand, h8300_src_operand,\n\tnibble_operand, reg_or_nibble_operand, single_one_operand,\n\tsingle_zero_operand, call_insn_operand,\n\ttwo_insn_adds_subs_operand, small_call_insn_operand,\n\tjump_address_operand, bit_operand, bit_memory_operand,\n\tstack_pointer_operand, const_int_gt_2_operand,\n\tconst_int_ge_8_operand, const_int_qi_operand,\n\tconst_int_hi_operand, incdec_operand, eqne_operator,\n\tgtle_operator, gtuleu_operator, iorxor_operator, bit_operator,\n\th8sx_binary_memory_operator, h8sx_unary_memory_operator,\n\th8sx_unary_shift_operator, h8sx_binary_shift_operator,\n\tnshift_operator): Move to predicates.md.\n\t* config/h8300/h8300.h (PREDICATE_CODES): Remove.\n\t* config/h8300/h8300.md: Include predicates.md.\n\t* config/h8300/predicates.md: New.\n\nFrom-SVN: r96631", "tree": {"sha": "65756bb2bffaf514fbbb90f4c5bc24f2291c876c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65756bb2bffaf514fbbb90f4c5bc24f2291c876c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/981c7dcef835c914783cd456ee18a29611afe4db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981c7dcef835c914783cd456ee18a29611afe4db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/981c7dcef835c914783cd456ee18a29611afe4db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981c7dcef835c914783cd456ee18a29611afe4db/comments", "author": null, "committer": null, "parents": [{"sha": "ffd1953e438cfd6bf901ab0146fdfd3e328220b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd1953e438cfd6bf901ab0146fdfd3e328220b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd1953e438cfd6bf901ab0146fdfd3e328220b2"}], "stats": {"total": 1100, "additions": 549, "deletions": 551}, "files": [{"sha": "dd11e2c19449c35611916c92c016470179aebcf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=981c7dcef835c914783cd456ee18a29611afe4db", "patch": "@@ -1,3 +1,40 @@\n+2005-03-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300-protos.h: Remove prototypes for\n+\tgeneral_operand_src, general_operand_dst, single_one_operand,\n+\tsingle_zero_operand, call_insn_operand,\n+\ttwo_insn_adds_subs_operand, small_call_insn_operand,\n+\tjump_address_operand, bit_operand, bit_memory_operand,\n+\tstack_pointer_operand, const_int_gt_2_operand,\n+\tconst_int_ge_8_operand, const_int_qi_operand,\n+\tconst_int_hi_operand, incdec_operand, bit_operator,\n+\tnshift_operator, eqne_operator, gtle_operator,\n+\tgtuleu_operator, iorxor_operator.\n+\tAdd prototypes for h8sx_shift_type h8sx_classify_shift and\n+\th8300_ldm_stm_parallel.\n+\t* config/h8300/h8300.c (h8sx_shift_type,): Move to\n+\th8300-protos.h.\n+\t(SYMBOL_FLAG_FUNCVEC_FUNCTION, SYMBOL_FLAG_EIGHTBIT_DATA,\n+\tSYMBOL_FLAG_TINY_DATA): Move to h8300.h.\n+\t(h8300_ldm_stm_parallel): Make it extern.\n+\t(h8300_ldm_parallel, h8300_stm_parallel,\n+\th8300_return_parallel, general_operand_src,\n+\tgeneral_operand_dst, h8300_dst_operand, h8300_src_operand,\n+\tnibble_operand, reg_or_nibble_operand, single_one_operand,\n+\tsingle_zero_operand, call_insn_operand,\n+\ttwo_insn_adds_subs_operand, small_call_insn_operand,\n+\tjump_address_operand, bit_operand, bit_memory_operand,\n+\tstack_pointer_operand, const_int_gt_2_operand,\n+\tconst_int_ge_8_operand, const_int_qi_operand,\n+\tconst_int_hi_operand, incdec_operand, eqne_operator,\n+\tgtle_operator, gtuleu_operator, iorxor_operator, bit_operator,\n+\th8sx_binary_memory_operator, h8sx_unary_memory_operator,\n+\th8sx_unary_shift_operator, h8sx_binary_shift_operator,\n+\tnshift_operator): Move to predicates.md.\n+\t* config/h8300/h8300.h (PREDICATE_CODES): Remove.\n+\t* config/h8300/h8300.md: Include predicates.md.\n+\t* config/h8300/predicates.md: New.\n+\n 2005-03-17  Richard Henderson  <rth@redhat.com>\n \n \t* config.gcc (ia64*-*-hpux*): Add extra_options."}, {"sha": "54fe462b93bf1ff88a65fd442e3d6b7ef2750fa0", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=981c7dcef835c914783cd456ee18a29611afe4db", "patch": "@@ -53,29 +53,6 @@ extern int fix_bit_operand (rtx *, enum rtx_code);\n extern int h8300_adjust_insn_length (rtx, int);\n extern void split_adds_subs (enum machine_mode, rtx[]);\n \n-extern int general_operand_src (rtx, enum machine_mode);\n-extern int general_operand_dst (rtx, enum machine_mode);\n-extern int single_one_operand (rtx, enum machine_mode);\n-extern int single_zero_operand (rtx, enum machine_mode);\n-extern int call_insn_operand (rtx, enum machine_mode);\n-extern int two_insn_adds_subs_operand (rtx, enum machine_mode);\n-extern int small_call_insn_operand (rtx, enum machine_mode);\n-extern int jump_address_operand (rtx, enum machine_mode);\n-extern int bit_operand (rtx, enum machine_mode);\n-extern int bit_memory_operand (rtx, enum machine_mode);\n-extern int stack_pointer_operand (rtx, enum machine_mode);\n-extern int const_int_gt_2_operand (rtx, enum machine_mode);\n-extern int const_int_ge_8_operand (rtx, enum machine_mode);\n-extern int const_int_qi_operand (rtx, enum machine_mode);\n-extern int const_int_hi_operand (rtx, enum machine_mode);\n-extern int incdec_operand (rtx, enum machine_mode);\n-extern int bit_operator (rtx, enum machine_mode);\n-extern int nshift_operator (rtx, enum machine_mode);\n-extern int eqne_operator (rtx, enum machine_mode);\n-extern int gtle_operator (rtx, enum machine_mode);\n-extern int gtuleu_operator (rtx, enum machine_mode);\n-extern int iorxor_operator (rtx, enum machine_mode);\n-\n extern int h8300_eightbit_constant_address_p (rtx);\n extern int h8300_tiny_constant_address_p (rtx);\n extern int byte_accesses_mergeable_p (rtx, rtx);\n@@ -87,6 +64,28 @@ extern int h8300_legitimate_address_p (enum machine_mode, rtx, int);\n \n /* Used in builtins.c */\n extern rtx h8300_return_addr_rtx (int, rtx);\n+\n+/* Classifies an h8sx shift operation.\n+\n+   H8SX_SHIFT_NONE\n+\tThe shift cannot be done in a single instruction.\n+\n+   H8SX_SHIFT_UNARY\n+\tThe shift is effectively a unary operation.  The instruction will\n+\tallow any sort of destination operand and have a format similar\n+\tto neg and not.  This is true of certain power-of-2 shifts.\n+\n+   H8SX_SHIFT_BINARY\n+\tThe shift is a binary operation.  The destination must be a\n+\tregister and the source can be a register or a constant.  */\n+enum h8sx_shift_type {\n+  H8SX_SHIFT_NONE,\n+  H8SX_SHIFT_UNARY,\n+  H8SX_SHIFT_BINARY\n+};\n+\n+extern enum h8sx_shift_type h8sx_classify_shift (enum machine_mode, enum rtx_code, rtx);\n+extern int h8300_ldm_stm_parallel (rtvec, int, int);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "d4120ff060a249d6ce76718c1e4f08f05235143f", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 489, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=981c7dcef835c914783cd456ee18a29611afe4db", "patch": "@@ -72,26 +72,6 @@ enum h8300_operand_class\n   NUM_H8OPS\n };\n \n-/* Classifies an h8sx shift operation.\n-\n-   H8SX_SHIFT_NONE\n-\tThe shift cannot be done in a single instruction.\n-\n-   H8SX_SHIFT_UNARY\n-\tThe shift is effectively a unary operation.  The instruction will\n-\tallow any sort of destination operand and have a format similar\n-\tto neg and not.  This is true of certain power-of-2 shifts.\n-\n-   H8SX_SHIFT_BINARY\n-\tThe shift is a binary operation.  The destination must be a\n-\tregister and the source can be a register or a constant.  */\n-enum h8sx_shift_type\n-{\n-  H8SX_SHIFT_NONE,\n-  H8SX_SHIFT_UNARY,\n-  H8SX_SHIFT_BINARY\n-};\n-\n /* For a general two-operand instruction, element [X][Y] gives\n    the length of the opcode fields when the first operand has class\n    (X + 1) and the second has class Y.  */\n@@ -121,7 +101,6 @@ static int h8300_shift_costs (rtx);\n static void          h8300_push_pop               (int, int, int, int);\n static int           h8300_stack_offset_p         (rtx, int);\n static int           h8300_ldm_stm_regno          (rtx, int, int, int);\n-static int           h8300_ldm_stm_parallel       (rtvec, int, int);\n static void          h8300_reorg                  (void);\n static unsigned int  h8300_constant_length        (rtx);\n static unsigned int  h8300_displacement_length    (rtx, int);\n@@ -133,7 +112,6 @@ static unsigned int  h8300_bitfield_length        (rtx, rtx);\n static unsigned int  h8300_binary_length          (rtx, const h8300_length_table *);\n static bool          h8300_short_move_mem_p       (rtx, enum rtx_code);\n static unsigned int  h8300_move_length            (rtx *, const h8300_length_table *);\n-enum h8sx_shift_type h8sx_classify_shift          (enum machine_mode, enum rtx_code, rtx);\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -163,11 +141,6 @@ const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n \n /* Value of MOVE_RATIO.  */\n int h8300_move_ratio;\n-\n-/* Machine-specific symbol_ref flags.  */\n-#define SYMBOL_FLAG_FUNCVEC_FUNCTION\t(SYMBOL_FLAG_MACH_DEP << 0)\n-#define SYMBOL_FLAG_EIGHTBIT_DATA\t(SYMBOL_FLAG_MACH_DEP << 1)\n-#define SYMBOL_FLAG_TINY_DATA\t\t(SYMBOL_FLAG_MACH_DEP << 2)\n \f\n /* See below where shifts are handled for explanation of this enum.  */\n \n@@ -761,7 +734,7 @@ h8300_ldm_stm_regno (rtx x, int load_p, int index, int nregs)\n /* Return true if the elements of VEC starting at FIRST describe an\n    ldm or stm instruction (LOAD_P says which).  */\n \n-static int\n+int\n h8300_ldm_stm_parallel (rtvec vec, int load_p, int first)\n {\n   rtx last;\n@@ -805,31 +778,6 @@ h8300_ldm_stm_parallel (rtvec vec, int load_p, int first)\n \t  && h8300_stack_offset_p (SET_SRC (last), adjust));\n }\n \n-/* Return true if X is an ldm.l pattern.  X is known to be parallel.  */\n-\n-int\n-h8300_ldm_parallel (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return h8300_ldm_stm_parallel (XVEC (x, 0), 1, 0);\n-}\n-\n-/* Likewise stm.l.  */\n-\n-int\n-h8300_stm_parallel (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return h8300_ldm_stm_parallel (XVEC (x, 0), 0, 0);\n-}\n-\n-/* Likewise rts/l and rte/l.  Note that the .md pattern will check\n-   for the return so there's no need to do that here.  */\n-\n-int\n-h8300_return_parallel (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return h8300_ldm_stm_parallel (XVEC (x, 0), 1, 1);\n-}\n-\n /* This is what the stack looks like after the prolog of\n    a function with a frame has been set up:\n \n@@ -1020,169 +968,6 @@ h8300_file_end (void)\n   fputs (\"\\t.end\\n\", asm_out_file);\n }\n \f\n-/* Return true if OP is a valid source operand for an integer move\n-   instruction.  */\n-\n-int\n-general_operand_src (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) == mode\n-      && GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == POST_INC)\n-    return 1;\n-  return general_operand (op, mode);\n-}\n-\n-/* Return true if OP is a valid destination operand for an integer move\n-   instruction.  */\n-\n-int\n-general_operand_dst (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) == mode\n-      && GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == PRE_DEC)\n-    return 1;\n-  return general_operand (op, mode);\n-}\n-\n-/* Return true if OP is a suitable first operand for a general arithmetic\n-   insn such as \"add\".  */\n-\n-int\n-h8300_dst_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_H8300SX)\n-    return nonimmediate_operand (op, mode);\n-  return register_operand (op, mode);\n-}\n-\n-/* Likewise the second operand.  */\n-\n-int\n-h8300_src_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_H8300SX)\n-    return general_operand (op, mode);\n-  return nonmemory_operand (op, mode);\n-}\n-\n-/* Check that an operand is either a register or an unsigned 4-bit\n-   constant.  */\n-\n-int\n-nibble_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && TARGET_H8300SX\n-\t  && INTVAL (op) >= 0 && INTVAL (op) <= 15);\n-}\n-\n-/* Check that an operand is either a register or an unsigned 4-bit\n-   constant.  */\n-\n-int\n-reg_or_nibble_operand (rtx op, enum machine_mode mode)\n-{\n-  return (nibble_operand (op, mode) || register_operand (op, mode));\n-}\n-\n-/* Return true if OP is a constant that contains only one 1 in its\n-   binary representation.  */\n-\n-int\n-single_one_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (operand) == CONST_INT)\n-    {\n-      /* We really need to do this masking because 0x80 in QImode is\n-\t represented as -128 for example.  */\n-      if (exact_log2 (INTVAL (operand) & GET_MODE_MASK (mode)) >= 0)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return true if OP is a constant that contains only one 0 in its\n-   binary representation.  */\n-\n-int\n-single_zero_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (operand) == CONST_INT)\n-    {\n-      /* We really need to do this masking because 0x80 in QImode is\n-\t represented as -128 for example.  */\n-      if (exact_log2 (~INTVAL (operand) & GET_MODE_MASK (mode)) >= 0)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return true if OP is a valid call operand.  */\n-\n-int\n-call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx inside = XEXP (op, 0);\n-      if (register_operand (inside, Pmode))\n-\treturn 1;\n-      if (CONSTANT_ADDRESS_P (inside))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-/* Return 1 if an addition/subtraction of a constant integer can be\n-   transformed into two consecutive adds/subs that are faster than the\n-   straightforward way.  Otherwise, return 0.  */\n-\n-int\n-two_insn_adds_subs_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_H8300SX)\n-    return 0;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      HOST_WIDE_INT value = INTVAL (op);\n-\n-      /* Force VALUE to be positive so that we do not have to consider\n-         the negative case.  */\n-      if (value < 0)\n-\tvalue = -value;\n-      if (TARGET_H8300H || TARGET_H8300S)\n-\t{\n-\t  /* A constant addition/subtraction takes 2 states in QImode,\n-\t     4 states in HImode, and 6 states in SImode.  Thus, the\n-\t     only case we can win is when SImode is used, in which\n-\t     case, two adds/subs are used, taking 4 states.  */\n-\t  if (mode == SImode\n-\t      && (value == 2 + 1\n-\t\t  || value == 4 + 1\n-\t\t  || value == 4 + 2\n-\t\t  || value == 4 + 4))\n-\t    return 1;\n-\t}\n-      else\n-\t{\n-\t  /* We do not profit directly by splitting addition or\n-\t     subtraction of 3 and 4.  However, since these are\n-\t     implemented as a sequence of adds or subs, they do not\n-\t     clobber (cc0) unlike a sequence of add.b and add.x.  */\n-\t  if (mode == HImode\n-\t      && (value == 2 + 1\n-\t\t  || value == 2 + 2))\n-\t    return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n /* Split an add of a small constant into two adds/subs insns.\n \n    If USE_INCDEC_P is nonzero, we generate the last insn using inc/dec\n@@ -1231,85 +1016,6 @@ split_adds_subs (enum machine_mode mode, rtx *operands)\n   return;\n }\n \n-/* Return true if OP is a valid call operand, and OP represents\n-   an operand for a small call (4 bytes instead of 6 bytes).  */\n-\n-int\n-small_call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx inside = XEXP (op, 0);\n-\n-      /* Register indirect is a small call.  */\n-      if (register_operand (inside, Pmode))\n-\treturn 1;\n-\n-      /* A call through the function vector is a small call too.  */\n-      if (GET_CODE (inside) == SYMBOL_REF\n-\t  && (SYMBOL_REF_FLAGS (inside) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n-\treturn 1;\n-    }\n-  /* Otherwise it's a large call.  */\n-  return 0;\n-}\n-\n-/* Return true if OP is a valid jump operand.  */\n-\n-int\n-jump_address_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == REG)\n-    return mode == Pmode;\n-\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx inside = XEXP (op, 0);\n-      if (register_operand (inside, Pmode))\n-\treturn 1;\n-      if (CONSTANT_ADDRESS_P (inside))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-/* Recognize valid operands for bit-field instructions.  */\n-\n-int\n-bit_operand (rtx op, enum machine_mode mode)\n-{\n-  /* We can accept any nonimmediate operand, except that MEM operands must\n-     be limited to those that use addresses valid for the 'U' constraint.  */\n-  if (!nonimmediate_operand (op, mode))\n-    return 0;\n-\n-  /* H8SX accepts pretty much anything here.  */\n-  if (TARGET_H8300SX)\n-    return 1;\n-\n-  /* Accept any mem during RTL generation.  Otherwise, the code that does\n-     insv and extzv will think that we cannot handle memory.  However,\n-     to avoid reload problems, we only accept 'U' MEM operands after RTL\n-     generation.  This means that any named pattern which uses this predicate\n-     must force its operands to match 'U' before emitting RTL.  */\n-\n-  if (GET_CODE (op) == REG)\n-    return 1;\n-  if (GET_CODE (op) == SUBREG)\n-    return 1;\n-  return (GET_CODE (op) == MEM\n-\t  && OK_FOR_U (op));\n-}\n-\n-/* Return nonzero if OP is a MEM suitable for bit manipulation insns.  */\n-\n-int\n-bit_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == MEM\n-\t  && OK_FOR_U (op));\n-}\n-\n /* Handle machine specific pragmas for compatibility with existing\n    compilers for the H8/300.\n \n@@ -2258,114 +1964,6 @@ notice_update_cc (rtx body, rtx insn)\n       break;\n     }\n }\n-\n-/* Return nonzero if X is a stack pointer.  */\n-\n-int\n-stack_pointer_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return x == stack_pointer_rtx;\n-}\n-\n-/* Return nonzero if X is a constant whose absolute value is greater\n-   than 2.  */\n-\n-int\n-const_int_gt_2_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (x) == CONST_INT\n-\t  && abs (INTVAL (x)) > 2);\n-}\n-\n-/* Return nonzero if X is a constant whose absolute value is no\n-   smaller than 8.  */\n-\n-int\n-const_int_ge_8_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (x) == CONST_INT\n-\t  && abs (INTVAL (x)) >= 8);\n-}\n-\n-/* Return nonzero if X is a constant expressible in QImode.  */\n-\n-int\n-const_int_qi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (x) == CONST_INT\n-\t  && (INTVAL (x) & 0xff) == INTVAL (x));\n-}\n-\n-/* Return nonzero if X is a constant expressible in HImode.  */\n-\n-int\n-const_int_hi_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (x) == CONST_INT\n-\t  && (INTVAL (x) & 0xffff) == INTVAL (x));\n-}\n-\n-/* Return nonzero if X is a constant suitable for inc/dec.  */\n-\n-int\n-incdec_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (x) == CONST_INT\n-\t  && (CONST_OK_FOR_M (INTVAL (x))\n-\t      || CONST_OK_FOR_O (INTVAL (x))));\n-}\n-\n-/* Return nonzero if X is either EQ or NE.  */\n-\n-int\n-eqne_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  return (code == EQ || code == NE);\n-}\n-\n-/* Return nonzero if X is either GT or LE.  */\n-\n-int\n-gtle_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  return (code == GT || code == LE);\n-}\n-\n-/* Return nonzero if X is either GTU or LEU.  */\n-\n-int\n-gtuleu_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  return (code == GTU || code == LEU);\n-}\n-\n-/* Return nonzero if X is either IOR or XOR.  */\n-\n-int\n-iorxor_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  return (code == IOR || code == XOR);\n-}\n-\n-/* Recognize valid operators for bit instructions.  */\n-\n-int\n-bit_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  return (code == XOR\n-\t  || code == AND\n-\t  || code == IOR);\n-}\n \f\n /* Given that X occurs in an address of the form (plus X constant),\n    return the part of X that is expected to be a register.  There are\n@@ -2896,58 +2494,6 @@ h8300_operands_match_p (rtx *operands)\n \n   return false;\n }\n-\n-/* Return true if OP is a binary operator in which it would be safe to\n-   replace register operands with memory operands.  */\n-\n-int\n-h8sx_binary_memory_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (!TARGET_H8300SX)\n-    return false;\n-\n-  if (GET_MODE (op) != QImode\n-      && GET_MODE (op) != HImode\n-      && GET_MODE (op) != SImode)\n-    return false;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case PLUS:\n-    case MINUS:\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      return true;\n-\n-    default:\n-      return h8sx_unary_shift_operator (op, mode);\n-    }\n-}\n-\n-/* Like h8sx_binary_memory_operator, but applies to unary operators.  */\n-\n-int\n-h8sx_unary_memory_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (!TARGET_H8300SX)\n-    return false;\n-\n-  if (GET_MODE (op) != QImode\n-      && GET_MODE (op) != HImode\n-      && GET_MODE (op) != SImode)\n-    return false;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case NEG:\n-    case NOT:\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n \f\n /* Try using movmd to move LENGTH bytes from memory region SRC to memory\n    region DEST.  The two regions do not overlap and have the common\n@@ -4049,26 +3595,6 @@ h8sx_classify_shift (enum machine_mode mode, enum rtx_code code, rtx op)\n     }\n }\n \n-/* Return true if X is a shift operation of type H8SX_SHIFT_UNARY.  */\n-\n-int\n-h8sx_unary_shift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (BINARY_P (x) && NON_COMMUTATIVE_P (x)\n-\t  && (h8sx_classify_shift (GET_MODE (x), GET_CODE (x), XEXP (x, 1))\n-\t      == H8SX_SHIFT_UNARY));\n-}\n-\n-/* Likewise H8SX_SHIFT_BINARY.  */\n-\n-int\n-h8sx_binary_shift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (BINARY_P (x) && NON_COMMUTATIVE_P (x)\n-\t  && (h8sx_classify_shift (GET_MODE (x), GET_CODE (x), XEXP (x, 1))\n-\t      == H8SX_SHIFT_BINARY));\n-}\n-\n /* Return the asm template for a single h8sx shift instruction.\n    OPERANDS[0] and OPERANDS[1] are the destination, OPERANDS[2]\n    is the source and OPERANDS[3] is the shift.  SUFFIX is the\n@@ -4115,20 +3641,6 @@ output_h8sx_shift (rtx *operands, int suffix, int optype)\n     sprintf (buffer, \"%s.%c\\t%%X2,%%%c0\", stem, suffix, optype);\n   return buffer;\n }\n-int\n-nshift_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (x))\n-    {\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-    case ASHIFT:\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n \n /* Emit code to do shifts.  */\n "}, {"sha": "5b131bd7641edc4bb2b5afd69be64bdd4a17ef6e", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=981c7dcef835c914783cd456ee18a29611afe4db", "patch": "@@ -1200,44 +1200,9 @@ extern int h8300_move_ratio;\n #undef  MOVE_RATIO\n #define MOVE_RATIO h8300_move_ratio\n \n-/* Define the codes that are matched by predicates in h8300.c.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"general_operand_src\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t   LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n-  {\"general_operand_dst\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"h8300_src_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n-  {\"h8300_dst_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"nibble_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"reg_or_nibble_operand\", {CONST_INT, SUBREG, REG}},\t\t\t\\\n-  {\"h8sx_unary_shift_operator\", {ASHIFTRT, LSHIFTRT, ASHIFT, ROTATE}},\t\\\n-  {\"h8sx_binary_shift_operator\", {ASHIFTRT, LSHIFTRT, ASHIFT}},\t\t\\\n-  {\"h8sx_binary_memory_operator\", {PLUS, MINUS, AND, IOR, XOR, ASHIFT,\t\\\n-\t\t\t\t   ASHIFTRT, LSHIFTRT, ROTATE}},\t\\\n-  {\"h8sx_unary_memory_operator\", {NEG, NOT}},\t\t\t\t\\\n-  {\"h8300_ldm_parallel\", {PARALLEL}},\t\t\t\t\t\\\n-  {\"h8300_stm_parallel\", {PARALLEL}},\t\t\t\t\t\\\n-  {\"h8300_return_parallel\", {PARALLEL}},\t\t\t\t\\\n-  {\"single_one_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"single_zero_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"call_insn_operand\", {MEM}},\t\t\t\t\t\t\\\n-  {\"small_call_insn_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"jump_address_operand\", {REG, MEM}},\t\t\t\t\t\\\n-  {\"two_insn_adds_subs_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"bit_operand\", {REG, SUBREG, MEM}},\t\t\t\t\t\\\n-  {\"bit_memory_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"stack_pointer_operand\", {REG}},\t\t\t\t\t\\\n-  {\"const_int_gt_2_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"const_int_ge_8_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"const_int_qi_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"const_int_hi_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"incdec_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"bit_operator\", {XOR, AND, IOR}},\t\t\t\t\t\\\n-  {\"nshift_operator\", {ASHIFTRT, LSHIFTRT, ASHIFT}},\t\t\t\\\n-  {\"eqne_operator\", {EQ, NE}},\t\t\t\t\t\t\\\n-  {\"gtle_operator\", {GT, LE, GTU, LEU}},\t\t\t\t\\\n-  {\"gtuleu_operator\", {GTU, LEU}},\t\t\t\t\t\\\n-  {\"iorxor_operator\", {IOR, XOR}},\n+/* Machine-specific symbol_ref flags.  */\n+#define SYMBOL_FLAG_FUNCVEC_FUNCTION\t(SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_FLAG_EIGHTBIT_DATA\t(SYMBOL_FLAG_MACH_DEP << 1)\n+#define SYMBOL_FLAG_TINY_DATA\t\t(SYMBOL_FLAG_MACH_DEP << 2)\n \n #endif /* ! GCC_H8300_H */"}, {"sha": "cfd6c1b8d1cb3241323c7221f7434adf54f24c46", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=981c7dcef835c914783cd456ee18a29611afe4db", "patch": "@@ -175,6 +175,8 @@\n \t       (ne (symbol_ref \"TARGET_H8300H\") (const_int 0)) (const_int 10)\n \t       (ne (symbol_ref \"TARGET_H8300S\") (const_int 0)) (const_int 10)]\n \t      (const_int 14)))])\n+\n+(include \"predicates.md\")\n \f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS"}, {"sha": "a913e8bf247cabdd99995f787b47704bf2a59288", "filename": "gcc/config/h8300/predicates.md", "status": "added", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981c7dcef835c914783cd456ee18a29611afe4db/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fpredicates.md?ref=981c7dcef835c914783cd456ee18a29611afe4db", "patch": "@@ -0,0 +1,483 @@\n+;; Predicate definitions for Renesas H8/300.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return true if OP is a valid source operand for an integer move\n+;; instruction.\n+\n+(define_predicate \"general_operand_src\"\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,mem\")\n+{\n+  if (GET_MODE (op) == mode\n+      && GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == POST_INC)\n+    return 1;\n+  return general_operand (op, mode);\n+})\n+\n+;; Return true if OP is a valid destination operand for an integer\n+;; move instruction.\n+\n+(define_predicate \"general_operand_dst\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (GET_MODE (op) == mode\n+      && GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == PRE_DEC)\n+    return 1;\n+  return general_operand (op, mode);\n+})\n+\n+;; Likewise the second operand.\n+\n+(define_predicate \"h8300_src_operand\"\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,mem\")\n+{\n+  if (TARGET_H8300SX)\n+    return general_operand (op, mode);\n+  return nonmemory_operand (op, mode);\n+})\n+\n+;; Return true if OP is a suitable first operand for a general\n+;; arithmetic insn such as \"add\".\n+\n+(define_predicate \"h8300_dst_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (TARGET_H8300SX)\n+    return nonimmediate_operand (op, mode);\n+  return register_operand (op, mode);\n+})\n+\n+;; Check that an operand is either a register or an unsigned 4-bit\n+;; constant.\n+\n+(define_predicate \"nibble_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && TARGET_H8300SX\n+\t  && INTVAL (op) >= 0 && INTVAL (op) <= 15);\n+})\n+\n+;; Check that an operand is either a register or an unsigned 4-bit\n+;; constant.\n+\n+(define_predicate \"reg_or_nibble_operand\"\n+  (match_code \"const_int,subreg,reg\")\n+{\n+  return (nibble_operand (op, mode) || register_operand (op, mode));\n+})\n+\n+;; Return true if X is a shift operation of type H8SX_SHIFT_UNARY.\n+\n+(define_predicate \"h8sx_unary_shift_operator\"\n+  (match_code \"ashiftrt,lshiftrt,ashift,rotate\")\n+{\n+  return (BINARY_P (op) && NON_COMMUTATIVE_P (op)\n+\t  && (h8sx_classify_shift (GET_MODE (op), GET_CODE (op), XEXP (op, 1))\n+\t      == H8SX_SHIFT_UNARY));\n+})\n+\n+;; Likewise H8SX_SHIFT_BINARY.\n+\n+(define_predicate \"h8sx_binary_shift_operator\"\n+  (match_code \"ashiftrt,lshiftrt,ashift\")\n+{\n+  return (BINARY_P (op) && NON_COMMUTATIVE_P (op)\n+\t  && (h8sx_classify_shift (GET_MODE (op), GET_CODE (op), XEXP (op, 1))\n+\t      == H8SX_SHIFT_BINARY));\n+})\n+\n+;; Return true if OP is a binary operator in which it would be safe to\n+;; replace register operands with memory operands.\n+\n+(define_predicate \"h8sx_binary_memory_operator\"\n+  (match_code \"plus,minus,and,ior,xor,ashift,ashiftrt,lshiftrt,rotate\")\n+{\n+  if (!TARGET_H8300SX)\n+    return false;\n+\n+  if (GET_MODE (op) != QImode\n+      && GET_MODE (op) != HImode\n+      && GET_MODE (op) != SImode)\n+    return false;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      return true;\n+\n+    default:\n+      return h8sx_unary_shift_operator (op, mode);\n+    }\n+})\n+\n+;; Like h8sx_binary_memory_operator, but applies to unary operators.\n+\n+(define_predicate \"h8sx_unary_memory_operator\"\n+  (match_code \"neg,not\")\n+{\n+  if (!TARGET_H8300SX)\n+    return false;\n+\n+  if (GET_MODE (op) != QImode\n+      && GET_MODE (op) != HImode\n+      && GET_MODE (op) != SImode)\n+    return false;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case NEG:\n+    case NOT:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+})\n+\n+;; Return true if X is an ldm.l pattern.  X is known to be parallel.\n+\n+(define_predicate \"h8300_ldm_parallel\"\n+  (match_code \"parallel\")\n+{\n+  return h8300_ldm_stm_parallel (XVEC (op, 0), 1, 0);\n+})\n+\n+;; Likewise stm.l.\n+\n+(define_predicate \"h8300_stm_parallel\"\n+  (match_code \"parallel\")\n+{\n+  return h8300_ldm_stm_parallel (XVEC (op, 0), 0, 0);\n+})\n+\n+;; Likewise rts/l and rte/l.  Note that the .md pattern will check for\n+;; the return so there's no need to do that here.\n+\n+(define_predicate \"h8300_return_parallel\"\n+  (match_code \"parallel\")\n+{\n+  return h8300_ldm_stm_parallel (XVEC (op, 0), 1, 1);\n+})\n+\n+;; Return true if OP is a constant that contains only one 1 in its\n+;; binary representation.\n+\n+(define_predicate \"single_one_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      /* We really need to do this masking because 0x80 in QImode is\n+\t represented as -128 for example.  */\n+      if (exact_log2 (INTVAL (op) & GET_MODE_MASK (mode)) >= 0)\n+\treturn 1;\n+    }\n+\n+  return 0;\n+})\n+\n+;; Return true if OP is a constant that contains only one 0 in its\n+;; binary representation.\n+\n+(define_predicate \"single_zero_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      /* We really need to do this masking because 0x80 in QImode is\n+\t represented as -128 for example.  */\n+      if (exact_log2 (~INTVAL (op) & GET_MODE_MASK (mode)) >= 0)\n+\treturn 1;\n+    }\n+\n+  return 0;\n+})\n+\n+;; Return true if OP is a valid call operand.\n+\n+(define_predicate \"call_insn_operand\"\n+  (match_code \"mem\")\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+      if (register_operand (inside, Pmode))\n+\treturn 1;\n+      if (CONSTANT_ADDRESS_P (inside))\n+\treturn 1;\n+    }\n+  return 0;\n+})\n+\n+;; Return true if OP is a valid call operand, and OP represents an\n+;; operand for a small call (4 bytes instead of 6 bytes).\n+\n+(define_predicate \"small_call_insn_operand\"\n+  (match_code \"mem\")\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+\n+      /* Register indirect is a small call.  */\n+      if (register_operand (inside, Pmode))\n+\treturn 1;\n+\n+      /* A call through the function vector is a small call too.  */\n+      if (GET_CODE (inside) == SYMBOL_REF\n+\t  && (SYMBOL_REF_FLAGS (inside) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+\treturn 1;\n+    }\n+  /* Otherwise it's a large call.  */\n+  return 0;\n+})\n+\n+;; Return true if OP is a valid jump operand.\n+\n+(define_predicate \"jump_address_operand\"\n+  (match_code \"reg,mem\")\n+{\n+  if (GET_CODE (op) == REG)\n+    return mode == Pmode;\n+\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+      if (register_operand (inside, Pmode))\n+\treturn 1;\n+      if (CONSTANT_ADDRESS_P (inside))\n+\treturn 1;\n+    }\n+  return 0;\n+})\n+\n+;; Return 1 if an addition/subtraction of a constant integer can be\n+;; transformed into two consecutive adds/subs that are faster than the\n+;; straightforward way.  Otherwise, return 0.\n+\n+(define_predicate \"two_insn_adds_subs_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (TARGET_H8300SX)\n+    return 0;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      HOST_WIDE_INT value = INTVAL (op);\n+\n+      /* Force VALUE to be positive so that we do not have to consider\n+         the negative case.  */\n+      if (value < 0)\n+\tvalue = -value;\n+      if (TARGET_H8300H || TARGET_H8300S)\n+\t{\n+\t  /* A constant addition/subtraction takes 2 states in QImode,\n+\t     4 states in HImode, and 6 states in SImode.  Thus, the\n+\t     only case we can win is when SImode is used, in which\n+\t     case, two adds/subs are used, taking 4 states.  */\n+\t  if (mode == SImode\n+\t      && (value == 2 + 1\n+\t\t  || value == 4 + 1\n+\t\t  || value == 4 + 2\n+\t\t  || value == 4 + 4))\n+\t    return 1;\n+\t}\n+      else\n+\t{\n+\t  /* We do not profit directly by splitting addition or\n+\t     subtraction of 3 and 4.  However, since these are\n+\t     implemented as a sequence of adds or subs, they do not\n+\t     clobber (cc0) unlike a sequence of add.b and add.x.  */\n+\t  if (mode == HImode\n+\t      && (value == 2 + 1\n+\t\t  || value == 2 + 2))\n+\t    return 1;\n+\t}\n+    }\n+\n+  return 0;\n+})\n+\n+;; Recognize valid operands for bit-field instructions.\n+\n+(define_predicate \"bit_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  /* We can accept any nonimmediate operand, except that MEM operands must\n+     be limited to those that use addresses valid for the 'U' constraint.  */\n+  if (!nonimmediate_operand (op, mode))\n+    return 0;\n+\n+  /* H8SX accepts pretty much anything here.  */\n+  if (TARGET_H8300SX)\n+    return 1;\n+\n+  /* Accept any mem during RTL generation.  Otherwise, the code that does\n+     insv and extzv will think that we cannot handle memory.  However,\n+     to avoid reload problems, we only accept 'U' MEM operands after RTL\n+     generation.  This means that any named pattern which uses this predicate\n+     must force its operands to match 'U' before emitting RTL.  */\n+\n+  if (GET_CODE (op) == REG)\n+    return 1;\n+  if (GET_CODE (op) == SUBREG)\n+    return 1;\n+  return (GET_CODE (op) == MEM\n+\t  && OK_FOR_U (op));\n+})\n+\n+;; Return nonzero if OP is a MEM suitable for bit manipulation insns.\n+\n+(define_predicate \"bit_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  return (GET_CODE (op) == MEM\n+\t  && OK_FOR_U (op));\n+})\n+\n+;; Return nonzero if X is a stack pointer.\n+\n+(define_predicate \"stack_pointer_operand\"\n+  (match_code \"reg\")\n+{\n+  return op == stack_pointer_rtx;\n+})\n+\n+;; Return nonzero if X is a constant whose absolute value is greater\n+;; than 2.\n+\n+(define_predicate \"const_int_gt_2_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && abs (INTVAL (op)) > 2);\n+})\n+\n+;; Return nonzero if X is a constant whose absolute value is no\n+;; smaller than 8.\n+\n+(define_predicate \"const_int_ge_8_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && abs (INTVAL (op)) >= 8);\n+})\n+\n+;; Return nonzero if X is a constant expressible in QImode.\n+\n+(define_predicate \"const_int_qi_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) & 0xff) == INTVAL (op));\n+})\n+\n+;; Return nonzero if X is a constant expressible in HImode.\n+\n+(define_predicate \"const_int_hi_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) & 0xffff) == INTVAL (op));\n+})\n+\n+;; Return nonzero if X is a constant suitable for inc/dec.\n+\n+(define_predicate \"incdec_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (CONST_OK_FOR_M (INTVAL (op))\n+\t      || CONST_OK_FOR_O (INTVAL (op))));\n+})\n+\n+;; Recognize valid operators for bit instructions.\n+\n+(define_predicate \"bit_operator\"\n+  (match_code \"xor,and,ior\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == XOR\n+\t  || code == AND\n+\t  || code == IOR);\n+})\n+\n+;; Return nonzero if OP is a shift operator.\n+\n+(define_predicate \"nshift_operator\"\n+  (match_code \"ashiftrt,lshiftrt,ashift\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ASHIFT:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; Return nonzero if X is either EQ or NE.\n+\n+(define_predicate \"eqne_operator\"\n+  (match_code \"eq,ne\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == EQ || code == NE);\n+})\n+\n+;; Return nonzero if X is either GT or LE.\n+\n+(define_predicate \"gtle_operator\"\n+  (match_code \"gt,le,gtu,leu\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == GT || code == LE);\n+})\n+\n+;; Return nonzero if X is either GTU or LEU.\n+\n+(define_predicate \"gtuleu_operator\"\n+  (match_code \"gtu,leu\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == GTU || code == LEU);\n+})\n+\n+;; Return nonzero if X is either IOR or XOR.\n+\n+(define_predicate \"iorxor_operator\"\n+  (match_code \"ior,xor\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == IOR || code == XOR);\n+})"}]}