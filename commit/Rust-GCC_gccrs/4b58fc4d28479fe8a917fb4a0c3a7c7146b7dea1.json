{"sha": "4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI1OGZjNGQyODQ3OWZlOGE5MTdmYjRhMGMzYTdjNzE0NmI3ZGVhMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-03T17:30:12Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-03T17:30:12Z"}, "message": "fold-const.c (fold_unary): Avoid directly using the original expression t as much as possible.\n\n\t* fold-const.c (fold_unary): Avoid directly using the original\n\texpression t as much as possible.\n\nFrom-SVN: r95837", "tree": {"sha": "a8611d2cd0e2908044f5b8d76c24456ab8db0387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8611d2cd0e2908044f5b8d76c24456ab8db0387"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1/comments", "author": null, "committer": null, "parents": [{"sha": "af85b8e458035822a927da15087e975a692dc023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af85b8e458035822a927da15087e975a692dc023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af85b8e458035822a927da15087e975a692dc023"}], "stats": {"total": 59, "additions": 28, "deletions": 31}, "files": [{"sha": "ba2e68a1fe6600143ab5f3e597a7c3b38149256c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1", "patch": "@@ -11,6 +11,9 @@\n \n \t* fold-const.c (fold): Remove handling of unary expressions.\n \n+\t* fold-const.c (fold_unary): Avoid directly using the original\n+\texpression t as much as possible.\n+\n 2005-03-03  Roger Sayle  <roger@eyesopen.com>\n \t    Andrew Pinski  <pinskia@physics.uc.edu>\n "}, {"sha": "72e557eeb7179758ed6a619fed91118b3d3f5932", "filename": "gcc/fold-const.c", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4b58fc4d28479fe8a917fb4a0c3a7c7146b7dea1", "patch": "@@ -6606,15 +6606,15 @@ fold_unary (tree expr)\n   const tree t = expr;\n   const tree type = TREE_TYPE (expr);\n   tree tem;\n-  tree arg0;\n+  tree op0, arg0;\n   enum tree_code code = TREE_CODE (t);\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n \n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 1);\n \n \n-  arg0 = TREE_OPERAND (t, 0);\n+  arg0 = op0 = TREE_OPERAND (t, 0);\n   if (arg0)\n     {\n       if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n@@ -6713,15 +6713,15 @@ fold_unary (tree expr)\n     case FIX_CEIL_EXPR:\n     case FIX_FLOOR_EXPR:\n     case FIX_ROUND_EXPR:\n-      if (TREE_TYPE (TREE_OPERAND (t, 0)) == type)\n-\treturn TREE_OPERAND (t, 0);\n+      if (TREE_TYPE (op0) == type)\n+\treturn op0;\n \n       /* Handle cases of two conversions in a row.  */\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR)\n+      if (TREE_CODE (op0) == NOP_EXPR\n+\t  || TREE_CODE (op0) == CONVERT_EXPR)\n \t{\n-\t  tree inside_type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n-\t  tree inter_type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t  tree inside_type = TREE_TYPE (TREE_OPERAND (op0, 0));\n+\t  tree inter_type = TREE_TYPE (op0);\n \t  int inside_int = INTEGRAL_TYPE_P (inside_type);\n \t  int inside_ptr = POINTER_TYPE_P (inside_type);\n \t  int inside_float = FLOAT_TYPE_P (inside_type);\n@@ -6745,8 +6745,7 @@ fold_unary (tree expr)\n \t  if (TYPE_MAIN_VARIANT (inside_type) == TYPE_MAIN_VARIANT (type)\n \t      && ((inter_int && final_int) || (inter_float && final_float))\n \t      && inter_prec >= final_prec)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n \n \t  /* Likewise, if the intermediate and final types are either both\n \t     float or both integer, we don't need the middle conversion if\n@@ -6761,16 +6760,14 @@ fold_unary (tree expr)\n \t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n \t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n \t      && ! final_ptr)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n \n \t  /* If we have a sign-extension of a zero-extended value, we can\n \t     replace that by a single zero-extension.  */\n \t  if (inside_int && inter_int && final_int\n \t      && inside_prec < inter_prec && inter_prec < final_prec\n \t      && inside_unsignedp && !inter_unsignedp)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n \n \t  /* Two conversions in a row are not needed unless:\n \t     - some conversion is floating-point (overstrict for now), or\n@@ -6794,23 +6791,21 @@ fold_unary (tree expr)\n \t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n \t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n \t      && ! final_ptr)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+\t    return fold (build1 (code, type, TREE_OPERAND (op0, 0)));\n \t}\n \n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR\n-\t  && TREE_CONSTANT (TREE_OPERAND (TREE_OPERAND (t, 0), 1))\n+      if (TREE_CODE (op0) == MODIFY_EXPR\n+\t  && TREE_CONSTANT (TREE_OPERAND (op0, 1))\n \t  /* Detect assigning a bitfield.  */\n-\t  && !(TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)) == COMPONENT_REF\n-\t       && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 1))))\n+\t  && !(TREE_CODE (TREE_OPERAND (op0, 0)) == COMPONENT_REF\n+\t       && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (op0, 0), 1))))\n \t{\n \t  /* Don't leave an assignment inside a conversion\n \t     unless assigning a bitfield.  */\n-\t  tree prev = TREE_OPERAND (t, 0);\n \t  tem = copy_node (t);\n-\t  TREE_OPERAND (tem, 0) = TREE_OPERAND (prev, 1);\n+\t  TREE_OPERAND (tem, 0) = TREE_OPERAND (op0, 1);\n \t  /* First do the assignment, then return converted constant.  */\n-\t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), prev, fold (tem));\n+\t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), op0, fold (tem));\n \t  TREE_NO_WARNING (tem) = 1;\n \t  TREE_USED (tem) = 1;\n \t  return tem;\n@@ -6821,10 +6816,10 @@ fold_unary (tree expr)\n \t in c).  This folds extension into the BIT_AND_EXPR.  */\n       if (INTEGRAL_TYPE_P (type)\n \t  && TREE_CODE (type) != BOOLEAN_TYPE\n-\t  && TREE_CODE (TREE_OPERAND (t, 0)) == BIT_AND_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 1)) == INTEGER_CST)\n+\t  && TREE_CODE (op0) == BIT_AND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST)\n \t{\n-\t  tree and = TREE_OPERAND (t, 0);\n+\t  tree and = op0;\n \t  tree and0 = TREE_OPERAND (and, 0), and1 = TREE_OPERAND (and, 1);\n \t  int change = 0;\n \n@@ -6867,13 +6862,13 @@ fold_unary (tree expr)\n \n       /* Convert (T1)((T2)X op Y) into (T1)X op Y, for pointer types T1 and\n \t T2 being pointers to types of the same size.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (t))\n+      if (POINTER_TYPE_P (type)\n \t  && BINARY_CLASS_P (arg0)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == NOP_EXPR\n \t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t{\n \t  tree arg00 = TREE_OPERAND (arg0, 0);\n-\t  tree t0 = TREE_TYPE (t);\n+\t  tree t0 = type;\n \t  tree t1 = TREE_TYPE (arg00);\n \t  tree tt0 = TREE_TYPE (t0);\n \t  tree tt1 = TREE_TYPE (t1);\n@@ -6889,9 +6884,8 @@ fold_unary (tree expr)\n       return tem ? tem : t;\n \n     case VIEW_CONVERT_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == VIEW_CONVERT_EXPR)\n-\treturn build1 (VIEW_CONVERT_EXPR, type,\n-\t\t       TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+      if (TREE_CODE (op0) == VIEW_CONVERT_EXPR)\n+\treturn build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));\n       return t;\n \n     case NEGATE_EXPR:"}]}