{"sha": "43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNkODYxYTViYzAzYzFjOWVkMWRkZTRjYTdiZjE1OTM3NzFkN2U2ZQ==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2007-05-28T11:10:27Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2007-05-28T11:10:27Z"}, "message": "matrix-reorg.c: New file.\n\n2007-05-07  Razya Ladelsky  <razya@il.ibm.com>  \n        \n        * matrix-reorg.c: New file. Implement matrix flattening and transposing\n\t    optimization.\n        * tree-pass.h: Add matrix reorg pass.\n        * common.opt: Add fipa-mreorg flag.\n        * Makefile.in: Add matrix-reorg.c.\n        * passes.c: Add matrix reorg pass.\n\t  * varpool.c (add_new_static_var): New function.\n\t  * cgraph.h (add_new_static_var): Declare.\n\nFrom-SVN: r125126", "tree": {"sha": "438fd56569603b56035ec8c6adb7973791f877e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438fd56569603b56035ec8c6adb7973791f877e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/comments", "author": null, "committer": null, "parents": [{"sha": "4322c52f38afc74665f55412d31adb2fcb85d80a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4322c52f38afc74665f55412d31adb2fcb85d80a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4322c52f38afc74665f55412d31adb2fcb85d80a"}], "stats": {"total": 2407, "additions": 2406, "deletions": 1}, "files": [{"sha": "ed77d81a5c0e7ef8aba4c80107bd6cd208505cfd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -1,3 +1,15 @@\n+2007-05-07  Razya Ladelsky  <razya@il.ibm.com>  \n+        \n+        * matrix-reorg.c: New file. Implement matrix flattening and transposing\n+\t    optimization.\n+        * tree-pass.h: Add matrix reorg pass.\n+        * common.opt: Add fipa-mreorg flag.\n+        * Makefile.in: Add matrix-reorg.c.\n+        * passes.c: Add matrix reorg pass.\n+\t  * varpool.c (add_new_static_var): New function.\n+\t  * cgraph.h (add_new_static_var): Declare.\n+\n+\n 2007-05-27  Eric Christopher  <echristo@apple.com>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_prologue): Update"}, {"sha": "8064b2f01fa5816712f27d917cc5cb394990e632", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -1178,6 +1178,7 @@ OBJS-archive = \\\n \tipa-type-escape.o \\\n \tipa-utils.o \\\n \tipa.o \\\n+\tmatrix-reorg.o \\\n \ttree-inline.o \\\n \ttree-nomudflap.o \\\n \tvarpool.o\n@@ -2400,6 +2401,9 @@ ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    langhooks.h $(TARGET_H) $(CGRAPH_H) ipa-prop.h tree-inline.h tree-dump.h \\\n    $(TREE_FLOW_H) $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H) $(DIAGNOSTIC_H)\n+matrix-reorg.o : matrix-reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n+   $(TARGET_H) $(CGRAPH_H) $(TREE_FLOW_H) $(TM_H) tree-pass.h  \\\n+   $(FLAGS_H) $(TREE_H) $(DIAGNOSTIC_H)\n ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \\\n@@ -2959,7 +2963,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n-  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c \\\n+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c $(srcdir)/matrix-reorg.c \\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n   $(srcdir)/dojump.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\"}, {"sha": "a9879375276c26fd5df69bcfb5af5b3d60576e32", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -410,4 +410,9 @@ varpool_next_static_initializer (struct varpool_node *node)\n void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool, bool);\n void cgraph_mark_inline_edge (struct cgraph_edge *, bool);\n bool cgraph_default_inline_p (struct cgraph_node *, const char **);\n+\n+\n+/* Create a new static variable of type TYPE.  */\n+tree add_new_static_var (tree type);\n+\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "2358bc49c627b1ad3a45a8b99ba0e84e5131936f", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -584,6 +584,11 @@ fipa-type-escape\n Common Report Var(flag_ipa_type_escape) Init(0) Optimization\n Type based escape and alias analysis\n \n+fipa-matrix-reorg\n+Common Report Var(flag_ipa_matrix_reorg)\n+Perform matrix layout flattening and transposing based\n+on profiling information.\n+\n fivopts\n Common Report Var(flag_ivopts) Init(1) Optimization\n Optimize induction variables on trees"}, {"sha": "98bb895ea268f7f0c85aed010435267d499e7851", "filename": "gcc/matrix-reorg.c", "status": "added", "additions": 2351, "deletions": 0, "changes": 2351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -0,0 +1,2351 @@\n+/* Matrix layout transformations.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Razya Ladelsky <razya@il.ibm.com>\n+   Originally written by Revital Eres and Mustafa Hagog.\n+   \n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/*\n+   Matrix flattening optimization tries to replace a N-dimensional \n+   matrix with its equivalent M-dimensional matrix, where M < N.\n+   This first implementation focuses on global matrices defined dynamically.\n+\n+   When N==1, we actually flatten the whole matrix.\n+   For instance consider a two-dimensional array a [dim1] [dim2].\n+   The code for allocating space for it usually looks like:\n+\n+     a = (int **)  malloc(dim1 * sizeof(int *));\n+     for (i=0; i<dim1; i++)\n+        a[i] = (int *) malloc (dim2 * sizeof(int));\n+\n+   If the array \"a\" is found suitable for this optimization,\n+   its allocation is replaced by:\n+\n+     a = (int *) malloc (dim1 * dim2 *sizeof(int));\n+\n+   and all the references to a[i][j] are replaced by a[i * dim2 + j].\n+\n+   The two main phases of the optimization are the analysis\n+   and transformation.\n+   The driver of the optimization is matrix_reorg ().\n+\n+    \n+      \n+   Analysis phase:\n+   ===============\n+\n+   We'll number the dimensions outside-in, meaning the most external \n+   is 0, then 1, and so on.   \n+   The analysis part of the optimization determines K, the escape \n+   level of a N-dimensional matrix (K <= N), that allows flattening of \n+   the external dimensions 0,1,..., K-1. Escape level 0 means that the\n+   whole matrix escapes and no flattening is possible.\n+     \n+   The analysis part is implemented in analyze_matrix_allocation_site() \n+   and analyze_matrix_accesses().\n+\n+   Transformation phase:\n+   =====================\n+   In this phase we define the new flattened matrices that replace the \n+   original matrices in the code. \n+   Implemented in transform_allocation_sites(), \n+   transform_access_sites().  \n+\n+   Matrix Transposing\n+   ==================\n+   The idea of Matrix Transposing is organizing the matrix in a different \n+   layout such that the dimensions are reordered.\n+   This could produce better cache behavior in some cases.\n+\n+   For example, lets look at the matrix accesses in the following loop:\n+\n+   for (i=0; i<N; i++)\n+    for (j=0; j<M; j++)\n+     access to a[i][j]\n+\n+   This loop can produce good cache behavior because the elements of \n+   the inner dimension are accessed sequentially.\n+\n+  However, if the accesses of the matrix were of the following form:\n+\n+  for (i=0; i<N; i++)\n+   for (j=0; j<M; j++)\n+     access to a[j][i]\n+\n+  In this loop we iterate the columns and not the rows. \n+  Therefore, replacing the rows and columns \n+  would have had an organization with better (cache) locality.\n+  Replacing the dimensions of the matrix is called matrix transposing.\n+\n+  This  example, of course, could be enhanced to multiple dimensions matrices \n+  as well.\n+\n+  Since a program could include all kind of accesses, there is a decision \n+  mechanism, implemented in analyze_transpose(), which implements a  \n+  heuristic that tries to determine whether to transpose the matrix or not,\n+  according to the form of the more dominant accesses.\n+  This decision is transferred to the flattening mechanism, and whether \n+  the matrix was transposed or not, the matrix is flattened (if possible).\n+  \n+  This decision making is based on profiling information and loop information.\n+  If profiling information is available, decision making mechanism will be \n+  operated, otherwise the matrix will only be flattened (if possible).\n+\n+  Both optimizations are described in the paper \"Matrix flattening and \n+  transposing in GCC\" which was presented in GCC summit 2006. \n+  http://www.gccsummit.org/2006/2006-GCC-Summit-Proceedings.pdf\n+\n+ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"c-tree.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-flow-inline.h\"\n+#include \"langhooks.h\"\n+#include \"hashtab.h\"\n+#include \"toplev.h\"\n+#include \"flags.h\"\n+#include \"ggc.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+#include \"timevar.h\"\n+#include \"params.h\"\n+#include \"fibheap.h\"\n+#include \"c-common.h\"\n+#include \"intl.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-pass.h\"\n+#include \"opts.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-scalar-evolution.h\"\n+\n+/*\n+   We need to collect a lot of data from the original malloc,\n+   particularly as the gimplifier has converted:\n+\n+   orig_var = (struct_type *) malloc (x * sizeof (struct_type *));\n+\n+   into\n+\n+   T3 = <constant> ;  ** <constant> is amount to malloc; precomputed **\n+   T4 = malloc (T3);\n+   T5 = (struct_type *) T4;\n+   orig_var = T5;\n+\n+   The following struct fields allow us to collect all the necessary data from\n+   the gimplified program.  The comments in the struct below are all based\n+   on the gimple example above.  */\n+\n+struct malloc_call_data\n+{\n+  tree call_stmt;\t\t/* Tree for \"T4 = malloc (T3);\"                     */\n+  tree size_var;\t\t/* Var decl for T3.                                 */\n+  tree malloc_size;\t\t/* Tree for \"<constant>\", the rhs assigned to T3.   */\n+};\n+\n+/* The front end of the compiler, when parsing statements of the form:\n+\n+   var = (type_cast) malloc (sizeof (type));\n+\n+   always converts this single statement into the following statements\n+   (GIMPLE form):\n+\n+   T.1 = sizeof (type);\n+   T.2 = malloc (T.1);\n+   T.3 = (type_cast) T.2;\n+   var = T.3;\n+\n+   Since we need to create new malloc statements and modify the original\n+   statements somewhat, we need to find all four of the above statements.\n+   Currently record_call_1 (called for building cgraph edges) finds and\n+   records the statements containing the actual call to malloc, but we\n+   need to find the rest of the variables/statements on our own.  That\n+   is what the following function does.  */\n+static void\n+collect_data_for_malloc_call (tree stmt, struct malloc_call_data *m_data)\n+{\n+  tree size_var = NULL;\n+  tree malloc_fn_decl;\n+  tree tmp;\n+  tree arg1;\n+\n+  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n+\n+  tmp = get_call_expr_in (stmt);\n+  malloc_fn_decl = CALL_EXPR_FN (tmp);\n+  if (TREE_CODE (malloc_fn_decl) != ADDR_EXPR\n+      || TREE_CODE (TREE_OPERAND (malloc_fn_decl, 0)) != FUNCTION_DECL\n+      || DECL_FUNCTION_CODE (TREE_OPERAND (malloc_fn_decl, 0)) !=\n+      BUILT_IN_MALLOC)\n+    return;\n+\n+  arg1 = CALL_EXPR_ARG (tmp, 0);\n+  size_var = arg1;\n+\n+  m_data->call_stmt = stmt;\n+  m_data->size_var = size_var;\n+  if (TREE_CODE (size_var) != VAR_DECL)\n+    m_data->malloc_size = size_var;\n+  else\n+    m_data->malloc_size = NULL_TREE;\n+}\n+\n+/* Information about matrix access site.\n+   For example: if an access site of matrix arr is arr[i][j]\n+   the ACCESS_SITE_INFO structure will have the address\n+   of arr as its stmt.  The INDEX_INFO will hold information about the\n+   initial address and index of each dimension.  */\n+struct access_site_info\n+{\n+  /* The statement (INDIRECT_REF or PLUS_EXPR).  */\n+  tree stmt;\n+\n+  /* In case of PLUS_EXPR, what is the offset.  */\n+  tree offset;\n+\n+  /* The index which created the offset.  */\n+  tree index;\n+\n+  /* The indirection level of this statement.  */\n+  int level;\n+\n+  /* TRUE for allocation site FALSE for access site.  */\n+  bool is_alloc;\n+\n+  /* The function containing the access site.  */\n+  tree function_decl;\n+\n+  /* This access is iterated in the inner most loop */\n+  bool iterated_by_inner_most_loop_p;\n+};\n+\n+typedef struct access_site_info *access_site_info_p;\n+DEF_VEC_P (access_site_info_p);\n+DEF_VEC_ALLOC_P (access_site_info_p, heap);\n+\n+/* Information about matrix to flatten.  */\n+struct matrix_info\n+{\n+  /* Decl tree of this matrix.  */\n+  tree decl;\n+  /* Number of dimensions; number\n+     of \"*\" in the type declaration.  */\n+  int num_dims;\n+\n+  /* Minimum indirection level that escapes, 0 means that\n+     the whole matrix escapes, k means that dimensions\n+     0 to ACTUAL_DIM - k escapes.  */\n+  int min_indirect_level_escape;\n+\n+  tree min_indirect_level_escape_stmt;\n+\n+  /* Is the matrix transposed.  */\n+  bool is_transposed_p;\n+\n+  /* Hold the allocation site for each level (dimension).\n+     We can use NUM_DIMS as the upper bound and allocate the array\n+     once with this number of elements and no need to use realloc and\n+     MAX_MALLOCED_LEVEL.  */\n+  tree *malloc_for_level;\n+\n+  int max_malloced_level;\n+\n+  /* The location of the allocation sites (they must be in one\n+     function).  */\n+  tree allocation_function_decl;\n+\n+  /* The calls to free for each level of indirection.  */\n+  struct free_info\n+  {\n+    tree stmt;\n+    tree func;\n+  } *free_stmts;\n+\n+  /* An array which holds for each dimension its size. where\n+     dimension 0 is the outer most (one that contains all the others).\n+   */\n+  tree *dimension_size;\n+\n+  /* An array which holds for each dimension it's original size \n+     (before transposing and flattening take place).  */\n+  tree *dimension_size_orig;\n+\n+  /* An array which holds for each dimension the size of the type of\n+     of elements accessed in that level (in bytes).  */\n+  HOST_WIDE_INT *dimension_type_size;\n+\n+  int dimension_type_size_len;\n+\n+  /* An array collecting the count of accesses for each dimension.  */\n+  gcov_type *dim_hot_level;\n+\n+  /* An array of the accesses to be flattened.\n+     elements are of type \"struct access_site_info *\".  */\n+    VEC (access_site_info_p, heap) * access_l;\n+\n+  /* A map of how the dimensions will be organized at the end of \n+     the analyses.  */\n+  int *dim_map;\n+};\n+\n+/* In each phi node we want to record the indirection level we have when we\n+   get to the phi node.  Usually we will have phi nodes with more than two\n+   arguments, then we must assure that all of them get to the phi node with\n+   the same indirection level, otherwise it's not safe to do the flattening.\n+   So we record the information regarding the indirection level each time we\n+   get to the phi node in this hash table.  */\n+\n+struct matrix_access_phi_node\n+{\n+  tree phi;\n+  int indirection_level;\n+};\n+\n+/* We use this structure to find if the SSA variable is accessed inside the\n+   tree and record the tree containing it.  */\n+\n+struct ssa_acc_in_tree\n+{\n+  /* The variable whose accesses in the tree we are looking for.  */\n+  tree ssa_var;\n+  /* The tree and code inside it the ssa_var is accessed, currently\n+     it could be an INDIRECT_REF or CALL_EXPR.  */\n+  enum tree_code t_code;\n+  tree t_tree;\n+  /* The place in the containing tree.  */\n+  tree *tp;\n+  tree second_op;\n+  bool var_found;\n+};\n+\n+static void analyze_matrix_accesses (struct matrix_info *, tree, int, bool,\n+\t\t\t\t     sbitmap, bool);\n+static int transform_allocation_sites (void **, void *);\n+static int transform_access_sites (void **, void *);\n+static int analyze_transpose (void **, void *);\n+static int dump_matrix_reorg_analysis (void **, void *);\n+\n+static bool check_transpose_p;\n+\n+/* Hash function used for the phi nodes.  */\n+\n+static hashval_t\n+mat_acc_phi_hash (const void *p)\n+{\n+  const struct matrix_access_phi_node *ma_phi = p;\n+\n+  return htab_hash_pointer (ma_phi->phi);\n+}\n+\n+/* Equality means phi node pointers are the same.  */\n+\n+static int\n+mat_acc_phi_eq (const void *p1, const void *p2)\n+{\n+  const struct matrix_access_phi_node *phi1 = p1;\n+  const struct matrix_access_phi_node *phi2 = p2;\n+\n+  if (phi1->phi == phi2->phi)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Hold the PHI nodes we visit during the traversal for escaping\n+   analysis.  */\n+static htab_t htab_mat_acc_phi_nodes = NULL;\n+\n+/* This hash-table holds the information about the matrices we are\n+   going to handle.  */\n+static htab_t matrices_to_reorg = NULL;\n+\n+/* Return a hash for MTT, which is really a \"matrix_info *\".  */\n+static hashval_t\n+mtt_info_hash (const void *mtt)\n+{\n+  return htab_hash_pointer (((struct matrix_info *) mtt)->decl);\n+}\n+\n+/* Return true if MTT1 and MTT2 (which are really both of type\n+   \"matrix_info *\") refer to the same decl.  */\n+static int\n+mtt_info_eq (const void *mtt1, const void *mtt2)\n+{\n+  const struct matrix_info *i1 = mtt1;\n+  const struct matrix_info *i2 = mtt2;\n+\n+  if (i1->decl == i2->decl)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return the inner most tree that is not a cast.  */\n+static tree\n+get_inner_of_cast_expr (tree t)\n+{\n+  while (TREE_CODE (t) == CONVERT_EXPR || TREE_CODE (t) == NOP_EXPR\n+\t || TREE_CODE (t) == VIEW_CONVERT_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n+  return t;\n+}\n+\n+/* Return false if STMT may contain a vector expression.  \n+   In this situation, all matrices should not be flattened.  */\n+static bool\n+may_flatten_matrices_1 (tree stmt)\n+{\n+  tree t;\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case GIMPLE_MODIFY_STMT:\n+      t = GIMPLE_STMT_OPERAND (stmt, 1);\n+      while (TREE_CODE (t) == CONVERT_EXPR || TREE_CODE (t) == NOP_EXPR)\n+\t{\n+\t  if (TREE_TYPE (t) && POINTER_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      tree pointee;\n+\n+\t      pointee = TREE_TYPE (t);\n+\t      while (POINTER_TYPE_P (pointee))\n+\t\tpointee = TREE_TYPE (pointee);\n+\t      if (TREE_CODE (pointee) == VECTOR_TYPE)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Found vector type, don't flatten matrix\\n\");\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t  t = TREE_OPERAND (t, 0);\n+\t}\n+      break;\n+    case ASM_EXPR:\n+      /* Asm code could contain vector operations.  */\n+      return false;\n+      break;\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n+/* Return false if there are hand-written vectors in the program.  \n+   We disable the flattening in such a case.  */\n+static bool\n+may_flatten_matrices (struct cgraph_node *node)\n+{\n+  tree decl;\n+  struct function *func;\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+\n+  decl = node->decl;\n+  if (node->analyzed)\n+    {\n+      func = DECL_STRUCT_FUNCTION (decl);\n+      FOR_EACH_BB_FN (bb, func)\n+\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tif (!may_flatten_matrices_1 (bsi_stmt (bsi)))\n+\t  return false;\n+    }\n+  return true;\n+}\n+\n+/* Given a VAR_DECL, check its type to determine whether it is\n+   a definition of a dynamic allocated matrix and therefore is\n+   a suitable candidate for the matrix flattening optimization.\n+   Return NULL if VAR_DECL is not such decl.  Otherwise, allocate\n+   a MATRIX_INFO structure, fill it with the relevant information\n+   and return a pointer to it.\n+   TODO: handle also statically defined arrays.  */\n+static struct matrix_info *\n+analyze_matrix_decl (tree var_decl)\n+{\n+  struct matrix_info *m_node, tmpmi, *mi;\n+  tree var_type;\n+  int dim_num = 0;\n+\n+  gcc_assert (matrices_to_reorg);\n+\n+  if (TREE_CODE (var_decl) == PARM_DECL)\n+    var_type = DECL_ARG_TYPE (var_decl);\n+  else if (TREE_CODE (var_decl) == VAR_DECL)\n+    var_type = TREE_TYPE (var_decl);\n+  else\n+    return NULL;\n+\n+  if (!POINTER_TYPE_P (var_type))\n+    return NULL;\n+\n+  while (POINTER_TYPE_P (var_type))\n+    {\n+      var_type = TREE_TYPE (var_type);\n+      dim_num++;\n+    }\n+\n+  if (dim_num <= 1)\n+    return NULL;\n+\n+  if (!COMPLETE_TYPE_P (var_type)\n+      || TREE_CODE (TYPE_SIZE_UNIT (var_type)) != INTEGER_CST)\n+    return NULL;\n+\n+  /* Check to see if this pointer is already in there.  */\n+  tmpmi.decl = var_decl;\n+  mi = htab_find (matrices_to_reorg, &tmpmi);\n+\n+  if (mi)\n+    return NULL;\n+\n+  /* Record the matrix.  */\n+\n+  m_node = (struct matrix_info *) xcalloc (1, sizeof (struct matrix_info));\n+  m_node->decl = var_decl;\n+  m_node->num_dims = dim_num;\n+  m_node->free_stmts\n+    = (struct free_info *) xcalloc (dim_num, sizeof (struct free_info));\n+\n+  /* Init min_indirect_level_escape to -1 to indicate that no escape\n+     analysis has been done yet.  */\n+  m_node->min_indirect_level_escape = -1;\n+  m_node->is_transposed_p = false;\n+\n+  return m_node;\n+}\n+\n+/* Free matrix E.  */\n+static void\n+mat_free (void *e)\n+{\n+  struct matrix_info *mat = (struct matrix_info *) e;\n+\n+  if (!mat)\n+    return;\n+\n+  if (mat->free_stmts)\n+    free (mat->free_stmts);\n+  if (mat->dim_hot_level)\n+    free (mat->dim_hot_level);\n+  if (mat->malloc_for_level)\n+    free (mat->malloc_for_level);\n+}\n+\n+/* Find all potential matrices.\n+   TODO: currently we handle only multidimensional\n+   dynamically allocated arrays.  */\n+static void\n+find_matrices_decl (void)\n+{\n+  struct matrix_info *tmp;\n+  PTR *slot;\n+  struct varpool_node *vnode;\n+\n+  gcc_assert (matrices_to_reorg);\n+\n+  /* For every global variable in the program:\n+     Check to see if it's of a candidate type and record it.  */\n+  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+    {\n+      tree var_decl = vnode->decl;\n+\n+      if (!var_decl || TREE_CODE (var_decl) != VAR_DECL)\n+\tcontinue;\n+\n+      if (matrices_to_reorg)\n+\tif ((tmp = analyze_matrix_decl (var_decl)))\n+\t  {\n+\t    if (!TREE_ADDRESSABLE (var_decl))\n+\t      {\n+\t\tslot = htab_find_slot (matrices_to_reorg, tmp, INSERT);\n+\t\t*slot = tmp;\n+\t      }\n+\t  }\n+    }\n+  return;\n+}\n+\n+/* Mark that the matrix MI escapes at level L.  */\n+static void\n+mark_min_matrix_escape_level (struct matrix_info *mi, int l, tree s)\n+{\n+  if (mi->min_indirect_level_escape == -1\n+      || (mi->min_indirect_level_escape > l))\n+    {\n+      mi->min_indirect_level_escape = l;\n+      mi->min_indirect_level_escape_stmt = s;\n+    }\n+}\n+\n+/* Find if the SSA variable is accessed inside the\n+   tree and record the tree containing it.\n+   The only relevant uses are the case of SSA_NAME, or SSA inside\n+   INDIRECT_REF, CALL_EXPR, PLUS_EXPR, MULT_EXPR.  */\n+static void\n+ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n+{\n+  tree call, decl;\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+\n+  a->t_code = TREE_CODE (t);\n+  switch (a->t_code)\n+    {\n+      tree op1, op2;\n+\n+    case SSA_NAME:\n+      if (t == a->ssa_var)\n+\ta->var_found = true;\n+      break;\n+    case INDIRECT_REF:\n+      if (SSA_VAR_P (TREE_OPERAND (t, 0))\n+\t  && TREE_OPERAND (t, 0) == a->ssa_var)\n+\ta->var_found = true;\n+      break;\n+    case CALL_EXPR:\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, t)\n+      {\n+\tif (arg == a->ssa_var)\n+\t  {\n+\t    a->var_found = true;\n+\t    call = get_call_expr_in (t);\n+\t    if (call && (decl = get_callee_fndecl (call)))\n+\t      a->t_tree = decl;\n+\t    break;\n+\t  }\n+      }\n+      break;\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+      op1 = TREE_OPERAND (t, 0);\n+      op2 = TREE_OPERAND (t, 1);\n+\n+      if (op1 == a->ssa_var)\n+\t{\n+\t  a->var_found = true;\n+\t  a->second_op = op2;\n+\t}\n+      else if (op2 == a->ssa_var)\n+\t{\n+\t  a->var_found = true;\n+\t  a->second_op = op1;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Record the access/allocation site information for matrix MI so we can \n+   handle it later in transformation.  */\n+static void\n+record_access_alloc_site_info (struct matrix_info *mi, tree stmt, tree offset,\n+\t\t\t       tree index, int level, bool is_alloc)\n+{\n+  struct access_site_info *acc_info;\n+\n+  if (!mi->access_l)\n+    mi->access_l = VEC_alloc (access_site_info_p, heap, 100);\n+\n+  acc_info\n+    = (struct access_site_info *)\n+    xcalloc (1, sizeof (struct access_site_info));\n+  acc_info->stmt = stmt;\n+  acc_info->offset = offset;\n+  acc_info->index = index;\n+  acc_info->function_decl = current_function_decl;\n+  acc_info->level = level;\n+  acc_info->is_alloc = is_alloc;\n+\n+  VEC_safe_push (access_site_info_p, heap, mi->access_l, acc_info);\n+\n+}\n+\n+/* Record the malloc as the allocation site of the given LEVEL.  But\n+   first we Make sure that all the size parameters passed to malloc in\n+   all the allocation sites could be pre-calculated before the call to\n+   the malloc of level 0 (the main malloc call).  */\n+static void\n+add_allocation_site (struct matrix_info *mi, tree stmt, int level)\n+{\n+  struct malloc_call_data mcd;\n+\n+  /* Make sure that the allocation sites are in the same function.  */\n+  if (!mi->allocation_function_decl)\n+    mi->allocation_function_decl = current_function_decl;\n+  else if (mi->allocation_function_decl != current_function_decl)\n+    {\n+      int min_malloc_level;\n+\n+      gcc_assert (mi->malloc_for_level);\n+\n+      /* Find the minimum malloc level that already has been seen;\n+         we known its allocation function must be\n+         MI->allocation_function_decl since it's different than\n+         CURRENT_FUNCTION_DECL then the escaping level should be\n+         MIN (LEVEL, MIN_MALLOC_LEVEL) - 1 , and the allocation function\n+         must be set accordingly.  */\n+      for (min_malloc_level = 0;\n+\t   min_malloc_level < mi->max_malloced_level\n+\t   && mi->malloc_for_level[min_malloc_level]; min_malloc_level++);\n+      if (level < min_malloc_level)\n+\t{\n+\t  mi->allocation_function_decl = current_function_decl;\n+\t  mark_min_matrix_escape_level (mi, min_malloc_level, stmt);\n+\t}\n+      else\n+\t{\n+\t  mark_min_matrix_escape_level (mi, level, stmt);\n+\t  /* cannot be that (level == min_malloc_level) \n+\t     we would have returned earlier.  */\n+\t  return;\n+\t}\n+    }\n+\n+  /* Find the correct malloc information.  */\n+  collect_data_for_malloc_call (stmt, &mcd);\n+\n+  /* We accept only calls to malloc function; we do not accept\n+     calls like calloc and realloc.  */\n+  if (!mi->malloc_for_level)\n+    {\n+      mi->malloc_for_level = xcalloc (level + 1, sizeof (tree));\n+      mi->max_malloced_level = level + 1;\n+    }\n+  else if (mi->max_malloced_level <= level)\n+    {\n+      mi->malloc_for_level\n+\t= xrealloc (mi->malloc_for_level, (level + 1) * sizeof (tree));\n+\n+      /* Zero the newly allocated items.  */\n+      memset (&(mi->malloc_for_level[mi->max_malloced_level + 1]),\n+\t      0, (level - mi->max_malloced_level) * sizeof (tree));\n+\n+      mi->max_malloced_level = level + 1;\n+    }\n+  mi->malloc_for_level[level] = stmt;\n+}\n+\n+/* Given an assignment statement STMT that we know that its\n+   left-hand-side is the matrix MI variable, we traverse the immediate\n+   uses backwards until we get to a malloc site.  We make sure that\n+   there is one and only one malloc site that sets this variable.  When\n+   we are performing the flattening we generate a new variable that\n+   will hold the size for each dimension; each malloc that allocates a\n+   dimension has the size parameter; we use that parameter to\n+   initialize the dimension size variable so we can use it later in\n+   the address calculations.  LEVEL is the dimension we're inspecting.  \n+   Return if STMT is related to an allocation site.  */\n+\n+static void\n+analyze_matrix_allocation_site (struct matrix_info *mi, tree stmt,\n+\t\t\t\tint level, sbitmap visited)\n+{\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+    {\n+      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\n+      rhs = get_inner_of_cast_expr (rhs);\n+      if (TREE_CODE (rhs) == SSA_NAME)\n+\t{\n+\t  tree def = SSA_NAME_DEF_STMT (rhs);\n+\n+\t  analyze_matrix_allocation_site (mi, def, level, visited);\n+\t  return;\n+\t}\n+\n+      /* A result of call to malloc.  */\n+      else if (TREE_CODE (rhs) == CALL_EXPR)\n+\t{\n+\t  int call_flags = call_expr_flags (rhs);\n+\n+\t  if (!(call_flags & ECF_MALLOC))\n+\t    {\n+\t      mark_min_matrix_escape_level (mi, level, stmt);\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree malloc_fn_decl;\n+\t      const char *malloc_fname;\n+\n+\t      malloc_fn_decl = CALL_EXPR_FN (rhs);\n+\t      if (TREE_CODE (malloc_fn_decl) != ADDR_EXPR\n+\t\t  || TREE_CODE (TREE_OPERAND (malloc_fn_decl, 0)) !=\n+\t\t  FUNCTION_DECL)\n+\t\t{\n+\t\t  mark_min_matrix_escape_level (mi, level, stmt);\n+\t\t  return;\n+\t\t}\n+\t      malloc_fn_decl = TREE_OPERAND (malloc_fn_decl, 0);\n+\t      malloc_fname = IDENTIFIER_POINTER (DECL_NAME (malloc_fn_decl));\n+\t      if (DECL_FUNCTION_CODE (malloc_fn_decl) != BUILT_IN_MALLOC)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Matrix %s is an argument to function %s\\n\",\n+\t\t\t     get_name (mi->decl), get_name (malloc_fn_decl));\n+\t\t  mark_min_matrix_escape_level (mi, level, stmt);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  /* This is a call to malloc.  Check to see if this is the first\n+\t     call in this indirection level; if so, mark it; if not, mark\n+\t     as escaping.  */\n+\t  if (mi->malloc_for_level\n+\t      && mi->malloc_for_level[level]\n+\t      && mi->malloc_for_level[level] != stmt)\n+\t    {\n+\t      mark_min_matrix_escape_level (mi, level, stmt);\n+\t      return;\n+\t    }\n+\t  else\n+\t    add_allocation_site (mi, stmt, level);\n+\t  return;\n+\t}\n+      /* If we are back to the original matrix variable then we\n+         are sure that this is analyzed as an access site.  */\n+      else if (rhs == mi->decl)\n+\treturn;\n+    }\n+  /* Looks like we don't know what is happening in this\n+     statement so be in the safe side and mark it as escaping.  */\n+  mark_min_matrix_escape_level (mi, level, stmt);\n+}\n+\n+/* The transposing decision making.\n+   In order to to calculate the profitability of transposing, we collect two \n+   types of information regarding the accesses:\n+   1. profiling information used to express the hotness of an access, that\n+   is how often the matrix is accessed by this access site (count of the \n+   access site). \n+   2. which dimension in the access site is iterated by the inner\n+   most loop containing this access.\n+\n+   The matrix will have a calculated value of weighted hotness for each \n+   dimension.\n+   Intuitively the hotness level of a dimension is a function of how \n+   many times it was the most frequently accessed dimension in the \n+   highly executed access sites of this matrix.\n+\n+   As computed by following equation:\n+   m      n \n+   __   __  \n+   \\    \\  dim_hot_level[i] +=   \n+   /_   /_\n+   j     i \n+                 acc[j]->dim[i]->iter_by_inner_loop * count(j)\n+\n+  Where n is the number of dims and m is the number of the matrix\n+  access sites. acc[j]->dim[i]->iter_by_inner_loop is 1 if acc[j]\n+  iterates over dim[i] in innermost loop, and is 0 otherwise.\n+\n+  The organization of the new matrix should be according to the\n+  hotness of each dimension. The hotness of the dimension implies\n+  the locality of the elements.*/\n+static int\n+analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  struct matrix_info *mi = *slot;\n+  int min_escape_l = mi->min_indirect_level_escape;\n+  struct loop *loop;\n+  affine_iv iv;\n+  struct access_site_info *acc_info;\n+  int i;\n+\n+  if (min_escape_l < 2 || !mi->access_l)\n+    {\n+      if (mi->access_l)\n+\t{\n+\t  for (i = 0;\n+\t       VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n+\t       i++)\n+\t    free (acc_info);\n+\t  VEC_free (access_site_info_p, heap, mi->access_l);\n+\n+\t}\n+      return 1;\n+    }\n+  if (!mi->dim_hot_level)\n+    mi->dim_hot_level =\n+      (gcov_type *) xcalloc (min_escape_l, sizeof (gcov_type));\n+\n+\n+  for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n+       i++)\n+    {\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (acc_info->stmt, 1)) == PLUS_EXPR\n+\t  && acc_info->level < min_escape_l)\n+\t{\n+\t  loop = loop_containing_stmt (acc_info->stmt);\n+\t  if (!loop || loop->inner)\n+\t    {\n+\t      free (acc_info);\n+\t      continue;\n+\t    }\n+\t  if (simple_iv (loop, acc_info->stmt, acc_info->offset, &iv, true))\n+\t    {\n+\t      if (iv.step != NULL)\n+\t\t{\n+\t\t  HOST_WIDE_INT istep;\n+\n+\t\t  istep = int_cst_value (iv.step);\n+\t\t  if (istep != 0)\n+\t\t    {\n+\t\t      acc_info->iterated_by_inner_most_loop_p = 1;\n+\t\t      mi->dim_hot_level[acc_info->level] +=\n+\t\t\tbb_for_stmt (acc_info->stmt)->count;\n+\t\t    }\n+\n+\t\t}\n+\t    }\n+\t}\n+      free (acc_info);\n+    }\n+  VEC_free (access_site_info_p, heap, mi->access_l);\n+\n+  return 1;\n+}\n+\n+/* Find the index which defines the OFFSET from base.  \n+   We walk from use to def until we find how the offset was defined.  */\n+static tree\n+get_index_from_offset (tree offset, tree def_stmt)\n+{\n+  tree op1, op2, expr, index;\n+\n+  if (TREE_CODE (def_stmt) == PHI_NODE)\n+    return NULL;\n+  expr = get_inner_of_cast_expr (GIMPLE_STMT_OPERAND (def_stmt, 1));\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    return get_index_from_offset (offset, SSA_NAME_DEF_STMT (expr));\n+  else if (TREE_CODE (expr) == MULT_EXPR)\n+    {\n+      op1 = TREE_OPERAND (expr, 0);\n+      op2 = TREE_OPERAND (expr, 1);\n+      if (TREE_CODE (op1) != INTEGER_CST && TREE_CODE (op2) != INTEGER_CST)\n+\treturn NULL;\n+      index = (TREE_CODE (op1) == INTEGER_CST) ? op2 : op1;\n+      return index;\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* update MI->dimension_type_size[CURRENT_INDIRECT_LEVEL] with the size\n+   of the type related to the SSA_VAR, or the type related to the\n+   lhs of STMT, in the case that it is an INDIRECT_REF.  */\n+static void\n+update_type_size (struct matrix_info *mi, tree stmt, tree ssa_var,\n+\t\t  int current_indirect_level)\n+{\n+  tree lhs;\n+  HOST_WIDE_INT type_size;\n+\n+  /* Update type according to the type of the INDIRECT_REF expr.   */\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == INDIRECT_REF)\n+    {\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      gcc_assert (POINTER_TYPE_P\n+\t\t  (TREE_TYPE (SSA_NAME_VAR (TREE_OPERAND (lhs, 0)))));\n+      type_size =\n+\tint_size_in_bytes (TREE_TYPE\n+\t\t\t   (TREE_TYPE\n+\t\t\t    (SSA_NAME_VAR (TREE_OPERAND (lhs, 0)))));\n+    }\n+  else\n+    type_size = int_size_in_bytes (TREE_TYPE (ssa_var));\n+\n+  /* Record the size of elements accessed (as a whole)\n+     in the current indirection level (dimension).  If the size of\n+     elements is not known at compile time, mark it as escaping.  */\n+  if (type_size <= 0)\n+    mark_min_matrix_escape_level (mi, current_indirect_level, stmt);\n+  else\n+    {\n+      int l = current_indirect_level;\n+\n+      if (!mi->dimension_type_size)\n+\t{\n+\t  mi->dimension_type_size\n+\t    = (HOST_WIDE_INT *) xcalloc (l + 1, sizeof (HOST_WIDE_INT));\n+\t  mi->dimension_type_size_len = l + 1;\n+\t}\n+      else if (mi->dimension_type_size_len < l + 1)\n+\t{\n+\t  mi->dimension_type_size\n+\t    = (HOST_WIDE_INT *) xrealloc (mi->dimension_type_size,\n+\t\t\t\t\t  (l + 1) * sizeof (HOST_WIDE_INT));\n+\t  memset (&mi->dimension_type_size[mi->dimension_type_size_len],\n+\t\t  0, (l + 1 - mi->dimension_type_size_len)\n+\t\t  * sizeof (HOST_WIDE_INT));\n+\t  mi->dimension_type_size_len = l + 1;\n+\t}\n+      /* Make sure all the accesses in the same level have the same size\n+         of the type.  */\n+      if (!mi->dimension_type_size[l])\n+\tmi->dimension_type_size[l] = type_size;\n+      else if (mi->dimension_type_size[l] != type_size)\n+\tmark_min_matrix_escape_level (mi, l, stmt);\n+    }\n+}\n+\n+/* USE_STMT represents a call_expr ,where one of the arguments is the \n+   ssa var that we want to check because it came from some use of matrix \n+   MI.  CURRENT_INDIRECT_LEVEL is the indirection level we reached so \n+   far.  */\n+\n+static void\n+analyze_accesses_for_call_expr (struct matrix_info *mi, tree use_stmt,\n+\t\t\t\tint current_indirect_level)\n+{\n+  tree call = get_call_expr_in (use_stmt);\n+  if (call && get_callee_fndecl (call))\n+    {\n+      if (DECL_FUNCTION_CODE (get_callee_fndecl (call)) != BUILT_IN_FREE)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Matrix %s: Function call %s, level %d escapes.\\n\",\n+\t\t     get_name (mi->decl), get_name (get_callee_fndecl (call)),\n+\t\t     current_indirect_level);\n+\t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n+\t}\n+      else if (mi->free_stmts[current_indirect_level].stmt != NULL\n+\t       && mi->free_stmts[current_indirect_level].stmt != use_stmt)\n+\tmark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n+      else\n+\t{\n+\t  /*Record the free statements so we can delete them\n+\t     later. */\n+\t  int l = current_indirect_level;\n+\n+\t  mi->free_stmts[l].stmt = use_stmt;\n+\t  mi->free_stmts[l].func = current_function_decl;\n+\t}\n+    }\n+}\n+\n+/* USE_STMT represents a phi node of the ssa var that we want to \n+   check  because it came from some use of matrix \n+   MI.\n+   We check all the escaping levels that get to the PHI node\n+   and make sure they are all the same escaping;\n+   if not (which is rare) we let the escaping level be the\n+   minimum level that gets into that PHI because starting from\n+   that level we cannot expect the behavior of the indirections.  \n+   CURRENT_INDIRECT_LEVEL is the indirection level we reached so far.  */\n+\n+static void\n+analyze_accesses_for_phi_node (struct matrix_info *mi, tree use_stmt,\n+\t\t\t       int current_indirect_level, sbitmap visited,\n+\t\t\t       bool record_accesses)\n+{\n+\n+  struct matrix_access_phi_node tmp_maphi, *maphi, **pmaphi;\n+\n+  tmp_maphi.phi = use_stmt;\n+  if ((maphi = htab_find (htab_mat_acc_phi_nodes, &tmp_maphi)))\n+    {\n+      if (maphi->indirection_level == current_indirect_level)\n+\treturn;\n+      else\n+\t{\n+\t  int level = MIN (maphi->indirection_level,\n+\t\t\t   current_indirect_level);\n+\t  int j;\n+\t  tree t = NULL_TREE;\n+\n+\t  maphi->indirection_level = level;\n+\t  for (j = 0; j < PHI_NUM_ARGS (use_stmt); j++)\n+\t    {\n+\t      tree def = PHI_ARG_DEF (use_stmt, j);\n+\n+\t      if (TREE_CODE (SSA_NAME_DEF_STMT (def)) != PHI_NODE)\n+\t\tt = SSA_NAME_DEF_STMT (def);\n+\t    }\n+\t  mark_min_matrix_escape_level (mi, level, t);\n+\t}\n+      return;\n+    }\n+  maphi = (struct matrix_access_phi_node *)\n+    xcalloc (1, sizeof (struct matrix_access_phi_node));\n+  maphi->phi = use_stmt;\n+  maphi->indirection_level = current_indirect_level;\n+\n+  /* Insert to hash table.  */\n+  pmaphi = (struct matrix_access_phi_node **)\n+    htab_find_slot (htab_mat_acc_phi_nodes, maphi, INSERT);\n+  gcc_assert (pmaphi);\n+  *pmaphi = maphi;\n+\n+  if (!TEST_BIT (visited, SSA_NAME_VERSION (PHI_RESULT (use_stmt))))\n+    {\n+      SET_BIT (visited, SSA_NAME_VERSION (PHI_RESULT (use_stmt)));\n+      analyze_matrix_accesses (mi, PHI_RESULT (use_stmt),\n+\t\t\t       current_indirect_level, false, visited,\n+\t\t\t       record_accesses);\n+      RESET_BIT (visited, SSA_NAME_VERSION (PHI_RESULT (use_stmt)));\n+    }\n+}\n+\n+/* USE_STMT represents a modify statement (the rhs or lhs include \n+   the ssa var that we want to check  because it came from some use of matrix \n+   MI.\n+   CURRENT_INDIRECT_LEVEL is the indirection level we reached so far.  */\n+\n+static int\n+analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n+\t\t\t\t  tree use_stmt, int current_indirect_level,\n+\t\t\t\t  bool last_op, sbitmap visited,\n+\t\t\t\t  bool record_accesses)\n+{\n+\n+  tree lhs = GIMPLE_STMT_OPERAND (use_stmt, 0);\n+  tree rhs = GIMPLE_STMT_OPERAND (use_stmt, 1);\n+  struct ssa_acc_in_tree lhs_acc, rhs_acc;\n+\n+  memset (&lhs_acc, 0, sizeof (lhs_acc));\n+  memset (&rhs_acc, 0, sizeof (rhs_acc));\n+\n+  lhs_acc.ssa_var = ssa_var;\n+  lhs_acc.t_code = ERROR_MARK;\n+  ssa_accessed_in_tree (lhs, &lhs_acc);\n+  rhs_acc.ssa_var = ssa_var;\n+  rhs_acc.t_code = ERROR_MARK;\n+  ssa_accessed_in_tree (get_inner_of_cast_expr (rhs), &rhs_acc);\n+\n+  /* The SSA must be either in the left side or in the right side,\n+     to understand what is happening.\n+     In case the SSA_NAME is found in both sides we should be escaping\n+     at this level because in this case we cannot calculate the\n+     address correctly.  */\n+  if ((lhs_acc.var_found && rhs_acc.var_found\n+       && lhs_acc.t_code == INDIRECT_REF)\n+      || (!rhs_acc.var_found && !lhs_acc.var_found))\n+    {\n+      mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n+      return current_indirect_level;\n+    }\n+  gcc_assert (!rhs_acc.var_found || !lhs_acc.var_found);\n+\n+  /* If we are storing to the matrix at some level, then mark it as\n+     escaping at that level.  */\n+  if (lhs_acc.var_found)\n+    {\n+      tree def;\n+      int l = current_indirect_level + 1;\n+\n+      gcc_assert (lhs_acc.t_code == INDIRECT_REF);\n+      def = get_inner_of_cast_expr (rhs);\n+      if (TREE_CODE (def) != SSA_NAME)\n+\tmark_min_matrix_escape_level (mi, l, use_stmt);\n+      else\n+\t{\n+\t  def = SSA_NAME_DEF_STMT (def);\n+\t  analyze_matrix_allocation_site (mi, def, l, visited);\n+\t  if (record_accesses)\n+\t    record_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n+\t\t\t\t\t   NULL_TREE, l, true);\n+\t  update_type_size (mi, use_stmt, NULL, l);\n+\t}\n+      return current_indirect_level;\n+    }\n+  /* Now, check the right-hand-side, to see how the SSA variable \n+     is used.  */\n+  if (rhs_acc.var_found)\n+    {\n+      /* If we are passing the ssa name to a function call and\n+         the pointer escapes when passed to the function \n+         (not the case of free), then we mark the matrix as \n+         escaping at this level.  */\n+      if (rhs_acc.t_code == CALL_EXPR)\n+\t{\n+\t  analyze_accesses_for_call_expr (mi, use_stmt,\n+\t\t\t\t\t  current_indirect_level);\n+\n+\t  return current_indirect_level;\n+\t}\n+      if (rhs_acc.t_code != INDIRECT_REF\n+\t  && rhs_acc.t_code != PLUS_EXPR && rhs_acc.t_code != SSA_NAME)\n+\t{\n+\t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n+\t  return current_indirect_level;\n+\t}\n+      /* If the access in the RHS has an indirection increase the\n+         indirection level.  */\n+      if (rhs_acc.t_code == INDIRECT_REF)\n+\t{\n+\t  if (record_accesses)\n+\t    record_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n+\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t   current_indirect_level, true);\n+\t  current_indirect_level += 1;\n+\t}\n+      else if (rhs_acc.t_code == PLUS_EXPR)\n+\t{\n+\t  /* ??? maybe we should check\n+\t     the type of the PLUS_EXP and make sure it's\n+\t     integral type.  */\n+\t  gcc_assert (rhs_acc.second_op);\n+\t  if (last_op)\n+\t    /* Currently we support only one PLUS expression on the\n+\t       SSA_NAME that holds the base address of the current\n+\t       indirection level; to support more general case there\n+\t       is a need to hold a stack of expressions and regenerate\n+\t       the calculation later.  */\n+\t    mark_min_matrix_escape_level (mi, current_indirect_level,\n+\t\t\t\t\t  use_stmt);\n+\t  else\n+\t    {\n+\t      tree index;\n+\t      tree op1, op2;\n+\n+\t      op1 = TREE_OPERAND (rhs, 0);\n+\t      op2 = TREE_OPERAND (rhs, 1);\n+\n+\t      op2 = (op1 == ssa_var) ? op2 : op1;\n+\t      if (TREE_CODE (op2) == INTEGER_CST)\n+\t\tindex =\n+\t\t  build_int_cst (TREE_TYPE (op1),\n+\t\t\t\t TREE_INT_CST_LOW (op2) /\n+\t\t\t\t int_size_in_bytes (TREE_TYPE (op1)));\n+\t      else\n+\t\t{\n+\t\t  index =\n+\t\t    get_index_from_offset (op2, SSA_NAME_DEF_STMT (op2));\n+\t\t  if (index == NULL_TREE)\n+\t\t    {\n+\t\t      mark_min_matrix_escape_level (mi,\n+\t\t\t\t\t\t    current_indirect_level,\n+\t\t\t\t\t\t    use_stmt);\n+\t\t      return current_indirect_level;\n+\t\t    }\n+\t\t}\n+\t      if (record_accesses)\n+\t\trecord_access_alloc_site_info (mi, use_stmt, op2,\n+\t\t\t\t\t       index,\n+\t\t\t\t\t       current_indirect_level, false);\n+\t    }\n+\t}\n+      /* If we are storing this level of indirection mark it as\n+         escaping.  */\n+      if (lhs_acc.t_code == INDIRECT_REF || TREE_CODE (lhs) != SSA_NAME)\n+\t{\n+\t  int l = current_indirect_level;\n+\n+\t  /* One exception is when we are storing to the matrix\n+\t     variable itself; this is the case of malloc, we must make\n+\t     sure that it's the one and only one call to malloc so \n+\t     we call analyze_matrix_allocation_site to check \n+\t     this out.  */\n+\t  if (TREE_CODE (lhs) != VAR_DECL || lhs != mi->decl)\n+\t    mark_min_matrix_escape_level (mi, current_indirect_level,\n+\t\t\t\t\t  use_stmt);\n+\t  else\n+\t    {\n+\t      /* Also update the escaping level.  */\n+\t      analyze_matrix_allocation_site (mi, use_stmt, l, visited);\n+\t      if (record_accesses)\n+\t\trecord_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n+\t\t\t\t\t       NULL_TREE, l, true);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* We are placing it in an SSA, follow that SSA.  */\n+\t  analyze_matrix_accesses (mi, lhs,\n+\t\t\t\t   current_indirect_level,\n+\t\t\t\t   rhs_acc.t_code == PLUS_EXPR,\n+\t\t\t\t   visited, record_accesses);\n+\t}\n+    }\n+  return current_indirect_level;\n+}\n+\n+/* Given a SSA_VAR (coming from a use statement of the matrix MI), \n+   follow its uses and level of indirection and find out the minimum\n+   indirection level it escapes in (the highest dimension) and the maximum\n+   level it is accessed in (this will be the actual dimension of the\n+   matrix).  The information is accumulated in MI.\n+   We look at the immediate uses, if one escapes we finish; if not,\n+   we make a recursive call for each one of the immediate uses of the\n+   resulting SSA name.  */\n+static void\n+analyze_matrix_accesses (struct matrix_info *mi, tree ssa_var,\n+\t\t\t int current_indirect_level, bool last_op,\n+\t\t\t sbitmap visited, bool record_accesses)\n+{\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+\n+  update_type_size (mi, SSA_NAME_DEF_STMT (ssa_var), ssa_var,\n+\t\t    current_indirect_level);\n+\n+  /* We don't go beyond the escaping level when we are performing the\n+     flattening.  NOTE: we keep the last indirection level that doesn't\n+     escape.  */\n+  if (mi->min_indirect_level_escape > -1\n+      && mi->min_indirect_level_escape <= current_indirect_level)\n+    return;\n+\n+/* Now go over the uses of the SSA_NAME and check how it is used in\n+   each one of them.  We are mainly looking for the pattern INDIRECT_REF,\n+   then a PLUS_EXPR, then INDIRECT_REF etc.  while in between there could\n+   be any number of copies and casts.  */\n+  gcc_assert (TREE_CODE (ssa_var) == SSA_NAME);\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ssa_var)\n+  {\n+    tree use_stmt = USE_STMT (use_p);\n+    if (TREE_CODE (use_stmt) == PHI_NODE)\n+      /* We check all the escaping levels that get to the PHI node\n+         and make sure they are all the same escaping;\n+         if not (which is rare) we let the escaping level be the\n+         minimum level that gets into that PHI because starting from\n+         that level we cannot expect the behavior of the indirections.  */\n+\n+      analyze_accesses_for_phi_node (mi, use_stmt, current_indirect_level,\n+\t\t\t\t     visited, record_accesses);\n+\n+    else if (TREE_CODE (use_stmt) == CALL_EXPR)\n+      analyze_accesses_for_call_expr (mi, use_stmt, current_indirect_level);\n+    else if (TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT)\n+      current_indirect_level =\n+\tanalyze_accesses_for_modify_stmt (mi, ssa_var, use_stmt,\n+\t\t\t\t\t  current_indirect_level, last_op,\n+\t\t\t\t\t  visited, record_accesses);\n+  }\n+}\n+\n+\n+/* A walk_tree function to go over the VAR_DECL, PARM_DECL nodes of\n+   the malloc size expression and check that those aren't changed\n+   over the function.  */\n+static tree\n+check_var_notmodified_p (tree * tp, int *walk_subtrees, void *data)\n+{\n+  basic_block bb;\n+  tree t = *tp;\n+  tree fn = data;\n+  block_stmt_iterator bsi;\n+  tree stmt;\n+\n+  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+    return NULL_TREE;\n+\n+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (fn))\n+  {\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\tstmt = bsi_stmt (bsi);\n+\tif (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+\t  continue;\n+\tif (GIMPLE_STMT_OPERAND (stmt, 0) == t)\n+\t  return stmt;\n+      }\n+  }\n+  *walk_subtrees = 1;\n+  return NULL_TREE;\n+}\n+\n+/* Go backwards in the use-def chains and find out the expression\n+   represented by the possible SSA name in EXPR, until it is composed\n+   of only VAR_DECL, PARM_DECL and INT_CST.  In case of phi nodes\n+   we make sure that all the arguments represent the same subexpression,\n+   otherwise we fail.  */\n+static tree\n+can_calculate_expr_before_stmt (tree expr, sbitmap visited)\n+{\n+  tree def_stmt, op1, op2, res;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case SSA_NAME:\n+      /* Case of loop, we don't know to represent this expression.  */\n+      if (TEST_BIT (visited, SSA_NAME_VERSION (expr)))\n+\treturn NULL_TREE;\n+\n+      SET_BIT (visited, SSA_NAME_VERSION (expr));\n+      def_stmt = SSA_NAME_DEF_STMT (expr);\n+      res = can_calculate_expr_before_stmt (def_stmt, visited);\n+      RESET_BIT (visited, SSA_NAME_VERSION (expr));\n+      return res;\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case INTEGER_CST:\n+      return expr;\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+      op1 = TREE_OPERAND (expr, 0);\n+      op2 = TREE_OPERAND (expr, 1);\n+\n+      op1 = can_calculate_expr_before_stmt (op1, visited);\n+      if (!op1)\n+\treturn NULL_TREE;\n+      op2 = can_calculate_expr_before_stmt (op2, visited);\n+      if (op2)\n+\treturn fold_build2 (TREE_CODE (expr), TREE_TYPE (expr), op1, op2);\n+      return NULL_TREE;\n+    case GIMPLE_MODIFY_STMT:\n+      return can_calculate_expr_before_stmt (GIMPLE_STMT_OPERAND (expr, 1),\n+\t\t\t\t\t     visited);\n+    case PHI_NODE:\n+      {\n+\tint j;\n+\n+\tres = NULL_TREE;\n+\t/* Make sure all the arguments represent the same value.  */\n+\tfor (j = 0; j < PHI_NUM_ARGS (expr); j++)\n+\t  {\n+\t    tree new_res;\n+\t    tree def = PHI_ARG_DEF (expr, j);\n+\n+\t    new_res = can_calculate_expr_before_stmt (def, visited);\n+\t    if (res == NULL_TREE)\n+\t      res = new_res;\n+\t    else if (!new_res || !expressions_equal_p (res, new_res))\n+\t      return NULL_TREE;\n+\t  }\n+\treturn res;\n+      }\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      res = can_calculate_expr_before_stmt (TREE_OPERAND (expr, 0), visited);\n+      if (res != NULL_TREE)\n+\treturn build1 (TREE_CODE (expr), TREE_TYPE (expr), res);\n+      else\n+\treturn NULL_TREE;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* There should be only one allocation function for the dimensions\n+   that don't escape. Here we check the allocation sites in this\n+   function. We must make sure that all the dimensions are allocated\n+   using malloc and that the malloc size parameter expression could be\n+   pre-calculated before the call to the malloc of dimension 0.\n+\n+   Given a candidate matrix for flattening -- MI -- check if it's\n+   appropriate for flattening -- we analyze the allocation\n+   sites that we recorded in the previous analysis.  The result of the\n+   analysis is a level of indirection (matrix dimension) in which the\n+   flattening is safe.  We check the following conditions:\n+   1. There is only one allocation site for each dimension.\n+   2. The allocation sites of all the dimensions are in the same\n+      function.\n+      (The above two are being taken care of during the analysis when\n+      we check the allocation site).\n+   3. All the dimensions that we flatten are allocated at once; thus\n+      the total size must be known before the allocation of the\n+      dimension 0 (top level) -- we must make sure we represent the\n+      size of the allocation as an expression of global parameters or\n+      constants and that those doesn't change over the function.  */\n+\n+static int\n+check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  int level;\n+  block_stmt_iterator bsi;\n+  basic_block bb_level_0;\n+  struct matrix_info *mi = *slot;\n+  sbitmap visited = sbitmap_alloc (num_ssa_names);\n+\n+  if (!mi->malloc_for_level)\n+    return 1;\n+  /* Do nothing if the current function is not the allocation\n+     function of MI.  */\n+  if (mi->allocation_function_decl != current_function_decl\n+      /* We aren't in the main allocation function yet.  */\n+      || !mi->malloc_for_level[0])\n+    return 1;\n+\n+  for (level = 1; level < mi->max_malloced_level; level++)\n+    if (!mi->malloc_for_level[level])\n+      break;\n+\n+  mark_min_matrix_escape_level (mi, level, NULL_TREE);\n+\n+  bsi = bsi_for_stmt (mi->malloc_for_level[0]);\n+  bb_level_0 = bsi.bb;\n+\n+  /* Check if the expression of the size passed to malloc could be\n+     pre-calculated before the malloc of level 0.  */\n+  for (level = 1; level < mi->min_indirect_level_escape; level++)\n+    {\n+      tree call_stmt, size;\n+      struct malloc_call_data mcd;\n+\n+      call_stmt = mi->malloc_for_level[level];\n+\n+      /* Find the correct malloc information.  */\n+      collect_data_for_malloc_call (call_stmt, &mcd);\n+\n+      /* No need to check anticipation for constants.  */\n+      if (TREE_CODE (mcd.size_var) == INTEGER_CST)\n+\t{\n+\t  if (!mi->dimension_size)\n+\t    {\n+\t      mi->dimension_size =\n+\t\t(tree *) xcalloc (mi->min_indirect_level_escape,\n+\t\t\t\t  sizeof (tree));\n+\t      mi->dimension_size_orig =\n+\t\t(tree *) xcalloc (mi->min_indirect_level_escape,\n+\t\t\t\t  sizeof (tree));\n+\t    }\n+\t  mi->dimension_size[level] = mcd.size_var;\n+\t  mi->dimension_size_orig[level] = mcd.size_var;\n+\t  continue;\n+\t}\n+      /* ??? Here we should also add the way to calculate the size\n+         expression not only know that it is anticipated.  */\n+      sbitmap_zero (visited);\n+      size = can_calculate_expr_before_stmt (mcd.size_var, visited);\n+      if (size == NULL_TREE)\n+\t{\n+\t  mark_min_matrix_escape_level (mi, level, call_stmt);\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Matrix %s: Cannot calculate the size of allocation. escaping at level %d\\n\",\n+\t\t     get_name (mi->decl), level);\n+\t  break;\n+\t}\n+      if (!mi->dimension_size)\n+\t{\n+\t  mi->dimension_size =\n+\t    (tree *) xcalloc (mi->min_indirect_level_escape, sizeof (tree));\n+\t  mi->dimension_size_orig =\n+\t    (tree *) xcalloc (mi->min_indirect_level_escape, sizeof (tree));\n+\t}\n+      mi->dimension_size[level] = size;\n+      mi->dimension_size_orig[level] = size;\n+    }\n+\n+  /* We don't need those anymore.  */\n+  for (level = mi->min_indirect_level_escape;\n+       level < mi->max_malloced_level; level++)\n+    mi->malloc_for_level[level] = NULL;\n+  return 1;\n+}\n+\n+/* Track all access and allocation sites.  */\n+static void\n+find_sites_in_func (bool record)\n+{\n+  sbitmap visited_stmts_1;\n+\n+  block_stmt_iterator bsi;\n+  tree stmt;\n+  basic_block bb;\n+  struct matrix_info tmpmi, *mi;\n+\n+  visited_stmts_1 = sbitmap_alloc (num_ssa_names);\n+\n+  FOR_EACH_BB (bb)\n+  {\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\tstmt = bsi_stmt (bsi);\n+\tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == VAR_DECL)\n+\t  {\n+\t    tmpmi.decl = GIMPLE_STMT_OPERAND (stmt, 0);\n+\t    if ((mi = htab_find (matrices_to_reorg, &tmpmi)))\n+\t      {\n+\t\tsbitmap_zero (visited_stmts_1);\n+\t\tanalyze_matrix_allocation_site (mi, stmt, 0, visited_stmts_1);\n+\t      }\n+\t  }\n+\tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == VAR_DECL)\n+\t  {\n+\t    tmpmi.decl = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t    if ((mi = htab_find (matrices_to_reorg, &tmpmi)))\n+\t      {\n+\t\tsbitmap_zero (visited_stmts_1);\n+\t\tanalyze_matrix_accesses (mi,\n+\t\t\t\t\t GIMPLE_STMT_OPERAND (stmt, 0), 0,\n+\t\t\t\t\t false, visited_stmts_1, record);\n+\t      }\n+\t  }\n+      }\n+  }\n+  sbitmap_free (visited_stmts_1);\n+}\n+\n+/* Traverse the use-def chains to see if there are matrices that\n+   are passed through pointers and we cannot know how they are accessed.\n+   For each SSA-name defined by a global variable of our interest,\n+   we traverse the use-def chains of the SSA and follow the indirections,\n+   and record in what level of indirection the use of the variable\n+   escapes.  A use of a pointer escapes when it is passed to a function,\n+   stored into memory or assigned (except in malloc and free calls).  */\n+\n+static void\n+record_all_accesses_in_func (void)\n+{\n+  unsigned i;\n+  sbitmap visited_stmts_1;\n+\n+  visited_stmts_1 = sbitmap_alloc (num_ssa_names);\n+\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      struct matrix_info tmpmi, *mi;\n+      tree ssa_var = ssa_name (i);\n+      tree rhs, lhs;\n+\n+      if (!ssa_var\n+\t  || TREE_CODE (SSA_NAME_DEF_STMT (ssa_var)) != GIMPLE_MODIFY_STMT)\n+\tcontinue;\n+      rhs = GIMPLE_STMT_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 1);\n+      lhs = GIMPLE_STMT_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 0);\n+      if (TREE_CODE (rhs) != VAR_DECL && TREE_CODE (lhs) != VAR_DECL)\n+\tcontinue;\n+\n+      /* If the RHS is a matrix that we want to analyze, follow the def-use\n+         chain for this SSA_VAR and check for escapes or apply the\n+         flattening.  */\n+      tmpmi.decl = rhs;\n+      if ((mi = htab_find (matrices_to_reorg, &tmpmi)))\n+\t{\n+\t  /* This variable will track the visited PHI nodes, so we can limit\n+\t     its size to the maximum number of SSA names.  */\n+\t  sbitmap_zero (visited_stmts_1);\n+\t  analyze_matrix_accesses (mi, ssa_var,\n+\t\t\t\t   0, false, visited_stmts_1, true);\n+\n+\t}\n+    }\n+  sbitmap_free (visited_stmts_1);\n+}\n+\n+/* We know that we are allowed to perform matrix flattening (according to the\n+   escape analysis), so we traverse the use-def chains of the SSA vars\n+   defined by the global variables pointing to the matrices of our interest.\n+   in each use of the SSA we calculate the offset from the base address\n+   according to the following equation:\n+\n+     a[I1][I2]...[Ik] , where D1..Dk is the length of each dimension and the\n+     escaping level is m <= k, and a' is the new allocated matrix, \n+     will be translated to :\n+       \n+       b[I(m+1)]...[Ik]\n+       \n+       where \n+       b = a' + I1*D2...*Dm + I2*D3...Dm + ... + Im\n+                                                      */\n+\n+static int\n+transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  tree stmts;\n+  block_stmt_iterator bsi;\n+  struct matrix_info *mi = *slot;\n+  int min_escape_l = mi->min_indirect_level_escape;\n+  struct access_site_info *acc_info;\n+  int i;\n+\n+  if (min_escape_l < 2 || !mi->access_l)\n+    return 1;\n+  for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n+       i++)\n+    {\n+      tree orig, type;\n+\n+      /* This is possible because we collect the access sites before\n+         we determine the final minimum indirection level.  */\n+      if (acc_info->level >= min_escape_l)\n+\t{\n+\t  free (acc_info);\n+\t  continue;\n+\t}\n+      if (acc_info->is_alloc)\n+\t{\n+\t  if (acc_info->level >= 0 && bb_for_stmt (acc_info->stmt))\n+\t    {\n+\t      ssa_op_iter iter;\n+\t      tree def;\n+\t      tree stmt = acc_info->stmt;\n+\n+\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+\t\tmark_sym_for_renaming (SSA_NAME_VAR (def));\n+\t      bsi = bsi_for_stmt (stmt);\n+\t      gcc_assert (TREE_CODE (acc_info->stmt) == GIMPLE_MODIFY_STMT);\n+\t      if (TREE_CODE (GIMPLE_STMT_OPERAND (acc_info->stmt, 0)) ==\n+\t\t  SSA_NAME && acc_info->level < min_escape_l - 1)\n+\t\t{\n+\t\t  imm_use_iterator imm_iter;\n+\t\t  use_operand_p use_p;\n+\t\t  tree use_stmt;\n+\n+\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n+\t\t\t\t\t GIMPLE_STMT_OPERAND (acc_info->stmt,\n+\t\t\t\t\t\t\t      0))\n+\t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t  {\n+\t\t    tree conv, tmp, stmts;\n+\n+\t\t    /* Emit convert statement to convert to type of use.  */\n+\t\t    conv =\n+\t\t      fold_build1 (CONVERT_EXPR,\n+\t\t\t\t   TREE_TYPE (GIMPLE_STMT_OPERAND\n+\t\t\t\t\t      (acc_info->stmt, 0)),\n+\t\t\t\t   TREE_OPERAND (GIMPLE_STMT_OPERAND\n+\t\t\t\t\t\t (acc_info->stmt, 1), 0));\n+\t\t    tmp =\n+\t\t      create_tmp_var (TREE_TYPE\n+\t\t\t\t      (GIMPLE_STMT_OPERAND\n+\t\t\t\t       (acc_info->stmt, 0)), \"new\");\n+\t\t    add_referenced_var (tmp);\n+\t\t    stmts =\n+\t\t      fold_build2 (GIMPLE_MODIFY_STMT,\n+\t\t\t\t   TREE_TYPE (GIMPLE_STMT_OPERAND\n+\t\t\t\t\t      (acc_info->stmt, 0)), tmp,\n+\t\t\t\t   conv);\n+\t\t    tmp = make_ssa_name (tmp, stmts);\n+\t\t    GIMPLE_STMT_OPERAND (stmts, 0) = tmp;\n+\t\t    bsi = bsi_for_stmt (acc_info->stmt);\n+\t\t    bsi_insert_after (&bsi, stmts, BSI_SAME_STMT);\n+\t\t    SET_USE (use_p, tmp);\n+\t\t  }\n+\t\t}\n+\t      if (acc_info->level < min_escape_l - 1)\n+\t\tbsi_remove (&bsi, true);\n+\t    }\n+\t  free (acc_info);\n+\t  continue;\n+\t}\n+      orig = GIMPLE_STMT_OPERAND (acc_info->stmt, 1);\n+      type = TREE_TYPE (orig);\n+      if (TREE_CODE (orig) == INDIRECT_REF\n+\t  && acc_info->level < min_escape_l - 1)\n+\t{\n+\t  /* Replace the INDIRECT_REF with NOP (cast) usually we are casting\n+\t     from \"pointer to type\" to \"type\".  */\n+\t  orig =\n+\t    build1 (NOP_EXPR, TREE_TYPE (orig),\n+\t\t    GIMPLE_STMT_OPERAND (orig, 0));\n+\t  GIMPLE_STMT_OPERAND (acc_info->stmt, 1) = orig;\n+\t}\n+      else if (TREE_CODE (orig) == PLUS_EXPR\n+\t       && acc_info->level < (min_escape_l))\n+\t{\n+\t  imm_use_iterator imm_iter;\n+\t  use_operand_p use_p;\n+\n+\t  tree offset;\n+\t  int k = acc_info->level;\n+\t  tree num_elements, total_elements;\n+\t  tree tmp1;\n+\t  tree d_size = mi->dimension_size[k];\n+\n+\t  /* We already make sure in the analysis that the first operand\n+\t     is the base and the second is the offset.  */\n+\t  offset = acc_info->offset;\n+\t  if (mi->dim_map[k] == min_escape_l - 1)\n+\t    {\n+\t      if (!check_transpose_p || mi->is_transposed_p == false)\n+\t\ttmp1 = offset;\n+\t      else\n+\t\t{\n+\t\t  int x, y;\n+\t\t  tree ratio;\n+\t\t  tree new_offset;\n+\t\t  tree d_type_size, d_type_size_k;\n+\n+\t\t  d_type_size =\n+\t\t    build_int_cst (type,\n+\t\t\t\t   mi->dimension_type_size[min_escape_l]);\n+\t\t  d_type_size_k =\n+\t\t    build_int_cst (type, mi->dimension_type_size[k + 1]);\n+\t\t  x = exact_log2 (mi->dimension_type_size[min_escape_l]);\n+\t\t  y = exact_log2 (mi->dimension_type_size[k + 1]);\n+\n+\t\t  if (x != -1 && y != -1)\n+\t\t    {\n+\t\t      if (x - y == 0)\n+\t\t\tnew_offset = offset;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  tree log = build_int_cst (type, x - y);\n+\t\t\t  new_offset =\n+\t\t\t    fold_build2 (LSHIFT_EXPR, TREE_TYPE (offset),\n+\t\t\t\t\t offset, log);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      ratio =\n+\t\t\tfold_build2 (TRUNC_DIV_EXPR, type, d_type_size,\n+\t\t\t\t     d_type_size_k);\n+\t\t      new_offset =\n+\t\t\tfold_build2 (MULT_EXPR, type, offset, ratio);\n+\t\t    }\n+\t\t  total_elements = new_offset;\n+\t\t  if (new_offset != offset)\n+\t\t    {\n+\t\t      tmp1 =\n+\t\t\tforce_gimple_operand (total_elements, &stmts, true,\n+\t\t\t\t\t      NULL);\n+\t\t      if (stmts)\n+\t\t\t{\n+\t\t\t  tree_stmt_iterator tsi;\n+\n+\t\t\t  for (tsi = tsi_start (stmts); !tsi_end_p (tsi);\n+\t\t\t       tsi_next (&tsi))\n+\t\t\t    mark_symbols_for_renaming (tsi_stmt (tsi));\n+\t\t\t  bsi = bsi_for_stmt (acc_info->stmt);\n+\t\t\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    tmp1 = offset;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      d_size = mi->dimension_size[mi->dim_map[k] + 1];\n+\t      num_elements =\n+\t\tfold_build2 (MULT_EXPR, type, acc_info->index, d_size);\n+\t      tmp1 = force_gimple_operand (num_elements, &stmts, true, NULL);\n+\t      add_referenced_var (d_size);\n+\t      if (stmts)\n+\t\t{\n+\t\t  tree_stmt_iterator tsi;\n+\n+\t\t  for (tsi = tsi_start (stmts); !tsi_end_p (tsi);\n+\t\t       tsi_next (&tsi))\n+\t\t    mark_symbols_for_renaming (tsi_stmt (tsi));\n+\t\t  bsi = bsi_for_stmt (acc_info->stmt);\n+\t\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\t\t}\n+\t    }\n+\t  /* Replace the offset if needed.  */\n+\t  if (tmp1 != offset)\n+\t    {\n+\t      if (TREE_CODE (offset) == SSA_NAME)\n+\t\t{\n+\t\t  tree use_stmt;\n+\n+\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, offset)\n+\t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t    if (use_stmt == acc_info->stmt)\n+\t\t    SET_USE (use_p, tmp1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (TREE_CODE (offset) == INTEGER_CST);\n+\t\t  TREE_OPERAND (orig, 1) = tmp1;\n+\t\t}\n+\t    }\n+\t}\n+      /* ??? meanwhile this happens because we record the same access\n+         site more than once; we should be using a hash table to\n+         avoid this and insert the STMT of the access site only\n+         once.\n+         else\n+         gcc_unreachable (); */\n+      free (acc_info);\n+    }\n+  VEC_free (access_site_info_p, heap, mi->access_l);\n+\n+  update_ssa (TODO_update_ssa);\n+#ifdef ENABLE_CHECKING\n+  verify_ssa (true);\n+#endif\n+  return 1;\n+}\n+\n+/* Sort A array of counts. Arrange DIM_MAP to reflect the new order.  */\n+\n+static void\n+sort_dim_hot_level (gcov_type * a, int *dim_map, int n)\n+{\n+  int i, j, tmp1;\n+  gcov_type tmp;\n+\n+  for (i = 0; i < n - 1; i++)\n+    {\n+      for (j = 0; j < n - 1 - i; j++)\n+\t{\n+\t  if (a[j + 1] < a[j])\n+\t    {\n+\t      tmp = a[j];\t/* swap a[j] and a[j+1]      */\n+\t      a[j] = a[j + 1];\n+\t      a[j + 1] = tmp;\n+\t      tmp1 = dim_map[j];\n+\t      dim_map[j] = dim_map[j + 1];\n+\t      dim_map[j + 1] = tmp1;\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Replace multiple mallocs (one for each dimension) to one malloc\n+   with the size of DIM1*DIM2*...*DIMN*size_of_element\n+   Make sure that we hold the size in the malloc site inside a\n+   new global variable; this way we ensure that the size doesn't\n+   change and it is accessible from all the other functions that\n+   uses the matrix.  Also, the original calls to free are deleted, \n+   and replaced by a new call to free the flattened matrix.  */\n+\n+static int\n+transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+  struct matrix_info *mi;\n+  tree type, call_stmt_0, malloc_stmt, oldfn, stmts, prev_dim_size, use_stmt;\n+  struct cgraph_node *c_node;\n+  struct cgraph_edge *e;\n+  block_stmt_iterator bsi;\n+  struct malloc_call_data mcd;\n+  HOST_WIDE_INT element_size;\n+\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  tree old_size_0, tmp;\n+  int min_escape_l;\n+  int id;\n+\n+  mi = *slot;\n+\n+  min_escape_l = mi->min_indirect_level_escape;\n+\n+  if (!mi->malloc_for_level)\n+    mi->min_indirect_level_escape = 0;\n+\n+  if (mi->min_indirect_level_escape < 2)\n+    return 1;\n+\n+  mi->dim_map = (int *) xcalloc (mi->min_indirect_level_escape, sizeof (int));\n+  for (i = 0; i < mi->min_indirect_level_escape; i++)\n+    mi->dim_map[i] = i;\n+  if (check_transpose_p)\n+    {\n+      int i;\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Matrix %s:\\n\", get_name (mi->decl));\n+\t  for (i = 0; i < min_escape_l; i++)\n+\t    {\n+\t      fprintf (dump_file, \"dim %d before sort \", i);\n+\t      if (mi->dim_hot_level)\n+\t\tfprintf (dump_file,\n+\t\t\t \"count is  \" HOST_WIDEST_INT_PRINT_DEC \"  \\n\",\n+\t\t\t mi->dim_hot_level[i]);\n+\t    }\n+\t}\n+      sort_dim_hot_level (mi->dim_hot_level, mi->dim_map,\n+\t\t\t  mi->min_indirect_level_escape);\n+      if (dump_file)\n+\tfor (i = 0; i < min_escape_l; i++)\n+\t  {\n+\t    fprintf (dump_file, \"dim %d after sort\\n\", i);\n+\t    if (mi->dim_hot_level)\n+\t      fprintf (dump_file, \"count is  \" HOST_WIDE_INT_PRINT_DEC\n+\t\t       \"  \\n\", (HOST_WIDE_INT) mi->dim_hot_level[i]);\n+\t  }\n+      for (i = 0; i < mi->min_indirect_level_escape; i++)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"dim_map[%d] after sort %d\\n\", i,\n+\t\t     mi->dim_map[i]);\n+\t  if (mi->dim_map[i] != i)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Transposed dimensions: dim %d is now dim %d\\n\",\n+\t\t\t mi->dim_map[i], i);\n+\t      mi->is_transposed_p = true;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 0; i < mi->min_indirect_level_escape; i++)\n+\tmi->dim_map[i] = i;\n+    }\n+  /* Call statement of allocation site of level 0.  */\n+  call_stmt_0 = mi->malloc_for_level[0];\n+\n+  /* Finds the correct malloc information.  */\n+  collect_data_for_malloc_call (call_stmt_0, &mcd);\n+\n+  mi->dimension_size[0] = mcd.size_var;\n+  mi->dimension_size_orig[0] = mcd.size_var;\n+  /* Make sure that the variables in the size expression for\n+     all the dimensions (above level 0) aren't modified in\n+     the allocation function.  */\n+  for (i = 1; i < mi->min_indirect_level_escape; i++)\n+    {\n+      tree t;\n+\n+      /* mi->dimension_size must contain the expression of the size calculated\n+         in check_allocation_function.  */\n+      gcc_assert (mi->dimension_size[i]);\n+\n+      t = walk_tree_without_duplicates (&(mi->dimension_size[i]),\n+\t\t\t\t\tcheck_var_notmodified_p,\n+\t\t\t\t\tmi->allocation_function_decl);\n+      if (t != NULL_TREE)\n+\t{\n+\t  mark_min_matrix_escape_level (mi, i, t);\n+\t  break;\n+\t}\n+    }\n+\n+  if (mi->min_indirect_level_escape < 2)\n+    return 1;\n+\n+  /* Since we should make sure that the size expression is available\n+     before the call to malloc of level 0.  */\n+  bsi = bsi_for_stmt (call_stmt_0);\n+\n+  /* Find out the size of each dimension by looking at the malloc\n+     sites and create a global variable to hold it.\n+     We add the assignment to the global before the malloc of level 0.  */\n+\n+  /* To be able to produce gimple temporaries.  */\n+  oldfn = current_function_decl;\n+  current_function_decl = mi->allocation_function_decl;\n+  cfun = DECL_STRUCT_FUNCTION (mi->allocation_function_decl);\n+\n+  /* Set the dimension sizes as follows:\n+     DIM_SIZE[i] = DIM_SIZE[n] * ... * DIM_SIZE[i]\n+     where n is the maximum non escaping level.  */\n+  element_size = mi->dimension_type_size[mi->min_indirect_level_escape];\n+  prev_dim_size = NULL_TREE;\n+\n+  for (i = mi->min_indirect_level_escape - 1; i >= 0; i--)\n+    {\n+      tree dim_size, dim_var, tmp;\n+      tree d_type_size;\n+      tree_stmt_iterator tsi;\n+\n+      /* Now put the size expression in a global variable and initialize it to\n+         the size expression before the malloc of level 0.  */\n+      dim_var =\n+\tadd_new_static_var (TREE_TYPE\n+\t\t\t    (mi->dimension_size_orig[mi->dim_map[i]]));\n+      type = TREE_TYPE (mi->dimension_size_orig[mi->dim_map[i]]);\n+      d_type_size =\n+\tbuild_int_cst (type, mi->dimension_type_size[mi->dim_map[i] + 1]);\n+\n+      /* DIM_SIZE = MALLOC_SIZE_PARAM / TYPE_SIZE.  */\n+      /* Find which dim ID becomes dim I.  */\n+      for (id = 0; id < mi->min_indirect_level_escape; id++)\n+\tif (mi->dim_map[id] == i)\n+\t  break;\n+      if (!prev_dim_size)\n+\tprev_dim_size = build_int_cst (type, element_size);\n+      if (!check_transpose_p && i == mi->min_indirect_level_escape - 1)\n+\t{\n+\t  dim_size = mi->dimension_size_orig[id];\n+\t}\n+      else\n+\t{\n+\t  dim_size =\n+\t    fold_build2 (TRUNC_DIV_EXPR, type, mi->dimension_size_orig[id],\n+\t\t\t d_type_size);\n+\n+\t  dim_size = fold_build2 (MULT_EXPR, type, dim_size, prev_dim_size);\n+\t}\n+      dim_size = force_gimple_operand (dim_size, &stmts, true, NULL);\n+      if (stmts)\n+\t{\n+\t  for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n+\t    mark_symbols_for_renaming (tsi_stmt (tsi));\n+\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\t  bsi = bsi_for_stmt (call_stmt_0);\n+\t}\n+      /* GLOBAL_HOLDING_THE_SIZE = DIM_SIZE.  */\n+      tmp = fold_build2 (GIMPLE_MODIFY_STMT, type, dim_var, dim_size);\n+      GIMPLE_STMT_OPERAND (tmp, 0) = dim_var;\n+      mark_symbols_for_renaming (tmp);\n+      bsi_insert_before (&bsi, tmp, BSI_NEW_STMT);\n+      bsi = bsi_for_stmt (call_stmt_0);\n+\n+      prev_dim_size = mi->dimension_size[i] = dim_var;\n+    }\n+  update_ssa (TODO_update_ssa);\n+  /* Replace the malloc size argument in the malloc of level 0 to be\n+     the size of all the dimensions.  */\n+  malloc_stmt = GIMPLE_STMT_OPERAND (call_stmt_0, 1);\n+  c_node = cgraph_node (mi->allocation_function_decl);\n+  old_size_0 = CALL_EXPR_ARG (malloc_stmt, 0);\n+  bsi = bsi_for_stmt (call_stmt_0);\n+  tmp = force_gimple_operand (mi->dimension_size[0], &stmts, true, NULL);\n+  if (stmts)\n+    {\n+      tree_stmt_iterator tsi;\n+\n+      for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n+\tmark_symbols_for_renaming (tsi_stmt (tsi));\n+      bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+      bsi = bsi_for_stmt (call_stmt_0);\n+    }\n+  if (TREE_CODE (old_size_0) == SSA_NAME)\n+    {\n+      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, old_size_0)\n+\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\tif (use_stmt == call_stmt_0)\n+\tSET_USE (use_p, tmp);\n+    }\n+  /* When deleting the calls to malloc we need also to remove the edge from\n+     the call graph to keep it consistent.  Notice that cgraph_edge may\n+     create a new node in the call graph if there is no node for the given\n+     declaration; this shouldn't be the case but currently there is no way to\n+     check this outside of \"cgraph.c\".  */\n+  for (i = 1; i < mi->min_indirect_level_escape; i++)\n+    {\n+      block_stmt_iterator bsi;\n+      tree use_stmt1 = NULL;\n+      tree call;\n+\n+      tree call_stmt = mi->malloc_for_level[i];\n+      call = GIMPLE_STMT_OPERAND (call_stmt, 1);\n+      gcc_assert (TREE_CODE (call) == CALL_EXPR);\n+      e = cgraph_edge (c_node, call_stmt);\n+      gcc_assert (e);\n+      cgraph_remove_edge (e);\n+      bsi = bsi_for_stmt (call_stmt);\n+      /* Remove the call stmt.  */\n+      bsi_remove (&bsi, true);\n+      /* remove the type cast stmt.  */\n+      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n+\t\t\t     GIMPLE_STMT_OPERAND (call_stmt, 0))\n+      {\n+\tuse_stmt1 = use_stmt;\n+\tbsi = bsi_for_stmt (use_stmt);\n+\tbsi_remove (&bsi, true);\n+      }\n+      /* Remove the assignment of the allocated area.  */\n+      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n+\t\t\t     GIMPLE_STMT_OPERAND (use_stmt1, 0))\n+      {\n+\tbsi = bsi_for_stmt (use_stmt);\n+\tbsi_remove (&bsi, true);\n+      }\n+    }\n+  update_ssa (TODO_update_ssa);\n+#ifdef ENABLE_CHECKING\n+  verify_ssa (true);\n+#endif\n+  /* Delete the calls to free.  */\n+  for (i = 1; i < mi->min_indirect_level_escape; i++)\n+    {\n+      block_stmt_iterator bsi;\n+      tree call;\n+\n+      /* ??? wonder why this case is possible but we failed on it once.  */\n+      if (!mi->free_stmts[i].stmt)\n+\tcontinue;\n+\n+      call = TREE_OPERAND (mi->free_stmts[i].stmt, 1);\n+      c_node = cgraph_node (mi->free_stmts[i].func);\n+\n+      gcc_assert (TREE_CODE (mi->free_stmts[i].stmt) == CALL_EXPR);\n+      e = cgraph_edge (c_node, mi->free_stmts[i].stmt);\n+      gcc_assert (e);\n+      cgraph_remove_edge (e);\n+      current_function_decl = mi->free_stmts[i].func;\n+      cfun = DECL_STRUCT_FUNCTION (mi->free_stmts[i].func);\n+      bsi = bsi_for_stmt (mi->free_stmts[i].stmt);\n+      bsi_remove (&bsi, true);\n+    }\n+  /* Return to the previous situation.  */\n+  current_function_decl = oldfn;\n+  cfun = oldfn ? DECL_STRUCT_FUNCTION (oldfn) : NULL;\n+  return 1;\n+\n+}\n+\n+\n+/* Print out the results of the escape analysis.  */\n+static int\n+dump_matrix_reorg_analysis (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  struct matrix_info *mi = *slot;\n+\n+  if (!dump_file)\n+    return 1;\n+  fprintf (dump_file, \"Matrix \\\"%s\\\"; Escaping Level: %d, Num Dims: %d,\",\n+\t   get_name (mi->decl), mi->min_indirect_level_escape, mi->num_dims);\n+  fprintf (dump_file, \" Malloc Dims: %d, \", mi->max_malloced_level);\n+  fprintf (dump_file, \"\\n\");\n+  if (mi->min_indirect_level_escape >= 2)\n+    fprintf (dump_file, \"Flattened %d dimensions \\n\",\n+\t     mi->min_indirect_level_escape);\n+  return 1;\n+}\n+\n+\n+/* Perform matrix flattening.  */\n+\n+static unsigned int\n+matrix_reorg (void)\n+{\n+  struct cgraph_node *node;\n+\n+  if (profile_info)\n+    check_transpose_p = true;\n+  else\n+    check_transpose_p = false;\n+  /* If there are hand written vectors, we skip this optimization.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (!may_flatten_matrices (node))\n+      return 0;\n+  matrices_to_reorg = htab_create (37, mtt_info_hash, mtt_info_eq, mat_free);\n+  /* Find and record all potential matrices in the program.  */\n+  find_matrices_decl ();\n+  /* Analyze the accesses of the matrices (escaping analysis).  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed)\n+      {\n+\ttree temp_fn;\n+\n+\ttemp_fn = current_function_decl;\n+\tcurrent_function_decl = node->decl;\n+\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\tbitmap_obstack_initialize (NULL);\n+\ttree_register_cfg_hooks ();\n+\n+\tif (!gimple_in_ssa_p (cfun))\n+\t  {\n+\t    free_dominance_info (CDI_DOMINATORS);\n+\t    free_dominance_info (CDI_POST_DOMINATORS);\n+\t    pop_cfun ();\n+\t    current_function_decl = temp_fn;\n+\n+\t    return 0;\n+\t  }\n+\n+#ifdef ENABLE_CHECKING\n+\tverify_flow_info ();\n+#endif\n+\n+\tif (!matrices_to_reorg)\n+\t  {\n+\t    free_dominance_info (CDI_DOMINATORS);\n+\t    free_dominance_info (CDI_POST_DOMINATORS);\n+\t    pop_cfun ();\n+\t    current_function_decl = temp_fn;\n+\n+\t    return 0;\n+\t  }\n+\n+\t/* Create htap for phi nodes.  */\n+\thtab_mat_acc_phi_nodes = htab_create (37, mat_acc_phi_hash,\n+\t\t\t\t\t      mat_acc_phi_eq, free);\n+\tif (!check_transpose_p)\n+\t  find_sites_in_func (false);\n+\telse\n+\t  {\n+\t    find_sites_in_func (true);\n+\t    loop_optimizer_init (LOOPS_NORMAL);\n+\t    if (current_loops)\n+\t      scev_initialize ();\n+\t    htab_traverse (matrices_to_reorg, analyze_transpose, NULL);\n+\t    if (current_loops)\n+\t      {\n+\t\tscev_finalize ();\n+\t\tloop_optimizer_finalize ();\n+\t\tcurrent_loops = NULL;\n+\t      }\n+\t  }\n+\t/* If the current function is the allocation function for any of\n+\t   the matrices we check its allocation and the escaping level.  */\n+\thtab_traverse (matrices_to_reorg, check_allocation_function, NULL);\n+\tfree_dominance_info (CDI_DOMINATORS);\n+\tfree_dominance_info (CDI_POST_DOMINATORS);\n+\tpop_cfun ();\n+\tcurrent_function_decl = temp_fn;\n+      }\n+  htab_traverse (matrices_to_reorg, transform_allocation_sites, NULL);\n+  /* Now transform the accesses.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed)\n+      {\n+\t/* Remember that allocation sites have been handled.  */\n+\ttree temp_fn;\n+\n+\ttemp_fn = current_function_decl;\n+\tcurrent_function_decl = node->decl;\n+\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\tbitmap_obstack_initialize (NULL);\n+\ttree_register_cfg_hooks ();\n+\trecord_all_accesses_in_func ();\n+\thtab_traverse (matrices_to_reorg, transform_access_sites, NULL);\n+\tfree_dominance_info (CDI_DOMINATORS);\n+\tfree_dominance_info (CDI_POST_DOMINATORS);\n+\tpop_cfun ();\n+\tcurrent_function_decl = temp_fn;\n+      }\n+  htab_traverse (matrices_to_reorg, dump_matrix_reorg_analysis, NULL);\n+\n+  current_function_decl = NULL;\n+  cfun = NULL;\n+  matrices_to_reorg = NULL;\n+  return 0;\n+}\n+\n+\n+/* The condition for matrix flattening to be performed.  */\n+static bool\n+gate_matrix_reorg (void)\n+{\n+  return flag_ipa_matrix_reorg /*&& flag_whole_program */ ;\n+}\n+\n+struct tree_opt_pass pass_ipa_matrix_reorg = {\n+  \"matrix-reorg\",\t\t/* name */\n+  gate_matrix_reorg,\t\t/* gate */\n+  matrix_reorg,\t\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t/* properties_required */\n+  PROP_trees,\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */\n+  0\t\t\t\t/* letter */\n+};"}, {"sha": "f50b7a565b0874528de539a21bfa02739272c614", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -506,6 +506,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_inline_parameters);\n     }\n   NEXT_PASS (pass_ipa_increase_alignment);\n+  NEXT_PASS (pass_ipa_matrix_reorg);\n   NEXT_PASS (pass_ipa_cp);\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_reference);"}, {"sha": "39b6bec7ef33682cdf29fdf8bc004ebe8b6e5020", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -316,6 +316,7 @@ extern struct tree_opt_pass pass_build_cgraph_edges;\n extern struct tree_opt_pass pass_reset_cc_flags;\n \n /* IPA Passes */\n+extern struct tree_opt_pass pass_ipa_matrix_reorg;\n extern struct tree_opt_pass pass_ipa_cp;\n extern struct tree_opt_pass pass_ipa_inline;\n extern struct tree_opt_pass pass_ipa_early_inline;"}, {"sha": "17327260d5e8ac652b0cb1c201d5a570f7cd0671", "filename": "gcc/varpool.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=43d861a5bc03c1c9ed1dde4ca7bf1593771d7e6e", "patch": "@@ -33,6 +33,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"debug.h\" \n #include \"target.h\"\n #include \"output.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-flow.h\"\n \n /*  This file contains basic routines manipulating variable pool.\n \n@@ -459,4 +461,28 @@ varpool_output_debug_info (void)\n   timevar_pop (TV_SYMOUT);\n }\n \n+/* Create a new global variable of type TYPE.  */\n+tree\n+add_new_static_var (tree type)\n+{\n+  tree new_decl;\n+  struct varpool_node *new_node;\n+\n+  new_decl = create_tmp_var (type, NULL);\n+  DECL_NAME (new_decl) = create_tmp_var_name (NULL);\n+  TREE_READONLY (new_decl) = 0;\n+  TREE_STATIC (new_decl) = 1;\n+  TREE_USED (new_decl) = 1;\n+  DECL_CONTEXT (new_decl) = NULL_TREE;\n+  DECL_ABSTRACT (new_decl) = 0;\n+  lang_hooks.dup_lang_specific_decl (new_decl);\n+  create_var_ann (new_decl);\n+  new_node = varpool_node (new_decl);\n+  varpool_mark_needed_node (new_node);\n+  add_referenced_var (new_decl);\n+  varpool_finalize_decl (new_decl);\n+\n+  return new_node->decl;\n+}\n+\n #include \"gt-varpool.h\""}]}