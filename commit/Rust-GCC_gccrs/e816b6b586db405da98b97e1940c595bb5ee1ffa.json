{"sha": "e816b6b586db405da98b97e1940c595bb5ee1ffa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgxNmI2YjU4NmRiNDA1ZGE5OGI5N2UxOTQwYzU5NWJiNWVlMWZmYQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2008-07-24T03:59:55Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2008-07-24T03:59:55Z"}, "message": "spu-c.c (__vector_keyword): New variable.\n\ngcc/\n\t* config/spu/spu-c.c (__vector_keyword): New variable.\n\t(vector_keyword): Likewise.\n\t(spu_categorize_keyword): New function.\n\t(spu_macro_to_expand): Likewise.\n\t(spu_cpu_cpp_builtins): Enable context-sensitive macros if not\n\tcompiling an ISO C dialect.\n\ngcc/testsuite/\n\t* gcc.target/spu/vector.c: New test.\n\t* gcc.target/spu/vector-ansi.c: Likewise.\n\nFrom-SVN: r138106", "tree": {"sha": "48cf2d5103777938fb9f99fcc76afd222ecdf400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48cf2d5103777938fb9f99fcc76afd222ecdf400"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e816b6b586db405da98b97e1940c595bb5ee1ffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e816b6b586db405da98b97e1940c595bb5ee1ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e816b6b586db405da98b97e1940c595bb5ee1ffa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e816b6b586db405da98b97e1940c595bb5ee1ffa/comments", "author": null, "committer": null, "parents": [{"sha": "ce26ee21273d142d14a55bdd71a0c38875f4f052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce26ee21273d142d14a55bdd71a0c38875f4f052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce26ee21273d142d14a55bdd71a0c38875f4f052"}], "stats": {"total": 155, "additions": 155, "deletions": 0}, "files": [{"sha": "82c7e61e39c06107c66a509e55b8cd01231b18c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e816b6b586db405da98b97e1940c595bb5ee1ffa", "patch": "@@ -1,3 +1,12 @@\n+2008-07-24  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* config/spu/spu-c.c (__vector_keyword): New variable.\n+\t(vector_keyword): Likewise.\n+\t(spu_categorize_keyword): New function.\n+\t(spu_macro_to_expand): Likewise.\n+\t(spu_cpu_cpp_builtins): Enable context-sensitive macros if not\n+\tcompiling an ISO C dialect.\n+\n 2008-07-24  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/rs6000/rs6000-c.c: Move GTY(()) markers to match"}, {"sha": "96fe43e6e9416faa91f829d06e8c6bda3d980385", "filename": "gcc/config/spu/spu-c.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Fconfig%2Fspu%2Fspu-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Fconfig%2Fspu%2Fspu-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-c.c?ref=e816b6b586db405da98b97e1940c595bb5ee1ffa", "patch": "@@ -35,6 +35,64 @@\n #include \"spu-builtins.h\"\n \f\n \n+/* Keep the vector keywords handy for fast comparisons.  */\n+static GTY(()) tree __vector_keyword;\n+static GTY(()) tree vector_keyword;\n+\n+static cpp_hashnode *\n+spu_categorize_keyword (const cpp_token *tok)\n+{\n+  if (tok->type == CPP_NAME)\n+    {\n+      cpp_hashnode *ident = tok->val.node;\n+\n+      if (ident == C_CPP_HASHNODE (vector_keyword)\n+\t  || ident == C_CPP_HASHNODE (__vector_keyword))\n+\treturn C_CPP_HASHNODE (__vector_keyword);\n+      else\n+\treturn ident;\n+    }\n+  return 0;\n+}\n+\n+/* Called to decide whether a conditional macro should be expanded.\n+   Since we have exactly one such macro (i.e, 'vector'), we do not\n+   need to examine the 'tok' parameter.  */\n+\n+static cpp_hashnode *\n+spu_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n+{\n+  cpp_hashnode *expand_this = tok->val.node;\n+  cpp_hashnode *ident;\n+\n+  ident = spu_categorize_keyword (tok);\n+  if (ident == C_CPP_HASHNODE (__vector_keyword))\n+    {\n+      tok = cpp_peek_token (pfile, 0);\n+      ident = spu_categorize_keyword (tok);\n+\n+      if (ident)\n+\t{\n+\t  enum rid rid_code = (enum rid)(ident->rid_code);\n+\t  if (ident->type == NT_MACRO)\n+\t    {\n+\t      (void) cpp_get_token (pfile);\n+\t      tok = cpp_peek_token (pfile, 0);\n+\t      ident = spu_categorize_keyword (tok);\n+\t      if (ident)\n+\t\trid_code = (enum rid)(ident->rid_code);\n+\t    }\n+\t  \n+\t  if (rid_code == RID_UNSIGNED || rid_code == RID_LONG\n+\t      || rid_code == RID_SHORT || rid_code == RID_SIGNED\n+\t      || rid_code == RID_INT || rid_code == RID_CHAR\n+\t      || rid_code == RID_FLOAT || rid_code == RID_DOUBLE)\n+\t    expand_this = C_CPP_HASHNODE (__vector_keyword);\n+\t}\n+    }\n+  return expand_this;\n+}\n+\n /* target hook for resolve_overloaded_builtin(). Returns a function call\n    RTX if we can resolve the overloaded builtin */\n tree\n@@ -140,6 +198,22 @@ spu_cpu_cpp_builtins (struct cpp_reader *pfile)\n   if (spu_arch == PROCESSOR_CELLEDP)\n     builtin_define_std (\"__SPU_EDP__\");\n   builtin_define_std (\"__vector=__attribute__((__spu_vector__))\");\n+\n+  if (!flag_iso)\n+    {\n+      /* Define this when supporting context-sensitive keywords.  */\n+      cpp_define (pfile, \"__VECTOR_KEYWORD_SUPPORTED__\");\n+      cpp_define (pfile, \"vector=vector\");\n+\n+      /* Initialize vector keywords.  */\n+      __vector_keyword = get_identifier (\"__vector\");\n+      C_CPP_HASHNODE (__vector_keyword)->flags |= NODE_CONDITIONAL;\n+      vector_keyword = get_identifier (\"vector\");\n+      C_CPP_HASHNODE (vector_keyword)->flags |= NODE_CONDITIONAL;\n+\n+      /* Enable context-sensitive macros.  */\n+      cpp_get_callbacks (pfile)->macro_to_expand = spu_macro_to_expand;\n+    }\n }\n \n void"}, {"sha": "5be864f133fcef942fb1c436a4778c2d8679d3a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e816b6b586db405da98b97e1940c595bb5ee1ffa", "patch": "@@ -1,3 +1,8 @@\n+2008-07-24  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* gcc.target/spu/vector.c: New test.\n+\t* gcc.target/spu/vector-ansi.c: Likewise.\n+\n 2008-07-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR 35058"}, {"sha": "3c086169947e7e2ab23bfc5e247636ccaf5d42a9", "filename": "gcc/testsuite/gcc.target/spu/vector-ansi.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector-ansi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector-ansi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector-ansi.c?ref=e816b6b586db405da98b97e1940c595bb5ee1ffa", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-ansi\" } */\n+\n+/* This is done by spu_internals.h, but we not include it here to keep\n+   down the dependencies.  */\n+\n+#ifndef __VECTOR_KEYWORD_SUPPORTED__\n+#define vector __vector\n+#endif\n+\n+/* __vector is expanded unconditionally by the preprocessor.  */\n+__vector int vi;\n+__vector unsigned char vuc;\n+__vector signed char vsc;\n+__vector unsigned short vus;\n+__vector signed short vss;\n+__vector unsigned int vui;\n+__vector signed int vsi;\n+__vector unsigned long long ull;\n+__vector signed long long sll;\n+__vector float vf;\n+__vector double vd;\n+\n+/* vector is expanded by the define above, regardless of context.  */\n+vector int vi;\n+vector unsigned char vuc;\n+vector signed char vsc;\n+vector unsigned short vus;\n+vector signed short vss;\n+vector unsigned int vui;\n+vector signed int vsi;\n+vector unsigned long long ull;\n+vector signed long long sll;\n+vector float vf;\n+vector double vd;"}, {"sha": "237f93b7e58e7c87e153d329c405bc4b529039e0", "filename": "gcc/testsuite/gcc.target/spu/vector.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e816b6b586db405da98b97e1940c595bb5ee1ffa/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fvector.c?ref=e816b6b586db405da98b97e1940c595bb5ee1ffa", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+#ifndef __VECTOR_KEYWORD_SUPPORTED__\n+#error __VECTOR_KEYWORD_SUPPORTED__ is not defined\n+#endif\n+\n+/* __vector is expanded unconditionally.  */\n+__vector int vi;\n+__vector unsigned char vuc;\n+__vector signed char vsc;\n+__vector unsigned short vus;\n+__vector signed short vss;\n+__vector unsigned int vui;\n+__vector signed int vsi;\n+__vector unsigned long long ull;\n+__vector signed long long sll;\n+__vector float vf;\n+__vector double vd;\n+\n+/* vector is expanded conditionally, based on the context.  */\n+vector int vi;\n+vector unsigned char vuc;\n+vector signed char vsc;\n+vector unsigned short vus;\n+vector signed short vss;\n+vector unsigned int vui;\n+vector signed int vsi;\n+vector unsigned long long ull;\n+vector signed long long sll;\n+vector float vf;\n+vector double vd;"}]}