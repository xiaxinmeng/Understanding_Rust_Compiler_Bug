{"sha": "d206399a97bc0111cff30c66c535ce0884228b77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIwNjM5OWE5N2JjMDExMWNmZjMwYzY2YzUzNWNlMDg4NDIyOGI3Nw==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-06-09T14:29:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-09T12:35:31Z"}, "message": "[Ada] Improve performance of Ada.Containers.Doubly_Linked_Lists.Generic_Sorting.Sort\n\ngcc/ada/\n\n\t* libgnat/a-cdlili.adb: Reimplement\n\tAda.Containers.Doubly_Linked_Lists.Generic_Sorting.Sort using\n\tMergesort instead of the previous Quicksort variant.", "tree": {"sha": "6cec71cce62a9586daab3935fb424a84592b2f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cec71cce62a9586daab3935fb424a84592b2f27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d206399a97bc0111cff30c66c535ce0884228b77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d206399a97bc0111cff30c66c535ce0884228b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d206399a97bc0111cff30c66c535ce0884228b77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d206399a97bc0111cff30c66c535ce0884228b77/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66d43665bc9c8a8f38531a8b9a02cfcfe129cc88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d43665bc9c8a8f38531a8b9a02cfcfe129cc88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d43665bc9c8a8f38531a8b9a02cfcfe129cc88"}], "stats": {"total": 219, "additions": 161, "deletions": 58}, "files": [{"sha": "d98975113063078e8241ac305883a843bc8e0209", "filename": "gcc/ada/libgnat/a-cdlili.adb", "status": "modified", "additions": 161, "deletions": 58, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d206399a97bc0111cff30c66c535ce0884228b77/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d206399a97bc0111cff30c66c535ce0884228b77/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb?ref=d206399a97bc0111cff30c66c535ce0884228b77", "patch": "@@ -675,68 +675,152 @@ is\n \n       procedure Sort (Container : in out List) is\n \n-         procedure Partition (Pivot : Node_Access; Back : Node_Access);\n-\n-         procedure Sort (Front, Back : Node_Access);\n-\n-         ---------------\n-         -- Partition --\n-         ---------------\n+         type List_Descriptor is\n+            record\n+               First, Last : Node_Access;\n+               Length      : Count_Type;\n+            end record;\n+\n+         function Merge_Sort (Arg : List_Descriptor) return List_Descriptor;\n+         --  Sort list of given length using MergeSort; length must be >= 2.\n+         --  As required by RM, the sort is stable.\n+\n+         ----------------\n+         -- Merge_Sort --\n+         ----------------\n+\n+         function Merge_Sort (Arg : List_Descriptor) return List_Descriptor\n+         is\n+            procedure Split_List\n+              (Unsplit : List_Descriptor; Part1, Part2 : out List_Descriptor);\n+            --  Split list into two parts for divide-and-conquer.\n+            --  Unsplit.Length must be >= 2.\n+\n+            function Merge_Parts\n+              (Part1, Part2 : List_Descriptor) return List_Descriptor;\n+            --  Merge two sorted lists, preserving sorted property.\n+\n+            ----------------\n+            -- Split_List --\n+            ----------------\n+\n+            procedure Split_List\n+              (Unsplit : List_Descriptor; Part1, Part2 : out List_Descriptor)\n+            is\n+               Rover : Node_Access := Unsplit.First;\n+               Bump_Count : constant Count_Type := (Unsplit.Length - 1) / 2;\n+            begin\n+               for Iter in 1 .. Bump_Count loop\n+                  Rover := Rover.Next;\n+               end loop;\n+\n+               Part1 := (First  => Unsplit.First,\n+                         Last   => Rover,\n+                         Length => Bump_Count + 1);\n+\n+               Part2 := (First => Rover.Next,\n+                         Last  => Unsplit.Last,\n+                         Length => Unsplit.Length - Part1.Length);\n+\n+               --  Detach\n+               Part1.Last.Next := null;\n+               Part2.First.Prev := null;\n+            end Split_List;\n+\n+            -----------------\n+            -- Merge_Parts --\n+            -----------------\n+\n+            function Merge_Parts\n+              (Part1, Part2 : List_Descriptor) return List_Descriptor\n+            is\n+               Empty  : constant List_Descriptor := (null, null, 0);\n+\n+               procedure Detach_First (Source   : in out List_Descriptor;\n+                                       Detached : out Node_Access);\n+               --  Detach the first element from a non-empty list and\n+               --  return the detached node via the Detached parameter.\n+\n+               ------------------\n+               -- Detach_First --\n+               ------------------\n+\n+               procedure Detach_First (Source   : in out List_Descriptor;\n+                                       Detached : out Node_Access) is\n+               begin\n+                  Detached := Source.First;\n+\n+                  if Source.Length = 1 then\n+                     Source := Empty;\n+                  else\n+                     Source := (Source.First.Next,\n+                                Source.Last,\n+                                Source.Length - 1);\n+\n+                     Detached.Next.Prev := null;\n+                     Detached.Next := null;\n+                  end if;\n+               end Detach_First;\n+\n+               P1     : List_Descriptor := Part1;\n+               P2     : List_Descriptor := Part2;\n+               Merged : List_Descriptor := Empty;\n+\n+               Take_From_P2 : Boolean;\n+               Detached     : Node_Access;\n+\n+            --  Start of processing for Merge_Parts\n \n-         procedure Partition (Pivot : Node_Access; Back : Node_Access) is\n-            Node : Node_Access;\n+            begin\n+               while (P1.Length /= 0) or (P2.Length /= 0) loop\n+                  if P1.Length = 0 then\n+                     Take_From_P2 := True;\n+                  elsif P2.Length = 0 then\n+                     Take_From_P2 := False;\n+                  else\n+                     --  If the compared elements are equal then Take_From_P2\n+                     --  must be False in order to ensure stability.\n+\n+                     Take_From_P2 := P2.First.Element < P1.First.Element;\n+                  end if;\n+\n+                  if Take_From_P2 then\n+                     Detach_First (P2, Detached);\n+                  else\n+                     Detach_First (P1, Detached);\n+                  end if;\n+\n+                  if Merged.Length = 0 then\n+                     Merged := (First | Last => Detached, Length => 1);\n+                  else\n+                     Detached.Prev := Merged.Last;\n+                     Merged.Last.Next := Detached;\n+                     Merged.Last := Detached;\n+                     Merged.Length := Merged.Length + 1;\n+                  end if;\n+               end loop;\n+               return Merged;\n+            end Merge_Parts;\n+\n+         --  Start of processing for Merge_Sort\n \n          begin\n-            Node := Pivot.Next;\n-            while Node /= Back loop\n-               if Node.Element < Pivot.Element then\n-                  declare\n-                     Prev : constant Node_Access := Node.Prev;\n-                     Next : constant Node_Access := Node.Next;\n-\n-                  begin\n-                     Prev.Next := Next;\n-\n-                     if Next = null then\n-                        Container.Last := Prev;\n-                     else\n-                        Next.Prev := Prev;\n-                     end if;\n-\n-                     Node.Next := Pivot;\n-                     Node.Prev := Pivot.Prev;\n-\n-                     Pivot.Prev := Node;\n-\n-                     if Node.Prev = null then\n-                        Container.First := Node;\n-                     else\n-                        Node.Prev.Next := Node;\n-                     end if;\n-\n-                     Node := Next;\n-                  end;\n+            if Arg.Length < 2 then\n+               --  already sorted\n+               return Arg;\n+            end if;\n \n-               else\n-                  Node := Node.Next;\n-               end if;\n-            end loop;\n-         end Partition;\n+            declare\n+               Part1, Part2 : List_Descriptor;\n+            begin\n+               Split_List (Unsplit => Arg, Part1 => Part1, Part2 => Part2);\n \n-         ----------\n-         -- Sort --\n-         ----------\n+               Part1 := Merge_Sort (Part1);\n+               Part2 := Merge_Sort (Part2);\n \n-         procedure Sort (Front, Back : Node_Access) is\n-            Pivot : constant Node_Access :=\n-              (if Front = null then Container.First else Front.Next);\n-         begin\n-            if Pivot /= Back then\n-               Partition (Pivot, Back);\n-               Sort (Front, Pivot);\n-               Sort (Pivot, Back);\n-            end if;\n-         end Sort;\n+               return Merge_Parts (Part1, Part2);\n+            end;\n+         end Merge_Sort;\n \n       --  Start of processing for Sort\n \n@@ -754,9 +838,28 @@ is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            Lock : With_Lock (Container.TC'Unchecked_Access);\n+            Lock     : With_Lock (Container.TC'Unchecked_Access);\n+\n+            Unsorted : constant List_Descriptor :=\n+                                  (First  => Container.First,\n+                                   Last   => Container.Last,\n+                                   Length => Container.Length);\n+\n+            Sorted   : List_Descriptor;\n          begin\n-            Sort (Front => null, Back => null);\n+            --  If a call to the formal < operator references the container\n+            --  during sorting, seeing an empty container seems preferable\n+            --  to seeing an internally inconsistent container.\n+            --\n+            Container.First  := null;\n+            Container.Last   := null;\n+            Container.Length := 0;\n+\n+            Sorted := Merge_Sort (Unsorted);\n+\n+            Container.First  := Sorted.First;\n+            Container.Last   := Sorted.Last;\n+            Container.Length := Sorted.Length;\n          end;\n \n          pragma Assert (Container.First.Prev = null);"}]}