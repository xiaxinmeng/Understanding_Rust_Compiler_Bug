{"sha": "05350ac648924d81ebd552d045da2dfe71b72e24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUzNTBhYzY0ODkyNGQ4MWViZDU1MmQwNDVkYTJkZmU3MWI3MmUyNA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2006-10-31T17:57:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:57:36Z"}, "message": "exp_ch7.adb (Build_Array_Deep_Procs, [...]): Rename Is_Return_By_Reference_Type to be Is_Inherently_Limited_Type...\n\n2006-10-31  Bob Duff  <duff@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch7.adb (Build_Array_Deep_Procs, Build_Record_Deep_Procs,\n\tMake_Deep_Record_Body): Rename Is_Return_By_Reference_Type to be\n\tIs_Inherently_Limited_Type, because return-by-reference has no meaning\n\tin Ada 2005.\n\t(Find_Node_To_Be_Wrapped): Use new method of determining the result\n\ttype of the function containing a return statement, because the\n\tReturn_Type field was removed. We now use the Return_Applies_To field.\n\n        * exp_util.ads, exp_util.adb: Use new subtype N_Membership_Test\n\t(Build_Task_Image_Decl): If procedure is not called from an\n\tinitialization procedure, indicate that function that builds task name\n\tuses the sec. stack. Otherwise the enclosing initialization procedure\n\twill carry the indication.\n\t(Insert_Actions): Remove N_Return_Object_Declaration. We now use\n\tN_Object_Declaration instead.\n\t(Kill_Dead_Code): New interface to implement -gnatwt warning for\n\tconditional dead code killed, and change implementation accordingly.\n\t(Insert_Actions): Add N_Return_Object_Declaration case.\n\tCorrect comment to mention N_Extension_Aggregate node.\n\t(Set_Current_Value_Condition): Call Safe_To_Capture_Value to avoid bad\n\tattempts to save information for global variables which cannot be\n\tsafely tracked.\n\t(Get_Current_Value_Condition): Handle conditions the other way round\n\t(constant on left). Also handle right operand of AND and AND THEN\n\t(Set_Current_Value_Condition): Corresponding changes\n\t(Append_Freeze_Action): Remove unnecessary initialization of Fnode.\n\t(Get_Current_Value_Condition): Handle simple boolean operands\n\t(Get_Current_Value_Condition): Handle left operand of AND or AND THEN\n\t(Get_Current_Value_Condition): If the variable reference is within an\n\tif-statement, does not appear in the list of then_statments, and does\n\tnot come from source, treat it as being at unknown location.\n\t(Get_Current_Value_Condition): Enhance to allow while statements to be\n\tprocessed as well as if statements.\n\t(New_Class_Wide_Subtype): The entity for a class-wide subtype does not\n\tcome from source.\n\t(OK_To_Do_Constant_Replacement): Allow constant replacement within body\n\tof loop. This is safe now that we fixed Kill_Current_Values.\n\t(OK_To_Do_Constant_Replacement): Check whether current scope is\n\tStandard, before examining outer scopes.\n\nFrom-SVN: r118269", "tree": {"sha": "e77e0ad5561f246f65cc168507d7e581154bca8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e77e0ad5561f246f65cc168507d7e581154bca8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05350ac648924d81ebd552d045da2dfe71b72e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05350ac648924d81ebd552d045da2dfe71b72e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05350ac648924d81ebd552d045da2dfe71b72e24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05350ac648924d81ebd552d045da2dfe71b72e24/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ac9e9918462165841002d13123546e6e179e7be5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9e9918462165841002d13123546e6e179e7be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9e9918462165841002d13123546e6e179e7be5"}], "stats": {"total": 452, "additions": 366, "deletions": 86}, "files": [{"sha": "0a4a52714e59d2579979e34f7ef0eb117dd62e50", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05350ac648924d81ebd552d045da2dfe71b72e24/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05350ac648924d81ebd552d045da2dfe71b72e24/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=05350ac648924d81ebd552d045da2dfe71b72e24", "patch": "@@ -380,7 +380,7 @@ package body Exp_Ch7 is\n           Typ   => Typ,\n           Stmts => Make_Deep_Array_Body (Initialize_Case, Typ)));\n \n-      if not Is_Return_By_Reference_Type (Typ) then\n+      if not Is_Inherently_Limited_Type (Typ) then\n          Set_TSS (Typ,\n            Make_Deep_Proc (\n              Prim  => Adjust_Case,\n@@ -475,7 +475,7 @@ package body Exp_Ch7 is\n           Typ   => Typ,\n           Stmts => Make_Deep_Record_Body (Initialize_Case, Typ)));\n \n-      if not Is_Return_By_Reference_Type (Typ) then\n+      if not Is_Inherently_Limited_Type (Typ) then\n          Set_TSS (Typ,\n            Make_Deep_Proc (\n              Prim  => Adjust_Case,\n@@ -1825,11 +1825,18 @@ package body Exp_Ch7 is\n             --  itself needs wrapping at the outer-level\n \n             when N_Return_Statement            =>\n-               if Requires_Transient_Scope (Return_Type (The_Parent)) then\n-                  return Empty;\n-               else\n-                  return The_Parent;\n-               end if;\n+               declare\n+                  Applies_To : constant Entity_Id :=\n+                                 Return_Applies_To\n+                                   (Return_Statement_Entity (The_Parent));\n+                  Return_Type : constant Entity_Id := Etype (Applies_To);\n+               begin\n+                  if Requires_Transient_Scope (Return_Type) then\n+                     return Empty;\n+                  else\n+                     return The_Parent;\n+                  end if;\n+               end;\n \n             --  If we leave a scope without having been able to find a node to\n             --  wrap, something is going wrong but this can happen in error\n@@ -2632,7 +2639,7 @@ package body Exp_Ch7 is\n       Res            : constant List_Id := New_List;\n \n    begin\n-      if Is_Return_By_Reference_Type (Typ) then\n+      if Is_Inherently_Limited_Type (Typ) then\n          Controller_Typ := RTE (RE_Limited_Record_Controller);\n       else\n          Controller_Typ := RTE (RE_Record_Controller);"}, {"sha": "13878a3ef1928128f481dde486468f8ca3732f7e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 318, "deletions": 57, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05350ac648924d81ebd552d045da2dfe71b72e24/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05350ac648924d81ebd552d045da2dfe71b72e24/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=05350ac648924d81ebd552d045da2dfe71b72e24", "patch": "@@ -268,7 +268,7 @@ package body Exp_Util is\n    --------------------------\n \n    procedure Append_Freeze_Action (T : Entity_Id; N : Node_Id) is\n-      Fnode : Node_Id := Freeze_Node (T);\n+      Fnode : Node_Id;\n \n    begin\n       Ensure_Freeze_Node (T);\n@@ -580,9 +580,10 @@ package body Exp_Util is\n    ----------------------------\n \n    function Build_Task_Image_Decls\n-     (Loc    : Source_Ptr;\n-      Id_Ref : Node_Id;\n-      A_Type : Entity_Id) return List_Id\n+     (Loc          : Source_Ptr;\n+      Id_Ref       : Node_Id;\n+      A_Type       : Entity_Id;\n+      In_Init_Proc : Boolean := False) return List_Id\n    is\n       Decls  : constant List_Id   := New_List;\n       T_Id   : Entity_Id := Empty;\n@@ -651,6 +652,10 @@ package body Exp_Util is\n          Append (Fun, Decls);\n          Expr := Make_Function_Call (Loc,\n            Name => New_Occurrence_Of (Defining_Entity (Fun), Loc));\n+\n+         if not In_Init_Proc then\n+            Set_Uses_Sec_Stack (Defining_Entity (Fun));\n+         end if;\n       end if;\n \n       Decl := Make_Object_Declaration (Loc,\n@@ -688,8 +693,6 @@ package body Exp_Util is\n       --  Calls to 'Image use the secondary stack, which must be cleaned\n       --  up after the task name is built.\n \n-      Set_Uses_Sec_Stack (Defining_Unit_Name (Spec));\n-\n       return Make_Subprogram_Body (Loc,\n          Specification => Spec,\n          Declarations => Decls,\n@@ -1124,8 +1127,8 @@ package body Exp_Util is\n    --  objects which are constrained by an initial expression. Basically it\n    --  transforms an unconstrained subtype indication into a constrained one.\n    --  The expression may also be transformed in certain cases in order to\n-   --  avoid multiple evaulation. In the static allocation case, the general\n-   --  scheme is :\n+   --  avoid multiple evaluation. In the static allocation case, the general\n+   --  scheme is:\n \n    --     Val : T := Expr;\n \n@@ -1833,6 +1836,11 @@ package body Exp_Util is\n    -- Get_Current_Value_Condition --\n    ---------------------------------\n \n+   --  Note: the implementation of this procedure is very closely tied to the\n+   --  implementation of Set_Current_Value_Condition. In the Get procedure, we\n+   --  interpret Current_Value fields set by the Set procedure, so the two\n+   --  procedures need to be closely coordinated.\n+\n    procedure Get_Current_Value_Condition\n      (Var : Node_Id;\n       Op  : out Node_Kind;\n@@ -1841,6 +1849,134 @@ package body Exp_Util is\n       Loc : constant Source_Ptr := Sloc (Var);\n       Ent : constant Entity_Id  := Entity (Var);\n \n+      procedure Process_Current_Value_Condition\n+        (N : Node_Id;\n+         S : Boolean);\n+      --  N is an expression which holds either True (S = True) or False (S =\n+      --  False) in the condition. This procedure digs out the expression and\n+      --  if it refers to Ent, sets Op and Val appropriately.\n+\n+      -------------------------------------\n+      -- Process_Current_Value_Condition --\n+      -------------------------------------\n+\n+      procedure Process_Current_Value_Condition\n+        (N : Node_Id;\n+         S : Boolean)\n+      is\n+         Cond : Node_Id;\n+         Sens : Boolean;\n+\n+      begin\n+         Cond := N;\n+         Sens := S;\n+\n+         --  Deal with NOT operators, inverting sense\n+\n+         while Nkind (Cond) = N_Op_Not loop\n+            Cond := Right_Opnd (Cond);\n+            Sens := not Sens;\n+         end loop;\n+\n+         --  Deal with AND THEN and AND cases\n+\n+         if Nkind (Cond) = N_And_Then\n+           or else Nkind (Cond) = N_Op_And\n+         then\n+            --  Don't ever try to invert a condition that is of the form\n+            --  of an AND or AND THEN (since we are not doing sufficiently\n+            --  general processing to allow this).\n+\n+            if Sens = False then\n+               Op  := N_Empty;\n+               Val := Empty;\n+               return;\n+            end if;\n+\n+            --  Recursively process AND and AND THEN branches\n+\n+            Process_Current_Value_Condition (Left_Opnd (Cond), True);\n+\n+            if Op /= N_Empty then\n+               return;\n+            end if;\n+\n+            Process_Current_Value_Condition (Right_Opnd (Cond), True);\n+            return;\n+\n+         --  Case of relational operator\n+\n+         elsif Nkind (Cond) in N_Op_Compare then\n+            Op := Nkind (Cond);\n+\n+            --  Invert sense of test if inverted test\n+\n+            if Sens = False then\n+               case Op is\n+                  when N_Op_Eq => Op := N_Op_Ne;\n+                  when N_Op_Ne => Op := N_Op_Eq;\n+                  when N_Op_Lt => Op := N_Op_Ge;\n+                  when N_Op_Gt => Op := N_Op_Le;\n+                  when N_Op_Le => Op := N_Op_Gt;\n+                  when N_Op_Ge => Op := N_Op_Lt;\n+                  when others  => raise Program_Error;\n+               end case;\n+            end if;\n+\n+            --  Case of entity op value\n+\n+            if Is_Entity_Name (Left_Opnd (Cond))\n+              and then Ent = Entity (Left_Opnd (Cond))\n+              and then Compile_Time_Known_Value (Right_Opnd (Cond))\n+            then\n+               Val := Right_Opnd (Cond);\n+\n+            --  Case of value op entity\n+\n+            elsif Is_Entity_Name (Right_Opnd (Cond))\n+              and then Ent = Entity (Right_Opnd (Cond))\n+              and then Compile_Time_Known_Value (Left_Opnd (Cond))\n+            then\n+               Val := Left_Opnd (Cond);\n+\n+               --  We are effectively swapping operands\n+\n+               case Op is\n+                  when N_Op_Eq => null;\n+                  when N_Op_Ne => null;\n+                  when N_Op_Lt => Op := N_Op_Gt;\n+                  when N_Op_Gt => Op := N_Op_Lt;\n+                  when N_Op_Le => Op := N_Op_Ge;\n+                  when N_Op_Ge => Op := N_Op_Le;\n+                  when others  => raise Program_Error;\n+               end case;\n+\n+            else\n+               Op := N_Empty;\n+            end if;\n+\n+            return;\n+\n+            --  Case of Boolean variable reference, return as though the\n+            --  reference had said var = True.\n+\n+         else\n+            if Is_Entity_Name (Cond)\n+              and then Ent = Entity (Cond)\n+            then\n+               Val := New_Occurrence_Of (Standard_True, Sloc (Cond));\n+\n+               if Sens = False then\n+                  Op := N_Op_Ne;\n+               else\n+                  Op := N_Op_Eq;\n+               end if;\n+            end if;\n+         end if;\n+      end Process_Current_Value_Condition;\n+\n+   --  Start of processing for Get_Current_Value_Condition\n+\n    begin\n       Op  := N_Empty;\n       Val := Empty;\n@@ -1857,7 +1993,6 @@ package body Exp_Util is\n          CV   : constant Node_Id := Current_Value (Ent);\n          Sens : Boolean;\n          Stm  : Node_Id;\n-         Cond : Node_Id;\n \n       begin\n          --  If statement. Condition is known true in THEN section, known False\n@@ -1909,7 +2044,17 @@ package body Exp_Util is\n                then\n                   Sens := True;\n \n-                  --  Otherwise we must be in ELSIF or ELSE part\n+               --  If the variable reference does not come from source, we\n+               --  cannot reliably tell whether it appears in the else part.\n+               --  In particular, if if appears in generated code for a node\n+               --  that requires finalization, it may be attached to a list\n+               --  that has not been yet inserted into the code. For now,\n+               --  treat it as unknown.\n+\n+               elsif not Comes_From_Source (N) then\n+                  return;\n+\n+               --  Otherwise we must be in ELSIF or ELSE part\n \n                else\n                   Sens := False;\n@@ -1972,44 +2117,41 @@ package body Exp_Util is\n                end if;\n             end;\n \n-            --  All other cases of Current_Value settings\n+         --  Iteration scheme of while loop. The condition is known to be\n+         --  true within the body of the loop.\n \n-         else\n-            return;\n-         end if;\n+         elsif Nkind (CV) = N_Iteration_Scheme then\n+            declare\n+               Loop_Stmt : constant Node_Id := Parent (CV);\n \n-         --  If we fall through here, then we have a reportable condition, Sens\n-         --  is True if the condition is true and False if it needs inverting.\n+            begin\n+               --  Before start of body of loop\n \n-         --  Deal with NOT operators, inverting sense\n+               if Loc < Sloc (Loop_Stmt) then\n+                  return;\n \n-         Cond := Condition (CV);\n-         while Nkind (Cond) = N_Op_Not loop\n-            Cond := Right_Opnd (Cond);\n-            Sens := not Sens;\n-         end loop;\n+               --  After end of LOOP statement\n \n-         --  Now we must have a relational operator\n+               elsif Loc >= Sloc (End_Label (Loop_Stmt)) then\n+                  return;\n \n-         pragma Assert (Entity (Var) = Entity (Left_Opnd (Cond)));\n-         Val := Right_Opnd (Cond);\n-         Op  := Nkind (Cond);\n+               --  We are within the body of the loop\n \n-         if Sens = False then\n-            case Op is\n-            when N_Op_Eq => Op := N_Op_Ne;\n-            when N_Op_Ne => Op := N_Op_Eq;\n-            when N_Op_Lt => Op := N_Op_Ge;\n-            when N_Op_Gt => Op := N_Op_Le;\n-            when N_Op_Le => Op := N_Op_Gt;\n-            when N_Op_Ge => Op := N_Op_Lt;\n+               else\n+                  Sens := True;\n+               end if;\n+            end;\n \n-               --  No other entry should be possible\n+         --  All other cases of Current_Value settings\n \n-            when others =>\n-               raise Program_Error;\n-            end case;\n+         else\n+            return;\n          end if;\n+\n+         --  If we fall through here, then we have a reportable condition, Sens\n+         --  is True if the condition is true and False if it needs inverting.\n+\n+         Process_Current_Value_Condition (Condition (CV), Sens);\n       end;\n    end Get_Current_Value_Condition;\n \n@@ -2183,7 +2325,7 @@ package body Exp_Util is\n       --  Capture root of the transient scope\n \n       if Scope_Is_Transient then\n-         Wrapped_Node  := Node_To_Be_Wrapped;\n+         Wrapped_Node := Node_To_Be_Wrapped;\n       end if;\n \n       loop\n@@ -2362,8 +2504,9 @@ package body Exp_Util is\n                   null;\n \n                --  Do not insert if parent of P is an N_Component_Association\n-               --  node (i.e. we are in the context of an N_Aggregate node.\n-               --  In this case we want to insert before the entire aggregate.\n+               --  node (i.e. we are in the context of an N_Aggregate or\n+               --  N_Extension_Aggregate node. In this case we want to insert\n+               --  before the entire aggregate.\n \n                elsif Nkind (Parent (P)) = N_Component_Association then\n                   null;\n@@ -2397,7 +2540,7 @@ package body Exp_Util is\n \n                --  Otherwise we can go ahead and do the insertion\n \n-               elsif  P = Wrapped_Node then\n+               elsif P = Wrapped_Node then\n                   Store_Before_Actions_In_Scope (Ins_Actions);\n                   return;\n \n@@ -3230,27 +3373,33 @@ package body Exp_Util is\n                and then not Is_Tagged_Type (Full_View (T))\n                and then Is_Derived_Type (Full_View (T))\n                and then Etype (Full_View (T)) /= T);\n-\n    end Is_Untagged_Derivation;\n \n    --------------------\n    -- Kill_Dead_Code --\n    --------------------\n \n-   procedure Kill_Dead_Code (N : Node_Id) is\n+   procedure Kill_Dead_Code (N : Node_Id; Warn : Boolean := False) is\n    begin\n       if Present (N) then\n          Remove_Warning_Messages (N);\n \n+         if Warn then\n+            Error_Msg_F\n+              (\"?this code can never be executed and has been deleted\", N);\n+         end if;\n+\n          --  Recurse into block statements and bodies to process declarations\n          --  and statements\n \n          if Nkind (N) = N_Block_Statement\n            or else Nkind (N) = N_Subprogram_Body\n            or else Nkind (N) = N_Package_Body\n          then\n-            Kill_Dead_Code (Declarations (N));\n-            Kill_Dead_Code (Statements (Handled_Statement_Sequence (N)));\n+            Kill_Dead_Code\n+              (Declarations (N), False);\n+            Kill_Dead_Code\n+              (Statements (Handled_Statement_Sequence (N)));\n \n             if Nkind (N) = N_Subprogram_Body then\n                Set_Is_Eliminated (Defining_Entity (N));\n@@ -3309,15 +3458,17 @@ package body Exp_Util is\n \n    --  Case where argument is a list of nodes to be killed\n \n-   procedure Kill_Dead_Code (L : List_Id) is\n+   procedure Kill_Dead_Code (L : List_Id; Warn : Boolean := False) is\n       N : Node_Id;\n-\n+      W : Boolean;\n    begin\n+      W := Warn;\n       if Is_Non_Empty_List (L) then\n          loop\n             N := Remove_Head (L);\n             exit when No (N);\n-            Kill_Dead_Code (N);\n+            Kill_Dead_Code (N, W);\n+            W := False;\n          end loop;\n       end if;\n    end Kill_Dead_Code;\n@@ -3829,6 +3980,7 @@ package body Exp_Util is\n \n    begin\n       Copy_Node (CW_Typ, Res);\n+      Set_Comes_From_Source (Res, False);\n       Set_Sloc (Res, Sloc (N));\n       Set_Is_Itype (Res);\n       Set_Associated_Node_For_Itype (Res, N);\n@@ -3884,7 +4036,6 @@ package body Exp_Util is\n       --  Otherwise check scopes\n \n       else\n-\n          CS := Current_Scope;\n \n          loop\n@@ -3896,14 +4047,21 @@ package body Exp_Util is\n             --  Packages do not affect the determination of safety\n \n             elsif Ekind (CS) = E_Package then\n-               CS := Scope (CS);\n                exit when CS = Standard_Standard;\n+               CS := Scope (CS);\n \n             --  Blocks do not affect the determination of safety\n \n             elsif Ekind (CS) = E_Block then\n                CS := Scope (CS);\n \n+            --  Loops do not affect the determination of safety. Note that we\n+            --  kill all current values on entry to a loop, so we are just\n+            --  talking about processing within a loop here.\n+\n+            elsif Ekind (CS) = E_Loop then\n+               CS := Scope (CS);\n+\n             --  Otherwise, the reference is dubious, and we cannot be sure that\n             --  it is safe to do the replacement.\n \n@@ -4091,11 +4249,10 @@ package body Exp_Util is\n             --  are side effect free. For this purpose binary operators\n             --  include membership tests and short circuit forms\n \n-            when N_Binary_Op |\n-                 N_In        |\n-                 N_Not_In    |\n-                 N_And_Then  |\n-                 N_Or_Else   =>\n+            when N_Binary_Op       |\n+                 N_Membership_Test |\n+                 N_And_Then        |\n+                 N_Or_Else         =>\n                return Side_Effect_Free (Left_Opnd  (N))\n                  and then Side_Effect_Free (Right_Opnd (N));\n \n@@ -4687,9 +4844,113 @@ package body Exp_Util is\n       else\n          return False;\n       end if;\n-\n    end Safe_Unchecked_Type_Conversion;\n \n+   ---------------------------------\n+   -- Set_Current_Value_Condition --\n+   ---------------------------------\n+\n+   --  Note: the implementation of this procedure is very closely tied to the\n+   --  implementation of Get_Current_Value_Condition. Here we set required\n+   --  Current_Value fields, and in Get_Current_Value_Condition, we interpret\n+   --  them, so they must have a consistent view.\n+\n+   procedure Set_Current_Value_Condition (Cnode : Node_Id) is\n+\n+      procedure Set_Entity_Current_Value (N : Node_Id);\n+      --  If N is an entity reference, where the entity is of an appropriate\n+      --  kind, then set the current value of this entity to Cnode, unless\n+      --  there is already a definite value set there.\n+\n+      procedure Set_Expression_Current_Value (N : Node_Id);\n+      --  If N is of an appropriate form, sets an appropriate entry in current\n+      --  value fields of relevant entities. Multiple entities can be affected\n+      --  in the case of an AND or AND THEN.\n+\n+      ------------------------------\n+      -- Set_Entity_Current_Value --\n+      ------------------------------\n+\n+      procedure Set_Entity_Current_Value (N : Node_Id) is\n+      begin\n+         if Is_Entity_Name (N) then\n+            declare\n+               Ent : constant Entity_Id := Entity (N);\n+\n+            begin\n+               --  Don't capture if not safe to do so\n+\n+               if not Safe_To_Capture_Value (N, Ent, Cond => True) then\n+                  return;\n+               end if;\n+\n+               --  Here we have a case where the Current_Value field may\n+               --  need to be set. We set it if it is not already set to a\n+               --  compile time expression value.\n+\n+               --  Note that this represents a decision that one condition\n+               --  blots out another previous one. That's certainly right\n+               --  if they occur at the same level. If the second one is\n+               --  nested, then the decision is neither right nor wrong (it\n+               --  would be equally OK to leave the outer one in place, or\n+               --  take the new inner one. Really we should record both, but\n+               --  our data structures are not that elaborate.\n+\n+               if Nkind (Current_Value (Ent)) not in N_Subexpr then\n+                  Set_Current_Value (Ent, Cnode);\n+               end if;\n+            end;\n+         end if;\n+      end Set_Entity_Current_Value;\n+\n+      ----------------------------------\n+      -- Set_Expression_Current_Value --\n+      ----------------------------------\n+\n+      procedure Set_Expression_Current_Value (N : Node_Id) is\n+         Cond : Node_Id;\n+\n+      begin\n+         Cond := N;\n+\n+         --  Loop to deal with (ignore for now) any NOT operators present. The\n+         --  presence of NOT operators will be handled properly when we call\n+         --  Get_Current_Value_Condition.\n+\n+         while Nkind (Cond) = N_Op_Not loop\n+            Cond := Right_Opnd (Cond);\n+         end loop;\n+\n+         --  For an AND or AND THEN, recursively process operands\n+\n+         if Nkind (Cond) = N_Op_And or else Nkind (Cond) = N_And_Then then\n+            Set_Expression_Current_Value (Left_Opnd (Cond));\n+            Set_Expression_Current_Value (Right_Opnd (Cond));\n+            return;\n+         end if;\n+\n+         --  Check possible relational operator\n+\n+         if Nkind (Cond) in N_Op_Compare then\n+            if Compile_Time_Known_Value (Right_Opnd (Cond)) then\n+               Set_Entity_Current_Value (Left_Opnd (Cond));\n+            elsif Compile_Time_Known_Value (Left_Opnd (Cond)) then\n+               Set_Entity_Current_Value (Right_Opnd (Cond));\n+            end if;\n+\n+            --  Check possible boolean variable reference\n+\n+         else\n+            Set_Entity_Current_Value (Cond);\n+         end if;\n+      end Set_Expression_Current_Value;\n+\n+   --  Start of processing for Set_Current_Value_Condition\n+\n+   begin\n+      Set_Expression_Current_Value (Condition (Cnode));\n+   end Set_Current_Value_Condition;\n+\n    --------------------------\n    -- Set_Elaboration_Flag --\n    --------------------------"}, {"sha": "cfff619aa85fc1b264d8aaf217dcb260f60931f8", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05350ac648924d81ebd552d045da2dfe71b72e24/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05350ac648924d81ebd552d045da2dfe71b72e24/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=05350ac648924d81ebd552d045da2dfe71b72e24", "patch": "@@ -191,15 +191,15 @@ package Exp_Util is\n    --  Add a new freeze action for the given type. The freeze action is\n    --  attached to the freeze node for the type. Actions will be elaborated in\n    --  the order in which they are added. Note that the added node is not\n-   --  analyzed. The analyze call is found in Sem_Ch13.Expand_N_Freeze_Entity.\n+   --  analyzed. The analyze call is found in Exp_Ch13.Expand_N_Freeze_Entity.\n \n    procedure Append_Freeze_Actions (T : Entity_Id; L : List_Id);\n    --  Adds the given list of freeze actions (declarations or statements) for\n    --  the given type. The freeze actions are attached to the freeze node for\n    --  the type. Actions will be elaborated in the order in which they are\n    --  added, and the actions within the list will be elaborated in list order.\n    --  Note that the added nodes are not analyzed. The analyze call is found in\n-   --  Sem_Ch13.Expand_N_Freeze_Entity.\n+   --  Exp_Ch13.Expand_N_Freeze_Entity.\n \n    function Build_Runtime_Call (Loc : Source_Ptr; RE : RE_Id) return Node_Id;\n    --  Build an N_Procedure_Call_Statement calling the given runtime entity.\n@@ -208,10 +208,10 @@ package Exp_Util is\n    --  analyzed on return, the caller is responsible for analyzing it.\n \n    function Build_Task_Image_Decls\n-     (Loc    : Source_Ptr;\n-      Id_Ref : Node_Id;\n-      A_Type : Entity_Id)\n-      return   List_Id;\n+     (Loc          : Source_Ptr;\n+      Id_Ref       : Node_Id;\n+      A_Type       : Entity_Id;\n+      In_Init_Proc : Boolean := False) return List_Id;\n    --  Build declaration for a variable that holds an identifying string to be\n    --  used as a task name. Id_Ref is an identifier if the task is a variable,\n    --  and a selected or indexed component if the task is component of an\n@@ -220,6 +220,11 @@ package Exp_Util is\n    --  index values. For composite types, the result includes two declarations:\n    --  one for a generated function that computes the image without using\n    --  concatenation, and one for the variable that holds the result.\n+   --  If In_Init_Proc is true, the call is part of the initialization of\n+   --  a component of a composite type, and the enclosing initialization\n+   --  procedure must be flagged as using the secondary stack. If In_Init_Proc\n+   --  is false, the call is for a stand-alone object, and the generated\n+   --  function itself must do its own cleanups.\n \n    function Component_May_Be_Bit_Aligned (Comp : Entity_Id) return Boolean;\n    --  This function is in charge of detecting record components that may cause\n@@ -407,17 +412,14 @@ package Exp_Util is\n    --  on return Cond is set to N_Empty, and Val is set to Empty.\n    --\n    --  The other case is when Current_Value points to an N_If_Statement or an\n-   --  N_Elsif_Part (while statement). Such a setting only occurs if the\n-   --  condition of an IF or ELSIF is of the form X op Y, where is the variable\n-   --  in question, Y is a compile-time known value, and op is one of the six\n-   --  possible relational operators.\n-   --\n-   --  In this case, Get_Current_Condition digs out the condition, and then\n-   --  checks if the condition is known false, known true, or not known at all.\n-   --  In the first two cases, Get_Current_Condition will return with Op set to\n-   --  the appropriate conditional operator (inverted if the condition is known\n-   --  false), and Val set to the constant value. If the condition is not\n-   --  known, then Cond and Val are set for the empty case (N_Empty and Empty).\n+   --  N_Elsif_Part or a N_Iteration_Scheme node (see description in Einfo for\n+   --  exact details). In this case, Get_Current_Condition digs out the\n+   --  condition, and then checks if the condition is known false, known true,\n+   --  or not known at all. In the first two cases, Get_Current_Condition will\n+   --  return with Op set to the appropriate conditional operator (inverted if\n+   --  the condition is known false), and Val set to the constant value. If the\n+   --  condition is not known, then Cond and Val are set for the empty case\n+   --  (N_Empty and Empty).\n    --\n    --  The check for whether the condition is true/false unknown depends\n    --  on the case:\n@@ -465,7 +467,7 @@ package Exp_Util is\n    --  routine with No_List as the argument.\n \n    function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation.\n+   --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation\n \n    function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a reference to a bit packed array, i.e.\n@@ -505,14 +507,17 @@ package Exp_Util is\n    --  Returns true if type T is not tagged and is a derived type,\n    --  or is a private type whose completion is such a type.\n \n-   procedure Kill_Dead_Code (N : Node_Id);\n+   procedure Kill_Dead_Code (N : Node_Id; Warn : Boolean := False);\n    --  N represents a node for a section of code that is known to be dead. The\n    --  node is deleted, and any exception handler references and warning\n-   --  messages relating to this code are removed.\n+   --  messages relating to this code are removed. If Warn is True, a warning\n+   --  will be output at the start of N indicating the deletion of the code.\n \n-   procedure Kill_Dead_Code (L : List_Id);\n+   procedure Kill_Dead_Code (L : List_Id; Warn : Boolean := False);\n    --  Like the above procedure, but applies to every element in the given\n    --  list. Each of the entries is removed from the list before killing it.\n+   --  If Warn is True, a warning will be output at the start of N indicating\n+   --  the deletion of the code.\n \n    function Known_Non_Negative (Opnd : Node_Id) return Boolean;\n    --  Given a node for a subexpression, determines if it represents a value\n@@ -589,6 +594,13 @@ package Exp_Util is\n    --  field may not be set, but in that case it must be the case that the\n    --  Subtype_Mark field of the node is set/analyzed.\n \n+   procedure Set_Current_Value_Condition (Cnode : Node_Id);\n+   --  Cnode is N_If_Statement, N_Elsif_Part, or N_Iteration_Scheme (the latter\n+   --  when a WHILE condition is present). This call checks whether Condition\n+   --  (Cnode) has embedded expressions of a form that should result in setting\n+   --  the Current_Value field of one or more entities, and if so sets these\n+   --  fields to point to Cnode.\n+\n    procedure Set_Elaboration_Flag (N : Node_Id; Spec_Id : Entity_Id);\n    --  N is the node for a subprogram or generic body, and Spec_Id is the\n    --  entity for the corresponding spec. If an elaboration entity is defined,"}]}