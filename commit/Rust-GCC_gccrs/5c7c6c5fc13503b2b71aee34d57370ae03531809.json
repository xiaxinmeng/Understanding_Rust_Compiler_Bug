{"sha": "5c7c6c5fc13503b2b71aee34d57370ae03531809", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM3YzZjNWZjMTM1MDNiMmI3MWFlZTM0ZDU3MzcwYWUwMzUzMTgwOQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2019-08-22T15:06:37Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2019-08-22T15:06:37Z"}, "message": "[ARM] Cleanup DImode shifts\n\nLike the logical operations, expand all shifts early rather than only\nsometimes.  The Neon shift expansions are never emitted (not even with\n-fneon-for-64bits), so they are not useful.  So all the late expansions\nand Neon shift patterns can be removed, and shifts are more optimized\nas a result.  Since some extend patterns use Neon DImode shifts, remove\nthe Neon extend variants and related splits.\n\nA simple example now generates the same efficient code after this\npatch with -mfpu=neon and -mfpu=vfp (previously just the fact of\nhaving Neon enabled resulted inefficient code for no reason).\n\nunsigned long long f(unsigned long long x, unsigned long long y)\n{ return x & (y >> 33); }\n\nBefore:\n\tstrd    r4, r5, [sp, #-8]!\n\tlsr     r4, r3, #1\n\tmov     r5, #0\n\tand     r1, r1, r5\n\tand     r0, r0, r4\n\tldrd    r4, r5, [sp]\n\tadd     sp, sp, #8\n\tbx      lr\n\nAfter:\n\tand     r0, r0, r3, lsr #1\n\tmov     r1, #0\n\tbx      lr\n\nBootstrap and regress OK on arm-none-linux-gnueabihf --with-cpu=cortex-a57\n\n    gcc/\n\t* config/arm/iterators.md (qhs_extenddi_cstr): Update.\n\t(qhs_extenddi_cstr): Likewise.\n\t* config/arm/arm.md (ashldi3): Always expand early.\n\t(ashlsi3): Likewise.\n\t(ashrsi3): Likewise.\n\t(zero_extend<mode>di2): Remove Neon variants.\n\t(extend<mode>di2): Likewise.\n\t* config/arm/neon.md (ashldi3_neon_noclobber): Remove.\n\t(signed_shift_di3_neon): Likewise.\n\t(unsigned_shift_di3_neon): Likewise.\n\t(ashrdi3_neon_imm_noclobber): Likewise.\n\t(lshrdi3_neon_imm_noclobber): Likewise.\n\t(<shift>di3_neon): Likewise.\n\t(split extend): Remove DI extend split patterns.\n\n   gcc/testsuite/\n\t* gcc.target/arm/neon-extend-1.c: Remove test.\n\t* gcc.target/arm/neon-extend-2.c: Remove test.\n\nFrom-SVN: r274824", "tree": {"sha": "f35d539176f8246d76b17e80ae30101e41847f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f35d539176f8246d76b17e80ae30101e41847f26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c7c6c5fc13503b2b71aee34d57370ae03531809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c7c6c5fc13503b2b71aee34d57370ae03531809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c7c6c5fc13503b2b71aee34d57370ae03531809", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c7c6c5fc13503b2b71aee34d57370ae03531809/comments", "author": null, "committer": null, "parents": [{"sha": "cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdfc0e863a03698a80c74896cbdc9f5c8c652e64"}], "stats": {"total": 407, "additions": 48, "deletions": 359}, "files": [{"sha": "6c1335e918aefd78049d1dd962a8af404dfeb832", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c7c6c5fc13503b2b71aee34d57370ae03531809", "patch": "@@ -1,3 +1,20 @@\n+2019-08-22  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/arm/iterators.md (qhs_extenddi_cstr): Update.\n+\t(qhs_extenddi_cstr): Likewise.\n+\t* config/arm/arm.md (ashldi3): Always expand early.\n+\t(ashlsi3): Likewise.\n+\t(ashrsi3): Likewise.\n+\t(zero_extend<mode>di2): Remove Neon variants.\n+\t(extend<mode>di2): Likewise.\n+\t* config/arm/neon.md (ashldi3_neon_noclobber): Remove.\n+\t(signed_shift_di3_neon): Likewise.\n+\t(unsigned_shift_di3_neon): Likewise.\n+\t(ashrdi3_neon_imm_noclobber): Likewise.\n+\t(lshrdi3_neon_imm_noclobber): Likewise.\n+\t(<shift>di3_neon): Likewise.\n+\t(split extend): Remove DI extend split patterns.\n+\n 2019-08-22  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/arm/arm.md (split and/eor/ior): Remove Neon check."}, {"sha": "4f6e3aa1661979ac991f9dc697b297cba2129f6c", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 24, "deletions": 102, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5c7c6c5fc13503b2b71aee34d57370ae03531809", "patch": "@@ -3621,44 +3621,14 @@\n (define_expand \"ashldi3\"\n   [(set (match_operand:DI            0 \"s_register_operand\")\n         (ashift:DI (match_operand:DI 1 \"s_register_operand\")\n-                   (match_operand:SI 2 \"general_operand\")))]\n+                   (match_operand:SI 2 \"reg_or_int_operand\")))]\n   \"TARGET_32BIT\"\n   \"\n-  if (TARGET_NEON)\n-    {\n-      /* Delay the decision whether to use NEON or core-regs until\n-\t register allocation.  */\n-      emit_insn (gen_ashldi3_neon (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  else\n-    {\n-      /* Only the NEON case can handle in-memory shift counts.  */\n-      if (!reg_or_int_operand (operands[2], SImode))\n-        operands[2] = force_reg (SImode, operands[2]);\n-    }\n-\n-  if (!CONST_INT_P (operands[2]) && TARGET_REALLY_IWMMXT)\n-    ; /* No special preparation statements; expand pattern as above.  */\n-  else\n-    {\n-      rtx scratch1, scratch2;\n-\n-      /* Ideally we should use iwmmxt here if we could know that operands[1]\n-         ends up already living in an iwmmxt register. Otherwise it's\n-         cheaper to have the alternate code being generated than moving\n-         values to iwmmxt regs and back.  */\n-\n-      /* Expand operation using core-registers.\n-\t 'FAIL' would achieve the same thing, but this is a bit smarter.  */\n-      scratch1 = gen_reg_rtx (SImode);\n-      scratch2 = gen_reg_rtx (SImode);\n-      arm_emit_coreregs_64bit_shift (ASHIFT, operands[0], operands[1],\n-\t\t\t\t     operands[2], scratch1, scratch2);\n-      DONE;\n-    }\n-  \"\n-)\n+  arm_emit_coreregs_64bit_shift (ASHIFT, operands[0], operands[1],\n+\t\t\t\t operands[2], gen_reg_rtx (SImode),\n+\t\t\t\t gen_reg_rtx (SImode));\n+  DONE;\n+\")\n \n (define_expand \"ashlsi3\"\n   [(set (match_operand:SI            0 \"s_register_operand\")\n@@ -3681,35 +3651,11 @@\n                      (match_operand:SI 2 \"reg_or_int_operand\")))]\n   \"TARGET_32BIT\"\n   \"\n-  if (TARGET_NEON)\n-    {\n-      /* Delay the decision whether to use NEON or core-regs until\n-\t register allocation.  */\n-      emit_insn (gen_ashrdi3_neon (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-\n-  if (!CONST_INT_P (operands[2]) && TARGET_REALLY_IWMMXT)\n-    ; /* No special preparation statements; expand pattern as above.  */\n-  else\n-    {\n-      rtx scratch1, scratch2;\n-\n-      /* Ideally we should use iwmmxt here if we could know that operands[1]\n-         ends up already living in an iwmmxt register. Otherwise it's\n-         cheaper to have the alternate code being generated than moving\n-         values to iwmmxt regs and back.  */\n-\n-      /* Expand operation using core-registers.\n-\t 'FAIL' would achieve the same thing, but this is a bit smarter.  */\n-      scratch1 = gen_reg_rtx (SImode);\n-      scratch2 = gen_reg_rtx (SImode);\n-      arm_emit_coreregs_64bit_shift (ASHIFTRT, operands[0], operands[1],\n-\t\t\t\t     operands[2], scratch1, scratch2);\n-      DONE;\n-    }\n-  \"\n-)\n+  arm_emit_coreregs_64bit_shift (ASHIFTRT, operands[0], operands[1],\n+\t\t\t\t operands[2], gen_reg_rtx (SImode),\n+\t\t\t\t gen_reg_rtx (SImode));\n+  DONE;\n+\")\n \n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI              0 \"s_register_operand\")\n@@ -3729,35 +3675,11 @@\n                      (match_operand:SI 2 \"reg_or_int_operand\")))]\n   \"TARGET_32BIT\"\n   \"\n-  if (TARGET_NEON)\n-    {\n-      /* Delay the decision whether to use NEON or core-regs until\n-\t register allocation.  */\n-      emit_insn (gen_lshrdi3_neon (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-\n-  if (!CONST_INT_P (operands[2]) && TARGET_REALLY_IWMMXT)\n-    ; /* No special preparation statements; expand pattern as above.  */\n-  else\n-    {\n-      rtx scratch1, scratch2;\n-\n-      /* Ideally we should use iwmmxt here if we could know that operands[1]\n-         ends up already living in an iwmmxt register. Otherwise it's\n-         cheaper to have the alternate code being generated than moving\n-         values to iwmmxt regs and back.  */\n-\n-      /* Expand operation using core-registers.\n-\t 'FAIL' would achieve the same thing, but this is a bit smarter.  */\n-      scratch1 = gen_reg_rtx (SImode);\n-      scratch2 = gen_reg_rtx (SImode);\n-      arm_emit_coreregs_64bit_shift (LSHIFTRT, operands[0], operands[1],\n-\t\t\t\t     operands[2], scratch1, scratch2);\n-      DONE;\n-    }\n-  \"\n-)\n+  arm_emit_coreregs_64bit_shift (LSHIFTRT, operands[0], operands[1],\n+\t\t\t\t operands[2], gen_reg_rtx (SImode),\n+\t\t\t\t gen_reg_rtx (SImode));\n+  DONE;\n+\")\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI              0 \"s_register_operand\")\n@@ -4782,30 +4704,30 @@\n ;; Zero and sign extension instructions.\n \n (define_insn \"zero_extend<mode>di2\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=w,r,?r,w\")\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"=r,?r\")\n         (zero_extend:DI (match_operand:QHSI 1 \"<qhs_zextenddi_op>\"\n \t\t\t\t\t    \"<qhs_zextenddi_cstr>\")))]\n   \"TARGET_32BIT <qhs_zextenddi_cond>\"\n   \"#\"\n-  [(set_attr \"length\" \"8,4,8,8\")\n-   (set_attr \"arch\" \"neon_for_64bits,*,*,avoid_neon_for_64bits\")\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"arch\" \"*,*\")\n    (set_attr \"ce_count\" \"2\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"multiple,mov_reg,multiple,multiple\")]\n+   (set_attr \"type\" \"mov_reg,multiple\")]\n )\n \n (define_insn \"extend<mode>di2\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=w,r,?r,?r,w\")\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"=r,?r,?r\")\n         (sign_extend:DI (match_operand:QHSI 1 \"<qhs_extenddi_op>\"\n \t\t\t\t\t    \"<qhs_extenddi_cstr>\")))]\n   \"TARGET_32BIT <qhs_sextenddi_cond>\"\n   \"#\"\n-  [(set_attr \"length\" \"8,4,8,8,8\")\n+  [(set_attr \"length\" \"4,8,8\")\n    (set_attr \"ce_count\" \"2\")\n    (set_attr \"shift\" \"1\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"arch\" \"neon_for_64bits,*,a,t,avoid_neon_for_64bits\")\n-   (set_attr \"type\" \"multiple,mov_reg,multiple,multiple,multiple\")]\n+   (set_attr \"arch\" \"*,a,t\")\n+   (set_attr \"type\" \"mov_reg,multiple,multiple\")]\n )\n \n ;; Splits for all extensions to DImode"}, {"sha": "fa6f0c0529d5364b1e1df705cb1029868578e38c", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=5c7c6c5fc13503b2b71aee34d57370ae03531809", "patch": "@@ -741,8 +741,8 @@\n (define_mode_attr qhs_extenddi_op [(SI \"s_register_operand\")\n \t\t\t\t   (HI \"nonimmediate_operand\")\n \t\t\t\t   (QI \"arm_reg_or_extendqisi_mem_op\")])\n-(define_mode_attr qhs_extenddi_cstr [(SI \"r,0,r,r,r\") (HI \"r,0,rm,rm,r\") (QI \"r,0,rUq,rm,r\")])\n-(define_mode_attr qhs_zextenddi_cstr [(SI \"r,0,r,r\") (HI \"r,0,rm,r\") (QI \"r,0,rm,r\")])\n+(define_mode_attr qhs_extenddi_cstr [(SI \"0,r,r\") (HI \"0,rm,rm\") (QI \"0,rUq,rm\")])\n+(define_mode_attr qhs_zextenddi_cstr [(SI \"0,r\") (HI \"0,rm\") (QI \"0,rm\")])\n \n ;; Mode attributes used for fixed-point support.\n (define_mode_attr qaddsub_suf [(V4UQQ \"8\") (V2UHQ \"16\") (UQQ \"8\") (UHQ \"16\")"}, {"sha": "757f2c0f5377148c770e061849424aed924a7d7a", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=5c7c6c5fc13503b2b71aee34d57370ae03531809", "patch": "@@ -1135,173 +1135,6 @@\n   [(set_attr \"type\" \"neon_load1_1reg,neon_from_gp\")]\n )\n \n-(define_insn \"ashldi3_neon_noclobber\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t    \"=w,w\")\n-\t(ashift:DI (match_operand:DI 1 \"s_register_operand\" \" w,w\")\n-\t\t   (match_operand:DI 2 \"reg_or_int_operand\" \" i,w\")))]\n-  \"TARGET_NEON && reload_completed\n-   && (!CONST_INT_P (operands[2])\n-       || (INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 64))\"\n-  \"@\n-   vshl.u64\\t%P0, %P1, %2\n-   vshl.u64\\t%P0, %P1, %P2\"\n-  [(set_attr \"type\" \"neon_shift_imm, neon_shift_reg\")]\n-)\n-\n-(define_insn_and_split \"ashldi3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t    \"= w, w, &r, r, &r, ?w,?w\")\n-\t(ashift:DI (match_operand:DI 1 \"s_register_operand\" \" 0w, w, 0r, 0,  r, 0w, w\")\n-\t\t   (match_operand:SI 2 \"general_operand\"    \"rUm, i,  r, i,  i,rUm, i\")))\n-   (clobber (match_scratch:SI 3\t\t\t\t    \"= X, X, &r, X,  X,  X, X\"))\n-   (clobber (match_scratch:SI 4\t\t\t\t    \"= X, X, &r, X,  X,  X, X\"))\n-   (clobber (match_scratch:DI 5\t\t\t\t    \"=&w, X,  X, X,  X, &w, X\"))\n-   (clobber (reg:CC_C CC_REGNUM))]\n-  \"TARGET_NEON\"\n-  \"#\"\n-  \"TARGET_NEON && reload_completed\"\n-  [(const_int 0)]\n-  \"\n-  {\n-    if (IS_VFP_REGNUM (REGNO (operands[0])))\n-      {\n-        if (CONST_INT_P (operands[2]))\n-\t  {\n-\t    if (INTVAL (operands[2]) < 1)\n-\t      {\n-\t        emit_insn (gen_movdi (operands[0], operands[1]));\n-\t\tDONE;\n-\t      }\n-\t    else if (INTVAL (operands[2]) > 63)\n-\t      operands[2] = gen_rtx_CONST_INT (VOIDmode, 63);\n-\t  }\n-\telse\n-\t  {\n-\t    emit_insn (gen_neon_load_count (operands[5], operands[2]));\n-\t    operands[2] = operands[5];\n-\t  }\n-\n-\t/* Ditch the unnecessary clobbers.  */\n-\temit_insn (gen_ashldi3_neon_noclobber (operands[0], operands[1],\n-\t\t\t\t\t       operands[2]));\n-      }\n-    else\n-      {\n-\t/* The shift expanders support either full overlap or no overlap.  */\n-\tgcc_assert (!reg_overlap_mentioned_p (operands[0], operands[1])\n-\t\t    || REGNO (operands[0]) == REGNO (operands[1]));\n-\n-\tarm_emit_coreregs_64bit_shift (ASHIFT, operands[0], operands[1],\n-\t\t\t\t       operands[2], operands[3], operands[4]);\n-      }\n-    DONE;\n-  }\"\n-  [(set_attr \"arch\" \"neon_for_64bits,neon_for_64bits,*,*,*,avoid_neon_for_64bits,avoid_neon_for_64bits\")\n-   (set_attr \"opt\" \"*,*,speed,speed,speed,*,*\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-; The shift amount needs to be negated for right-shifts\n-(define_insn \"signed_shift_di3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t     \"=w\")\n-\t(unspec:DI [(match_operand:DI 1 \"s_register_operand\" \" w\")\n-\t\t    (match_operand:DI 2 \"s_register_operand\" \" w\")]\n-\t\t   UNSPEC_ASHIFT_SIGNED))]\n-  \"TARGET_NEON && reload_completed\"\n-  \"vshl.s64\\t%P0, %P1, %P2\"\n-  [(set_attr \"type\" \"neon_shift_reg\")]\n-)\n-\n-; The shift amount needs to be negated for right-shifts\n-(define_insn \"unsigned_shift_di3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t     \"=w\")\n-\t(unspec:DI [(match_operand:DI 1 \"s_register_operand\" \" w\")\n-\t\t    (match_operand:DI 2 \"s_register_operand\" \" w\")]\n-\t\t   UNSPEC_ASHIFT_UNSIGNED))]\n-  \"TARGET_NEON && reload_completed\"\n-  \"vshl.u64\\t%P0, %P1, %P2\"\n-  [(set_attr \"type\" \"neon_shift_reg\")]\n-)\n-\n-(define_insn \"ashrdi3_neon_imm_noclobber\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t      \"=w\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"s_register_operand\" \" w\")\n-\t\t     (match_operand:DI 2 \"const_int_operand\"  \" i\")))]\n-  \"TARGET_NEON && reload_completed\n-   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 64\"\n-  \"vshr.s64\\t%P0, %P1, %2\"\n-  [(set_attr \"type\" \"neon_shift_imm\")]\n-)\n-\n-(define_insn \"lshrdi3_neon_imm_noclobber\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t      \"=w\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"s_register_operand\" \" w\")\n-\t\t     (match_operand:DI 2 \"const_int_operand\"  \" i\")))]\n-  \"TARGET_NEON && reload_completed\n-   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 64\"\n-  \"vshr.u64\\t%P0, %P1, %2\"\n-  [(set_attr \"type\" \"neon_shift_imm\")]\n-)\n-\n-;; ashrdi3_neon\n-;; lshrdi3_neon\n-(define_insn_and_split \"<shift>di3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t     \"= w, w, &r, r, &r,?w,?w\")\n-\t(RSHIFTS:DI (match_operand:DI 1 \"s_register_operand\" \" 0w, w, 0r, 0,  r,0w, w\")\n-\t\t    (match_operand:SI 2 \"reg_or_int_operand\" \"  r, i,  r, i,  i, r, i\")))\n-   (clobber (match_scratch:SI 3\t\t\t\t     \"=2r, X, &r, X,  X,2r, X\"))\n-   (clobber (match_scratch:SI 4\t\t\t\t     \"= X, X, &r, X,  X, X, X\"))\n-   (clobber (match_scratch:DI 5\t\t\t\t     \"=&w, X,  X, X, X,&w, X\"))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_NEON\"\n-  \"#\"\n-  \"TARGET_NEON && reload_completed\"\n-  [(const_int 0)]\n-  \"\n-  {\n-    if (IS_VFP_REGNUM (REGNO (operands[0])))\n-      {\n-\tif (CONST_INT_P (operands[2]))\n-\t  {\n-\t    if (INTVAL (operands[2]) < 1)\n-\t      {\n-\t        emit_insn (gen_movdi (operands[0], operands[1]));\n-\t\tDONE;\n-\t      }\n-\t    else if (INTVAL (operands[2]) > 64)\n-\t      operands[2] = gen_rtx_CONST_INT (VOIDmode, 64);\n-\n-\t    /* Ditch the unnecessary clobbers.  */\n-\t    emit_insn (gen_<shift>di3_neon_imm_noclobber (operands[0],\n-\t\t\t\t\t\t\t  operands[1],\n-\t\t\t\t\t\t\t  operands[2]));\n-\t  }\n-\telse \n-\t  {\n-\t    /* We must use a negative left-shift.  */\n-\t    emit_insn (gen_negsi2 (operands[3], operands[2]));\n-\t    emit_insn (gen_neon_load_count (operands[5], operands[3]));\n-\t    emit_insn (gen_<shifttype>_shift_di3_neon (operands[0], operands[1],\n-\t\t\t\t\t\t       operands[5]));\n-\t  }\n-      }\n-    else\n-      {\n-\t/* The shift expanders support either full overlap or no overlap.  */\n-\tgcc_assert (!reg_overlap_mentioned_p (operands[0], operands[1])\n-\t\t    || REGNO (operands[0]) == REGNO (operands[1]));\n-\n-\t/* This clobbers CC (ASHIFTRT by register only).  */\n-\tarm_emit_coreregs_64bit_shift (<CODE>, operands[0], operands[1],\n-\t\t\t\t       operands[2], operands[3], operands[4]);\n-      }\n-\n-    DONE;\n-  }\"\n-  [(set_attr \"arch\" \"neon_for_64bits,neon_for_64bits,*,*,*,avoid_neon_for_64bits,avoid_neon_for_64bits\")\n-   (set_attr \"opt\" \"*,*,speed,speed,speed,*,*\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n ;; Widening operations\n \n (define_expand \"widen_ssum<mode>3\"\n@@ -6792,65 +6625,3 @@ if (BYTES_BIG_ENDIAN)\n  \"vabd.<V_if_elem> %<V_reg>0, %<V_reg>1, %<V_reg>2\"\n  [(set_attr \"type\" \"neon_fp_abd_s<q>\")]\n )\n-\n-;; Copy from core-to-neon regs, then extend, not vice-versa\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(sign_extend:DI (match_operand:SI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_NEON && reload_completed && IS_VFP_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 2) (vec_duplicate:V2SI (match_dup 1)))\n-   (set (match_dup 0) (ashiftrt:DI (match_dup 0) (const_int 32)))]\n-  {\n-    operands[2] = gen_rtx_REG (V2SImode, REGNO (operands[0]));\n-  })\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(sign_extend:DI (match_operand:HI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_NEON && reload_completed && IS_VFP_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 2) (vec_duplicate:V4HI (match_dup 1)))\n-   (set (match_dup 0) (ashiftrt:DI (match_dup 0) (const_int 48)))]\n-  {\n-    operands[2] = gen_rtx_REG (V4HImode, REGNO (operands[0]));\n-  })\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(sign_extend:DI (match_operand:QI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_NEON && reload_completed && IS_VFP_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 2) (vec_duplicate:V8QI (match_dup 1)))\n-   (set (match_dup 0) (ashiftrt:DI (match_dup 0) (const_int 56)))]\n-  {\n-    operands[2] = gen_rtx_REG (V8QImode, REGNO (operands[0]));\n-  })\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(zero_extend:DI (match_operand:SI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_NEON && reload_completed && IS_VFP_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 2) (vec_duplicate:V2SI (match_dup 1)))\n-   (set (match_dup 0) (lshiftrt:DI (match_dup 0) (const_int 32)))]\n-  {\n-    operands[2] = gen_rtx_REG (V2SImode, REGNO (operands[0]));\n-  })\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(zero_extend:DI (match_operand:HI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_NEON && reload_completed && IS_VFP_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 2) (vec_duplicate:V4HI (match_dup 1)))\n-   (set (match_dup 0) (lshiftrt:DI (match_dup 0) (const_int 48)))]\n-  {\n-    operands[2] = gen_rtx_REG (V4HImode, REGNO (operands[0]));\n-  })\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(zero_extend:DI (match_operand:QI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_NEON && reload_completed && IS_VFP_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 2) (vec_duplicate:V8QI (match_dup 1)))\n-   (set (match_dup 0) (lshiftrt:DI (match_dup 0) (const_int 56)))]\n-  {\n-    operands[2] = gen_rtx_REG (V8QImode, REGNO (operands[0]));\n-  })"}, {"sha": "a3890674c8618144df4a0e644de0fa550971fd77", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c7c6c5fc13503b2b71aee34d57370ae03531809/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c7c6c5fc13503b2b71aee34d57370ae03531809", "patch": "@@ -1,3 +1,8 @@\n+2019-08-22  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* gcc.target/arm/neon-extend-1.c: Remove test.\n+\t* gcc.target/arm/neon-extend-2.c: Remove test.\n+\n 2019-08-22  Sylvia Taylor  <sylvia.taylor@arm.com>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vld1x4.c: New test."}, {"sha": "cfe83ce1bde260cdd99ae47963dde6676627cca3", "filename": "gcc/testsuite/gcc.target/arm/neon-extend-1.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-extend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-extend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-extend-1.c?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-require-effective-target arm_neon_hw } */\n-/* { dg-options \"-O2\" } */\n-/* { dg-add-options arm_neon } */\n-\n-void\n-f (unsigned int a)\n-{\n-  unsigned long long b = a;\n-  asm volatile (\"@ extended to %0\" : : \"w\" (b));\n-}\n-\n-/* { dg-final { scan-assembler \"vdup.32\" } } */\n-/* { dg-final { scan-assembler \"vshr.u64\" } } */"}, {"sha": "1c5a17e427859146f53828ec4a02b439ab0580ff", "filename": "gcc/testsuite/gcc.target/arm/neon-extend-2.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-extend-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdfc0e863a03698a80c74896cbdc9f5c8c652e64/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-extend-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-extend-2.c?ref=cdfc0e863a03698a80c74896cbdc9f5c8c652e64", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-require-effective-target arm_neon_hw } */\n-/* { dg-options \"-O2\" } */\n-/* { dg-add-options arm_neon } */\n-\n-void\n-f (int a)\n-{\n-  long long b = a;\n-  asm volatile (\"@ extended to %0\" : : \"w\" (b));\n-}\n-\n-/* { dg-final { scan-assembler \"vdup.32\" } } */\n-/* { dg-final { scan-assembler \"vshr.s64\" } } */"}]}