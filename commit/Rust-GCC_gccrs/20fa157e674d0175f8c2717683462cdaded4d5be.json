{"sha": "20fa157e674d0175f8c2717683462cdaded4d5be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBmYTE1N2U2NzRkMDE3NWY4YzI3MTc2ODM0NjJjZGFkZWQ0ZDViZQ==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2019-09-30T14:56:33Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@gcc.gnu.org", "date": "2019-09-30T14:56:33Z"}, "message": "Introduce rtx_alloca, alloca_raw_REG and alloca_rtx_fmt_*\n\nWhen one passes short-lived fake rtxes to backends in order to test\ntheir capabilities, it might be beneficial to allocate these rtxes on\nstack in order to reduce the load on GC.\n\nProvide macro counterparts of some of the gen_* functions for that\npurpose.\n\ngcc/ChangeLog:\n\n2019-09-30  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* emit-rtl.c (init_raw_REG): New function.\n\t(gen_raw_REG): Use init_raw_REG.\n\t* gengenrtl.c (gendef): Emit init_* functions and alloca_*\n\tmacros.\n\t* rtl.c (rtx_alloc_stat_v): Use rtx_init.\n\t* rtl.h (rtx_init): New function.\n\t(rtx_alloca): New function.\n\t(init_raw_REG): New function.\n\t(alloca_raw_REG): New macro.\n\nFrom-SVN: r276303", "tree": {"sha": "352896fb14df54a2a599b18e2707299ae6055830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/352896fb14df54a2a599b18e2707299ae6055830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20fa157e674d0175f8c2717683462cdaded4d5be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20fa157e674d0175f8c2717683462cdaded4d5be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20fa157e674d0175f8c2717683462cdaded4d5be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20fa157e674d0175f8c2717683462cdaded4d5be/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9343bf99b5e36fa11b723aafa282fd5900a5e525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9343bf99b5e36fa11b723aafa282fd5900a5e525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9343bf99b5e36fa11b723aafa282fd5900a5e525"}], "stats": {"total": 108, "additions": 84, "deletions": 24}, "files": [{"sha": "e0acd9d4ba20d86575add15162b27598d443b00d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20fa157e674d0175f8c2717683462cdaded4d5be", "patch": "@@ -1,3 +1,15 @@\n+2019-09-30  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\t* emit-rtl.c (init_raw_REG): New function.\n+\t(gen_raw_REG): Use init_raw_REG.\n+\t* gengenrtl.c (gendef): Emit init_* functions and alloca_*\n+\tmacros.\n+\t* rtl.c (rtx_alloc_stat_v): Use rtx_init.\n+\t* rtl.h (rtx_init): New function.\n+\t(rtx_alloca): New function.\n+\t(init_raw_REG): New function.\n+\t(alloca_raw_REG): New macro.\n+\n 2019-09-30  Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/predicates.md (pcrel_address): Delete predicate."}, {"sha": "783fdb9ef0aaeb2db11985b4eb56e31afa78cc34", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=20fa157e674d0175f8c2717683462cdaded4d5be", "patch": "@@ -466,6 +466,17 @@ set_mode_and_regno (rtx x, machine_mode mode, unsigned int regno)\n   set_regno_raw (x, regno, nregs);\n }\n \n+/* Initialize a fresh REG rtx with mode MODE and register REGNO.  */\n+\n+rtx\n+init_raw_REG (rtx x, machine_mode mode, unsigned int regno)\n+{\n+  set_mode_and_regno (x, mode, regno);\n+  REG_ATTRS (x) = NULL;\n+  ORIGINAL_REGNO (x) = regno;\n+  return x;\n+}\n+\n /* Generate a new REG rtx.  Make sure ORIGINAL_REGNO is set properly, and\n    don't attempt to share with the various global pieces of rtl (such as\n    frame_pointer_rtx).  */\n@@ -474,9 +485,7 @@ rtx\n gen_raw_REG (machine_mode mode, unsigned int regno)\n {\n   rtx x = rtx_alloc (REG MEM_STAT_INFO);\n-  set_mode_and_regno (x, mode, regno);\n-  REG_ATTRS (x) = NULL;\n-  ORIGINAL_REGNO (x) = regno;\n+  init_raw_REG (x, mode, regno);\n   return x;\n }\n "}, {"sha": "eebbc09fd3f356aa6766a244c437f2e50ae0c268", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=20fa157e674d0175f8c2717683462cdaded4d5be", "patch": "@@ -231,31 +231,26 @@ genmacro (int idx)\n   puts (\")\");\n }\n \n-/* Generate the code for the function to generate RTL whose\n-   format is FORMAT.  */\n+/* Generate the code for functions to generate RTL whose format is FORMAT.  */\n \n static void\n gendef (const char *format)\n {\n   const char *p;\n   int i, j;\n \n-  /* Start by writing the definition of the function name and the types\n+  /* Write the definition of the init function name and the types\n      of the arguments.  */\n \n-  printf (\"static inline rtx\\ngen_rtx_fmt_%s_stat (RTX_CODE code, machine_mode mode\", format);\n+  puts (\"static inline rtx\");\n+  printf (\"init_rtx_fmt_%s (rtx rt, machine_mode mode\", format);\n   for (p = format, i = 0; *p != 0; p++)\n     if (*p != '0')\n       printf (\",\\n\\t%sarg%d\", type_from_format (*p), i++);\n+  puts (\")\");\n \n-  puts (\" MEM_STAT_DECL)\");\n-\n-  /* Now write out the body of the function itself, which allocates\n-     the memory and initializes it.  */\n+  /* Now write out the body of the init function itself.  */\n   puts (\"{\");\n-  puts (\"  rtx rt;\");\n-  puts (\"  rt = rtx_alloc (code PASS_MEM_STAT);\\n\");\n-\n   puts (\"  PUT_MODE_RAW (rt, mode);\");\n \n   for (p = format, i = j = 0; *p ; ++p, ++i)\n@@ -266,16 +261,53 @@ gendef (const char *format)\n     else\n       printf (\"  %s (rt, %d) = arg%d;\\n\", accessor_from_format (*p), i, j++);\n \n-  puts (\"\\n  return rt;\\n}\\n\");\n+  puts (\"  return rt;\\n}\\n\");\n+\n+  /* Write the definition of the gen function name and the types\n+     of the arguments.  */\n+\n+  puts (\"static inline rtx\");\n+  printf (\"gen_rtx_fmt_%s_stat (RTX_CODE code, machine_mode mode\", format);\n+  for (p = format, i = 0; *p != 0; p++)\n+    if (*p != '0')\n+      printf (\",\\n\\t%sarg%d\", type_from_format (*p), i++);\n+  puts (\" MEM_STAT_DECL)\");\n+\n+  /* Now write out the body of the function itself, which allocates\n+     the memory and initializes it.  */\n+  puts (\"{\");\n+  puts (\"  rtx rt;\\n\");\n+\n+  puts (\"  rt = rtx_alloc (code PASS_MEM_STAT);\");\n+  printf (\"  return init_rtx_fmt_%s (rt, mode\", format);\n+  for (p = format, i = 0; *p != 0; p++)\n+    if (*p != '0')\n+      printf (\", arg%d\", i++);\n+  puts (\");\\n}\\n\");\n+\n+  /* Write the definition of gen macro.  */\n+\n   printf (\"#define gen_rtx_fmt_%s(c, m\", format);\n   for (p = format, i = 0; *p != 0; p++)\n     if (*p != '0')\n-      printf (\", p%i\",i++);\n-  printf (\")\\\\\\n        gen_rtx_fmt_%s_stat (c, m\", format);\n+      printf (\", arg%d\", i++);\n+  printf (\") \\\\\\n  gen_rtx_fmt_%s_stat ((c), (m)\", format);\n   for (p = format, i = 0; *p != 0; p++)\n     if (*p != '0')\n-      printf (\", p%i\",i++);\n+      printf (\", (arg%d)\", i++);\n   printf (\" MEM_STAT_INFO)\\n\\n\");\n+\n+  /* Write the definition of alloca macro.  */\n+\n+  printf (\"#define alloca_rtx_fmt_%s(c, m\", format);\n+  for (p = format, i = 0; *p != 0; p++)\n+    if (*p != '0')\n+      printf (\", arg%d\", i++);\n+  printf (\") \\\\\\n  init_rtx_fmt_%s (rtx_alloca ((c)), (m)\", format);\n+  for (p = format, i = 0; *p != 0; p++)\n+    if (*p != '0')\n+      printf (\", (arg%d)\", i++);\n+  printf (\")\\n\\n\");\n }\n \n /* Generate the documentation header for files we write.  */"}, {"sha": "0be52d38d934af29954c1d83c771398747500d36", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=20fa157e674d0175f8c2717683462cdaded4d5be", "patch": "@@ -219,12 +219,7 @@ rtx_alloc_stat_v (RTX_CODE code MEM_STAT_DECL, int extra)\n   rtx rt = ggc_alloc_rtx_def_stat (RTX_CODE_SIZE (code) + extra\n \t\t\t\t   PASS_MEM_STAT);\n \n-  /* We want to clear everything up to the FLD array.  Normally, this\n-     is one int, but we don't want to assume that and it isn't very\n-     portable anyway; this is.  */\n-\n-  memset (rt, 0, RTX_HDR_SIZE);\n-  PUT_CODE (rt, code);\n+  rtx_init (rt, code);\n \n   if (GATHER_STATISTICS)\n     {"}, {"sha": "b75b3ed6759d96531b76d61ddbbefdd0595e4a37", "filename": "gcc/rtl.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20fa157e674d0175f8c2717683462cdaded4d5be/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=20fa157e674d0175f8c2717683462cdaded4d5be", "patch": "@@ -2957,6 +2957,15 @@ extern HOST_WIDE_INT get_stack_check_protect (void);\n \n /* In rtl.c */\n extern rtx rtx_alloc (RTX_CODE CXX_MEM_STAT_INFO);\n+inline rtx\n+rtx_init (rtx rt, RTX_CODE code)\n+{\n+  memset (rt, 0, RTX_HDR_SIZE);\n+  PUT_CODE (rt, code);\n+  return rt;\n+}\n+#define rtx_alloca(code) \\\n+  rtx_init ((rtx) alloca (RTX_CODE_SIZE ((code))), (code))\n extern rtx rtx_alloc_stat_v (RTX_CODE MEM_STAT_DECL, int);\n #define rtx_alloc_v(c, SZ) rtx_alloc_stat_v (c MEM_STAT_INFO, SZ)\n #define const_wide_int_alloc(NWORDS)\t\t\t\t\\\n@@ -3823,7 +3832,10 @@ gen_rtx_INSN (machine_mode mode, rtx_insn *prev_insn, rtx_insn *next_insn,\n extern rtx gen_rtx_CONST_INT (machine_mode, HOST_WIDE_INT);\n extern rtx gen_rtx_CONST_VECTOR (machine_mode, rtvec);\n extern void set_mode_and_regno (rtx, machine_mode, unsigned int);\n+extern rtx init_raw_REG (rtx, machine_mode, unsigned int);\n extern rtx gen_raw_REG (machine_mode, unsigned int);\n+#define alloca_raw_REG(mode, regno) \\\n+  init_raw_REG (rtx_alloca (REG), (mode), (regno))\n extern rtx gen_rtx_REG (machine_mode, unsigned int);\n extern rtx gen_rtx_SUBREG (machine_mode, rtx, poly_uint64);\n extern rtx gen_rtx_MEM (machine_mode, rtx);"}]}