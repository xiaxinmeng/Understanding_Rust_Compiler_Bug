{"sha": "b980edba506442c846cc779243ceeffd13065740", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4MGVkYmE1MDY0NDJjODQ2Y2M3NzkyNDNjZWVmZmQxMzA2NTc0MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-03-19T08:21:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-03-19T08:25:23Z"}, "message": "Fix segfault during encoding of CONSTRUCTORs\n\nThe segfault occurs in native_encode_initializer when it is encoding the\nCONSTRUCTOR for an array whose lower bound is negative (it's OK in Ada).\nThe computation of the current position is done in HOST_WIDE_INT and this\ndoes not work for arrays whose original range has a negative lower bound\nand a positive upper bound; the computation must be done in sizetype\ninstead so that it may wrap around.\n\ngcc/\n\tPR middle-end/99641\n\t* fold-const.c (native_encode_initializer) <CONSTRUCTOR>: For an\n\tarray type, do the computation of the current position in sizetype.", "tree": {"sha": "0cc3db8d427a637ef5e93d1ac113907e6e4e971c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cc3db8d427a637ef5e93d1ac113907e6e4e971c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b980edba506442c846cc779243ceeffd13065740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b980edba506442c846cc779243ceeffd13065740", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b980edba506442c846cc779243ceeffd13065740", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b980edba506442c846cc779243ceeffd13065740/comments", "author": null, "committer": null, "parents": [{"sha": "287e3e8466f44f9d395a2e4dcfcda56cc34ceb1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287e3e8466f44f9d395a2e4dcfcda56cc34ceb1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/287e3e8466f44f9d395a2e4dcfcda56cc34ceb1c"}], "stats": {"total": 45, "additions": 32, "deletions": 13}, "files": [{"sha": "1ebc73d065a5d952fa94606f4a9e9951cd8859cc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b980edba506442c846cc779243ceeffd13065740/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b980edba506442c846cc779243ceeffd13065740/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b980edba506442c846cc779243ceeffd13065740", "patch": "@@ -8051,21 +8051,21 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n       int o = off == -1 ? 0 : off;\n       if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n-\t  HOST_WIDE_INT min_index;\n+\t  tree min_index;\n \t  unsigned HOST_WIDE_INT cnt;\n \t  HOST_WIDE_INT curpos = 0, fieldsize, valueinit = -1;\n \t  constructor_elt *ce;\n \n-\t  if (TYPE_DOMAIN (type) == NULL_TREE\n-\t      || !tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type))))\n+\t  if (!TYPE_DOMAIN (type)\n+\t      || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST)\n \t    return 0;\n \n \t  fieldsize = int_size_in_bytes (TREE_TYPE (type));\n \t  if (fieldsize <= 0)\n \t    return 0;\n \n-\t  min_index = tree_to_shwi (TYPE_MIN_VALUE (TYPE_DOMAIN (type)));\n-\t  if (ptr != NULL)\n+\t  min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n+\t  if (ptr)\n \t    memset (ptr, '\\0', MIN (total_bytes - off, len));\n \n \t  for (cnt = 0; ; cnt++)\n@@ -8084,21 +8084,40 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\tbreak;\n \t      else\n \t\tpos = total_bytes;\n+\n \t      if (index && TREE_CODE (index) == RANGE_EXPR)\n \t\t{\n-\t\t  if (!tree_fits_shwi_p (TREE_OPERAND (index, 0))\n-\t\t      || !tree_fits_shwi_p (TREE_OPERAND (index, 1)))\n+\t\t  if (TREE_CODE (TREE_OPERAND (index, 0)) != INTEGER_CST\n+\t\t      || TREE_CODE (TREE_OPERAND (index, 1)) != INTEGER_CST)\n+\t\t    return 0;\n+\t\t  offset_int wpos\n+\t\t    = wi::sext (wi::to_offset (TREE_OPERAND (index, 0))\n+\t\t\t\t- wi::to_offset (min_index),\n+\t\t\t\tTYPE_PRECISION (sizetype));\n+\t\t  wpos *= fieldsize;\n+\t\t  if (!wi::fits_shwi_p (pos))\n \t\t    return 0;\n-\t\t  pos = (tree_to_shwi (TREE_OPERAND (index, 0)) - min_index)\n-\t\t\t* fieldsize;\n-\t\t  count = (tree_to_shwi (TREE_OPERAND (index, 1))\n-\t\t\t   - tree_to_shwi (TREE_OPERAND (index, 0)));\n+\t\t  pos = wpos.to_shwi ();\n+\t\t  offset_int wcount\n+\t\t    = wi::sext (wi::to_offset (TREE_OPERAND (index, 1))\n+\t\t\t\t- wi::to_offset (TREE_OPERAND (index, 0)),\n+\t\t\t\tTYPE_PRECISION (sizetype));\n+\t\t  if (!wi::fits_shwi_p (wcount))\n+\t\t    return 0;\n+\t\t  count = wcount.to_shwi ();\n \t\t}\n \t      else if (index)\n \t\t{\n-\t\t  if (!tree_fits_shwi_p (index))\n+\t\t  if (TREE_CODE (index) != INTEGER_CST)\n+\t\t    return 0;\n+\t\t  offset_int wpos\n+\t\t    = wi::sext (wi::to_offset (index)\n+\t\t\t\t- wi::to_offset (min_index),\n+\t\t\t\tTYPE_PRECISION (sizetype));\n+\t\t  wpos *= fieldsize;\n+\t\t  if (!wi::fits_shwi_p (wpos))\n \t\t    return 0;\n-\t\t  pos = (tree_to_shwi (index) - min_index) * fieldsize;\n+\t\t  pos = wpos.to_shwi ();\n \t\t}\n \n \t      if (mask && !CONSTRUCTOR_NO_CLEARING (init) && curpos != pos)"}]}