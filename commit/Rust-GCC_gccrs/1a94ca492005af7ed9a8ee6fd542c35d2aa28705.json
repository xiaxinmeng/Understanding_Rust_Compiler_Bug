{"sha": "1a94ca492005af7ed9a8ee6fd542c35d2aa28705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE5NGNhNDkyMDA1YWY3ZWQ5YThlZTZmZDU0MmMzNWQyYWEyODcwNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-21T11:32:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-21T11:32:36Z"}, "message": "Initial revision\n\nFrom-SVN: r2539", "tree": {"sha": "f787ffcba9843c446027ad51f24d2ebfd63e79f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f787ffcba9843c446027ad51f24d2ebfd63e79f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a94ca492005af7ed9a8ee6fd542c35d2aa28705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a94ca492005af7ed9a8ee6fd542c35d2aa28705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a94ca492005af7ed9a8ee6fd542c35d2aa28705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a94ca492005af7ed9a8ee6fd542c35d2aa28705/comments", "author": null, "committer": null, "parents": [{"sha": "2f6f882470d32cc42a74a2eae7b244f7b020d3e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6f882470d32cc42a74a2eae7b244f7b020d3e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6f882470d32cc42a74a2eae7b244f7b020d3e7"}], "stats": {"total": 1559, "additions": 1559, "deletions": 0}, "files": [{"sha": "8c4be54902fd0fb3dca93edcf5d4e1936cb5378b", "filename": "gcc/config/alpha/alpha.h", "status": "added", "additions": 1559, "deletions": 0, "changes": 1559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a94ca492005af7ed9a8ee6fd542c35d2aa28705/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a94ca492005af7ed9a8ee6fd542c35d2aa28705/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=1a94ca492005af7ed9a8ee6fd542c35d2aa28705", "patch": "@@ -0,0 +1,1559 @@\n+/* Definitions of target machine for GNU compiler, for DEC Alpha.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"\\\n+-Dunix -D__osf__ -D__alpha -D__alpha__ -D_LONGLONG -DSYSTYPE_BSD  \\\n+-D_SYSTYPE_BSD\"\n+\n+/* Write out the correct language type definition for the header files.  */\n+#define CPP_SPEC \"\\\n+%{.c:\t-D__LANGUAGE_C__  -D__LANGUAGE_C %{!ansi:-DLANGUAGE_C}}  \\\n+%{.h:\t-D__LANGUAGE_C__  -D__LANGUAGE_C %{!ansi:-DLANGUAGE_C}}  \\\n+%{.S:\t-D__LANGUAGE_ASSEMBLY__ -D__LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n+%{.cc:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS} \\\n+%{.cxx:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS} \\\n+%{.C:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS} \\\n+%{.m:\t-D__LANGUAGE_OBJECTIVE_C__ -D__LANGUAGE_OBJECTIVE_C}\"\n+\n+/* Set the spec to use for signed char.  The default tests the above macro\n+   but DEC's compiler can't handle the conditional in a \"constant\"\n+   operand.  */\n+\n+#define SIGNED_CHAR_SPEC \"%{funsigned-char:-D__CHAR_UNSIGNED__}\"\n+\n+/* Right now Alpha OSF/1 doesn't seem to have debugging or profiled \n+   libraries.  */\n+\n+#define LIB_SPEC \"-lc\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION\n+\n+/* Define the location for the startup file on OSF/1 for Alpha.  */\n+\n+#define MD_STARTFILE_PREFIX \"/usr/lib/cmplrs/cc/\"\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* This means that floating-point support exists in the target implementation\n+   of the Alpha architecture.  This is usually the default.  */\n+\n+#define TARGET_FP\t(target_flags & 1)\n+\n+/* This means that floating-point registers are allowed to be used.  Note\n+   that Alpha implementations without FP operations are required to\n+   provide the FP registers.  */\n+\n+#define TARGET_FPREGS (target_flags & 2)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES\t\t\t\\\n+  { {\"no-soft-float\", 1},\t\t\\\n+    {\"soft-float\", -1},\t\t\t\\\n+    {\"fp-regs\", 2},\t\t\t\\\n+    {\"no-fp-regs\", -3},\t\t\t\\\n+    {\"\", TARGET_DEFAULT} }\n+\n+#define TARGET_DEFAULT 3\n+\n+/* Define this macro to change register usage conditional on target flags.\n+\n+   On the Alpha, we use this to disable the floating-point registers when\n+   they don't exist.  */\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\\\n+  if (! TARGET_FPREGS)\t\t\t\\\n+    for (i = 32; i < 64; i++)\t\t\\\n+      fixed_regs[i] = call_used_regs[i] = 1;\n+\n+/* Define this to change the optimizations performed by default.  */\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL)\t\\\n+{\t\t\t\t\t\\\n+  if ((LEVEL) > 0)\t\t\t\\\n+    {\t\t\t\t\t\\\n+      flag_force_addr = 1;\t\t\\\n+      flag_force_mem = 1;\t\t\\\n+      flag_omit_frame_pointer = 1;\t\\\n+    }\t\t\t\t\t\\\n+}\n+\f\n+/* target machine storage layout */\n+\n+/* Define the size of `int'.  The default is the same as the word size.  */\n+#define INT_TYPE_SIZE 32\n+\n+/* Define the size of `long long'.  The default is the twice the word size.  */\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+/* The two floating-point formats we support are S-floating, which is\n+   4 bytes, and T-floating, which is 8 bytes.  `float' is S and `double'\n+   and `long double' are T.  */\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Define this macro if it is advisible to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.\n+\n+   For Alpha, we always store objects in a full register.  32-bit objects\n+   are always sign-extended, but smaller objects retain their signedness.  */\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((MODE) == SImode)\t\t\t\\\n+\t(UNSIGNEDP) = 0;\t\t\t\\\n+      (MODE) = DImode;\t\t\t\t\\\n+    }\n+\n+/* Define this if function arguments should also be promoted using the above\n+   procedure.  */\n+\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* Likewise, if the function return value is promoted.  */\n+\n+#define PROMOTE_FUNCTION_RETURN\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+\n+   There are no such instructions on the Alpha, but the documentation\n+   is little endian.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.\n+   This is false on the Alpha.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered.\n+\n+   For Alpha we can decide arbitrarily since there are no machine instructions\n+   for them.  Might as well be consistent with bytes. */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 64\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 8\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 64\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 64\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 64\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 64\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Align loop starts for optimal branching. \n+\n+   Don't do this until they fix the assembler.  */\n+\n+/* #define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n+  ASM_OUTPUT_ALIGN (FILE, 5)  */\n+\n+/* This is how to align an instruction for optimal branching.\n+   On Alpha we'll get better performance by aligning on a quadword\n+   boundary.  */\n+#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n+  ASM_OUTPUT_ALIGN ((FILE), 4)\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Set this non-zero if move instructions will actually fail to work\n+   when given unaligned data.\n+\n+   Since we get an error message when we do one, call them invalid.  */\n+\n+#define STRICT_ALIGNMENT 1\n+\n+/* Set this non-zero if unaligned move instructions are extremely slow.\n+\n+   On the Alpha, they trap.  */\n+/* #define SLOW_UNALIGNED_ACCESS 1  */\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   We define all 32 integer registers, even though $31 is always zero,\n+   and all 32 floating-point registers, even though $f31 is also\n+   always zero.  We do not bother defining the FP status register and\n+   there are no other registers.  */\n+\n+#define FIRST_PSEUDO_REGISTER 64\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, \\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   We allocate in the following order:\n+   $f1\t\t\t(nonsaved floating-point register)\n+   $f10-$f15\t\t(likewise)\n+   $f22-$f30\t\t(likewise)\n+   $f21-$f16\t\t(likewise, but input args)\n+   $f0\t\t\t(nonsaved, but return value)\n+   $f2-$f9\t\t(saved floating-point registers)\n+   $1-$8\t\t(nonsaved integer registers)\n+   $22-$25\t\t(likewise)\n+   $28\t\t\t(likewise)\n+   $0\t\t\t(likewise, but return value)\n+   $21-$16\t\t(likewise, but input args)\n+   $27\t\t\t(procedure value)\n+   $9-$14\t\t(saved integer registers)\n+   $26\t\t\t(return PC)\n+   $15\t\t\t(frame pointer)\n+   $29\t\t\t(global pointer)\n+   $30, $31, $f31\t(stack pointer and always zero)  */\n+\n+#define REG_ALLOC_ORDER\t\t\\\n+  {33,\t\t\t\t\t\\\n+   42, 43, 44, 45,\t\t\t\\\n+   54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n+   53, 52, 51, 50, 49, 48,\t\t\\\n+   32,\t\t\t\t\t\\\n+   34, 35, 36, 37, 38, 39, 40, 41,\t\\\n+   1, 2, 3, 4, 5, 6, 7, 8,\t\t\\\n+   22, 23, 24, 25,\t\t\t\\\n+   28,\t\t\t\t\t\\\n+   0,\t\t\t\t\t\\\n+   21, 20, 19, 18, 17, 16,\t\t\\\n+   27,\t\t\t\t\t\\\n+   9, 10, 11, 12, 13, 14,\t\t\\\n+   26,\t\t\t\t\t\\\n+   15,\t\t\t\t\t\\\n+   29,\t\t\t\t\t\\\n+   30, 31, 63 }\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On Alpha, the integer registers can hold any mode.  The floating-point\n+   registers can hold 32-bit and 64-bit integers as well, but not 16-bit\n+   or 8-bit values.  If we only allowed the larger integers into FP registers,\n+   we'd have to say that QImode and SImode aren't tiable, which is a\n+   pain.  So say all registers can hold everything and see how that works.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Alpha pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 30\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 15\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 15\n+\n+/* Register in which static-chain is passed to a function. \n+\n+   For the Alpha, this is based on an example; the calling sequence\n+   doesn't seem to specify this.  */\n+#define STATIC_CHAIN_REGNUM 1\n+\n+/* Register in which address to store a structure value\n+   arrives in the function.  On the Alpha, the address is passed\n+   as a hidden argument.  */\n+#define STRUCT_VALUE 0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n+\t\t LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES\t\t\t\t\\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"FLOAT_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+  { {0, 0}, {~0, 0}, {0, ~0}, {~0, ~0} }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) ((REGNO) >= 32 ? FLOAT_REGS : GENERAL_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\\\n+ ((C) == 'f' ? FLOAT_REGS : NO_REGS)\n+\n+/* Define this macro to change register usage conditional on target flags.  */\n+/* #define CONDITIONAL_REGISTER_USAGE  */\n+\n+/* The letters I, J, K, L, M, N, O, and P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For Alpha:\n+   `I' is used for the range of constants most insns can contain.\n+   `J' is the constant zero.\n+   `K' is used for the constant in an LDA insn.\n+   `L' is used for the constant in a LDAH insn.\n+   `M' is used for the constants that can be AND'ed with using a ZAP insn.\n+   `N' is used for complemented 8-bit constants.\n+   `O' is used for negated 8-bit constants.\n+   `P' is used for the constants 1, 2 and 3.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'I' ? (unsigned HOST_WIDE_INT) (VALUE) < 0x100\t\\\n+   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\t\\\n+   : (C) == 'K' ? (unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000\t\\\n+   : (C) == 'L' ? (((VALUE) & 0xffff) == 0\t\t\t\\\n+\t\t   && (((VALUE)) >> 31 == -1 || (VALUE) >> 31 == 0)) \\\n+   : (C) == 'M' ? zap_mask (VALUE)\t\t\t\t\\\n+   : (C) == 'N' ? (unsigned HOST_WIDE_INT) (~ (VALUE)) < 0x100\t\\\n+   : (C) == 'O' ? (unsigned HOST_WIDE_INT) (- (VALUE)) < 0x100\t\\\n+   : (C) == 'P' ? (VALUE) == 1 || (VALUE) == 2 || (VALUE) == 3\t\\\n+   : 0)\n+\n+/* Similar, but for floating or large integer constants, and defining letters\n+   G and H.   Here VALUE is the CONST_DOUBLE rtx itself.\n+\n+   For Alpha, `G' is the floating-point constant zero.  `H' is a CONST_DOUBLE\n+   that is the operand of a ZAP insn.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \t\t\t\\\n+  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\\\n+\t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n+   : (C) == 'H' ? (GET_MODE (VALUE) == VOIDmode\t\t\t\t\\\n+\t\t   && zap_mask (CONST_DOUBLE_LOW (VALUE))\t\t\\\n+\t\t   && zap_mask (CONST_DOUBLE_HIGH (VALUE)))\t\t\\\n+   : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+\n+   On the Alpha, all constants except zero go into a floating-point\n+   register via memory.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\\\n+  (CONSTANT_P (X) && (X) != const0_rtx && (X) != CONST0_RTX (GET_MODE (X)) \\\n+   ? ((CLASS) == FLOAT_REGS ? NO_REGS : GENERAL_REGS)\t\t\t\\\n+   : (CLASS))\n+\n+/* Loading and storing HImode or QImode values to and from memory\n+   usually requires a scratch register.  The exceptions are loading\n+   QImode and HImode from an aligned address to a general register. */\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN)\t\t\t\\\n+(((GET_CODE (IN) == MEM \t\t\t\t\t\t\\\n+   || (GET_CODE (IN) == REG && REGNO (IN) >= FIRST_PSEUDO_REGISTER)\t\\\n+   || (GET_CODE (IN) == SUBREG\t\t\t\t\t\t\\\n+       && (GET_CODE (SUBREG_REG (IN)) == MEM\t\t\t\t\\\n+\t   || (GET_CODE (SUBREG_REG (IN)) == REG\t\t\t\\\n+\t       && REGNO (SUBREG_REG (IN)) >= FIRST_PSEUDO_REGISTER))))\t\\\n+  && (((CLASS) == FLOAT_REGS\t\t\t\t\t\t\\\n+       && ((MODE) == SImode || (MODE) == HImode || (MODE) == QImode))\t\\\n+      || (((MODE) == QImode || (MODE) == HImode)\t\t\t\\\n+\t  && unaligned_memory_operand (IN, MODE))))\t\t\t\\\n+ ? GENERAL_REGS : NO_REGS)\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT)\t\t\t\\\n+(((GET_CODE (OUT) == MEM \t\t\t\t\t\t\\\n+   || (GET_CODE (OUT) == REG && REGNO (OUT) >= FIRST_PSEUDO_REGISTER)\t\\\n+   || (GET_CODE (OUT) == SUBREG\t\t\t\t\t\t\\\n+       && (GET_CODE (SUBREG_REG (OUT)) == MEM\t\t\t\t\\\n+\t   || (GET_CODE (SUBREG_REG (OUT)) == REG\t\t\t\\\n+\t       && REGNO (SUBREG_REG (OUT)) >= FIRST_PSEUDO_REGISTER)))) \\\n+  && (((MODE) == HImode || (MODE) == QImode\t\t\t\t\\\n+       || ((MODE) == SImode && (CLASS) == FLOAT_REGS))))\t\t\\\n+ ? GENERAL_REGS : NO_REGS)\n+\n+/* If we are copying between general and FP registers, we need a memory\n+   location.  */\n+\n+#define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE) ((CLASS1) != (CLASS2))\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Define the cost of moving between registers of various classes.  Moving\n+   between FLOAT_REGS and anything else except float regs is expensive. \n+   In fact, we make it quite expensive because we really don't want to\n+   do these moves unless it is clearly worth it.  Optimizations may\n+   reduce the impact of not being able to allocate a pseudo to a\n+   hard register.  */\n+\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\\\n+  (((CLASS1) == FLOAT_REGS) == ((CLASS2) == FLOAT_REGS) ? 2 : 20)\n+\n+/* A C expressions returning the cost of moving data of MODE from a register to\n+   or from memory.\n+\n+   On the Alpha, bump this up a bit.  */\n+\n+#define MEMORY_MOVE_COST(MODE)  6\n+\n+/* Provide the cost of a branch.  Exact meaning under development.  */\n+#define BRANCH_COST 5\n+\n+/* Adjust the cost of dependencies.  */\n+\n+#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n+  (COST) = alpha_adjust_cost (INSN, LINK, DEP, COST)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET (- current_function_pretend_args_size)\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On Alpha, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Define this if the maximum size of all the outgoing args is to be\n+   accumulated and pushed during the prologue.  The amount can be\n+   found in the variable current_function_outgoing_args_size.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) (- current_function_pretend_args_size)\n+\n+/* Definitions for register eliminations.\n+\n+   We have one register that can be eliminated on the Alpha.  The\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.\n+\n+   In addition, we use the elimination mechanism to see if gp (r29) is needed.\n+   Initially we assume that it isn't.  If it is, we spill it.  This is done\n+   by making it an eliminable register.  It doesn't matter what we replace\n+   it with, since it will never occur in the rtl at this point.  */\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { 29, 0}}\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.\n+\n+   We need gp (r29) if we have calls or load symbols\n+   (tested in alpha_need_gp).\n+\n+   All other eliminations are valid since the cases where FP can't be\n+   eliminated are already handled.  */\n+\n+#define CAN_ELIMINATE(FROM, TO) ((FROM) == 29 ? ! alpha_need_gp () : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+    (OFFSET) = (get_frame_size () + current_function_outgoing_args_size \\\n+\t\t+ current_function_pretend_args_size\t\t\t\\\n+\t\t+ alpha_sa_size () + 15) & ~ 15;\t\t\t\\\n+}\n+\n+/* Define this if stack space is still allocated for a parameter passed\n+   in a register.  */\n+/* #define REG_PARM_STACK_SPACE */\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.\n+\n+   On Alpha the value is found in $0 for integer functions and\n+   $f0 for floating-point functions.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n+  gen_rtx (REG,\t\t\t\t\t\t\\\n+\t   ((TREE_CODE (VALTYPE) == INTEGER_TYPE\t\\\n+\t     || TREE_CODE (VALTYPE) == ENUMERAL_TYPE\t\\\n+\t     || TREE_CODE (VALTYPE) == BOOLEAN_TYPE\t\\\n+\t     || TREE_CODE (VALTYPE) == CHAR_TYPE\t\\\n+\t     || TREE_CODE (VALTYPE) == POINTER_TYPE\t\\\n+\t     || TREE_CODE (VALTYPE) == OFFSET_TYPE)\t\\\n+\t    && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD) \\\n+\t   ? word_mode : TYPE_MODE (VALTYPE),\t\t\\\n+\t   TARGET_FPREGS && TREE_CODE (VALTYPE) == REAL_TYPE ? 32 : 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)\t\\\n+   gen_rtx (REG, MODE,\t\t\\\n+\t    TARGET_FPREGS && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 0)\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 32)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On Alpha, these are $16-$21 and $f16-$f21.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  (((N) >= 16 && (N) <= 21) || ((N) >= 16 + 32 && (N) <= 21 + 32))\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On Alpha, this is a single integer, which is a number of words\n+   of arguments scanned so far.\n+   Thus 6 or more means all following args should go on the stack.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)  (CUM) = 0\n+\n+/* Define intermediate macro to compute the size (in registers) of an argument\n+   for the Alpha.  */\n+\n+#define ALPHA_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n+((MODE) != BLKmode\t\t\t\t\t\t\t\\\n+ ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n+ : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\t\\\n+    (CUM) = 6;\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    (CUM) += ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On Alpha the first 6 words of args are normally in registers\n+   and the rest are pushed.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+((CUM) < 6 && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\\\n+ ? gen_rtx(REG, (MODE),\t\t\t\t\\\n+\t   (CUM) + 16 + (TARGET_FPREGS\t\t\\\n+\t\t\t && GET_MODE_CLASS (MODE) == MODE_FLOAT) * 32) : 0)\n+\n+/* This indicates that an argument is to be passed with an invisible reference\n+   (i.e., a pointer to the object is passed).\n+\n+   On the Alpha, we do this if it must be passed on the stack.  */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (MUST_PASS_IN_STACK (MODE, TYPE))\n+\n+/* Specify the padding direction of arguments.\n+\n+   On the Alpha, we must pad upwards in order to be able to pass args in\n+   registers.  */\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\tupward\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n+((CUM) < 6 && 6 < (CUM) + ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\t\\\n+ ? 6 - (CUM) : 0)\n+\n+/* Generate necessary RTL for __builtin_saveregs().\n+   ARGLIST is the argument list; see expr.c.  */\n+extern struct rtx_def *alpha_builtin_saveregs ();\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) alpha_builtin_saveregs (ARGLIST)\n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+\n+extern struct rtx_def *alpha_compare_op0, *alpha_compare_op1;\n+extern int alpha_compare_fp_p;\n+\n+/* This macro produces the initial definition of a function name.  On the\n+   29k, we need to save the function name for the epilogue.  */\n+\n+extern char *alpha_function_name;\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n+ { fprintf (FILE, \"\\t.ent %s 2\\n\", NAME);\t\t\\\n+   ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\\\n+   alpha_function_name = NAME;\t\t\t\t\\\n+}\n+   \n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)  output_prolog (FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\toutput_epilog (FILE, SIZE)\n+\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.  We\n+   use $28 (at) as a temporary.  Note that $27 has been set to the\n+   address of the trampoline, so we can use it for addressability\n+   of the two data items.  Trampolines are always aligned to\n+   FUNCTION_BOUNDARY, which is 64 bits.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n+{\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tbis $27,$27,$28\\n\");\t\\\n+  fprintf (FILE, \"\\tldq $27,16($27)\\n\");\t\\\n+  fprintf (FILE, \"\\tldq $1,20($28)\\n\");\t\t\\\n+  fprintf (FILE, \"\\tjmp $31,0($27),0\\n\");\t\\\n+  fprintf (FILE, \"\\t.quad 0,0\\n\");\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE    24\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  We assume\n+   here that a function will be called many more times than its address\n+   is taken (e.g., it might be passed to qsort), so we take the trouble \n+   to initialize the \"hint\" field in the JMP insn.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx _temp, _temp1, _addr;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  _addr = memory_address (Pmode, plus_constant ((TRAMP), 16));\t\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode, _addr), (FNADDR));\t\t\\\n+  _addr = memory_address (Pmode, plus_constant ((TRAMP), 20));\t\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode, _addr), (CXT));\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  _temp = expand_shift (RSHIFT_EXPR, Pmode, (FNADDR),\t\t\t\\\n+\t\t\tbuild_int_2 (2, 0), NULL_RTX, 1);\t\t\\\n+  _temp = expand_and (_temp, GEN_INT (0x1fff), 0); \t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  _addr = memory_address (SImode, plus_constant ((TRAMP), 12));\t\t\\\n+  _temp1 = force_reg (SImode, gen_rtx (MEM, SImode, _addr));\t\t\\\n+  _temp1 = expand_and (_temp, GEN_INT (0xfffe000), NULL_RTX);\t\t\\\n+  _temp1 = expand_binop (SImode, ior_optab, _temp1, _temp, _temp1, 1,\t\\\n+\t\t\t OPTAB_WIDEN);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, _addr), _temp1);\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+(((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Recognize any constant value that is a valid address.  For the Alpha,\n+   there are only constants none since we want to use LDA to load any\n+   symbolic addresses into registers.  */\n+\n+#define CONSTANT_ADDRESS_P(X)   \\\n+  (GET_CODE (X) == CONST_INT\t\\\n+   && (unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n+\n+/* Include all constant integers and constant doubles, but not\n+   floating-point, except for floating-point zero.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X)  \t\t\\\n+  (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n+   || (X) == CONST0_RTX (GET_MODE (X)))\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 0\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X)  \\\n+  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address. \n+\n+   For Alpha, we have either a constant address or the sum of a register\n+   and a constant address, or just a register.  For DImode, any of those\n+   forms can be surrounded with an AND that clear the low-order three bits;\n+   this is an \"unaligned\" access.\n+\n+   We also allow a SYMBOL_REF that is the name of the current function as\n+   valid address.  This is for CALL_INSNs.  It cannot be used in any other\n+   context.\n+\n+   First define the basic valid address.  */\n+\n+#define GO_IF_LEGITIMATE_SIMPLE_ADDRESS(MODE, X, ADDR) \\\n+{ if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P (X))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\\\n+      && REG_P (XEXP (X, 0))\t\t\t\\\n+      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\\\n+      && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+\n+/* Now accept the simple address, or, for DImode only, an AND of a simple\n+   address that turns off the low three bits.  */\n+\n+extern char *current_function_name;\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+{ GO_IF_LEGITIMATE_SIMPLE_ADDRESS (MODE, X, ADDR); \\\n+  if ((MODE) == DImode\t\t\t\t\\\n+      && GET_CODE (X) == AND\t\t\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n+      && INTVAL (XEXP (X, 1)) == -8)\t\t\\\n+    GO_IF_LEGITIMATE_SIMPLE_ADDRESS (MODE, XEXP (X, 0), ADDR); \\\n+  if ((MODE) == Pmode && GET_CODE (X) == SYMBOL_REF\t\\\n+      && ! strcmp (XSTR (X, 0), current_function_name))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output. \n+\n+   For the Alpha, there are three cases we handle:\n+\n+   (1) If the address is (plus reg const_int) and the CONST_INT is not a\n+       valid offset, compute the high part of the constant and add it to the\n+       register.  Then our address is (plus temp low-part-const).\n+   (2) If the address is (const (plus FOO const_int)), find the low-order\n+       part of the CONST_INT.  Then load FOO plus any high-order part of the\n+       CONST_INT into a register.  Our address is (plus reg low-part-const).\n+       This is done to reduce the number of GOT entries.\n+   (3) If we have a (plus reg const), emit the load as in (2), then add\n+       the two registers, and finally generate (plus reg low-part-const) as\n+       our address.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+      && ! CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\\\n+      HOST_WIDE_INT lowpart = (val & 0xffff) - 2 * (val & 0x8000); \\\n+      HOST_WIDE_INT highpart = val - lowpart;\t\t\t\\\n+      rtx high = GEN_INT (highpart);\t\t\t\t\\\n+      rtx temp = expand_binop (Pmode, add_optab, XEXP (x, 0),\t\\\n+\t\t\t       high, 0, OPTAB_LIB_WIDEN);\t\\\n+\t\t\t\t\t\t\t\t\\\n+      (X) = plus_constant (temp, lowpart);\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST\t\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (X, 0), 1));\t\\\n+      HOST_WIDE_INT lowpart = (val & 0xffff) - 2 * (val & 0x8000); \\\n+      HOST_WIDE_INT highpart = val - lowpart;\t\t\t\\\n+      rtx high = XEXP (XEXP (X, 0), 0);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (highpart)\t\t\t\t\t\t\\\n+\thigh = plus_constant (high, highpart);\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      (X) = plus_constant (force_reg (Pmode, high), lowpart);\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG \\\n+\t   && GET_CODE (XEXP (X, 1)) == CONST\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (X, 1), 0)) == PLUS\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (XEXP (X, 1), 0), 1)) == CONST_INT) \\\n+    {\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (X, 1), 0), 1)); \\\n+      HOST_WIDE_INT lowpart = (val & 0xffff) - 2 * (val & 0x8000); \\\n+      HOST_WIDE_INT highpart = val - lowpart;\t\t\t\\\n+      rtx high = XEXP (XEXP (XEXP (X, 1), 0), 0);\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (highpart)\t\t\t\t\t\t\\\n+\thigh = plus_constant (high, highpart);\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      high = expand_binop (Pmode, add_optab, XEXP (X, 0),\t\\\n+\t\t\t   force_reg (Pmode, high),\t\t\\\n+\t\t\t   high, OPTAB_LIB_WIDEN);\t\t\\\n+      (X) = plus_constant (high, lowpart);\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the Alpha this is true only for the unaligned modes.   We can\n+   simplify this test since we know that the address must be valid.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+{ if (GET_CODE (ADDR) == AND) goto LABEL; }\n+\n+/* Compute the cost of an address.  For the Alpha, all valid addresses are\n+   the same cost.  */\n+\n+#define ADDRESS_COST(X)  0\n+\n+/* Define this if some processing needs to be done immediately before\n+   emitting code for an insn.  */\n+\n+/* #define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS) */\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.\n+\n+   We actually lie a bit here as overflow conditions are different.  But\n+   they aren't being checked anyway.  */\n+\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move to or from memory\n+   in one reasonably fast instruction.  */\n+\n+#define MOVE_MAX 8\n+\n+/* Largest number of bytes of an object that can be placed in a register.\n+   On the Alpha we have plenty of registers, so use TImode.  */\n+#define MAX_FIXED_MODE_SIZE\tGET_MODE_BITSIZE (TImode)\n+\n+/* Nonzero if access to memory by bytes is no faster than for words.\n+   Also non-zero if doing byte operations (specifically shifts) in registers\n+   is undesirable. \n+\n+   On the Alpha, we want to not use the byte operation and instead use\n+   masking operations to access fields; these will save instructions.  */\n+\n+#define SLOW_BYTE_ACCESS\t1\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bits in the register.  */\n+/* #define BYTE_LOADS_ZERO_EXTEND  */\n+\n+/* Define if normal loads of shorter-than-word items from memory sign-extends\n+   the rest of the bits in the register.  */\n+#define BYTE_LOADS_SIGN_EXTEND\n+\n+/* We aren't doing ANYTHING about debugging for now.  */\n+/* #define SDB_DEBUGGING_INFO */\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* Don't try to use the `x' type-cross-reference character in DBX data.\n+   Also has the consequence of putting each struct, union or enum\n+   into a separate .stabs, containing only cross-refs to the others.  */\n+#define DBX_NO_XREFS\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Define the value returned by a floating-point comparison instruction.  */\n+\n+#define FLOAT_STORE_FLAG_VALUE 0.5\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode DImode\n+\n+/* Mode of a function address in a call instruction (for indexing purposes). */\n+\n+#define FUNCTION_MODE Pmode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.\n+\n+   We define this on the Alpha so that gen_call and gen_call_value\n+   get to see the SYMBOL_REF (for the hint field of the jsr).  It will\n+   then copy it into a register, thus actually letting the address be\n+   cse'ed.  */\n+\n+#define NO_FUNCTION_CSE\n+\n+/* Define this if shift instructions ignore all but the low-order\n+   few bits. */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.\n+\n+   We only care about the cost if it is valid in an insn, so all constants\n+   are cheap.  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 0;\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+    return 6;\t\t\t\t\t\t\t\\\n+    \n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  */\n+   \n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\\\n+  case MINUS:\t\t\t\t\t\t\\\n+    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\\\n+      return COSTS_N_INSNS (6);\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\\\n+      return COSTS_N_INSNS (6);\t\t\t\t\\\n+    else\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (21);\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == SFmode)\t\t\t\t\\\n+      return COSTS_N_INSNS (34);\t\t\t\\\n+    else if (GET_MODE (X) == DFmode)\t\t\t\\\n+      return COSTS_N_INSNS (63);\t\t\t\\\n+    else\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (70);\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (3);\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{ extern char *version_string;\t\t\t\t\t\\\n+  char *p, *after_dir = main_input_filename;\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.verstamp 9 0 \");\t\t\t\t\\\n+  for (p = version_string; *p != 0; p++)\t\t\t\\\n+    fprintf (FILE, \"%c\", *p == '.' ? ' ' : *p);\t\t\t\\\n+  fprintf (FILE, \"\\n\\t.set noreorder\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set noat\\n\");\t\t\t\t\\\n+  for (p = main_input_filename; *p; p++)\t\t\t\\\n+    if (*p == '/')\t\t\t\t\t\t\\\n+      after_dir = p + 1;\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\\t.file 2 \\\"%s\\\"\\n\", after_dir);\t        \\\n+}\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before read-only data.  */\n+\n+#define READONLY_DATA_SECTION_ASM_OP \".rdata\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* Define an extra section for read-only data, a routine to enter it, and\n+   indicate that it is for read-only data.  */\n+\n+#define EXTRA_SECTIONS\treadonly_data\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+literal_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != readonly_data)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", READONLY_DATA_SECTION_ASM_OP); \\\n+      in_section = readonly_data;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+\n+#define READONLY_DATA_SECTION\tliteral_section\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\\\n+{\"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\t\t\\\n+ \"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\",\t\t\\\n+ \"$16\", \"$17\", \"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\",\t\\\n+ \"$24\", \"$25\", \"$26\", \"$27\", \"$28\", \"$29\", \"$30\", \"$31\",\t\\\n+ \"$f0\", \"$f1\", \"$f2\", \"$f3\", \"$f4\", \"$f5\", \"$f6\", \"$f7\", \"$f8\",\t\\\n+ \"$f9\", \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\t\\\n+ \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\\\n+ \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\"}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  if ((PREFIX)[0] == 'L')\t\t\t\t\\\n+    fprintf (FILE, \"$%s%d:\\n\", & (PREFIX)[1], NUM + 32); \\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM);\n+\n+/* This is how to output a label for a jump table.  Arguments are the same as\n+   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n+   passed. */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+{ ASM_OUTPUT_ALIGN (FILE, 2); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  if ((PREFIX)[0] == 'L')\t\t\t\t\\\n+    sprintf (LABEL, \"*$%s%d\", & (PREFIX)[1], NUM + 32);\t\\\n+  else\t\t\t\t\t\t\t\\\n+    sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.t_floating %.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.s_floating %.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \t\t\\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line defining a `long' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)\t\\\n+( fprintf (FILE, \"\\t.quad \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* We use the default ASCII-output routine, except that we don't write more\n+   than 50 characters since the assembler doesn't support very long lines.  */\n+\n+#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    FILE *_hide_asm_out_file = (MYFILE);\t\t\t\t      \\\n+    unsigned char *_hide_p = (unsigned char *) (MYSTRING);\t\t      \\\n+    int _hide_thissize = (MYLENGTH);\t\t\t\t\t      \\\n+    int _size_so_far = 0;\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n+      unsigned char *p = _hide_p;\t\t\t\t\t      \\\n+      int thissize = _hide_thissize;\t\t\t\t\t      \\\n+      int i;\t\t\t\t\t\t\t\t      \\\n+      fprintf (asm_out_file, \"\\t.ascii \\\"\");\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  register int c = p[i];\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+\t  if (_size_so_far ++ > 50 && i < thissize - 4)\t\t\t      \\\n+\t    _size_so_far = 0, fprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+\t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n+\t    putc ('\\\\', asm_out_file);\t\t\t\t\t      \\\n+\t  if (c >= ' ' && c < 0177)\t\t\t\t\t      \\\n+\t    putc (c, asm_out_file);\t\t\t\t\t      \\\n+\t  else\t\t\t\t\t\t\t\t      \\\n+\t    {\t\t\t\t\t\t\t\t      \\\n+\t      fprintf (asm_out_file, \"\\\\%o\", c);\t\t\t      \\\n+\t      /* After an octal-escape, if a digit follows,\t\t      \\\n+\t\t terminate one string constant and start another.\t      \\\n+\t\t The Vax assembler fails to stop reading the escape\t      \\\n+\t\t after three digits, so this is the only way we\t\t      \\\n+\t\t can get it to parse the data properly.  */\t\t      \\\n+\t      if (i < thissize - 1\t\t\t\t\t      \\\n+\t\t  && p[i + 1] >= '0' && p[i + 1] <= '9')\t\t      \\\n+\t\tfprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");\t\t      \\\n+\t  }\t\t\t\t\t\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t      \\\n+      fprintf (asm_out_file, \"\\\"\\n\");\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  }\t\t\t\t\t\t\t\t\t      \\\n+  while (0)\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n+ fprintf (FILE, \"\\tsubq $30,8,$30\\n\\tst%s $%s%d,0($30)\\n\",\t\t\\\n+\t  (REGNO) > 32 ? \"t\" : \"q\", (REGNO) > 32 ? \"f\" : \"\",\t\t\\\n+\t  (REGNO) & 31);\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tld%s $%s%d,0($30)\\n\\taddq $30,8,$30\\n\",\t\t\\\n+\t  (REGNO) > 32 ? \"t\" : \"q\", (REGNO) > 32 ? \"f\" : \"\",\t\t\\\n+\t  (REGNO) & 31);\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.gprel32 $%d\\n\", (VALUE) + 32)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (Alpha does not use such vectors, but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  abort ()\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", LOG);\n+\n+/* This is how to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n+\n+/* Determine which codes are valid without a following integer.  These must\n+   not be alphabetic.  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) 0\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\\\n+{ rtx addr = (ADDR);\t\t\t\t\t\\\n+  int basereg = 31;\t\t\t\t\t\\\n+  HOST_WIDE_INT offset = 0;\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  if (GET_CODE (addr) == AND)\t\t\t\t\\\n+    addr = XEXP (addr, 0);\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  if (GET_CODE (addr) == REG)\t\t\t\t\\\n+    basereg = REGNO (addr);\t\t\t\t\\\n+  else if (GET_CODE (addr) == CONST_INT)\t\t\\\n+    offset = INTVAL (addr);\t\t\t\t\\\n+  else if (GET_CODE (addr) == PLUS\t\t\t\\\n+\t   && GET_CODE (XEXP (addr, 0)) == REG\t\t\\\n+\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\\\n+    basereg = REGNO (XEXP (addr, 0)), offset = INTVAL (XEXP (addr, 1)); \\\n+  else\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"%d($%d)\", offset, basereg);\t\t\\\n+}\n+/* Define the codes that are matched by predicates in alpha.c.  */\n+\n+#define PREDICATE_CODES \\\n+  {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\\\n+  {\"reg_or_8bit_operand\", {SUBREG, REG, CONST_INT}},\t\\\n+  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\\\n+  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"sext_add_operand\", {SUBREG, REG, CONST_INT}},\t\\\n+  {\"const48_operand\", {CONST_INT}},\t\t\t\\\n+  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"mode_mask_operand\", {CONST_INT}},\t\t\t\\\n+  {\"mul8_operand\", {CONST_INT}},\t\t\t\\\n+  {\"mode_width_operand\", {CONST_INT}},\t\t\t\\\n+  {\"reg_or_fp0_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\\\n+  {\"alpha_comparison_operator\", {EQ, LE, LT, LEU, LTU}}, \\\n+  {\"signed_comparison_operator\", {EQ, NE, LE, LT, GE, GT}}, \\\n+  {\"fp0_operand\", {CONST_DOUBLE}},\t\t\t\\\n+  {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\\\n+\t\t     SYMBOL_REF, CONST, LABEL_REF}},\t\\\n+  {\"aligned_memory_operand\", {MEM}},\t\t\t\\\n+  {\"unaligned_memory_operand\", {MEM}},\t\t\t\\\n+  {\"any_memory_operand\", {MEM}},"}]}