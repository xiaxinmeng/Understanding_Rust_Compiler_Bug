{"sha": "922db4bb4e54b4d3b2b65fb7e6242bbb86080275", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIyZGI0YmI0ZTU0YjRkM2IyYjY1ZmI3ZTYyNDJiYmI4NjA4MDI3NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-29T13:43:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-29T13:43:27Z"}, "message": "(find_reloads_address_1, case PLUS): When handle SUBREG, add SUBREG_WORD offset to SUBREG_REG register number.\n\n(find_reloads_address_1, case PLUS): When handle SUBREG, add SUBREG_WORD\noffset to SUBREG_REG register number.\n(find_reloads_address_1, case SUBREG): If a pseudo register inside a SUBREG is\nlarger than the class, then reload the entire SUBREG.\n\nFrom-SVN: r10197", "tree": {"sha": "52481ae8d769b7f585abb0a7dd0b41824071f230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52481ae8d769b7f585abb0a7dd0b41824071f230"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/922db4bb4e54b4d3b2b65fb7e6242bbb86080275", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922db4bb4e54b4d3b2b65fb7e6242bbb86080275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/922db4bb4e54b4d3b2b65fb7e6242bbb86080275", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922db4bb4e54b4d3b2b65fb7e6242bbb86080275/comments", "author": null, "committer": null, "parents": [{"sha": "1e63b23a042a8a3776db7662c8c9342d396fc8ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e63b23a042a8a3776db7662c8c9342d396fc8ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e63b23a042a8a3776db7662c8c9342d396fc8ab"}], "stats": {"total": 46, "additions": 34, "deletions": 12}, "files": [{"sha": "b33eb4babfcba179271bb79cb6594e58818455f5", "filename": "gcc/reload.c", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922db4bb4e54b4d3b2b65fb7e6242bbb86080275/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922db4bb4e54b4d3b2b65fb7e6242bbb86080275/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=922db4bb4e54b4d3b2b65fb7e6242bbb86080275", "patch": "@@ -4561,12 +4561,18 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n \t  {\n \t    op0 = SUBREG_REG (op0);\n \t    code0 = GET_CODE (op0);\n+\t    if (code0 == REG && REGNO (op0) < FIRST_PSEUDO_REGISTER)\n+\t      op0 = gen_rtx (REG, word_mode,\n+\t\t\t     REGNO (op0) + SUBREG_WORD (orig_op0));\n \t  }\n \n \tif (GET_CODE (op1) == SUBREG)\n \t  {\n \t    op1 = SUBREG_REG (op1);\n \t    code1 = GET_CODE (op1);\n+\t    if (code1 == REG && REGNO (op1) < FIRST_PSEUDO_REGISTER)\n+\t      op1 = gen_rtx (REG, GET_MODE (op1),\n+\t\t\t     REGNO (op1) + SUBREG_WORD (orig_op1));\n \t  }\n \n \tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE \n@@ -4828,21 +4834,37 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n       return 0;\n \n     case SUBREG:\n-      /* If this is a SUBREG of a hard register and the resulting register is\n-\t of the wrong class, reload the whole SUBREG.  This avoids needless\n-\t copies if SUBREG_REG is multi-word.  */\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n-\t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n+      if (GET_CODE (SUBREG_REG (x)) == REG)\n \t{\n-\t  int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\t  /* If this is a SUBREG of a hard register and the resulting register\n+\t     is of the wrong class, reload the whole SUBREG.  This avoids\n+\t     needless copies if SUBREG_REG is multi-word.  */\n+\t  if (REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n \n-\t  if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t : REGNO_OK_FOR_BASE_P (regno)))\n+\t      if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n+\t\t     : REGNO_OK_FOR_BASE_P (regno)))\n+\t\t{\n+\t\t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t\t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n+\t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t\t  return 1;\n+\t\t}\n+\t    }\n+\t  /* If this is a SUBREG of a pseudo-register, and the psuedo-register\n+\t     is larger than the class size, then reload the whole SUBREG.  */\n+\t  else\n \t    {\n-\t      push_reload (x, NULL_RTX, loc, NULL_PTR,\n-\t\t\t   context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n-\t      return 1;\n+\t      enum reg_class class = (context\n+\t\t\t\t      ? INDEX_REG_CLASS : BASE_REG_CLASS);\n+\t      if (CLASS_MAX_NREGS (class, GET_MODE (SUBREG_REG (x)))\n+\t\t  > reg_class_size[class])\n+\t\t{\n+\t\t  push_reload (x, NULL_RTX, loc, NULL_PTR, class,\n+\t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t\t  return 1;\n+\t\t}\n \t    }\n \t}\n       break;"}]}