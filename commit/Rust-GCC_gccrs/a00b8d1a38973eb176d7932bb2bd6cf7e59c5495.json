{"sha": "a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAwYjhkMWEzODk3M2ViMTc2ZDc5MzJiYjJiZDZjZjdlNTljNTQ5NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-01-27T18:23:14Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-01-27T18:23:14Z"}, "message": "re PR fortran/30407 ([4.1 only] Elemental functions in WHERE assignments wrongly rejected)\n\n2007-01-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/30407\n\t* trans-expr.c (gfc_conv_operator_assign): New function.\n\t* trans.h : Add prototype for gfc_conv_operator_assign.\n\t* trans-stmt.c (gfc_trans_where_assign): Add a gfc_symbol for\n\ta potential operator assignment subroutine.  If it is non-NULL\n\tcall gfc_conv_operator_assign instead of the first assignment.\n\t( gfc_trans_where_2): In the case of an operator assignment,\n\textract the argument expressions from the code for the\n\tsubroutine call and pass the symbol to gfc_trans_where_assign.\n\tresolve.c (resolve_where, gfc_resolve_where_code_in_forall,\n\tgfc_resolve_forall_body): Resolve the subroutine call for\n\toperator assignments.\n\n2007-01-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/30407\n\t* gfortran.dg/where_operator_assign_1.f90: New test.\n\t* gfortran.dg/where_operator_assign_2.f90: New test.\n\t* gfortran.dg/where_operator_assign_3.f90: New test.\n\nFrom-SVN: r121235", "tree": {"sha": "5980c7b71db5312698ab4c49a4066d1da8d30e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5980c7b71db5312698ab4c49a4066d1da8d30e6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/comments", "author": null, "committer": null, "parents": [{"sha": "ea6244280b016b12843432c1381a2a9064f60d00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea6244280b016b12843432c1381a2a9064f60d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea6244280b016b12843432c1381a2a9064f60d00"}], "stats": {"total": 412, "additions": 406, "deletions": 6}, "files": [{"sha": "75aa23fa6c5ccb5f57567cc9139a263b97c06393", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -1,3 +1,18 @@\n+2007-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/30407\n+\t* trans-expr.c (gfc_conv_operator_assign): New function.\n+\t* trans.h : Add prototype for gfc_conv_operator_assign.\n+\t* trans-stmt.c (gfc_trans_where_assign): Add a gfc_symbol for\n+\ta potential operator assignment subroutine.  If it is non-NULL\n+\tcall gfc_conv_operator_assign instead of the first assignment.\n+\t( gfc_trans_where_2): In the case of an operator assignment,\n+\textract the argument expressions from the code for the\n+\tsubroutine call and pass the symbol to gfc_trans_where_assign.\n+\tresolve.c (resolve_where, gfc_resolve_where_code_in_forall,\n+\tgfc_resolve_forall_body): Resolve the subroutine call for\n+\toperator assignments.\n+\n 2007-01-26  Steven Bosscher  <stevenb.gcc@gmail.com>\n \t    Steven G. Kargl <kargl@gcc.gnu.org>\n "}, {"sha": "9a06a9820a3b06def86808e9629ce6fc86176380", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -4550,6 +4550,11 @@ resolve_where (gfc_code *code, gfc_expr *mask)\n \t\t\t  \"inconsistent shape\", &cnext->expr->where);\n \t      break;\n \n+  \n+\t    case EXEC_ASSIGN_CALL:\n+\t      resolve_call (cnext);\n+\t      break;\n+\n \t    /* WHERE or WHERE construct is part of a where-body-construct */\n \t    case EXEC_WHERE:\n \t      resolve_where (cnext, e);\n@@ -4750,6 +4755,11 @@ gfc_resolve_where_code_in_forall (gfc_code *code, int nvar,\n \t    case EXEC_ASSIGN:\n \t      gfc_resolve_assign_in_forall (cnext, nvar, var_expr);\n \t      break;\n+  \n+\t    /* WHERE operator assignment statement */\n+\t    case EXEC_ASSIGN_CALL:\n+\t      resolve_call (cnext);\n+\t      break;\n \n \t    /* WHERE or WHERE construct is part of a where-body-construct */\n \t    case EXEC_WHERE:\n@@ -4789,6 +4799,10 @@ gfc_resolve_forall_body (gfc_code *code, int nvar, gfc_expr **var_expr)\n \t  gfc_resolve_assign_in_forall (c, nvar, var_expr);\n \t  break;\n \n+\tcase EXEC_ASSIGN_CALL:\n+\t  resolve_call (c);\n+\t  break;\n+\n \t/* Because the gfc_resolve_blocks() will handle the nested FORALL,\n \t   there is no need to handle it here.  */\n \tcase EXEC_FORALL:"}, {"sha": "487b6a7d2ab3242eaafca7c33f84b28ccaab40ab", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -1249,6 +1249,48 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n }\n \n \n+/* Translate the call for an elemental subroutine call used in an operator\n+   assignment.  This is a simplified version of gfc_conv_function_call.  */\n+\n+tree\n+gfc_conv_operator_assign (gfc_se *lse, gfc_se *rse, gfc_symbol *sym)\n+{\n+  tree args;\n+  tree tmp;\n+  gfc_se se;\n+  stmtblock_t block;\n+\n+  /* Only elemental subroutines with two arguments.  */\n+  gcc_assert (sym->attr.elemental && sym->attr.subroutine);\n+  gcc_assert (sym->formal->next->next == NULL);\n+\n+  gfc_init_block (&block);\n+\n+  gfc_add_block_to_block (&block, &lse->pre);\n+  gfc_add_block_to_block (&block, &rse->pre);\n+\n+  /* Build the argument list for the call, including hidden string lengths.  */\n+  args = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (lse->expr));\n+  args = gfc_chainon_list (args, build_fold_addr_expr (rse->expr));\n+  if (lse->string_length != NULL_TREE)\n+    args = gfc_chainon_list (args, lse->string_length);\n+  if (rse->string_length != NULL_TREE)\n+    args = gfc_chainon_list (args, rse->string_length);    \n+\n+  /* Build the function call.  */\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_function_val (&se, sym);\n+  tmp = TREE_TYPE (TREE_TYPE (TREE_TYPE (se.expr)));\n+  tmp = build3 (CALL_EXPR, tmp, se.expr, args, NULL_TREE);\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  gfc_add_block_to_block (&block, &lse->post);\n+  gfc_add_block_to_block (&block, &rse->post);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* Initialize MAPPING.  */\n \n void"}, {"sha": "6640cf735e28446219834fd5b930921a40d8d8ff", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -2878,7 +2878,8 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n static tree\n gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n \t\t\ttree mask, bool invert,\n-                        tree count1, tree count2)\n+                        tree count1, tree count2,\n+\t\t\tgfc_symbol *sym)\n {\n   gfc_se lse;\n   gfc_se rse;\n@@ -2992,8 +2993,12 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n     maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr), maskexpr);\n \n   /* Use the scalar assignment as is.  */\n-  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n-\t\t\t\t loop.temp_ss != NULL, false);\n+  if (sym == NULL)\n+    tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n+\t\t\t\t   loop.temp_ss != NULL, false);\n+  else\n+    tmp = gfc_conv_operator_assign (&lse, &rse, sym);\n+\n   tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n \n   gfc_add_expr_to_block (&body, tmp);\n@@ -3102,6 +3107,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n   tree ppmask = NULL_TREE;\n   tree cmask = NULL_TREE;\n   tree pmask = NULL_TREE;\n+  gfc_actual_arglist *arg;\n \n   /* the WHERE statement or the WHERE construct statement.  */\n   cblock = code->block;\n@@ -3213,13 +3219,29 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n           switch (cnext->op)\n             {\n             /* WHERE assignment statement.  */\n+\t    case EXEC_ASSIGN_CALL:\n+\n+\t      arg = cnext->ext.actual;\n+\t      expr1 = expr2 = NULL;\n+\t      for (; arg; arg = arg->next)\n+\t\t{\n+\t\t  if (!arg->expr)\n+\t\t    continue;\n+\t\t  if (expr1 == NULL)\n+\t\t    expr1 = arg->expr;\n+\t\t  else\n+\t\t    expr2 = arg->expr;\n+\t\t}\n+\t      goto evaluate;\n+\n             case EXEC_ASSIGN:\n               expr1 = cnext->expr;\n               expr2 = cnext->expr2;\n+    evaluate:\n               if (nested_forall_info != NULL)\n                 {\n                   need_temp = gfc_check_dependency (expr1, expr2, 0);\n-                  if (need_temp)\n+                  if (need_temp && cnext->op != EXEC_ASSIGN_CALL)\n                     gfc_trans_assign_need_temp (expr1, expr2,\n \t\t\t\t\t\tcmask, invert,\n                                                 nested_forall_info, block);\n@@ -3233,7 +3255,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \n                       tmp = gfc_trans_where_assign (expr1, expr2,\n \t\t\t\t\t\t    cmask, invert,\n-\t\t\t\t\t\t    count1, count2);\n+\t\t\t\t\t\t    count1, count2,\n+\t\t\t\t\t\t    cnext->resolved_sym);\n \n                       tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n                                                           tmp, 1);\n@@ -3250,7 +3273,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \n                   tmp = gfc_trans_where_assign (expr1, expr2,\n \t\t\t\t\t\tcmask, invert,\n-\t\t\t\t\t\tcount1, count2);\n+\t\t\t\t\t\tcount1, count2,\n+\t\t\t\t\t\tcnext->resolved_sym);\n                   gfc_add_expr_to_block (block, tmp);\n \n                 }"}, {"sha": "a3b6f04780be316a9d422f38cd02a08f0ca694b1", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -303,6 +303,9 @@ void gfc_conv_intrinsic_function (gfc_se *, gfc_expr *);\n /* Does an intrinsic map directly to an external library call.  */\n int gfc_is_intrinsic_libcall (gfc_expr *);\n \n+/* Used to call the elemental subroutines used in operator assignments.  */\n+tree gfc_conv_operator_assign (gfc_se *, gfc_se *, gfc_symbol *);\n+\n /* Also used to CALL subroutines.  */\n int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n \t\t\t    tree);"}, {"sha": "dd502222f43480874f7f378f3fcc1ad4ae4c4bc6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -1,3 +1,10 @@\n+2007-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/30407\n+\t* gfortran.dg/where_operator_assign_1.f90: New test.\n+\t* gfortran.dg/where_operator_assign_2.f90: New test.\n+\t* gfortran.dg/where_operator_assign_3.f90: New test.\n+\n 2007-01-26  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lib/target-supports.exp"}, {"sha": "c2b4abf851892c85f2996e31853be6492c62ba54", "filename": "gcc/testsuite/gfortran.dg/where_operator_assign_1.f90", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_1.f90?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -0,0 +1,108 @@\n+! { dg-do compile }\n+! Tests the fix for PR30407, in which operator assignments did not work\n+! in WHERE blocks or simple WHERE statements.  This is the test provided\n+! by the reporter.\n+!\n+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>\n+!==============================================================================\n+\n+MODULE kind_mod\n+\n+   IMPLICIT NONE\n+\n+   PRIVATE\n+\n+   INTEGER, PUBLIC, PARAMETER :: I4=SELECTED_INT_KIND(9)\n+   INTEGER, PUBLIC, PARAMETER :: TF=KIND(.TRUE._I4)\n+\n+END MODULE kind_mod\n+\n+!==============================================================================\n+\n+MODULE pointer_mod\n+\n+   USE kind_mod, ONLY : I4\n+\n+   IMPLICIT NONE\n+\n+   PRIVATE\n+\n+   TYPE, PUBLIC :: pvt\n+      INTEGER(I4), POINTER, DIMENSION(:) :: vect\n+   END TYPE pvt\n+\n+   INTERFACE ASSIGNMENT(=)\n+      MODULE PROCEDURE p_to_p\n+   END INTERFACE\n+\n+   PUBLIC :: ASSIGNMENT(=)\n+\n+CONTAINS\n+\n+   !---------------------------------------------------------------------------\n+\n+   PURE ELEMENTAL SUBROUTINE p_to_p(a1, a2)\n+      IMPLICIT NONE\n+      TYPE(pvt), INTENT(OUT) :: a1\n+      TYPE(pvt), INTENT(IN) :: a2\n+      a1%vect = a2%vect\n+   END SUBROUTINE p_to_p\n+\n+   !---------------------------------------------------------------------------\n+\n+END MODULE pointer_mod\n+\n+!==============================================================================\n+\n+PROGRAM test_prog\n+\n+   USE pointer_mod, ONLY : pvt, ASSIGNMENT(=)\n+\n+   USE kind_mod, ONLY : I4, TF\n+\n+   IMPLICIT NONE\n+\n+   INTEGER(I4), DIMENSION(12_I4), TARGET :: ia\n+   LOGICAL(TF), DIMENSION(2_I4,3_I4) :: la\n+   TYPE(pvt), DIMENSION(6_I4) :: pv\n+   INTEGER(I4) :: i\n+\n+   ! Initialisation...\n+   la(:,1_I4:3_I4:2_I4)=.TRUE._TF\n+   la(:,2_I4)=.FALSE._TF\n+\n+   DO i=1_I4,6_I4\n+      pv(i)%vect => ia((2_I4*i-1_I4):(2_I4*i))\n+   END DO\n+\n+   ia=0_I4\n+\n+   DO i=1_I4,3_I4\n+      WHERE(la((/1_I4,2_I4/),i))\n+         pv((2_I4*i-1_I4):(2_I4*i))= iaef((/(2_I4*i-1_I4),(2_I4*i)/))\n+      ELSEWHERE\n+         pv((2_I4*i-1_I4):(2_I4*i))= iaef((/0_I4,0_I4/))\n+      END WHERE\n+   END DO\n+\n+   if (any (ia .ne. (/1,-1,2,-2,0,0,0,0,5,-5,6,-6/))) call abort ()\n+\n+CONTAINS\n+\n+   TYPE(pvt) ELEMENTAL FUNCTION iaef(index) RESULT(ans)\n+\n+      USE kind_mod, ONLY :  I4\n+      USE pointer_mod, ONLY : pvt, ASSIGNMENT(=)\n+\n+      IMPLICIT NONE\n+\n+      INTEGER(I4), INTENT(IN) :: index\n+\n+      ALLOCATE(ans%vect(2_I4))\n+      ans%vect=(/index,-index/)\n+\n+   END FUNCTION iaef\n+\n+END PROGRAM test_prog\n+\n+! { dg-final { cleanup-modules \"kind_mod pointer_mod\" } }"}, {"sha": "420103f1978e2855988cce53c4f47a7c032c7ef3", "filename": "gcc/testsuite/gfortran.dg/where_operator_assign_2.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_2.f90?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do compile }\n+! Tests the fix for PR30407, in which operator assignments did not work\n+! in WHERE blocks or simple WHERE statements.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!******************************************************************************\n+module global\n+  type :: a\n+    integer :: b\n+    integer :: c\n+  end type a\n+  interface assignment(=)\n+    module procedure a_to_a\n+  end interface\n+  interface operator(.ne.)\n+    module procedure a_ne_a\n+  end interface\n+\n+  type(a) :: x(4), y(4), z(4), u(4, 4)\n+  logical :: l1(4), t = .true., f= .false.\n+contains\n+!******************************************************************************\n+  elemental subroutine a_to_a (m, n)\n+    type(a), intent(in) :: n\n+    type(a), intent(out) :: m\n+    m%b = n%b + 1\n+    m%c = n%c\n+  end subroutine a_to_a\n+!******************************************************************************\n+  elemental logical function a_ne_a (m, n)\n+    type(a), intent(in) :: n\n+    type(a), intent(in) :: m\n+    a_ne_a = (m%b .ne. n%b) .or. (m%c .ne. n%c)\n+  end function a_ne_a\n+!******************************************************************************\n+  elemental function foo (m)\n+    type(a) :: foo\n+    type(a), intent(in) :: m\n+    foo%b = 0\n+    foo%c = m%c\n+  end function foo  \n+end module global\n+!******************************************************************************\n+program test\n+  use global\n+  x = (/a (0, 1),a (0, 2),a (0, 3),a (0, 4)/)\n+  y = x\n+  z = x\n+  l1 = (/t, f, f, t/)\n+\n+  call test_where_1\n+  if (any (y .ne. (/a (2, 1),a (2, 2),a (2, 3),a (2, 4)/))) call abort ()\n+\n+  call test_where_2\n+  if (any (y .ne. (/a (1, 0),a (2, 2),a (2, 3),a (1, 0)/))) call abort ()\n+  if (any (z .ne. (/a (3, 4),a (1, 0),a (1, 0),a (3, 1)/))) call abort ()\n+\n+  call test_where_3\n+  if (any (y .ne. (/a (1, 0),a (1, 2),a (1, 3),a (1, 0)/))) call abort ()\n+\n+  y = x\n+  call test_where_forall_1\n+  if (any (u(4, :) .ne. (/a (1, 4),a (2, 2),a (2, 3),a (1, 4)/))) call abort ()\n+\n+  l1 = (/t, f, t, f/)\n+  call test_where_4\n+  if (any (x .ne. (/a (1, 1),a (2, 1),a (1, 3),a (2, 3)/))) call abort ()\n+\n+contains\n+!******************************************************************************\n+  subroutine test_where_1        ! Test a simple WHERE\n+    where (l1) y = x\n+  end subroutine test_where_1\n+!******************************************************************************\n+  subroutine test_where_2        ! Test a WHERE blocks\n+    where (l1)\n+      y = a (0, 0)\n+      z = z(4:1:-1)\n+    elsewhere\n+      y = x\n+      z = a (0, 0)\n+    end where\n+  end subroutine test_where_2\n+!******************************************************************************\n+  subroutine test_where_3        ! Test a simple WHERE with a function assignment\n+    where (.not. l1) y = foo (x)\n+  end subroutine test_where_3\n+!******************************************************************************\n+  subroutine test_where_forall_1 ! Test a WHERE in a FORALL block\n+    forall (i = 1:4)\n+      where (.not. l1)\n+        u(i, :) = x\n+      elsewhere\n+        u(i, :) = a(0, i)\n+      endwhere\n+    end forall\n+  end subroutine test_where_forall_1\n+!******************************************************************************\n+  subroutine test_where_4       ! Test a WHERE assignment with dependencies\n+    where (l1(1:3))\n+      x(2:4) = x(1:3)\n+    endwhere\n+  end subroutine test_where_4\n+end program test \n+! { dg-final { cleanup-modules \"global\" } }\n+"}, {"sha": "eddbdfc00afffdeb76bd31be8a0fd02aaec77b31", "filename": "gcc/testsuite/gfortran.dg/where_operator_assign_3.f90", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b8d1a38973eb176d7932bb2bd6cf7e59c5495/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_operator_assign_3.f90?ref=a00b8d1a38973eb176d7932bb2bd6cf7e59c5495", "patch": "@@ -0,0 +1,81 @@\n+! { dg-do compile }\n+! Tests the fix for PR30407, in which operator assignments did not work\n+! in WHERE blocks or simple WHERE statements. This tests that the character\n+! lengths are transmitted OK.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!******************************************************************************\n+module global\n+  type :: a\n+    integer :: b\n+    character(8):: c\n+  end type a\n+  interface assignment(=)\n+    module procedure a_to_a, c_to_a, a_to_c\n+  end interface\n+  interface operator(.ne.)\n+    module procedure a_ne_a\n+  end interface\n+\n+  type(a) :: x(4), y(4)\n+  logical :: l1(4), t = .true., f= .false.\n+contains\n+!******************************************************************************\n+  elemental subroutine a_to_a (m, n)\n+    type(a), intent(in) :: n\n+    type(a), intent(out) :: m\n+    m%b = len ( trim(n%c))\n+    m%c = n%c\n+  end subroutine a_to_a\n+  elemental subroutine c_to_a (m, n)\n+    character(8), intent(in) :: n\n+    type(a), intent(out) :: m\n+    m%b = m%b + 1\n+    m%c = n\n+  end subroutine c_to_a\n+  elemental subroutine a_to_c (m, n)\n+    type(a), intent(in) :: n\n+    character(8), intent(out) :: m\n+    m = n%c\n+  end subroutine a_to_c\n+!******************************************************************************\n+  elemental logical function a_ne_a (m, n)\n+    type(a), intent(in) :: n\n+    type(a), intent(in) :: m\n+    a_ne_a = (m%b .ne. n%b) .or. (m%c .ne. n%c)\n+  end function a_ne_a\n+!******************************************************************************\n+  elemental function foo (m)\n+    type(a) :: foo\n+    type(a), intent(in) :: m\n+    foo%b = 0\n+    foo%c = m%c\n+  end function foo  \n+end module global\n+!******************************************************************************\n+program test\n+  use global\n+  x = (/a (0, \"one\"),a (0, \"two\"),a (0, \"three\"),a (0, \"four\")/)\n+  y = x\n+  l1 = (/t,f,f,t/)\n+\n+  call test_where_char1\n+  call test_where_char2\n+  if (any(y .ne. &\n+    (/a(4, \"null\"), a(8, \"non-null\"), a(8, \"non-null\"), a(4, \"null\")/))) call abort ()\n+contains\n+  subroutine test_where_char1   ! Test a WHERE blocks\n+    where (l1)\n+      y = a (0, \"null\")\n+    elsewhere\n+      y = x\n+    end where\n+  end subroutine test_where_char1\n+  subroutine test_where_char2   ! Test a WHERE blocks\n+    where (y%c .ne. \"null\")\n+      y = a (99, \"non-null\")\n+    endwhere\n+  end subroutine test_where_char2\n+end program test \n+! { dg-final { cleanup-modules \"global\" } }\n+"}]}