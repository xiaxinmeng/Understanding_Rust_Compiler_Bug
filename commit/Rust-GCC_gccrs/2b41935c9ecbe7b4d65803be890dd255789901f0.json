{"sha": "2b41935c9ecbe7b4d65803be890dd255789901f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI0MTkzNWM5ZWNiZTdiNGQ2NTgwM2JlODkwZGQyNTU3ODk5MDFmMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-03T19:06:11Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-03T19:06:11Z"}, "message": "pa.c (apparent_fsize): Delete variable.\n\n\t* pa.c \t(apparent_fsize): Delete variable.\n\t(compute_frame_size): Many changes. Return the total frame size,\n\tincluding space for \"magic\" stuff at the top of the stack and any\n\trounding for the Snake.\n\t(output_function_prologue): Don't take a leaf_function argument;\n\tDecide that based on frame size and frame_pointer_needed.\n\tDon't emit any frame diddling code if actual_fsize is 0.\n\t(output_function_epilogue): Don't take leaf_function argument.\n\tDon't do anything if no frame.\n\tKeep stack pointer aligned to 64 bytes before loading from old\n\tframe pointer.\n\t(hppa_epilogue_delay_slots): Only if there is no frame will we\n\thave an empty delay slot to fill.\n\t(eligible_for_epilogue_delay): Don't check \"leaf_function\" anymore.\n\nFrom-SVN: r3072", "tree": {"sha": "dd948008d339ecb7694ca2273e4ebdd8ed28de96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd948008d339ecb7694ca2273e4ebdd8ed28de96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b41935c9ecbe7b4d65803be890dd255789901f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b41935c9ecbe7b4d65803be890dd255789901f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b41935c9ecbe7b4d65803be890dd255789901f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b41935c9ecbe7b4d65803be890dd255789901f0/comments", "author": null, "committer": null, "parents": [{"sha": "2721a2e96d5c7562130ad80991c8bc92aab055f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2721a2e96d5c7562130ad80991c8bc92aab055f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2721a2e96d5c7562130ad80991c8bc92aab055f4"}], "stats": {"total": 244, "additions": 132, "deletions": 112}, "files": [{"sha": "d7fedc8e3dcf42e33c61fa1750267ccb3c1dc278", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 132, "deletions": 112, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b41935c9ecbe7b4d65803be890dd255789901f0/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b41935c9ecbe7b4d65803be890dd255789901f0/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=2b41935c9ecbe7b4d65803be890dd255789901f0", "patch": "@@ -1473,37 +1473,36 @@ print_ldw (file, r, disp, base)\n /* Global variables set by FUNCTION_PROLOGUE.  */\n /* Size of frame.  Need to know this to emit return insns from\n    leaf procedures.  */\n-int apparent_fsize;\n-int actual_fsize;\n-int local_fsize, save_fregs;\n+static int actual_fsize;\n+static int local_fsize, save_fregs;\n \n int\n-compute_frame_size (size, leaf_function, fregs_live)\n+compute_frame_size (size, fregs_live)\n      int size;\n-     int leaf_function;\n      int *fregs_live;\n {\n   extern int current_function_outgoing_args_size;\n-  int i;\n+  int i, fsize;\n \n-  /* 8 is space for frame pointer + filler */\n-  local_fsize = actual_fsize = size + 8;\n+  /* 8 is space for frame pointer + filler. If any frame is allocated \n+     we need to add this in because of STARTING_FRAME_OFFSET. */\n+  fsize = size + (size || frame_pointer_needed ? 8 : 0);\n \n   /* fp is stored in a special place. */\n   for (i = 18; i >= 5; i--)\n     if (regs_ever_live[i])\n-      actual_fsize += 4;\n+      fsize += 4;\n \n   if (regs_ever_live[3])\n-    actual_fsize += 4;\n-  actual_fsize = (actual_fsize + 7) & ~7;\n+    fsize += 4;\n+  fsize = (fsize + 7) & ~7;\n \n   if (!TARGET_SNAKE)\n     {\n       for (i = 47; i >= 44; i--)\n \tif (regs_ever_live[i])\n \t  {\n-\t    actual_fsize += 8;\n+\t    fsize += 8;\n \t    if (fregs_live)\n \t      *fregs_live = 1;\n \t  }\n@@ -1513,29 +1512,30 @@ compute_frame_size (size, leaf_function, fregs_live)\n       for (i = 90; i >= 72; i -= 2)\n \tif (regs_ever_live[i] || regs_ever_live[i + 1])\n \t  {\n-\t    actual_fsize += 8;\n+\t    fsize += 8;\n \t    if (fregs_live)\n \t      *fregs_live = 1;\n \t  }\n     }\n-  return actual_fsize + current_function_outgoing_args_size;\n+  fsize += current_function_outgoing_args_size;\n+  if (! leaf_function_p () || fsize)\n+    fsize += 32;\n+  return TARGET_SNAKE ? (fsize + 63 & ~63) : fsize;\n }\n      \n void\n-output_function_prologue (file, size, leaf_function)\n+output_function_prologue (file, size)\n      FILE *file;\n      int size;\n-     int leaf_function;\n {\n   extern char call_used_regs[];\n   extern int frame_pointer_needed;\n   extern int current_function_returns_struct;\n   int i, offset;\n \n   save_fregs = 0;\n-  actual_fsize = compute_frame_size (size, leaf_function, &save_fregs) + 32;\n-  if (TARGET_SNAKE)\n-    actual_fsize = (actual_fsize + 63) & ~63;\n+  local_fsize =  size + (size || frame_pointer_needed ? 8 : 0);\n+  actual_fsize = compute_frame_size (size, &save_fregs);\n \n   /* Let's not try to bullshit more than we need to here. */\n   /* This might be right a lot of the time */\n@@ -1553,27 +1553,28 @@ output_function_prologue (file, size, leaf_function)\n     fprintf (file, \"\\tstw 2,-20(0,30)\\n\");\n \n   /* Reserve space for local variables.  */\n-  if (frame_pointer_needed)\n-    {\n-      if (VAL_14_BITS_P (actual_fsize))\n-\tfprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstwm 1,%d(0,30)\\n\",\n-\t\t actual_fsize);\n-      else\n-\t{\n-\t  fprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstw 1,0(0,4)\\n\");\n+  if (actual_fsize)\n+    if (frame_pointer_needed)\n+      {\n+\tif (VAL_14_BITS_P (actual_fsize))\n+\t  fprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstwm 1,%d(0,30)\\n\",\n+\t\t   actual_fsize);\n+\telse\n+\t  {\n+\t    fprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstw 1,0(0,4)\\n\");\n+\t    fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n+\t\t     actual_fsize, actual_fsize);\n+\t  }\n+      }\n+    else\n+      /* Used to be abort ();  */\n+      {\n+\tif (VAL_14_BITS_P (actual_fsize))\n+\t  fprintf (file, \"\\tldo %d(30),30\\n\", actual_fsize);\n+\telse\n \t  fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n \t\t   actual_fsize, actual_fsize);\n-\t}\n-    }\n-  else\n-    /* Used to be abort ();  */\n-    {\n-      if (VAL_14_BITS_P (actual_fsize))\n-\tfprintf (file, \"\\tldo %d(30),30\\n\", actual_fsize);\n-      else\n-\tfprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n-\t\t actual_fsize, actual_fsize);\n-    }\n+      }\n   /* The hppa calling conventions say that that %r19, the pic offset \n      register, is saved at sp - 32 (in this function's frame) */\n   if (flag_pic)\n@@ -1658,43 +1659,46 @@ output_function_prologue (file, size, leaf_function)\n \n   /* Floating point register store.  */\n   if (save_fregs)\n-    if (frame_pointer_needed)\n-      {\n-\tif (VAL_14_BITS_P (offset))\n-\t  fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n-\telse\n-\t  fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\", offset, offset);\n-      }\n-    else\n-      {\n-\tif (VAL_14_BITS_P (offset))\n-\t  fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n-\telse\n-\t  fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\", offset, offset);\n-      }\n-  if (!TARGET_SNAKE)\n     {\n-      for (i = 47; i >= 44; i--)\n+      if (frame_pointer_needed)\n \t{\n-\t  if (regs_ever_live[i])\n-\t    fprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n+\t  if (VAL_14_BITS_P (offset))\n+\t    fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n+\t  else\n+\t    fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\",\n+\t\t     offset, offset);\n+\t}\n+      else\n+\t{\n+\t  if (VAL_14_BITS_P (offset))\n+\t    fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n+\t  else\n+\t    fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\",\n+\t\t     offset, offset);\n+\t}\n+      if (!TARGET_SNAKE)\n+\t{\n+\t  for (i = 47; i >= 44; i--)\n+\t    {\n+\t      if (regs_ever_live[i])\n+\t\tfprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = 90; i >= 72; i -= 2)\n+\t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t      {\n+\t\tfprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n+\t      }\n \t}\n-    }\n-  else\n-    {\n-      for (i = 90; i >= 72; i -= 2)\n-\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t  {\n-\t    fprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n-\t  }\n     }\n }\n \n void\n-output_function_epilogue (file, size, leaf_function)\n+output_function_epilogue (file, size)\n      FILE *file;\n      int size;\n-     int leaf_function;\n {\n   extern char call_used_regs[];\n   extern int frame_pointer_needed;\n@@ -1730,68 +1734,76 @@ output_function_epilogue (file, size, leaf_function)\n \n   /* Floating point register restore.  */\n   if (save_fregs)\n-    if (frame_pointer_needed)\n-      {\n-\tif (VAL_14_BITS_P (offset))\n-\t  fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n-\telse\n-\t  fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\", offset, offset);\n-      }\n-    else\n-      {\n-\tif (VAL_14_BITS_P (offset))\n-\t  fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n-\telse\n-\t  fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\", offset, offset);\n-      }\n-  if (!TARGET_SNAKE)\n     {\n-      for (i = 47; i >= 44; i--)\n+      if (frame_pointer_needed)\n \t{\n-\t  if (regs_ever_live[i])\n-\t    fprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n+\t  if (VAL_14_BITS_P (offset))\n+\t    fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n+\t  else\n+\t    fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\",\n+\t\t     offset, offset);\n+\t}\n+      else\n+\t{\n+\t  if (VAL_14_BITS_P (offset))\n+\t    fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n+\t  else\n+\t    fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\",\n+\t\t     offset, offset);\n+\t}\n+      if (!TARGET_SNAKE)\n+\t{\n+\t  for (i = 47; i >= 44; i--)\n+\t    {\n+\t      if (regs_ever_live[i])\n+\t\tfprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = 90; i >= 72; i -= 2)\n+\t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t      {\n+\t\tfprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n+\t      }\n \t}\n-    }\n-  else\n-    {\n-      for (i = 90; i >= 72; i -= 2)\n-\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t  {\n-\t    fprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n-\t  }\n     }\n   /* Reset stack pointer (and possibly frame pointer).  The stack */\n-  /* pointer is initially set to fp + 8 to avoid a race condition. */\n+  /* pointer is initially set to fp + 64 to avoid a race condition. */\n   if (frame_pointer_needed)\n     {\n-      fprintf (file, \"\\tldo 8(4),30\\n\");\n+      fprintf (file, \"\\tldo 64(%%r4),%%r30\\n\");\n       if (regs_ever_live[2] || profile_flag)\n-\tfprintf (file, \"\\tldw -28(0,30),2\\n\");\n-      fprintf (file, \"\\tbv 0(2)\\n\\tldwm -8(30),4\\n\");\n+\tfprintf (file, \"\\tldw -84(%%r30),%%r2\\n\");\n+      fprintf (file, \"\\tbv 0(%%r2)\\n\\tldwm -64(%%r30),4\\n\");\n     }\n   else if (actual_fsize)\n     {\n-      if ((regs_ever_live[2] || profile_flag)\n-          && VAL_14_BITS_P (actual_fsize + 20))\n-\tfprintf (file, \"\\tldw %d(30),2\\n\\tbv 0(2)\\n\\tldo %d(30),30\\n\",\n-\t\t -(actual_fsize + 20), -actual_fsize);\n-      else if (regs_ever_live[2] || profile_flag)\n-\tfprintf (file,\n-\t\t \"\\taddil L'%d,30\\n\\tldw %d(1),2\\n\\tbv 0(2)\\n\\tldo R'%d(1),30\\n\",\n-\t\t - actual_fsize,\n-\t\t - (actual_fsize + 20 + ((-actual_fsize) & ~0x7ff)),\n-\t\t /* - ((actual_fsize + 20) - (actual_fsize & ~0x7ff)), */\n-\t\t - actual_fsize);\n+      if (regs_ever_live[2] || profile_flag)\n+          \n+\t{\n+\t  if (VAL_14_BITS_P (actual_fsize + 20))\n+\t    fprintf (file, \"\\tldw %d(30),2\\n\\tbv 0(2)\\n\\tldo %d(30),30\\n\",\n+\t\t     -(actual_fsize + 20), -actual_fsize);\n+\t  else\n+\t    fprintf (file,\n+\t\t     \"\\taddil L'%d,30\\n\\tldw %d(1),2\\n\\tbv 0(2)\\n\\\n+\\tldo R'%d(1),30\\n\",\n+\t\t     - actual_fsize,\n+\t\t     - (actual_fsize + 20 + ((-actual_fsize) & ~0x7ff)),\n+\t\t     - actual_fsize);\n+\t}\n       else if (VAL_14_BITS_P (actual_fsize))\n \tfprintf (file, \"\\tbv 0(2)\\n\\tldo %d(30),30\\n\", - actual_fsize);\n       else\n-\tfprintf (file, \"\\taddil L'%d,30\\n\\tbv 0(2)\\n\\tldo R'%d(1),30\\n\");\n+\tfprintf (file, \"\\taddil L'%d,30\\n\\tbv 0(2)\\n\\tldo R'%d(1),30\\n\",\n+\t\t - actual_fsize, - actual_fsize);\n     }\n   else if (current_function_epilogue_delay_list)\n     {\n       fprintf (file, \"\\tbv 0(2)\\n\");\n-      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t       file, write_symbols, 1, 0, 1);\n+      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0), file,\n+\t\t       1, 0, 1);\n     }\n   else\n     fprintf (file, \"\\tbv,n 0(2)\\n\");\n@@ -1812,6 +1824,15 @@ gen_compare_reg (code, x, y)\n   return cc_reg;\n }\n \n+/* If there's a frame, it will be deallocated in the delay slot of the \n+   bv 0(2) return instruction. */\n+\n+int\n+hppa_epilogue_delay_slots ()\n+{\n+  return (compute_frame_size (get_frame_size (), 0) ? 0 : 1);\n+}\n+\n /* Return nonzero if TRIAL can go into the function epilogue's\n    delay slot.  SLOT is the slot we are trying to fill.  */\n \n@@ -1827,8 +1848,7 @@ eligible_for_epilogue_delay (trial, slot)\n     return 0;\n   if (get_attr_length (trial) != 1)\n     return 0;\n-  return (leaf_function &&\n-\t  get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_TRUE);\n+  return (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_TRUE);\n }\n \n rtx"}]}