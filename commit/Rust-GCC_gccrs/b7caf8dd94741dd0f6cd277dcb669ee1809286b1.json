{"sha": "b7caf8dd94741dd0f6cd277dcb669ee1809286b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdjYWY4ZGQ5NDc0MWRkMGY2Y2QyNzdkY2I2NjllZTE4MDkyODZiMQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-09-11T10:16:00Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-09-11T10:16:00Z"}, "message": "2002-09-11  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/Socket.java\n\t(Socket): protected to public (since JDK 1.4). Added @specnote.\n\t(bind): New method.\n\t(connect): Two new methods.\n\t(getKeepalive): Get correct socket option.\n\t(setKeepalive): Set correct socket option.\n\t(getOOBInline): New method.\n\t(setOOBInline): New method.\n\t* java/net/ServerSocket.java\n\t(bind): Two new methods.\n\t(getInetAddress): Reimplemented, catch exception.\n\t(getLocalSocketAddress): New method.\n\t(setReuseAddress): New method.\n\t(getReuseAdress): New method.\n\t(setReceiveBufferSize): New method.\n\t(getReceiveBufferSize): New method.\n\t(toString): Made string JDK 1.4 compliant.\n\nFrom-SVN: r57032", "tree": {"sha": "29b4d322e1afd2e63388601bec364509ef956429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29b4d322e1afd2e63388601bec364509ef956429"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7caf8dd94741dd0f6cd277dcb669ee1809286b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7caf8dd94741dd0f6cd277dcb669ee1809286b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7caf8dd94741dd0f6cd277dcb669ee1809286b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7caf8dd94741dd0f6cd277dcb669ee1809286b1/comments", "author": null, "committer": null, "parents": [{"sha": "35bb45c65bbad615d43c42f69b2949b10f5d7d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35bb45c65bbad615d43c42f69b2949b10f5d7d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35bb45c65bbad615d43c42f69b2949b10f5d7d05"}], "stats": {"total": 273, "additions": 268, "deletions": 5}, "files": [{"sha": "96476e7dbf1c1d14e5becd0dd48cde925076b8e4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7caf8dd94741dd0f6cd277dcb669ee1809286b1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7caf8dd94741dd0f6cd277dcb669ee1809286b1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b7caf8dd94741dd0f6cd277dcb669ee1809286b1", "patch": "@@ -1,3 +1,23 @@\n+2002-09-11  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/Socket.java\n+\t(Socket): protected to public (since JDK 1.4). Added @specnote.\n+\t(bind): New method.\n+\t(connect): Two new methods.\n+\t(getKeepalive): Get correct socket option.\n+\t(setKeepalive): Set correct socket option.\n+\t(getOOBInline): New method.\n+\t(setOOBInline): New method.\n+\t* java/net/ServerSocket.java\n+\t(bind): Two new methods.\n+\t(getInetAddress): Reimplemented, catch exception.\n+\t(getLocalSocketAddress): New method.\n+\t(setReuseAddress): New method.\n+\t(getReuseAdress): New method.\n+\t(setReceiveBufferSize): New method.\n+\t(getReceiveBufferSize): New method.\n+\t(toString): Made string JDK 1.4 compliant.\n+\n 2002-09-10  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/SocketImpl.java"}, {"sha": "c6b187071ec5846dc002f38857dc6eeb14fa959a", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 156, "deletions": 2, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7caf8dd94741dd0f6cd277dcb669ee1809286b1/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7caf8dd94741dd0f6cd277dcb669ee1809286b1/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=b7caf8dd94741dd0f6cd277dcb669ee1809286b1", "patch": "@@ -151,14 +151,68 @@ public ServerSocket (int port, int backlog, InetAddress bindAddr)\n     impl.listen(backlog);\n   }\n \n+  /**\n+   * Binds the server socket to a specified socket address\n+   *\n+   * @param endpoint The socket address to bind to\n+   *\n+   * @exception IOException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public void bind (SocketAddress endpoint)\n+    throws IOException\n+  {\n+    if (impl == null)\n+      throw new IOException (\"Cannot initialize Socket implementation\");\n+\n+    InetSocketAddress tmp = (InetSocketAddress) endpoint;\n+    \n+    SecurityManager s = System.getSecurityManager ();\n+    if (s != null)\n+      s.checkListen (tmp.getPort ());\n+\n+    impl.bind (tmp.getAddress (), tmp.getPort ());\n+  }\n+ \n+  /**\n+   * Binds the server socket to a specified socket address\n+   *\n+   * @param endpoint The socket address to bind to\n+   * @param backlog The length of the pending connection queue\n+   * @exception IOException If an error occurs\n+   */\n+  public void bind (SocketAddress endpoint, int backlog)\n+    throws java.io.IOException \n+  {\n+    if (impl == null)\n+      throw new IOException (\"Cannot initialize Socket implementation\");\n+\n+    InetSocketAddress tmp = (InetSocketAddress) endpoint;\n+    \n+    SecurityManager s = System.getSecurityManager ();\n+    if (s != null)\n+      s.checkListen (tmp.getPort ());\n+\n+    impl.bind (tmp.getAddress (), tmp.getPort ());\n+    impl.listen(backlog);\n+  }\n+  \n   /**\n    * This method returns the local address to which this socket is bound\n    *\n    * @return The socket's local address\n    */\n   public InetAddress getInetAddress()\n   {\n-    return impl.getInetAddress();\n+    try\n+      {\n+        return (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);\n+      }\n+    catch (SocketException e)\n+      {\n+        return null;\n+      }\n   }\n \n   /**\n@@ -171,6 +225,21 @@ public int getLocalPort()\n     return impl.getLocalPort();\n   }\n \n+  /**\n+   * Returns the local socket address\n+   *\n+   * @since 1.4\n+   */\n+  public SocketAddress getLocalSocketAddress()\n+  {\n+    InetAddress addr = getInetAddress();\n+\n+    if (addr != null)\n+      return new InetSocketAddress (getInetAddress(), getLocalPort());\n+\n+    return null;\n+  }\n+\n   /**\n    * Accepts a new connection and returns a connected <code>Socket</code> \n    * instance representing that connection.  This method will block until a \n@@ -254,14 +323,99 @@ public int getSoTimeout () throws IOException\n     return ((Integer)timeout).intValue();\n   }\n \n+  /**\n+   * Enables/Disables the SO_REUSEADDR option\n+   * \n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public void setReuseAddress (boolean on)\n+    throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    impl.setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));\n+  }\n+\n+  /**\n+   * Checks if the SO_REUSEADDR option is enabled\n+   * \n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public boolean getReuseAddress()\n+    throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    Object reuseaddr = impl.getOption (SocketOptions.SO_REUSEADDR);\n+\n+    if (!(reuseaddr instanceof Boolean))\n+      throw new SocketException (\"Internal Error\");\n+    \n+    return ((Boolean) reuseaddr).booleanValue ();\n+  }\n+\n+  /**\n+   * This method sets the value for the system level socket option\n+   * SO_RCVBUF to the specified value.  Note that valid values for this\n+   * option are specific to a given operating system.\n+   * \n+   * @param size The new receive buffer size.\n+   * \n+   * @exception SocketException If an error occurs or Socket is not connected\n+   *\n+   * @since 1.4\n+   */\n+  public void setReceiveBufferSize (int size)\n+    throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Not connected\");\n+\n+    if (size <= 0)\n+      throw new IllegalArgumentException (\"SO_RCVBUF value must be > 0\");\n+\n+    impl.setOption (SocketOptions.SO_RCVBUF, new Integer (size));\n+  }\n+\n+  /**\n+   * This method returns the value of the system level socket option\n+   * SO_RCVBUF, which is used by the operating system to tune buffer\n+   * sizes for data transfers.\n+   * \n+   * @return The receive buffer size.\n+   *             \n+   * @exception SocketException If an error occurs or Socket is not connected\n+   * \n+   * @since 1.4\n+   */\n+  public int getReceiveBufferSize ()\n+    throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Not connected\");\n+\n+    Object buf = impl.getOption (SocketOptions.SO_RCVBUF);\n+\n+    if (!(buf instanceof Integer))\n+      throw new SocketException (\"Internal Error: Unexpected type\");\n+    \n+    return ((Integer) buf).intValue ();\n+  }\n+\n   /**\n    * Returns the value of this socket as a <code>String</code>. \n    *\n    * @return This socket represented as a <code>String</code>.\n    */\n   public String toString ()\n   {\n-    return \"ServerSocket \" + impl.toString();\n+    return \"ServerSocket\" + impl.toString();\n   }\n \n   // Class methods"}, {"sha": "078bfff7a03b495dd669a80e4f4c4800049d48cf", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 92, "deletions": 3, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7caf8dd94741dd0f6cd277dcb669ee1809286b1/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7caf8dd94741dd0f6cd277dcb669ee1809286b1/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=b7caf8dd94741dd0f6cd277dcb669ee1809286b1", "patch": "@@ -84,8 +84,10 @@\n    * Initializes a new instance of <code>Socket</code> object without \n    * connecting to a remote host.  This useful for subclasses of socket that \n    * might want this behavior.\n+   *\n+   * @specnote This constructor is public since JDK 1.4\n    */\n-  protected Socket ()\n+  public Socket ()\n   {\n     if (factory != null)\n       impl = factory.createSocketImpl();\n@@ -265,6 +267,56 @@ private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,\n       impl.connect(raddr, rport);\n   }\n \n+  /**\n+   * Binds the socket to the givent local address/port\n+   *\n+   * @param bindpoint The address/port to bind to\n+   *\n+   * @exception If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public void bind (SocketAddress bindpoint) throws IOException\n+  {\n+    if ( !(bindpoint instanceof InetSocketAddress))\n+      throw new IllegalArgumentException ();\n+\n+    InetSocketAddress tmp = (InetSocketAddress) bindpoint;\n+    impl.bind (tmp.getAddress(), tmp.getPort());\n+  }\n+  \n+  /**\n+   * Connects the socket with a remote address.\n+   *\n+   * @param endpoint The address to connect to\n+   *\n+   * @exception IOException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public void connect (SocketAddress endpoint)\n+    throws IOException\n+  {\n+    impl.connect (endpoint, 0);\n+  }\n+\n+  /**\n+   * Connects the socket with a remote address. A timeout of zero is\n+   * interpreted as an infinite timeout. The connection will then block\n+   * until established or an error occurs.\n+   *\n+   * @param endpoint The address to connect to\n+   *\n+   * @exception IOException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public void connect (SocketAddress endpoint, int timeout)\n+    throws IOException\n+  {\n+    impl.connect (endpoint, timeout);\n+  }\n+\n   /**\n    * Returns the address of the remote end of the socket.  If this socket\n    * is not connected, then <code>null</code> is returned.\n@@ -472,6 +524,43 @@ public int getSoLinger() throws SocketException\n       return -1;\n   }\n \n+  /**\n+   * Enables/disables the SO_OOBINLINE option\n+   * \n+   * @param on True if SO_OOBLINE should be enabled \n+   * \n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public void setOOBInline (boolean on) throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    impl.setOption(SocketOptions.SO_OOBINLINE, new Boolean(on));\n+  }\n+\n+  /**\n+   * Returns the current setting of the SO_OOBINLINE option for this socket\n+   * \n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public boolean getOOBInline () throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException(\"Not connected\");\n+\n+    Object buf = impl.getOption(SocketOptions.SO_OOBINLINE);\n+\n+    if (buf instanceof Boolean)\n+      return(((Boolean)buf).booleanValue());\n+    else\n+      throw new SocketException(\"Internal Error: Unexpected type\");\n+  }\n+  \n   /**\n    * Sets the value of the SO_TIMEOUT option on the socket.  If this value\n    * is set, and an read/write is performed that does not complete within\n@@ -632,7 +721,7 @@ public void setKeepAlive (boolean on) throws SocketException\n     if (impl == null)\n       throw new SocketException(\"Not connected\");\n \n-    impl.setOption(SocketOptions.SO_RCVBUF, new Boolean(on));\n+    impl.setOption(SocketOptions.SO_KEEPALIVE, new Boolean(on));\n   }\n \n   /**\n@@ -650,7 +739,7 @@ public boolean getKeepAlive () throws SocketException\n     if (impl == null)\n       throw new SocketException(\"Not connected\");\n \n-    Object buf = impl.getOption(SocketOptions.SO_RCVBUF);\n+    Object buf = impl.getOption(SocketOptions.SO_KEEPALIVE);\n \n     if (buf instanceof Boolean)\n       return(((Boolean)buf).booleanValue());"}]}