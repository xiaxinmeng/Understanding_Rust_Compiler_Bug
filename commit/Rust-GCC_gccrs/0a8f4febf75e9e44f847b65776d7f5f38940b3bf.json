{"sha": "0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE4ZjRmZWJmNzVlOWU0NGY4NDdiNjU3NzZkN2Y1ZjM4OTQwYjNiZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-01-23T16:46:17Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-01-29T15:52:08Z"}, "message": "libstdc++: Fix conformance issues in <stop_token> (PR92895)\n\nFix synchronization issues in <stop_token>. Replace shared_ptr with\n_Stop_state_ref and a reference count embedded in the shared state.\nReplace std::mutex with spinlock using one bit of a std::atomic<> that\nalso tracks whether a stop request has been made and how many\nstop_source objects share ownership of the state.\n\n\tPR libstdc++/92895\n\t* include/std/stop_token (stop_token::stop_possible()): Call new\n\t_M_stop_possible() function.\n\t(stop_token::stop_requested()): Do not use stop_possible().\n\t(stop_token::binary_semaphore): New class, as temporary stand-in for\n\tstd::binary_semaphore.\n\t(stop_token::_Stop_cb::_M_callback): Add noexcept to type.\n\t(stop_token::_Stop_cb::_M_destroyed, stop_token::_Stop_cb::_M_done):\n\tNew data members for symchronization with stop_callback destruction.\n\t(stop_token::_Stop_cb::_Stop_cb): Make non-template.\n\t(stop_token::_Stop_cb::_M_linked, stop_token::_Stop_cb::_S_execute):\n\tRemove.\n\t(stop_token::_Stop_cb::_M_run): New member function.\n\t(stop_token::_Stop_state::_M_stopped, stop_token::_Stop_state::_M_mtx):\n\tRemove.\n\t(stop_token::_Stop_state::_M_owners): New data member to track\n\treference count for ownership.\n\t(stop_token::_Stop_state::_M_value): New data member combining a\n\tspinlock, the stop requested flag, and the reference count for\n\tassociated stop_source objects.\n\t(stop_token::_Stop_state::_M_requester): New data member for\n\tsynchronization with stop_callback destruction.\n\t(stop_token::_Stop_state::_M_stop_possible()): New member function.\n\t(stop_token::_Stop_state::_M_stop_requested()): Inspect relevant bit\n\tof _M_value.\n\t(stop_token::_Stop_state::_M_add_owner)\n\t(stop_token::_Stop_state::_M_release_ownership)\n\t(stop_token::_Stop_state::_M_add_ssrc)\n\t(stop_token::_Stop_state::_M_sub_ssrc): New member functions for\n\tupdating reference counts.\n\t(stop_token::_Stop_state::_M_lock, stop_token::_Stop_state::_M_unlock)\n\t(stop_token::_Stop_state::_M_lock, stop_token::_Stop_state::_M_unlock)\n\t(stop_token::_Stop_state::_M_try_lock)\n\t(stop_token::_Stop_state::_M_try_lock_and_stop)\n\t(stop_token::_Stop_state::_M_do_try_lock): New member functions for\n\tmanaging spinlock.\n\t(stop_token::_Stop_state::_M_request_stop): Use atomic operations to\n\tread and update state. Release lock while running callbacks. Use new\n\tdata members to synchronize with callback destruction.\n\t(stop_token::_Stop_state::_M_remove_callback): Likewise.\n\t(stop_token::_Stop_state::_M_register_callback): Use atomic operations\n\tto read and update state.\n\t(stop_token::_Stop_state_ref): Handle type to manage _Stop_state,\n\treplacing shared_ptr.\n\t(stop_source::stop_source(const stop_source&)): Update reference count.\n\t(stop_source::operator=(const stop_source&)): Likewise.\n\t(stop_source::~stop_source()): Likewise.\n\t(stop_source::stop_source(stop_source&&)): Define as defaulted.\n\t(stop_source::operator=(stop_source&&)): Establish postcondition on\n\tparameter.\n\t(stop_callback): Enforce preconditions on template parameter. Replace\n\tbase class with data member of new _Cb_impl type.\n\t(stop_callback::stop_callback(const stop_token&, Cb&&))\n\t(stop_callback::stop_callback(stop_token&&, Cb&&)): Fix TOCTTOU race.\n\t(stop_callback::_Cb_impl): New type wrapping _Callback member and\n\tdefining the _S_execute member function.\n\t* testsuite/30_threads/stop_token/stop_callback/deadlock-mt.cc: New\n\ttest.\n\t* testsuite/30_threads/stop_token/stop_callback/deadlock.cc: New test.\n\t* testsuite/30_threads/stop_token/stop_callback/destroy.cc: New test.\n\t* testsuite/30_threads/stop_token/stop_callback/destructible_neg.cc:\n\tNew test.\n\t* testsuite/30_threads/stop_token/stop_callback/invocable_neg.cc: New\n\ttest.\n\t* testsuite/30_threads/stop_token/stop_callback/invoke.cc: New test.\n\t* testsuite/30_threads/stop_token/stop_source/assign.cc: New test.\n\t* testsuite/30_threads/stop_token/stop_token/stop_possible.cc: New\n\ttest.", "tree": {"sha": "41f1ebc55bf8097be0f8f03ce6d0e54a1b55d7d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41f1ebc55bf8097be0f8f03ce6d0e54a1b55d7d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989a5fb3aa5cb241727922c669da6742d33a7a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989a5fb3aa5cb241727922c669da6742d33a7a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/989a5fb3aa5cb241727922c669da6742d33a7a86"}], "stats": {"total": 982, "additions": 880, "deletions": 102}, "files": [{"sha": "6953a789bc3467db6b67558d63629f334dbbff79", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -1,5 +1,74 @@\n 2020-01-29  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/92895\n+\t* include/std/stop_token (stop_token::stop_possible()): Call new\n+\t_M_stop_possible() function.\n+\t(stop_token::stop_requested()): Do not use stop_possible().\n+\t(stop_token::binary_semaphore): New class, as temporary stand-in for\n+\tstd::binary_semaphore.\n+\t(stop_token::_Stop_cb::_M_callback): Add noexcept to type.\n+\t(stop_token::_Stop_cb::_M_destroyed, stop_token::_Stop_cb::_M_done):\n+\tNew data members for symchronization with stop_callback destruction.\n+\t(stop_token::_Stop_cb::_Stop_cb): Make non-template.\n+\t(stop_token::_Stop_cb::_M_linked, stop_token::_Stop_cb::_S_execute):\n+\tRemove.\n+\t(stop_token::_Stop_cb::_M_run): New member function.\n+\t(stop_token::_Stop_state::_M_stopped, stop_token::_Stop_state::_M_mtx):\n+\tRemove.\n+\t(stop_token::_Stop_state::_M_owners): New data member to track\n+\treference count for ownership.\n+\t(stop_token::_Stop_state::_M_value): New data member combining a\n+\tspinlock, the stop requested flag, and the reference count for\n+\tassociated stop_source objects.\n+\t(stop_token::_Stop_state::_M_requester): New data member for\n+\tsynchronization with stop_callback destruction.\n+\t(stop_token::_Stop_state::_M_stop_possible()): New member function.\n+\t(stop_token::_Stop_state::_M_stop_requested()): Inspect relevant bit\n+\tof _M_value.\n+\t(stop_token::_Stop_state::_M_add_owner)\n+\t(stop_token::_Stop_state::_M_release_ownership)\n+\t(stop_token::_Stop_state::_M_add_ssrc)\n+\t(stop_token::_Stop_state::_M_sub_ssrc): New member functions for\n+\tupdating reference counts.\n+\t(stop_token::_Stop_state::_M_lock, stop_token::_Stop_state::_M_unlock)\n+\t(stop_token::_Stop_state::_M_lock, stop_token::_Stop_state::_M_unlock)\n+\t(stop_token::_Stop_state::_M_try_lock)\n+\t(stop_token::_Stop_state::_M_try_lock_and_stop)\n+\t(stop_token::_Stop_state::_M_do_try_lock): New member functions for\n+\tmanaging spinlock.\n+\t(stop_token::_Stop_state::_M_request_stop): Use atomic operations to\n+\tread and update state. Release lock while running callbacks. Use new\n+\tdata members to synchronize with callback destruction.\n+\t(stop_token::_Stop_state::_M_remove_callback): Likewise.\n+\t(stop_token::_Stop_state::_M_register_callback): Use atomic operations\n+\tto read and update state.\n+\t(stop_token::_Stop_state_ref): Handle type to manage _Stop_state,\n+\treplacing shared_ptr.\n+\t(stop_source::stop_source(const stop_source&)): Update reference count.\n+\t(stop_source::operator=(const stop_source&)): Likewise.\n+\t(stop_source::~stop_source()): Likewise.\n+\t(stop_source::stop_source(stop_source&&)): Define as defaulted.\n+\t(stop_source::operator=(stop_source&&)): Establish postcondition on\n+\tparameter.\n+\t(stop_callback): Enforce preconditions on template parameter. Replace\n+\tbase class with data member of new _Cb_impl type.\n+\t(stop_callback::stop_callback(const stop_token&, Cb&&))\n+\t(stop_callback::stop_callback(stop_token&&, Cb&&)): Fix TOCTTOU race.\n+\t(stop_callback::_Cb_impl): New type wrapping _Callback member and\n+\tdefining the _S_execute member function.\n+\t* testsuite/30_threads/stop_token/stop_callback/deadlock-mt.cc: New\n+\ttest.\n+\t* testsuite/30_threads/stop_token/stop_callback/deadlock.cc: New test.\n+\t* testsuite/30_threads/stop_token/stop_callback/destroy.cc: New test.\n+\t* testsuite/30_threads/stop_token/stop_callback/destructible_neg.cc:\n+\tNew test.\n+\t* testsuite/30_threads/stop_token/stop_callback/invocable_neg.cc: New\n+\ttest.\n+\t* testsuite/30_threads/stop_token/stop_callback/invoke.cc: New test.\n+\t* testsuite/30_threads/stop_token/stop_source/assign.cc: New test.\n+\t* testsuite/30_threads/stop_token/stop_token/stop_possible.cc: New\n+\ttest.\n+\n \t* libsupc++/compare (__detail::__3way_builtin_ptr_cmp): Use\n \tthree_way_comparable_with.\n \t(__detail::__3way_cmp_with): Remove workaround for fixed bug."}, {"sha": "6fb8ae05197c5bb4f45416c0213a34bba5cbd3ff", "filename": "libstdc++-v3/include/std/stop_token", "status": "modified", "additions": 376, "deletions": 102, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -32,13 +32,13 @@\n #if __cplusplus > 201703L\n \n #include <atomic>\n-#include <bits/std_mutex.h>\n-#include <ext/concurrence.h>\n-#include <bits/unique_ptr.h>\n-#include <bits/shared_ptr.h>\n \n #ifdef _GLIBCXX_HAS_GTHREADS\n # define __cpp_lib_jthread 201907L\n+# include <bits/gthr.h>\n+# if __has_include(<semaphore>)\n+#  include <semaphore>\n+# endif\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -49,35 +49,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   struct nostopstate_t { explicit nostopstate_t() = default; };\n   inline constexpr nostopstate_t nostopstate{};\n \n+  class stop_source;\n+\n   /// Allow testing whether a stop request has been made on a `stop_source`.\n   class stop_token\n   {\n   public:\n     stop_token() noexcept = default;\n \n-    stop_token(const stop_token& __other) noexcept = default;\n-    stop_token(stop_token&& __other) noexcept = default;\n+    stop_token(const stop_token&) noexcept = default;\n+    stop_token(stop_token&&) noexcept = default;\n \n     ~stop_token() = default;\n \n     stop_token&\n-    operator=(const stop_token& __rhs) noexcept = default;\n+    operator=(const stop_token&) noexcept = default;\n \n     stop_token&\n-    operator=(stop_token&& __rhs) noexcept = default;\n+    operator=(stop_token&&) noexcept = default;\n \n     [[nodiscard]]\n     bool\n     stop_possible() const noexcept\n     {\n-      return static_cast<bool>(_M_state);\n+      return static_cast<bool>(_M_state) && _M_state->_M_stop_possible();\n     }\n \n     [[nodiscard]]\n     bool\n     stop_requested() const noexcept\n     {\n-      return stop_possible() && _M_state->_M_stop_requested();\n+      return static_cast<bool>(_M_state) && _M_state->_M_stop_requested();\n     }\n \n     void\n@@ -98,120 +100,373 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     template<typename _Callback>\n       friend class stop_callback;\n \n-    struct _Stop_cb\n+    static void\n+    _S_yield() noexcept\n     {\n-      void(*_M_callback)(_Stop_cb*);\n-      _Stop_cb* _M_prev = nullptr;\n-      _Stop_cb* _M_next = nullptr;\n+#if defined __i386__ || defined __x86_64__\n+      __builtin_ia32_pause();\n+#elif defined _GLIBCXX_USE_SCHED_YIELD\n+      __gthread_yield();\n+#endif\n+    }\n \n-      template<typename _Cb>\n-\t_Stop_cb(_Cb&& __cb)\n-\t: _M_callback(std::forward<_Cb>(__cb))\n-\t{ }\n+#ifndef __cpp_lib_semaphore\n+    // TODO: replace this with a real implementation of std::binary_semaphore\n+    struct binary_semaphore\n+    {\n+      explicit binary_semaphore(int __d) : _M_counter(__d > 0) { }\n \n-      bool\n-      _M_linked() const noexcept\n-      {\n-        return (_M_prev != nullptr)\n-          || (_M_next != nullptr);\n-      }\n+      void release() { _M_counter.fetch_add(1, memory_order::release); }\n \n-      static void\n-      _S_execute(_Stop_cb* __cb) noexcept\n+      void acquire()\n       {\n-        __cb->_M_callback(__cb);\n-        __cb->_M_prev = __cb->_M_next = nullptr;\n+\tint __old = 1;\n+\twhile (!_M_counter.compare_exchange_weak(__old, 0,\n+\t\t\t\t\t\t memory_order::acquire,\n+\t\t\t\t\t\t memory_order::relaxed))\n+\t  {\n+\t    __old = 1;\n+\t    _S_yield();\n+\t  }\n       }\n+\n+      atomic<int> _M_counter;\n+    };\n+#endif\n+\n+    struct _Stop_cb\n+    {\n+      using __cb_type = void(_Stop_cb*) noexcept;\n+      __cb_type* _M_callback;\n+      _Stop_cb* _M_prev = nullptr;\n+      _Stop_cb* _M_next = nullptr;\n+      bool* _M_destroyed = nullptr;\n+      binary_semaphore _M_done{0};\n+\n+      [[__gnu__::__nonnull__]]\n+      explicit\n+      _Stop_cb(__cb_type* __cb)\n+      : _M_callback(__cb)\n+      { }\n+\n+      void _M_run() noexcept { _M_callback(this); }\n     };\n \n     struct _Stop_state_t\n     {\n-      std::atomic<bool> _M_stopped{false};\n+      using value_type = uint32_t;\n+      static constexpr value_type _S_stop_requested_bit = 1;\n+      static constexpr value_type _S_locked_bit = 2;\n+      static constexpr value_type _S_ssrc_counter_inc = 4;\n+\n+      std::atomic<value_type> _M_owners{1};\n+      std::atomic<value_type> _M_value{_S_ssrc_counter_inc};\n       _Stop_cb* _M_head = nullptr;\n-#ifdef _GLIBCXX_HAS_GTHREADS\n-      std::mutex _M_mtx;\n+#if _GLIBCXX_HAS_GTHREADS\n+      __gthread_t _M_requester;\n #endif\n \n       _Stop_state_t() = default;\n \n+      bool\n+      _M_stop_possible() noexcept\n+      {\n+\t// true if a stop request has already been made or there are still\n+\t// stop_source objects that would allow one to be made.\n+\treturn _M_value.load(memory_order::acquire) & ~_S_locked_bit;\n+      }\n+\n       bool\n       _M_stop_requested() noexcept\n       {\n-        return _M_stopped;\n+\treturn _M_value.load(memory_order::acquire) & _S_stop_requested_bit;\n+      }\n+\n+      void\n+      _M_add_owner() noexcept\n+      {\n+\t_M_owners.fetch_add(1, memory_order::relaxed);\n+      }\n+\n+      void\n+      _M_release_ownership() noexcept\n+      {\n+\tif (_M_owners.fetch_sub(1, memory_order::release) == 1)\n+\t  delete this;\n+      }\n+\n+      void\n+      _M_add_ssrc() noexcept\n+      {\n+\t_M_value.fetch_add(_S_ssrc_counter_inc, memory_order::relaxed);\n+      }\n+\n+      void\n+      _M_sub_ssrc() noexcept\n+      {\n+\t_M_value.fetch_sub(_S_ssrc_counter_inc, memory_order::release);\n+      }\n+\n+      // Obtain lock.\n+      void\n+      _M_lock() noexcept\n+      {\n+\t// Can use relaxed loads to get the current value.\n+\t// The successful call to _M_try_lock is an acquire operation.\n+\tauto __old = _M_value.load(memory_order::relaxed);\n+\twhile (!_M_try_lock(__old, memory_order::relaxed))\n+\t  { }\n+      }\n+\n+      // Precondition: calling thread holds the lock.\n+      void\n+      _M_unlock() noexcept\n+      {\n+\t_M_value.fetch_sub(_S_locked_bit, memory_order::release);\n       }\n \n       bool\n-      _M_request_stop()\n+      _M_request_stop() noexcept\n       {\n-        bool __stopped = false;\n-        if (_M_stopped.compare_exchange_strong(__stopped, true))\n-          {\n-#ifdef _GLIBCXX_HAS_GTHREADS\n-            std::lock_guard<std::mutex> __lck{_M_mtx};\n+\t// obtain lock and set stop_requested bit\n+\tauto __old = _M_value.load(memory_order::acquire);\n+\tdo\n+\t  {\n+\t    if (__old & _S_stop_requested_bit) // stop request already made\n+\t      return false;\n+\t  }\n+\twhile (!_M_try_lock_and_stop(__old));\n+\n+#if _GLIBCXX_HAS_GTHREADS\n+\t_M_requester = __gthread_self();\n #endif\n-            while (_M_head)\n-              {\n-                auto __p = _M_head;\n-                _M_head = _M_head->_M_next;\n-                _Stop_cb::_S_execute(__p);\n-              }\n-            return true;\n-          }\n-        return false;\n+\n+\twhile (_M_head)\n+\t  {\n+\t    bool __last_cb;\n+\t    _Stop_cb* __cb = _M_head;\n+\t    _M_head = _M_head->_M_next;\n+\t    if (_M_head)\n+\t      {\n+\t\t_M_head->_M_prev = nullptr;\n+\t\t__last_cb = false;\n+\t      }\n+\t    else\n+\t      __last_cb = true;\n+\n+\t    // Allow other callbacks to be unregistered while __cb runs.\n+\t    _M_unlock();\n+\n+\t    bool __destroyed = false;\n+\t    __cb->_M_destroyed = &__destroyed;\n+\n+\t    // run callback\n+\t    __cb->_M_run();\n+\n+\t    if (!__destroyed)\n+\t      {\n+\t\t__cb->_M_destroyed = nullptr;\n+#if _GLIBCXX_HAS_GTHREADS\n+\t\t// synchronize with destructor of stop_callback that owns *__cb\n+\t\t__cb->_M_done.release();\n+#endif\n+\t      }\n+\n+\t    // Avoid relocking if we already know there are no more callbacks.\n+\t    if (__last_cb)\n+\t      return true;\n+\n+\t    _M_lock();\n+\t  }\n+\n+\t_M_unlock();\n+\treturn true;\n       }\n \n+      [[__gnu__::__nonnull__]]\n       bool\n-      _M_register_callback(_Stop_cb* __cb)\n+      _M_register_callback(_Stop_cb* __cb) noexcept\n       {\n-#ifdef _GLIBCXX_HAS_GTHREADS\n-        std::lock_guard<std::mutex> __lck{_M_mtx};\n-#endif\n-        if (_M_stopped)\n-          return false;\n+\tauto __old = _M_value.load(memory_order::acquire);\n+\tdo\n+\t  {\n+\t    if (__old & _S_stop_requested_bit) // stop request already made\n+\t      {\n+\t\t__cb->_M_run(); // run synchronously\n+\t\treturn false;\n+\t      }\n+\n+\t    if (__old < _S_ssrc_counter_inc) // no stop_source owns *this\n+\t      // No need to register callback if no stop request can be made.\n+\t      // Returning false also means the stop_callback does not share\n+\t      // ownership of this state, but that's not observable.\n+\t      return false;\n+\t  }\n+\twhile (!_M_try_lock(__old));\n \n         __cb->_M_next = _M_head;\n         if (_M_head)\n           {\n             _M_head->_M_prev = __cb;\n           }\n         _M_head = __cb;\n+\t_M_unlock();\n         return true;\n       }\n \n+      // Called by ~stop_callback just before destroying *__cb.\n+      [[__gnu__::__nonnull__]]\n       void\n       _M_remove_callback(_Stop_cb* __cb)\n       {\n-#ifdef _GLIBCXX_HAS_GTHREADS\n-        std::lock_guard<std::mutex> __lck{_M_mtx};\n-#endif\n+\t_M_lock();\n+\n         if (__cb == _M_head)\n           {\n             _M_head = _M_head->_M_next;\n             if (_M_head)\n-              {\n-                _M_head->_M_prev = nullptr;\n-              }\n+\t      _M_head->_M_prev = nullptr;\n+\t    _M_unlock();\n+\t    return;\n           }\n-        else if (!__cb->_M_linked())\n-          {\n-            return;\n-          }\n-        else\n+\telse if (__cb->_M_prev)\n           {\n             __cb->_M_prev->_M_next = __cb->_M_next;\n             if (__cb->_M_next)\n-              {\n-                __cb->_M_next->_M_prev = __cb->_M_prev;\n-              }\n+\t      __cb->_M_next->_M_prev = __cb->_M_prev;\n+\t    _M_unlock();\n+\t    return;\n           }\n+\n+\t_M_unlock();\n+\n+\t// Callback is not in the list, so must have been removed by a call to\n+\t// _M_request_stop.\n+\n+#if _GLIBCXX_HAS_GTHREADS\n+\t// Despite appearances there is no data race on _M_requester. The only\n+\t// write to it happens before the callback is removed from the list,\n+\t// and removing it from the list happens before this read.\n+\tif (!__gthread_equal(_M_requester, __gthread_self()))\n+\t  {\n+\t    // Synchronize with completion of callback.\n+\t    __cb->_M_done.acquire();\n+\t    // Safe for ~stop_callback to destroy *__cb now.\n+\t    return;\n+\t  }\n+#endif\n+\tif (__cb->_M_destroyed)\n+\t  *__cb->_M_destroyed = true;\n+      }\n+\n+      // Try to obtain the lock.\n+      // Returns true if the lock is acquired (with memory order acquire).\n+      // Otherwise, sets __curval = _M_value.load(__failure) and returns false.\n+      // Might fail spuriously, so must be called in a loop.\n+      bool\n+      _M_try_lock(value_type& __curval,\n+\t\t  memory_order __failure = memory_order::acquire) noexcept\n+      {\n+\treturn _M_do_try_lock(__curval, 0, memory_order::acquire, __failure);\n+      }\n+\n+      // Try to obtain the lock to make a stop request.\n+      // Returns true if the lock is acquired and the _S_stop_requested_bit is\n+      // set (with memory order acq_rel so that other threads see the request).\n+      // Otherwise, sets __curval = _M_value.load(memory_order::acquire) and\n+      // returns false.\n+      // Might fail spuriously, so must be called in a loop.\n+      bool\n+      _M_try_lock_and_stop(value_type& __curval) noexcept\n+      {\n+\treturn _M_do_try_lock(__curval, _S_stop_requested_bit,\n+\t\t\t      memory_order::acq_rel, memory_order::acquire);\n+      }\n+\n+      bool\n+      _M_do_try_lock(value_type& __curval, value_type __newbits,\n+\t\t     memory_order __success, memory_order __failure) noexcept\n+      {\n+\tif (__curval & _S_locked_bit)\n+\t  {\n+\t    _S_yield();\n+\t    __curval = _M_value.load(__failure);\n+\t    return false;\n+\t  }\n+\t__newbits |= _S_locked_bit;\n+\treturn _M_value.compare_exchange_weak(__curval, __curval | __newbits,\n+\t\t\t\t\t      __success, __failure);\n+      }\n+    };\n+\n+    struct _Stop_state_ref\n+    {\n+      _Stop_state_ref() = default;\n+\n+      explicit\n+      _Stop_state_ref(const stop_source&)\n+      : _M_ptr(new _Stop_state_t())\n+      { }\n+\n+      _Stop_state_ref(const _Stop_state_ref& __other) noexcept\n+      : _M_ptr(__other._M_ptr)\n+      {\n+\tif (_M_ptr)\n+\t  _M_ptr->_M_add_owner();\n+      }\n+\n+      _Stop_state_ref(_Stop_state_ref&& __other) noexcept\n+      : _M_ptr(__other._M_ptr)\n+      {\n+\t__other._M_ptr = nullptr;\n       }\n+\n+      _Stop_state_ref&\n+      operator=(const _Stop_state_ref& __other) noexcept\n+      {\n+\tif (auto __ptr = __other._M_ptr; __ptr != _M_ptr)\n+\t  {\n+\t    if (__ptr)\n+\t      __ptr->_M_add_owner();\n+\t    if (_M_ptr)\n+\t      _M_ptr->_M_release_ownership();\n+\t    _M_ptr = __ptr;\n+\t  }\n+\treturn *this;\n+      }\n+\n+      _Stop_state_ref&\n+      operator=(_Stop_state_ref&& __other) noexcept\n+      {\n+\t_Stop_state_ref(std::move(__other)).swap(*this);\n+\treturn *this;\n+      }\n+\n+      ~_Stop_state_ref()\n+      {\n+\tif (_M_ptr)\n+\t  _M_ptr->_M_release_ownership();\n+      }\n+\n+      void\n+      swap(_Stop_state_ref& __other) noexcept\n+      { std::swap(_M_ptr, __other._M_ptr); }\n+\n+      explicit operator bool() const noexcept { return _M_ptr != nullptr; }\n+\n+      _Stop_state_t* operator->() const noexcept { return _M_ptr; }\n+\n+      friend bool\n+      operator==(const _Stop_state_ref&, const _Stop_state_ref&) = default;\n+\n+    private:\n+      _Stop_state_t* _M_ptr = nullptr;\n     };\n \n-    using _Stop_state = std::shared_ptr<_Stop_state_t>;\n-    _Stop_state _M_state;\n+    _Stop_state_ref _M_state;\n \n     explicit\n-    stop_token(const _Stop_state& __state) noexcept\n+    stop_token(const _Stop_state_ref& __state) noexcept\n     : _M_state{__state}\n     { }\n   };\n@@ -220,34 +475,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   class stop_source\n   {\n   public:\n-    stop_source()\n-      : _M_state(std::make_shared<stop_token::_Stop_state_t>())\n+    stop_source() : _M_state(*this)\n     { }\n \n     explicit stop_source(std::nostopstate_t) noexcept\n     { }\n \n     stop_source(const stop_source& __other) noexcept\n-      : _M_state(__other._M_state)\n-    { }\n+    : _M_state(__other._M_state)\n+    {\n+      if (_M_state)\n+\t_M_state->_M_add_ssrc();\n+    }\n \n-    stop_source(stop_source&& __other) noexcept\n-      : _M_state(std::move(__other._M_state))\n-    { }\n+    stop_source(stop_source&&) noexcept = default;\n \n     stop_source&\n-    operator=(const stop_source& __rhs) noexcept\n+    operator=(const stop_source& __other) noexcept\n     {\n-      if (_M_state != __rhs._M_state)\n-        _M_state = __rhs._M_state;\n+      if (_M_state != __other._M_state)\n+\t{\n+\t  stop_source __sink(std::move(*this));\n+\t  _M_state = __other._M_state;\n+\t  if (_M_state)\n+\t    _M_state->_M_add_ssrc();\n+\t}\n       return *this;\n     }\n \n     stop_source&\n-    operator=(stop_source&& __rhs) noexcept\n+    operator=(stop_source&&) noexcept = default;\n+\n+    ~stop_source()\n     {\n-      std::swap(_M_state, __rhs._M_state);\n-      return *this;\n+      if (_M_state)\n+\t_M_state->_M_sub_ssrc();\n     }\n \n     [[nodiscard]]\n@@ -261,7 +523,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool\n     stop_requested() const noexcept\n     {\n-      return stop_possible() && _M_state->_M_stop_requested();\n+      return static_cast<bool>(_M_state) && _M_state->_M_stop_requested();\n     }\n \n     bool\n@@ -299,14 +561,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   private:\n-    stop_token::_Stop_state _M_state;\n+    stop_token::_Stop_state_ref _M_state;\n   };\n \n   /// A wrapper for callbacks to be run when a stop request is made.\n   template<typename _Callback>\n     class [[nodiscard]] stop_callback\n-      : private stop_token::_Stop_cb\n     {\n+      static_assert(is_nothrow_destructible_v<_Callback>);\n+      static_assert(is_invocable_v<_Callback>);\n+\n     public:\n       using callback_type = _Callback;\n \n@@ -315,13 +579,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         explicit\n \tstop_callback(const stop_token& __token, _Cb&& __cb)\n         noexcept(is_nothrow_constructible_v<_Callback, _Cb>)\n-        : _Stop_cb(&_S_execute), _M_cb(std::forward<_Cb>(__cb))\n+\t: _M_cb(std::forward<_Cb>(__cb))\n         {\n \t  if (auto __state = __token._M_state)\n \t    {\n-\t      if (__state->_M_stop_requested())\n-\t\t_S_execute(this); // ensures std::terminate on throw\n-\t      else if (__state->_M_register_callback(this))\n+\t      if (__state->_M_register_callback(&_M_cb))\n \t\t_M_state.swap(__state);\n \t    }\n         }\n@@ -331,13 +593,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         explicit\n \tstop_callback(stop_token&& __token, _Cb&& __cb)\n         noexcept(is_nothrow_constructible_v<_Callback, _Cb>)\n-        : _Stop_cb(&_S_execute), _M_cb(std::forward<_Cb>(__cb))\n+\t: _M_cb(std::forward<_Cb>(__cb))\n \t{\n \t  if (auto& __state = __token._M_state)\n \t    {\n-\t      if (__state->_M_stop_requested())\n-\t\t_S_execute(this); // ensures std::terminate on throw\n-\t      else if (__state->_M_register_callback(this))\n+\t      if (__state->_M_register_callback(&_M_cb))\n \t\t_M_state.swap(__state);\n \t    }\n \t}\n@@ -346,7 +606,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \tif (_M_state)\n \t  {\n-\t    _M_state->_M_remove_callback(this);\n+\t    _M_state->_M_remove_callback(&_M_cb);\n \t  }\n       }\n \n@@ -356,14 +616,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       stop_callback& operator=(stop_callback&&) = delete;\n \n     private:\n-      _Callback _M_cb;\n-      stop_token::_Stop_state _M_state = nullptr;\n-\n-      static void\n-      _S_execute(_Stop_cb* __that) noexcept\n+      struct _Cb_impl : stop_token::_Stop_cb\n       {\n-\tstatic_cast<stop_callback*>(__that)->_M_cb();\n-      }\n+\ttemplate<typename _Cb>\n+\t  explicit\n+\t  _Cb_impl(_Cb&& __cb)\n+\t  : _Stop_cb(&_S_execute),\n+\t    _M_cb(std::forward<_Cb>(__cb))\n+\t  { }\n+\n+\t_Callback _M_cb;\n+\n+\t[[__gnu__::__nonnull__]]\n+\tstatic void\n+\t_S_execute(_Stop_cb* __that) noexcept\n+\t{\n+\t  _Callback& __cb = static_cast<_Cb_impl*>(__that)->_M_cb;\n+\t  std::forward<_Callback>(__cb)();\n+\t}\n+      };\n+\n+      _Cb_impl _M_cb;\n+      stop_token::_Stop_state_ref _M_state;\n     };\n \n   template<typename _Callback>"}, {"sha": "12c54db554fdcc8cc21df20223d321bf79b6e3c5", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_callback/deadlock-mt.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdeadlock-mt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdeadlock-mt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdeadlock-mt.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\"  }\n+// { dg-require-effective-target c++2a }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <stop_token>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::stop_source ssrc;\n+  std::stop_token stok = ssrc.get_token();\n+  using F = void(*)();\n+  std::unique_ptr<std::stop_callback<F>> pcb;\n+  auto dereg = [&pcb] { pcb.reset(); };\n+  std::stop_callback cb1(stok, dereg);\n+  pcb = std::make_unique<std::stop_callback<F>>(stok, []{});\n+  std::stop_callback cb2(stok, dereg);\n+\n+  // PR libstdc++/92895\n+  // Making a stop request runs the callbacks. Whichever of cb1 and cb2\n+  // runs first will destroy *pcb, which will try to unregister it.\n+  // This recursive access to the shared stop state within a callback must\n+  // work without deadlock.\n+  ssrc.request_stop();\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "f9de6e02562d8c76a0a6a0b3fc709102bde0390a", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_callback/deadlock.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdeadlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdeadlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdeadlock.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <stop_token>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::stop_source ssrc;\n+  std::stop_token stok = ssrc.get_token();\n+  using F = void(*)();\n+  std::unique_ptr<std::stop_callback<F>> pcb;\n+  auto dereg = [&pcb] { pcb.reset(); };\n+  std::stop_callback cb1(stok, dereg);\n+  pcb = std::make_unique<std::stop_callback<F>>(stok, []{});\n+  std::stop_callback cb2(stok, dereg);\n+\n+  // PR libstdc++/92895\n+  // Making a stop request runs the callbacks. Whichever of cb1 and cb2\n+  // runs first will destroy *pcb, which will try to unregister it.\n+  // This recursive access to the shared stop state within a callback must\n+  // work without deadlock.\n+  ssrc.request_stop();\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "3fa4d21c55cbf3db372babc22dcce4dd31412d27", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_callback/destroy.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdestroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdestroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdestroy.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\"  }\n+// { dg-require-effective-target c++2a }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <stop_token>\n+#include <atomic>\n+#include <thread>\n+#include <testsuite_hooks.h>\n+\n+struct F\n+{\n+  static std::atomic<int> stage;\n+\n+  F(int) { }\n+\n+  ~F()\n+  {\n+    // PR libstdc++/92895\n+    // Callback function must not be destroyed while still executing.\n+    VERIFY( stage == 4 );\n+  }\n+\n+  void operator()() const noexcept\n+  {\n+    stage = 2; // trigger destructor of stop_callback that owns *this\n+    while (stage == 2)\n+      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+    std::this_thread::sleep_for(std::chrono::milliseconds(500));\n+    stage = 4; // destructor checks for this\n+  }\n+};\n+\n+std::atomic<int> F::stage{0};\n+\n+void\n+test01()\n+{\n+  std::stop_source ssrc;\n+  std::stop_token stok = ssrc.get_token();\n+  std::thread t1([&ssrc] {\n+    while (F::stage == 0)\n+      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+    ssrc.request_stop();\n+    while (F::stage != 5)\n+      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+  });\n+\n+  std::thread t2([&ssrc] {\n+    std::stop_callback<F> cb(ssrc.get_token(), 0);\n+    F::stage = 1; // trigger stop request in other thread, which runs callback\n+    while (F::stage == 1)\n+      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+    F::stage = 3;\n+    // stop_callback destructor should block until callback completes\n+  });\n+\n+  t2.join();\n+  F::stage = 5; // allow first thread to exit\n+  t1.join();\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "5016af009c01a4952c3ff66a4c481ef1a50a7be3", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_callback/destructible_neg.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdestructible_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdestructible_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Fdestructible_neg.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <stop_token>\n+\n+struct F\n+{\n+  F();\n+\n+  void operator()() const { }\n+\n+private:\n+  ~F();\n+};\n+\n+auto\n+test01(std::stop_token& tok, F& f)\n+{\n+  auto ok = sizeof(std::stop_callback<F&>);\n+  auto bad = sizeof(std::stop_callback<F>); // { dg-error \"here\" }\n+  return ok + bad;\n+}\n+\n+struct G\n+{\n+  G();\n+  ~G() noexcept(false);\n+\n+  void operator()() const { }\n+};\n+\n+auto\n+test02(std::stop_token& tok, G& g)\n+{\n+  auto ok = sizeof(std::stop_callback<G&>);\n+  auto bad = sizeof(std::stop_callback<G>); // { dg-error \"here\" }\n+  return ok + bad;\n+}\n+\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "459a481ed6ef64aa32d6d94190ce4730697debd7", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_callback/invocable_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Finvocable_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Finvocable_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Finvocable_neg.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <stop_token>\n+\n+struct F\n+{\n+};\n+\n+auto\n+test01(std::stop_token& tok, F& f)\n+{\n+  auto bad1 = sizeof(std::stop_callback<F&>); // { dg-error \"here\" }\n+  auto bad2 = sizeof(std::stop_callback<F>);  // { dg-error \"here\" }\n+  return bad1 + bad2;\n+}\n+\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "9b8137cc46d25e5d320d7dcc3e1f69785f322874", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_callback/invoke.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Finvoke.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Finvoke.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_callback%2Finvoke.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <stop_token>\n+#include <testsuite_hooks.h>\n+\n+int lval[5];\n+int rval[5];\n+\n+void\n+test01()\n+{\n+  std::stop_source ssrc;\n+  std::stop_token stok = ssrc.get_token();\n+  struct F\n+  {\n+    void operator()() const & { ++lval[i]; }\n+    void operator()() && { ++rval[i]; }\n+\n+    int i;\n+  };\n+  std::stop_callback<F> cb0(stok, F{0});\n+  std::stop_callback<F> cb1(stok, F{1});\n+  std::stop_callback<F> cb2(stok, F{2});\n+  F f3{3};\n+  std::stop_callback<F&> cb3(stok, f3);\n+  std::stop_callback<const F> cb4(stok, F{4});\n+\n+  // PR libstdc++/92895\n+  // Callback should be invoked with correct value category.\n+  ssrc.request_stop();\n+\n+  VERIFY( lval[0] == 0 && lval[1] == 0 && lval[2] == 0 );\n+  VERIFY( lval[3] == 1 );\n+  VERIFY( lval[4] == 1 );\n+  VERIFY( rval[0] == 1 );\n+  VERIFY( rval[1] == 1 );\n+  VERIFY( rval[2] == 1 );\n+  VERIFY( rval[3] == 0 && rval[4] == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "c822e8e398f7406e249288dd714db7c9c926579f", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_source/assign.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_source%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_source%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_source%2Fassign.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <stop_token>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::stop_source src1, src2;\n+  const std::stop_source orig1(src1);\n+  VERIFY( src1 != src2 );\n+  src1 = src2;\n+  VERIFY( src1 == src2 );\n+  VERIFY( src1 != orig1 );\n+}\n+\n+void\n+test02()\n+{\n+  std::stop_source src1, src2;\n+  const std::stop_source orig1(src1), orig2(src2), src0(std::nostopstate);\n+  src1 = std::move(src2);\n+  VERIFY( src1 == orig2 );\n+  VERIFY( src2 == src0 );\n+  VERIFY( src1 != orig1 );\n+  VERIFY( src0 != orig1 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "ee8de6889ed4f65c0bc70428853b2f10ca7673b4", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_token/stop_possible.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token%2Fstop_possible.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8f4febf75e9e44f847b65776d7f5f38940b3bf/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token%2Fstop_possible.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token%2Fstop_possible.cc?ref=0a8f4febf75e9e44f847b65776d7f5f38940b3bf", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <stop_token>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::stop_source ssrc;\n+  std::stop_token tok = ssrc.get_token();\n+  VERIFY(tok.stop_possible());\n+\n+  ssrc.request_stop();\n+  VERIFY(tok.stop_possible());\n+}\n+\n+void\n+test02()\n+{\n+  std::stop_token tok = std::stop_source().get_token();\n+  // PR libstdc++/92895\n+  // stop_possible() is false when there is no associated stop_source\n+  VERIFY(!tok.stop_possible());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}]}