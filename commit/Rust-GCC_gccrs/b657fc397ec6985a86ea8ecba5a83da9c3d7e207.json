{"sha": "b657fc397ec6985a86ea8ecba5a83da9c3d7e207", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY1N2ZjMzk3ZWM2OTg1YTg2ZWE4ZWNiYTVhODNkYTljM2Q3ZTIwNw==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gnu.org", "date": "1998-06-05T00:13:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-05T00:13:57Z"}, "message": "i386.c (output_fp_conditional_move): New function to output floating point conditional move.\n\n        * i386/i386.c (output_fp_conditional_move): New function\n        to output floating point conditional move.\n        (output_int_conditional_move): New function to output integer\n        conditional move.\n        * i386/i386.md (movsicci+5, movhicc+5, movdicc+5): Call\n        output_int_conditional_move () to output int conditional move.\n        (movsfcc+5, movdfcc+5, movxfcc+5): Call\n        output_fp_conditional_move () to output floating point\n        conditional move.\n        * i386/i386.c (put_condition_code): In INT mode, check\n        cc_prev_status.flags & CC_NO_OVERFLOW for GE and LT.\n\nFrom-SVN: r20233", "tree": {"sha": "e981f078bfcfcc87807e3fcb9cb8288abb40c57b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e981f078bfcfcc87807e3fcb9cb8288abb40c57b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b657fc397ec6985a86ea8ecba5a83da9c3d7e207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b657fc397ec6985a86ea8ecba5a83da9c3d7e207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b657fc397ec6985a86ea8ecba5a83da9c3d7e207", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b657fc397ec6985a86ea8ecba5a83da9c3d7e207/comments", "author": null, "committer": null, "parents": [{"sha": "265078b93fa51175c9d5942476b288849be92bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265078b93fa51175c9d5942476b288849be92bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265078b93fa51175c9d5942476b288849be92bc1"}], "stats": {"total": 341, "additions": 151, "deletions": 190}, "files": [{"sha": "4a9e3a27d147447ff4fe219f339e234d09e5f794", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b657fc397ec6985a86ea8ecba5a83da9c3d7e207/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b657fc397ec6985a86ea8ecba5a83da9c3d7e207/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b657fc397ec6985a86ea8ecba5a83da9c3d7e207", "patch": "@@ -1,3 +1,19 @@\n+Fri Jun  5 01:12:15 1998  H.J. Lu  (hjl@gnu.org)\n+\n+\t* i386/i386.c (output_fp_conditional_move): New function\n+\tto output floating point conditional move.\n+\t(output_int_conditional_move): New function to output integer\n+\tconditional move.\n+\n+\t* i386/i386.md (movsicci+5, movhicc+5, movdicc+5): Call\n+\toutput_int_conditional_move () to output int conditional move.\n+\t(movsfcc+5, movdfcc+5, movxfcc+5): Call\n+\toutput_fp_conditional_move () to output floating point\n+\tconditional move.\n+\n+\t* i386/i386.c (put_condition_code): In INT mode, check\n+\tcc_prev_status.flags & CC_NO_OVERFLOW for GE and LT.\n+\n Thu Jun  4 16:09:51 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* dbxout.c (dbxout_type): Output arrays of bits as if"}, {"sha": "73d89dc8cddae03e77394df866228e973c88a87b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 129, "deletions": 2, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b657fc397ec6985a86ea8ecba5a83da9c3d7e207/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b657fc397ec6985a86ea8ecba5a83da9c3d7e207/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b657fc397ec6985a86ea8ecba5a83da9c3d7e207", "patch": "@@ -3097,7 +3097,10 @@ put_condition_code (code, reverse_cc, mode, file)\n \treturn;\n \n       case GE:\n-\tfputs (\"ge\", file);\n+\tif (cc_prev_status.flags & CC_NO_OVERFLOW)\n+\t  fputs (\"ns\", file);\n+\telse\n+\t  fputs (\"ge\", file);\n \treturn;\n \n       case GT:\n@@ -3109,7 +3112,10 @@ put_condition_code (code, reverse_cc, mode, file)\n \treturn;\n \n       case LT:\n-\tfputs (\"l\", file);\n+\tif (cc_prev_status.flags & CC_NO_OVERFLOW)\n+\t  fputs (\"s\", file);\n+\telse\n+\t  fputs (\"l\", file);\n \treturn;\n \n       case GEU:\n@@ -5132,3 +5138,124 @@ output_strlen_unroll (operands)\n \n   return \"\";\n }\n+\n+char *\n+output_fp_conditional_move (which_alternative, operands)\n+     int which_alternative;\n+     rtx operands[];\n+{\n+  int code = GET_CODE (operands[1]);\n+\n+  /* This is very tricky. We have to do it right. For a code segement\n+     like:\n+\n+\tint foo;\n+\tdouble bar;\n+\t....\n+\tfoo = foo - x;\n+\tif (foo >= 0)\n+\t  bar = y;\n+\n+     final_scan_insn () may delete the insn which sets CC. We have to\n+     tell final_scan_insn () if it should be reinserted. When CODE is\n+     GT or LE, we have to check the CC_NO_OVERFLOW bit and return\n+     NULL_PTR to tell final to reinsert the test insn because the\n+     conditional move cannot be handled properly without it. */\n+  if ((code == GT || code == LE)\n+      && (cc_prev_status.flags & CC_NO_OVERFLOW))\n+    return NULL_PTR;\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* r <- cond ? arg : r */\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      break;\n+  \n+    case 1:\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n+\n+    case 2:\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n+      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return \"\";\n+}\n+\n+char *\n+output_int_conditional_move (which_alternative, operands)\n+     int which_alternative;\n+     rtx operands[];\n+{\n+  int code = GET_CODE (operands[1]);\n+  enum machine_mode mode;\n+  rtx xops[4];\n+\n+  /* This is very tricky. We have to do it right. For a code segement\n+     like:\n+\n+\tint foo, bar;\n+\t....\n+\tfoo = foo - x;\n+\tif (foo >= 0)\n+\t  bar = y;\n+\n+     final_scan_insn () may delete the insn which sets CC. We have to\n+     tell final_scan_insn () if it should be reinserted. When CODE is\n+     GT or LE, we have to check the CC_NO_OVERFLOW bit and return\n+     NULL_PTR to tell final to reinsert the test insn because the\n+     conditional move cannot be handled properly without it. */\n+  if ((code == GT || code == LE)\n+      && (cc_prev_status.flags & CC_NO_OVERFLOW))\n+    return NULL_PTR;\n+\n+  mode = GET_MODE (operands [0]);\n+  if (mode == DImode)\n+    {\n+      xops [0] = gen_rtx_SUBREG (SImode, operands [0], 1);\n+      xops [1] = operands [1];\n+      xops [2] = gen_rtx_SUBREG (SImode, operands [2], 1);\n+      xops [3] = gen_rtx_SUBREG (SImode, operands [3], 1);\n+    }\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* r <- cond ? arg : r */\n+      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n+      if (mode == DImode)\n+\toutput_asm_insn (AS2 (cmov%C1,%2,%0), xops);\n+      break;\n+\n+    case 1:\n+      /* r <- cond ? r : arg */\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      if (mode == DImode)\n+\toutput_asm_insn (AS2 (cmov%c1,%3,%0), xops);\n+      break;\n+\n+    case 2:\n+      /* rm <- cond ? arg1 : arg2 */\n+      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n+      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n+      if (mode == DImode)\n+\t{\n+\t  output_asm_insn (AS2 (cmov%C1,%2,%0), xops);\n+\t  output_asm_insn (AS2 (cmov%c1,%3,%0), xops);\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return \"\";\n+}"}, {"sha": "b2ee298ca19256ddabc8eb6cc844c434ad90f8fe", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 6, "deletions": 188, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b657fc397ec6985a86ea8ecba5a83da9c3d7e207/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b657fc397ec6985a86ea8ecba5a83da9c3d7e207/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b657fc397ec6985a86ea8ecba5a83da9c3d7e207", "patch": "@@ -7307,35 +7307,7 @@ byte_xor_operation:\n \t\t      (match_operand:SI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n \t\t      (match_operand:SI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n   \"TARGET_CMOVE && reload_completed\"\n-  \"*\n-{\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      break;\n-\n-    case 1:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n-\n-    case 2:\n-      /* r <- cond ? arg1 : arg2 */\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n-\n-    default:\n-      abort();\n-    /* NOTREACHED */\n-      break;\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_int_conditional_move (which_alternative, operands);\")\n \n (define_expand \"movhicc\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n@@ -7410,35 +7382,7 @@ byte_xor_operation:\n \t\t      (match_operand:HI 2 \"nonimmediate_operand\" \"rm,0,rm\")\n \t\t      (match_operand:HI 3 \"nonimmediate_operand\" \"0,rm,rm\")))]\n   \"TARGET_CMOVE && reload_completed\"\n-  \"*\n-{\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      break;\n-\n-    case 1:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n-\n-    case 2:\n-      /* r <- cond ? arg1 : arg2 */\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      break;\n-\n-    default:\n-      abort();\n-    /* NOTREACHED */\n-      break;\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_int_conditional_move (which_alternative, operands);\")\n \n (define_expand \"movsfcc\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -7512,35 +7456,7 @@ byte_xor_operation:\n \t\t      (match_operand:SF 2 \"register_operand\" \"f,0,f\")\n \t\t      (match_operand:SF 3 \"register_operand\" \"0,f,f\")))]\n   \"TARGET_CMOVE && reload_completed\"\n-  \"*\n-{\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      break;\n-\n-    case 1:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-      break;\n-\n-    case 2:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-      break;\n-\n-    default:\n-      abort();\n-    /* NOTREACHED */\n-      break;\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_fp_conditional_move (which_alternative, operands);\")\n \n (define_expand \"movdfcc\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n@@ -7614,35 +7530,7 @@ byte_xor_operation:\n \t\t      (match_operand:DF 2 \"register_operand\" \"f,0,f\")\n \t\t      (match_operand:DF 3 \"register_operand\" \"0,f,f\")))]\n   \"TARGET_CMOVE && reload_completed\"\n-  \"*\n-{\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      break;\n-\n-    case 1:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-      break;\n-\n-    case 2:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-      break;\n-\n-    default:\n-      abort();\n-    /* NOTREACHED */\n-      break;\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_fp_conditional_move (which_alternative, operands);\")\n \n (define_expand \"movxfcc\"\n   [(set (match_operand:XF 0 \"register_operand\" \"\")\n@@ -7716,35 +7604,7 @@ byte_xor_operation:\n \t\t      (match_operand:XF 2 \"register_operand\" \"f,0,f\")\n \t\t      (match_operand:XF 3 \"register_operand\" \"0,f,f\")))]\n   \"TARGET_CMOVE && reload_completed\"\n-  \"*\n-{\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      break;\n-\n-    case 1:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-      break;\n-\n-    case 2:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n-      output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);\n-      break;\n-\n-    default:\n-      abort();\n-    /* NOTREACHED */\n-      break;\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_fp_conditional_move (which_alternative, operands);\")\n \n (define_expand \"movdicc\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -7818,49 +7678,7 @@ byte_xor_operation:\n \t\t      (match_operand:DI 2 \"nonimmediate_operand\" \"ro,0,ro\")\n \t\t      (match_operand:DI 3 \"nonimmediate_operand\" \"0,ro,ro\")))]\n   \"TARGET_CMOVE && reload_completed\"\n-  \"*\n-{\n-  rtx xops[4];\n-\n-  xops[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  xops[1] = operands[1];\n-  xops[2] = REG_P (operands[2])\n-\t\t? gen_rtx_REG (SImode, REGNO (operands[2]) + 1)\n-\t\t: adj_offsettable_operand (operands[2], 4);\n-  xops[3] = REG_P (operands[3])\n-\t\t? gen_rtx_REG (SImode, REGNO (operands[3]) + 1)\n-\t\t: adj_offsettable_operand (operands[3], 4);\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      /* r <- cond ? arg : r */\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), xops);\n-      break;\n-\n-    case 1:\n-      /* r <- cond ? r : arg */\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), xops);\n-      break;\n-\n-    case 2:\n-      /* r <- cond ? arg1 : arg2 */\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), operands);\n-      output_asm_insn (AS2 (cmov%C1,%2,%0), xops);\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), operands);\n-      output_asm_insn (AS2 (cmov%c1,%3,%0), xops);\n-      break;\n-\n-    default:\n-      abort();\n-    /* NOTREACHED */\n-      break;\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_int_conditional_move (which_alternative, operands);\")\n \n (define_insn \"strlensi_unroll\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r,&r\")"}]}