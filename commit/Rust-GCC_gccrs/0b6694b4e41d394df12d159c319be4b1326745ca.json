{"sha": "0b6694b4e41d394df12d159c319be4b1326745ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI2Njk0YjRlNDFkMzk0ZGYxMmQxNTljMzE5YmU0YjEzMjY3NDVjYQ==", "commit": {"author": {"name": "Joffrey Huguet", "email": "huguet@adacore.com", "date": "2019-07-10T09:01:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-10T09:01:28Z"}, "message": "[Ada] Add contracts to Strings libraries\n\nThis patch adds contracts to Ada.Strings libraries, in order to remove\nwarnings when using these libraries in SPARK.\n\n2019-07-10  Joffrey Huguet  <huguet@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-strbou.ads, libgnat/a-strfix.ads,\n\tlibgnat/a-strunb.ads, libgnat/a-strunb__shared.ads: Add global\n\tcontracts, contract cases, preconditions and postconditions to\n\tprocedures and functions.\n\nFrom-SVN: r273334", "tree": {"sha": "b6b1671197753eafa5230593976443fa82782351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6b1671197753eafa5230593976443fa82782351"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b6694b4e41d394df12d159c319be4b1326745ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b6694b4e41d394df12d159c319be4b1326745ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b6694b4e41d394df12d159c319be4b1326745ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b6694b4e41d394df12d159c319be4b1326745ca/comments", "author": {"login": "joffreyhuguet", "id": 36951399, "node_id": "MDQ6VXNlcjM2OTUxMzk5", "avatar_url": "https://avatars.githubusercontent.com/u/36951399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joffreyhuguet", "html_url": "https://github.com/joffreyhuguet", "followers_url": "https://api.github.com/users/joffreyhuguet/followers", "following_url": "https://api.github.com/users/joffreyhuguet/following{/other_user}", "gists_url": "https://api.github.com/users/joffreyhuguet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joffreyhuguet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joffreyhuguet/subscriptions", "organizations_url": "https://api.github.com/users/joffreyhuguet/orgs", "repos_url": "https://api.github.com/users/joffreyhuguet/repos", "events_url": "https://api.github.com/users/joffreyhuguet/events{/privacy}", "received_events_url": "https://api.github.com/users/joffreyhuguet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef8a3d9ef0ace5479d42f7a5382393b5a1a79d96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef8a3d9ef0ace5479d42f7a5382393b5a1a79d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef8a3d9ef0ace5479d42f7a5382393b5a1a79d96"}], "stats": {"total": 1582, "additions": 1328, "deletions": 254}, "files": [{"sha": "9d990336be7833837a94348ccdaac6c0224b5915", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0b6694b4e41d394df12d159c319be4b1326745ca", "patch": "@@ -1,3 +1,10 @@\n+2019-07-10  Joffrey Huguet  <huguet@adacore.com>\n+\n+\t* libgnat/a-strbou.ads, libgnat/a-strfix.ads,\n+\tlibgnat/a-strunb.ads, libgnat/a-strunb__shared.ads: Add global\n+\tcontracts, contract cases, preconditions and postconditions to\n+\tprocedures and functions.\n+\n 2019-07-10  Doug Rupp  <rupp@adacore.com>\n \n \t* sysdep.c (__gnat_is_file_not_found_error): Reformulate to also"}, {"sha": "ae61b869e2154764cdbc1e578929469717979ae7", "filename": "gcc/ada/libgnat/a-strbou.ads", "status": "modified", "additions": 444, "deletions": 77, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strbou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strbou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strbou.ads?ref=0b6694b4e41d394df12d159c319be4b1326745ca", "patch": "@@ -33,6 +33,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Pre => Ignore);\n+\n with Ada.Strings.Maps;\n with Ada.Strings.Superbounded;\n \n@@ -43,7 +49,9 @@ package Ada.Strings.Bounded is\n       Max : Positive;\n       --  Maximum length of a Bounded_String\n \n-   package Generic_Bounded_Length is\n+   package Generic_Bounded_Length with\n+     Initial_Condition => Length (Null_Bounded_String) = 0\n+   is\n \n       Max_Length : constant Positive := Max;\n \n@@ -54,170 +62,311 @@ package Ada.Strings.Bounded is\n \n       subtype Length_Range is Natural range 0 .. Max_Length;\n \n-      function Length (Source : Bounded_String) return Length_Range;\n+      function Length (Source : Bounded_String) return Length_Range with\n+        Global => null;\n \n       --------------------------------------------------------\n       -- Conversion, Concatenation, and Selection Functions --\n       --------------------------------------------------------\n \n       function To_Bounded_String\n         (Source : String;\n-         Drop   : Truncation := Error) return Bounded_String;\n+         Drop   : Truncation := Error) return Bounded_String\n+      with\n+        Pre    => (if Source'Length > Max_Length then Drop /= Error),\n+        Post   =>\n+          Length (To_Bounded_String'Result)\n+        = Natural'Min (Max_Length, Source'Length),\n+        Global => null;\n \n-      function To_String (Source : Bounded_String) return String;\n+      function To_String (Source : Bounded_String) return String with\n+        Post   => To_String'Result'Length = Length (Source),\n+        Global => null;\n \n       procedure Set_Bounded_String\n         (Target : out Bounded_String;\n          Source : String;\n-         Drop   : Truncation := Error);\n+         Drop   : Truncation := Error)\n+      with\n+        Pre    => (if Source'Length > Max_Length then Drop /= Error),\n+        Post   => Length (Target) = Natural'Min (Max_Length, Source'Length),\n+        Global => null;\n       pragma Ada_05 (Set_Bounded_String);\n \n       function Append\n         (Left  : Bounded_String;\n          Right : Bounded_String;\n-         Drop  : Truncation  := Error) return Bounded_String;\n+         Drop  : Truncation  := Error) return Bounded_String\n+      with\n+        Pre    =>\n+          (if Length (Left) > Max_Length - Length (Right)\n+           then Drop /= Error),\n+        Post   =>\n+          Length (Append'Result)\n+        = Natural'Min (Max_Length, Length (Left) + Length (Right)),\n+        Global => null;\n \n       function Append\n         (Left  : Bounded_String;\n          Right : String;\n-         Drop  : Truncation := Error) return Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+      with\n+        Pre    =>\n+          (if Right'Length > Max_Length - Length (Left)\n+           then Drop /= Error),\n+        Post   =>\n+          Length (Append'Result)\n+        = Natural'Min (Max_Length, Length (Left) + Right'Length),\n+        Global => null;\n \n       function Append\n         (Left  : String;\n          Right : Bounded_String;\n-         Drop  : Truncation := Error) return Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+      with\n+        Pre    =>\n+          (if Left'Length > Max_Length - Length (Right)\n+           then Drop /= Error),\n+        Post   =>\n+          Length (Append'Result)\n+        = Natural'Min (Max_Length, Left'Length + Length (Right)),\n+        Global => null;\n \n       function Append\n         (Left  : Bounded_String;\n          Right : Character;\n-         Drop  : Truncation := Error) return Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+      with\n+        Pre    => (if Length (Left) = Max_Length then Drop /= Error),\n+        Post   =>\n+          Length (Append'Result)\n+        = Natural'Min (Max_Length, Length (Left) + 1),\n+        Global => null;\n \n       function Append\n         (Left  : Character;\n          Right : Bounded_String;\n-         Drop  : Truncation := Error) return Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+      with\n+        Pre    => (if Length (Right) = Max_Length then Drop /= Error),\n+        Post   =>\n+          Length (Append'Result)\n+        = Natural'Min (Max_Length, 1 + Length (Right)),\n+        Global => null;\n \n       procedure Append\n         (Source   : in out Bounded_String;\n          New_Item : Bounded_String;\n-         Drop     : Truncation  := Error);\n+         Drop     : Truncation  := Error)\n+      with\n+        Pre    =>\n+          (if Length (Source) > Max_Length - Length (New_Item)\n+           then Drop /= Error),\n+        Post   =>\n+          Length (Source)\n+        = Natural'Min (Max_Length, Length (Source)'Old + Length (New_Item)),\n+        Global => null;\n \n       procedure Append\n         (Source   : in out Bounded_String;\n          New_Item : String;\n-         Drop     : Truncation  := Error);\n+         Drop     : Truncation  := Error)\n+      with\n+        Pre    =>\n+          (if New_Item'Length > Max_Length - Length (Source)\n+           then Drop /= Error),\n+        Post   =>\n+          Length (Source)\n+        = Natural'Min (Max_Length, Length (Source)'Old + New_Item'Length),\n+        Global => null;\n \n       procedure Append\n         (Source   : in out Bounded_String;\n          New_Item : Character;\n-         Drop     : Truncation  := Error);\n+         Drop     : Truncation  := Error)\n+      with\n+        Pre    => (if Length (Source) = Max_Length then Drop /= Error),\n+        Post   =>\n+          Length (Source)\n+        = Natural'Min (Max_Length, Length (Source)'Old + 1),\n+        Global => null;\n \n       function \"&\"\n         (Left  : Bounded_String;\n-         Right : Bounded_String) return Bounded_String;\n+         Right : Bounded_String) return Bounded_String\n+      with\n+        Pre    => Length (Left) <= Max_Length - Length (Right),\n+        Post   => Length (\"&\"'Result) = Length (Left) + Length (Right),\n+        Global => null;\n \n       function \"&\"\n         (Left  : Bounded_String;\n-         Right : String) return Bounded_String;\n+         Right : String) return Bounded_String\n+      with\n+        Pre    => Right'Length <= Max_Length - Length (Left),\n+        Post   => Length (\"&\"'Result) = Length (Left) + Right'Length,\n+        Global => null;\n \n       function \"&\"\n         (Left  : String;\n-         Right : Bounded_String) return Bounded_String;\n+         Right : Bounded_String) return Bounded_String\n+      with\n+        Pre    => Left'Length <= Max_Length - Length (Right),\n+        Post   => Length (\"&\"'Result) = Left'Length + Length (Right),\n+        Global => null;\n \n       function \"&\"\n         (Left  : Bounded_String;\n-         Right : Character) return Bounded_String;\n+         Right : Character) return Bounded_String\n+      with\n+        Pre    => Length (Left) < Max_Length,\n+        Post   => Length (\"&\"'Result) = Length (Left) + 1,\n+        Global => null;\n \n       function \"&\"\n         (Left  : Character;\n-         Right : Bounded_String) return Bounded_String;\n+         Right : Bounded_String) return Bounded_String\n+      with\n+        Pre    => Length (Right) < Max_Length,\n+        Post   => Length (\"&\"'Result) = 1 + Length (Right),\n+        Global => null;\n \n       function Element\n         (Source : Bounded_String;\n-         Index  : Positive) return Character;\n+         Index  : Positive) return Character\n+      with\n+        Pre    => Index <= Length (Source),\n+        Global => null;\n \n       procedure Replace_Element\n         (Source : in out Bounded_String;\n          Index  : Positive;\n-         By     : Character);\n+         By     : Character)\n+      with\n+        Pre    => Index <= Length (Source),\n+        Post   => Length (Source) = Length (Source)'Old,\n+        Global => null;\n \n       function Slice\n         (Source : Bounded_String;\n          Low    : Positive;\n-         High   : Natural) return String;\n+         High   : Natural) return String\n+      with\n+        Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+        Post   => Slice'Result'Length = Natural'Max (0, High - Low + 1),\n+        Global => null;\n \n       function Bounded_Slice\n         (Source : Bounded_String;\n          Low    : Positive;\n-         High   : Natural) return Bounded_String;\n+         High   : Natural) return Bounded_String\n+       with\n+        Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+        Post   =>\n+          Length (Bounded_Slice'Result) = Natural'Max (0, High - Low + 1),\n+        Global => null;\n       pragma Ada_05 (Bounded_Slice);\n \n       procedure Bounded_Slice\n         (Source : Bounded_String;\n          Target : out Bounded_String;\n          Low    : Positive;\n-         High   : Natural);\n+         High   : Natural)\n+      with\n+        Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+        Post   => Length (Target) = Natural'Max (0, High - Low + 1),\n+        Global => null;\n       pragma Ada_05 (Bounded_Slice);\n \n       function \"=\"\n         (Left  : Bounded_String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \"=\"\n         (Left  : Bounded_String;\n-         Right : String) return Boolean;\n+         Right : String) return Boolean\n+      with\n+        Global => null;\n \n       function \"=\"\n         (Left  : String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \"<\"\n         (Left  : Bounded_String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \"<\"\n         (Left  : Bounded_String;\n-         Right : String) return Boolean;\n+         Right : String) return Boolean\n+      with\n+        Global => null;\n \n       function \"<\"\n         (Left  : String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \"<=\"\n         (Left  : Bounded_String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \"<=\"\n         (Left  : Bounded_String;\n-         Right : String) return Boolean;\n+         Right : String) return Boolean\n+      with\n+        Global => null;\n \n       function \"<=\"\n         (Left  : String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \">\"\n         (Left  : Bounded_String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \">\"\n         (Left  : Bounded_String;\n-         Right : String) return Boolean;\n+         Right : String) return Boolean\n+      with\n+        Global => null;\n \n       function \">\"\n         (Left  : String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \">=\"\n         (Left  : Bounded_String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       function \">=\"\n         (Left  : Bounded_String;\n-         Right : String) return Boolean;\n+         Right : String) return Boolean\n+      with\n+        Global => null;\n \n       function \">=\"\n         (Left  : String;\n-         Right : Bounded_String) return Boolean;\n+         Right : Bounded_String) return Boolean\n+      with\n+        Global => null;\n \n       ----------------------\n       -- Search Functions --\n@@ -227,103 +376,156 @@ package Ada.Strings.Bounded is\n         (Source  : Bounded_String;\n          Pattern : String;\n          Going   : Direction := Forward;\n-         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+      with\n+        Pre    => Pattern'Length /= 0,\n+        Global => null;\n \n       function Index\n         (Source  : Bounded_String;\n          Pattern : String;\n          Going   : Direction := Forward;\n-         Mapping : Maps.Character_Mapping_Function) return Natural;\n+         Mapping : Maps.Character_Mapping_Function) return Natural\n+      with\n+        Pre    => Pattern'Length /= 0,\n+        Global => null;\n \n       function Index\n         (Source : Bounded_String;\n          Set    : Maps.Character_Set;\n          Test   : Membership := Inside;\n-         Going  : Direction  := Forward) return Natural;\n+         Going  : Direction  := Forward) return Natural\n+      with\n+        Global => null;\n \n       function Index\n         (Source  : Bounded_String;\n          Pattern : String;\n          From    : Positive;\n          Going   : Direction := Forward;\n-         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+      with\n+        Pre    =>\n+          (if Length (Source) /= 0\n+           then From <= Length (Source))\n+                  and then Pattern'Length /= 0,\n+        Global => null;\n       pragma Ada_05 (Index);\n \n       function Index\n         (Source  : Bounded_String;\n          Pattern : String;\n          From    : Positive;\n          Going   : Direction := Forward;\n-         Mapping : Maps.Character_Mapping_Function) return Natural;\n+         Mapping : Maps.Character_Mapping_Function) return Natural\n+      with\n+        Pre    =>\n+          (if Length (Source) /= 0\n+           then From <= Length (Source))\n+                  and then Pattern'Length /= 0,\n+        Global => null;\n       pragma Ada_05 (Index);\n \n       function Index\n         (Source  : Bounded_String;\n          Set     : Maps.Character_Set;\n          From    : Positive;\n          Test    : Membership := Inside;\n-         Going   : Direction := Forward) return Natural;\n+         Going   : Direction := Forward) return Natural\n+      with\n+        Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+        Global => null;\n       pragma Ada_05 (Index);\n \n       function Index_Non_Blank\n         (Source : Bounded_String;\n-         Going  : Direction := Forward) return Natural;\n+         Going  : Direction := Forward) return Natural\n+      with\n+        Global => null;\n \n       function Index_Non_Blank\n         (Source : Bounded_String;\n          From   : Positive;\n-         Going  : Direction := Forward) return Natural;\n+         Going  : Direction := Forward) return Natural\n+      with\n+        Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+        Global => null;\n       pragma Ada_05 (Index_Non_Blank);\n \n       function Count\n         (Source  : Bounded_String;\n          Pattern : String;\n-         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+         Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+      with\n+        Pre    => Pattern'Length /= 0,\n+        Global => null;\n \n       function Count\n         (Source  : Bounded_String;\n          Pattern : String;\n-         Mapping : Maps.Character_Mapping_Function) return Natural;\n+         Mapping : Maps.Character_Mapping_Function) return Natural\n+      with\n+        Pre    => Pattern'Length /= 0,\n+        Global => null;\n \n       function Count\n         (Source : Bounded_String;\n-         Set    : Maps.Character_Set) return Natural;\n+         Set    : Maps.Character_Set) return Natural\n+      with\n+        Global => null;\n \n       procedure Find_Token\n         (Source : Bounded_String;\n          Set    : Maps.Character_Set;\n          From   : Positive;\n          Test   : Membership;\n          First  : out Positive;\n-         Last   : out Natural);\n+         Last   : out Natural)\n+      with\n+        Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+        Global => null;\n       pragma Ada_2012 (Find_Token);\n \n       procedure Find_Token\n         (Source : Bounded_String;\n          Set    : Maps.Character_Set;\n          Test   : Membership;\n          First  : out Positive;\n-         Last   : out Natural);\n+         Last   : out Natural)\n+      with\n+        Global => null;\n \n       ------------------------------------\n       -- String Translation Subprograms --\n       ------------------------------------\n \n       function Translate\n         (Source  : Bounded_String;\n-         Mapping : Maps.Character_Mapping) return Bounded_String;\n+         Mapping : Maps.Character_Mapping) return Bounded_String\n+      with\n+        Post   => Length (Translate'Result) = Length (Source),\n+        Global => null;\n \n       procedure Translate\n         (Source   : in out Bounded_String;\n-         Mapping  : Maps.Character_Mapping);\n+         Mapping  : Maps.Character_Mapping)\n+      with\n+        Post   => Length (Source) = Length (Source)'Old,\n+        Global => null;\n \n       function Translate\n         (Source  : Bounded_String;\n-         Mapping : Maps.Character_Mapping_Function) return Bounded_String;\n+         Mapping : Maps.Character_Mapping_Function) return Bounded_String\n+      with\n+        Post   => Length (Translate'Result) = Length (Source),\n+        Global => null;\n \n       procedure Translate\n         (Source  : in out Bounded_String;\n-         Mapping : Maps.Character_Mapping_Function);\n+         Mapping : Maps.Character_Mapping_Function)\n+      with\n+        Post   => Length (Source) = Length (Source)'Old,\n+        Global => null;\n \n       ---------------------------------------\n       -- String Transformation Subprograms --\n@@ -334,125 +536,290 @@ package Ada.Strings.Bounded is\n          Low    : Positive;\n          High   : Natural;\n          By     : String;\n-         Drop   : Truncation := Error) return Bounded_String;\n+         Drop   : Truncation := Error) return Bounded_String\n+      with\n+        Pre            =>\n+          Low - 1 <= Length (Source)\n+            and then\n+          (if Drop = Error\n+           then (if High >= Low\n+                 then Low - 1\n+                   <= Max_Length - By'Length\n+                    - Natural'Max (Length (Source) - High, 0)\n+                 else Length (Source) <= Max_Length - By'Length)),\n+        Contract_Cases =>\n+          (High >= Low =>\n+             Length (Replace_Slice'Result)\n+           = Natural'Min\n+             (Max_Length,\n+              Low - 1 + By'Length + Natural'Max (Length (Source) - High,\n+                                                  0)),\n+           others      =>\n+             Length (Replace_Slice'Result)\n+           = Natural'Min (Max_Length, Length (Source) + By'Length)),\n+        Global         => null;\n \n       procedure Replace_Slice\n         (Source   : in out Bounded_String;\n          Low      : Positive;\n          High     : Natural;\n          By       : String;\n-         Drop     : Truncation := Error);\n+         Drop     : Truncation := Error)\n+      with\n+        Pre            =>\n+          Low - 1 <= Length (Source)\n+            and then\n+          (if Drop = Error\n+           then (if High >= Low\n+                 then Low - 1\n+                   <= Max_Length - By'Length\n+                    - Natural'Max (Length (Source) - High, 0)\n+                 else Length (Source) <= Max_Length - By'Length)),\n+        Contract_Cases =>\n+          (High >= Low =>\n+            Length (Source)\n+          = Natural'Min\n+              (Max_Length,\n+               Low - 1 + By'Length + Natural'Max (Length (Source)'Old - High,\n+                                                  0)),\n+           others      =>\n+             Length (Source)\n+           = Natural'Min (Max_Length, Length (Source)'Old + By'Length)),\n+        Global         => null;\n \n       function Insert\n         (Source   : Bounded_String;\n          Before   : Positive;\n          New_Item : String;\n-         Drop     : Truncation := Error) return Bounded_String;\n+         Drop     : Truncation := Error) return Bounded_String\n+      with\n+        Pre    =>\n+          Before - 1 <= Length (Source)\n+            and then (if New_Item'Length > Max_Length - Length (Source)\n+                      then Drop /= Error),\n+        Post   =>\n+          Length (Insert'Result)\n+        = Natural'Min (Max_Length, Length (Source) + New_Item'Length),\n+        Global => null;\n \n       procedure Insert\n         (Source   : in out Bounded_String;\n          Before   : Positive;\n          New_Item : String;\n-         Drop     : Truncation := Error);\n+         Drop     : Truncation := Error)\n+      with\n+        Pre    =>\n+          Before - 1 <= Length (Source)\n+            and then (if New_Item'Length > Max_Length - Length (Source)\n+                      then Drop /= Error),\n+        Post   =>\n+          Length (Source)\n+        = Natural'Min (Max_Length, Length (Source)'Old + New_Item'Length),\n+        Global => null;\n \n       function Overwrite\n         (Source   : Bounded_String;\n          Position : Positive;\n          New_Item : String;\n-         Drop     : Truncation := Error) return Bounded_String;\n+         Drop     : Truncation := Error) return Bounded_String\n+      with\n+        Pre    =>\n+          Position - 1 <= Length (Source)\n+            and then (if New_Item'Length > Max_Length - (Position - 1)\n+                      then Drop /= Error),\n+        Post   =>\n+          Length (Overwrite'Result)\n+        = Natural'Max\n+            (Length (Source),\n+             Natural'Min (Max_Length, Position - 1 + New_Item'Length)),\n+        Global => null;\n \n       procedure Overwrite\n         (Source    : in out Bounded_String;\n          Position  : Positive;\n          New_Item  : String;\n-         Drop      : Truncation := Error);\n+         Drop      : Truncation := Error)\n+      with\n+        Pre    =>\n+          Position - 1 <= Length (Source)\n+            and then (if New_Item'Length > Max_Length - (Position - 1)\n+                      then Drop /= Error),\n+        Post   =>\n+          Length (Source)\n+        = Natural'Max\n+            (Length (Source)'Old,\n+             Natural'Min (Max_Length, Position - 1 + New_Item'Length)),\n+        Global => null;\n \n       function Delete\n         (Source  : Bounded_String;\n          From    : Positive;\n-         Through : Natural) return Bounded_String;\n+         Through : Natural) return Bounded_String\n+      with\n+        Pre            =>\n+          (if Through <= From then From - 1 <= Length (Source)),\n+        Contract_Cases =>\n+          (Through >= From =>\n+             Length (Delete'Result) = Length (Source) - (Through - From + 1),\n+           others          =>\n+             Length (Delete'Result) = Length (Source)),\n+\n+        Global         => null;\n \n       procedure Delete\n         (Source  : in out Bounded_String;\n          From    : Positive;\n-         Through : Natural);\n+         Through : Natural)\n+      with\n+        Pre            =>\n+          (if Through <= From then From - 1 <= Length (Source)),\n+        Contract_Cases =>\n+          (Through >= From =>\n+             Length (Source) = Length (Source)'Old - (Through - From + 1),\n+           others          =>\n+             Length (Source) = Length (Source)'Old),\n+        Global         => null;\n \n       ---------------------------------\n       -- String Selector Subprograms --\n       ---------------------------------\n \n       function Trim\n         (Source : Bounded_String;\n-         Side   : Trim_End) return Bounded_String;\n+         Side   : Trim_End) return Bounded_String\n+      with\n+        Post   => Length (Trim'Result) <= Length (Source),\n+        Global => null;\n \n       procedure Trim\n         (Source : in out Bounded_String;\n-         Side   : Trim_End);\n+         Side   : Trim_End)\n+      with\n+        Post   => Length (Source) <= Length (Source)'Old,\n+        Global => null;\n \n       function Trim\n         (Source : Bounded_String;\n          Left   : Maps.Character_Set;\n-         Right  : Maps.Character_Set) return Bounded_String;\n+         Right  : Maps.Character_Set) return Bounded_String\n+      with\n+        Post   => Length (Trim'Result) <= Length (Source),\n+        Global => null;\n \n       procedure Trim\n         (Source : in out Bounded_String;\n          Left   : Maps.Character_Set;\n-         Right  : Maps.Character_Set);\n+         Right  : Maps.Character_Set)\n+      with\n+        Post   => Length (Source) <= Length (Source)'Old,\n+        Global => null;\n \n       function Head\n         (Source : Bounded_String;\n          Count  : Natural;\n          Pad    : Character := Space;\n-         Drop   : Truncation := Error) return Bounded_String;\n+         Drop   : Truncation := Error) return Bounded_String\n+      with\n+        Pre    => (if Count > Max_Length then Drop /= Error),\n+        Post   => Length (Head'Result) = Natural'Min (Max_Length, Count),\n+        Global => null;\n \n       procedure Head\n         (Source : in out Bounded_String;\n          Count  : Natural;\n          Pad    : Character  := Space;\n-         Drop   : Truncation := Error);\n+         Drop   : Truncation := Error)\n+      with\n+        Pre    => (if Count > Max_Length then Drop /= Error),\n+        Post   => Length (Source) = Natural'Min (Max_Length, Count),\n+        Global => null;\n \n       function Tail\n         (Source : Bounded_String;\n          Count  : Natural;\n          Pad    : Character  := Space;\n-         Drop   : Truncation := Error) return Bounded_String;\n+         Drop   : Truncation := Error) return Bounded_String\n+      with\n+        Pre    => (if Count > Max_Length then Drop /= Error),\n+        Post   => Length (Tail'Result) = Natural'Min (Max_Length, Count),\n+        Global => null;\n \n       procedure Tail\n         (Source : in out Bounded_String;\n          Count  : Natural;\n          Pad    : Character  := Space;\n-         Drop   : Truncation := Error);\n+         Drop   : Truncation := Error)\n+      with\n+        Pre    => (if Count > Max_Length then Drop /= Error),\n+        Post   => Length (Source) = Natural'Min (Max_Length, Count),\n+        Global => null;\n \n       ------------------------------------\n       -- String Constructor Subprograms --\n       ------------------------------------\n \n       function \"*\"\n         (Left  : Natural;\n-         Right : Character) return Bounded_String;\n+         Right : Character) return Bounded_String\n+      with\n+        Pre    => Left <= Max_Length,\n+        Post   => Length (\"*\"'Result) = Left,\n+        Global => null;\n \n       function \"*\"\n         (Left  : Natural;\n-         Right : String) return Bounded_String;\n+         Right : String) return Bounded_String\n+      with\n+        Pre    => (if Left /= 0 then Right'Length <= Max_Length / Left),\n+        Post   => Length (\"*\"'Result) = Left * Right'Length,\n+        Global => null;\n \n       function \"*\"\n         (Left  : Natural;\n-         Right : Bounded_String) return Bounded_String;\n+         Right : Bounded_String) return Bounded_String\n+      with\n+        Pre    => (if Left /= 0 then Length (Right) <= Max_Length / Left),\n+        Post   => Length (\"*\"'Result) = Left * Length (Right),\n+        Global => null;\n \n       function Replicate\n         (Count : Natural;\n          Item  : Character;\n-         Drop  : Truncation := Error) return Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+      with\n+        Pre    => (if Count > Max_Length then Drop /= Error),\n+        Post   =>\n+          Length (Replicate'Result)\n+        = Natural'Min (Max_Length, Count),\n+        Global => null;\n \n       function Replicate\n         (Count : Natural;\n          Item  : String;\n-         Drop  : Truncation := Error) return Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+      with\n+        Pre    =>\n+          (if Item'Length /= 0\n+             and then Count > Max_Length / Item'Length\n+           then Drop /= Error),\n+        Post   =>\n+          Length (Replicate'Result)\n+        = Natural'Min (Max_Length, Count * Item'Length),\n+        Global => null;\n \n       function Replicate\n         (Count : Natural;\n          Item  : Bounded_String;\n-         Drop  : Truncation := Error) return Bounded_String;\n+         Drop  : Truncation := Error) return Bounded_String\n+      with\n+        Pre    =>\n+          (if Length (Item) /= 0\n+             and then Count > Max_Length / Length (Item)\n+           then Drop /= Error),\n+        Post   =>\n+          Length (Replicate'Result)\n+        = Natural'Min (Max_Length, Count * Length (Item)),\n+        Global => null;\n \n    private\n       --  Most of the implementation is in the separate non generic package"}, {"sha": "7d6e121c5349197ffdbc1f6c0f89942487cd6d4c", "filename": "gcc/ada/libgnat/a-strfix.ads", "status": "modified", "additions": 209, "deletions": 37, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strfix.ads?ref=0b6694b4e41d394df12d159c319be4b1326745ca", "patch": "@@ -13,6 +13,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Pre => Ignore);\n+\n with Ada.Strings.Maps;\n \n --  The language-defined package Strings.Fixed provides string-handling\n@@ -34,7 +40,7 @@ with Ada.Strings.Maps;\n --  these effects. Similar control is provided by the string transformation\n --  procedures.\n \n-package Ada.Strings.Fixed is\n+package Ada.Strings.Fixed with SPARK_Mode is\n    pragma Preelaborate;\n \n    --------------------------------------------------------------\n@@ -46,7 +52,12 @@ package Ada.Strings.Fixed is\n       Target  : out String;\n       Drop    : Truncation := Error;\n       Justify : Alignment  := Left;\n-      Pad     : Character  := Space);\n+      Pad     : Character  := Space)\n+   with\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  The Move procedure copies characters from Source to Target. If Source\n    --  has the same length as Target, then the effect is to assign Source to\n    --  Target. If Source is shorter than Target then:\n@@ -95,15 +106,25 @@ package Ada.Strings.Fixed is\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    =>\n+       Pattern'Length /= 0\n+         and then (if Source'Length /= 0 then From in Source'Range),\n+     Global => null;\n    pragma Ada_05 (Index);\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    =>\n+       Pattern'Length /= 0\n+         and then (if Source'Length /= 0 then From in Source'Range),\n+     Global => null;\n    pragma Ada_05 (Index);\n \n    --  Each Index function searches, starting from From, for a slice of\n@@ -123,13 +144,19 @@ package Ada.Strings.Fixed is\n      (Source  : String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => Pattern'Length > 0,\n+     Global => null;\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    --  If Going = Forward, returns:\n    --\n@@ -143,14 +170,19 @@ package Ada.Strings.Fixed is\n      (Source : String;\n       Set    : Maps.Character_Set;\n       Test   : Membership := Inside;\n-      Going  : Direction  := Forward) return Natural;\n+      Going  : Direction  := Forward) return Natural\n+   with\n+     Global => null;\n \n    function Index\n      (Source  : String;\n       Set     : Maps.Character_Set;\n       From    : Positive;\n       Test    : Membership := Inside;\n-      Going   : Direction := Forward) return Natural;\n+      Going   : Direction := Forward) return Natural\n+   with\n+     Pre    => (if Source'Length /= 0 then From in Source'Range),\n+     Global => null;\n    pragma Ada_05 (Index);\n    --  Index searches for the first or last occurrence of any of a set of\n    --  characters (when Test=Inside), or any of the complement of a set of\n@@ -164,32 +196,45 @@ package Ada.Strings.Fixed is\n    function Index_Non_Blank\n      (Source : String;\n       From   : Positive;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Pre   => (if Source'Length /= 0 then From in Source'Range),\n+     Global => null;\n    pragma Ada_05 (Index_Non_Blank);\n    --  Returns Index (Source, Maps.To_Set(Space), From, Outside, Going)\n \n    function Index_Non_Blank\n      (Source : String;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Global => null;\n    --  Returns Index (Source, Maps.To_Set(Space), Outside, Going)\n \n    function Count\n      (Source  : String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Count\n      (Source  : String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    --  Returns the maximum number of nonoverlapping slices of Source that match\n    --  Pattern with respect to Mapping. If Pattern is the null string then\n    --  Pattern_Error is propagated.\n \n    function Count\n      (Source : String;\n-      Set    : Maps.Character_Set) return Natural;\n+      Set    : Maps.Character_Set) return Natural\n+   with\n+     Global => null;\n    --  Returns the number of occurrences in Source of characters that are in\n    --  Set.\n \n@@ -199,7 +244,10 @@ package Ada.Strings.Fixed is\n       From   : Positive;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Pre    => (if Source'Length /= 0 then From in Source'Range),\n+     Global => null;\n    pragma Ada_2012 (Find_Token);\n    --  If Source is not the null string and From is not in Source'Range, then\n    --  Index_Error is raised. Otherwise, First is set to the index of the first\n@@ -214,7 +262,9 @@ package Ada.Strings.Fixed is\n       Set    : Maps.Character_Set;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Global => null;\n    --  Equivalent to Find_Token (Source, Set, Source'First, Test, First, Last)\n \n    ------------------------------------\n@@ -223,23 +273,33 @@ package Ada.Strings.Fixed is\n \n    function Translate\n      (Source  : String;\n-      Mapping : Maps.Character_Mapping_Function) return String;\n+      Mapping : Maps.Character_Mapping_Function) return String\n+   with\n+     Post   => Translate'Result'Length = Source'Length,\n+     Global => null;\n \n    function Translate\n      (Source  : String;\n-      Mapping : Maps.Character_Mapping) return String;\n+      Mapping : Maps.Character_Mapping) return String\n+   with\n+     Post   => Translate'Result'Length = Source'Length,\n+     Global => null;\n \n    --  Returns the string S whose length is Source'Length and such that S (I)\n    --  is the character to which Mapping maps the corresponding element of\n    --  Source, for I in 1 .. Source'Length.\n \n    procedure Translate\n      (Source  : in out String;\n-      Mapping : Maps.Character_Mapping_Function);\n+      Mapping : Maps.Character_Mapping_Function)\n+   with\n+     Global => null;\n \n    procedure Translate\n      (Source  : in out String;\n-      Mapping : Maps.Character_Mapping);\n+      Mapping : Maps.Character_Mapping)\n+   with\n+     Global => null;\n \n    --  Equivalent to Source := Translate(Source, Mapping)\n \n@@ -254,7 +314,15 @@ package Ada.Strings.Fixed is\n       By      : String;\n       Drop    : Truncation := Error;\n       Justify : Alignment  := Left;\n-      Pad     : Character  := Space);\n+      Pad     : Character  := Space)\n+   with\n+     Pre    =>\n+\n+       --  Incomplete contract\n+\n+       Low - 1 <= Source'Last\n+         and then High >= Source'First - 1,\n+     Global => null;\n    --  If Low > Source'Last+1, or High < Source'First - 1, then Index_Error is\n    --  propagated. Otherwise:\n    --\n@@ -269,7 +337,25 @@ package Ada.Strings.Fixed is\n      (Source : String;\n       Low    : Positive;\n       High   : Natural;\n-      By     : String) return String;\n+      By     : String) return String\n+   with\n+     Pre            =>\n+       Low - 1 <= Source'Last\n+         and then High >= Source'First - 1\n+         and then (if High >= Low\n+                   then Natural'Max (0, Low - Source'First)\n+                     <= Natural'Last - By'Length\n+                      - Natural'Max (Source'Last - High, 0)\n+                   else Source'Length <= Natural'Last - By'Length),\n+     Contract_Cases =>\n+       (High >= Low =>\n+          Replace_Slice'Result'Length\n+        = Natural'Max (0, Low - Source'First)\n+        + By'Length\n+        + Natural'Max (Source'Last - High, 0),\n+        others      =>\n+          Replace_Slice'Result'Length = Source'Length + By'Length),\n+     Global         => null;\n    --  Equivalent to:\n    --\n    --    Move (Replace_Slice (Source, Low, High, By),\n@@ -278,7 +364,13 @@ package Ada.Strings.Fixed is\n    function Insert\n      (Source   : String;\n       Before   : Positive;\n-      New_Item : String) return String;\n+      New_Item : String) return String\n+   with\n+     Pre    =>\n+       Before - 1 in Source'First - 1 .. Source'Last\n+         and then Source'Length <= Natural'Last - New_Item'Length,\n+     Post   => Insert'Result'Length = Source'Length + New_Item'Length,\n+     Global => null;\n    --  Propagates Index_Error if Before is not in\n    --  Source'First .. Source'Last+1; otherwise, returns\n    --  Source (Source'First .. Before - 1)\n@@ -288,13 +380,30 @@ package Ada.Strings.Fixed is\n      (Source   : in out String;\n       Before   : Positive;\n       New_Item : String;\n-      Drop     : Truncation := Error);\n+      Drop     : Truncation := Error)\n+   with\n+     Pre    => Before - 1 in Source'First - 1 .. Source'Last,\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to Move (Insert (Source, Before, New_Item), Source, Drop)\n \n    function Overwrite\n      (Source   : String;\n       Position : Positive;\n-      New_Item : String) return String;\n+      New_Item : String) return String\n+   with\n+     Pre    =>\n+       Position - 1 in Source'First - 1 .. Source'Last\n+         and then\n+       (if Position - Source'First >= Source'Length - New_Item'Length\n+        then Position - Source'First <= Natural'Last - New_Item'Length),\n+     Post   =>\n+       Overwrite'Result'Length\n+     = Integer'Max (Source'Length,\n+                    Position - Source'First + New_Item'Length),\n+     Global => null;\n    --  Propagates Index_Error if Position is not in\n    --  Source'First .. Source'Last + 1; otherwise, returns the string obtained\n    --  from Source by consecutively replacing characters starting at Position\n@@ -306,13 +415,29 @@ package Ada.Strings.Fixed is\n      (Source   : in out String;\n       Position : Positive;\n       New_Item : String;\n-      Drop     : Truncation := Right);\n+      Drop     : Truncation := Right)\n+   with\n+     Pre    => Position - 1 in Source'First - 1 .. Source'Last,\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to Move(Overwrite(Source, Position, New_Item), Source, Drop)\n \n    function Delete\n      (Source  : String;\n       From    : Positive;\n-      Through : Natural) return String;\n+      Through : Natural) return String\n+   with\n+     Pre    => (if From <= Through\n+                then (From in Source'Range\n+                        and then Through <= Source'Last)),\n+     Post   =>\n+       Delete'Result'Length\n+     = Source'Length - (if From <= Through\n+                        then Through - From + 1\n+                        else 0),\n+     Global => null;\n    --  If From <= Through, the returned string is\n    --  Replace_Slice(Source, From, Through, \"\"); otherwise, it is Source with\n    --  lower bound 1.\n@@ -322,7 +447,15 @@ package Ada.Strings.Fixed is\n       From    : Positive;\n       Through : Natural;\n       Justify : Alignment := Left;\n-      Pad     : Character := Space);\n+      Pad     : Character := Space)\n+   with\n+     Pre    => (if From <= Through\n+                then (From in Source'Range\n+                        and then Through <= Source'Last)),\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to:\n    --\n    --     Move (Delete (Source, From, Through),\n@@ -334,7 +467,10 @@ package Ada.Strings.Fixed is\n \n    function Trim\n      (Source : String;\n-      Side   : Trim_End) return String;\n+      Side   : Trim_End) return String\n+   with\n+     Post   => Trim'Result'Length <= Source'Length,\n+     Global => null;\n    --  Returns the string obtained by removing from Source all leading Space\n    --  characters (if Side = Left), all trailing Space characters (if\n    --  Side = Right), or all leading and trailing Space characters (if\n@@ -344,15 +480,23 @@ package Ada.Strings.Fixed is\n      (Source  : in out String;\n       Side    : Trim_End;\n       Justify : Alignment := Left;\n-      Pad     : Character := Space);\n+      Pad     : Character := Space)\n+   with\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to:\n    --\n    --     Move (Trim (Source, Side), Source, Justify=>Justify, Pad=>Pad).\n \n    function Trim\n      (Source : String;\n       Left   : Maps.Character_Set;\n-      Right  : Maps.Character_Set) return String;\n+      Right  : Maps.Character_Set) return String\n+   with\n+     Post   => Trim'Result'Length <= Source'Length,\n+     Global => null;\n    --  Returns the string obtained by removing from Source all leading\n    --  characters in Left and all trailing characters in Right.\n \n@@ -361,7 +505,12 @@ package Ada.Strings.Fixed is\n       Left    : Maps.Character_Set;\n       Right   : Maps.Character_Set;\n       Justify : Alignment := Strings.Left;\n-      Pad     : Character := Space);\n+      Pad     : Character := Space)\n+   with\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to:\n    --\n    --     Move (Trim (Source, Left, Right),\n@@ -370,7 +519,10 @@ package Ada.Strings.Fixed is\n    function Head\n      (Source : String;\n       Count  : Natural;\n-      Pad    : Character := Space) return String;\n+      Pad    : Character := Space) return String\n+   with\n+     Post   => Head'Result'Length = Count,\n+     Global => null;\n    --  Returns a string of length Count. If Count <= Source'Length, the string\n    --  comprises the first Count characters of Source. Otherwise, its contents\n    --  are Source concatenated with Count - Source'Length Pad characters.\n@@ -379,7 +531,12 @@ package Ada.Strings.Fixed is\n      (Source  : in out String;\n       Count   : Natural;\n       Justify : Alignment := Left;\n-      Pad     : Character := Space);\n+      Pad     : Character := Space)\n+   with\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to:\n    --\n    --     Move (Head (Source, Count, Pad),\n@@ -388,7 +545,10 @@ package Ada.Strings.Fixed is\n    function Tail\n      (Source : String;\n       Count  : Natural;\n-      Pad    : Character := Space) return String;\n+      Pad    : Character := Space) return String\n+   with\n+     Post   => Tail'Result'Length = Count,\n+     Global => null;\n    --  Returns a string of length Count. If Count <= Source'Length, the string\n    --  comprises the last Count characters of Source. Otherwise, its contents\n    --  are Count-Source'Length Pad characters concatenated with Source.\n@@ -397,7 +557,12 @@ package Ada.Strings.Fixed is\n      (Source  : in out String;\n       Count   : Natural;\n       Justify : Alignment := Left;\n-      Pad     : Character := Space);\n+      Pad     : Character := Space)\n+   with\n+\n+     --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to:\n    --\n    --     Move (Tail (Source, Count, Pad),\n@@ -409,11 +574,18 @@ package Ada.Strings.Fixed is\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : Character) return String;\n+      Right : Character) return String\n+   with\n+     Post   => \"*\"'Result'Length = Left,\n+     Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : String) return String;\n+      Right : String) return String\n+   with\n+     Pre    => (if Right'Length /= 0 then Left <= Natural'Last / Right'Length),\n+     Post   => \"*\"'Result'Length = Left * Right'Length,\n+     Global => null;\n \n    --  These functions replicate a character or string a specified number of\n    --  times. The first function returns a string whose length is Left and each"}, {"sha": "e875b5b90c8de64fd9d0d69f13e25901bdf69e58", "filename": "gcc/ada/libgnat/a-strunb.ads", "status": "modified", "additions": 333, "deletions": 70, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strunb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strunb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strunb.ads?ref=0b6694b4e41d394df12d159c319be4b1326745ca", "patch": "@@ -33,6 +33,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Pre => Ignore);\n+\n with Ada.Strings.Maps;\n with Ada.Finalization;\n \n@@ -45,7 +51,9 @@ with Ada.Finalization;\n --  length. Since the Unbounded_String type is private, relevant constructor\n --  and selector operations are provided.\n \n-package Ada.Strings.Unbounded is\n+package Ada.Strings.Unbounded with\n+  Initial_Condition => Length (Null_Unbounded_String) = 0\n+is\n    pragma Preelaborate;\n \n    type Unbounded_String is private;\n@@ -56,7 +64,8 @@ package Ada.Strings.Unbounded is\n    --  otherwise initialized, it will be initialized to the same value as\n    --  Null_Unbounded_String.\n \n-   function Length (Source : Unbounded_String) return Natural;\n+   function Length (Source : Unbounded_String) return Natural with\n+     Global => null;\n    --  Returns the length of the String represented by Source\n \n    type String_Access is access all String;\n@@ -71,15 +80,25 @@ package Ada.Strings.Unbounded is\n    --------------------------------------------------------\n \n    function To_Unbounded_String\n-     (Source : String)  return Unbounded_String;\n+     (Source : String) return Unbounded_String\n+   with\n+     Post   => Length (To_Unbounded_String'Result) = Source'Length,\n+     Global => null;\n    --  Returns an Unbounded_String that represents Source\n \n    function To_Unbounded_String\n-     (Length : Natural) return Unbounded_String;\n+     (Length : Natural) return Unbounded_String\n+   with\n+     Post   =>\n+       Ada.Strings.Unbounded.Length (To_Unbounded_String'Result)\n+     = Length,\n+     Global => null;\n    --  Returns an Unbounded_String that represents an uninitialized String\n    --  whose length is Length.\n \n-   function To_String (Source : Unbounded_String) return String;\n+   function To_String (Source : Unbounded_String) return String with\n+     Post   => To_String'Result'Length = Length (Source),\n+     Global => null;\n    --  Returns the String with lower bound 1 represented by Source\n \n    --  To_String and To_Unbounded_String are related as follows:\n@@ -91,45 +110,79 @@ package Ada.Strings.Unbounded is\n \n    procedure Set_Unbounded_String\n      (Target : out Unbounded_String;\n-      Source : String);\n+      Source : String)\n+   with\n+     Global => null;\n    pragma Ada_05 (Set_Unbounded_String);\n    --  Sets Target to an Unbounded_String that represents Source\n \n    procedure Append\n      (Source   : in out Unbounded_String;\n-      New_Item : Unbounded_String);\n+      New_Item : Unbounded_String)\n+   with\n+     Pre    => Length (New_Item) <= Natural'Last - Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old + Length (New_Item),\n+     Global => null;\n \n    procedure Append\n      (Source   : in out Unbounded_String;\n-      New_Item : String);\n+      New_Item : String)\n+   with\n+     Pre    => New_Item'Length <= Natural'Last - Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old + New_Item'Length,\n+     Global => null;\n \n    procedure Append\n      (Source   : in out Unbounded_String;\n-      New_Item : Character);\n+      New_Item : Character)\n+   with\n+     Pre    => Length (Source) < Natural'Last,\n+     Post   => Length (Source) = Length (Source)'Old + 1,\n+     Global => null;\n \n    --  For each of the Append procedures, the resulting string represented by\n    --  the Source parameter is given by the concatenation of the original value\n    --  of Source and the value of New_Item.\n \n    function \"&\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => Length (Right) <= Natural'Last - Length (Left),\n+     Post   => Length (\"&\"'Result) = Length (Left) + Length (Right),\n+     Global => null;\n \n    function \"&\"\n      (Left  : Unbounded_String;\n-      Right : String) return Unbounded_String;\n+      Right : String) return Unbounded_String\n+   with\n+     Pre    => Right'Length <= Natural'Last - Length (Left),\n+     Post   => Length (\"&\"'Result) = Length (Left) + Right'Length,\n+     Global => null;\n \n    function \"&\"\n      (Left  : String;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => Left'Length <= Natural'Last - Length (Right),\n+     Post   => Length (\"&\"'Result) = Left'Length + Length (Right),\n+     Global => null;\n \n    function \"&\"\n      (Left  : Unbounded_String;\n-      Right : Character) return Unbounded_String;\n+      Right : Character) return Unbounded_String\n+   with\n+     Pre    => Length (Left) < Natural'Last,\n+     Post   => Length (\"&\"'Result) = Length (Left) + 1,\n+     Global => null;\n \n    function \"&\"\n      (Left  : Character;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => Length (Right) < Natural'Last,\n+     Post   => Length (\"&\"'Result) = Length (Right) + 1,\n+     Global => null;\n \n    --  Each of the \"&\" functions returns an Unbounded_String obtained by\n    --  concatenating the string or character given or represented by one of the\n@@ -139,22 +192,33 @@ package Ada.Strings.Unbounded is\n \n    function Element\n      (Source : Unbounded_String;\n-      Index  : Positive) return Character;\n+      Index  : Positive) return Character\n+   with\n+     Pre    => Index <= Length (Source),\n+     Global => null;\n    --  Returns the character at position Index in the string represented by\n    --  Source; propagates Index_Error if Index > Length (Source).\n \n    procedure Replace_Element\n      (Source : in out Unbounded_String;\n       Index  : Positive;\n-      By     : Character);\n+      By     : Character)\n+   with\n+     Pre    => Index <= Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old,\n+     Global => null;\n    --  Updates Source such that the character at position Index in the string\n    --  represented by Source is By; propagates Index_Error if\n    --  Index > Length (Source).\n \n    function Slice\n      (Source : Unbounded_String;\n       Low    : Positive;\n-      High   : Natural) return String;\n+      High   : Natural) return String\n+   with\n+     Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+     Post   => Slice'Result'Length = Natural'Max (0, High - Low + 1),\n+     Global => null;\n    --  Returns the slice at positions Low through High in the string\n    --  represented by Source; propagates Index_Error if\n    --  Low > Length (Source) + 1 or High > Length (Source). The bounds of the\n@@ -163,7 +227,12 @@ package Ada.Strings.Unbounded is\n    function Unbounded_Slice\n      (Source : Unbounded_String;\n       Low    : Positive;\n-      High   : Natural) return Unbounded_String;\n+      High   : Natural) return Unbounded_String\n+   with\n+     Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+     Post   =>\n+       Length (Unbounded_Slice'Result) = Natural'Max (0, High - Low + 1),\n+     Global => null;\n    pragma Ada_05 (Unbounded_Slice);\n    --  Returns the slice at positions Low through High in the string\n    --  represented by Source as an Unbounded_String. This propagates\n@@ -173,71 +242,105 @@ package Ada.Strings.Unbounded is\n      (Source : Unbounded_String;\n       Target : out Unbounded_String;\n       Low    : Positive;\n-      High   : Natural);\n+      High   : Natural)\n+   with\n+     Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+     Post   => Length (Target) = Natural'Max (0, High - Low + 1),\n+     Global => null;\n    pragma Ada_05 (Unbounded_Slice);\n    --  Sets Target to the Unbounded_String representing the slice at positions\n    --  Low through High in the string represented by Source. This propagates\n    --  Index_Error if Low > Length(Source) + 1 or High > Length (Source).\n \n    function \"=\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"=\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \"=\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<=\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<=\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<=\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \">\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">=\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">=\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \">=\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    --  Each of the functions \"=\", \"<\", \">\", \"<=\", and \">=\" returns the same\n    --  result as the corresponding String operation applied to the String\n@@ -251,83 +354,120 @@ package Ada.Strings.Unbounded is\n      (Source  : Unbounded_String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Index\n      (Source  : Unbounded_String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Index\n      (Source : Unbounded_String;\n       Set    : Maps.Character_Set;\n       Test   : Membership := Inside;\n-      Going  : Direction  := Forward) return Natural;\n+      Going  : Direction  := Forward) return Natural\n+   with\n+     Global => null;\n \n    function Index\n      (Source  : Unbounded_String;\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source))\n+               and then Pattern'Length /= 0,\n+     Global => null;\n    pragma Ada_05 (Index);\n \n    function Index\n      (Source  : Unbounded_String;\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source))\n+               and then Pattern'Length /= 0,\n+     Global => null;\n    pragma Ada_05 (Index);\n \n    function Index\n      (Source  : Unbounded_String;\n       Set     : Maps.Character_Set;\n       From    : Positive;\n       Test    : Membership := Inside;\n-      Going   : Direction := Forward) return Natural;\n+      Going   : Direction := Forward) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+     Global => null;\n    pragma Ada_05 (Index);\n \n    function Index_Non_Blank\n      (Source : Unbounded_String;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Global => null;\n \n    function Index_Non_Blank\n      (Source : Unbounded_String;\n       From   : Positive;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+     Global => null;\n    pragma Ada_05 (Index_Non_Blank);\n \n    function Count\n      (Source  : Unbounded_String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Count\n      (Source  : Unbounded_String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Count\n      (Source : Unbounded_String;\n-      Set    : Maps.Character_Set) return Natural;\n+      Set    : Maps.Character_Set) return Natural\n+   with\n+     Global => null;\n \n    procedure Find_Token\n      (Source : Unbounded_String;\n       Set    : Maps.Character_Set;\n       From   : Positive;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+     Global => null;\n    pragma Ada_2012 (Find_Token);\n \n    procedure Find_Token\n      (Source : Unbounded_String;\n       Set    : Maps.Character_Set;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Global => null;\n \n    --  Each of the search subprograms (Index, Index_Non_Blank, Count,\n    --  Find_Token) has the same effect as the corresponding subprogram in\n@@ -340,19 +480,31 @@ package Ada.Strings.Unbounded is\n \n    function Translate\n      (Source  : Unbounded_String;\n-      Mapping : Maps.Character_Mapping) return Unbounded_String;\n+      Mapping : Maps.Character_Mapping) return Unbounded_String\n+   with\n+     Post   => Length (Translate'Result) = Length (Source),\n+     Global => null;\n \n    procedure Translate\n      (Source  : in out Unbounded_String;\n-      Mapping : Maps.Character_Mapping);\n+      Mapping : Maps.Character_Mapping)\n+   with\n+     Post   => Length (Source) = Length (Source)'Old,\n+     Global => null;\n \n    function Translate\n      (Source  : Unbounded_String;\n-      Mapping : Maps.Character_Mapping_Function) return Unbounded_String;\n+      Mapping : Maps.Character_Mapping_Function) return Unbounded_String\n+   with\n+     Post   => Length (Translate'Result) = Length (Source),\n+     Global => null;\n \n    procedure Translate\n      (Source  : in out Unbounded_String;\n-      Mapping : Maps.Character_Mapping_Function);\n+      Mapping : Maps.Character_Mapping_Function)\n+   with\n+     Post   => Length (Source) = Length (Source)'Old,\n+     Global => null;\n \n    --  The Translate function has an analogous effect to the corresponding\n    --  subprogram in Strings.Fixed. The translation is applied to the string\n@@ -367,93 +519,204 @@ package Ada.Strings.Unbounded is\n      (Source : Unbounded_String;\n       Low    : Positive;\n       High   : Natural;\n-      By     : String) return Unbounded_String;\n+      By     : String) return Unbounded_String\n+   with\n+     Pre            =>\n+       Low - 1 <= Length (Source)\n+       and then (if High >= Low\n+                 then Low - 1\n+                   <= Natural'Last - By'Length\n+                    - Natural'Max (Length (Source) - High, 0)\n+                 else Length (Source) <= Natural'Last - By'Length),\n+     Contract_Cases =>\n+       (High >= Low =>\n+          Length (Replace_Slice'Result)\n+        = Low - 1 + By'Length + Natural'Max (Length (Source)'Old - High, 0),\n+        others      =>\n+          Length (Replace_Slice'Result) = Length (Source)'Old + By'Length),\n+     Global         => null;\n \n    procedure Replace_Slice\n      (Source : in out Unbounded_String;\n       Low    : Positive;\n       High   : Natural;\n-      By     : String);\n+      By     : String)\n+   with\n+     Pre            =>\n+       Low - 1 <= Length (Source)\n+       and then (if High >= Low\n+                 then Low - 1\n+                   <= Natural'Last - By'Length\n+                    - Natural'Max (Length (Source) - High, 0)\n+                 else Length (Source) <= Natural'Last - By'Length),\n+     Contract_Cases =>\n+       (High >= Low =>\n+          Length (Source)\n+        = Low - 1 + By'Length + Natural'Max (Length (Source)'Old - High, 0),\n+        others      =>\n+          Length (Source) = Length (Source)'Old + By'Length),\n+     Global         => null;\n \n    function Insert\n      (Source   : Unbounded_String;\n       Before   : Positive;\n-      New_Item : String) return Unbounded_String;\n+      New_Item : String) return Unbounded_String\n+   with\n+     Pre    => Before - 1 <= Length (Source)\n+                 and then New_Item'Length <= Natural'Last - Length (Source),\n+     Post   => Length (Insert'Result) = Length (Source) + New_Item'Length,\n+     Global => null;\n \n    procedure Insert\n      (Source   : in out Unbounded_String;\n       Before   : Positive;\n-      New_Item : String);\n+      New_Item : String)\n+   with\n+     Pre    => Before - 1 <= Length (Source)\n+                 and then New_Item'Length <= Natural'Last - Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old + New_Item'Length,\n+     Global => null;\n \n    function Overwrite\n      (Source   : Unbounded_String;\n       Position : Positive;\n-      New_Item : String) return Unbounded_String;\n+      New_Item : String) return Unbounded_String\n+   with\n+     Pre    => Position - 1 <= Length (Source)\n+                 and then (if New_Item'Length /= 0\n+                           then\n+                           New_Item'Length <= Natural'Last - (Position - 1)),\n+     Post   =>\n+       Length (Overwrite'Result)\n+     = Natural'Max (Length (Source), Position - 1 + New_Item'Length),\n+     Global => null;\n \n    procedure Overwrite\n      (Source   : in out Unbounded_String;\n       Position : Positive;\n-      New_Item : String);\n+      New_Item : String)\n+   with\n+     Pre    => Position - 1 <= Length (Source)\n+                 and then (if New_Item'Length /= 0\n+                           then\n+                           New_Item'Length <= Natural'Last - (Position - 1)),\n+     Post   =>\n+       Length (Source)\n+     = Natural'Max (Length (Source)'Old, Position - 1 + New_Item'Length),\n+\n+     Global => null;\n \n    function Delete\n      (Source  : Unbounded_String;\n       From    : Positive;\n-      Through : Natural) return Unbounded_String;\n+      Through : Natural) return Unbounded_String\n+   with\n+     Pre            => (if Through <= From then From - 1 <= Length (Source)),\n+     Contract_Cases =>\n+       (Through >= From =>\n+          Length (Delete'Result) = Length (Source) - (Through - From + 1),\n+        others          =>\n+          Length (Delete'Result) = Length (Source)),\n+     Global         => null;\n \n    procedure Delete\n      (Source  : in out Unbounded_String;\n       From    : Positive;\n-      Through : Natural);\n+      Through : Natural)\n+   with\n+     Pre            => (if Through <= From then From - 1 <= Length (Source)),\n+     Contract_Cases =>\n+       (Through >= From =>\n+          Length (Source) = Length (Source)'Old - (Through - From + 1),\n+        others          =>\n+          Length (Source) = Length (Source)'Old),\n+     Global         => null;\n \n    function Trim\n      (Source : Unbounded_String;\n-      Side   : Trim_End) return Unbounded_String;\n+      Side   : Trim_End) return Unbounded_String\n+   with\n+     Post   => Length (Trim'Result) <= Length (Source),\n+     Global => null;\n \n    procedure Trim\n      (Source : in out Unbounded_String;\n-      Side   : Trim_End);\n+      Side   : Trim_End)\n+   with\n+     Post   => Length (Source) <= Length (Source)'Old,\n+     Global => null;\n \n    function Trim\n      (Source : Unbounded_String;\n       Left   : Maps.Character_Set;\n-      Right  : Maps.Character_Set) return Unbounded_String;\n+      Right  : Maps.Character_Set) return Unbounded_String\n+   with\n+     Post   => Length (Trim'Result) <= Length (Source),\n+     Global => null;\n \n    procedure Trim\n      (Source : in out Unbounded_String;\n       Left   : Maps.Character_Set;\n-      Right  : Maps.Character_Set);\n+      Right  : Maps.Character_Set)\n+   with\n+     Post   => Length (Source) <= Length (Source)'Old,\n+     Global => null;\n \n    function Head\n      (Source : Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space) return Unbounded_String;\n+      Pad    : Character := Space) return Unbounded_String\n+   with\n+     Post   => Length (Head'Result) = Count,\n+     Global => null;\n \n    procedure Head\n      (Source : in out Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space);\n+      Pad    : Character := Space)\n+   with\n+     Post   => Length (Source) = Count,\n+     Global => null;\n \n    function Tail\n      (Source : Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space) return Unbounded_String;\n+      Pad    : Character := Space) return Unbounded_String\n+   with\n+     Post   => Length (Tail'Result) = Count,\n+     Global => null;\n \n    procedure Tail\n      (Source : in out Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space);\n+      Pad    : Character := Space)\n+   with\n+     Post   => Length (Source) = Count,\n+     Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : Character) return Unbounded_String;\n+      Right : Character) return Unbounded_String\n+   with\n+     Pre    => Left <= Natural'Last,\n+     Post   => Length (\"*\"'Result) = Left,\n+     Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : String) return Unbounded_String;\n+      Right : String) return Unbounded_String\n+   with\n+     Pre    => (if Left /= 0 then Right'Length <= Natural'Last / Left),\n+     Post   => Length (\"*\"'Result) = Left * Right'Length,\n+     Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => (if Left /= 0 then Length (Right) <= Natural'Last / Left),\n+     Post   => Length (\"*\"'Result) = Left * Length (Right),\n+     Global => null;\n \n    --  Each of the transformation functions (Replace_Slice, Insert, Overwrite,\n    --  Delete), selector functions (Trim, Head, Tail), and constructor"}, {"sha": "17acd56e491dbc8045d2e59b5cb9fec595e418a3", "filename": "gcc/ada/libgnat/a-strunb__shared.ads", "status": "modified", "additions": 335, "deletions": 70, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strunb__shared.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b6694b4e41d394df12d159c319be4b1326745ca/gcc%2Fada%2Flibgnat%2Fa-strunb__shared.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strunb__shared.ads?ref=0b6694b4e41d394df12d159c319be4b1326745ca", "patch": "@@ -33,6 +33,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Pre => Ignore);\n+\n --  This package provides an implementation of Ada.Strings.Unbounded that uses\n --  reference counts to implement copy on modification (rather than copy on\n --  assignment). This is significantly more efficient on many targets.\n@@ -73,15 +79,18 @@ with Ada.Strings.Maps;\n private with Ada.Finalization;\n private with System.Atomic_Counters;\n \n-package Ada.Strings.Unbounded is\n+package Ada.Strings.Unbounded with\n+  Initial_Condition => Length (Null_Unbounded_String) = 0\n+is\n    pragma Preelaborate;\n \n    type Unbounded_String is private;\n    pragma Preelaborable_Initialization (Unbounded_String);\n \n    Null_Unbounded_String : constant Unbounded_String;\n \n-   function Length (Source : Unbounded_String) return Natural;\n+   function Length (Source : Unbounded_String) return Natural with\n+     Global => null;\n \n    type String_Access is access all String;\n \n@@ -92,136 +101,229 @@ package Ada.Strings.Unbounded is\n    --------------------------------------------------------\n \n    function To_Unbounded_String\n-     (Source : String)  return Unbounded_String;\n+     (Source : String)  return Unbounded_String\n+   with\n+     Post   => Length (To_Unbounded_String'Result) = Source'Length,\n+     Global => null;\n \n    function To_Unbounded_String\n-     (Length : Natural) return Unbounded_String;\n+     (Length : Natural) return Unbounded_String\n+   with\n+     Post   =>\n+       Ada.Strings.Unbounded.Length (To_Unbounded_String'Result) = Length,\n+     Global => null;\n \n-   function To_String (Source : Unbounded_String) return String;\n+   function To_String (Source : Unbounded_String) return String with\n+     Post   => To_String'Result'Length = Length (Source),\n+     Global => null;\n \n    procedure Set_Unbounded_String\n      (Target : out Unbounded_String;\n-      Source : String);\n+      Source : String)\n+   with\n+     Global => null;\n    pragma Ada_05 (Set_Unbounded_String);\n \n    procedure Append\n      (Source   : in out Unbounded_String;\n-      New_Item : Unbounded_String);\n+      New_Item : Unbounded_String)\n+   with\n+     Pre    => Length (New_Item) <= Natural'Last - Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old + Length (New_Item),\n+     Global => null;\n \n    procedure Append\n      (Source   : in out Unbounded_String;\n-      New_Item : String);\n+      New_Item : String)\n+   with\n+     Pre    => New_Item'Length <= Natural'Last - Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old + New_Item'Length,\n+     Global => null;\n \n    procedure Append\n      (Source   : in out Unbounded_String;\n-      New_Item : Character);\n+      New_Item : Character)\n+   with\n+     Pre    => Length (Source) < Natural'Last,\n+     Post   => Length (Source) = Length (Source)'Old + 1,\n+     Global => null;\n \n    function \"&\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => Length (Right) <= Natural'Last - Length (Left),\n+     Post   => Length (\"&\"'Result) = Length (Left) + Length (Right),\n+     Global => null;\n \n    function \"&\"\n      (Left  : Unbounded_String;\n-      Right : String) return Unbounded_String;\n+      Right : String) return Unbounded_String\n+   with\n+     Pre    => Right'Length <= Natural'Last - Length (Left),\n+     Post   => Length (\"&\"'Result) = Length (Left) + Right'Length,\n+     Global => null;\n \n    function \"&\"\n      (Left  : String;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => Left'Length <= Natural'Last - Length (Right),\n+     Post   => Length (\"&\"'Result) = Left'Length + Length (Right),\n+     Global => null;\n \n    function \"&\"\n      (Left  : Unbounded_String;\n-      Right : Character) return Unbounded_String;\n+      Right : Character) return Unbounded_String\n+   with\n+     Pre    => Length (Left) < Natural'Last,\n+     Post   => Length (\"&\"'Result) = Length (Left) + 1,\n+     Global => null;\n \n    function \"&\"\n      (Left  : Character;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => Length (Right) < Natural'Last,\n+     Post   => Length (\"&\"'Result) = Length (Right) + 1,\n+     Global => null;\n \n    function Element\n      (Source : Unbounded_String;\n-      Index  : Positive) return Character;\n+      Index  : Positive) return Character\n+   with\n+     Pre    => Index <= Length (Source),\n+     Global => null;\n \n    procedure Replace_Element\n      (Source : in out Unbounded_String;\n       Index  : Positive;\n-      By     : Character);\n+      By     : Character)\n+   with\n+     Pre    => Index <= Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old,\n+     Global => null;\n \n    function Slice\n      (Source : Unbounded_String;\n       Low    : Positive;\n-      High   : Natural) return String;\n+      High   : Natural) return String\n+   with\n+     Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+     Post   => Slice'Result'Length = Natural'Max (0, High - Low + 1),\n+     Global => null;\n \n    function Unbounded_Slice\n      (Source : Unbounded_String;\n       Low    : Positive;\n-      High   : Natural) return Unbounded_String;\n+      High   : Natural) return Unbounded_String\n+   with\n+     Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+     Post   =>\n+       Length (Unbounded_Slice'Result) = Natural'Max (0, High - Low + 1),\n+     Global => null;\n    pragma Ada_05 (Unbounded_Slice);\n \n    procedure Unbounded_Slice\n      (Source : Unbounded_String;\n       Target : out Unbounded_String;\n       Low    : Positive;\n-      High   : Natural);\n+      High   : Natural)\n+   with\n+     Pre    => Low - 1 <= Length (Source) and then High <= Length (Source),\n+     Post   => Length (Target) = Natural'Max (0, High - Low + 1),\n+     Global => null;\n    pragma Ada_05 (Unbounded_Slice);\n \n    function \"=\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"=\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \"=\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<=\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<=\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \"<=\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \">\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">=\"\n      (Left  : Unbounded_String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    function \">=\"\n      (Left  : Unbounded_String;\n-      Right : String) return Boolean;\n+      Right : String) return Boolean\n+   with\n+     Global => null;\n \n    function \">=\"\n      (Left  : String;\n-      Right : Unbounded_String) return Boolean;\n+      Right : Unbounded_String) return Boolean\n+   with\n+     Global => null;\n \n    ------------------------\n    -- Search Subprograms --\n@@ -231,103 +333,155 @@ package Ada.Strings.Unbounded is\n      (Source  : Unbounded_String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Index\n      (Source  : Unbounded_String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Index\n      (Source : Unbounded_String;\n       Set    : Maps.Character_Set;\n       Test   : Membership := Inside;\n-      Going  : Direction  := Forward) return Natural;\n+      Going  : Direction  := Forward) return Natural\n+   with\n+     Global => null;\n \n    function Index\n      (Source  : Unbounded_String;\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0\n+                then From <= Length (Source))\n+                       and then Pattern'Length /= 0,\n+     Global => null;\n    pragma Ada_05 (Index);\n \n    function Index\n      (Source  : Unbounded_String;\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0\n+                then From <= Length (Source))\n+                       and then Pattern'Length /= 0,\n+     Global => null;\n+\n    pragma Ada_05 (Index);\n \n    function Index\n      (Source  : Unbounded_String;\n       Set     : Maps.Character_Set;\n       From    : Positive;\n       Test    : Membership := Inside;\n-      Going   : Direction := Forward) return Natural;\n+      Going   : Direction := Forward) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+     Global => null;\n    pragma Ada_05 (Index);\n \n    function Index_Non_Blank\n      (Source : Unbounded_String;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Global => null;\n \n    function Index_Non_Blank\n      (Source : Unbounded_String;\n       From   : Positive;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+     Global => null;\n    pragma Ada_05 (Index_Non_Blank);\n \n    function Count\n      (Source  : Unbounded_String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Count\n      (Source  : Unbounded_String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => Pattern'Length /= 0,\n+     Global => null;\n \n    function Count\n      (Source : Unbounded_String;\n-      Set    : Maps.Character_Set) return Natural;\n+      Set    : Maps.Character_Set) return Natural\n+   with\n+     Global => null;\n \n    procedure Find_Token\n      (Source : Unbounded_String;\n       Set    : Maps.Character_Set;\n       From   : Positive;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Pre    => (if Length (Source) /= 0 then From <= Length (Source)),\n+     Global => null;\n    pragma Ada_2012 (Find_Token);\n \n    procedure Find_Token\n      (Source : Unbounded_String;\n       Set    : Maps.Character_Set;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Global => null;\n \n    ------------------------------------\n    -- String Translation Subprograms --\n    ------------------------------------\n \n    function Translate\n      (Source  : Unbounded_String;\n-      Mapping : Maps.Character_Mapping) return Unbounded_String;\n+      Mapping : Maps.Character_Mapping) return Unbounded_String\n+   with\n+     Post   => Length (Translate'Result) = Length (Source),\n+     Global => null;\n \n    procedure Translate\n      (Source  : in out Unbounded_String;\n-      Mapping : Maps.Character_Mapping);\n+      Mapping : Maps.Character_Mapping)\n+   with\n+     Post   => Length (Source) = Length (Source)'Old,\n+     Global => null;\n \n    function Translate\n      (Source  : Unbounded_String;\n-      Mapping : Maps.Character_Mapping_Function) return Unbounded_String;\n+      Mapping : Maps.Character_Mapping_Function) return Unbounded_String\n+   with\n+     Post   => Length (Translate'Result) = Length (Source),\n+     Global => null;\n \n    procedure Translate\n      (Source  : in out Unbounded_String;\n-      Mapping : Maps.Character_Mapping_Function);\n+      Mapping : Maps.Character_Mapping_Function)\n+   with\n+     Post   => Length (Source) = Length (Source)'Old,\n+     Global => null;\n \n    ---------------------------------------\n    -- String Transformation Subprograms --\n@@ -337,93 +491,204 @@ package Ada.Strings.Unbounded is\n      (Source : Unbounded_String;\n       Low    : Positive;\n       High   : Natural;\n-      By     : String) return Unbounded_String;\n+      By     : String) return Unbounded_String\n+   with\n+     Pre            =>\n+       Low - 1 <= Length (Source)\n+         and then (if High >= Low\n+                   then Low - 1\n+                     <= Natural'Last - By'Length\n+                      - Natural'Max (Length (Source) - High, 0)\n+                   else Length (Source) <= Natural'Last - By'Length),\n+     Contract_Cases =>\n+       (High >= Low =>\n+          Length (Replace_Slice'Result)\n+        = Low - 1 + By'Length + Natural'Max (Length (Source)'Old - High, 0),\n+        others      =>\n+          Length (Replace_Slice'Result) = Length (Source)'Old + By'Length),\n+     Global         => null;\n \n    procedure Replace_Slice\n      (Source : in out Unbounded_String;\n       Low    : Positive;\n       High   : Natural;\n-      By     : String);\n+      By     : String)\n+   with\n+     Pre            =>\n+       Low - 1 <= Length (Source)\n+         and then (if High >= Low\n+                   then Low - 1\n+                     <= Natural'Last - By'Length\n+                      - Natural'Max (Length (Source) - High, 0)\n+                   else Length (Source) <= Natural'Last - By'Length),\n+     Contract_Cases =>\n+       (High >= Low =>\n+          Length (Source)\n+        = Low - 1 + By'Length + Natural'Max (Length (Source)'Old - High, 0),\n+        others      =>\n+          Length (Source) = Length (Source)'Old + By'Length),\n+     Global         => null;\n \n    function Insert\n      (Source   : Unbounded_String;\n       Before   : Positive;\n-      New_Item : String) return Unbounded_String;\n+      New_Item : String) return Unbounded_String\n+   with\n+     Pre    => Before - 1 <= Length (Source)\n+                 and then New_Item'Length <= Natural'Last - Length (Source),\n+     Post   => Length (Insert'Result) = Length (Source) + New_Item'Length,\n+     Global => null;\n \n    procedure Insert\n      (Source   : in out Unbounded_String;\n       Before   : Positive;\n-      New_Item : String);\n+      New_Item : String)\n+   with\n+     Pre    => Before - 1 <= Length (Source)\n+                 and then New_Item'Length <= Natural'Last - Length (Source),\n+     Post   => Length (Source) = Length (Source)'Old + New_Item'Length,\n+     Global => null;\n \n    function Overwrite\n      (Source   : Unbounded_String;\n       Position : Positive;\n-      New_Item : String) return Unbounded_String;\n+      New_Item : String) return Unbounded_String\n+   with\n+     Pre    => Position - 1 <= Length (Source)\n+                 and then (if New_Item'Length /= 0\n+                           then\n+                             New_Item'Length <= Natural'Last - (Position - 1)),\n+     Post   =>\n+       Length (Overwrite'Result)\n+     = Natural'Max (Length (Source), Position - 1 + New_Item'Length),\n+     Global => null;\n \n    procedure Overwrite\n      (Source   : in out Unbounded_String;\n       Position : Positive;\n-      New_Item : String);\n+      New_Item : String)\n+   with\n+     Pre    => Position - 1 <= Length (Source)\n+                 and then (if New_Item'Length /= 0\n+                           then\n+                             New_Item'Length <= Natural'Last - (Position - 1)),\n+     Post   =>\n+       Length (Source)\n+     = Natural'Max (Length (Source)'Old, Position - 1 + New_Item'Length),\n+\n+     Global => null;\n \n    function Delete\n      (Source  : Unbounded_String;\n       From    : Positive;\n-      Through : Natural) return Unbounded_String;\n+      Through : Natural) return Unbounded_String\n+   with\n+     Pre            => (if Through <= From then From - 1 <= Length (Source)),\n+     Contract_Cases =>\n+       (Through >= From =>\n+          Length (Delete'Result) = Length (Source) - (Through - From + 1),\n+        others          =>\n+          Length (Delete'Result) = Length (Source)),\n+     Global         => null;\n \n    procedure Delete\n      (Source  : in out Unbounded_String;\n       From    : Positive;\n-      Through : Natural);\n+      Through : Natural)\n+   with\n+     Pre            => (if Through <= From then From - 1 <= Length (Source)),\n+     Contract_Cases =>\n+       (Through >= From =>\n+          Length (Source) = Length (Source)'Old - (Through - From + 1),\n+        others          =>\n+          Length (Source) = Length (Source)'Old),\n+     Global         => null;\n \n    function Trim\n      (Source : Unbounded_String;\n-      Side   : Trim_End) return Unbounded_String;\n+      Side   : Trim_End) return Unbounded_String\n+   with\n+     Post   => Length (Trim'Result) <= Length (Source),\n+     Global => null;\n \n    procedure Trim\n      (Source : in out Unbounded_String;\n-      Side   : Trim_End);\n+      Side   : Trim_End)\n+   with\n+     Post   => Length (Source) <= Length (Source)'Old,\n+     Global => null;\n \n    function Trim\n      (Source : Unbounded_String;\n       Left   : Maps.Character_Set;\n-      Right  : Maps.Character_Set) return Unbounded_String;\n+      Right  : Maps.Character_Set) return Unbounded_String\n+   with\n+     Post   => Length (Trim'Result) <= Length (Source),\n+     Global => null;\n \n    procedure Trim\n      (Source : in out Unbounded_String;\n       Left   : Maps.Character_Set;\n-      Right  : Maps.Character_Set);\n+      Right  : Maps.Character_Set)\n+   with\n+     Post   => Length (Source) <= Length (Source)'Old,\n+     Global => null;\n \n    function Head\n      (Source : Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space) return Unbounded_String;\n+      Pad    : Character := Space) return Unbounded_String\n+   with\n+     Post   => Length (Head'Result) = Count,\n+     Global => null;\n \n    procedure Head\n      (Source : in out Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space);\n+      Pad    : Character := Space)\n+   with\n+     Post   => Length (Source) = Count,\n+     Global => null;\n \n    function Tail\n      (Source : Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space) return Unbounded_String;\n+      Pad    : Character := Space) return Unbounded_String\n+   with\n+     Post   => Length (Tail'Result) = Count,\n+     Global => null;\n \n    procedure Tail\n      (Source : in out Unbounded_String;\n       Count  : Natural;\n-      Pad    : Character := Space);\n+      Pad    : Character := Space)\n+   with\n+     Post   => Length (Source) = Count,\n+     Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : Character) return Unbounded_String;\n+      Right : Character) return Unbounded_String\n+   with\n+     Pre    => Left <= Natural'Last,\n+     Post   => Length (\"*\"'Result) = Left,\n+     Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : String) return Unbounded_String;\n+      Right : String) return Unbounded_String\n+   with\n+     Pre    => (if Left /= 0 then Right'Length <= Natural'Last / Left),\n+     Post   => Length (\"*\"'Result) = Left * Right'Length,\n+     Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n-      Right : Unbounded_String) return Unbounded_String;\n+      Right : Unbounded_String) return Unbounded_String\n+   with\n+     Pre    => (if Left /= 0 then Length (Right) <= Natural'Last / Left),\n+     Post   => Length (\"*\"'Result) = Left * Length (Right),\n+     Global => null;\n \n private\n    pragma Inline (Length);"}]}