{"sha": "d6479fe772c6ab3191be8268ac658f309675bc28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0NzlmZTc3MmM2YWIzMTkxYmU4MjY4YWM2NThmMzA5Njc1YmMyOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-03-09T23:02:42Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-09T23:02:42Z"}, "message": "cp-tree.h (flag_access_control): Declare.\n\n\t* cp-tree.h (flag_access_control): Declare.\n\t(TREE_VIA_PPUBLIC): Document.\n\t(DECL_NONSTATIC_MEMBER_P): New macro.\n\t(enforce_access): Return an indication of whether or not access\n\twas permitted.\n\t(build_self_reference): Change prototype.\n\t(compute_access): Replace with ...\n\t(accessible_p): New function.\n\t(dfs_walk): Change prototype.\n\t(dfs_unmark): Likewise.\n\t(markedp): Likewise.\n\t* call.c (enforce_access): Use accessible_p.\n\t* class.c (build_self_reference): Insert the declaration into the\n\tlist of members for this type, and make it public.\n\t* decl.c (xref_basetypes): Avoid ill-timed recursion.\n\t* init.c (build_offset_ref): Use lookup_member, not three separate\n\tname-lookups.  Call enforce_access rather than checking for\n\tillegal accesses here.\n\t(resolve_offset_ref): Likewise.\n\t* lex.c (do_identifier): Likewise.\n\t* method.c (hack_identifier): Likewise.\n\t* parse.y (self_reference): Remove.\n\t(opt_component_decl_list): Don't use it.\n\t* parse.c: Regenerated.\n\t* pt.c (print_candidates): Generalize to handle lists of\n\toverloaded functions.\n\t(instantiate_class_template): Don't rely on TREE_VIA_PRIVATE; it's\n\tnot set.\n\t(get_template_base): Use new calling convention for dfs_walk.\n\t* search.c: Include varray.h.  Add prototypes.\n\t(dfs_walk): Accept a data pointer to pass to the work functions.\n\tAll callers changed.  All work functions changed.\n\t(breadth_first_search): Rename to bfs_walk, and make consistent\n\twith dfs_walk.\n\t(dfs_walk_real): New function.\n\t(canonical_binfo): New function.\n\t(context_for_name_lookup): Likewise.\n\t(shared_marked_p): Likewise.\n\t(shared_unmarked_p): Likewise.\n\t(lokup_field_queue_p): Likewise.\n\t(lookup_field_r): Generalize to handle both functions and fields.\n\t(lookup_field): Just call lookup_member.\n\t(lookup_fnfields): Likewise.\n\t(lookup_member): Move body of lookup_field here and generalize.\n\t(dfs_accessible_queue_p): Likewise.\n\t(dfs_accessible_p): Likewise.\n\t(dfs_access_in_type): Likewise.\n\t(access_in_type): Likewise.\n\t(compute_access): Remove, and replace with ...\n\t(accessible_p): New function.\n\t(vbase_types): Remove.\n\t(vbase_decl_ptr_intermediate): Likewise.\n\t(vbase_decl_ptr): Likewise.\n\t(vbase_init_result): Likewise.\n\t(closed_envelopes): Likewise.\n\t(bvtable): Likewise.\n\nFrom-SVN: r25661", "tree": {"sha": "b19fb389204ade44a8b25a95fc03743a45c8d0e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b19fb389204ade44a8b25a95fc03743a45c8d0e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6479fe772c6ab3191be8268ac658f309675bc28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6479fe772c6ab3191be8268ac658f309675bc28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6479fe772c6ab3191be8268ac658f309675bc28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6479fe772c6ab3191be8268ac658f309675bc28/comments", "author": null, "committer": null, "parents": [{"sha": "8f96c7ac27203b9c74a1d244c52ce242b65e8681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f96c7ac27203b9c74a1d244c52ce242b65e8681", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f96c7ac27203b9c74a1d244c52ce242b65e8681"}], "stats": {"total": 8626, "additions": 4342, "deletions": 4284}, "files": [{"sha": "7dcdfeae0526da42cb8106f779db23499ef8abd0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -1,3 +1,62 @@\n+1999-03-09  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (flag_access_control): Declare.\n+\t(TREE_VIA_PPUBLIC): Document.\n+\t(DECL_NONSTATIC_MEMBER_P): New macro.\n+\t(enforce_access): Return an indication of whether or not access\n+\twas permitted.\n+\t(build_self_reference): Change prototype.\n+\t(compute_access): Replace with ...\n+\t(accessible_p): New function.\n+\t(dfs_walk): Change prototype.\n+\t(dfs_unmark): Likewise.\n+\t(markedp): Likewise.\n+\t* call.c (enforce_access): Use accessible_p.\n+\t* class.c (build_self_reference): Insert the declaration into the\n+\tlist of members for this type, and make it public.\n+\t* decl.c (xref_basetypes): Avoid ill-timed recursion.\n+\t* init.c (build_offset_ref): Use lookup_member, not three separate\n+\tname-lookups.  Call enforce_access rather than checking for\n+\tillegal accesses here.\n+\t(resolve_offset_ref): Likewise.\n+\t* lex.c (do_identifier): Likewise.\n+\t* method.c (hack_identifier): Likewise.\n+\t* parse.y (self_reference): Remove.\n+\t(opt_component_decl_list): Don't use it.\n+\t* parse.c: Regenerated.\n+\t* pt.c (print_candidates): Generalize to handle lists of\n+\toverloaded functions.\n+\t(instantiate_class_template): Don't rely on TREE_VIA_PRIVATE; it's\n+\tnot set.\n+\t(get_template_base): Use new calling convention for dfs_walk.\n+\t* search.c: Include varray.h.  Add prototypes.\n+\t(dfs_walk): Accept a data pointer to pass to the work functions. \n+\tAll callers changed.  All work functions changed.\n+\t(breadth_first_search): Rename to bfs_walk, and make consistent\n+\twith dfs_walk.\n+\t(dfs_walk_real): New function.\n+\t(canonical_binfo): New function.\n+\t(context_for_name_lookup): Likewise.\n+\t(shared_marked_p): Likewise.\n+\t(shared_unmarked_p): Likewise.\n+\t(lokup_field_queue_p): Likewise.\n+\t(lookup_field_r): Generalize to handle both functions and fields.\n+\t(lookup_field): Just call lookup_member.\n+\t(lookup_fnfields): Likewise.\n+\t(lookup_member): Move body of lookup_field here and generalize.\n+\t(dfs_accessible_queue_p): Likewise.\n+\t(dfs_accessible_p): Likewise.\n+\t(dfs_access_in_type): Likewise.\n+\t(access_in_type): Likewise.\n+\t(compute_access): Remove, and replace with ...\n+\t(accessible_p): New function.\n+\t(vbase_types): Remove.\n+\t(vbase_decl_ptr_intermediate): Likewise.\n+\t(vbase_decl_ptr): Likewise.\n+\t(vbase_init_result): Likewise.\n+\t(closed_envelopes): Likewise.\n+\t(bvtable): Likewise.\n+\n 1999-03-09  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (add_function_candidate): Check for proper number of args"}, {"sha": "1376303140ad0a08781e38992aa605d31bb4853d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -3029,28 +3029,30 @@ build_op_delete_call (code, addr, size, flags, placement)\n }\n \n /* If the current scope isn't allowed to access DECL along\n-   BASETYPE_PATH, give an error.  */\n+   BASETYPE_PATH, give an error.  The most derived class in\n+   BASETYPE_PATH is the one used to qualify DECL.  */\n \n-void\n+int\n enforce_access (basetype_path, decl)\n-     tree basetype_path, decl;\n+     tree basetype_path;\n+     tree decl;\n {\n-  tree access = compute_access (basetype_path, decl);\n+  int accessible;\n \n-  if (access == access_private_node)\n-    {\n-      cp_error_at (\"`%+#D' is %s\", decl, \n-\t\t   TREE_PRIVATE (decl) ? \"private\"\n-\t\t   : \"from private base class\");\n-      error (\"within this context\");\n-    }\n-  else if (access == access_protected_node)\n+  accessible = accessible_p (basetype_path, decl);\n+  if (!accessible)\n     {\n-      cp_error_at (\"`%+#D' %s\", decl,\n-\t\t   TREE_PROTECTED (decl) ? \"is protected\"\n-\t\t   : \"has protected accessibility\");\n-      error (\"within this context\");\n+      if (TREE_PRIVATE (decl))\n+\tcp_error_at (\"`%+#D' is private\", decl);\n+      else if (TREE_PROTECTED (decl))\n+\tcp_error_at (\"`%+#D' is protected\", decl);\n+      else\n+\tcp_error_at (\"`%+#D' is inaccessible\", decl);\n+      cp_error (\"within this context\");\n+      return 0;\n     }\n+\n+  return 1;\n }\n \n /* Perform the conversions in CONVS on the expression EXPR.  */"}, {"sha": "6d8a4d61e507256c0eed653b4733a2b7eadcea92", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -1440,7 +1440,6 @@ alter_access (t, binfo, fdecl, access)\n   else\n     {\n       enforce_access (binfo, fdecl);\n-\n       DECL_ACCESS (fdecl) = tree_cons (t, access, DECL_ACCESS (fdecl));\n       return 1;\n     }\n@@ -5548,18 +5547,24 @@ maybe_push_cache_obstack ()\n    into  the scope of the class itself.  For purposes of access checking,\n    the inserted class name is treated as if it were a public member name.  */\n \n-tree\n+void\n build_self_reference ()\n {\n   tree name = constructor_name (current_class_type);\n   tree value = build_lang_decl (TYPE_DECL, name, current_class_type);\n+  tree saved_cas;\n+\n   DECL_NONLOCAL (value) = 1;\n   DECL_CONTEXT (value) = current_class_type;\n   DECL_CLASS_CONTEXT (value) = current_class_type;\n   DECL_ARTIFICIAL (value) = 1;\n \n   pushdecl_class_level (value);\n-  return value;\n+\n+  saved_cas = current_access_specifier;\n+  current_access_specifier = access_public_node;\n+  finish_member_declaration (value);\n+  current_access_specifier = saved_cas;\n }\n \n /* Returns 1 if TYPE contains only padding bytes.  */"}, {"sha": "551803bb6add82530eee471dd89e9efe5f2351bf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -549,6 +549,11 @@ extern int flag_vtable_gc;\n /* Nonzero means make the default pedwarns warnings instead of errors.\n    The value of this flag is ignored if -pedantic is specified.  */\n extern int flag_permissive;\n+\n+/* Nonzero if we want to obey access control semantics.  */\n+\n+extern int flag_access_control;\n+\n \f\n /* C++ language-specific tree codes.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n@@ -1086,11 +1091,16 @@ struct lang_type\n    gcc/tree.h.  In particular if D is derived from B then the BINFO\n    for B (in D) will have a BINFO_INHERITANCE_CHAIN pointing to\n    D.  In tree.h, this pointer is described as pointing in other\n-   direction.  \n+   direction.  There is a different BINFO for each path to a virtual\n+   base; BINFOs for virtual bases are not shared.  In addition, shared\n+   versions of each of the virtual class BINFOs are stored in\n+   CLASSTYPE_VBASECLASSES.\n \n-   After a call to get_vbase_types, the vbases are chained together in\n-   depth-first order via TREE_CHAIN.  Other than that, TREE_CHAIN is\n-   unused.  */\n+   We use TREE_VIA_PROTECTED and TREE_VIA_PUBLIC, but private\n+   inheritance is indicated by the absence of the other two flags, not\n+   by TREE_VIAR_PRIVATE, which is unused.\n+\n+   The TREE_CHAIN is for scratch space in search.c.  */\n \n /* Nonzero means marked by DFS or BFS search, including searches\n    by `get_binfo' and `get_base_distance'.  */\n@@ -1299,6 +1309,12 @@ struct lang_decl\n    has `this' as volatile X *const.  */\n #define DECL_VOLATILE_MEMFUNC_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.volatile_memfunc)\n \n+/* Nonzero for a DECL means that this member is a non-static member.  */\n+#define DECL_NONSTATIC_MEMBER_P(NODE) \t\t\\\n+  ((TREE_CODE (NODE) == FUNCTION_DECL \t\t\\\n+    && DECL_NONSTATIC_MEMBER_FUNCTION_P (NODE))\t\\\n+   || TREE_CODE (NODE) == FIELD_DECL)\n+\n /* Nonzero for _DECL means that this member object type\n    is mutable.  */\n #define DECL_MUTABLE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.mutable_flag)\n@@ -2653,7 +2669,7 @@ extern tree build_op_new_call\t\t\tPROTO((enum tree_code, tree, tree, int));\n extern tree build_op_delete_call\t\tPROTO((enum tree_code, tree, tree, int, tree));\n extern int can_convert\t\t\t\tPROTO((tree, tree));\n extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n-extern void enforce_access                      PROTO((tree, tree));\n+extern int enforce_access                       PROTO((tree, tree));\n extern tree convert_default_arg                 PROTO((tree, tree, tree));\n extern tree convert_arg_to_ellipsis             PROTO((tree));\n \n@@ -2680,7 +2696,7 @@ extern tree instantiate_type\t\t\tPROTO((tree, tree, int));\n extern void print_class_statistics\t\tPROTO((void));\n extern void maybe_push_cache_obstack\t\tPROTO((void));\n extern unsigned HOST_WIDE_INT skip_rtti_stuff\tPROTO((tree *));\n-extern tree build_self_reference\t\tPROTO((void));\n+extern void build_self_reference\t\tPROTO((void));\n extern void warn_hidden\t\t\t\tPROTO((tree));\n extern tree get_enclosing_class\t\t\tPROTO((tree));\n int is_base_of_enclosing_class\t\t\tPROTO((tree, tree));\n@@ -3128,7 +3144,7 @@ extern int types_overlap_p\t\t\tPROTO((tree, tree));\n extern tree get_vbase\t\t\t\tPROTO((tree, tree));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n-extern tree compute_access\t\t\tPROTO((tree, tree));\n+extern int accessible_p                         PROTO((tree, tree));\n extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n extern int lookup_fnfields_1                    PROTO((tree, tree));\n@@ -3153,9 +3169,12 @@ extern void reinit_search_statistics\t\tPROTO((void));\n extern tree current_scope\t\t\tPROTO((void));\n extern tree lookup_conversions\t\t\tPROTO((tree));\n extern tree binfo_for_vtable\t\t\tPROTO((tree));\n-extern void dfs_walk                            PROTO((tree, void (*) (tree), int (*) (tree)));\n-extern void dfs_unmark                          PROTO((tree));\n-extern int  markedp                             PROTO((tree));\n+extern tree dfs_walk                            PROTO((tree, \n+\t\t\t\t\t\t       tree (*)(tree, void *),\n+\t\t\t\t\t\t       tree (*) (tree, void *),\n+\t\t\t\t\t\t       void *));\n+extern tree dfs_unmark                          PROTO((tree, void *));\n+extern tree markedp                             PROTO((tree, void *));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PROTO((tree));"}, {"sha": "9a51e651404c0ed5dbee05ed786237e292152d73", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -12383,6 +12383,8 @@ xref_basetypes (code_type_node, name, ref, binfo)\n   /* In the declaration `A : X, Y, ... Z' we mark all the types\n      (A, X, Y, ..., Z) so we can check for duplicates.  */\n   tree binfos;\n+  tree base;\n+\n   int i, len;\n   enum tag_types tag_code = (enum tag_types) TREE_INT_CST_LOW (code_type_node);\n \n@@ -12395,6 +12397,13 @@ xref_basetypes (code_type_node, name, ref, binfo)\n   len = list_length (binfo);\n   push_obstacks (TYPE_OBSTACK (ref), TYPE_OBSTACK (ref));\n \n+  /* First, make sure that any templates in base-classes are\n+     instantiated.  This ensures that if we call ourselves recursively\n+     we do not get confused about which classes are marked and which\n+     are not.  */\n+  for (base = binfo; base; base = TREE_CHAIN (base))\n+    complete_type (TREE_VALUE (base));\n+\n   SET_CLASSTYPE_MARKED (ref);\n   BINFO_BASETYPES (TYPE_BINFO (ref)) = binfos = make_tree_vec (len);\n \n@@ -12433,16 +12442,14 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \n       GNU_xref_hier (name, basetype, via_public, via_virtual, 0);\n \n-#if 1\n       /* This code replaces similar code in layout_basetypes.\n          We put the complete_type first for implicit `typename'.  */\n-      if (TYPE_SIZE (complete_type (basetype)) == NULL_TREE\n+      if (TYPE_SIZE (basetype) == NULL_TREE\n \t  && ! (current_template_parms && uses_template_parms (basetype)))\n \t{\n \t  cp_error (\"base class `%T' has incomplete type\", basetype);\n \t  continue;\n \t}\n-#endif\n       else\n \t{\n \t  if (CLASSTYPE_MARKED (basetype))"}, {"sha": "98f26f59325dca21b83fa870b922b5f97f6da2e6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 40, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -1490,7 +1490,8 @@ tree\n build_offset_ref (type, name)\n      tree type, name;\n {\n-  tree decl, fnfields, fields, t = error_mark_node;\n+  tree decl, t = error_mark_node;\n+  tree member;\n   tree basebinfo = NULL_TREE;\n   tree orig_name = name;\n \n@@ -1558,17 +1559,17 @@ build_offset_ref (type, name)\n \n   decl = maybe_dummy_object (type, &basebinfo);\n \n-  fnfields = lookup_fnfields (basebinfo, name, 1);\n-  fields = lookup_field (basebinfo, name, 0, 0);\n+  member = lookup_member (basebinfo, name, 1, 0);\n \n-  if (fields == error_mark_node || fnfields == error_mark_node)\n+  if (member == error_mark_node)\n     return error_mark_node;\n \n   /* A lot of this logic is now handled in lookup_field and\n      lookup_fnfield.  */\n-  if (fnfields)\n+  if (member && TREE_CODE (member) == TREE_LIST)\n     {\n       /* Go from the TREE_BASELINK to the member function info.  */\n+      tree fnfields = member;\n       t = TREE_VALUE (fnfields);\n \n       if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n@@ -1596,26 +1597,13 @@ build_offset_ref (type, name)\n \n       if (!really_overloaded_fn (t))\n \t{\n-\t  tree access;\n-\n \t  /* Get rid of a potential OVERLOAD around it */\n \t  t = OVL_CURRENT (t);\n \n \t  /* unique functions are handled easily.  */\n \t  basebinfo = TREE_PURPOSE (fnfields);\n-\t  access = compute_access (basebinfo, t);\n-\t  if (access == access_protected_node)\n-\t    {\n-\t      cp_error_at (\"member function `%#D' is protected\", t);\n-\t      error (\"in this context\");\n-\t      return error_mark_node;\n-\t    }\n-\t  if (access == access_private_node)\n-\t    {\n-\t      cp_error_at (\"member function `%#D' is private\", t);\n-\t      error (\"in this context\");\n-\t      return error_mark_node;\n-\t    }\n+\t  if (!enforce_access (basebinfo, t))\n+\t    return error_mark_node;\n \t  mark_used (t);\n \t  if (DECL_STATIC_FUNCTION_P (t))\n \t    return t;\n@@ -1638,14 +1626,7 @@ build_offset_ref (type, name)\n       return t;\n     }\n \n-  /* Now that we know we are looking for a field, see if we\n-     have access to that field.  Lookup_field will give us the\n-     error message.  */\n-\n-  t = lookup_field (basebinfo, name, 1, 0);\n-\n-  if (t == error_mark_node)\n-    return error_mark_node;\n+  t = member;\n \n   if (t == NULL_TREE)\n     {\n@@ -1754,7 +1735,6 @@ resolve_offset_ref (exp)\n       && (base == current_class_ref || is_dummy_object (base)))\n     {\n       tree basetype_path;\n-      tree access;\n       tree expr;\n \n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n@@ -1771,19 +1751,9 @@ resolve_offset_ref (exp)\n \t}\n       /* Kludge: we need to use basetype_path now, because\n \t convert_pointer_to will bash it.  */\n-      access = compute_access (basetype_path, member);\n+      enforce_access (basetype_path, member);\n       addr = convert_pointer_to (basetype, base);\n \n-      /* Issue errors if there was an access violation.  */\n-      if (access != access_public_node)\n-\t{\n-\t  cp_error_at (\"member `%D' is %s\", \n-\t\t       access == access_private_node \n-\t\t       ? \"private\" : \"protected\",\n-\t\t       member);\n-\t  cp_error (\"in this context\");\n-\t} \n-\n       /* Even in the case of illegal access, we form the\n \t COMPONENT_REF; that will allow better error recovery than\n \t just feeding back error_mark_node.  */"}, {"sha": "6d440f424741d9f37facfa3fc47903d0d7584e53", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -3043,14 +3043,9 @@ do_identifier (token, parsing, args)\n   /* TREE_USED is set in `hack_identifier'.  */\n   if (TREE_CODE (id) == CONST_DECL)\n     {\n+      /* Check access.  */\n       if (IDENTIFIER_CLASS_VALUE (token) == id)\n-\t{\n-\t  /* Check access.  */\n-\t  tree access = compute_access (TYPE_BINFO (current_class_type), id);\n-\t  if (access == access_private_node)\n-\t    cp_error (\"enum `%D' is private\", id);\n-\t  /* protected is OK, since it's an enum of `this'.  */\n-\t}\n+\tenforce_access (current_class_type, id);\n       if (!processing_template_decl || DECL_TEMPLATE_PARM_P (id))\n \tid = DECL_INITIAL (id);\n     }"}, {"sha": "c2ac3f4e4514855ce346bf31a74a31acecfbb6e3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -1994,29 +1994,15 @@ hack_identifier (value, name)\n       if (DECL_LANG_SPECIFIC (value)\n \t  && DECL_CLASS_CONTEXT (value) != current_class_type)\n \t{\n-\t  tree path, access;\n+\t  tree path;\n \t  register tree context\n \t    = (TREE_CODE (value) == FUNCTION_DECL && DECL_VIRTUAL_P (value))\n \t      ? DECL_CLASS_CONTEXT (value)\n \t      : DECL_CONTEXT (value);\n \n \t  get_base_distance (context, current_class_type, 0, &path);\n-\t  if (path)\n-\t    {\n-\t      access = compute_access (path, value);\n-\t      if (access != access_public_node)\n-\t\t{\n-\t\t  if (TREE_CODE (value) == VAR_DECL)\n-\t\t    error (\"static member `%s' is %s\",\n-\t\t\t   IDENTIFIER_POINTER (name),\n-\t\t\t   TREE_PRIVATE (value) ? \"private\"\n-\t\t\t\t\t\t: \"from a private base class\");\n-\t\t  else\n-\t\t    error (\"enum `%s' is from private base class\",\n-\t\t\t   IDENTIFIER_POINTER (name));\n-\t\t  return error_mark_node;\n-\t\t}\n-\t    }\n+\t  if (path && !enforce_access (current_class_type, value))\n+\t    return error_mark_node;\n \t}\n     }\n   else if (TREE_CODE (value) == TREE_LIST && TREE_NONLOCAL_FLAG (value))"}, {"sha": "5e9600f55c87549f923e1ebaaab9d64eb36dd3ea", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3138, "deletions": 3192, "changes": 6330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28"}, {"sha": "31b31b18b5a8075902aca623fb58d75bb19f9786", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -2388,16 +2388,8 @@ left_curly:\n                 { $<ttype>0 = begin_class_definition ($<ttype>0); }\n \t;\n \n-self_reference:\n-\t  /* empty */\n-\t\t{\n-\t\t  finish_member_declaration (build_self_reference ());\n-\t\t}\n-\t;\n-\n opt.component_decl_list:\n-\t  self_reference\n-\t| self_reference component_decl_list\n+\t| component_decl_list\n \t| opt.component_decl_list access_specifier component_decl_list\n \t| opt.component_decl_list access_specifier \n \t;"}, {"sha": "4e9c52fc5886a55ae749ce745553bb0ba7fca8f7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -900,7 +900,10 @@ print_candidates (fns)\n \n   for (fn = fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n     {\n-      cp_error_at (\"%s %+#D\", str, TREE_VALUE (fn));\n+      tree f;\n+\n+      for (f = TREE_VALUE (fn); f; f = OVL_NEXT (f))\n+\tcp_error_at (\"%s %+#D\", str, OVL_CURRENT (f));\n       str = \"               \";\n     }\n }\n@@ -4807,7 +4810,7 @@ instantiate_class_template (type)\n \t\taccess = access_public_virtual_node;\n \t      else if (TREE_VIA_PROTECTED (pbase))\n \t\taccess = access_protected_virtual_node;\n-\t      else if (TREE_VIA_PRIVATE (pbase))\n+\t      else \n \t\taccess = access_private_virtual_node;\n \t    }\n \t  else\n@@ -4816,7 +4819,7 @@ instantiate_class_template (type)\n \t\taccess = access_public_node;\n \t      else if (TREE_VIA_PROTECTED (pbase))\n \t\taccess = access_protected_node;\n-\t      else if (TREE_VIA_PRIVATE (pbase))\n+\t      else \n \t\taccess = access_private_node;\n \t    }\n \n@@ -7840,7 +7843,7 @@ get_template_base (tparms, targs, parm, arg)\n \n   /* Since get_template_base_recursive marks the bases classes, we\n      must unmark them here.  */\n-  dfs_walk (arg_binfo, dfs_unmark, markedp);\n+  dfs_walk (arg_binfo, dfs_unmark, markedp, 0);\n \n   return rval;\n }"}, {"sha": "42678f150f7c0259bd4bdf65ae6e200d467152c9", "filename": "gcc/cp/search.c", "status": "modified", "additions": 922, "deletions": 934, "changes": 1856, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n+#include \"varray.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -85,8 +86,8 @@ static int lookup_fnfields_here PROTO((tree, tree));\n static int is_subobject_of_p PROTO((tree, tree));\n static int hides PROTO((tree, tree));\n static tree virtual_context PROTO((tree, tree, tree));\n-static void dfs_check_overlap PROTO((tree));\n-static int dfs_no_overlap_yet PROTO((tree));\n+static tree dfs_check_overlap PROTO((tree, void *));\n+static tree dfs_no_overlap_yet PROTO((tree, void *));\n static void envelope_add_decl PROTO((tree, tree, tree *));\n static int get_base_distance_recursive\n \tPROTO((tree, int, int, int, int *, tree *, tree,\n@@ -96,39 +97,53 @@ static void expand_upcast_fixups\n static void fixup_virtual_upcast_offsets\n \tPROTO((tree, tree, int, int, tree, tree, tree, tree,\n \t       tree *));\n-static int unmarkedp PROTO((tree));\n-static int marked_vtable_pathp PROTO((tree));\n-static int unmarked_vtable_pathp PROTO((tree));\n-static int marked_new_vtablep PROTO((tree));\n-static int unmarked_new_vtablep PROTO((tree));\n-static int dfs_debug_unmarkedp PROTO((tree));\n-static void dfs_debug_mark PROTO((tree));\n-static void dfs_find_vbases PROTO((tree));\n-static void dfs_clear_vbase_slots PROTO((tree));\n-static void dfs_init_vbase_pointers PROTO((tree));\n-static void dfs_get_vbase_types PROTO((tree));\n-static void dfs_pushdecls PROTO((tree));\n-static void dfs_compress_decls PROTO((tree));\n-static void dfs_unuse_fields PROTO((tree));\n+static tree unmarkedp PROTO((tree, void *));\n+static tree marked_vtable_pathp PROTO((tree, void *));\n+static tree unmarked_vtable_pathp PROTO((tree, void *));\n+static tree marked_new_vtablep PROTO((tree, void *));\n+static tree unmarked_new_vtablep PROTO((tree, void *));\n+static tree marked_pushdecls_p PROTO((tree, void *));\n+static tree unmarked_pushdecls_p PROTO((tree, void *));\n+static tree dfs_debug_unmarkedp PROTO((tree, void *));\n+static tree dfs_debug_mark PROTO((tree, void *));\n+static tree dfs_find_vbases PROTO((tree, void *));\n+static tree dfs_clear_vbase_slots PROTO((tree, void *));\n+static tree dfs_init_vbase_pointers PROTO((tree, void *));\n+static tree dfs_get_vbase_types PROTO((tree, void *));\n+static tree dfs_pushdecls PROTO((tree, void *));\n+static tree dfs_compress_decls PROTO((tree, void *));\n+static tree dfs_unuse_fields PROTO((tree, void *));\n static tree add_conversions PROTO((tree, void *));\n-static tree get_virtuals_named_this PROTO((tree));\n+static tree get_virtuals_named_this PROTO((tree, tree));\n static tree get_virtual_destructor PROTO((tree, void *));\n-static int tree_has_any_destructor_p PROTO((tree, void *));\n+static tree tree_has_any_destructor_p PROTO((tree, void *));\n static int covariant_return_p PROTO((tree, tree));\n static struct search_level *push_search_level\n \tPROTO((struct stack_level *, struct obstack *));\n static struct search_level *pop_search_level\n \tPROTO((struct stack_level *));\n-static tree breadth_first_search\n-\tPROTO((tree, tree (*) (tree, void *), int (*) (tree, void *),\n-\t       void (*) (tree *, tree *, void *), void *));\n-static int lookup_field_queue_p PROTO((tree, void *));\n+static tree bfs_walk\n+\tPROTO((tree, tree (*) (tree, void *), tree (*) (tree, void *),\n+\t       void *));\n+static tree lookup_field_queue_p PROTO((tree, void *));\n static tree lookup_field_r PROTO((tree, void *));\n-static void lookup_field_post PROTO((tree *, tree *, void *));\n-\n-static tree vbase_types;\n-static tree vbase_decl_ptr_intermediate, vbase_decl_ptr;\n-static tree vbase_init_result;\n+static tree dfs_walk_real PROTO ((tree, \n+\t\t\t\t  tree (*) (tree, void *),\n+\t\t\t\t  tree (*) (tree, void *),\n+\t\t\t\t  tree (*) (tree, void *),\n+\t\t\t\t  void *));\n+static tree dfs_bfv_queue_p PROTO ((tree, void *));\n+static tree dfs_bfv_helper PROTO ((tree, void *));\n+static tree get_virtuals_named_this_r PROTO ((tree, void *));\n+static tree context_for_name_lookup PROTO ((tree));\n+static tree canonical_binfo PROTO ((tree));\n+static tree shared_marked_p PROTO ((tree, void *));\n+static tree shared_unmarked_p PROTO ((tree, void *));\n+static int  dependent_base_p PROTO ((tree));\n+static tree dfs_accessible_queue_p PROTO ((tree, void *));\n+static tree dfs_accessible_p PROTO ((tree, void *));\n+static tree dfs_access_in_type PROTO ((tree, void *));\n+static tree access_in_type PROTO ((tree, tree));\n \n /* Allocate a level of searching.  */\n \n@@ -166,9 +181,6 @@ static int n_outer_fields_searched;\n static int n_contexts_saved;\n #endif /* GATHER_STATISTICS */\n \n-/* This list is used by push_class_decls to know what decls need to\n-   be pushed into class scope.  */\n-static tree closed_envelopes = NULL_TREE;\n \f\n /* Get a virtual binfo that is found inside BINFO's hierarchy that is\n    the same type as the type given in PARENT.  To be optimal, we want\n@@ -577,214 +589,348 @@ current_scope ()\n   return current_class_type;\n }\n \n-/* Compute the access of FIELD.  This is done by computing\n-   the access available to each type in BASETYPES (which comes\n-   as a list of [via_public/basetype] in reverse order, namely base\n-   class before derived class).  The first one which defines a\n-   access defines the access for the field.  Otherwise, the\n-   access of the field is that which occurs normally.\n+/* Return the scope of DECL, as appropriate when doing name-lookup.  */\n \n-   Uses global variables CURRENT_CLASS_TYPE and\n-   CURRENT_FUNCTION_DECL to use friend relationships\n-   if necessary.\n+static tree\n+context_for_name_lookup (decl)\n+     tree decl;\n+{\n+  /* [class.union]\n+     \n+     For the purposes of name lookup, after the anonymous union\n+     definition, the members of the anonymous union are considered to\n+     have been defined in the scope in which teh anonymous union is\n+     declared.  */ \n+  tree context = DECL_REAL_CONTEXT (decl);\n+\n+  while (TYPE_P (context) && ANON_UNION_TYPE_P (context))\n+    context = TYPE_CONTEXT (context);\n+  if (!context)\n+    context = global_namespace;\n \n-   This will be static when lookup_fnfield comes into this file.\n+  return context;\n+}\n \n-   access_public_node means that the field can be accessed by the current lexical\n-   scope.\n+/* Return a canonical BINFO if BINFO is a virtual base, or just BINFO\n+   otherwise.  */\n \n-   access_protected_node means that the field cannot be accessed by the current\n-   lexical scope because it is protected.\n+static tree\n+canonical_binfo (binfo)\n+     tree binfo;\n+{\n+  return (TREE_VIA_VIRTUAL (binfo)\n+\t  ? TYPE_BINFO (BINFO_TYPE (binfo)) : binfo);\n+}\n \n-   access_private_node means that the field cannot be accessed by the current\n-   lexical scope because it is private.  */\n+/* If BINFO is marked, return a canonical version of BINFO.\n+   Otherwise, return NULL_TREE.  */\n \n-#if 0\n-#define PUBLIC_RETURN return (DECL_PUBLIC (field) = 1), access_public_node\n-#define PROTECTED_RETURN return (DECL_PROTECTED (field) = 1), access_protected_node\n-#define PRIVATE_RETURN return (DECL_PRIVATE (field) = 1), access_private_node\n-#else\n-#define PUBLIC_RETURN return access_public_node\n-#define PROTECTED_RETURN return access_protected_node\n-#define PRIVATE_RETURN return access_private_node\n-#endif\n+static tree\n+shared_marked_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  binfo = canonical_binfo (binfo);\n+  return markedp (binfo, data) ? binfo : NULL_TREE;\n+}\n \n-#if 0\n-/* Disabled with DECL_PUBLIC &c.  */\n-static tree previous_scope = NULL_TREE;\n-#endif\n+/* If BINFO is not marked, return a canonical version of BINFO.\n+   Otherwise, return NULL_TREE.  */\n \n-tree\n-compute_access (basetype_path, field)\n-     tree basetype_path, field;\n+static tree\n+shared_unmarked_p (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n-  tree access;\n-  tree types;\n-  tree context;\n-  int protected_ok, via_protected;\n-  extern int flag_access_control;\n-#if 1\n-  /* Replaces static decl above.  */\n-  tree previous_scope;\n-#endif\n-  int static_mem\n-    = ((TREE_CODE (field) == FUNCTION_DECL && DECL_STATIC_FUNCTION_P (field))\n-       || (TREE_CODE (field) != FUNCTION_DECL && TREE_STATIC (field)));\n+  binfo = canonical_binfo (binfo);\n+  return unmarkedp (binfo, data) ? binfo : NULL_TREE;\n+}\n \n-  if (! flag_access_control)\n-    return access_public_node;\n+/* Called from access_in_type via dfs_walk.  Calculate the access to\n+   DATA (which is really a DECL) in BINFO.  */\n \n-  /* The field lives in the current class.  */\n-  if (BINFO_TYPE (basetype_path) == current_class_type)\n-    return access_public_node;\n+static tree\n+dfs_access_in_type (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree decl = (tree) data;\n+  tree type = BINFO_TYPE (binfo);\n+  tree access = NULL_TREE;\n \n-#if 0\n-  /* Disabled until pushing function scope clears these out.  If ever.  */\n-  /* Make these special cases fast.  */\n-  if (current_scope () == previous_scope)\n+  if (context_for_name_lookup (decl) == type)\n     {\n-      if (DECL_PUBLIC (field))\n-\treturn access_public_node;\n-      if (DECL_PROTECTED (field))\n-\treturn access_protected_node;\n-      if (DECL_PRIVATE (field))\n-\treturn access_private_node;\n+      /* If we have desceneded to the scope of DECL, just note the\n+\t appropriate access.  */\n+      if (TREE_PRIVATE (decl))\n+\taccess = access_private_node;\n+      else if (TREE_PROTECTED (decl))\n+\taccess = access_protected_node;\n+      else\n+\taccess = access_public_node;\n     }\n-#endif\n+  else \n+    {\n+      /* First, check for an access-declaration that gives us more\n+\t access to the DECL.  The CONST_DECL for an enumeration\n+\t constant will not have DECL_LANG_SPECIFIC, and thus no\n+\t DECL_ACCESS.  */\n+      if (DECL_LANG_SPECIFIC (decl))\n+\t{\n+\t  access = purpose_member (type, DECL_ACCESS (decl));\n+\t  if (access)\n+\t    access = TREE_VALUE (access);\n+\t}\n+\n+      if (!access)\n+\t{\n+\t  int i;\n+\t  int n_baselinks;\n+\t  tree binfos;\n+\t  \n+\t  /* Otherwise, scan our baseclasses, and pick the most favorable\n+\t     access.  */\n+\t  binfos = BINFO_BASETYPES (binfo);\n+\t  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\t  for (i = 0; i < n_baselinks; ++i)\n+\t    {\n+\t      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+\t      tree base_access = TREE_CHAIN (canonical_binfo (base_binfo));\n+\n+\t      if (!base_access || base_access == access_private_node)\n+\t\t/* If it was not accessible in the base, or only\n+\t\t   accessible as a private member, we can't access it\n+\t\t   all.  */\n+\t\tbase_access = NULL_TREE;\n+\t      else if (TREE_VIA_PROTECTED (base_binfo))\n+\t\t/* Public and protected members in the base are\n+\t\t   protected here.  */\n+\t\tbase_access = access_protected_node;\n+\t      else if (!TREE_VIA_PUBLIC (base_binfo))\n+\t\t/* Public and protected members in the base are\n+\t\t   private here.  */\n+\t\tbase_access = access_private_node;\n+\n+\t      /* See if the new access, via this base, gives more\n+\t\t access than our previous best access.  */\n+\t      if (base_access &&\n+\t\t  (base_access == access_public_node\n+\t\t   || (base_access == access_protected_node\n+\t\t       && access != access_public_node)\n+\t\t   || (base_access == access_private_node\n+\t\t       && !access)))\n+\t\t{\n+\t\t  access = base_access;\n \n-  /* We don't currently support access control on nested types.  */\n-  if (TREE_CODE (field) == TYPE_DECL)\n-    return access_public_node;\n+\t\t  /* If the new access is public, we can't do better.  */\n+\t\t  if (access == access_public_node)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n-  previous_scope = current_scope ();\n+  /* Note the access to DECL in TYPE.  */\n+  TREE_CHAIN (binfo) = access;\n \n-  context = DECL_REAL_CONTEXT (field);\n+  /* Mark TYPE as visited so that if we reach it again we do not\n+     duplicate our efforts here.  */\n+  SET_BINFO_MARKED (binfo);\n \n-  /* Fields coming from nested anonymous unions have their DECL_CLASS_CONTEXT\n-     slot set to the union type rather than the record type containing\n-     the anonymous union.  */\n-  if (context && ANON_UNION_TYPE_P (context)\n-      && TREE_CODE (field) == FIELD_DECL)\n-    context = TYPE_CONTEXT (context);\n+  return NULL_TREE;\n+}\n \n-  /* If we aren't a real class member (e.g. we're from a namespace-scope\n-     anonymous union), there's no access control.  */\n-  if (context == NULL_TREE || ! TYPE_P (context))\n-    PUBLIC_RETURN;\n-\n-  /* Virtual function tables are never private.  But we should know that\n-     we are looking for this, and not even try to hide it.  */\n-  if (DECL_NAME (field) && VFIELD_NAME_P (DECL_NAME (field)) == 1)\n-    PUBLIC_RETURN;\n-\n-  /* Member found immediately within object.  */\n-  if (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE)\n-    {\n-      /* Are we (or an enclosing scope) friends with the class that has\n-         FIELD? */\n-      if (is_friend (context, previous_scope))\n-\tPUBLIC_RETURN;\n-\n-      /* If it's private, it's private, you letch.  */\n-      if (TREE_PRIVATE (field))\n-\tPRIVATE_RETURN;\n-\n-      /* ARM $11.5.  Member functions of a derived class can access the\n-\t non-static protected members of a base class only through a\n-\t pointer to the derived class, a reference to it, or an object\n-\t of it. Also any subsequently derived classes also have\n-\t access.  */\n-      else if (TREE_PROTECTED (field))\n-\t{\n-\t  if (current_class_type\n-\t      && (static_mem || DECL_CONSTRUCTOR_P (field))\n-\t      && ACCESSIBLY_DERIVED_FROM_P (context, current_class_type))\n-\t    PUBLIC_RETURN;\n-\t  else\n-\t    PROTECTED_RETURN;\n-\t}\n-      else\n-\tPUBLIC_RETURN;\n-    }\n+/* Return the access to DECL in TYPE.  */\n \n-  /* must reverse more than one element */\n-  basetype_path = reverse_path (basetype_path);\n-  types = basetype_path;\n-  via_protected = 0;\n-  access = access_default_node;\n-  protected_ok = static_mem && current_class_type\n-    && ACCESSIBLY_DERIVED_FROM_P (BINFO_TYPE (types), current_class_type);\n+static tree \n+access_in_type (type, decl)\n+     tree type;\n+     tree decl;\n+{\n+  tree binfo = TYPE_BINFO (type);\n \n-  while (1)\n-    {\n-      tree member;\n-      tree binfo = types;\n-      tree type = BINFO_TYPE (binfo);\n-      int private_ok = 0;\n+  /* We must take into account\n \n-      /* Friends of a class can see protected members of its bases.\n-         Note that classes are their own friends.  */\n-      if (is_friend (type, previous_scope))\n-\t{\n-\t  protected_ok = 1;\n-\t  private_ok = 1;\n-\t}\n+       [class.paths]\n \n-      member = purpose_member (type, DECL_ACCESS (field));\n-      if (member)\n-\t{\n-\t  access = TREE_VALUE (member);\n-\t  break;\n-\t}\n+       If a name can be reached by several paths through a multiple\n+       inheritance graph, the access is that of the path that gives\n+       most access.  \n \n-      types = BINFO_INHERITANCE_CHAIN (types);\n+    The algorithm we use is to make a post-order depth-first traversal\n+    of the base-class hierarchy.  As we come up the tree, we annotate\n+    each node with the most lenient access.  */\n+  dfs_walk_real (binfo, 0, dfs_access_in_type, shared_unmarked_p, decl);\n+  dfs_walk (binfo, dfs_unmark, shared_marked_p,  0);\n \n-      /* If the next type was VIA_PROTECTED, then fields of all remaining\n-\t classes past that one are *at least* protected.  */\n-      if (types)\n-\t{\n-\t  if (TREE_VIA_PROTECTED (types))\n-\t    via_protected = 1;\n-\t  else if (! TREE_VIA_PUBLIC (types) && ! private_ok)\n-\t    {\n-\t      access = access_private_node;\n-\t      break;\n-\t    }\n-\t}\n-      else\n-\tbreak;\n+  return TREE_CHAIN (binfo);\n+}\n+\n+/* Called from dfs_accessible_p via dfs_walk.  */\n+\n+static tree\n+dfs_accessible_queue_p (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  if (BINFO_MARKED (binfo))\n+    return NULL_TREE;\n+\n+  /* If this class is inherited via private or protected inheritance,\n+     then we can't see it, unless we are a friend of the subclass.  */\n+  if (!TREE_VIA_PUBLIC (binfo)\n+      && !is_friend (BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo)),\n+\t\t     current_scope ()))\n+    return NULL_TREE;\n+\n+  return canonical_binfo (binfo);\n+}\n+\n+/* Called from dfs_accessible_p via dfs_walk.  */\n+\n+static tree\n+dfs_accessible_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  int protected_ok = data != 0;\n+  tree access;\n+\n+  /* We marked the binfos while computing the access in each type.\n+     So, we unmark as we go now.  */\n+  SET_BINFO_MARKED (binfo);\n+\n+  access = TREE_CHAIN (binfo);\n+  if (access == access_public_node\n+      || (access == access_protected_node && protected_ok))\n+    return binfo;\n+  else if (access && is_friend (BINFO_TYPE (binfo), current_scope ()))\n+    return binfo;\n+\n+  return NULL_TREE;\n+}\n+\n+/* DECL is a declaration from a base class of TYPE, which was the\n+   classs used to name DECL.  Return non-zero if, in the current\n+   context, DECL is accessible.  If TYPE is actually a BINFO node,\n+   then the most derived class along the path indicated by BINFO is\n+   the one used to name the DECL.  */\n+\n+int \n+accessible_p (type, decl)\n+     tree type;\n+     tree decl;\n+     \n+{\n+  tree scope;\n+  tree binfo;\n+  tree t;\n+\n+  /* Non-zero if it's OK to access DECL if it has protected\n+     accessibility in TYPE.  */\n+  int protected_ok = 0;\n+\n+  /* If we're not checking access, everything is accessible.  */\n+  if (!flag_access_control)\n+    return 1;\n+\n+  /* If this declaration is in a block or namespace scope, there's no\n+     access control.  */\n+  if (!TYPE_P (context_for_name_lookup (decl)))\n+    return 1;\n+\n+  /* We don't do access control for types yet.  */\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    return 1;\n+\n+  if (!TYPE_P (type))\n+    {\n+      binfo = type;\n+      type = BINFO_TYPE (type);\n     }\n+  else\n+    binfo = TYPE_BINFO (type);\n+\n+  /* [class.access.base]\n+\n+     A member m is accessible when named in class N if\n+\n+     --m as a member of N is public, or\n \n-  /* No special visibilities apply.  Use normal rules.  */\n+     --m as a member of N is private, and the reference occurs in a\n+       member or friend of class N, or\n \n-  if (access == access_default_node)\n+     --m as a member of N is protected, and the reference occurs in a\n+       member or friend of class N, or in a member or friend of a\n+       class P derived from N, where m as a member of P is private or\n+       protected, or\n+\n+     --there exists a base class B of N that is accessible at the point\n+       of reference, and m is accessible when named in class B.  \n+\n+    We walk the base class hierarchy, checking these conditions.  */\n+\n+  /* Figure out where the reference is occurring.  Check to see if\n+     DECL is private or protected in this scope, since that will\n+     determine whether protected access in TYPE allowed.  */\n+  if (current_class_type\n+      && DERIVED_FROM_P (type, current_class_type))\n     {\n-      if (is_friend (context, previous_scope))\n-\taccess = access_public_node;\n-      else if (TREE_PRIVATE (field))\n-\taccess = access_private_node;\n-      else if (TREE_PROTECTED (field))\n-\taccess = access_protected_node;\n-      else\n-\taccess = access_public_node;\n+      tree access = access_in_type (current_class_type, decl);\n+      if (same_type_p (current_class_type, type)\n+\t  && access == access_private_node)\n+\tprotected_ok = 1;\n+      else if (access && (access == access_private_node\n+\t\t\t  || access == access_protected_node))\n+\tprotected_ok = 1;\n     }\n \n-  if (access == access_public_node && via_protected)\n-    access = access_protected_node;\n+  /* Now, loop through the classes of which SCOPE is a friend.  */\n+  if (!protected_ok && scope)\n+    {\n+      /* FIXME: Implement this.  Right now, we have no way of knowing\n+\t        which classes befriend a particular function or class.  */\n+    }\n \n-  if (access == access_protected_node && protected_ok)\n-    access = access_public_node;\n+  /* [class.protected]\n \n-#if 0\n-  if (access == access_public_node)\n-    DECL_PUBLIC (field) = 1;\n-  else if (access == access_protected_node)\n-    DECL_PROTECTED (field) = 1;\n-  else if (access == access_private_node)\n-    DECL_PRIVATE (field) = 1;\n-  else my_friendly_abort (96);\n-#endif\n-  return access;\n+     When a friend or a member function of a derived class references\n+     a protected nonstatic member of a base class, an access check\n+     applies in addition to those described earlier in clause\n+     _class.access_.4) Except when forming a pointer to member\n+     (_expr.unary.op_), the access must be through a pointer to,\n+     reference to, or object of the derived class itself (or any class\n+     derived from that class) (_expr.ref_).  If the access is to form\n+     a pointer to member, the nested-name-specifier shall name the\n+     derived class (or any class derived from that class).  */\n+  if (protected_ok && DECL_NONSTATIC_MEMBER_P (decl))\n+    {\n+      /* We can tell through what the reference is occurring by\n+\t chasing BINFO up to the root.  */\n+      t = binfo;\n+      while (BINFO_INHERITANCE_CHAIN (t))\n+\tt = BINFO_INHERITANCE_CHAIN (t);\n+      \n+      if (!DERIVED_FROM_P (current_class_type, BINFO_TYPE (t)))\n+\tprotected_ok = 0;\n+    }\n+  \n+  /* Standardize on the same that will access_in_type will use.  We\n+     don't need to know what path was chosen from this point onwards.  */ \n+  binfo = TYPE_BINFO (type);\n+\n+  /* Compute the accessibility of DECL in the class hierarchy\n+     dominated by type.  */\n+  access_in_type (type, decl);\n+  /* Walk the hierarchy again, looking for a base class that allows\n+     access.  */\n+  t = dfs_walk (binfo, dfs_accessible_p, \n+\t\tdfs_accessible_queue_p,\n+\t\tprotected_ok ? &protected_ok : 0);\n+  /* Clear any mark bits.  */\n+  dfs_walk (binfo, dfs_unmark, shared_marked_p,  0);\n+\n+  return t != NULL_TREE;\n }\n \n /* Routine to see if the sub-object denoted by the binfo PARENT can be\n@@ -799,15 +945,18 @@ is_subobject_of_p (parent, binfo)\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n+  if (TREE_VIA_VIRTUAL (parent))\n+    parent = TYPE_BINFO (TREE_TYPE (parent));\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    binfo = TYPE_BINFO (TREE_TYPE (binfo));\n+\n   if (parent == binfo)\n     return 1;\n \n   /* Process and/or queue base types.  */\n   for (i = 0; i < n_baselinks; i++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tbase_binfo = TYPE_BINFO (BINFO_TYPE (base_binfo));\n+      tree base_binfo = canonical_binfo (TREE_VEC_ELT (binfos, i));\n       if (is_subobject_of_p (parent, base_binfo))\n \treturn 1;\n     }\n@@ -859,20 +1008,21 @@ lookup_fnfields_here (type, name)\n }\n \n struct lookup_field_info {\n+  /* The type in which we're looking.  */\n+  tree type;\n   /* The name of the field for which we're looking.  */\n   tree name;\n   /* If non-NULL, the current result of the lookup.  */\n   tree rval;\n   /* The path to RVAL.  */\n   tree rval_binfo;\n-  /* If non-NULL, a list of the possible candidates.  */\n+  /* If non-NULL, the lookup was ambiguous, and this is a list of the\n+     candidates.  */\n   tree ambiguous;\n-  /* The access computed for RVAL.  */\n-  tree access;\n-  /* If non-zero, we must check access.  */\n-  int protect;\n   /* If non-zero, we are looking for types, not data members.  */\n   int want_type;\n+  /* If non-zero, RVAL was found by looking through a dependent base.  */\n+  int from_dep_base_p;\n   /* If something went wrong, a message indicating what.  */\n   char *errstr;\n };\n@@ -882,14 +1032,28 @@ struct lookup_field_info {\n    it.  DATA is really a struct lookup_field_info.  Called from\n    lookup_field via breadth_first_search.  */\n \n-static int\n+static tree\n lookup_field_queue_p (binfo, data)\n      tree binfo;\n      void *data;\n {\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n-  \n-  return !(lfi->rval_binfo && hides (lfi->rval_binfo, binfo));\n+\n+  /* Don't look for constructors or destructors in base classes.  */\n+  if (lfi->name == ctor_identifier || lfi->name == dtor_identifier)\n+    return NULL_TREE;\n+\n+  /* If this base class is hidden by the best-known value so far, we\n+     don't need to look.  */\n+  if (!lfi->from_dep_base_p && lfi->rval_binfo\n+      && hides (lfi->rval_binfo, binfo))\n+    return NULL_TREE;\n+\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    return binfo_member (BINFO_TYPE (binfo),\n+\t\t\t CLASSTYPE_VBASECLASSES (lfi->type));\n+  else\n+    return binfo;\n }\n \n /* DATA is really a struct lookup_field_info.  Look for a field with\n@@ -906,22 +1070,54 @@ lookup_field_r (binfo, data)\n   tree type = BINFO_TYPE (binfo);\n   tree nval;\n   int idx;\n+  int from_dep_base_p;\n \n-  /* See if the field is present in TYPE.  */\n-  nval = lookup_field_1 (type, lfi->name);\n+  /* First, look for a function.  There can't be a function and a data\n+     member with the same name, and if there's a function and a type\n+     with the same name, the type is hidden by the function.  */\n+  idx = lookup_fnfields_here (type, lfi->name);\n+  if (idx >= 0)\n+    nval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n+  else\n+    /* Look for a data member or type.  */\n+    nval = lookup_field_1 (type, lfi->name);\n+\n+  /* If there is no declaration with the indicated name in this type,\n+     then there's nothing to do.  */\n   if (!nval)\n-    idx = lookup_fnfields_here (type, lfi->name);\n+    return NULL_TREE;\n \n-  /* If the data member wasn't present, then there's nothing further\n-     to do for this type.  */\n-  if (!nval && idx < 0)\n+  from_dep_base_p = dependent_base_p (binfo);\n+  if (lfi->from_dep_base_p && !from_dep_base_p)\n+    {\n+      /* If the new declaration is not found via a dependent base, and\n+\t the old one was, then we must prefer the new one.  We weren't\n+\t really supposed to be able to find the old one, so we don't\n+\t want to be affected by a specialization.  Consider:\n+\n+\t   struct B { typedef int I; };\n+\t   template <typename T> struct D1 : virtual public B {}; \n+\t   template <typename T> struct D :\n+\t   public D1, virtual pubic B { I i; };\n+\n+\t The `I' in `D<T>' is unambigousuly `B::I', regardless of how\n+\t D1 is specialized.  */\n+      lfi->from_dep_base_p = 0;\n+      lfi->rval = NULL_TREE;\n+      lfi->rval_binfo = NULL_TREE;\n+      lfi->ambiguous = NULL_TREE;\n+      lfi->errstr = 0;\n+    }\n+  else if (lfi->rval_binfo && !lfi->from_dep_base_p && from_dep_base_p)\n+    /* Similarly, if the old declaration was not found via a dependent\n+       base, and the new one is, ignore the new one.  */\n     return NULL_TREE;\n \n   /* If the lookup already found a match, and the new value doesn't\n      hide the old one, we might have an ambiguity.  */\n   if (lfi->rval_binfo && !hides (binfo, lfi->rval_binfo))\n     {\n-      if (nval && nval == lfi->rval && SHARED_MEMBER_P (nval))\n+      if (nval == lfi->rval && SHARED_MEMBER_P (nval))\n \t/* The two things are really the same.  */\n \t;\n       else if (hides (lfi->rval_binfo, binfo))\n@@ -937,14 +1133,6 @@ lookup_field_r (binfo, data)\n \t       to the list.  */\n \t    lfi->ambiguous = scratch_tree_cons (NULL_TREE, lfi->rval,\n \t\t\t\t\t\tNULL_TREE);\n-\t  /* If NVAL is NULL here, that means that we found a\n-\t     function, not a data member.  Pick a representative\n-\t     function, from the overload set, for use in error\n-\t     messages. */\n-\t  if (!nval)\n-\t    nval = OVL_CURRENT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC\n-\t\t\t\t\t      (type), idx));\n-\t      \n \t  /* Add the new value.  */\n \t  lfi->ambiguous = scratch_tree_cons (NULL_TREE, nval, \n \t\t\t\t\t      lfi->ambiguous);\n@@ -955,174 +1143,44 @@ lookup_field_r (binfo, data)\n     {\n       /* The new lookup is the best we've got so far.  Verify that\n \t it's the kind of thing we're looking for.  */\n-      if (nval)\n+      if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL)\n \t{\n-\t  if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL)\n-\t    {\n-\t      nval = purpose_member (lfi->name, CLASSTYPE_TAGS (type));\n-\t      if (nval)\n-\t\tnval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n-\t    }\n-\t  else if (!lfi->want_type && TREE_CODE (nval) == TYPE_DECL\n-\t\t   && lookup_fnfields_here (type, lfi->name) >= 0)\n-\t    /* The type declaration is actually hidden by the\n-\t       function declaration.  */\n-\t    nval = NULL_TREE;\n+\t  nval = purpose_member (lfi->name, CLASSTYPE_TAGS (type));\n+\t  if (nval)\n+\t    nval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n \t}\n \n       if (nval)\n \t{\n-\t  /* The lookup found a data member.  */\n-\t  lfi->rval = nval;\n-\t  if (lfi->protect)\n-\t    lfi->access = compute_access (binfo, nval);\n \t  /* If the thing we're looking for is a virtual base class,\n \t     then we know we've got what we want at this point;\n \t     there's no way to get an ambiguity.  */\n \t  if (VBASE_NAME_P (lfi->name))\n-\t    return nval;\n+\t    {\n+\t      lfi->rval = nval;\n+\t      return nval;\n+\t    }\n+\n+\t  if (from_dep_base_p && TREE_CODE (nval) != TYPE_DECL\n+\t      /* We need to return a member template class so we can\n+\t\t define partial specializations.  Is there a better\n+\t\t way?  */\n+\t      && !DECL_CLASS_TEMPLATE_P (nval))\n+\t    /* The thing we're looking for isn't a type, so the implicit\n+\t       typename extension doesn't apply, so we just pretend we\n+\t       didn't find anything.  */\n+\t    return NULL_TREE;\n \t}\n-      else\n-\t/* The lookup found a function member.  This lookup hides\n-\t   whatever was there before, so even though we're not\n-\t   interested in this value we keep track of the way in\n-\t   which we found the function.  Subsequent lookups\n-\t   shouldn't find a data member if it is hidden by this\n-\t   function member.  */\n-\tlfi->rval = NULL_TREE;\n \n+      lfi->rval = nval;\n+      lfi->from_dep_base_p = from_dep_base_p;\n       lfi->rval_binfo = binfo;\n     }\n \n-  return 0;\n-}\n-\n-/* Check to see if the result of the field lookup (as indicated by\n-   DATA, which is really a struct field_info) has any access other\n-   than that we previously computed.  SEARCH_HEAD and SEARCH_TAIL\n-   bound the path taken to find the result.  Called from lookup_field\n-   via breadth_first_search.  */\n-\n-static void\n-lookup_field_post (search_head, search_tail, data)\n-     tree *search_head;\n-     tree *search_tail;\n-     void *data;\n-{\n-  struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n-  tree rval = lfi->rval;\n-  tree own_access = access_default_node;\n-  tree *tp;\n-\n-  /* If we didn't find anything, or we found ambiguous function\n-     declarations, but no data members, just return.  */\n-  if (!rval)\n-    {\n-      lfi->errstr = 0;\n-      return;\n-    }\n-\n-  /* If we've already hit a snag, we're done.  */\n-  if (lfi->errstr)\n-    return;\n-\n-  /* Check accessibility.  */\n-  if (lfi->protect)\n-    {\n-      /* If is possible for one of the derived types on the path to\n-\t have defined special access for this field.  Look for such\n-\t declarations and report an error if a conflict is found.  */\n-      if (DECL_LANG_SPECIFIC (rval) && DECL_ACCESS (rval))\n-\tfor (tp = search_head; tp < search_tail; ++tp)\n-\t  {\n-\t    tree new_v = NULL_TREE;\n-\t\n-\t    if (lfi->access != access_default_node)\n-\t      new_v = compute_access (*tp, lfi->rval);\n-\t    if (lfi->access != access_default_node && new_v != lfi->access)\n-\t      {\n-\t\tlfi->errstr = \"conflicting access to member `%D'\";\n-\t\tlfi->access = access_default_node;\n-\t\treturn; \n-\t      }\n-\t    own_access = new_v;\n-\t    tp++;\n-\t  }\n-  \n-      /* Check to see that access to the member is allowed.  */\n-      if (own_access == access_private_node)\n-\tlfi->errstr = \"member `%D' declared private\";\n-      else if (own_access == access_protected_node)\n-\tlfi->errstr = \"member `%D' declared protected\";\n-      else if (lfi->access == access_private_node)\n-\tlfi->errstr = TREE_PRIVATE (lfi->rval)\n-\t  ? \"member `%D' is private\"\n-\t  : \"member `%D' is from private base class\";\n-      else if (lfi->access== access_protected_node)\n-\tlfi->errstr = TREE_PROTECTED (rval)\n-\t  ? \"member `%D' is protected\"\n-\t  : \"member `%D' is from protected base class\";\n-    }\n-\n-  /* The implicit typename extension allows us to find type\n-     declarations in dependent base clases.  It also handles\n-     out-of-class definitions where the enclosing class is a\n-     template.  For example:\n-\n-       template <class T> struct S { struct I { void f(); }; };\n-       template <class T> void S<T>::I::f() {}\n-\n-     will come through here to handle `S<T>::I'.  The bottom line is\n-     that while searching for the field, we will have happily\n-     descended into dependent base classes, and we must now figure out\n-     what to do about it.  */\n-\n-  /* If we're not in a template, or the search terminated in the\n-     current class, then there's no problem.  */\n-  if (!processing_template_decl \n-      || currently_open_class (BINFO_TYPE (lfi->rval_binfo)))\n-    return;\n-  \n-  /* We need to return a member template class so we can define partial\n-     specializations.  Is there a better way?  */\n-  if (DECL_CLASS_TEMPLATE_P (rval))\n-    return;\n-\n-  /* Walk the path to the base in which the search finally suceeded,\n-     checking for dependent bases along the way.  */\n-  for (tp = (currently_open_class (BINFO_TYPE (*search_head)))\n-\t ? search_head + 1 : search_head; \n-       tp < search_tail; \n-       ++tp)\n-    {\n-      if (!uses_template_parms (BINFO_TYPE (*tp)))\n-\tcontinue;\n-\n-      if (TREE_CODE (rval) != TYPE_DECL)\n-\t{\n-\t  /* The thing we're looking for isn't a type, so the implicit\n-\t     typename extension doesn't apply, so we just pretend we\n-\t     didn't find anything.  */\n-\t  lfi->rval = NULL_TREE;\n-\t  return;\n-\t}\n-\n-      /* We've passed a dependent base on our way to finding the\n-\t type.  So, create an implicit typename type.  The appropriate\n-         context for the typename is *TP.  But, there's a small catch;\n-         the base classes for a partial instantiation are not correct,\n-\t because we don't tsubst into them when we do the partial\n-\t instantiation.  So, we just use the context of the current\n-\t class type.  */\n-      lfi->rval = TYPE_STUB_DECL (build_typename_type \n-\t\t\t\t  (BINFO_TYPE (*search_head), \n-\t\t\t\t   lfi->name, lfi->name, \n-\t\t\t\t   TREE_TYPE (rval)));\n-      return;\n-    }\n+  return NULL_TREE;\n }\n \n-/* Look for a field named NAME in an inheritance lattice dominated by\n+/* Look for a memer named NAME in an inheritance lattice dominated by\n    XBASETYPE.  PROTECT is zero if we can avoid computing access\n    information, otherwise it is 1.  WANT_TYPE is 1 when we should only\n    return TYPE_DECLs, if no TYPE_DECL can be found return NULL_TREE.\n@@ -1132,7 +1190,7 @@ lookup_field_post (search_head, search_tail, data)\n    the error.  */\n \n tree\n-lookup_field (xbasetype, name, protect, want_type)\n+lookup_member (xbasetype, name, protect, want_type)\n      register tree xbasetype, name;\n      int protect, want_type;\n {\n@@ -1156,17 +1214,6 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   char *errstr = 0;\n \n-  bzero (&lfi, sizeof (lfi));\n-\n-#if 0\n-  /* We cannot search for constructor/destructor names like this.  */\n-  /* This can't go here, but where should it go?  */\n-  /* If we are looking for a constructor in a templated type, use the\n-     unspecialized name, as that is how we store it.  */\n-  if (IDENTIFIER_TEMPLATE (name))\n-    name = constructor_name (name);\n-#endif\n-\n   if (xbasetype == current_class_type && TYPE_BEING_DEFINED (xbasetype)\n       && IDENTIFIER_CLASS_VALUE (name))\n     {\n@@ -1197,12 +1244,11 @@ lookup_field (xbasetype, name, protect, want_type)\n   n_calls_lookup_field++;\n #endif /* GATHER_STATISTICS */\n \n+  bzero (&lfi, sizeof (lfi));\n+  lfi.type = type;\n   lfi.name = name;\n-  lfi.protect = protect;\n   lfi.want_type = want_type;\n-  lfi.access = access_default_node;\n-  breadth_first_search (basetype_path, &lookup_field_r, \n-\t\t\t&lookup_field_queue_p, &lookup_field_post, &lfi);\n+  bfs_walk (basetype_path, &lookup_field_r, &lookup_field_queue_p, &lfi);\n   rval = lfi.rval;\n   rval_binfo = lfi.rval_binfo;\n   if (rval_binfo)\n@@ -1213,6 +1259,16 @@ lookup_field (xbasetype, name, protect, want_type)\n      just return NULL_TREE.  */\n   if (!protect && lfi.ambiguous)\n     return NULL_TREE;\n+  \n+  /* [class.access]\n+\n+     In the case of overloaded function names, access control is\n+     applied to the function selected by overloaded resolution.  */\n+  if (rval && protect && !is_overloaded_fn (rval)\n+      && !IS_SIGNATURE_POINTER (DECL_REAL_CONTEXT (rval))\n+      && !IS_SIGNATURE_REFERENCE (DECL_REAL_CONTEXT (rval))\n+      && !enforce_access (xbasetype, rval))\n+    return error_mark_node;\n \n   if (errstr && protect)\n     {\n@@ -1222,6 +1278,50 @@ lookup_field (xbasetype, name, protect, want_type)\n       rval = error_mark_node;\n     }\n \n+  /* If the thing we found was found via the implicit typename\n+     extension, build the typename type.  */\n+  if (rval && lfi.from_dep_base_p && !DECL_CLASS_TEMPLATE_P (rval))\n+    rval = TYPE_STUB_DECL (build_typename_type (BINFO_TYPE (basetype_path),\n+\t\t\t\t\t\tname, name,\n+\t\t\t\t\t\tTREE_TYPE (rval)));\n+\n+  if (rval && is_overloaded_fn (rval))\n+    rval = scratch_tree_cons (basetype_path, rval, NULL_TREE);\n+\n+  return rval;\n+}\n+\n+/* Like lookup_member, except that if we find a function member we\n+   return NULL_TREE.  */\n+\n+tree\n+lookup_field (xbasetype, name, protect, want_type)\n+     register tree xbasetype, name;\n+     int protect, want_type;\n+{\n+  tree rval = lookup_member (xbasetype, name, protect, want_type);\n+  \n+  /* Ignore functions.  */\n+  if (rval && TREE_CODE (rval) == TREE_LIST)\n+    return NULL_TREE;\n+\n+  return rval;\n+}\n+\n+/* Like lookup_member, except that if we find a non-function member we\n+   return NULL_TREE.  */\n+\n+tree\n+lookup_fnfields (xbasetype, name, protect)\n+     register tree xbasetype, name;\n+     int protect;\n+{\n+  tree rval = lookup_member (xbasetype, name, protect, /*want_type=*/0);\n+\n+  /* Ignore non-functions.  */\n+  if (rval && TREE_CODE (rval) != TREE_LIST)\n+    return NULL_TREE;\n+\n   return rval;\n }\n \n@@ -1342,325 +1442,65 @@ lookup_fnfields_1 (type, name)\n \t\t  /* Since all conversion operators come first, we know\n \t\t     there is no such operator.  */\n \t\t  methods = end;\n-\t\t  break;\n-\t\t}\n-\t      else if (TREE_CODE (OVL_CURRENT (*methods)) == TEMPLATE_DECL)\n-\t\tbreak;\n-\t    }\n-\t}\n-\n-      if (methods != end && *methods)\n-\treturn methods - &TREE_VEC_ELT (method_vec, 0);\n-    }\n-\n-  return -1;\n-}\n-\n-/* Starting from BASETYPE, return a TREE_BASELINK-like object\n-   which gives the following information (in a list):\n-\n-   TREE_TYPE: list of basetypes needed to get to...\n-   TREE_VALUE: list of all functions in a given type\n-   which have name NAME.\n-\n-   No access information is computed by this function,\n-   other then to adorn the list of basetypes with\n-   TREE_VIA_PUBLIC.\n-\n-   If there are two ways to find a name (two members), if COMPLAIN is\n-   non-zero, then error_mark_node is returned, and an error message is\n-   printed, otherwise, just an error_mark_node is returned.\n-\n-   As a special case, is COMPLAIN is -1, we don't complain, and we\n-   don't return error_mark_node, but rather the complete list of\n-   virtuals.  This is used by get_virtuals_named_this.  */\n-\n-tree\n-lookup_fnfields (basetype_path, name, complain)\n-     tree basetype_path, name;\n-     int complain;\n-{\n-  int head = 0, tail = 0;\n-  tree type, rval, rval_binfo = NULL_TREE, rvals = NULL_TREE;\n-  tree rval_binfo_h = NULL_TREE, binfo, basetype_chain, binfo_h;\n-  int idx, find_all = 0;\n-\n-  /* rval_binfo is the binfo associated with the found member, note,\n-     this can be set with useful information, even when rval is not\n-     set, because it must deal with ALL members, not just function\n-     members.  It is used for ambiguity checking and the hidden\n-     checks.  Whereas rval is only set if a proper (not hidden)\n-     function member is found.  */\n-\n-  /* rval_binfo_h and binfo_h are binfo values used when we perform the\n-     hiding checks, as virtual base classes may not be shared.  The strategy\n-     is we always go into the binfo hierarchy owned by TYPE_BINFO of\n-     virtual base classes, as we cross virtual base class lines.  This way\n-     we know that binfo of a virtual base class will always == itself when\n-     found along any line.  (mrs)  */\n-\n-  /* For now, don't try this.  */\n-  int protect = complain;\n-\n-  char *errstr = 0;\n-\n-  if (complain == -1)\n-    {\n-      find_all = 1;\n-      protect = complain = 0;\n-    }\n-\n-#if 0\n-  /* We cannot search for constructor/destructor names like this.  */\n-  /* This can't go here, but where should it go?  */\n-  /* If we are looking for a constructor in a templated type, use the\n-     unspecialized name, as that is how we store it.  */\n-  if (IDENTIFIER_TEMPLATE (name))\n-    name = constructor_name (name);\n-#endif\n-\n-  binfo = basetype_path;\n-  binfo_h = binfo;\n-  type = complete_type (BINFO_TYPE (basetype_path));\n-\n-#ifdef GATHER_STATISTICS\n-  n_calls_lookup_fnfields++;\n-#endif /* GATHER_STATISTICS */\n-\n-  idx = lookup_fnfields_here (type, name);\n-  if (idx >= 0 || lookup_field_1 (type, name))\n-    {\n-      rval_binfo = basetype_path;\n-      rval_binfo_h = rval_binfo;\n-    }\n-\n-  if (idx >= 0)\n-    {\n-      rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n-      rvals = scratch_tree_cons (basetype_path, rval, rvals);\n-      if (BINFO_BASETYPES (binfo) && CLASSTYPE_BASELINK_VEC (type))\n-\tTREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), idx);\n-\n-      return rvals;\n-    }\n-  rval = NULL_TREE;\n-\n-  if (name == ctor_identifier || name == dtor_identifier)\n-    {\n-      /* Don't allow lookups of constructors and destructors to go\n- \t deeper than the first place we look.  */\n-      return NULL_TREE;\n-    }\n-\n-  if (basetype_path == TYPE_BINFO (type))\n-    {\n-      basetype_chain = CLASSTYPE_BINFO_AS_LIST (type);\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE,\n-\t\t\t  980827);\n-    }\n-  else\n-    basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n-\n-  /* The ambiguity check relies upon breadth first searching.  */\n-\n-  search_stack = push_search_level (search_stack, &search_obstack);\n-  binfo = basetype_path;\n-  binfo_h = binfo;\n-\n-  while (1)\n-    {\n-      tree binfos = BINFO_BASETYPES (binfo);\n-      int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-      int idx;\n-\n-      /* Process and/or queue base types.  */\n-      for (i = 0; i < n_baselinks; i++)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t  if (BINFO_FIELDS_MARKED (base_binfo) == 0)\n-\t    {\n-\t      tree btypes;\n-\n-\t      SET_BINFO_FIELDS_MARKED (base_binfo);\n-\t      btypes = scratch_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n-\t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\tbtypes = scratch_tree_cons (NULL_TREE,\n-\t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n-\t\t\t\t    btypes);\n-\t      else\n-\t\tbtypes = scratch_tree_cons (NULL_TREE,\n-\t\t\t\t    TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i),\n-\t\t\t\t    btypes);\n-\t      obstack_ptr_grow (&search_obstack, btypes);\n-\t      tail += 1;\n-\t      if (tail >= search_stack->limit)\n-\t\tmy_friendly_abort (99);\n-\t    }\n-\t}\n-\n-      /* Process head of queue, if one exists.  */\n-      if (head >= tail)\n-\tbreak;\n-\n-      basetype_chain = search_stack->first[head++];\n-      binfo_h = TREE_VALUE (basetype_chain);\n-      basetype_chain = TREE_CHAIN (basetype_chain);\n-      basetype_path = TREE_VALUE (basetype_chain);\n-      if (TREE_CHAIN (basetype_chain))\n-\tmy_friendly_assert\n-\t  ((BINFO_INHERITANCE_CHAIN (basetype_path)\n-\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)))\n-\t   /* We only approximate base info for partial instantiations.  */ \n-\t   || current_template_parms,\n-\t   980827);\n-      else\n-\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n-\t\t\t    == NULL_TREE, 980827);\n-\n-      binfo = basetype_path;\n-      type = BINFO_TYPE (binfo);\n-\n-      /* See if we can find NAME in TYPE.  If RVAL is nonzero,\n-\t and we do find NAME in TYPE, verify that such a second\n-\t sighting is in fact valid.  */\n-\n-      idx = lookup_fnfields_here (type, name);\n-\n-      if (idx >= 0 || (lookup_field_1 (type, name)!=NULL_TREE && !find_all))\n-\t{\n-\t  if (rval_binfo && !find_all && hides (rval_binfo_h, binfo_h))\n-\t    {\n-\t      /* This is ok, the member found is in rval_binfo, not\n-\t\t here (binfo).  */\n-\t    }\n-\t  else if (rval_binfo==NULL_TREE || find_all || hides (binfo_h, rval_binfo_h))\n-\t    {\n-\t      /* This is ok, the member found is here (binfo), not in\n-\t\t rval_binfo.  */\n-\t      if (idx >= 0)\n-\t\t{\n-\t\t  rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n-\t\t  /* Note, rvals can only be previously set if find_all is\n-\t\t     true.  */\n-\t\t  rvals = scratch_tree_cons (basetype_path, rval, rvals);\n-\t\t  if (TYPE_BINFO_BASETYPES (type)\n-\t\t      && CLASSTYPE_BASELINK_VEC (type))\n-\t\t    TREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), idx);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Undo finding it before, as something else hides it.  */\n-\t\t  rval = NULL_TREE;\n-\t\t  rvals = NULL_TREE;\n+\t\t  break;\n \t\t}\n-\t      rval_binfo = binfo;\n-\t      rval_binfo_h = binfo_h;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* This is ambiguous.  */\n-\t      errstr = \"request for method `%D' is ambiguous\";\n-\t      rvals = error_mark_node;\n-\t      break;\n+\t      else if (TREE_CODE (OVL_CURRENT (*methods)) == TEMPLATE_DECL)\n+\t\tbreak;\n \t    }\n \t}\n-    }\n-  {\n-    tree *tp = search_stack->first;\n-    tree *search_tail = tp + tail;\n \n-    while (tp < search_tail)\n-      {\n-\tCLEAR_BINFO_FIELDS_MARKED (TREE_VALUE (TREE_CHAIN (*tp)));\n-\ttp += 1;\n-      }\n-  }\n-  search_stack = pop_search_level (search_stack);\n-\n-  if (errstr && protect)\n-    {\n-      cp_error (errstr, name);\n-      rvals = error_mark_node;\n+      if (methods != end && *methods)\n+\treturn methods - &TREE_VEC_ELT (method_vec, 0);\n     }\n \n-  return rvals;\n-}\n-\n-/* Look for a field or function named NAME in an inheritance lattice\n-   dominated by XBASETYPE.  PROTECT is zero if we can avoid computing\n-   access information, otherwise it is 1.  WANT_TYPE is 1 when we should\n-   only return TYPE_DECLs, if no TYPE_DECL can be found return NULL_TREE.  */\n-\n-tree\n-lookup_member (xbasetype, name, protect, want_type)\n-     tree xbasetype, name;\n-     int protect, want_type;\n-{\n-  tree ret, basetype_path;\n-\n-  if (TREE_CODE (xbasetype) == TREE_VEC)\n-    basetype_path = xbasetype;\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)))\n-    {\n-      basetype_path = TYPE_BINFO (xbasetype);\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n-\t\t\t  == NULL_TREE, 980827);\n-    }\n-  else\n-    my_friendly_abort (97);\n-  \n-  ret = lookup_field (basetype_path, name, protect, want_type);\n-  if (! ret && ! want_type)\n-    ret = lookup_fnfields (basetype_path, name, protect);\n-  return ret;\n+  return -1;\n }\n \f\n-/* BREADTH-FIRST SEARCH ROUTINES.  */\n-\n-/* Search a multiple inheritance hierarchy by breadth-first search.\n-\n-   BINFO is an aggregate type, possibly in a multiple-inheritance hierarchy.\n-   TESTFN is a function, which, if true, means that our condition has\n-   been met, and its return value should be returned.\n-   QFN, if non-NULL, is a predicate dictating whether the type should\n-   even be queued.  \n-   POSTFN, if non-NULL, is a function to call before returning.  It is\n-   passed an array whose first element is the most derived type in the\n-   chain, and whose last element is the least derived type. \n-   \n-   All of the functions are also passed the DATA, which they may use\n-   as they see fit.  */\n+/* Walk the class hierarchy dominated by TYPE.  FN is called for each\n+   type in the hierarchy, in a breadth-first preorder traversal.  .\n+   If it ever returns a non-NULL value, that value is immediately\n+   returned and the walk is terminated.  At each node FN, is passed a\n+   BINFO indicating the path from the curently visited base-class to\n+   TYPE.  The TREE_CHAINs of the BINFOs may be used for scratch space;\n+   they are otherwise unused.  Before each base-class is walked QFN is\n+   called.  If the value returned is non-zero, the base-class is\n+   walked; otherwise it is not.  If QFN is NULL, it is treated as a\n+   function which always returns 1.  Both FN and QFN are passed the\n+   DATA whenever they are called.  */\n \n static tree\n-breadth_first_search (binfo, testfn, qfn, postfn, data)\n+bfs_walk (binfo, fn, qfn, data)\n      tree binfo;\n-     tree (*testfn) PROTO((tree, void *));\n-     int (*qfn) PROTO((tree, void *));\n-     void (*postfn) PROTO((tree *, tree *, void *));\n+     tree (*fn) PROTO((tree, void *));\n+     tree (*qfn) PROTO((tree, void *));\n      void *data;\n {\n-  int head = 0, tail = 0;\n+  size_t head;\n+  size_t tail;\n   tree rval = NULL_TREE;\n-  tree *tp;\n-  tree *search_tail;\n+  /* An array of the base classes of BINFO.  These will be built up in\n+     breadth-first order, except where QFN prunes the search.  */\n+  varray_type bfs_bases;\n \n-  search_stack = push_search_level (search_stack, &search_obstack);\n+  /* Start with enough room for ten base classes.  That will be enough\n+     for most hierarchies.  */\n+  VARRAY_TREE_INIT (bfs_bases, 10, \"search_stack\");\n \n-  SET_BINFO_MARKED (binfo);\n-  obstack_ptr_grow (&search_obstack, binfo);\n-  ++tail;\n+  /* Put the first type into the stack.  */\n+  VARRAY_TREE (bfs_bases, 0) = binfo;\n+  tail = 1;\n \n-  while (head < tail)\n+  for (head = 0; head < tail; ++head)\n     {\n-      tree binfos;\n-      int n_baselinks;\n       int i;\n+      int n_baselinks;\n+      tree binfos;\n \n       /* Pull the next type out of the queue.  */\n-      binfo = search_stack->first[head++];\n+      binfo = VARRAY_TREE (bfs_bases, head);\n \n       /* If this is the one we're looking for, we're done.  */\n-      rval = (*testfn) (binfo, data);\n+      rval = (*fn) (binfo, data);\n       if (rval)\n \tbreak;\n \n@@ -1671,72 +1511,153 @@ breadth_first_search (binfo, testfn, qfn, postfn, data)\n \t{\n \t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n-\t    base_binfo = TYPE_BINFO (BINFO_TYPE (base_binfo));\n+\t  if (qfn)\n+\t    base_binfo = (*qfn) (base_binfo, data);\n \n-\t  if (BINFO_MARKED (base_binfo) == 0\n-\t      && (qfn == 0 || (*qfn) (base_binfo, data)))\n+\t  if (base_binfo)\n \t    {\n-\t      SET_BINFO_MARKED (base_binfo);\n-\t      obstack_ptr_grow (&search_obstack, base_binfo);\n+\t      if (tail == VARRAY_SIZE (bfs_bases))\n+\t\tVARRAY_GROW (bfs_bases, 2 * VARRAY_SIZE (bfs_bases));\n+\t      VARRAY_TREE (bfs_bases, tail) = base_binfo;\n \t      ++tail;\n-\t      if (tail >= search_stack->limit)\n-\t\tmy_friendly_abort (100);\n \t    }\n \t}\n     }\n \n-  tp = search_stack->first;\n-  search_tail = tp + tail;\n-  \n-  if (postfn)\n-    (*postfn) (tp, search_tail, data);\n-  \n-  while (tp < search_tail)\n+  /* Clean up.  */\n+  VARRAY_FREE (bfs_bases);\n+\n+  return rval;\n+}\n+\n+/* Exactly like bfs_walk, except that a depth-first traversal is\n+   performed, and PREFN is called in preorder, while POSTFN is called\n+   in postorder.  */\n+\n+static tree\n+dfs_walk_real (binfo, prefn, postfn, qfn, data)\n+     tree binfo;\n+     tree (*prefn) PROTO((tree, void *));\n+     tree (*postfn) PROTO((tree, void *));\n+     tree (*qfn) PROTO((tree, void *));\n+     void *data;\n+{\n+  int i;\n+  int n_baselinks;\n+  tree binfos;\n+  tree rval = NULL_TREE;\n+\n+  /* Call the pre-order walking function.  */\n+  if (prefn)\n     {\n-      tree binfo = *tp++;\n-      CLEAR_BINFO_MARKED (binfo);\n+      rval = (*prefn) (binfo, data);\n+      if (rval)\n+\treturn rval;\n     }\n \n-  search_stack = pop_search_level (search_stack);\n+  /* Process the basetypes.  */\n+  binfos = BINFO_BASETYPES (binfo);\n+  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos): 0;\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      \n+      if (qfn)\n+\tbase_binfo = (*qfn) (base_binfo, data);\n+\n+      if (base_binfo)\n+\t{\n+\t  rval = dfs_walk_real (base_binfo, prefn, postfn, qfn, data);\n+\t  if (rval)\n+\t    return rval;\n+\t}\n+    }\n+\n+  /* Call the post-order walking function.  */\n+  if (postfn)\n+    rval = (*postfn) (binfo, data);\n+  \n   return rval;\n }\n \n-/* Functions to use in breadth first searches.  */\n-typedef tree (*pfi) PROTO((tree));\n+/* Exactly like bfs_walk, except that a depth-first post-order traversal is\n+   performed.  */\n+\n+tree\n+dfs_walk (binfo, fn, qfn, data)\n+     tree binfo;\n+     tree (*fn) PROTO((tree, void *));\n+     tree (*qfn) PROTO((tree, void *));\n+     void *data;\n+{\n+  return dfs_walk_real (binfo, 0, fn, qfn, data);\n+}\n+\n+struct gvnt_info \n+{\n+  /* The name of the function we are looking for.  */\n+  tree name;\n+  /* The overloaded functions we have found.  */\n+  tree fields;\n+};\n+\n+/* Called from get_virtuals_named_this via bfs_walk.  */\n+\n+static tree\n+get_virtuals_named_this_r (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  struct gvnt_info *gvnti = (struct gvnt_info *) data;\n+  tree type = BINFO_TYPE (binfo);\n+  int idx;\n+\n+  idx = lookup_fnfields_here (BINFO_TYPE (binfo), gvnti->name);\n+  if (idx >= 0)\n+    gvnti->fields\n+      = scratch_tree_cons (binfo, \n+\t\t\t   TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type),\n+\t\t\t\t\t idx),\n+\t\t\t   gvnti->fields);\n+\n+  return NULL_TREE;\n+}\n \n-static tree declarator;\n+/* Return the virtual functions with the indicated NAME in the type\n+   indicated by BINFO.  The result is a TREE_LIST whose TREE_PURPOSE\n+   indicates the base class from which the TREE_VALUE (an OVERLOAD or\n+   just a FUNCTION_DECL) originated.  */\n \n static tree\n-get_virtuals_named_this (binfo)\n+get_virtuals_named_this (binfo, name)\n      tree binfo;\n+     tree name;\n {\n+  struct gvnt_info gvnti;\n   tree fields;\n \n-  fields = lookup_fnfields (binfo, declarator, -1);\n-  /* fields cannot be error_mark_node */\n+  gvnti.name = name;\n+  gvnti.fields = NULL_TREE;\n \n-  if (fields == 0)\n-    return 0;\n+  bfs_walk (binfo, get_virtuals_named_this_r, 0, &gvnti);\n \n   /* Get to the function decls, and return the first virtual function\n      with this name, if there is one.  */\n-  while (fields)\n+  for (fields = gvnti.fields; fields; fields = next_baselink (fields))\n     {\n       tree fndecl;\n \n       for (fndecl = TREE_VALUE (fields); fndecl; fndecl = OVL_NEXT (fndecl))\n \tif (DECL_VINDEX (OVL_CURRENT (fndecl)))\n \t  return fields;\n-      fields = next_baselink (fields);\n     }\n   return NULL_TREE;\n }\n \n static tree\n get_virtual_destructor (binfo, data)\n      tree binfo;\n-     void *data;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree type = BINFO_TYPE (binfo);\n   if (TYPE_HAS_DESTRUCTOR (type)\n@@ -1745,13 +1666,13 @@ get_virtual_destructor (binfo, data)\n   return 0;\n }\n \n-static int\n+static tree\n tree_has_any_destructor_p (binfo, data)\n      tree binfo;\n-     void *data;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree type = BINFO_TYPE (binfo);\n-  return TYPE_NEEDS_DESTRUCTOR (type);\n+  return TYPE_NEEDS_DESTRUCTOR (type) ? binfo : NULL_TREE;\n }\n \n /* Returns > 0 if a function with type DRETTYPE overriding a function\n@@ -1834,23 +1755,19 @@ get_matching_virtual (binfo, fndecl, dtorp)\n   /* Breadth first search routines start searching basetypes\n      of TYPE, so we must perform first ply of search here.  */\n   if (dtorp)\n-    {\n-      return breadth_first_search (binfo,\n-\t\t\t\t   get_virtual_destructor,\n-\t\t\t\t   tree_has_any_destructor_p, 0, 0);\n-    }\n+    return bfs_walk (binfo, get_virtual_destructor,\n+\t\t     tree_has_any_destructor_p, 0);\n   else\n     {\n       tree drettype, dtypes, btypes, instptr_type;\n       tree basetype = DECL_CLASS_CONTEXT (fndecl);\n       tree baselink, best = NULL_TREE;\n       tree name = DECL_ASSEMBLER_NAME (fndecl);\n-\n-      declarator = DECL_NAME (fndecl);\n+      tree declarator = DECL_NAME (fndecl);\n       if (IDENTIFIER_VIRTUAL_P (declarator) == 0)\n \treturn NULL_TREE;\n \n-      baselink = get_virtuals_named_this (binfo);\n+      baselink = get_virtuals_named_this (binfo, declarator);\n       if (baselink == NULL_TREE)\n \treturn NULL_TREE;\n \n@@ -2117,76 +2034,6 @@ convert_pointer_to_single_level (to_type, expr)\n \t\t\t   last, 1);\n }\n \n-/* The main function which implements depth first search.\n-\n-   This routine has to remember the path it walked up, when\n-   dfs_init_vbase_pointers is the work function, as otherwise there\n-   would be no record.  */\n-\n-void\n-dfs_walk (binfo, fn, qfn)\n-     tree binfo;\n-     void (*fn) PROTO((tree));\n-     int (*qfn) PROTO((tree));\n-{\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-      if (qfn == 0 || (*qfn)(base_binfo))\n-\t{\n-\t  if (TREE_CODE (BINFO_TYPE (base_binfo)) == TEMPLATE_TYPE_PARM\n-\t      || TREE_CODE (BINFO_TYPE (base_binfo)) == TEMPLATE_TEMPLATE_PARM)\n-\t    /* Pass */;\n-\t  else if (fn == dfs_init_vbase_pointers)\n-\t    {\n-\t      /* When traversing an arbitrary MI hierarchy, we need to keep\n-\t\t a record of the path we took to get down to the final base\n-\t\t type, as otherwise there would be no record of it, and just\n-\t\t trying to blindly convert at the bottom would be ambiguous.\n-\n-\t\t The easiest way is to do the conversions one step at a time,\n-\t\t as we know we want the immediate base class at each step.\n-\n-\t\t The only special trick to converting one step at a time,\n-\t\t is that when we hit the last virtual base class, we must\n-\t\t use the SLOT value for it, and not use the normal convert\n-\t\t routine.  We use the last virtual base class, as in our\n-\t\t implementation, we have pointers to all virtual base\n-\t\t classes in the base object.  */\n-\n-\t      tree saved_vbase_decl_ptr_intermediate\n-\t\t= vbase_decl_ptr_intermediate;\n-\n-\t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\t{\n-\t\t  /* No need for the conversion here, as we know it is the\n-\t\t     right type.  */\n-\t\t  vbase_decl_ptr_intermediate\n-\t\t    = CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (base_binfo));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  vbase_decl_ptr_intermediate\n-\t\t    = convert_pointer_to_single_level (BINFO_TYPE (base_binfo),\n-\t\t\t\t\t\t       vbase_decl_ptr_intermediate);\n-\t\t}\n-\n-\t      dfs_walk (base_binfo, fn, qfn);\n-\n-\t      vbase_decl_ptr_intermediate = saved_vbase_decl_ptr_intermediate;\n-\t    }\n-\t  else\n-\t    dfs_walk (base_binfo, fn, qfn);\n-\t}\n-    }\n-\n-  fn (binfo);\n-}\n-\n /* Like dfs_walk, but only walk until fn returns something, and return\n    that.  We also use the real vbase binfos instead of the placeholders\n    in the normal binfo hierarchy.  START is the most-derived type for this\n@@ -2222,46 +2069,82 @@ dfs_search (binfo, fn, start)\n   return fn (binfo);\n }\n \n-int markedp (binfo) tree binfo;\n-{ return BINFO_MARKED (binfo); }\n-static int unmarkedp (binfo) tree binfo;\n-{ return BINFO_MARKED (binfo) == 0; }\n+tree markedp (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  return BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n+}\n+\n+static tree\n+unmarkedp (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return !BINFO_MARKED (binfo) ? binfo : NULL_TREE;\n+}\n \n-#if 0\n-static int bfs_markedp (binfo, i) tree binfo; int i;\n-{ return BINFO_MARKED (BINFO_BASETYPE (binfo, i)); }\n-static int bfs_unmarkedp (binfo, i) tree binfo; int i;\n-{ return BINFO_MARKED (BINFO_BASETYPE (binfo, i)) == 0; }\n-static int bfs_marked_vtable_pathp (binfo, i) tree binfo; int i;\n-{ return BINFO_VTABLE_PATH_MARKED (BINFO_BASETYPE (binfo, i)); }\n-static int bfs_unmarked_vtable_pathp (binfo, i) tree binfo; int i;\n-{ return BINFO_VTABLE_PATH_MARKED (BINFO_BASETYPE (binfo, i)) == 0; }\n-static int bfs_marked_new_vtablep (binfo, i) tree binfo; int i;\n-{ return BINFO_NEW_VTABLE_MARKED (BINFO_BASETYPE (binfo, i)); }\n-static int bfs_unmarked_new_vtablep (binfo, i) tree binfo; int i;\n-{ return BINFO_NEW_VTABLE_MARKED (BINFO_BASETYPE (binfo, i)) == 0; }\n-#endif\n+static tree\n+marked_vtable_pathp (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  return BINFO_VTABLE_PATH_MARKED (binfo) ? binfo : NULL_TREE; \n+}\n+\n+static tree\n+unmarked_vtable_pathp (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  return !BINFO_VTABLE_PATH_MARKED (binfo) ? binfo : NULL_TREE; \n+}\n+\n+static tree \n+marked_new_vtablep (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return BINFO_NEW_VTABLE_MARKED (binfo) ? binfo : NULL_TREE; \n+}\n+\n+static tree\n+unmarked_new_vtablep (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  return !BINFO_NEW_VTABLE_MARKED (binfo) ? binfo : NULL_TREE; \n+}\n+\n+static tree\n+marked_pushdecls_p (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return BINFO_PUSHDECLS_MARKED (binfo) ? binfo : NULL_TREE; \n+}\n \n-static int marked_vtable_pathp (binfo) tree binfo;\n-{ return BINFO_VTABLE_PATH_MARKED (binfo); }\n-static int unmarked_vtable_pathp (binfo) tree binfo;\n-{ return BINFO_VTABLE_PATH_MARKED (binfo) == 0; }\n-static int marked_new_vtablep (binfo) tree binfo;\n-{ return BINFO_NEW_VTABLE_MARKED (binfo); }\n-static int unmarked_new_vtablep (binfo) tree binfo;\n-{ return BINFO_NEW_VTABLE_MARKED (binfo) == 0; }\n-static int marked_pushdecls_p (binfo) tree binfo;\n-{ return BINFO_PUSHDECLS_MARKED (binfo); }\n-static int unmarked_pushdecls_p (binfo) tree binfo;\n-{ return BINFO_PUSHDECLS_MARKED (binfo) == 0; }\n+static tree\n+unmarked_pushdecls_p (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  return !BINFO_PUSHDECLS_MARKED (binfo) ? binfo : NULL_TREE;\n+}\n \n #if 0\n static int dfs_search_slot_nonempty_p (binfo) tree binfo;\n { return CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) != 0; }\n #endif\n \n-static int dfs_debug_unmarkedp (binfo) tree binfo;\n-{ return CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) == 0; }\n+static tree \n+dfs_debug_unmarkedp (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n+\t  ? binfo : NULL_TREE);\n+}\n \n /* The worker functions for `dfs_walk'.  These do not need to\n    test anything (vis a vis marking) if they are paired with\n@@ -2273,9 +2156,14 @@ dfs_mark (binfo) tree binfo;\n { SET_BINFO_MARKED (binfo); }\n #endif\n \n-void\n-dfs_unmark (binfo) tree binfo;\n-{ CLEAR_BINFO_MARKED (binfo); }\n+tree\n+dfs_unmark (binfo, data) \n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  CLEAR_BINFO_MARKED (binfo); \n+  return NULL_TREE;\n+}\n \n #if 0\n static void\n@@ -2299,9 +2187,10 @@ dfs_clear_search_slot (binfo) tree binfo;\n { CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) = 0; }\n #endif\n \n-static void\n-dfs_debug_mark (binfo)\n+static tree\n+dfs_debug_mark (binfo, data)\n      tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree t = BINFO_TYPE (binfo);\n \n@@ -2312,12 +2201,12 @@ dfs_debug_mark (binfo)\n   CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n \n   if (methods == 0)\n-    return;\n+    return NULL_TREE;\n \n   /* If interface info is known, either we've already emitted the debug\n      info or we don't need to.  */\n   if (CLASSTYPE_INTERFACE_KNOWN (t))\n-    return;\n+    return NULL_TREE;\n \n   /* If debug info is requested from this context for this type, supply it.\n      If debug info is requested from another context for this type,\n@@ -2341,7 +2230,7 @@ dfs_debug_mark (binfo)\n \t      /* Somebody, somewhere is going to have to define this\n \t\t virtual function.  When they do, they will provide\n \t\t the debugging info.  */\n-\t      return;\n+\t      return NULL_TREE;\n \t    }\n \t  methods = TREE_CHAIN (methods);\n \t}\n@@ -2350,17 +2239,26 @@ dfs_debug_mark (binfo)\n      so we must write out the debug info ourselves.  */\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n   rest_of_type_compilation (t, toplevel_bindings_p ());\n+\n+  return NULL_TREE;\n }\n \f\n-/*  Attach to the type of the virtual base class, the pointer to the\n-    virtual base class, given the global pointer vbase_decl_ptr.\n+struct vbase_info \n+{\n+  tree decl_ptr;\n+  tree inits;\n+  tree vbase_types;\n+};\n \n-    We use the global vbase_types.  ICK!  */\n+/*  Attach to the type of the virtual base class, the pointer to the\n+    virtual base class.  */\n \n-static void\n-dfs_find_vbases (binfo)\n+static tree\n+dfs_find_vbases (binfo, data)\n      tree binfo;\n+     void *data;\n {\n+  struct vbase_info *vi = (struct vbase_info *) data;\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n@@ -2372,21 +2270,25 @@ dfs_find_vbases (binfo)\n \t  && CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (base_binfo)) == 0)\n \t{\n \t  tree vbase = BINFO_TYPE (base_binfo);\n-\t  tree binfo = binfo_member (vbase, vbase_types);\n+\t  tree binfo = binfo_member (vbase, vi->vbase_types);\n \n \t  CLASSTYPE_SEARCH_SLOT (vbase)\n \t    = build (PLUS_EXPR, build_pointer_type (vbase),\n-\t\t     vbase_decl_ptr, BINFO_OFFSET (binfo));\n+\t\t     vi->decl_ptr, BINFO_OFFSET (binfo));\n \t}\n     }\n   SET_BINFO_VTABLE_PATH_MARKED (binfo);\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n+\n+  return NULL_TREE;\n }\n \n-static void\n-dfs_init_vbase_pointers (binfo)\n+static tree\n+dfs_init_vbase_pointers (binfo, data)\n      tree binfo;\n+     void *data;\n {\n+  struct vbase_info *vi = (struct vbase_info *) data;\n   tree type = BINFO_TYPE (binfo);\n   tree fields = TYPE_FIELDS (type);\n   tree this_vbase_ptr;\n@@ -2400,42 +2302,57 @@ dfs_init_vbase_pointers (binfo)\n     fields = TREE_CHAIN (fields);\n #endif\n \n+  if (BINFO_INHERITANCE_CHAIN (binfo))\n+    {\n+      this_vbase_ptr = TREE_CHAIN (BINFO_INHERITANCE_CHAIN (binfo));\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\tthis_vbase_ptr = CLASSTYPE_SEARCH_SLOT (type);\n+      else\n+\tthis_vbase_ptr = convert_pointer_to_single_level (type,\n+\t\t\t\t\t\t\t  this_vbase_ptr); \n+      TREE_CHAIN (binfo) = this_vbase_ptr;\n+    }\n+  else\n+    this_vbase_ptr = TREE_CHAIN (binfo);\n+\n   if (fields == NULL_TREE\n       || DECL_NAME (fields) == NULL_TREE\n       || ! VBASE_NAME_P (DECL_NAME (fields)))\n-    return;\n-\n-  this_vbase_ptr = vbase_decl_ptr_intermediate;\n+    return NULL_TREE;\n \n-  if (build_pointer_type (type) != TYPE_MAIN_VARIANT (TREE_TYPE (this_vbase_ptr)))\n+  if (build_pointer_type (type) \n+      != TYPE_MAIN_VARIANT (TREE_TYPE (this_vbase_ptr)))\n     my_friendly_abort (125);\n \n-  while (fields && DECL_NAME (fields)\n-\t && VBASE_NAME_P (DECL_NAME (fields)))\n+  while (fields && DECL_NAME (fields) && VBASE_NAME_P (DECL_NAME (fields)))\n     {\n       tree ref = build (COMPONENT_REF, TREE_TYPE (fields),\n \t\t\tbuild_indirect_ref (this_vbase_ptr, NULL_PTR), fields);\n       tree init = CLASSTYPE_SEARCH_SLOT (TREE_TYPE (TREE_TYPE (fields)));\n-      vbase_init_result = tree_cons (binfo_member (TREE_TYPE (TREE_TYPE (fields)),\n-\t\t\t\t\t\t   vbase_types),\n-\t\t\t\t     build_modify_expr (ref, NOP_EXPR, init),\n-\t\t\t\t     vbase_init_result);\n+      vi->inits = tree_cons (binfo_member (TREE_TYPE (TREE_TYPE (fields)),\n+\t\t\t\t\t   vi->vbase_types),\n+\t\t\t     build_modify_expr (ref, NOP_EXPR, init),\n+\t\t\t     vi->inits);\n       fields = TREE_CHAIN (fields);\n     }\n+  \n+  return NULL_TREE;\n }\n \n /* Sometimes this needs to clear both VTABLE_PATH and NEW_VTABLE.  Other\n    times, just NEW_VTABLE, but optimizer should make both with equal\n    efficiency (though it does not currently).  */\n \n-static void\n-dfs_clear_vbase_slots (binfo)\n+static tree\n+dfs_clear_vbase_slots (binfo, data)\n      tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree type = BINFO_TYPE (binfo);\n   CLASSTYPE_SEARCH_SLOT (type) = 0;\n   CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n   CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n+  return NULL_TREE;\n }\n \n tree\n@@ -2445,17 +2362,29 @@ init_vbase_pointers (type, decl_ptr)\n {\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n+      struct vbase_info vi;\n       int old_flag = flag_this_is_variable;\n       tree binfo = TYPE_BINFO (type);\n       flag_this_is_variable = -2;\n-      vbase_types = CLASSTYPE_VBASECLASSES (type);\n-      vbase_decl_ptr = vbase_decl_ptr_intermediate = decl_ptr;\n-      vbase_init_result = NULL_TREE;\n-      dfs_walk (binfo, dfs_find_vbases, unmarked_vtable_pathp);\n-      dfs_walk (binfo, dfs_init_vbase_pointers, marked_vtable_pathp);\n-      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep);\n+\n+      /* Find all the virtual base classes, marking them for later\n+\t initialization.  */\n+      vi.decl_ptr = decl_ptr;\n+      vi.vbase_types = CLASSTYPE_VBASECLASSES (type);\n+      vi.inits = NULL_TREE;\n+\n+      dfs_walk (binfo, dfs_find_vbases, unmarked_vtable_pathp, &vi);\n+\n+      /* Build up a list of the initializers.  */\n+      TREE_CHAIN (binfo) = decl_ptr;\n+      dfs_walk_real (binfo, \n+\t\t     dfs_init_vbase_pointers, 0,\n+\t\t     marked_vtable_pathp,\n+\t\t     &vi);\n+\n+      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, 0);\n       flag_this_is_variable = old_flag;\n-      return vbase_init_result;\n+      return vi.inits;\n     }\n   return 0;\n }\n@@ -2693,10 +2622,7 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n    When USE_COMPUTED_OFFSETS is non-zero, we can assume that the\n    object was laid out by a top-level constructor and the computed\n    offsets are valid to store vtables.  When zero, we must store new\n-   vtables through virtual baseclass pointers.\n-\n-   We setup and use the globals: vbase_decl_ptr, vbase_types\n-   ICK!  */\n+   vtables through virtual baseclass pointers.  */\n \n void\n expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n@@ -2720,17 +2646,19 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n     {\n       rtx fixup_insns = NULL_RTX;\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n-      vbase_types = vbases;\n-      vbase_decl_ptr = true_exp ? build_unary_op (ADDR_EXPR, true_exp, 0) : decl_ptr;\n+      struct vbase_info vi;\n+      vi.decl_ptr = (true_exp ? build_unary_op (ADDR_EXPR, true_exp, 0) \n+\t\t     : decl_ptr);\n+      vi.vbase_types = vbases;\n \n-      dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep);\n+      dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep, &vi);\n \n       /* Initialized with vtables of type TYPE.  */\n       for (; vbases; vbases = TREE_CHAIN (vbases))\n \t{\n \t  tree addr;\n \n-\t  addr = convert_pointer_to_vbase (TREE_TYPE (vbases), vbase_decl_ptr);\n+\t  addr = convert_pointer_to_vbase (TREE_TYPE (vbases), vi.decl_ptr);\n \n \t  /* Do all vtables from this virtual base.  */\n \t  /* This assumes that virtual bases can never serve as parent\n@@ -2755,7 +2683,7 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \t      push_to_sequence (fixup_insns);\n \t      fixup_virtual_upcast_offsets (vbases,\n \t\t\t\t\t    TYPE_BINFO (BINFO_TYPE (vbases)),\n-\t\t\t\t\t    1, 0, addr, vbase_decl_ptr,\n+\t\t\t\t\t    1, 0, addr, vi.decl_ptr,\n \t\t\t\t\t    type, vbases, &vbase_offsets);\n \t      fixup_insns = get_insns ();\n \t      end_sequence ();\n@@ -2777,44 +2705,51 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \t  expand_end_cond ();\n \t}\n \n-      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep);\n+      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, 0);\n     }\n }\n \n /* get virtual base class types.\n    This adds type to the vbase_types list in reverse dfs order.\n    Ordering is very important, so don't change it.  */\n \n-static void\n-dfs_get_vbase_types (binfo)\n+static tree\n+dfs_get_vbase_types (binfo, data)\n      tree binfo;\n+     void *data;\n {\n+  tree *vbase_types = (tree *) data;\n+\n   if (TREE_VIA_VIRTUAL (binfo) && ! BINFO_VBASE_MARKED (binfo))\n     {\n       tree new_vbase = make_binfo (integer_zero_node, binfo,\n \t\t\t\t   BINFO_VTABLE (binfo),\n \t\t\t\t   BINFO_VIRTUALS (binfo));\n-      TREE_CHAIN (new_vbase) = vbase_types;\n+      TREE_CHAIN (new_vbase) = *vbase_types;\n       TREE_VIA_VIRTUAL (new_vbase) = 1;\n-      vbase_types = new_vbase;\n+      *vbase_types = new_vbase;\n       SET_BINFO_VBASE_MARKED (binfo);\n     }\n   SET_BINFO_MARKED (binfo);\n+  return NULL_TREE;\n }\n \n-/* get a list of virtual base classes in dfs order.  */\n+/* Return a list of binfos for the virtual base classes for TYPE, in\n+   depth-first search order.  The list is freshly allocated, so\n+   no modification is made to  the current binfo hierarchy.  */\n \n tree\n get_vbase_types (type)\n      tree type;\n {\n+  tree vbase_types;\n   tree vbases;\n   tree binfo;\n \n   binfo = TYPE_BINFO (type);\n   vbase_types = NULL_TREE;\n-  dfs_walk (binfo, dfs_get_vbase_types, unmarkedp);\n-  dfs_walk (binfo, dfs_unmark, markedp);\n+  dfs_walk (binfo, dfs_get_vbase_types, unmarkedp, &vbase_types);\n+  dfs_walk (binfo, dfs_unmark, markedp, 0);\n   /* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now\n      reverse it so that we get normal dfs ordering.  */\n   vbase_types = nreverse (vbase_types);\n@@ -2852,13 +2787,13 @@ note_debug_info_needed (type)\n   if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n     return;\n \n-  dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp);\n+  dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp, 0);\n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     {\n       tree ttype;\n       if (TREE_CODE (field) == FIELD_DECL\n \t  && IS_AGGR_TYPE (ttype = target_type (TREE_TYPE (field)))\n-\t  && dfs_debug_unmarkedp (TYPE_BINFO (ttype)))\n+\t  && dfs_debug_unmarkedp (TYPE_BINFO (ttype), 0))\n \tnote_debug_info_needed (ttype);\n     }\n }\n@@ -2975,7 +2910,7 @@ dependent_base_p (binfo)\n {\n   for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {\n-      if (TREE_TYPE (binfo) == current_class_type)\n+      if (currently_open_class (TREE_TYPE (binfo)))\n \tbreak;\n       if (uses_template_parms (TREE_TYPE (binfo)))\n \treturn 1;\n@@ -3002,10 +2937,12 @@ dependent_base_p (binfo)\n    Because if it is, it could be a set of overloaded methods from an\n    outer scope.  */\n \n-static void\n-dfs_pushdecls (binfo)\n+static tree\n+dfs_pushdecls (binfo, data)\n      tree binfo;\n+     void *data;\n {\n+  tree *closed_envelopes = (tree *) data;\n   tree type = BINFO_TYPE (binfo);\n   tree fields;\n   tree method_vec;\n@@ -3031,7 +2968,7 @@ dfs_pushdecls (binfo)\n       if (DECL_NAME (fields) == NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (fields)) == UNION_TYPE)\n \t{\n-\t  dfs_pushdecls (TYPE_BINFO (TREE_TYPE (fields)));\n+\t  dfs_pushdecls (TYPE_BINFO (TREE_TYPE (fields)), data);\n \t  continue;\n \t}\n \n@@ -3048,9 +2985,9 @@ dfs_pushdecls (binfo)\n \t      || TREE_CODE (TREE_PURPOSE (class_value)) == IDENTIFIER_NODE)\n \t    {\n \t      /* See comment above for a description of envelopes.  */\n-\t      closed_envelopes = tree_cons (NULL_TREE, class_value,\n-\t\t\t\t\t    closed_envelopes);\n-\t      IDENTIFIER_CLASS_VALUE (name) = closed_envelopes;\n+\t      *closed_envelopes = tree_cons (NULL_TREE, class_value,\n+\t\t\t\t\t     *closed_envelopes);\n+\t      IDENTIFIER_CLASS_VALUE (name) = *closed_envelopes;\n \t      class_value = IDENTIFIER_CLASS_VALUE (name);\n \t    }\n \n@@ -3090,9 +3027,9 @@ dfs_pushdecls (binfo)\n \t      || TREE_CODE (TREE_PURPOSE (class_value)) == IDENTIFIER_NODE)\n \t    {\n \t      /* See comment above for a description of envelopes.  */\n-\t      closed_envelopes = tree_cons (NULL_TREE, class_value,\n-\t\t\t\t\t    closed_envelopes);\n-\t      IDENTIFIER_CLASS_VALUE (name) = closed_envelopes;\n+\t      *closed_envelopes = tree_cons (NULL_TREE, class_value,\n+\t\t\t\t\t     *closed_envelopes);\n+\t      IDENTIFIER_CLASS_VALUE (name) = *closed_envelopes;\n \t      class_value = IDENTIFIER_CLASS_VALUE (name);\n \t    }\n \n@@ -3111,13 +3048,16 @@ dfs_pushdecls (binfo)\n   /* We can't just use BINFO_MARKED because envelope_add_decl uses\n      DERIVED_FROM_P, which calls get_base_distance.  */\n   SET_BINFO_PUSHDECLS_MARKED (binfo);\n+  \n+  return NULL_TREE;\n }\n \n /* Consolidate unique (by name) member functions.  */\n \n-static void\n-dfs_compress_decls (binfo)\n+static tree\n+dfs_compress_decls (binfo, data)\n      tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree type = BINFO_TYPE (binfo);\n   tree method_vec \n@@ -3155,6 +3095,8 @@ dfs_compress_decls (binfo)\n \t}\n     }\n   CLEAR_BINFO_PUSHDECLS_MARKED (binfo);\n+\n+  return NULL_TREE;\n }\n \n /* When entering the scope of a class, we cache all of the\n@@ -3169,6 +3111,7 @@ push_class_decls (type)\n      tree type;\n {\n   struct obstack *ambient_obstack = current_obstack;\n+  tree closed_envelopes = NULL_TREE;\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n   /* Build up all the relevant bindings and such on the cache\n@@ -3177,11 +3120,13 @@ push_class_decls (type)\n   maybe_push_cache_obstack ();\n \n   /* Push class fields into CLASS_VALUE scope, and mark.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_pushdecls, unmarked_pushdecls_p);\n+  dfs_walk (TYPE_BINFO (type), dfs_pushdecls, unmarked_pushdecls_p, \n+\t    &closed_envelopes);\n \n   /* Compress fields which have only a single entry\n      by a given name, and unmark.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_compress_decls, marked_pushdecls_p);\n+  dfs_walk (TYPE_BINFO (type), dfs_compress_decls, marked_pushdecls_p,\n+\t    0);\n \n   /* Open up all the closed envelopes and push the contained decls into\n      class scope.  */\n@@ -3252,9 +3197,10 @@ push_class_decls (type)\n \n /* Here's a subroutine we need because C lacks lambdas.  */\n \n-static void\n-dfs_unuse_fields (binfo)\n+static tree\n+dfs_unuse_fields (binfo, data)\n      tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   tree type = TREE_TYPE (binfo);\n   tree fields;\n@@ -3269,13 +3215,15 @@ dfs_unuse_fields (binfo)\n \t  && TREE_CODE (TREE_TYPE (fields)) == UNION_TYPE)\n \tunuse_fields (TREE_TYPE (fields));\n     }\n+\n+  return NULL_TREE;\n }\n \n void\n unuse_fields (type)\n      tree type;\n {\n-  dfs_walk (TYPE_BINFO (type), dfs_unuse_fields, unmarkedp);\n+  dfs_walk (TYPE_BINFO (type), dfs_unuse_fields, unmarkedp, 0);\n }\n \n void\n@@ -3360,44 +3308,55 @@ lookup_conversions (type)\n   tree conversions = NULL_TREE;\n \n   if (TYPE_SIZE (type))\n-    breadth_first_search (TYPE_BINFO (type), add_conversions,\n-\t\t\t  0, 0, &conversions);\n+    bfs_walk (TYPE_BINFO (type), add_conversions, 0, &conversions);\n \n   for (t = conversions; t; t = TREE_CHAIN (t))\n     IDENTIFIER_MARKED (DECL_NAME (OVL_CURRENT (TREE_VALUE (t)))) = 0;\n \n   return conversions;\n }\n \n+struct overlap_info \n+{\n+  tree compare_type;\n+  int found_overlap;\n+};\n+\n /* Check whether the empty class indicated by EMPTY_BINFO is also present\n    at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */\n \n-static tree compare_type;\n-static int found_overlap;\n-static void\n-dfs_check_overlap (empty_binfo)\n+static tree\n+dfs_check_overlap (empty_binfo, data)\n      tree empty_binfo;\n+     void *data;\n {\n+  struct overlap_info *oi = (struct overlap_info *) data;\n   tree binfo;\n-  for (binfo = TYPE_BINFO (compare_type); ; binfo = BINFO_BASETYPE (binfo, 0))\n+  for (binfo = TYPE_BINFO (oi->compare_type); \n+       ; \n+       binfo = BINFO_BASETYPE (binfo, 0))\n     {\n       if (BINFO_TYPE (binfo) == BINFO_TYPE (empty_binfo))\n \t{\n-\t  found_overlap = 1;\n+\t  oi->found_overlap = 1;\n \t  break;\n \t}\n       else if (BINFO_BASETYPES (binfo) == NULL_TREE)\n \tbreak;\n     }\n+\n+  return NULL_TREE;\n }\n \n /* Trivial function to stop base traversal when we find something.  */\n \n-static int\n-dfs_no_overlap_yet (t)\n-     tree t ATTRIBUTE_UNUSED;\n+static tree\n+dfs_no_overlap_yet (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n-  return found_overlap == 0;\n+  struct overlap_info *oi = (struct overlap_info *) data;\n+  return !oi->found_overlap ? binfo : NULL_TREE;\n }\n \n /* Returns nonzero if EMPTY_TYPE or any of its bases can also be found at\n@@ -3407,34 +3366,63 @@ int\n types_overlap_p (empty_type, next_type)\n      tree empty_type, next_type;\n {\n+  struct overlap_info oi;\n+\n   if (! IS_AGGR_TYPE (next_type))\n     return 0;\n-  compare_type = next_type;\n-  found_overlap = 0;\n-  dfs_walk (TYPE_BINFO (empty_type), dfs_check_overlap, dfs_no_overlap_yet);\n-  return found_overlap;\n+  oi.compare_type = next_type;\n+  oi.found_overlap = 0;\n+  dfs_walk (TYPE_BINFO (empty_type), dfs_check_overlap,\n+\t    dfs_no_overlap_yet, &oi);\n+  return oi.found_overlap;\n+}\n+\n+struct bfv_info {\n+  tree vbases;\n+  tree var;\n+};\n+\n+static tree\n+dfs_bfv_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  struct bfv_info *bfvi = (struct bfv_info *) data;\n+\n+  /* Use the real virtual base class objects, not the placeholders in\n+     the usual hierarchy.  */\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    return binfo_member (BINFO_TYPE (binfo), bfvi->vbases);\n+  \n+  return binfo;\n }\n \n /* Passed to dfs_search by binfo_for_vtable; determine if bvtable comes\n    from BINFO.  */\n \n-static tree bvtable;\n static tree\n-dfs_bfv_helper (binfo)\n+dfs_bfv_helper (binfo, data)\n      tree binfo;\n+     void *data;\n {\n-  if (BINFO_VTABLE (binfo) == bvtable)\n+  struct bfv_info *bfvi = (struct bfv_info *) data;\n+\n+  if (BINFO_VTABLE (binfo) == bfvi->var)\n     return binfo;\n   return NULL_TREE;\n }\n \n-/* Given a vtable VARS, determine which binfo it comes from.  */\n+/* Given a vtable VAR, determine which binfo it comes from.  */\n \n tree\n-binfo_for_vtable (vars)\n-     tree vars;\n+binfo_for_vtable (var)\n+     tree var;\n {\n-  bvtable = vars;\n-  return dfs_search (TYPE_BINFO (DECL_CONTEXT (vars)), dfs_bfv_helper,\n-\t\t     DECL_CONTEXT (vars));\n+  tree type;\n+  struct bfv_info bfvi;\n+\n+  type = DECL_CONTEXT (var);\n+  bfvi.vbases = CLASSTYPE_VBASECLASSES (type);\n+  return dfs_walk_real (TYPE_BINFO (type),\n+\t\t\t0, dfs_bfv_helper, dfs_bfv_queue_p, &bfvi);\n }"}, {"sha": "00c30867cf96703af5a45954e980228991a2fd61", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash11.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -3,8 +3,8 @@\n extern \"C\" void printf (char *, ...);\n \n class A {\n-\tint\ti;\n-\tint\tj;\n+        int\ti; // ERROR - private\n+        int\tj; // ERROR - private\n     public:\n \tint\th;\n \tA() { i=10; j=20; }"}, {"sha": "1738c736297c8c55b6b54bbafdeaec0c77e55c29", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash19.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash19.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -151,8 +151,8 @@ struct __streambuf {\n     char* _gptr;\t \n     char* _egptr;\t \n     char* _eback;\t \n-    char* _pbase;\t \n-    char* _pptr;\t \n+    char* _pbase; // ERROR - inacessible\n+    char* _pptr;  // ERROR - inacessible\t \n     char* _epptr;\t \n     char* _base;\t \n     char* _ebuf;\t "}, {"sha": "8c5c9ad9299d8e3bc15ab4fb8efa7b733134474c", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/enum6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fenum6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fenum6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fenum6.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -2,7 +2,7 @@\n // GROUPS passed enums\n class X {\n   private:\n-    enum E1 {a1, b1};\n+    enum E1 {a1, b1}; // ERROR - private\n   public:\n     enum E2 {a2, b2};\n     };\n@@ -12,5 +12,5 @@ void h(X* p) {\n     int x2 = X::a2;\n \n     X::E1 e1;\n-    int x1 = X::a1;\t\t// Should be rejected, and is.// ERROR - .*\n+    int x1 = X::a1;  // ERROR - within this context\n     }"}, {"sha": "784c16772ea88c841e0311a92f651d197dfbab72", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/visibility1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility1.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -2,7 +2,7 @@\n // GROUPS passed visibility\n class foo {\n protected:\n-  int i;\n+  int i; // ERROR - protected\n };\n \n class bar : public foo {"}, {"sha": "85f47b5f89dada9020e325c0a5f5ab3364be30f2", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/visibility6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility6.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -3,7 +3,7 @@\n class bottom\n {\n public:\n-  int b;\n+  int b; // ERROR - private\n };\n class middle : private bottom\n {"}, {"sha": "2d69e7bcf01fc50e7b907169c1828a1c6366be36", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/visibility8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fvisibility8.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -5,7 +5,7 @@\n class foo\n {\n public:\n-  static int y;\n+  static int y; // ERROR - private\n };\n class foo1 : private foo\n { };"}, {"sha": "676eac1bcc1fe24c1b2d8d3a3cabb067f79be09f", "filename": "gcc/testsuite/g++.old-deja/g++.jason/access17.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess17.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -3,7 +3,7 @@\n \n struct A {\n protected:\n-  int i;\n+  int i;                        // ERROR - private\n   int f ();\t\t\t// ERROR - \n };\n "}, {"sha": "99e0b4565ce057e6dae542c21ba564c671ecab8b", "filename": "gcc/testsuite/g++.old-deja/g++.jason/access23.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Faccess23.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -16,24 +16,24 @@ public:\n   int PUB_A;\n protected:\n   union {\n-    long B;\n-    void *pY;\n+    long B; // ERROR - protected\n+    void *pY; // ERROR - protected\n   } ;\n   union Y {\n     long B;\n     void *pY;\n-  } PRT;\n-  int PRT_A;\n+  } PRT; // ERROR - protected\n+  int PRT_A; // ERROR - protected\n private:\n   union {\n-    long C;\n-    void *pZ;\n+    long C; // ERROR - private\n+    void *pZ; // ERROR - private\n   };\n   union Z {\n-    long C;\n+    long C;  \n     void *pZ;\n-  } PRV;\n-  int PRV_A;\n+  } PRV; // ERROR - private\n+  int PRV_A; // ERROR - private\n };\n \n struct Bar : public Foo {"}, {"sha": "d50b3cdfd9bbc5f0c6d3ac89dbca94f87770ade0", "filename": "gcc/testsuite/g++.old-deja/g++.law/arm14.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm14.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -9,7 +9,7 @@\n \n class X {\n   private:\n-    enum E1 {a1, b1};\n+    enum E1 {a1, b1}; // ERROR - private\n   public:\n     enum E2 {a2, b2};\n     };"}, {"sha": "66c2c665cabd1b18710a80d0612cab0f961ba041", "filename": "gcc/testsuite/g++.old-deja/g++.law/union2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Funion2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Funion2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Funion2.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -10,9 +10,9 @@ class A {\n public:\n   int x;\n private:\n-  int y;\n+  int y;    // ERROR - private\n   union {\n-    int z;\n+    int z;  // ERROR - private\n   };\n };\n "}, {"sha": "3aa6d6b26b86a259a5f7f1ebf91b41c3ddb540e4", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility12.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility12.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -6,7 +6,7 @@\n // Subject:  member access rule bug\n // Message-ID: <9306300528.AA17185@coda.mel.dit.CSIRO.AU>\n struct a {\n-        int aa;\n+  int aa; // ERROR - private\n         };\n \n class b : private a {"}, {"sha": "7f634e20cd87c012154d917fb02d9fe2b30263e6", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility13.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -23,8 +23,8 @@ public:\n     virtual Type& operator[](int ix) { return ia[ix]; }\n private:\n     void init(const Type*, int);\n-    int size;\n-    int *ia;\n+    int size; // ERROR - private\n+    int *ia; // ERROR - private\n };\n \n template <class Type>"}, {"sha": "5291d7c8961e38a8b07f3cc30866c7f0b2150ef2", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility16.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility16.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -7,9 +7,9 @@\n // Message-ID: <9308051553.AA07639@nwd2sun1.analog.com>\n class A {\n   protected:\n-    int astuff;\n+    int astuff; // ERROR - protected\n     A() {\n-        astuff = 3;\n+        astuff = 3; \n     }\n };\n "}, {"sha": "a1ec468f5218fca962abbd2e23c2ed4da3b5b366", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility18.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility18.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -7,7 +7,7 @@\n // Message-ID: <9308061142.AA08533@iiserv>\n struct T1 { int i; };\n \n-struct T2 { int j; };\n+struct T2 { int j; }; // ERROR - private\n \n struct T3 : public T1, private T2 {\n } x;"}, {"sha": "82a1dc5b79ba8b9f63504aa05680d9513a7e22c0", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility19.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility19.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -7,7 +7,7 @@\n // Message-ID: <9308252030.AA02352@tnt.acsys.com>\n class B {\n protected:\n-    int i;\n+    int i; // ERROR - protected\n };\n \n class D1 : public B {"}, {"sha": "2d7079eed2b1ea04786e932cc16226637e6dd56e", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility4.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -8,7 +8,7 @@\n \n class A {\n public:\n-        int b;\n+     int b; // ERROR - private\n };\n \n class C : private A {                   // NOTE WELL. private, not public"}, {"sha": "8b36e8043123777487d4c08b272815960d2d2fde", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility8.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -7,7 +7,7 @@\n // Message-ID: <m0nof3E-0021ifC@jts.com\n class t1 {\n protected:\n-    int a;\n+    int a; // ERROR - protected\n };\n \n "}, {"sha": "4b0ab333be0d90e9cac175c2d5c7c8611b761fc8", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility9.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -8,7 +8,7 @@\n \n class A {\n protected:\n-    int a;\n+    int a; // ERROR - protected\n };\n \n class B : public A {"}, {"sha": "e10f4cfd40ec343d2a9af131a0267486174eccdd", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p8785.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp8785.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp8785.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp8785.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -3,7 +3,7 @@\n \n class Outer {\n private:\n-  int x;\n+  int x; // ERROR - private\n public:\n   struct Inner {\n     int y;"}, {"sha": "2ba2c0c51d67c63a6b0c9ab3a698a4b47ee2f72b", "filename": "gcc/testsuite/g++.old-deja/g++.other/access3.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess3.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -1,10 +1,11 @@\n+// Build don't link:\n // The standard sez that a use of a name gets the most access it can through\n // the various paths that can reach it.  Here, the access decl in B gives\n // us access.\n \n struct A\n {\n-  void f ();\t\t\t// gets bogus error - ref below XFAIL *-*-*\n+  void f ();\t\t\t\n };\n \n struct B: private virtual A\n@@ -21,5 +22,5 @@ main ()\n {\n   C c;\n \n-  c.f ();\t\t\t// gets bogus error - private XFAIL *-*-*\n+  c.f ();\t\t\t\n }"}, {"sha": "75f3a6191a386d667935fd9f81af3a9d52940901", "filename": "gcc/testsuite/g++.old-deja/g++.other/access4.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess4.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+\n+struct A {\n+  static int i;\n+};\n+\n+struct B : private A { };\n+\n+struct C : public B {\n+  int f () { return A::i; }\n+};"}, {"sha": "0d58ea0b3f32f8693c8739424d6f824693376e76", "filename": "gcc/testsuite/g++.old-deja/g++.other/access5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess5.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -0,0 +1,22 @@\n+// Build don't link:\n+\n+class A\n+{\n+protected:\n+  int i;     \n+};\n+\n+class B : private A\n+{\n+protected:\n+  A::i;\n+};\n+\n+struct C : public B {\n+  friend int f(C *p);\n+};\n+\n+int f(C *p) {\n+  return p->i;\n+}\n+"}, {"sha": "7a7c7ff59417502414a999c18f441bee9ab61b5a", "filename": "gcc/testsuite/g++.old-deja/g++.other/access6.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Faccess6.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -0,0 +1,17 @@\n+// Build don't link:\n+\n+template <int I>\n+struct S {\n+  void g();\n+};\n+\n+class C {\n+  static const int i = 3; // gets bogus error - private - XFAIL *-*-*\n+public:\n+  S<C::i>* f(); // gets bogus error - redeclared - XFAIL *-*-*\n+};\n+\n+S<C::i>* C::f() { // gets bogus error - private - XFAIL *-*-*\n+  return 0;\n+}\n+"}, {"sha": "d6574a2b79c9c48d5bd8c33540dcf8d3b6ee4832", "filename": "gcc/testsuite/g++.old-deja/g++.other/ambig1.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fambig1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fambig1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fambig1.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -1,15 +1,15 @@\n // Build don't link:\n \n struct A {\n-  int operator ++();\n-  void operator ()();\n-  void operator delete(void*);\n+  int operator ++(); // ERROR - candidates\n+  void operator ()(); // ERROR - candidates\n+  void operator delete(void*); // ERROR - candidates\n };\n \n struct B {\n-  int operator ++(int);\n-  void operator ()();\n-  void operator delete(void*);\n+  int operator ++(int); // ERROR - candidates\n+  void operator ()(); // ERROR - candidates\n+  void operator delete(void*); // ERROR - candidates\n   void f();\n };\n "}, {"sha": "0f581988b1f6868c89e988a70ece48452da779b8", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash7.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -4,8 +4,8 @@ void f()\n {\n   union {\n   private:\n-    int i;\n+    int i; // ERROR - private\n   } u;\n \n-  u.i = 3; // ERROR - private\n+  u.i = 3; // ERROR - within this context\n }"}, {"sha": "ef90607eaebc355041352a4bd8b9ebad7cbaac47", "filename": "gcc/testsuite/g++.old-deja/g++.other/friend1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend1.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -12,8 +12,8 @@\n \n class B {\n protected:\n-    int i;\n-    static int j;\n+  int i; // ERROR - in this context\n+  static int j; // gets bogus error - XFAIL *-*-*\n };\n \n class D : public B {"}, {"sha": "07969cd54871bd706c014a09ed0e1212161b5450", "filename": "gcc/testsuite/g++.old-deja/g++.other/friend4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend4.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -10,7 +10,7 @@\n \n template <class A, class B> void foo();\n template <class C> class bar {\n-  int i;\n+  int i; // ERROR - private\n   template <class B> friend void foo<C,B>(); // ERROR - bogus declaration\n };\n template <class A, class B> void foo() {"}, {"sha": "737792cab9ff78342122707bd306675a23a9f9a5", "filename": "gcc/testsuite/g++.old-deja/g++.pt/derived2.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fderived2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fderived2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fderived2.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -0,0 +1,35 @@\n+// Build don't link:\n+// Special g++ Options:\n+\n+template <typename T>\n+void f(T);\n+template <>\n+void f(int) {}\n+\n+struct B {\n+  typedef int I;\n+};\n+\n+template <typename T> \n+struct D1 : virtual public B {\n+  typedef T I;\n+};\n+\n+\n+template <typename T> \n+struct D : virtual public B, public D1<T>\n+{\n+  void g()\n+    {\n+      I i;\n+      f(i);\n+    }\n+};\n+\n+int\n+main()\n+{\n+  D<double> d;\n+  d.g();\n+}\n+"}, {"sha": "1aeba3a1018a9dfc72f7989038dac632b7f0bfca", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend11.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -20,7 +20,7 @@ class C\n   template <class U>\n   friend void S<T>::f(U);\n \n-  int i;\n+  int i; // ERROR - private\n };\n \n "}, {"sha": "3f690a4404aa16ed461c183554d960ef446e0c41", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend21.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend21.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -7,7 +7,7 @@ template <class T> struct A {\n template <class T> class B\n {\n   friend class A<T>;\n-  static int i;\n+  static int i; // ERROR - private\n };\n \n template <class T> class C"}, {"sha": "74d0e06699c051df531d7cc298fa137a7e4dfe62", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6479fe772c6ab3191be8268ac658f309675bc28/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend3.C?ref=d6479fe772c6ab3191be8268ac658f309675bc28", "patch": "@@ -7,7 +7,7 @@ class C\n {\n   friend void f<>(double);\n \n-  int i;\n+  int i; // ERROR - private\n };\n \n "}]}