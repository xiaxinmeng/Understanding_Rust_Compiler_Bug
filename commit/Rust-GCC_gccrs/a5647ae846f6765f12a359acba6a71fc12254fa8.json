{"sha": "a5647ae846f6765f12a359acba6a71fc12254fa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2NDdhZTg0NmY2NzY1ZjEyYTM1OWFjYmE2YTcxZmMxMjI1NGZhOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-10T18:56:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-10T18:56:37Z"}, "message": "Replace call_used_reg_set with call_used_or_fixed_regs\n\nCALL_USED_REGISTERS and call_used_regs infamously contain all fixed\nregisters (hence the need for CALL_REALLY_USED_REGISTERS etc.).\nWe try to recover from this to some extent with:\n\n  /* Contains 1 for registers that are set or clobbered by calls.  */\n  /* ??? Ideally, this would be just call_used_regs plus global_regs, but\n     for someone's bright idea to have call_used_regs strictly include\n     fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n     that are actually preserved.  We know for sure that those associated\n     with the local stack frame are safe, but scant others.  */\n  HARD_REG_SET x_regs_invalidated_by_call;\n\nSince global registers are added to fixed_reg_set and call_used_reg_set\ntoo, it's always the case that:\n\n  call_used_reg_set == regs_invalidated_by_call | fixed_reg_set\n\nThis patch replaces all uses of call_used_reg_set with a new macro\ncall_used_or_fixed_regs to make this clearer.\n\nThis is part of a series that allows call_used_regs to be what is\nnow call_really_used_regs.  It's a purely mechanical replacement;\nlater patches clean up obvious oddities like\n\"call_used_or_fixed_regs & ~fixed_regs\".\n\n2019-09-10  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* hard-reg-set.h (target_hard_regs::x_call_used_reg_set): Delete.\n\t(call_used_reg_set): Delete.\n\t(call_used_or_fixed_regs): New macro.\n\t* reginfo.c (init_reg_sets_1, globalize_reg): Remove initialization\n\tof call_used_reg_set.\n\t* caller-save.c (setup_save_areas): Use call_used_or_fixed_regs\n\tinstead of call_used_regs.\n\t(save_call_clobbered_regs): Likewise.\n\t* cfgcleanup.c (old_insns_match_p): Likewise.\n\t* config/c6x/c6x.c (c6x_call_saved_register_used): Likewise.\n\t* config/epiphany/epiphany.c (epiphany_conditional_register_usage):\n\tLikewise.\n\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n\t* config/sh/sh.c (output_stack_adjust): Likewise.\n\t* final.c (collect_fn_hard_reg_usage): Likewise.\n\t* ira-build.c (ira_build): Likewise.\n\t* ira-color.c (calculate_saved_nregs): Likewise.\n\t(allocno_reload_assign, calculate_spill_cost): Likewise.\n\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n\t* ira-costs.c (ira_tune_allocno_costs): Likewise.\n\t* ira-lives.c (process_bb_node_lives): Likewise.\n\t* ira.c (setup_reg_renumber): Likewise.\n\t* lra-assigns.c (find_hard_regno_for_1, lra_assign): Likewise.\n\t* lra-constraints.c (need_for_call_save_p): Likewise.\n\t(need_for_split_p, inherit_in_ebb): Likewise.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* lra-remat.c (call_used_input_regno_present_p): Likewise.\n\t* postreload.c (reload_combine): Likewise.\n\t* regrename.c (find_rename_reg): Likewise.\n\t* reload1.c (reload_as_needed): Likewise.\n\t* rtlanal.c (find_all_hard_reg_sets): Likewise.\n\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n\t* shrink-wrap.c (requires_stack_frame_p): Likewise.\n\nFrom-SVN: r275600", "tree": {"sha": "3ca1e4fc718b6a7523af1797005c2a814c34f8d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ca1e4fc718b6a7523af1797005c2a814c34f8d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5647ae846f6765f12a359acba6a71fc12254fa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5647ae846f6765f12a359acba6a71fc12254fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5647ae846f6765f12a359acba6a71fc12254fa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5647ae846f6765f12a359acba6a71fc12254fa8/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "026116ce2a4dedad81518b0ca89dd8243b545778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/026116ce2a4dedad81518b0ca89dd8243b545778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/026116ce2a4dedad81518b0ca89dd8243b545778"}], "stats": {"total": 134, "additions": 81, "deletions": 53}, "files": [{"sha": "403e8ddbd3af5c84ef3bcb13355bed12104ac59d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1,3 +1,39 @@\n+2019-09-10  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h (target_hard_regs::x_call_used_reg_set): Delete.\n+\t(call_used_reg_set): Delete.\n+\t(call_used_or_fixed_regs): New macro.\n+\t* reginfo.c (init_reg_sets_1, globalize_reg): Remove initialization\n+\tof call_used_reg_set.\n+\t* caller-save.c (setup_save_areas): Use call_used_or_fixed_regs\n+\tinstead of call_used_regs.\n+\t(save_call_clobbered_regs): Likewise.\n+\t* cfgcleanup.c (old_insns_match_p): Likewise.\n+\t* config/c6x/c6x.c (c6x_call_saved_register_used): Likewise.\n+\t* config/epiphany/epiphany.c (epiphany_conditional_register_usage):\n+\tLikewise.\n+\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n+\t* config/sh/sh.c (output_stack_adjust): Likewise.\n+\t* final.c (collect_fn_hard_reg_usage): Likewise.\n+\t* ira-build.c (ira_build): Likewise.\n+\t* ira-color.c (calculate_saved_nregs): Likewise.\n+\t(allocno_reload_assign, calculate_spill_cost): Likewise.\n+\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n+\t* ira-costs.c (ira_tune_allocno_costs): Likewise.\n+\t* ira-lives.c (process_bb_node_lives): Likewise.\n+\t* ira.c (setup_reg_renumber): Likewise.\n+\t* lra-assigns.c (find_hard_regno_for_1, lra_assign): Likewise.\n+\t* lra-constraints.c (need_for_call_save_p): Likewise.\n+\t(need_for_split_p, inherit_in_ebb): Likewise.\n+\t* lra-lives.c (process_bb_lives): Likewise.\n+\t* lra-remat.c (call_used_input_regno_present_p): Likewise.\n+\t* postreload.c (reload_combine): Likewise.\n+\t* regrename.c (find_rename_reg): Likewise.\n+\t* reload1.c (reload_as_needed): Likewise.\n+\t* rtlanal.c (find_all_hard_reg_sets): Likewise.\n+\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n+\t* shrink-wrap.c (requires_stack_frame_p): Likewise.\n+\n 2019-09-10  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* hard-reg-set.h (target_hard_regs::x_no_caller_save_reg_set): Delete."}, {"sha": "b63e5683faeb3dc40075b293b0ff5e79896341fe", "filename": "gcc/caller-save.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -426,7 +426,7 @@ setup_save_areas (void)\n       freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n       REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n \t\t\t       &chain->live_throughout);\n-      get_call_reg_set_usage (insn, &used_regs, call_used_reg_set);\n+      get_call_reg_set_usage (insn, &used_regs, call_used_or_fixed_regs);\n \n       /* Record all registers set in this call insn.  These don't\n \t need to be saved.  N.B. the call insn might set a subreg\n@@ -509,7 +509,7 @@ setup_save_areas (void)\n \n \t  REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n \t\t\t\t   &chain->live_throughout);\n-\t  get_call_reg_set_usage (insn, &used_regs, call_used_reg_set);\n+\t  get_call_reg_set_usage (insn, &used_regs, call_used_or_fixed_regs);\n \n \t  /* Record all registers set in this call insn.  These don't\n \t     need to be saved.  N.B. the call insn might set a subreg\n@@ -839,7 +839,7 @@ save_call_clobbered_regs (void)\n \t\t\t\t     | hard_regs_saved);\n \t      hard_regs_to_save &= savable_regs;\n \t      get_call_reg_set_usage (insn, &call_def_reg_set,\n-\t\t\t\t      call_used_reg_set);\n+\t\t\t\t      call_used_or_fixed_regs);\n \t      hard_regs_to_save &= call_def_reg_set;\n \n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n@@ -855,7 +855,8 @@ save_call_clobbered_regs (void)\n \t      \n \t      if (cheap\n \t\t  && HARD_REGISTER_P (cheap)\n-\t\t  && TEST_HARD_REG_BIT (call_used_reg_set, REGNO (cheap)))\n+\t\t  && TEST_HARD_REG_BIT (call_used_or_fixed_regs,\n+\t\t\t\t\tREGNO (cheap)))\n \t\t{\n \t\t  rtx dest, newpat;\n \t\t  rtx pat = PATTERN (insn);"}, {"sha": "17fa1de68efae8c662007f1b06c4928e42311f26", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1228,8 +1228,8 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx_insn *i1, rtx_insn *i2)\n \n       HARD_REG_SET i1_used, i2_used;\n \n-      get_call_reg_set_usage (i1, &i1_used, call_used_reg_set);\n-      get_call_reg_set_usage (i2, &i2_used, call_used_reg_set);\n+      get_call_reg_set_usage (i1, &i1_used, call_used_or_fixed_regs);\n+      get_call_reg_set_usage (i2, &i2_used, call_used_or_fixed_regs);\n \n       if (i1_used != i2_used)\n         return dir_none;"}, {"sha": "f7f0dbc3063bebab1c5690618e5d2c1b1f88604c", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1094,7 +1094,7 @@ c6x_call_saved_register_used (tree call_expr)\n   INIT_CUMULATIVE_ARGS (cum_v, NULL, NULL, 0, 0);\n   cum = pack_cumulative_args (&cum_v);\n \n-  call_saved_regset = ~call_used_reg_set;\n+  call_saved_regset = ~call_used_or_fixed_regs;\n   for (i = 0; i < call_expr_nargs (call_expr); i++)\n     {\n       parameter = CALL_EXPR_ARG (call_expr, i);"}, {"sha": "d8b1cee69ddca436be14c74edb043d124e6dfc56", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -2242,7 +2242,7 @@ epiphany_conditional_register_usage (void)\n     CLEAR_HARD_REG_SET (reg_class_contents[SHORT_INSN_REGS]);\n   reg_class_contents[SIBCALL_REGS] = reg_class_contents[GENERAL_REGS];\n   /* It would be simpler and quicker if we could just use\n-     &~, alas, call_used_reg_set is yet uninitialized;\n+     &~, alas, call_used_or_fixed_regs is yet uninitialized;\n      it is set up later by our caller.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (!call_used_regs[i])"}, {"sha": "90c062bed191a202ca43ec379ad7ba7f55ad6b6e", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -5201,7 +5201,7 @@ frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n      not fixed.  However, allow the ICC/ICR temporary registers to be allocated\n      if we did not need to use them in reloading other registers.  */\n   memset (&tmp_reg->regs, 0, sizeof (tmp_reg->regs));\n-  tmp_reg->regs = call_used_reg_set &~ fixed_reg_set;\n+  tmp_reg->regs = call_used_or_fixed_regs &~ fixed_reg_set;\n   SET_HARD_REG_BIT (tmp_reg->regs, ICC_TEMP);\n   SET_HARD_REG_BIT (tmp_reg->regs, ICR_TEMP);\n "}, {"sha": "fd23fb03c724fc77748f4cdcfda765ff7e7920bd", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -6707,7 +6707,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t    temp = -1;\n \t  if (temp < 0 && ! current_function_interrupt && epilogue_p >= 0)\n \t    {\n-\t      HARD_REG_SET temps = (call_used_reg_set\n+\t      HARD_REG_SET temps = (call_used_or_fixed_regs\n \t\t\t\t    & ~fixed_reg_set\n \t\t\t\t    & savable_regs);\n \t      if (epilogue_p > 0)"}, {"sha": "ae8ff22894fb239800f1b12b10a0e95155ee4ef3", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -5007,7 +5007,7 @@ collect_fn_hard_reg_usage (void)\n \t  && !self_recursive_call_p (insn))\n \t{\n \t  if (!get_call_reg_set_usage (insn, &insn_used_regs,\n-\t\t\t\t       call_used_reg_set))\n+\t\t\t\t       call_used_or_fixed_regs))\n \t    return;\n \n \t  function_used_regs |= insn_used_regs;\n@@ -5030,7 +5030,7 @@ collect_fn_hard_reg_usage (void)\n \n   /* The information we have gathered is only interesting if it exposes a\n      register from the call_used_regs that is not used in this function.  */\n-  if (hard_reg_set_subset_p (call_used_reg_set, function_used_regs))\n+  if (hard_reg_set_subset_p (call_used_or_fixed_regs, function_used_regs))\n     return;\n \n   node = cgraph_node::rtl_info (current_function_decl);"}, {"sha": "33ac640d2095c628b2e6abad45d24cbfa3746338", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -397,9 +397,6 @@ struct target_hard_regs {\n \n   char x_call_really_used_regs[FIRST_PSEUDO_REGISTER];\n \n-  /* The same info as a HARD_REG_SET.  */\n-  HARD_REG_SET x_call_used_reg_set;\n-\n   /* For targets that use reload rather than LRA, this is the set\n      of registers that we are able to save and restore around calls\n      (i.e. those for which we know a suitable mode and set of\n@@ -480,12 +477,12 @@ extern struct target_hard_regs *this_target_hard_regs;\n   (this_target_hard_regs->x_call_used_regs)\n #define call_really_used_regs \\\n   (this_target_hard_regs->x_call_really_used_regs)\n-#define call_used_reg_set \\\n-  (this_target_hard_regs->x_call_used_reg_set)\n #define savable_regs \\\n   (this_target_hard_regs->x_savable_regs)\n #define regs_invalidated_by_call \\\n   (this_target_hard_regs->x_regs_invalidated_by_call)\n+#define call_used_or_fixed_regs \\\n+  (regs_invalidated_by_call | fixed_reg_set)\n #define reg_alloc_order \\\n   (this_target_hard_regs->x_reg_alloc_order)\n #define inv_reg_alloc_order \\"}, {"sha": "b5e693333b08352bf9d06261c183d124dd91721b", "filename": "gcc/ira-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -3462,7 +3462,7 @@ ira_build (void)\n \t allocno crossing calls.  */\n       FOR_EACH_ALLOCNO (a, ai)\n \tif (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\t  ior_hard_reg_conflicts (a, call_used_reg_set);\n+\t  ior_hard_reg_conflicts (a, call_used_or_fixed_regs);\n     }\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     print_copies (ira_dump_file);"}, {"sha": "505d5c8ffb36c7d4c304a7371a43983c5afe8bcf", "filename": "gcc/ira-color.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1650,7 +1650,7 @@ calculate_saved_nregs (int hard_regno, machine_mode mode)\n   ira_assert (hard_regno >= 0);\n   for (i = hard_regno_nregs (hard_regno, mode) - 1; i >= 0; i--)\n     if (!allocated_hardreg_p[hard_regno + i]\n-\t&& !TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + i)\n+\t&& !TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno + i)\n \t&& !LOCAL_REGNO (hard_regno + i))\n       nregs++;\n   return nregs;\n@@ -4379,7 +4379,7 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n       saved[i] = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n       OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= forbidden_regs;\n       if (! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_reg_set;\n+\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_or_fixed_regs;\n     }\n   ALLOCNO_ASSIGNED_P (a) = false;\n   aclass = ALLOCNO_CLASS (a);\n@@ -4400,7 +4400,7 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n \t\t\t\t\t    [aclass][hard_regno]]));\n       if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n \t  && ira_hard_reg_set_intersection_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t      call_used_reg_set))\n+\t\t\t\t\t      call_used_or_fixed_regs))\n \t{\n \t  ira_assert (flag_caller_saves);\n \t  caller_save_needed = 1;\n@@ -4715,7 +4715,7 @@ calculate_spill_cost (int *regnos, rtx in, rtx out, rtx_insn *insn,\n       cost += ALLOCNO_MEMORY_COST (a) - ALLOCNO_CLASS_COST (a);\n       nregs = hard_regno_nregs (hard_regno, ALLOCNO_MODE (a));\n       for (j = 0; j < nregs; j++)\n-\tif (! TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + j))\n+\tif (! TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno + j))\n \t  break;\n       if (j == nregs)\n \tcount++;"}, {"sha": "afbc2ec0d52066af6bc9991d9f48a83e74b3d1ef", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -740,7 +740,7 @@ ira_build_conflicts (void)\n   else\n     temp_hard_reg_set = (reg_class_contents[base]\n \t\t\t & ~ira_no_alloc_regs\n-\t\t\t & call_used_reg_set);\n+\t\t\t & call_used_or_fixed_regs);\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       int i, n = ALLOCNO_NUM_OBJECTS (a);\n@@ -760,13 +760,13 @@ ira_build_conflicts (void)\n \t\t  && REG_USERVAR_P (allocno_reg)\n \t\t  && ! reg_is_parm_p (allocno_reg)))\n \t    {\n-\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_reg_set;\n-\t      OBJECT_CONFLICT_HARD_REGS (obj) |= call_used_reg_set;\n+\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_or_fixed_regs;\n+\t      OBJECT_CONFLICT_HARD_REGS (obj) |= call_used_or_fixed_regs;\n \t    }\n \t  else if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \t    {\n \t      HARD_REG_SET no_caller_save_reg_set\n-\t\t= (call_used_reg_set & ~savable_regs);\n+\t\t= (call_used_or_fixed_regs & ~savable_regs);\n \t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= no_caller_save_reg_set;\n \t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= temp_hard_reg_set;\n \t      OBJECT_CONFLICT_HARD_REGS (obj) |= no_caller_save_reg_set;\n@@ -805,7 +805,7 @@ ira_build_conflicts (void)\n \t      /* Allocnos bigger than the saved part of call saved\n \t\t regs must conflict with them.  */\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif (!TEST_HARD_REG_BIT (call_used_reg_set, regno)\n+\t\tif (!TEST_HARD_REG_BIT (call_used_or_fixed_regs, regno)\n \t\t    && targetm.hard_regno_call_part_clobbered (NULL, regno,\n \t\t\t\t\t\t\t       obj_mode))\n \t\t  {"}, {"sha": "aefec08da548475c0509a70afdca8eb3b4e2a97d", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -2380,7 +2380,7 @@ ira_tune_allocno_costs (void)\n \t      if (ira_hard_reg_set_intersection_p (regno, mode,\n \t\t\t\t\t\t   *crossed_calls_clobber_regs)\n \t\t  && (ira_hard_reg_set_intersection_p (regno, mode,\n-\t\t\t\t\t\t       call_used_reg_set)\n+\t\t\t\t\t\t       call_used_or_fixed_regs)\n \t\t      || targetm.hard_regno_call_part_clobbered (NULL, regno,\n \t\t\t\t\t\t\t\t mode)))\n \t\tcost += (ALLOCNO_CALL_FREQ (a)"}, {"sha": "eb7eb0f5777ec114b9b460522041bbc9dc1fbb83", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1257,7 +1257,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  HARD_REG_SET this_call_used_reg_set;\n \n \t\t  get_call_reg_set_usage (insn, &this_call_used_reg_set,\n-\t\t\t\t\t  call_used_reg_set);\n+\t\t\t\t\t  call_used_or_fixed_regs);\n \n \t\t  /* Don't allocate allocnos that cross setjmps or any\n \t\t     call, if this function receives a nonlocal"}, {"sha": "b44647fcc14a4f333bf3190bea2e3bf6550e3f51", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -2370,7 +2370,7 @@ setup_reg_renumber (void)\n \t    }\n \t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n \t      && ira_hard_reg_set_intersection_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t\t  call_used_reg_set))\n+\t\t\t\t\t\t  call_used_or_fixed_regs))\n \t    {\n \t      ira_assert (!optimize || flag_caller_saves\n \t\t\t  || (ALLOCNO_CALLS_CROSSED_NUM (a)"}, {"sha": "014fb49624b54c4c7340bd048c556f49b33d0ecb", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -654,7 +654,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \t  for (j = 0;\n \t       j < hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno));\n \t       j++)\n-\t    if (! TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + j)\n+\t    if (! TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno + j)\n \t\t&& ! df_regs_ever_live_p (hard_regno + j))\n \t      /* It needs save restore.\t */\n \t      hard_regno_costs[hard_regno]\n@@ -1641,7 +1641,7 @@ lra_assign (bool &fails_p)\n     for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n       if (lra_reg_info[i].nrefs != 0 && reg_renumber[i] >= 0\n \t  && lra_reg_info[i].call_insn\n-\t  && overlaps_hard_reg_set_p (call_used_reg_set,\n+\t  && overlaps_hard_reg_set_p (call_used_or_fixed_regs,\n \t\t\t\t      PSEUDO_REGNO_MODE (i), reg_renumber[i]))\n \tgcc_unreachable ();\n   /* Setup insns to process on the next constraint pass.  */"}, {"sha": "a60bc6cc3f9f8d2373c3b59713dc9a26bcb9fbc3", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -5439,7 +5439,7 @@ need_for_call_save_p (int regno)\n \t      ((flag_ipa_ra &&\n \t\t! hard_reg_set_empty_p (lra_reg_info[regno].actual_call_used_reg_set))\n \t       ? lra_reg_info[regno].actual_call_used_reg_set\n-\t       : call_used_reg_set,\n+\t       : call_used_or_fixed_regs,\n \t       PSEUDO_REGNO_MODE (regno), reg_renumber[regno])\n \t      || (targetm.hard_regno_call_part_clobbered\n \t\t  (lra_reg_info[regno].call_insn,\n@@ -5483,7 +5483,7 @@ need_for_split_p (HARD_REG_SET potential_reload_hard_regs, int regno)\n \t      true) the assign pass assumes that all pseudos living\n \t      through calls are assigned to call saved hard regs.  */\n \t   && (regno >= FIRST_PSEUDO_REGISTER\n-\t       || ! TEST_HARD_REG_BIT (call_used_reg_set, regno)\n+\t       || ! TEST_HARD_REG_BIT (call_used_or_fixed_regs, regno)\n \t       || usage_insns[regno].calls_num == calls_num)\n \t   /* We need at least 2 reloads to make pseudo splitting\n \t      profitable.  We should provide hard regno splitting in\n@@ -6458,7 +6458,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t  /* If there are pending saves/restores, the\n \t\t     optimization is not worth.\t */\n \t\t  && usage_insns[regno].calls_num == calls_num - 1\n-\t\t  && TEST_HARD_REG_BIT (call_used_reg_set, hard_regno))\n+\t\t  && TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno))\n \t\t{\n \t\t  /* Restore the pseudo from the call result as\n \t\t     REG_RETURNED note says that the pseudo value is"}, {"sha": "e509cc3b85ed38f034c95640737048e54c1b2fce", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -928,12 +928,12 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t{\n \t  call_insn = curr_insn;\n \t  if (! flag_ipa_ra && ! targetm.return_call_with_max_clobbers)\n-\t    last_call_used_reg_set = call_used_reg_set;\n+\t    last_call_used_reg_set = call_used_or_fixed_regs;\n \t  else\n \t    {\n \t      HARD_REG_SET this_call_used_reg_set;\n \t      get_call_reg_set_usage (curr_insn, &this_call_used_reg_set,\n-\t\t\t\t      call_used_reg_set);\n+\t\t\t\t      call_used_or_fixed_regs);\n \n \t      bool flush = (! hard_reg_set_empty_p (last_call_used_reg_set)\n \t\t\t    && (last_call_used_reg_set"}, {"sha": "18c0a6a17d81acc19a7c92e452444d4875eb0101", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -69,9 +69,9 @@ along with GCC; see the file COPYING3.\tIf not see\n /* Number of candidates for rematerialization.  */\n static unsigned int cands_num;\n \n-/* The following is used for representation of call_used_reg_set in\n+/* The following is used for representation of call_used_or_fixed_regs in\n    form array whose elements are hard register numbers with nonzero bit\n-   in CALL_USED_REG_SET. */\n+   in CALL_USED_OR_FIXED_REGS. */\n static int call_used_regs_arr_len;\n static int call_used_regs_arr[FIRST_PSEUDO_REGISTER];\n \n@@ -710,7 +710,7 @@ call_used_input_regno_present_p (rtx_insn *insn)\n \t reg != NULL;\n \t reg = reg->next)\n       if (reg->type == OP_IN && reg->regno < FIRST_PSEUDO_REGISTER\n-\t  && TEST_HARD_REG_BIT (call_used_reg_set, reg->regno))\n+\t  && TEST_HARD_REG_BIT (call_used_or_fixed_regs, reg->regno))\n \treturn true;\n   return false;\n }"}, {"sha": "af64defb972d1f9c3d9fa5fe7c352cb53672fe4a", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1332,7 +1332,7 @@ reload_combine (void)\n \t  rtx link;\n \t  HARD_REG_SET used_regs;\n \n-\t  get_call_reg_set_usage (insn, &used_regs, call_used_reg_set);\n+\t  get_call_reg_set_usage (insn, &used_regs, call_used_or_fixed_regs);\n \n \t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n \t    if (TEST_HARD_REG_BIT (used_regs, r))"}, {"sha": "026a7bfff749a7b001a508a8e5ea1498b5657012", "filename": "gcc/reginfo.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -350,7 +350,6 @@ init_reg_sets_1 (void)\n   /* Initialize \"constant\" tables.  */\n \n   CLEAR_HARD_REG_SET (fixed_reg_set);\n-  CLEAR_HARD_REG_SET (call_used_reg_set);\n   CLEAR_HARD_REG_SET (regs_invalidated_by_call);\n \n   operand_reg_set &= accessible_reg_set;\n@@ -384,9 +383,6 @@ init_reg_sets_1 (void)\n       if (fixed_regs[i])\n \tSET_HARD_REG_BIT (fixed_reg_set, i);\n \n-      if (call_used_regs[i])\n-\tSET_HARD_REG_BIT (call_used_reg_set, i);\n-\n       /* There are a couple of fixed registers that we know are safe to\n \t exclude from being clobbered by calls:\n \n@@ -426,7 +422,6 @@ init_reg_sets_1 (void)\n \t{\n \t  fixed_regs[i] = call_used_regs[i] = 1;\n \t  SET_HARD_REG_BIT (fixed_reg_set, i);\n-\t  SET_HARD_REG_BIT (call_used_reg_set, i);\n \t}\n     }\n \n@@ -779,7 +774,6 @@ globalize_reg (tree decl, int i)\n #endif\n \n   SET_HARD_REG_BIT (fixed_reg_set, i);\n-  SET_HARD_REG_BIT (call_used_reg_set, i);\n \n   reinit_regs ();\n }"}, {"sha": "47d8224fe1839352fdeb840b893954531a951fb8", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -367,7 +367,7 @@ find_rename_reg (du_head_p this_head, enum reg_class super_class,\n      If the chain needs a call-saved register, mark the call-used\n      registers as unavailable.  */\n   if (this_head->need_caller_save_reg)\n-    *unavailable |= call_used_reg_set;\n+    *unavailable |= call_used_or_fixed_regs;\n \n   /* Mark registers that overlap this chain's lifetime as unavailable.  */\n   merge_overlapping_regs (unavailable, this_head);"}, {"sha": "8234e1e5b8c5742147db05e6d300a6dfff6febb6", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -4784,7 +4784,7 @@ reload_as_needed (int live_known)\n          be partially clobbered by the call.  */\n       else if (CALL_P (insn))\n \t{\n-\t  reg_reloaded_valid &= ~(call_used_reg_set\n+\t  reg_reloaded_valid &= ~(call_used_or_fixed_regs\n \t\t\t\t  | reg_reloaded_call_part_clobbered);\n \n \t  /* If this is a call to a setjmp-type function, we must not"}, {"sha": "1fbbeda88b26d5a8540ab7d7e785fe1fa8c4b993", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1477,7 +1477,7 @@ find_all_hard_reg_sets (const rtx_insn *insn, HARD_REG_SET *pset, bool implicit)\n   CLEAR_HARD_REG_SET (*pset);\n   note_stores (insn, record_hard_reg_sets, pset);\n   if (CALL_P (insn) && implicit)\n-    *pset |= call_used_reg_set;\n+    *pset |= call_used_or_fixed_regs;\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     if (REG_NOTE_KIND (link) == REG_INC)\n       record_hard_reg_sets (XEXP (link, 0), NULL, pset);"}, {"sha": "e515b1b5e7c5bf581d06ed7012ebf584230f5203", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -1224,10 +1224,10 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n     reg_rename_p->unavailable_hard_regs |= sel_hrd.stack_regs;\n #endif\n \n-  /* If there's a call on this path, make regs from call_used_reg_set\n+  /* If there's a call on this path, make regs from call_used_or_fixed_regs\n      unavailable.  */\n   if (def->crosses_call)\n-    reg_rename_p->unavailable_hard_regs |= call_used_reg_set;\n+    reg_rename_p->unavailable_hard_regs |= call_used_or_fixed_regs;\n \n   /* Stop here before reload: we need FRAME_REGS, STACK_REGS, and crosses_call,\n      but not register classes.  */"}, {"sha": "018696637647f9b2d4e5042cc55e80988e9adb66", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5647ae846f6765f12a359acba6a71fc12254fa8/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=a5647ae846f6765f12a359acba6a71fc12254fa8", "patch": "@@ -76,7 +76,7 @@ requires_stack_frame_p (rtx_insn *insn, HARD_REG_SET prologue_used,\n     }\n   if (hard_reg_set_intersect_p (hardregs, prologue_used))\n     return true;\n-  hardregs &= ~call_used_reg_set;\n+  hardregs &= ~call_used_or_fixed_regs;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (TEST_HARD_REG_BIT (hardregs, regno)\n \t&& df_regs_ever_live_p (regno))"}]}