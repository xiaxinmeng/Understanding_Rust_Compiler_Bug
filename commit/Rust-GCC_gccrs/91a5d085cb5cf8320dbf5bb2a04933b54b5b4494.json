{"sha": "91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "node_id": "C_kwDOANBUbNoAKDkxYTVkMDg1Y2I1Y2Y4MzIwZGJmNWJiMmEwNDkzM2I1NGI1YjQ0OTQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-14T13:34:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-15T22:38:46Z"}, "message": "Refactor CallExpr and MethodCallExpr into rust-compile-expr.cc", "tree": {"sha": "912bb533fb22cd2f877b6874422b0d1a98b25d41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/912bb533fb22cd2f877b6874422b0d1a98b25d41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "310968874db1902084012cf767ad0b6e93f028c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310968874db1902084012cf767ad0b6e93f028c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310968874db1902084012cf767ad0b6e93f028c2"}], "stats": {"total": 526, "additions": 262, "deletions": 264}, "files": [{"sha": "7c8aa29e24c6283f80fb427a5824cd32470861ba", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "patch": "@@ -154,6 +154,268 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n \t\t\t\t\t\tknown_valid, expr.get_locus ());\n }\n \n+void\n+CompileExpr::visit (HIR::CallExpr &expr)\n+{\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_fnexpr ()->get_mappings ().get_hirid (), &tyty))\n+    {\n+      rust_error_at (expr.get_locus (), \"unknown type\");\n+      return;\n+    }\n+\n+  // must be a tuple constructor\n+  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  if (!is_fn)\n+    {\n+      rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+      auto variant = adt->get_variants ().at (0);\n+\n+      // this assumes all fields are in order from type resolution and if a\n+      // base struct was specified those fields are filed via accesors\n+      std::vector<tree> vals;\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+\t{\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  auto respective_field = variant->get_field_at_index (i);\n+\t  auto expected = respective_field->get_field_type ();\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  vals.push_back (rvalue);\n+\t}\n+\n+      translated\n+\t= ctx->get_backend ()->constructor_expression (compiled_adt_type, vals,\n+\t\t\t\t\t\t       -1, expr.get_locus ());\n+    }\n+  else\n+    {\n+      auto get_parameter_tyty_at_index\n+\t= [] (const TyTy::BaseType *base, size_t index,\n+\t      TyTy::BaseType **result) -> bool {\n+\tbool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t     || base->get_kind () == TyTy::TypeKind::FNPTR;\n+\trust_assert (is_fn);\n+\n+\tif (base->get_kind () == TyTy::TypeKind::FNPTR)\n+\t  {\n+\t    const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n+\t    *result = fn->param_at (index);\n+\n+\t    return true;\n+\t  }\n+\n+\tconst TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n+\tauto param = fn->param_at (index);\n+\t*result = param.second;\n+\n+\treturn true;\n+      };\n+\n+      bool is_varadic = false;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  is_varadic = fn->is_varadic ();\n+\t}\n+\n+      size_t required_num_args;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n+      else\n+\t{\n+\t  const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n+\n+      std::vector<tree> args;\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+\t{\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  if (is_varadic && i >= required_num_args)\n+\t    {\n+\t      args.push_back (rvalue);\n+\t      continue;\n+\t    }\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  bool ok;\n+\t  TyTy::BaseType *expected = nullptr;\n+\t  ok = get_parameter_tyty_at_index (tyty, i, &expected);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  args.push_back (rvalue);\n+\t}\n+\n+      // must be a call to a function\n+      auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+      auto fncontext = ctx->peek_fn ();\n+      translated\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n+\t\t\t\t\t\targs, nullptr,\n+\t\t\t\t\t\texpr.get_locus ());\n+    }\n+}\n+\n+void\n+CompileExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  // method receiver\n+  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n+      return;\n+    }\n+\n+  // reverse lookup\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // lookup the expected function type\n+  TyTy::BaseType *lookup_fntype = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    expr.get_method_name ().get_mappings ().get_hirid (), &lookup_fntype);\n+  rust_assert (ok);\n+  rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      for (auto &arg : expr.get_arguments ())\n+\targuments.push_back (arg.get ());\n+\n+      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n+\t\t\t\t\t      arguments, expr.get_locus ());\n+      return;\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathExprSegment method_name = expr.get_method_name ();\n+  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n+  tree fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self = ctx->get_backend ()->address_expression (\n+\t    self, expr.get_receiver ()->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  tree expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self = ctx->get_backend ()->indirect_expression (\n+\t    expected_type, self, true, /* known_valid*/\n+\t    expr.get_receiver ()->get_locus ());\n+\t  break;\n+\t}\n+    }\n+\n+  std::vector<tree> args;\n+  args.push_back (self); // adjusted self\n+\n+  // normal args\n+  for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+    {\n+      auto &argument = expr.get_arguments ().at (i);\n+      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+      // assignments are coercion sites so lets convert the rvalue if\n+      // necessary, offset from the already adjusted implicit self\n+      bool ok;\n+      TyTy::BaseType *expected = fntype->param_at (i + 1).second;\n+\n+      TyTy::BaseType *actual = nullptr;\n+      ok = ctx->get_tyctx ()->lookup_type (\n+\targument->get_mappings ().get_hirid (), &actual);\n+      rust_assert (ok);\n+\n+      // coerce it if required\n+      rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+      // add it to the list\n+      args.push_back (rvalue);\n+    }\n+\n+  auto fncontext = ctx->peek_fn ();\n+  translated\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t    nullptr, expr.get_locus ());\n+}\n+\n tree\n CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\tTyTy::BaseType *receiver,"}, {"sha": "ac3be3bd1809e193cf9bb30cdcfce4259418837d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91a5d085cb5cf8320dbf5bb2a04933b54b5b4494/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=91a5d085cb5cf8320dbf5bb2a04933b54b5b4494", "patch": "@@ -52,270 +52,6 @@ CompileCrate::go ()\n     CompileItem::compile (item.get (), ctx, true);\n }\n \n-// rust-compile-expr.h\n-\n-void\n-CompileExpr::visit (HIR::CallExpr &expr)\n-{\n-  TyTy::BaseType *tyty = nullptr;\n-  if (!ctx->get_tyctx ()->lookup_type (\n-\texpr.get_fnexpr ()->get_mappings ().get_hirid (), &tyty))\n-    {\n-      rust_error_at (expr.get_locus (), \"unknown type\");\n-      return;\n-    }\n-\n-  // must be a tuple constructor\n-  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  if (!is_fn)\n-    {\n-      rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n-      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n-      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n-\n-      rust_assert (!adt->is_enum ());\n-      rust_assert (adt->number_of_variants () == 1);\n-      auto variant = adt->get_variants ().at (0);\n-\n-      // this assumes all fields are in order from type resolution and if a\n-      // base struct was specified those fields are filed via accesors\n-      std::vector<tree> vals;\n-      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n-\t{\n-\t  auto &argument = expr.get_arguments ().at (i);\n-\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n-\n-\t  // assignments are coercion sites so lets convert the rvalue if\n-\t  // necessary\n-\t  auto respective_field = variant->get_field_at_index (i);\n-\t  auto expected = respective_field->get_field_type ();\n-\n-\t  TyTy::BaseType *actual = nullptr;\n-\t  bool ok = ctx->get_tyctx ()->lookup_type (\n-\t    argument->get_mappings ().get_hirid (), &actual);\n-\t  rust_assert (ok);\n-\n-\t  // coerce it if required\n-\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n-\n-\t  // add it to the list\n-\t  vals.push_back (rvalue);\n-\t}\n-\n-      translated\n-\t= ctx->get_backend ()->constructor_expression (compiled_adt_type, vals,\n-\t\t\t\t\t\t       -1, expr.get_locus ());\n-    }\n-  else\n-    {\n-      auto get_parameter_tyty_at_index\n-\t= [] (const TyTy::BaseType *base, size_t index,\n-\t      TyTy::BaseType **result) -> bool {\n-\tbool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n-\t\t     || base->get_kind () == TyTy::TypeKind::FNPTR;\n-\trust_assert (is_fn);\n-\n-\tif (base->get_kind () == TyTy::TypeKind::FNPTR)\n-\t  {\n-\t    const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n-\t    *result = fn->param_at (index);\n-\n-\t    return true;\n-\t  }\n-\n-\tconst TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n-\tauto param = fn->param_at (index);\n-\t*result = param.second;\n-\n-\treturn true;\n-      };\n-\n-      bool is_varadic = false;\n-      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-\t{\n-\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n-\t  is_varadic = fn->is_varadic ();\n-\t}\n-\n-      size_t required_num_args;\n-      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-\t{\n-\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n-\t  required_num_args = fn->num_params ();\n-\t}\n-      else\n-\t{\n-\t  const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n-\t  required_num_args = fn->num_params ();\n-\t}\n-\n-      std::vector<tree> args;\n-      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n-\t{\n-\t  auto &argument = expr.get_arguments ().at (i);\n-\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n-\n-\t  if (is_varadic && i >= required_num_args)\n-\t    {\n-\t      args.push_back (rvalue);\n-\t      continue;\n-\t    }\n-\n-\t  // assignments are coercion sites so lets convert the rvalue if\n-\t  // necessary\n-\t  bool ok;\n-\t  TyTy::BaseType *expected = nullptr;\n-\t  ok = get_parameter_tyty_at_index (tyty, i, &expected);\n-\t  rust_assert (ok);\n-\n-\t  TyTy::BaseType *actual = nullptr;\n-\t  ok = ctx->get_tyctx ()->lookup_type (\n-\t    argument->get_mappings ().get_hirid (), &actual);\n-\t  rust_assert (ok);\n-\n-\t  // coerce it if required\n-\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n-\n-\t  // add it to the list\n-\t  args.push_back (rvalue);\n-\t}\n-\n-      // must be a call to a function\n-      auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n-      auto fncontext = ctx->peek_fn ();\n-      translated\n-\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n-\t\t\t\t\t\targs, nullptr,\n-\t\t\t\t\t\texpr.get_locus ());\n-    }\n-}\n-\n-void\n-CompileExpr::visit (HIR::MethodCallExpr &expr)\n-{\n-  // method receiver\n-  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n-\n-  // lookup the resolved name\n-  NodeId resolved_node_id = UNKNOWN_NODEID;\n-  if (!ctx->get_resolver ()->lookup_resolved_name (\n-\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n-    {\n-      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n-      return;\n-    }\n-\n-  // reverse lookup\n-  HirId ref;\n-  if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n-      return;\n-    }\n-\n-  // lookup the expected function type\n-  TyTy::BaseType *lookup_fntype = nullptr;\n-  bool ok = ctx->get_tyctx ()->lookup_type (\n-    expr.get_method_name ().get_mappings ().get_hirid (), &lookup_fntype);\n-  rust_assert (ok);\n-  rust_assert (lookup_fntype->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup_fntype);\n-\n-  TyTy::BaseType *receiver = nullptr;\n-  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t   &receiver);\n-  rust_assert (ok);\n-\n-  bool is_dyn_dispatch\n-    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n-  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n-  if (is_generic_receiver)\n-    {\n-      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n-      receiver = p->resolve ();\n-    }\n-\n-  if (is_dyn_dispatch)\n-    {\n-      const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n-\n-      std::vector<HIR::Expr *> arguments;\n-      for (auto &arg : expr.get_arguments ())\n-\targuments.push_back (arg.get ());\n-\n-      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n-\t\t\t\t\t      arguments, expr.get_locus ());\n-      return;\n-    }\n-\n-  // lookup compiled functions since it may have already been compiled\n-  HIR::PathExprSegment method_name = expr.get_method_name ();\n-  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n-  tree fn_expr\n-    = resolve_method_address (fntype, ref, receiver, segment_name,\n-\t\t\t      expr.get_mappings (), expr.get_locus ());\n-\n-  // lookup the autoderef mappings\n-  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n-  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n-    expr.get_mappings ().get_hirid (), &adjustments);\n-  rust_assert (ok);\n-\n-  for (auto &adjustment : *adjustments)\n-    {\n-      switch (adjustment.get_type ())\n-\t{\n-\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n-\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  self = ctx->get_backend ()->address_expression (\n-\t    self, expr.get_receiver ()->get_locus ());\n-\t  break;\n-\n-\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  tree expected_type\n-\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\t  self = ctx->get_backend ()->indirect_expression (\n-\t    expected_type, self, true, /* known_valid*/\n-\t    expr.get_receiver ()->get_locus ());\n-\t  break;\n-\t}\n-    }\n-\n-  std::vector<tree> args;\n-  args.push_back (self); // adjusted self\n-\n-  // normal args\n-  for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n-    {\n-      auto &argument = expr.get_arguments ().at (i);\n-      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n-\n-      // assignments are coercion sites so lets convert the rvalue if\n-      // necessary, offset from the already adjusted implicit self\n-      bool ok;\n-      TyTy::BaseType *expected = fntype->param_at (i + 1).second;\n-\n-      TyTy::BaseType *actual = nullptr;\n-      ok = ctx->get_tyctx ()->lookup_type (\n-\targument->get_mappings ().get_hirid (), &actual);\n-      rust_assert (ok);\n-\n-      // coerce it if required\n-      rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n-\n-      // add it to the list\n-      args.push_back (rvalue);\n-    }\n-\n-  auto fncontext = ctx->peek_fn ();\n-  translated\n-    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n-\t\t\t\t\t    nullptr, expr.get_locus ());\n-}\n-\n // rust-compile-block.h\n \n void"}]}