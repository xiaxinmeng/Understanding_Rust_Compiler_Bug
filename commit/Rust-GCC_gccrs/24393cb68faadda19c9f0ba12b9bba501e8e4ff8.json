{"sha": "24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "node_id": "C_kwDOANBUbNoAKDI0MzkzY2I2OGZhYWRkYTE5YzlmMGJhMTJiOWJiYTUwMWU4ZTRmZjg", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T11:53:58Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:06Z"}, "message": "gccrs: Add Rust type information\n\nContains abstractions over Rust's types, used when performing the\nHIR's type-resolution.\n\n\tgcc/rust/\n\t* typecheck/rust-tyty.cc: New.\n\t* typecheck/rust-tyty.h: New.", "tree": {"sha": "d1595bae8f743fe2cbf995fa8bb70a5589246a18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1595bae8f743fe2cbf995fa8bb70a5589246a18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24393cb68faadda19c9f0ba12b9bba501e8e4ff8/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6c3db21769e8455f38e0d6ce004c44521aad7bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c3db21769e8455f38e0d6ce004c44521aad7bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c3db21769e8455f38e0d6ce004c44521aad7bd"}], "stats": {"total": 5418, "additions": 5418, "deletions": 0}, "files": [{"sha": "3c2c6786940186ca16dc173a3b593a0c43688d68", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "added", "additions": 2885, "deletions": 0, "changes": 2885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24393cb68faadda19c9f0ba12b9bba501e8e4ff8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24393cb68faadda19c9f0ba12b9bba501e8e4ff8/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "patch": "@@ -0,0 +1,2885 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-tyty-rules.h\"\n+#include \"rust-tyty-cmp.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-trait-ref.h\"\n+#include \"rust-hir-type-bounds.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+std::string\n+TypeKindFormat::to_string (TypeKind kind)\n+{\n+  switch (kind)\n+    {\n+    case TypeKind::INFER:\n+      return \"Infer\";\n+\n+    case TypeKind::ADT:\n+      return \"ADT\";\n+\n+    case TypeKind::STR:\n+      return \"STR\";\n+\n+    case TypeKind::REF:\n+      return \"REF\";\n+\n+    case TypeKind::POINTER:\n+      return \"POINTER\";\n+\n+    case TypeKind::PARAM:\n+      return \"PARAM\";\n+\n+    case TypeKind::ARRAY:\n+      return \"ARRAY\";\n+\n+    case TypeKind::SLICE:\n+      return \"SLICE\";\n+\n+    case TypeKind::FNDEF:\n+      return \"FnDef\";\n+\n+    case TypeKind::FNPTR:\n+      return \"FnPtr\";\n+\n+    case TypeKind::TUPLE:\n+      return \"Tuple\";\n+\n+    case TypeKind::BOOL:\n+      return \"Bool\";\n+\n+    case TypeKind::CHAR:\n+      return \"Char\";\n+\n+    case TypeKind::INT:\n+      return \"Int\";\n+\n+    case TypeKind::UINT:\n+      return \"Uint\";\n+\n+    case TypeKind::FLOAT:\n+      return \"Float\";\n+\n+    case TypeKind::USIZE:\n+      return \"Usize\";\n+\n+    case TypeKind::ISIZE:\n+      return \"Isize\";\n+\n+    case TypeKind::NEVER:\n+      return \"Never\";\n+\n+    case TypeKind::PLACEHOLDER:\n+      return \"Placeholder\";\n+\n+    case TypeKind::PROJECTION:\n+      return \"Projection\";\n+\n+    case TypeKind::DYNAMIC:\n+      return \"Dynamic\";\n+\n+    case TypeKind::CLOSURE:\n+      return \"Closure\";\n+\n+    case TypeKind::ERROR:\n+      return \"ERROR\";\n+    }\n+  gcc_unreachable ();\n+}\n+\n+bool\n+is_primitive_type_kind (TypeKind kind)\n+{\n+  switch (kind)\n+    {\n+    case TypeKind::BOOL:\n+    case TypeKind::CHAR:\n+    case TypeKind::INT:\n+    case TypeKind::UINT:\n+    case TypeKind::ISIZE:\n+    case TypeKind::USIZE:\n+    case TypeKind::FLOAT:\n+    case TypeKind::NEVER:\n+    case TypeKind::STR:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+bool\n+BaseType::satisfies_bound (const TypeBoundPredicate &predicate) const\n+{\n+  const Resolver::TraitReference *query = predicate.get ();\n+  for (auto &bound : specified_bounds)\n+    {\n+      const Resolver::TraitReference *item = bound.get ();\n+      bool found = item->get_mappings ().get_defid ()\n+\t\t   == query->get_mappings ().get_defid ();\n+      if (found)\n+\treturn true;\n+    }\n+\n+  auto probed = Resolver::TypeBoundsProbe::Probe (this);\n+  for (auto &b : probed)\n+    {\n+      const Resolver::TraitReference *bound = b.first;\n+      bool found = bound->get_mappings ().get_defid ()\n+\t\t   == query->get_mappings ().get_defid ();\n+      if (found)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+bool\n+BaseType::bounds_compatible (const BaseType &other, Location locus,\n+\t\t\t     bool emit_error) const\n+{\n+  std::vector<std::reference_wrapper<const TypeBoundPredicate>>\n+    unsatisfied_bounds;\n+  for (auto &bound : get_specified_bounds ())\n+    {\n+      if (!other.satisfies_bound (bound))\n+\tunsatisfied_bounds.push_back (bound);\n+    }\n+\n+  // lets emit a single error for this\n+  if (unsatisfied_bounds.size () > 0)\n+    {\n+      RichLocation r (locus);\n+      std::string missing_preds;\n+      for (size_t i = 0; i < unsatisfied_bounds.size (); i++)\n+\t{\n+\t  const TypeBoundPredicate &pred = unsatisfied_bounds.at (i);\n+\t  r.add_range (pred.get_locus ());\n+\t  missing_preds += pred.get_name ();\n+\n+\t  bool have_next = (i + 1) < unsatisfied_bounds.size ();\n+\t  if (have_next)\n+\t    missing_preds += \", \";\n+\t}\n+\n+      if (emit_error)\n+\t{\n+\t  rust_error_at (r,\n+\t\t\t \"bounds not satisfied for %s %<%s%> is not satisfied\",\n+\t\t\t other.get_name ().c_str (), missing_preds.c_str ());\n+\t  // rust_assert (!emit_error);\n+\t}\n+    }\n+\n+  return unsatisfied_bounds.size () == 0;\n+}\n+\n+void\n+BaseType::inherit_bounds (const BaseType &other)\n+{\n+  inherit_bounds (other.get_specified_bounds ());\n+}\n+\n+void\n+BaseType::inherit_bounds (\n+  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n+{\n+  // FIXME\n+  // 1. This needs to union the bounds\n+  // 2. Do some checking for trait polarity to ensure compatibility\n+  for (auto &bound : specified_bounds)\n+    {\n+      add_bound (bound);\n+    }\n+}\n+\n+const BaseType *\n+BaseType::get_root () const\n+{\n+  // FIXME this needs to be it its own visitor class with a vector adjustments\n+  const TyTy::BaseType *root = this;\n+  if (get_kind () == TyTy::REF)\n+    {\n+      const ReferenceType *r = static_cast<const ReferenceType *> (root);\n+      root = r->get_base ()->get_root ();\n+    }\n+  else if (get_kind () == TyTy::POINTER)\n+    {\n+      const PointerType *r = static_cast<const PointerType *> (root);\n+      root = r->get_base ()->get_root ();\n+    }\n+\n+  // these are an unsize\n+  else if (get_kind () == TyTy::SLICE)\n+    {\n+      const SliceType *r = static_cast<const SliceType *> (root);\n+      root = r->get_element_type ()->get_root ();\n+    }\n+  // else if (get_kind () == TyTy::ARRAY)\n+  //   {\n+  //     const ArrayType *r = static_cast<const ArrayType *> (root);\n+  //     root = r->get_element_type ()->get_root ();\n+  //   }\n+\n+  return root;\n+}\n+\n+const BaseType *\n+BaseType::destructure () const\n+{\n+  int recurisve_ops = 0;\n+  const BaseType *x = this;\n+  while (true)\n+    {\n+      if (recurisve_ops++ >= rust_max_recursion_depth)\n+\t{\n+\t  rust_error_at (\n+\t    Location (),\n+\t    \"%<recursion depth%> count exceeds limit of %i (use \"\n+\t    \"%<frust-max-recursion-depth=%> to increase the limit)\",\n+\t    rust_max_recursion_depth);\n+\t  return new ErrorType (get_ref ());\n+\t}\n+\n+      switch (x->get_kind ())\n+\t{\n+\t  case TyTy::TypeKind::PARAM: {\n+\t    const TyTy::ParamType *p = static_cast<const TyTy::ParamType *> (x);\n+\t    x = p->resolve ();\n+\t  }\n+\t  break;\n+\n+\t  case TyTy::TypeKind::PLACEHOLDER: {\n+\t    const TyTy::PlaceholderType *p\n+\t      = static_cast<const TyTy::PlaceholderType *> (x);\n+\t    rust_assert (p->can_resolve ());\n+\t    x = p->resolve ();\n+\t  }\n+\t  break;\n+\n+\t  case TyTy::TypeKind::PROJECTION: {\n+\t    const TyTy::ProjectionType *p\n+\t      = static_cast<const TyTy::ProjectionType *> (x);\n+\t    x = p->get ();\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  return x;\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n+TyVar::TyVar (HirId ref) : ref (ref)\n+{\n+  // ensure this reference is defined within the context\n+  auto context = Resolver::TypeCheckContext::get ();\n+  BaseType *lookup = nullptr;\n+  bool ok = context->lookup_type (ref, &lookup);\n+  rust_assert (ok);\n+}\n+\n+BaseType *\n+TyVar::get_tyty () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  BaseType *lookup = nullptr;\n+  bool ok = context->lookup_type (ref, &lookup);\n+  rust_assert (ok);\n+  return lookup;\n+}\n+\n+TyVar\n+TyVar::get_implicit_infer_var (Location locus)\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  InferType *infer = new InferType (mappings->get_next_hir_id (),\n+\t\t\t\t    InferType::InferTypeKind::GENERAL, locus);\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       infer->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tinfer);\n+  mappings->insert_location (infer->get_ref (), locus);\n+\n+  return TyVar (infer->get_ref ());\n+}\n+\n+TyVar\n+TyVar::subst_covariant_var (TyTy::BaseType *orig, TyTy::BaseType *subst)\n+{\n+  if (orig->get_kind () != TyTy::TypeKind::PARAM)\n+    return TyVar (subst->get_ty_ref ());\n+  else if (subst->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (subst);\n+      if (p->resolve ()->get_kind () == TyTy::TypeKind::PARAM)\n+\t{\n+\t  return TyVar (subst->get_ty_ref ());\n+\t}\n+    }\n+\n+  return TyVar (subst->get_ref ());\n+}\n+\n+TyVar\n+TyVar::clone () const\n+{\n+  TyTy::BaseType *c = get_tyty ()->clone ();\n+  return TyVar (c->get_ref ());\n+}\n+\n+TyVar\n+TyVar::monomorphized_clone () const\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  // this needs a new hirid\n+  TyTy::BaseType *c = get_tyty ()->monomorphized_clone ();\n+  c->set_ref (mappings->get_next_hir_id ());\n+\n+  // insert it\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID, c->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tc);\n+\n+  return TyVar (c->get_ref ());\n+}\n+\n+TyWithLocation::TyWithLocation (BaseType *ty, Location locus)\n+  : ty (ty), locus (locus)\n+{}\n+\n+TyWithLocation::TyWithLocation (BaseType *ty) : ty (ty)\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  locus = mappings->lookup_location (ty->get_ref ());\n+}\n+\n+void\n+InferType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+InferType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+InferType::as_string () const\n+{\n+  switch (infer_kind)\n+    {\n+    case GENERAL:\n+      return \"T?\";\n+    case INTEGRAL:\n+      return \"<integer>\";\n+    case FLOAT:\n+      return \"<float>\";\n+    }\n+  return \"<infer::error>\";\n+}\n+\n+BaseType *\n+InferType::unify (BaseType *other)\n+{\n+  InferRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+InferType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  InferCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+InferType::clone () const\n+{\n+  // clones for inference variables are special in that they _must_ exist within\n+  // the type check context and we must ensure we don't loose the chain\n+  // otherwise we will end up in the missing type annotations case\n+  //\n+  // This means we cannot simply take over the same reference we must generate a\n+  // new ref just like the get_implicit_infer_var code then we can setup the\n+  // chain of references accordingly to ensure we don't loose the ability to\n+  // update the inference variables when we solve the type\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  InferType *clone\n+    = new InferType (mappings->get_next_hir_id (), get_infer_kind (),\n+\t\t     get_ident ().locus, get_combined_refs ());\n+\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       clone->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tclone);\n+  mappings->insert_location (clone->get_ref (),\n+\t\t\t     mappings->lookup_location (get_ref ()));\n+\n+  // setup the chain to reference this\n+  clone->append_reference (get_ref ());\n+\n+  return clone;\n+}\n+\n+BaseType *\n+InferType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+bool\n+InferType::default_type (BaseType **type) const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  bool ok = false;\n+  switch (infer_kind)\n+    {\n+    case GENERAL:\n+      return false;\n+\n+      case INTEGRAL: {\n+\tok = context->lookup_builtin (\"i32\", type);\n+\trust_assert (ok);\n+\treturn ok;\n+      }\n+\n+      case FLOAT: {\n+\tok = context->lookup_builtin (\"f64\", type);\n+\trust_assert (ok);\n+\treturn ok;\n+      }\n+    }\n+  return false;\n+}\n+\n+void\n+ErrorType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ErrorType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ErrorType::as_string () const\n+{\n+  return \"<tyty::error>\";\n+}\n+\n+BaseType *\n+ErrorType::unify (BaseType *other)\n+{\n+  return this;\n+}\n+\n+bool\n+ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  return get_kind () == other->get_kind ();\n+}\n+\n+BaseType *\n+ErrorType::clone () const\n+{\n+  return new ErrorType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+BaseType *\n+ErrorType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+std::string\n+StructFieldType::as_string () const\n+{\n+  return name + \":\" + get_field_type ()->debug_str ();\n+}\n+\n+bool\n+StructFieldType::is_equal (const StructFieldType &other) const\n+{\n+  bool names_eq = get_name ().compare (other.get_name ()) == 0;\n+\n+  TyTy::BaseType *o = other.get_field_type ();\n+  if (o->get_kind () == TypeKind::PARAM)\n+    {\n+      ParamType *op = static_cast<ParamType *> (o);\n+      o = op->resolve ();\n+    }\n+\n+  bool types_eq = get_field_type ()->is_equal (*o);\n+\n+  return names_eq && types_eq;\n+}\n+\n+StructFieldType *\n+StructFieldType::clone () const\n+{\n+  return new StructFieldType (get_ref (), get_name (),\n+\t\t\t      get_field_type ()->clone ());\n+}\n+\n+StructFieldType *\n+StructFieldType::monomorphized_clone () const\n+{\n+  return new StructFieldType (get_ref (), get_name (),\n+\t\t\t      get_field_type ()->monomorphized_clone ());\n+}\n+\n+bool\n+SubstitutionParamMapping::need_substitution () const\n+{\n+  if (!param->can_resolve ())\n+    return true;\n+\n+  auto resolved = param->resolve ();\n+  return !resolved->is_concrete ();\n+}\n+\n+bool\n+SubstitutionParamMapping::fill_param_ty (\n+  SubstitutionArgumentMappings &subst_mappings, Location locus)\n+{\n+  SubstitutionArg arg = SubstitutionArg::error ();\n+  bool ok = subst_mappings.get_argument_for_symbol (get_param_ty (), &arg);\n+  if (!ok)\n+    return true;\n+\n+  TyTy::BaseType &type = *arg.get_tyty ();\n+  if (type.get_kind () == TyTy::TypeKind::INFER)\n+    {\n+      type.inherit_bounds (*param);\n+    }\n+  else\n+    {\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+    }\n+\n+  if (type.get_kind () == TypeKind::PARAM)\n+    {\n+      // delete param;\n+      param = static_cast<ParamType *> (type.clone ());\n+    }\n+  else\n+    {\n+      // check the substitution is compatible with bounds\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+\n+      // recursively pass this down to all HRTB's\n+      for (auto &bound : param->get_specified_bounds ())\n+\tbound.handle_substitions (subst_mappings);\n+\n+      param->set_ty_ref (type.get_ref ());\n+    }\n+\n+  return true;\n+}\n+\n+void\n+SubstitutionParamMapping::override_context ()\n+{\n+  if (!param->can_resolve ())\n+    return;\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       param->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tparam->resolve ());\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n+{\n+  if (args.get_binding_args ().size () > 0)\n+    {\n+      RichLocation r (args.get_locus ());\n+      for (auto &binding : args.get_binding_args ())\n+\tr.add_range (binding.get_locus ());\n+\n+      rust_error_at (r, \"associated type bindings are not allowed here\");\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  // for inherited arguments\n+  size_t offs = used_arguments.size ();\n+  if (args.get_type_args ().size () + offs > substitutions.size ())\n+    {\n+      RichLocation r (args.get_locus ());\n+      r.add_range (substitutions.front ().get_param_locus ());\n+\n+      rust_error_at (\n+\tr,\n+\t\"generic item takes at most %lu type arguments but %lu were supplied\",\n+\t(unsigned long) substitutions.size (),\n+\t(unsigned long) args.get_type_args ().size ());\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  if (args.get_type_args ().size () + offs < min_required_substitutions ())\n+    {\n+      RichLocation r (args.get_locus ());\n+      r.add_range (substitutions.front ().get_param_locus ());\n+\n+      rust_error_at (\n+\tr,\n+\t\"generic item takes at least %lu type arguments but %lu were supplied\",\n+\t(unsigned long) (min_required_substitutions () - offs),\n+\t(unsigned long) args.get_type_args ().size ());\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  std::vector<SubstitutionArg> mappings = used_arguments.get_mappings ();\n+  for (auto &arg : args.get_type_args ())\n+    {\n+      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n+      if (resolved == nullptr || resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (args.get_locus (), \"failed to resolve type arguments\");\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n+\n+      SubstitutionArg subst_arg (&substitutions.at (offs), resolved);\n+      offs++;\n+      mappings.push_back (std::move (subst_arg));\n+    }\n+\n+  // we must need to fill out defaults\n+  size_t left_over\n+    = num_required_substitutions () - min_required_substitutions ();\n+  if (left_over > 0)\n+    {\n+      for (size_t offs = mappings.size (); offs < substitutions.size (); offs++)\n+\t{\n+\t  SubstitutionParamMapping &param = substitutions.at (offs);\n+\t  rust_assert (param.param_has_default_ty ());\n+\n+\t  BaseType *resolved = param.get_default_ty ();\n+\t  if (resolved->get_kind () == TypeKind::ERROR)\n+\t    return SubstitutionArgumentMappings::error ();\n+\n+\t  // this resolved default might already contain default parameters\n+\t  if (resolved->contains_type_parameters ())\n+\t    {\n+\t      SubstitutionArgumentMappings intermediate (mappings,\n+\t\t\t\t\t\t\t args.get_locus ());\n+\t      resolved = Resolver::SubstMapperInternal::Resolve (resolved,\n+\t\t\t\t\t\t\t\t intermediate);\n+\n+\t      if (resolved->get_kind () == TypeKind::ERROR)\n+\t\treturn SubstitutionArgumentMappings::error ();\n+\t    }\n+\n+\t  SubstitutionArg subst_arg (&param, resolved);\n+\t  mappings.push_back (std::move (subst_arg));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (mappings, args.get_locus ());\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::adjust_mappings_for_this (\n+  SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      auto &subst = substitutions.at (i);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      if (mappings.size () == substitutions.size ())\n+\t{\n+\t  mappings.get_argument_at (i, &arg);\n+\t}\n+      else\n+\t{\n+\t  if (subst.needs_substitution ())\n+\t    {\n+\t      // get from passed in mappings\n+\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+\t    }\n+\t  else\n+\t    {\n+\t      // we should already have this somewhere\n+\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n+\t\t\t\t\t\t      &arg);\n+\t    }\n+\t}\n+\n+      bool ok = !arg.is_error ();\n+      if (ok)\n+\t{\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  if (resolved_mappings.empty ())\n+    return SubstitutionArgumentMappings::error ();\n+\n+  return SubstitutionArgumentMappings (resolved_mappings, mappings.get_locus (),\n+\t\t\t\t       mappings.get_subst_cb (),\n+\t\t\t\t       mappings.trait_item_mode ());\n+}\n+\n+bool\n+SubstitutionRef::are_mappings_bound (SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      auto &subst = substitutions.at (i);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      if (mappings.size () == substitutions.size ())\n+\t{\n+\t  mappings.get_argument_at (i, &arg);\n+\t}\n+      else\n+\t{\n+\t  if (subst.needs_substitution ())\n+\t    {\n+\t      // get from passed in mappings\n+\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+\t    }\n+\t  else\n+\t    {\n+\t      // we should already have this somewhere\n+\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n+\t\t\t\t\t\t      &arg);\n+\t    }\n+\t}\n+\n+      bool ok = !arg.is_error ();\n+      if (ok)\n+\t{\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return !resolved_mappings.empty ();\n+}\n+\n+// this function assumes that the mappings being passed are for the same type as\n+// this new substitution reference so ordering matters here\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_mappings_from_receiver_for_self (\n+  SubstitutionArgumentMappings &mappings) const\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  rust_assert (mappings.size () == get_num_substitutions ());\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      const SubstitutionParamMapping &param_mapping = substitutions.at (i);\n+      SubstitutionArg &arg = mappings.get_mappings ().at (i);\n+\n+      if (param_mapping.needs_substitution ())\n+\t{\n+\t  SubstitutionArg adjusted (&param_mapping, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_locus ());\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n+\t\t\t\t\t\t   SubstitutionRef &to)\n+{\n+  rust_assert (!ref.needs_substitution ());\n+  rust_assert (needs_substitution ());\n+  rust_assert (get_num_substitutions () == ref.get_num_substitutions ());\n+\n+  Location locus = used_arguments.get_locus ();\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  std::map<HirId, std::pair<ParamType *, BaseType *>> substs;\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      SubstitutionParamMapping &a = substitutions.at (i);\n+      SubstitutionParamMapping &b = ref.substitutions.at (i);\n+\n+      if (a.need_substitution ())\n+\t{\n+\t  const BaseType *root = a.get_param_ty ()->resolve ()->get_root ();\n+\t  rust_assert (root->get_kind () == TyTy::TypeKind::PARAM);\n+\t  const ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+\n+\t  substs[p->get_ty_ref ()] = {static_cast<ParamType *> (p->clone ()),\n+\t\t\t\t      b.get_param_ty ()->resolve ()};\n+\t}\n+    }\n+\n+  for (auto it = substs.begin (); it != substs.end (); it++)\n+    {\n+      HirId param_id = it->first;\n+      BaseType *arg = it->second.second;\n+\n+      const SubstitutionParamMapping *associate_param = nullptr;\n+      for (SubstitutionParamMapping &p : to.substitutions)\n+\t{\n+\t  if (p.get_param_ty ()->get_ty_ref () == param_id)\n+\t    {\n+\t      associate_param = &p;\n+\t      break;\n+\t    }\n+\t}\n+\n+      rust_assert (associate_param != nullptr);\n+      SubstitutionArg argument (associate_param, arg);\n+      resolved_mappings.push_back (std::move (argument));\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings, locus);\n+}\n+\n+bool\n+SubstitutionRef::monomorphize ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  for (const auto &subst : get_substs ())\n+    {\n+      const TyTy::ParamType *pty = subst.get_param_ty ();\n+\n+      if (!pty->can_resolve ())\n+\tcontinue;\n+\n+      const TyTy::BaseType *binding = pty->resolve ();\n+      if (binding->get_kind () == TyTy::TypeKind::PARAM)\n+\tcontinue;\n+\n+      for (const auto &bound : pty->get_specified_bounds ())\n+\t{\n+\t  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n+\n+\t  // setup any associated type mappings for the specified bonds and this\n+\t  // type\n+\t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n+\n+\t  Resolver::AssociatedImplTrait *associated_impl_trait = nullptr;\n+\t  for (auto &probed_bound : candidates)\n+\t    {\n+\t      const Resolver::TraitReference *bound_trait_ref\n+\t\t= probed_bound.first;\n+\t      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+\t      HirId impl_block_id\n+\t\t= associated_impl->get_mappings ().get_hirid ();\n+\t      Resolver::AssociatedImplTrait *associated = nullptr;\n+\t      bool found_impl_trait\n+\t\t= context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t\t &associated);\n+\t      if (found_impl_trait)\n+\t\t{\n+\t\t  bool found_trait\n+\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t\t  bool found_self\n+\t\t    = associated->get_self ()->can_eq (binding, false);\n+\t\t  if (found_trait && found_self)\n+\t\t    {\n+\t\t      associated_impl_trait = associated;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (associated_impl_trait != nullptr)\n+\t    {\n+\t      associated_impl_trait->setup_associated_types (binding, bound);\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+void\n+ADTType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ADTType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ADTType::as_string () const\n+{\n+  std::string variants_buffer;\n+  for (size_t i = 0; i < number_of_variants (); ++i)\n+    {\n+      TyTy::VariantDef *variant = variants.at (i);\n+      variants_buffer += variant->as_string ();\n+      if ((i + 1) < number_of_variants ())\n+\tvariants_buffer += \", \";\n+    }\n+\n+  return identifier + subst_as_string () + \"{\" + variants_buffer + \"}\";\n+}\n+\n+BaseType *\n+ADTType::unify (BaseType *other)\n+{\n+  ADTRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+ADTType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  ADTCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+ADTType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const ADTType &> (other);\n+  if (get_adt_kind () != other2.get_adt_kind ())\n+    return false;\n+\n+  if (number_of_variants () != other2.number_of_variants ())\n+    return false;\n+\n+  if (has_subsititions_defined () != other2.has_subsititions_defined ())\n+    return false;\n+\n+  if (has_subsititions_defined ())\n+    {\n+      if (get_num_substitutions () != other2.get_num_substitutions ())\n+\treturn false;\n+\n+      for (size_t i = 0; i < get_num_substitutions (); i++)\n+\t{\n+\t  const SubstitutionParamMapping &a = substitutions.at (i);\n+\t  const SubstitutionParamMapping &b = other2.substitutions.at (i);\n+\n+\t  const ParamType *aa = a.get_param_ty ();\n+\t  const ParamType *bb = b.get_param_ty ();\n+\t  BaseType *aaa = aa->resolve ();\n+\t  BaseType *bbb = bb->resolve ();\n+\t  if (!aaa->is_equal (*bbb))\n+\t    return false;\n+\t}\n+    }\n+\n+  for (size_t i = 0; i < number_of_variants (); i++)\n+    {\n+      const TyTy::VariantDef *a = get_variants ().at (i);\n+      const TyTy::VariantDef *b = other2.get_variants ().at (i);\n+\n+      if (!a->is_equal (*b))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+BaseType *\n+ADTType::clone () const\n+{\n+  std::vector<VariantDef *> cloned_variants;\n+  for (auto &variant : variants)\n+    cloned_variants.push_back (variant->clone ());\n+\n+  return new ADTType (get_ref (), get_ty_ref (), identifier, ident,\n+\t\t      get_adt_kind (), cloned_variants, clone_substs (),\n+\t\t      get_repr_options (), used_arguments,\n+\t\t      get_combined_refs ());\n+}\n+\n+BaseType *\n+ADTType::monomorphized_clone () const\n+{\n+  std::vector<VariantDef *> cloned_variants;\n+  for (auto &variant : variants)\n+    cloned_variants.push_back (variant->monomorphized_clone ());\n+\n+  return new ADTType (get_ref (), get_ty_ref (), identifier, ident,\n+\t\t      get_adt_kind (), cloned_variants, clone_substs (),\n+\t\t      get_repr_options (), used_arguments,\n+\t\t      get_combined_refs ());\n+}\n+\n+static bool\n+handle_substitions (SubstitutionArgumentMappings &subst_mappings,\n+\t\t    StructFieldType *field)\n+{\n+  auto fty = field->get_field_type ();\n+  bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+  if (is_param_ty)\n+    {\n+      ParamType *p = static_cast<ParamType *> (fty);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+      if (ok)\n+\t{\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      field->set_field_type (new_field);\n+\t    }\n+\t  else\n+\t    {\n+\t      field->get_field_type ()->set_ty_ref (argt->get_ref ());\n+\t    }\n+\t}\n+    }\n+  else if (fty->has_subsititions_defined () || fty->contains_type_parameters ())\n+    {\n+      BaseType *concrete\n+\t= Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+      if (concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve field substitution type: %s\",\n+\t\t\t fty->as_string ().c_str ());\n+\t  return false;\n+\t}\n+\n+      auto new_field = concrete->clone ();\n+      new_field->set_ref (fty->get_ref ());\n+      field->set_field_type (new_field);\n+    }\n+\n+  return true;\n+}\n+\n+ADTType *\n+ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+{\n+  ADTType *adt = static_cast<ADTType *> (clone ());\n+  adt->set_ty_ref (mappings->get_next_hir_id ());\n+  adt->used_arguments = subst_mappings;\n+\n+  for (auto &sub : adt->get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      if (ok)\n+\tsub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n+    }\n+\n+  for (auto &variant : adt->get_variants ())\n+    {\n+      if (variant->is_dataless_variant ())\n+\tcontinue;\n+\n+      for (auto &field : variant->get_fields ())\n+\t{\n+\t  bool ok = ::Rust::TyTy::handle_substitions (subst_mappings, field);\n+\t  if (!ok)\n+\t    return adt;\n+\t}\n+    }\n+\n+  return adt;\n+}\n+\n+void\n+TupleType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TupleType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+TupleType::as_string () const\n+{\n+  std::string fields_buffer;\n+  for (const TyVar &field : get_fields ())\n+    {\n+      fields_buffer += field.get_tyty ()->as_string ();\n+      fields_buffer += \", \";\n+    }\n+  return \"(\" + fields_buffer + \")\";\n+}\n+\n+BaseType *\n+TupleType::get_field (size_t index) const\n+{\n+  return fields.at (index).get_tyty ();\n+}\n+\n+BaseType *\n+TupleType::unify (BaseType *other)\n+{\n+  TupleRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+TupleType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  TupleCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+TupleType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const TupleType &> (other);\n+  if (num_fields () != other2.num_fields ())\n+    return false;\n+\n+  for (size_t i = 0; i < num_fields (); i++)\n+    {\n+      if (!get_field (i)->is_equal (*other2.get_field (i)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+BaseType *\n+TupleType::clone () const\n+{\n+  std::vector<TyVar> cloned_fields;\n+  for (const auto &f : fields)\n+    cloned_fields.push_back (f.clone ());\n+\n+  return new TupleType (get_ref (), get_ty_ref (), get_ident ().locus,\n+\t\t\tcloned_fields, get_combined_refs ());\n+}\n+\n+BaseType *\n+TupleType::monomorphized_clone () const\n+{\n+  std::vector<TyVar> cloned_fields;\n+  for (const auto &f : fields)\n+    cloned_fields.push_back (f.monomorphized_clone ());\n+\n+  return new TupleType (get_ref (), get_ty_ref (), get_ident ().locus,\n+\t\t\tcloned_fields, get_combined_refs ());\n+}\n+\n+TupleType *\n+TupleType::handle_substitions (SubstitutionArgumentMappings mappings)\n+{\n+  auto mappings_table = Analysis::Mappings::get ();\n+\n+  TupleType *tuple = static_cast<TupleType *> (clone ());\n+  tuple->set_ref (mappings_table->get_next_hir_id ());\n+  tuple->set_ty_ref (mappings_table->get_next_hir_id ());\n+\n+  for (size_t i = 0; i < tuple->fields.size (); i++)\n+    {\n+      TyVar &field = fields.at (i);\n+      if (field.get_tyty ()->contains_type_parameters ())\n+\t{\n+\t  BaseType *concrete\n+\t    = Resolver::SubstMapperInternal::Resolve (field.get_tyty (),\n+\t\t\t\t\t\t      mappings);\n+\t  tuple->fields[i]\n+\t    = TyVar::subst_covariant_var (field.get_tyty (), concrete);\n+\t}\n+    }\n+\n+  return tuple;\n+}\n+\n+void\n+FnType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+FnType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+FnType::as_string () const\n+{\n+  std::string params_str = \"\";\n+  for (auto &param : params)\n+    {\n+      auto pattern = param.first;\n+      auto ty = param.second;\n+      params_str += pattern->as_string () + \" \" + ty->as_string ();\n+      params_str += \",\";\n+    }\n+\n+  std::string ret_str = type->as_string ();\n+  return \"fn\" + subst_as_string () + \" (\" + params_str + \") -> \" + ret_str;\n+}\n+\n+BaseType *\n+FnType::unify (BaseType *other)\n+{\n+  FnRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+FnType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  FnCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+FnType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const FnType &> (other);\n+  if (get_identifier ().compare (other2.get_identifier ()) != 0)\n+    return false;\n+\n+  if (!get_return_type ()->is_equal (*other2.get_return_type ()))\n+    return false;\n+\n+  if (has_subsititions_defined () != other2.has_subsititions_defined ())\n+    return false;\n+\n+  if (has_subsititions_defined ())\n+    {\n+      if (get_num_substitutions () != other2.get_num_substitutions ())\n+\treturn false;\n+\n+      const FnType &ofn = static_cast<const FnType &> (other);\n+      for (size_t i = 0; i < get_num_substitutions (); i++)\n+\t{\n+\t  const SubstitutionParamMapping &a = get_substs ().at (i);\n+\t  const SubstitutionParamMapping &b = ofn.get_substs ().at (i);\n+\n+\t  const ParamType *pa = a.get_param_ty ();\n+\t  const ParamType *pb = b.get_param_ty ();\n+\n+\t  if (!pa->is_equal (*pb))\n+\t    return false;\n+\t}\n+    }\n+\n+  if (num_params () != other2.num_params ())\n+    return false;\n+\n+  for (size_t i = 0; i < num_params (); i++)\n+    {\n+      auto lhs = param_at (i).second;\n+      auto rhs = other2.param_at (i).second;\n+      if (!lhs->is_equal (*rhs))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+BaseType *\n+FnType::clone () const\n+{\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back ({p.first, p.second->clone ()});\n+\n+  return new FnType (get_ref (), get_ty_ref (), get_id (), get_identifier (),\n+\t\t     ident, flags, abi, std::move (cloned_params),\n+\t\t     get_return_type ()->clone (), clone_substs (),\n+\t\t     get_combined_refs ());\n+}\n+\n+BaseType *\n+FnType::monomorphized_clone () const\n+{\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back ({p.first, p.second->monomorphized_clone ()});\n+\n+  return new FnType (get_ref (), get_ty_ref (), get_id (), get_identifier (),\n+\t\t     ident, flags, abi, std::move (cloned_params),\n+\t\t     get_return_type ()->clone (), clone_substs (),\n+\t\t     get_combined_refs ());\n+}\n+\n+FnType *\n+FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+{\n+  FnType *fn = static_cast<FnType *> (clone ());\n+  fn->set_ty_ref (mappings->get_next_hir_id ());\n+  fn->used_arguments = subst_mappings;\n+\n+  for (auto &sub : fn->get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      if (ok)\n+\t{\n+\t  sub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n+\t}\n+    }\n+\n+  auto fty = fn->get_return_type ();\n+  bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+  if (is_param_ty)\n+    {\n+      ParamType *p = static_cast<ParamType *> (fty);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+      if (ok)\n+\t{\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      fn->type = new_field;\n+\t    }\n+\t  else\n+\t    {\n+\t      fty->set_ty_ref (argt->get_ref ());\n+\t    }\n+\t}\n+    }\n+  else if (fty->needs_generic_substitutions ()\n+\t   || fty->contains_type_parameters ())\n+    {\n+      BaseType *concrete\n+\t= Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+      if (concrete == nullptr || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve field substitution type: %s\",\n+\t\t\t fty->as_string ().c_str ());\n+\t  return nullptr;\n+\t}\n+\n+      auto new_field = concrete->clone ();\n+      new_field->set_ref (fty->get_ref ());\n+      fn->type = new_field;\n+    }\n+\n+  for (auto &param : fn->get_params ())\n+    {\n+      auto fty = param.second;\n+\n+      bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+      if (is_param_ty)\n+\t{\n+\t  ParamType *p = static_cast<ParamType *> (fty);\n+\n+\t  SubstitutionArg arg = SubstitutionArg::error ();\n+\t  bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+\t  if (ok)\n+\t    {\n+\t      auto argt = arg.get_tyty ();\n+\t      bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t      bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t      if (arg_is_param || arg_is_concrete)\n+\t\t{\n+\t\t  auto new_field = argt->clone ();\n+\t\t  new_field->set_ref (fty->get_ref ());\n+\t\t  param.second = new_field;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fty->set_ty_ref (argt->get_ref ());\n+\t\t}\n+\t    }\n+\t}\n+      else if (fty->has_subsititions_defined ()\n+\t       || fty->contains_type_parameters ())\n+\t{\n+\t  BaseType *concrete\n+\t    = Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+\t  if (concrete == nullptr\n+\t      || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t    {\n+\t      rust_error_at (subst_mappings.get_locus (),\n+\t\t\t     \"Failed to resolve field substitution type: %s\",\n+\t\t\t     fty->as_string ().c_str ());\n+\t      return nullptr;\n+\t    }\n+\n+\t  auto new_field = concrete->clone ();\n+\t  new_field->set_ref (fty->get_ref ());\n+\t  param.second = new_field;\n+\t}\n+    }\n+\n+  return fn;\n+}\n+\n+void\n+FnPtr::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+FnPtr::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+FnPtr::as_string () const\n+{\n+  std::string params_str;\n+\n+  auto &params = get_params ();\n+  for (auto &p : params)\n+    {\n+      params_str += p.get_tyty ()->as_string () + \" ,\";\n+    }\n+\n+  return \"fnptr (\" + params_str + \") -> \" + get_return_type ()->as_string ();\n+}\n+\n+BaseType *\n+FnPtr::unify (BaseType *other)\n+{\n+  FnptrRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  FnptrCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+FnPtr::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const FnPtr &> (other);\n+  auto this_ret_type = get_return_type ();\n+  auto other_ret_type = other2.get_return_type ();\n+  if (this_ret_type->is_equal (*other_ret_type))\n+    return false;\n+\n+  if (num_params () != other2.num_params ())\n+    return false;\n+\n+  for (size_t i = 0; i < num_params (); i++)\n+    {\n+      if (!param_at (i)->is_equal (*other2.param_at (i)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+BaseType *\n+FnPtr::clone () const\n+{\n+  std::vector<TyVar> cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back (TyVar (p.get_ref ()));\n+\n+  return new FnPtr (get_ref (), get_ty_ref (), ident.locus,\n+\t\t    std::move (cloned_params), result_type,\n+\t\t    get_combined_refs ());\n+}\n+\n+BaseType *\n+FnPtr::monomorphized_clone () const\n+{\n+  std::vector<TyVar> cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back (p.monomorphized_clone ());\n+\n+  return new FnPtr (get_ref (), get_ty_ref (), ident.locus,\n+\t\t    std::move (cloned_params), result_type,\n+\t\t    get_combined_refs ());\n+}\n+\n+void\n+ClosureType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ClosureType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ClosureType::as_string () const\n+{\n+  return \"TODO\";\n+}\n+\n+BaseType *\n+ClosureType::unify (BaseType *other)\n+{\n+  ClosureRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  ClosureCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+ClosureType::is_equal (const BaseType &other) const\n+{\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+BaseType *\n+ClosureType::clone () const\n+{\n+  return new ClosureType (get_ref (), get_ty_ref (), ident, id, parameter_types,\n+\t\t\t  result_type, clone_substs (), get_combined_refs ());\n+}\n+\n+BaseType *\n+ClosureType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+ClosureType *\n+ClosureType::handle_substitions (SubstitutionArgumentMappings mappings)\n+{\n+  gcc_unreachable ();\n+  return nullptr;\n+}\n+\n+void\n+ArrayType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ArrayType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ArrayType::as_string () const\n+{\n+  return \"[\" + get_element_type ()->as_string () + \":\" + \"CAPACITY\" + \"]\";\n+}\n+\n+BaseType *\n+ArrayType::unify (BaseType *other)\n+{\n+  ArrayRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  ArrayCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+ArrayType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const ArrayType &> (other);\n+\n+  auto this_element_type = get_element_type ();\n+  auto other_element_type = other2.get_element_type ();\n+\n+  return this_element_type->is_equal (*other_element_type);\n+}\n+\n+BaseType *\n+ArrayType::get_element_type () const\n+{\n+  return element_type.get_tyty ();\n+}\n+\n+BaseType *\n+ArrayType::clone () const\n+{\n+  return new ArrayType (get_ref (), get_ty_ref (), ident.locus, capacity_expr,\n+\t\t\telement_type, get_combined_refs ());\n+}\n+\n+BaseType *\n+ArrayType::monomorphized_clone () const\n+{\n+  return new ArrayType (get_ref (), get_ty_ref (), ident.locus, capacity_expr,\n+\t\t\telement_type.monomorphized_clone (),\n+\t\t\tget_combined_refs ());\n+}\n+\n+ArrayType *\n+ArrayType::handle_substitions (SubstitutionArgumentMappings mappings)\n+{\n+  auto mappings_table = Analysis::Mappings::get ();\n+\n+  ArrayType *ref = static_cast<ArrayType *> (clone ());\n+  ref->set_ty_ref (mappings_table->get_next_hir_id ());\n+\n+  // might be &T or &ADT so this needs to be recursive\n+  auto base = ref->get_element_type ();\n+  BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n+  ref->element_type = TyVar::subst_covariant_var (base, concrete);\n+\n+  return ref;\n+}\n+\n+void\n+SliceType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+SliceType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+SliceType::as_string () const\n+{\n+  return \"[\" + get_element_type ()->as_string () + \"]\";\n+}\n+\n+BaseType *\n+SliceType::unify (BaseType *other)\n+{\n+  SliceRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+SliceType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  SliceCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+SliceType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const SliceType &> (other);\n+\n+  auto this_element_type = get_element_type ();\n+  auto other_element_type = other2.get_element_type ();\n+\n+  return this_element_type->is_equal (*other_element_type);\n+}\n+\n+BaseType *\n+SliceType::get_element_type () const\n+{\n+  return element_type.get_tyty ();\n+}\n+\n+BaseType *\n+SliceType::clone () const\n+{\n+  return new SliceType (get_ref (), get_ty_ref (), ident.locus,\n+\t\t\telement_type.clone (), get_combined_refs ());\n+}\n+\n+BaseType *\n+SliceType::monomorphized_clone () const\n+{\n+  return new SliceType (get_ref (), get_ty_ref (), ident.locus,\n+\t\t\telement_type.monomorphized_clone (),\n+\t\t\tget_combined_refs ());\n+}\n+\n+SliceType *\n+SliceType::handle_substitions (SubstitutionArgumentMappings mappings)\n+{\n+  auto mappings_table = Analysis::Mappings::get ();\n+\n+  SliceType *ref = static_cast<SliceType *> (clone ());\n+  ref->set_ty_ref (mappings_table->get_next_hir_id ());\n+\n+  // might be &T or &ADT so this needs to be recursive\n+  auto base = ref->get_element_type ();\n+  BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n+  ref->element_type = TyVar::subst_covariant_var (base, concrete);\n+\n+  return ref;\n+}\n+\n+void\n+BoolType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+BoolType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+BoolType::as_string () const\n+{\n+  return \"bool\";\n+}\n+\n+BaseType *\n+BoolType::unify (BaseType *other)\n+{\n+  BoolRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+BoolType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  BoolCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+BoolType::clone () const\n+{\n+  return new BoolType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+BaseType *\n+BoolType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+void\n+IntType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+IntType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+IntType::as_string () const\n+{\n+  switch (int_kind)\n+    {\n+    case I8:\n+      return \"i8\";\n+    case I16:\n+      return \"i16\";\n+    case I32:\n+      return \"i32\";\n+    case I64:\n+      return \"i64\";\n+    case I128:\n+      return \"i128\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_int_type\";\n+}\n+\n+BaseType *\n+IntType::unify (BaseType *other)\n+{\n+  IntRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+IntType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  IntCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+IntType::clone () const\n+{\n+  return new IntType (get_ref (), get_ty_ref (), get_int_kind (),\n+\t\t      get_combined_refs ());\n+}\n+\n+BaseType *\n+IntType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+bool\n+IntType::is_equal (const BaseType &other) const\n+{\n+  if (!BaseType::is_equal (other))\n+    return false;\n+\n+  const IntType &o = static_cast<const IntType &> (other);\n+  return get_int_kind () == o.get_int_kind ();\n+}\n+\n+void\n+UintType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+UintType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+UintType::as_string () const\n+{\n+  switch (uint_kind)\n+    {\n+    case U8:\n+      return \"u8\";\n+    case U16:\n+      return \"u16\";\n+    case U32:\n+      return \"u32\";\n+    case U64:\n+      return \"u64\";\n+    case U128:\n+      return \"u128\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_uint_type\";\n+}\n+\n+BaseType *\n+UintType::unify (BaseType *other)\n+{\n+  UintRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+UintType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  UintCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+UintType::clone () const\n+{\n+  return new UintType (get_ref (), get_ty_ref (), get_uint_kind (),\n+\t\t       get_combined_refs ());\n+}\n+\n+BaseType *\n+UintType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+bool\n+UintType::is_equal (const BaseType &other) const\n+{\n+  if (!BaseType::is_equal (other))\n+    return false;\n+\n+  const UintType &o = static_cast<const UintType &> (other);\n+  return get_uint_kind () == o.get_uint_kind ();\n+}\n+\n+void\n+FloatType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+FloatType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+FloatType::as_string () const\n+{\n+  switch (float_kind)\n+    {\n+    case F32:\n+      return \"f32\";\n+    case F64:\n+      return \"f64\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_float_type\";\n+}\n+\n+BaseType *\n+FloatType::unify (BaseType *other)\n+{\n+  FloatRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+FloatType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  FloatCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+FloatType::clone () const\n+{\n+  return new FloatType (get_ref (), get_ty_ref (), get_float_kind (),\n+\t\t\tget_combined_refs ());\n+}\n+\n+BaseType *\n+FloatType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+bool\n+FloatType::is_equal (const BaseType &other) const\n+{\n+  if (!BaseType::is_equal (other))\n+    return false;\n+\n+  const FloatType &o = static_cast<const FloatType &> (other);\n+  return get_float_kind () == o.get_float_kind ();\n+}\n+\n+void\n+USizeType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+USizeType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+USizeType::as_string () const\n+{\n+  return \"usize\";\n+}\n+\n+BaseType *\n+USizeType::unify (BaseType *other)\n+{\n+  USizeRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+USizeType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  USizeCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+USizeType::clone () const\n+{\n+  return new USizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+BaseType *\n+USizeType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+void\n+ISizeType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ISizeType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ISizeType::as_string () const\n+{\n+  return \"isize\";\n+}\n+\n+BaseType *\n+ISizeType::unify (BaseType *other)\n+{\n+  ISizeRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  ISizeCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+ISizeType::clone () const\n+{\n+  return new ISizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+BaseType *\n+ISizeType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+void\n+CharType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+CharType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+CharType::as_string () const\n+{\n+  return \"char\";\n+}\n+\n+BaseType *\n+CharType::unify (BaseType *other)\n+{\n+  CharRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+CharType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  CharCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+CharType::clone () const\n+{\n+  return new CharType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+BaseType *\n+CharType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+void\n+ReferenceType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ReferenceType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ReferenceType::as_string () const\n+{\n+  return std::string (\"&\") + (is_mutable () ? \"mut\" : \"\") + \" \"\n+\t + get_base ()->as_string ();\n+}\n+\n+BaseType *\n+ReferenceType::unify (BaseType *other)\n+{\n+  ReferenceRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  ReferenceCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+ReferenceType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const ReferenceType &> (other);\n+  if (mutability () != other2.mutability ())\n+    return false;\n+\n+  return get_base ()->is_equal (*other2.get_base ());\n+}\n+\n+BaseType *\n+ReferenceType::get_base () const\n+{\n+  return base.get_tyty ();\n+}\n+\n+BaseType *\n+ReferenceType::clone () const\n+{\n+  return new ReferenceType (get_ref (), get_ty_ref (), base, mutability (),\n+\t\t\t    get_combined_refs ());\n+}\n+\n+BaseType *\n+ReferenceType::monomorphized_clone () const\n+{\n+  return new ReferenceType (get_ref (), get_ty_ref (),\n+\t\t\t    base.monomorphized_clone (), mutability (),\n+\t\t\t    get_combined_refs ());\n+}\n+\n+ReferenceType *\n+ReferenceType::handle_substitions (SubstitutionArgumentMappings mappings)\n+{\n+  auto mappings_table = Analysis::Mappings::get ();\n+\n+  ReferenceType *ref = static_cast<ReferenceType *> (clone ());\n+  ref->set_ty_ref (mappings_table->get_next_hir_id ());\n+\n+  // might be &T or &ADT so this needs to be recursive\n+  auto base = ref->get_base ();\n+  BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n+  ref->base = TyVar::subst_covariant_var (base, concrete);\n+\n+  return ref;\n+}\n+\n+void\n+PointerType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+PointerType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+PointerType::as_string () const\n+{\n+  return std::string (\"* \") + (is_mutable () ? \"mut\" : \"const\") + \" \"\n+\t + get_base ()->as_string ();\n+}\n+\n+BaseType *\n+PointerType::unify (BaseType *other)\n+{\n+  PointerRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+PointerType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  PointerCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+PointerType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const PointerType &> (other);\n+  if (mutability () != other2.mutability ())\n+    return false;\n+\n+  return get_base ()->is_equal (*other2.get_base ());\n+}\n+\n+BaseType *\n+PointerType::get_base () const\n+{\n+  return base.get_tyty ();\n+}\n+\n+BaseType *\n+PointerType::clone () const\n+{\n+  return new PointerType (get_ref (), get_ty_ref (), base, mutability (),\n+\t\t\t  get_combined_refs ());\n+}\n+\n+BaseType *\n+PointerType::monomorphized_clone () const\n+{\n+  return new PointerType (get_ref (), get_ty_ref (),\n+\t\t\t  base.monomorphized_clone (), mutability (),\n+\t\t\t  get_combined_refs ());\n+}\n+\n+PointerType *\n+PointerType::handle_substitions (SubstitutionArgumentMappings mappings)\n+{\n+  auto mappings_table = Analysis::Mappings::get ();\n+\n+  PointerType *ref = static_cast<PointerType *> (clone ());\n+  ref->set_ty_ref (mappings_table->get_next_hir_id ());\n+\n+  // might be &T or &ADT so this needs to be recursive\n+  auto base = ref->get_base ();\n+  BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n+  ref->base = TyVar::subst_covariant_var (base, concrete);\n+\n+  return ref;\n+}\n+\n+void\n+ParamType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ParamType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ParamType::as_string () const\n+{\n+  if (!can_resolve ())\n+    {\n+      return get_symbol () + \" REF: \" + std::to_string (get_ref ());\n+    }\n+\n+  BaseType *lookup = resolve ();\n+  return get_symbol () + \"=\" + lookup->as_string ();\n+}\n+\n+std::string\n+ParamType::get_name () const\n+{\n+  if (!can_resolve ())\n+    return get_symbol ();\n+\n+  return resolve ()->get_name ();\n+}\n+\n+BaseType *\n+ParamType::unify (BaseType *other)\n+{\n+  ParamRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+ParamType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  ParamCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+ParamType::clone () const\n+{\n+  return new ParamType (get_symbol (), ident.locus, get_ref (), get_ty_ref (),\n+\t\t\tparam, get_specified_bounds (), get_combined_refs ());\n+}\n+\n+BaseType *\n+ParamType::monomorphized_clone () const\n+{\n+  return resolve ()->clone ();\n+}\n+\n+std::string\n+ParamType::get_symbol () const\n+{\n+  return symbol;\n+}\n+\n+BaseType *\n+ParamType::resolve () const\n+{\n+  TyVar var (get_ty_ref ());\n+  BaseType *r = var.get_tyty ();\n+\n+  while (r->get_kind () == TypeKind::PARAM)\n+    {\n+      ParamType *rr = static_cast<ParamType *> (r);\n+      if (!rr->can_resolve ())\n+\tbreak;\n+\n+      TyVar v (rr->get_ty_ref ());\n+      r = v.get_tyty ();\n+    }\n+\n+  if (r->get_kind () == TypeKind::PARAM && (r->get_ref () == r->get_ty_ref ()))\n+    return TyVar (r->get_ty_ref ()).get_tyty ();\n+\n+  return r;\n+}\n+\n+bool\n+ParamType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    {\n+      if (!can_resolve ())\n+\treturn false;\n+\n+      return resolve ()->is_equal (other);\n+    }\n+\n+  auto other2 = static_cast<const ParamType &> (other);\n+  if (can_resolve () != other2.can_resolve ())\n+    return false;\n+\n+  if (can_resolve ())\n+    return resolve ()->can_eq (other2.resolve (), false);\n+\n+  return get_symbol ().compare (other2.get_symbol ()) == 0;\n+}\n+\n+ParamType *\n+ParamType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+{\n+  SubstitutionArg arg = SubstitutionArg::error ();\n+  bool ok = subst_mappings.get_argument_for_symbol (this, &arg);\n+  if (!ok || arg.is_error ())\n+    return this;\n+\n+  ParamType *p = static_cast<ParamType *> (clone ());\n+  subst_mappings.on_param_subst (*p, arg);\n+\n+  // there are two cases one where we substitute directly to a new PARAM and\n+  // otherwise\n+  if (arg.get_tyty ()->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      p->set_ty_ref (arg.get_tyty ()->get_ref ());\n+      return p;\n+    }\n+\n+  // this is the new subst that this needs to pass\n+  p->set_ref (mappings->get_next_hir_id ());\n+  p->set_ty_ref (arg.get_tyty ()->get_ref ());\n+\n+  return p;\n+}\n+\n+BaseType *\n+StrType::clone () const\n+{\n+  return new StrType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+BaseType *\n+StrType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+void\n+StrType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+StrType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+StrType::as_string () const\n+{\n+  return \"str\";\n+}\n+\n+BaseType *\n+StrType::unify (BaseType *other)\n+{\n+  StrRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+StrType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  StrCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+bool\n+StrType::is_equal (const BaseType &other) const\n+{\n+  return get_kind () == other.get_kind ();\n+}\n+\n+void\n+NeverType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+NeverType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+NeverType::as_string () const\n+{\n+  return \"!\";\n+}\n+\n+BaseType *\n+NeverType::unify (BaseType *other)\n+{\n+  NeverRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+NeverType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  NeverCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+NeverType::clone () const\n+{\n+  return new NeverType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+BaseType *\n+NeverType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+// placeholder type\n+\n+void\n+PlaceholderType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+PlaceholderType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+PlaceholderType::as_string () const\n+{\n+  return \"<placeholder:\" + (can_resolve () ? resolve ()->as_string () : \"\")\n+\t + \">\";\n+}\n+\n+BaseType *\n+PlaceholderType::unify (BaseType *other)\n+{\n+  PlaceholderRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  PlaceholderCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+PlaceholderType::clone () const\n+{\n+  return new PlaceholderType (get_symbol (), get_ref (), get_ty_ref (),\n+\t\t\t      get_combined_refs ());\n+}\n+\n+BaseType *\n+PlaceholderType::monomorphized_clone () const\n+{\n+  if (can_resolve ())\n+    return resolve ()->monomorphized_clone ();\n+\n+  return clone ();\n+}\n+\n+void\n+PlaceholderType::set_associated_type (HirId ref)\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->insert_associated_type_mapping (get_ty_ref (), ref);\n+}\n+\n+void\n+PlaceholderType::clear_associated_type ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->clear_associated_type_mapping (get_ty_ref ());\n+}\n+\n+bool\n+PlaceholderType::can_resolve () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  return context->lookup_associated_type_mapping (get_ty_ref (), nullptr);\n+}\n+\n+BaseType *\n+PlaceholderType::resolve () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  HirId mapping;\n+  bool ok = context->lookup_associated_type_mapping (get_ty_ref (), &mapping);\n+  rust_assert (ok);\n+\n+  return TyVar (mapping).get_tyty ();\n+}\n+\n+bool\n+PlaceholderType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    {\n+      if (!can_resolve ())\n+\treturn false;\n+\n+      return resolve ()->is_equal (other);\n+    }\n+\n+  auto other2 = static_cast<const PlaceholderType &> (other);\n+  return get_symbol ().compare (other2.get_symbol ()) == 0;\n+}\n+\n+// Projection type\n+\n+void\n+ProjectionType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ProjectionType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ProjectionType::as_string () const\n+{\n+  return \"<Projection=\" + subst_as_string () + \"::\" + base->as_string () + \">\";\n+}\n+\n+BaseType *\n+ProjectionType::unify (BaseType *other)\n+{\n+  return base->unify (other);\n+}\n+\n+bool\n+ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  return base->can_eq (other, emit_errors);\n+}\n+\n+BaseType *\n+ProjectionType::clone () const\n+{\n+  return new ProjectionType (get_ref (), get_ty_ref (), base->clone (), trait,\n+\t\t\t     item, clone_substs (), used_arguments,\n+\t\t\t     get_combined_refs ());\n+}\n+\n+BaseType *\n+ProjectionType::monomorphized_clone () const\n+{\n+  return get ()->monomorphized_clone ();\n+}\n+\n+ProjectionType *\n+ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+{\n+  // // do we really need to substitute this?\n+  // if (base->needs_generic_substitutions () || base->contains_type_parameters\n+  // ())\n+  //   {\n+  //     return this;\n+  //   }\n+\n+  ProjectionType *projection = static_cast<ProjectionType *> (clone ());\n+  projection->set_ty_ref (mappings->get_next_hir_id ());\n+  projection->used_arguments = subst_mappings;\n+\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->insert_implicit_type (projection->get_ty_ref (), projection);\n+\n+  for (auto &sub : projection->get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      if (ok)\n+\tsub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n+    }\n+\n+  auto fty = projection->base;\n+  bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+  if (is_param_ty)\n+    {\n+      ParamType *p = static_cast<ParamType *> (fty);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+      if (ok)\n+\t{\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      projection->base = new_field;\n+\t    }\n+\t  else\n+\t    {\n+\t      fty->set_ty_ref (argt->get_ref ());\n+\t    }\n+\t}\n+    }\n+  else if (fty->needs_generic_substitutions ()\n+\t   || fty->contains_type_parameters ())\n+    {\n+      BaseType *concrete\n+\t= Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+      if (concrete == nullptr || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve field substitution type: %s\",\n+\t\t\t fty->as_string ().c_str ());\n+\t  return nullptr;\n+\t}\n+\n+      projection->base = concrete;\n+    }\n+\n+  return projection;\n+}\n+\n+void\n+DynamicObjectType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+DynamicObjectType::accept_vis (TyConstVisitor &vis) const\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+DynamicObjectType::as_string () const\n+{\n+  return \"dyn [\" + raw_bounds_as_string () + \"]\";\n+}\n+\n+BaseType *\n+DynamicObjectType::unify (BaseType *other)\n+{\n+  DynamicRules r (this);\n+  return r.unify (other);\n+}\n+\n+bool\n+DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n+{\n+  DynamicCmp r (this, emit_errors);\n+  return r.can_eq (other);\n+}\n+\n+BaseType *\n+DynamicObjectType::clone () const\n+{\n+  return new DynamicObjectType (get_ref (), get_ty_ref (), ident,\n+\t\t\t\tspecified_bounds, get_combined_refs ());\n+}\n+\n+BaseType *\n+DynamicObjectType::monomorphized_clone () const\n+{\n+  return clone ();\n+}\n+\n+std::string\n+DynamicObjectType::get_name () const\n+{\n+  return \"dyn [\" + raw_bounds_as_name () + \"]\";\n+}\n+\n+bool\n+DynamicObjectType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  if (num_specified_bounds () != other.num_specified_bounds ())\n+    return false;\n+\n+  return bounds_compatible (other, Location (), false);\n+}\n+\n+const std::vector<\n+  std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n+DynamicObjectType::get_object_items () const\n+{\n+  std::vector<\n+    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n+    items;\n+  for (auto &bound : get_specified_bounds ())\n+    {\n+      const Resolver::TraitReference *trait = bound.get ();\n+      for (auto &item : trait->get_trait_items ())\n+\t{\n+\t  if (item.get_trait_item_type ()\n+\t\t== Resolver::TraitItemReference::TraitItemType::FN\n+\t      && item.is_object_safe ())\n+\t    items.push_back ({&item, &bound});\n+\t}\n+\n+      for (auto &super_trait : trait->get_super_traits ())\n+\t{\n+\t  for (auto &item : super_trait->get_trait_items ())\n+\t    {\n+\t      if (item.get_trait_item_type ()\n+\t\t    == Resolver::TraitItemReference::TraitItemType::FN\n+\t\t  && item.is_object_safe ())\n+\t\titems.push_back ({&item, &bound});\n+\t    }\n+\t}\n+    }\n+  return items;\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "c47921d44d71a9f63bbe7ba90f4cf6d1b95fd70e", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "added", "additions": 2533, "deletions": 0, "changes": 2533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24393cb68faadda19c9f0ba12b9bba501e8e4ff8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24393cb68faadda19c9f0ba12b9bba501e8e4ff8/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "patch": "@@ -0,0 +1,2533 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY\n+#define RUST_TYTY\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-abi.h\"\n+#include \"rust-common.h\"\n+#include \"rust-identifier.h\"\n+\n+namespace Rust {\n+\n+namespace Resolver {\n+class TraitReference;\n+class TraitItemReference;\n+class AssociatedImplTrait;\n+} // namespace Resolver\n+\n+namespace TyTy {\n+\n+// https://rustc-dev-guide.rust-lang.org/type-inference.html#inference-variables\n+// https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variants\n+enum TypeKind\n+{\n+  INFER,\n+  ADT,\n+  STR,\n+  REF,\n+  POINTER,\n+  PARAM,\n+  ARRAY,\n+  SLICE,\n+  FNDEF,\n+  FNPTR,\n+  TUPLE,\n+  BOOL,\n+  CHAR,\n+  INT,\n+  UINT,\n+  FLOAT,\n+  USIZE,\n+  ISIZE,\n+  NEVER,\n+  PLACEHOLDER,\n+  PROJECTION,\n+  DYNAMIC,\n+  CLOSURE,\n+  // there are more to add...\n+  ERROR\n+};\n+\n+extern bool\n+is_primitive_type_kind (TypeKind kind);\n+\n+class TypeKindFormat\n+{\n+public:\n+  static std::string to_string (TypeKind kind);\n+};\n+\n+class BaseType;\n+class TypeBoundPredicate;\n+class TypeBoundPredicateItem\n+{\n+public:\n+  TypeBoundPredicateItem (const TypeBoundPredicate *parent,\n+\t\t\t  const Resolver::TraitItemReference *trait_item_ref)\n+    : parent (parent), trait_item_ref (trait_item_ref)\n+  {}\n+\n+  static TypeBoundPredicateItem error ()\n+  {\n+    return TypeBoundPredicateItem (nullptr, nullptr);\n+  }\n+\n+  bool is_error () const\n+  {\n+    return parent == nullptr || trait_item_ref == nullptr;\n+  }\n+\n+  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n+\n+  const Resolver::TraitItemReference *get_raw_item () const;\n+\n+  bool needs_implementation () const;\n+\n+  const TypeBoundPredicate *get_parent () const { return parent; }\n+\n+  Location get_locus () const;\n+\n+private:\n+  const TypeBoundPredicate *parent;\n+  const Resolver::TraitItemReference *trait_item_ref;\n+};\n+\n+class TypeBoundsMappings\n+{\n+protected:\n+  TypeBoundsMappings (std::vector<TypeBoundPredicate> specified_bounds);\n+\n+public:\n+  std::vector<TypeBoundPredicate> &get_specified_bounds ();\n+\n+  const std::vector<TypeBoundPredicate> &get_specified_bounds () const;\n+\n+  size_t num_specified_bounds () const;\n+\n+  std::string raw_bounds_as_string () const;\n+\n+  std::string bounds_as_string () const;\n+\n+  std::string raw_bounds_as_name () const;\n+\n+protected:\n+  void add_bound (TypeBoundPredicate predicate);\n+\n+  std::vector<TypeBoundPredicate> specified_bounds;\n+};\n+\n+class TyVisitor;\n+class TyConstVisitor;\n+class BaseType : public TypeBoundsMappings\n+{\n+public:\n+  virtual ~BaseType () {}\n+\n+  HirId get_ref () const { return ref; }\n+\n+  void set_ref (HirId id)\n+  {\n+    if (id != ref)\n+      append_reference (ref);\n+    ref = id;\n+  }\n+\n+  HirId get_ty_ref () const { return ty_ref; }\n+\n+  void set_ty_ref (HirId id) { ty_ref = id; }\n+\n+  virtual void accept_vis (TyVisitor &vis) = 0;\n+\n+  virtual void accept_vis (TyConstVisitor &vis) const = 0;\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual std::string get_name () const = 0;\n+\n+  // Unify two types. Returns a pointer to the newly-created unified ty, or\n+  // nullptr if the two ty cannot be unified. The caller is responsible for\n+  // releasing the memory of the returned ty.\n+  virtual BaseType *unify (BaseType *other) = 0;\n+\n+  // similar to unify but does not actually perform type unification but\n+  // determines whether they are compatible. Consider the following\n+  //\n+  // fn foo<T>() -> T { ... }\n+  // fn foo() -> i32 { ... }\n+  //\n+  // when the function has been substituted they can be considered equal.\n+  //\n+  // It can also be used to optional emit errors for trait item compatibility\n+  // checks\n+  virtual bool can_eq (const BaseType *other, bool emit_errors) const = 0;\n+\n+  // Check value equality between two ty. Type inference rules are ignored. Two\n+  //   ty are considered equal if they're of the same kind, and\n+  //     1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n+  //     2. (For functions) have the same signature\n+  virtual bool is_equal (const BaseType &other) const\n+  {\n+    return get_kind () == other.get_kind ();\n+  }\n+\n+  bool satisfies_bound (const TypeBoundPredicate &predicate) const;\n+\n+  bool bounds_compatible (const BaseType &other, Location locus,\n+\t\t\t  bool emit_error) const;\n+\n+  void inherit_bounds (const BaseType &other);\n+\n+  void inherit_bounds (\n+    const std::vector<TyTy::TypeBoundPredicate> &specified_bounds);\n+\n+  virtual bool is_unit () const { return false; }\n+\n+  virtual bool is_concrete () const = 0;\n+\n+  TypeKind get_kind () const { return kind; }\n+\n+  /* Returns a pointer to a clone of this. The caller is responsible for\n+   * releasing the memory of the returned ty. */\n+  virtual BaseType *clone () const = 0;\n+\n+  // TODO\n+  virtual BaseType *monomorphized_clone () const = 0;\n+\n+  // get_combined_refs returns the chain of node refs involved in unification\n+  std::set<HirId> get_combined_refs () const { return combined; }\n+\n+  void append_reference (HirId id) { combined.insert (id); }\n+\n+  virtual bool supports_substitutions () const { return false; }\n+\n+  virtual bool has_subsititions_defined () const { return false; }\n+\n+  virtual bool can_substitute () const\n+  {\n+    return supports_substitutions () && has_subsititions_defined ();\n+  }\n+\n+  virtual bool needs_generic_substitutions () const { return false; }\n+\n+  bool contains_type_parameters () const { return !is_concrete (); }\n+\n+  std::string mappings_str () const\n+  {\n+    std::string buffer = \"Ref: \" + std::to_string (get_ref ())\n+\t\t\t + \" TyRef: \" + std::to_string (get_ty_ref ());\n+    buffer += \"[\";\n+    for (auto &ref : combined)\n+      buffer += std::to_string (ref) + \",\";\n+    buffer += \"]\";\n+    return \"(\" + buffer + \")\";\n+  }\n+\n+  std::string debug_str () const\n+  {\n+    return TypeKindFormat::to_string (get_kind ()) + \":\" + as_string () + \":\"\n+\t   + mappings_str () + \":\" + bounds_as_string ();\n+  }\n+\n+  void debug () const\n+  {\n+    rust_debug (\"[%p] %s\", static_cast<const void *> (this),\n+\t\tdebug_str ().c_str ());\n+  }\n+\n+  // FIXME this will eventually go away\n+  const BaseType *get_root () const;\n+\n+  // This will get the monomorphized type from Params, Placeholders or\n+  // Projections if available or error\n+  const BaseType *destructure () const;\n+\n+  const RustIdent &get_ident () const { return ident; }\n+\n+  Location get_locus () const { return ident.locus; }\n+\n+protected:\n+  BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n+\t    std::set<HirId> refs = std::set<HirId> ())\n+    : TypeBoundsMappings ({}), kind (kind), ref (ref), ty_ref (ty_ref),\n+      combined (refs), ident (ident), mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n+\t    std::vector<TypeBoundPredicate> specified_bounds,\n+\t    std::set<HirId> refs = std::set<HirId> ())\n+    : TypeBoundsMappings (specified_bounds), kind (kind), ref (ref),\n+      ty_ref (ty_ref), combined (refs), ident (ident),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  TypeKind kind;\n+  HirId ref;\n+  HirId ty_ref;\n+  std::set<HirId> combined;\n+  RustIdent ident;\n+\n+  Analysis::Mappings *mappings;\n+};\n+\n+// this is a placeholder for types that can change like inference variables\n+class TyVar\n+{\n+public:\n+  explicit TyVar (HirId ref);\n+\n+  HirId get_ref () const { return ref; }\n+\n+  BaseType *get_tyty () const;\n+\n+  TyVar clone () const;\n+\n+  TyVar monomorphized_clone () const;\n+\n+  static TyVar get_implicit_infer_var (Location locus);\n+\n+  static TyVar subst_covariant_var (TyTy::BaseType *orig,\n+\t\t\t\t    TyTy::BaseType *subst);\n+\n+private:\n+  HirId ref;\n+};\n+\n+class TyWithLocation\n+{\n+public:\n+  TyWithLocation (BaseType *ty, Location locus);\n+  TyWithLocation (BaseType *ty);\n+\n+  BaseType *get_ty () const { return ty; }\n+  Location get_locus () const { return locus; }\n+\n+private:\n+  BaseType *ty;\n+  Location locus;\n+};\n+\n+class InferType : public BaseType\n+{\n+public:\n+  enum InferTypeKind\n+  {\n+    GENERAL,\n+    INTEGRAL,\n+    FLOAT\n+  };\n+\n+  InferType (HirId ref, InferTypeKind infer_kind, Location locus,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::INFER,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      infer_kind (infer_kind)\n+  {}\n+\n+  InferType (HirId ref, HirId ty_ref, InferTypeKind infer_kind, Location locus,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::INFER,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      infer_kind (infer_kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  InferTypeKind get_infer_kind () const { return infer_kind; }\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool default_type (BaseType **type) const;\n+\n+  bool is_concrete () const final override { return true; }\n+\n+private:\n+  InferTypeKind infer_kind;\n+};\n+\n+class ErrorType : public BaseType\n+{\n+public:\n+  ErrorType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::ERROR,\n+\t\t{Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n+  {}\n+\n+  ErrorType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::ERROR,\n+\t\t{Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  bool is_unit () const override { return true; }\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool is_concrete () const final override { return false; }\n+};\n+\n+class SubstitutionArgumentMappings;\n+class ParamType : public BaseType\n+{\n+public:\n+  ParamType (std::string symbol, Location locus, HirId ref,\n+\t     HIR::GenericParam &param,\n+\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PARAM,\n+\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t\t locus},\n+\t\tspecified_bounds, refs),\n+      symbol (symbol), param (param)\n+  {}\n+\n+  ParamType (std::string symbol, Location locus, HirId ref, HirId ty_ref,\n+\t     HIR::GenericParam &param,\n+\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::PARAM,\n+\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t\t locus},\n+\t\tspecified_bounds, refs),\n+      symbol (symbol), param (param)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  std::string get_symbol () const;\n+\n+  HIR::GenericParam &get_generic_param () { return param; }\n+\n+  bool can_resolve () const { return get_ref () != get_ty_ref (); }\n+\n+  BaseType *resolve () const;\n+\n+  std::string get_name () const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  bool is_concrete () const override final\n+  {\n+    auto r = resolve ();\n+    if (r == this)\n+      return false;\n+\n+    return r->is_concrete ();\n+  }\n+\n+  ParamType *handle_substitions (SubstitutionArgumentMappings mappings);\n+\n+private:\n+  std::string symbol;\n+  HIR::GenericParam &param;\n+};\n+\n+class StructFieldType\n+{\n+public:\n+  StructFieldType (HirId ref, std::string name, BaseType *ty)\n+    : ref (ref), name (name), ty (ty)\n+  {}\n+\n+  HirId get_ref () const { return ref; }\n+\n+  std::string as_string () const;\n+\n+  bool is_equal (const StructFieldType &other) const;\n+\n+  std::string get_name () const { return name; }\n+\n+  BaseType *get_field_type () const { return ty; }\n+\n+  void set_field_type (BaseType *fty) { ty = fty; }\n+\n+  StructFieldType *clone () const;\n+\n+  StructFieldType *monomorphized_clone () const;\n+\n+  bool is_concrete () const { return ty->is_concrete (); }\n+\n+  void debug () const { rust_debug (\"%s\", as_string ().c_str ()); }\n+\n+private:\n+  HirId ref;\n+  std::string name;\n+  BaseType *ty;\n+};\n+\n+class TupleType : public BaseType\n+{\n+public:\n+  TupleType (HirId ref, Location locus,\n+\t     std::vector<TyVar> fields = std::vector<TyVar> (),\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::TUPLE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      fields (fields)\n+  {}\n+\n+  TupleType (HirId ref, HirId ty_ref, Location locus,\n+\t     std::vector<TyVar> fields = std::vector<TyVar> (),\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::TUPLE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      fields (fields)\n+  {}\n+\n+  static TupleType *get_unit_type (HirId ref)\n+  {\n+    return new TupleType (ref, Linemap::predeclared_location ());\n+  }\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  bool is_unit () const override { return this->fields.empty (); }\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  size_t num_fields () const { return fields.size (); }\n+\n+  BaseType *get_field (size_t index) const;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_concrete () const override final\n+  {\n+    for (size_t i = 0; i < num_fields (); i++)\n+      {\n+\tif (!get_field (i)->is_concrete ())\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n+  const std::vector<TyVar> &get_fields () const { return fields; }\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  TupleType *handle_substitions (SubstitutionArgumentMappings mappings);\n+\n+private:\n+  std::vector<TyVar> fields;\n+};\n+\n+class SubstitutionParamMapping\n+{\n+public:\n+  SubstitutionParamMapping (const HIR::TypeParam &generic, ParamType *param)\n+    : generic (generic), param (param)\n+  {}\n+\n+  SubstitutionParamMapping (const SubstitutionParamMapping &other)\n+    : generic (other.generic), param (other.param)\n+  {}\n+\n+  std::string as_string () const\n+  {\n+    if (param == nullptr)\n+      return \"nullptr\";\n+\n+    return param->get_name ();\n+  }\n+\n+  bool fill_param_ty (SubstitutionArgumentMappings &subst_mappings,\n+\t\t      Location locus);\n+\n+  SubstitutionParamMapping clone () const\n+  {\n+    return SubstitutionParamMapping (generic, static_cast<ParamType *> (\n+\t\t\t\t\t\tparam->clone ()));\n+  }\n+\n+  ParamType *get_param_ty () { return param; }\n+\n+  const ParamType *get_param_ty () const { return param; }\n+\n+  const HIR::TypeParam &get_generic_param () { return generic; };\n+\n+  // this is used for the backend to override the HirId ref of the param to\n+  // what the concrete type is for the rest of the context\n+  void override_context ();\n+\n+  bool needs_substitution () const\n+  {\n+    return !(get_param_ty ()->is_concrete ());\n+  }\n+\n+  Location get_param_locus () const { return generic.get_locus (); }\n+\n+  bool param_has_default_ty () const { return generic.has_type (); }\n+\n+  BaseType *get_default_ty () const\n+  {\n+    TyVar var (generic.get_type_mappings ().get_hirid ());\n+    return var.get_tyty ();\n+  }\n+\n+  bool need_substitution () const;\n+\n+private:\n+  const HIR::TypeParam &generic;\n+  ParamType *param;\n+};\n+\n+class SubstitutionArg\n+{\n+public:\n+  SubstitutionArg (const SubstitutionParamMapping *param, BaseType *argument)\n+    : param (param), argument (argument)\n+  {}\n+\n+  // FIXME\n+  // the copy constructors need removed - they are unsafe see\n+  // TypeBoundPredicate\n+  SubstitutionArg (const SubstitutionArg &other)\n+    : param (other.param), argument (other.argument)\n+  {}\n+\n+  SubstitutionArg &operator= (const SubstitutionArg &other)\n+  {\n+    param = other.param;\n+    argument = other.argument;\n+    return *this;\n+  }\n+\n+  BaseType *get_tyty () { return argument; }\n+\n+  const BaseType *get_tyty () const { return argument; }\n+\n+  const SubstitutionParamMapping *get_param_mapping () const { return param; }\n+\n+  static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n+\n+  bool is_error () const { return param == nullptr || argument == nullptr; }\n+\n+  bool is_conrete () const\n+  {\n+    if (argument != nullptr)\n+      return true;\n+\n+    if (argument->get_kind () == TyTy::TypeKind::PARAM)\n+      return false;\n+\n+    return argument->is_concrete ();\n+  }\n+\n+  std::string as_string () const\n+  {\n+    return param->as_string ()\n+\t   + (argument != nullptr ? \":\" + argument->as_string () : \"\");\n+  }\n+\n+private:\n+  const SubstitutionParamMapping *param;\n+  BaseType *argument;\n+};\n+\n+typedef std::function<void (const ParamType &, const SubstitutionArg &)>\n+  ParamSubstCb;\n+class SubstitutionArgumentMappings\n+{\n+public:\n+  SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n+\t\t\t\tLocation locus,\n+\t\t\t\tParamSubstCb param_subst_cb = nullptr,\n+\t\t\t\tbool trait_item_flag = false)\n+    : mappings (mappings), locus (locus), param_subst_cb (param_subst_cb),\n+      trait_item_flag (trait_item_flag)\n+  {}\n+\n+  SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other)\n+    : mappings (other.mappings), locus (other.locus),\n+      param_subst_cb (other.param_subst_cb),\n+      trait_item_flag (other.trait_item_flag)\n+  {}\n+\n+  SubstitutionArgumentMappings &\n+  operator= (const SubstitutionArgumentMappings &other)\n+  {\n+    mappings = other.mappings;\n+    locus = other.locus;\n+    param_subst_cb = other.param_subst_cb;\n+    trait_item_flag = other.trait_item_flag;\n+\n+    return *this;\n+  }\n+\n+  static SubstitutionArgumentMappings error ()\n+  {\n+    return SubstitutionArgumentMappings ({}, Location (), nullptr, false);\n+  }\n+\n+  bool is_error () const { return mappings.size () == 0; }\n+\n+  bool get_argument_for_symbol (const ParamType *param_to_find,\n+\t\t\t\tSubstitutionArg *argument)\n+  {\n+    for (auto &mapping : mappings)\n+      {\n+\tconst SubstitutionParamMapping *param = mapping.get_param_mapping ();\n+\tconst ParamType *p = param->get_param_ty ();\n+\n+\tif (p->get_symbol ().compare (param_to_find->get_symbol ()) == 0)\n+\t  {\n+\t    *argument = mapping;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  bool get_argument_at (size_t index, SubstitutionArg *argument)\n+  {\n+    if (index > mappings.size ())\n+      return false;\n+\n+    *argument = mappings.at (index);\n+    return true;\n+  }\n+\n+  // is_concrete means if the used args is non error, ie: non empty this will\n+  // verify if actual real types have been put in place of are they still\n+  // ParamTy\n+  bool is_concrete () const\n+  {\n+    for (auto &mapping : mappings)\n+      {\n+\tif (!mapping.is_conrete ())\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  size_t size () const { return mappings.size (); }\n+\n+  bool is_empty () const { return size () == 0; }\n+\n+  std::vector<SubstitutionArg> &get_mappings () { return mappings; }\n+\n+  const std::vector<SubstitutionArg> &get_mappings () const { return mappings; }\n+\n+  std::string as_string () const\n+  {\n+    std::string buffer;\n+    for (auto &mapping : mappings)\n+      {\n+\tbuffer += mapping.as_string () + \", \";\n+      }\n+    return \"<\" + buffer + \">\";\n+  }\n+\n+  void on_param_subst (const ParamType &p, const SubstitutionArg &a) const\n+  {\n+    if (param_subst_cb == nullptr)\n+      return;\n+\n+    param_subst_cb (p, a);\n+  }\n+\n+  ParamSubstCb get_subst_cb () const { return param_subst_cb; }\n+\n+  bool trait_item_mode () const { return trait_item_flag; }\n+\n+private:\n+  std::vector<SubstitutionArg> mappings;\n+  Location locus;\n+  ParamSubstCb param_subst_cb;\n+  bool trait_item_flag;\n+};\n+\n+class SubstitutionRef\n+{\n+public:\n+  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions,\n+\t\t   SubstitutionArgumentMappings arguments)\n+    : substitutions (substitutions), used_arguments (arguments)\n+  {}\n+\n+  bool has_substitutions () const { return substitutions.size () > 0; }\n+\n+  std::string subst_as_string () const\n+  {\n+    std::string buffer;\n+    for (size_t i = 0; i < substitutions.size (); i++)\n+      {\n+\tconst SubstitutionParamMapping &sub = substitutions.at (i);\n+\tbuffer += sub.as_string ();\n+\n+\tif ((i + 1) < substitutions.size ())\n+\t  buffer += \", \";\n+      }\n+\n+    return buffer.empty () ? \"\" : \"<\" + buffer + \">\";\n+  }\n+\n+  size_t get_num_substitutions () const { return substitutions.size (); }\n+\n+  std::vector<SubstitutionParamMapping> &get_substs () { return substitutions; }\n+\n+  const std::vector<SubstitutionParamMapping> &get_substs () const\n+  {\n+    return substitutions;\n+  }\n+\n+  std::vector<SubstitutionParamMapping> clone_substs () const\n+  {\n+    std::vector<SubstitutionParamMapping> clone;\n+\n+    for (auto &sub : substitutions)\n+      clone.push_back (sub.clone ());\n+\n+    return clone;\n+  }\n+\n+  void override_context ()\n+  {\n+    for (auto &sub : substitutions)\n+      {\n+\tsub.override_context ();\n+      }\n+  }\n+\n+  bool needs_substitution () const\n+  {\n+    for (auto &sub : substitutions)\n+      {\n+\tif (sub.need_substitution ())\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n+  bool was_substituted () const { return !needs_substitution (); }\n+\n+  SubstitutionArgumentMappings get_substitution_arguments () const\n+  {\n+    return used_arguments;\n+  }\n+\n+  // this is the count of type params that are not substituted fuly\n+  size_t num_required_substitutions () const\n+  {\n+    size_t n = 0;\n+    for (auto &p : substitutions)\n+      {\n+\tif (p.needs_substitution ())\n+\t  n++;\n+      }\n+    return n;\n+  }\n+\n+  // this is the count of type params that need substituted taking into account\n+  // possible defaults\n+  size_t min_required_substitutions () const\n+  {\n+    size_t n = 0;\n+    for (auto &p : substitutions)\n+      {\n+\tif (p.needs_substitution () && !p.param_has_default_ty ())\n+\t  n++;\n+      }\n+    return n;\n+  }\n+\n+  // We are trying to subst <i32, f32> into Struct Foo<X,Y> {}\n+  // in the case of Foo<i32,f32>{...}\n+  //\n+  // the substitions we have here define X,Y but the arguments have no bindings\n+  // so its a matter of ordering\n+  SubstitutionArgumentMappings\n+  get_mappings_from_generic_args (HIR::GenericArgs &args);\n+\n+  // Recursive substitutions\n+  // Foo <A,B> { a:A, b: B}; Bar <X,Y,Z>{a:X, b: Foo<Y,Z>}\n+  //\n+  // we have bindings for X Y Z and need to propagate the binding Y,Z into Foo\n+  // Which binds to A,B\n+  SubstitutionArgumentMappings\n+  adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n+\n+  // Are the mappings here actually bound to this type. For example imagine the\n+  // case:\n+  //\n+  // struct Foo<T>(T);\n+  // impl<T> Foo<T> {\n+  //   fn test(self) { ... }\n+  // }\n+  //\n+  // In this case we have a generic ADT of Foo and an impl block of a generic T\n+  // on Foo for the Self type. When we it comes to path resolution we can have:\n+  //\n+  // Foo::<i32>::test()\n+  //\n+  // This means the first segment of Foo::<i32> returns the ADT Foo<i32> not the\n+  // Self ADT bound to the T from the impl block. This means when it comes to\n+  // the next segment of test which resolves to the function we need to check\n+  // wether the arguments in the struct definition of foo can be bound here\n+  // before substituting the previous segments type here. This functions acts as\n+  // a guard for the solve_mappings_from_receiver_for_self to handle the case\n+  // where arguments are not bound. This is important for this next case:\n+  //\n+  // struct Baz<A, B>(A, B);\n+  // impl Baz<i32, f32> {\n+  //   fn test<X>(a: X) -> X {\n+  //       a\n+  //   }\n+  // }\n+  //\n+  // In this case Baz has been already substituted for the impl's Self to become\n+  // ADT<i32, f32> so that the function test only has 1 generic argument of X.\n+  // The path for this will be:\n+  //\n+  // Baz::test::<_>(123)\n+  //\n+  // So the first segment here will be Baz<_, _> to try and infer the arguments\n+  // which will be taken from the impl's Self type in this case since it is\n+  // already substituted and like the previous case the check to see if we need\n+  // to inherit the previous segments generic arguments takes place but the\n+  // generic arguments are not bound to this type as they have already been\n+  // substituted.\n+  //\n+  // Its important to remember from the first example the FnType actually looks\n+  // like:\n+  //\n+  // fn <T>test(self :Foo<T>(T))\n+  //\n+  // As the generic parameters are \"bound\" to each of the items in the impl\n+  // block. So this check is about wether the arguments we have here can\n+  // actually be bound to this type.\n+  bool are_mappings_bound (SubstitutionArgumentMappings &mappings);\n+\n+  // struct Foo<A, B>(A, B);\n+  //\n+  // impl<T> Foo<T, f32>;\n+  //     -> fn test<X>(self, a: X) -> X\n+  //\n+  // We might invoke this via:\n+  //\n+  // a = Foo(123, 456f32);\n+  // b = a.test::<bool>(false);\n+  //\n+  // we need to figure out relevant generic arguemts for self to apply to the\n+  // fntype\n+  SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n+    SubstitutionArgumentMappings &mappings) const;\n+\n+  // TODO comment\n+  SubstitutionArgumentMappings\n+  solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n+\n+  // TODO comment\n+  BaseType *infer_substitions (Location locus)\n+  {\n+    std::vector<SubstitutionArg> args;\n+    std::map<std::string, BaseType *> argument_mappings;\n+    for (auto &p : get_substs ())\n+      {\n+\tif (p.needs_substitution ())\n+\t  {\n+\t    const std::string &symbol = p.get_param_ty ()->get_symbol ();\n+\t    auto it = argument_mappings.find (symbol);\n+\t    if (it == argument_mappings.end ())\n+\t      {\n+\t\tTyVar infer_var = TyVar::get_implicit_infer_var (locus);\n+\t\targs.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t\targument_mappings[symbol] = infer_var.get_tyty ();\n+\t      }\n+\t    else\n+\t      {\n+\t\targs.push_back (SubstitutionArg (&p, it->second));\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    args.push_back (\n+\t      SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t  }\n+      }\n+\n+    SubstitutionArgumentMappings infer_arguments (std::move (args), locus);\n+    return handle_substitions (std::move (infer_arguments));\n+  }\n+\n+  // TODO comment\n+  bool monomorphize ();\n+\n+  // TODO comment\n+  virtual BaseType *handle_substitions (SubstitutionArgumentMappings mappings)\n+    = 0;\n+\n+  SubstitutionArgumentMappings get_used_arguments () const\n+  {\n+    return used_arguments;\n+  }\n+\n+protected:\n+  std::vector<SubstitutionParamMapping> substitutions;\n+  SubstitutionArgumentMappings used_arguments;\n+};\n+\n+class TypeBoundPredicate : public SubstitutionRef\n+{\n+public:\n+  TypeBoundPredicate (const Resolver::TraitReference &trait_reference,\n+\t\t      Location locus);\n+\n+  TypeBoundPredicate (DefId reference,\n+\t\t      std::vector<SubstitutionParamMapping> substitutions,\n+\t\t      Location locus);\n+\n+  TypeBoundPredicate (const TypeBoundPredicate &other);\n+\n+  TypeBoundPredicate &operator= (const TypeBoundPredicate &other);\n+\n+  static TypeBoundPredicate error ();\n+\n+  std::string as_string () const;\n+\n+  std::string as_name () const;\n+\n+  const Resolver::TraitReference *get () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::string get_name () const;\n+\n+  // check that this predicate is object-safe see:\n+  // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n+  bool is_object_safe (bool emit_error, Location locus) const;\n+\n+  void apply_generic_arguments (HIR::GenericArgs *generic_args);\n+\n+  bool contains_item (const std::string &search) const;\n+\n+  TypeBoundPredicateItem\n+  lookup_associated_item (const std::string &search) const;\n+\n+  TypeBoundPredicateItem\n+  lookup_associated_item (const Resolver::TraitItemReference *ref) const;\n+\n+  // WARNING THIS WILL ALWAYS RETURN NULLPTR\n+  BaseType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n+  bool is_error () const;\n+\n+  bool requires_generic_args () const;\n+\n+private:\n+  DefId reference;\n+  Location locus;\n+  bool error_flag;\n+};\n+\n+// https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.VariantDef.html\n+class VariantDef\n+{\n+public:\n+  enum VariantType\n+  {\n+    NUM,\n+    TUPLE,\n+    STRUCT\n+  };\n+\n+  static std::string variant_type_string (VariantType type)\n+  {\n+    switch (type)\n+      {\n+      case NUM:\n+\treturn \"enumeral\";\n+      case TUPLE:\n+\treturn \"tuple\";\n+      case STRUCT:\n+\treturn \"struct\";\n+      }\n+    gcc_unreachable ();\n+    return \"\";\n+  }\n+\n+  VariantDef (HirId id, std::string identifier, RustIdent ident,\n+\t      HIR::Expr *discriminant)\n+    : id (id), identifier (identifier), ident (ident),\n+      discriminant (discriminant)\n+\n+  {\n+    type = VariantType::NUM;\n+    fields = {};\n+  }\n+\n+  VariantDef (HirId id, std::string identifier, RustIdent ident,\n+\t      VariantType type, HIR::Expr *discriminant,\n+\t      std::vector<StructFieldType *> fields)\n+    : id (id), identifier (identifier), ident (ident), type (type),\n+      discriminant (discriminant), fields (fields)\n+  {\n+    rust_assert (\n+      (type == VariantType::NUM && fields.empty ())\n+      || (type == VariantType::TUPLE || type == VariantType::STRUCT));\n+  }\n+\n+  VariantDef (const VariantDef &other)\n+    : id (other.id), identifier (other.identifier), ident (other.ident),\n+      type (other.type), discriminant (other.discriminant),\n+      fields (other.fields)\n+  {}\n+\n+  VariantDef &operator= (const VariantDef &other)\n+  {\n+    id = other.id;\n+    identifier = other.identifier;\n+    type = other.type;\n+    discriminant = other.discriminant;\n+    fields = other.fields;\n+    ident = other.ident;\n+\n+    return *this;\n+  }\n+\n+  static VariantDef &get_error_node ()\n+  {\n+    static VariantDef node\n+      = VariantDef (UNKNOWN_HIRID, \"\",\n+\t\t    {Resolver::CanonicalPath::create_empty (),\n+\t\t     Linemap::unknown_location ()},\n+\t\t    nullptr);\n+\n+    return node;\n+  }\n+\n+  bool is_error () const { return get_id () == UNKNOWN_HIRID; }\n+\n+  HirId get_id () const { return id; }\n+\n+  VariantType get_variant_type () const { return type; }\n+  bool is_data_variant () const { return type != VariantType::NUM; }\n+  bool is_dataless_variant () const { return type == VariantType::NUM; }\n+\n+  std::string get_identifier () const { return identifier; }\n+\n+  size_t num_fields () const { return fields.size (); }\n+  StructFieldType *get_field_at_index (size_t index)\n+  {\n+    rust_assert (index < fields.size ());\n+    return fields.at (index);\n+  }\n+\n+  std::vector<StructFieldType *> &get_fields ()\n+  {\n+    rust_assert (type != NUM);\n+    return fields;\n+  }\n+\n+  bool lookup_field (const std::string &lookup, StructFieldType **field_lookup,\n+\t\t     size_t *index) const\n+  {\n+    size_t i = 0;\n+    for (auto &field : fields)\n+      {\n+\tif (field->get_name ().compare (lookup) == 0)\n+\t  {\n+\t    if (index != nullptr)\n+\t      *index = i;\n+\n+\t    if (field_lookup != nullptr)\n+\t      *field_lookup = field;\n+\n+\t    return true;\n+\t  }\n+\ti++;\n+      }\n+    return false;\n+  }\n+\n+  HIR::Expr *get_discriminant () const\n+  {\n+    rust_assert (discriminant != nullptr);\n+    return discriminant;\n+  }\n+\n+  std::string as_string () const\n+  {\n+    if (type == VariantType::NUM)\n+      return identifier + \" = \" + discriminant->as_string ();\n+\n+    std::string buffer;\n+    for (size_t i = 0; i < fields.size (); ++i)\n+      {\n+\tbuffer += fields.at (i)->as_string ();\n+\tif ((i + 1) < fields.size ())\n+\t  buffer += \", \";\n+      }\n+\n+    if (type == VariantType::TUPLE)\n+      return identifier + \" (\" + buffer + \")\";\n+    else\n+      return identifier + \" {\" + buffer + \"}\";\n+  }\n+\n+  bool is_equal (const VariantDef &other) const\n+  {\n+    if (type != other.type)\n+      return false;\n+\n+    if (identifier.compare (other.identifier) != 0)\n+      return false;\n+\n+    if (discriminant != other.discriminant)\n+      return false;\n+\n+    if (fields.size () != other.fields.size ())\n+      return false;\n+\n+    for (size_t i = 0; i < fields.size (); i++)\n+      {\n+\tif (!fields.at (i)->is_equal (*other.fields.at (i)))\n+\t  return false;\n+      }\n+\n+    return true;\n+  }\n+\n+  VariantDef *clone () const\n+  {\n+    std::vector<StructFieldType *> cloned_fields;\n+    for (auto &f : fields)\n+      cloned_fields.push_back ((StructFieldType *) f->clone ());\n+\n+    return new VariantDef (id, identifier, ident, type, discriminant,\n+\t\t\t   cloned_fields);\n+  }\n+\n+  VariantDef *monomorphized_clone () const\n+  {\n+    std::vector<StructFieldType *> cloned_fields;\n+    for (auto &f : fields)\n+      cloned_fields.push_back ((StructFieldType *) f->monomorphized_clone ());\n+\n+    return new VariantDef (id, identifier, ident, type, discriminant,\n+\t\t\t   cloned_fields);\n+  }\n+\n+  const RustIdent &get_ident () const { return ident; }\n+\n+private:\n+  HirId id;\n+  std::string identifier;\n+  RustIdent ident;\n+  VariantType type;\n+  // can either be a structure or a discriminant value\n+  HIR::Expr *discriminant;\n+  std::vector<StructFieldType *> fields;\n+};\n+\n+class ADTType : public BaseType, public SubstitutionRef\n+{\n+public:\n+  enum ADTKind\n+  {\n+    STRUCT_STRUCT,\n+    TUPLE_STRUCT,\n+    UNION,\n+    ENUM\n+  };\n+\n+  // Representation options, specified via attributes e.g. #[repr(packed)]\n+  struct ReprOptions\n+  {\n+    // bool is_c;\n+    // bool is_transparent;\n+    //...\n+\n+    // For align and pack: 0 = unspecified. Nonzero = byte alignment.\n+    // It is an error for both to be nonzero, this should be caught when\n+    // parsing the #[repr] attribute.\n+    unsigned char align = 0;\n+    unsigned char pack = 0;\n+  };\n+\n+  ADTType (HirId ref, std::string identifier, RustIdent ident, ADTKind adt_kind,\n+\t   std::vector<VariantDef *> variants,\n+\t   std::vector<SubstitutionParamMapping> subst_refs,\n+\t   SubstitutionArgumentMappings generic_arguments\n+\t   = SubstitutionArgumentMappings::error (),\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::ADT, ident, refs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      identifier (identifier), variants (variants), adt_kind (adt_kind)\n+  {}\n+\n+  ADTType (HirId ref, HirId ty_ref, std::string identifier, RustIdent ident,\n+\t   ADTKind adt_kind, std::vector<VariantDef *> variants,\n+\t   std::vector<SubstitutionParamMapping> subst_refs,\n+\t   SubstitutionArgumentMappings generic_arguments\n+\t   = SubstitutionArgumentMappings::error (),\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::ADT, ident, refs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      identifier (identifier), variants (variants), adt_kind (adt_kind)\n+  {}\n+\n+  ADTType (HirId ref, HirId ty_ref, std::string identifier, RustIdent ident,\n+\t   ADTKind adt_kind, std::vector<VariantDef *> variants,\n+\t   std::vector<SubstitutionParamMapping> subst_refs, ReprOptions repr,\n+\t   SubstitutionArgumentMappings generic_arguments\n+\t   = SubstitutionArgumentMappings::error (),\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::ADT, ident, refs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      identifier (identifier), variants (variants), adt_kind (adt_kind),\n+      repr (repr)\n+  {}\n+\n+  ADTKind get_adt_kind () const { return adt_kind; }\n+  ReprOptions get_repr_options () const { return repr; }\n+\n+  bool is_struct_struct () const { return adt_kind == STRUCT_STRUCT; }\n+  bool is_tuple_struct () const { return adt_kind == TUPLE_STRUCT; }\n+  bool is_union () const { return adt_kind == UNION; }\n+  bool is_enum () const { return adt_kind == ENUM; }\n+\n+  bool is_unit () const override\n+  {\n+    if (number_of_variants () == 0)\n+      return true;\n+\n+    if (number_of_variants () == 1)\n+      return variants.at (0)->num_fields () == 0;\n+\n+    return false;\n+  }\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  std::string get_identifier () const { return identifier; }\n+\n+  std::string get_name () const override final\n+  {\n+    return identifier + subst_as_string ();\n+  }\n+\n+  bool is_concrete () const override final\n+  {\n+    for (auto &variant : variants)\n+      {\n+\tfor (auto &field : variant->get_fields ())\n+\t  {\n+\t    if (!field->is_concrete ())\n+\t      return false;\n+\t  }\n+      }\n+    return true;\n+  }\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n+  bool supports_substitutions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitutions ();\n+  }\n+\n+  size_t number_of_variants () const { return variants.size (); }\n+\n+  std::vector<VariantDef *> &get_variants () { return variants; }\n+  const std::vector<VariantDef *> &get_variants () const { return variants; }\n+\n+  bool lookup_variant (const std::string &lookup,\n+\t\t       VariantDef **found_variant) const\n+  {\n+    for (auto &variant : variants)\n+      {\n+\tif (variant->get_identifier ().compare (lookup) == 0)\n+\t  {\n+\t    *found_variant = variant;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  bool lookup_variant_by_id (HirId id, VariantDef **found_variant,\n+\t\t\t     int *index = nullptr) const\n+  {\n+    int i = 0;\n+    for (auto &variant : variants)\n+      {\n+\tif (variant->get_id () == id)\n+\t  {\n+\t    if (index != nullptr)\n+\t      *index = i;\n+\n+\t    *found_variant = variant;\n+\t    return true;\n+\t  }\n+\ti++;\n+      }\n+    return false;\n+  }\n+\n+  ADTType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n+private:\n+  std::string identifier;\n+  std::vector<VariantDef *> variants;\n+  ADTType::ADTKind adt_kind;\n+  ReprOptions repr;\n+};\n+\n+class FnType : public BaseType, public SubstitutionRef\n+{\n+public:\n+  static const uint8_t FNTYPE_DEFAULT_FLAGS = 0x00;\n+  static const uint8_t FNTYPE_IS_METHOD_FLAG = 0x01;\n+  static const uint8_t FNTYPE_IS_EXTERN_FLAG = 0x02;\n+  static const uint8_t FNTYPE_IS_VARADIC_FLAG = 0X04;\n+\n+  FnType (HirId ref, DefId id, std::string identifier, RustIdent ident,\n+\t  uint8_t flags, ABI abi,\n+\t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n+\t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n+\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::FNDEF, ident, refs),\n+      SubstitutionRef (std::move (subst_refs),\n+\t\t       SubstitutionArgumentMappings::error ()),\n+      params (std::move (params)), type (type), flags (flags),\n+      identifier (identifier), id (id), abi (abi)\n+  {\n+    LocalDefId local_def_id = id.localDefId;\n+    rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+  }\n+\n+  FnType (HirId ref, HirId ty_ref, DefId id, std::string identifier,\n+\t  RustIdent ident, uint8_t flags, ABI abi,\n+\t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n+\t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n+\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::FNDEF, ident, refs),\n+      SubstitutionRef (std::move (subst_refs),\n+\t\t       SubstitutionArgumentMappings::error ()),\n+      params (params), type (type), flags (flags), identifier (identifier),\n+      id (id), abi (abi)\n+  {\n+    LocalDefId local_def_id = id.localDefId;\n+    rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+  }\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  std::string get_identifier () const { return identifier; }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  size_t num_params () const { return params.size (); }\n+\n+  bool is_method () const\n+  {\n+    if (num_params () == 0)\n+      return false;\n+\n+    return (flags & FNTYPE_IS_METHOD_FLAG) != 0;\n+  }\n+\n+  bool is_extern () const { return (flags & FNTYPE_IS_EXTERN_FLAG) != 0; }\n+\n+  bool is_varadic () const { return (flags & FNTYPE_IS_VARADIC_FLAG) != 0; }\n+\n+  DefId get_id () const { return id; }\n+\n+  // get the Self type for the method\n+  BaseType *get_self_type () const\n+  {\n+    rust_assert (is_method ());\n+    return param_at (0).second;\n+  }\n+\n+  bool is_concrete () const override final\n+  {\n+    for (const auto &param : params)\n+      {\n+\tconst BaseType *p = param.second;\n+\tif (!p->is_concrete ())\n+\t  return false;\n+      }\n+    return get_return_type ()->is_concrete ();\n+  }\n+\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params ()\n+  {\n+    return params;\n+  }\n+\n+  const std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params () const\n+  {\n+    return params;\n+  }\n+\n+  std::pair<HIR::Pattern *, BaseType *> &param_at (size_t idx)\n+  {\n+    return params.at (idx);\n+  }\n+\n+  const std::pair<HIR::Pattern *, BaseType *> &param_at (size_t idx) const\n+  {\n+    return params.at (idx);\n+  }\n+\n+  BaseType *get_return_type () const { return type; }\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n+  bool supports_substitutions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitutions ();\n+  }\n+\n+  FnType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n+  ABI get_abi () const { return abi; }\n+\n+private:\n+  std::vector<std::pair<HIR::Pattern *, BaseType *>> params;\n+  BaseType *type;\n+  uint8_t flags;\n+  std::string identifier;\n+  DefId id;\n+  ABI abi;\n+};\n+\n+class FnPtr : public BaseType\n+{\n+public:\n+  FnPtr (HirId ref, Location locus, std::vector<TyVar> params,\n+\t TyVar result_type, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::FNPTR,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      params (std::move (params)), result_type (result_type)\n+  {}\n+\n+  FnPtr (HirId ref, HirId ty_ref, Location locus, std::vector<TyVar> params,\n+\t TyVar result_type, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::FNPTR,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      params (params), result_type (result_type)\n+  {}\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *get_return_type () const { return result_type.get_tyty (); }\n+\n+  size_t num_params () const { return params.size (); }\n+\n+  BaseType *param_at (size_t idx) const { return params.at (idx).get_tyty (); }\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  void iterate_params (std::function<bool (BaseType *)> cb) const\n+  {\n+    for (auto &p : params)\n+      {\n+\tif (!cb (p.get_tyty ()))\n+\t  return;\n+      }\n+  }\n+\n+  std::vector<TyVar> &get_params () { return params; }\n+  const std::vector<TyVar> &get_params () const { return params; }\n+\n+  bool is_concrete () const override final\n+  {\n+    for (auto &p : params)\n+      {\n+\tif (!p.get_tyty ()->is_concrete ())\n+\t  return false;\n+      }\n+    return result_type.get_tyty ()->is_concrete ();\n+  }\n+\n+private:\n+  std::vector<TyVar> params;\n+  TyVar result_type;\n+};\n+\n+class ClosureType : public BaseType, public SubstitutionRef\n+{\n+public:\n+  ClosureType (HirId ref, DefId id, RustIdent ident,\n+\t       std::vector<TyVar> parameter_types, TyVar result_type,\n+\t       std::vector<SubstitutionParamMapping> subst_refs,\n+\t       std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::CLOSURE, ident, refs),\n+      SubstitutionRef (std::move (subst_refs),\n+\t\t       SubstitutionArgumentMappings::error ()),\n+      parameter_types (std::move (parameter_types)),\n+      result_type (std::move (result_type)), id (id)\n+  {\n+    LocalDefId local_def_id = id.localDefId;\n+    rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+  }\n+\n+  ClosureType (HirId ref, HirId ty_ref, RustIdent ident, DefId id,\n+\t       std::vector<TyVar> parameter_types, TyVar result_type,\n+\t       std::vector<SubstitutionParamMapping> subst_refs,\n+\t       std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::CLOSURE, ident, refs),\n+      SubstitutionRef (std::move (subst_refs),\n+\t\t       SubstitutionArgumentMappings::error ()),\n+      parameter_types (std::move (parameter_types)),\n+      result_type (std::move (result_type)), id (id)\n+  {\n+    LocalDefId local_def_id = id.localDefId;\n+    rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+  }\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_concrete () const override final\n+  {\n+    for (auto &param : parameter_types)\n+      {\n+\tauto p = param.get_tyty ();\n+\tif (!p->is_concrete ())\n+\t  return false;\n+      }\n+    return result_type.get_tyty ()->is_concrete ();\n+  }\n+\n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n+  bool supports_substitutions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitutions ();\n+  }\n+\n+  ClosureType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n+private:\n+  std::vector<TyVar> parameter_types;\n+  TyVar result_type;\n+  DefId id;\n+};\n+\n+class ArrayType : public BaseType\n+{\n+public:\n+  ArrayType (HirId ref, Location locus, HIR::Expr &capacity_expr, TyVar base,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::ARRAY,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base), capacity_expr (capacity_expr)\n+  {}\n+\n+  ArrayType (HirId ref, HirId ty_ref, Location locus, HIR::Expr &capacity_expr,\n+\t     TyVar base, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::ARRAY,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base), capacity_expr (capacity_expr)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *get_element_type () const;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_concrete () const final override\n+  {\n+    return get_element_type ()->is_concrete ();\n+  }\n+\n+  HIR::Expr &get_capacity_expr () const { return capacity_expr; }\n+\n+  ArrayType *handle_substitions (SubstitutionArgumentMappings mappings);\n+\n+private:\n+  TyVar element_type;\n+  HIR::Expr &capacity_expr;\n+};\n+\n+class SliceType : public BaseType\n+{\n+public:\n+  SliceType (HirId ref, Location locus, TyVar base,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::SLICE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base)\n+  {}\n+\n+  SliceType (HirId ref, HirId ty_ref, Location locus, TyVar base,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::SLICE,\n+\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n+      element_type (base)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *get_element_type () const;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_concrete () const final override\n+  {\n+    return get_element_type ()->is_concrete ();\n+  }\n+\n+  SliceType *handle_substitions (SubstitutionArgumentMappings mappings);\n+\n+private:\n+  TyVar element_type;\n+};\n+\n+class BoolType : public BaseType\n+{\n+public:\n+  BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::BOOL,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::BOOL,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+  bool is_concrete () const override final { return true; }\n+};\n+\n+class IntType : public BaseType\n+{\n+public:\n+  enum IntKind\n+  {\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128\n+  };\n+\n+  IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::INT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      int_kind (kind)\n+  {}\n+\n+  IntType (HirId ref, HirId ty_ref, IntKind kind,\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::INT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      int_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  IntKind get_int_kind () const { return int_kind; }\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_equal (const BaseType &other) const override;\n+  bool is_concrete () const override final { return true; }\n+\n+private:\n+  IntKind int_kind;\n+};\n+\n+class UintType : public BaseType\n+{\n+public:\n+  enum UintKind\n+  {\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128\n+  };\n+\n+  UintType (HirId ref, UintKind kind, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::UINT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      uint_kind (kind)\n+  {}\n+\n+  UintType (HirId ref, HirId ty_ref, UintKind kind,\n+\t    std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::UINT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      uint_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  UintKind get_uint_kind () const { return uint_kind; }\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_equal (const BaseType &other) const override;\n+  bool is_concrete () const override final { return true; }\n+\n+private:\n+  UintKind uint_kind;\n+};\n+\n+class FloatType : public BaseType\n+{\n+public:\n+  enum FloatKind\n+  {\n+    F32,\n+    F64\n+  };\n+\n+  FloatType (HirId ref, FloatKind kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::FLOAT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      float_kind (kind)\n+  {}\n+\n+  FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::FLOAT,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      float_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  FloatKind get_float_kind () const { return float_kind; }\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_equal (const BaseType &other) const override;\n+  bool is_concrete () const override final { return true; }\n+\n+private:\n+  FloatKind float_kind;\n+};\n+\n+class USizeType : public BaseType\n+{\n+public:\n+  USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::USIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::USIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+  bool is_concrete () const override final { return true; }\n+};\n+\n+class ISizeType : public BaseType\n+{\n+public:\n+  ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::ISIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::ISIZE,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+  bool is_concrete () const override final { return true; }\n+};\n+\n+class CharType : public BaseType\n+{\n+public:\n+  CharType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::CHAR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  CharType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::CHAR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+  bool is_concrete () const override final { return true; }\n+};\n+\n+class StrType : public BaseType\n+{\n+public:\n+  StrType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::STR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  StrType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::STR,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+  bool is_concrete () const override final { return true; }\n+};\n+\n+class ReferenceType : public BaseType\n+{\n+public:\n+  ReferenceType (HirId ref, TyVar base, Mutability mut,\n+\t\t std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::REF,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n+  {}\n+\n+  ReferenceType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n+\t\t std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::REF,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n+  {}\n+\n+  BaseType *get_base () const;\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final\n+  {\n+    return \"&\" + get_base ()->get_name ();\n+  }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_concrete () const override final\n+  {\n+    return get_base ()->is_concrete ();\n+  }\n+\n+  ReferenceType *handle_substitions (SubstitutionArgumentMappings mappings);\n+\n+  Mutability mutability () const { return mut; }\n+\n+  bool is_mutable () const { return mut == Mutability::Mut; }\n+\n+  bool is_dyn_object () const\n+  {\n+    return is_dyn_slice_type () || is_dyn_str_type ();\n+  }\n+\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const\n+  {\n+    const TyTy::BaseType *element = get_base ()->destructure ();\n+    if (element->get_kind () != TyTy::TypeKind::SLICE)\n+      return false;\n+    if (slice == nullptr)\n+      return true;\n+\n+    *slice = static_cast<const TyTy::SliceType *> (element);\n+    return true;\n+  }\n+\n+  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const\n+  {\n+    const TyTy::BaseType *element = get_base ()->destructure ();\n+    if (element->get_kind () != TyTy::TypeKind::STR)\n+      return false;\n+    if (str == nullptr)\n+      return true;\n+\n+    *str = static_cast<const TyTy::StrType *> (element);\n+    return true;\n+  }\n+\n+private:\n+  TyVar base;\n+  Mutability mut;\n+};\n+\n+class PointerType : public BaseType\n+{\n+public:\n+  PointerType (HirId ref, TyVar base, Mutability mut,\n+\t       std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::POINTER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n+  {}\n+\n+  PointerType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n+\t       std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::POINTER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      base (base), mut (mut)\n+  {}\n+\n+  BaseType *get_base () const;\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  std::string get_name () const override final\n+  {\n+    return \"*\" + get_base ()->get_name ();\n+  }\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  bool is_concrete () const override final\n+  {\n+    return get_base ()->is_concrete ();\n+  }\n+\n+  PointerType *handle_substitions (SubstitutionArgumentMappings mappings);\n+\n+  Mutability mutability () const { return mut; }\n+\n+  bool is_mutable () const { return mut == Mutability::Mut; }\n+\n+  bool is_const () const { return mut == Mutability::Imm; }\n+\n+  bool is_dyn_object () const\n+  {\n+    return is_dyn_slice_type () || is_dyn_str_type ();\n+  }\n+\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const\n+  {\n+    const TyTy::BaseType *element = get_base ()->destructure ();\n+    if (element->get_kind () != TyTy::TypeKind::SLICE)\n+      return false;\n+    if (slice == nullptr)\n+      return true;\n+\n+    *slice = static_cast<const TyTy::SliceType *> (element);\n+    return true;\n+  }\n+\n+  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const\n+  {\n+    const TyTy::BaseType *element = get_base ()->destructure ();\n+    if (element->get_kind () != TyTy::TypeKind::STR)\n+      return false;\n+    if (str == nullptr)\n+      return true;\n+\n+    *str = static_cast<const TyTy::StrType *> (element);\n+    return true;\n+  }\n+\n+private:\n+  TyVar base;\n+  Mutability mut;\n+};\n+\n+// https://doc.rust-lang.org/std/primitive.never.html\n+//\n+// Since the `!` type is really complicated and it is even still unstable\n+// in rustc, only fairly limited support for this type is introduced here.\n+// Unification between `!` and ANY other type (including `<T?>`) is simply\n+// not allowed. If it is needed, it should be handled manually. For example,\n+// unifying `!` with other types is very necessary when resolving types of\n+// `if/else` expressions.\n+//\n+// See related discussion at https://github.com/Rust-GCC/gccrs/pull/364\n+class NeverType : public BaseType\n+{\n+public:\n+  NeverType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::NEVER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  NeverType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::NEVER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool is_unit () const override { return true; }\n+  bool is_concrete () const override final { return true; }\n+};\n+\n+// used at the type in associated types in traits\n+// see: https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+class PlaceholderType : public BaseType\n+{\n+public:\n+  PlaceholderType (std::string symbol, HirId ref,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PLACEHOLDER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      symbol (symbol)\n+  {}\n+\n+  PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      symbol (symbol)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool is_unit () const override\n+  {\n+    rust_assert (can_resolve ());\n+    return resolve ()->is_unit ();\n+  }\n+\n+  std::string get_symbol () const { return symbol; }\n+\n+  void set_associated_type (HirId ref);\n+\n+  void clear_associated_type ();\n+\n+  bool can_resolve () const;\n+\n+  BaseType *resolve () const;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  bool is_concrete () const override final\n+  {\n+    if (!can_resolve ())\n+      return true;\n+\n+    return resolve ()->is_concrete ();\n+  }\n+\n+private:\n+  std::string symbol;\n+};\n+\n+class ProjectionType : public BaseType, public SubstitutionRef\n+{\n+public:\n+  ProjectionType (HirId ref, BaseType *base,\n+\t\t  const Resolver::TraitReference *trait, DefId item,\n+\t\t  std::vector<SubstitutionParamMapping> subst_refs,\n+\t\t  SubstitutionArgumentMappings generic_arguments\n+\t\t  = SubstitutionArgumentMappings::error (),\n+\t\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PROJECTION,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      base (base), trait (trait), item (item)\n+  {}\n+\n+  ProjectionType (HirId ref, HirId ty_ref, BaseType *base,\n+\t\t  const Resolver::TraitReference *trait, DefId item,\n+\t\t  std::vector<SubstitutionParamMapping> subst_refs,\n+\t\t  SubstitutionArgumentMappings generic_arguments\n+\t\t  = SubstitutionArgumentMappings::error (),\n+\t\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::PROJECTION,\n+\t\t{Resolver::CanonicalPath::create_empty (),\n+\t\t Linemap::predeclared_location ()},\n+\t\trefs),\n+      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+      base (base), trait (trait), item (item)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool is_unit () const override { return false; }\n+\n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n+  bool supports_substitutions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitutions ();\n+  }\n+\n+  const BaseType *get () const { return base; }\n+  BaseType *get () { return base; }\n+\n+  bool is_concrete () const override final { return base->is_concrete (); }\n+\n+  ProjectionType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n+private:\n+  BaseType *base;\n+  const Resolver::TraitReference *trait;\n+  DefId item;\n+};\n+\n+class DynamicObjectType : public BaseType\n+{\n+public:\n+  DynamicObjectType (HirId ref, RustIdent ident,\n+\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n+  {}\n+\n+  DynamicObjectType (HirId ref, HirId ty_ref, RustIdent ident,\n+\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n+\n+  std::string get_name () const override final;\n+\n+  bool is_concrete () const override final { return true; }\n+\n+  // this returns a flat list of items including super trait bounds\n+  const std::vector<\n+    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n+  get_object_items () const;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY"}]}