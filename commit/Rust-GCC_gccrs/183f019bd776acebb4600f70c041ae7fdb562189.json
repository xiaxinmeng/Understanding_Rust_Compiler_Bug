{"sha": "183f019bd776acebb4600f70c041ae7fdb562189", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgzZjAxOWJkNzc2YWNlYmI0NjAwZjcwYzA0MWFlN2ZkYjU2MjE4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-09-04T07:28:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-09-04T07:28:15Z"}, "message": "mips.md (SHORT): New mode macro.\n\n\t* config/mips/mips.md (SHORT): New mode macro.\n\t(size): New mode attribute.\n\t(extend[qh]i[sd]i2): Redefine using :GPR and :SHORT.\n\t(*extend[qh]i[sd]i2): New define_insn_and_split, combining previous\n\t*extend[qh]i[sd]i2 and *extend[qh]i[sd]i2_mem patterns.  Use only if\n\t!ISA_HAS_SEB_SEH.\n\t(*extend[qh]i[sd]i2_se[bh]): New pattern, combining previous\n\t*extend[qh]isi2_hw patterns and extending them to di.\n\t(extendqihi2): Implement as define_insn_and_split that produces\n\textendqisi2 after reload.\n\nFrom-SVN: r87075", "tree": {"sha": "4721a7a6f039d6b0a45faa22cfc506e943d56c25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4721a7a6f039d6b0a45faa22cfc506e943d56c25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/183f019bd776acebb4600f70c041ae7fdb562189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/183f019bd776acebb4600f70c041ae7fdb562189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/183f019bd776acebb4600f70c041ae7fdb562189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/183f019bd776acebb4600f70c041ae7fdb562189/comments", "author": null, "committer": null, "parents": [{"sha": "351cfd8b8da5b9e80a488b6a24766371ebbe602d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351cfd8b8da5b9e80a488b6a24766371ebbe602d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/351cfd8b8da5b9e80a488b6a24766371ebbe602d"}], "stats": {"total": 242, "additions": 62, "deletions": 180}, "files": [{"sha": "f19a4f411fbfe89945fa7e89a907356c4d503911", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/183f019bd776acebb4600f70c041ae7fdb562189/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/183f019bd776acebb4600f70c041ae7fdb562189/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=183f019bd776acebb4600f70c041ae7fdb562189", "patch": "@@ -1,3 +1,16 @@\n+2004-09-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.md (SHORT): New mode macro.\n+\t(size): New mode attribute.\n+\t(extend[qh]i[sd]i2): Redefine using :GPR and :SHORT.\n+\t(*extend[qh]i[sd]i2): New define_insn_and_split, combining previous\n+\t*extend[qh]i[sd]i2 and *extend[qh]i[sd]i2_mem patterns.  Use only if\n+\t!ISA_HAS_SEB_SEH.\n+\t(*extend[qh]i[sd]i2_se[bh]): New pattern, combining previous\n+\t*extend[qh]isi2_hw patterns and extending them to di.\n+\t(extendqihi2): Implement as define_insn_and_split that produces\n+\textendqisi2 after reload.\n+\n 2004-09-03  Devang Patel  <dpatel@apple.com>\n \n \t* Makefile.in (OBJS-common): Add tree-if-conv.o"}, {"sha": "cc3f018a5c83cad4854e4c60c039f776789ec079", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 49, "deletions": 180, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/183f019bd776acebb4600f70c041ae7fdb562189/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/183f019bd776acebb4600f70c041ae7fdb562189/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=183f019bd776acebb4600f70c041ae7fdb562189", "patch": "@@ -324,6 +324,10 @@\n ;; conditional-move-type condition is needed.\n (define_mode_macro MOVECC [SI (DI \"TARGET_64BIT\") (CC \"TARGET_HARD_FLOAT\")])\n \n+;; This mode macro allows the QI and HI extension patterns to be defined from\n+;; the same template.\n+(define_mode_macro SHORT [QI HI])\n+\n ;; This mode macro allows :ANYF to be used wherever a scalar or vector\n ;; floating-point mode is allowed.\n (define_mode_macro ANYF [(SF \"TARGET_HARD_FLOAT\")\n@@ -338,6 +342,10 @@\n ;; 32-bit version and \"dsubu\" in the 64-bit version.\n (define_mode_attr d [(SI \"\") (DI \"d\")])\n \n+;; This attribute gives the length suffix for a sign- or zero-extension\n+;; instruction.\n+(define_mode_attr size [(QI \"b\") (HI \"h\")])\n+\n ;; Mode attributes for GPR loads and stores.\n (define_mode_attr load [(SI \"lw\") (DI \"ld\")])\n (define_mode_attr store [(SI \"sw\") (DI \"sd\")])\n@@ -2479,194 +2487,55 @@ beq\\t%2,%.,1b\\;\\\n   [(set_attr \"type\" \"arith,load\")\n    (set_attr \"mode\" \"DI\")])\n \n-;; These patterns originally accepted general_operands, however, slightly\n-;; better code is generated by only accepting register_operands, and then\n-;; letting combine generate the lh and lb insns.\n-\n-;; These expanders originally put values in registers first. We split\n-;; all non-mem patterns after reload.\n-\n-(define_expand \"extendhidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\")\n-        (sign_extend:DI (match_operand:HI 1 \"nonimmediate_operand\")))]\n-  \"TARGET_64BIT\"\n+(define_expand \"extend<SHORT:mode><GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+        (sign_extend:GPR (match_operand:SHORT 1 \"nonimmediate_operand\")))]\n   \"\")\n \n-(define_insn \"*extendhidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (sign_extend:DI (match_operand:HI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_64BIT\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-        (sign_extend:DI (match_operand:HI 1 \"register_operand\")))]\n-  \"TARGET_64BIT && reload_completed\"\n-  [(set (match_dup 0)\n-        (ashift:DI (match_dup 1) (const_int 48)))\n-   (set (match_dup 0)\n-        (ashiftrt:DI (match_dup 0) (const_int 48)))]\n-  \"operands[1] = gen_lowpart (DImode, operands[1]);\")\n-\n-(define_insn \"*extendhidi2_mem\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (sign_extend:DI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_64BIT\"\n-  \"lh\\t%0,%1\"\n-  [(set_attr \"type\"     \"load\")\n-   (set_attr \"mode\"     \"DI\")])\n-\n-(define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\")))]\n-  \"\"\n+(define_insn_and_split \"*extend<SHORT:mode><GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n+        (sign_extend:GPR\n+\t     (match_operand:SHORT 1 \"nonimmediate_operand\" \"d,m\")))]\n+  \"!ISA_HAS_SEB_SEH\"\n+  \"@\n+   #\n+   l<SHORT:size>\\t%0,%1\"\n+  \"&& reload_completed && REG_P (operands[1])\"\n+  [(set (match_dup 0) (ashift:GPR (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (ashiftrt:GPR (match_dup 0) (match_dup 2)))]\n {\n-  if (ISA_HAS_SEB_SEH)\n-    {\n-      emit_insn (gen_extendhisi2_hw (operands[0],\n-\t\t\t\t     force_reg (HImode, operands[1])));\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"*extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (sign_extend:SI (match_operand:HI 1 \"register_operand\")))]\n-  \"reload_completed\"\n-  [(set (match_dup 0)\n-        (ashift:SI (match_dup 1) (const_int 16)))\n-   (set (match_dup 0)\n-        (ashiftrt:SI (match_dup 0) (const_int 16)))]\n-  \"operands[1] = gen_lowpart (SImode, operands[1]);\")\n-\n-(define_insn \"extendhisi2_mem\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"lh\\t%0,%1\"\n-  [(set_attr \"type\"     \"load\")\n-   (set_attr \"mode\"     \"SI\")])\n+  operands[1] = gen_lowpart (<GPR:MODE>mode, operands[1]);\n+  operands[2] = GEN_INT (GET_MODE_BITSIZE (<GPR:MODE>mode)\n+\t\t\t - GET_MODE_BITSIZE (<SHORT:MODE>mode));\n+}\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")\n+   (set_attr \"length\" \"8,*\")])\n \n-(define_insn \"extendhisi2_hw\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+(define_insn \"*extend<SHORT:mode><GPR:mode>2_se<SHORT:size>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n+        (sign_extend:GPR\n+\t     (match_operand:SHORT 1 \"nonimmediate_operand\" \"d,m\")))]\n   \"ISA_HAS_SEB_SEH\"\n-  \"seh\\t%0,%1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\")\n-        (sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n-        (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\")\n-        (sign_extend:HI (match_operand:QI 1 \"register_operand\")))]\n-  \"reload_completed\"\n-  [(set (match_dup 0)\n-        (ashift:SI (match_dup 1) (const_int 24)))\n-   (set (match_dup 0)\n-        (ashiftrt:SI (match_dup 0) (const_int 24)))]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\")\n-\n-(define_insn \"*extendqihi2_internal_mem\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n-        (sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"lb\\t%0,%1\"\n-  [(set_attr \"type\"     \"load\")\n-   (set_attr \"mode\"     \"SI\")])\n-\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\")))]\n-  \"\"\n-{\n-  if (ISA_HAS_SEB_SEH)\n-    {\n-      emit_insn (gen_extendqisi2_hw (operands[0],\n-\t\t\t\t     force_reg (QImode, operands[1])));\n-      DONE;\n-    }\n-})\n+  \"@\n+   se<SHORT:size>\\t%0,%1\n+   l<SHORT:size>\\t%0,%1\"\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_insn \"*extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"d\")))]\n+;; This pattern generates the same code as extendqisi2; split it into\n+;; that form after reload.\n+(define_insn_and_split \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d\")\n+        (sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"d,m\")))]\n   \"\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (sign_extend:SI (match_operand:QI 1 \"register_operand\")))]\n+  \"#\"\n   \"reload_completed\"\n-  [(set (match_dup 0)\n-        (ashift:SI (match_dup 1) (const_int 24)))\n-   (set (match_dup 0)\n-        (ashiftrt:SI (match_dup 0) (const_int 24)))]\n-  \"operands[1] = gen_lowpart (SImode, operands[1]);\")\n-\n-(define_insn \"*extendqisi2_mem\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"lb\\t%0,%1\"\n-  [(set_attr \"type\"     \"load\")\n-   (set_attr \"mode\"     \"SI\")])\n-\n-(define_insn \"extendqisi2_hw\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"ISA_HAS_SEB_SEH\"\n-  \"seb\\t%0,%1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"extendqidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\")\n-        (sign_extend:DI (match_operand:QI 1 \"nonimmediate_operand\")))]\n-  \"TARGET_64BIT\"\n-  \"\")\n-\n-(define_insn \"*extendqidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (sign_extend:DI (match_operand:QI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_64BIT\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-        (sign_extend:DI (match_operand:QI 1 \"register_operand\")))]\n-  \"TARGET_64BIT && reload_completed\"\n-  [(set (match_dup 0)\n-        (ashift:DI (match_dup 1) (const_int 56)))\n-   (set (match_dup 0)\n-        (ashiftrt:DI (match_dup 0) (const_int 56)))]\n-  \"operands[1] = gen_lowpart (DImode, operands[1]);\")\n-\n-(define_insn \"*extendqidi2_mem\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (sign_extend:DI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_64BIT\"\n-  \"lb\\t%0,%1\"\n-  [(set_attr \"type\"     \"load\")\n-   (set_attr \"mode\"     \"DI\")])\n+  [(set (match_dup 0) (sign_extend:SI (match_dup 1)))]\n+  { operands[0] = gen_lowpart (SImode, operands[0]); }\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"length\" \"8,*\")])\n \n (define_insn \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")"}]}