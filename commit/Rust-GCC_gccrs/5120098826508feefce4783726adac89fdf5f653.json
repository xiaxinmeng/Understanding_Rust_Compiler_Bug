{"sha": "5120098826508feefce4783726adac89fdf5f653", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyMDA5ODgyNjUwOGZlZWZjZTQ3ODM3MjZhZGFjODlmZGY1ZjY1Mw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-12-05T18:53:20Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-12-05T18:53:20Z"}, "message": "(negsf2): Flip sign bit if software floating point.\n\n(negdf2,negxf2): Likewise.\n(abssf2): Zero sign bit if software floating point.\n(absdf2,absxf2): Likewise.\n\nFrom-SVN: r8608", "tree": {"sha": "f470b001b7f84c0a7e0f1383bc69bab8a7210320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f470b001b7f84c0a7e0f1383bc69bab8a7210320"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5120098826508feefce4783726adac89fdf5f653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5120098826508feefce4783726adac89fdf5f653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5120098826508feefce4783726adac89fdf5f653", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5120098826508feefce4783726adac89fdf5f653/comments", "author": null, "committer": null, "parents": [{"sha": "d537c24df239d35f32f5fb473b70607278c81e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d537c24df239d35f32f5fb473b70607278c81e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d537c24df239d35f32f5fb473b70607278c81e82"}], "stats": {"total": 197, "additions": 187, "deletions": 10}, "files": [{"sha": "bd826e16313b939fab91533e45b25977e48fe970", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 187, "deletions": 10, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5120098826508feefce4783726adac89fdf5f653/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5120098826508feefce4783726adac89fdf5f653/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=5120098826508feefce4783726adac89fdf5f653", "patch": "@@ -3292,11 +3292,34 @@\n   \"\"\n   \"neg%.b %0\")\n \n+;; If using software floating point, just flip the sign bit.\n+\n (define_expand \"negsf2\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(neg:SF (match_operand:SF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n-  \"\")\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_FPA && !TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+\n+      target = operand_subword_force (operands[0], 0, SFmode);\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+\n+      /* Make a place for REG_EQUAL.  */\n+      emit_move_insn (operands[0], operands[0]);\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=x,y\")\n@@ -3323,8 +3346,36 @@\n (define_expand \"negdf2\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n-  \"\")\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_FPA && !TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+      rtx insns;\n+\n+      start_sequence ();\n+      target = operand_subword (operands[0], 0, 1, DFmode);\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, DFmode),\n+\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+  \n+      emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n+\t\t      operand_subword_force (operands[1], 1, DFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=x,y\")\n@@ -3363,12 +3414,34 @@\n }\")\n \n ;; Absolute value instructions\n+;; If using software floating point, just zero the sign bit.\n \n (define_expand \"abssf2\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(abs:SF (match_operand:SF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n-  \"\")\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_FPA && !TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+\n+      target = operand_subword_force (operands[0], 0, SFmode);\n+      result = expand_binop (SImode, and_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t     GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+\n+      /* Make a place for REG_EQUAL.  */\n+      emit_move_insn (operands[0], operands[0]);\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=x,y\")\n@@ -3390,8 +3463,36 @@\n (define_expand \"absdf2\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(abs:DF (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881 || TARGET_FPA\"\n-  \"\")\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_FPA && !TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+      rtx insns;\n+\n+      start_sequence ();\n+      target = operand_subword (operands[0], 0, 1, DFmode);\n+      result = expand_binop (SImode, and_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, DFmode),\n+\t\t\t     GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+  \n+      emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n+\t\t      operand_subword_force (operands[1], 1, DFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=x,y\")\n@@ -5606,7 +5707,45 @@\n   return \\\"fdiv%.x %f2,%0\\\";\n }\")\n \n-(define_insn \"negxf2\"\n+(define_expand \"negxf2\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"\")\n+\t(neg:XF (match_operand:XF 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* ??? There isn't an FPA define_insn so we could handle it here too.\n+     For now we don't (paranoia).  */\n+  if (!TARGET_FPA && !TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+      rtx insns;\n+\n+      start_sequence ();\n+      target = operand_subword (operands[0], 0, 1, XFmode);\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, XFmode),\n+\t\t\t     GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+  \n+      emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 1, XFmode));\n+      emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 2, XFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"negxf2_68881\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=f\")\n \t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"fmF\")))]\n   \"TARGET_68881\"\n@@ -5617,7 +5756,45 @@\n   return \\\"fneg%.x %f1,%0\\\";\n }\")\n \n-(define_insn \"absxf2\"\n+(define_expand \"absxf2\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"\")\n+\t(abs:XF (match_operand:XF 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* ??? There isn't an FPA define_insn so we could handle it here too.\n+     For now we don't (paranoia).  */\n+  if (!TARGET_FPA && !TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+      rtx insns;\n+\n+      start_sequence ();\n+      target = operand_subword (operands[0], 0, 1, XFmode);\n+      result = expand_binop (SImode, and_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, XFmode),\n+\t\t\t     GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+  \n+      emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 1, XFmode));\n+      emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 2, XFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"absxf2_68881\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=f\")\n \t(abs:XF (match_operand:XF 1 \"nonimmediate_operand\" \"fmF\")))]\n   \"TARGET_68881\""}]}