{"sha": "041bfa6f07787752743e8c32c7a75a47015ba65a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQxYmZhNmYwNzc4Nzc1Mjc0M2U4YzMyYzdhNzVhNDcwMTViYTY1YQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2018-10-01T12:34:05Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2018-10-01T12:34:05Z"}, "message": "Fix caching of tests for multiple variant runs and update existing target-supports tests.\n\nCurrently some target supports checks such as vect_int cache their\nresults in a manner that would cause them not to be rechecked when\nrunning the same tests against a different variant in a multi variant\nrun.  This causes tests to be skipped or run when they shouldn't be.\n\nthere is already an existing caching mechanism in place that does the\ncaching correctly, but presumably these weren't used because some of these\ntests originally only contained static data. e.g. only checked if the target is\naarch64*-*-* etc.\n\nThis patch changes every function that needs to do any caching at all to use\ncheck_cached_effective_target which will cache per variant instead of globally.\n\nFor those tests that already parameterize over et_index I have created\ncheck_cached_effective_target_indexed to handle this common case by creating a list\ncontaining the property name and the current value of et_index.\n\nThese changes result in a much simpler implementation for most tests and a large\nreduction in lines for target-supports.exp.\n\nRegtested on\n  aarch64-none-elf\n  x86_64-pc-linux-gnu\n  powerpc64-unknown-linux-gnu\n  arm-none-eabi\n\nand no testsuite errors. Difference would depend on your site.exp.\nOn arm we get about 4500 new testcases and on aarch64 the low 10s.\nOn PowerPC and x86_64 no changes as expected since the default exp for these\njust test the default configuration.\n\nWhat this means for new target checks is that they should always use either\ncheck_cached_effective_target or check_cached_effective_target_indexed if the\nresult of the check is to be cached.\n\nAs an example the new vect_int looks like\n\nproc check_effective_target_vect_int { } {\n    return [check_cached_effective_target_indexed <name> {\n      expr {\n         <condition>\n\t}}]\n}\n\nThe debug information that was once there is now all hidden in\ncheck_cached_effective_target, (called from check_cached_effective_target_indexed)\nand so the only thing you are required to do is give it a unique cache name and a condition.\n\nThe condition doesn't need to be an if statement so simple boolean expressions are enough here:\n\n         [istarget i?86-*-*] || [istarget x86_64-*-*]\n         || ([istarget powerpc*-*-*]\n\t     && ![istarget powerpc-*-linux*paired*])\n         || ...\n\nFrom-SVN: r264745", "tree": {"sha": "7e2c9792ee27dd1c894dbc15fe520a6df8a23505", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e2c9792ee27dd1c894dbc15fe520a6df8a23505"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/041bfa6f07787752743e8c32c7a75a47015ba65a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041bfa6f07787752743e8c32c7a75a47015ba65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041bfa6f07787752743e8c32c7a75a47015ba65a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041bfa6f07787752743e8c32c7a75a47015ba65a/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03cc70b5f1999fe04354c0ba2227fce733308ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03cc70b5f1999fe04354c0ba2227fce733308ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03cc70b5f1999fe04354c0ba2227fce733308ad4"}], "stats": {"total": 1700, "additions": 421, "deletions": 1279}, "files": [{"sha": "20db918cdeb3e78e6a6b60cd3cb94250ea8a3458", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041bfa6f07787752743e8c32c7a75a47015ba65a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041bfa6f07787752743e8c32c7a75a47015ba65a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=041bfa6f07787752743e8c32c7a75a47015ba65a", "patch": "@@ -1,3 +1,90 @@\n+2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* lib/target-supports.exp (check_cached_effective_target_indexed): New.\n+\t(check_cached_effective_target, clear_effective_target_cache): Cleanup.\n+\t(check_compile): Support values already Boolean.\n+\t(check_alias_available, check_gc_sections_available,\n+\tcheck_profiling_available, check_effective_target_vect_cmdline_needed,\n+\tcheck_effective_target_vect_int,\n+\tcheck_effective_target_vect_intfloat_cvt,\n+\tcheck_effective_target_vect_doubleint_cvt,\n+\tcheck_effective_target_vect_intdouble_cvt,\n+\tcheck_effective_target_vect_uintfloat_cvt,\n+\tcheck_effective_target_vect_floatint_cvt,\n+\tcheck_effective_target_vect_floatuint_cvt,\n+\tcheck_effective_target_vect_peeling_profitable,\n+\tcheck_effective_target_vect_simd_clones,\n+\tcheck_effective_target_vect_peeling_profitable,\n+\tcheck_effective_target_vect_simd_clones,\n+\tcheck_effective_target_vect_shift,\n+\tcheck_effective_target_vect_bswap,\n+\tcheck_effective_target_vect_shift_char,\n+\tcheck_effective_target_vect_float,\n+\tcheck_effective_target_vect_double,\n+\tcheck_effective_target_vect_long_long,\n+\tcheck_effective_target_vect_no_int_min_max,\n+\tcheck_effective_target_vect_no_int_add,\n+\tcheck_effective_target_vect_no_bitwise,\n+\tcheck_effective_target_vect_perm,\n+\tcheck_effective_target_vect_perm_byte,\n+\tcheck_effective_target_vect_perm_short,\n+\tcheck_effective_target_xorsign,\n+\tcheck_effective_target_vect_widen_sum_hi_to_si_pattern,\n+\tcheck_effective_target_vect_widen_sum_hi_to_si,\n+\tcheck_effective_target_vect_widen_sum_qi_to_hi,\n+\tcheck_effective_target_vect_widen_sum_qi_to_si,\n+\tcheck_effective_target_vect_widen_mult_qi_to_hi,\n+\tcheck_effective_target_vect_widen_mult_hi_to_si,\n+\tcheck_effective_target_vect_widen_mult_qi_to_hi_pattern,\n+\tcheck_effective_target_vect_widen_mult_hi_to_si_pattern,\n+\tcheck_effective_target_vect_widen_mult_si_to_di_pattern,\n+\tcheck_effective_target_vect_widen_shift,\n+\tcheck_effective_target_vect_sdot_qi,\n+\tcheck_effective_target_vect_udot_qi,\n+\tcheck_effective_target_vect_sdot_hi,\n+\tcheck_effective_target_vect_udot_hi,\n+\tcheck_effective_target_vect_usad_char,\n+\tcheck_effective_target_vect_pack_trunc,\n+\tcheck_effective_target_vect_unpack,\n+\tcheck_effective_target_unaligned_stack,\n+\tcheck_effective_target_vect_no_align,\n+\tcheck_effective_target_vect_hw_misalign,\n+\tcheck_effective_target_natural_alignment_32,\n+\tcheck_effective_target_natural_alignment_64,\n+\tcheck_effective_target_vect_element_align,\n+\tcheck_effective_target_vect_load_lanes **,\n+\tcheck_effective_target_vect_condition,\n+\tcheck_effective_target_vect_cond_mixed,\n+\tcheck_effective_target_vect_char_mult,\n+\tcheck_effective_target_vect_short_mult,\n+\tcheck_effective_target_vect_int_mult,\n+\tcheck_effective_target_vect_extract_even_odd,\n+\tcheck_effective_target_vect_interleave,\n+\tcheck_effective_target_vect_stridedN,\n+\tcheck_effective_target_vect_call_copysignf,\n+\tcheck_effective_target_sqrt_insn,\n+\tcheck_effective_target_vect_call_sqrtf,\n+\tcheck_effective_target_vect_call_btrunc,\n+\tcheck_effective_target_vect_call_btruncf,\n+\tcheck_effective_target_vect_call_ceil,\n+\tcheck_effective_target_vect_call_ceilf,\n+\tcheck_effective_target_vect_call_floor,\n+\tcheck_effective_target_vect_call_floorf,\n+\tcheck_effective_target_vect_call_lceil,\n+\tcheck_effective_target_vect_call_lfloor,\n+\tcheck_effective_target_vect_call_nearbyint,\n+\tcheck_effective_target_vect_call_nearbyintf,\n+\tcheck_effective_target_vect_call_round,\n+\tcheck_effective_target_vect_call_roundf,\n+\tcheck_effective_target_section_anchors,\n+\tcheck_effective_target_bswap,\n+\tcheck_effective_target_sync_int_long,\n+\tcheck_effective_target_sync_char_short,\n+\tcheck_effective_target_tiny,\n+\tcheck_effective_target_pie_copyreloc,\n+\tcheck_effective_target_got32x_reloc,\n+\tcheck_effective_target_tls_get_addr_via_got): Use new caching.\n+\n 2018-10-01  MCC CS <deswurstes@users.noreply.github.com>\n \n \tPR tree-optimization/87261"}, {"sha": "2e2c65148ae0fb17ba545b7b7a17ac6e67c39c83", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 334, "deletions": 1279, "changes": 1613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041bfa6f07787752743e8c32c7a75a47015ba65a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041bfa6f07787752743e8c32c7a75a47015ba65a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=041bfa6f07787752743e8c32c7a75a47015ba65a", "patch": "@@ -37,6 +37,7 @@\n # and \"// Go\" for Go\n # If the tool is ObjC/ObjC++ then we overide the extension to .m/.mm to \n # allow for ObjC/ObjC++ specific flags.\n+\n proc check_compile {basename type contents args} {\n     global tool\n     verbose \"check_compile tool: $tool for $basename\" \n@@ -117,25 +118,35 @@ proc current_target_name { } {\n \n proc check_cached_effective_target { prop args } {\n     global et_cache\n-    global et_prop_list\n \n     set target [current_target_name]\n-    if {![info exists et_cache($prop,target)]\n-\t|| $et_cache($prop,target) != $target} {\n+    if {![info exists et_cache($prop,$target)]} {\n \tverbose \"check_cached_effective_target $prop: checking $target\" 2\n-\tset et_cache($prop,target) $target\n-\tset et_cache($prop,value) [uplevel eval $args]\n-\tif {![info exists et_prop_list]\n-\t    || [lsearch $et_prop_list $prop] < 0} {\n-\t    lappend et_prop_list $prop\n+\tif {[string is true -strict $args] || [string is false -strict $args]} {\n+\t    error {check_cached_effective_target condition already evaluated; did you pass [...] instead of the expected {...}?}\n+\t} else {\n+\t    set code [catch {uplevel eval $args} result]\n+\t    if {$code != 0 && $code != 2} {\n+\t\treturn -code $code $result\n+\t    }\n+\t    set et_cache($prop,$target) $result\n \t}\n-\tverbose \"check_cached_effective_target cached list is now: $et_prop_list\" 2\n     }\n-    set value $et_cache($prop,value)\n+    set value $et_cache($prop,$target)\n     verbose \"check_cached_effective_target $prop: returning $value for $target\" 2\n     return $value\n }\n \n+# Implements a version of check_cached_effective_target that also takes et_index\n+# into account when creating the key for the cache.\n+proc check_cached_effective_target_indexed { prop args } {\n+    global et_index\n+    set key \"$et_index $prop\"\n+    verbose \"check_cached_effective_target_index $prop: returning $key\" 2\n+\n+    return [check_cached_effective_target $key [list uplevel eval $args]]\n+}\n+\n # Clear effective-target cache. This is useful after testing\n # effective-target features and overriding TEST_ALWAYS_FLAGS and/or\n # ALWAYS_CXXFLAGS.\n@@ -147,16 +158,7 @@ proc check_cached_effective_target { prop args } {\n \n proc clear_effective_target_cache { } {\n     global et_cache\n-    global et_prop_list\n-\n-    if {[info exists et_prop_list]} {\n-\tverbose \"clear_effective_target_cache: $et_prop_list\" 2\n-\tforeach prop $et_prop_list {\n-\t    unset et_cache($prop,value)\n-\t    unset et_cache($prop,target)\n-\t}\n-\tunset et_prop_list\n-    }\n+    array unset et_cache\n }\n \n # Like check_compile, but delete the output file and return true if the\n@@ -380,12 +382,9 @@ proc check_visibility_available { what_kind } {\n # be determined.\n \n proc check_alias_available { } {\n-    global alias_available_saved\n     global tool\n \n-    if [info exists alias_available_saved] {\n-        verbose \"check_alias_available  returning saved $alias_available_saved\" 2\n-    } else {\n+    return [check_cached_effective_target alias_available {\n \tset src alias[pid].c\n \tset obj alias[pid].o\n         verbose \"check_alias_available  compiling testfile $src\" 2\n@@ -402,7 +401,7 @@ proc check_alias_available { } {\n \n \tif [string match \"\" $lines] then {\n \t    # No error messages, everything is OK.\n-\t    set alias_available_saved 2\n+\t    return 2\n \t} else {\n \t    if [regexp \"alias definitions not supported\" $lines] {\n \t\tverbose \"check_alias_available  target does not support aliases\" 2\n@@ -411,24 +410,20 @@ proc check_alias_available { } {\n \n \t\tif { $objformat == \"elf\" } {\n \t\t    verbose \"check_alias_available  but target uses ELF format, so it ought to\" 2\n-\t\t    set alias_available_saved -1\n+\t\t    return -1\n \t\t} else {\n-\t\t    set alias_available_saved 0\n+\t\t    return 0\n \t\t}\n \t    } else {\n \t\tif [regexp \"only weak aliases are supported\" $lines] {\n \t\tverbose \"check_alias_available  target supports only weak aliases\" 2\n-\t\tset alias_available_saved 1\n+\t\t    return 1\n \t\t} else {\n-\t\t    set alias_available_saved -1\n+\t\t    return -1\n \t\t}\n \t    }\n \t}\n-\n-\tverbose \"check_alias_available  returning $alias_available_saved\" 2\n-    }\n-\n-    return $alias_available_saved\n+    }]\n }\n \n # Returns 1 if the target toolchain supports strong aliases, 0 otherwise.\n@@ -461,44 +456,39 @@ proc check_ifunc_available { } {\n # Returns true if --gc-sections is supported on the target.\n \n proc check_gc_sections_available { } {\n-    global gc_sections_available_saved\n     global tool\n \n-    if {![info exists gc_sections_available_saved]} {\n+    return [check_cached_effective_target gc_sections_available {\n \t# Some targets don't support gc-sections despite whatever's\n \t# advertised by ld's options.\n \tif { [istarget alpha*-*-*]\n \t     || [istarget ia64-*-*] } {\n-\t    set gc_sections_available_saved 0\n \t    return 0\n \t}\n \n \t# elf2flt uses -q (--emit-relocs), which is incompatible with\n \t# --gc-sections.\n \tif { [board_info target exists ldflags]\n \t     && [regexp \" -elf2flt\\[ =\\]\" \" [board_info target ldflags] \"] } {\n-\t    set gc_sections_available_saved 0\n \t    return 0\n \t}\n \n \t# VxWorks kernel modules are relocatable objects linked with -r,\n \t# while RTP executables are linked with -q (--emit-relocs).\n \t# Both of these options are incompatible with --gc-sections.\n \tif { [istarget *-*-vxworks*] } {\n-\t    set gc_sections_available_saved 0\n \t    return 0\n \t}\n \n \t# Check if the ld used by gcc supports --gc-sections.\n \tset gcc_ld [lindex [${tool}_target_compile \"-print-prog-name=ld\" \"\" \"none\" \"\"] 0]\n \tset ld_output [remote_exec host \"$gcc_ld\" \"--help\"]\n \tif { [ string first \"--gc-sections\" $ld_output ] >= 0 } {\n-\t    set gc_sections_available_saved 1\n+\t    return 1\n \t} else {\n-\t    set gc_sections_available_saved 0\n+\t    return 0\n \t}\n-    }\n-    return $gc_sections_available_saved\n+    }]\n }\n \n # Return 1 if according to target_info struct and explicit target list\n@@ -581,8 +571,6 @@ proc profopt-perf-wrapper { } {\n # Return true if profiling is supported on the target.\n \n proc check_profiling_available { test_what } {\n-    global profiling_available_saved\n-\n     verbose \"Profiling argument is <$test_what>\" 1\n \n     # These conditions depend on the argument so examine them before\n@@ -657,7 +645,8 @@ proc check_profiling_available { test_what } {\n     }\n \n     # Now examine the cache variable.\n-    if {![info exists profiling_available_saved]} {\n+    set profiling_working \\\n+       [check_cached_effective_target profiling_available {\n \t# Some targets don't have any implementation of __bb_init_func or are\n \t# missing other needed machinery.\n \tif {[istarget aarch64*-*-elf]\n@@ -693,16 +682,15 @@ proc check_profiling_available { test_what } {\n \t     || [istarget xtensa*-*-elf]\n \t     || [istarget *-*-rtems*]\n \t     || [istarget *-*-vxworks*] } {\n-\t    set profiling_available_saved 0\n+\t    return 0\n \t} else {\n-\t    set profiling_available_saved 1\n+\t    return 1\n \t}\n-    }\n+    }]\n \n     # -pg link test result can't be cached since it may change between\n     # runs.\n-    set profiling_working $profiling_available_saved\n-    if { $profiling_available_saved == 1\n+    if { $profiling_working == 1\n          && ![check_no_compiler_messages_nocache profiling executable {\n \t      int main() { return 0; } } \"-pg\"] } {\n \tset profiling_working 0\n@@ -3045,7 +3033,6 @@ proc check_effective_target_ucn { } {\n # instruction set.\n \n proc check_effective_target_vect_cmdline_needed { } {\n-    global et_vect_cmdline_needed_saved\n     global et_vect_cmdline_needed_target_name\n \n     if { ![info exists et_vect_cmdline_needed_target_name] } {\n@@ -3063,10 +3050,7 @@ proc check_effective_target_vect_cmdline_needed { } {\n \t}\n     }\n \n-    if [info exists et_vect_cmdline_needed_saved] {\n-\tverbose \"check_effective_target_vect_cmdline_needed: using cached result\" 2\n-    } else {\n-\tset et_vect_cmdline_needed_saved 1\n+    return [check_cached_effective_target vect_cmdline_needed {\n \tif { [istarget alpha*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || (([istarget i?86-*-*] || [istarget x86_64-*-*])\n@@ -3078,119 +3062,73 @@ proc check_effective_target_vect_cmdline_needed { } {\n              || [istarget spu-*-*]\n \t     || ([istarget arm*-*-*] && [check_effective_target_arm_neon])\n \t     || [istarget aarch64*-*-*] } {\n-\t   set et_vect_cmdline_needed_saved 0\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_cmdline_needed: returning $et_vect_cmdline_needed_saved\" 2\n-    return $et_vect_cmdline_needed_saved\n+\t    return 0\n+\t} else {\n+\t    return 1\n+\t}}]\n }\n \n # Return 1 if the target supports hardware vectors of int, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_int { } {\n-    global et_vect_int_saved\n-    global et_index\n-\n-    if [info exists et_vect_int_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_int: using cached result\" 2\n-    } else {\n-\tset et_vect_int_saved($et_index) 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-             || ([istarget powerpc*-*-*]\n-\t\t && ![istarget powerpc-*-linux*paired*])\n-\t     || [istarget spu-*-*]\n-\t     || [istarget sparc*-*-*]\n-\t     || [istarget alpha*-*-*]\n-\t     || [istarget ia64-*-*] \n-\t     || [istarget aarch64*-*-*]\n-\t     || [is-effective-target arm_neon]\n-\t     || ([istarget mips*-*-*]\n-\t\t && ([et-is-effective-target mips_loongson]\n-\t\t     || [et-is-effective-target mips_msa]))\n-\t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_int_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_int:\\\n-\t     returning $et_vect_int_saved($et_index)\" 2\n-    return $et_vect_int_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_int {\n+      expr {\n+         [istarget i?86-*-*] || [istarget x86_64-*-*]\n+         || ([istarget powerpc*-*-*]\n+\t     && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget spu-*-*]\n+\t || [istarget sparc*-*-*]\n+\t || [istarget alpha*-*-*]\n+\t || [istarget ia64-*-*]\n+\t || [istarget aarch64*-*-*]\n+\t || [is-effective-target arm_neon]\n+\t || ([istarget mips*-*-*]\n+\t     && ([et-is-effective-target mips_loongson]\n+\t     || [et-is-effective-target mips_msa]))\n+\t || ([istarget s390*-*-*]\n+\t     && [check_effective_target_s390_vx])\n+\t}}]\n }\n \n # Return 1 if the target supports signed int->float conversion \n #\n \n proc check_effective_target_vect_intfloat_cvt { } {\n-    global et_vect_intfloat_cvt_saved\n-    global et_index\n-\n-    if [info exists et_vect_intfloat_cvt_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_intfloat_cvt:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_intfloat_cvt_saved($et_index) 0\n-        if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target_indexed vect_intfloat_cvt {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget powerpc*-*-*]\n \t\t && ![istarget powerpc-*-linux*paired*])\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_intfloat_cvt_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_intfloat_cvt:\\\n-\t     returning $et_vect_intfloat_cvt_saved($et_index)\" 2\n-    return $et_vect_intfloat_cvt_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if the target supports signed double->int conversion\n #\n \n proc check_effective_target_vect_doubleint_cvt { } {\n-    global et_vect_doubleint_cvt_saved\n-    global et_index\n-\n-    if [info exists et_vect_doubleint_cvt_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_doubleint_cvt: using cached result\" 2\n-    } else {\n-\tset et_vect_doubleint_cvt_saved($et_index) 0\n-\tif { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n-\t      && [check_no_compiler_messages vect_doubleint_cvt assembly {\n-\t\t  #ifdef __tune_atom__\n-\t\t  # error No double vectorizer support.\n-\t\t  #endif\n+    return [check_cached_effective_target_indexed vect_doubleint_cvt {\n+      expr { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t       && [check_no_compiler_messages vect_doubleint_cvt assembly {\n+\t\t   #ifdef __tune_atom__\n+\t\t   # error No double vectorizer support.\n+\t\t   #endif\n \t      }])\n-\t     || [istarget aarch64*-*-*]\n-\t     || [istarget spu-*-*]\n-\t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n-\t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_doubleint_cvt_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_doubleint_cvt:\\\n-\t     returning $et_vect_doubleint_cvt_saved($et_index)\" 2\n-    return $et_vect_doubleint_cvt_saved($et_index)\n+\t    || [istarget aarch64*-*-*]\n+\t    || [istarget spu-*-*]\n+\t    || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n+\t    || ([istarget mips*-*-*]\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if the target supports signed int->double conversion\n #\n \n proc check_effective_target_vect_intdouble_cvt { } {\n-    global et_vect_intdouble_cvt_saved\n-    global et_index\n-\n-    if [info exists et_vect_intdouble_cvt_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_intdouble_cvt: using cached result\" 2\n-    } else {\n-\tset et_vect_intdouble_cvt_saved($et_index) 0\n-\tif { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+    return [check_cached_effective_target_indexed vect_intdouble_cvt {\n+      expr { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n \t      && [check_no_compiler_messages vect_intdouble_cvt assembly {\n \t\t  #ifdef __tune_atom__\n \t\t  # error No double vectorizer support.\n@@ -3200,14 +3138,7 @@ proc check_effective_target_vect_intdouble_cvt { } {\n \t     || [istarget spu-*-*]\n \t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_intdouble_cvt_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_intdouble_cvt:\\\n-\t     returning $et_vect_intdouble_cvt_saved($et_index)\" 2\n-    return $et_vect_intdouble_cvt_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n #Return 1 if we're supporting __int128 for target, 0 otherwise.\n@@ -3228,132 +3159,64 @@ proc check_effective_target_int128 { } {\n #\n \n proc check_effective_target_vect_uintfloat_cvt { } {\n-    global et_vect_uintfloat_cvt_saved\n-    global et_index\n-\n-    if [info exists et_vect_uintfloat_cvt_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_uintfloat_cvt:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_uintfloat_cvt_saved($et_index) 0\n-        if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target_indexed vect_uintfloat_cvt {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget powerpc*-*-*]\n \t\t && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget aarch64*-*-*]\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_uintfloat_cvt_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_uintfloat_cvt:\\\n-\t     returning $et_vect_uintfloat_cvt_saved($et_index)\" 2\n-    return $et_vect_uintfloat_cvt_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n \n # Return 1 if the target supports signed float->int conversion\n #\n \n proc check_effective_target_vect_floatint_cvt { } {\n-    global et_vect_floatint_cvt_saved\n-    global et_index\n-\n-    if [info exists et_vect_floatint_cvt_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_floatint_cvt:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_floatint_cvt_saved($et_index) 0\n-        if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target_indexed vect_floatint_cvt {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget powerpc*-*-*]\n \t\t && ![istarget powerpc-*-linux*paired*])\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_floatint_cvt_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_floatint_cvt:\\\n-\t     returning $et_vect_floatint_cvt_saved($et_index)\" 2\n-    return $et_vect_floatint_cvt_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if the target supports unsigned float->int conversion\n #\n \n proc check_effective_target_vect_floatuint_cvt { } {\n-    global et_vect_floatuint_cvt_saved\n-    global et_index\n-\n-    if [info exists et_vect_floatuint_cvt_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_floatuint_cvt:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_floatuint_cvt_saved($et_index) 0\n-        if { ([istarget powerpc*-*-*]\n+    return [check_cached_effective_target_indexed vect_floatuint_cvt {\n+      expr { ([istarget powerpc*-*-*]\n \t      && ![istarget powerpc-*-linux*paired*])\n \t    || [is-effective-target arm_neon]\n \t    || ([istarget mips*-*-*]\n-\t\t&& [et-is-effective-target mips_msa]) } {\n-\t   set et_vect_floatuint_cvt_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_floatuint_cvt:\\\n-\t     returning $et_vect_floatuint_cvt_saved($et_index)\" 2\n-    return $et_vect_floatuint_cvt_saved($et_index)\n+\t\t&& [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if peeling for alignment might be profitable on the target\n #\n \n proc check_effective_target_vect_peeling_profitable { } {\n-    global et_vect_peeling_profitable_saved\n-    global et_index\n-\n-    if [info exists et_vect_peeling_profitable_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_peeling_profitable: using cached result\" 2\n-    } else {\n-\tset et_vect_peeling_profitable_saved($et_index) 1\n-        if { ([istarget s390*-*-*]\n+    return [check_cached_effective_target_indexed vect_peeling_profitable {\n+      expr { ([istarget s390*-*-*]\n \t      && [check_effective_target_s390_vx])\n-\t     || [check_effective_target_vect_element_align_preferred] } {\n-\t    set et_vect_peeling_profitable_saved($et_index) 0\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_peeling_profitable:\\\n-\t     returning $et_vect_peeling_profitable_saved($et_index)\" 2\n-    return $et_vect_peeling_profitable_saved($et_index)\n+\t    || [check_effective_target_vect_element_align_preferred] }}]\n }\n \n # Return 1 if the target supports #pragma omp declare simd, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_simd_clones { } {\n-    global et_vect_simd_clones_saved\n-    global et_index\n-\n-    if [info exists et_vect_simd_clones_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_simd_clones: using cached result\" 2\n-    } else {\n-\tset et_vect_simd_clones_saved($et_index) 0\n-\t# On i?86/x86_64 #pragma omp declare simd builds a sse2, avx,\n-\t# avx2 and avx512f clone.  Only the right clone for the\n-\t# specified arch will be chosen, but still we need to at least\n-\t# be able to assemble avx512f.\n-\tif { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n-\t      && [check_effective_target_avx512f]) } {\n-\t    set et_vect_simd_clones_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_simd_clones:\\\n-\t     returning $et_vect_simd_clones_saved($et_index)\" 2\n-    return $et_vect_simd_clones_saved($et_index)\n+    # On i?86/x86_64 #pragma omp declare simd builds a sse2, avx,\n+    # avx2 and avx512f clone.  Only the right clone for the\n+    # specified arch will be chosen, but still we need to at least\n+    # be able to assemble avx512f.\n+    return [check_cached_effective_target_indexed vect_simd_clones {\n+      expr { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t      && [check_effective_target_avx512f]) }}]\n }\n \n # Return 1 if this is a AArch64 target supporting big endian\n@@ -5439,14 +5302,8 @@ proc check_effective_target_sparc_vis { } {\n # Return 1 if the target supports hardware vector shift operation.\n \n proc check_effective_target_vect_shift { } {\n-    global et_vect_shift_saved\n-    global et_index\n-\n-    if [info exists et_vect_shift_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_shift: using cached result\" 2\n-    } else {\n-\tset et_vect_shift_saved($et_index) 0\n-\tif { ([istarget powerpc*-*-*]\n+    return [check_cached_effective_target_indexed vect_shift {\n+      expr {([istarget powerpc*-*-*]\n \t      && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n@@ -5456,14 +5313,7 @@ proc check_effective_target_vect_shift { } {\n \t\t && ([et-is-effective-target mips_msa]\n \t\t     || [et-is-effective-target mips_loongson]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_shift_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_shift:\\\n-\t     returning $et_vect_shift_saved($et_index)\" 2\n-    return $et_vect_shift_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n proc check_effective_target_whole_vector_shift { } {\n@@ -5489,49 +5339,21 @@ proc check_effective_target_whole_vector_shift { } {\n # Return 1 if the target supports vector bswap operations.\n \n proc check_effective_target_vect_bswap { } {\n-    global et_vect_bswap_saved\n-    global et_index\n-\n-    if [info exists et_vect_bswap_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_bswap: using cached result\" 2\n-    } else {\n-\tset et_vect_bswap_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*]\n-             || [is-effective-target arm_neon]\n-\t   } {\n-\t   set et_vect_bswap_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_bswap:\\\n-\t     returning $et_vect_bswap_saved($et_index)\" 2\n-    return $et_vect_bswap_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_bswap {\n+      expr { [istarget aarch64*-*-*] || [is-effective-target arm_neon] }}]\n }\n \n # Return 1 if the target supports hardware vector shift operation for char.\n \n proc check_effective_target_vect_shift_char { } {\n-    global et_vect_shift_char_saved\n-    global et_index\n-\n-    if [info exists et_vect_shift_char_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_shift_char: using cached result\" 2\n-    } else {\n-\tset et_vect_shift_char_saved($et_index) 0\n-\tif { ([istarget powerpc*-*-*]\n+    return [check_cached_effective_target_indexed vect_shift_char {\n+      expr { ([istarget powerpc*-*-*]\n              && ![istarget powerpc-*-linux*paired*])\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_shift_char_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_shift_char:\\\n-\t     returning $et_vect_shift_char_saved($et_index)\" 2\n-    return $et_vect_shift_char_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports hardware vectors of long, 0 otherwise.\n@@ -5565,14 +5387,8 @@ proc check_effective_target_vect_long { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_float { } {\n-    global et_vect_float_saved\n-    global et_index\n-\n-    if [info exists et_vect_float_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_float: using cached result\" 2\n-    } else {\n-\tset et_vect_float_saved($et_index) 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target_indexed vect_float {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget mips-sde-elf]\n@@ -5583,14 +5399,7 @@ proc check_effective_target_vect_float { } {\n \t\t && [et-is-effective-target mips_msa])\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vxe]) } {\n-\t    set et_vect_float_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_float:\\\n-\t     returning $et_vect_float_saved($et_index)\" 2\n-    return $et_vect_float_saved($et_index)\n+\t\t && [check_effective_target_s390_vxe]) }}]\n }\n \n # Return 1 if the target supports hardware vectors of float without\n@@ -5606,33 +5415,20 @@ proc check_effective_target_vect_float_strict { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_double { } {\n-    global et_vect_double_saved\n-    global et_index\n-\n-    if [info exists et_vect_double_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_double: using cached result\" 2\n-    } else {\n-\tset et_vect_double_saved($et_index) 0\n-\tif { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n-\t      && [check_no_compiler_messages vect_double assembly {\n+    return [check_cached_effective_target_indexed vect_double {\n+        expr { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t         && [check_no_compiler_messages vect_double assembly {\n \t\t  #ifdef __tune_atom__\n \t\t  # error No double vectorizer support.\n \t\t  #endif\n-\t      }])\n+\t\t}])\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget spu-*-*]\n \t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_double_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_double:\\\n-\t     returning $et_vect_double_saved($et_index)\" 2\n-    return $et_vect_double_saved($et_index)\n+\t\t && [check_effective_target_s390_vx])} }]\n }\n \n # Return 1 if the target supports conditional addition, subtraction,\n@@ -5648,25 +5444,12 @@ proc check_effective_target_vect_double_cond_arith { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_long_long { } {\n-    global et_vect_long_long_saved\n-    global et_index\n-\n-    if [info exists et_vect_long_long_saved($et_index)] {\n-        verbose \"check_effective_target_vect_long_long: using cached result\" 2\n-    } else {\n-\tset et_vect_long_long_saved($et_index) 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target_indexed vect_long_long {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_long_long_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_long_long:\\\n-\t     returning $et_vect_long_long_saved($et_index)\" 2\n-    return $et_vect_long_long_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n \n@@ -5676,25 +5459,12 @@ proc check_effective_target_vect_long_long { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_no_int_min_max { } {\n-    global et_vect_no_int_min_max_saved\n-    global et_index\n-\n-    if [info exists et_vect_no_int_min_max_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_no_int_min_max:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_no_int_min_max_saved($et_index) 0\n-\tif { [istarget sparc*-*-*]\n+    return [check_cached_effective_target_indexed vect_no_int_min_max {\n+      expr { [istarget sparc*-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget alpha*-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_loongson]) } {\n-\t    set et_vect_no_int_min_max_saved($et_index) 1\n-\t}\n-    }\n-    verbose \"check_effective_target_vect_no_int_min_max:\\\n-\t     returning $et_vect_no_int_min_max_saved($et_index)\" 2\n-    return $et_vect_no_int_min_max_saved($et_index)\n+\t\t && [et-is-effective-target mips_loongson]) }}]\n }\n \n # Return 1 if the target plus current options does not support a vector\n@@ -5703,21 +5473,9 @@ proc check_effective_target_vect_no_int_min_max { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_no_int_add { } {\n-    global et_vect_no_int_add_saved\n-    global et_index\n-\n-    if [info exists et_vect_no_int_add_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_no_int_add: using cached result\" 2\n-    } else {\n-\tset et_vect_no_int_add_saved($et_index) 0\n-\t# Alpha only supports vector add on V8QI and V4HI.\n-\tif { [istarget alpha*-*-*] } {\n-\t    set et_vect_no_int_add_saved($et_index) 1\n-\t}\n-    }\n-    verbose \"check_effective_target_vect_no_int_add:\\\n-\t     returning $et_vect_no_int_add_saved($et_index)\" 2\n-    return $et_vect_no_int_add_saved($et_index)\n+    # Alpha only supports vector add on V8QI and V4HI.\n+    return [check_cached_effective_target_indexed vect_no_int_add {\n+      expr { [istarget alpha*-*-*] }}]\n }\n \n # Return 1 if the target plus current options does not support vector\n@@ -5726,17 +5484,7 @@ proc check_effective_target_vect_no_int_add { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_no_bitwise { } {\n-    global et_vect_no_bitwise_saved\n-    global et_index\n-\n-    if [info exists et_vect_no_bitwise_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_no_bitwise: using cached result\" 2\n-    } else {\n-\tset et_vect_no_bitwise_saved($et_index) 0\n-    }\n-    verbose \"check_effective_target_vect_no_bitwise:\\\n-\t     returning $et_vect_no_bitwise_saved($et_index)\" 2\n-    return $et_vect_no_bitwise_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_no_bitwise { return 0 }]\n }\n \n # Return 1 if the target plus current options supports vector permutation,\n@@ -5745,14 +5493,8 @@ proc check_effective_target_vect_no_bitwise { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_perm { } {\n-    global et_vect_perm_saved\n-    global et_index\n-\n-    if [info exists et_vect_perm_saved($et_index)] {\n-        verbose \"check_effective_target_vect_perm: using cached result\" 2\n-    } else {\n-\tset et_vect_perm_saved($et_index) 0\n-        if { [is-effective-target arm_neon]\n+    return [check_cached_effective_target_indexed vect_perm {\n+      expr { [is-effective-target arm_neon]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*]\n@@ -5761,13 +5503,7 @@ proc check_effective_target_vect_perm { } {\n \t\t && ([et-is-effective-target mpaired_single]\n \t\t     || [et-is-effective-target mips_msa]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_perm_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_perm:\\\n-\t     returning $et_vect_perm_saved($et_index)\" 2\n-    return $et_vect_perm_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if, for some VF:\n@@ -5850,14 +5586,8 @@ proc check_effective_target_vect_perm3_int { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_perm_byte { } {\n-    global et_vect_perm_byte_saved\n-    global et_index\n-\n-    if [info exists et_vect_perm_byte_saved($et_index)] {\n-        verbose \"check_effective_target_vect_perm_byte: using cached result\" 2\n-    } else {\n-\tset et_vect_perm_byte_saved($et_index) 0\n-        if { ([is-effective-target arm_neon]\n+    return [check_cached_effective_target_indexed vect_perm_byte {\n+      expr { ([is-effective-target arm_neon]\n \t      && [is-effective-target arm_little_endian])\n \t     || ([istarget aarch64*-*-*]\n \t\t && [is-effective-target aarch64_little_endian])\n@@ -5866,13 +5596,7 @@ proc check_effective_target_vect_perm_byte { } {\n \t     || ([istarget mips-*.*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_perm_byte_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_perm_byte:\\\n-\t     returning $et_vect_perm_byte_saved($et_index)\" 2\n-    return $et_vect_perm_byte_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports SLP permutation of 3 vectors when each\n@@ -5889,14 +5613,8 @@ proc check_effective_target_vect_perm3_byte { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_perm_short { } {\n-    global et_vect_perm_short_saved\n-    global et_index\n-\n-    if [info exists et_vect_perm_short_saved($et_index)] {\n-        verbose \"check_effective_target_vect_perm_short: using cached result\" 2\n-    } else {\n-\tset et_vect_perm_short_saved($et_index) 0\n-        if { ([is-effective-target arm_neon]\n+    return [check_cached_effective_target_indexed vect_perm_short {\n+      expr { ([is-effective-target arm_neon]\n \t      && [is-effective-target arm_little_endian])\n \t     || ([istarget aarch64*-*-*]\n \t\t && [is-effective-target aarch64_little_endian])\n@@ -5907,13 +5625,7 @@ proc check_effective_target_vect_perm_short { } {\n \t     || ([istarget mips*-*-*]\n \t\t  && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_perm_short_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_perm_short:\\\n-\t     returning $et_vect_perm_short_saved($et_index)\" 2\n-    return $et_vect_perm_short_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports SLP permutation of 3 vectors when each\n@@ -5930,20 +5642,8 @@ proc check_effective_target_vect_perm3_short { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_xorsign { } {\n-    global et_xorsign_saved\n-    global et_index\n-\n-    if [info exists et_xorsign_saved($et_index)] {\n-        verbose \"check_effective_target_xorsign: using cached result\" 2\n-    } else {\n-\tset et_xorsign_saved($et_index) 0\n-        if { [istarget aarch64*-*-*] || [istarget arm*-*-*] } {\n-\t    set et_xorsign_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_xorsign:\\\n-\t     returning $et_xorsign_saved($et_index)\" 2\n-    return $et_xorsign_saved($et_index)\n+    return [check_cached_effective_target_indexed xorsign {\n+      expr { [istarget aarch64*-*-*] || [istarget arm*-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -5952,25 +5652,12 @@ proc check_effective_target_xorsign { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_sum_hi_to_si_pattern { } {\n-    global et_vect_widen_sum_hi_to_si_pattern_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_sum_hi_to_si_pattern_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_sum_hi_to_si_pattern:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_widen_sum_hi_to_si_pattern_saved($et_index) 0\n-        if { [istarget powerpc*-*-*]\n+    return [check_cached_effective_target_indexed vect_widen_sum_hi_to_si_pattern {\n+      expr { [istarget powerpc*-*-*]\n              || ([istarget aarch64*-*-*]\n \t\t && ![check_effective_target_aarch64_sve])\n \t     || [is-effective-target arm_neon]\n-             || [istarget ia64-*-*] } {\n-\t    set et_vect_widen_sum_hi_to_si_pattern_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_sum_hi_to_si_pattern:\\\n-\t     returning $et_vect_widen_sum_hi_to_si_pattern_saved($et_index)\" 2\n-    return $et_vect_widen_sum_hi_to_si_pattern_saved($et_index)\n+             || [istarget ia64-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -5979,25 +5666,12 @@ proc check_effective_target_vect_widen_sum_hi_to_si_pattern { } {\n # promotion (unpacking) from shorts to ints.\n #\n # This won't change for different subtargets so cache the result.\n-                                                                                                \n-proc check_effective_target_vect_widen_sum_hi_to_si { } {\n-    global et_vect_widen_sum_hi_to_si_saved\n-    global et_index\n \n-    if [info exists et_vect_widen_sum_hi_to_si_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_sum_hi_to_si:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_widen_sum_hi_to_si_saved($et_index) \\\n-\t    [check_effective_target_vect_unpack]\n-        if { [istarget powerpc*-*-*] \n-\t     || [istarget ia64-*-*] } {\n-\t    set et_vect_widen_sum_hi_to_si_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_sum_hi_to_si:\\\n-\t     returning $et_vect_widen_sum_hi_to_si_saved($et_index)\" 2\n-    return $et_vect_widen_sum_hi_to_si_saved($et_index)\n+proc check_effective_target_vect_widen_sum_hi_to_si { } {\n+    return [check_cached_effective_target_indexed vect_widen_sum_hi_to_si {\n+      expr { [check_effective_target_vect_unpack]\n+             || [istarget powerpc*-*-*]\n+\t     || [istarget ia64-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6008,23 +5682,10 @@ proc check_effective_target_vect_widen_sum_hi_to_si { } {\n # This won't change for different subtargets so cache the result.\n                                                                                                 \n proc check_effective_target_vect_widen_sum_qi_to_hi { } {\n-    global et_vect_widen_sum_qi_to_hi_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_sum_qi_to_hi_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_sum_qi_to_hi:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_widen_sum_qi_to_hi_saved($et_index) 0\n-\tif { [check_effective_target_vect_unpack] \n+    return [check_cached_effective_target_indexed vect_widen_sum_qi_to_hi {\n+      expr { [check_effective_target_vect_unpack]\n \t     || [is-effective-target arm_neon]\n-\t     || [istarget ia64-*-*] } {\n-\t    set et_vect_widen_sum_qi_to_hi_saved($et_index) 1\n-\t}\n-    }\n-    verbose \"check_effective_target_vect_widen_sum_qi_to_hi:\\\n-\t     returning $et_vect_widen_sum_qi_to_hi_saved($et_index)\" 2\n-    return $et_vect_widen_sum_qi_to_hi_saved($et_index)\n+\t     || [istarget ia64-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6033,21 +5694,8 @@ proc check_effective_target_vect_widen_sum_qi_to_hi { } {\n # This won't change for different subtargets so cache the result.\n                                                                                                 \n proc check_effective_target_vect_widen_sum_qi_to_si { } {\n-    global et_vect_widen_sum_qi_to_si_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_sum_qi_to_si_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_sum_qi_to_si:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_widen_sum_qi_to_si_saved($et_index) 0\n-        if { [istarget powerpc*-*-*] } {\n-\t    set et_vect_widen_sum_qi_to_si_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_sum_qi_to_si:\\\n-\t     returning $et_vect_widen_sum_qi_to_si_saved($et_index)\" 2\n-    return $et_vect_widen_sum_qi_to_si_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_widen_sum_qi_to_si {\n+      expr { [istarget powerpc*-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6060,31 +5708,15 @@ proc check_effective_target_vect_widen_sum_qi_to_si { } {\n \n \n proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n-    global et_vect_widen_mult_qi_to_hi_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_mult_qi_to_hi_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_mult_qi_to_hi:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tif { [check_effective_target_vect_unpack]\n-\t     && [check_effective_target_vect_short_mult] } {\n-\t    set et_vect_widen_mult_qi_to_hi_saved($et_index) 1\n-\t} else {\n-\t    set et_vect_widen_mult_qi_to_hi_saved($et_index) 0\n-\t}\n-        if { [istarget powerpc*-*-*]\n-              || ([istarget aarch64*-*-*]\n-\t\t  && ![check_effective_target_aarch64_sve])\n-              || [is-effective-target arm_neon]\n-\t      || ([istarget s390*-*-*]\n-\t\t  && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_widen_mult_qi_to_hi_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_mult_qi_to_hi:\\\n-\t     returning $et_vect_widen_mult_qi_to_hi_saved($et_index)\" 2\n-    return $et_vect_widen_mult_qi_to_hi_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_widen_mult_qi_to_hi {\n+      expr { ([check_effective_target_vect_unpack]\n+\t       && [check_effective_target_vect_short_mult])\n+\t      || ([istarget powerpc*-*-*]\n+\t\t  || ([istarget aarch64*-*-*]\n+\t\t      && ![check_effective_target_aarch64_sve])\n+\t\t  || [is-effective-target arm_neon]\n+\t\t  || ([istarget s390*-*-*]\n+\t\t      && [check_effective_target_s390_vx])) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6097,34 +5729,18 @@ proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n \n \n proc check_effective_target_vect_widen_mult_hi_to_si { } {\n-    global et_vect_widen_mult_hi_to_si_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_mult_hi_to_si_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_mult_hi_to_si:\\\n-\t\t using cached result\" 2\n-    } else {\n-        if { [check_effective_target_vect_unpack]\n-             && [check_effective_target_vect_int_mult] } {\n-\t  set et_vect_widen_mult_hi_to_si_saved($et_index) 1\n-        } else {\n-\t  set et_vect_widen_mult_hi_to_si_saved($et_index) 0\n-        }\n-        if { [istarget powerpc*-*-*]\n-\t     || [istarget spu-*-*]\n-\t     || [istarget ia64-*-*]\n-\t     || ([istarget aarch64*-*-*]\n-\t\t && ![check_effective_target_aarch64_sve])\n-\t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t     || [is-effective-target arm_neon]\n-\t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_widen_mult_hi_to_si_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_mult_hi_to_si:\\\n-\t     returning $et_vect_widen_mult_hi_to_si_saved($et_index)\" 2\n-    return $et_vect_widen_mult_hi_to_si_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_widen_mult_hi_to_si {\n+      expr { ([check_effective_target_vect_unpack]\n+              && [check_effective_target_vect_int_mult])\n+\t     || ([istarget powerpc*-*-*]\n+\t\t || [istarget spu-*-*]\n+\t\t || [istarget ia64-*-*]\n+\t\t || ([istarget aarch64*-*-*]\n+\t\t     && ![check_effective_target_aarch64_sve])\n+\t\t || [istarget i?86-*-*] || [istarget x86_64-*-*]\n+\t\t || [is-effective-target arm_neon]\n+\t\t || ([istarget s390*-*-*]\n+\t\t     && [check_effective_target_s390_vx])) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6133,25 +5749,12 @@ proc check_effective_target_vect_widen_mult_hi_to_si { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_mult_qi_to_hi_pattern { } {\n-    global et_vect_widen_mult_qi_to_hi_pattern_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_mult_qi_to_hi_pattern_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_widen_mult_qi_to_hi_pattern_saved($et_index) 0\n-        if { [istarget powerpc*-*-*]\n-              || ([is-effective-target arm_neon]\n-\t\t  && [check_effective_target_arm_little_endian])\n-\t      || ([istarget s390*-*-*]\n-\t\t  && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_widen_mult_qi_to_hi_pattern_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern:\\\n-\t     returning $et_vect_widen_mult_qi_to_hi_pattern_saved($et_index)\" 2\n-    return $et_vect_widen_mult_qi_to_hi_pattern_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_widen_mult_qi_to_hi_pattern {\n+      expr { [istarget powerpc*-*-*]\n+             || ([is-effective-target arm_neon]\n+\t\t && [check_effective_target_arm_little_endian])\n+\t     || ([istarget s390*-*-*]\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6160,28 +5763,15 @@ proc check_effective_target_vect_widen_mult_qi_to_hi_pattern { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n-    global et_vect_widen_mult_hi_to_si_pattern_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_mult_hi_to_si_pattern_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_widen_mult_hi_to_si_pattern_saved($et_index) 0\n-        if { [istarget powerpc*-*-*]\n+    return [check_cached_effective_target_indexed vect_widen_mult_hi_to_si_pattern {\n+      expr { [istarget powerpc*-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([is-effective-target arm_neon]\n \t\t && [check_effective_target_arm_little_endian])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_widen_mult_hi_to_si_pattern_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern:\\\n-\t     returning $et_vect_widen_mult_hi_to_si_pattern_saved($et_index)\" 2\n-    return $et_vect_widen_mult_hi_to_si_pattern_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6190,46 +5780,21 @@ proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_mult_si_to_di_pattern { } {\n-    global et_vect_widen_mult_si_to_di_pattern_saved\n-    global et_index\n-\n-    if [info exists et_vect_widen_mult_si_to_di_pattern_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_widen_mult_si_to_di_pattern:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_widen_mult_si_to_di_pattern_saved($et_index) 0\n-        if {[istarget ia64-*-*]\n-\t    || [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t    || ([istarget s390*-*-*]\n-\t\t&& [check_effective_target_s390_vx]) } {\n-\t    set et_vect_widen_mult_si_to_di_pattern_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_mult_si_to_di_pattern:\\\n-\t     returning $et_vect_widen_mult_si_to_di_pattern_saved($et_index)\" 2\n-    return $et_vect_widen_mult_si_to_di_pattern_saved($et_index)\n-}\n+    return [check_cached_effective_target_indexed vect_widen_mult_si_to_di_pattern {\n+      expr { [istarget ia64-*-*]\n+\t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n+\t     || ([istarget s390*-*-*]\n+\t\t && [check_effective_target_s390_vx]) }}]\n+}\n \n # Return 1 if the target plus current options supports a vector\n # widening shift, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_widen_shift { } {\n-    global et_vect_widen_shift_saved\n-    global et_index\n-\n-    if [info exists et_vect_shift_saved($et_index)] {\n-        verbose \"check_effective_target_vect_widen_shift: using cached result\" 2\n-    } else {\n-\tset et_vect_widen_shift_saved($et_index) 0\n-        if { [is-effective-target arm_neon] } {\n-\t    set et_vect_widen_shift_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_widen_shift:\\\n-\t     returning $et_vect_widen_shift_saved($et_index)\" 2\n-    return $et_vect_widen_shift_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_widen_shift {\n+      expr { [is-effective-target arm_neon] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6238,24 +5803,12 @@ proc check_effective_target_vect_widen_shift { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_sdot_qi { } {\n-    global et_vect_sdot_qi_saved\n-    global et_index\n-\n-    if [info exists et_vect_sdot_qi_saved($et_index)] {\n-        verbose \"check_effective_target_vect_sdot_qi: using cached result\" 2\n-    } else {\n-\tset et_vect_sdot_qi_saved($et_index) 0\n-\tif { [istarget ia64-*-*]\n+    return [check_cached_effective_target_indexed vect_sdot_qi {\n+      expr { [istarget ia64-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget arm*-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-            set et_vect_udot_qi_saved 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_sdot_qi:\\\n-\t     returning $et_vect_sdot_qi_saved($et_index)\" 2\n-    return $et_vect_sdot_qi_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6264,25 +5817,13 @@ proc check_effective_target_vect_sdot_qi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_udot_qi { } {\n-    global et_vect_udot_qi_saved\n-    global et_index\n-\n-    if [info exists et_vect_udot_qi_saved($et_index)] {\n-        verbose \"check_effective_target_vect_udot_qi: using cached result\" 2\n-    } else {\n-\tset et_vect_udot_qi_saved($et_index) 0\n-        if { [istarget powerpc*-*-*]\n+    return [check_cached_effective_target_indexed vect_udot_qi {\n+      expr { [istarget powerpc*-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget arm*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_udot_qi_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_udot_qi:\\\n-\t     returning $et_vect_udot_qi_saved($et_index)\" 2\n-    return $et_vect_udot_qi_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6291,24 +5832,12 @@ proc check_effective_target_vect_udot_qi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_sdot_hi { } {\n-    global et_vect_sdot_hi_saved\n-    global et_index\n-\n-    if [info exists et_vect_sdot_hi_saved($et_index)] {\n-        verbose \"check_effective_target_vect_sdot_hi: using cached result\" 2\n-    } else {\n-\tset et_vect_sdot_hi_saved($et_index) 0\n-        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n+    return [check_cached_effective_target_indexed vect_sdot_hi {\n+      expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_sdot_hi_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_sdot_hi:\\\n-\t     returning $et_vect_sdot_hi_saved($et_index)\" 2\n-    return $et_vect_sdot_hi_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6317,22 +5846,10 @@ proc check_effective_target_vect_sdot_hi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_udot_hi { } {\n-    global et_vect_udot_hi_saved\n-    global et_index\n-\n-    if [info exists et_vect_udot_hi_saved($et_index)] {\n-        verbose \"check_effective_target_vect_udot_hi: using cached result\" 2\n-    } else {\n-\tset et_vect_udot_hi_saved($et_index) 0\n-\tif { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n+    return [check_cached_effective_target_indexed vect_udot_hi {\n+      expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) } {\n-\t    set et_vect_udot_hi_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_udot_hi:\\\n-\t     returning $et_vect_udot_hi_saved($et_index)\" 2\n-    return $et_vect_udot_hi_saved($et_index)\n+\t\t && [et-is-effective-target mips_msa]) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6341,20 +5858,8 @@ proc check_effective_target_vect_udot_hi { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_usad_char { } {\n-    global et_vect_usad_char_saved\n-    global et_index\n-\n-    if [info exists et_vect_usad_char_saved($et_index)] {\n-        verbose \"check_effective_target_vect_usad_char: using cached result\" 2\n-    } else {\n-\tset et_vect_usad_char_saved($et_index) 0\n-        if { [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n-\t    set et_vect_usad_char_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_usad_char:\\\n-\t     returning $et_vect_usad_char_saved($et_index)\" 2\n-    return $et_vect_usad_char_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_usad_char {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports both signed\n@@ -6372,14 +5877,8 @@ proc check_effective_target_vect_avg_qi {} {\n # This won't change for different subtargets so cache the result.\n                                                                                 \n proc check_effective_target_vect_pack_trunc { } {\n-    global et_vect_pack_trunc_saved\n-    global et_index\n-                                                                                \n-    if [info exists et_vect_pack_trunc_saved($et_index)] {\n-        verbose \"check_effective_target_vect_pack_trunc: using cached result\" 2\n-    } else {\n-\tset et_vect_pack_trunc_saved($et_index) 0\n-        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n+    return [check_cached_effective_target_indexed vect_pack_trunc {\n+      expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget aarch64*-*-*]\n              || [istarget spu-*-*]\n@@ -6388,13 +5887,7 @@ proc check_effective_target_vect_pack_trunc { } {\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_pack_trunc_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_pack_trunc:\\\n-\t     returning $et_vect_pack_trunc_saved($et_index)\" 2\n-    return $et_vect_pack_trunc_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6403,15 +5896,9 @@ proc check_effective_target_vect_pack_trunc { } {\n # This won't change for different subtargets so cache the result.\n                                    \n proc check_effective_target_vect_unpack { } {\n-    global et_vect_unpack_saved\n-    global et_index\n-                                        \n-    if [info exists et_vect_unpack_saved($et_index)] {\n-        verbose \"check_effective_target_vect_unpack: using cached result\" 2\n-    } else {\n-\tset et_vect_unpack_saved($et_index) 0\n-        if { ([istarget powerpc*-*-*] && ![istarget powerpc-*paired*])\n-             || [istarget i?86-*-*] || [istarget x86_64-*-*] \n+    return [check_cached_effective_target_indexed vect_unpack {\n+      expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*paired*])\n+             || [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || [istarget spu-*-*]\n              || [istarget ia64-*-*]\n              || [istarget aarch64*-*-*]\n@@ -6420,13 +5907,7 @@ proc check_effective_target_vect_unpack { } {\n              || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]\n \t\t && [check_effective_target_arm_little_endian])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_unpack_saved($et_index) 1\n-        }\n-    }\n-    verbose \"check_effective_target_vect_unpack:\\\n-\t     returning $et_vect_unpack_saved($et_index)\" 2\n-    return $et_vect_unpack_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target plus current options does not guarantee\n@@ -6435,15 +5916,7 @@ proc check_effective_target_vect_unpack { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_unaligned_stack { } {\n-    global et_unaligned_stack_saved\n-\n-    if [info exists et_unaligned_stack_saved] {\n-        verbose \"check_effective_target_unaligned_stack: using cached result\" 2\n-    } else {\n-        set et_unaligned_stack_saved 0\n-    }\n-    verbose \"check_effective_target_unaligned_stack: returning $et_unaligned_stack_saved\" 2\n-    return $et_unaligned_stack_saved\n+    return [check_cached_effective_target_indexed unaligned_stack { expr 0 }]\n }\n \n # Return 1 if the target plus current options does not support a vector\n@@ -6452,56 +5925,37 @@ proc check_effective_target_unaligned_stack { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_no_align { } {\n-    global et_vect_no_align_saved\n-    global et_index\n-\n-    if [info exists et_vect_no_align_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_no_align: using cached result\" 2\n-    } else {\n-\tset et_vect_no_align_saved($et_index) 0\n-\tif { [istarget mipsisa64*-*-*]\n+    return [check_cached_effective_target_indexed vect_no_align {\n+      expr { [istarget mipsisa64*-*-*]\n \t     || [istarget mips-sde-elf]\n \t     || [istarget sparc*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [check_effective_target_arm_vect_no_misalign]\n \t     || ([istarget powerpc*-*-*] && [check_p8vector_hw_available])\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_loongson]) } {\n-\t    set et_vect_no_align_saved($et_index) 1\n-\t}\n-    }\n-    verbose \"check_effective_target_vect_no_align:\\\n-\t     returning $et_vect_no_align_saved($et_index)\" 2\n-    return $et_vect_no_align_saved($et_index)\n+\t\t && [et-is-effective-target mips_loongson]) }}]\n }\n \n # Return 1 if the target supports a vector misalign access, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_vect_hw_misalign { } {\n-    global et_vect_hw_misalign_saved\n-    global et_index\n-\n-    if [info exists et_vect_hw_misalign_saved($et_index)] {\n-        verbose \"check_effective_target_vect_hw_misalign: using cached result\" 2\n-    } else {\n-\tset et_vect_hw_misalign_saved($et_index) 0\n+    return [check_cached_effective_target_indexed vect_hw_misalign {\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget powerpc*-*-*] && [check_p8vector_hw_available])\n \t     || [istarget aarch64*-*-*]\n \t     || ([istarget mips*-*-*] && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n \t\t && [check_effective_target_s390_vx]) } {\n-\t  set et_vect_hw_misalign_saved($et_index) 1\n+\t  return 1\n \t}\n-\tif { [istarget arm*-*-*] } {\n-\t    set et_vect_hw_misalign_saved($et_index) [expr ![check_effective_target_arm_vect_no_misalign]]\n+\tif { [istarget arm*-*-*]\n+\t     && ![check_effective_target_arm_vect_no_misalign] } {\n+\t  return 1\n \t}\n-    }\n-    verbose \"check_effective_target_vect_hw_misalign:\\\n-\t     returning $et_vect_hw_misalign_saved($et_index)\" 2\n-    return $et_vect_hw_misalign_saved($et_index)\n+        return 0\n+    }]\n }\n \n \n@@ -6528,20 +5982,15 @@ proc check_effective_target_vect_aligned_arrays { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_natural_alignment_32 { } {\n-    global et_natural_alignment_32\n-\n-    if [info exists et_natural_alignment_32_saved] {\n-        verbose \"check_effective_target_natural_alignment_32: using cached result\" 2\n-    } else {\n-        # FIXME: 32bit powerpc: guaranteed only if MASK_ALIGN_NATURAL/POWER.\n-        set et_natural_alignment_32_saved 1\n-        if { ([istarget *-*-darwin*] && [is-effective-target lp64])\n-             || [istarget avr-*-*] } {\n-            set et_natural_alignment_32_saved 0\n-        }\n-    }\n-    verbose \"check_effective_target_natural_alignment_32: returning $et_natural_alignment_32_saved\" 2\n-    return $et_natural_alignment_32_saved\n+    # FIXME: 32bit powerpc: guaranteed only if MASK_ALIGN_NATURAL/POWER.\n+    return [check_cached_effective_target_indexed natural_alignment_32 {\n+      if { ([istarget *-*-darwin*] && [is-effective-target lp64])\n+\t    || [istarget avr-*-*] } {\n+\t   return 0\n+\t } else {\n+\t   return 1\n+\t }\n+      }]\n }\n \n # Return 1 if types of size 64 bit or less are naturally aligned (aligned to their\n@@ -6550,19 +5999,10 @@ proc check_effective_target_natural_alignment_32 { } {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_natural_alignment_64 { } {\n-    global et_natural_alignment_64\n-\n-    if [info exists et_natural_alignment_64_saved] {\n-        verbose \"check_effective_target_natural_alignment_64: using cached result\" 2\n-    } else {\n-        set et_natural_alignment_64_saved 0\n-        if { ([is-effective-target lp64] && ![istarget *-*-darwin*])\n-             || [istarget spu-*-*] } {\n-            set et_natural_alignment_64_saved 1\n-        }\n-    }\n-    verbose \"check_effective_target_natural_alignment_64: returning $et_natural_alignment_64_saved\" 2\n-    return $et_natural_alignment_64_saved\n+    return [check_cached_effective_target_indexed natural_alignment_64 {\n+      expr { ([is-effective-target lp64] && ![istarget *-*-darwin*])\n+\t      || [istarget spu-*-*] }\n+    }]\n }\n \n # Return 1 if all vector types are naturally aligned (aligned to their\n@@ -6632,24 +6072,10 @@ proc check_effective_target_vector_alignment_reachable_for_64bit { } {\n # Return 1 if the target only requires element alignment for vector accesses\n \n proc check_effective_target_vect_element_align { } {\n-    global et_vect_element_align\n-    global et_index\n-\n-    if [info exists et_vect_element_align($et_index)] {\n-\tverbose \"check_effective_target_vect_element_align:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_element_align($et_index) 0\n-\tif { ([istarget arm*-*-*]\n+    return [check_cached_effective_target_indexed vect_element_align {\n+      expr { ([istarget arm*-*-*]\n \t      && ![check_effective_target_arm_vect_no_misalign])\n-\t     || [check_effective_target_vect_hw_misalign] } {\n-\t   set et_vect_element_align($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_element_align:\\\n-\t     returning $et_vect_element_align($et_index)\" 2\n-    return $et_vect_element_align($et_index)\n+\t     || [check_effective_target_vect_hw_misalign] }}]\n }\n \n # Return 1 if we expect to see unaligned accesses in at least some\n@@ -6664,21 +6090,11 @@ proc check_effective_target_vect_unaligned_possible { } {\n # Return 1 if the target supports vector LOAD_LANES operations, 0 otherwise.\n \n proc check_effective_target_vect_load_lanes { } {\n-    global et_vect_load_lanes\n-\n-    if [info exists et_vect_load_lanes] {\n-\tverbose \"check_effective_target_vect_load_lanes: using cached result\" 2\n-    } else {\n-\tset et_vect_load_lanes 0\n-\t# We don't support load_lanes correctly on big-endian arm.\n-\tif { ([check_effective_target_arm_little_endian] && [check_effective_target_arm_neon_ok])\n-\t     || [istarget aarch64*-*-*] } {\n-\t    set et_vect_load_lanes 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_load_lanes: returning $et_vect_load_lanes\" 2\n-    return $et_vect_load_lanes\n+    # We don't support load_lanes correctly on big-endian arm.\n+    return [check_cached_effective_target vect_load_lanes {\n+      expr { ([check_effective_target_arm_little_endian]\n+\t      && [check_effective_target_arm_neon_ok])\n+\t     || [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector masked stores.\n@@ -6696,14 +6112,8 @@ proc check_effective_target_vect_scatter_store { } {\n # Return 1 if the target supports vector conditional operations, 0 otherwise.\n \n proc check_effective_target_vect_condition { } {\n-    global et_vect_cond_saved\n-    global et_index\n-\n-    if [info exists et_vect_cond_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_cond: using cached result\" 2\n-    } else {\n-\tset et_vect_cond_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*]\n+    return [check_cached_effective_target_indexed vect_condition {\n+      expr { [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n@@ -6713,82 +6123,43 @@ proc check_effective_target_vect_condition { } {\n \t     || ([istarget arm*-*-*]\n \t\t && [check_effective_target_arm_neon_ok])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_cond_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_cond:\\\n-\t     returning $et_vect_cond_saved($et_index)\" 2\n-    return $et_vect_cond_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports vector conditional operations where\n # the comparison has different type from the lhs, 0 otherwise.\n \n proc check_effective_target_vect_cond_mixed { } {\n-    global et_vect_cond_mixed_saved\n-    global et_index\n-\n-    if [info exists et_vect_cond_mixed_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_cond_mixed: using cached result\" 2\n-    } else {\n-\tset et_vect_cond_mixed_saved($et_index) 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target_indexed vect_cond_mixed {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*] \n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_cond_mixed_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_cond_mixed:\\\n-\t     returning $et_vect_cond_mixed_saved($et_index)\" 2\n-    return $et_vect_cond_mixed_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports vector char multiplication, 0 otherwise.\n \n proc check_effective_target_vect_char_mult { } {\n-    global et_vect_char_mult_saved\n-    global et_index\n-\n-    if [info exists et_vect_char_mult_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_char_mult: using cached result\" 2\n-    } else {\n-\tset et_vect_char_mult_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*]\n+    return [check_cached_effective_target_indexed vect_char_mult {\n+      expr { [istarget aarch64*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [check_effective_target_arm32]\n \t     || [check_effective_target_powerpc_altivec]\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_char_mult_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_char_mult:\\\n-\t     returning $et_vect_char_mult_saved($et_index)\" 2\n-    return $et_vect_char_mult_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports vector short multiplication, 0 otherwise.\n \n proc check_effective_target_vect_short_mult { } {\n-    global et_vect_short_mult_saved\n-    global et_index\n-\n-    if [info exists et_vect_short_mult_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_short_mult: using cached result\" 2\n-    } else {\n-\tset et_vect_short_mult_saved($et_index) 0\n-\tif { [istarget ia64-*-*]\n+    return [check_cached_effective_target_indexed vect_short_mult {\n+      expr { [istarget ia64-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n@@ -6798,27 +6169,14 @@ proc check_effective_target_vect_short_mult { } {\n \t\t && ([et-is-effective-target mips_msa]\n \t\t     || [et-is-effective-target mips_loongson]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_short_mult_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_short_mult:\\\n-\t     returning $et_vect_short_mult_saved($et_index)\" 2\n-    return $et_vect_short_mult_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports vector int multiplication, 0 otherwise.\n \n proc check_effective_target_vect_int_mult { } {\n-    global et_vect_int_mult_saved\n-    global et_index\n-\n-    if [info exists et_vect_int_mult_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_int_mult: using cached result\" 2\n-    } else {\n-\tset et_vect_int_mult_saved($et_index) 0\n-\tif { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n+    return [check_cached_effective_target_indexed vect_int_mult {\n+      expr { ([istarget powerpc*-*-*] && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget ia64-*-*]\n@@ -6827,14 +6185,7 @@ proc check_effective_target_vect_int_mult { } {\n \t\t && [et-is-effective-target mips_msa])\n \t     || [check_effective_target_arm32]\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_vect_int_mult_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_int_mult:\\\n-\t     returning $et_vect_int_mult_saved($et_index)\" 2\n-    return $et_vect_int_mult_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports 64 bit hardware vector\n@@ -6864,15 +6215,8 @@ proc check_effective_target_vect_long_mult { } {\n # Return 1 if the target supports vector even/odd elements extraction, 0 otherwise.\n \n proc check_effective_target_vect_extract_even_odd { } {\n-    global et_vect_extract_even_odd_saved\n-    global et_index\n-    \n-    if [info exists et_vect_extract_even_odd_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_extract_even_odd:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_extract_even_odd_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*]\n+    return [check_cached_effective_target_indexed extract_even_odd {\n+      expr { [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [is-effective-target arm_neon]\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n@@ -6882,27 +6226,14 @@ proc check_effective_target_vect_extract_even_odd { } {\n \t\t && ([et-is-effective-target mips_msa]\n \t\t     || [et-is-effective-target mpaired_single]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_extract_even_odd_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_extract_even_odd:\\\n-\t     returning $et_vect_extract_even_odd_saved($et_index)\" 2\n-    return $et_vect_extract_even_odd_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports vector interleaving, 0 otherwise.\n \n proc check_effective_target_vect_interleave { } {\n-    global et_vect_interleave_saved\n-    global et_index\n-    \n-    if [info exists et_vect_interleave_saved($et_index)] {\n-        verbose \"check_effective_target_vect_interleave: using cached result\" 2\n-    } else {\n-\tset et_vect_interleave_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*]\n+    return [check_cached_effective_target_indexed vect_interleave {\n+      expr { [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [is-effective-target arm_neon]\n              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n@@ -6912,42 +6243,25 @@ proc check_effective_target_vect_interleave { } {\n \t\t && ([et-is-effective-target mpaired_single]\n \t\t     || [et-is-effective-target mips_msa]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_interleave_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect_interleave:\\\n-\t     returning $et_vect_interleave_saved($et_index)\" 2\n-    return $et_vect_interleave_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n foreach N {2 3 4 8} {\n     eval [string map [list N $N] {\n \t# Return 1 if the target supports 2-vector interleaving\n \tproc check_effective_target_vect_stridedN { } {\n-\t    global et_vect_stridedN_saved\n-\t    global et_index\n-\n-\t    if [info exists et_vect_stridedN_saved($et_index)] {\n-\t\tverbose \"check_effective_target_vect_stridedN:\\\n-\t\t\t using cached result\" 2\n-\t    } else {\n-\t\tset et_vect_stridedN_saved($et_index) 0\n+\t    return [check_cached_effective_target_indexed vect_stridedN {\n \t\tif { (N & -N) == N\n \t\t     && [check_effective_target_vect_interleave]\n \t\t     && [check_effective_target_vect_extract_even_odd] } {\n-\t\t    set et_vect_stridedN_saved($et_index) 1\n+\t\t    return 1\n \t\t}\n \t\tif { ([istarget arm*-*-*]\n \t\t      || [istarget aarch64*-*-*]) && N >= 2 && N <= 4 } {\n-\t\t    set et_vect_stridedN_saved($et_index) 1\n+\t\t    return 1\n \t\t}\n-\t    }\n-\n-\t    verbose \"check_effective_target_vect_stridedN:\\\n-\t\t     returning $et_vect_stridedN_saved($et_index)\" 2\n-\t    return $et_vect_stridedN_saved($et_index)\n+\t\treturn 0\n+\t    }]\n \t}\n     }]\n }\n@@ -6998,71 +6312,33 @@ proc check_effective_target_vect64 { } {\n # Return 1 if the target supports vector copysignf calls.\n \n proc check_effective_target_vect_call_copysignf { } {\n-    global et_vect_call_copysignf_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_copysignf_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_copysignf:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_call_copysignf_saved($et_index) 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target_indexed vect_call_copysignf {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n-\t     || [istarget aarch64*-*-*] } {\n-\t   set et_vect_call_copysignf_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_copysignf:\\\n-\t     returning $et_vect_call_copysignf_saved($et_index)\" 2\n-    return $et_vect_call_copysignf_saved($et_index)\n+\t     || [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports hardware square root instructions.\n \n proc check_effective_target_sqrt_insn { } {\n-    global et_sqrt_insn_saved\n-\n-    if [info exists et_sqrt_insn_saved] {\n-\tverbose \"check_effective_target_hw_sqrt: using cached result\" 2\n-    } else {\n-\tset et_sqrt_insn_saved 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n+    return [check_cached_effective_target sqrt_insn {\n+      expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || ([istarget arm*-*-*] && [check_effective_target_arm_vfp_ok])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t   set et_sqrt_insn_saved 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_hw_sqrt: returning et_sqrt_insn_saved\" 2\n-    return $et_sqrt_insn_saved\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports vector sqrtf calls.\n \n proc check_effective_target_vect_call_sqrtf { } {\n-    global et_vect_call_sqrtf_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_sqrtf_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_sqrtf: using cached result\" 2\n-    } else {\n-\tset et_vect_call_sqrtf_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*]\n+    return [check_cached_effective_target_indexed vect_call_sqrtf {\n+      expr { [istarget aarch64*-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) } {\n-\t    set et_vect_call_sqrtf_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_sqrtf:\\\n-\t     returning $et_vect_call_sqrtf_saved($et_index)\" 2\n-    return $et_vect_call_sqrtf_saved($et_index)\n+\t\t && [check_effective_target_s390_vx]) }}]\n }\n \n # Return 1 if the target supports vector lrint calls.\n@@ -7081,244 +6357,85 @@ proc check_effective_target_vect_call_lrint { } {\n # Return 1 if the target supports vector btrunc calls.\n \n proc check_effective_target_vect_call_btrunc { } {\n-    global et_vect_call_btrunc_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_btrunc_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_btrunc:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_call_btrunc_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_btrunc_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_btrunc:\\\n-\t     returning $et_vect_call_btrunc_saved($et_index)\" 2\n-    return $et_vect_call_btrunc_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_btrunc {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector btruncf calls.\n \n proc check_effective_target_vect_call_btruncf { } {\n-    global et_vect_call_btruncf_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_btruncf_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_btruncf:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_call_btruncf_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_btruncf_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_btruncf:\\\n-\t     returning $et_vect_call_btruncf_saved($et_index)\" 2\n-    return $et_vect_call_btruncf_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_btruncf {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector ceil calls.\n \n proc check_effective_target_vect_call_ceil { } {\n-    global et_vect_call_ceil_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_ceil_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_ceil: using cached result\" 2\n-    } else {\n-\tset et_vect_call_ceil_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_ceil_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_ceil:\\\n-\t     returning $et_vect_call_ceil_saved($et_index)\" 2\n-    return $et_vect_call_ceil_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_ceil {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector ceilf calls.\n \n proc check_effective_target_vect_call_ceilf { } {\n-    global et_vect_call_ceilf_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_ceilf_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_ceilf: using cached result\" 2\n-    } else {\n-\tset et_vect_call_ceilf_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_ceilf_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_ceilf:\\\n-\t     returning $et_vect_call_ceilf_saved($et_index)\" 2\n-    return $et_vect_call_ceilf_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_ceilf {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector floor calls.\n \n proc check_effective_target_vect_call_floor { } {\n-    global et_vect_call_floor_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_floor_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_floor: using cached result\" 2\n-    } else {\n-\tset et_vect_call_floor_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_floor_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_floor:\\\n-\t     returning $et_vect_call_floor_saved($et_index)\" 2\n-    return $et_vect_call_floor_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_floor {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector floorf calls.\n \n proc check_effective_target_vect_call_floorf { } {\n-    global et_vect_call_floorf_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_floorf_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_floorf: using cached result\" 2\n-    } else {\n-\tset et_vect_call_floorf_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_floorf_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_floorf:\\\n-\t     returning $et_vect_call_floorf_saved($et_index)\" 2\n-    return $et_vect_call_floorf_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_floorf {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector lceil calls.\n \n proc check_effective_target_vect_call_lceil { } {\n-    global et_vect_call_lceil_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_lceil_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_lceil: using cached result\" 2\n-    } else {\n-\tset et_vect_call_lceil_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_lceil_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_lceil:\\\n-\t     returning $et_vect_call_lceil_saved($et_index)\" 2\n-    return $et_vect_call_lceil_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_lceil {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector lfloor calls.\n \n proc check_effective_target_vect_call_lfloor { } {\n-    global et_vect_call_lfloor_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_lfloor_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_lfloor: using cached result\" 2\n-    } else {\n-\tset et_vect_call_lfloor_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_lfloor_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_lfloor:\\\n-\t     returning $et_vect_call_lfloor_saved($et_index)\" 2\n-    return $et_vect_call_lfloor_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_lfloor {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector nearbyint calls.\n \n proc check_effective_target_vect_call_nearbyint { } {\n-    global et_vect_call_nearbyint_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_nearbyint_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_nearbyint: using cached result\" 2\n-    } else {\n-\tset et_vect_call_nearbyint_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_nearbyint_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_nearbyint:\\\n-\t     returning $et_vect_call_nearbyint_saved($et_index)\" 2\n-    return $et_vect_call_nearbyint_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_nearbyint {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector nearbyintf calls.\n \n proc check_effective_target_vect_call_nearbyintf { } {\n-    global et_vect_call_nearbyintf_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_nearbyintf_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_nearbyintf:\\\n-\t\t using cached result\" 2\n-    } else {\n-\tset et_vect_call_nearbyintf_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_nearbyintf_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_nearbyintf:\\\n-\t     returning $et_vect_call_nearbyintf_saved($et_index)\" 2\n-    return $et_vect_call_nearbyintf_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_nearbyintf {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector round calls.\n \n proc check_effective_target_vect_call_round { } {\n-    global et_vect_call_round_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_round_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_round: using cached result\" 2\n-    } else {\n-\tset et_vect_call_round_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_round_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_round:\\\n-\t     returning $et_vect_call_round_saved($et_index)\" 2\n-    return $et_vect_call_round_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_round {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports vector roundf calls.\n \n proc check_effective_target_vect_call_roundf { } {\n-    global et_vect_call_roundf_saved\n-    global et_index\n-\n-    if [info exists et_vect_call_roundf_saved($et_index)] {\n-\tverbose \"check_effective_target_vect_call_roundf: using cached result\" 2\n-    } else {\n-\tset et_vect_call_roundf_saved($et_index) 0\n-\tif { [istarget aarch64*-*-*] } {\n-\t  set et_vect_call_roundf_saved($et_index) 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_vect_call_roundf:\\\n-\t     returning $et_vect_call_roundf_saved($et_index)\" 2\n-    return $et_vect_call_roundf_saved($et_index)\n+    return [check_cached_effective_target_indexed vect_call_roundf {\n+      expr { [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports AND, OR and XOR reduction.\n@@ -7336,21 +6453,10 @@ proc check_effective_target_vect_fold_extract_last { } {\n # Return 1 if the target supports section-anchors\n \n proc check_effective_target_section_anchors { } {\n-    global et_section_anchors_saved\n-\n-    if [info exists et_section_anchors_saved] {\n-        verbose \"check_effective_target_section_anchors: using cached result\" 2\n-    } else {\n-        set et_section_anchors_saved 0\n-        if { [istarget powerpc*-*-*]\n-\t      || [istarget arm*-*-*] \n-\t      || [istarget aarch64*-*-*] } {\n-           set et_section_anchors_saved 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_section_anchors: returning $et_section_anchors_saved\" 2\n-    return $et_section_anchors_saved\n+    return [check_cached_effective_target section_anchors {\n+      expr { [istarget powerpc*-*-*]\n+\t     || [istarget arm*-*-*]\n+\t     || [istarget aarch64*-*-*] }}]\n }\n \n # Return 1 if the target supports atomic operations on \"int_128\" values.\n@@ -7446,13 +6552,8 @@ proc check_effective_target_sync_long_long_runtime { } {\n # Return 1 if the target supports byte swap instructions.\n \n proc check_effective_target_bswap { } {\n-    global et_bswap_saved\n-\n-    if [info exists et_bswap_saved] {\n-        verbose \"check_effective_target_bswap: using cached result\" 2\n-    } else {\n-\tset et_bswap_saved 0\n-\tif { [istarget aarch64*-*-*]\n+    return [check_cached_effective_target bswap {\n+      expr { [istarget aarch64*-*-*]\n \t     || [istarget alpha*-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget m68k-*-*]\n@@ -7465,27 +6566,16 @@ proc check_effective_target_bswap { } {\n \t\t     #error not armv6 or later\n \t\t     #endif\n \t\t     int i;\n-\t\t } \"\"]) } {\n-\t\tset et_bswap_saved 1\n-\t}\n-    }\n-\n-    verbose \"check_effective_target_bswap: returning $et_bswap_saved\" 2\n-    return $et_bswap_saved\n+\t\t } \"\"]) }}]\n }\n \n # Return 1 if the target supports atomic operations on \"int\" and \"long\".\n \n proc check_effective_target_sync_int_long { } {\n-    global et_sync_int_long_saved\n-\n-    if [info exists et_sync_int_long_saved] {\n-        verbose \"check_effective_target_sync_int_long: using cached result\" 2\n-    } else {\n-        set et_sync_int_long_saved 0\n # This is intentionally powerpc but not rs6000, rs6000 doesn't have the\n # load-reserved/store-conditional instructions.\n-        if { [istarget ia64-*-*]\n+    return [check_cached_effective_target sync_int_long {\n+      expr { [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget alpha*-*-*] \n@@ -7500,27 +6590,16 @@ proc check_effective_target_sync_int_long { } {\n \t     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])\n \t     || [istarget spu-*-*]\n \t     || ([istarget arc*-*-*] && [check_effective_target_arc_atomic])\n-\t     || [check_effective_target_mips_llsc] } {\n-           set et_sync_int_long_saved 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_sync_int_long: returning $et_sync_int_long_saved\" 2\n-    return $et_sync_int_long_saved\n+\t     || [check_effective_target_mips_llsc] }}]\n }\n \n # Return 1 if the target supports atomic operations on \"char\" and \"short\".\n \n proc check_effective_target_sync_char_short { } {\n-    global et_sync_char_short_saved\n-\n-    if [info exists et_sync_char_short_saved] {\n-        verbose \"check_effective_target_sync_char_short: using cached result\" 2\n-    } else {\n-        set et_sync_char_short_saved 0\n # This is intentionally powerpc but not rs6000, rs6000 doesn't have the\n # load-reserved/store-conditional instructions.\n-        if { [istarget aarch64*-*-*]\n+    return [check_cached_effective_target sync_char_short {\n+      expr { [istarget aarch64*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget alpha*-*-*] \n@@ -7534,13 +6613,7 @@ proc check_effective_target_sync_char_short { } {\n \t     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])\n \t     || [istarget spu-*-*]\n \t     || ([istarget arc*-*-*] && [check_effective_target_arc_atomic])\n-\t     || [check_effective_target_mips_llsc] } {\n-           set et_sync_char_short_saved 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_sync_char_short: returning $et_sync_char_short_saved\" 2\n-    return $et_sync_char_short_saved\n+\t     || [check_effective_target_mips_llsc] }}]\n }\n \n # Return 1 if the target uses a ColdFire FPU.\n@@ -7692,6 +6765,7 @@ proc is-effective-target { arg } {\n \t  default          { error \"unknown effective target keyword `$arg'\" }\n \t}\n     }\n+\n     verbose \"is-effective-target: $arg $selected\" 2\n     return $selected\n }\n@@ -8822,23 +7896,17 @@ proc check_effective_target_fenv_exceptions {} {\n }\n \n proc check_effective_target_tiny {} {\n-    global et_target_tiny_saved\n-\n-    if [info exists et_target_tiny_saved] {\n-      verbose \"check_effective_target_tiny: using cached result\" 2\n-    } else {\n-       set et_target_tiny_saved 0\n-       if { [istarget aarch64*-*-*]\n-             && [check_effective_target_aarch64_tiny] } {\n-         set et_target_tiny_saved 1\n-       }\n-       if { [istarget avr-*-*]\n-             && [check_effective_target_avr_tiny] } {\n-         set et_target_tiny_saved 1\n-       }\n-    }\n-\n-    return $et_target_tiny_saved\n+    return [check_cached_effective_target tiny {\n+      if { [istarget aarch64*-*-*]\n+\t\t && [check_effective_target_aarch64_tiny] } {\n+\t   return 1\n+      }\n+      if { [istarget avr-*-*]\n+\t    && [check_effective_target_avr_tiny] } {\n+\t   return 1\n+      }\n+      return 0\n+    }]\n }\n \n # Return 1 if LOGICAL_OP_NON_SHORT_CIRCUIT is set to 0 for the current target.\n@@ -8924,7 +7992,6 @@ proc scan-ltrans-tree-dump-dem-not_required_options {} {\n # otherwise.  Cache the result.\n \n proc check_effective_target_pie_copyreloc { } {\n-    global pie_copyreloc_available_saved\n     global tool\n     global GCC_UNDER_TEST\n \n@@ -8937,9 +8004,7 @@ proc check_effective_target_pie_copyreloc { } {\n \treturn 0\n     }\n \n-    if [info exists pie_copyreloc_available_saved] {\n-\tverbose \"check_effective_target_pie_copyreloc returning saved $pie_copyreloc_available_saved\" 2\n-    } else {\n+    return [check_cached_effective_target pie_copyreloc {\n \t# Set up and compile to see if linker supports PIE with copy\n \t# reloc.  Include the current process ID in the file names to\n \t# prevent conflicts with invocations for multiple testsuites.\n@@ -8962,21 +8027,18 @@ proc check_effective_target_pie_copyreloc { } {\n \n \tif [string match \"\" $lines] then {\n \t    verbose \"check_effective_target_pie_copyreloc testfile compilation passed\" 2\n-\t    set pie_copyreloc_available_saved 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_effective_target_pie_copyreloc testfile compilation failed\" 2\n-\t    set pie_copyreloc_available_saved 0\n+\t    return 0\n \t}\n-    }\n-\n-    return $pie_copyreloc_available_saved\n+    }]\n }\n \n # Return 1 if the x86 target supports R_386_GOT32X relocation, 0\n # otherwise.  Cache the result.\n \n proc check_effective_target_got32x_reloc { } {\n-    global got32x_reloc_available_saved\n     global tool\n     global GCC_UNDER_TEST\n \n@@ -8989,9 +8051,7 @@ proc check_effective_target_got32x_reloc { } {\n \treturn 0\n     }\n \n-    if [info exists got32x_reloc_available_saved] {\n-\tverbose \"check_effective_target_got32x_reloc returning saved $got32x_reloc_available_saved\" 2\n-    } else {\n+    return [check_cached_effective_target got32x_reloc {\n \t# Include the current process ID in the file names to prevent\n \t# conflicts with invocations for multiple testsuites.\n \n@@ -9013,12 +8073,12 @@ proc check_effective_target_got32x_reloc { } {\n \n \tif [string match \"\" $lines] then {\n \t    verbose \"check_effective_target_got32x_reloc testfile compilation passed\" 2\n-\t    set got32x_reloc_available_saved 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_effective_target_got32x_reloc testfile compilation failed\" 2\n-\t    set got32x_reloc_available_saved 0\n+\t    return 0\n \t}\n-    }\n+    }]\n \n     return $got32x_reloc_available_saved\n }\n@@ -9027,7 +8087,6 @@ proc check_effective_target_got32x_reloc { } {\n # 0 otherwise.  Cache the result.\n \n proc check_effective_target_tls_get_addr_via_got { } {\n-    global tls_get_addr_via_got_available_saved\n     global tool\n     global GCC_UNDER_TEST\n \n@@ -9040,9 +8099,7 @@ proc check_effective_target_tls_get_addr_via_got { } {\n \treturn 0\n     }\n \n-    if [info exists tls_get_addr_via_got_available_saved] {\n-\tverbose \"check_effective_target_tls_get_addr_via_got returning saved $tls_get_addr_via_got_available_saved\" 2\n-    } else {\n+    return [check_cached_effective_target tls_get_addr_via_got {\n \t# Include the current process ID in the file names to prevent\n \t# conflicts with invocations for multiple testsuites.\n \n@@ -9064,14 +8121,12 @@ proc check_effective_target_tls_get_addr_via_got { } {\n \n \tif [string match \"\" $lines] then {\n \t    verbose \"check_effective_target_tls_get_addr_via_got testfile compilation passed\" 2\n-\t    set tls_get_addr_via_got_available_saved 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_effective_target_tls_get_addr_via_got testfile compilation failed\" 2\n-\t    set tls_get_addr_via_got_available_saved 0\n+\t    return 0\n \t}\n-    }\n-\n-    return $tls_get_addr_via_got_available_saved\n+    }]\n }\n \n # Return 1 if the target uses comdat groups."}]}