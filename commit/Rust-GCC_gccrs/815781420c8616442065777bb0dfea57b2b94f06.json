{"sha": "815781420c8616442065777bb0dfea57b2b94f06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE1NzgxNDIwYzg2MTY0NDIwNjU3NzdiYjBkZmVhNTdiMmI5NGYwNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-17T03:59:13Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-17T03:59:13Z"}, "message": "entered into RCS\n\nFrom-SVN: r1600", "tree": {"sha": "756855f8cd1ae9781afb2406d3b47f0623178ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/756855f8cd1ae9781afb2406d3b47f0623178ab9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/815781420c8616442065777bb0dfea57b2b94f06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815781420c8616442065777bb0dfea57b2b94f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815781420c8616442065777bb0dfea57b2b94f06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815781420c8616442065777bb0dfea57b2b94f06/comments", "author": null, "committer": null, "parents": [{"sha": "3b59a331296d68c340d2d61572564e506a09b2f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b59a331296d68c340d2d61572564e506a09b2f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b59a331296d68c340d2d61572564e506a09b2f0"}], "stats": {"total": 152, "additions": 149, "deletions": 3}, "files": [{"sha": "9796a46a619b05b114f088acaf1c8dd5559a335f", "filename": "gcc/integrate.c", "status": "modified", "additions": 149, "deletions": 3, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815781420c8616442065777bb0dfea57b2b94f06/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815781420c8616442065777bb0dfea57b2b94f06/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=815781420c8616442065777bb0dfea57b2b94f06", "patch": "@@ -612,6 +612,11 @@ copy_decl_tree (block)\n   t = copy_node (block);\n   BLOCK_VARS (t) = vars;\n   BLOCK_SUBBLOCKS (t) = nreverse (subblocks);\n+  /* If the BLOCK being cloned is already marked as having been instantiated\n+     from something else, then leave that `origin' marking alone.  Elsewise,\n+     mark the clone as having originated from the BLOCK we are cloning.  */\n+  if (BLOCK_ABSTRACT_ORIGIN (t) == NULL_TREE)\n+    BLOCK_ABSTRACT_ORIGIN (t) = block;\n   return t;\n }\n \n@@ -1096,7 +1101,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n      tree type;\n      rtx structure_value_addr;\n {\n-  tree formal, actual;\n+  tree formal, actual, block;\n   rtx header = DECL_SAVED_INSNS (fndecl);\n   rtx insns = FIRST_FUNCTION_INSN (header);\n   rtx parm_insns = FIRST_PARM_INSN (header);\n@@ -1663,7 +1668,8 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n      and copied LABEL_DECLs.  */\n \n   expand_end_bindings (getdecls (), 1, 1);\n-  poplevel (1, 1, 0);\n+  block = poplevel (1, 1, 0);\n+  BLOCK_ABSTRACT_ORIGIN (block) = fndecl;\n   poplevel (0, 0, 0);\n   emit_line_note (input_filename, lineno);\n \n@@ -1766,7 +1772,10 @@ integrate_decl_tree (let, level, map)\n     {\n       node = poplevel (1, 0, 0);\n       if (node)\n-\tTREE_USED (node) = TREE_USED (let);\n+\t{\n+\t  TREE_USED (node) = TREE_USED (let);\n+\t  BLOCK_ABSTRACT_ORIGIN (node) = let;\n+\t}\n     }\n }\n \f\n@@ -2533,6 +2542,132 @@ restore_constants (px)\n     }\n }\n \f\n+/* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the\n+   given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so\n+   that it points to the node itself, thus indicating that the node is its\n+   own (abstract) origin.  Additionally, if the BLOCK_ABSTRACT_ORIGIN for\n+   the given node is NULL, recursively descend the decl/block tree which\n+   it is the root of, and for each other ..._DECL or BLOCK node contained\n+   therein whose DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also\n+   still NULL, set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN\n+   values to point to themselves.  */\n+\n+static void set_decl_origin_self ();\n+\n+static void\n+set_block_origin_self (stmt)\n+     register tree stmt;\n+{\n+  if (BLOCK_ABSTRACT_ORIGIN (stmt) == NULL_TREE)\n+    {\n+      BLOCK_ABSTRACT_ORIGIN (stmt) = stmt;\n+\n+      {\n+        register tree local_decl;\n+\n+        for (local_decl = BLOCK_VARS (stmt);\n+\t     local_decl != NULL_TREE;\n+\t     local_decl = TREE_CHAIN (local_decl))\n+          set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n+      }\n+\n+      {\n+        register tree subblock;\n+\n+        for (subblock = BLOCK_SUBBLOCKS (stmt);\n+\t     subblock != NULL_TREE;\n+\t     subblock = BLOCK_CHAIN (subblock))\n+          set_block_origin_self (subblock);\t/* Recurse.  */\n+      }\n+    }\n+}\n+\n+/* Given a pointer to some ..._DECL node, if the DECL_ABSTRACT_ORIGIN for\n+   the given ..._DECL node is NULL, set the DECL_ABSTRACT_ORIGIN for the\n+   node to so that it points to the node itself, thus indicating that the\n+   node represents its own (abstract) origin.  Additionally, if the\n+   DECL_ABSTRACT_ORIGIN for the given node is NULL, recursively descend\n+   the decl/block tree of which the given node is the root of, and for\n+   each other ..._DECL or BLOCK node contained therein whose\n+   DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also still NULL,\n+   set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN values to\n+   point to themselves.  */\n+\n+static void\n+set_decl_origin_self (decl)\n+     register tree decl;\n+{\n+  if (DECL_ABSTRACT_ORIGIN (decl) == NULL_TREE)\n+    {\n+      DECL_ABSTRACT_ORIGIN (decl) = decl;\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  register tree arg;\n+\n+\t  for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n+\t    DECL_ABSTRACT_ORIGIN (arg) = arg;\n+\t  if (DECL_INITIAL (decl) != NULL_TREE)\n+\t    set_block_origin_self (DECL_INITIAL (decl));\n+\t}\n+    }\n+}\n+\f\n+/* Given a pointer to some BLOCK node, and a boolean value to set the\n+   \"abstract\" flags to, set that value into the BLOCK_ABSTRACT flag for\n+   the given block, and for all local decls and all local sub-blocks\n+   (recursively) which are contained therein.  */\n+\n+void set_decl_abstract_flags ();\n+\n+static void\n+set_block_abstract_flags (stmt, setting)\n+     register tree stmt;\n+     register int setting;\n+{\n+  BLOCK_ABSTRACT (stmt) = setting;\n+\n+  {\n+    register tree local_decl;\n+\n+    for (local_decl = BLOCK_VARS (stmt);\n+\t local_decl != NULL_TREE;\n+\t local_decl = TREE_CHAIN (local_decl))\n+      set_decl_abstract_flags (local_decl, setting);\n+  }\n+\n+  {\n+    register tree subblock;\n+\n+    for (subblock = BLOCK_SUBBLOCKS (stmt);\n+\t subblock != NULL_TREE;\n+\t subblock = BLOCK_CHAIN (subblock))\n+      set_block_abstract_flags (subblock, setting);\n+  }\n+}\n+\n+/* Given a pointer to some ..._DECL node, and a boolean value to set the\n+   \"abstract\" flags to, set that value into the DECL_ABSTRACT flag for the\n+   given decl, and (in the case where the decl is a FUNCTION_DECL) also\n+   set the abstract flags for all of the parameters, local vars, local\n+   blocks and sub-blocks (recursively) to the same setting.  */\n+\n+void\n+set_decl_abstract_flags (decl, setting)\n+     register tree decl;\n+     register int setting;\n+{\n+  DECL_ABSTRACT (decl) = setting;\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      register tree arg;\n+\n+      for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n+\tDECL_ABSTRACT (arg) = setting;\n+      if (DECL_INITIAL (decl) != NULL_TREE)\n+\tset_block_abstract_flags (DECL_INITIAL (decl), setting);\n+    }\n+}\n+\f\n /* Output the assembly language code for the function FNDECL\n    from its DECL_SAVED_INSNS.  Used for inline functions that are output\n    at end of compilation instead of where they came in the source.  */\n@@ -2614,6 +2749,17 @@ output_inline_function (fndecl)\n   set_new_first_and_last_insn (FIRST_PARM_INSN (head), last);\n   set_new_first_and_last_label_num (FIRST_LABELNO (head), LAST_LABELNO (head));\n \n+  /* We must have already output DWARF debugging information for the\n+     original (abstract) inline function declaration/definition, so\n+     we want to make sure that the debugging information we generate\n+     for this special instance of the inline function refers back to\n+     the information we already generated.  To make sure that happens,\n+     we simply have to set the DECL_ABSTRACT_ORIGIN for the function\n+     node (and for all of the local ..._DECL nodes which are its children)\n+     so that they all point to themselves.  */\n+\n+  set_decl_origin_self (fndecl);\n+\n   /* Compile this function all the way down to assembly code.  */\n   rest_of_compilation (fndecl);\n "}]}