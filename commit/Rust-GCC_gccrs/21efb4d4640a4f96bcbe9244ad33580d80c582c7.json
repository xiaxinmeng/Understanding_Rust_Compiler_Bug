{"sha": "21efb4d4640a4f96bcbe9244ad33580d80c582c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFlZmI0ZDQ2NDBhNGY5NmJjYmU5MjQ0YWQzMzU4MGQ4MGM1ODJjNw==", "commit": {"author": {"name": "Harsha Jagasia", "email": "harsha.jagasia@amd.com", "date": "2007-02-05T23:33:54Z"}, "committer": {"name": "Harsha Jagasia", "email": "hjagasia@gcc.gnu.org", "date": "2007-02-05T23:33:54Z"}, "message": "amdfam10\n\nFrom-SVN: r121625", "tree": {"sha": "04a07dd660a6daef283ae583ef03c1e2b2ae3bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04a07dd660a6daef283ae583ef03c1e2b2ae3bd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21efb4d4640a4f96bcbe9244ad33580d80c582c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21efb4d4640a4f96bcbe9244ad33580d80c582c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21efb4d4640a4f96bcbe9244ad33580d80c582c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21efb4d4640a4f96bcbe9244ad33580d80c582c7/comments", "author": null, "committer": null, "parents": [{"sha": "63694bdd4ea2e2df10f86a16b5e3ccd38209e34a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63694bdd4ea2e2df10f86a16b5e3ccd38209e34a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63694bdd4ea2e2df10f86a16b5e3ccd38209e34a"}], "stats": {"total": 2014, "additions": 1865, "deletions": 149}, "files": [{"sha": "8cf29789f67120377ed2339a83ef332242aa75ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -1,3 +1,157 @@\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/athlon.md (athlon_fldxf_k8, athlon_fld_k8,\n+\tathlon_fstxf_k8, athlon_fst_k8, athlon_fist, athlon_fmov,\n+\tathlon_fadd_load, athlon_fadd_load_k8, athlon_fadd, athlon_fmul,\n+\tathlon_fmul_load, athlon_fmul_load_k8, athlon_fsgn,\n+\tathlon_fdiv_load, athlon_fdiv_load_k8, athlon_fdiv_k8,\n+\tathlon_fpspc_load, athlon_fpspc, athlon_fcmov_load,\n+\tathlon_fcmov_load_k8, athlon_fcmov_k8, athlon_fcomi_load_k8,\n+\tathlon_fcomi, athlon_fcom_load_k8, athlon_fcom): Added amdfam10.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/i386.md (x86_sahf_1, cmpfp_i_mixed, cmpfp_i_sse,\n+\tcmpfp_i_i387, cmpfp_iu_mixed, cmpfp_iu_sse, cmpfp_iu_387,\n+\tswapsi, swaphi_1, swapqi_1, swapdi_rex64, fix_truncsfdi_sse,\n+\tfix_truncdfdi_sse, fix_truncsfsi_sse, fix_truncdfsi_sse,\n+\tx86_fldcw_1, floatsisf2_mixed, floatsisf2_sse, floatdisf2_mixed,\n+\tfloatdisf2_sse, floatsidf2_mixed, floatsidf2_sse,\n+\tfloatdidf2_mixed, floatdidf2_sse, muldi3_1_rex64, mulsi3_1,\n+\tmulsi3_1_zext, mulhi3_1, mulqi3_1, umulqihi3_1, mulqihi3_insn,\n+\tumulditi3_insn, umulsidi3_insn, mulditi3_insn, mulsidi3_insn,\n+\tumuldi3_highpart_rex64, umulsi3_highpart_insn,\n+\tumulsi3_highpart_zext, smuldi3_highpart_rex64,\n+\tsmulsi3_highpart_insn, smulsi3_highpart_zext, x86_64_shld,\n+\tx86_shld_1, x86_64_shrd, sqrtsf2_mixed, sqrtsf2_sse,\n+\tsqrtsf2_i387, sqrtdf2_mixed, sqrtdf2_sse, sqrtdf2_i387,\n+\tsqrtextendsfdf2_i387, sqrtxf2, sqrtextendsfxf2_i387,\n+\tsqrtextenddfxf2_i387): Added amdfam10_decode.\n+\t\n+\t* config/i386/athlon.md (athlon_idirect_amdfam10,\n+\tathlon_ivector_amdfam10, athlon_idirect_load_amdfam10,\n+\tathlon_ivector_load_amdfam10, athlon_idirect_both_amdfam10,\n+\tathlon_ivector_both_amdfam10, athlon_idirect_store_amdfam10,\n+\tathlon_ivector_store_amdfam10): New define_insn_reservation.\n+\t(athlon_idirect_loadmov, athlon_idirect_movstore): Added\n+\tamdfam10.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/athlon.md (athlon_call_amdfam10,\n+\tathlon_pop_amdfam10, athlon_lea_amdfam10): New\n+\tdefine_insn_reservation.\n+\t(athlon_branch, athlon_push, athlon_leave_k8, athlon_imul_k8,\n+\tathlon_imul_k8_DI, athlon_imul_mem_k8, athlon_imul_mem_k8_DI,\n+\tathlon_idiv, athlon_idiv_mem, athlon_str): Added amdfam10.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/athlon.md (athlon_sseld_amdfam10,\n+\tathlon_mmxld_amdfam10, athlon_ssest_amdfam10,\n+\tathlon_mmxssest_short_amdfam10): New define_insn_reservation.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/athlon.md (athlon_sseins_amdfam10): New\n+\tdefine_insn_reservation.\n+\t* config/i386/i386.md (sseins): Added sseins to define_attr type\n+\tand define_attr unit.\n+\t* config/i386/sse.md: Set type attribute to sseins for insertq\n+\tand insertqi.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/athlon.md (sselog_load_amdfam10, sselog_amdfam10,\n+\tssecmpvector_load_amdfam10, ssecmpvector_amdfam10,\n+\tssecomi_load_amdfam10, ssecomi_amdfam10,\n+\tsseaddvector_load_amdfam10, sseaddvector_amdfam10): New\n+\tdefine_insn_reservation.\n+\t(ssecmp_load_k8, ssecmp, sseadd_load_k8, seadd): Added amdfam10.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/athlon.md (cvtss2sd_load_amdfam10,\n+\tcvtss2sd_amdfam10, cvtps2pd_load_amdfam10, cvtps2pd_amdfam10,\n+\tcvtsi2sd_load_amdfam10, cvtsi2ss_load_amdfam10,\n+\tcvtsi2sd_amdfam10, cvtsi2ss_amdfam10, cvtsd2ss_load_amdfam10,\n+\tcvtsd2ss_amdfam10, cvtpd2ps_load_amdfam10, cvtpd2ps_amdfam10,\n+\tcvtsX2si_load_amdfam10, cvtsX2si_amdfam10): New \n+\tdefine_insn_reservation.\n+\n+\t* config/i386/sse.md (cvtsi2ss, cvtsi2ssq, cvtss2si,\n+\tcvtss2siq, cvttss2si, cvttss2siq, cvtsi2sd, cvtsi2sdq,\n+\tcvtsd2si, cvtsd2siq, cvttsd2si, cvttsd2siq,\n+\tcvtpd2dq, cvttpd2dq, cvtsd2ss, cvtss2sd,\n+\tcvtpd2ps, cvtps2pd): Added amdfam10_decode attribute.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/athlon.md (athlon_ssedivvector_amdfam10,\n+\tathlon_ssedivvector_load_amdfam10, athlon_ssemulvector_amdfam10,\n+\tathlon_ssemulvector_load_amdfam10): New define_insn_reservation.\n+\t(athlon_ssediv, athlon_ssediv_load_k8, athlon_ssemul,\n+\tathlon_ssemul_load_k8): Added amdfam10.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/i386.h (TARGET_SSE_UNALIGNED_MOVE_OPTIMAL): New macro.\n+\t(x86_sse_unaligned_move_optimal): New variable.\n+\t\n+\t* config/i386/i386.c (x86_sse_unaligned_move_optimal): Enable for  \n+\tm_AMDFAM10.\n+\t(ix86_expand_vector_move_misalign): Add code to generate movupd/movups\n+\tfor unaligned vector SSE double/single precision loads for AMDFAM10.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\n+\t* config/i386/i386.h (TARGET_AMDFAM10): New macro.\n+\t(TARGET_CPU_CPP_BUILTINS): Add code for amdfam10.\n+\tDefine TARGET_CPU_DEFAULT_amdfam10.\n+\t(TARGET_CPU_DEFAULT_NAMES): Add amdfam10.\n+\t(processor_type): Add PROCESSOR_AMDFAM10.\t\n+\t\n+\t* config/i386/i386.md: Add amdfam10 as a new cpu attribute to match\n+\tprocessor_type in config/i386/i386.h.\n+\tEnable imul peepholes for TARGET_AMDFAM10.\n+\t\n+\t* config.gcc: Add support for --with-cpu option for amdfam10.\n+\t\n+\t* config/i386/i386.c (amdfam10_cost): New variable.\n+\t(m_AMDFAM10): New macro.\n+\t(m_ATHLON_K8_AMDFAM10): New macro.\n+\t(x86_use_leave, x86_push_memory, x86_movx, x86_unroll_strlen,\n+\tx86_cmove, x86_3dnow_a, x86_deep_branch, x86_use_simode_fiop,\n+\tx86_promote_QImode, x86_integer_DFmode_moves,\n+\tx86_partial_reg_dependency, x86_memory_mismatch_stall, \n+\tx86_accumulate_outgoing_args, x86_arch_always_fancy_math_387,\n+\tx86_sse_partial_reg_dependency, x86_sse_typeless_stores,\n+\tx86_use_ffreep, x86_use_incdec, x86_four_jump_limit,\n+\tx86_schedule, x86_use_bt, x86_cmpxchg16b, x86_pad_returns):\n+\tEnable/disable for amdfam10.\n+\t(override_options): Add amdfam10_cost to processor_target_table.\n+\tSet up PROCESSOR_AMDFAM10 for amdfam10 entry in \n+\tprocessor_alias_table.\n+\t(ix86_issue_rate): Add PROCESSOR_AMDFAM10.\n+\t(ix86_adjust_cost): Add code for amdfam10.\n+\n+2007-02-05\tHarsha Jagasia\t<harsha.jagasia@amd.com>\n+\t\n+\t* config/i386/i386.opt: Add new Advanced Bit Manipulation (-mabm)\n+\tinstruction set feature flag. Add new (-mpopcnt) flag for popcnt \n+\tinstruction. Add new SSE4A (-msse4a) instruction set feature flag.\n+\t* config/i386/i386.h: Add builtin definition for SSE4A.\n+\t* config/i386/i386.md: Add support for ABM instructions \n+\t(popcnt and lzcnt).\n+\t* config/i386/sse.md: Add support for SSE4A instructions\n+\t(movntss, movntsd, extrq, insertq).\n+\t* config/i386/i386.c: Add support for ABM and SSE4A builtins.\n+\tAdd -march=amdfam10 flag.\n+\t* config/i386/ammintrin.h: Add support for SSE4A intrinsics.\n+\t* doc/invoke.texi: Add documentation on flags for sse4a, abm, popcnt\n+\tand amdfam10.\n+\t* doc/extend.texi: Add documentation for SSE4A builtins.\n+\n 2007-02-05  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (constantpool_mem_p): Skip over SUBREGs."}, {"sha": "17f429c9f2dcd32ede4fcfb81c78ced394027ddb", "filename": "gcc/config.gcc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -272,12 +272,12 @@ xscale-*-*)\n i[34567]86-*-*)\n \tcpu_type=i386\n \textra_headers=\"mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n-\t\t       pmmintrin.h tmmintrin.h\"\n+\t\t       pmmintrin.h tmmintrin.h ammintrin.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n \textra_headers=\"mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n-\t\t       pmmintrin.h tmmintrin.h\"\n+\t\t       pmmintrin.h tmmintrin.h ammintrin.h\"\n \tneed_64bit_hwint=yes\n \t;;\n ia64-*-*)\n@@ -1111,14 +1111,14 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu)\n \t\t\t# FIXME: -m64 for i[34567]86-*-* should be allowed just\n \t\t\t# like -m32 for x86_64-*-*.\n \t\t\tcase X\"${with_cpu}\" in\n-\t\t\tXgeneric|Xcore2|Xnocona|Xx86-64|Xk8|Xopteron|Xathlon64|Xathlon-fx)\n+\t\t\tXgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xk8|Xopteron|Xathlon64|Xathlon-fx)\n \t\t\t\t;;\n \t\t\tX)\n \t\t\t\twith_cpu=generic\n \t\t\t\t;;\n \t\t\t*)\n \t\t\t\techo \"Unsupported CPU used in --with-cpu=$with_cpu, supported values:\" 1>&2\n-\t\t\t\techo \"generic core2 nocona x86-64 k8 opteron athlon64 athlon-fx\" 1>&2\n+\t\t\t\techo \"generic core2 nocona x86-64 amdfam10 k8 opteron athlon64 athlon-fx\" 1>&2\n \t\t\t\texit 1\n \t\t\t\t;;\n \t\t\tesac\n@@ -1240,14 +1240,14 @@ i[34567]86-*-solaris2*)\n \t\t# FIXME: -m64 for i[34567]86-*-* should be allowed just\n \t\t# like -m32 for x86_64-*-*.\n \t\tcase X\"${with_cpu}\" in\n-\t\tXgeneric|Xcore2|Xnocona|Xx86-64|Xk8|Xopteron|Xathlon64|Xathlon-fx)\n+\t\tXgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xk8|Xopteron|Xathlon64|Xathlon-fx)\n \t\t\t;;\n \t\tX)\n \t\t\twith_cpu=generic\n \t\t\t;;\n \t\t*)\n \t\t\techo \"Unsupported CPU used in --with-cpu=$with_cpu, supported values:\" 1>&2\n-\t\t\techo \"generic core2 nocona x86-64 k8 opteron athlon64 athlon-fx\" 1>&2\n+\t\t\techo \"generic core2 nocona x86-64 amdfam10 k8 opteron athlon64 athlon-fx\" 1>&2\n \t\t\texit 1\n \t\t\t;;\n \t\tesac\n@@ -2568,6 +2568,9 @@ if test x$with_cpu = x ; then\n       ;;\n     i686-*-* | i786-*-*)\n       case ${target_noncanonical} in\n+        amdfam10-*)\n+          with_cpu=amdfam10\n+          ;;\n         k8-*|opteron-*|athlon_64-*)\n           with_cpu=k8\n           ;;\n@@ -2611,6 +2614,9 @@ if test x$with_cpu = x ; then\n       ;;\n     x86_64-*-*)\n       case ${target_noncanonical} in\n+        amdfam10-*)\n+          with_cpu=amdfam10\n+          ;;\n         k8-*|opteron-*|athlon_64-*)\n           with_cpu=k8\n           ;;\n@@ -2874,7 +2880,7 @@ case \"${target}\" in\n \t\t\t\tesac\n \t\t\t\t# OK\n \t\t\t\t;;\n-\t\t\t\"\" | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)\n+\t\t\t\"\" | amdfam10 | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)\n \t\t\t\t# OK\n \t\t\t\t;;\n \t\t\t*)"}, {"sha": "869c2880e25b7ccabee311cde5347b8d9ab45bb2", "filename": "gcc/config/i386/ammintrin.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fammintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fammintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fammintrin.h?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -0,0 +1,73 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/* Implemented from the specification included in the AMD Programmers\n+   Manual Update, version 2.x */\n+\n+#ifndef _AMMINTRIN_H_INCLUDED\n+#define _AMMINTRIN_H_INCLUDED\n+\n+#ifndef __SSE4A__\n+# error \"SSE4A instruction set not enabled\"\n+#else\n+\n+/* We need definitions from the SSE3, SSE2 and SSE header files*/\n+#include <pmmintrin.h>\n+\n+static __inline void __attribute__((__always_inline__))\n+_mm_stream_sd (double * __P, __m128d __Y)\n+{\n+  __builtin_ia32_movntsd (__P, (__v2df) __Y);\n+}\n+\n+static __inline void __attribute__((__always_inline__))\n+_mm_stream_ss (float * __P, __m128 __Y)\n+{\n+  __builtin_ia32_movntss (__P, (__v4sf) __Y);\n+}\n+\n+static __inline __m128i __attribute__((__always_inline__))\n+_mm_extract_si64 (__m128i __X, __m128i __Y)\n+{\n+  return (__m128i) __builtin_ia32_extrq ((__v2di) __X, (__v16qi) __Y);\n+}\n+\n+#define _mm_extracti_si64(X, I, L) \\\n+((__m128i) __builtin_ia32_extrqi ((__v2di)(X), I, L))\n+\n+static __inline __m128i __attribute__((__always_inline__))\n+_mm_insert_si64 (__m128i __X,__m128i __Y)\n+{\n+  return (__m128i) __builtin_ia32_insertq ((__v2di)__X, (__v2di)__Y);\n+}\n+\n+#define _mm_inserti_si64(X, Y, I, L) \\\n+((__m128i) __builtin_ia32_insertqi ((__v2di)(X), (__v2di)(Y), I, L))\n+\n+\n+#endif /* __SSE4A__ */\n+\n+#endif /* _AMMINTRIN_H_INCLUDED */"}, {"sha": "708507f422472ff47d7db2f757527758cd5a3d24", "filename": "gcc/config/i386/athlon.md", "status": "modified", "additions": 336, "deletions": 42, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fathlon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fathlon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fathlon.md?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -29,6 +29,8 @@\n \t   (const_string \"vector\")]\n \t(const_string \"direct\")))\n \n+(define_attr \"amdfam10_decode\" \"direct,vector,double\"\n+  (const_string \"direct\"))\n ;;\n ;;           decode0 decode1 decode2\n ;;                 \\    |   /\n@@ -131,18 +133,22 @@\n \n ;; Jump instructions are executed in the branch unit completely transparent to us\n (define_insn_reservation \"athlon_branch\" 0\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"ibr\"))\n \t\t\t \"athlon-direct,athlon-ieu\")\n (define_insn_reservation \"athlon_call\" 0\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"call,callv\"))\n \t\t\t \"athlon-vector,athlon-ieu\")\n+(define_insn_reservation \"athlon_call_amdfam10\" 0\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"call,callv\"))\n+\t\t\t \"athlon-double,athlon-ieu\")\n \n ;; Latency of push operation is 3 cycles, but ESP value is available\n ;; earlier\n (define_insn_reservation \"athlon_push\" 2\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"push\"))\n \t\t\t \"athlon-direct,athlon-agu,athlon-store\")\n (define_insn_reservation \"athlon_pop\" 4\n@@ -153,12 +159,16 @@\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"pop\"))\n \t\t\t \"athlon-double,(athlon-ieu+athlon-load)\")\n+(define_insn_reservation \"athlon_pop_amdfam10\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"pop\"))\n+\t\t\t \"athlon-direct,(athlon-ieu+athlon-load)\")\n (define_insn_reservation \"athlon_leave\" 3\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (eq_attr \"type\" \"leave\"))\n \t\t\t \"athlon-vector,(athlon-ieu+athlon-load)\")\n (define_insn_reservation \"athlon_leave_k8\" 3\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"leave\"))\n \t\t\t \"athlon-double,(athlon-ieu+athlon-load)\")\n \n@@ -167,6 +177,11 @@\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"lea\"))\n \t\t\t \"athlon-direct,athlon-agu,nothing\")\n+;; Lea executes in AGU unit with 1 cycle latency on AMDFAM10\n+(define_insn_reservation \"athlon_lea_amdfam10\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"lea\"))\n+\t\t\t \"athlon-direct,athlon-agu,nothing\")\n \n ;; Mul executes in special multiplier unit attached to IEU0\n (define_insn_reservation \"athlon_imul\" 5\n@@ -176,29 +191,35 @@\n \t\t\t \"athlon-vector,athlon-ieu0,athlon-mult,nothing,nothing,athlon-ieu0\")\n ;; ??? Widening multiply is vector or double.\n (define_insn_reservation \"athlon_imul_k8_DI\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"imul\")\n \t\t\t\t   (and (eq_attr \"mode\" \"DI\")\n \t\t\t\t\t(eq_attr \"memory\" \"none,unknown\"))))\n \t\t\t \"athlon-direct0,athlon-ieu0,athlon-mult,nothing,athlon-ieu0\")\n (define_insn_reservation \"athlon_imul_k8\" 3\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"imul\")\n \t\t\t\t   (eq_attr \"memory\" \"none,unknown\")))\n \t\t\t \"athlon-direct0,athlon-ieu0,athlon-mult,athlon-ieu0\")\n+(define_insn_reservation \"athlon_imul_amdfam10_HI\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"imul\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"HI\")\n+\t\t\t\t\t(eq_attr \"memory\" \"none,unknown\"))))\n+\t\t\t \"athlon-vector,athlon-ieu0,athlon-mult,nothing,athlon-ieu0\")\t\t\t \n (define_insn_reservation \"athlon_imul_mem\" 8\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (and (eq_attr \"type\" \"imul\")\n \t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n \t\t\t \"athlon-vector,athlon-load,athlon-ieu,athlon-mult,nothing,nothing,athlon-ieu\")\n (define_insn_reservation \"athlon_imul_mem_k8_DI\" 7\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"imul\")\n \t\t\t\t   (and (eq_attr \"mode\" \"DI\")\n \t\t\t\t\t(eq_attr \"memory\" \"load,both\"))))\n \t\t\t \"athlon-vector,athlon-load,athlon-ieu,athlon-mult,nothing,athlon-ieu\")\n (define_insn_reservation \"athlon_imul_mem_k8\" 6\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"imul\")\n \t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n \t\t\t \"athlon-vector,athlon-load,athlon-ieu,athlon-mult,athlon-ieu\")\n@@ -209,21 +230,23 @@\n ;; other instructions.\n ;; ??? Experiments show that the idiv can overlap with roughly 6 cycles\n ;; of the other code\n+;; Using the same heuristics for amdfam10 as K8 with idiv\n \n (define_insn_reservation \"athlon_idiv\" 6\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"idiv\")\n \t\t\t\t   (eq_attr \"memory\" \"none,unknown\")))\n \t\t\t \"athlon-vector,(athlon-ieu0*6+(athlon-fpsched,athlon-fvector))\")\n (define_insn_reservation \"athlon_idiv_mem\" 9\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"idiv\")\n \t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n \t\t\t \"athlon-vector,((athlon-load,athlon-ieu0*6)+(athlon-fpsched,athlon-fvector))\")\n ;; The parallelism of string instructions is not documented.  Model it same way\n ;; as idiv to create smaller automata.  This probably does not matter much.\n+;; Using the same heuristics for amdfam10 as K8 with idiv\n (define_insn_reservation \"athlon_str\" 6\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"str\")\n \t\t\t\t   (eq_attr \"memory\" \"load,both,store\")))\n \t\t\t \"athlon-vector,athlon-load,athlon-ieu0*6\")\n@@ -234,34 +257,62 @@\n \t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n \t\t\t\t\t(eq_attr \"memory\" \"none,unknown\"))))\n \t\t\t \"athlon-direct,athlon-ieu\")\n+(define_insn_reservation \"athlon_idirect_amdfam10\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"direct\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"none,unknown\"))))\n+\t\t\t \"athlon-direct,athlon-ieu\")\n (define_insn_reservation \"athlon_ivector\" 2\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"vector\")\n \t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n \t\t\t\t\t(eq_attr \"memory\" \"none,unknown\"))))\n \t\t\t \"athlon-vector,athlon-ieu,athlon-ieu\")\n+(define_insn_reservation \"athlon_ivector_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"none,unknown\"))))\n+\t\t\t \"athlon-vector,athlon-ieu,athlon-ieu\")\n+\n (define_insn_reservation \"athlon_idirect_loadmov\" 3\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"imov\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-load\")\n+\n (define_insn_reservation \"athlon_idirect_load\" 4\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"direct\")\n \t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-load,athlon-ieu\")\n+(define_insn_reservation \"athlon_idirect_load_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"direct\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n+\t\t\t \"athlon-direct,athlon-load,athlon-ieu\")\n (define_insn_reservation \"athlon_ivector_load\" 6\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"vector\")\n \t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-vector,athlon-load,athlon-ieu,athlon-ieu\")\n+(define_insn_reservation \"athlon_ivector_load_amdfam10\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n+\t\t\t \"athlon-vector,athlon-load,athlon-ieu,athlon-ieu\")\n+\n (define_insn_reservation \"athlon_idirect_movstore\" 1\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"imov\")\n \t\t\t\t   (eq_attr \"memory\" \"store\")))\n \t\t\t \"athlon-direct,athlon-agu,athlon-store\")\n+\n (define_insn_reservation \"athlon_idirect_both\" 4\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"direct\")\n@@ -270,6 +321,15 @@\n \t\t\t \"athlon-direct,athlon-load,\n \t\t\t  athlon-ieu,athlon-store,\n \t\t\t  athlon-store\")\n+(define_insn_reservation \"athlon_idirect_both_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"direct\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"both\"))))\n+\t\t\t \"athlon-direct,athlon-load,\n+\t\t\t  athlon-ieu,athlon-store,\n+\t\t\t  athlon-store\")\t\t\t  \n+\n (define_insn_reservation \"athlon_ivector_both\" 6\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"vector\")\n@@ -279,20 +339,45 @@\n \t\t\t  athlon-ieu,\n \t\t\t  athlon-ieu,\n \t\t\t  athlon-store\")\n+(define_insn_reservation \"athlon_ivector_both_amdfam10\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"both\"))))\n+\t\t\t \"athlon-vector,athlon-load,\n+\t\t\t  athlon-ieu,\n+\t\t\t  athlon-ieu,\n+\t\t\t  athlon-store\")\n+\n (define_insn_reservation \"athlon_idirect_store\" 1\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"direct\")\n \t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n \t\t\t\t\t(eq_attr \"memory\" \"store\"))))\n \t\t\t \"athlon-direct,(athlon-ieu+athlon-agu),\n \t\t\t  athlon-store\")\n+(define_insn_reservation \"athlon_idirect_store_amdfam10\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"direct\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"store\"))))\n+\t\t\t \"athlon-direct,(athlon-ieu+athlon-agu),\n+\t\t\t  athlon-store\")\n+\n (define_insn_reservation \"athlon_ivector_store\" 2\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"vector\")\n \t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n \t\t\t\t\t(eq_attr \"memory\" \"store\"))))\n \t\t\t \"athlon-vector,(athlon-ieu+athlon-agu),athlon-ieu,\n \t\t\t  athlon-store\")\n+(define_insn_reservation \"athlon_ivector_store_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t   (and (eq_attr \"unit\" \"integer,unknown\")\n+\t\t\t\t\t(eq_attr \"memory\" \"store\"))))\n+\t\t\t \"athlon-vector,(athlon-ieu+athlon-agu),athlon-ieu,\n+\t\t\t  athlon-store\")\n \n ;; Athlon floatin point unit\n (define_insn_reservation \"athlon_fldxf\" 12\n@@ -302,7 +387,7 @@\n \t\t\t\t\t(eq_attr \"mode\" \"XF\"))))\n \t\t\t \"athlon-vector,athlon-fpload2,athlon-fvector*9\")\n (define_insn_reservation \"athlon_fldxf_k8\" 13\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fmov\")\n \t\t\t\t   (and (eq_attr \"memory\" \"load\")\n \t\t\t\t\t(eq_attr \"mode\" \"XF\"))))\n@@ -314,7 +399,7 @@\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fany\")\n (define_insn_reservation \"athlon_fld_k8\" 2\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fmov\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fstore\")\n@@ -326,7 +411,7 @@\n \t\t\t\t\t(eq_attr \"mode\" \"XF\"))))\n \t\t\t \"athlon-vector,(athlon-fpsched+athlon-agu),(athlon-store2+(athlon-fvector*7))\")\n (define_insn_reservation \"athlon_fstxf_k8\" 8\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fmov\")\n \t\t\t\t   (and (eq_attr \"memory\" \"store,both\")\n \t\t\t\t\t(eq_attr \"mode\" \"XF\"))))\n@@ -337,16 +422,16 @@\n \t\t\t\t   (eq_attr \"memory\" \"store,both\")))\n \t\t\t \"athlon-direct,(athlon-fpsched+athlon-agu),(athlon-fstore+athlon-store)\")\n (define_insn_reservation \"athlon_fst_k8\" 2\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fmov\")\n \t\t\t\t   (eq_attr \"memory\" \"store,both\")))\n \t\t\t \"athlon-direct,(athlon-fpsched+athlon-agu),(athlon-fstore+athlon-store)\")\n (define_insn_reservation \"athlon_fist\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fistp,fisttp\"))\n \t\t\t \"athlon-direct,(athlon-fpsched+athlon-agu),(athlon-fstore+athlon-store)\")\n (define_insn_reservation \"athlon_fmov\" 2\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fmov\"))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-faddmul\")\n (define_insn_reservation \"athlon_fadd_load\" 4\n@@ -355,12 +440,12 @@\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fadd\")\n (define_insn_reservation \"athlon_fadd_load_k8\" 6\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fop\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_fadd\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fop\"))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fadd\")\n (define_insn_reservation \"athlon_fmul_load\" 4\n@@ -369,16 +454,16 @@\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fmul\")\n (define_insn_reservation \"athlon_fmul_load_k8\" 6\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fmul\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fmul\")\n (define_insn_reservation \"athlon_fmul\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fmul\"))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fmul\")\n (define_insn_reservation \"athlon_fsgn\" 2\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fsgn\"))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fmul\")\n (define_insn_reservation \"athlon_fdiv_load\" 24\n@@ -387,7 +472,7 @@\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fmul\")\n (define_insn_reservation \"athlon_fdiv_load_k8\" 13\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fdiv\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fmul\")\n@@ -396,16 +481,16 @@\n \t\t\t      (eq_attr \"type\" \"fdiv\"))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fmul\")\n (define_insn_reservation \"athlon_fdiv_k8\" 11\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fdiv\"))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fmul\")\n (define_insn_reservation \"athlon_fpspc_load\" 103\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fpspc\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-vector,athlon-fpload,athlon-fvector\")\n (define_insn_reservation \"athlon_fpspc\" 100\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fpspc\"))\n \t\t\t \"athlon-vector,athlon-fpsched,athlon-fvector\")\n (define_insn_reservation \"athlon_fcmov_load\" 7\n@@ -418,12 +503,12 @@\n \t\t\t      (eq_attr \"type\" \"fcmov\"))\n \t\t\t \"athlon-vector,athlon-fpsched,athlon-fvector\")\n (define_insn_reservation \"athlon_fcmov_load_k8\" 17\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fcmov\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-vector,athlon-fploadk8,athlon-fvector\")\n (define_insn_reservation \"athlon_fcmov_k8\" 15\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fcmov\"))\n \t\t\t \"athlon-vector,athlon-fpsched,athlon-fvector\")\n ;; fcomi is vector decoded by uses only one pipe.\n@@ -434,13 +519,13 @@\n \t\t\t\t        (eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-vector,athlon-fpload,athlon-fadd\")\n (define_insn_reservation \"athlon_fcomi_load_k8\" 5\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fcmp\")\n \t\t\t\t   (and (eq_attr \"athlon_decode\" \"vector\")\n \t\t\t\t        (eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-vector,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_fcomi\" 3\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"athlon_decode\" \"vector\")\n \t\t\t\t   (eq_attr \"type\" \"fcmp\")))\n \t\t\t \"athlon-vector,athlon-fpsched,athlon-fadd\")\n@@ -450,18 +535,18 @@\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fadd\")\n (define_insn_reservation \"athlon_fcom_load_k8\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"fcmp\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_fcom\" 2\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (eq_attr \"type\" \"fcmp\"))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fadd\")\n ;; Never seen by the scheduler because we still don't do post reg-stack\n ;; scheduling.\n ;(define_insn_reservation \"athlon_fxch\" 2\n-;\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+;\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n ;\t\t\t      (eq_attr \"type\" \"fxch\"))\n ;\t\t\t \"athlon-direct,athlon-fpsched,athlon-fany\")\n \n@@ -516,6 +601,23 @@\n \t\t\t      (and (eq_attr \"type\" \"mmxmov,ssemov\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fstore\")\n+;; On AMDFAM10 all double, single and integer packed and scalar SSEx data\n+;; loads  generated are direct path, latency of 2 and do not use any FP\n+;; executions units. No seperate entries for movlpx/movhpx loads, which\n+;; are direct path, latency of 4 and use the FADD/FMUL FP execution units,\n+;; as they will not be generated.\n+(define_insn_reservation \"athlon_sseld_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssemov\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8\")\n+;; On AMDFAM10 MMX data loads  generated are direct path, latency of 4\n+;; and can use any  FP executions units\n+(define_insn_reservation \"athlon_mmxld_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"mmxmov\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8, athlon-fany\")\t\t\t \n (define_insn_reservation \"athlon_mmxssest\" 3\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (and (eq_attr \"type\" \"mmxmov,ssemov\")\n@@ -533,6 +635,25 @@\n \t\t\t      (and (eq_attr \"type\" \"mmxmov,ssemov\")\n \t\t\t\t   (eq_attr \"memory\" \"store,both\")))\n \t\t\t \"athlon-direct,(athlon-fpsched+athlon-agu),(athlon-fstore+athlon-store)\")\n+;; On AMDFAM10 all double, single and integer packed SSEx data stores\n+;; generated are all double path, latency of 2 and use the FSTORE FP\n+;; execution unit. No entries seperate for movupx/movdqu, which are\n+;; vector path, latency of 3 and use the FSTORE*2 FP execution unit,\n+;; as they will not be generated.\n+(define_insn_reservation \"athlon_ssest_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssemov\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF,V2DF,TI\")\n+\t\t\t\t\t(eq_attr \"memory\" \"store,both\"))))\n+\t\t\t \"athlon-double,(athlon-fpsched+athlon-agu),((athlon-fstore+athlon-store)*2)\")\n+;; On AMDFAM10 all double, single and integer scalar SSEx and MMX\n+;; data stores generated are all direct path, latency of 2 and use\n+;; the FSTORE FP execution unit\n+(define_insn_reservation \"athlon_mmxssest_short_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"mmxmov,ssemov\")\n+\t\t\t\t   (eq_attr \"memory\" \"store,both\")))\n+\t\t\t \"athlon-direct,(athlon-fpsched+athlon-agu),(athlon-fstore+athlon-store)\")\n (define_insn_reservation \"athlon_movaps_k8\" 2\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (and (eq_attr \"type\" \"ssemov\")\n@@ -578,6 +699,11 @@\n \t\t\t      (and (eq_attr \"type\" \"sselog,sselog1\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-double,athlon-fpload2k8,(athlon-fmul*2)\")\n+(define_insn_reservation \"athlon_sselog_load_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sselog,sselog1\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8,(athlon-fadd|athlon-fmul)\")\n (define_insn_reservation \"athlon_sselog\" 3\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (eq_attr \"type\" \"sselog,sselog1\"))\n@@ -586,6 +712,11 @@\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"sselog,sselog1\"))\n \t\t\t \"athlon-double,athlon-fpsched,athlon-fmul\")\n+(define_insn_reservation \"athlon_sselog_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"sselog,sselog1\"))\n+\t\t\t \"athlon-direct,athlon-fpsched,(athlon-fadd|athlon-fmul)\")\n+\n ;; ??? pcmp executes in addmul, probably not worthwhile to bother about that.\n (define_insn_reservation \"athlon_ssecmp_load\" 2\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n@@ -594,13 +725,13 @@\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fadd\")\n (define_insn_reservation \"athlon_ssecmp_load_k8\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"ssecmp\")\n \t\t\t\t   (and (eq_attr \"mode\" \"SF,DF,DI,TI\")\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_ssecmp\" 2\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"ssecmp\")\n \t\t\t\t   (eq_attr \"mode\" \"SF,DF,DI,TI\")))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fadd\")\n@@ -614,6 +745,11 @@\n \t\t\t      (and (eq_attr \"type\" \"ssecmp\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-double,athlon-fpload2k8,(athlon-fadd*2)\")\n+(define_insn_reservation \"athlon_ssecmpvector_load_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecmp\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_ssecmpvector\" 3\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (eq_attr \"type\" \"ssecmp\"))\n@@ -622,6 +758,10 @@\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"ssecmp\"))\n \t\t\t \"athlon-double,athlon-fpsched,(athlon-fadd*2)\")\n+(define_insn_reservation \"athlon_ssecmpvector_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"ssecmp\"))\n+\t\t\t \"athlon-direct,athlon-fpsched,athlon-fadd\")\n (define_insn_reservation \"athlon_ssecomi_load\" 4\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (and (eq_attr \"type\" \"ssecomi\")\n@@ -632,24 +772,34 @@\n \t\t\t      (and (eq_attr \"type\" \"ssecomi\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-vector,athlon-fploadk8,athlon-fadd\")\n+(define_insn_reservation \"athlon_ssecomi_load_amdfam10\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecomi\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_ssecomi\" 4\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"ssecmp\"))\n \t\t\t \"athlon-vector,athlon-fpsched,athlon-fadd\")\n+(define_insn_reservation \"athlon_ssecomi_amdfam10\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+;; It seems athlon_ssecomi has a bug in the attr_type, fixed for amdfam10\n+\t\t\t      (eq_attr \"type\" \"ssecomi\"))\n+\t\t\t \"athlon-direct,athlon-fpsched,athlon-fadd\")\n (define_insn_reservation \"athlon_sseadd_load\" 4\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (and (eq_attr \"type\" \"sseadd\")\n \t\t\t\t   (and (eq_attr \"mode\" \"SF,DF,DI\")\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fadd\")\n (define_insn_reservation \"athlon_sseadd_load_k8\" 6\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"sseadd\")\n \t\t\t\t   (and (eq_attr \"mode\" \"SF,DF,DI\")\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_sseadd\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"sseadd\")\n \t\t\t\t   (eq_attr \"mode\" \"SF,DF,DI\")))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fadd\")\n@@ -663,6 +813,11 @@\n \t\t\t      (and (eq_attr \"type\" \"sseadd\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-double,athlon-fpload2k8,(athlon-fadd*2)\")\n+(define_insn_reservation \"athlon_sseaddvector_load_amdfam10\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseadd\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8,athlon-fadd\")\n (define_insn_reservation \"athlon_sseaddvector\" 5\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (eq_attr \"type\" \"sseadd\"))\n@@ -671,6 +826,10 @@\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"sseadd\"))\n \t\t\t \"athlon-double,athlon-fpsched,(athlon-fadd*2)\")\n+(define_insn_reservation \"athlon_sseaddvector_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"sseadd\"))\n+\t\t\t \"athlon-direct,athlon-fpsched,athlon-fadd\")\n \n ;; Conversions behaves very irregularly and the scheduling is critical here.\n ;; Take each instruction separately.  Assume that the mode is always set to the\n@@ -684,12 +843,25 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"DF\")\n \t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fstore\")\n+(define_insn_reservation \"athlon_ssecvt_cvtss2sd_load_amdfam10\" 7\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"DF\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-double,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\n (define_insn_reservation \"athlon_ssecvt_cvtss2sd\" 2\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n \t\t\t\t   (and (eq_attr \"athlon_decode\" \"direct\")\n \t\t\t\t\t(eq_attr \"mode\" \"DF\"))))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fstore\")\n+(define_insn_reservation \"athlon_ssecvt_cvtss2sd_amdfam10\" 7\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t\t(eq_attr \"mode\" \"DF\"))))\n+\t\t\t \"athlon-vector,athlon-fpsched,athlon-faddmul,(athlon-fstore*2)\")\n ;; cvtps2pd.  Model same way the other double decoded FP conversions.\n (define_insn_reservation \"athlon_ssecvt_cvtps2pd_load_k8\" 5\n \t\t\t (and (eq_attr \"cpu\" \"k8,athlon,generic64\")\n@@ -698,12 +870,25 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"V2DF,V4SF,TI\")\n \t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n \t\t\t \"athlon-double,athlon-fpload2k8,(athlon-fstore*2)\")\n+(define_insn_reservation \"athlon_ssecvt_cvtps2pd_load_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"direct\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"V2DF,V4SF,TI\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-direct,athlon-fploadk8,athlon-fstore\")\n (define_insn_reservation \"athlon_ssecvt_cvtps2pd_k8\" 3\n \t\t\t (and (eq_attr \"cpu\" \"k8,athlon,generic64\")\n \t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n \t\t\t\t   (and (eq_attr \"athlon_decode\" \"double\")\n \t\t\t\t\t(eq_attr \"mode\" \"V2DF,V4SF,TI\"))))\n \t\t\t \"athlon-double,athlon-fpsched,athlon-fstore,athlon-fstore\")\n+(define_insn_reservation \"athlon_ssecvt_cvtps2pd_amdfam10\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"direct\")\n+\t\t\t\t\t(eq_attr \"mode\" \"V2DF,V4SF,TI\"))))\n+\t\t\t \"athlon-direct,athlon-fpsched,athlon-fstore\")\n ;; cvtsi2sd mem,reg is directpath path  (cvtsi2sd reg,reg is doublepath)\n ;; cvtsi2sd has troughput 1 and is executed in store unit with latency of 6\n (define_insn_reservation \"athlon_sseicvt_cvtsi2sd_load\" 6\n@@ -713,6 +898,13 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n \t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fstore\")\n+(define_insn_reservation \"athlon_sseicvt_cvtsi2sd_load_amdfam10\" 9\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-double,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\n ;; cvtsi2ss mem, reg is doublepath\n (define_insn_reservation \"athlon_sseicvt_cvtsi2ss_load\" 9\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n@@ -728,6 +920,13 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n \t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n \t\t\t \"athlon-double,athlon-fploadk8,(athlon-fstore*2)\")\n+(define_insn_reservation \"athlon_sseicvt_cvtsi2ss_load_amdfam10\" 9\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-double,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\t\t\t \n ;; cvtsi2sd reg,reg is double decoded (vector on Athlon)\n (define_insn_reservation \"athlon_sseicvt_cvtsi2sd_k8\" 11\n \t\t\t (and (eq_attr \"cpu\" \"k8,athlon,generic64\")\n@@ -736,6 +935,13 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n \t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n \t\t\t \"athlon-double,athlon-fploadk8,athlon-fstore\")\n+(define_insn_reservation \"athlon_sseicvt_cvtsi2sd_amdfam10\" 14\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n+\t\t\t \"athlon-vector,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\n ;; cvtsi2ss reg, reg is doublepath\n (define_insn_reservation \"athlon_sseicvt_cvtsi2ss\" 14\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n@@ -744,6 +950,13 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n \t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n \t\t\t \"athlon-vector,athlon-fploadk8,(athlon-fvector*2)\")\n+(define_insn_reservation \"athlon_sseicvt_cvtsi2ss_amdfam10\" 14\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SF,DF\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n+\t\t\t \"athlon-vector,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\n ;; cvtsd2ss mem,reg is doublepath, troughput unknown, latency 9\n (define_insn_reservation \"athlon_ssecvt_cvtsd2ss_load_k8\" 9\n \t\t\t (and (eq_attr \"cpu\" \"k8,athlon,generic64\")\n@@ -752,6 +965,13 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SF\")\n \t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n \t\t\t \"athlon-double,athlon-fploadk8,(athlon-fstore*3)\")\n+(define_insn_reservation \"athlon_ssecvt_cvtsd2ss_load_amdfam10\" 9\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-double,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\n ;; cvtsd2ss reg,reg is vectorpath, troughput unknown, latency 12\n (define_insn_reservation \"athlon_ssecvt_cvtsd2ss\" 12\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n@@ -760,13 +980,27 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SF\")\n \t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n \t\t\t \"athlon-vector,athlon-fpsched,(athlon-fvector*3)\")\n+(define_insn_reservation \"athlon_ssecvt_cvtsd2ss_amdfam10\" 8\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"vector\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n+\t\t\t \"athlon-vector,athlon-fpsched,athlon-faddmul,(athlon-fstore*2)\")\n (define_insn_reservation \"athlon_ssecvt_cvtpd2ps_load_k8\" 8\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n \t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n \t\t\t\t   (and (eq_attr \"athlon_decode\" \"vector\")\n \t\t\t\t\t(and (eq_attr \"mode\" \"V4SF,V2DF,TI\")\n \t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n \t\t\t \"athlon-double,athlon-fpload2k8,(athlon-fstore*3)\")\n+(define_insn_reservation \"athlon_ssecvt_cvtpd2ps_load_amdfam10\" 9\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"V4SF,V2DF,TI\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-double,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\n ;; cvtpd2ps mem,reg is vectorpath, troughput unknown, latency 10\n ;; ??? Why it is fater than cvtsd2ss?\n (define_insn_reservation \"athlon_ssecvt_cvtpd2ps\" 8\n@@ -776,6 +1010,13 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"V4SF,V2DF,TI\")\n \t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n \t\t\t \"athlon-vector,athlon-fpsched,athlon-fvector*2\")\n+(define_insn_reservation \"athlon_ssecvt_cvtpd2ps_amdfam10\" 7\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssecvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"V4SF,V2DF,TI\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n+\t\t\t \"athlon-double,athlon-fpsched,(athlon-faddmul+athlon-fstore)\")\n ;; cvtsd2si mem,reg is doublepath, troughput 1, latency 9\n (define_insn_reservation \"athlon_secvt_cvtsX2si_load\" 9\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n@@ -784,6 +1025,13 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SI,DI\")\n \t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n \t\t\t \"athlon-vector,athlon-fploadk8,athlon-fvector\")\n+(define_insn_reservation \"athlon_secvt_cvtsX2si_load_amdfam10\" 10\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SI,DI\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-double,athlon-fploadk8,(athlon-fadd+athlon-fstore)\")\n ;; cvtsd2si reg,reg is doublepath, troughput 1, latency 9\n (define_insn_reservation \"athlon_ssecvt_cvtsX2si\" 9\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n@@ -799,6 +1047,29 @@\n \t\t\t\t\t(and (eq_attr \"mode\" \"SI,DI\")\n \t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n \t\t\t \"athlon-double,athlon-fpsched,athlon-fstore\")\n+(define_insn_reservation \"athlon_ssecvt_cvtsX2si_amdfam10\" 8\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"SI,DI\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n+\t\t\t \"athlon-double,athlon-fpsched,(athlon-fadd+athlon-fstore)\")\n+;; cvtpd2dq reg,mem is doublepath, troughput 1, latency 9 on amdfam10\n+(define_insn_reservation \"athlon_sseicvt_cvtpd2dq_load_amdfam10\" 9\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"TI\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"load\")))))\n+\t\t\t \"athlon-double,athlon-fploadk8,(athlon-faddmul+athlon-fstore)\")\n+;; cvtpd2dq reg,mem is doublepath, troughput 1, latency 7 on amdfam10\n+(define_insn_reservation \"athlon_sseicvt_cvtpd2dq_amdfam10\" 7\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"sseicvt\")\n+\t\t\t\t   (and (eq_attr \"amdfam10_decode\" \"double\")\n+\t\t\t\t\t(and (eq_attr \"mode\" \"TI\")\n+\t\t\t\t\t     (eq_attr \"memory\" \"none\")))))\n+\t\t\t \"athlon-double,athlon-fpsched,(athlon-faddmul+athlon-fstore)\")\n \n \n (define_insn_reservation \"athlon_ssemul_load\" 4\n@@ -808,13 +1079,13 @@\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fmul\")\n (define_insn_reservation \"athlon_ssemul_load_k8\" 6\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"ssemul\")\n \t\t\t\t   (and (eq_attr \"mode\" \"SF,DF\")\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fmul\")\n (define_insn_reservation \"athlon_ssemul\" 4\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"ssemul\")\n \t\t\t\t   (eq_attr \"mode\" \"SF,DF\")))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fmul\")\n@@ -828,6 +1099,11 @@\n \t\t\t      (and (eq_attr \"type\" \"ssemul\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-double,athlon-fpload2k8,(athlon-fmul*2)\")\n+(define_insn_reservation \"athlon_ssemulvector_load_amdfam10\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssemul\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8,athlon-fmul\")\n (define_insn_reservation \"athlon_ssemulvector\" 5\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (eq_attr \"type\" \"ssemul\"))\n@@ -836,6 +1112,10 @@\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"ssemul\"))\n \t\t\t \"athlon-double,athlon-fpsched,(athlon-fmul*2)\")\n+(define_insn_reservation \"athlon_ssemulvector_amdfam10\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"ssemul\"))\n+\t\t\t \"athlon-direct,athlon-fpsched,athlon-fmul\")\t\t\t \n ;; divsd timings.  divss is faster\n (define_insn_reservation \"athlon_ssediv_load\" 20\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n@@ -844,13 +1124,13 @@\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fpload,athlon-fmul*17\")\n (define_insn_reservation \"athlon_ssediv_load_k8\" 22\n-\t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"ssediv\")\n \t\t\t\t   (and (eq_attr \"mode\" \"SF,DF\")\n \t\t\t\t\t(eq_attr \"memory\" \"load\"))))\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fmul*17\")\n (define_insn_reservation \"athlon_ssediv\" 20\n-\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64\")\n+\t\t\t (and (eq_attr \"cpu\" \"athlon,k8,generic64,amdfam10\")\n \t\t\t      (and (eq_attr \"type\" \"ssediv\")\n \t\t\t\t   (eq_attr \"mode\" \"SF,DF\")))\n \t\t\t \"athlon-direct,athlon-fpsched,athlon-fmul*17\")\n@@ -864,6 +1144,11 @@\n \t\t\t      (and (eq_attr \"type\" \"ssediv\")\n \t\t\t\t   (eq_attr \"memory\" \"load\")))\n \t\t\t \"athlon-double,athlon-fpload2k8,athlon-fmul*34\")\n+(define_insn_reservation \"athlon_ssedivvector_load_amdfam10\" 22\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (and (eq_attr \"type\" \"ssediv\")\n+\t\t\t\t   (eq_attr \"memory\" \"load\")))\n+\t\t\t \"athlon-direct,athlon-fploadk8,athlon-fmul*17\")\t\t\t \n (define_insn_reservation \"athlon_ssedivvector\" 39\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (eq_attr \"type\" \"ssediv\"))\n@@ -872,3 +1157,12 @@\n \t\t\t (and (eq_attr \"cpu\" \"k8,generic64\")\n \t\t\t      (eq_attr \"type\" \"ssediv\"))\n \t\t\t \"athlon-double,athlon-fmul*34\")\n+(define_insn_reservation \"athlon_ssedivvector_amdfam10\" 20\n+\t\t\t (and (eq_attr \"cpu\" \"amdfam10\")\n+\t\t\t      (eq_attr \"type\" \"ssediv\"))\n+\t\t\t \"athlon-direct,athlon-fmul*17\")\n+(define_insn_reservation \"athlon_sseins_amdfam10\" 5\n+                         (and (eq_attr \"cpu\" \"amdfam10\")\n+                              (and (eq_attr \"type\" \"sseins\")\n+                                   (eq_attr \"mode\" \"TI\")))\n+                         \"athlon-vector,athlon-fpsched,athlon-faddmul\")"}, {"sha": "43a626236445aaf17380ecb0edb53ccaf47adefe", "filename": "gcc/config/i386/emmintrin.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Femmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Femmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Femmintrin.h?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -30,7 +30,11 @@\n #ifndef _EMMINTRIN_H_INCLUDED\n #define _EMMINTRIN_H_INCLUDED\n \n-#ifdef __SSE2__\n+#ifndef __SSE2__\n+# error \"SSE2 instruction set not enabled\"\n+#else\n+\n+/* We need definitions from the SSE header files*/\n #include <xmmintrin.h>\n \n /* SSE2 */"}, {"sha": "24ebc440407c1674d1754240472fca906e0086a0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 392, "deletions": 39, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -604,6 +604,80 @@ struct processor_costs k8_cost = {\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n };\n \n+struct processor_costs amdfam10_cost = {\n+  COSTS_N_INSNS (1),                    /* cost of an add instruction */\n+  COSTS_N_INSNS (2),                    /* cost of a lea instruction */\n+  COSTS_N_INSNS (1),                    /* variable shift costs */\n+  COSTS_N_INSNS (1),                    /* constant shift costs */\n+  {COSTS_N_INSNS (3),                   /* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),                   /*                               HI */\n+   COSTS_N_INSNS (3),                   /*                               SI */\n+   COSTS_N_INSNS (4),                   /*                               DI */\n+   COSTS_N_INSNS (5)},                  /*                               other */\n+  0,                                    /* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (19),                  /* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (35),                  /*                          HI */\n+   COSTS_N_INSNS (51),                  /*                          SI */\n+   COSTS_N_INSNS (83),                  /*                          DI */\n+   COSTS_N_INSNS (83)},                 /*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  9,\t\t\t\t\t/* MOVE_RATIO */\n+  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {4, 4, 12},\t\t\t\t/* cost of loading fp registers\n+\t\t   \t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+ \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {3, 3},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {4, 4, 3},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  \t\t\t\t\t/* On K8\n+  \t\t\t\t\t    MOVD reg64, xmmreg \tDouble\tFSTORE 4\n+\t\t\t\t\t    MOVD reg32, xmmreg \tDouble\tFSTORE 4\n+\t\t\t\t\t   On AMDFAM10\n+\t\t\t\t\t    MOVD reg64, xmmreg \tDouble\tFADD 3\n+                                                                1/1  1/1\n+\t\t\t\t\t    MOVD reg32, xmmreg \tDouble\tFADD 3\n+                                                                1/1  1/1 */\n+  64,\t\t\t\t\t/* size of prefetch block */\n+  /* New AMD processors never drop prefetches; if they cannot be performed\n+     immediately, they are queued.  We set number of simultaneous prefetches\n+     to a large constant to reflect this (it probably is not a good idea not\n+     to limit number of prefetches at all, as their execution also takes some\n+     time).  */\n+  100,\t\t\t\t\t/* number of parallel prefetches */\n+  5,\t\t\t\t\t/* Branch cost */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (19),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n+\n+  /* AMDFAM10 has optimized REP instruction for medium sized blocks, but for\n+     very small blocks it is better to use loop. For large blocks, libcall can\n+     do nontemporary accesses and beat inline considerably.  */\n+  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{8, loop}, {24, unrolled_loop},\n+\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n+};\n+\n static const\n struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -917,34 +991,44 @@ const struct processor_costs *ix86_cost = &pentium_cost;\n #define m_PENT4  (1<<PROCESSOR_PENTIUM4)\n #define m_K8  (1<<PROCESSOR_K8)\n #define m_ATHLON_K8  (m_K8 | m_ATHLON)\n+#define m_AMDFAM10  (1<<PROCESSOR_AMDFAM10)\n #define m_NOCONA  (1<<PROCESSOR_NOCONA)\n #define m_CORE2  (1<<PROCESSOR_CORE2)\n #define m_GENERIC32 (1<<PROCESSOR_GENERIC32)\n #define m_GENERIC64 (1<<PROCESSOR_GENERIC64)\n #define m_GENERIC (m_GENERIC32 | m_GENERIC64)\n+#define m_ATHLON_K8_AMDFAM10  (m_K8 | m_ATHLON | m_AMDFAM10)\n \n /* Generic instruction choice should be common subset of supported CPUs\n    (PPro/PENT4/NOCONA/CORE2/Athlon/K8).  */\n \n /* Leave is not affecting Nocona SPEC2000 results negatively, so enabling for\n    Generic64 seems like good code size tradeoff.  We can't enable it for 32bit\n    generic because it is not working well with PPro base chips.  */\n-const int x86_use_leave = m_386 | m_K6_GEODE | m_ATHLON_K8 | m_CORE2 | m_GENERIC64;\n-const int x86_push_memory = m_386 | m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_use_leave = m_386 | m_K6_GEODE | m_ATHLON_K8_AMDFAM10 | m_CORE2\n+                          | m_GENERIC64;\n+const int x86_push_memory = m_386 | m_K6_GEODE | m_ATHLON_K8_AMDFAM10 | m_PENT4\n+                            | m_NOCONA | m_CORE2 | m_GENERIC;\n const int x86_zero_extend_with_and = m_486 | m_PENT;\n-const int x86_movx = m_ATHLON_K8 | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC | m_GEODE /* m_386 | m_K6 */;\n+/* Enable to zero extend integer registers to avoid partial dependencies */\n+const int x86_movx = m_ATHLON_K8_AMDFAM10 | m_PPRO | m_PENT4 | m_NOCONA\n+                     | m_CORE2 | m_GENERIC | m_GEODE /* m_386 | m_K6 */;\n const int x86_double_with_add = ~m_386;\n const int x86_use_bit_test = m_386;\n-const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO | m_ATHLON_K8 | m_K6 | m_CORE2 | m_GENERIC;\n-const int x86_cmove = m_PPRO | m_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA;\n-const int x86_3dnow_a = m_ATHLON_K8;\n-const int x86_deep_branch = m_PPRO | m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO | m_ATHLON_K8_AMDFAM10\n+                              | m_K6 | m_CORE2 | m_GENERIC;\n+const int x86_cmove = m_PPRO | m_GEODE | m_ATHLON_K8_AMDFAM10 | m_PENT4\n+                      | m_NOCONA;\n+const int x86_3dnow_a = m_ATHLON_K8_AMDFAM10;\n+const int x86_deep_branch = m_PPRO | m_K6_GEODE | m_ATHLON_K8_AMDFAM10\n+                            | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n /* Branch hints were put in P4 based on simulation result. But\n    after P4 was made, no performance benefit was observed with\n    branch hints. It also increases the code size. As the result,\n    icc never generates branch hints.  */\n const int x86_branch_hints = 0;\n-const int x86_use_sahf = m_PPRO | m_K6_GEODE | m_PENT4 | m_NOCONA | m_GENERIC32; /*m_GENERIC | m_ATHLON_K8 ? */\n+const int x86_use_sahf = m_PPRO | m_K6_GEODE | m_PENT4 | m_NOCONA | m_GENERIC32;\n+                         /*m_GENERIC | m_ATHLON_K8 ? */\n /* We probably ought to watch for partial register stalls on Generic32\n    compilation setting as well.  However in current implementation the\n    partial register stalls are not eliminated very well - they can\n@@ -956,13 +1040,16 @@ const int x86_use_sahf = m_PPRO | m_K6_GEODE | m_PENT4 | m_NOCONA | m_GENERIC32;\n const int x86_partial_reg_stall = m_PPRO;\n const int x86_partial_flag_reg_stall =  m_CORE2 | m_GENERIC;\n const int x86_use_himode_fiop = m_386 | m_486 | m_K6_GEODE;\n-const int x86_use_simode_fiop = ~(m_PPRO | m_ATHLON_K8 | m_PENT | m_CORE2 | m_GENERIC);\n+const int x86_use_simode_fiop = ~(m_PPRO | m_ATHLON_K8_AMDFAM10 | m_PENT\n+                                  | m_CORE2 | m_GENERIC);\n const int x86_use_mov0 = m_K6;\n const int x86_use_cltd = ~(m_PENT | m_K6 | m_CORE2 | m_GENERIC);\n const int x86_read_modify_write = ~m_PENT;\n const int x86_read_modify = ~(m_PENT | m_PPRO);\n const int x86_split_long_moves = m_PPRO;\n-const int x86_promote_QImode = m_K6_GEODE | m_PENT | m_386 | m_486 | m_ATHLON_K8 | m_CORE2 | m_GENERIC; /* m_PENT4 ? */\n+const int x86_promote_QImode = m_K6_GEODE | m_PENT | m_386 | m_486\n+                               | m_ATHLON_K8_AMDFAM10 | m_CORE2 | m_GENERIC;\n+                               /* m_PENT4 ? */\n const int x86_fast_prefix = ~(m_PENT | m_486 | m_386);\n const int x86_single_stringop = m_386 | m_PENT4 | m_NOCONA;\n const int x86_qimode_math = ~(0);\n@@ -972,18 +1059,37 @@ const int x86_promote_qi_regs = 0;\n    if our scheme for avoiding partial stalls was more effective.  */\n const int x86_himode_math = ~(m_PPRO);\n const int x86_promote_hi_regs = m_PPRO;\n-const int x86_sub_esp_4 = m_ATHLON_K8 | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n-const int x86_sub_esp_8 = m_ATHLON_K8 | m_PPRO | m_386 | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n-const int x86_add_esp_4 = m_ATHLON_K8 | m_K6_GEODE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n-const int x86_add_esp_8 = m_ATHLON_K8 | m_PPRO | m_K6_GEODE | m_386 | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n-const int x86_integer_DFmode_moves = ~(m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC | m_GEODE);\n-const int x86_partial_reg_dependency = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n-const int x86_memory_mismatch_stall = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n-const int x86_accumulate_outgoing_args = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;\n+/* Enable if add/sub rsp is preferred over 1 or 2 push/pop */\n+const int x86_sub_esp_4 = m_ATHLON_K8_AMDFAM10 | m_PPRO | m_PENT4 | m_NOCONA\n+                          | m_CORE2 | m_GENERIC;\n+const int x86_sub_esp_8 = m_ATHLON_K8_AMDFAM10 | m_PPRO | m_386 | m_486\n+                          | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_add_esp_4 = m_ATHLON_K8_AMDFAM10 | m_K6_GEODE | m_PENT4 | m_NOCONA\n+                          | m_CORE2 | m_GENERIC;\n+const int x86_add_esp_8 = m_ATHLON_K8_AMDFAM10 | m_PPRO | m_K6_GEODE | m_386\n+                          | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+/* Enable if integer moves are preferred for DFmode copies */\n+const int x86_integer_DFmode_moves = ~(m_ATHLON_K8_AMDFAM10 | m_PENT4 | m_NOCONA\n+                                       | m_PPRO | m_CORE2 | m_GENERIC | m_GEODE);\n+const int x86_partial_reg_dependency = m_ATHLON_K8_AMDFAM10 | m_PENT4 | m_NOCONA\n+                                       | m_CORE2 | m_GENERIC;\n+const int x86_memory_mismatch_stall = m_ATHLON_K8_AMDFAM10 | m_PENT4 | m_NOCONA \n+                                      | m_CORE2 | m_GENERIC;\n+/* If ACCUMULATE_OUTGOING_ARGS is enabled, the maximum amount of space required\n+   for outgoing arguments will be computed and placed into the variable\n+   `current_function_outgoing_args_size'. No space will be pushed onto the stack\n+   for each call; instead, the function prologue should increase the stack frame\n+   size by this amount. Setting both PUSH_ARGS and ACCUMULATE_OUTGOING_ARGS is\n+   not proper. */\n+const int x86_accumulate_outgoing_args = m_ATHLON_K8_AMDFAM10 | m_PENT4\n+                                         | m_NOCONA | m_PPRO | m_CORE2\n+                                         | m_GENERIC;\n const int x86_prologue_using_move = m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC;\n const int x86_epilogue_using_move = m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC;\n const int x86_shift1 = ~m_486;\n-const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO\n+                                           | m_ATHLON_K8_AMDFAM10 | m_PENT4 \n+                                           | m_NOCONA | m_CORE2 | m_GENERIC;\n /* In Generic model we have an conflict here in between PPro/Pentium4 based chips\n    that thread 128bit SSE registers as single units versus K8 based chips that\n    divide SSE registers to two 64bit halves.\n@@ -993,27 +1099,81 @@ const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO | m_ATHLON_K8 | m_PEN\n    this option on P4 brings over 20% SPECfp regression, while enabling it on\n    K8 brings roughly 2.4% regression that can be partly masked by careful scheduling\n    of moves.  */\n-const int x86_sse_partial_reg_dependency = m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;\n+const int x86_sse_partial_reg_dependency = m_PENT4 | m_NOCONA | m_PPRO | m_CORE2\n+                                           | m_GENERIC | m_AMDFAM10;\n /* Set for machines where the type and dependencies are resolved on SSE\n    register parts instead of whole registers, so we may maintain just\n    lower part of scalar values in proper format leaving the upper part\n    undefined.  */\n const int x86_sse_split_regs = m_ATHLON_K8;\n-const int x86_sse_typeless_stores = m_ATHLON_K8;\n+/* Code generation for scalar reg-reg moves of single and double precision data:\n+     if (x86_sse_partial_reg_dependency == true | x86_sse_split_regs == true)\n+       movaps reg, reg\n+     else\n+       movss reg, reg\n+     if (x86_sse_partial_reg_dependency == true)\n+       movapd reg, reg\n+     else\n+       movsd reg, reg\n+\n+   Code generation for scalar loads of double precision data:\n+     if (x86_sse_split_regs == true)\n+       movlpd mem, reg      (gas syntax)\n+     else\n+       movsd mem, reg\n+ \n+   Code generation for unaligned packed loads of single precision data\n+   (x86_sse_unaligned_move_optimal overrides x86_sse_partial_reg_dependency):\n+     if (x86_sse_unaligned_move_optimal)\n+       movups mem, reg\n+\n+     if (x86_sse_partial_reg_dependency == true)\n+       {\n+         xorps  reg, reg\n+         movlps mem, reg\n+         movhps mem+8, reg\n+       }\n+     else\n+       {\n+         movlps mem, reg\n+         movhps mem+8, reg\n+       }\n+\n+   Code generation for unaligned packed loads of double precision data\n+   (x86_sse_unaligned_move_optimal overrides x86_sse_split_regs):\n+     if (x86_sse_unaligned_move_optimal)\n+       movupd mem, reg\n+\n+     if (x86_sse_split_regs == true)\n+       {\n+         movlpd mem, reg\n+         movhpd mem+8, reg\n+       }\n+     else\n+       {\n+         movsd  mem, reg\n+         movhpd mem+8, reg\n+       }\n+ */\n+const int x86_sse_unaligned_move_optimal = m_AMDFAM10;\n+const int x86_sse_typeless_stores = m_ATHLON_K8_AMDFAM10;\n const int x86_sse_load0_by_pxor = m_PPRO | m_PENT4 | m_NOCONA;\n-const int x86_use_ffreep = m_ATHLON_K8;\n+const int x86_use_ffreep = m_ATHLON_K8_AMDFAM10;\n const int x86_use_incdec = ~(m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC);\n \n /* ??? Allowing interunit moves makes it all too easy for the compiler to put\n    integer data in xmm registers.  Which results in pretty abysmal code.  */\n const int x86_inter_unit_moves = 0 /* ~(m_ATHLON_K8) */;\n \n-const int x86_ext_80387_constants = m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;\n+const int x86_ext_80387_constants = m_K6_GEODE | m_ATHLON_K8 | m_PENT4\n+                                    | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;\n /* Some CPU cores are not able to predict more than 4 branch instructions in\n    the 16 byte window.  */\n-const int x86_four_jump_limit = m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n-const int x86_schedule = m_PPRO | m_ATHLON_K8 | m_K6_GEODE | m_PENT | m_CORE2 | m_GENERIC;\n-const int x86_use_bt = m_ATHLON_K8;\n+const int x86_four_jump_limit = m_PPRO | m_ATHLON_K8_AMDFAM10 | m_PENT4\n+                                | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_schedule = m_PPRO | m_ATHLON_K8_AMDFAM10 | m_K6_GEODE | m_PENT\n+                         | m_CORE2 | m_GENERIC;\n+const int x86_use_bt = m_ATHLON_K8_AMDFAM10;\n /* Compare and exchange was added for 80486.  */\n const int x86_cmpxchg = ~m_386;\n /* Compare and exchange 8 bytes was added for pentium.  */\n@@ -1022,7 +1182,7 @@ const int x86_cmpxchg8b = ~(m_386 | m_486);\n const int x86_xadd = ~m_386;\n /* Byteswap was added for 80486.  */\n const int x86_bswap = ~m_386;\n-const int x86_pad_returns = m_ATHLON_K8 | m_CORE2 | m_GENERIC;\n+const int x86_pad_returns = m_ATHLON_K8_AMDFAM10 | m_CORE2 | m_GENERIC;\n \n static enum stringop_alg stringop_alg = no_stringop;\n \n@@ -1600,16 +1760,24 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n     case OPT_msse:\n       if (!value)\n \t{\n-\t  target_flags &= ~(MASK_SSE2 | MASK_SSE3);\n-\t  target_flags_explicit |= MASK_SSE2 | MASK_SSE3;\n+\t  target_flags &= ~(MASK_SSE2 | MASK_SSE3 | MASK_SSE4A);\n+\t  target_flags_explicit |= MASK_SSE2 | MASK_SSE3 | MASK_SSE4A;\n \t}\n       return true;\n \n     case OPT_msse2:\n       if (!value)\n \t{\n-\t  target_flags &= ~MASK_SSE3;\n-\t  target_flags_explicit |= MASK_SSE3;\n+\t  target_flags &= ~(MASK_SSE3 | MASK_SSE4A);\n+\t  target_flags_explicit |= MASK_SSE3 | MASK_SSE4A;\n+\t}\n+      return true;\n+\n+    case OPT_msse3:\n+      if (!value)\n+\t{\n+\t  target_flags &= ~MASK_SSE4A;\n+\t  target_flags_explicit |= MASK_SSE4A;\n \t}\n       return true;\n \n@@ -1661,7 +1829,8 @@ override_options (void)\n       {&nocona_cost, 0, 0, 0, 0, 0, 0, 0},\n       {&core2_cost, 0, 0, 16, 7, 16, 7, 16},\n       {&generic32_cost, 0, 0, 16, 7, 16, 7, 16},\n-      {&generic64_cost, 0, 0, 16, 7, 16, 7, 16}\n+      {&generic64_cost, 0, 0, 16, 7, 16, 7, 16},\n+      {&amdfam10_cost, 0, 0, 32, 7, 32, 7, 32}\n     };\n \n   static const char * const cpu_names[] = TARGET_CPU_DEFAULT_NAMES;\n@@ -1680,7 +1849,10 @@ override_options (void)\n \t  PTA_3DNOW_A = 64,\n \t  PTA_64BIT = 128,\n \t  PTA_SSSE3 = 256,\n-\t  PTA_CX16 = 512\n+\t  PTA_CX16 = 512,\n+\t  PTA_POPCNT = 1024,\n+\t  PTA_ABM = 2048,\n+ \t  PTA_SSE4A = 4096\n \t} flags;\n     }\n   const processor_alias_table[] =\n@@ -1736,6 +1908,10 @@ override_options (void)\n \t\t\t\t      | PTA_3DNOW_A | PTA_SSE | PTA_SSE2},\n       {\"athlon-fx\", PROCESSOR_K8, PTA_MMX | PTA_PREFETCH_SSE | PTA_3DNOW | PTA_64BIT\n \t\t\t\t      | PTA_3DNOW_A | PTA_SSE | PTA_SSE2},\n+      {\"amdfam10\", PROCESSOR_AMDFAM10, PTA_MMX | PTA_PREFETCH_SSE | PTA_3DNOW\n+                                       | PTA_64BIT | PTA_3DNOW_A | PTA_SSE\n+                                       | PTA_SSE2 | PTA_SSE3 | PTA_POPCNT\n+                                       | PTA_ABM | PTA_SSE4A | PTA_CX16},\n       {\"generic32\", PROCESSOR_GENERIC32, 0 /* flags are only used for -march switch.  */ },\n       {\"generic64\", PROCESSOR_GENERIC64, PTA_64BIT /* flags are only used for -march switch.  */ },\n     };\n@@ -1919,6 +2095,15 @@ override_options (void)\n \t  x86_prefetch_sse = true;\n \tif (processor_alias_table[i].flags & PTA_CX16)\n \t  x86_cmpxchg16b = true;\n+\tif (processor_alias_table[i].flags & PTA_POPCNT\n+\t    && !(target_flags_explicit & MASK_POPCNT))\n+\t  target_flags |= MASK_POPCNT;\n+\tif (processor_alias_table[i].flags & PTA_ABM\n+\t    && !(target_flags_explicit & MASK_ABM))\n+\t  target_flags |= MASK_ABM;\n+\tif (processor_alias_table[i].flags & PTA_SSE4A\n+\t    && !(target_flags_explicit & MASK_SSE4A))\n+\t  target_flags |= MASK_SSE4A;\n \tif (TARGET_64BIT && !(processor_alias_table[i].flags & PTA_64BIT))\n \t  error (\"CPU you selected does not support x86-64 \"\n \t\t \"instruction set\");\n@@ -2097,6 +2282,10 @@ override_options (void)\n   if (TARGET_SSSE3)\n     target_flags |= MASK_SSE3;\n \n+  /* Turn on SSE3 builtins for -msse4a.  */\n+  if (TARGET_SSE4A)\n+    target_flags |= MASK_SSE3;\n+\n   /* Turn on SSE2 builtins for -msse3.  */\n   if (TARGET_SSE3)\n     target_flags |= MASK_SSE2;\n@@ -2116,6 +2305,10 @@ override_options (void)\n   if (TARGET_3DNOW)\n     target_flags |= MASK_MMX;\n \n+  /* Turn on POPCNT builtins for -mabm.  */\n+  if (TARGET_ABM)\n+    target_flags |= MASK_POPCNT;\n+\n   if (TARGET_64BIT)\n     {\n       if (TARGET_ALIGN_DOUBLE)\n@@ -9308,8 +9501,16 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t}\n \n       if (TARGET_SSE2 && mode == V2DFmode)\n-\t{\n-\t  rtx zero;\n+        {\n+          rtx zero;\n+\n+          if (TARGET_SSE_UNALIGNED_MOVE_OPTIMAL)\n+            {\n+              op0 = gen_lowpart (V2DFmode, op0);\n+              op1 = gen_lowpart (V2DFmode, op1);\n+              emit_insn (gen_sse2_movupd (op0, op1));\n+              return;\n+            }\n \n \t  /* When SSE registers are split into halves, we can avoid\n \t     writing to the top half twice.  */\n@@ -9337,7 +9538,15 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  emit_insn (gen_sse2_loadhpd (op0, op0, m));\n \t}\n       else\n-\t{\n+        {\n+          if (TARGET_SSE_UNALIGNED_MOVE_OPTIMAL)\n+            {\n+              op0 = gen_lowpart (V4SFmode, op0);\n+              op1 = gen_lowpart (V4SFmode, op1);\n+              emit_insn (gen_sse_movups (op0, op1));\n+              return;\n+            }\n+\n \t  if (TARGET_SSE_PARTIAL_REG_DEPENDENCY)\n \t    emit_move_insn (op0, CONST0_RTX (mode));\n \t  else\n@@ -14699,6 +14908,7 @@ ix86_issue_rate (void)\n     case PROCESSOR_PENTIUM4:\n     case PROCESSOR_ATHLON:\n     case PROCESSOR_K8:\n+    case PROCESSOR_AMDFAM10:\n     case PROCESSOR_NOCONA:\n     case PROCESSOR_GENERIC32:\n     case PROCESSOR_GENERIC64:\n@@ -14897,6 +15107,7 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n     case PROCESSOR_ATHLON:\n     case PROCESSOR_K8:\n+    case PROCESSOR_AMDFAM10:\n     case PROCESSOR_GENERIC32:\n     case PROCESSOR_GENERIC64:\n       memory = get_attr_memory (insn);\n@@ -15609,6 +15820,14 @@ enum ix86_builtins\n   IX86_BUILTIN_PABSW128,\n   IX86_BUILTIN_PABSD128,\n \n+  /* AMDFAM10 - SSE4A New Instructions.  */\n+  IX86_BUILTIN_MOVNTSD,\n+  IX86_BUILTIN_MOVNTSS,\n+  IX86_BUILTIN_EXTRQI,\n+  IX86_BUILTIN_EXTRQ,\n+  IX86_BUILTIN_INSERTQI,\n+  IX86_BUILTIN_INSERTQ,\n+\n   IX86_BUILTIN_VEC_INIT_V2SI,\n   IX86_BUILTIN_VEC_INIT_V4HI,\n   IX86_BUILTIN_VEC_INIT_V8QI,\n@@ -16366,6 +16585,18 @@ ix86_init_mmx_sse_builtins (void)\n     = build_function_type_list (void_type_node,\n \t\t\t        pchar_type_node, V16QI_type_node, NULL_TREE);\n \n+  tree v2di_ftype_v2di_unsigned_unsigned\n+    = build_function_type_list (V2DI_type_node, V2DI_type_node,\n+                                unsigned_type_node, unsigned_type_node,\n+                                NULL_TREE);\n+  tree v2di_ftype_v2di_v2di_unsigned_unsigned\n+    = build_function_type_list (V2DI_type_node, V2DI_type_node, V2DI_type_node,\n+                                unsigned_type_node, unsigned_type_node,\n+                                NULL_TREE);\n+  tree v2di_ftype_v2di_v16qi\n+    = build_function_type_list (V2DI_type_node, V2DI_type_node, V16QI_type_node,\n+                                NULL_TREE);\n+\n   tree float80_type;\n   tree float128_type;\n   tree ftype;\n@@ -16702,6 +16933,20 @@ ix86_init_mmx_sse_builtins (void)\n   def_builtin (MASK_SSSE3, \"__builtin_ia32_palignr\", di_ftype_di_di_int,\n \t       IX86_BUILTIN_PALIGNR);\n \n+  /* AMDFAM10 SSE4A New built-ins  */\n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_movntsd\", \n+               void_ftype_pdouble_v2df, IX86_BUILTIN_MOVNTSD);\n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_movntss\", \n+               void_ftype_pfloat_v4sf, IX86_BUILTIN_MOVNTSS);\n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_extrqi\", \n+               v2di_ftype_v2di_unsigned_unsigned, IX86_BUILTIN_EXTRQI);\n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_extrq\",\n+               v2di_ftype_v2di_v16qi,  IX86_BUILTIN_EXTRQ);\n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_insertqi\",\n+               v2di_ftype_v2di_v2di_unsigned_unsigned, IX86_BUILTIN_INSERTQI);\n+  def_builtin (MASK_SSE4A, \"__builtin_ia32_insertq\",\n+               v2di_ftype_v2di_v2di, IX86_BUILTIN_INSERTQ);\n+\n   /* Access to the vec_init patterns.  */\n   ftype = build_function_type_list (V2SI_type_node, integer_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n@@ -17190,9 +17435,9 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   enum insn_code icode;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg0, arg1, arg2;\n-  rtx op0, op1, op2, pat;\n-  enum machine_mode tmode, mode0, mode1, mode2, mode3;\n+  tree arg0, arg1, arg2, arg3;\n+  rtx op0, op1, op2, op3, pat;\n+  enum machine_mode tmode, mode0, mode1, mode2, mode3, mode4;\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n \n   switch (fcode)\n@@ -17610,6 +17855,114 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       emit_insn (pat);\n       return target;\n \n+    case IX86_BUILTIN_MOVNTSD:\n+      return ix86_expand_store_builtin (CODE_FOR_sse4a_vmmovntv2df, arglist);\n+\n+    case IX86_BUILTIN_MOVNTSS:\n+      return ix86_expand_store_builtin (CODE_FOR_sse4a_vmmovntv4sf, arglist);\n+\n+    case IX86_BUILTIN_INSERTQ:\n+    case IX86_BUILTIN_EXTRQ:\n+      icode = (fcode == IX86_BUILTIN_EXTRQ\n+               ? CODE_FOR_sse4a_extrq\n+               : CODE_FOR_sse4a_insertq);\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode1 = insn_data[icode].operand[1].mode;\n+      mode2 = insn_data[icode].operand[2].mode;\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode1))\n+        op0 = copy_to_mode_reg (mode1, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode2))\n+        op1 = copy_to_mode_reg (mode2, op1);\n+      if (optimize || target == 0\n+          || GET_MODE (target) != tmode\n+          || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+        target = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1);\n+      if (! pat)\n+        return NULL_RTX;\n+      emit_insn (pat);\n+      return target;\n+\n+    case IX86_BUILTIN_EXTRQI:\n+      icode = CODE_FOR_sse4a_extrqi;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+      op2 = expand_normal (arg2);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode1 = insn_data[icode].operand[1].mode;\n+      mode2 = insn_data[icode].operand[2].mode;\n+      mode3 = insn_data[icode].operand[3].mode;\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode1))\n+        op0 = copy_to_mode_reg (mode1, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode2))\n+        {\n+          error (\"index mask must be an immediate\");\n+          return gen_reg_rtx (tmode);\n+        }\n+      if (! (*insn_data[icode].operand[3].predicate) (op2, mode3))\n+        {\n+          error (\"length mask must be an immediate\");\n+          return gen_reg_rtx (tmode);\n+        }\n+      if (optimize || target == 0\n+          || GET_MODE (target) != tmode\n+          || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+        target = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2);\n+      if (! pat)\n+        return NULL_RTX;\n+      emit_insn (pat);\n+      return target;\n+\n+    case IX86_BUILTIN_INSERTQI:\n+      icode = CODE_FOR_sse4a_insertqi;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+      op2 = expand_normal (arg2);\n+      op3 = expand_normal (arg3);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode1 = insn_data[icode].operand[1].mode;\n+      mode2 = insn_data[icode].operand[2].mode;\n+      mode3 = insn_data[icode].operand[3].mode;\n+      mode4 = insn_data[icode].operand[4].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode1))\n+        op0 = copy_to_mode_reg (mode1, op0);\n+\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode2))\n+        op1 = copy_to_mode_reg (mode2, op1);\n+\n+      if (! (*insn_data[icode].operand[3].predicate) (op2, mode3))\n+        {\n+          error (\"index mask must be an immediate\");\n+          return gen_reg_rtx (tmode);\n+        }\n+      if (! (*insn_data[icode].operand[4].predicate) (op3, mode4))\n+        {\n+          error (\"length mask must be an immediate\");\n+          return gen_reg_rtx (tmode);\n+        }\n+      if (optimize || target == 0\n+          || GET_MODE (target) != tmode\n+          || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+        target = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2, op3);\n+      if (! pat)\n+        return NULL_RTX;\n+      emit_insn (pat);\n+      return target;\n+\n     case IX86_BUILTIN_VEC_INIT_V2SI:\n     case IX86_BUILTIN_VEC_INIT_V4HI:\n     case IX86_BUILTIN_VEC_INIT_V8QI:"}, {"sha": "c2ebe93f5e9e300a02bdd5b156b57b1cf0c395f7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -177,6 +177,7 @@ extern const struct processor_costs *ix86_cost;\n #define TARGET_GENERIC32 (ix86_tune == PROCESSOR_GENERIC32)\n #define TARGET_GENERIC64 (ix86_tune == PROCESSOR_GENERIC64)\n #define TARGET_GENERIC (TARGET_GENERIC32 || TARGET_GENERIC64)\n+#define TARGET_AMDFAM10 (ix86_tune == PROCESSOR_AMDFAM10)\n \n #define TUNEMASK (1 << ix86_tune)\n extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;\n@@ -195,6 +196,7 @@ extern const int x86_accumulate_outgoing_args, x86_prologue_using_move;\n extern const int x86_epilogue_using_move, x86_decompose_lea;\n extern const int x86_arch_always_fancy_math_387, x86_shift1;\n extern const int x86_sse_partial_reg_dependency, x86_sse_split_regs;\n+extern const int x86_sse_unaligned_move_optimal;\n extern const int x86_sse_typeless_stores, x86_sse_load0_by_pxor;\n extern const int x86_use_ffreep;\n extern const int x86_inter_unit_moves, x86_schedule;\n@@ -244,6 +246,8 @@ extern int x86_prefetch_sse, x86_cmpxchg16b;\n #define TARGET_PARTIAL_REG_DEPENDENCY (x86_partial_reg_dependency & TUNEMASK)\n #define TARGET_SSE_PARTIAL_REG_DEPENDENCY \\\n \t\t\t\t      (x86_sse_partial_reg_dependency & TUNEMASK)\n+#define TARGET_SSE_UNALIGNED_MOVE_OPTIMAL \\\n+\t\t\t\t      (x86_sse_unaligned_move_optimal & TUNEMASK)\n #define TARGET_SSE_SPLIT_REGS (x86_sse_split_regs & TUNEMASK)\n #define TARGET_SSE_TYPELESS_STORES (x86_sse_typeless_stores & TUNEMASK)\n #define TARGET_SSE_LOAD0_BY_PXOR (x86_sse_load0_by_pxor & TUNEMASK)\n@@ -436,6 +440,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \t}\t\t\t\t\t\t\t\\\n       else if (TARGET_K8)\t\t\t\t\t\\\n \tbuiltin_define (\"__tune_k8__\");\t\t\t\t\\\n+      else if (TARGET_AMDFAM10)\t\t\t\t\t\\\n+\tbuiltin_define (\"__tune_amdfam10__\");\t\t\t\\\n       else if (TARGET_PENTIUM4)\t\t\t\t\t\\\n \tbuiltin_define (\"__tune_pentium4__\");\t\t\t\\\n       else if (TARGET_NOCONA)\t\t\t\t\t\\\n@@ -457,6 +463,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \tbuiltin_define (\"__SSE3__\");\t\t\t\t\\\n       if (TARGET_SSSE3)\t\t\t\t\t\t\\\n \tbuiltin_define (\"__SSSE3__\");\t\t\t\t\\\n+      if (TARGET_SSE4A)\t\t\t\t\t\\\n+ \tbuiltin_define (\"__SSE4A__\");\t\t                \\\n       if (TARGET_SSE_MATH && TARGET_SSE)\t\t\t\\\n \tbuiltin_define (\"__SSE_MATH__\");\t\t\t\\\n       if (TARGET_SSE_MATH && TARGET_SSE2)\t\t\t\\\n@@ -512,6 +520,11 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \t  builtin_define (\"__k8\");\t\t\t\t\\\n \t  builtin_define (\"__k8__\");\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n+      else if (ix86_arch == PROCESSOR_AMDFAM10)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  builtin_define (\"__amdfam10\");\t\t\t\\\n+\t  builtin_define (\"__amdfam10__\");\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n       else if (ix86_arch == PROCESSOR_PENTIUM4)\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n \t  builtin_define (\"__pentium4\");\t\t\t\\\n@@ -550,13 +563,14 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_CPU_DEFAULT_nocona 17\n #define TARGET_CPU_DEFAULT_core2 18\n #define TARGET_CPU_DEFAULT_generic 19\n+#define TARGET_CPU_DEFAULT_amdfam10 20\n \n #define TARGET_CPU_DEFAULT_NAMES {\"i386\", \"i486\", \"pentium\", \"pentium-mmx\",\\\n \t\t\t\t  \"pentiumpro\", \"pentium2\", \"pentium3\", \\\n                                   \"pentium4\", \"geode\", \"k6\", \"k6-2\", \"k6-3\", \\\n \t\t\t\t  \"athlon\", \"athlon-4\", \"k8\", \\\n \t\t\t\t  \"pentium-m\", \"prescott\", \"nocona\", \\\n-\t\t\t\t  \"core2\", \"generic\"}\n+\t\t\t\t  \"core2\", \"generic\", \"amdfam10\"}\n \n #ifndef CC1_SPEC\n #define CC1_SPEC \"%(cc1_cpu) \"\n@@ -2105,6 +2119,7 @@ enum processor_type\n   PROCESSOR_CORE2,\n   PROCESSOR_GENERIC32,\n   PROCESSOR_GENERIC64,\n+  PROCESSOR_AMDFAM10,\n   PROCESSOR_max\n };\n "}, {"sha": "92fcde91025b17489d611f95bac0bee5d222b5b6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 292, "deletions": 39, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -154,6 +154,12 @@\n    (UNSPEC_PSHUFB\t\t120)\n    (UNSPEC_PSIGN\t\t121)\n    (UNSPEC_PALIGNR\t\t122)\n+\n+   ; For SSE4A support\n+   (UNSPEC_EXTRQI               130)\n+   (UNSPEC_EXTRQ                131)   \n+   (UNSPEC_INSERTQI             132)\n+   (UNSPEC_INSERTQ              133)\n   ])\n \n (define_constants\n@@ -195,7 +201,8 @@\n \f\n ;; Processor type.  This attribute must exactly match the processor_type\n ;; enumeration in i386.h.\n-(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro,geode,k6,athlon,pentium4,k8,nocona,core2,generic32,generic64\"\n+(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro,geode,k6,athlon,pentium4,k8,\n+                    nocona,core2,generic32,generic64,amdfam10\"\n   (const (symbol_ref \"ix86_tune\")))\n \n ;; A basic instruction type.  Refinements due to arguments to be\n@@ -206,10 +213,10 @@\n    incdec,ishift,ishift1,rotate,rotate1,imul,idiv,\n    icmp,test,ibr,setcc,icmov,\n    push,pop,call,callv,leave,\n-   str,\n+   str,bitmanip,\n    fmov,fop,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,fistp,fisttp,frndint,\n    sselog,sselog1,sseiadd,sseishft,sseimul,\n-   sse,ssemov,sseadd,ssemul,ssecmp,ssecomi,ssecvt,sseicvt,ssediv,\n+   sse,ssemov,sseadd,ssemul,ssecmp,ssecomi,ssecvt,sseicvt,ssediv,sseins,\n    mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft\"\n   (const_string \"other\"))\n \n@@ -223,7 +230,7 @@\n   (cond [(eq_attr \"type\" \"fmov,fop,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,fistp,fisttp,frndint\")\n \t   (const_string \"i387\")\n \t (eq_attr \"type\" \"sselog,sselog1,sseiadd,sseishft,sseimul,\n-\t\t\t  sse,ssemov,sseadd,ssemul,ssecmp,ssecomi,ssecvt,sseicvt,ssediv\")\n+\t\t\t  sse,ssemov,sseadd,ssemul,ssecmp,ssecomi,ssecvt,sseicvt,ssediv,sseins\")\n \t   (const_string \"sse\")\n \t (eq_attr \"type\" \"mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft\")\n \t   (const_string \"mmx\")\n@@ -233,7 +240,8 @@\n \n ;; The (bounding maximum) length of an instruction immediate.\n (define_attr \"length_immediate\" \"\"\n-  (cond [(eq_attr \"type\" \"incdec,setcc,icmov,str,lea,other,multi,idiv,leave\")\n+  (cond [(eq_attr \"type\" \"incdec,setcc,icmov,str,lea,other,multi,idiv,leave,\n+                          bitmanip\")\n \t   (const_int 0)\n \t (eq_attr \"unit\" \"i387,sse,mmx\")\n \t   (const_int 0)\n@@ -287,7 +295,7 @@\n ;; Set when 0f opcode prefix is used.\n (define_attr \"prefix_0f\" \"\"\n   (if_then_else\n-    (ior (eq_attr \"type\" \"imovx,setcc,icmov\")\n+    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip\")\n \t (eq_attr \"unit\" \"sse,mmx\"))\n     (const_int 1)\n     (const_int 0)))\n@@ -416,7 +424,7 @@\n \t   (const_string \"load\")\n \t (and (eq_attr \"type\"\n \t\t \"!alu1,negnot,ishift1,\n-\t\t   imov,imovx,icmp,test,\n+\t\t   imov,imovx,icmp,test,bitmanip,\n \t\t   fmov,fcmp,fsgn,\n \t\t   sse,ssemov,ssecmp,ssecomi,ssecvt,sseicvt,sselog1,\n \t\t   mmx,mmxmov,mmxcmp,mmxcvt\")\n@@ -977,10 +985,11 @@\n   \"sahf\"\n   [(set_attr \"length\" \"1\")\n    (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"direct\")\n    (set_attr \"mode\" \"SI\")])\n \n ;; Pentium Pro can do steps 1 through 3 in one go.\n-\n+;; comi*, ucomi*, fcomi*, ficomi*,fucomi* (i387 instructions set condition codes) \n (define_insn \"*cmpfp_i_mixed\"\n   [(set (reg:CCFP FLAGS_REG)\n \t(compare:CCFP (match_operand 0 \"register_operand\" \"f,x\")\n@@ -994,7 +1003,8 @@\n      (if_then_else (match_operand:SF 1 \"\" \"\")\n         (const_string \"SF\")\n         (const_string \"DF\")))\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n (define_insn \"*cmpfp_i_sse\"\n   [(set (reg:CCFP FLAGS_REG)\n@@ -1009,7 +1019,8 @@\n      (if_then_else (match_operand:SF 1 \"\" \"\")\n         (const_string \"SF\")\n         (const_string \"DF\")))\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n (define_insn \"*cmpfp_i_i387\"\n   [(set (reg:CCFP FLAGS_REG)\n@@ -1028,7 +1039,8 @@\n \t      (const_string \"DF\")\n \t   ]\n \t   (const_string \"XF\")))\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n (define_insn \"*cmpfp_iu_mixed\"\n   [(set (reg:CCFPU FLAGS_REG)\n@@ -1043,7 +1055,8 @@\n      (if_then_else (match_operand:SF 1 \"\" \"\")\n         (const_string \"SF\")\n         (const_string \"DF\")))\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n (define_insn \"*cmpfp_iu_sse\"\n   [(set (reg:CCFPU FLAGS_REG)\n@@ -1058,7 +1071,8 @@\n      (if_then_else (match_operand:SF 1 \"\" \"\")\n         (const_string \"SF\")\n         (const_string \"DF\")))\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n (define_insn \"*cmpfp_iu_387\"\n   [(set (reg:CCFPU FLAGS_REG)\n@@ -1077,7 +1091,8 @@\n \t      (const_string \"DF\")\n \t   ]\n \t   (const_string \"XF\")))\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \f\n ;; Move instructions.\n \n@@ -1283,7 +1298,8 @@\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"double\")])   \n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n@@ -1400,8 +1416,10 @@\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"double\")])   \n \n+;; Not added amdfam10_decode since TARGET_PARTIAL_REG_STALL is disabled for AMDFAM10\n (define_insn \"*swaphi_2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"+r\")\n \t(match_operand:HI 1 \"register_operand\" \"+r\"))\n@@ -1574,8 +1592,10 @@\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"vector\")])   \n \n+;; Not added amdfam10_decode since TARGET_PARTIAL_REG_STALL is disabled for AMDFAM10\n (define_insn \"*swapqi_2\"\n   [(set (match_operand:QI 0 \"register_operand\" \"+q\")\n \t(match_operand:QI 1 \"register_operand\" \"+q\"))\n@@ -2139,7 +2159,8 @@\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"mode\" \"DI\")\n    (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"double\")])   \n \n (define_expand \"movti\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n@@ -4179,7 +4200,8 @@\n   \"cvttss2si{q}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"SF\")\n-   (set_attr \"athlon_decode\" \"double,vector\")])\n+   (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")])\n \n (define_insn \"fix_truncdfdi_sse\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -4188,7 +4210,8 @@\n   \"cvttsd2si{q}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DF\")\n-   (set_attr \"athlon_decode\" \"double,vector\")])\n+   (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")])\n \n (define_insn \"fix_truncsfsi_sse\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -4197,7 +4220,8 @@\n   \"cvttss2si\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DF\")\n-   (set_attr \"athlon_decode\" \"double,vector\")])\n+   (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")])\n \n (define_insn \"fix_truncdfsi_sse\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -4206,7 +4230,8 @@\n   \"cvttsd2si\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DF\")\n-   (set_attr \"athlon_decode\" \"double,vector\")])\n+   (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")])\n \n ;; Shorten x87->SSE reload sequences of fix_trunc?f?i_sse patterns.\n (define_peephole2\n@@ -4488,7 +4513,8 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"mode\" \"HI\")\n    (set_attr \"unit\" \"i387\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"vector\")])   \n \f\n ;; Conversion between fixed point and floating point.\n \n@@ -4539,6 +4565,7 @@\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"unit\" \"*,i387,*,*\")\n    (set_attr \"athlon_decode\" \"*,*,vector,double\")\n+   (set_attr \"amdfam10_decode\" \"*,*,vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatsisf2_sse\"\n@@ -4549,6 +4576,7 @@\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"athlon_decode\" \"vector,double\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatsisf2_i387\"\n@@ -4582,6 +4610,7 @@\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"unit\" \"*,i387,*,*\")\n    (set_attr \"athlon_decode\" \"*,*,vector,double\")\n+   (set_attr \"amdfam10_decode\" \"*,*,vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatdisf2_sse\"\n@@ -4592,6 +4621,7 @@\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"athlon_decode\" \"vector,double\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatdisf2_i387\"\n@@ -4650,6 +4680,7 @@\n    (set_attr \"mode\" \"DF\")\n    (set_attr \"unit\" \"*,i387,*,*\")\n    (set_attr \"athlon_decode\" \"*,*,double,direct\")\n+   (set_attr \"amdfam10_decode\" \"*,*,vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatsidf2_sse\"\n@@ -4660,6 +4691,7 @@\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DF\")\n    (set_attr \"athlon_decode\" \"double,direct\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatsidf2_i387\"\n@@ -4693,6 +4725,7 @@\n    (set_attr \"mode\" \"DF\")\n    (set_attr \"unit\" \"*,i387,*,*\")\n    (set_attr \"athlon_decode\" \"*,*,double,direct\")\n+   (set_attr \"amdfam10_decode\" \"*,*,vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatdidf2_sse\"\n@@ -4703,6 +4736,7 @@\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DF\")\n    (set_attr \"athlon_decode\" \"double,direct\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatdidf2_i387\"\n@@ -6910,6 +6944,14 @@\n   \"TARGET_64BIT\"\n   \"\")\n \n+;; On AMDFAM10 \n+;; IMUL reg64, reg64, imm8 \tDirect\n+;; IMUL reg64, mem64, imm8 \tVectorPath\n+;; IMUL reg64, reg64, imm32 \tDirect\n+;; IMUL reg64, mem64, imm32 \tVectorPath \n+;; IMUL reg64, reg64 \t\tDirect\n+;; IMUL reg64, mem64 \t\tDirect\n+\n (define_insn \"*muldi3_1_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n \t(mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n@@ -6932,6 +6974,11 @@\n \t\t    (match_operand 1 \"memory_operand\" \"\"))\n \t\t  (const_string \"vector\")]\n \t      (const_string \"direct\")))\n+   (set (attr \"amdfam10_decode\")\n+\t(cond [(and (eq_attr \"alternative\" \"0,1\")\n+\t\t    (match_operand 1 \"memory_operand\" \"\"))\n+\t\t  (const_string \"vector\")]\n+\t      (const_string \"direct\")))\t      \n    (set_attr \"mode\" \"DI\")])\n \n (define_expand \"mulsi3\"\n@@ -6942,6 +6989,14 @@\n   \"\"\n   \"\")\n \n+;; On AMDFAM10 \n+;; IMUL reg32, reg32, imm8 \tDirect\n+;; IMUL reg32, mem32, imm8 \tVectorPath\n+;; IMUL reg32, reg32, imm32 \tDirect\n+;; IMUL reg32, mem32, imm32 \tVectorPath\n+;; IMUL reg32, reg32 \t\tDirect\n+;; IMUL reg32, mem32 \t\tDirect\n+\n (define_insn \"*mulsi3_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n@@ -6963,6 +7018,11 @@\n \t\t    (match_operand 1 \"memory_operand\" \"\"))\n \t\t  (const_string \"vector\")]\n \t      (const_string \"direct\")))\n+   (set (attr \"amdfam10_decode\")\n+\t(cond [(and (eq_attr \"alternative\" \"0,1\")\n+\t\t    (match_operand 1 \"memory_operand\" \"\"))\n+\t\t  (const_string \"vector\")]\n+\t      (const_string \"direct\")))\t      \n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*mulsi3_1_zext\"\n@@ -6988,6 +7048,11 @@\n \t\t    (match_operand 1 \"memory_operand\" \"\"))\n \t\t  (const_string \"vector\")]\n \t      (const_string \"direct\")))\n+   (set (attr \"amdfam10_decode\")\n+\t(cond [(and (eq_attr \"alternative\" \"0,1\")\n+\t\t    (match_operand 1 \"memory_operand\" \"\"))\n+\t\t  (const_string \"vector\")]\n+\t      (const_string \"direct\")))\t      \n    (set_attr \"mode\" \"SI\")])\n \n (define_expand \"mulhi3\"\n@@ -6998,6 +7063,13 @@\n   \"TARGET_HIMODE_MATH\"\n   \"\")\n \n+;; On AMDFAM10\n+;; IMUL reg16, reg16, imm8 \tVectorPath\n+;; IMUL reg16, mem16, imm8 \tVectorPath\n+;; IMUL reg16, reg16, imm16 \tVectorPath\n+;; IMUL reg16, mem16, imm16 \tVectorPath\n+;; IMUL reg16, reg16 \t\tDirect\n+;; IMUL reg16, mem16 \t\tDirect\n (define_insn \"*mulhi3_1\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n \t(mult:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n@@ -7016,6 +7088,10 @@\n \t       (eq_attr \"alternative\" \"1,2\")\n \t\t  (const_string \"vector\")]\n \t      (const_string \"direct\")))\n+   (set (attr \"amdfam10_decode\")\n+\t(cond [(eq_attr \"alternative\" \"0,1\")\n+\t\t  (const_string \"vector\")]\n+\t      (const_string \"direct\")))\n    (set_attr \"mode\" \"HI\")])\n \n (define_expand \"mulqi3\"\n@@ -7026,6 +7102,10 @@\n   \"TARGET_QIMODE_MATH\"\n   \"\")\n \n+;;On AMDFAM10\n+;; MUL reg8 \tDirect\n+;; MUL mem8 \tDirect\n+\n (define_insn \"*mulqi3_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=a\")\n \t(mult:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")\n@@ -7040,6 +7120,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"direct\")))\n+   (set_attr \"amdfam10_decode\" \"direct\")        \n    (set_attr \"mode\" \"QI\")])\n \n (define_expand \"umulqihi3\"\n@@ -7066,6 +7147,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"direct\")))\n+   (set_attr \"amdfam10_decode\" \"direct\")        \n    (set_attr \"mode\" \"QI\")])\n \n (define_expand \"mulqihi3\"\n@@ -7090,6 +7172,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"direct\")))\n+   (set_attr \"amdfam10_decode\" \"direct\")        \n    (set_attr \"mode\" \"QI\")])\n \n (define_expand \"umulditi3\"\n@@ -7116,6 +7199,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")        \n    (set_attr \"mode\" \"DI\")])\n \n ;; We can't use this pattern in 64bit mode, since it results in two separate 32bit registers\n@@ -7143,6 +7227,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")        \n    (set_attr \"mode\" \"SI\")])\n \n (define_expand \"mulditi3\"\n@@ -7169,6 +7254,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_expand \"mulsidi3\"\n@@ -7195,6 +7281,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")        \n    (set_attr \"mode\" \"SI\")])\n \n (define_expand \"umuldi3_highpart\"\n@@ -7231,6 +7318,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")        \n    (set_attr \"mode\" \"DI\")])\n \n (define_expand \"umulsi3_highpart\"\n@@ -7266,6 +7354,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*umulsi3_highpart_zext\"\n@@ -7288,6 +7377,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_expand \"smuldi3_highpart\"\n@@ -7323,6 +7413,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_expand \"smulsi3_highpart\"\n@@ -7357,6 +7448,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*smulsi3_highpart_zext\"\n@@ -7378,6 +7470,7 @@\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"SI\")])\n \n ;; The patterns that match these are at the end of this file.\n@@ -10359,7 +10452,8 @@\n   [(set_attr \"type\" \"ishift\")\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"mode\" \"DI\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"vector\")])   \n \n (define_expand \"x86_64_shift_adj\"\n   [(set (reg:CCZ FLAGS_REG)\n@@ -10574,7 +10668,8 @@\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"vector\")])   \n \n (define_expand \"x86_shift_adj_1\"\n   [(set (reg:CCZ FLAGS_REG)\n@@ -11334,7 +11429,8 @@\n   [(set_attr \"type\" \"ishift\")\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"mode\" \"DI\")\n-   (set_attr \"athlon_decode\" \"vector\")])\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"vector\")])   \n \n (define_expand \"ashrdi3\"\n   [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n@@ -14608,7 +14704,23 @@\n      [(set (match_dup 0) (xor:SI (match_dup 0) (const_int 31)))\n       (clobber (reg:CC FLAGS_REG))])]\n   \"\"\n-  \"\")\n+{\n+  if (TARGET_ABM)\n+    {\n+      emit_insn (gen_clzsi2_abm (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"clzsi2_abm\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (clz:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_ABM\"\n+  \"lzcnt{l}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*bsr\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -14617,7 +14729,44 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n   \"bsr{l}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"prefix_0f\" \"1\")])\n+  [(set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"popcountsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(popcount:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_POPCNT\"\n+  \"popcnt{l}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*popcountsi2_cmp\"\n+  [(set (reg FLAGS_REG)\n+\t(compare\n+\t  (popcount:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))\n+\t  (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(popcount:SI (match_dup 1)))]\n+  \"TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)\"\n+  \"popcnt{l}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*popcountsi2_cmp_zext\"\n+  [(set (reg FLAGS_REG)\n+        (compare\n+          (popcount:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))\n+          (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (zero_extend:DI(popcount:SI (match_dup 1))))]\n+  \"TARGET_64BIT && TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)\"\n+  \"popcnt{l}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"bswapsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -14647,7 +14796,23 @@\n      [(set (match_dup 0) (xor:DI (match_dup 0) (const_int 63)))\n       (clobber (reg:CC FLAGS_REG))])]\n   \"TARGET_64BIT\"\n-  \"\")\n+{\n+  if (TARGET_ABM)\n+    {\n+      emit_insn (gen_clzdi2_abm (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"clzdi2_abm\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(clz:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && TARGET_ABM\"\n+  \"lzcnt{q}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_insn \"*bsr_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -14656,7 +14821,92 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n   \"bsr{q}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"prefix_0f\" \"1\")])\n+  [(set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"popcountdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(popcount:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && TARGET_POPCNT\"\n+  \"popcnt{q}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*popcountdi2_cmp\"\n+  [(set (reg FLAGS_REG)\n+\t(compare\n+\t  (popcount:DI (match_operand:DI 1 \"nonimmediate_operand\" \"rm\"))\n+\t  (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(popcount:DI (match_dup 1)))]\n+  \"TARGET_64BIT && TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)\"\n+  \"popcnt{q}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_expand \"clzhi2\"\n+  [(parallel\n+     [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t   (minus:HI (const_int 15)\n+\t\t     (clz:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\"))))\n+      (clobber (reg:CC FLAGS_REG))])\n+   (parallel\n+     [(set (match_dup 0) (xor:HI (match_dup 0) (const_int 15)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+{\n+  if (TARGET_ABM)\n+    {\n+      emit_insn (gen_clzhi2_abm (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"clzhi2_abm\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(clz:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_ABM\"\n+  \"lzcnt{w}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"*bsrhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(minus:HI (const_int 15)\n+\t\t  (clz:HI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"bsr{w}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"popcounthi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(popcount:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_POPCNT\"\n+  \"popcnt{w}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"*popcounthi2_cmp\"\n+  [(set (reg FLAGS_REG)\n+        (compare\n+          (popcount:HI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\"))\n+          (const_int 0)))\n+   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (popcount:HI (match_dup 1)))]\n+  \"TARGET_POPCNT && ix86_match_ccmode (insn, CCZmode)\"\n+  \"popcnt{w}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"HI\")])\n \f\n ;; Thread-local storage patterns for ELF.\n ;;\n@@ -15564,7 +15814,8 @@\n   \"fsqrt\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")\n-   (set_attr \"athlon_decode\" \"direct\")])\n+   (set_attr \"athlon_decode\" \"direct\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n (define_insn \"sqrt_extend<mode>xf2_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n@@ -15575,7 +15826,8 @@\n   \"fsqrt\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")\n-   (set_attr \"athlon_decode\" \"direct\")])\n+   (set_attr \"athlon_decode\" \"direct\")   \n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n (define_insn \"*sqrt<mode>2_sse\"\n   [(set (match_operand:SSEMODEF 0 \"register_operand\" \"=x\")\n@@ -15585,7 +15837,8 @@\n   \"sqrts<ssemodefsuffix>\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"athlon_decode\" \"*\")])\n+   (set_attr \"athlon_decode\" \"*\")\n+   (set_attr \"amdfam10_decode\" \"*\")])\n \n (define_expand \"sqrt<mode>2\"\n   [(set (match_operand:X87MODEF12 0 \"register_operand\" \"\")\n@@ -19995,7 +20248,7 @@\n \t\t   (mult:DI (match_operand:DI 1 \"memory_operand\" \"\")\n \t\t\t    (match_operand:DI 2 \"immediate_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n+  \"(TARGET_K8 || TARGET_GENERIC64 || TARGET_AMDFAM10) && !optimize_size\n    && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (match_dup 0) (mult:DI (match_dup 3) (match_dup 2)))\n@@ -20008,7 +20261,7 @@\n \t\t   (mult:SI (match_operand:SI 1 \"memory_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"immediate_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n+  \"(TARGET_K8 || TARGET_GENERIC64 || TARGET_AMDFAM10) && !optimize_size\n    && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))\n@@ -20022,7 +20275,7 @@\n \t\t     (mult:SI (match_operand:SI 1 \"memory_operand\" \"\")\n \t\t\t      (match_operand:SI 2 \"immediate_operand\" \"\"))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n+  \"(TARGET_K8 || TARGET_GENERIC64 || TARGET_AMDFAM10) && !optimize_size\n    && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (match_dup 0) (zero_extend:DI (mult:SI (match_dup 3) (match_dup 2))))\n@@ -20039,7 +20292,7 @@\n \t\t\t    (match_operand:DI 2 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_scratch:DI 3 \"r\")]\n-  \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n+  \"(TARGET_K8 || TARGET_GENERIC64 || TARGET_AMDFAM10) && !optimize_size\n    && satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 2))\n    (parallel [(set (match_dup 0) (mult:DI (match_dup 0) (match_dup 3)))\n@@ -20055,7 +20308,7 @@\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_scratch:SI 3 \"r\")]\n-  \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n+  \"(TARGET_K8 || TARGET_GENERIC64 || TARGET_AMDFAM10) && !optimize_size\n    && satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 2))\n    (parallel [(set (match_dup 0) (mult:SI (match_dup 0) (match_dup 3)))\n@@ -20071,7 +20324,7 @@\n \t\t\t    (match_operand:HI 2 \"immediate_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_scratch:HI 3 \"r\")]\n-  \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\"\n+  \"(TARGET_K8 || TARGET_GENERIC64 || TARGET_AMDFAM10) && !optimize_size\"\n   [(set (match_dup 3) (match_dup 2))\n    (parallel [(set (match_dup 0) (mult:HI (match_dup 0) (match_dup 3)))\n \t      (clobber (reg:CC FLAGS_REG))])]"}, {"sha": "61c68074020160dae11302ec67cc933cbdeedf40", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -1,6 +1,6 @@\n ; Options for the IA-32 and AMD64 ports of the compiler.\n \n-; Copyright (C) 2005 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -205,6 +205,22 @@ mssse3\n Target Report Mask(SSSE3)\n Support MMX, SSE, SSE2, SSE3 and SSSE3 built-in functions and code generation\n \n+msse4a\n+Target Report Mask(SSE4A)\n+Support MMX, SSE, SSE2, SSE3 and SSE4A built-in functions and code generation\n+\n+mpopcnt\n+Target Report Mask(POPCNT)\n+Support code generation of popcount instruction for popcount built-ins \n+namely __builtin_popcount, __builtin_popcountl and __builtin_popcountll\n+\n+mabm\n+Target Report Mask(ABM)\n+Support code generation of Advanced Bit Manipulation (ABM) instructions,\n+which include popcnt and lzcnt instructions, for popcount and clz built-ins\n+namely __builtin_popcount, __builtin_popcountl, __builtin_popcountll and\n+__builtin_clz, __builtin_clzl, __builtin_clzll\n+\n msseregparm\n Target RejectNegative Mask(SSEREGPARM)\n Use SSE register passing conventions for SF and DF mode"}, {"sha": "39d7c170a73365ba3074334d9691b16afa8c0f18", "filename": "gcc/config/i386/pmmintrin.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fpmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fpmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpmmintrin.h?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -30,7 +30,11 @@\n #ifndef _PMMINTRIN_H_INCLUDED\n #define _PMMINTRIN_H_INCLUDED\n \n-#ifdef __SSE3__\n+#ifndef __SSE3__\n+# error \"SSE3 instruction set not enabled\"\n+#else\n+\n+/* We need definitions from the SSE2 and SSE header files*/\n #include <xmmintrin.h>\n #include <emmintrin.h>\n "}, {"sha": "1bb099e48a9ce883f7bb346dfff082b0e8819124", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 119, "deletions": 12, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for SSE instructions\n-;; Copyright (C) 2005, 2006\n+;; Copyright (C) 2005, 2006, 2007\n ;; Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n@@ -956,6 +956,7 @@\n   \"cvtsi2ss\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"vector,double\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"sse_cvtsi2ssq\"\n@@ -969,6 +970,7 @@\n   \"cvtsi2ssq\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"vector,double\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"sse_cvtss2si\"\n@@ -992,6 +994,7 @@\n   \"cvtss2si\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"sse_cvtss2siq\"\n@@ -1015,6 +1018,7 @@\n   \"cvtss2siq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"sse_cvttss2si\"\n@@ -1027,6 +1031,7 @@\n   \"cvttss2si\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"sse_cvttss2siq\"\n@@ -1039,6 +1044,7 @@\n   \"cvttss2siq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"sse2_cvtdq2ps\"\n@@ -1944,7 +1950,8 @@\n   \"cvtsi2sd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DF\")\n-   (set_attr \"athlon_decode\" \"double,direct\")])\n+   (set_attr \"athlon_decode\" \"double,direct\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")])\n \n (define_insn \"sse2_cvtsi2sdq\"\n   [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n@@ -1957,7 +1964,8 @@\n   \"cvtsi2sdq\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DF\")\n-   (set_attr \"athlon_decode\" \"double,direct\")])\n+   (set_attr \"athlon_decode\" \"double,direct\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")])\n \n (define_insn \"sse2_cvtsd2si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -1980,6 +1988,7 @@\n   \"cvtsd2si\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"sse2_cvtsd2siq\"\n@@ -2003,6 +2012,7 @@\n   \"cvtsd2siq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"sse2_cvttsd2si\"\n@@ -2015,7 +2025,8 @@\n   \"cvttsd2si\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"SI\")\n-   (set_attr \"athlon_decode\" \"double,vector\")])\n+   (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")])\n \n (define_insn \"sse2_cvttsd2siq\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -2027,7 +2038,8 @@\n   \"cvttsd2siq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"DI\")\n-   (set_attr \"athlon_decode\" \"double,vector\")])\n+   (set_attr \"athlon_decode\" \"double,vector\")\n+   (set_attr \"amdfam10_decode\" \"double,double\")])\n \n (define_insn \"sse2_cvtdq2pd\"\n   [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n@@ -2058,7 +2070,8 @@\n   \"TARGET_SSE2\"\n   \"cvtpd2dq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"TI\")\n+   (set_attr \"amdfam10_decode\" \"double\")])\n \n (define_expand \"sse2_cvttpd2dq\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n@@ -2076,7 +2089,8 @@\n   \"TARGET_SSE2\"\n   \"cvttpd2dq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"TI\")\n+   (set_attr \"amdfam10_decode\" \"double\")])\n \n (define_insn \"sse2_cvtsd2ss\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n@@ -2090,20 +2104,22 @@\n   \"cvtsd2ss\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecvt\")\n    (set_attr \"athlon_decode\" \"vector,double\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"sse2_cvtss2sd\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n \t(vec_merge:V2DF\n \t  (float_extend:V2DF\n \t    (vec_select:V2SF\n-\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")\n+\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"x,m\")\n \t      (parallel [(const_int 0) (const_int 1)])))\n-\t  (match_operand:V2DF 1 \"register_operand\" \"0\")\n+\t  (match_operand:V2DF 1 \"register_operand\" \"0,0\")\n \t  (const_int 1)))]\n   \"TARGET_SSE2\"\n   \"cvtss2sd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecvt\")\n+   (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"mode\" \"DF\")])\n \n (define_expand \"sse2_cvtpd2ps\"\n@@ -2124,7 +2140,8 @@\n   \"TARGET_SSE2\"\n   \"cvtpd2ps\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"V4SF\")\n+   (set_attr \"amdfam10_decode\" \"double\")])\n \n (define_insn \"sse2_cvtps2pd\"\n   [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n@@ -2135,7 +2152,8 @@\n   \"TARGET_SSE2\"\n   \"cvtps2pd\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"V2DF\")])\n+   (set_attr \"mode\" \"V2DF\")\n+   (set_attr \"amdfam10_decode\" \"direct\")])\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n@@ -5146,3 +5164,92 @@\n   \"pabs<mmxvecsize>\\t{%1, %0|%0, %1}\";\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"mode\" \"DI\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; AMD SSE4A instructions\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn \"sse4a_vmmovntv2df\"\n+  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n+        (unspec:DF [(vec_select:DF \n+                      (match_operand:V2DF 1 \"register_operand\" \"x\")\n+                      (parallel [(const_int 0)]))]\n+                   UNSPEC_MOVNT))]\n+  \"TARGET_SSE4A\"\n+  \"movntsd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"sse4a_movntdf\"\n+  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n+        (unspec:DF [(match_operand:DF 1 \"register_operand\" \"x\")]\n+                   UNSPEC_MOVNT))]\n+  \"TARGET_SSE4A\"\n+  \"movntsd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"sse4a_vmmovntv4sf\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(unspec:SF [(vec_select:SF \n+\t              (match_operand:V4SF 1 \"register_operand\" \"x\")\n+\t\t      (parallel [(const_int 0)]))]\n+\t\t   UNSPEC_MOVNT))]\n+  \"TARGET_SSE4A\"\n+  \"movntss\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"sse4a_movntsf\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"x\")]\n+\t\t   UNSPEC_MOVNT))]\n+  \"TARGET_SSE4A\"\n+  \"movntss\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"sse4a_extrqi\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"0\")\n+                      (match_operand 2 \"const_int_operand\" \"\")\n+                      (match_operand 3 \"const_int_operand\" \"\")]\n+                     UNSPEC_EXTRQI))]\n+  \"TARGET_SSE4A\"\n+  \"extrq\\t{%3, %2, %0|%0, %2, %3}\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4a_extrq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"0\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"x\")]\n+                     UNSPEC_EXTRQ))]\n+  \"TARGET_SSE4A\"\n+  \"extrq\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4a_insertqi\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"0\")\n+        \t      (match_operand:V2DI 2 \"register_operand\" \"x\")\n+                      (match_operand 3 \"const_int_operand\" \"\")\n+                      (match_operand 4 \"const_int_operand\" \"\")]\n+                     UNSPEC_INSERTQI))]\n+  \"TARGET_SSE4A\"\n+  \"insertq\\t{%4, %3, %2, %0|%0, %2, %3, %4}\"\n+  [(set_attr \"type\" \"sseins\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4a_insertq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"0\")\n+        \t      (match_operand:V2DI 2 \"register_operand\" \"x\")]\n+        \t     UNSPEC_INSERTQ))]\n+  \"TARGET_SSE4A\"\n+  \"insertq\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseins\")\n+   (set_attr \"mode\" \"TI\")])"}, {"sha": "cf9d99d0901b5a6e5d030aad334b12ca53903188", "filename": "gcc/config/i386/tmmintrin.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Ftmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fconfig%2Fi386%2Ftmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ftmmintrin.h?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -30,7 +30,11 @@\n #ifndef _TMMINTRIN_H_INCLUDED\n #define _TMMINTRIN_H_INCLUDED\n \n-#ifdef __SSSE3__\n+#ifndef __SSSE3__\n+# error \"SSSE3 instruction set not enabled\"\n+#else\n+\n+/* We need definitions from the SSE3, SSE2 and SSE header files*/\n #include <pmmintrin.h>\n \n static __inline __m128i __attribute__((__always_inline__))"}, {"sha": "2417a73d20a1fdd4499cb28ebbf8f094ebaaad36", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -7269,6 +7269,23 @@ v4si __builtin_ia32_pabsd128 (v4si)\n v8hi __builtin_ia32_pabsw128 (v8hi)\n @end smallexample\n \n+The following built-in functions are available when @option{-msse4a} is used.\n+\n+@smallexample\n+void             _mm_stream_sd (double*,__m128d);\n+Generates the @code{movntsd} machine instruction.\n+void             _mm_stream_ss (float*,__m128);\n+Generates the @code{movntss} machine instruction.\n+__m128i          _mm_extract_si64 (__m128i, __m128i);\n+Generates the @code{extrq} machine instruction with only SSE register operands.\n+__m128i          _mm_extracti_si64 (__m128i, int, int);\n+Generates the @code{extrq} machine instruction with SSE register and immediate operands.\n+__m128i          _mm_insert_si64 (__m128i, __m128i);\n+Generates the @code{insertq} machine instruction with only SSE register operands.\n+__m128i          _mm_inserti_si64 (__m128i, __m128i, int, int);\n+Generates the @code{insertq} machine instruction with SSE register and immediate operands.\n+@end smallexample\n+\n The following built-in functions are available when @option{-m3dnow} is used.\n All of them generate the machine instruction that is part of the name.\n "}, {"sha": "cae7f8b038dc86d280c633ee8518c2cd2ad98862", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -538,7 +538,7 @@ Objective-C and Objective-C++ Dialects}.\n -mno-fp-ret-in-387  -msoft-float  -msvr3-shlib @gol\n -mno-wide-multiply  -mrtd  -malign-double @gol\n -mpreferred-stack-boundary=@var{num} @gol\n--mmmx  -msse  -msse2 -msse3 -mssse3 -m3dnow @gol\n+-mmmx  -msse  -msse2 -msse3 -mssse3 -msse4a -m3dnow -mpopcnt -mabm @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n -m96bit-long-double  -mregparm=@var{num}  -msseregparm @gol\n@@ -9501,6 +9501,10 @@ instruction set support.\n @item k8, opteron, athlon64, athlon-fx\n AMD K8 core based CPUs with x86-64 instruction set support.  (This supersets\n MMX, SSE, SSE2, 3dNOW!, enhanced 3dNOW! and 64-bit instruction set extensions.)\n+@item amdfam10\n+AMD Family 10 core based CPUs with x86-64 instruction set support.  (This\n+supersets MMX, SSE, SSE2, SSE3, SSE4A, 3dNOW!, enhanced 3dNOW!, ABM and 64-bit\n+instruction set extensions.)\n @item winchip-c6\n IDT Winchip C6 CPU, dealt in same way as i486 with additional MMX instruction\n set support.\n@@ -9795,16 +9799,22 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mno-sse3\n @item -mssse3\n @itemx -mno-ssse3\n+@item -msse4a\n+@item -mno-sse4a\n @item -m3dnow\n @itemx -mno-3dnow\n+@item -mpopcnt\n+@itemx -mno-popcnt\n+@item -mabm\n+@itemx -mno-abm\n @opindex mmmx\n @opindex mno-mmx\n @opindex msse\n @opindex mno-sse\n @opindex m3dnow\n @opindex mno-3dnow\n These switches enable or disable the use of instructions in the MMX,\n-SSE, SSE2, SSE3, SSSE3 or 3DNow! extended instruction sets.\n+SSE, SSE2, SSE3, SSSE3, SSE4A, ABM or 3DNow! extended instruction sets.\n These extensions are also available as built-in functions: see\n @ref{X86 Built-in Functions}, for details of the functions enabled and\n disabled by these switches."}, {"sha": "03f1aa6462ef663409e27a8bc3fefb7ec302cd78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -1,3 +1,12 @@\n+2007-02-05      Dwarakanath Rajagopal <dwarak.rajagopal@amd.com>\n+\n+        * gcc.dg/i386-cpuid.h: Test whether SSE4A is supported\n+        for running tests.\n+        * gcc.target/i386/sse4a-extract.c: New test.\n+        * gcc.target/i386/sse4a-insert.c: New test.\n+        * gcc.target/i386/sse4a-montsd.c: New test.\n+        * gcc.target/i386/sse4a-montss.c: New test.\n+\n 2007-02-05  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.target/i386/vectorize3.c: New testcase."}, {"sha": "c7b999c7fdfbd74960c14333ef12ae121e18022a", "filename": "gcc/testsuite/gcc.dg/i386-cpuid.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -12,6 +12,10 @@\n #define bit_SSE (1 << 25)\n #define bit_SSE2 (1 << 26)\n \n+/* Extended Features */\n+/* %ecx */\n+#define bit_SSE4a (1 << 6)\n+\n #ifndef NOINLINE\n #define NOINLINE __attribute__ ((noinline))\n #endif\n@@ -60,8 +64,43 @@ i386_get_cpuid (unsigned int *ecx, unsigned int *edx)\n   return 1;\n }\n \n+static inline unsigned int\n+i386_get_extended_cpuid (unsigned int *ecx, unsigned int *edx)\n+{\n+  int fl1;\n+  if (!(i386_get_cpuid (ecx, edx)))\n+    return 0;\n+\n+  /* Invoke CPUID(0x80000000) to get the highest supported extended function\n+     number */\n+#ifdef __x86_64__\n+  __asm__ (\"cpuid\"\n+\t   : \"=a\" (fl1) : \"0\" (0x80000000) : \"edx\", \"ecx\", \"ebx\");\n+#else\n+  __asm__ (\"pushl %%ebx; cpuid; popl %%ebx\"\n+\t   : \"=a\" (fl1) : \"0\" (0x80000000) : \"edx\", \"ecx\");\n+#endif\n+  /* Check if highest supported extended function used below are supported */\n+  if (fl1 < 0x80000001)\n+    return 0;  \n+\n+  /* Invoke CPUID(0x80000001), return %ecx and %edx; caller can examine bits to\n+     determine what's supported.  */\n+#ifdef __x86_64__\n+  __asm__ (\"cpuid\"\n+\t   : \"=c\" (*ecx), \"=d\" (*edx), \"=a\" (fl1) : \"2\" (0x80000001) : \"ebx\");\n+#else\n+  __asm__ (\"pushl %%ebx; cpuid; popl %%ebx\"\n+\t   : \"=c\" (*ecx), \"=d\" (*edx), \"=a\" (fl1) : \"2\" (0x80000001));\n+#endif\n+  return 1;\n+}\n+\n+\n unsigned int i386_cpuid_ecx (void) NOINLINE;\n unsigned int i386_cpuid_edx (void) NOINLINE;\n+unsigned int i386_extended_cpuid_ecx (void) NOINLINE;\n+unsigned int i386_extended_cpuid_edx (void) NOINLINE;\n \n unsigned int NOINLINE\n i386_cpuid_ecx (void)\n@@ -83,6 +122,26 @@ i386_cpuid_edx (void)\n     return 0;\n }\n \n+unsigned int NOINLINE\n+i386_extended_cpuid_ecx (void)\n+{\n+  unsigned int ecx, edx;\n+  if (i386_get_extended_cpuid (&ecx, &edx))\n+    return ecx;\n+  else\n+    return 0;\n+}\n+\n+unsigned int NOINLINE\n+i386_extended_cpuid_edx (void)\n+{\n+  unsigned int ecx, edx;\n+  if (i386_get_extended_cpuid (&ecx, &edx))\n+    return edx;\n+  else\n+    return 0;\n+}\n+\n static inline unsigned int\n i386_cpuid (void)\n {"}, {"sha": "90ad0f65a235f12260c3d1d84b49dbfddddd9782", "filename": "gcc/testsuite/gcc.target/i386/sse4a-extract.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-extract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-extract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-extract.c?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -0,0 +1,100 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse4a\" } */\n+#include <ammintrin.h>\n+#include <stdlib.h>\n+#include \"../../gcc.dg/i386-cpuid.h\"\n+\n+static void sse4a_test (void);\n+\n+typedef union\n+{\n+  long long i[2];\n+  __m128i vec;\n+} LI;\n+\n+int\n+main ()\n+{  \n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_extended_cpuid_ecx ();\n+\n+  /* Run SSE4a test only if host has SSE4a support.  */\n+  if ((cpu_facilities & bit_SSE4a))\n+    sse4a_test ();\n+\n+  exit (0);\n+}\n+\n+static long long \n+sse4a_test_extrq (long long in)\n+{\n+  __m128i v1, v2;\n+  long long index_length, pad;\n+  LI v_out;\n+  index_length = 0x0000000000000810; \n+  pad = 0x0;\n+  v1 = _mm_set_epi64x (pad, in);\n+  v2 = _mm_set_epi64x (pad, index_length); \n+  v_out.vec = _mm_extract_si64 (v1, v2);\n+  return (v_out.i[0]); \n+}\n+\n+static long long \n+sse4a_test_extrqi (long long in)\n+{\n+  __m128i v1;\n+  long long pad =0x0;\n+  LI v_out;\n+  v1 = _mm_set_epi64x (pad, in);\n+  v_out.vec = _mm_extracti_si64 (v1, (unsigned int) 0x10,(unsigned int) 0x08);\n+  return (v_out.i[0]);\n+}\n+\n+static chk (long long i1, long long i2)\n+{\n+  int n_fails =0;\n+  if (i1 != i2) \n+    n_fails +=1;\n+  return n_fails;\n+}\n+\n+long long vals_in[5] =\n+  {\n+    0x1234567887654321,\n+    0x1456782093002490,\n+    0x2340909123990390,\n+    0x9595959599595999,\n+    0x9099038798000029\n+  };\n+\n+long long vals_out[5] =\n+  {\n+    0x0000000000006543,\n+    0x0000000000000024,\n+    0x0000000000009903,\n+    0x0000000000005959,\n+    0x0000000000000000\n+  };\n+\n+static void\n+sse4a_test (void)\n+{\n+  int i;\n+  int fail = 0;\n+  long long out;\n+\n+  for (i = 0; i < 5; i += 1)\n+    {\n+      out = sse4a_test_extrq (vals_in[i]);\n+      fail += chk(out, vals_out[i]);\n+\n+      out = sse4a_test_extrqi (vals_in[i]);\n+      fail += chk(out, vals_out[i]);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+\n+  exit (0);\n+}"}, {"sha": "69262bdfcb0664e0d0af47779cda36d4b1f0f72c", "filename": "gcc/testsuite/gcc.target/i386/sse4a-insert.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-insert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-insert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-insert.c?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse4a\" } */\n+#include <ammintrin.h>\n+#include <stdlib.h>\n+#include \"../../gcc.dg/i386-cpuid.h\"\n+\n+static void sse4a_test (void);\n+\n+typedef union\n+{\n+  long long i[2];\n+  __m128i vec;\n+} LI;\n+\n+int\n+main ()\n+{  \n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_extended_cpuid_ecx ();\n+\n+  /* Run SSE4a test only if host has SSE4a support.  */\n+  if ((cpu_facilities & bit_SSE4a))\n+    sse4a_test ();\n+\n+  exit (0);\n+}\n+\n+static long long\n+sse4a_test_insert (long long in1, long long in2)\n+{\n+  __m128i v1,v2;\n+  long long index_length, pad;\n+  LI v_out;\n+  index_length = 0x0000000000000810;\n+  pad = 0x0;\n+  v1 = _mm_set_epi64x (pad, in1);\n+  v2 = _mm_set_epi64x (index_length, in2); \n+  v_out.vec = _mm_insert_si64 (v1, v2);\n+  return (v_out.i[0]);\n+}\n+\n+static long long\n+sse4a_test_inserti (long long in1, long long in2)\n+{\n+  __m128i v1,v2;\n+  long long pad = 0x0;\n+  LI v_out;\n+  v1 = _mm_set_epi64x (pad, in1);\n+  v2 = _mm_set_epi64x (pad, in2); \n+  v_out.vec = _mm_inserti_si64 (v1, v2, (unsigned int) 0x10, (unsigned int) 0x08);\n+  return (v_out.i[0]);  \n+}\n+\n+static chk (long long i1, long long i2)\n+{\n+  int n_fails =0;\n+  if (i1 != i2) \n+    n_fails +=1;\n+  return n_fails;\n+}\n+\n+long long vals_in1[5] =\n+  {\n+    0x1234567887654321,\n+    0x1456782093002490,\n+    0x2340909123990390,\n+    0x9595959599595999,\n+    0x9099038798000029\n+  };\n+\n+long long vals_in2[5] =\n+  {\n+    0x9ABCDEF00FEDCBA9,\n+    0x234567097289672A,\n+    0x45476453097BD342,\n+    0x23569012AE586FF0,\n+    0x432567ABCDEF765D\n+  };\n+\n+long long vals_out[5] =\n+  {\n+    0x1234567887CBA921,\n+    0x1456782093672A90,\n+    0x2340909123D34290,\n+    0x95959595996FF099,\n+    0x9099038798765D29\n+  };\n+\n+static void\n+sse4a_test (void)\n+{\n+  int i;\n+  int fail = 0;\n+  long long out;\n+\n+  for (i = 0; i < 5; i += 1)\n+    {\n+      out = sse4a_test_insert (vals_in1[i], vals_in2[i]);\n+      fail += chk(out, vals_out[i]);\n+\n+      out = sse4a_test_inserti (vals_in1[i], vals_in2[i]);\n+      fail += chk(out, vals_out[i]);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+\n+  exit (0);\n+}"}, {"sha": "e9be98e3bb8271e45ea53d798f775f5953b706a0", "filename": "gcc/testsuite/gcc.target/i386/sse4a-montsd.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-montsd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-montsd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-montsd.c?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse4a\" } */\n+#include <ammintrin.h>\n+#include <stdlib.h>\n+#include \"../../gcc.dg/i386-cpuid.h\"\n+\n+static void sse4a_test (void);\n+\n+int\n+main ()\n+{  \n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_extended_cpuid_ecx ();\n+\n+  /* Run SSE4a test only if host has SSE4a support.  */\n+  if ((cpu_facilities & bit_SSE4a))\n+    sse4a_test ();\n+\n+  exit (0);\n+}\n+  \n+static void \n+sse4a_test_movntsd (double *out, double *in)\n+{\n+  __m128d in_v2df = _mm_load_sd (in);\n+  _mm_stream_sd (out, in_v2df);\n+}\n+\n+static int \n+chk_sd (double *v1, double *v2)\n+{\n+  int n_fails = 0;\n+  if (v1[0] != v2[0])\n+    n_fails += 1;\n+  return n_fails;\n+}\n+\n+double vals[10] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, \n+    -1.0, .345, -21.5, 9.32,  8.41\n+  };\n+\n+static void\n+sse4a_test (void)\n+{\n+  int i;\n+  int fail = 0;\n+  double *out;\n+\n+  out = (double *) malloc (sizeof (double));\n+  for (i = 0; i < 10; i += 1)\n+    {\n+      sse4a_test_movntsd (out, &vals[i]);\n+      \n+      fail += chk_sd (out, &vals[i]);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+\n+  exit (0);\n+}"}, {"sha": "28ecb1cf3c0d61e284d2c66d2f5cc3abbf25fc6b", "filename": "gcc/testsuite/gcc.target/i386/sse4a-montss.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-montss.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21efb4d4640a4f96bcbe9244ad33580d80c582c7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-montss.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-montss.c?ref=21efb4d4640a4f96bcbe9244ad33580d80c582c7", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse4a\" } */\n+#include <ammintrin.h>\n+#include <stdlib.h>\n+#include \"../../gcc.dg/i386-cpuid.h\"\n+\n+static void sse4a_test (void);\n+\n+int\n+main ()\n+{  \n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_extended_cpuid_ecx ();\n+\n+  /* Run SSE4a test only if host has SSE4a support.  */\n+  if ((cpu_facilities & bit_SSE4a))\n+    sse4a_test ();\n+\n+  exit (0);\n+}\n+\n+static void \n+sse4a_test_movntss (float *out, float *in)\n+{\n+  __m128 in_v4sf = _mm_load_ss (in);\n+  _mm_stream_ss (out, in_v4sf);\n+}\n+\n+static int \n+chk_ss (float *v1, float *v2)\n+{\n+  int n_fails = 0;\n+  if (v1[0] != v2[0])\n+    n_fails += 1;\n+  return n_fails;\n+}\n+\n+float vals[10] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, \n+    -1.0, .345, -21.5, 9.32,  8.41\n+  };\n+\n+static void\n+sse4a_test (void)\n+{\n+  int i;\n+  int fail = 0;\n+  float *out;\n+\n+  out = (float *) malloc (sizeof (float));\n+  for (i = 0; i < 10; i += 1)\n+    {\n+      sse4a_test_movntss (out, &vals[i]);\n+      \n+      fail += chk_ss (out, &vals[i]);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+\n+  exit (0);\n+}"}]}