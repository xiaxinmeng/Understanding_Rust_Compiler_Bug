{"sha": "9a3ad294e0af5ed45b53c340382a7806fb150bdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEzYWQyOTRlMGFmNWVkNDViNTNjMzQwMzgyYTc4MDZmYjE1MGJkZg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-01-08T17:18:00Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-01-10T15:59:22Z"}, "message": "Add in a check for unused decls within ribs.\n\nThis lead to cleanup of the name resolver as the usage of mappings means\nthat in a given rib if there are no references to a decl NodeId that\nmeans it was not used.\n\nTo get on par with the offical rust compiler it should be allowed to have\na reference where the name was assigned but not used but this might be a seperate pass.", "tree": {"sha": "81458d62a2191b38be775026f2f8583d3ca7c2ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81458d62a2191b38be775026f2f8583d3ca7c2ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a3ad294e0af5ed45b53c340382a7806fb150bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a3ad294e0af5ed45b53c340382a7806fb150bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a3ad294e0af5ed45b53c340382a7806fb150bdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a3ad294e0af5ed45b53c340382a7806fb150bdf/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f42a240e53e932de0ae4799d54fe0bd15d06047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f42a240e53e932de0ae4799d54fe0bd15d06047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f42a240e53e932de0ae4799d54fe0bd15d06047"}], "stats": {"total": 199, "additions": 159, "deletions": 40}, "files": [{"sha": "e042ccbd9f7fd7be2307a9a44079b29a40226d0b", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -180,7 +180,7 @@ class CompileItem : public HIRCompileBase\n       }\n \n     std::vector<Bvariable *> locals;\n-    rib->iterate_decls ([&] (NodeId n) mutable -> bool {\n+    rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n       Resolver::Definition d;\n       bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n       rust_assert (ok);"}, {"sha": "374f8a091fd9ed7bc57da0de1316416f2f80463b", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -75,7 +75,7 @@ ResolvePathType::visit (HIR::PathInExpression &expr)\n {\n   // need to look up the reference for this identifier\n   NodeId ref_node_id;\n-  if (!ctx->get_resolver ()->lookup_resolved_name (\n+  if (!ctx->get_resolver ()->lookup_resolved_type (\n \texpr.get_mappings ().get_nodeid (), &ref_node_id))\n     {\n       rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");"}, {"sha": "3f8a962159f17e826c3da1c1b60a371478aed798", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -64,7 +64,7 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n     }\n \n   std::vector<Bvariable *> locals;\n-  rib->iterate_decls ([&] (NodeId n) mutable -> bool {\n+  rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n     Resolver::Definition d;\n     bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n     rust_assert (ok);"}, {"sha": "324d820e6b977fcc39ba545ecb357dbfcf876786", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -40,21 +40,27 @@ class ResolveExpr : public ResolverBase\n   void visit (AST::PathInExpression &expr)\n   {\n     // name scope first\n-    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n       {\n-\t// check the type scope\n-\tif (!resolver->get_type_scope ().lookup (expr.as_string (),\n+\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+    // check the type scope\n+    else if (resolver->get_type_scope ().lookup (expr.as_string (),\n \t\t\t\t\t\t &resolved_node))\n-\t  {\n-\t    rust_error_at (expr.get_locus (), \"unknown path %s\",\n-\t\t\t   expr.as_string ().c_str ());\n-\t    return;\n-\t  }\n+      {\n+\tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+    else\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown path %s\",\n+\t\t       expr.as_string ().c_str ());\n       }\n-\n-    resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-    resolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t     Definition{expr.get_node_id (), parent});\n   }\n \n   void visit (AST::ReturnExpr &expr)"}, {"sha": "b0b979f90bfaf4fac24e5e95de8cb05229889601", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-ast-resolve-type.h\"\n #include \"rust-ast-resolve-pattern.h\"\n #include \"rust-ast-resolve-stmt.h\"\n+#include \"rust-ast-resolve-unused.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -84,6 +85,9 @@ class ResolveItem : public ResolverBase\n     ResolveExpr::go (function.get_definition ().get (),\n \t\t     function.get_node_id ());\n \n+    ScanUnused::Scan (resolver->get_name_scope ().peek ());\n+    ScanUnused::Scan (resolver->get_type_scope ().peek ());\n+\n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n   }"}, {"sha": "c79f7d33493be49ac1097354e589b6d37f78af03", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -81,7 +81,8 @@ class PatternDeclaration : public ResolverBase\n     // if we have a duplicate id this then allows for shadowing correctly\n     // as new refs to this decl will match back here so it is ok to overwrite\n     resolver->get_name_scope ().insert (pattern.get_ident (),\n-\t\t\t\t\tpattern.get_node_id ());\n+\t\t\t\t\tpattern.get_node_id (),\n+\t\t\t\t\tpattern.get_locus ());\n     resolver->insert_new_definition (pattern.get_node_id (),\n \t\t\t\t     Definition{pattern.get_node_id (),\n \t\t\t\t\t\tparent});"}, {"sha": "447fe4bd78669e09301817d696ea628c36db27f2", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -39,13 +39,14 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::StructStruct &struct_decl)\n   {\n     resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n-\t\t\t\t\tstruct_decl.get_node_id ());\n+\t\t\t\t\tstruct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_locus ());\n   }\n \n   void visit (AST::StaticItem &var)\n   {\n     resolver->get_name_scope ().insert (var.get_identifier (),\n-\t\t\t\t\tvar.get_node_id ());\n+\t\t\t\t\tvar.get_node_id (), var.get_locus ());\n     resolver->insert_new_definition (var.get_node_id (),\n \t\t\t\t     Definition{var.get_node_id (),\n \t\t\t\t\t\tvar.get_node_id ()});\n@@ -54,18 +55,26 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::ConstantItem &constant)\n   {\n     resolver->get_name_scope ().insert (constant.get_identifier (),\n-\t\t\t\t\tconstant.get_node_id ());\n+\t\t\t\t\tconstant.get_node_id (),\n+\t\t\t\t\tconstant.get_locus ());\n     resolver->insert_new_definition (constant.get_node_id (),\n \t\t\t\t     Definition{constant.get_node_id (),\n \t\t\t\t\t\tconstant.get_node_id ()});\n   }\n \n   void visit (AST::Function &function)\n   {\n-    // function_names are simple std::String identifiers so this can be a\n-    // NodeId mapping to the Function node\n     resolver->get_name_scope ().insert (function.get_function_name (),\n+\t\t\t\t\tfunction.get_node_id (),\n+\t\t\t\t\tfunction.get_locus ());\n+\n+    // if this does not get a reference it will be determined to be unused\n+    // lets give it a fake reference to itself\n+    if (function.get_function_name ().compare (\"main\") == 0)\n+      {\n+\tresolver->insert_resolved_name (function.get_node_id (),\n \t\t\t\t\tfunction.get_node_id ());\n+      }\n   }\n \n private:"}, {"sha": "8ec3a9c30aea00c17ed2a7ead99831d15cad0570", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -46,7 +46,6 @@ class ResolveType : public ResolverBase\n   {\n     // this will need changed to handle mod/crate/use globs and look\n     // at the segments in granularity\n-    locus = path.get_locus ();\n     if (resolver->get_type_scope ().lookup (path.as_string (), &resolved_node))\n       {\n \tresolver->insert_resolved_type (path.get_node_id (), resolved_node);"}, {"sha": "08b2db1f4f91c921440daf05a377aa80fbd3347d", "filename": "gcc/rust/resolve/rust-ast-resolve-unused.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_UNUSED_H\n+#define RUST_AST_RESOLVE_UNUSED_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ScanUnused : public ResolverBase\n+{\n+public:\n+  static void Scan (Rib *r)\n+  {\n+    r->iterate_decls ([&] (NodeId decl_node_id, Location locus) -> bool {\n+      if (!r->have_references_for_node (decl_node_id))\n+\t{\n+\t  rust_warning_at (locus, 0, \"unused name\");\n+\t}\n+      return true;\n+    });\n+  }\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_UNUSED_H"}, {"sha": "d6eed9394cf908a4fb22e82d848b4e920296741c", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-ast-resolve-toplevel.h\"\n #include \"rust-ast-resolve-item.h\"\n #include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-unused.h\"\n \n #define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n   do                                                                           \\\n@@ -107,8 +108,9 @@ void\n Resolver::insert_builtin_types (Rib *r)\n {\n   auto builtins = get_builtin_types ();\n-  for (auto it = builtins.begin (); it != builtins.end (); it++)\n-    r->insert_name ((*it)->as_string (), (*it)->get_node_id ());\n+  for (auto &builtin : builtins)\n+    r->insert_name (builtin->as_string (), builtin->get_node_id (),\n+\t\t    Linemap::predeclared_location ());\n }\n \n std::vector<AST::TypePath *> &\n@@ -187,7 +189,7 @@ Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n   rust_assert (it == resolved_names.end ());\n \n   resolved_names[refId] = defId;\n-  get_name_scope ().peek ()->append_reference_for_def (defId, refId);\n+  get_name_scope ().append_reference_for_def (refId, defId);\n }\n \n bool\n@@ -208,7 +210,7 @@ Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n   rust_assert (it == resolved_types.end ());\n \n   resolved_types[refId] = defId;\n-  get_type_scope ().peek ()->append_reference_for_def (defId, refId);\n+  get_type_scope ().append_reference_for_def (refId, defId);\n }\n \n bool\n@@ -267,6 +269,9 @@ NameResolution::go (AST::Crate &crate)\n   // next we can drill down into the items and their scopes\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     ResolveItem::go (it->get ());\n+\n+  ScanUnused::Scan (resolver->get_name_scope ().peek ());\n+  ScanUnused::Scan (resolver->get_type_scope ().peek ());\n }\n \n // rust-ast-resolve-expr.h\n@@ -288,6 +293,9 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   if (expr.has_tail_expr ())\n     ResolveExpr::go (expr.get_tail_expr ().get (), expr.get_node_id ());\n \n+  ScanUnused::Scan (resolver->get_name_scope ().peek ());\n+  ScanUnused::Scan (resolver->get_type_scope ().peek ());\n+\n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n }"}, {"sha": "515ebfd674251f4730723d60fd4a3699cfdfe705", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -37,10 +37,10 @@ class Rib\n \n   ~Rib () {}\n \n-  void insert_name (std::string ident, NodeId id)\n+  void insert_name (std::string ident, NodeId id, Location locus)\n   {\n     mappings[ident] = id;\n-    decls_within_rib.insert (id);\n+    decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n     references[id] = {};\n   }\n \n@@ -57,11 +57,11 @@ class Rib\n   CrateNum get_crate_num () const { return crate_num; }\n   NodeId get_node_id () const { return node_id; }\n \n-  void iterate_decls (std::function<bool (NodeId)> cb)\n+  void iterate_decls (std::function<bool (NodeId, Location)> cb)\n   {\n     for (auto it : decls_within_rib)\n       {\n-\tif (!cb (it))\n+\tif (!cb (it.first, it.second))\n \t  return;\n       }\n   }\n@@ -84,11 +84,30 @@ class Rib\n     references[def].insert (ref);\n   }\n \n+  bool have_references_for_node (NodeId def) const\n+  {\n+    auto it = references.find (def);\n+    if (it == references.end ())\n+      return false;\n+\n+    return !it->second.empty ();\n+  }\n+\n+  bool decl_was_declared_here (NodeId def) const\n+  {\n+    for (auto &it : decls_within_rib)\n+      {\n+\tif (it.first == def)\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n private:\n   CrateNum crate_num;\n   NodeId node_id;\n   std::map<std::string, NodeId> mappings;\n-  std::set<NodeId> decls_within_rib;\n+  std::set<std::pair<NodeId, Location> > decls_within_rib;\n   std::map<NodeId, std::set<NodeId> > references;\n };\n \n@@ -98,9 +117,9 @@ class Scope\n   Scope (CrateNum crate_num) : crate_num (crate_num) {}\n   ~Scope () {}\n \n-  void insert (std::string ident, NodeId id)\n+  void insert (std::string ident, NodeId id, Location locus)\n   {\n-    peek ()->insert_name (ident, id);\n+    peek ()->insert_name (ident, id, locus);\n   }\n \n   bool lookup (std::string ident, NodeId *id)\n@@ -138,6 +157,21 @@ class Scope\n \n   CrateNum get_crate_num () const { return crate_num; }\n \n+  void append_reference_for_def (NodeId refId, NodeId defId)\n+  {\n+    bool ok = false;\n+    iterate ([&] (Rib *r) mutable -> bool {\n+      if (r->decl_was_declared_here (defId))\n+\t{\n+\t  ok = true;\n+\t  r->append_reference_for_def (defId, refId);\n+\t  return false;\n+\t}\n+      return true;\n+    });\n+    rust_assert (ok);\n+  }\n+\n private:\n   CrateNum crate_num;\n   std::vector<Rib *> stack;"}, {"sha": "8fa6714143e347c2a8d41f790d835c6b4b347b4a", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -140,10 +140,13 @@ TypeCheckStructExpr::visit (HIR::PathInExpression &expr)\n   NodeId ref_node_id;\n   if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n     {\n-      rust_error_at (expr.get_locus (),\n-\t\t     \"Failed to lookup reference for node: %s\",\n-\t\t     expr.as_string ().c_str ());\n-      return;\n+      if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"Failed to lookup reference for node: %s\",\n+\t\t\t expr.as_string ().c_str ());\n+\t  return;\n+\t}\n     }\n \n   // node back to HIR"}, {"sha": "22c3c9164f60e1c3d8afa1d7313188c09e213b81", "filename": "gcc/rust/typecheck/rust-tyty-resolver.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -44,7 +44,7 @@ class TyTyResolver\n \n   void go (Rib *rib)\n   {\n-    rib->iterate_decls ([&] (NodeId decl_node_id) mutable -> bool {\n+    rib->iterate_decls ([&] (NodeId decl_node_id, Location) mutable -> bool {\n       // type inference in rust means we need to gather and examine all\n       // references of this decl and combine each to make sure the type is\n       // correctly inferred. Consider the example:"}, {"sha": "0fea50144f799c55eb586bc467ddcc9206d86d9f", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -331,8 +331,6 @@ Mappings::insert_hir_param (CrateNum crateNum, HirId id,\n {\n   rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n \n-  printf (\"inserting param with node id %u hir id: %u\\n\",\n-\t  param->get_mappings ()->get_nodeid (), id);\n   hirParamMappings[crateNum][id] = param;\n   nodeIdToHirMappings[crateNum][param->get_mappings ()->get_nodeid ()] = id;\n }"}, {"sha": "cb501885f5b816989c372293e3eb38b8479d4928", "filename": "gcc/testsuite/rust.test/compilable/unused1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funused1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3ad294e0af5ed45b53c340382a7806fb150bdf/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funused1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funused1.rs?ref=9a3ad294e0af5ed45b53c340382a7806fb150bdf", "patch": "@@ -0,0 +1,12 @@\n+fn test() -> i32 {\n+    1\n+}\n+\n+fn unused() -> i32 {\n+    2\n+}\n+\n+fn main() {\n+    let a = 1;\n+    let b = test();\n+}"}]}