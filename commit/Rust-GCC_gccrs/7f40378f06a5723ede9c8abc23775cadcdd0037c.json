{"sha": "7f40378f06a5723ede9c8abc23775cadcdd0037c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0MDM3OGYwNmE1NzIzZWRlOWM4YWJjMjM3NzVjYWRjZGQwMDM3Yw==", "commit": {"author": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2007-02-15T17:25:24Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2007-02-15T17:25:24Z"}, "message": "Make-lang.in (JAVA_MANFILES): Add doc/gc-analyze.1.\n\ngcc/java:\n2007-02-15  David Daney  <ddaney@avtrex.com>\n\n\t* Make-lang.in (JAVA_MANFILES): Add doc/gc-analyze.1.\n\t(java.maintainer-clean):Add gc-analyze.1.\n\t(.INTERMEDIATE): Add gc-analyze.pod.\n\t(gc-analyze.pod): New rule.\n\t(java.install-man): Install gc-analyze.1\n\t* gcj.texi: Add new section for the gc-analyze program.\n\nlibjava:\n2007-02-15  Johannes Schmidt  <jschmidt@avtrex.com>\n\tDavid Daney  <ddaney@avtrex.com>\n\n\t* configure.ac: Create vm-tools-packages file.  Add \n\tgnu/gcj/tools/gc_analyze to standard.omit and vm-tools-packages.\n\tCheck for /proc/self/maps.\n\t* Makefile.am (bin_PROGRAMS): Added gc-analyze.\n\t(gc_analyze_SOURCES): New.\n\t(gc_analyze_LDFLAGS): New.\n\t(gc_analyze_LINK): New.\n\t(gc_analyze_LDADD): New.\n\t(gc_analyze_DEPENDENCIES): New.\n\t(nat_source_files): Add gnu/gcj/util/natGCInfo.cc.\n\t* Makefile.in: Regenerated.\n\t* configure: Regenerated.\n\t* include/config.h.in: Regenerated.\n\t* sources.am: Regenerated.\n\t* scripts/makemake.tcl: Don't include gc-analyze classes in libgcj.\n\t* gnu/gcj/tools/gc_analyze/SymbolLookup.java: New.\n\t* gnu/gcj/tools/gc_analyze/ObjectMap.java: New.\n\t* gnu/gcj/tools/gc_analyze/MemoryMap.java: New.\n\t* gnu/gcj/tools/gc_analyze/SymbolTable.java: New.\n\t* gnu/gcj/tools/gc_analyze/BlockMap.java: New.\n\t* gnu/gcj/tools/gc_analyze/BytePtr.java: New.\n\t* gnu/gcj/tools/gc_analyze/ItemList.java: New.\n\t* gnu/gcj/tools/gc_analyze/ToolPrefix.java: New.\n\t* gnu/gcj/tools/gc_analyze/MemoryAnalyze.java: New.\n\t* gnu/gcj/util/GCInfo.java: New.\n\t* gnu/gcj/util/GCInfo.h: New.\n\t* gnu/gcj/util/natGCInfo.cc: New.\n\t* gnu/gcj/util/UtilPermission.java: New.\n\t* gnu/gcj/util/UtilPermission.h: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/SymbolTable.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/ObjectMap$ObjectItem.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryMap$RangeComparator.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/BlockMap$PtrMarks.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryMap$Range.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/BlockMap.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/BytePtr.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$SubstringComparator.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/ItemList.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/ToolPrefix.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$1$Info.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$1.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$2.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$3.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$4.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$OptionParser.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/BlockMap$SizeKind.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/SymbolLookup.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/ObjectMap.class: New.\n\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryMap.class: New.\n\t* classpath/lib/gnu/gcj/util/GCInfo.class: New.\n\t* classpath/lib/gnu/gcj/util/UtilPermission.class: New.\n\nlibjava/classpath:\n2007-02-15  David Daney  <ddaney@avtrex.com>\n\n\t* tools/Makefile.am (TOOLS_ZIP): Add classes from vm-tools-packages.\n\t* tools/Makefile.in: Regenerated.\n\nFrom-SVN: r122007", "tree": {"sha": "ecd80f4d6cba05c29ed9420459814c84387b36bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd80f4d6cba05c29ed9420459814c84387b36bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f40378f06a5723ede9c8abc23775cadcdd0037c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f40378f06a5723ede9c8abc23775cadcdd0037c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f40378f06a5723ede9c8abc23775cadcdd0037c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f40378f06a5723ede9c8abc23775cadcdd0037c/comments", "author": null, "committer": null, "parents": [{"sha": "31429fbc3c70716cb375dc73d1d151ed769d945e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31429fbc3c70716cb375dc73d1d151ed769d945e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31429fbc3c70716cb375dc73d1d151ed769d945e"}], "stats": {"total": 2822, "additions": 2783, "deletions": 39}, "files": [{"sha": "f9ef73fb28e414e191ffa1071cea66139ac05878", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -1,3 +1,12 @@\n+2007-02-15  David Daney  <ddaney@avtrex.com>\n+\n+\t* Make-lang.in (JAVA_MANFILES): Add doc/gc-analyze.1.\n+\t(java.maintainer-clean):Add gc-analyze.1.\n+\t(.INTERMEDIATE): Add gc-analyze.pod.\n+\t(gc-analyze.pod): New rule.\n+\t(java.install-man): Install gc-analyze.1\n+\t* gcj.texi: Add new section for the gc-analyze program.\n+\n 2007-02-07  Andrew Haley  <aph@redhat.com>\n \n \t* class.c (uncache_this_class_ref): New."}, {"sha": "a2024948a711b76b49ab2c75736a3640470b7451", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -139,7 +139,7 @@ java.pdf: doc/gcj.pdf\n java.html: $(build_htmldir)/java/index.html\n JAVA_MANFILES = doc/gcj.1 doc/jcf-dump.1 doc/gij.1 \\\n                 doc/jv-convert.1 doc/grmic.1 doc/grmiregistry.1 \\\n-\t\tdoc/gcj-dbtool.1\n+\t\tdoc/gcj-dbtool.1 doc/gc-analyze.1\n \n java.man: $(JAVA_MANFILES)\n \n@@ -208,6 +208,7 @@ java.maintainer-clean:\n \t-rm -f $(docobjdir)/grmic.1\n \t-rm -f $(docobjdir)/grmiregistry.1\n \t-rm -f $(docobjdir)/gcj-dbtool.1\n+\t-rm -f $(docobjdir)/gc-analyze.1\n #\f\n # Stage hooks:\n # The main makefile has already created stage?/java.\n@@ -318,7 +319,7 @@ $(build_htmldir)/java/index.html: $(TEXI_JAVA_FILES)\n \t$(TEXI2HTML) -I $(gcc_docdir)/include -I $(srcdir)/java -o $(@D) $<\n \n .INTERMEDIATE: gcj.pod jcf-dump.pod gij.pod \\\n-  jv-convert.pod grmic.pod grmiregistry.pod gcj-dbtool.pod\n+  jv-convert.pod grmic.pod grmiregistry.pod gcj-dbtool.pod gc-analyze.pod\n \n gcj.pod: java/gcj.texi\n \t-$(TEXI2POD) -D gcj < $< > $@\n@@ -334,15 +335,17 @@ grmiregistry.pod: java/gcj.texi\n \t-$(TEXI2POD) -D grmiregistry < $< > $@\n gcj-dbtool.pod: java/gcj.texi\n \t-$(TEXI2POD) -D gcj-dbtool < $< > $@\n+gc-analyze.pod: java/gcj.texi\n+\t-$(TEXI2POD) -D gc-analyze < $< > $@\n \n # Install the man pages.\n java.install-man: installdirs \\\n                   $(DESTDIR)$(man1dir)/$(JAVA_INSTALL_NAME)$(man1ext) \\\n \t\t  $(JAVA_TARGET_INDEPENDENT_BIN_TOOLS:%=doc/%.1) \\\n \t\t  doc/gij.1 doc/jv-convert.1 doc/grmic.1 doc/grmiregistry.1 \\\n-\t\t  doc/gcj-dbtool.1\n+\t\t  doc/gcj-dbtool.1 doc/gc-analyze.1\n \tfor tool in $(JAVA_TARGET_INDEPENDENT_BIN_TOOLS) \\\n-\t\tgij jv-convert grmic grmiregistry gcj-dbtool ; do \\\n+\t\tgij jv-convert grmic grmiregistry gcj-dbtool gc-analyze ; do \\\n \t  tool_transformed_name=`echo $$tool|sed '$(program_transform_name)'`; \\\n \t  man_name=$(DESTDIR)$(man1dir)/$${tool_transformed_name}$(man1ext); \\\n \t  rm -f $$man_name ; \\"}, {"sha": "8bd9d5bcfb68814d69204eea03ba28eaeed45fe1", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -17,7 +17,7 @@\n @c the word ``Java'.\n \n @c When this manual is copyrighted.\n-@set copyrights-gcj 2001, 2002, 2003, 2004, 2005\n+@set copyrights-gcj 2001, 2002, 2003, 2004, 2005, 2006, 2007\n \n @c Versions\n @set which-gcj GCC-@value{version-GCC}\n@@ -79,6 +79,8 @@ man page gfdl(7).\n                             Generate stubs for Remote Method Invocation.\n * grmiregistry: (gcj)Invoking grmiregistry.\n                             The remote object registry.\n+* gc-analyze: (gcj)Invoking gc-analyze.\n+                            Analyze Garbage Collector (GC) memory dumps.\n @end direntry\n @end format\n \n@@ -125,6 +127,7 @@ files and object files, and it can read both Java source code and\n * Invoking jv-convert:: Converting from one encoding to another\n * Invoking grmic::      Generate stubs for Remote Method Invocation.\n * Invoking grmiregistry:: The remote object registry.\n+* Invoking gc-analyze:: Analyze Garbage Collector (GC) memory dumps.\n * About CNI::           Description of the Compiled Native Interface\n * System properties::   Modifying runtime behavior of the libgcj library\n * Resources::\t\tWhere to look for more information\n@@ -1412,6 +1415,89 @@ Print version information, then exit.\n @c man end\n \n \n+@node Invoking gc-analyze\n+@chapter Invoking gc-analyze\n+\n+@c man title gc-analyze Analyze Garbage Collector (GC) memory dumps\n+\n+@c man begin SYNOPSIS gc-analyze\n+@command{gc-analyze} [@option{OPTION}] @dots{} [@var{file}]\n+@ignore\n+  [@option{-v}]\n+  [@option{--verbose}]\n+  [@option{-p} @var{tool-prefix}]\n+  [@option{-d} @var{directory}]\n+  [@option{--version}]\n+  [@option{--help}]\n+@end ignore\n+@c man end\n+\n+@c man begin DESCRIPTION gc-analyze\n+\n+@command{gc-analyze} prints an analysis of a GC memory dump to\n+standard out.\n+\n+The memory dumps may be created by calling\n+@code{gnu.gcj.util.GCInfo.enumerate(String namePrefix)} from java\n+code.  A memory dump will be created on an out of memory condition if\n+@code{gnu.gcj.util.GCInfo.setOOMDump(String namePrefix)} is called\n+before the out of memory occurs.\n+\n+Running this program will create two files: @file{TestDump001} and\n+@file{TestDump001.bytes}.\n+\n+@example\n+import gnu.gcj.util.*;\n+import java.util.*;\n+\n+public class GCDumpTest\n+@{\n+    static public void main(String args[])\n+    @{\n+        ArrayList<String> l = new ArrayList<String>(1000);\n+        \n+        for (int i = 1; i < 1500; i++) @{\n+            l.add(\"This is string #\" + i);\n+        @}\n+        GCInfo.enumerate(\"TestDump\");\n+    @}\n+@}\n+@end example\n+\n+The memory dump may then be displayed by running:\n+\n+@example\n+gc-analyze -v TestDump001\n+@end example\n+\n+@c FIXME: Add real information here.\n+@c This really isn't much more than the --help output.\n+\n+@c man end\n+\n+@c man begin OPTIONS gc-analyze\n+\n+@table @gcctabopt\n+@item --verbose\n+@itemx -v\n+Verbose output.\n+\n+@item -p @var{tool-prefix}\n+Prefix added to the names of the @command{nm} and @command{readelf} commands.\n+\n+@item -d @var{directory}\n+Directory that contains the executable and shared libraries used when\n+the dump was generated.\n+\n+@item --help\n+Print a help message, then exit.\n+\n+@item --version\n+Print version information, then exit.\n+@end table\n+\n+@c man end\n+\n @node About CNI\n @chapter About CNI\n "}, {"sha": "9d4406f32fe6441d7a7ca66ba5d5804ca181bacd", "filename": "libjava/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -1,3 +1,59 @@\n+2007-02-15  Johannes Schmidt  <jschmidt@avtrex.com>\n+\tDavid Daney  <ddaney@avtrex.com>\n+\n+\t* configure.ac: Create vm-tools-packages file.  Add \n+\tgnu/gcj/tools/gc_analyze to standard.omit and vm-tools-packages.\n+\tCheck for /proc/self/maps.\n+\t* Makefile.am (bin_PROGRAMS): Added gc-analyze.\n+\t(gc_analyze_SOURCES): New.\n+\t(gc_analyze_LDFLAGS): New.\n+\t(gc_analyze_LINK): New.\n+\t(gc_analyze_LDADD): New.\n+\t(gc_analyze_DEPENDENCIES): New.\n+\t(nat_source_files): Add gnu/gcj/util/natGCInfo.cc.\n+\t* Makefile.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* include/config.h.in: Regenerated.\n+\t* sources.am: Regenerated.\n+\t* scripts/makemake.tcl: Don't include gc-analyze classes in libgcj.\n+\t* gnu/gcj/tools/gc_analyze/SymbolLookup.java: New.\n+\t* gnu/gcj/tools/gc_analyze/ObjectMap.java: New.\n+\t* gnu/gcj/tools/gc_analyze/MemoryMap.java: New.\n+\t* gnu/gcj/tools/gc_analyze/SymbolTable.java: New.\n+\t* gnu/gcj/tools/gc_analyze/BlockMap.java: New.\n+\t* gnu/gcj/tools/gc_analyze/BytePtr.java: New.\n+\t* gnu/gcj/tools/gc_analyze/ItemList.java: New.\n+\t* gnu/gcj/tools/gc_analyze/ToolPrefix.java: New.\n+\t* gnu/gcj/tools/gc_analyze/MemoryAnalyze.java: New.\n+\t* gnu/gcj/util/GCInfo.java: New.\n+\t* gnu/gcj/util/GCInfo.h: New.\n+\t* gnu/gcj/util/natGCInfo.cc: New.\n+\t* gnu/gcj/util/UtilPermission.java: New.\n+\t* gnu/gcj/util/UtilPermission.h: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/SymbolTable.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/ObjectMap$ObjectItem.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryMap$RangeComparator.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/BlockMap$PtrMarks.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryMap$Range.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/BlockMap.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/BytePtr.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$SubstringComparator.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/ItemList.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/ToolPrefix.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$1$Info.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$1.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$2.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$3.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$4.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryAnalyze$OptionParser.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/BlockMap$SizeKind.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/SymbolLookup.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/ObjectMap.class: New.\n+\t* classpath/tools/gnu/gcj/tools/gc_analyze/MemoryMap.class: New.\n+\t* classpath/lib/gnu/gcj/util/GCInfo.class: New.\n+\t* classpath/lib/gnu/gcj/util/UtilPermission.class: New.\n+\n 2007-02-15  David Daney  <ddaney@avtrex.com>\n \n \t* gnu/java/net/PlainSocketImpl.h: Regenerate."}, {"sha": "7c700e109294a4f66e3bad767e3157171f40a7f3", "filename": "libjava/Makefile.am", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -73,7 +73,7 @@ db_pathtail = gcj-$(gcc_version)/$(db_name)\n if NATIVE\n bin_PROGRAMS = jv-convert gij grmic grmiregistry gcj-dbtool \\\n \tgappletviewer gjarsigner gkeytool gjar gjavah gnative2ascii \\\n-\tgorbd grmid gserialver gtnameserv\n+\tgorbd grmid gserialver gtnameserv gc-analyze\n \n ## It is convenient to actually build and install the default database\n ## when gcj-dbtool is available.\n@@ -647,6 +647,20 @@ gcj_dbtool_LDADD = gnu/gcj/tools/gcj_dbtool.lo -L$(here)/.libs libgcj.la\n ## linking this program.\n gcj_dbtool_DEPENDENCIES = gnu/gcj/tools/gcj_dbtool.lo libgcj.la libgcj.spec\n \n+gc_analyze_SOURCES =\n+\n+## We need -nodefaultlibs because we want to avoid gcj's `-lgcj'.  We\n+## need this because we are explicitly using libtool to link using the\n+## `.la' file.\n+gc_analyze_LDFLAGS = --main=gnu.gcj.tools.gc_analyze.MemoryAnalyze \\\n+        -rpath $(toolexeclibdir) -shared-libgcc $(THREADLDFLAGS)\n+gc_analyze_LINK = $(GCJLINK)\n+## See jv_convert_LDADD.\n+gc_analyze_LDADD = -L$(here)/.libs libgcj-tools.la libgcj.la\n+## Depend on the spec file to make sure it is up to date before\n+## linking this program.\n+gc_analyze_DEPENDENCIES = libgcj-tools.la libgcj.la libgcj.spec\n+\n gij_SOURCES = \n ## We need -nodefaultlibs because we want to avoid gcj's `-lgcj'.  We\n ## need this because we are explicitly using libtool to link using the\n@@ -831,6 +845,7 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natSystemClassLoader.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/util/natDebug.cc \\\n+gnu/gcj/util/natGCInfo.cc \\\n gnu/java/lang/natMainThread.cc \\\n gnu/java/lang/management/natVMClassLoadingMXBeanImpl.cc \\\n gnu/java/lang/management/natVMCompilationMXBeanImpl.cc \\"}, {"sha": "b7cfb00aab7619a022fe472fe65648e4cc3b36fa", "filename": "libjava/Makefile.in", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -51,7 +51,7 @@ target_triplet = @target@\n @NATIVE_TRUE@\tgjar$(EXEEXT) gjavah$(EXEEXT) \\\n @NATIVE_TRUE@\tgnative2ascii$(EXEEXT) gorbd$(EXEEXT) \\\n @NATIVE_TRUE@\tgrmid$(EXEEXT) gserialver$(EXEEXT) \\\n-@NATIVE_TRUE@\tgtnameserv$(EXEEXT)\n+@NATIVE_TRUE@\tgtnameserv$(EXEEXT) gc-analyze$(EXEEXT)\n @BUILD_ECJ1_TRUE@libexecsub_PROGRAMS = ecjx$(EXEEXT)\n @ANONVERSCRIPT_TRUE@am__append_5 = -Wl,--version-script=$(srcdir)/libgcj.ver\n @USING_GCC_TRUE@am__append_6 = $(WARNINGS)\n@@ -305,7 +305,7 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc jvmti.cc exception.cc \\\n \tgnu/gcj/runtime/natSharedLibLoader.cc \\\n \tgnu/gcj/runtime/natSystemClassLoader.cc \\\n \tgnu/gcj/runtime/natStringBuffer.cc gnu/gcj/util/natDebug.cc \\\n-\tgnu/java/lang/natMainThread.cc \\\n+\tgnu/gcj/util/natGCInfo.cc gnu/java/lang/natMainThread.cc \\\n \tgnu/java/lang/management/natVMClassLoadingMXBeanImpl.cc \\\n \tgnu/java/lang/management/natVMCompilationMXBeanImpl.cc \\\n \tgnu/java/lang/management/natVMGarbageCollectorMXBeanImpl.cc \\\n@@ -368,7 +368,7 @@ am__objects_2 = gnu/classpath/jdwp/natVMFrame.lo \\\n \tgnu/gcj/runtime/natSharedLibLoader.lo \\\n \tgnu/gcj/runtime/natSystemClassLoader.lo \\\n \tgnu/gcj/runtime/natStringBuffer.lo gnu/gcj/util/natDebug.lo \\\n-\tgnu/java/lang/natMainThread.lo \\\n+\tgnu/gcj/util/natGCInfo.lo gnu/java/lang/natMainThread.lo \\\n \tgnu/java/lang/management/natVMClassLoadingMXBeanImpl.lo \\\n \tgnu/java/lang/management/natVMCompilationMXBeanImpl.lo \\\n \tgnu/java/lang/management/natVMGarbageCollectorMXBeanImpl.lo \\\n@@ -438,6 +438,8 @@ am_ecjx_OBJECTS =\n ecjx_OBJECTS = $(am_ecjx_OBJECTS)\n am_gappletviewer_OBJECTS =\n gappletviewer_OBJECTS = $(am_gappletviewer_OBJECTS)\n+am_gc_analyze_OBJECTS =\n+gc_analyze_OBJECTS = $(am_gc_analyze_OBJECTS)\n am_gcj_dbtool_OBJECTS = gnu/gcj/tools/gcj_dbtool/natMain.$(OBJEXT)\n gcj_dbtool_OBJECTS = $(am_gcj_dbtool_OBJECTS)\n am__gen_from_JIS_SOURCES_DIST = gnu/gcj/convert/gen-from-JIS.c \\\n@@ -501,23 +503,23 @@ SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) $(libgcj_tools_la_SOURCES) \\\n \t$(libgcj_la_SOURCES) $(EXTRA_libgcj_la_SOURCES) \\\n \t$(libgcj_bc_la_SOURCES) $(libgij_la_SOURCES) \\\n \t$(libjvm_la_SOURCES) $(ecjx_SOURCES) $(gappletviewer_SOURCES) \\\n-\t$(gcj_dbtool_SOURCES) $(gen_from_JIS_SOURCES) $(gij_SOURCES) \\\n-\t$(gjar_SOURCES) $(gjarsigner_SOURCES) $(gjavah_SOURCES) \\\n-\t$(gkeytool_SOURCES) $(gnative2ascii_SOURCES) $(gorbd_SOURCES) \\\n-\t$(grmic_SOURCES) $(grmid_SOURCES) $(grmiregistry_SOURCES) \\\n-\t$(gserialver_SOURCES) $(gtnameserv_SOURCES) \\\n-\t$(jv_convert_SOURCES)\n+\t$(gc_analyze_SOURCES) $(gcj_dbtool_SOURCES) \\\n+\t$(gen_from_JIS_SOURCES) $(gij_SOURCES) $(gjar_SOURCES) \\\n+\t$(gjarsigner_SOURCES) $(gjavah_SOURCES) $(gkeytool_SOURCES) \\\n+\t$(gnative2ascii_SOURCES) $(gorbd_SOURCES) $(grmic_SOURCES) \\\n+\t$(grmid_SOURCES) $(grmiregistry_SOURCES) $(gserialver_SOURCES) \\\n+\t$(gtnameserv_SOURCES) $(jv_convert_SOURCES)\n DIST_SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) \\\n \t$(libgcj_tools_la_SOURCES) $(am__libgcj_la_SOURCES_DIST) \\\n \t$(EXTRA_libgcj_la_SOURCES) $(libgcj_bc_la_SOURCES) \\\n \t$(libgij_la_SOURCES) $(libjvm_la_SOURCES) $(ecjx_SOURCES) \\\n-\t$(gappletviewer_SOURCES) $(gcj_dbtool_SOURCES) \\\n-\t$(am__gen_from_JIS_SOURCES_DIST) $(gij_SOURCES) \\\n-\t$(gjar_SOURCES) $(gjarsigner_SOURCES) $(gjavah_SOURCES) \\\n-\t$(gkeytool_SOURCES) $(gnative2ascii_SOURCES) $(gorbd_SOURCES) \\\n-\t$(grmic_SOURCES) $(grmid_SOURCES) $(grmiregistry_SOURCES) \\\n-\t$(gserialver_SOURCES) $(gtnameserv_SOURCES) \\\n-\t$(jv_convert_SOURCES)\n+\t$(gappletviewer_SOURCES) $(gc_analyze_SOURCES) \\\n+\t$(gcj_dbtool_SOURCES) $(am__gen_from_JIS_SOURCES_DIST) \\\n+\t$(gij_SOURCES) $(gjar_SOURCES) $(gjarsigner_SOURCES) \\\n+\t$(gjavah_SOURCES) $(gkeytool_SOURCES) $(gnative2ascii_SOURCES) \\\n+\t$(gorbd_SOURCES) $(grmic_SOURCES) $(grmid_SOURCES) \\\n+\t$(grmiregistry_SOURCES) $(gserialver_SOURCES) \\\n+\t$(gtnameserv_SOURCES) $(jv_convert_SOURCES)\n RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \thtml-recursive info-recursive install-data-recursive \\\n \tinstall-exec-recursive install-info-recursive \\\n@@ -1344,7 +1346,9 @@ gnu/gcj/tools/gcj_dbtool/Main.java\n \n gnu_gcj_tools_gcj_dbtool_header_files = $(patsubst %.java,%.h,$(gnu_gcj_tools_gcj_dbtool_source_files))\n gnu_gcj_util_source_files = \\\n-gnu/gcj/util/Debug.java\n+gnu/gcj/util/Debug.java \\\n+gnu/gcj/util/GCInfo.java \\\n+gnu/gcj/util/UtilPermission.java\n \n gnu_gcj_util_header_files = $(patsubst %.java,%.h,$(gnu_gcj_util_source_files))\n gnu_gcj_xlib_source_files = \\\n@@ -7818,6 +7822,13 @@ gcj_dbtool_LDFLAGS = --main=gnu.gcj.tools.gcj_dbtool.Main \\\n gcj_dbtool_LINK = $(GCJLINK)\n gcj_dbtool_LDADD = gnu/gcj/tools/gcj_dbtool.lo -L$(here)/.libs libgcj.la\n gcj_dbtool_DEPENDENCIES = gnu/gcj/tools/gcj_dbtool.lo libgcj.la libgcj.spec\n+gc_analyze_SOURCES = \n+gc_analyze_LDFLAGS = --main=gnu.gcj.tools.gc_analyze.MemoryAnalyze \\\n+        -rpath $(toolexeclibdir) -shared-libgcc $(THREADLDFLAGS)\n+\n+gc_analyze_LINK = $(GCJLINK)\n+gc_analyze_LDADD = -L$(here)/.libs libgcj-tools.la libgcj.la\n+gc_analyze_DEPENDENCIES = libgcj-tools.la libgcj.la libgcj.spec\n gij_SOURCES = \n gij_LDFLAGS = -rpath $(libdir)/gcj-$(gcc_version) -rpath $(toolexeclibdir) \\\n \t-shared-libgcc $(THREADLDFLAGS)\n@@ -7947,6 +7958,7 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natSystemClassLoader.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/util/natDebug.cc \\\n+gnu/gcj/util/natGCInfo.cc \\\n gnu/java/lang/natMainThread.cc \\\n gnu/java/lang/management/natVMClassLoadingMXBeanImpl.cc \\\n gnu/java/lang/management/natVMCompilationMXBeanImpl.cc \\\n@@ -8360,6 +8372,8 @@ gnu/gcj/util/$(DEPDIR)/$(am__dirstamp):\n \t@: > gnu/gcj/util/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/util/natDebug.lo: gnu/gcj/util/$(am__dirstamp) \\\n \tgnu/gcj/util/$(DEPDIR)/$(am__dirstamp)\n+gnu/gcj/util/natGCInfo.lo: gnu/gcj/util/$(am__dirstamp) \\\n+\tgnu/gcj/util/$(DEPDIR)/$(am__dirstamp)\n gnu/java/lang/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/lang\n \t@: > gnu/java/lang/$(am__dirstamp)\n@@ -8694,6 +8708,9 @@ ecjx$(EXEEXT): $(ecjx_OBJECTS) $(ecjx_DEPENDENCIES)\n gappletviewer$(EXEEXT): $(gappletviewer_OBJECTS) $(gappletviewer_DEPENDENCIES) \n \t@rm -f gappletviewer$(EXEEXT)\n \t$(gappletviewer_LINK) $(gappletviewer_LDFLAGS) $(gappletviewer_OBJECTS) $(gappletviewer_LDADD) $(LIBS)\n+gc-analyze$(EXEEXT): $(gc_analyze_OBJECTS) $(gc_analyze_DEPENDENCIES) \n+\t@rm -f gc-analyze$(EXEEXT)\n+\t$(gc_analyze_LINK) $(gc_analyze_LDFLAGS) $(gc_analyze_OBJECTS) $(gc_analyze_LDADD) $(LIBS)\n gnu/gcj/tools/gcj_dbtool/$(am__dirstamp):\n \t@$(mkdir_p) gnu/gcj/tools/gcj_dbtool\n \t@: > gnu/gcj/tools/gcj_dbtool/$(am__dirstamp)\n@@ -8826,6 +8843,8 @@ mostlyclean-compile:\n \t-rm -f gnu/gcj/tools/gcj_dbtool/natMain.$(OBJEXT)\n \t-rm -f gnu/gcj/util/natDebug.$(OBJEXT)\n \t-rm -f gnu/gcj/util/natDebug.lo\n+\t-rm -f gnu/gcj/util/natGCInfo.$(OBJEXT)\n+\t-rm -f gnu/gcj/util/natGCInfo.lo\n \t-rm -f gnu/gcj/xlib/lib_gnu_awt_xlib_la-natClip.$(OBJEXT)\n \t-rm -f gnu/gcj/xlib/lib_gnu_awt_xlib_la-natClip.lo\n \t-rm -f gnu/gcj/xlib/lib_gnu_awt_xlib_la-natColormap.$(OBJEXT)\n@@ -9035,6 +9054,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natSystemClassLoader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/tools/gcj_dbtool/$(DEPDIR)/natMain.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/util/$(DEPDIR)/natDebug.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/util/$(DEPDIR)/natGCInfo.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/xlib/$(DEPDIR)/lib_gnu_awt_xlib_la-natClip.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/xlib/$(DEPDIR)/lib_gnu_awt_xlib_la-natColormap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/xlib/$(DEPDIR)/lib_gnu_awt_xlib_la-natDisplay.Plo@am__quote@"}, {"sha": "c147ab6a7a828ec9b5fbc993b8b6e49b7805b433", "filename": "libjava/classpath/ChangeLog.gcj", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gcj?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -1,3 +1,8 @@\n+2007-02-15  David Daney  <ddaney@avtrex.com>\n+\n+\t* tools/Makefile.am (TOOLS_ZIP): Add classes from vm-tools-packages.\n+\t* tools/Makefile.in: Regenerated.\n+\n 2007-02-15  Gary Benson  <gbenson@redhat.com>\n \n \t* javax/management/AttributeList.java: Updated."}, {"sha": "e07bb933213793525f941ff3dc138bf32eafc68f", "filename": "libjava/classpath/lib/gnu/gcj/util/GCInfo.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Futil%2FGCInfo.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Futil%2FGCInfo.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Futil%2FGCInfo.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "f7d9dadb63ee445f9213a5a2f1f59ddfe2646fda", "filename": "libjava/classpath/lib/gnu/gcj/util/UtilPermission.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Futil%2FUtilPermission.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Futil%2FUtilPermission.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Futil%2FUtilPermission.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "8ba984bb31444921a8b296c66b4fca50ed14df9d", "filename": "libjava/classpath/tools/Makefile.am", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2FMakefile.am?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -155,12 +155,19 @@ $(TOOLS_ZIP): $(TOOLS_JAVA_FILES)\n ##\tmkdir classes asm\n \tfind $(srcdir)/external/asm -name '*.java' -print > asm.lst\n \tfind $(srcdir)/gnu/classpath/tools -name '*.java' -print > classes.lst\n-\tcat classes.lst asm.lst > all-classes.lst\n+\tif [ -f $(top_builddir)/../vm-tools-packages ]; then \\\n+\t    for pkg in `cat $(top_builddir)/../vm-tools-packages`; do \\\n+\t      $(FIND) $(top_srcdir)/../$$pkg -follow -name '*.java' -print >> vm-tools.lst; \\\n+\t    done \\\n+\telse \\\n+\t    echo -n > vm-tools.lst; \\\n+\tfi\n+\tcat classes.lst asm.lst vm-tools.lst > all-classes.lst\n if JAVA_MAINTAINER_MODE\n ## Compile ASM separately as it is latin-1 encoded.\n \tAC=`echo $(JCOMPILER) | sed -e 's/UTF-8/ISO-8859-1/g'`; \\\n \t  $$AC -g -w -d $(srcdir)/asm @asm.lst\n-\t$(JCOMPILER) -g -w -d $(srcdir)/classes @classes.lst\n+\t$(JCOMPILER) -g -w -d $(srcdir)/classes @classes.lst @vm-tools.lst\n ## Copy over tools resource files.\n \t@list=`cd $(top_srcdir)/resource && find gnu/classpath/tools -name \\*.properties -print`; \\\n \tfor p in $$list; do \\"}, {"sha": "960dc6e0035bd7f6bd6cda3211cfd1c881099a5d", "filename": "libjava/classpath/tools/Makefile.in", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2FMakefile.in?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -1079,10 +1079,17 @@ dist-hook:\n $(TOOLS_ZIP): $(TOOLS_JAVA_FILES)\n \tfind $(srcdir)/external/asm -name '*.java' -print > asm.lst\n \tfind $(srcdir)/gnu/classpath/tools -name '*.java' -print > classes.lst\n-\tcat classes.lst asm.lst > all-classes.lst\n+\tif [ -f $(top_builddir)/../vm-tools-packages ]; then \\\n+\t    for pkg in `cat $(top_builddir)/../vm-tools-packages`; do \\\n+\t      $(FIND) $(top_srcdir)/../$$pkg -follow -name '*.java' -print >> vm-tools.lst; \\\n+\t    done \\\n+\telse \\\n+\t    echo -n > vm-tools.lst; \\\n+\tfi\n+\tcat classes.lst asm.lst vm-tools.lst > all-classes.lst\n @JAVA_MAINTAINER_MODE_TRUE@\tAC=`echo $(JCOMPILER) | sed -e 's/UTF-8/ISO-8859-1/g'`; \\\n @JAVA_MAINTAINER_MODE_TRUE@\t  $$AC -g -w -d $(srcdir)/asm @asm.lst\n-@JAVA_MAINTAINER_MODE_TRUE@\t$(JCOMPILER) -g -w -d $(srcdir)/classes @classes.lst\n+@JAVA_MAINTAINER_MODE_TRUE@\t$(JCOMPILER) -g -w -d $(srcdir)/classes @classes.lst @vm-tools.lst\n @JAVA_MAINTAINER_MODE_TRUE@\t@list=`cd $(top_srcdir)/resource && find gnu/classpath/tools -name \\*.properties -print`; \\\n @JAVA_MAINTAINER_MODE_TRUE@\tfor p in $$list; do \\\n @JAVA_MAINTAINER_MODE_TRUE@\t  dirname=classes/`dirname $$p`; \\"}, {"sha": "59094b9c9b8f9b9e9e3dedfa94c553d4200dca89", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/BlockMap$PtrMarks.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap%24PtrMarks.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap%24PtrMarks.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap%24PtrMarks.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "4a9c99a43ca86febb3738363998344318d8c9996", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/BlockMap$SizeKind.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap%24SizeKind.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap%24SizeKind.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap%24SizeKind.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "b29214c02901feacd083e09054bd5cfb351af603", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/BlockMap.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "c5a812e90bf3c38c8dc315ac3334a281ea3c29b2", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/BytePtr.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBytePtr.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBytePtr.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBytePtr.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "c1098e5d87d808f8bcdcb10fb8e9efd10dbf6d93", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/ItemList.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FItemList.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FItemList.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FItemList.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "687e94d388cc8a68218f26c48d482cca823758e5", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze$1$Info.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%241%24Info.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%241%24Info.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%241%24Info.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "9fbf1a59d74ca6452c05f9ed69fb4f52f9564d03", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze$1.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%241.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%241.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%241.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "5fa44be1b86feeb53fbb73075a28a2f8405d024a", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze$2.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%242.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%242.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%242.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "2c91530397e80931bf752eb197fb75895a654733", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze$3.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%243.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%243.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%243.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "125ac72799012c7e6848926cdf16920c5c8e510d", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze$4.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%244.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%244.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%244.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "9a12fb87991780968dc2df6d56347dab67b6f7be", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze$OptionParser.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%24OptionParser.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%24OptionParser.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%24OptionParser.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "238c2583b7149b877512b7ff8662e202f9a78d37", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze$SubstringComparator.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%24SubstringComparator.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%24SubstringComparator.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze%24SubstringComparator.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "ce5c998e1644d4dab1b58aaa07fd4dfa86321be8", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryAnalyze.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "72d9ee0a4372a30789f7b517bf9859236d6c0a9e", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryMap$Range.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap%24Range.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap%24Range.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap%24Range.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "4355000f58d47085c890a87e22d37c3dd167f36f", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryMap$RangeComparator.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap%24RangeComparator.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap%24RangeComparator.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap%24RangeComparator.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "2646141081abfb17992fc9a605104129f18945fe", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/MemoryMap.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "4a27d3fd48f587b913298d164d1cac417e68de76", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/ObjectMap$ObjectItem.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap%24ObjectItem.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap%24ObjectItem.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap%24ObjectItem.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "f7fc0df7ae8737da7cf5f4e3053478a891ae6eca", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/ObjectMap.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "7099959e27cfac09db5929038254c6cd7310c5c9", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/SymbolLookup.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolLookup.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolLookup.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolLookup.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "49e0bbb8bfcbe7711c9677c03f1ff0fca9638005", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/SymbolTable.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolTable.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolTable.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolTable.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "2224a23bb5d3b09203d8872fb396871c9b188386", "filename": "libjava/classpath/tools/classes/gnu/gcj/tools/gc_analyze/ToolPrefix.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FToolPrefix.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FToolPrefix.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fclasses%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FToolPrefix.class?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c"}, {"sha": "04449d535e121153dfd87963939b960ce09f1afe", "filename": "libjava/configure", "status": "modified", "additions": 181, "deletions": 11, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -5087,6 +5087,12 @@ if test \"$use_x_awt\" != yes; then\n    echo gnu/java/awt/peer/x >> standard.omit\n fi\n \n+# Tools that need to be compiled against classpath's tools classes\n+for package in gnu/gcj/tools/gc_analyze ; do\n+    echo $package >> standard.omit\n+    echo $package >> vm-tools-packages\n+done\n+\n if test -z \"${with_multisubdir}\"; then\n    builddotdot=.\n else\n@@ -6024,7 +6030,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 6027 \"configure\"' > conftest.$ac_ext\n+  echo '#line 6033 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -7066,7 +7072,7 @@ if test \"${enable_sjlj_exceptions+set}\" = set; then\n   :\n else\n   cat > conftest.$ac_ext << EOF\n-#line 7069 \"configure\"\n+#line 7075 \"configure\"\n struct S { ~S(); };\n void bar();\n void foo()\n@@ -7819,15 +7825,15 @@ ac_x_header_dirs='\n /usr/openwin/share/include'\n \n if test \"$ac_x_includes\" = no; then\n-  # Guess where to find include files, by looking for Intrinsic.h.\n+  # Guess where to find include files, by looking for Xlib.h.\n   # First, try using that file with no special directory specified.\n   cat >conftest.$ac_ext <<_ACEOF\n /* confdefs.h.  */\n _ACEOF\n cat confdefs.h >>conftest.$ac_ext\n cat >>conftest.$ac_ext <<_ACEOF\n /* end confdefs.h.  */\n-#include <X11/Intrinsic.h>\n+#include <X11/Xlib.h>\n _ACEOF\n if { (eval echo \"$as_me:$LINENO: \\\"$ac_cpp conftest.$ac_ext\\\"\") >&5\n   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1\n@@ -7854,7 +7860,7 @@ else\n sed 's/^/| /' conftest.$ac_ext >&5\n \n   for ac_dir in $ac_x_header_dirs; do\n-  if test -r \"$ac_dir/X11/Intrinsic.h\"; then\n+  if test -r \"$ac_dir/X11/Xlib.h\"; then\n     ac_x_includes=$ac_dir\n     break\n   fi\n@@ -7868,7 +7874,7 @@ if test \"$ac_x_libraries\" = no; then\n   # See if we find them without any special options.\n   # Don't add to $LIBS permanently.\n   ac_save_LIBS=$LIBS\n-  LIBS=\"-lXt $LIBS\"\n+  LIBS=\"-lX11 $LIBS\"\n   if test x$gcc_no_link = xyes; then\n   { { echo \"$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&5\n echo \"$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&2;}\n@@ -7880,11 +7886,11 @@ _ACEOF\n cat confdefs.h >>conftest.$ac_ext\n cat >>conftest.$ac_ext <<_ACEOF\n /* end confdefs.h.  */\n-#include <X11/Intrinsic.h>\n+#include <X11/Xlib.h>\n int\n main ()\n {\n-XtMalloc (0)\n+XrmInitialize ()\n   ;\n   return 0;\n }\n@@ -10395,6 +10401,37 @@ cat >>confdefs.h <<\\_ACEOF\n #define HAVE_PROC_SELF_EXE 1\n _ACEOF\n \n+fi\n+\n+     echo \"$as_me:$LINENO: checking for /proc/self/maps\" >&5\n+echo $ECHO_N \"checking for /proc/self/maps... $ECHO_C\" >&6\n+if test \"${ac_cv_file__proc_self_maps+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  test \"$cross_compiling\" = yes &&\n+  { { echo \"$as_me:$LINENO: error: cannot check for file existence when cross compiling\" >&5\n+echo \"$as_me: error: cannot check for file existence when cross compiling\" >&2;}\n+   { (exit 1); exit 1; }; }\n+if test -r \"/proc/self/maps\"; then\n+  ac_cv_file__proc_self_maps=yes\n+else\n+  ac_cv_file__proc_self_maps=no\n+fi\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_file__proc_self_maps\" >&5\n+echo \"${ECHO_T}$ac_cv_file__proc_self_maps\" >&6\n+if test $ac_cv_file__proc_self_maps = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE__PROC_SELF_MAPS 1\n+_ACEOF\n+\n+\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_PROC_SELF_MAPS 1\n+_ACEOF\n+\n fi\n \n    else\n@@ -10405,6 +10442,11 @@ cat >>confdefs.h <<\\_ACEOF\n #define HAVE_PROC_SELF_EXE 1\n _ACEOF\n \n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_PROC_SELF_MAPS 1\n+_ACEOF\n+\n        ;;\n      esac\n    fi\n@@ -16815,7 +16857,7 @@ if test \"${have_tls+set}\" = set; then\n else\n \n     if test \"$cross_compiling\" = yes; then\n-  if test x$gcc_no_link = xyes; then\n+                if test x$gcc_no_link = xyes; then\n   { { echo \"$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&5\n echo \"$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&2;}\n    { (exit 1); exit 1; }; }\n@@ -16855,6 +16897,7 @@ fi\n rm -f conftest.err conftest.$ac_objext \\\n       conftest$ac_exeext conftest.$ac_ext\n \n+\n else\n   cat >conftest.$ac_ext <<_ACEOF\n __thread int a; int b; int main() { return a = b; }\n@@ -16870,7 +16913,7 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }; }; then\n-                      save_LDFLAGS=\"$LDFLAGS\"\n+                      chktls_save_LDFLAGS=\"$LDFLAGS\"\n       LDFLAGS=\"-static $LDFLAGS\"\n       if test x$gcc_no_link = xyes; then\n   { { echo \"$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&5\n@@ -16942,7 +16985,134 @@ have_tls=yes\n fi\n rm -f conftest.err conftest.$ac_objext \\\n       conftest$ac_exeext conftest.$ac_ext\n-      LDFLAGS=\"$save_LDFLAGS\"\n+      LDFLAGS=\"$chktls_save_LDFLAGS\"\n+      if test $have_tls = yes; then\n+\t\t\t\t\t\tchktls_save_CFLAGS=\"$CFLAGS\"\n+\tthread_CFLAGS=failed\n+\tfor flag in '' '-pthread' '-lpthread'; do\n+\t  CFLAGS=\"$flag $chktls_save_CFLAGS\"\n+\t  if test x$gcc_no_link = xyes; then\n+  { { echo \"$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&5\n+echo \"$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+\t\tvoid *g(void *d) { return NULL; }\n+int\n+main ()\n+{\n+pthread_t t; pthread_create(&t,NULL,g,NULL);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  thread_CFLAGS=\"$flag\"\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+\t  if test \"X$thread_CFLAGS\" != Xfailed; then\n+\t    break\n+\t  fi\n+\tdone\n+\tCFLAGS=\"$chktls_save_CFLAGS\"\n+\tif test \"X$thread_CFLAGS\" != Xfailed; then\n+\t  CFLAGS=\"$thread_CFLAGS $chktls_save_CFLAGS\"\n+\t  if test \"$cross_compiling\" = yes; then\n+  { { echo \"$as_me:$LINENO: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&5\n+echo \"$as_me: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+\t\t__thread int a;\n+\t\tstatic int *a_in_other_thread;\n+\t\tstatic void *\n+\t\tthread_func (void *arg)\n+\t\t{\n+\t\t  a_in_other_thread = &a;\n+\t\t  return (void *)0;\n+\t\t}\n+int\n+main ()\n+{\n+pthread_t thread;\n+\t\tvoid *thread_retval;\n+\t\tint *a_in_main_thread;\n+\t\tif (pthread_create (&thread, (pthread_attr_t *)0,\n+\t\t\t\t    thread_func, (void *)0))\n+\t\t  return 0;\n+\t\ta_in_main_thread = &a;\n+\t\tif (pthread_join (thread, &thread_retval))\n+\t\t  return 0;\n+\t\treturn (a_in_other_thread == a_in_main_thread);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  have_tls=yes\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+( exit $ac_status )\n+have_tls=no\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+\t  CFLAGS=\"$chktls_save_CFLAGS\"\n+\tfi\n+      fi\n else\n   echo \"$as_me: program exited with status $ac_status\" >&5\n echo \"$as_me: failed program was:\" >&5"}, {"sha": "a8e536f15d3113b1d6b91eaadf5fbdf59601c321", "filename": "libjava/configure.ac", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -295,6 +295,12 @@ if test \"$use_x_awt\" != yes; then\n    echo gnu/java/awt/peer/x >> standard.omit\n fi\n \n+# Tools that need to be compiled against classpath's tools classes\n+for package in gnu/gcj/tools/gc_analyze ; do\n+    echo $package >> standard.omit\n+    echo $package >> vm-tools-packages\n+done\n+\n if test -z \"${with_multisubdir}\"; then\n    builddotdot=.\n else\n@@ -1012,10 +1018,14 @@ else\n    if test x\"$cross_compiling\" = x\"no\"; then\n      AC_CHECK_FILES(/proc/self/exe, [\n        AC_DEFINE(HAVE_PROC_SELF_EXE, 1, [Define if you have /proc/self/exe])])\n+     AC_CHECK_FILES(/proc/self/maps, [\n+       AC_DEFINE(HAVE_PROC_SELF_MAPS, 1,\n+         [Define if you have /proc/self/maps])])\n    else\n      case $host in\n      *-linux*)\n        AC_DEFINE(HAVE_PROC_SELF_EXE, 1, [Define if you have /proc/self/exe])\n+       AC_DEFINE(HAVE_PROC_SELF_MAPS, 1, [Define if you have /proc/self/maps])\n        ;;\n      esac\n    fi"}, {"sha": "6e7adae20dd96abd6db13371375f99724edfdb62", "filename": "libjava/gnu/gcj/tools/gc_analyze/BlockMap.java", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBlockMap.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,218 @@\n+/* BlockMap.java -- Container for information on GC maintained memory blocks.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+class BlockMap\n+{\n+  static final int HBLKSIZE = 4096;\n+\n+  class SizeKind implements Comparable<SizeKind>\n+  {\n+    int size;\n+    int kind;\n+\n+    public SizeKind(int size, int kind)\n+    {\n+      this.size = size;\n+      this.kind = kind;\n+    }\n+\n+    public int compareTo(SizeKind b)\n+    {\n+      if (this.size != b.size)\n+        return this.size - b.size;\n+      return this.kind - b.kind;\n+    }\n+  }\n+\n+  class PtrMarks\n+  {\n+    long ptr;\n+    int marks;\n+  \n+    public PtrMarks(long ptr, int marks)\n+    {\n+      this.ptr = ptr;\n+      this.marks = marks;\n+    }\n+  }\n+\n+  private TreeMap<SizeKind, ArrayList<PtrMarks>> map =\n+    new TreeMap<SizeKind, ArrayList<PtrMarks>>();\n+\n+  public BlockMap(BufferedReader reader) throws IOException\n+  {\n+    for (;;)\n+      {\n+        String s = reader.readLine();\n+        if (s == null)\n+          break;\n+        if (s.charAt(0) == '#')\n+          continue;\n+        if (s.indexOf(\"Begin block map\") >= 0)\n+          {\n+            for (;;)\n+              {\n+                s = reader.readLine();\n+                if (s.charAt(0) == '#')\n+                  continue;\n+                if (s.indexOf(\"End block map\") >= 0)\n+                  return;\n+                String[] items = s.split(\",\");\n+                long ptr = 0;\n+                int kind = 0, size = 0, marks = 0;\n+                for (int i=0; i<items.length; i++)\n+                  {\n+                    String[] x = items[i].split(\" \");\n+                    String last = x[x.length - 1];\n+                    switch (i)\n+                      {\n+                      case 0:\n+                        ptr = MemoryMap.parseHexLong(last.substring(2));\n+                        break;\n+                      case 1:\n+                        kind = Integer.parseInt(last);\n+                        break;\n+                      case 2:\n+                        size = Integer.parseInt(last);\n+                        break;\n+                      case 3:\n+                        marks = Integer.parseInt(last);\n+                        break;\n+                      }\n+                  }\n+                SizeKind sk = new SizeKind(size, kind);\n+                ArrayList<PtrMarks> m = map.get(sk);\n+                if (m == null)\n+                    {\n+                        m = new ArrayList<PtrMarks>();\n+                        map.put(sk, m);\n+                    }\n+                PtrMarks pm = new PtrMarks(ptr, marks);\n+                m.add(pm);\n+              } // inner loop\n+          } // started inner loop\n+      } // outer loop - finding begin\n+  } // memoryMap\n+\n+  public void dump()\n+  {\n+    System.out.println();\n+    System.out.println();\n+    System.out.println(\"*** Used Blocks ***\\n\");\n+    System.out.println();\n+    System.out.println(\"  Size     Kind            Blocks     Used       Free       Wasted\");\n+    System.out.println(\"-------  -------------    ------- ---------- ----------    -------\");\n+\n+    int total_blocks = 0, total_used = 0, total_free = 0, total_wasted = 0;\n+\n+    for (Map.Entry<SizeKind, ArrayList<PtrMarks>> me : map.entrySet())\n+      {\n+        SizeKind sk = me.getKey();\n+\n+        System.out.println(MemoryAnalyze.format(sk.size, 7) + \"  \"\n+                           + MemoryAnalyze.kindToName(sk.kind));\n+\n+        int sub_blocks = 0, sub_used = 0, sub_free = 0, sub_wasted = 0;\n+        int sub_count = 0;\n+\n+        ArrayList<PtrMarks> v = me.getValue();\n+\n+        for (PtrMarks pm : v)\n+          {\n+            int bytes = sk.size;\n+            int blocks = (sk.size + HBLKSIZE - 1) / HBLKSIZE;\n+            int used;\n+            int free;\n+            int wasted;\n+\n+            if (bytes < HBLKSIZE)\n+              {\n+                used = bytes * pm.marks;\n+                free = bytes * (HBLKSIZE / bytes - pm.marks);\n+                wasted = HBLKSIZE - HBLKSIZE / bytes * bytes;\n+              }\n+            else\n+              {\n+                if (pm.marks != 0)\n+                  {\n+                    used = bytes;\n+                    free = 0;\n+                    wasted = (bytes + HBLKSIZE - 1)\n+                      / HBLKSIZE * HBLKSIZE - used;\n+                  }\n+                else\n+                  {\n+                    used = 0;\n+                    free = bytes;\n+                    wasted = 0;\n+                  }\n+              }\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"                            \");\n+            sb.append(MemoryAnalyze.format(blocks, 5));\n+            sb.append(\"  \");\n+            sb.append(MemoryAnalyze.format(used, 9));\n+            sb.append(\"  \");\n+            sb.append(MemoryAnalyze.format(free, 9));\n+            sb.append(\"  \");\n+            sb.append(MemoryAnalyze.format(wasted, 9));\n+            System.out.println(sb);\n+\n+            sub_blocks += blocks;\n+            sub_used += used;\n+            sub_free += free;\n+            sub_wasted += wasted;\n+            sub_count++;\n+\n+            total_blocks += blocks;\n+            total_used += used;\n+            total_free += free;\n+            total_wasted += wasted;\n+          } // blocks with size/kind\n+        if (sub_count > 1)\n+          {\n+            System.out.println(\n+                               \"                          ------- ---------- ----------    -------\");\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"                            \");\n+            sb.append(MemoryAnalyze.format(sub_blocks, 5));\n+            sb.append(\"  \");\n+            sb.append(MemoryAnalyze.format(sub_used, 9));\n+            sb.append(\"  \");\n+            sb.append(MemoryAnalyze.format(sub_free, 9));\n+            sb.append(\"  \");\n+            sb.append(MemoryAnalyze.format(sub_wasted, 9));\n+            System.out.println(sb);\n+          }\n+      } // size/kind\n+\n+    System.out.println(\"-------  -------------    ------- ---------- ----------    -------\");\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"                            \");\n+    sb.append(MemoryAnalyze.format(total_blocks, 5));\n+    sb.append(\"  \");\n+    sb.append(MemoryAnalyze.format(total_used, 9));\n+    sb.append(\"  \");\n+    sb.append(MemoryAnalyze.format(total_free, 9));\n+    sb.append(\"  \");\n+    sb.append(MemoryAnalyze.format(total_wasted, 9));\n+    System.out.println(sb);\n+    System.out.println(\"Total bytes = \"\n+                       + MemoryAnalyze.format(total_blocks * HBLKSIZE, 10));\n+  }\n+}"}, {"sha": "4afceeeec8a4d0217ccfe9808295cc6e341c33e8", "filename": "libjava/gnu/gcj/tools/gc_analyze/BytePtr.java", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBytePtr.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBytePtr.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FBytePtr.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,115 @@\n+/* BytePtr.java -- Container for bytes from a memory image.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.nio.ByteBuffer;\n+\n+public class BytePtr\n+{\n+  ByteBuffer content;\n+  int wordSize;\n+\n+  BytePtr(ByteBuffer b, int ws)\n+  {\n+    content = b;\n+    wordSize = ws;\n+  }\n+  \n+  public int getsize()\n+  {\n+    return content.limit();\n+  }\n+\n+  public int getByte(int offset)\n+  {\n+    return content.get(offset);\n+  }\n+\n+  public int getInt(int n)\n+  {\n+    return content.getInt(n * 4);\n+  }\n+\n+  public int getShort(int n)\n+  {\n+    return content.getShort(n * 2);\n+  }\n+  \n+  public long getWord(int n)\n+  {\n+    if (4 == wordSize)\n+      return 0xffffffffL & content.getInt(n * 4);\n+    else\n+      return content.getLong(n * 8);\n+  }\n+  \n+  public int intsPerWord()\n+  {\n+    return (4 == wordSize) ? 1 : 2;\n+  }\n+\n+  public BytePtr getRegion(int offset, int size)\n+  {\n+    int oldLimit = content.limit();\n+    content.position(offset);\n+    content.limit(offset + size);\n+    ByteBuffer n = content.slice();\n+    content.position(0);\n+    content.limit(oldLimit);\n+    \n+    return new BytePtr(n, wordSize);\n+  }\n+\n+  public void setInt(int a, int n)\n+  {\n+    content.putInt(a * 4, n);\n+  }\n+\n+  public void dump()\n+  {\n+    // 38 5a f4 2a 50 bd 04 10 10 00 00 00 0e 00 00 00   8Z.*P...........\n+    int i;\n+    StringBuilder b = new StringBuilder(67);\n+    for (i = 0; i < 66; i++)\n+      b.append(' ');\n+    b.append('\\n');\n+\n+    i = 0;\n+    do\n+      {\n+        for (int j = 0; j < 16; j++)\n+          {\n+            int k = i + j;\n+\n+            if (k < content.limit())\n+              {\n+                int v = 0xff & getByte(k);\n+                // hex\n+                int v1 = v/16;\n+                b.setCharAt(j * 3 + 0,\n+                            (char)(v1 >= 10 ? 'a' - 10 + v1 : v1 + '0'));\n+                v1 = v % 16;\n+                b.setCharAt(j * 3 + 1,\n+                            (char)(v1 >= 10 ? 'a' - 10 + v1 : v1 + '0'));\n+                // ascii\n+                b.setCharAt(j + 50, (char)((v >= 32 && v <= 127) ? v: '.'));\n+              }\n+            else\n+              {\n+                b.setCharAt(j * 3 + 0, ' ');\n+                b.setCharAt(j * 3 + 1, ' ');\n+                b.setCharAt(j + 50, ' ');\n+              }\n+          }\n+        i += 16;\n+        System.out.print(b);\n+      } while (i < content.limit());\n+  }\n+}"}, {"sha": "7912bebca576494d062c830735ea0349ebac8988", "filename": "libjava/gnu/gcj/tools/gc_analyze/ItemList.java", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FItemList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FItemList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FItemList.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,72 @@\n+/* ItemList.java -- Maps all objects keyed by their addresses.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+class ItemList\n+{\n+  public ItemList()\n+  {\n+  }\n+\n+  private TreeMap<Long, HashMap<ObjectMap.ObjectItem, Integer>> map;\n+\n+  public void add(ObjectMap.ObjectItem item)\n+  {\n+    if (map == null)\n+      map = new TreeMap<Long, HashMap<ObjectMap.ObjectItem, Integer>>();\n+    Long x = new Long(item.klass);\n+    HashMap<ObjectMap.ObjectItem, Integer> list = map.get(x);\n+    if (list == null)\n+      {\n+        list = new HashMap<ObjectMap.ObjectItem, Integer>();\n+        map.put(x, list);\n+      }\n+    Integer count = list.get(item);\n+    if (count == null)\n+      list.put(item, new Integer(1));\n+    else\n+      list.put(item, new Integer(count.intValue() + 1));\n+  }\n+\n+  void dump(String title, SymbolLookup lookup) throws IOException\n+  {\n+    if (map == null)\n+      return;\n+    System.out.println(title);\n+    for (Map.Entry<Long, HashMap<ObjectMap.ObjectItem, Integer>> me :\n+           map.entrySet())\n+      {\n+        HashMap<ObjectMap.ObjectItem, Integer> list = me.getValue();\n+        boolean first = true;\n+\n+        for (Map.Entry<ObjectMap.ObjectItem, Integer> me2 : list.entrySet())\n+          {\n+            ObjectMap.ObjectItem item = me2.getKey();\n+            Integer count = me2.getValue();\n+            if (first)\n+              {\n+                String name =\n+                  MemoryAnalyze.getSymbolPretty(lookup, item, false);\n+                System.out.println(\"    \" + name + \":\");\n+                first = false;\n+              }\n+            System.out.print(\"        0x\" + Long.toHexString(item.ptr));\n+            if (count.intValue() != 1)\n+              System.out.print(\" * \" + count);\n+            System.out.println();\n+          }\n+      }\n+  }\n+}"}, {"sha": "d56a71da31164af943bb71787cf9fcfa7273c054", "filename": "libjava/gnu/gcj/tools/gc_analyze/MemoryAnalyze.java", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryAnalyze.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,458 @@\n+/* MemoryAnalyze.java -- Analyzes a libgcj heap dump.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import gnu.classpath.tools.getopt.FileArgumentCallback;\n+import gnu.classpath.tools.getopt.Option;\n+import gnu.classpath.tools.getopt.OptionException;\n+import gnu.classpath.tools.getopt.Parser;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.text.NumberFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+class MemoryAnalyze\n+{\n+  public MemoryAnalyze()\n+  {\n+  }\n+\n+  private static NumberFormat numberFormat;\n+  private static boolean verbose;\n+  static String format(long number, int digits)\n+  {\n+    if (numberFormat == null)\n+      {\n+        numberFormat = NumberFormat.getNumberInstance();\n+        numberFormat.setGroupingUsed(true);\n+      }\n+    String temp = numberFormat.format(number);\n+    int spaces = digits - temp.length();\n+    if (spaces < 0)\n+      spaces = 0;\n+    return \"                                \".substring(0,spaces) + temp;\n+  }\n+\n+  static void sorted_report(String description,\n+                            int total_space,\n+                            ArrayList<String> list,\n+                            Comparator<String> comparator)\n+  {\n+    System.out.println(\"*** \" + description + \" ***\");\n+    System.out.println();\n+    System.out.println(\"  Total Size       Count       Size    Description\");\n+    System.out.println(\"--------------     -----    --------   -----------------------------------\");\n+    Collections.sort(list, comparator);\n+    for (Iterator it = list.iterator(); it.hasNext(); )\n+      {\n+        String v = (String)it.next();\n+        System.out.println(stripend(v));\n+      }\n+    System.out.println(\"--------------     -----    --------   -----------------------------------\");\n+    System.out.println(format(total_space, 14));\n+    System.out.println();\n+    System.out.println();\n+  }\n+\n+  private static String stripend(String s)\n+  {\n+    int n = s.lastIndexOf(\" /\");\n+    if (n > 0)\n+      return s.substring(0,n);\n+    return s;\n+  }\n+\n+  static  class SubstringComparator implements Comparator<String>\n+  {\n+    private int begin, end;\n+    private boolean reverse;\n+\n+    SubstringComparator(int begin, int end, boolean reverse)\n+    {\n+      this.begin = begin;\n+      this.end = end;\n+      this.reverse = reverse;\n+    }\n+\n+    public int compare(String s1, String s2)\n+    {\n+      if (end == 0)\n+        s1 = s1.substring(begin);\n+      else\n+        s1 = s1.substring(begin, end);\n+\n+      if (end == 0)\n+        s2 = s2.substring(begin);\n+      else\n+        s2 = s2.substring(begin, end);\n+      int i = s1.compareTo(s2);\n+      if (reverse)\n+        return -i;\n+      return i;\n+    }\n+  }\n+\n+  static class OptionParser extends Parser\n+  {\n+    int filesFound;\n+\t  \n+    OptionParser()\n+    {\n+      super(\"gc-analyze\",\n+            \"gc-analyze (\" + System.getProperty(\"java.vm.version\") + \")\");\n+\n+      add(new Option('d',\n+                     \"Directory containing runtime objects\",\n+                     \"directory\")\n+        {\n+          public void parsed(String argument) throws OptionException\n+          {\n+            ToolPrefix.pathPrefix = argument;\t\t\t\n+          }\n+        });\n+\n+      add(new Option('p',\n+                     \"Binary tool prefix, prepended to nm and readelf to \"\n+                     + \"obtain target specific versions of these commands\",\n+                     \"prefix\")\n+        {\n+          public void parsed(String argument) throws OptionException\n+          {\n+            ToolPrefix.toolPrefix = argument;\t\t\t\n+          }\n+        });\n+\n+      add(new Option(\"verbose\", 'v',\n+                     \"Verbose output; requires filename.bytes\")\n+        {\n+          public void parsed(String argument) throws OptionException\n+          {\n+            verbose = true;\t\t\t\n+          }\n+        });\n+\n+      setHeader(\"usage: gc-analyze [-v] [-p tool-prefix] [-d <directory>] \"\n+                + \"filename\");\n+    }\n+\t  \n+    protected void validate() throws OptionException\n+    {\n+      if (filesFound != 1)\n+        throw new OptionException(\"Must specify exactly one filename\");\n+    }\n+\t  \n+    public String[] parse(String[] inArgs)\n+    {\n+      final ArrayList<String> fileResult = new ArrayList<String>();\n+      parse(inArgs, new FileArgumentCallback()\n+        {\n+          public void notifyFile(String fileArgument)\n+          {\n+            filesFound++;\n+            fileResult.add(fileArgument);\n+          }\n+        });\n+      return fileResult.toArray(new String[1]);\n+    }\n+  }\n+  \n+  public static void main(String[] args)\n+  {\n+    class Info\n+    {\n+      int size;\n+      int count;\n+    }\n+    int total_space = 0;\n+\n+    Parser optionParser = new OptionParser();\n+    \n+    String rest[] = optionParser.parse(args);\n+    \n+    String filename = rest[0];\n+    \n+    try\n+      {\n+        BufferedReader reader =\n+          new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\n+        SymbolLookup lookup = new SymbolLookup(reader, filename + \".bytes\");\n+        ObjectMap objectMap = new ObjectMap(reader);\n+        BlockMap blockMap = new BlockMap(reader);\n+        reader.close();\n+\n+        // add info to item(s)\n+        // add item.klass\n+        for (Map.Entry<Long, ObjectMap.ObjectItem> me : objectMap)\n+        {\n+            ObjectMap.ObjectItem item = me.getValue();\n+\n+            // try to get a klass (happens with intern'ed strings...)\n+            if (item.klass==0)\n+              {\n+                BytePtr p = lookup.getBytePtr(item.ptr, item.size);\n+                if (p!=null)\n+                  {\n+                    long vtable = p.getWord(0);\n+                    String sym =\n+                        lookup.getSymbolViaVtable(vtable - 2 * lookup.memoryMap.wordSize);\n+                    if (sym != null)\n+                      {\n+                        item.typeName = SymbolTable.demangleVTName(sym);\n+                      }\n+                    else if (vtable != 0)\n+                      {\n+                        // get klass from vtable\n+                        p = lookup.getBytePtr(vtable,\n+                                              lookup.memoryMap.wordSize);\n+                        if (p != null)\n+                          {\n+                            long klass = p.getWord(0);\n+                            item.klass = klass;\n+                          }\n+                      }\n+                  }\n+              }\n+\n+            // figure out strings\n+            String class_name;\n+            if (null == item.typeName)\n+              {\n+                class_name =\n+                  MemoryAnalyze.getSymbolPretty(lookup, item, false);\n+                item.typeName = class_name;\n+              }\n+            else\n+              {\n+                class_name = item.typeName;\n+              }\n+            System.out.print(\"class_name=[\" + class_name + \"]\");\n+\n+            if (class_name.compareTo(\"_ZTVN4java4lang6StringE\")==0\n+                || class_name.compareTo(\"java.lang.String\")==0)\n+              {\n+                BytePtr p = lookup.getBytePtr(item.ptr, item.size);\n+                long data = p.getWord(1); \n+                int boffset = p.getInt(2 * p.intsPerWord());\n+                int count = p.getInt(1 + 2 * p.intsPerWord());\n+                int hash = p.getInt(2 + 2 * p.intsPerWord());\n+                BytePtr chars = lookup.getBytePtr(data+boffset, count * 2);\n+                StringBuffer sb = new StringBuffer(count);\n+                for (int qq = 0; qq<count; qq++)\n+                  sb.append((char)chars.getShort(qq));\n+                int newhash = sb.toString().hashCode();\n+                if (newhash!=hash)\n+                  {\n+                    p.setInt(4, newhash);\n+                  }\n+\n+                item.string = sb.toString();\n+                System.out.println(\" value = \\\"\" + item.string + \"\\\"\");\n+                if (data != item.ptr)\n+                  {\n+                    ObjectMap.ObjectItem next = objectMap.get(data);\n+                    if (next != null)\n+                      next.stringData = true;\n+                    else\n+                      System.out.println(\"String [\" + item.string + \"] at \"\n+                                         + Long.toHexString(item.ptr)\n+                                         + \" can't find array at \" \n+                                         + Long.toHexString(data));\n+                  }\n+              }\n+            else if (null != item.string)\n+              System.out.println(\" value = \\\"\" + item.string + \"\\\"\");\n+            else\n+              System.out.println();\n+          }\n+\n+\n+        HashMap<String, Info> map = new HashMap<String, Info>();\n+        for (Map.Entry<Long, ObjectMap.ObjectItem> me : objectMap)\n+          {\n+            ObjectMap.ObjectItem item = me.getValue();\n+            String name = getSymbolPretty(lookup, item, true);\n+            Info info = map.get(name);\n+            if (info == null)\n+              {\n+                info = new Info();\n+                info.count = 0;\n+                info.size = item.size;\n+                map.put(name, info);\n+              }\n+            info.count++;\n+            total_space += item.size;\n+          }\n+\n+        ArrayList<String> list = new ArrayList<String>();\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext(); )\n+          {\n+            Map.Entry me = (Map.Entry)it.next();\n+            String name = (String)me.getKey();\n+            Info info = (Info)me.getValue();\n+\n+            StringBuffer sb = new StringBuffer();\n+            sb.append(format(info.count * info.size * 100 / total_space,\n+                             3));\n+            sb.append(\"%\");\n+            sb.append(format(info.count * info.size, 10));\n+            sb.append(\" = \");\n+            sb.append(format(info.count, 7));\n+            sb.append(\" * \");\n+            sb.append(format(info.size, 9));\n+            sb.append(\" - \");\n+            sb.append(name);\n+            list.add(sb.toString());\n+          }\n+\n+        sorted_report(\"Memory Usage Sorted by Total Size\",\n+                      total_space, list, new SubstringComparator(5,14,true));\n+        sorted_report(\"Memory Usage Sorted by Description\",\n+                      total_space, list, new SubstringComparator(39,0,false));\n+        sorted_report(\"Memory Usage Sorted by Count\",\n+                      total_space, list, new SubstringComparator(17,25,true));\n+        sorted_report(\"Memory Usage Sorted by Size\",\n+                      total_space, list, new SubstringComparator(28,37,true));\n+\n+        blockMap.dump();\n+\n+        // dump raw memory\n+        if (verbose)\n+          {\n+            // analyze references\n+            for (Map.Entry<Long, ObjectMap.ObjectItem> me : objectMap)\n+              {\n+                long ptr = me.getKey();\n+                ObjectMap.ObjectItem item = me.getValue();\n+                BytePtr p = lookup.getBytePtr(ptr, item.size);\n+                if (p == null)\n+                  System.out.println(\"can't find ptr 0x\"\n+                                     + Long.toHexString(ptr));\n+                else if (item.kind != 0) // not GC_PTRFREE\n+                  for (int i = 1;\n+                       i < item.size / lookup.memoryMap.wordSize; i++)\n+                    {\n+                      long maybe_ptr = p.getWord(i);\n+                      ObjectMap.ObjectItem item2 = objectMap.get(maybe_ptr);\n+                      if (item2 != null)\n+                        {\n+                          item2.pointed_by.add(item);\n+                          item.points_to.add(item2);\n+                        }\n+                    }\n+              }\n+            System.out.println();\n+            System.out.println(\"*** All Objects ***\");\n+            System.out.println();\n+\n+            for (Map.Entry<Long, ObjectMap.ObjectItem> me : objectMap)\n+            {\n+              long ptr = me.getKey();\n+              ObjectMap.ObjectItem item = me.getValue();\n+              String name = getSymbolPretty(lookup, item, false);\n+              System.out.print(\"0x\" + Long.toHexString(ptr) + \" - \" + name\n+                               + \" (\" + item.size + \")\");\n+              if (item.string != null)\n+        \tSystem.out.println(\" \\\"\" + item.string + \"\\\"\");\n+              else\n+        \tSystem.out.println();\n+\n+              BytePtr p = lookup.getBytePtr(ptr, item.size);\n+\n+              if (p == null)\n+                System.out.println(\n+                  \"can't find memory; recently allocated from free list?\");\n+              else\n+                p.dump();\n+\n+              item.points_to.dump(\"  points to:\", lookup);\n+              item.pointed_by.dump(\"  pointed to by:\", lookup);\n+              System.out.println();\n+            }\n+          }\n+      }\n+    catch (IOException e)\n+      {\n+        e.printStackTrace();\n+      }\n+  }\n+\n+  public static String kindToName(int kind)\n+  {\n+    String name;\n+    switch (kind)\n+      {\n+      case 0:\n+        name = \"GC_PTRFREE\";\n+        break;\n+      case 1:\n+        name = \"GC_NORMAL\";\n+        break;\n+      case 2:\n+        name = \"GC_UNCOLLECTABLE\";\n+        break;\n+      case 3:\n+        name = \"GC_AUUNCOLLCTABLE\";\n+        break;\n+      case 4:\n+        name = \"(Java)\";\n+        break;\n+      case 5:\n+        name = \"(Java Debug)\";\n+        break;\n+      case 6:\n+        name = \"(Java Array)\";\n+        break;\n+      default:\n+        name = \"(Kind \" + kind + \")\";\n+        break;\n+      }\n+    return name;\n+  }\n+\n+  public static String getSymbolPretty(SymbolLookup lookup,\n+                                       ObjectMap.ObjectItem item,\n+                                       boolean bsize)\n+    throws IOException\n+  {\n+    \n+    String name = item.typeName;\n+    \n+    if (name == null)\n+      name = lookup.getSymbol(item.klass);\n+    \n+    if (name == null)\n+      {\n+      \tString v = lookup.decodeUTF8(item.ptr, item.size);\n+      \tif (null != v)\n+      \t  {\n+      \t    name = \"UTF8Const\";\n+      \t    item.string = v;\n+      \t  }\n+      }\n+    \n+    if (name == null)\n+      {\n+        name = kindToName(item.kind);\n+      }\n+    if (item.kind==6)\n+      name += \"[\" + format(item.data, 0) + \"]\";\n+    if (bsize)\n+      name = name + \" / \" + format(item.size, 7);\n+    return name;\n+  }\n+}"}, {"sha": "1bc06d58422bd4b6ded7ec3b3b760da1e87d7c67", "filename": "libjava/gnu/gcj/tools/gc_analyze/MemoryMap.java", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FMemoryMap.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,359 @@\n+/* MemoryMap.java -- Maps address ranges to their data.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.io.BufferedReader;\n+import java.io.EOFException;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+/**\n+ * Reads /proc/self/maps output from dump file.\n+ * Creates map of <filename> to Range.\n+ *\n+ * Returns filename given address.\n+ * Returns offset given address.\n+ * Returns BytePtr given address.\n+ *\n+ */\n+class MemoryMap\n+{\n+  static class RangeComparator implements Comparator<Range>\n+  {\n+    public int compare(Range r1, Range r2)\n+    {\n+      if (r2.end == 0 && r1.end != 0)\n+        return -compare(r2, r1);\n+      \n+      if (r1.begin < r2.begin)\n+        return -1;\n+      else if (r1.begin >= r2.end)\n+        return 1;\n+      else\n+        return 0;\n+    }\n+  }\n+  \n+  static class Range\n+  {\n+    long begin;\n+    long end;\n+\n+    long offset;\n+    String filename;\n+    Range()\n+    {\n+    }\n+    \n+    Range(long b, long e, String s, long o)\n+    {\n+      begin = b;\n+      end = e;\n+      filename = s;\n+      offset = o;\n+    }\n+  }\n+\n+  /**\n+   * Parse the string as an unsigned hexadecimal number.  This is\n+   * similar to Long.parseInt(s,16), but without the restriction that\n+   * values that have the sign bit set not being allowed.\n+   *\n+   * @param s the number as a String.\n+   * @return the number.\n+   */\n+  static long parseHexLong(String s)\n+  {\n+    if (s.length() > 16)\n+      throw new NumberFormatException();\n+    long r = 0;\n+    for (int i = 0; i < s.length(); i++)\n+      {\n+        int digit = 0;\n+        char c = s.charAt(i);\n+        switch (c)\n+          {\n+          case '0':\n+          case '1':\n+          case '2':\n+          case '3':\n+          case '4':\n+          case '5':\n+          case '6':\n+          case '7':\n+          case '8':\n+          case '9':\n+            digit = c - '0';\n+            break;\n+          case 'a':\n+          case 'b':\n+          case 'c':\n+          case 'd':\n+          case 'e':\n+          case 'f':\n+            digit = 10 + c - 'a';\n+            break;\n+          case 'A':\n+          case 'B':\n+          case 'C':\n+          case 'D':\n+          case 'E':\n+          case 'F':\n+            digit = 10 + c - 'A';\n+            break;\n+          default:\n+            throw new NumberFormatException();\n+          }\n+        r = (r << 4) + digit;\n+      }\n+    return r;\n+  }\n+  \n+  // String filename -> Range\n+  TreeSet<Range> map = new TreeSet<Range>(new RangeComparator());\n+  HashMap<String, SymbolTable> symbolTables =\n+    new HashMap<String, SymbolTable>();\n+  ByteOrder byteOrder;\n+  int wordSize;\n+\n+  public MemoryMap(BufferedReader reader,\n+                   String rawFileName) throws IOException\n+  {\n+    FileChannel raw = (new RandomAccessFile(rawFileName, \"r\")).getChannel();\n+    ByteBuffer buf = ByteBuffer.allocate(8);\n+    raw.read(buf);\n+    if (buf.hasRemaining())\n+      {\n+        raw.close();\n+        throw new EOFException();\n+      }\n+    buf.flip();\n+    wordSize = buf.get();\n+    \n+    if (wordSize == 8 || wordSize == 4)\n+      byteOrder = ByteOrder.LITTLE_ENDIAN;\n+    else\n+      {\n+        byteOrder = ByteOrder.BIG_ENDIAN;\n+        buf.rewind();\n+        wordSize = buf.getInt();\n+        if (0 == wordSize)\n+          wordSize = buf.getInt();\n+      }\n+    switch (wordSize)\n+      {\n+      case 4:\n+      case 8:\n+        break;\n+      default:\n+        throw new IOException(\"Bad .bytes file header\");\n+      }\n+    buf = ByteBuffer.allocate(3 * wordSize);\n+    buf.order(byteOrder);\n+    raw.position(0L);\n+\n+    for(;;)\n+      {\n+        // Read the block header.\n+        buf.clear();\n+        if (-1 == raw.read(buf))\n+          {\n+            //EOF\n+            raw.close();\n+            break;\n+          }\n+        if (buf.hasRemaining())\n+          {\n+            raw.close();\n+            throw new EOFException();\n+          }\n+        buf.flip();\n+        long dummy\n+          = (wordSize == 4) ? (buf.getInt() & 0xffffffffL) : buf.getLong();\n+        if (dummy != wordSize)\n+          throw new IOException(\"Bad .bytes file header\");\n+        long start\n+          = wordSize == 4 ? (buf.getInt() & 0xffffffffL) : buf.getLong();\n+        long length\n+          = wordSize == 4 ? (buf.getInt() & 0xffffffffL) : buf.getLong();\n+        if (length < 0L)\n+          throw new IOException(\"Bad .bytes file header\");\n+      \n+        long currentPos = raw.position();\n+        raw.position(currentPos + length);\n+    \n+        Range range = new Range(start, start + length,\n+                                rawFileName, currentPos);\n+        map.add(range);\n+      }\n+\n+    for (;;)\n+      {\n+        String s = reader.readLine();\n+        if (s == null)\n+          break;\n+        if (s.indexOf(\"Begin address map\") >= 0)\n+          {\n+            for (;;)\n+              {\n+                s = reader.readLine();\n+                if (s.indexOf(\"End address map\") >= 0)\n+                  {\n+                    dump();\n+                    return;\n+                  }\n+                int endOfAddress = s.indexOf('-');\n+                long address = parseHexLong(s.substring(0, endOfAddress));\n+                int endOfAddress2 = s.indexOf(' ', endOfAddress + 1);\n+                long address2 = parseHexLong(s.substring(endOfAddress + 1,\n+                                                         endOfAddress2));\n+                int endOfOffset = s.indexOf(' ', endOfAddress2 + 6);\n+                long offset;\n+                try\n+                  {\n+                    offset = parseHexLong(s.substring(endOfAddress2 + 6,\n+                                                      endOfOffset));\n+                  }\n+                catch (Exception e)\n+                  {\n+                    offset = 0;\n+                  }\n+                int end = s.indexOf('/');\n+\n+                if (end > 0)\n+                  {\n+                    String file = s.substring(end);\n+                    if (file.startsWith(\"/dev/\"))\n+                      continue;\n+\n+                    Range r = new Range(address, address2, file, offset);\n+                    if (offset == 0)\n+                      {\n+                        // Read the file's symbol table\n+                        try\n+                          {\n+                            File f = ToolPrefix.fileForName(file);\n+                            if (f != null)\n+                              {\n+                                SymbolTable st = new SymbolTable(f.getPath());\n+                                if (st.loadAddr != address)\n+                                  st.relocation = address - st.loadAddr;\n+                                symbolTables.put(file, st);\n+                              }\n+                          }\n+                        catch (Exception ex)\n+                          {\n+                            ex.printStackTrace();\n+                          }\n+                      }\n+                    map.add(r);\n+                  }\n+              } // inner loop\n+          } // started inner loop\n+      } // outer loop - finding begin\n+  } // memoryMap\n+\n+  \n+  public void dump()\n+  {\n+    System.out.println(\"MemoryMap:\");\n+    for (Range r : map)\n+      {\n+        System.out.println(Long.toHexString(r.begin) + \"-\"\n+                           + Long.toHexString(r.end) + \" -> \"\n+                           + r.filename + \" offset \"\n+                           + Long.toHexString(r.offset));\n+      }\n+  }\n+\n+  Range getRange(long addr)\n+  {\n+    Range r = new Range();\n+    r.begin = addr;\n+    SortedSet<Range> t = map.tailSet(r);\n+    if (t.isEmpty())\n+      return null;\n+    Range c = t.first();\n+    if (c.begin <= addr && addr < c.end)\n+      return c;\n+    return null;\n+  }\n+  \n+  String getFile(long addr)\n+  {\n+    Range r = getRange(addr);\n+    if (null != r)\n+      return r.filename;\n+    return null;\n+  }\n+\n+  long getOffset(long addr)\n+  {\n+    Range r = getRange(addr);\n+    if (null != r)\n+      return r.offset;\n+    return 0L;\n+  }\n+\n+  /**\n+   * @return BytePtr which includes given address.\n+   */\n+  BytePtr getBytePtr(long addr, int length) throws IOException\n+  {\n+    Range r = getRange(addr);\n+    \n+    if (null == r)\n+      return null;\n+\n+    File f = ToolPrefix.fileForName(r.filename);\n+    if (null == f)\n+      return null;\n+    \n+    if (addr + length > r.end)\n+      length = (int)(r.end - addr);\n+    \n+    ByteBuffer b = ByteBuffer.allocate(length);\n+    b.order(byteOrder);\n+    \n+    FileChannel fc = (new RandomAccessFile(f, \"r\")).getChannel();\n+    fc.position(r.offset + addr - r.begin);\n+    int nr = fc.read(b);\n+    fc.close();\n+    if (nr != length)\n+      return null;\n+    b.flip();\n+    return new BytePtr(b, wordSize);\n+  }\n+  \n+  public String getSymbol(long addr)\n+  {\n+    Range r = getRange(addr);\n+    \n+    if (r == null)\n+      return null;\n+    \n+    SymbolTable st = symbolTables.get(r.filename);\n+    if (st == null)\n+      return null;\n+    \n+    // Apply relocation\n+    addr -= st.relocation;\n+    \n+    return st.getSymbol(addr);\n+  }\n+}"}, {"sha": "b55034be137d77d44098284834f4d5eeea506b56", "filename": "libjava/gnu/gcj/tools/gc_analyze/ObjectMap.java", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FObjectMap.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,140 @@\n+/* ObjectMap.java -- Contains a map of all objects keyed by their addresses.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+class ObjectMap implements Iterable<Map.Entry<Long, ObjectMap.ObjectItem>>\n+{\n+\n+  class ObjectItem\n+  {\n+    int used;\n+    int size;\n+    int kind;\n+    long klass;\n+    long data;\n+    long ptr;\n+    String typeName;\n+    String string; // only for string objects\n+    boolean stringData; // character array pointed to by a string\n+    ObjectItem reference; // object at reference points to this\n+\n+    ItemList points_to = new ItemList();\n+    ItemList pointed_by = new ItemList();\n+  }\n+\n+  private TreeMap<Long, ObjectItem> map = new TreeMap<Long, ObjectItem>();\n+\n+  public Iterator<Map.Entry<Long, ObjectItem>> iterator()\n+  {\n+    return map.entrySet().iterator();\n+  }\n+\n+  public ObjectItem get(long ptr)\n+  {\n+    ObjectItem item = map.get(ptr);\n+    return item;\n+  }\n+\n+  public ObjectMap(BufferedReader reader) throws IOException\n+  {\n+    outer_loop:\n+    for (;;)\n+      {\n+        String s = reader.readLine();\n+        if (s == null)\n+          break;\n+        if (s.indexOf(\"Begin object map\") >= 0)\n+          {\n+            for (;;)\n+              {\n+                s = reader.readLine();\n+                if (s.indexOf(\"End object map\") >= 0)\n+                  break outer_loop;\n+                String[] items = s.split(\",\");\n+                ObjectItem item = new ObjectItem();\n+                long ptr = 0;\n+                for (int i=0; i<items.length; i++)\n+                  {\n+                    String[] x = items[i].split(\" \");\n+                    String last = x[x.length-1];\n+                    switch (i)\n+                      {\n+                      case 0:\n+                        item.used = Integer.parseInt(last);\n+                        break;\n+                      case 1:\n+                        ptr = MemoryMap.parseHexLong(last.substring(2));\n+                        break;\n+                      case 2:\n+                        item.size = Integer.parseInt(last);\n+                        break;\n+                      case 3:\n+                        item.kind = Integer.parseInt(last);\n+                        break;\n+                      case 4:\n+                        if (last.length() > 1)\n+                          item.klass =\n+                            MemoryMap.parseHexLong(last.substring(2));\n+                        else\n+                          item.klass  = Integer.parseInt(last,16);\n+                        break;\n+                      case 5:\n+                        try\n+                          {\n+                            item.data =\n+                              Integer.parseInt(last.substring(2), 16);\n+                          }\n+                        catch (Exception e)\n+                          {\n+                            item.data = 0;\n+                          }\n+                        break;\n+                      }\n+                  }\n+                item.ptr = ptr;\n+                map.put(ptr, item);\n+              } // inner loop\n+          } // started inner loop\n+      } // outer loop - finding begin\n+    for (Map.Entry<Long, ObjectItem> me : this)\n+      {\n+        ObjectItem item = me.getValue();\n+        if (item.data != 0)\n+          {\n+            // see if data is a pointer to a block\n+            ObjectItem referenced = map.get(item.data);\n+            if (referenced != null)\n+              {\n+                referenced.reference = item;\n+              }\n+          }\n+      }\n+  } // memoryMap\n+\n+  public void dump()\n+  {\n+    for (Map.Entry<Long, ObjectItem> me : this)\n+      {\n+        long ptr = me.getKey();\n+        ObjectItem item = me.getValue();\n+        System.out.println(\"ptr = \" + Long.toHexString(ptr)\n+                           + \", size = \" + item.size\n+                           + \", klass = \" + Long.toHexString(item.klass)\n+                           + \", kind = \" + item.kind\n+                           + \", data = \" + item.data);\n+      }\n+  }\n+}"}, {"sha": "b3963d8cfd8ad0cef3937a4fe16c82dca0098d9f", "filename": "libjava/gnu/gcj/tools/gc_analyze/SymbolLookup.java", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolLookup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolLookup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolLookup.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,112 @@\n+/* SymbolLookup.java -- Finds class names by analyzing memory.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+\n+class SymbolLookup\n+{\n+  MemoryMap memoryMap;\n+\n+  public SymbolLookup(BufferedReader reader,\n+                      String rawFileName)\n+    throws IOException\n+  {\n+    memoryMap = new MemoryMap(reader, rawFileName);\n+  }\n+\n+  public String decodeUTF8(long address) throws IOException\n+  {\n+    return decodeUTF8(address, -1);\n+  }\n+  \n+  public String decodeUTF8(long address, int limit) throws IOException\n+  {\n+    if (address == 0)\n+      return null;\n+\n+    BytePtr utf8 = memoryMap.getBytePtr(address, 64);\n+\n+    if (utf8 == null)\n+      return null;\n+\n+    int len = utf8.getShort(1);\n+    int hash16 = utf8.getShort(0) & 0xffff;\n+\n+    if (len <= 0 || (limit > 0 && len > (limit - 4)))\n+      return null;\n+    \n+    if (len > utf8.getsize() + 4)\n+      utf8 = memoryMap.getBytePtr(address, len + 4);\n+\n+    if (utf8 == null)\n+      return null;\n+    \n+    StringBuilder sb = new StringBuilder(len);\n+    int pos = 4;\n+    len += 4;\n+    \n+    while (pos < len)\n+      {\n+        int f = utf8.getByte(pos++);\n+        if ((f & 0x80) == 0)\n+          {\n+            sb.append((char)f);\n+          }\n+        else if ((f & 0xe0) == 0xc0)\n+          {\n+            int s = utf8.getByte(pos++);\n+            char c = (char)(((f & 0x1f) << 6) | (s & 0x80));\n+            sb.append(c);\n+          }\n+        else if ((f & 0xe0) == 0xe0)\n+          {\n+            int s = utf8.getByte(pos++);\n+            int t = utf8.getByte(pos++);\n+            char c = (char)(((f & 0x0f) << 12)\n+                            | ((s & 0x80) << 6) | (t & 0x80));\n+            sb.append(c);\n+          }\n+        else \n+          break;  // Bad utf8\n+      }\n+    String rv = sb.toString();\n+    if (hash16 == (rv.hashCode() & 0xffff))\n+      return rv;\n+    else\n+      return null;\n+  }\n+\n+  public String getSymbolViaVtable(long address) throws IOException\n+  {\n+    return memoryMap.getSymbol(address);\n+  }\n+\n+  public String getSymbol(long address) throws IOException\n+  {\n+    String symbol = memoryMap.getSymbol(address);\n+    if (null != symbol)\n+      return symbol;\n+    \n+    BytePtr klass = memoryMap.getBytePtr(address, 3 * memoryMap.wordSize);\n+    if (klass == null)\n+      return null;\n+    \n+    long nameUTF8p = klass.getWord(2);\n+    \n+    return decodeUTF8(nameUTF8p);\n+  }\n+\n+  BytePtr getBytePtr(long addr, int length) throws IOException\n+  {\n+    return memoryMap.getBytePtr(addr, length);\n+  }\n+}"}, {"sha": "eb5df7641b78cfb273ae5c9443dc1eb79deb2e83", "filename": "libjava/gnu/gcj/tools/gc_analyze/SymbolTable.java", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FSymbolTable.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,198 @@\n+/* SymbolTable.java -- Maintains a mapping of addresses to names.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+class SymbolTable\n+{\n+  // Long address->String name\n+  private HashMap<Long, String> map = new HashMap<Long, String>();\n+\n+  // Reverse\n+  // String name -> Long address\n+  // used for RelocateImage\n+  private HashMap<String, Long> reverse = new HashMap<String, Long>();\n+  \n+  long loadAddr;\n+  long relocation;\n+\n+  static Matcher interestingSymbol =\n+    Pattern.compile(\"^([0-9a-fA-F]+)\\\\s+\\\\S+\\\\s+(_Z\\\\S+)\").matcher(\"\");\n+  static Matcher readelfLoadMatcher =\n+    Pattern.compile(\"^\\\\s+LOAD\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s.*\").matcher(\"\");\n+ \n+  public SymbolTable(String filename) throws IOException\n+  {\n+    Process p = Runtime.getRuntime().exec(ToolPrefix.toolPrefix\n+                                          + \"nm \" + filename);\n+    InputStream es = p.getErrorStream();\n+    InputStream is = p.getInputStream();\n+\n+    BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n+    int count = 0;\n+\n+    String line;\n+    while ((line = reader.readLine()) != null)\n+      {\n+        interestingSymbol.reset(line);\n+        if (interestingSymbol.matches())\n+          {\n+            try\n+              {\n+                String name = interestingSymbol.group(2);\n+                String addr = interestingSymbol.group(1);\n+                if (name.startsWith(\"_ZTVN\") || name.endsWith(\"6class$E\"))\n+                  {\n+                    long address = MemoryMap.parseHexLong(addr);\n+                    Long l = new Long(address);\n+                    map.put(l, name);\n+                    count++;\n+                    reverse.put(name, l);\n+                  }\n+              }\n+            catch (NumberFormatException e)\n+              {\n+                // ignore it\n+              }\n+          }\n+      }\n+    es.close();\n+    is.close();\n+    p.destroy();\n+    \n+    if (count > 0)\n+      {\n+        // Assume nm read some symbols from it and that\n+        // readelf can tell us something about how it is loaded.\n+        p = Runtime.getRuntime().exec(ToolPrefix.toolPrefix\n+                                      + \"readelf -l \" + filename);\n+        es = p.getErrorStream();\n+        is = p.getInputStream();\n+\n+        reader = new BufferedReader(new InputStreamReader(is));\n+        while ((line = reader.readLine()) != null)\n+          {\n+            readelfLoadMatcher.reset(line);\n+            if (readelfLoadMatcher.matches())\n+              {\n+                loadAddr\n+                  = Long.decode(readelfLoadMatcher.group(2)).longValue();\n+                break;\n+              }\n+          }\n+        es.close();\n+        is.close();\n+        p.destroy();\n+      }\n+    \n+    System.out.println(ToolPrefix.toolPrefix + \"nm \" + filename\n+                       + \" -> \" + count + \" symbols\");\n+  }\n+\n+  public static void main(String args[])\n+  {\n+    try\n+      {\n+        SymbolTable st = new SymbolTable(args[0]);\n+        st.dump();\n+      }\n+    catch (Exception ex)\n+      {\n+        ex.printStackTrace();\n+      }\n+  }\n+\n+  public static String demangleVTName(String n)\n+  {\n+    if (n.startsWith(\"_ZTVN\") && n.endsWith(\"E\"))\n+      return demangle(n.substring(5, n.length() - 1));\n+    else\n+      return null;\n+  }\n+\n+  public void dump()\n+  {\n+    for (Map.Entry<Long, String> me : map.entrySet())\n+      {\n+        long address = me.getKey();\n+        String symbol = me.getValue();\n+        System.out.println(Long.toHexString(address) + \" -> \" + symbol);\n+        if (symbol.startsWith(\"_ZN\") && symbol.endsWith(\"6class$E\"))\n+          {\n+            System.out.println(\"  Class: \"\n+                               + demangle(symbol.substring(3, symbol.length()\n+                                                           - 8)));\n+          }\n+        else if (symbol.startsWith(\"_ZTVN\") && symbol.endsWith(\"E\"))\n+          {\n+            System.out.println(\"  VT: \"\n+                               + demangle(symbol.substring(5, symbol.length()\n+                                                           - 1)));\n+          }\n+      }\n+  }\n+\n+  private static String demangle(String symbol)\n+  {\n+    StringBuilder sb = new StringBuilder();\n+    for (int i=0; i<symbol.length(); )\n+      {\n+        int l = 0;\n+        while (i < symbol.length())\n+          {\n+            int d = symbol.charAt(i);\n+            if (d < '0' || d > '9')\n+              break;\n+            l = 10 * l + (d - '0');\n+            i++;\n+          }\n+        if (l == 0)\n+          break; \n+        // copy\n+        if (sb.length() > 0)\n+          sb.append('.');\n+        while (l > 0 && i < symbol.length())\n+          {\n+            sb.append(symbol.charAt(i));\n+            l--;\n+            i++;\n+          }\n+      }\n+    return sb.toString();\n+  }\n+\n+  public String getSymbol(long address)\n+  {\n+    String symbol = map.get(address);\n+    if (symbol == null)\n+      return null;\n+\n+    if (symbol.startsWith(\"_ZN\") && symbol.endsWith(\"6class$E\"))\n+      symbol = demangle(symbol.substring(3, symbol.length() - 8));\n+    return symbol;\n+  }\n+\n+  // will return -1 if not found\n+  public long getAddress(String symbol)\n+  {\n+    Long address = reverse.get(symbol);\n+    if (address == null)\n+      return -1;\n+    return address.longValue();\n+  }\n+}"}, {"sha": "e8d73ae92dbac0ac9d6189259aa23288823767ab", "filename": "libjava/gnu/gcj/tools/gc_analyze/ToolPrefix.java", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FToolPrefix.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FToolPrefix.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgc_analyze%2FToolPrefix.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,45 @@\n+/* ToolPrefix.java -- Container of the toolPrefix String.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.tools.gc_analyze;\n+\n+import java.io.File;\n+\n+class ToolPrefix\n+{\n+  /**\n+   * Private constructor.  No creation allowed.  This class has\n+   * Static methods only.\n+    */\n+  private ToolPrefix()\n+  {\n+  }\n+  \n+  static String toolPrefix = \"\";\n+\n+  static String pathPrefix = \"\";\n+  \n+  static File fileForName(String filename)\n+  {\n+    File f = new File(pathPrefix + filename);\n+    if (!f.canRead())\n+      {\n+        // Try it without the prefix.\n+        f = new File(filename);\n+        if (!f.canRead())\n+          {\n+            // Try to find it in the current directory.\n+            f = new File(f.getName());\n+            if (!f.canRead())\n+              return null;\n+          }      \n+      }\n+    return f;\n+  }\n+}"}, {"sha": "06e0dd0d06c8047723ee33feb399acffcd27c3ec", "filename": "libjava/gnu/gcj/util/GCInfo.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FGCInfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FGCInfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2FGCInfo.h?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,45 @@\n+\n+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n+\n+#ifndef __gnu_gcj_util_GCInfo__\n+#define __gnu_gcj_util_GCInfo__\n+\n+#pragma interface\n+\n+#include <java/lang/Object.h>\n+extern \"Java\"\n+{\n+  namespace gnu\n+  {\n+    namespace gcj\n+    {\n+      namespace util\n+      {\n+          class GCInfo;\n+      }\n+    }\n+  }\n+}\n+\n+class gnu::gcj::util::GCInfo : public ::java::lang::Object\n+{\n+\n+  GCInfo();\n+  static void checkPermission();\n+public:\n+  static void dump(::java::lang::String *);\n+private:\n+  static void dump0(::java::lang::String *);\n+public:\n+  static void enumerate(::java::lang::String *);\n+private:\n+  static void enumerate0(::java::lang::String *);\n+public:\n+  static void setOOMDump(::java::lang::String *);\n+private:\n+  static void setOOMDump0(::java::lang::String *);\n+public:\n+  static ::java::lang::Class class$;\n+};\n+\n+#endif // __gnu_gcj_util_GCInfo__"}, {"sha": "73f4718f9f2337671ed4417962458ddaf1a93e73", "filename": "libjava/gnu/gcj/util/GCInfo.java", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FGCInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FGCInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2FGCInfo.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,79 @@\n+/* GCInfo.java -- Support for creating heap dumps.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n+\n+package gnu.gcj.util;\n+\n+public class GCInfo\n+{\n+  private GCInfo()\n+  {\n+  }\n+\n+  /**\n+   * @throws SecurityException if there is a SecurityManager installed\n+   * and UtilPermission(\"dumpHeap\") is not granted.\n+   */\n+  private static void checkPermission()\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission(new UtilPermission(\"dumpHeap\"));\n+  }\n+  \n+\n+  /**\n+   * Dump a description of the heap state.\n+   *\n+   * @param namePrefix The filename prefix for the dump files.\n+   *\n+   * @throws SecurityException if there is a SecurityManager installed\n+   * and UtilPermission(\"dumpHeap\") is not granted.\n+   */\n+  public static synchronized void dump(String name)\n+  {\n+    checkPermission();\n+    dump0(name);\n+  }\n+  \n+  private static native void dump0(String name);\n+\n+\n+  /**\n+   * Create a heap dump.\n+   *\n+   * @param namePrefix The filename prefix for the dump files.\n+   *\n+   * @throws SecurityException if there is a SecurityManager installed\n+   * and UtilPermission(\"dumpHeap\") is not granted.\n+   */\n+  public static synchronized void enumerate(String namePrefix)\n+  {\n+    checkPermission();\n+    enumerate0(namePrefix);\n+  }\n+  \n+  private static native void enumerate0(String namePrefix);\n+\n+  /**\n+   * Cause a heap dump if out-of-memory condition occurs.\n+   *\n+   * @param namePrefix The filename prefix for the dump files.  If\n+   * null no dumps are created.\n+   *\n+   * @throws SecurityException if there is a SecurityManager installed\n+   * and UtilPermission(\"dumpHeap\") is not granted.\n+   */\n+  public static synchronized void setOOMDump(String namePrefix)\n+  {\n+    checkPermission();\n+    setOOMDump0(namePrefix);\n+  }\n+  \n+  private static native void setOOMDump0(String namePrefix);\n+}"}, {"sha": "4c7b2267154a084b578a2844fe53b0316199a234", "filename": "libjava/gnu/gcj/util/UtilPermission.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FUtilPermission.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FUtilPermission.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2FUtilPermission.h?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,32 @@\n+\n+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n+\n+#ifndef __gnu_gcj_util_UtilPermission__\n+#define __gnu_gcj_util_UtilPermission__\n+\n+#pragma interface\n+\n+#include <java/security/BasicPermission.h>\n+extern \"Java\"\n+{\n+  namespace gnu\n+  {\n+    namespace gcj\n+    {\n+      namespace util\n+      {\n+          class UtilPermission;\n+      }\n+    }\n+  }\n+}\n+\n+class gnu::gcj::util::UtilPermission : public ::java::security::BasicPermission\n+{\n+\n+public:\n+  UtilPermission(::java::lang::String *);\n+  static ::java::lang::Class class$;\n+};\n+\n+#endif // __gnu_gcj_util_UtilPermission__"}, {"sha": "1ea4cb71668c61b285346a8bba8900074d84f1e1", "filename": "libjava/gnu/gcj/util/UtilPermission.java", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FUtilPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FUtilPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2FUtilPermission.java?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,20 @@\n+/* GCInfo.java -- Support for creating heap dumps.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n+\n+package gnu.gcj.util;\n+\n+import java.security.BasicPermission;\n+\n+public class UtilPermission extends BasicPermission\n+{\n+  public UtilPermission(String name)\n+  {\n+    super(name);\n+  }\n+}"}, {"sha": "7e5c6fbb8454984934fe96d9bd4d6a532ccd6f67", "filename": "libjava/gnu/gcj/util/natGCInfo.cc", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FnatGCInfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fgnu%2Fgcj%2Futil%2FnatGCInfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2FnatGCInfo.cc?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -0,0 +1,454 @@\n+/* natGCInfo.cc -- Native portion of support for creating heap dumps.\n+   Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n+\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+\n+#include <gnu/gcj/util/GCInfo.h>\n+\n+#ifdef HAVE_PROC_SELF_MAPS\n+//\n+// If /proc/self/maps does not exist we assume we are doomed and do nothing.\n+//\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+//\n+// Boehm GC includes.\n+//\n+#ifdef PACKAGE_NAME\n+#undef PACKAGE_NAME\n+#endif\n+\n+#ifdef PACKAGE_STRING\n+#undef PACKAGE_STRING\n+#endif\n+\n+#ifdef PACKAGE_TARNAME\n+#undef PACKAGE_TARNAME\n+#endif\n+\n+#ifdef PACKAGE_VERSION\n+#undef PACKAGE_VERSION\n+#endif\n+\n+#ifdef TRUE\n+#undef TRUE\n+#endif\n+\n+#ifdef FALSE\n+#undef FALSE\n+#endif\n+\n+extern \"C\" {\n+#include \"private/dbg_mlc.h\"\n+  int GC_n_set_marks(hdr* hhdr);\n+  ptr_t GC_clear_stack(ptr_t p);\n+  extern int GC_gcj_kind;\n+  extern int GC_gcj_debug_kind;\n+}\n+\n+#endif\n+\n+#ifdef HAVE_PROC_SELF_MAPS\n+\n+static int gc_ok = 1;\n+\n+typedef struct gc_debug_info\n+{\n+  int used;\n+  int free;\n+  int wasted;\n+  int blocks;\n+  FILE* fp;\n+};\n+\n+static void\n+GC_print_debug_callback(hblk *h, word user_data)\n+{\n+  hdr *hhdr = HDR(h);\n+  size_t bytes = WORDS_TO_BYTES(hhdr -> hb_sz);\n+\n+  gc_debug_info *pinfo = (gc_debug_info *)user_data;\n+\n+  fprintf(pinfo->fp, \"ptr = %#lx, kind = %d, size = %zd, marks = %d\\n\",\n+          (unsigned long)h, hhdr->hb_obj_kind, bytes, GC_n_set_marks(hhdr));\n+}\n+\n+/*\n+  this next section of definitions shouldn't really be here.\n+  copied from boehmgc/allchblk.c\n+*/\n+\n+# define UNIQUE_THRESHOLD 32\n+# define HUGE_THRESHOLD 256\n+# define FL_COMPRESSION 8\n+# define N_HBLK_FLS (HUGE_THRESHOLD - UNIQUE_THRESHOLD)/FL_COMPRESSION \\\n+                         + UNIQUE_THRESHOLD\n+#ifndef USE_MUNMAP\n+extern \"C\" {\n+  extern word GC_free_bytes[N_HBLK_FLS+1];\n+}\n+#endif\n+\n+# ifdef USE_MUNMAP\n+#   define IS_MAPPED(hhdr) (((hhdr) -> hb_flags & WAS_UNMAPPED) == 0)\n+# else  /* !USE_MMAP */\n+#   define IS_MAPPED(hhdr) 1\n+# endif /* USE_MUNMAP */\n+\n+static void\n+GC_print_hblkfreelist_file(FILE *fp)\n+{\n+  struct hblk * h;\n+  word total_free = 0;\n+  hdr * hhdr;\n+  word sz;\n+  int i;\n+    \n+  fprintf(fp, \"---------- Begin free map ----------\\n\");\n+  for (i = 0; i <= N_HBLK_FLS; ++i)\n+    {\n+      h = GC_hblkfreelist[i];\n+#ifdef USE_MUNMAP\n+      if (0 != h)\n+        fprintf (fp, \"Free list %ld:\\n\", (unsigned long)i);\n+#else\n+      if (0 != h)\n+        fprintf (fp, \"Free list %ld (Total size %ld):\\n\",\n+                 (unsigned long)i,\n+                 (unsigned long)GC_free_bytes[i]);\n+#endif\n+      while (h != 0)\n+        {\n+          hhdr = HDR(h);\n+          sz = hhdr -> hb_sz;\n+          fprintf (fp, \"\\t0x%lx size %lu \", (unsigned long)h,\n+                   (unsigned long)sz);\n+          total_free += sz;\n+\n+          if (GC_is_black_listed (h, HBLKSIZE) != 0)\n+            fprintf (fp, \"start black listed\\n\");\n+          else if (GC_is_black_listed(h, hhdr -> hb_sz) != 0)\n+            fprintf (fp, \"partially black listed\\n\");\n+          else\n+            fprintf (fp, \"not black listed\\n\");\n+\n+          h = hhdr -> hb_next;\n+        }\n+    }\n+#ifndef USE_MUNMAP\n+  if (total_free != GC_large_free_bytes)\n+    {\n+      fprintf (fp, \"GC_large_free_bytes = %lu (INCONSISTENT!!)\\n\",\n+               (unsigned long) GC_large_free_bytes);\n+    }\n+#endif\n+  fprintf (fp, \"Total of %lu bytes on free list\\n\", (unsigned long)total_free);\n+  fprintf (fp, \"---------- End free map ----------\\n\");\n+}\n+\n+static int GC_dump_count = 1;\n+\n+static void\n+GC_print_debug_info_file(FILE* fp)\n+{\n+  gc_debug_info info;\n+\n+  memset(&info, 0, sizeof info);\n+  info.fp = fp;\n+\n+  if (gc_ok)\n+    GC_gcollect();\n+  fprintf(info.fp, \"---------- Begin block map ----------\\n\");\n+  GC_apply_to_all_blocks(GC_print_debug_callback, (word)(void*)(&info));\n+  //fprintf(fp, \"#Total used %d free %d wasted %d\\n\", info.used, info.free, info.wasted);\n+  //fprintf(fp, \"#Total blocks %d; %dK bytes\\n\", info.blocks, info.blocks*4);\n+  fprintf(info.fp, \"---------- End block map ----------\\n\");\n+\n+  //fprintf(fp, \"\\n***Free blocks:\\n\");\n+  //GC_print_hblkfreelist();\n+}\n+\n+namespace\n+{\n+  class  __attribute__ ((visibility (\"hidden\"))) GC_enumerator\n+  {\n+  public:\n+    GC_enumerator(const char *name);\n+    void enumerate();\n+  private:\n+    FILE* fp;\n+    int bytes_fd;\n+\n+    void print_address_map();\n+    void enumerate_callback(struct hblk *h);\n+    static void enumerate_callback_adaptor(struct hblk *h, word dummy);\n+  };\n+}\n+\n+GC_enumerator::GC_enumerator(const char *name)\n+{\n+  bytes_fd = -1;\n+  fp = fopen (name, \"w\");\n+  if (!fp)\n+    {\n+      printf (\"GC_enumerator failed to open [%s]\\n\", name);\n+      return;\n+    }\n+  printf (\"GC_enumerator saving summary to [%s]\\n\", name);\n+\n+  // open heap file\n+  char bytes_name[strlen(name) + 10];\n+  sprintf (bytes_name, \"%s.bytes\", name);\n+  bytes_fd = open (bytes_name, O_CREAT|O_TRUNC|O_WRONLY, 0666);\n+  if (bytes_fd <= 0)\n+    {\n+      printf (\"GC_enumerator failed to open [%s]\\n\", bytes_name);\n+      return;\n+    }\n+  printf (\"GC_enumerator saving heap contents to [%s]\\n\", bytes_name);\n+}\n+\n+/*\n+  sample format of /proc/self/maps\n+\n+  0063b000-00686000 rw-p 001fb000 03:01 81993      /avtrex/bin/dumppropapp\n+  00686000-0072e000 rwxp 00000000 00:00 0 \n+\n+  These are parsed below as:\n+  start   -end      xxxx xxxxxxxx  a:b xxxxxxxxxxxxxxx\n+\n+*/\n+\n+\n+void\n+GC_enumerator::print_address_map()\n+{\n+  FILE* fm;\n+  char buffer[128];\n+\n+  fprintf(fp, \"---------- Begin address map ----------\\n\");\n+\n+  fm = fopen(\"/proc/self/maps\", \"r\");\n+  if (fm == NULL)\n+    {\n+      if (0 == strerror_r (errno, buffer, sizeof buffer))\n+        fputs (buffer, fp);\n+    }\n+  else\n+    {\n+      while (fgets (buffer, sizeof buffer, fm) != NULL)\n+        {\n+          fputs (buffer, fp);\n+          char *dash = strchr(buffer, '-');\n+          char *colon = strchr(buffer, ':');\n+          if (dash && colon && ((ptrdiff_t)strlen(buffer) > (colon - buffer) + 2))\n+            {\n+              char *endp;\n+              unsigned long start = strtoul(buffer, NULL, 16);\n+              unsigned long end   = strtoul(dash + 1, &endp, 16);\n+              unsigned long a     = strtoul(colon - 2, NULL, 16);\n+              unsigned long b     = strtoul(colon + 1, NULL, 16);\n+              // If it is an anonymous mapping 00:00 and both readable\n+              // and writeable then dump the contents of the mapping\n+              // to the bytes file.  Each block has a header of three\n+              // unsigned longs:\n+              // 0 - The number sizeof(unsigned long) to detect endianness and\n+              //     structure layout.\n+              // 1 - The offset in VM.\n+              // 2 - The Length in bytes.\n+              // Followed by the bytes.\n+              if (!a && !b && endp < colon && 'r' == endp[1] && 'w' == endp[2])\n+                {\n+                  unsigned long t = sizeof(unsigned long);\n+                  write(bytes_fd, (void*)&t, sizeof(t));\n+                  write(bytes_fd, (void*)&start, sizeof(start));\n+                  t = end - start;\n+                  write(bytes_fd, (void*)&t, sizeof(t));\n+                  write(bytes_fd, (void*)start, (end - start));\n+                }\n+            }\n+        } \n+      fclose(fm);\n+    }\n+  fprintf(fp, \"---------- End address map ----------\\n\");\n+  fflush(fp);\n+}\n+\n+void\n+GC_enumerator::enumerate()\n+{\n+  print_address_map();\n+  fprintf(fp, \"---------- Begin object map ----------\\n\");\n+  if (gc_ok)\n+    GC_gcollect();\n+  GC_apply_to_all_blocks(enumerate_callback_adaptor, \n+                         (word)(void*)(this));\n+  fprintf(fp, \"---------- End object map ----------\\n\");\n+  fflush(fp); \n+\n+  GC_print_debug_info_file(fp);\n+  fflush(fp); \n+  GC_print_hblkfreelist_file(fp);\n+  fflush(fp); \n+\n+  close(bytes_fd);\n+  fclose(fp);\n+\n+  GC_clear_stack(0);\n+}\n+\n+void\n+GC_enumerator::enumerate_callback_adaptor(struct hblk *h,\n+                                          word dummy)\n+{\n+  GC_enumerator* pinfo = (GC_enumerator*)dummy;\n+  pinfo->enumerate_callback(h);\n+}\n+\n+void\n+GC_enumerator::enumerate_callback(struct hblk *h)\n+{\n+  hdr * hhdr = HDR(h);\n+  size_t bytes = WORDS_TO_BYTES(hhdr->hb_sz);\n+  int i;\n+\n+  for (i = 0; i == 0 || (i + bytes <= HBLKSIZE); i += bytes)\n+    {\n+      int inUse = mark_bit_from_hdr(hhdr,BYTES_TO_WORDS(i));  // in use\n+      char *ptr = (char*)h+i;                                 // address\n+      int kind = hhdr->hb_obj_kind;                           // kind\n+      void *klass = 0;\n+      void *data = 0;\n+      if (kind == GC_gcj_kind\n+          || kind == GC_gcj_debug_kind\n+          || kind == GC_gcj_debug_kind+1)\n+        {\n+          void* v = *(void **)ptr;\n+          if (v)\n+            {\n+              klass = *(void **)v;\n+              data = *(void **)(ptr + sizeof(void*));\n+            }\n+        }\n+      if (inUse)\n+        fprintf (fp, \"used = %d, ptr = %#lx, size = %zd, kind = %d, \"\n+                 \"klass = %#lx, data = %#lx\\n\", \n+                 inUse, (unsigned long)ptr, bytes, kind,\n+                 (unsigned long)klass, (unsigned long)data);\n+    }\n+}\n+\n+/*\n+ * Fill in a char[] with low bytes of the string characters.  These\n+ * methods may be called while an OutOfMemoryError is being thrown, so\n+ * we cannot call nice java methods to get the encoding of the string.\n+ */\n+static void\n+J2A(::java::lang::String* str, char *dst)\n+{\n+  jchar * pchars = JvGetStringChars(str);\n+  jint len = str->length();\n+  int i;\n+  for (i=0; i<len; i++)\n+    dst[i] = (char)pchars[i];\n+  dst[i] = 0;\n+}\n+\n+void\n+::gnu::gcj::util::GCInfo::dump0 (::java::lang::String * name)\n+{\n+  char n[name->length() + 1];\n+  J2A(name, n);\n+  \n+  char temp[name->length() + 20];\n+  sprintf(temp, \"%s%03d\", n, GC_dump_count++);\n+  FILE* fp = fopen(temp, \"w\");\n+\n+  GC_print_debug_info_file(fp);\n+\n+  fclose(fp);\n+}\n+\n+void\n+::gnu::gcj::util::GCInfo::enumerate0 (::java::lang::String * name)\n+{\n+  char n[name->length() + 1];\n+  J2A(name, n);\n+  char temp[name->length() + 20];\n+  sprintf(temp, \"%s%03d\", n, GC_dump_count++);\n+\n+  GC_enumerator x(temp);\n+  x.enumerate();\n+}\n+\n+static char *oomDumpName = NULL;\n+\n+static void *\n+nomem_handler(size_t size)\n+{\n+  if (oomDumpName)\n+    {\n+      char temp[strlen(oomDumpName) + 20];\n+      sprintf(temp, \"%s%03d\", temp, GC_dump_count++);\n+      printf(\"nomem_handler(%zd) called\\n\", size);\n+      gc_ok--;\n+      GC_enumerator x(temp);\n+      x.enumerate();\n+      gc_ok++;\n+    }\n+  return (void*)0;\n+}\n+\n+void\n+::gnu::gcj::util::GCInfo::setOOMDump0 (::java::lang::String * name)\n+{\n+  char *oldName = oomDumpName;\n+  oomDumpName = NULL;\n+  free (oldName);\n+  \n+  if (NULL == name)\n+    return;\n+  \n+  char *n = (char *)malloc(name->length() + 1);\n+\n+  J2A(name, n);\n+  oomDumpName = n;\n+  GC_oom_fn = nomem_handler;\n+}\n+\n+#else  // HAVE_PROC_SELF_MAPS\n+\n+void\n+::gnu::gcj::util::GCInfo::dump0 (::java::lang::String * name)\n+{\n+  // Do nothing if dumping not supported.\n+}\n+\n+void\n+::gnu::gcj::util::GCInfo::enumerate0 (::java::lang::String * name)\n+{\n+  // Do nothing if dumping not supported.\n+}\n+\n+void\n+::gnu::gcj::util::GCInfo::setOOMDump0 (::java::lang::String * name)\n+{\n+  // Do nothing if dumping not supported.\n+}\n+\n+#endif // HAVE_PROC_SELF_MAPS\n+"}, {"sha": "2c025a27af5b9468aa6bc249e1cd3ad3af44f127", "filename": "libjava/include/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -232,6 +232,9 @@\n /* Define if you have /proc/self/exe */\n #undef HAVE_PROC_SELF_EXE\n \n+/* Define if you have /proc/self/maps */\n+#undef HAVE_PROC_SELF_MAPS\n+\n /* Define if using POSIX threads that have the mutexattr functions. */\n #undef HAVE_PTHREAD_MUTEXATTR_INIT\n \n@@ -375,6 +378,9 @@\n /* Define to 1 if you have the file `AC_File'. */\n #undef HAVE__PROC_SELF_EXE\n \n+/* Define to 1 if you have the file `AC_File'. */\n+#undef HAVE__PROC_SELF_MAPS\n+\n /* Define as const if the declaration of iconv() needs const. */\n #undef ICONV_CONST\n "}, {"sha": "5a60097d698de0a48ad36bccccc77ccfc5e7e969", "filename": "libjava/scripts/makemake.tcl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fscripts%2Fmakemake.tcl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fscripts%2Fmakemake.tcl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fscripts%2Fmakemake.tcl?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -42,6 +42,7 @@ set package_map(.) package\n # These are ignored in Classpath.\n set package_map(gnu/test) ignore\n set package_map(gnu/javax/swing/plaf/gtk) ignore\n+set package_map(gnu/gcj/tools/gc_analyze) ignore\n \n set package_map(gnu/java/awt/peer/swing) bc\n "}, {"sha": "79b8832bb43945db4be32ff98f927a5d5360e40e", "filename": "libjava/sources.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f40378f06a5723ede9c8abc23775cadcdd0037c/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=7f40378f06a5723ede9c8abc23775cadcdd0037c", "patch": "@@ -555,7 +555,9 @@ gnu/gcj/tools/gcj_dbtool.list: $(gnu_gcj_tools_gcj_dbtool_source_files)\n \n \n gnu_gcj_util_source_files = \\\n-gnu/gcj/util/Debug.java\n+gnu/gcj/util/Debug.java \\\n+gnu/gcj/util/GCInfo.java \\\n+gnu/gcj/util/UtilPermission.java\n \n gnu_gcj_util_header_files = $(patsubst %.java,%.h,$(gnu_gcj_util_source_files))\n "}]}