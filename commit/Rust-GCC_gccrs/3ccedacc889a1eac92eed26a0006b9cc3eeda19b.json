{"sha": "3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjZWRhY2M4ODlhMWVhYzkyZWVkMjZhMDAwNmI5Y2MzZWVkYTE5Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T10:57:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T10:57:32Z"}, "message": "[multiple changes]\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb: Minor reformatting.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case Assert and related pragmas):\n\tBefore normalizing these pragmas into a pragma Check, preanalyze\n\tthe optional Message argument, (which is subsequently copied)\n\tso that it has the proper semantic information for ASIS use.\n\t* sem_case.adb: Initialize flag earlier.\n\t* osint.adb, osint.ads (Find_File): Add parameter Full_Name, used when\n\tthe full source path of a configuration file is requested.\n\t(Read_Source_File): Use Full_Name parameter..\n\nFrom-SVN: r213571", "tree": {"sha": "d6f8f350a66150fb3508f68a68d6944ea0d841ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6f8f350a66150fb3508f68a68d6944ea0d841ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/comments", "author": null, "committer": null, "parents": [{"sha": "f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3124d8f6431bcfce76eca31a198ba89ce0d15fe"}], "stats": {"total": 188, "additions": 110, "deletions": 78}, "files": [{"sha": "4737fc7a9acb3f6dc4f81c1e4d2a1339176e6da2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "patch": "@@ -1,3 +1,18 @@\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb: Minor reformatting.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Assert and related pragmas):\n+\tBefore normalizing these pragmas into a pragma Check, preanalyze\n+\tthe optional Message argument, (which is subsequently copied)\n+\tso that it has the proper semantic information for ASIS use.\n+\t* sem_case.adb: Initialize flag earlier.\n+\t* osint.adb, osint.ads (Find_File): Add parameter Full_Name, used when\n+\tthe full source path of a configuration file is requested.\n+\t(Read_Source_File): Use Full_Name parameter..\n+\n 2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* opt.ads Alphabetize various global flags. New flag"}, {"sha": "3fd796c495390cb9fc5aa6e3855d8d897750e788", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "patch": "@@ -119,10 +119,11 @@ package body Osint is\n    --  failure\n \n    procedure Find_File\n-     (N     : File_Name_Type;\n-      T     : File_Type;\n-      Found : out File_Name_Type;\n-      Attr  : access File_Attributes);\n+     (N         : File_Name_Type;\n+      T         : File_Type;\n+      Found     : out File_Name_Type;\n+      Attr      : access File_Attributes;\n+      Full_Name : Boolean := False);\n    --  A version of Find_File that also returns a cache of the file attributes\n    --  for later reuse\n \n@@ -1153,13 +1154,14 @@ package body Osint is\n    ---------------\n \n    function Find_File\n-     (N : File_Name_Type;\n-      T : File_Type) return File_Name_Type\n+     (N         : File_Name_Type;\n+      T         : File_Type;\n+      Full_Name : Boolean := False) return File_Name_Type\n    is\n       Attr  : aliased File_Attributes;\n       Found : File_Name_Type;\n    begin\n-      Find_File (N, T, Found, Attr'Access);\n+      Find_File (N, T, Found, Attr'Access, Full_Name);\n       return Found;\n    end Find_File;\n \n@@ -1168,10 +1170,11 @@ package body Osint is\n    ---------------\n \n    procedure Find_File\n-     (N     : File_Name_Type;\n-      T     : File_Type;\n-      Found : out File_Name_Type;\n-      Attr  : access File_Attributes) is\n+     (N         : File_Name_Type;\n+      T         : File_Type;\n+      Found     : out File_Name_Type;\n+      Attr      : access File_Attributes;\n+      Full_Name : Boolean := False) is\n    begin\n       Get_Name_String (N);\n \n@@ -1193,6 +1196,20 @@ package body Osint is\n          then\n             Found := N;\n             Attr.all  := Unknown_Attributes;\n+\n+            if T = Config and then Full_Name then\n+               declare\n+                  Full_Path : constant String :=\n+                           Normalize_Pathname (Get_Name_String (N));\n+                  Full_Size : constant Natural := Full_Path'Length;\n+\n+               begin\n+                  Name_Buffer (1 .. Full_Size) := Full_Path;\n+                  Name_Len := Full_Size;\n+                  Found := Name_Find;\n+               end;\n+            end if;\n+\n             return;\n \n          --  If we are trying to find the current main file just look in the\n@@ -2591,7 +2608,7 @@ package body Osint is\n       --  For the call to Close\n \n    begin\n-      Current_Full_Source_Name  := Find_File (N, T);\n+      Current_Full_Source_Name  := Find_File (N, T, Full_Name => True);\n       Current_Full_Source_Stamp := File_Stamp (Current_Full_Source_Name);\n \n       if Current_Full_Source_Name = No_File then"}, {"sha": "caddf666b2af24047357ed9681c44cedee0369be", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "patch": "@@ -63,8 +63,9 @@ package Osint is\n    type File_Type is (Source, Library, Config, Definition, Preprocessing_Data);\n \n    function Find_File\n-     (N : File_Name_Type;\n-      T : File_Type) return File_Name_Type;\n+     (N         : File_Name_Type;\n+      T         : File_Type;\n+      Full_Name : Boolean := False) return File_Name_Type;\n    --  Finds a source, library or config file depending on the value of T\n    --  following the directory search order rules unless N is the name of the\n    --  file just read with Next_Main_File and already contains directory\n@@ -76,6 +77,9 @@ package Osint is\n    --  set and the file name ends in \".dg\", in which case we look for the\n    --  generated file only in the current directory, since that is where it is\n    --  always built.\n+   --  In the case of configuration files, full path names are needed for some\n+   --  ASIS queries. The flag Full_Name indicates that the name of the file\n+   --  should be normalized to include a full path.\n \n    function Get_File_Names_Case_Sensitive return Int;\n    pragma Import (C, Get_File_Names_Case_Sensitive,"}, {"sha": "201855b5e364518ee93f0a2fc7db5f5f1f7deb5b", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "patch": "@@ -735,6 +735,8 @@ package body Sem_Case is\n          return;\n       end if;\n \n+      Predicate_Error := False;\n+\n       --  Choice_Table must start at 0 which is an unused location used by the\n       --  sorting algorithm. However the first valid position for a discrete\n       --  choice is 1.\n@@ -762,8 +764,6 @@ package body Sem_Case is\n       --  expression is static, independently of whether the aspect mentions\n       --  Static explicitly.\n \n-      Predicate_Error := False;\n-\n       if Has_Predicate then\n          Pred    := First (Static_Discrete_Predicate (Bounds_Type));\n          Prev_Lo := Uint_Minus_1;"}, {"sha": "f7b73754eb8640bc60a0ba87f3bfe5cd861b71b4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 49, "deletions": 60, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "patch": "@@ -632,8 +632,8 @@ package body Sem_Ch6 is\n               and then not GNAT_Mode\n             then\n                Error_Msg_N\n-                 (\"(Ada 2005) cannot copy object of a limited type \" &\n-                  \"(RM-2005 6.5(5.5/2))\", Expr);\n+                 (\"(Ada 2005) cannot copy object of a limited type \"\n+                  & \"(RM-2005 6.5(5.5/2))\", Expr);\n \n                if Is_Limited_View (R_Type) then\n                   Error_Msg_N\n@@ -723,7 +723,7 @@ package body Sem_Ch6 is\n             if not Predicates_Match (R_Stm_Type, R_Type) then\n                Error_Msg_Node_2 := R_Type;\n                Error_Msg_NE\n-                 (\"\\predicate of & does not match predicate of &\",\n+                 (\"\\predicate of& does not match predicate of&\",\n                   N, R_Stm_Type);\n             end if;\n          end Error_No_Match;\n@@ -774,8 +774,8 @@ package body Sem_Ch6 is\n          elsif R_Stm_Type_Is_Anon_Access\n            and then not R_Type_Is_Anon_Access\n          then\n-            Error_Msg_N (\"anonymous access not allowed for function with \" &\n-                         \"named access result\", Subtype_Ind);\n+            Error_Msg_N (\"anonymous access not allowed for function with \"\n+                         & \"named access result\", Subtype_Ind);\n \n          --  Subtype indication case: check that the return object's type is\n          --  covered by the result type, and that the subtypes statically match\n@@ -942,8 +942,8 @@ package body Sem_Ch6 is\n                      & \"in Ada 2012??\", N);\n \n                elsif not Is_Limited_View (R_Type) then\n-                  Error_Msg_N (\"aliased only allowed for limited\"\n-                     & \" return objects\", N);\n+                  Error_Msg_N\n+                    (\"aliased only allowed for limited return objects\", N);\n                end if;\n             end if;\n          end;\n@@ -1013,8 +1013,8 @@ package body Sem_Ch6 is\n                  Subprogram_Access_Level (Scope_Id)\n             then\n                Error_Msg_N\n-                 (\"level of return expression type is deeper than \" &\n-                  \"class-wide function!\", Expr);\n+                 (\"level of return expression type is deeper than \"\n+                  & \"class-wide function!\", Expr);\n             end if;\n          end if;\n \n@@ -1807,8 +1807,8 @@ package body Sem_Ch6 is\n \n             else\n                Error_Msg_N\n-                 (\"return nested in extended return statement cannot return \" &\n-                  \"value (use `RETURN;`)\", N);\n+                 (\"return nested in extended return statement cannot return \"\n+                  & \"value (use `RETURN;`)\", N);\n             end if;\n          end if;\n \n@@ -2128,7 +2128,7 @@ package body Sem_Ch6 is\n            and then Contains_Refined_State (Prag)\n          then\n             Error_Msg_NE\n-              (\"body of subprogram & requires global refinement\",\n+              (\"body of subprogram& requires global refinement\",\n                Body_Decl, Spec_Id);\n          end if;\n       end if;\n@@ -2151,7 +2151,7 @@ package body Sem_Ch6 is\n            and then Contains_Refined_State (Prag)\n          then\n             Error_Msg_NE\n-              (\"body of subprogram & requires dependance refinement\",\n+              (\"body of subprogram& requires dependance refinement\",\n                Body_Decl, Spec_Id);\n          end if;\n       end if;\n@@ -2952,7 +2952,7 @@ package body Sem_Ch6 is\n               and then  Operator_Matches_Spec (Spec_Id, Spec_Id)\n             then\n                Error_Msg_NE\n-                 (\"subprogram & overrides predefined operator \",\n+                 (\"subprogram& overrides predefined operator \",\n                     Body_Spec, Spec_Id);\n \n             --  Overriding indicators aren't allowed for protected subprogram\n@@ -2963,18 +2963,16 @@ package body Sem_Ch6 is\n                Error_Msg_Warn := Error_To_Warning;\n \n                Error_Msg_N\n-                 (\"<<overriding indicator not allowed \" &\n-                  \"for protected subprogram body\",\n-                  Body_Spec);\n+                 (\"<<overriding indicator not allowed \"\n+                  & \"for protected subprogram body\", Body_Spec);\n \n             --  If this is not a primitive operation, then the overriding\n             --  indicator is altogether illegal.\n \n             elsif not Is_Primitive (Spec_Id) then\n                Error_Msg_N\n-                 (\"overriding indicator only allowed \" &\n-                  \"if subprogram is primitive\",\n-                  Body_Spec);\n+                 (\"overriding indicator only allowed \"\n+                  & \"if subprogram is primitive\", Body_Spec);\n             end if;\n \n          --  If checking the style rule and the operation overrides, then\n@@ -3764,7 +3762,7 @@ package body Sem_Ch6 is\n \n          else\n             Error_Msg_Sloc := Sloc (SPARK_Pragma (Body_Id));\n-            Error_Msg_N (\"incorrect application of SPARK_Mode#\", N);\n+            Error_Msg_N (\"incorrect application of SPARK_Mode #\", N);\n             Error_Msg_Sloc := Sloc (Spec_Id);\n             Error_Msg_NE\n               (\"\\no value was set for SPARK_Mode on & #\", N, Spec_Id);\n@@ -4746,7 +4744,7 @@ package body Sem_Ch6 is\n             --  this before checking that the types of the formals match.\n \n             if Chars (Old_Formal) /= Chars (New_Formal) then\n-               Conformance_Error (\"\\name & does not match!\", New_Formal);\n+               Conformance_Error (\"\\name& does not match!\", New_Formal);\n \n                --  Set error posted flag on new formal as well to stop\n                --  junk cascaded messages in some cases.\n@@ -4769,7 +4767,7 @@ package body Sem_Ch6 is\n                   Comes_From_Source (New_Formal)\n                then\n                   Conformance_Error\n-                    (\"\\null exclusion for & does not match\", New_Formal);\n+                    (\"\\null exclusion for& does not match\", New_Formal);\n \n                   --  Mark error posted on the new formal to avoid duplicated\n                   --  complaint about types not matching.\n@@ -4905,8 +4903,7 @@ package body Sem_Ch6 is\n                   declare\n                      T : constant  Entity_Id := Find_Dispatching_Type (New_Id);\n                   begin\n-                     if Is_Protected_Type\n-                          (Corresponding_Concurrent_Type (T))\n+                     if Is_Protected_Type (Corresponding_Concurrent_Type (T))\n                      then\n                         Error_Msg_PT (T, New_Id);\n                      else\n@@ -4979,9 +4976,9 @@ package body Sem_Ch6 is\n                      if Is_Controlling_Formal (New_Formal) then\n                         Error_Msg_Node_2 := Scope (New_Formal);\n                         Conformance_Error\n-                         (\"\\controlling formal& of& excludes null, \"\n-                           & \"declaration must exclude null as well\",\n-                            New_Formal);\n+                         (\"\\controlling formal & of & excludes null, \"\n+                          & \"declaration must exclude null as well\",\n+                          New_Formal);\n \n                      --  Normal case (couldn't we give more detail here???)\n \n@@ -5175,23 +5172,21 @@ package body Sem_Ch6 is\n                         Error_Msg_N (\"\\\\primitive % defined #\", Typ);\n                      else\n                         Error_Msg_N\n-                          (\"\\\\overriding operation % with \" &\n-                           \"convention % defined #\", Typ);\n+                          (\"\\\\overriding operation % with \"\n+                           & \"convention % defined #\", Typ);\n                      end if;\n \n                   else pragma Assert (Present (Alias (Op)));\n                      Error_Msg_Sloc := Sloc (Alias (Op));\n-                     Error_Msg_N\n-                       (\"\\\\inherited operation % with \" &\n-                        \"convention % defined #\", Typ);\n+                     Error_Msg_N (\"\\\\inherited operation % with \"\n+                                  & \"convention % defined #\", Typ);\n                   end if;\n \n                   Error_Msg_Name_1 := Chars (Op);\n                   Error_Msg_Name_2 := Get_Convention_Name (Iface_Conv);\n                   Error_Msg_Sloc   := Sloc (Iface_Prim);\n-                  Error_Msg_N\n-                    (\"\\\\overridden operation % with \" &\n-                     \"convention % defined #\", Typ);\n+                  Error_Msg_N (\"\\\\overridden operation % with \"\n+                               & \"convention % defined #\", Typ);\n \n                   --  Avoid cascading errors\n \n@@ -5722,9 +5717,8 @@ package body Sem_Ch6 is\n             if not Is_Primitive\n               and then Ekind (Scope (Subp)) /= E_Protected_Type\n             then\n-               Error_Msg_N\n-                 (\"overriding indicator only allowed \"\n-                  & \"if subprogram is primitive\", Subp);\n+               Error_Msg_N (\"overriding indicator only allowed \"\n+                            & \"if subprogram is primitive\", Subp);\n \n             elsif Can_Override_Operator (Subp) then\n                Error_Msg_NE\n@@ -7085,7 +7079,7 @@ package body Sem_Ch6 is\n             then\n                if Scope (E) /= Standard_Standard then\n                   Error_Msg_Sloc := Sloc (E);\n-                  Error_Msg_N (\"declaration of & hides one#?h?\", S);\n+                  Error_Msg_N (\"declaration of & hides one #?h?\", S);\n \n                elsif Nkind (S) = N_Defining_Operator_Symbol\n                  and then\n@@ -7159,7 +7153,7 @@ package body Sem_Ch6 is\n          else\n             if Ada_Version >= Ada_2012 then\n                Error_Msg_NE\n-                 (\"equality operator must be declared before type& is \"\n+                 (\"equality operator must be declared before type & is \"\n                   & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)<<\", Eq_Op, Typ);\n \n                --  In Ada 2012 mode with error turned to warning, output one\n@@ -8395,8 +8389,8 @@ package body Sem_Ch6 is\n                then\n                   Error_Msg_Node_2 := F_Typ;\n                   Error_Msg_NE\n-                    (\"private operation& in generic unit does not override \" &\n-                     \"any primitive operation of& (RM 12.3 (18))??\",\n+                    (\"private operation& in generic unit does not override \"\n+                     & \"any primitive operation of& (RM 12.3 (18))??\",\n                      New_E, New_E);\n                end if;\n \n@@ -8429,13 +8423,11 @@ package body Sem_Ch6 is\n \n                   if Class_Present (P) and then not Split_PPC (P) then\n                      if Pragma_Name (P) = Name_Precondition then\n-                        Error_Msg_N\n-                          (\"info: & inherits `Pre''Class` aspect from #?L?\",\n-                           E);\n+                        Error_Msg_N (\"info: & inherits `Pre''Class` aspect \"\n+                                     & \"from #?L?\", E);\n                      else\n-                        Error_Msg_N\n-                          (\"info: & inherits `Post''Class` aspect from #?L?\",\n-                           E);\n+                        Error_Msg_N (\"info: & inherits `Post''Class` aspect \"\n+                                     & \"from #?L?\", E);\n                      end if;\n                   end if;\n \n@@ -8663,18 +8655,15 @@ package body Sem_Ch6 is\n                  and then (not Is_Overriding\n                             or else not Is_Abstract_Subprogram (E))\n                then\n-                  Error_Msg_N\n-                    (\"abstract subprograms must be visible \"\n-                     & \"(RM 3.9.3(10))!\", S);\n+                  Error_Msg_N (\"abstract subprograms must be visible \"\n+                               & \"(RM 3.9.3(10))!\", S);\n \n                elsif Ekind (S) = E_Function and then not Is_Overriding then\n                   if Is_Tagged_Type (T) and then T = Base_Type (Etype (S)) then\n-                     Error_Msg_N\n-                       (\"private function with tagged result must\"\n-                        & \" override visible-part function\", S);\n-                     Error_Msg_N\n-                       (\"\\move subprogram to the visible part\"\n-                        & \" (RM 3.9.3(10))\", S);\n+                     Error_Msg_N (\"private function with tagged result must\"\n+                                  & \" override visible-part function\", S);\n+                     Error_Msg_N (\"\\move subprogram to the visible part\"\n+                                  & \" (RM 3.9.3(10))\", S);\n \n                   --  AI05-0073: extend this test to the case of a function\n                   --  with a controlling access result.\n@@ -8687,10 +8676,10 @@ package body Sem_Ch6 is\n                   then\n                      Error_Msg_N\n                        (\"private function with controlling access result \"\n-                          & \"must override visible-part function\", S);\n+                        & \"must override visible-part function\", S);\n                      Error_Msg_N\n                        (\"\\move subprogram to the visible part\"\n-                          & \" (RM 3.9.3(10))\", S);\n+                        & \" (RM 3.9.3(10))\", S);\n                   end if;\n                end if;\n             end if;"}, {"sha": "ad51ce326e955f845131356dd66caeb563f4d9d8", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccedacc889a1eac92eed26a0006b9cc3eeda19b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3ccedacc889a1eac92eed26a0006b9cc3eeda19b", "patch": "@@ -11010,6 +11010,11 @@ package body Sem_Prag is\n \n             if Arg_Count > 1 then\n                Check_Optional_Identifier (Arg2, Name_Message);\n+\n+               --  Provide semantic annnotations for optional argument, for\n+               --  ASIS use, before rewriting.\n+\n+               Preanalyze_And_Resolve (Expression (Arg2), Standard_String);\n                Append_To (Newa, New_Copy_Tree (Arg2));\n             end if;\n \n@@ -19319,7 +19324,6 @@ package body Sem_Prag is\n \n                else\n                   Spec_Id := Defining_Entity (Unit (Context));\n-                  Inst_Id := Related_Instance (Spec_Id);\n                   Check_Library_Level_Entity (Spec_Id);\n                   Check_Pragma_Conformance\n                     (Context_Pragma => SPARK_Mode_Pragma,\n@@ -19329,7 +19333,10 @@ package body Sem_Prag is\n                   Set_SPARK_Pragma           (Spec_Id, N);\n                   Set_SPARK_Pragma_Inherited (Spec_Id, False);\n \n-                  if Present (Inst_Id) then\n+                  if Ekind (Spec_Id) = E_Package\n+                    and then Present (Related_Instance (Spec_Id))\n+                  then\n+                     Inst_Id := Related_Instance (Spec_Id);\n                      Set_SPARK_Pragma           (Inst_Id, N);\n                      Set_SPARK_Pragma_Inherited (Inst_Id, False);\n                   end if;"}]}