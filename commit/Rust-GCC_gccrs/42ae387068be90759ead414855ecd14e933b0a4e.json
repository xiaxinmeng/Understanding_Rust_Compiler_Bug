{"sha": "42ae387068be90759ead414855ecd14e933b0a4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhZTM4NzA2OGJlOTA3NTllYWQ0MTQ4NTVlY2QxNGU5MzNiMGE0ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-02-06T11:13:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-02-06T11:13:07Z"}, "message": "[multiple changes]\n\n2013-02-06  Vincent Celier  <celier@adacore.com>\n\n\t* prj-proc.adb (Process_Aggregated_Projects): Use a new project\n\tnode tree for each project tree rooted at an aggregated project.\n\n2013-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_util.adb (Is_Interface_Conversion): New routine.\n\t(Object_Access_Level): Detect an interface conversion\n\tthat has been rewritten into a different construct. Use the\n\toriginal form of the conversion to find the access level of\n\tthe operand.\n\n2013-02-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* einfo.ads (Has_Pragma_No_Inline): New flag using Flag201.\n\t(Has_Pragma_No_Inline): Declare and mark as inline.\n\t(Set_Has_Pragma_No_Inline): Likewise.\n\t* einfo.adb (Has_Pragma_No_Inline): New function.\n\t(Set_Has_Pragma_No_Inline): New procedure.\n\t(Write_Entity_Flags): Handle Has_Pragma_No_Inline.\n\t* snames.ads-tmpl (Name_No_Inline): New pragma-related name.\n\t(Pragma_Id): Add Pragma_No_Inline value.\n\t* par-prag.adb (Prag): Handle Pragma_Inline.\n\t* sem_prag.adb (Inline_Status): New enumeration type.\n\t(Process_Inline): Change Active parameter\n\tto Inline_Status and add support for suppressed inlining.\n\t(Analyze_Pragma) <Pragma_Inline>: Adjust to above change.\n\t<Pragma_Inline_Always>: Likewise.\n\t <Pragma_No_Inline>: Implement new pragma No_Inline.\n\t(Sig_Flags): Add Pragma_No_Inline.\n\t* gnat_rm.texi (Implementation Defined Pragmas): Add No_Inline.\n\t* gnat_ugn.texi (Switches for gcc): Mention Pragma No_Inline.\n\n2013-02-06  Pascal Obry  <obry@adacore.com>\n\n\t* s-osprim-mingw.adb (Clock): Make sure we copy all data locally\n\tto avoid interleaved modifications that could happen from another\n\ttask calling Get_Base_Data.\n\t(Get_Base_Data): Make it a critical section. Avoid updating if another\n\ttask has already done it.\n\nFrom-SVN: r195801", "tree": {"sha": "2d2c0a48d50ef471daf900e9946d67c3a8d2ec61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d2c0a48d50ef471daf900e9946d67c3a8d2ec61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42ae387068be90759ead414855ecd14e933b0a4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ae387068be90759ead414855ecd14e933b0a4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ae387068be90759ead414855ecd14e933b0a4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ae387068be90759ead414855ecd14e933b0a4e/comments", "author": null, "committer": null, "parents": [{"sha": "f403355afb84e58c73c83329b18bac3bc24f336c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f403355afb84e58c73c83329b18bac3bc24f336c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f403355afb84e58c73c83329b18bac3bc24f336c"}], "stats": {"total": 2894, "additions": 1696, "deletions": 1198}, "files": [{"sha": "b1a22da8d9693b080d5be2f31c36b293e9a248ae", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -1,3 +1,49 @@\n+2013-02-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n+2013-02-06  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-proc.adb (Process_Aggregated_Projects): Use a new project\n+\tnode tree for each project tree rooted at an aggregated project.\n+\n+2013-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_util.adb (Is_Interface_Conversion): New routine.\n+\t(Object_Access_Level): Detect an interface conversion\n+\tthat has been rewritten into a different construct. Use the\n+\toriginal form of the conversion to find the access level of\n+\tthe operand.\n+\n+2013-02-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads (Has_Pragma_No_Inline): New flag using Flag201.\n+\t(Has_Pragma_No_Inline): Declare and mark as inline.\n+\t(Set_Has_Pragma_No_Inline): Likewise.\n+\t* einfo.adb (Has_Pragma_No_Inline): New function.\n+\t(Set_Has_Pragma_No_Inline): New procedure.\n+\t(Write_Entity_Flags): Handle Has_Pragma_No_Inline.\n+\t* snames.ads-tmpl (Name_No_Inline): New pragma-related name.\n+\t(Pragma_Id): Add Pragma_No_Inline value.\n+\t* par-prag.adb (Prag): Handle Pragma_Inline.\n+\t* sem_prag.adb (Inline_Status): New enumeration type.\n+\t(Process_Inline): Change Active parameter\n+\tto Inline_Status and add support for suppressed inlining.\n+\t(Analyze_Pragma) <Pragma_Inline>: Adjust to above change.\n+\t<Pragma_Inline_Always>: Likewise.\n+\t <Pragma_No_Inline>: Implement new pragma No_Inline.\n+\t(Sig_Flags): Add Pragma_No_Inline.\n+\t* gnat_rm.texi (Implementation Defined Pragmas): Add No_Inline.\n+\t* gnat_ugn.texi (Switches for gcc): Mention Pragma No_Inline.\n+\n+2013-02-06  Pascal Obry  <obry@adacore.com>\n+\n+\t* s-osprim-mingw.adb (Clock): Make sure we copy all data locally\n+\tto avoid interleaved modifications that could happen from another\n+\ttask calling Get_Base_Data.\n+\t(Get_Base_Data): Make it a critical section. Avoid updating if another\n+\ttask has already done it.\n+\n 2013-02-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_prag.adb: Minor reformatting."}, {"sha": "934dd27e25b87f0b9b254ab428416ade1ab499e1", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -483,6 +483,7 @@ package body Einfo is\n    --    Is_Ada_2012_Only                Flag199\n \n    --    Has_Delayed_Aspects             Flag200\n+   --    Has_Pragma_No_Inline            Flag201\n    --    Itype_Printed                   Flag202\n    --    Has_Pragma_Pure                 Flag203\n    --    Is_Known_Null                   Flag204\n@@ -542,8 +543,6 @@ package body Einfo is\n    --    Has_Anonymous_Master            Flag253\n    --    Is_Implementation_Defined       Flag254\n \n-   --    (unused)                        Flag201\n-\n    --    (unused)                        Flag255\n    --    (unused)                        Flag256\n    --    (unused)                        Flag257\n@@ -1560,6 +1559,11 @@ package body Einfo is\n       return Flag230 (Id);\n    end Has_Pragma_Inline_Always;\n \n+   function Has_Pragma_No_Inline (Id : E) return B is\n+   begin\n+      return Flag201 (Id);\n+   end Has_Pragma_No_Inline;\n+\n    function Has_Pragma_Ordered (Id : E) return B is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n@@ -4111,6 +4115,11 @@ package body Einfo is\n       Set_Flag230 (Id, V);\n    end Set_Has_Pragma_Inline_Always;\n \n+   procedure Set_Has_Pragma_No_Inline (Id : E; V : B := True) is\n+   begin\n+      Set_Flag201 (Id, V);\n+   end Set_Has_Pragma_No_Inline;\n+\n    procedure Set_Has_Pragma_Ordered (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n@@ -7686,6 +7695,7 @@ package body Einfo is\n       W (\"Has_Pragma_Elaborate_Body\",       Flag150 (Id));\n       W (\"Has_Pragma_Inline\",               Flag157 (Id));\n       W (\"Has_Pragma_Inline_Always\",        Flag230 (Id));\n+      W (\"Has_Pragma_No_Inline\",            Flag201 (Id));\n       W (\"Has_Pragma_Ordered\",              Flag198 (Id));\n       W (\"Has_Pragma_Pack\",                 Flag121 (Id));\n       W (\"Has_Pragma_Preelab_Init\",         Flag221 (Id));"}, {"sha": "8616333a0a8f2ff884f356c95974c9a9835f6f16", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -1671,6 +1671,11 @@ package Einfo is\n --       pragma Inline_Always applies. Note that if this flag is set, the flag\n --       Has_Pragma_Inline is also set.\n \n+--    Has_Pragma_No_Inline (Flag201)\n+--       Defined in all entities. Set for functions and procedures for which a\n+--       pragma No_Inline applies. Note that if this flag is set, the flag\n+--       Has_Pragma_Inline_Always cannot be set.\n+\n --    Has_Pragma_Ordered (Flag198) [implementation base type only]\n --       Defined in entities for enumeration types. If set indicates that a\n --       valid pragma Ordered was given for the type. This flag is inherited\n@@ -4833,6 +4838,7 @@ package Einfo is\n    --    Has_Pragma_Elaborate_Body           (Flag150)\n    --    Has_Pragma_Inline                   (Flag157)\n    --    Has_Pragma_Inline_Always            (Flag230)\n+   --    Has_Pragma_No_Inline                (Flag201)\n    --    Has_Pragma_Pure                     (Flag203)\n    --    Has_Pragma_Pure_Function            (Flag179)\n    --    Has_Pragma_Thread_Local_Storage     (Flag169)\n@@ -6232,6 +6238,7 @@ package Einfo is\n    function Has_Pragma_Elaborate_Body           (Id : E) return B;\n    function Has_Pragma_Inline                   (Id : E) return B;\n    function Has_Pragma_Inline_Always            (Id : E) return B;\n+   function Has_Pragma_No_Inline                (Id : E) return B;\n    function Has_Pragma_Ordered                  (Id : E) return B;\n    function Has_Pragma_Pack                     (Id : E) return B;\n    function Has_Pragma_Preelab_Init             (Id : E) return B;\n@@ -6831,6 +6838,7 @@ package Einfo is\n    procedure Set_Has_Pragma_Elaborate_Body       (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Inline               (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Inline_Always        (Id : E; V : B := True);\n+   procedure Set_Has_Pragma_No_Inline            (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Ordered              (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Pack                 (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Preelab_Init         (Id : E; V : B := True);\n@@ -7521,6 +7529,7 @@ package Einfo is\n    pragma Inline (Has_Pragma_Elaborate_Body);\n    pragma Inline (Has_Pragma_Inline);\n    pragma Inline (Has_Pragma_Inline_Always);\n+   pragma Inline (Has_Pragma_No_Inline);\n    pragma Inline (Has_Pragma_Ordered);\n    pragma Inline (Has_Pragma_Pack);\n    pragma Inline (Has_Pragma_Preelab_Init);\n@@ -7971,6 +7980,7 @@ package Einfo is\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);\n    pragma Inline (Set_Has_Pragma_Inline);\n    pragma Inline (Set_Has_Pragma_Inline_Always);\n+   pragma Inline (Set_Has_Pragma_No_Inline);\n    pragma Inline (Set_Has_Pragma_Ordered);\n    pragma Inline (Set_Has_Pragma_Pack);\n    pragma Inline (Set_Has_Pragma_Preelab_Init);"}, {"sha": "57f90090dcf9081fdf98cb02b9da8b2ccbbdb694", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1114, "deletions": 1077, "changes": 2191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=42ae387068be90759ead414855ecd14e933b0a4e"}, {"sha": "2af3ca83ee3b5448f46d93c0bc00a00ec070c383", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -2908,10 +2908,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       {\n \tNode_Id full_definition = Declaration_Node (gnat_entity);\n \tNode_Id record_definition = Type_Definition (full_definition);\n+\tNode_Id gnat_constr;\n \tEntity_Id gnat_field;\n-\ttree gnu_field, gnu_field_list = NULL_TREE, gnu_get_parent;\n+\ttree gnu_field, gnu_field_list = NULL_TREE;\n+\ttree gnu_get_parent;\n \t/* Set PACKED in keeping with gnat_to_gnu_field.  */\n-\tint packed\n+\tconst int packed\n \t  = Is_Packed (gnat_entity)\n \t    ? 1\n \t    : Component_Alignment (gnat_entity) == Calign_Storage_Unit\n@@ -2921,13 +2923,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     && Known_RM_Size (gnat_entity)))\n \t\t? -2\n \t\t: 0;\n-\tbool has_discr = Has_Discriminants (gnat_entity);\n-\tbool has_rep = Has_Specified_Layout (gnat_entity);\n-\tbool all_rep = has_rep;\n-\tbool is_extension\n+\tconst bool has_discr = Has_Discriminants (gnat_entity);\n+\tconst bool has_rep = Has_Specified_Layout (gnat_entity);\n+\tconst bool is_extension\n \t  = (Is_Tagged_Type (gnat_entity)\n \t     && Nkind (record_definition) == N_Derived_Type_Definition);\n-\tbool is_unchecked_union = Is_Unchecked_Union (gnat_entity);\n+\tconst bool is_unchecked_union = Is_Unchecked_Union (gnat_entity);\n+\tbool all_rep = has_rep;\n \n \t/* See if all fields have a rep clause.  Stop when we find one\n \t   that doesn't.  */\n@@ -3166,6 +3168,51 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \t    }\n \n+\t/* If we have a derived untagged type that renames discriminants in\n+\t   the root type, the (stored) discriminants are a just copy of the\n+\t   discriminants of the root type.  This means that any constraints\n+\t   added by the renaming in the derivation are disregarded as far\n+\t   as the layout of the derived type is concerned.  To rescue them,\n+\t   we change the type of the (stored) discriminants to a subtype\n+\t   with the bounds of the type of the visible discriminants.  */\n+\tif (has_discr\n+\t    && !is_extension\n+\t    && Stored_Constraint (gnat_entity) != No_Elist)\n+\t  for (gnat_constr = First_Elmt (Stored_Constraint (gnat_entity));\n+\t       gnat_constr != No_Elmt;\n+\t       gnat_constr = Next_Elmt (gnat_constr))\n+\t    if (Nkind (Node (gnat_constr)) == N_Identifier\n+\t\t/* Ignore access discriminants.  */\n+\t\t&& !Is_Access_Type (Etype (Node (gnat_constr)))\n+\t\t&& Ekind (Entity (Node (gnat_constr))) == E_Discriminant)\n+\t      {\n+\t\tEntity_Id gnat_discr = Entity (Node (gnat_constr));\n+\t\ttree gnu_discr_type = gnat_to_gnu_type (Etype (gnat_discr));\n+\t\ttree gnu_ref\n+\t\t  = gnat_to_gnu_entity (Original_Record_Component (gnat_discr),\n+\t\t\t\t\tNULL_TREE, 0);\n+\n+\t\t/* GNU_REF must be an expression using a PLACEHOLDER_EXPR built\n+\t\t   just above for one of the stored discriminants.  */\n+\t\tgcc_assert (TREE_TYPE (TREE_OPERAND (gnu_ref, 0)) == gnu_type);\n+\n+\t\tif (gnu_discr_type != TREE_TYPE (gnu_ref))\n+\t\t  {\n+\t\t    const unsigned prec = TYPE_PRECISION (TREE_TYPE (gnu_ref));\n+\t\t    tree gnu_subtype\n+\t\t      = TYPE_UNSIGNED (TREE_TYPE (gnu_ref))\n+\t\t        ? make_unsigned_type (prec) : make_signed_type (prec);\n+\t\t    TREE_TYPE (gnu_subtype) = TREE_TYPE (gnu_ref);\n+\t\t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n+\t\t    SET_TYPE_RM_MIN_VALUE (gnu_subtype,\n+\t\t\t\t\t   TYPE_MIN_VALUE (gnu_discr_type));\n+\t\t    SET_TYPE_RM_MAX_VALUE (gnu_subtype,\n+\t\t\t\t\t   TYPE_MAX_VALUE (gnu_discr_type));\n+\t\t    TREE_TYPE (gnu_ref)\n+\t\t      = TREE_TYPE (TREE_OPERAND (gnu_ref, 1)) = gnu_subtype;\n+\t\t  }\n+\t      }\n+\n \t/* Add the fields into the record type and finish it up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, false,\n@@ -4078,7 +4125,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_stub_type = NULL_TREE, gnu_stub_name = NULL_TREE;\n \ttree gnu_ext_name = create_concat_name (gnat_entity, NULL);\n \tEntity_Id gnat_param;\n-\tbool inline_flag = Is_Inlined (gnat_entity);\n+\tenum inline_status_t inline_status\n+\t  = Has_Pragma_No_Inline (gnat_entity)\n+\t    ? is_suppressed\n+\t    : (Is_Inlined (gnat_entity) ? is_enabled : is_disabled);\n \tbool public_flag = Is_Public (gnat_entity) || imported_p;\n \tbool extern_flag\n \t  = (Is_Public (gnat_entity) && !definition) || imported_p;\n@@ -4634,15 +4684,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    gnu_decl\n \t      = create_subprog_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t     gnu_param_list, inline_flag, public_flag,\n-\t\t\t\t     extern_flag, artificial_flag, attr_list,\n-\t\t\t\t     gnat_entity);\n+\t\t\t\t     gnu_param_list, inline_status,\n+\t\t\t\t     public_flag, extern_flag, artificial_flag,\n+\t\t\t\t     attr_list, gnat_entity);\n \t    if (has_stub)\n \t      {\n \t\ttree gnu_stub_decl\n \t\t  = create_subprog_decl (gnu_entity_name, gnu_stub_name,\n \t\t\t\t\t gnu_stub_type, gnu_stub_param_list,\n-\t\t\t\t\t inline_flag, true, extern_flag,\n+\t\t\t\t\t inline_status, true, extern_flag,\n \t\t\t\t\t false, attr_list, gnat_entity);\n \t\tSET_DECL_FUNCTION_STUB (gnu_decl, gnu_stub_decl);\n \t      }\n@@ -5375,7 +5425,7 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n \n   return\n     create_subprog_decl (gnu_entity_name, gnu_ext_name, void_ftype, NULL_TREE,\n-\t\t\t false, true, true, true, attr_list, gnat_entity);\n+\t\t\t is_disabled, true, true, true, attr_list, gnat_entity);\n }\n \n /* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n@@ -5964,7 +6014,7 @@ elaborate_entity (Entity_Id gnat_entity)\n \t       Present (gnat_field);\n \t       gnat_field = Next_Discriminant (gnat_field),\n \t       gnat_discriminant_expr = Next_Elmt (gnat_discriminant_expr))\n-\t    /* ??? For now, ignore access discriminants.  */\n+\t    /* Ignore access discriminants.  */\n \t    if (!Is_Access_Type (Etype (Node (gnat_discriminant_expr))))\n \t      elaborate_expression (Node (gnat_discriminant_expr),\n \t\t\t\t    gnat_entity, get_entity_name (gnat_field),\n@@ -7610,20 +7660,20 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n {\n   vec<subst_pair> gnu_list = vNULL;\n   Entity_Id gnat_discrim;\n-  Node_Id gnat_value;\n+  Node_Id gnat_constr;\n \n   for (gnat_discrim = First_Stored_Discriminant (gnat_type),\n-       gnat_value = First_Elmt (Stored_Constraint (gnat_subtype));\n+       gnat_constr = First_Elmt (Stored_Constraint (gnat_subtype));\n        Present (gnat_discrim);\n        gnat_discrim = Next_Stored_Discriminant (gnat_discrim),\n-       gnat_value = Next_Elmt (gnat_value))\n+       gnat_constr = Next_Elmt (gnat_constr))\n     /* Ignore access discriminants.  */\n-    if (!Is_Access_Type (Etype (Node (gnat_value))))\n+    if (!Is_Access_Type (Etype (Node (gnat_constr))))\n       {\n \ttree gnu_field = gnat_to_gnu_field_decl (gnat_discrim);\n \ttree replacement = convert (TREE_TYPE (gnu_field),\n \t\t\t\t    elaborate_expression\n-\t\t\t\t    (Node (gnat_value), gnat_subtype,\n+\t\t\t\t    (Node (gnat_constr), gnat_subtype,\n \t\t\t\t     get_entity_name (gnat_discrim),\n \t\t\t\t     definition, true, false));\n \tsubst_pair s = {gnu_field, replacement};"}, {"sha": "5dee7b56fb19c89ab26822296302fcdaddc3edba", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -430,6 +430,17 @@ enum exception_info_kind\n   exception_column\n };\n \n+/* Define the inline status of a subprogram.  */\n+enum inline_status_t\n+{\n+  /* Inlining is suppressed for the subprogram.  */\n+  is_suppressed,\n+  /* No inlining is requested for the subprogram.  */\n+  is_disabled,\n+  /* Inlining is requested for the subprogram.  */\n+  is_enabled\n+};\n+\n extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n extern GTY(()) tree gnat_raise_decls_ext[(int) LAST_REASON_CODE + 1];\n@@ -718,13 +729,14 @@ extern tree create_label_decl (tree, Node_Id);\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the DECL_CHAIN field).\n \n-   INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n+   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n    used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is\n    used for the position of the decl.  */\n extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n \t\t\t\t tree subprog_type, tree param_decl_list,\n-\t\t\t\t bool inline_flag, bool public_flag,\n-\t\t\t\t bool extern_flag, bool artificial_flag,\n+\t\t\t\t enum inline_status_t inline_status,\n+\t\t\t\t bool public_flag, bool extern_flag,\n+\t\t\t\t bool artificial_flag,\n \t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n \n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram"}, {"sha": "0b8f6f1936b6185974c0bde8926decf73719619a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 148, "deletions": 32, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -36,6 +36,8 @@\n #include \"gimple.h\"\n #include \"bitmap.h\"\n #include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+#include \"opts.h\"\n #include \"target.h\"\n #include \"common/common-target.h\"\n \n@@ -210,7 +212,7 @@ typedef struct range_check_info_d *range_check_info;\n \n /* Structure used to record information for a loop.  */\n struct GTY(()) loop_info_d {\n-  tree label;\n+  tree stmt;\n   tree loop_var;\n   vec<range_check_info, va_gc> *checks;\n };\n@@ -411,16 +413,16 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n      memory.  */\n   malloc_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   NULL, Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n   /* malloc32 is a function declaration tree for a function to allocate\n      32-bit memory on a 64-bit system.  Needed only on 64-bit VMS.  */\n   malloc32_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc32\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   NULL, Empty);\n   DECL_IS_MALLOC (malloc32_decl) = 1;\n \n   /* free is a function declaration tree for a function to free memory.  */\n@@ -429,14 +431,16 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t\t\t   build_function_type_list (void_type_node,\n \t\t\t\t\t\t     ptr_void_type_node,\n \t\t\t\t\t\t     NULL_TREE),\n-\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, NULL,\n+\t\t\t   Empty);\n \n   /* This is used for 64-bit multiplication with overflow checking.  */\n   mulv64_decl\n     = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n \t\t\t   build_function_type_list (int64_type, int64_type,\n \t\t\t\t\t\t     int64_type, NULL_TREE),\n-\t\t\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, NULL,\n+\t\t\t   Empty);\n \n   /* Name of the _Parent field in tagged record types.  */\n   parent_name_id = get_identifier (Get_Name_String (Name_uParent));\n@@ -457,15 +461,15 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, false, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (get_jmpbuf_decl) = 1;\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (void_type_node, jmpbuf_ptr_type,\n \t\t\t\t\t    NULL_TREE),\n-       NULL_TREE, false, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (set_jmpbuf_decl) = 1;\n \n   /* setjmp returns an integer and has one operand, which is a pointer to\n@@ -475,7 +479,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n        build_function_type_list (integer_type_node, jmpbuf_ptr_type,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, false, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n \n@@ -485,7 +489,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     = create_subprog_decl\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n        build_function_type_list (void_type_node, jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, false, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n@@ -495,27 +499,27 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \n   begin_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   NULL, Empty);\n   DECL_IGNORED_P (begin_handler_decl) = 1;\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   NULL, Empty);\n   DECL_IGNORED_P (end_handler_decl) = 1;\n \n   unhandled_except_decl\n     = create_subprog_decl (get_identifier (\"__gnat_unhandled_except_handler\"),\n \t\t\t   NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   NULL, Empty);\n   DECL_IGNORED_P (unhandled_except_decl) = 1;\n \n   reraise_zcx_decl\n     = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, false, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   NULL, Empty);\n   /* Indicate that these never return.  */\n   DECL_IGNORED_P (reraise_zcx_decl) = 1;\n   TREE_THIS_VOLATILE (reraise_zcx_decl) = 1;\n@@ -535,7 +539,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t\t\t\t     build_pointer_type\n \t\t\t\t     (unsigned_char_type_node),\n \t\t\t\t     integer_type_node, NULL_TREE),\n-\t   NULL_TREE, false, true, true, true, NULL, Empty);\n+\t   NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n       TREE_THIS_VOLATILE (decl) = 1;\n       TREE_SIDE_EFFECTS (decl) = 1;\n       TREE_TYPE (decl)\n@@ -568,7 +572,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n        build_function_type_list (build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-     NULL_TREE, false, true, true, true, NULL, Empty);\n+     NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n   DECL_IGNORED_P (get_excptr_decl) = 1;\n \n   raise_nodefer_decl\n@@ -577,7 +581,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n        build_function_type_list (void_type_node,\n \t\t\t\t build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, false, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n \n   /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n@@ -750,7 +754,7 @@ build_raise_check (int check, enum exception_info_kind kind)\n   result\n     = create_subprog_decl (get_identifier (Name_Buffer),\n \t\t\t   NULL_TREE, ftype, NULL_TREE,\n-\t\t\t   false, true, true, true, NULL, Empty);\n+\t\t\t   is_disabled, true, true, true, NULL, Empty);\n \n   /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (result) = 1;\n@@ -1184,11 +1188,11 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n static tree\n Pragma_to_gnu (Node_Id gnat_node)\n {\n-  Node_Id gnat_temp;\n   tree gnu_result = alloc_stmt_list ();\n+  Node_Id gnat_temp;\n \n-  /* Check for (and ignore) unrecognized pragma and do nothing if we are just\n-     annotating types.  */\n+  /* Do nothing if we are just annotating types and check for (and ignore)\n+     unrecognized pragmas.  */\n   if (type_annotate_only\n       || !Is_Pragma_Name (Chars (Pragma_Identifier (gnat_node))))\n     return gnu_result;\n@@ -1250,6 +1254,37 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t}\n       break;\n \n+    case Pragma_Loop_Optimize:\n+      for (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n+\t   Present (gnat_temp);\n+\t   gnat_temp = Next (gnat_temp))\n+\t{\n+\t  tree gnu_loop_stmt = gnu_loop_stack ->last ()->stmt;\n+\n+\t  switch (Chars (Expression (gnat_temp)))\n+\t    {\n+\t    case Name_No_Unroll:\n+\t      LOOP_STMT_NO_UNROLL (gnu_loop_stmt) = 1;\n+\t      break;\n+\n+\t    case Name_Unroll:\n+\t      LOOP_STMT_UNROLL (gnu_loop_stmt) = 1;\n+\t      break;\n+\n+\t    case Name_No_Vector:\n+\t      LOOP_STMT_NO_VECTOR (gnu_loop_stmt) = 1;\n+\t      break;\n+\n+\t    case Name_Vector:\n+\t      LOOP_STMT_VECTOR (gnu_loop_stmt) = 1;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      break;\n+\n     case Pragma_Optimize:\n       switch (Chars (Expression\n \t\t     (First (Pragma_Argument_Associations (gnat_node)))))\n@@ -1278,6 +1313,87 @@ Pragma_to_gnu (Node_Id gnat_node)\n       if (write_symbols == NO_DEBUG)\n \tpost_error (\"must specify -g?\", gnat_node);\n       break;\n+\n+    case Pragma_Warnings:\n+      {\n+\tNode_Id gnat_expr;\n+\t/* Preserve the location of the pragma.  */\n+\tconst location_t location = input_location;\n+\tstruct cl_option_handlers handlers;\n+\tunsigned int option_index;\n+\tdiagnostic_t kind;\n+\tbool imply;\n+\n+\tgnat_temp = First (Pragma_Argument_Associations (gnat_node));\n+\n+\t/* This is the String form: pragma Warnings (String).  */\n+\tif (Nkind (Expression (gnat_temp)) == N_String_Literal)\n+\t  {\n+\t    kind = DK_WARNING;\n+\t    gnat_expr = Expression (gnat_temp);\n+\t    imply = true;\n+\t  }\n+\n+\t/* This is the On/Off form: pragma Warnings (On | Off [,String]).  */\n+\telse if (Nkind (Expression (gnat_temp)) == N_Identifier)\n+\t  {\n+\t    switch (Chars (Expression (gnat_temp)))\n+\t      {\n+\t\tcase Name_Off:\n+\t\t  kind = DK_IGNORED;\n+\t\t  break;\n+\n+\t\tcase Name_On:\n+\t\t  kind = DK_WARNING;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t      }\n+\n+\t    if (Present (Next (gnat_temp)))\n+\t      {\n+\t\t/* pragma Warnings (On | Off, Name) is handled differently.  */\n+\t\tif (Nkind (Expression (Next (gnat_temp))) != N_String_Literal)\n+\t\t  break;\n+\n+\t        gnat_expr = Expression (Next (gnat_temp));\n+\t      }\n+\t    else\n+\t      gnat_expr = Empty;\n+\n+\t    imply = false;\n+\t  }\n+\n+\telse\n+\t  gcc_unreachable ();\n+\n+\t/* This is the same implementation as in the C family of compilers.  */\n+\tif (Present (gnat_expr))\n+\t  {\n+\t    tree gnu_expr = gnat_to_gnu (gnat_expr);\n+\t    const char *opt_string = TREE_STRING_POINTER (gnu_expr);\n+\t    const int len = TREE_STRING_LENGTH (gnu_expr);\n+\t    if (len < 3 || opt_string[0] != '-' || opt_string[1] != 'W')\n+\t      break;\n+\t    for (option_index = 0;\n+\t\t option_index < cl_options_count;\n+\t\t option_index++)\n+\t      if (strcmp (cl_options[option_index].opt_text, opt_string) == 0)\n+\t\tbreak;\n+\t  }\n+\telse\n+\t  option_index = 0;\n+\n+\tset_default_handlers (&handlers);\n+\tcontrol_warning_option (option_index, (int) kind, imply, location,\n+\t\t\t\tCL_Ada, &handlers, &global_options,\n+\t\t\t\t&global_options_set, global_dc);\n+      }\n+      break;\n+\n+    default:\n+      break;\n     }\n \n   return gnu_result;\n@@ -2344,8 +2460,8 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n   LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n \n-  /* Save the label so that a corresponding N_Exit_Statement can find it.  */\n-  gnu_loop_info->label = gnu_loop_label;\n+  /* Save the statement for later reuse.  */\n+  gnu_loop_info->stmt = gnu_loop_stmt;\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2699,7 +2815,7 @@ establish_gnat_vms_condition_handler (void)\n \t\t\t\t\t\t\t ptr_void_type_node,\n \t\t\t\t\t\t\t ptr_void_type_node,\n \t\t\t\t\t\t\t NULL_TREE),\n-\t\t\t       NULL_TREE, false, true, true, true, NULL,\n+\t\t\t       NULL_TREE, is_disabled, true, true, true, NULL,\n \t\t\t       Empty);\n \n       /* ??? DECL_CONTEXT shouldn't have been set because of DECL_EXTERNAL.  */\n@@ -4753,7 +4869,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   tree gnu_elab_proc_decl\n     = create_subprog_decl\n       (create_concat_name (gnat_unit_entity, body_p ? \"elabb\" : \"elabs\"),\n-       NULL_TREE, void_ftype, NULL_TREE, false, true, false, true, NULL,\n+       NULL_TREE, void_ftype, NULL_TREE, is_disabled, true, false, true, NULL,\n        gnat_unit);\n   struct elab_info *info;\n \n@@ -5681,7 +5797,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    create_subprog_decl (create_concat_name\n \t\t\t\t (Entity (Prefix (gnat_node)),\n \t\t\t\t  attr == Attr_Elab_Body ? \"elabb\" : \"elabs\"),\n-\t\t\t\t NULL_TREE, void_ftype, NULL_TREE, false,\n+\t\t\t\t NULL_TREE, void_ftype, NULL_TREE, is_disabled,\n \t\t\t\t true, true, true, NULL, gnat_node);\n \n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attr);\n@@ -6290,7 +6406,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n \t\t  (Present (Name (gnat_node))\n \t\t   ? get_gnu_tree (Entity (Name (gnat_node)))\n-\t\t   : gnu_loop_stack->last ()->label));\n+\t\t   : LOOP_STMT_LABEL (gnu_loop_stack->last ()->stmt)));\n       break;\n \n     case N_Simple_Return_Statement:"}, {"sha": "0906c0c319de27cb32d9e446e162d729b007f241", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -2621,14 +2621,14 @@ create_label_decl (tree label_name, Node_Id gnat_node)\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the DECL_CHAIN field).\n \n-   INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n+   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n    used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is\n    used for the position of the decl.  */\n \n tree\n create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n-\t\t     tree param_decl_list, bool inline_flag, bool public_flag,\n-\t\t     bool extern_flag, bool artificial_flag,\n+ \t\t     tree param_decl_list, enum inline_status_t inline_status,\n+\t\t     bool public_flag, bool extern_flag, bool artificial_flag,\n \t\t     struct attrib *attr_list, Node_Id gnat_node)\n {\n   tree subprog_decl = build_decl (input_location, FUNCTION_DECL, subprog_name,\n@@ -2642,7 +2642,7 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n      function in the current unit since it is private to the other unit.\n      We could inline the nested function as well but it's probably better\n      to err on the side of too little inlining.  */\n-  if (!inline_flag\n+  if (inline_status != is_enabled\n       && !public_flag\n       && current_function_decl\n       && DECL_DECLARED_INLINE_P (current_function_decl)\n@@ -2651,8 +2651,24 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n \n   DECL_ARTIFICIAL (subprog_decl) = artificial_flag;\n   DECL_EXTERNAL (subprog_decl) = extern_flag;\n-  DECL_DECLARED_INLINE_P (subprog_decl) = inline_flag;\n-  DECL_NO_INLINE_WARNING_P (subprog_decl) = inline_flag && artificial_flag;\n+\n+  switch (inline_status)\n+    {\n+    case is_suppressed:\n+      DECL_UNINLINABLE (subprog_decl) = 1;\n+      break;\n+\n+    case is_disabled:\n+      break;\n+\n+    case is_enabled:\n+      DECL_DECLARED_INLINE_P (subprog_decl) = 1;\n+      DECL_NO_INLINE_WARNING_P (subprog_decl) = artificial_flag;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   TREE_PUBLIC (subprog_decl) = public_flag;\n   TREE_READONLY (subprog_decl) = TYPE_READONLY (subprog_type);"}, {"sha": "3ef8a5245444d1c1d3204b2639f7998234a78d3a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -182,6 +182,7 @@ Implementation Defined Pragmas\n * Pragma Main::\n * Pragma Main_Storage::\n * Pragma No_Body::\n+* Pragma No_Inline::\n * Pragma No_Return::\n * Pragma No_Strict_Aliasing ::\n * Pragma Normalize_Scalars::\n@@ -934,6 +935,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Main::\n * Pragma Main_Storage::\n * Pragma No_Body::\n+* Pragma No_Inline::\n * Pragma No_Return::\n * Pragma No_Strict_Aliasing::\n * Pragma Normalize_Scalars::\n@@ -3373,8 +3375,8 @@ pragma Inline_Always (NAME [, NAME]);\n \n @noindent\n Similar to pragma @code{Inline} except that inlining is not subject to\n-the use of option @option{-gnatn} and the inlining happens regardless of\n-whether this option is used.\n+the use of option @option{-gnatn} or @option{-gnatN} and the inlining\n+happens regardless of whether these options are used.\n \n @node Pragma Inline_Generic\n @unnumberedsec Pragma Inline_Generic\n@@ -4020,6 +4022,24 @@ such a way that a body needed before is no longer needed. The provision of a\n dummy body with a No_Body pragma ensures that there is no interference from\n earlier versions of the package body.\n \n+@node Pragma No_Inline\n+@unnumberedsec Pragma No_Inline\n+@findex No_Inline\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma No_Inline (NAME [, NAME]);\n+@end smallexample\n+\n+@noindent\n+This pragma suppresses inlining for the callable entity or the instances of\n+the generic subprogram designated by @var{NAME}, including inlining that\n+results from the use of pragma @code{Inline}.  This pragma is always active,\n+in particular it is not subject to the use of option @option{-gnatn} or\n+@option{-gnatN}.  It is illegal to specify both pragma @code{No_Inline} and\n+pragma @code{Inline_Always} for the same @var{NAME}.\n+\n @node Pragma No_Return\n @unnumberedsec Pragma No_Return\n @findex No_Return"}, {"sha": "1af8a943ef789c623914fc6f11faccddd8b0c636", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -4055,7 +4055,8 @@ switches are set.  This includes suppression of inlining that\n results from the use of the pragma @code{Inline_Always}.\n Any occurrences of pragma @code{Inline} or @code{Inline_Always}\n are ignored, and @option{-gnatn} and @option{-gnatN} have no\n-effect if this switch is present.\n+effects if this switch is present.  Note that inlining can also\n+be suppressed on a finer-grained basis with pragma @code{No_Inline}.\n \n @item -fno-inline-functions\n @cindex @option{-fno-inline-functions} (@command{gcc})"}, {"sha": "07f31be423cd437f4a01ba026826335d6b79367f", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -1210,6 +1210,7 @@ begin\n            Pragma_Main_Storage                   |\n            Pragma_Memory_Size                    |\n            Pragma_No_Body                        |\n+           Pragma_No_Inline                      |\n            Pragma_No_Return                      |\n            Pragma_No_Run_Time                    |\n            Pragma_No_Strict_Aliasing             |"}, {"sha": "fe4c252b06ee85c4880c209379eadf5b5322044e", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -2607,6 +2607,7 @@ package body Prj.Proc is\n          Loaded_Project : Prj.Tree.Project_Node_Id;\n          Success        : Boolean := True;\n          Tree           : Project_Tree_Ref;\n+         Node_Tree      : Project_Node_Tree_Ref;\n \n       begin\n          if Project.Qualifier not in Aggregate_Project then\n@@ -2623,8 +2624,11 @@ package body Prj.Proc is\n \n          List := Project.Aggregated_Projects;\n          while Success and then List /= null loop\n+            Node_Tree := new Project_Node_Tree_Data;\n+            Initialize (Node_Tree);\n+\n             Prj.Part.Parse\n-              (In_Tree           => From_Project_Node_Tree,\n+              (In_Tree           => Node_Tree,\n                Project           => Loaded_Project,\n                Packages_To_Check => Packages_To_Check,\n                Project_File_Name => Get_Name_String (List.Path),\n@@ -2661,7 +2665,7 @@ package body Prj.Proc is\n                      Packages_To_Check      => Packages_To_Check,\n                      Success                => Success,\n                      From_Project_Node      => Loaded_Project,\n-                     From_Project_Node_Tree => From_Project_Node_Tree,\n+                     From_Project_Node_Tree => Node_Tree,\n                      Env                    => Child_Env,\n                      Reset_Tree             => False);\n                else\n@@ -2673,7 +2677,7 @@ package body Prj.Proc is\n                      Packages_To_Check      => Packages_To_Check,\n                      Success                => Success,\n                      From_Project_Node      => Loaded_Project,\n-                     From_Project_Node_Tree => From_Project_Node_Tree,\n+                     From_Project_Node_Tree => Node_Tree,\n                      Env                    => Env,\n                      Reset_Tree             => False);\n                end if;"}, {"sha": "874b1cb186a954b5a42ee679108491f6d1fd5ede", "filename": "gcc/ada/s-osprim-mingw.adb", "status": "modified", "additions": 110, "deletions": 24, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fs-osprim-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fs-osprim-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-mingw.adb?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -31,10 +31,12 @@\n \n --  This is the NT version of this package\n \n+with System.Task_Lock;\n with System.Win32.Ext;\n \n package body System.OS_Primitives is\n \n+   use System.Task_Lock;\n    use System.Win32;\n    use System.Win32.Ext;\n \n@@ -46,23 +48,49 @@ package body System.OS_Primitives is\n    --  Holds frequency of high-performance counter used by Clock\n    --  Windows NT uses a 1_193_182 Hz counter on PCs.\n \n-   Base_Ticks : LARGE_INTEGER;\n-   --  Holds the Tick count for the base time\n-\n    Base_Monotonic_Ticks : LARGE_INTEGER;\n    --  Holds the Tick count for the base monotonic time\n \n-   Base_Clock : Duration;\n-   --  Holds the current clock for the standard clock's base time\n-\n    Base_Monotonic_Clock : Duration;\n    --  Holds the current clock for monotonic clock's base time\n \n-   Base_Time : Long_Long_Integer;\n-   --  Holds the base time used to check for system time change, used with\n-   --  the standard clock.\n+   type Clock_Data is record\n+      Base_Ticks : LARGE_INTEGER;\n+      --  Holds the Tick count for the base time\n+\n+      Base_Time : Long_Long_Integer;\n+      --  Holds the base time used to check for system time change, used with\n+      --  the standard clock.\n+\n+      Base_Clock : Duration;\n+      --  Holds the current clock for the standard clock's base time\n+   end record;\n+\n+   type Clock_Data_Access is access all Clock_Data;\n+\n+   --  Two base clock buffers. This is used to be able to update a buffer\n+   --  while the other buffer is read. The point is that we do not want to\n+   --  use a lock inside the Clock routine for performance reasons. We still\n+   --  use a lock in the Get_Base_Time which is called very rarely. Current\n+   --  is a pointer, the pragma Atomic is there to ensure that the value can\n+   --  be set or read atomically. That's it, when Get_Base_Time has updated\n+   --  a buffer the switch to the new value is done by changing Current\n+   --  pointer.\n+\n+   First, Second : aliased Clock_Data;\n+   Current       : Clock_Data_Access := First'Access;\n+   pragma Atomic (Current);\n \n-   procedure Get_Base_Time;\n+   --  The following signature is to detect change on the base clock data\n+   --  above. The signature is a modular type, it will wrap around without\n+   --  raising an exception. We would need to have exactly 2**32 updates of\n+   --  the base data for the changes to get undetected.\n+\n+   type Signature_Type is mod 2**32;\n+   Signature     : Signature_Type := 0;\n+   pragma Atomic (Signature);\n+\n+   procedure Get_Base_Time (Data : out Clock_Data);\n    --  Retrieve the base time and base ticks. These values will be used by\n    --  clock to compute the current time by adding to it a fraction of the\n    --  performance counter. This is for the implementation of a\n@@ -82,24 +110,40 @@ package body System.OS_Primitives is\n    function Clock return Duration is\n       Max_Shift            : constant Duration        := 2.0;\n       Hundreds_Nano_In_Sec : constant Long_Long_Float := 1.0E7;\n+      Data                 : Clock_Data;\n       Current_Ticks        : aliased LARGE_INTEGER;\n       Elap_Secs_Tick       : Duration;\n       Elap_Secs_Sys        : Duration;\n       Now                  : aliased Long_Long_Integer;\n+      Sig1, Sig2           : Signature_Type;\n \n    begin\n+      --  Try ten times to get a coherent set of base data. For this we just\n+      --  check that the signature hasn't changed during the copy of the\n+      --  current data.\n+      --\n+      --  This loop will always be done once if there is no interleaved call\n+      --  to Get_Base_Time.\n+\n+      for K in 1 .. 10 loop\n+         Sig1 := Signature;\n+         Data := Current.all;\n+         Sig2 := Signature;\n+         exit when Sig1 = Sig2;\n+      end loop;\n+\n       if QueryPerformanceCounter (Current_Ticks'Access) = Win32.FALSE then\n          return 0.0;\n       end if;\n \n       GetSystemTimeAsFileTime (Now'Access);\n \n       Elap_Secs_Sys :=\n-        Duration (Long_Long_Float (abs (Now - Base_Time)) /\n+        Duration (Long_Long_Float (abs (Now - Data.Base_Time)) /\n                     Hundreds_Nano_In_Sec);\n \n       Elap_Secs_Tick :=\n-        Duration (Long_Long_Float (Current_Ticks - Base_Ticks) /\n+        Duration (Long_Long_Float (Current_Ticks - Data.Base_Ticks) /\n                   Long_Long_Float (Tick_Frequency));\n \n       --  If we have a shift of more than Max_Shift seconds we resynchronize\n@@ -108,21 +152,21 @@ package body System.OS_Primitives is\n       --  for this system (non-monotonic) clock.\n \n       if abs (Elap_Secs_Sys - Elap_Secs_Tick) > Max_Shift then\n-         Get_Base_Time;\n+         Get_Base_Time (Data);\n \n          Elap_Secs_Tick :=\n-           Duration (Long_Long_Float (Current_Ticks - Base_Ticks) /\n+           Duration (Long_Long_Float (Current_Ticks - Data.Base_Ticks) /\n                      Long_Long_Float (Tick_Frequency));\n       end if;\n \n-      return Base_Clock + Elap_Secs_Tick;\n+      return Data.Base_Clock + Elap_Secs_Tick;\n    end Clock;\n \n    -------------------\n    -- Get_Base_Time --\n    -------------------\n \n-   procedure Get_Base_Time is\n+   procedure Get_Base_Time (Data : out Clock_Data) is\n \n       --  The resolution for GetSystemTime is 1 millisecond\n \n@@ -136,11 +180,13 @@ package body System.OS_Primitives is\n       Max_Elapsed    : constant LARGE_INTEGER :=\n                          LARGE_INTEGER (Tick_Frequency / 100_000);\n       --  Look for a precision of 0.01 ms\n+      Sig            : constant Signature_Type := Signature;\n \n       Loc_Ticks, Ctrl_Ticks : aliased LARGE_INTEGER;\n       Loc_Time, Ctrl_Time   : aliased Long_Long_Integer;\n       Elapsed               : LARGE_INTEGER;\n       Current_Max           : LARGE_INTEGER := LARGE_INTEGER'Last;\n+      New_Data              : Clock_Data_Access;\n \n    begin\n       --  Here we must be sure that both of these calls are done in a short\n@@ -157,6 +203,28 @@ package body System.OS_Primitives is\n       --  millisecond) otherwise the runtime will use the best value reached\n       --  during the runs.\n \n+      Lock;\n+\n+      --  First check that the current value has not been updated. This\n+      --  could happen if another task has called Clock at the same time\n+      --  and that Max_Shift has been reached too.\n+      --\n+      --  But if the current value has been changed just before we entered\n+      --  into the critical section, we can safely return as the current\n+      --  base data (time, clock, ticks) have already been updated.\n+\n+      if Sig /= Signature then\n+         return;\n+      end if;\n+\n+      --  Check for the unused data buffer and set New_Data to point to it\n+\n+      if Current = First'Access then\n+         New_Data := Second'Access;\n+      else\n+         New_Data := First'Access;\n+      end if;\n+\n       for K in 1 .. 10 loop\n          if QueryPerformanceCounter (Loc_Ticks'Access) = Win32.FALSE then\n             pragma Assert\n@@ -191,8 +259,8 @@ package body System.OS_Primitives is\n          Elapsed := Ctrl_Ticks - Loc_Ticks;\n \n          if Elapsed < Current_Max then\n-            Base_Time   := Loc_Time;\n-            Base_Ticks  := Loc_Ticks;\n+            New_Data.Base_Time   := Loc_Time;\n+            New_Data.Base_Ticks  := Loc_Ticks;\n             Current_Max := Elapsed;\n \n             --  Exit the loop when we have reached the expected precision\n@@ -201,9 +269,27 @@ package body System.OS_Primitives is\n          end if;\n       end loop;\n \n-      Base_Clock := Duration\n-        (Long_Long_Float ((Base_Time - epoch_1970) * system_time_ns) /\n-         Long_Long_Float (Sec_Unit));\n+      New_Data.Base_Clock := Duration\n+        (Long_Long_Float ((New_Data.Base_Time - epoch_1970) * system_time_ns) /\n+           Long_Long_Float (Sec_Unit));\n+\n+      --  At this point all the base values have been set into the new data\n+      --  record. We just change the pointer (atomic operation) to this new\n+      --  values.\n+\n+      Current := New_Data;\n+      Data    := New_Data.all;\n+\n+      --  Set new signature for this data set\n+\n+      Signature := Signature + 1;\n+\n+      Unlock;\n+\n+   exception\n+      when others =>\n+         Unlock;\n+         raise;\n    end Get_Base_Time;\n \n    ---------------------\n@@ -305,14 +391,14 @@ package body System.OS_Primitives is\n            \"cannot get high performance counter frequency\";\n       end if;\n \n-      Get_Base_Time;\n+      Get_Base_Time (Current.all);\n \n       --  Keep base clock and ticks for the monotonic clock. These values\n       --  should never be changed to ensure proper behavior of the monotonic\n       --  clock.\n \n-      Base_Monotonic_Clock := Base_Clock;\n-      Base_Monotonic_Ticks := Base_Ticks;\n+      Base_Monotonic_Clock := Current.Base_Clock;\n+      Base_Monotonic_Ticks := Current.Base_Ticks;\n    end Initialize;\n \n end System.OS_Primitives;"}, {"sha": "32b5130f79782158956736b9de433255041ac787", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -886,10 +886,15 @@ package body Sem_Prag is\n       --  to declare types that match predefined C types, especially for cases\n       --  without corresponding Ada predefined type.\n \n-      procedure Process_Inline (Active : Boolean);\n-      --  Common processing for Inline and Inline_Always. The parameter\n-      --  indicates if the inline pragma is active, i.e. if it should actually\n-      --  cause inlining to occur.\n+      type Inline_Status is (Suppressed, Disabled, Enabled);\n+      --  Inline status of a subprogram, indicated as follows:\n+      --    Suppressed: inlining is suppressed for the subprogram\n+      --    Disabled:   no inlining is requested for the subprogram\n+      --    Enabled:    inlining is requested/required for the subprogram\n+\n+      procedure Process_Inline (Status : Inline_Status);\n+      --  Common processing for Inline, Inline_Always and No_Inline. Parameter\n+      --  indicates the inline status specified by the pragma.\n \n       procedure Process_Interface_Name\n         (Subprogram_Def : Entity_Id;\n@@ -4912,7 +4917,7 @@ package body Sem_Prag is\n       -- Process_Inline --\n       --------------------\n \n-      procedure Process_Inline (Active : Boolean) is\n+      procedure Process_Inline (Status : Inline_Status) is\n          Assoc     : Node_Id;\n          Decl      : Node_Id;\n          Subp_Id   : Node_Id;\n@@ -5017,7 +5022,9 @@ package body Sem_Prag is\n \n             --  If inlining is not possible, for now do not treat as an error\n \n-            elsif Inlining_Not_Possible (Subp) then\n+            elsif Status /= Suppressed\n+              and then Inlining_Not_Possible (Subp)\n+            then\n                Applies := True;\n                return;\n \n@@ -5145,18 +5152,56 @@ package body Sem_Prag is\n \n          procedure Set_Inline_Flags (Subp : Entity_Id) is\n          begin\n-            if Active then\n-               Set_Is_Inlined (Subp);\n-            end if;\n+            --  First set the Has_Pragma_XXX flags and issue the appropriate\n+            --  errors and warnings for suspicious combinations.\n \n-            if not Has_Pragma_Inline (Subp) then\n-               Set_Has_Pragma_Inline (Subp);\n-               Effective := True;\n-            end if;\n+            if Prag_Id = Pragma_No_Inline then\n+               if Has_Pragma_Inline_Always (Subp) then\n+                  Error_Msg_N\n+                    (\"Inline_Always and No_Inline are mutually exclusive\", N);\n+               elsif Has_Pragma_Inline (Subp) then\n+                  Error_Msg_NE\n+                    (\"Inline and No_Inline both specified for& ??\",\n+                     N, Entity (Subp_Id));\n+               end if;\n \n-            if Prag_Id = Pragma_Inline_Always then\n-               Set_Has_Pragma_Inline_Always (Subp);\n+               Set_Has_Pragma_No_Inline (Subp);\n+            else\n+               if Prag_Id = Pragma_Inline_Always then\n+                  if Has_Pragma_No_Inline (Subp) then\n+                     Error_Msg_N\n+                       (\"Inline_Always and No_Inline are mutually exclusive\",\n+                        N);\n+                  end if;\n+\n+                  Set_Has_Pragma_Inline_Always (Subp);\n+               else\n+                  if Has_Pragma_No_Inline (Subp) then\n+                     Error_Msg_NE\n+                       (\"Inline and No_Inline both specified for& ??\",\n+                        N, Entity (Subp_Id));\n+                  end if;\n+               end if;\n+\n+               if not Has_Pragma_Inline (Subp) then\n+                  Set_Has_Pragma_Inline (Subp);\n+                  Effective := True;\n+               end if;\n             end if;\n+\n+            --  Then adjust the Is_Inlined flag. It can never be set if the\n+            --  subprogram is subject to pragma No_Inline.\n+\n+            case Status is\n+               when Suppressed =>\n+                  Set_Is_Inlined (Subp, False);\n+               when Disabled =>\n+                  null;\n+               when Enabled =>\n+                  if not Has_Pragma_No_Inline (Subp) then\n+                     Set_Is_Inlined (Subp, True);\n+                  end if;\n+            end case;\n          end Set_Inline_Flags;\n \n       --  Start of processing for Process_Inline\n@@ -5165,7 +5210,7 @@ package body Sem_Prag is\n          Check_No_Identifiers;\n          Check_At_Least_N_Arguments (1);\n \n-         if Active then\n+         if Status = Enabled then\n             Inline_Processing_Required := True;\n          end if;\n \n@@ -5211,7 +5256,7 @@ package body Sem_Prag is\n \n             elsif not Effective\n               and then Warn_On_Redundant_Constructs\n-              and then not Suppress_All_Inlining\n+              and then not (Status = Suppressed or Suppress_All_Inlining)\n             then\n                if Inlining_Not_Possible (Subp) then\n                   Error_Msg_NE\n@@ -11061,9 +11106,13 @@ package body Sem_Prag is\n \n          when Pragma_Inline =>\n \n-            --  Pragma is active if inlining option is active\n+            --  Inline status is Enabled if inlining option is active\n \n-            Process_Inline (Inline_Active);\n+            if Inline_Active then\n+               Process_Inline (Enabled);\n+            else\n+               Process_Inline (Disabled);\n+            end if;\n \n          -------------------\n          -- Inline_Always --\n@@ -11078,7 +11127,7 @@ package body Sem_Prag is\n             --  this causes walk order issues.\n \n             if not (CodePeer_Mode or Alfa_Mode) then\n-               Process_Inline (True);\n+               Process_Inline (Enabled);\n             end if;\n \n          --------------------\n@@ -12613,6 +12662,16 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Pragma_Misplaced;\n \n+         ---------------\n+         -- No_Inline --\n+         ---------------\n+\n+         --  pragma No_Inline ( NAME {, NAME} );\n+\n+         when Pragma_No_Inline =>\n+            GNAT_Pragma;\n+            Process_Inline (Suppressed);\n+\n          ---------------\n          -- No_Return --\n          ---------------\n@@ -16630,6 +16689,7 @@ package body Sem_Prag is\n       Pragma_Memory_Size                    => -1,\n       Pragma_No_Return                      =>  0,\n       Pragma_No_Body                        =>  0,\n+      Pragma_No_Inline                      =>  0,\n       Pragma_No_Run_Time                    => -1,\n       Pragma_No_Strict_Aliasing             => -1,\n       Pragma_Normalize_Scalars              => -1,"}, {"sha": "ae6fe607c8896d6a1cad1b59f5e7041ce9891552", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -11997,9 +11997,6 @@ package body Sem_Util is\n    -- Object_Access_Level --\n    -------------------------\n \n-   function Object_Access_Level (Obj : Node_Id) return Uint is\n-      E : Entity_Id;\n-\n    --  Returns the static accessibility level of the view denoted by Obj. Note\n    --  that the value returned is the result of a call to Scope_Depth. Only\n    --  scope depths associated with dynamic scopes can actually be returned.\n@@ -12008,6 +12005,12 @@ package body Sem_Util is\n    --  always one is immaterial (invariant: if level(E2) is deeper than\n    --  level(E1), then Scope_Depth(E1) < Scope_Depth(E2)).\n \n+   function Object_Access_Level (Obj : Node_Id) return Uint is\n+      function Is_Interface_Conversion (N : Node_Id) return Boolean;\n+      --  Determine whether N is a construct of the form\n+      --    Some_Type (Operand._tag'Address)\n+      --  This construct appears in the context of dispatching calls\n+\n       function Reference_To (Obj : Node_Id) return Node_Id;\n       --  An explicit dereference is created when removing side-effects from\n       --  expressions for constraint checking purposes. In this case a local\n@@ -12016,6 +12019,18 @@ package body Sem_Util is\n       --  prefix of the dereference is created by an object declaration whose\n       --  initial expression is a reference.\n \n+      -----------------------------\n+      -- Is_Interface_Conversion --\n+      -----------------------------\n+\n+      function Is_Interface_Conversion (N : Node_Id) return Boolean is\n+      begin\n+         return\n+           Nkind (N) = N_Unchecked_Type_Conversion\n+             and then Nkind (Expression (N)) = N_Attribute_Reference\n+             and then Attribute_Name (Expression (N)) = Name_Address;\n+      end Is_Interface_Conversion;\n+\n       ------------------\n       -- Reference_To --\n       ------------------\n@@ -12034,6 +12049,10 @@ package body Sem_Util is\n          end if;\n       end Reference_To;\n \n+      --  Local variables\n+\n+      E : Entity_Id;\n+\n    --  Start of processing for Object_Access_Level\n \n    begin\n@@ -12104,7 +12123,17 @@ package body Sem_Util is\n          then\n             return Object_Access_Level (Prefix (Obj));\n \n-         elsif not (Comes_From_Source (Obj)) then\n+         --  Detect an interface conversion in the context of a dispatching\n+         --  call. Use the original form of the conversion to find the access\n+         --  level of the operand.\n+\n+         elsif Is_Interface (Etype (Obj))\n+           and then Is_Interface_Conversion (Prefix (Obj))\n+           and then Nkind (Original_Node (Obj)) = N_Type_Conversion\n+         then\n+            return Object_Access_Level (Original_Node (Obj));\n+\n+         elsif not Comes_From_Source (Obj) then\n             declare\n                Ref : constant Node_Id := Reference_To (Obj);\n             begin\n@@ -12119,9 +12148,7 @@ package body Sem_Util is\n             return Type_Access_Level (Etype (Prefix (Obj)));\n          end if;\n \n-      elsif Nkind (Obj) = N_Type_Conversion\n-        or else Nkind (Obj) = N_Unchecked_Type_Conversion\n-      then\n+      elsif Nkind_In (Obj, N_Type_Conversion, N_Unchecked_Type_Conversion) then\n          return Object_Access_Level (Expression (Obj));\n \n       elsif Nkind (Obj) = N_Function_Call then"}, {"sha": "5e5d1a2743c3e2405369787abfd347e6346fa99a", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae387068be90759ead414855ecd14e933b0a4e/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=42ae387068be90759ead414855ecd14e933b0a4e", "patch": "@@ -549,6 +549,7 @@ package Snames is\n    Name_Main_Storage                   : constant Name_Id := N + $; -- GNAT\n    Name_Memory_Size                    : constant Name_Id := N + $; -- Ada 83\n    Name_No_Body                        : constant Name_Id := N + $; -- GNAT\n+   Name_No_Inline                      : constant Name_Id := N + $; -- GNAT\n    Name_No_Return                      : constant Name_Id := N + $; -- Ada 05\n    Name_Obsolescent                    : constant Name_Id := N + $; -- GNAT\n    Name_Optimize                       : constant Name_Id := N + $;\n@@ -1819,6 +1820,7 @@ package Snames is\n       Pragma_Main_Storage,\n       Pragma_Memory_Size,\n       Pragma_No_Body,\n+      Pragma_No_Inline,\n       Pragma_No_Return,\n       Pragma_Obsolescent,\n       Pragma_Optimize,"}]}