{"sha": "311b62ce0310876fbffeeaab0b50707242b3e663", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzExYjYyY2UwMzEwODc2ZmJmZmVlYWFiMGI1MDcwNzI0MmIzZTY2Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:20:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:20:23Z"}, "message": "Remove global call sets: cse.c\n\nLike with the combine.c patch, this one keeps things simple by\ninvalidating values in partially-clobbered registers, rather than\ntrying to tell whether the value in a partially-clobbered register\nis actually clobbered or not.  Again, this is in principle a bug fix,\nbut probably never matters in practice.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* cse.c: Include regs.h and function-abi.h.\n\t(invalidate_for_call): Take the call insn as an argument.\n\tUse insn_callee_abi to get the ABI of the call and invalidate\n\tpartially clobbered registers as well as fully clobbered ones.\n\t(cse_insn): Update call accordingly.\n\nFrom-SVN: r276317", "tree": {"sha": "6d68e0cd56c765e61cccd1da7b2d3fa78160b9cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d68e0cd56c765e61cccd1da7b2d3fa78160b9cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/311b62ce0310876fbffeeaab0b50707242b3e663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/311b62ce0310876fbffeeaab0b50707242b3e663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/311b62ce0310876fbffeeaab0b50707242b3e663", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/311b62ce0310876fbffeeaab0b50707242b3e663/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "212b7076eec027d212e1badb9cb5a9db4b62ab50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/212b7076eec027d212e1badb9cb5a9db4b62ab50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/212b7076eec027d212e1badb9cb5a9db4b62ab50"}], "stats": {"total": 51, "additions": 32, "deletions": 19}, "files": [{"sha": "181fd8056e051eec1fb9b02136cd9e5aa2ab1112", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311b62ce0310876fbffeeaab0b50707242b3e663/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311b62ce0310876fbffeeaab0b50707242b3e663/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=311b62ce0310876fbffeeaab0b50707242b3e663", "patch": "@@ -1,3 +1,11 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* cse.c: Include regs.h and function-abi.h.\n+\t(invalidate_for_call): Take the call insn as an argument.\n+\tUse insn_callee_abi to get the ABI of the call and invalidate\n+\tpartially clobbered registers as well as fully clobbered ones.\n+\t(cse_insn): Update call accordingly.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* combine.c: Include function-abi.h."}, {"sha": "be3277b86609b356d440921b1cb299fb568d4605", "filename": "gcc/cse.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311b62ce0310876fbffeeaab0b50707242b3e663/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311b62ce0310876fbffeeaab0b50707242b3e663/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=311b62ce0310876fbffeeaab0b50707242b3e663", "patch": "@@ -42,6 +42,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"rtl-iter.h\"\n+#include \"regs.h\"\n+#include \"function-abi.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -566,7 +568,6 @@ static void remove_invalid_subreg_refs (unsigned int, poly_uint64,\n \t\t\t\t\tmachine_mode);\n static void rehash_using_reg (rtx);\n static void invalidate_memory (void);\n-static void invalidate_for_call (void);\n static rtx use_related_value (rtx, struct table_elt *);\n \n static inline unsigned canon_hash (rtx, machine_mode);\n@@ -2091,23 +2092,31 @@ rehash_using_reg (rtx x)\n }\n \f\n /* Remove from the hash table any expression that is a call-clobbered\n-   register.  Also update their TICK values.  */\n+   register in INSN.  Also update their TICK values.  */\n \n static void\n-invalidate_for_call (void)\n+invalidate_for_call (rtx_insn *insn)\n {\n-  unsigned int regno, endregno;\n-  unsigned int i;\n+  unsigned int regno;\n   unsigned hash;\n   struct table_elt *p, *next;\n   int in_table = 0;\n   hard_reg_set_iterator hrsi;\n \n-  /* Go through all the hard registers.  For each that is clobbered in\n-     a CALL_INSN, remove the register from quantity chains and update\n+  /* Go through all the hard registers.  For each that might be clobbered\n+     in call insn INSN, remove the register from quantity chains and update\n      reg_tick if defined.  Also see if any of these registers is currently\n-     in the table.  */\n-  EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, regno, hrsi)\n+     in the table.\n+\n+     ??? We could be more precise for partially-clobbered registers,\n+     and only invalidate values that actually occupy the clobbered part\n+     of the registers.  It doesn't seem worth the effort though, since\n+     we shouldn't see this situation much before RA.  Whatever choice\n+     we make here has to be consistent with the table walk below,\n+     so any change to this test will require a change there too.  */\n+  HARD_REG_SET callee_clobbers\n+    = insn_callee_abi (insn).full_and_partial_reg_clobbers ();\n+  EXECUTE_IF_SET_IN_HARD_REG_SET (callee_clobbers, 0, regno, hrsi)\n     {\n       delete_reg_equiv (regno);\n       if (REG_TICK (regno) >= 0)\n@@ -2132,15 +2141,11 @@ invalidate_for_call (void)\n \t      || REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n \t    continue;\n \n-\t  regno = REGNO (p->exp);\n-\t  endregno = END_REGNO (p->exp);\n-\n-\t  for (i = regno; i < endregno; i++)\n-\t    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-\t      {\n-\t\tremove_from_table (p, hash);\n-\t\tbreak;\n-\t      }\n+\t  /* This must use the same test as above rather than the\n+\t     more accurate clobbers_reg_p.  */\n+\t  if (overlaps_hard_reg_set_p (callee_clobbers, GET_MODE (p->exp),\n+\t\t\t\t       REGNO (p->exp)))\n+\t    remove_from_table (p, hash);\n \t}\n }\n \f\n@@ -5823,7 +5828,7 @@ cse_insn (rtx_insn *insn)\n \t  if (GET_CODE (XEXP (tem, 0)) == USE\n \t      && MEM_P (XEXP (XEXP (tem, 0), 0)))\n \t    invalidate (XEXP (XEXP (tem, 0), 0), VOIDmode);\n-      invalidate_for_call ();\n+      invalidate_for_call (insn);\n     }\n \n   /* Now invalidate everything set by this instruction."}]}