{"sha": "3a3f4da9377970c5cfd96dc7f4717427384263c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EzZjRkYTkzNzc5NzBjNWNmZDk2ZGM3ZjQ3MTc0MjczODQyNjNjNA==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2004-05-18T17:32:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-05-18T17:32:54Z"}, "message": "Makefile.in (tree-ssa-phiopt.o): Depends on flags.h.\n\n        * Makefile.in (tree-ssa-phiopt.o): Depends on flags.h.\n        * tree-ssa-phiopt.c: Include flags.h.\n        (conditional_replacement): Remove argument names from prototype.\n        Minor formatting and comment fixes.\n        (tree_ssa_phiopt): If conditional_replacement returns false, then\n        call value_replacement.\n        (value_replacement): New function.\n\n        * gcc.dg/tree-ssa/20040518-1.c: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r81999", "tree": {"sha": "194220596a30a54f69c02beeac10a3e12a189d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/194220596a30a54f69c02beeac10a3e12a189d98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a3f4da9377970c5cfd96dc7f4717427384263c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3f4da9377970c5cfd96dc7f4717427384263c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a3f4da9377970c5cfd96dc7f4717427384263c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3f4da9377970c5cfd96dc7f4717427384263c4/comments", "author": null, "committer": null, "parents": [{"sha": "e584e50152ea99c4f44f48a79a308cba7645c241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e584e50152ea99c4f44f48a79a308cba7645c241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e584e50152ea99c4f44f48a79a308cba7645c241"}], "stats": {"total": 144, "additions": 129, "deletions": 15}, "files": [{"sha": "06df3c2d483260269ac549d3ee0ec6ab908437c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a3f4da9377970c5cfd96dc7f4717427384263c4", "patch": "@@ -1,3 +1,14 @@\n+2004-05-18  Andrew Pinski  <pinskia@physics.uc.edu>\n+\t    Jeff Law <law@redhat.com>\n+\n+\t* Makefile.in (tree-ssa-phiopt.o): Depends on flags.h.\n+\t* tree-ssa-phiopt.c: Include flags.h.\n+\t(conditional_replacement): Remove argument names from prototype.\n+\tMinor formatting and comment fixes.\n+\t(tree_ssa_phiopt): If conditional_replacement returns false, then\n+\tcall value_replacement.\n+\t(value_replacement): New function.\n+\n 2004-05-18  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-phiopt.c (replace_phi_with_stmt): New function extracted"}, {"sha": "804aa5ea88a91b7bdb7b9c7961801c678d7c4606", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3a3f4da9377970c5cfd96dc7f4717427384263c4", "patch": "@@ -1581,7 +1581,7 @@ tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H)\n tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n-   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) langhooks.h\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) langhooks.h flags.h\n tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(RTL_H) function.h $(BASIC_BLOCK_H) $(EXPR_H) \\\n    diagnostic.h $(TREE_FLOW_H) $(TIMEVAR_H) $(TREE_DUMP_H) tree-pass.h \\"}, {"sha": "fcf983fbd7dcb6e3a903d5317731e7edabdb93f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a3f4da9377970c5cfd96dc7f4717427384263c4", "patch": "@@ -1,3 +1,7 @@\n+2004-05-18  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* gcc.dg/tree-ssa/20040518-1.c: New test.\n+\n 2004-05-18  Zack Weinberg  <zack@codesourcery.com>\n \n \t* gcc.c-torture/execute/991216-3.c: Delete, duplicate of 991216-2.c."}, {"sha": "f80a74a14eab0064c9f6cf37cf6b0d014248a087", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040518-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040518-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040518-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040518-1.c?ref=3a3f4da9377970c5cfd96dc7f4717427384263c4", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-phiopt1-details\" } */\n+int f(int a, int b)\n+{\n+   int c = b;\n+   if (a != b)\n+    c = a;\n+   return c;\n+}\n+\n+/* Should have no ifs left after straightening.  */\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"phiopt1\"} } */"}, {"sha": "bc339c808bf7e15fe7b2bbd100fd07355bc49ece", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 101, "deletions": 14, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a3f4da9377970c5cfd96dc7f4717427384263c4/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=3a3f4da9377970c5cfd96dc7f4717427384263c4", "patch": "@@ -26,6 +26,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"flags.h\"\n #include \"tm_p.h\"\n #include \"basic-block.h\"\n #include \"timevar.h\"\n@@ -36,15 +37,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n \n static void tree_ssa_phiopt (void);\n-static bool conditional_replacement (basic_block bb, tree phi, tree arg0,\n-\t\t\t\t     tree arg1);\t\t\t    \n+static bool conditional_replacement (basic_block, tree, tree, tree);\n+static bool value_replacement (basic_block, tree, tree, tree);\n static void replace_phi_with_stmt (block_stmt_iterator, basic_block,\n \t\t\t\t   basic_block, tree, tree);\n static bool candidate_bb_for_phi_optimization (basic_block,\n \t\t\t\t\t       basic_block *,\n \t\t\t\t\t       basic_block *);\n \n-\t\t\t\t  \n /* This pass eliminates PHI nodes which can be trivially implemented as\n    an assignment from a conditional expression.  ie if we have something\n    like:\n@@ -64,7 +64,25 @@ static bool candidate_bb_for_phi_optimization (basic_block,\n \n    bb1 will become unreachable and bb0 and bb2 will almost always\n    be merged into a single block.  This occurs often due to gimplification\n-   of conditionals.  */\n+    of conditionals. \n+   \n+   Also done is the following optimization:\n+\n+     bb0:\n+      if (a != b) goto bb2; else goto bb1;\n+     bb1:\n+     bb2:\n+      x = PHI (a (bb1), b (bb0))\n+\n+   We can rewrite that as:\n+\n+     bb0:\n+     bb1:\n+     bb2:\n+      x = b;\n+\n+   This can sometimes occur as a result of other optimizations.  A\n+   similar transformation is done by the ifcvt RTL optimizer.  */\n    \n static void\n tree_ssa_phiopt (void)\n@@ -77,7 +95,6 @@ tree_ssa_phiopt (void)\n     {\n       tree arg0, arg1, phi;\n \n-\n       /* We're searching for blocks with one PHI node which has two\n \t arguments.  */\n       phi = phi_nodes (bb);\n@@ -88,12 +105,13 @@ tree_ssa_phiopt (void)\n \t  arg1 = PHI_ARG_DEF (phi, 1);\n \t    \n \t  /* Do the replacement of conditional if it can be done.  */\n-\t  if (conditional_replacement (bb, phi, arg0, arg1))\n-\t    {\n-\t      /* We have done the replacement so we need to rebuild the cfg.  */\n-\t      removed_phis = true;\n-\t      continue;\n-\t    }\n+\t    if (conditional_replacement (bb, phi, arg0, arg1)\n+\t\t|| value_replacement (bb, phi, arg0, arg1))\n+\t      {\n+\t\t/* We have done the replacement so we need to rebuild the\n+\t\t   cfg when this pass is complete.  */\n+\t\tremoved_phis = true;\n+\t      }\n \t}\n     }\n \n@@ -294,8 +312,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \t\t    TREE_OPERAND (old_result, 0),\n \t\t    TREE_OPERAND (old_result, 1));\n       \n-      new1 = build (MODIFY_EXPR, TREE_TYPE (result),\n-\t\t    new_var, new1);\n+      new1 = build (MODIFY_EXPR, TREE_TYPE (result), new_var, new1);\n       bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n     }\n   \n@@ -330,7 +347,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n       \n       cond = cond1;\n       /* If what we get back is a conditional expression, there is no\n-\t way that is can be gimple.   */\n+\t  way that it can be gimple.  */\n       if (TREE_CODE (cond) == COND_EXPR)\n \treturn false; \n \n@@ -360,6 +377,76 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   return true;\n }\n \n+/*  The function value_replacement does the main work of doing the value\n+    replacement.  Return true if the replacement is done.  Otherwise return\n+    false.\n+    BB is the basic block where the replacement is going to be done on.  ARG0\n+    is argument 0 from the PHI.  Likewise for ARG1.   */\n+\n+static bool\n+value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n+{\n+  tree result;\n+  basic_block other_block = NULL;\n+  basic_block cond_block = NULL;\n+  tree new, cond;\n+  edge true_edge, false_edge;\n+\n+  /* If the type says honor signed zeros we cannot do this\n+     optimization.   */\n+  if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n+    return false;\n+\n+  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block))\n+    return false;\n+\n+  cond = COND_EXPR_COND (last_stmt (cond_block));\n+  result = PHI_RESULT (phi);\n+\n+  /* This transformation is only valid for equality comparisons.  */\n+  if (TREE_CODE (cond) != NE_EXPR && TREE_CODE (cond) != EQ_EXPR)\n+    return false;\n+\n+  /* We need to know which is the true edge and which is the false\n+      edge so that we know if have abs or negative abs.  */\n+  extract_true_false_edges_from_block (cond_block, &true_edge, &false_edge);\n+\n+  /* At this point we know we have a COND_EXPR with two successors.\n+     One successor is BB, the other successor is an empty block which\n+     falls through into BB.\n+\n+     The condition for the COND_EXPR is known to be NE_EXPR or EQ_EXPR.\n+\n+     There is a single PHI node at the join point (BB) with two arguments.\n+\n+     We now need to verify that the two arguments in the PHI node match\n+     the two arguments to the equality comparison.  */\n+  \n+  if ((operand_equal_p (arg0, TREE_OPERAND (cond, 0), 0)\n+       && operand_equal_p (arg1, TREE_OPERAND (cond, 1), 0))\n+      || (operand_equal_p (arg1, TREE_OPERAND (cond, 0), 0)\n+\t  && operand_equal_p (arg0, TREE_OPERAND (cond, 1), 0)))\n+    {\n+      edge e;\n+      tree arg;\n+\n+      e = (TREE_CODE (cond) == NE_EXPR ? true_edge : false_edge);\n+      if (PHI_ARG_EDGE (phi, 0) == e)\n+\targ = arg0;\n+      else\n+\targ = arg1;\n+\n+      /* Build the new assignment.  */\n+      new = build (MODIFY_EXPR, TREE_TYPE (result), result, arg);\n+\n+      replace_phi_with_stmt (bsi_start (bb), bb, cond_block, phi, new);\n+\n+      /* Note that we optimized this PHI.  */\n+      return true;\n+    }\n+  return false;\n+}\n+\n \n /* Always do these optimizations if we have SSA\n    trees to work on.  */\t\t\t\t\t\t"}]}