{"sha": "bfc79d3b30a7273612d573bd15f46af1e47da502", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZjNzlkM2IzMGE3MjczNjEyZDU3M2JkMTVmNDZhZjFlNDdkYTUwMg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1999-04-27T12:39:58Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1999-04-27T12:39:58Z"}, "message": "rs6000.h (read_only_data_section, [...]): Align CSECT on doubleword boundary for 64-bit target.\n\n\t* rs6000.h (read_only_data_section, private_data_section,\n\tread_only_private_data_section, toc_section): Align CSECT on\n\tdoubleword boundary for 64-bit target.\n\t(DATA_SECTION_ASM_OP): Likewise.\n\t* rs6000.c (rs6000_stack_info): Leaf procedure stack limit is 288.\n\nFrom-SVN: r26678", "tree": {"sha": "800a5beceec10d16b40a21ccd49a4a250037d67a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/800a5beceec10d16b40a21ccd49a4a250037d67a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfc79d3b30a7273612d573bd15f46af1e47da502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfc79d3b30a7273612d573bd15f46af1e47da502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfc79d3b30a7273612d573bd15f46af1e47da502", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfc79d3b30a7273612d573bd15f46af1e47da502/comments", "author": null, "committer": null, "parents": [{"sha": "a5cf6c1c947ede1377461083eb460e0c63e38d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5cf6c1c947ede1377461083eb460e0c63e38d90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5cf6c1c947ede1377461083eb460e0c63e38d90"}], "stats": {"total": 45, "additions": 29, "deletions": 16}, "files": [{"sha": "a80fb4d25f21a5ab102240453e95ebee24818b01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc79d3b30a7273612d573bd15f46af1e47da502/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc79d3b30a7273612d573bd15f46af1e47da502/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfc79d3b30a7273612d573bd15f46af1e47da502", "patch": "@@ -1,3 +1,11 @@\n+Tue Apr 27 15:33:42 1999  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* rs6000.h (read_only_data_section, private_data_section,\n+\tread_only_private_data_section, toc_section): Align CSECT on\n+\tdoubleword boundary for 64-bit target.\n+\t(DATA_SECTION_ASM_OP): Likewise.\n+\t* rs6000.c (rs6000_stack_info): Leaf procedure stack limit is 288.\n+\n Tue Apr 27 20:19:47 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.md (insv): Use copy_addr_to_reg."}, {"sha": "072e0d1229efda74da7694accf8a7c22d41cfdc0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc79d3b30a7273612d573bd15f46af1e47da502/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc79d3b30a7273612d573bd15f46af1e47da502/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bfc79d3b30a7273612d573bd15f46af1e47da502", "patch": "@@ -308,7 +308,7 @@ rs6000_override_options (default_cpu)\n      little endian mode, and causes an alignment trap.  The 750 does not cause\n      an alignment trap (except when the target is unaligned).  */\n \n-  if (!BYTES_BIG_ENDIAN && rs6000_cpu != PROCESSOR_PPC750)\n+  if (! BYTES_BIG_ENDIAN && rs6000_cpu != PROCESSOR_PPC750)\n     {\n       if (TARGET_MULTIPLE)\n \t{\n@@ -335,11 +335,11 @@ rs6000_override_options (default_cpu)\n   /* Set debug flags */\n   if (rs6000_debug_name)\n     {\n-      if (!strcmp (rs6000_debug_name, \"all\"))\n+      if (! strcmp (rs6000_debug_name, \"all\"))\n \trs6000_debug_stack = rs6000_debug_arg = 1;\n-      else if (!strcmp (rs6000_debug_name, \"stack\"))\n+      else if (! strcmp (rs6000_debug_name, \"stack\"))\n \trs6000_debug_stack = 1;\n-      else if (!strcmp (rs6000_debug_name, \"arg\"))\n+      else if (! strcmp (rs6000_debug_name, \"arg\"))\n \trs6000_debug_arg = 1;\n       else\n \terror (\"Unknown -mdebug-%s switch\", rs6000_debug_name);\n@@ -349,7 +349,8 @@ rs6000_override_options (default_cpu)\n   /* If the user desires alternate register names, copy in the alternate names\n      now.  */\n   if (TARGET_REGNAMES)\n-    bcopy ((char *)alt_reg_names, (char *)rs6000_reg_names, sizeof (rs6000_reg_names));\n+    bcopy ((char *)alt_reg_names, (char *)rs6000_reg_names,\n+\t   sizeof (rs6000_reg_names));\n #endif\n \n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n@@ -3607,7 +3608,7 @@ rs6000_stack_info ()\n      the stack might be dynamically adjusted), if we are debugging, if we\n      make calls, or if the sum of fp_save, gp_save, fpmem, and local variables\n      are more than the space needed to save all non-volatile registers:\n-     32-bit: 18*8 + 19*4 = 220 or 64-bit: 18*8 + 19*8 = 296\n+     32-bit: 18*8 + 19*4 = 220 or 64-bit: 18*8 + 18*8 = 288 (GPR13 reserved).\n \n      For V.4 we don't have the stack cushion that AIX uses, but assume that\n      the debugger can handle stackless frames.  */\n@@ -3624,7 +3625,7 @@ rs6000_stack_info ()\n     info_ptr->push_p = (frame_pointer_needed\n \t\t\t|| write_symbols != NO_DEBUG\n \t\t\t|| ((total_raw_size - info_ptr->fixed_size)\n-\t\t\t    > (TARGET_32BIT ? 220 : 296)));\n+\t\t\t    > (TARGET_32BIT ? 220 : 288)));\n \n   if (info_ptr->fpmem_p)\n     {"}, {"sha": "4aa720808c381d4d4b7fc3b909923bb7007a8a67", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfc79d3b30a7273612d573bd15f46af1e47da502/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfc79d3b30a7273612d573bd15f46af1e47da502/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=bfc79d3b30a7273612d573bd15f46af1e47da502", "patch": "@@ -2551,8 +2551,9 @@ read_only_data_section ()\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   if (in_section != read_only_data)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \".csect %s[RO]\\n\",\t\t\\\n-\t       xcoff_read_only_section_name);\t\t\\\n+      fprintf (asm_out_file, \".csect %s[RO]%s\\n\",\t\\\n+\t       xcoff_read_only_section_name,\t\t\\\n+\t       (TARGET_32BIT ? \"\" : \",3\"));\t\t\\\n       in_section = read_only_data;\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\\\n@@ -2562,9 +2563,9 @@ private_data_section ()\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   if (in_section != private_data)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \".csect %s[RW]\\n\",\t\t\\\n-\t       xcoff_private_data_section_name);\t\\\n-\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \".csect %s[RW]%s\\n\",\t\\\n+\t       xcoff_private_data_section_name,\t\t\\\n+\t       (TARGET_32BIT ? \"\" : \",3\"));\t\t\\\n       in_section = private_data;\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\\\n@@ -2574,8 +2575,9 @@ read_only_private_data_section ()\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   if (in_section != read_only_private_data)\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \".csect %s[RO]\\n\",\t\t\\\n-\t       xcoff_private_data_section_name);\t\\\n+      fprintf (asm_out_file, \".csect %s[RO]%s\\n\",\t\\\n+\t       xcoff_private_data_section_name,\t\t\\\n+\t       (TARGET_32BIT ? \"\" : \",3\"));\t\t\\\n       in_section = read_only_private_data;\t\t\\\n     }\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\\\n@@ -2596,7 +2598,8 @@ toc_section ()\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n       if (in_section != toc)\t\t\t\t\\\n-\tfputs (\".csect toc_table[RW]\\n\", asm_out_file); \\\n+\tfprintf (asm_out_file, \".csect toc_table[RW]%s\\n\",\t\\\n+\t\t (TARGET_32BIT ? \"\" : \",3\"));\t\t\\\n     }\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n@@ -2809,7 +2812,8 @@ extern int toc_initialized;\n \n /* Output before writable data.  */\n \n-#define DATA_SECTION_ASM_OP \".csect .data[RW]\"\n+#define DATA_SECTION_ASM_OP (TARGET_32BIT \\\n+\t\t\t     ? \".csect .data[RW]\" : \".csect .data[RW],3\")\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */"}]}