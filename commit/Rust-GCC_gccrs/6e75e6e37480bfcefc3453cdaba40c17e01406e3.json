{"sha": "6e75e6e37480bfcefc3453cdaba40c17e01406e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3NWU2ZTM3NDgwYmZjZWZjMzQ1M2NkYWJhNDBjMTdlMDE0MDZlMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-19T08:56:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-19T08:56:10Z"}, "message": "mips.c (gpr_mode): Delete.\n\ngcc/\n\t* config/mips/mips.c (gpr_mode): Delete.\n\t(mips16e_build_save_restore): Use word_mode and UNITS_PER_WORD\n\tinstead of gpr_mode.\n\t(mips_for_each_saved_reg): Likewise.\n\t(mips_expand_prologue, mips_expand_epilogue): Likewise.\n\t(override_options): Don't initialize gpr_mode.\n\t* config/mips/mips.md (eh_return): Use word_mode instead of gpr_mode.\n\nFrom-SVN: r129479", "tree": {"sha": "b45a122541cf8af602b1ab50daad4417e70d2207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b45a122541cf8af602b1ab50daad4417e70d2207"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e75e6e37480bfcefc3453cdaba40c17e01406e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e75e6e37480bfcefc3453cdaba40c17e01406e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e75e6e37480bfcefc3453cdaba40c17e01406e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e75e6e37480bfcefc3453cdaba40c17e01406e3/comments", "author": null, "committer": null, "parents": [{"sha": "c862c910f6a41f405005037e452fd72736383df7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c862c910f6a41f405005037e452fd72736383df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c862c910f6a41f405005037e452fd72736383df7"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "aa263181c1178cf33e22cddb0159659e5be01bae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e75e6e37480bfcefc3453cdaba40c17e01406e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e75e6e37480bfcefc3453cdaba40c17e01406e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e75e6e37480bfcefc3453cdaba40c17e01406e3", "patch": "@@ -1,3 +1,13 @@\n+2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.c (gpr_mode): Delete.\n+\t(mips16e_build_save_restore): Use word_mode and UNITS_PER_WORD\n+\tinstead of gpr_mode.\n+\t(mips_for_each_saved_reg): Likewise.\n+\t(mips_expand_prologue, mips_expand_epilogue): Likewise.\n+\t(override_options): Don't initialize gpr_mode.\n+\t* config/mips/mips.md (eh_return): Use word_mode instead of gpr_mode.\n+\n 2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.c (mips_hard_regno_nregs): Put the UNITS_PER_WORD"}, {"sha": "da6b8a9072f3f22894d8035d030bd33ffc409a04", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e75e6e37480bfcefc3453cdaba40c17e01406e3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e75e6e37480bfcefc3453cdaba40c17e01406e3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6e75e6e37480bfcefc3453cdaba40c17e01406e3", "patch": "@@ -468,9 +468,6 @@ enum mips_code_readable_setting mips_code_readable = CODE_READABLE_YES;\n /* If TRUE, we split addresses into their high and low parts in the RTL.  */\n int mips_split_addresses;\n \n-/* Mode used for saving/restoring general purpose registers.  */\n-static enum machine_mode gpr_mode;\n-\n /* Array giving truth value on whether or not a given hard register\n    can support a given mode.  */\n char mips_hard_regno_mode_ok[(int)MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n@@ -7472,7 +7469,7 @@ mips16e_build_save_restore (bool restore_p, unsigned int *mask_ptr,\n   /* Save the arguments.  */\n   for (i = 0; i < nargs; i++)\n     {\n-      offset = top_offset + i * GET_MODE_SIZE (gpr_mode);\n+      offset = top_offset + i * UNITS_PER_WORD;\n       set = mips16e_save_restore_reg (restore_p, offset, GP_ARG_FIRST + i);\n       XVECEXP (pattern, 0, n++) = set;\n     }\n@@ -7520,7 +7517,7 @@ mips16e_save_restore_pattern_p (rtx pattern, HOST_WIDE_INT adjust,\n   top_offset = adjust > 0 ? adjust : 0;\n \n   /* Interpret all other members of the PARALLEL.  */\n-  save_offset = top_offset - GET_MODE_SIZE (gpr_mode);\n+  save_offset = top_offset - UNITS_PER_WORD;\n   mask = 0;\n   nargs = 0;\n   i = 0;\n@@ -7549,7 +7546,7 @@ mips16e_save_restore_pattern_p (rtx pattern, HOST_WIDE_INT adjust,\n \treturn false;\n \n       /* Check for argument saves.  */\n-      if (offset == top_offset + nargs * GET_MODE_SIZE (gpr_mode)\n+      if (offset == top_offset + nargs * UNITS_PER_WORD\n \t  && REGNO (reg) == GP_ARG_FIRST + nargs)\n \tnargs++;\n       else if (offset == save_offset)\n@@ -7559,7 +7556,7 @@ mips16e_save_restore_pattern_p (rtx pattern, HOST_WIDE_INT adjust,\n \t      return false;\n \n \t  mask |= 1 << REGNO (reg);\n-\t  save_offset -= GET_MODE_SIZE (gpr_mode);\n+\t  save_offset -= UNITS_PER_WORD;\n \t}\n       else\n \treturn false;\n@@ -8160,8 +8157,8 @@ mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n   for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n     if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))\n       {\n-\tmips_save_restore_reg (gpr_mode, regno, offset, fn);\n-\toffset -= GET_MODE_SIZE (gpr_mode);\n+\tmips_save_restore_reg (word_mode, regno, offset, fn);\n+\toffset -= UNITS_PER_WORD;\n       }\n \n   /* This loop must iterate over the same space as its companion in\n@@ -8450,8 +8447,9 @@ mips_expand_prologue (void)\n  \t  for (regno = GP_REG_FIRST; regno < GP_REG_LAST; regno++)\n  \t    if (BITSET_P (mask, regno - GP_REG_FIRST))\n  \t      {\n-\t\toffset -= GET_MODE_SIZE (gpr_mode);\n-\t\tmips_save_restore_reg (gpr_mode, regno, offset, mips_save_reg);\n+\t\toffset -= UNITS_PER_WORD;\n+\t\tmips_save_restore_reg (word_mode, regno,\n+\t\t\t\t       offset, mips_save_reg);\n  \t      }\n  \t}\n       else\n@@ -8655,8 +8653,8 @@ mips_expand_epilogue (int sibcall_p)\n       for (regno = GP_REG_FIRST; regno < GP_REG_LAST; regno++)\n  \tif (BITSET_P (mask, regno - GP_REG_FIRST))\n  \t  {\n- \t    offset -= GET_MODE_SIZE (gpr_mode);\n- \t    mips_save_restore_reg (gpr_mode, regno, offset, mips_restore_reg);\n+ \t    offset -= UNITS_PER_WORD;\n+ \t    mips_save_restore_reg (word_mode, regno, offset, mips_restore_reg);\n  \t  }\n \n       /* Restore the remaining registers and deallocate the final bit\n@@ -12162,10 +12160,6 @@ override_options (void)\n       mips_hard_regno_mode_ok[(int)mode][regno]\n \t= mips_hard_regno_mode_ok_p (regno, mode);\n \n-  /* Save GPR registers in word_mode sized hunks.  word_mode hasn't been\n-     initialized yet, so we can't use that here.  */\n-  gpr_mode = TARGET_64BIT ? DImode : SImode;\n-\n   /* Function to allocate machine-dependent function status.  */\n   init_machine_status = &mips_init_machine_status;\n "}, {"sha": "77cd3ce583bc0ef272cc273a237c49e0479b2ff3", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e75e6e37480bfcefc3453cdaba40c17e01406e3/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e75e6e37480bfcefc3453cdaba40c17e01406e3/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6e75e6e37480bfcefc3453cdaba40c17e01406e3", "patch": "@@ -5548,10 +5548,8 @@\n   [(use (match_operand 0 \"general_operand\"))]\n   \"\"\n {\n-  enum machine_mode gpr_mode = TARGET_64BIT ? DImode : SImode;\n-\n-  if (GET_MODE (operands[0]) != gpr_mode)\n-    operands[0] = convert_to_mode (gpr_mode, operands[0], 0);\n+  if (GET_MODE (operands[0]) != word_mode)\n+    operands[0] = convert_to_mode (word_mode, operands[0], 0);\n   if (TARGET_64BIT)\n     emit_insn (gen_eh_set_lr_di (operands[0]));\n   else"}]}