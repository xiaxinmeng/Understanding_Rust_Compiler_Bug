{"sha": "6cb38cd4ae4e293f992f0593813c162803e533b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiMzhjZDRhZTRlMjkzZjk5MmYwNTkzODEzYzE2MjgwM2U1MzNiOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-10T10:44:48Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-10T10:44:48Z"}, "message": "c-common.c, [...]: Fix comment typos.\n\n\t* c-common.c, c-pch.c, defaults.h, lambda-code.c, passes.c,\n\ttree-data-ref.c, tree-flow.h, tree-ssa-operands.c,\n\ttree-ssa-threadupdate.c, tree-vectorizer.c, tree-vectorizer.h,\n\tvalue-prof.c: Fix comment typos.  Follow spelling conventions.\n\nFrom-SVN: r87288", "tree": {"sha": "e18647b48f7a6fbf0ceb4f1c9045c3e057e62d7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e18647b48f7a6fbf0ceb4f1c9045c3e057e62d7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cb38cd4ae4e293f992f0593813c162803e533b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb38cd4ae4e293f992f0593813c162803e533b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb38cd4ae4e293f992f0593813c162803e533b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb38cd4ae4e293f992f0593813c162803e533b9/comments", "author": null, "committer": null, "parents": [{"sha": "8166c2014f908bb47205709b34ab0bdca881b45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8166c2014f908bb47205709b34ab0bdca881b45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8166c2014f908bb47205709b34ab0bdca881b45a"}], "stats": {"total": 51, "additions": 29, "deletions": 22}, "files": [{"sha": "72d1e46fbaf2ccb835ce0547c38bf4a6352a43d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -1,3 +1,10 @@\n+2004-09-10  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-common.c, c-pch.c, defaults.h, lambda-code.c, passes.c,\n+\ttree-data-ref.c, tree-flow.h, tree-ssa-operands.c,\n+\ttree-ssa-threadupdate.c, tree-vectorizer.c, tree-vectorizer.h,\n+\tvalue-prof.c: Fix comment typos.  Follow spelling conventions.\n+\n 2004-09-10  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \t* unroll.c (unroll_loop, calculate_giv_inc, initial_reg_note_copy,"}, {"sha": "c0d276b35a93aa1cd5d64e5cb20a488743e9c23e", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -1448,7 +1448,7 @@ check_case_value (tree value)\n    bound of the case label, and CASE_HIGH_P is the upper bound or NULL\n    if the case is not a case range.\n    The caller has to make sure that we are not called with NULL for\n-   CASE_LOW_P (ie. the defualt case).\n+   CASE_LOW_P (ie. the default case).\n    Returns true if the case label is in range of ORIG_TYPE (satured or\n    untouched) or false if the label is out of range.  */\n "}, {"sha": "7371dbabe9294eba8892bfab1cff84f09c1a6894", "filename": "gcc/c-pch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -448,7 +448,7 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n   fclose (f);\n   \n   /* Give the front end a chance to take action after a PCH file has\n-     been loadeded.  */\n+     been loaded.  */\n   if (lang_post_pch_load)\n     (*lang_post_pch_load) ();\n }"}, {"sha": "013a74ca37e8f8fea7fc9cf877ce7daac3195e5a", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -632,7 +632,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) false\n #endif\n \n-/* True if the targets integer-comparision functions return { 0, 1, 2\n+/* True if the targets integer-comparison functions return { 0, 1, 2\n    } to indicate { <, ==, > }.  False if { -1, 0, 1 } is used\n    instead.  The libgcc routines are biased.  */\n #ifndef TARGET_LIB_INT_CMP_BIASED"}, {"sha": "325bb918827b0944a14d06d0df23a77cf0a68e22", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -47,7 +47,7 @@\n    math.\n  \n  A little terminology and a general sketch of the algorithm.  See \"A singular\n- loop transformatrion framework based on non-singular matrices\" by Wei Li and\n+ loop transformation framework based on non-singular matrices\" by Wei Li and\n  Keshav Pingali for formal proofs that the various statements below are\n  correct. \n \n@@ -74,20 +74,20 @@\n \n  For a dense source space, we take the transformation matrix, decompose it\n  into a lower triangular part (H) and a unimodular part (U). \n- We then compute the auxillary space from the unimodular part (source loop\n- nest . U = auxillary space) , which has two important properties:\n+ We then compute the auxiliary space from the unimodular part (source loop\n+ nest . U = auxiliary space) , which has two important properties:\n   1. It traverses the iterations in the same lexicographic order as the source\n   space.\n   2. It is a dense space when the source is a dense space (even if the target\n   space is going to be sparse).\n  \n- Given the auxillary space, we use the lower triangular part to compute the\n+ Given the auxiliary space, we use the lower triangular part to compute the\n  bounds in the target space by simple matrix multiplication.\n  The gaps in the target space (IE the new loop step sizes) will be the\n  diagonals of the H matrix.\n \n  Sparse source spaces require another step, because you can't directly compute\n- the exact bounds of the auxillary and target space from the sparse space.\n+ the exact bounds of the auxiliary and target space from the sparse space.\n  Rather than try to come up with a separate algorithm to handle sparse source\n  spaces directly, we just find a legal transformation matrix that gives you\n  the sparse source space, from a dense space, and then transform the dense\n@@ -749,7 +749,7 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n }\n \n /* Compute the loop bounds for the target space, using the bounds of\n-   the auxillary nest AUXILLARY_NEST, and the triangular matrix H.  This is\n+   the auxiliary nest AUXILLARY_NEST, and the triangular matrix H.  This is\n    done by matrix multiplication and then transformation of the new matrix\n    back into linear expression form.\n    Return the target loopnest.  */"}, {"sha": "93bfb914a1c8550d717932782f69b97acc82959b", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -1287,7 +1287,7 @@ rest_of_handle_jump (void)\n   timevar_push (TV_JUMP);\n   open_dump_file (DFI_sibling, current_function_decl);\n \n-  /* ??? We may get caled either via tree_rest_of_compilation when the CFG\n+  /* ??? We may get called either via tree_rest_of_compilation when the CFG\n      is already built or directly (for instance from coverage code).\n      The direct callers shall be updated.  */\n   if (!basic_block_info)"}, {"sha": "5ea9fecf4353bd6f439026f56edff309e0592dc0", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -146,7 +146,7 @@ array_base_name_differ_p (struct data_reference *a,\n   /* at this point we know that base_a != base_b. However, pointer accesses\n      of the form x=(*p) and y=(*q), which bases are p and q, may still by pointing\n      to the same base. In SSAed GIMPLE p and q will be SSA_NAMES in this case.\n-     Therefore, here we check if it's really two diferent declarations.  */\n+     Therefore, here we check if it's really two different declarations.  */\n   if (TREE_CODE (base_a) == VAR_DECL && TREE_CODE (base_b) == VAR_DECL)\n     {\n       *differ_p = true;\n@@ -525,7 +525,7 @@ analyze_array_indexes (struct loop *loop,\n     return opnd0;\n }\n \n-/* For a data reference REF contained in the statemet STMT, initialize\n+/* For a data reference REF contained in the statement STMT, initialize\n    a DATA_REFERENCE structure, and return it.  IS_READ flag has to be\n    set to true when REF is in the right hand side of an\n    assignment.  */\n@@ -558,7 +558,7 @@ analyze_array (tree stmt, tree ref, bool is_read)\n   return res;\n }\n \n-/* For a data reference REF contained in the statemet STMT, initialize\n+/* For a data reference REF contained in the statement STMT, initialize\n    a DATA_REFERENCE structure, and return it.  */\n \n struct data_reference *"}, {"sha": "0c3807885a659ecc453e96366078d16e7fea5e6c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -601,7 +601,7 @@ extern bool may_propagate_copy (tree, tree);\n \n struct tree_niter_desc\n {\n-  tree assumptions;\t/* The boolean expression.  If this expression evalutes\n+  tree assumptions;\t/* The boolean expression.  If this expression evaluates\n \t\t\t   to false, then the other fields in this structure\n \t\t\t   should not be used; there is no guarantee that they\n \t\t\t   will be correct.  */"}, {"sha": "9bac2925cc7f018b8625874886fe6fb75dfd56f3", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -34,9 +34,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"timevar.h\"\n \n \n-/* This file contains the code required to mnage the operands cache of the \n+/* This file contains the code required to manage the operands cache of the \n    SSA optimizer.  For every stmt, we maintain an operand cache in the stmt \n-   annotation.  This cache contains operands that will be of interets to \n+   annotation.  This cache contains operands that will be of interest to \n    optimizers and other passes wishing to manipulate the IL. \n \n    The operand type are broken up into REAL and VIRTUAL operands.  The real \n@@ -795,7 +795,7 @@ append_v_must_def (tree var)\n    will be destroyed.  It is appropriate to call free_stmt_operands() on \n    the value returned in old_ops.\n \n-   The rationale for this: Certain optimizations wish to exmaine the difference\n+   The rationale for this: Certain optimizations wish to examine the difference\n    between new_ops and old_ops after processing.  If a set of operands don't\n    change, new_ops will simply assume the pointer in old_ops, and the old_ops\n    pointer will be set to NULL, indicating no memory needs to be cleared.  \n@@ -1187,7 +1187,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n }\n \n \n-/* Scan operands in the ASM_EXPR stmt refered to in INFO.  */\n+/* Scan operands in the ASM_EXPR stmt referred to in INFO.  */\n \n static void\n get_asm_expr_operands (tree stmt)"}, {"sha": "c07bad2b186a1b2f04dd7985402f83281fba9845", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -204,7 +204,7 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n    and may expose new optimization opportunities.  Note that we have\n    to update dominator tree and SSA graph after such changes.\n \n-   The key to keeping the SSA graph update managable is to duplicate\n+   The key to keeping the SSA graph update manageable is to duplicate\n    the side effects occurring in BB so that those side effects still\n    occur on the paths which bypass BB after redirecting edges.\n "}, {"sha": "54d5d1abefe63957adfaf8f89d5d4b376c9ddecf", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -1525,7 +1525,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \n    Returns whether a stmt with OPERAND can be vectorized.\n    Supportable operands are constants, loop invariants, and operands that are\n-   defined by the current iteration of the loop. Unsupportable opernads are \n+   defined by the current iteration of the loop. Unsupportable operands are \n    those that are defined by a previous iteration of the loop (as is the case\n    in reduction/induction computations).  */\n "}, {"sha": "eb8a5868a77c30667f74867e0af664250f195829", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -52,7 +52,7 @@ typedef struct _stmt_vec_info {\n   /* The stmt to which this info struct refers to.  */\n   tree stmt;\n \n-  /* The loop with resprct to which STMT is vectorized.  */\n+  /* The loop with respect to which STMT is vectorized.  */\n   struct loop *loop;\n \n   /* Not all stmts in the loop need to be vectorized. e.g, the incrementation"}, {"sha": "6c6eed88daee11c01e51dd6ab1dff0d5a374cfe9", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb38cd4ae4e293f992f0593813c162803e533b9/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=6cb38cd4ae4e293f992f0593813c162803e533b9", "patch": "@@ -41,7 +41,7 @@ static struct value_prof_hooks *value_prof_hooks;\n    following optimizations are implemented (for more detailed descriptions\n    see comments at value_profile_transformations):\n \n-   1) Division/modulo specialisation.  Provided that we can determine that the\n+   1) Division/modulo specialization.  Provided that we can determine that the\n       operands of the division have some special properties, we may use it to\n       produce more effective code.\n    2) Speculative prefetching.  If we are able to determine that the difference"}]}