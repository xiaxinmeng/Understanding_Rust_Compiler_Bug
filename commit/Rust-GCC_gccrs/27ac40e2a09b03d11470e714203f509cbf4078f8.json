{"sha": "27ac40e2a09b03d11470e714203f509cbf4078f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdhYzQwZTJhMDliMDNkMTE0NzBlNzE0MjAzZjUwOWNiZjQwNzhmOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2007-04-13T08:14:57Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-04-13T08:14:57Z"}, "message": "i386.h (X87_FLOAT_MODE_P): Check for TARGET_80387.\n\n        * config/i386/i386.h (X87_FLOAT_MODE_P): Check for TARGET_80387.\n        * config/i386/i386.md (*cmpfp0): Remove check for TARGET_80387, this\n        check is now implied in X87_FLOAT_MODE_P.\n        (*cmpfp_u, *cmpfp_<mode>, *cmpfp_i_i387): Ditto.\n        (*cmpfp_iu_387, fix_trunc<mode>_fisttp_i386_1): Ditto.\n        (fix_trunc<mode>_i386_fisttp): Ditto.\n        (fix_trunc<mode>_i387_fisttp_with_temp): Ditto.\n        (*fix_trunc<mode>_i387_1, fix_truncdi_i387): Ditto.\n        (fix_truncdi_i387_with_temp, fix_trunc<mode>_i387): Ditto.\n        (fix_trunc<mode>_i387_with_temp, *fp_jcc_1_387): Ditto.\n        (*fp_jcc_2_387, *fp_jcc_5_387, *fp_jcc_6_387): Ditto.\n        (*fp_jcc_7_387, *fp_jcc_8<mode>_387): Ditto.\n        (unnamed_splitters): Ditto.\n        * config/i386/i386.c (function_value_32): Generate FIRST_FLOAT_REG\n        for X87_FLOAT_MODE_P mode.  Override FIRST_FLOAT_REG with\n        FIRST_SSE_REG for local functions when SSE math is enabled or\n        for functions with sseregparm attribute.\n        (standard_80387_constant_p): Return -1 if mode is not\n        X87_FLOAT_MODE_P.\n        (ix86_cc_mode): Assert that scalar mode is not DECIMAL_FLOAT_MODE_P.\n        (ix86_expand_compare): Ditto.\n        (ix86_expand_carry_flag_compare): Ditto.\n        (ix86_expand_int_movcc): Check for SCALAR_FLOAT_MODE_P instead\n        of FLOAT_MODE_P for cmp_mode and assert that cmp_mode is not\n        DECIMAL_FLOAT_MODE_P.\n        (ix86_preferred_output_reload_class): Use X87_FLOAT_MODE_P instead\n        of SCALAR_FLOAT_MODE_P.\n        (ix86_rtx_costs) [PLUS] Remove FLOAT_MODE_P and fall through to ...\n        [MINUS]: ... here.  Add SSE_FLOAT_MODE_P and X87_FLOAT_MODE_P\n        checks before FLOAT_MODE_P.\n        [MULT]: Add SSE_FLOAT_MODE_P and X87_FLOAT_MODE_P checks\n        before FLOAT_MODE_P.\n        [DIV]: Ditto.\n        [NEG]: Ditto.\n        [ABS]: Ditto.\n        [SQRT]: Ditto.\n        [FLOAT_EXTEND]: Use SSE_FLOAT_MODE_P.\n\nFrom-SVN: r123777", "tree": {"sha": "18b3bb6ec862f00cb47793e50a40b3be0c988c38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18b3bb6ec862f00cb47793e50a40b3be0c988c38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27ac40e2a09b03d11470e714203f509cbf4078f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ac40e2a09b03d11470e714203f509cbf4078f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ac40e2a09b03d11470e714203f509cbf4078f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ac40e2a09b03d11470e714203f509cbf4078f8/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd61d70827f28ddaf915542e2aa79bd539004402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd61d70827f28ddaf915542e2aa79bd539004402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd61d70827f28ddaf915542e2aa79bd539004402"}], "stats": {"total": 291, "additions": 197, "deletions": 94}, "files": [{"sha": "fb9a7338faada0c17c2519fa6be5a316ec8298ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27ac40e2a09b03d11470e714203f509cbf4078f8", "patch": "@@ -1,3 +1,43 @@\n+2007-04-13  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (X87_FLOAT_MODE_P): Check for TARGET_80387.\n+\t* config/i386/i386.md (*cmpfp0): Remove check for TARGET_80387, this\n+\tcheck is now implied in X87_FLOAT_MODE_P.\n+\t(*cmpfp_u, *cmpfp_<mode>, *cmpfp_i_i387): Ditto.\n+\t(*cmpfp_iu_387, fix_trunc<mode>_fisttp_i386_1): Ditto.\n+\t(fix_trunc<mode>_i386_fisttp): Ditto.\n+\t(fix_trunc<mode>_i387_fisttp_with_temp): Ditto.\n+\t(*fix_trunc<mode>_i387_1, fix_truncdi_i387): Ditto.\n+\t(fix_truncdi_i387_with_temp, fix_trunc<mode>_i387): Ditto.\n+\t(fix_trunc<mode>_i387_with_temp, *fp_jcc_1_387): Ditto.\n+\t(*fp_jcc_2_387, *fp_jcc_5_387, *fp_jcc_6_387): Ditto.\n+\t(*fp_jcc_7_387, *fp_jcc_8<mode>_387): Ditto.\n+\t(unnamed_splitters): Ditto.\n+\t* config/i386/i386.c (function_value_32): Generate FIRST_FLOAT_REG\n+\tfor X87_FLOAT_MODE_P mode.  Override FIRST_FLOAT_REG with\n+\tFIRST_SSE_REG for local functions when SSE math is enabled or\n+\tfor functions with sseregparm attribute.\n+\t(standard_80387_constant_p): Return -1 if mode is not\n+\tX87_FLOAT_MODE_P.\n+\t(ix86_cc_mode): Assert that scalar mode is not DECIMAL_FLOAT_MODE_P.\n+\t(ix86_expand_compare): Ditto.\n+\t(ix86_expand_carry_flag_compare): Ditto.\n+\t(ix86_expand_int_movcc): Check for SCALAR_FLOAT_MODE_P instead\n+\tof FLOAT_MODE_P for cmp_mode and assert that cmp_mode is not\n+\tDECIMAL_FLOAT_MODE_P.\n+\t(ix86_preferred_output_reload_class): Use X87_FLOAT_MODE_P instead\n+\tof SCALAR_FLOAT_MODE_P.\n+\t(ix86_rtx_costs) [PLUS] Remove FLOAT_MODE_P and fall through to ...\n+\t[MINUS]: ... here.  Add SSE_FLOAT_MODE_P and X87_FLOAT_MODE_P\n+\tchecks before FLOAT_MODE_P.\n+\t[MULT]: Add SSE_FLOAT_MODE_P and X87_FLOAT_MODE_P checks\n+\tbefore FLOAT_MODE_P.\n+\t[DIV]: Ditto.\n+\t[NEG]: Ditto.\n+\t[ABS]: Ditto.\n+\t[SQRT]: Ditto.\n+\t[FLOAT_EXTEND]: Use SSE_FLOAT_MODE_P.\n+\n 2007-04-12  Paolo Bonzini  <bonzini@gnu.org>\n             Charles Wilson  <libtool@cwilson.fastmail.fm>\n "}, {"sha": "a964b6a005358b380841f73067b864214a02b61e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 121, "deletions": 50, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=27ac40e2a09b03d11470e714203f509cbf4078f8", "patch": "@@ -4181,27 +4181,21 @@ function_value_32 (enum machine_mode orig_mode, enum machine_mode mode,\n \t   || (VECTOR_MODE_P (mode) && GET_MODE_SIZE (mode) == 16))\n     regno = TARGET_SSE ? FIRST_SSE_REG : 0;\n \n-  /* Decimal floating point values can go in %eax, unlike other float modes.  */\n-  else if (DECIMAL_FLOAT_MODE_P (mode))\n-    regno = 0;\n-\n-  /* Most things go in %eax, except (unless -mno-fp-ret-in-387) fp values.  */\n-  else if (!SCALAR_FLOAT_MODE_P (mode) || !TARGET_FLOAT_RETURNS_IN_80387)\n+  /* Floating point return values in %st(0) (unless -mno-fp-ret-in-387).  */\n+  else if (X87_FLOAT_MODE_P (mode) && TARGET_FLOAT_RETURNS_IN_80387)\n+    regno = FIRST_FLOAT_REG;\n+  else\n+    /* Most things go in %eax.  */\n     regno = 0;\n-\n-  /* Floating point return values in %st(0), except for local functions when\n+  \n+  /* Override FP return register with %xmm0 for local functions when\n      SSE math is enabled or for functions with sseregparm attribute.  */\n-  else\n+  if ((fn || fntype) && (mode == SFmode || mode == DFmode))\n     {\n-      regno = FIRST_FLOAT_REG;\n-\n-      if ((fn || fntype) && (mode == SFmode || mode == DFmode))\n-\t{\n-\t  int sse_level = ix86_function_sseregparm (fntype, fn);\n-\t  if ((sse_level >= 1 && mode == SFmode)\n-\t      || (sse_level == 2 && mode == DFmode))\n-\t    regno = FIRST_SSE_REG;\n-\t}\n+      int sse_level = ix86_function_sseregparm (fntype, fn);\n+      if ((sse_level >= 1 && mode == SFmode)\n+\t  || (sse_level == 2 && mode == DFmode))\n+\tregno = FIRST_SSE_REG;\n     }\n \n   return gen_rtx_REG (orig_mode, regno);\n@@ -4976,21 +4970,23 @@ init_ext_80387_constants (void)\n int\n standard_80387_constant_p (rtx x)\n {\n+  enum machine_mode mode = GET_MODE (x);\n+\n   REAL_VALUE_TYPE r;\n \n-  if (GET_CODE (x) != CONST_DOUBLE || !FLOAT_MODE_P (GET_MODE (x)))\n+  if (!(X87_FLOAT_MODE_P (mode) && (GET_CODE (x) == CONST_DOUBLE)))\n     return -1;\n \n-  if (x == CONST0_RTX (GET_MODE (x)))\n+  if (x == CONST0_RTX (mode))\n     return 1;\n-  if (x == CONST1_RTX (GET_MODE (x)))\n+  if (x == CONST1_RTX (mode))\n     return 2;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n \n   /* For XFmode constants, try to find a special 80387 instruction when\n      optimizing for size or on those CPUs that benefit from them.  */\n-  if (GET_MODE (x) == XFmode\n+  if (mode == XFmode\n       && (optimize_size || TARGET_EXT_80387_CONSTANTS))\n     {\n       int i;\n@@ -10683,8 +10679,14 @@ ix86_fp_compare_mode (enum rtx_code code ATTRIBUTE_UNUSED)\n enum machine_mode\n ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n {\n-  if (SCALAR_FLOAT_MODE_P (GET_MODE (op0)))\n-    return ix86_fp_compare_mode (code);\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (SCALAR_FLOAT_MODE_P (mode))\n+    {\n+      gcc_assert (!DECIMAL_FLOAT_MODE_P (mode));\n+      return ix86_fp_compare_mode (code);\n+    }\n+\n   switch (code)\n     {\n       /* Only zero flag is needed.  */\n@@ -11269,8 +11271,11 @@ ix86_expand_compare (enum rtx_code code, rtx *second_test, rtx *bypass_test)\n       ix86_compare_emitted = NULL_RTX;\n     }\n   else if (SCALAR_FLOAT_MODE_P (GET_MODE (op0)))\n-    ret = ix86_expand_fp_compare (code, op0, op1, NULL_RTX,\n-\t\t\t\t  second_test, bypass_test);\n+    {\n+      gcc_assert (!DECIMAL_FLOAT_MODE_P (GET_MODE (op0)));\n+      ret = ix86_expand_fp_compare (code, op0, op1, NULL_RTX,\n+\t\t\t\t    second_test, bypass_test);\n+    }\n   else\n     ret = ix86_expand_int_compare (code, op0, op1);\n \n@@ -11631,16 +11636,20 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n   enum machine_mode mode =\n     GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n \n-  /* Do not handle DImode compares that go through special path.  Also we can't\n-     deal with FP compares yet.  This is possible to add.  */\n+  /* Do not handle DImode compares that go through special path.\n+     Also we can't deal with FP compares yet.  This is possible to add.  */\n   if (mode == (TARGET_64BIT ? TImode : DImode))\n     return false;\n-  if (FLOAT_MODE_P (mode))\n+\n+  if (SCALAR_FLOAT_MODE_P (mode))\n     {\n       rtx second_test = NULL, bypass_test = NULL;\n       rtx compare_op, compare_seq;\n \n-      /* Shortcut:  following common codes never translate into carry flag compares.  */\n+      gcc_assert (!DECIMAL_FLOAT_MODE_P (mode));\n+\n+      /* Shortcut:  following common codes never translate\n+\t into carry flag compares.  */\n       if (code == EQ || code == NE || code == UNEQ || code == LTGT\n \t  || code == ORDERED || code == UNORDERED)\n \treturn false;\n@@ -11929,11 +11938,16 @@ ix86_expand_int_movcc (rtx operands[])\n \n       if (diff < 0)\n \t{\n+\t  enum machine_mode cmp_mode = GET_MODE (ix86_compare_op0);\n+\n \t  HOST_WIDE_INT tmp;\n \t  tmp = ct, ct = cf, cf = tmp;\n \t  diff = -diff;\n-\t  if (FLOAT_MODE_P (GET_MODE (ix86_compare_op0)))\n+\n+\t  if (SCALAR_FLOAT_MODE_P (cmp_mode))\n \t    {\n+\t      gcc_assert (!DECIMAL_FLOAT_MODE_P (cmp_mode));\n+\n \t      /* We may be reversing unordered compare to normal compare, that\n \t\t is not valid in general (we may convert non-trapping condition\n \t\t to trapping one), however on i386 we currently emit all\n@@ -12082,14 +12096,21 @@ ix86_expand_int_movcc (rtx operands[])\n \t{\n \t  if (cf == 0)\n \t    {\n+\t      enum machine_mode cmp_mode = GET_MODE (ix86_compare_op0);\n+\n \t      cf = ct;\n \t      ct = 0;\n-\t      if (FLOAT_MODE_P (GET_MODE (ix86_compare_op0)))\n-\t\t/* We may be reversing unordered compare to normal compare,\n-\t\t   that is not valid in general (we may convert non-trapping\n-\t\t   condition to trapping one), however on i386 we currently\n-\t\t   emit all comparisons unordered.  */\n-\t\tcode = reverse_condition_maybe_unordered (code);\n+\n+\t      if (SCALAR_FLOAT_MODE_P (cmp_mode))\n+\t\t{\n+\t\t  gcc_assert (!DECIMAL_FLOAT_MODE_P (cmp_mode));\n+\n+\t\t  /* We may be reversing unordered compare to normal compare,\n+\t\t     that is not valid in general (we may convert non-trapping\n+\t\t     condition to trapping one), however on i386 we currently\n+\t\t     emit all comparisons unordered.  */\n+\t\t  code = reverse_condition_maybe_unordered (code);\n+\t\t}\n \t      else\n \t\t{\n \t\t  code = reverse_condition (code);\n@@ -18863,7 +18884,7 @@ ix86_preferred_output_reload_class (rtx x, enum reg_class class)\n   if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n     return MAYBE_SSE_CLASS_P (class) ? SSE_REGS : NO_REGS;\n \n-  if (TARGET_80387 && SCALAR_FLOAT_MODE_P (mode))\n+  if (X87_FLOAT_MODE_P (mode))\n     {\n       if (class == FP_TOP_SSE_REGS)\n \treturn FP_TOP_REG;\n@@ -19348,8 +19369,20 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case MULT:\n-      if (FLOAT_MODE_P (mode))\n+      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t{\n+\t  /* ??? SSE scalar cost should be used here.  */\n+\t  *total = ix86_cost->fmul;\n+\t  return false;\n+\t}\n+      else if (X87_FLOAT_MODE_P (mode))\n+\t{\n+\t  *total = ix86_cost->fmul;\n+\t  return false;\n+\t}\n+      else if (FLOAT_MODE_P (mode))\n \t{\n+\t  /* ??? SSE vector cost should be used here.  */\n \t  *total = ix86_cost->fmul;\n \t  return false;\n \t}\n@@ -19402,16 +19435,20 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case UDIV:\n     case MOD:\n     case UMOD:\n-      if (FLOAT_MODE_P (mode))\n+      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t/* ??? SSE cost should be used here.  */\n+\t*total = ix86_cost->fdiv;\n+      else if (X87_FLOAT_MODE_P (mode))\n+\t*total = ix86_cost->fdiv;\n+      else if (FLOAT_MODE_P (mode))\n+\t/* ??? SSE vector cost should be used here.  */\n \t*total = ix86_cost->fdiv;\n       else\n \t*total = ix86_cost->divide[MODE_INDEX (mode)];\n       return false;\n \n     case PLUS:\n-      if (FLOAT_MODE_P (mode))\n-\t*total = ix86_cost->fadd;\n-      else if (GET_MODE_CLASS (mode) == MODE_INT\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n \t       && GET_MODE_BITSIZE (mode) <= GET_MODE_BITSIZE (Pmode))\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PLUS\n@@ -19454,11 +19491,23 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n       /* FALLTHRU */\n \n     case MINUS:\n-      if (FLOAT_MODE_P (mode))\n+      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t{\n+\t  /* ??? SSE cost should be used here.  */\n+\t  *total = ix86_cost->fadd;\n+\t  return false;\n+\t}\n+      else if (X87_FLOAT_MODE_P (mode))\n \t{\n \t  *total = ix86_cost->fadd;\n \t  return false;\n \t}\n+      else if (FLOAT_MODE_P (mode))\n+\t{\n+\t  /* ??? SSE vector cost should be used here.  */\n+\t  *total = ix86_cost->fadd;\n+\t  return false;\n+\t}\n       /* FALLTHRU */\n \n     case AND:\n@@ -19476,8 +19525,20 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n       /* FALLTHRU */\n \n     case NEG:\n-      if (FLOAT_MODE_P (mode))\n+      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t{\n+\t  /* ??? SSE cost should be used here.  */\n+\t  *total = ix86_cost->fchs;\n+\t  return false;\n+\t}\n+      else if (X87_FLOAT_MODE_P (mode))\n+\t{\n+\t  *total = ix86_cost->fchs;\n+\t  return false;\n+\t}\n+      else if (FLOAT_MODE_P (mode))\n \t{\n+\t  /* ??? SSE vector cost should be used here.  */\n \t  *total = ix86_cost->fchs;\n \t  return false;\n \t}\n@@ -19506,19 +19567,29 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case FLOAT_EXTEND:\n-      if (!TARGET_SSE_MATH\n-\t  || mode == XFmode\n-\t  || (mode == DFmode && !TARGET_SSE2))\n+      if (!(SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH))\n \t*total = 0;\n       return false;\n \n     case ABS:\n-      if (FLOAT_MODE_P (mode))\n+      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t/* ??? SSE cost should be used here.  */\n+\t*total = ix86_cost->fabs;\n+      else if (X87_FLOAT_MODE_P (mode))\n+\t*total = ix86_cost->fabs;\n+      else if (FLOAT_MODE_P (mode))\n+\t/* ??? SSE vector cost should be used here.  */\n \t*total = ix86_cost->fabs;\n       return false;\n \n     case SQRT:\n-      if (FLOAT_MODE_P (mode))\n+      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t/* ??? SSE cost should be used here.  */\n+\t*total = ix86_cost->fsqrt;\n+      else if (X87_FLOAT_MODE_P (mode))\n+\t*total = ix86_cost->fsqrt;\n+      else if (FLOAT_MODE_P (mode))\n+\t/* ??? SSE vector cost should be used here.  */\n \t*total = ix86_cost->fsqrt;\n       return false;\n "}, {"sha": "0ed9c1245c1a9be404e842e172edb60703ab8dbc", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=27ac40e2a09b03d11470e714203f509cbf4078f8", "patch": "@@ -1363,9 +1363,7 @@ enum reg_class\n #define ANY_FP_REGNO_P(N) (FP_REGNO_P (N) || SSE_REGNO_P (N))\n \n #define X87_FLOAT_MODE_P(MODE)\t\\\n-  ((MODE) == SFmode\t\t\\\n-   || (MODE) == DFmode\t\t\\\n-   || (MODE) == XFmode)\n+  (TARGET_80387 && ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode))\n \n #define SSE_REG_P(N) (REG_P (N) && SSE_REGNO_P (REGNO (N)))\n #define SSE_REGNO_P(N)\t\t\t\t\t\t\\"}, {"sha": "b306e05ef217cf2a1589efa5553bcaafa584e213", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac40e2a09b03d11470e714203f509cbf4078f8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=27ac40e2a09b03d11470e714203f509cbf4078f8", "patch": "@@ -866,8 +866,7 @@\n \t     (match_operand 1 \"register_operand\" \"f\")\n \t     (match_operand 2 \"const0_operand\" \"X\"))]\n \tUNSPEC_FNSTSW))]\n-  \"TARGET_80387\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n   \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"multi\")\n@@ -913,8 +912,7 @@\n \t     (match_operand 1 \"register_operand\" \"f\")\n \t     (match_operand 2 \"register_operand\" \"f\"))]\n \t  UNSPEC_FNSTSW))]\n-  \"TARGET_80387\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n   \"* return output_fp_compare (insn, operands, 0, 1);\"\n   [(set_attr \"type\" \"multi\")\n@@ -935,8 +933,8 @@\n \t     (match_operator 3 \"float_operator\"\n \t       [(match_operand:X87MODEI12 2 \"memory_operand\" \"m\")]))]\n \t  UNSPEC_FNSTSW))]\n-  \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && TARGET_USE_<MODE>MODE_FIOP\n    && (GET_MODE (operands [3]) == GET_MODE (operands[1]))\"\n   \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"multi\")\n@@ -1014,9 +1012,9 @@\n   [(set (reg:CCFP FLAGS_REG)\n \t(compare:CCFP (match_operand 0 \"register_operand\" \"f\")\n \t\t      (match_operand 1 \"register_operand\" \"f\")))]\n-  \"TARGET_80387 && TARGET_CMOVE\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && TARGET_CMOVE\n    && (!TARGET_SSE_MATH || !SSE_FLOAT_MODE_P (GET_MODE (operands[0])))\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 0);\"\n   [(set_attr \"type\" \"fcmp\")\n@@ -1066,9 +1064,9 @@\n   [(set (reg:CCFPU FLAGS_REG)\n \t(compare:CCFPU (match_operand 0 \"register_operand\" \"f\")\n \t\t       (match_operand 1 \"register_operand\" \"f\")))]\n-  \"TARGET_80387 && TARGET_CMOVE\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && TARGET_CMOVE\n    && (!TARGET_SSE_MATH || !SSE_FLOAT_MODE_P (GET_MODE (operands[0])))\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 1);\"\n   [(set_attr \"type\" \"fcmp\")\n@@ -4237,8 +4235,8 @@\n (define_insn_and_split \"fix_trunc<mode>_fisttp_i387_1\"\n   [(set (match_operand:X87MODEI 0 \"nonimmediate_operand\" \"=m,?r\")\n \t(fix:X87MODEI (match_operand 1 \"register_operand\" \"f,f\")))]\n-  \"TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && TARGET_FISTTP\n    && !((SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n \t && (TARGET_64BIT || <MODE>mode != DImode))\n \t&& TARGET_SSE_MATH)\n@@ -4265,8 +4263,8 @@\n   [(set (match_operand:X87MODEI 0 \"memory_operand\" \"=m\")\n \t(fix:X87MODEI (match_operand 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:XF 2 \"=&1f\"))]\n-  \"TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && TARGET_FISTTP\n    && !((SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n \t && (TARGET_64BIT || <MODE>mode != DImode))\n \t&& TARGET_SSE_MATH)\"\n@@ -4279,8 +4277,8 @@\n \t(fix:X87MODEI (match_operand 1 \"register_operand\" \"f,f\")))\n    (clobber (match_operand:X87MODEI 2 \"memory_operand\" \"=m,m\"))\n    (clobber (match_scratch:XF 3 \"=&1f,&1f\"))]\n-  \"TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && TARGET_FISTTP\n    && !((SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n \t&& (TARGET_64BIT || <MODE>mode != DImode))\n \t&& TARGET_SSE_MATH)\"\n@@ -4318,8 +4316,8 @@\n   [(set (match_operand:X87MODEI 0 \"nonimmediate_operand\" \"=m,?r\")\n \t(fix:X87MODEI (match_operand 1 \"register_operand\" \"f,f\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && !TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !TARGET_FISTTP\n    && !(SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n \t && (TARGET_64BIT || <MODE>mode != DImode))\n    && !(reload_completed || reload_in_progress)\"\n@@ -4353,8 +4351,8 @@\n    (use (match_operand:HI 2 \"memory_operand\" \"m\"))\n    (use (match_operand:HI 3 \"memory_operand\" \"m\"))\n    (clobber (match_scratch:XF 4 \"=&1f\"))]\n-  \"TARGET_80387 && !TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !TARGET_FISTTP\n    && !(TARGET_64BIT && SSE_FLOAT_MODE_P (GET_MODE (operands[1])))\"\n   \"* return output_fix_trunc (insn, operands, 0);\"\n   [(set_attr \"type\" \"fistp\")\n@@ -4368,8 +4366,8 @@\n    (use (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n    (clobber (match_operand:DI 4 \"memory_operand\" \"=m,m\"))\n    (clobber (match_scratch:XF 5 \"=&1f,&1f\"))]\n-  \"TARGET_80387 && !TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !TARGET_FISTTP\n    && !(TARGET_64BIT && SSE_FLOAT_MODE_P (GET_MODE (operands[1])))\"\n   \"#\"\n   [(set_attr \"type\" \"fistp\")\n@@ -4410,8 +4408,8 @@\n \t(fix:X87MODEI12 (match_operand 1 \"register_operand\" \"f\")))\n    (use (match_operand:HI 2 \"memory_operand\" \"m\"))\n    (use (match_operand:HI 3 \"memory_operand\" \"m\"))]\n-  \"TARGET_80387 && !TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !TARGET_FISTTP\n    && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n   \"* return output_fix_trunc (insn, operands, 0);\"\n   [(set_attr \"type\" \"fistp\")\n@@ -4424,8 +4422,8 @@\n    (use (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n    (use (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n    (clobber (match_operand:X87MODEI12 4 \"memory_operand\" \"=m,m\"))]\n-  \"TARGET_80387 && !TARGET_FISTTP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !TARGET_FISTTP\n    && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n   \"#\"\n   [(set_attr \"type\" \"fistp\")\n@@ -4686,7 +4684,6 @@\n   [(set (match_operand 0 \"fp_register_operand\" \"\")\n \t(float (match_operand 1 \"register_operand\" \"\")))]\n   \"reload_completed\n-   && TARGET_80387\n    && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\"\n   [(const_int 0)]\n {\n@@ -13730,8 +13727,8 @@\n \t  (pc)))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_CMOVE && TARGET_80387\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && TARGET_CMOVE\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n@@ -13775,8 +13772,8 @@\n \t  (label_ref (match_operand 3 \"\" \"\"))))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_CMOVE && TARGET_80387\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && TARGET_CMOVE\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n@@ -13829,8 +13826,7 @@\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))\n    (clobber (match_scratch:HI 4 \"=a\"))]\n-  \"TARGET_80387\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n@@ -13845,8 +13841,7 @@\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))\n    (clobber (match_scratch:HI 4 \"=a\"))]\n-  \"TARGET_80387\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n@@ -13861,8 +13856,7 @@\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))\n    (clobber (match_scratch:HI 4 \"=a\"))]\n-  \"TARGET_80387\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n    && SELECT_CC_MODE (GET_CODE (operands[0]),\n@@ -13886,8 +13880,8 @@\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))\n    (clobber (match_scratch:HI 5 \"=a,a\"))]\n-  \"TARGET_80387 && TARGET_USE_<MODE>MODE_FIOP\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[3]))\n+  \"X87_FLOAT_MODE_P (GET_MODE (operands[3]))\n+   && TARGET_USE_<MODE>MODE_FIOP\n    && GET_MODE (operands[1]) == GET_MODE (operands[3])\n    && !ix86_use_fcomi_compare (swap_condition (GET_CODE (operands[0])))\n    && ix86_fp_compare_mode (swap_condition (GET_CODE (operands[0]))) == CCFPmode\n@@ -15873,7 +15867,7 @@\n \t(match_operator 3 \"binary_fp_operator\"\n \t   [(float (match_operand:X87MODEI12 1 \"register_operand\" \"\"))\n \t    (match_operand 2 \"register_operand\" \"\")]))]\n-  \"TARGET_80387 && reload_completed\n+  \"reload_completed\n    && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\"\n   [(const_int 0)]\n {\n@@ -15893,7 +15887,7 @@\n \t(match_operator 3 \"binary_fp_operator\"\n \t   [(match_operand 1 \"register_operand\" \"\")\n \t    (float (match_operand:X87MODEI12 2 \"register_operand\" \"\"))]))]\n-  \"TARGET_80387 && reload_completed\n+  \"reload_completed\n    && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\"\n   [(const_int 0)]\n {"}]}