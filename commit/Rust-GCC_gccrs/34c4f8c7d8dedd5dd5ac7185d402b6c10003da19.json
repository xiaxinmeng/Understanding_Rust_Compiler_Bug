{"sha": "34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRjNGY4YzdkOGRlZGQ1ZGQ1YWM3MTg1ZDQwMmI2YzEwMDAzZGExOQ==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-10-02T18:38:29Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-10-02T18:38:29Z"}, "message": "re PR treelang/17762 (treelang doesn't use mapped locations)\n\n2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n\n        PR other/17762\n        * lex.l: Include input.h and errors.h\n        (lineno): New variable.\n        (LINEMAP_POSITION_FOR_COLUMN): Define as noop when USE_MAPPED_LOCATION\n        is not defined.\n        Set column position with LINEMAP_POSITION_FOR_COLUMN.\n        Use error instead of fprintf.\n        Set input_location with the value returned by linemap_start_line when\n        USE_MAPPED_LOCATION is defined.\n        (dump_lex_value): Use LOCATION_LINE.\n        * parse.y: Include errors.h.\n        Use error and warning instead of fprintf.\n        (return): Move exp to rule scope and always set to $2.  Test against\n        exp instead of $2.\n        (init): Set $$ to $2.\n        (print_token): Use LOCATION_LINE.\n        * tree1.c (treelang_init): Call treelang_init_decl_processing last.\n        Call linemap_add to set input_filename when USE_MAPPED_LOCATION is\n        defined.\n        (treelang_parse_file): Always start at line one.\n        Rename input_filename to main_input_filename when USE_MAPPED_LOCATION is\n        defined.\n        Leave main_input_filename when done parsing the input.\n        (insert_tree_name): Use error instead of fprintf.\n        * treetree.c (tree_code_get_expression): Wrap long line.\n        (tree_mark_addressable): Use %qD to print out DECLs.\n\n2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n\n        * compile/autofunc.tree: New File.\n        * compile/badchar.tree: New File.\n        * compile/externvar.tree: New File.\n        * compile/mismatch.tree: New File.\n        * compile/noproto.tree: New File.\n        * compile/novar.tree: New File.\n        * compile/var_defs.tree: Add duplicate variable.\n\nFrom-SVN: r88430", "tree": {"sha": "4295da4da797ffaedddce69661349e32567f4598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4295da4da797ffaedddce69661349e32567f4598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/comments", "author": null, "committer": null, "parents": [{"sha": "039784fa0d28b1d5f816cdf66d9567208f6546f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039784fa0d28b1d5f816cdf66d9567208f6546f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039784fa0d28b1d5f816cdf66d9567208f6546f1"}], "stats": {"total": 297, "additions": 184, "deletions": 113}, "files": [{"sha": "c60765b837c9bc9103fe6b688270cd55d2f458c4", "filename": "gcc/testsuite/treelang/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2FChangeLog?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -1,3 +1,13 @@\n+2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* compile/autofunc.tree: New File.\n+\t* compile/badchar.tree: New File.\n+\t* compile/externvar.tree: New File.\n+\t* compile/mismatch.tree: New File.\n+\t* compile/noproto.tree: New File.\n+\t* compile/novar.tree: New File.\n+\t* compile/var_defs.tree: Add duplicate variable.\n+\n 2004-07-31  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* compile/vars_def.tree: New File."}, {"sha": "97da41e412034dc5ebc10b15b1663f46296a3cf9", "filename": "gcc/testsuite/treelang/compile/autofunc.tree", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fautofunc.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fautofunc.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fautofunc.tree?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -0,0 +1,6 @@\n+// { dg-do compile }\n+automatic int bar ();  // { dg-error \"automatic\" }\n+\n+bar () {\n+\treturn -12;\n+}"}, {"sha": "0121cc88ed07368209aac19f8ecb8f20065b080a", "filename": "gcc/testsuite/treelang/compile/badchar.tree", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fbadchar.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fbadchar.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fbadchar.tree?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -0,0 +1,2 @@\n+// { dg-do compile }\n+static int bar = 1*;  // { dg-error \"Unrecognized\" }"}, {"sha": "1fa3d6e89fcc26bdbb6e0c4883a15039fcdac9ad", "filename": "gcc/testsuite/treelang/compile/externvar.tree", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fexternvar.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fexternvar.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fexternvar.tree?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do compile }\n+external_reference int bar = 0;  // { dg-error \"initial\" }\n+\n+static char barf = 1;"}, {"sha": "7c62cd35b0d5e10aef12160c5f783fe53273fb10", "filename": "gcc/testsuite/treelang/compile/mismatch.tree", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fmismatch.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fmismatch.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fmismatch.tree?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile }\n+static int bar ();\n+static void barf ();\n+\n+bar {\n+\tbarf (1); // { dg-error \"mismatch\" \"barf\" }\n+\treturn -12;\n+}"}, {"sha": "a704765a791fc120ee949b4471adaf1107ce47f3", "filename": "gcc/testsuite/treelang/compile/noproto.tree", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fnoproto.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fnoproto.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fnoproto.tree?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile }\n+foo // { dg-error \"foo\" \"prototype\" }\n+{ \n+ x = 3;\n+}"}, {"sha": "97ef611f8d33bcecce654a89a45f1049c008ee7e", "filename": "gcc/testsuite/treelang/compile/novar.tree", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fnovar.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fnovar.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fnovar.tree?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -0,0 +1,5 @@\n+static void bar ();\n+\n+bar {\n+ x =  3;  // { dg-error \"x\" \"not defined\" }\n+}"}, {"sha": "aaab0d9099ec9382737c95c0ee9a808f78c69de8", "filename": "gcc/testsuite/treelang/compile/var_defs.tree", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fvar_defs.tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fvar_defs.tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Ftreelang%2Fcompile%2Fvar_defs.tree?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -24,6 +24,8 @@ condition\n \n first_nonzero\n {\n+  automatic int y;\n+  automatic int y;  // { dg-error \"Duplicate\" }\n   if (arg5)\n     {\n       return arg5;"}, {"sha": "962086311fab444f51f98dd8257b6167d784a33a", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -1,3 +1,32 @@\n+2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\tPR other/17762\n+\t* lex.l: Include input.h and errors.h\n+\t(lineno): New variable.\n+\t(LINEMAP_POSITION_FOR_COLUMN): Define as noop when USE_MAPPED_LOCATION\n+\tis not defined.\n+\tSet column position with LINEMAP_POSITION_FOR_COLUMN.\n+\tUse error instead of fprintf.\n+\tSet input_location with the value returned by linemap_start_line when\n+\tUSE_MAPPED_LOCATION is defined.\n+\t(dump_lex_value): Use LOCATION_LINE.\n+\t* parse.y: Include errors.h.\n+\tUse error and warning instead of fprintf.\n+\t(return): Move exp to rule scope and always set to $2.  Test against\n+\texp instead of $2.\n+\t(init): Set $$ to $2.\n+\t(print_token): Use LOCATION_LINE.\n+\t* tree1.c (treelang_init): Call treelang_init_decl_processing last.\n+\tCall linemap_add to set input_filename when USE_MAPPED_LOCATION is\n+\tdefined.\n+\t(treelang_parse_file): Always start at line one.\n+\tRename input_filename to main_input_filename when USE_MAPPED_LOCATION is\n+\tdefined.\n+\tLeave main_input_filename when done parsing the input.\n+\t(insert_tree_name): Use error instead of fprintf.\n+\t* treetree.c (tree_code_get_expression): Wrap long line.\n+\t(tree_mark_addressable): Use %qD to print out DECLs.\n+\n 2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* parse.y: Use gcc_assert and gcc_unreachable instead of abort."}, {"sha": "71268ff3f8fc42e28243ab080647e80046f472d2", "filename": "gcc/treelang/lex.l", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Flex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Flex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flex.l?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -36,7 +36,8 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"diagnostic.h\"\n+#include \"input.h\"\n+#include \"errors.h\"\n #include \"tree.h\"\n \n /* Token defs.  */\n@@ -50,6 +51,7 @@ int yylex (void);\n void update_yylval (int a); \n \n static int next_tree_charno = 1;\n+static int lineno = 1;\n  \n static void update_lineno_charno (void);\n static void dump_lex_value (int lexret);\n@@ -58,7 +60,9 @@ static void dump_lex_value (int lexret);\n    {fprintf (stderr, \"\\nlexer returning\"); dump_lex_value (a);} return a;}\n #define NOT_RETURN(a) {update_yylval (a); if (option_lexer_trace)\\\n    {fprintf (stderr, \"\\nlexer swallowing\"); dump_lex_value (a);}}\n-\n+#ifndef USE_MAPPED_LOCATION\n+#define LINEMAP_POSITION_FOR_COLUMN(INPUT, LINETABLE, COL)\n+#endif\n %}\n \n %option nostack\n@@ -70,8 +74,10 @@ static void dump_lex_value (int lexret);\n %%\n \n  { \n-   /* Should really allocate only what we need. lll;.  */\n+   /* ??? Should really allocate only what we need.  */\n    yylval = my_malloc (sizeof (struct prod_token_parm_item));\n+   LINEMAP_POSITION_FOR_COLUMN (input_location, &line_table,\n+\t\t\t\tnext_tree_charno);\n    ((struct prod_token_parm_item *)yylval)->tp.tok.location = input_location;\n    ((struct prod_token_parm_item *)yylval)->tp.tok.charno = next_tree_charno;\n  }\n@@ -210,11 +216,9 @@ static void dump_lex_value (int lexret);\n   \n [^\\n]  {\n   update_lineno_charno ();\n-  fprintf (stderr, \"%s:%i:%i: Unrecognized character %c\\n\",\n-\t   ((struct prod_token_parm_item *)yylval)->tp.tok.location.file, \n-           ((struct prod_token_parm_item *)yylval)->tp.tok.location.line, \n-\t   ((struct prod_token_parm_item *)yylval)->tp.tok.charno, yytext[0]);\n-  errorcount++;\n+  error (\"%HUnrecognized character %qc.\", \n+\t &((struct prod_token_parm_item *)yylval)->tp.tok.location,\n+\t yytext[0]);\n }\n \n %%\n@@ -229,17 +233,23 @@ update_lineno_charno (void)\n    /* Update the values we send to caller in case we sometimes don't\n       tell them about all the 'tokens' eg comments etc.  */\n    int yyl;\n+   LINEMAP_POSITION_FOR_COLUMN (input_location, &line_table,\n+\t\t\t\tnext_tree_charno);\n    ((struct prod_token_parm_item *)yylval)->tp.tok.location = input_location;\n    ((struct prod_token_parm_item *)yylval)->tp.tok.charno = next_tree_charno;\n-   if (input_line == 0)\n-     input_line = 1;\n \n    for ( yyl = 0; yyl < yyleng; ++yyl ) \n       {\n          if ( yytext[yyl] == '\\n' ) \n             {\n-\t      ++input_line;\n-               next_tree_charno = 1;\n+#ifdef USE_MAPPED_LOCATION\n+\t      source_location s = linemap_line_start (&line_table, ++lineno,\n+\t\t\t\t\t\t      80);\n+\t      input_location = s;\n+#else\n+\t      input_line = ++lineno;\n+#endif\n+\t      next_tree_charno = 1;\n             } \n          else \n            next_tree_charno++;\n@@ -269,10 +279,13 @@ static void\n dump_lex_value (int lexret) \n {\n   int ix;\n+\n   fprintf (stderr, \" %d l:%d c:%d ln:%d text=\", lexret,\n-         ((struct prod_token_parm_item *) yylval)->tp.tok.location.line,\n-         ((struct prod_token_parm_item *) yylval)->tp.tok.charno,\n-         ((struct prod_token_parm_item *) yylval)->tp.tok.length);\n+\t   LOCATION_LINE (((struct prod_token_parm_item *)\n+\t\t\t  yylval)->tp.tok.location),\n+\t   ((struct prod_token_parm_item *) yylval)->tp.tok.charno,\n+\t   ((struct prod_token_parm_item *) yylval)->tp.tok.length);\n+\n   for (ix = 0; ix < yyleng; ix++) \n     {\n       fprintf (stderr, \"%c\", yytext[ix]);"}, {"sha": "5177c90fcded4002eecf8ced21e7b6bff2e9f0a0", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 50, "deletions": 79, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -39,7 +39,7 @@ the GCC compiler.  */\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"diagnostic.h\"\n+#include \"errors.h\"\n #include \"timevar.h\"\n \n #include \"treelang.h\"\n@@ -198,16 +198,16 @@ storage typename NAME init_opt SEMICOLON {\n   if (VAR_INIT (prod))\n     {\n       gcc_assert (((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code);\n-    if (STORAGE_CLASS (prod) == EXTERNAL_REFERENCE_STORAGE)\n-      {\n-        fprintf (stderr, \"%s:%i:%i: External reference variables may not have initial value\\n\",\n-\t\t tok->tp.tok.location.file,\n-\t\t tok->tp.tok.location.line, tok->tp.tok.charno);\n-        print_token (stderr, 0, tok);\n-        errorcount++;\n-        YYERROR;\n-      }\n+      if (STORAGE_CLASS (prod) == EXTERNAL_REFERENCE_STORAGE)\n+\t{\n+\t  error(\"%HExternal reference variable %q.*s has an initial value.\",\n+\t\t&tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n+\t  YYERROR;\n+\t  VAR_INIT (prod) = NULL;\n+\t}\n+\n     }\n+\n   prod->tp.pro.code = tree_code_create_variable\n     (STORAGE_CLASS (prod), \n      ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.chars,\n@@ -276,11 +276,8 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n       break;\n       \n     case AUTOMATIC_STORAGE:\n-      fprintf (stderr, \"%s:%i:%i: A function cannot be automatic\\n\",\n-\t       tok->tp.tok.location.file,\n-\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n-      print_token (stderr, 0, tok);\n-      errorcount++;\n+      error (\"%HFunction %q.*s cannot be automatic.\",\n+\t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n       break;\n \n@@ -294,14 +291,13 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n        this_parm = this_parm->tp.pro.next)\n     {\n       gcc_assert (this_parm->category == production_category);\n-\n       this_parm_var = VARIABLE (this_parm);\n \n       gcc_assert (this_parm_var);\n       gcc_assert (this_parm_var->category == production_category);\n+      gcc_assert (this_parm_var->tp.pro.main_token);\n \n       this_parms = my_malloc (sizeof (struct prod_token_parm_item));\n-      gcc_assert (this_parm_var->tp.pro.main_token);\n \n       this_parms->tp.par.variable_name =\n \tthis_parm_var->tp.pro.main_token->tp.tok.chars;\n@@ -343,13 +339,11 @@ NAME LEFT_BRACE {\n   current_function = proto = lookup_tree_name (&search_prod);\n   if (!proto)\n     {\n-      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\",\n-\t       tok->tp.tok.location.file,\n-\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n-      print_token (stderr, 0, tok);\n-      errorcount++;\n+      error (\"%HNo prototype found for %q.*s\", &tok->tp.tok.location,\n+\t     tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n+\n   gcc_assert (proto->tp.pro.code);\n \n   tree_code_create_function_initial (proto->tp.pro.code, tok->tp.tok.location,\n@@ -362,7 +356,7 @@ NAME LEFT_BRACE {\n        this_parm = this_parm->tp.pro.next)\n     {\n       gcc_assert ((struct prod_token_parm_item*)VARIABLE (this_parm));\n-      gcc_assert ((( (struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code));\n+      gcc_assert (((struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code);\n     }\n #endif\n }\n@@ -522,41 +516,34 @@ LEFT_BRACE variable_defs_opt statements_opt RIGHT_BRACE {\n return:\n tl_RETURN expression_opt {\n   struct prod_token_parm_item *type_prod;\n-  struct prod_token_parm_item* ret_tok;\n-  ret_tok = $1;\n+  struct prod_token_parm_item *ret_tok = $1;\n+  struct prod_token_parm_item *exp = $2;\n+\n   type_prod = EXPRESSION_TYPE (current_function);\n   if (NUMERIC_TYPE (type_prod) == VOID_TYPE)\n-    if ($2 == NULL)\n+    if (exp == NULL)\n       tree_code_generate_return (type_prod->tp.pro.code, NULL);\n     else\n       {\n-        fprintf (stderr, \"%s:%i:%i: Redundant expression in return\\n\",\n-                ret_tok->tp.tok.location.file,\n-                ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno);\n-        errorcount++;\n+\twarning (\"%HRedundant expression in return.\",\n+\t\t &ret_tok->tp.tok.location, ret_tok->tp.tok.length,\n+\t\t ret_tok->tp.tok.chars);\n         tree_code_generate_return (type_prod->tp.pro.code, NULL);\n        }\n   else\n-    if ($2 == NULL)\n-      {\n-        fprintf (stderr, \"%s:%i:%i: Expression missing in return\\n\",\n-                ret_tok->tp.tok.location.file,\n-                ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno);\n-        errorcount++;\n-      }\n+    if (exp == NULL)\n+\terror (\"%HExpression missing in return.\", &ret_tok->tp.tok.location);\n     else\n       {\n-        struct prod_token_parm_item *exp;\n-        exp = $2;\n         /* Check same type.  */\n-        if (check_type_match (NUMERIC_TYPE (type_prod), $2))\n+        if (check_type_match (NUMERIC_TYPE (type_prod), exp))\n           {\n-            gcc_assert (type_prod->tp.pro.code);\n-            gcc_assert (exp->tp.pro.code);\n+\t    gcc_assert (type_prod->tp.pro.code);\n+\t    gcc_assert (exp->tp.pro.code);\n \n             /* Generate the code. */\n             tree_code_generate_return (type_prod->tp.pro.code,\n-                                       exp->tp.pro.code);\n+\t\t\t\t       exp->tp.pro.code);\n           }\n       }\n }\n@@ -645,11 +632,8 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n   proto = lookup_tree_name (&search_prod);\n   if (!proto)\n     {\n-      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\",\n-\t       tok->tp.tok.location.file,\n-\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n-      print_token (stderr, 0, tok);\n-      errorcount++;\n+      error (\"%HFunction prototype not found for %q.*%s.\",\n+\t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n   EXPRESSION_TYPE (prod) = EXPRESSION_TYPE (proto);\n@@ -664,11 +648,8 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n \n   if (exp_count !=  exp_proto_count)\n     {\n-      fprintf (stderr, \"%s:%i:%i: expression count mismatch with prototype\\n\",\n-\t       tok->tp.tok.location.file,\n-\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n-      print_token (stderr, 0, tok);\n-      errorcount++;\n+      error (\"%HExpression count mismatch %q.*s with prototype.\",\n+\t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n   parms = tree_code_init_parameters ();\n@@ -726,11 +707,8 @@ NAME {\n   symbol_table_entry = lookup_tree_name (&search_prod);\n   if (!symbol_table_entry)\n     {\n-      fprintf (stderr, \"%s:%i:%i: Variable referred to but not defined\\n\",\n-              tok->tp.tok.location.file,\n-              tok->tp.tok.location.line, tok->tp.tok.charno);\n-      print_token (stderr, 0, tok);\n-      errorcount++;\n+      error (\"%HVariable %q.*s not defined.\",\n+\t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n \n@@ -758,6 +736,7 @@ init_opt:\n \n init:\n ASSIGN init_element {\n+  $$ = $2;\n }\n ;\n \n@@ -779,9 +758,10 @@ print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value)\n   unsigned int  ix;\n \n   tok  =  value;\n-  fprintf (file, \"%d \\\"\", tok->tp.tok.location.line);\n+  fprintf (file, \"%d \\\"\", LOCATION_LINE (tok->tp.tok.location));\n   for (ix  =  0; ix < tok->tp.tok.length; ix++)\n     fprintf (file, \"%c\", tok->tp.tok.chars[ix]);\n+\n   fprintf (file, \"\\\"\");\n }\n \n@@ -790,19 +770,12 @@ static void\n yyerror (const char *error_message)\n {\n   struct prod_token_parm_item *tok;\n-  \n+\n   tok = yylval;\n   if (tok)\n-    {\n-      fprintf (stderr, \"%s:%i:%i: %s\\n\", tok->tp.tok.location.file,\n-\t       tok->tp.tok.location.line, tok->tp.tok.charno, error_message);\n-      print_token (stderr, 0, tok);\n-    }\n+    error (\"%H%s\", &tok->tp.tok.location, error_message);\n   else\n-    fprintf (stderr, \"%s\\n\", error_message);\n-  \n-  errorcount++;\n-\n+    error (\"%s\", error_message);\n }\n \n /* Reverse the order of a token list, linked by parse_next, old first\n@@ -821,6 +794,7 @@ reverse_prod_list (struct prod_token_parm_item *old_first)\n   while (current) \n     {\n       gcc_assert (current->category == production_category);\n+\n       next = current->tp.pro.next;\n       current->tp.pro.next = prev;\n       prev = current;\n@@ -835,13 +809,8 @@ static void\n ensure_not_void (unsigned int type, struct prod_token_parm_item* name)\n {\n   if (type == VOID_TYPE)\n-    {\n-      fprintf (stderr, \"%s:%i:%i: Type must not be void in this context\\n\",\n-\t       name->tp.tok.location.file,\n-\t       name->tp.tok.location.line, name->tp.tok.charno);\n-      print_token (stderr, 0, name);\n-      errorcount++;\n-    }\n+    error (\"%HType must not be void in this context.\",\n+\t   &name->tp.tok.location);\n }\n \n /* Check TYPE1 and TYPE2 which are integral types.  Return the lowest\n@@ -932,13 +901,15 @@ make_plus_expression (struct prod_token_parm_item* tok,\n \n   NUMERIC_TYPE (prod) = type_code;\n   type = tree_code_get_type (type_code);\n+\n   gcc_assert (type);\n+\n   OP1 (prod) = op1;\n   OP2 (prod) = op2;\n       \n-  prod->tp.pro.code = tree_code_get_expression\n-     (prod_code, type, op1->tp.pro.code,\n-      op2->tp.pro.code, NULL);\n+  prod->tp.pro.code = tree_code_get_expression (prod_code, type,\n+\t\t\t\t\t\top1->tp.pro.code,\n+\t\t\t\t\t\top2->tp.pro.code, NULL);\n \n   return prod;\n }"}, {"sha": "26ef3bc7f98b9c4c1dcc92fb99d2db057e920516", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -129,7 +129,6 @@ treelang_handle_option (size_t scode, const char *arg ATTRIBUTE_UNUSED,\n \n     default:\n       gcc_unreachable ();\n-\n     }\n \n   return 1;\n@@ -140,12 +139,11 @@ treelang_handle_option (size_t scode, const char *arg ATTRIBUTE_UNUSED,\n bool\n treelang_init (void)\n {\n+#ifndef USE_MAPPED_LOCATION\n   input_filename = main_input_filename;\n-  input_line = 1;\n-\n-  /* Init decls etc.  */\n-\n-  treelang_init_decl_processing ();\n+#else\n+  linemap_add (&line_table, LC_ENTER, false, main_input_filename, 1);\n+#endif\n \n   /* This error will not happen from GCC as it will always create a\n      fake input file.  */\n@@ -167,6 +165,14 @@ treelang_init (void)\n       exit (1);\n     }\n \n+#ifdef USE_MAPPED_LOCATION\n+  linemap_add (&line_table, LC_RENAME, false, \"<built-in>\", 1);\n+  linemap_line_start (&line_table, 0, 1);\n+#endif\n+\n+  /* Init decls, etc.  */\n+  treelang_init_decl_processing ();\n+\n   return true;\n }\n \n@@ -183,9 +189,21 @@ treelang_finish (void)\n void\n treelang_parse_file (int debug_flag ATTRIBUTE_UNUSED)\n {\n+#ifdef USE_MAPPED_LOCATION\n+  source_location s;\n+  linemap_add (&line_table, LC_RENAME, false, main_input_filename, 1);\n+  s = linemap_line_start (&line_table, 1, 80);\n+  input_location = s;\n+#else\n+  input_line = 1;\n+#endif\n+\n   treelang_debug ();\n   yyparse ();\n   cgraph_finalize_compilation_unit ();\n+#ifdef USE_MAPPED_LOCATION\n+  linemap_add (&line_table, LC_LEAVE, false, NULL, 0);\n+#endif\n   cgraph_optimize ();\n }\n \n@@ -257,10 +275,8 @@ insert_tree_name (struct prod_token_parm_item *prod)\n   sanity_check (prod);\n   if (lookup_tree_name (prod))\n     {\n-      fprintf (stderr, \"%s:%i:%i duplicate name %s\\n\",\n-\t       tok->tp.tok.location.file, tok->tp.tok.location.line, \n-               tok->tp.tok.charno, tok->tp.tok.chars);\n-      errorcount++;\n+      error (\"%HDuplicate name %q.*s.\", &tok->tp.tok.location,\n+\t     tok->tp.tok.length, tok->tp.tok.chars);\n       return 1;\n     }\n   prod->tp.pro.next = symbol_table;"}, {"sha": "adcda4398a8b09712d086956d0ed933ad86c0392", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c4f8c7d8dedd5dd5ac7185d402b6c10003da19/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=34c4f8c7d8dedd5dd5ac7185d402b6c10003da19", "patch": "@@ -686,7 +686,9 @@ tree_code_get_expression (unsigned int exp_type,\n       gcc_assert (op1 && op2);\n       operator = MODIFY_EXPR;\n       ret1 = fold (build2 (operator, void_type_node, op1,\n-                           fold (build1 (CONVERT_EXPR, TREE_TYPE (op1), op2))));\n+                           fold (build1 (CONVERT_EXPR, TREE_TYPE (op1),\n+\t\t\t\t\t op2))));\n+\n       break;\n \n     case EXP_PLUS:\n@@ -837,24 +839,22 @@ tree_mark_addressable (tree exp)\n \t  {\n \t    if (TREE_PUBLIC (x))\n \t      {\n-\t\terror (\"global register variable `%s' used in nested function\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t\terror (\"Global register variable %qD used in nested function.\",\n+\t\t       x);\n \t\treturn 0;\n \t      }\n-\t    pedwarn (\"register variable `%s' used in nested function\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t    pedwarn (\"Register variable %qD used in nested function.\", x);\n \t  }\n \telse if (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x))\n \t  {\n \t    if (TREE_PUBLIC (x))\n \t      {\n-\t\terror (\"address of global register variable `%s' requested\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t\terror (\"Address of global register variable %qD requested.\",\n+\t\t       x);\n \t\treturn 0;\n \t      }\n \n-\t    pedwarn (\"address of register variable `%s' requested\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t    pedwarn (\"Address of register variable %qD requested.\", x);\n \t  }\n \n \t/* drops in */"}]}