{"sha": "ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhODg0NzFiNWRmMDM5YmI5YjhiOGU3Y2UwY2UxN2E3MWEwZDNiZA==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2010-10-27T22:44:31Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2010-10-27T22:44:31Z"}, "message": "tm.texi.in (TARGET_GET_RAW_RESULT_MODE): New.\n\n2010-10-27  Steve Ellcey  <sje@cup.hp.com>\n\n\t* doc/tm.texi.in (TARGET_GET_RAW_RESULT_MODE): New.\n\t(TARGET_GET_RAW_ARG_MODE): New.\n\t* doc/tm.texi: Regenerate.\n\t* target.def (get_raw_result_mode): New.\n\t(get_raw_arg_mode): New.\n\t* targhooks.c (default_get_reg_raw_mode): New.\n\t* targhooks.h (default_get_reg_raw_mode): New.\n\t* builtins.c (apply_args_size): Use targetm.calls.get_raw_arg_mode.\n\t(apply_result_size): Ditto.\n\t* config/ia64/ia64.c (ia64_get_reg_raw_mode): New.\n\t(TARGET_GET_RAW_RESULT_MODE): Define.\n\t(TARGET_GET_RAW_ARG_MODE): Ditto.\n\nFrom-SVN: r166021", "tree": {"sha": "a6eef89a2a1f2599082334f22265eeb9df63eb58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6eef89a2a1f2599082334f22265eeb9df63eb58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/comments", "author": null, "committer": null, "parents": [{"sha": "2b08f2c561e0dc9b8f569a00868a6b7eb2ba111b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b08f2c561e0dc9b8f569a00868a6b7eb2ba111b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b08f2c561e0dc9b8f569a00868a6b7eb2ba111b"}], "stats": {"total": 108, "additions": 99, "deletions": 9}, "files": [{"sha": "611b777ec9ce14e82d568d382512379bbbed44a0", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "patch": "@@ -1334,7 +1334,7 @@ apply_args_size (void)\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (FUNCTION_ARG_REGNO_P (regno))\n \t  {\n-\t    mode = reg_raw_mode[regno];\n+\t    mode = targetm.calls.get_raw_arg_mode (regno);\n \n \t    gcc_assert (mode != VOIDmode);\n \n@@ -1370,7 +1370,7 @@ apply_result_size (void)\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (targetm.calls.function_value_regno_p (regno))\n \t  {\n-\t    mode = reg_raw_mode[regno];\n+\t    mode = targetm.calls.get_raw_result_mode (regno);\n \n \t    gcc_assert (mode != VOIDmode);\n "}, {"sha": "4a738095c6e60970d3e2558b7e8b83eb0e771abc", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "patch": "@@ -209,6 +209,14 @@ static void ia64_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static int ia64_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t   tree, bool);\n+static rtx ia64_function_arg_1 (const CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\tconst_tree, bool, bool);\n+static rtx ia64_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t      const_tree, bool);\n+static rtx ia64_function_incoming_arg (CUMULATIVE_ARGS *,\n+\t\t\t\t       enum machine_mode, const_tree, bool);\n+static void ia64_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t       const_tree, bool);\n static bool ia64_function_ok_for_sibcall (tree, tree);\n static bool ia64_return_in_memory (const_tree, const_tree);\n static rtx ia64_function_value (const_tree, const_tree, bool);\n@@ -325,6 +333,7 @@ static void ia64_dwarf_handle_frame_unspec (const char *, rtx, int);\n static tree ia64_builtin_decl (unsigned, bool);\n \n static reg_class_t ia64_preferred_reload_class (rtx, reg_class_t);\n+static enum machine_mode ia64_get_reg_raw_mode (int regno);\n \f\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ia64_attribute_table[] =\n@@ -481,6 +490,12 @@ static const struct default_options ia64_option_optimization_table[] =\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ia64_function_ok_for_sibcall\n #undef TARGET_ARG_PARTIAL_BYTES\n #define TARGET_ARG_PARTIAL_BYTES ia64_arg_partial_bytes\n+#undef TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG ia64_function_arg\n+#undef TARGET_FUNCTION_INCOMING_ARG\n+#define TARGET_FUNCTION_INCOMING_ARG ia64_function_incoming_arg\n+#undef TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE ia64_function_arg_advance\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK ia64_output_mi_thunk\n@@ -545,6 +560,10 @@ static const struct default_options ia64_option_optimization_table[] =\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n+#undef TARGET_GET_RAW_RESULT_MODE\n+#define TARGET_GET_RAW_RESULT_MODE ia64_get_reg_raw_mode\n+#undef TARGET_GET_RAW_ARG_MODE\n+#define TARGET_GET_RAW_ARG_MODE ia64_get_reg_raw_mode\n \n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ia64_gimplify_va_arg\n@@ -4250,7 +4269,7 @@ hfa_element_mode (const_tree type, bool nested)\n /* Return the number of words required to hold a quantity of TYPE and MODE\n    when passed as an argument.  */\n static int\n-ia64_function_arg_words (tree type, enum machine_mode mode)\n+ia64_function_arg_words (const_tree type, enum machine_mode mode)\n {\n   int words;\n \n@@ -4276,7 +4295,8 @@ ia64_function_arg_words (tree type, enum machine_mode mode)\n    all as if they had 16 byte alignment.  Such aggregates can occur\n    only if gcc extensions are used.  */\n static int\n-ia64_function_arg_offset (CUMULATIVE_ARGS *cum, tree type, int words)\n+ia64_function_arg_offset (const CUMULATIVE_ARGS *cum,\n+\t\t\t  const_tree type, int words)\n {\n   /* No registers are skipped on VMS.  */\n   if (TARGET_ABI_OPEN_VMS || (cum->words & 1) == 0)\n@@ -4295,9 +4315,9 @@ ia64_function_arg_offset (CUMULATIVE_ARGS *cum, tree type, int words)\n /* ??? 128-bit quad-precision floats are always passed in general\n    registers.  */\n \n-rtx\n-ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n-\t\t   int named, int incoming)\n+static rtx\n+ia64_function_arg_1 (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t     const_tree type, bool named, bool incoming)\n {\n   int basereg = (incoming ? GR_ARG_FIRST : AR_ARG_FIRST);\n   int words = ia64_function_arg_words (type, mode);\n@@ -4486,6 +4506,25 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n     }\n }\n \n+/* Implement TARGET_FUNCION_ARG target hook.  */\n+\n+static rtx\n+ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t   const_tree type, bool named)\n+{\n+  return ia64_function_arg_1 (cum, mode, type, named, false);\n+}\n+\n+/* Implement TARGET_FUNCION_INCOMING_ARG target hook.  */\n+\n+static rtx\n+ia64_function_incoming_arg (CUMULATIVE_ARGS *cum,\n+\t\t\t    enum machine_mode mode,\n+\t\t\t    const_tree type, bool named)\n+{\n+  return ia64_function_arg_1 (cum, mode, type, named, true);\n+}\n+\n /* Return number of bytes, at the beginning of the argument, that must be\n    put in registers.  0 is the argument is entirely in registers or entirely\n    in memory.  */\n@@ -4531,9 +4570,9 @@ ia64_arg_type (enum machine_mode mode)\n /* Update CUM to point after this argument.  This is patterned after\n    ia64_function_arg.  */\n \n-void\n+static void\n ia64_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t   tree type, int named)\n+\t\t\t   const_tree type, bool named)\n {\n   int words = ia64_function_arg_words (type, mode);\n   int offset = ia64_function_arg_offset (cum, type, words);\n@@ -10959,5 +10998,12 @@ ia64_dconst_0_375 (void)\n   return ia64_dconst_0_375_rtx;\n }\n \n+static enum machine_mode\n+ia64_get_reg_raw_mode (int regno)\n+{\n+  if (FR_REGNO_P (regno))\n+    return XFmode;\n+  return default_get_reg_raw_mode(regno);\n+}\n \n #include \"gt-ia64.h\""}, {"sha": "a8d27a3e6ccacbc0b92eccec327e95dc8dc0d5c4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "patch": "@@ -4606,6 +4606,14 @@ This macro has effect in @option{-fpcc-struct-return} mode, but it does\n nothing when you use @option{-freg-struct-return} mode.\n @end defmac\n \n+@deftypefn {Target Hook} {enum machine_mode} TARGET_GET_RAW_RESULT_MODE (int @var{regno})\n+This target hook returns the mode to be used when accessing raw return registers in @code{__builtin_return}.  Define this macro if the value in @var{reg_raw_mode} is not correct.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {enum machine_mode} TARGET_GET_RAW_ARG_MODE (int @var{regno})\n+This target hook returns the mode to be used when accessing raw argument registers in @code{__builtin_apply_args}.  Define this macro if the value in @var{reg_raw_mode} is not correct.\n+@end deftypefn\n+\n @node Caller Saves\n @subsection Caller-Saves Register Allocation\n "}, {"sha": "47d4aa2170464c719dfaa402b43df6b599e5eb32", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "patch": "@@ -4600,6 +4600,10 @@ This macro has effect in @option{-fpcc-struct-return} mode, but it does\n nothing when you use @option{-freg-struct-return} mode.\n @end defmac\n \n+@hook TARGET_GET_RAW_RESULT_MODE\n+\n+@hook TARGET_GET_RAW_ARG_MODE\n+\n @node Caller Saves\n @subsection Caller-Saves Register Allocation\n "}, {"sha": "98cea58c40ddc4514125cf13eddccc690f99bdaf", "filename": "gcc/target.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "patch": "@@ -1982,6 +1982,26 @@ DEFHOOK\n  int, (tree fundecl, tree funtype, int size),\n  default_return_pops_args)\n \n+/* Return a mode wide enough to copy any function value that might be\n+   returned.  */\n+DEFHOOK\n+(get_raw_result_mode,\n+ \"This target hook returns the mode to be used when accessing raw return\\\n+ registers in @code{__builtin_return}.  Define this macro if the value\\\n+ in @var{reg_raw_mode} is not correct.\",\n+ enum machine_mode, (int regno),\n+ default_get_reg_raw_mode)\n+\n+/* Return a mode wide enough to copy any argument value that might be\n+   passed.  */\n+DEFHOOK\n+(get_raw_arg_mode,\n+ \"This target hook returns the mode to be used when accessing raw argument\\\n+ registers in @code{__builtin_apply_args}.  Define this macro if the value\\\n+ in @var{reg_raw_mode} is not correct.\",\n+ enum machine_mode, (int regno),\n+ default_get_reg_raw_mode)\n+\n HOOK_VECTOR_END (calls)\n \n /* Return the diagnostic message string if conversion from FROMTYPE"}, {"sha": "22bba3b33bc1d225729a9c00692e07ac9ae3fbed", "filename": "gcc/targhooks.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target-def.h\"\n #include \"ggc.h\"\n #include \"hard-reg-set.h\"\n+#include \"regs.h\"\n #include \"reload.h\"\n #include \"optabs.h\"\n #include \"recog.h\"\n@@ -1333,6 +1334,15 @@ sjlj_except_unwind_info (void)\n   return UI_SJLJ;\n }\n \n+/* To be used by targets where reg_raw_mode doesn't return the right\n+   mode for registers used in apply_builtin_return and apply_builtin_arg.  */\n+\n+enum machine_mode\n+default_get_reg_raw_mode(int regno)\n+{\n+  return reg_raw_mode[regno];\n+}\n+\n const struct default_options empty_optimization_table[] =\n   {\n     { OPT_LEVELS_NONE, 0, NULL, 0 }"}, {"sha": "87625137de35b161068f93e9936bb7a3ec6eb89d", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=ffa88471b5df039bb9b8b8e7ce0ce17a71a0d3bd", "patch": "@@ -168,4 +168,6 @@ extern int default_loop_align_max_skip (rtx);\n extern int default_label_align_max_skip (rtx);\n extern int default_jump_align_max_skip (rtx);\n \n+extern enum machine_mode default_get_reg_raw_mode(int);\n+\n extern const struct default_options empty_optimization_table[];"}]}