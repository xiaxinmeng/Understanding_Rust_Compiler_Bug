{"sha": "08e299d6c37b3d1af2eefd3db3d8772a863d5fb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhlMjk5ZDZjMzdiM2QxYWYyZWVmZDNkYjNkODc3MmE4NjNkNWZiOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-14T23:27:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-14T23:27:24Z"}, "message": "Update copyright.\n\nFrom-SVN: r24668", "tree": {"sha": "5c7c3288691fca8ae3771316161417ac7c651d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c7c3288691fca8ae3771316161417ac7c651d0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08e299d6c37b3d1af2eefd3db3d8772a863d5fb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e299d6c37b3d1af2eefd3db3d8772a863d5fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08e299d6c37b3d1af2eefd3db3d8772a863d5fb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e299d6c37b3d1af2eefd3db3d8772a863d5fb8/comments", "author": null, "committer": null, "parents": [{"sha": "8c55f49ce8890347168cecc7abdc290cc8d34963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c55f49ce8890347168cecc7abdc290cc8d34963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c55f49ce8890347168cecc7abdc290cc8d34963"}], "stats": {"total": 119, "additions": 106, "deletions": 13}, "files": [{"sha": "841989fa00304086a73835ed5bddec635ab23b47", "filename": "gcc/integrate.c", "status": "modified", "additions": 106, "deletions": 13, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e299d6c37b3d1af2eefd3db3d8772a863d5fb8/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e299d6c37b3d1af2eefd3db3d8772a863d5fb8/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=08e299d6c37b3d1af2eefd3db3d8772a863d5fb8", "patch": "@@ -1,5 +1,5 @@\n /* Procedure integration for GNU CC.\n-   Copyright (C) 1988, 91, 93-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 91, 93-98, 1999 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1778,12 +1778,12 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n       /* Machine mode function was declared to return.   */\n       enum machine_mode departing_mode = TYPE_MODE (type);\n+\n       /* (Possibly wider) machine mode it actually computes\n \t (for the sake of callers that fail to declare it right).\n \t We have to use the mode of the result's RTL, rather than\n \t its type, since expand_function_start may have promoted it.  */\n-      enum machine_mode arriving_mode\n-\t= GET_MODE (DECL_RTL (DECL_RESULT (fndecl)));\n+      enum machine_mode arriving_mode = GET_MODE (loc);\n       rtx reg_to_map;\n \n       /* Don't use MEMs as direct targets because on some machines\n@@ -1797,16 +1797,11 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t     the mode from that, otherwise abort. */\n \t  if (departing_mode == BLKmode)\n \t    {\n-\t      if (REG == GET_CODE (DECL_RTL (DECL_RESULT (fndecl))))\n-\t\t{\n-\t\t  departing_mode = GET_MODE (DECL_RTL (DECL_RESULT (fndecl)));\n-\t\t  arriving_mode = departing_mode;\n-\t\t}\n-\t      else\n-\t\tabort();\n+\t      departing_mode = GET_MODE (loc);\n+\t      arriving_mode = departing_mode;\n \t    }\n \t      \n-\ttarget = gen_reg_rtx (departing_mode);\n+\t  target = gen_reg_rtx (departing_mode);\n \t}\n \n       /* If function's value was promoted before return,\n@@ -1838,6 +1833,86 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n       else\n \tmap->reg_map[REGNO (loc)] = reg_to_map;\n     }\n+  else if (GET_CODE (loc) == CONCAT)\n+    {\n+      /* The function returns an object in a pair of registers and we use\n+\t the return value.  Set up our target for remapping.  */\n+\n+      /* Machine mode function was declared to return.   */\n+      enum machine_mode departing_mode = TYPE_MODE (type);\n+\n+      /* (Possibly wider) machine mode it actually computes\n+\t (for the sake of callers that fail to declare it right).\n+\t We have to use the mode of the result's RTL, rather than\n+\t its type, since expand_function_start may have promoted it.  */\n+      enum machine_mode arriving_mode = GET_MODE (loc);\n+      rtx reg_to_map;\n+\n+      /* Don't use MEMs as direct targets because on some machines\n+\t substituting a MEM for a REG makes invalid insns.\n+\t Let the combiner substitute the MEM if that is valid.  */\n+      if (target == 0 || GET_CODE (target) != REG\n+\t  || GET_MODE (target) != departing_mode)\n+\t{\n+\t  /* Don't make BLKmode registers.  If this looks like\n+\t     a BLKmode object being returned in a register, get\n+\t     the mode from that, otherwise abort. */\n+\t  if (departing_mode == BLKmode)\n+\t    {\n+\t      departing_mode = GET_MODE (DECL_RTL (DECL_RESULT (fndecl)));\n+\t      arriving_mode = departing_mode;\n+\t    }\n+\t      \n+\t  target = gen_reg_rtx (departing_mode);\n+\t}\n+\n+      /* If function's value was promoted before return,\n+\t avoid machine mode mismatch when we substitute INLINE_TARGET.\n+\t But TARGET is what we will return to the caller.  */\n+      if (arriving_mode != departing_mode)\n+\t{\n+\t  enum machine_mode submode;\n+\n+\t  /* Avoid creating a paradoxical subreg wider than\n+\t     BITS_PER_WORD, since that is illegal.  */\n+\t  if (GET_MODE_UNIT_SIZE (arriving_mode) > UNITS_PER_WORD)\n+\t    {\n+\t      if (!(TRULY_NOOP_TRUNCATION\n+\t\t    (GET_MODE_SIZE (departing_mode) * BITS_PER_UNIT,\n+\t\t     GET_MODE_SIZE (arriving_mode) * BITS_PER_UNIT)))\n+\t\t/* Maybe could be handled by using convert_move () ?  */\n+\t\tabort ();\n+\n+\t      reg_to_map = gen_reg_rtx (arriving_mode);\n+\n+\t      submode = TOGGLE_COMPLEX_MODE (departing_mode);\n+\t      target\n+\t\t= gen_rtx_CONCAT (departing_mode,\n+\t\t\t\t  gen_lowpart (submode, XEXP (reg_to_map, 0)),\n+\t\t\t\t  gen_lowpart (submode, XEXP (reg_to_map, 1)));\n+\t    }\n+\t  else\n+\t    {\n+\t      submode = TOGGLE_COMPLEX_MODE (arriving_mode);\n+\t      reg_to_map\n+\t\t= gen_rtx_CONCAT (arriving_mode,\n+\t\t\t\t  gen_lowpart (submode, XEXP (target, 0)),\n+\t\t\t\t  gen_lowpart (submode, XEXP (target, 1)));\n+\t    }\n+\t}\n+      else\n+\treg_to_map = target;\n+\n+      /* Usually, the result value is the machine's return register.\n+\t Sometimes it may be a pseudo. Handle both cases.  */\n+      if (REG_FUNCTION_VALUE_P (XEXP (loc, 0)))\n+\tmap->inline_target = reg_to_map;\n+      else\n+\t{\n+\t  map->reg_map[REGNO (XEXP (loc, 0))] = XEXP (reg_to_map, 0);\n+\t  map->reg_map[REGNO (XEXP (loc, 1))] = XEXP (reg_to_map, 1);\n+\t}\n+    }\n   else\n     abort ();\n \n@@ -2437,8 +2512,26 @@ copy_rtx_and_substitute (orig, map)\n \t\t/* Must be unrolling loops or replicating code if we\n \t\t   reach here, so return the register unchanged.  */\n \t\treturn orig;\n-\t      else if (GET_MODE (map->inline_target) != BLKmode\n-\t\t       && mode != GET_MODE (map->inline_target))\n+\t      else if (GET_MODE (map->inline_target) == BLKmode)\n+\t\treturn map->inline_target;\n+\t      else if (GET_CODE (map->inline_target) == CONCAT)\n+\t\t{\n+\t\t  rtx ret;\n+\n+\t\t  /* ??? Assume that the real part of a concat is in the\n+\t\t     first function value register.  */\n+\t\t  if (REGNO (orig) == 0 \n+\t\t      || ! FUNCTION_VALUE_REGNO_P (REGNO (orig) - 1))\n+\t\t    ret = XEXP (map->inline_target, 0);\n+\t\t  else\n+\t\t    ret = XEXP (map->inline_target, 1);\n+\n+\t\t  if (mode != GET_MODE (ret))\n+\t\t    ret = gen_lowpart (mode, ret);\n+\n+\t\t  return ret;\n+\t\t}\n+\t      else if (mode != GET_MODE (map->inline_target))\n \t\treturn gen_lowpart (mode, map->inline_target);\n \t      else\n \t\treturn map->inline_target;"}]}