{"sha": "37c46b43dba86b48bb19d9f7ed231385e02c1abd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdjNDZiNDNkYmE4NmI0OGJiMTlkOWY3ZWQyMzEzODVlMDJjMWFiZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-28T23:20:02Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-28T23:20:02Z"}, "message": "91th Cygnus<->FSF quick merge\n\nFrom-SVN: r14134", "tree": {"sha": "1eb8dc109639b3bbe2e0cb0199cf3ff635b2481b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eb8dc109639b3bbe2e0cb0199cf3ff635b2481b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37c46b43dba86b48bb19d9f7ed231385e02c1abd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37c46b43dba86b48bb19d9f7ed231385e02c1abd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37c46b43dba86b48bb19d9f7ed231385e02c1abd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37c46b43dba86b48bb19d9f7ed231385e02c1abd/comments", "author": null, "committer": null, "parents": [{"sha": "87c166683a971ac241f06423db6af2b45d1c39ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c166683a971ac241f06423db6af2b45d1c39ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c166683a971ac241f06423db6af2b45d1c39ed"}], "stats": {"total": 1275, "additions": 835, "deletions": 440}, "files": [{"sha": "a61f4ee9158dee095b75d6d71a7f3cbd748fb757", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 102, "deletions": 14, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -1,3 +1,91 @@\n+Tue May 27 19:49:19 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (convert): Don't do any extra work, if we can avoid it\n+\teasily.\n+\n+Tue May 27 18:21:47 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* *.[chy]: Change cp_convert to ocp_convert, change convert to\n+\tcp_convert.  convert is now reserved for the backend, and doesn't\n+\thave the semantics a frontend person should ever want.\n+\n+Fri May 23 10:58:31 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lang-specs.h: Define __EXCEPTIONS if exceptions are enabled.\n+\tLose -traditional support.\n+\n+Thu May 22 15:41:28 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (get_tinfo_var): Use TYPE_PRECISION (sizetype).\n+\n+\t* parse.y (self_reference): Do it for templates, too.\n+\t* class.c (pushclass): Don't overload_template_name; the alias\n+\tgenerated by build_self_reference serves the same purpose.\n+\n+\t* tree.c (list_hash): Make static, take more args.\n+\t(list_hash_lookup): Likewise.\n+\t(list_hash_add): Make static.\n+\t(list_hash_canon): Lose.\n+\t(hash_tree_cons): Only build a new node if one isn't already in the\n+\thashtable.\n+\t(hash_tree_chain): Use hash_tree_cons.\n+\t* cp-tree.h: Adjust.\n+\t* decl.c (grokfndecl): Just check IDENTIFIER_GLOBAL_VALUE instead\n+\tof calling lookup_name.\n+\n+Wed May 21 18:24:19 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): TYPE_VALUES for an enum\n+\tdoesn't refer to the CONST_DECLs.\n+\n+Tue May 20 21:09:32 1997  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* rtti.c (get_tinfo_var): Either INT_TYPE_SIZE or 32, whichever\n+\tis bigger.\n+\t(expand_class_desc): Convert the last argument to a sizetype.\n+\n+Tue May 20 13:55:57 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* gxx.gperf (__complex, __complex__, __imag, __imag__, __real,\n+\t__real__): Add reswords.\n+\t* hash.h: Regenerate.\n+\t* lex.h (rid): Add RID_COMPLEX.\n+\t(RID_LAST_MODIFIER): Set to RID_COMPLEX.\n+\t* lex.c (init_lex): Add building of RID_COMPLEX.  Unset reserved\n+\tword \"complex\" if -fno-gnu-keywords.\n+\t(real_yylex): General cleanup in line with what c-lex.c also has,\n+\tsans the cruft for traditional; add handling of SPEC_IMAG, complex\n+\ttypes, and imaginary numeric constants.\n+\t* parse.y (REALPART, IMAGPART): Add tokens.\n+\t(unary_expr): Add REALPART and IMAGPART rules.\n+\t* cp-tree.h (complex_{integer,float,double,long}_type_node): Declare.\n+\t* decl.c (complex_{integer,float,double,long}_type_node): Define\n+\ttypes.\n+\t(init_decl_processing): Set up the types.\n+\t(grokdeclarator): Add handling of RID_COMPLEX.  Set and use\n+\tDEFAULTED_INT instead of EXPLICIT_INT when we default to int type.\n+\t* call.c (build_new_op): Add REALPART_EXPR and IMAGPART_EXPR cases.\n+\t* cvt.c (cp_convert): Handle COMPLEX_TYPE.\n+\t* error.c (dump_type_prefix, dump_type, dump_type_suffix): Add\n+\tCOMPLEX_TYPE case.\n+\t* method.c (build_overload_name): Add handling of the different\n+\tCOMPLEX_TYPEs, prefixing them with `J'.\n+\t* pt.c (process_template_parm): Don't let them use a COMPLEX_TYPE\n+\tas a template parm.\n+\t(uses_template_parms, tsubst, unify): Add COMPLEX_TYPE case.\n+\t* tree.c (lvalue_p): Add REALPART_EXPR and IMAGPART_EXPR cases.\n+\t(mapcar): Handle COMPLEX_CST.\n+\t* typeck.c (build_binary_op_nodefault): Handle COMPLEX_TYPE.\n+\t(common_type): Add code for complex types.\n+\t(build_unary_op): Add REALPART_EXPR and IMAGPART_EXPR cases.\n+\t(convert_for_assignment): Likewise.\n+\t(mark_addressable): Add REALPART_EXPR and IMAGPART_EXPR cases.\n+\n+Mon May 19 12:26:27 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst): Don't pass the MINUS_EXPR for an array domain to\n+\ttsubst_expr, as it might try to do overload resolution.\n+\n Sat May 17 10:48:31 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (instantiate_class_template): Oops.\n@@ -38,10 +126,10 @@ Mon May  5 14:46:53 1997  Jason Merrill  <jason@yorick.cygnus.com>\n Thu May  1 18:26:37 1997  Mike Stump  <mrs@cygnus.com>\n \n \t* except.c (expand_exception_blocks): Ensure that we flow through\n- \tthe end of the exception region for the exception specification.\n-  \tMove exception region for the exception specification in, so that\n- \tit doesn't protect the parm cleanup.  Remove some obsolete code.\n-  \t* decl.c (store_parm_decls): Likewise.\n+\tthe end of the exception region for the exception specification.\n+\tMove exception region for the exception specification in, so that\n+\tit doesn't protect the parm cleanup.  Remove some obsolete code.\n+\t* decl.c (store_parm_decls): Likewise.\n \t(finish_function): Likewise.\n \n Tue Apr 29 15:38:54 1997  Jason Merrill  <jason@yorick.cygnus.com>\n@@ -64,7 +152,7 @@ Fri Apr 25 11:55:23 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \tto -Weffc++.\n \n \t* decl2.c (finish_prevtable_vardecl): Change NO_LINKAGE_HEURISTICS\n- \tto MULTIPLE_SYMBOL_SPACES.\n+\tto MULTIPLE_SYMBOL_SPACES.\n \n Wed Apr 23 18:06:50 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n@@ -89,7 +177,7 @@ Wed Apr 23 14:43:06 1997  Mike Stump  <mrs@cygnus.com>\n \t* exception.cc (__default_terminate): Likewise.\n \n \t* init.c (perform_member_init): Use new method of expr level\n- \tcleanups, instead of cleanups_this_call and friends.\n+\tcleanups, instead of cleanups_this_call and friends.\n \t(emit_base_init): Likewise.\n \t(expand_aggr_vbase_init_1): Likewise.\n \t(expand_vec_init): Likewise.\n@@ -111,7 +199,7 @@ Wed Apr 23 04:12:06 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tree.c (varargs_function_p): New fn.\n \t* method.c (emit_thunk): Replace broken generic code with code to\n- \tgenerate a heavyweight thunk function.\n+\tgenerate a heavyweight thunk function.\n \n Tue Apr 22 02:45:18 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n@@ -124,28 +212,28 @@ Tue Apr 22 02:45:18 1997  Jason Merrill  <jason@yorick.cygnus.com>\n Mon Apr 21 15:42:27 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* class.c (check_for_override): The signature of an overriding\n- \tfunction is not changed.\n+\tfunction is not changed.\n \n \t* call.c (build_over_call): Move setting of conv into the loop.\n \n Sun Apr 20 16:24:29 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (build_user_type_conversion_1): Really ignore rvalue\n- \tconversions when looking for a REFERENCE_TYPE.\n+\tconversions when looking for a REFERENCE_TYPE.\n \n \t* cvt.c (build_up_reference): Eviscerate, use build_unary_op.\n \t* cp-tree.h (TREE_REFERENCE_EXPR): #if 0.\n \t* typeck.c (decay_conversion): Don't set TREE_REFERENCE_EXPR.\n \t(build_unary_op): Likewise.\n \t* call.c (build_over_call): See through a CONVERT_EXPR around the\n- \tADDR_EXPR for on a temporary.\n+\tADDR_EXPR for on a temporary.\n \t* typeck.c (c_expand_return): See through a CONVERT_EXPR around\n- \tthe ADDR_EXPR for a local variable.\n+\tthe ADDR_EXPR for a local variable.\n \n Fri Apr 18 12:11:33 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (build_user_type_conversion_1): If we're trying to\n- \tconvert to a REFERENCE_TYPE, only consider lvalue conversions.\n+\tconvert to a REFERENCE_TYPE, only consider lvalue conversions.\n \t(build_new_function_call): Print candidates.\n \t(implicit_conversion): Try a temp binding if the lvalue conv is BAD.\n \t(reference_binding): Binding a temporary of a reference-related type\n@@ -163,7 +251,7 @@ Mon Apr 14 12:38:17 1997  Jason Merrill  <jason@yorick.cygnus.com>\n Fri Apr 11 02:18:30 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (implicit_conversion): Try to find a reference conversion\n- \tbefore binding a const reference to a temporary.\n+\tbefore binding a const reference to a temporary.\n \n Wed Apr  2 12:51:36 1997  Mike Stump  <mrs@cygnus.com>\n \n@@ -12223,7 +12311,7 @@ Tue Apr  5 17:48:41 1994  Per Bothner  <bothner@kalessin.cygnus.com>\n \t* decl2.c (write_vtable_entries, finish_vtable_typedecl):  Removed.\n \n \t* cp-tree.h, class.c, decl2.c, search.c:  Remove -fvtable-hack\n-\tand flag_vtable_hack.  \tUse -fvtable-thunks and flag_vtable_thunks\n+\tand flag_vtable_hack.  Use -fvtable-thunks and flag_vtable_thunks\n \tinstead.  (The rationale is that these optimizations both break binary\n \tcompatibility, but should become the default in a future release.)\n "}, {"sha": "0e3680750607cf0a2c748cbe268c8052dea8353d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -1448,7 +1448,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n       if (basetype != name && basetype != get_type_value (name))\n \tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  basetype, name);\n-      return convert (void_type_node, exp);\n+      return cp_convert (void_type_node, exp);\n     }\n \n   if (! is_aggr_type (basetype, 1))\n@@ -1494,7 +1494,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n \t      return error_mark_node;\n \t    }\n \t  if (! TYPE_HAS_DESTRUCTOR (TREE_TYPE (decl)))\n-\t    return convert (void_type_node, exp);\n+\t    return cp_convert (void_type_node, exp);\n \t  \n \t  return build_delete (TREE_TYPE (decl), decl, integer_two_node,\n \t\t\t       LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR,\n@@ -1751,11 +1751,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t{\n \t  cp_error (\"destructor name `~%D' does not match type `%T' of expression\",\n \t\t    name, basetype);\n-\t  return convert (void_type_node, instance);\n+\t  return cp_convert (void_type_node, instance);\n \t}\n \n       if (! TYPE_HAS_DESTRUCTOR (basetype))\n-\treturn convert (void_type_node, instance);\n+\treturn cp_convert (void_type_node, instance);\n       instance = default_conversion (instance);\n       instance_ptr = build_unary_op (ADDR_EXPR, instance, 0);\n       return build_delete (build_pointer_type (basetype),\n@@ -1986,7 +1986,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    basetype = inst_ptr_basetype;\n \t  else\n \t    {\n-\t      instance_ptr = convert (build_pointer_type (basetype), instance_ptr);\n+\t      instance_ptr = cp_convert (build_pointer_type (basetype), instance_ptr);\n \t      if (instance_ptr == error_mark_node)\n \t\treturn error_mark_node;\n \t    }\n@@ -4835,6 +4835,8 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     case POSTINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n       return build_unary_op (code, arg1, candidates != 0);\n \n     case ARRAY_REF:\n@@ -4972,8 +4974,8 @@ convert_like (convs, expr)\n     case LVALUE_CONV:\n       return decay_conversion (expr);\n     }\n-  return cp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n-\t\t     LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+  return ocp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n+\t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n }\n \n static tree\n@@ -5125,7 +5127,7 @@ build_over_call (fn, convs, args, flags)\n \t  && (TYPE_PRECISION (TREE_TYPE (val))\n \t      < TYPE_PRECISION (double_type_node)))\n \t/* Convert `float' to `double'.  */\n-\tval = convert (double_type_node, val);\n+\tval = cp_convert (double_type_node, val);\n       else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n \t       && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n \tcp_warning (\"cannot pass objects of type `%T' through `...'\","}, {"sha": "37cdb6b994adb22bd4549a4063962520d6218ad7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -322,8 +322,11 @@ build_vbase_path (code, type, expr, path, alias_this)\n   if (TREE_INT_CST_LOW (offset))\n     {\n       /* Bash types to make the backend happy.  */\n-      offset = convert (type, offset);\n+      offset = cp_convert (type, offset);\n+#if 0\n+      /* This shouldn't be necessary.  (mrs) */\n       expr = build1 (NOP_EXPR, type, expr);\n+#endif\n \n       /* For multiple inheritance: if `this' can be set by any\n \t function, then it could be 0 on entry to any function.\n@@ -518,8 +521,8 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n       *ptr_to_instptr\n \t= build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n \t\t *ptr_to_instptr,\n-\t\t convert (ptrdiff_type_node,\n-\t\t\t  build_component_ref (aref, delta_identifier, NULL_TREE, 0)));\n+\t\t cp_convert (ptrdiff_type_node,\n+\t\t\t     build_component_ref (aref, delta_identifier, NULL_TREE, 0)));\n     }\n \n   return build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n@@ -4630,8 +4633,10 @@ pushclass (type, modify)\n \n   pushlevel_class ();\n \n+#if 0\n   if (CLASSTYPE_TEMPLATE_INFO (type))\n     overload_template_name (type);\n+#endif\n \n   if (modify)\n     {"}, {"sha": "677c0fa9969ceb459ca90a8aafe0483d3632d958", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -135,6 +135,12 @@ extern tree unsigned_type_node;\n extern tree string_type_node, char_array_type_node, int_array_type_node;\n extern tree wchar_array_type_node;\n extern tree wchar_type_node, signed_wchar_type_node, unsigned_wchar_type_node;\n+\n+extern tree complex_integer_type_node;\n+extern tree complex_float_type_node;\n+extern tree complex_double_type_node;\n+extern tree complex_long_double_type_node;\n+\n extern tree intQI_type_node, unsigned_intQI_type_node;\n extern tree intHI_type_node, unsigned_intHI_type_node;\n extern tree intSI_type_node, unsigned_intSI_type_node;\n@@ -1969,7 +1975,8 @@ extern tree convert_from_reference\t\tPROTO((tree));\n extern tree convert_to_aggr\t\t\tPROTO((tree, tree, char **, int));\n extern tree convert_pointer_to_real\t\tPROTO((tree, tree));\n extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n-extern tree cp_convert\t\t\t\tPROTO((tree, tree, int, int));\n+extern tree ocp_convert\t\t\t\tPROTO((tree, tree, int, int));\n+extern tree cp_convert\t\t\t\tPROTO((tree, tree));\n extern tree convert\t\t\t\tPROTO((tree, tree));\n extern tree convert_force\t\t\tPROTO((tree, tree, int));\n extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n@@ -2380,10 +2387,6 @@ extern tree build_cplus_array_type\t\tPROTO((tree, tree));\n extern void propagate_binfo_offsets\t\tPROTO((tree, tree));\n extern int layout_vbasetypes\t\t\tPROTO((tree, int));\n extern tree layout_basetypes\t\t\tPROTO((tree, tree));\n-extern int list_hash\t\t\t\tPROTO((tree));\n-extern tree list_hash_lookup\t\t\tPROTO((int, tree));\n-extern void list_hash_add\t\t\tPROTO((int, tree));\n-extern tree list_hash_canon\t\t\tPROTO((int, tree));\n extern tree hash_tree_cons\t\t\tPROTO((int, int, int, tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n extern tree hash_chainon\t\t\tPROTO((tree, tree));"}, {"sha": "26e388d7d37432767e9c364ffec1c8ba4259dc06", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 91, "deletions": 13, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -283,7 +283,7 @@ cp_convert_to_pointer (type, expr)\n     {\n       if (type_precision (intype) == POINTER_SIZE)\n \treturn build1 (CONVERT_EXPR, type, expr);\n-      expr = convert (type_for_size (POINTER_SIZE, 0), expr);\n+      expr = cp_convert (type_for_size (POINTER_SIZE, 0), expr);\n       /* Modes may be different but sizes should be the same.  */\n       if (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr)))\n \t  != GET_MODE_SIZE (TYPE_MODE (type)))\n@@ -606,7 +606,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \trval = rval_as_conversion;\n       else if (! IS_AGGR_TYPE (type) && ! IS_AGGR_TYPE (intype))\n \t{\n-\t  rval = convert (type, expr);\n+\t  rval = cp_convert (type, expr);\n \t  if (rval == error_mark_node)\n \t    return error_mark_node;\n \t  \n@@ -922,12 +922,21 @@ convert_pointer_to (binfo, expr)\n   return convert_pointer_to_real (type, expr);\n }\n \f\n+/* C++ conversions, preference to static cast conversions.  */\n+\n+tree\n+cp_convert (type, expr)\n+     tree type, expr;\n+{\n+  return ocp_convert (type, expr, CONV_OLD_CONVERT, LOOKUP_NORMAL);\n+}\n+\n /* Conversion...\n \n    FLAGS indicates how we should behave.  */\n \n tree\n-cp_convert (type, expr, convtype, flags)\n+ocp_convert (type, expr, convtype, flags)\n      tree type, expr;\n      int convtype, flags;\n {\n@@ -951,7 +960,7 @@ cp_convert (type, expr, convtype, flags)\n   /* This is incorrect.  A truncation can't be stripped this way.\n      Extensions will be stripped by the use of get_unwidened.  */\n   if (TREE_CODE (e) == NOP_EXPR)\n-    return convert (type, TREE_OPERAND (e, 0));\n+    return cp_convert (type, TREE_OPERAND (e, 0));\n #endif\n \n   /* Just convert to the type of the member.  */\n@@ -1014,7 +1023,7 @@ cp_convert (type, expr, convtype, flags)\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE\n       || TYPE_PTRMEMFUNC_P (type))\n     return fold (cp_convert_to_pointer (type, e));\n-  if (code == REAL_TYPE)\n+  if (code == REAL_TYPE || code == COMPLEX_TYPE)\n     {\n       if (IS_AGGR_TYPE (TREE_TYPE (e)))\n \t{\n@@ -1027,7 +1036,10 @@ cp_convert (type, expr, convtype, flags)\n \t      cp_error (\"`%#T' used where a floating point value was expected\",\n \t\t\tTREE_TYPE (e));\n \t}\n-      return fold (convert_to_real (type, e));\n+      if (code == REAL_TYPE)\n+\treturn fold (convert_to_real (type, e));\n+      else if (code == COMPLEX_TYPE)\n+\treturn fold (convert_to_complex (type, e));\n     }\n \n   /* New C++ semantics:  since assignment is now based on\n@@ -1155,16 +1167,82 @@ cp_convert (type, expr, convtype, flags)\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n    conversions; callers should filter out those that are\n-   not permitted by the language being compiled.  */\n+   not permitted by the language being compiled.\n+\n+   Most of this routine is from build_reinterpret_cast.\n+\n+   The backend cannot call cp_convert (what was convert) because\n+   conversions to/from basetypes may involve memory references\n+   (vbases) and adding or subtracting small values (multiple\n+   inheritance), but it calls convert from the constant folding code\n+   on subtrees of already build trees after it has ripped them apart.\n+\n+   Also, if we ever support range variables, we'll probably also have to\n+   do a little bit more work.  */\n \n tree\n convert (type, expr)\n      tree type, expr;\n {\n-  return cp_convert (type, expr, CONV_OLD_CONVERT, LOOKUP_NORMAL);\n+  tree intype;\n+\n+  if (type == error_mark_node || expr == error_mark_node)\n+    return error_mark_node;\n+\n+  if (TREE_TYPE (expr) == type)\n+    return expr;\n+\n+  if (TREE_CODE (type) != REFERENCE_TYPE)\n+    {\n+      expr = decay_conversion (expr);\n+\n+      /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n+\t Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n+      if (TREE_CODE (expr) == NOP_EXPR\n+\t  && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\texpr = TREE_OPERAND (expr, 0);\n+    }\n+\n+  intype = TREE_TYPE (expr);\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      expr = build_unary_op (ADDR_EXPR, expr, 0);\n+      if (expr != error_mark_node)\n+\texpr = convert (build_pointer_type (TREE_TYPE (type)), expr);\n+      if (expr != error_mark_node)\n+\texpr = build_indirect_ref (expr, 0);\n+      return expr;\n+    }\n+  else if (comptypes (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type), 1))\n+    return build_static_cast (type, expr);\n+\n+  if (TYPE_PTR_P (type) && (TREE_CODE (intype) == INTEGER_TYPE\n+\t\t\t    || TREE_CODE (intype) == ENUMERAL_TYPE))\n+    /* OK */;\n+  else if (TREE_CODE (type) == INTEGER_TYPE && TYPE_PTR_P (intype))\n+    {\n+    }\n+  else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n+\t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n+    {\n+      if (TREE_READONLY_DECL_P (expr))\n+\texpr = decl_constant_value (expr);\n+      return fold (build1 (NOP_EXPR, type, expr));\n+    }\n+  else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+\t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n+    {\n+      if (TREE_READONLY_DECL_P (expr))\n+\texpr = decl_constant_value (expr);\n+      return fold (build1 (NOP_EXPR, type, expr));\n+    }\n+\n+  return ocp_convert (type, expr, CONV_OLD_CONVERT,\n+\t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n }\n \n-/* Like convert, except permit conversions to take place which\n+/* Like cp_convert, except permit conversions to take place which\n    are not normally allowed due to access restrictions\n    (such as conversion from sub-type to private super-type).  */\n \n@@ -1198,7 +1276,7 @@ convert_force (type, expr, convtype)\n       return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n     }\n \n-  return cp_convert (type, e, CONV_C_CAST|convtype, LOOKUP_NORMAL);\n+  return ocp_convert (type, e, CONV_C_CAST|convtype, LOOKUP_NORMAL);\n }\n \n /* Subroutine of build_type_conversion.  */\n@@ -1234,7 +1312,7 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n       && (TREE_READONLY (TREE_TYPE (TREE_TYPE (rval)))\n \t  > TREE_READONLY (TREE_TYPE (xtype))))\n     warning (\"user-defined conversion casting away `const'\");\n-  return convert (xtype, rval);\n+  return cp_convert (xtype, rval);\n }\n \n /* Convert an aggregate EXPR to type XTYPE.  If a conversion\n@@ -1539,8 +1617,8 @@ build_default_binary_type_conversion (code, arg1, arg2)\n \n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-      *arg1 = convert (boolean_type_node, *arg1);\n-      *arg2 = convert (boolean_type_node, *arg2);\n+      *arg1 = cp_convert (boolean_type_node, *arg1);\n+      *arg2 = cp_convert (boolean_type_node, *arg2);\n       break;\n \n     default:"}, {"sha": "41e6c1507443fcfa969ec87230424b79817ab8f4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 70, "deletions": 10, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -169,6 +169,11 @@ tree float_type_node;\n tree double_type_node;\n tree long_double_type_node;\n \n+tree complex_integer_type_node;\n+tree complex_float_type_node;\n+tree complex_double_type_node;\n+tree complex_long_double_type_node;\n+\n tree intQI_type_node;\n tree intHI_type_node;\n tree intSI_type_node;\n@@ -4805,6 +4810,30 @@ init_decl_processing ()\n   record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n   layout_type (long_double_type_node);\n \n+  complex_integer_type_node = make_node (COMPLEX_TYPE);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n+\t\t\tcomplex_integer_type_node));\n+  TREE_TYPE (complex_integer_type_node) = integer_type_node;\n+  layout_type (complex_integer_type_node);\n+\n+  complex_float_type_node = make_node (COMPLEX_TYPE);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n+\t\t\tcomplex_float_type_node));\n+  TREE_TYPE (complex_float_type_node) = float_type_node;\n+  layout_type (complex_float_type_node);\n+\n+  complex_double_type_node = make_node (COMPLEX_TYPE);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n+\t\t\tcomplex_double_type_node));\n+  TREE_TYPE (complex_double_type_node) = double_type_node;\n+  layout_type (complex_double_type_node);\n+\n+  complex_long_double_type_node = make_node (COMPLEX_TYPE);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n+\t\t\tcomplex_long_double_type_node));\n+  TREE_TYPE (complex_long_double_type_node) = long_double_type_node;\n+  layout_type (complex_long_double_type_node);\n+\n   integer_zero_node = build_int_2 (0, 0);\n   TREE_TYPE (integer_zero_node) = integer_type_node;\n   integer_one_node = build_int_2 (1, 0);\n@@ -7105,9 +7134,7 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \n       if (check == 0 && ! current_function_decl)\n \t{\n-\t  /* FIXME: this should only need to look at\n-             IDENTIFIER_GLOBAL_VALUE.  */\n-\t  tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n+\t  tmp = IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl));\n \t  if (tmp == NULL_TREE)\n \t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n \t  else if (TREE_CODE (tmp) != TREE_CODE (decl))\n@@ -7379,6 +7406,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   int virtualp, explicitp, friendp, inlinep, staticp;\n   int explicit_int = 0;\n   int explicit_char = 0;\n+  int defaulted_int = 0;\n   int opaque_typedef = 0;\n   tree typedef_decl = NULL_TREE;\n   char *name;\n@@ -7808,7 +7836,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   typedef_type = type;\n \n-  /* No type at all: default to `int', and set EXPLICIT_INT\n+  /* No type at all: default to `int', and set DEFAULTED_INT\n      because it was not a user-defined typedef.\n      Except when we have a `typedef' inside a signature, in\n      which case the type defaults to `unknown type' and is\n@@ -7822,7 +7850,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n     {\n       /* These imply 'int'.  */\n       type = integer_type_node;\n-      explicit_int = 1;\n+      defaulted_int = 1;\n     }\n \n   if (type == NULL_TREE)\n@@ -7928,7 +7956,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       else\n \t{\n \t  ok = 1;\n-\t  if (!explicit_int && !explicit_char && pedantic)\n+\t  if (!explicit_int && !defaulted_int && !explicit_char && pedantic)\n \t    {\n \t      pedwarn (\"long, short, signed or unsigned used invalidly for `%s'\",\n \t\t       name);\n@@ -7948,11 +7976,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t}\n     }\n \n+  if (RIDBIT_SETP (RID_COMPLEX, specbits)\n+      && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n+    {\n+      error (\"complex invalid for `%s'\", name);\n+      RIDBIT_RESET (RID_COMPLEX, specbits);\n+    }\n+\n   /* Decide whether an integer type is signed or not.\n      Optionally treat bitfields as signed by default.  */\n   if (RIDBIT_SETP (RID_UNSIGNED, specbits)\n       || (bitfield && ! flag_signed_bitfields\n-\t  && (explicit_int || explicit_char\n+\t  && (explicit_int || defaulted_int || explicit_char\n \t      /* A typedef for plain `int' without `signed'\n \t\t can be controlled just like plain `int'.  */\n \t      || ! (typedef_decl != NULL_TREE\n@@ -7983,6 +8018,31 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   else if (RIDBIT_SETP (RID_SHORT, specbits))\n     type = short_integer_type_node;\n \n+  if (RIDBIT_SETP (RID_COMPLEX, specbits))\n+    {\n+      /* If we just have \"complex\", it is equivalent to\n+\t \"complex double\", but if any modifiers at all are specified it is\n+\t the complex form of TYPE.  E.g, \"complex short\" is\n+\t \"complex short int\".  */\n+\n+      if (defaulted_int && ! longlong\n+\t  && ! (RIDBIT_SETP (RID_LONG, specbits)\n+\t\t|| RIDBIT_SETP (RID_SHORT, specbits)\n+\t\t|| RIDBIT_SETP (RID_SIGNED, specbits)\n+\t\t|| RIDBIT_SETP (RID_UNSIGNED, specbits)))\n+\ttype = complex_double_type_node;\n+      else if (type == integer_type_node)\n+\ttype = complex_integer_type_node;\n+      else if (type == float_type_node)\n+\ttype = complex_float_type_node;\n+      else if (type == double_type_node)\n+\ttype = complex_double_type_node;\n+      else if (type == long_double_type_node)\n+\ttype = complex_long_double_type_node;\n+      else\n+\ttype = build_complex_type (type);\n+    }\n+\n   /* Set CONSTP if this declaration is `const', whether by\n      explicit specification or via a typedef.\n      Likewise for VOLATILEP.  */\n@@ -8353,9 +8413,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t\titype\n \t\t  = fold (build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t   convert (index_type, size),\n-\t\t\t\t\t   convert (index_type,\n-\t\t\t\t\t\t    integer_one_node), 1));\n+\t\t\t\t\t   cp_convert (index_type, size),\n+\t\t\t\t\t   cp_convert (index_type,\n+\t\t\t\t\t\t       integer_one_node), 1));\n \t\tif (! TREE_CONSTANT (itype))\n \t\t  itype = variable_size (itype);\n \t\telse if (TREE_OVERFLOW (itype))"}, {"sha": "e8eac164e1ed7e760be3025688b998e3d7a37096", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -197,6 +197,11 @@ dump_type (t, v)\n       dump_decl (t, v);\n       break;\n \n+    case COMPLEX_TYPE:\n+      OB_PUTS (\"complex \");\n+      dump_type (TREE_TYPE (t), v);\n+      break;\n+\n     case INTEGER_TYPE:\n       if (!TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && TREE_UNSIGNED (t))\n \tOB_PUTS (\"unsigned \");\n@@ -435,6 +440,7 @@ dump_type_prefix (t, v)\n     case UNKNOWN_TYPE:\n     case VOID_TYPE:\n     case TYPENAME_TYPE:\n+    case COMPLEX_TYPE:\n       dump_type (t, v);\n       break;\n       \n@@ -516,6 +522,7 @@ dump_type_suffix (t, v)\n     case UNKNOWN_TYPE:\n     case VOID_TYPE:\n     case TYPENAME_TYPE:\n+    case COMPLEX_TYPE:\n       break;\n \n     default:"}, {"sha": "d9cad4a6255bfd74c45b73d144dac02b690af96c", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -9,13 +9,19 @@ __asm, GCC_ASM_KEYWORD, NORID\n __asm__, GCC_ASM_KEYWORD, NORID\n __attribute, ATTRIBUTE, NORID\n __attribute__, ATTRIBUTE, NORID\n+__complex, TYPESPEC, RID_COMPLEX\n+__complex__, TYPESPEC, RID_COMPLEX\n __const, CV_QUALIFIER, RID_CONST\n __const__, CV_QUALIFIER, RID_CONST\n __extension__, EXTENSION, NORID\n+__imag, IMAGPART, NORID\n+__imag__, IMAGPART, NORID\n __inline, SCSPEC, RID_INLINE\n __inline__, SCSPEC, RID_INLINE\n __label__, LABEL, NORID\n __null, CONSTANT, RID_NULL\n+__real, REALPART, NORID\n+__real__, REALPART, NORID\n __signature__, AGGR, RID_SIGNATURE\t/* Extension */,\n __signed, TYPESPEC, RID_SIGNED\n __signed__, TYPESPEC, RID_SIGNED"}, {"sha": "720890fd4c883168b79a527213dbabb44de8118d", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 124, "deletions": 110, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -1,14 +1,13 @@\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../devo/gcc/cp/gxx.gperf  */\n-/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gxx.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 97\n+#define TOTAL_KEYWORDS 103\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 202\n-/* maximum key range = 199, duplicates = 0 */\n+#define MAX_HASH_VALUE 195\n+/* maximum key range = 192, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -20,19 +19,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n-     203, 203, 203, 203, 203,   0, 203,  29,  22,  32,\n-      35,   0,  73,   8,  19,  48, 203,   0,   7,  15,\n-      11,  66,   9,  11,  19,  58,   1,   7,  83,  21,\n-      89,   5, 203, 203, 203, 203, 203, 203,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196, 196, 196, 196, 196, 196,\n+     196, 196, 196, 196, 196,   0, 196,  80,  26,  28,\n+      44,   0,  49,  38,   6,  81, 196,   2,   0,  41,\n+      16,  47,   4,  31,  32,   5,   6,  62,  20,  96,\n+      17,  25, 196, 196, 196, 196, 196, 196,\n     };\n   register int hval = len;\n \n@@ -66,133 +65,148 @@ is_reserved_word (str, len)\n     {\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"else\",  ELSE, NORID,},\n+      {\"\",}, \n+      {\"__real\",  REALPART, NORID},\n+      {\"\",}, \n+      {\"__real__\",  REALPART, NORID},\n+      {\"\",}, \n       {\"true\",  CXX_TRUE, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"try\",  TRY, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"not\",  '!', NORID,},\n       {\"\",}, \n-      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"this\",  THIS, NORID,},\n       {\"\",}, \n+      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"switch\",  SWITCH, NORID,},\n       {\"template\",  TEMPLATE, RID_TEMPLATE,},\n-      {\"__null\",  CONSTANT, RID_NULL},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"long\",  TYPESPEC, RID_LONG,},\n-      {\"not_eq\",  EQCOMPARE, NORID,},\n+      {\"not\",  '!', NORID,},\n+      {\"\",}, \n       {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"\",}, \n+      {\"bool\",  TYPESPEC, RID_BOOL,},\n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n+      {\"case\",  CASE, NORID,},\n+      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n+      {\"try\",  TRY, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"compl\",  '~', NORID,},\n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"\",}, \n       {\"__inline\",  SCSPEC, RID_INLINE},\n-      {\"using\",  USING, NORID,},\n+      {\"\",}, \n       {\"__inline__\",  SCSPEC, RID_INLINE},\n-      {\"while\",  WHILE, NORID,},\n-      {\"enum\",  ENUM, NORID,},\n-      {\"new\",  NEW, NORID,},\n-      {\"case\",  CASE, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"bool\",  TYPESPEC, RID_BOOL,},\n+      {\"class\",  AGGR, RID_CLASS,},\n+      {\"const\",  CV_QUALIFIER, RID_CONST,},\n+      {\"static\",  SCSPEC, RID_STATIC,},\n+      {\"__extension__\",  EXTENSION, NORID},\n+      {\"\",}, \n+      {\"short\",  TYPESPEC, RID_SHORT,},\n+      {\"__imag__\",  IMAGPART, NORID},\n       {\"delete\",  DELETE, NORID,},\n+      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n+      {\"xor\",  '^', NORID,},\n+      {\"not_eq\",  EQCOMPARE, NORID,},\n+      {\"xor_eq\",  ASSIGN, NORID,},\n+      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n       {\"typeid\",  TYPEID, NORID,},\n-      {\"return\",  RETURN, NORID,},\n       {\"\",}, \n-      {\"__label__\",  LABEL, NORID},\n-      {\"and_eq\",  ASSIGN, NORID,},\n-      {\"asm\",  ASM_KEYWORD, NORID,},\n-      {\"continue\",  CONTINUE, NORID,},\n-      {\"namespace\",  NAMESPACE, NORID,},\n+      {\"__complex__\",  TYPESPEC, RID_COMPLEX},\n+      {\"false\",  CXX_FALSE, NORID,},\n+      {\"sizeof\",  SIZEOF, NORID,},\n+      {\"typeof\",  TYPEOF, NORID,},\n+      {\"__const__\",  CV_QUALIFIER, RID_CONST},\n+      {\"__volatile\",  CV_QUALIFIER, RID_VOLATILE},\n       {\"\",}, \n-      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n-      {\"int\",  TYPESPEC, RID_INT,},\n-      {\"compl\",  '~', NORID,},\n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"__volatile__\",  CV_QUALIFIER, RID_VOLATILE},\n+      {\"__const\",  CV_QUALIFIER, RID_CONST},\n+      {\"catch\",  CATCH, NORID,},\n+      {\"__null\",  CONSTANT, RID_NULL},\n       {\"protected\",  VISSPEC, RID_PROTECTED,},\n-      {\"break\",  BREAK, NORID,},\n       {\"\",}, \n-      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+      {\"signed\",  TYPESPEC, RID_SIGNED,},\n       {\"\",}, \n-      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"__complex\",  TYPESPEC, RID_COMPLEX},\n+      {\"__alignof\",  ALIGNOF, NORID},\n       {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"__attribute__\",  ATTRIBUTE, NORID},\n       {\"double\",  TYPESPEC, RID_DOUBLE,},\n-      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n-      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n-      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n-      {\"and\",  ANDAND, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"const_cast\",  CONST_CAST, NORID,},\n+      {\"\",}, \n       {\"struct\",  AGGR, RID_RECORD,},\n-      {\"default\",  DEFAULT, NORID,},\n-      {\"char\",  TYPESPEC, RID_CHAR,},\n-      {\"__const\",  CV_QUALIFIER, RID_CONST},\n-      {\"__const__\",  CV_QUALIFIER, RID_CONST},\n-      {\"__volatile\",  CV_QUALIFIER, RID_VOLATILE},\n-      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n-      {\"__volatile__\",  CV_QUALIFIER, RID_VOLATILE},\n-      {\"typeof\",  TYPEOF, NORID,},\n+      {\"long\",  TYPESPEC, RID_LONG,},\n+      {\"or\",  OROR, NORID,},\n       {\"__typeof__\",  TYPEOF, NORID},\n       {\"or_eq\",  ASSIGN, NORID,},\n-      {\"short\",  TYPESPEC, RID_SHORT,},\n-      {\"switch\",  SWITCH, NORID,},\n+      {\"for\",  FOR, NORID,},\n+      {\"__imag\",  IMAGPART, NORID},\n+      {\"enum\",  ENUM, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"__label__\",  LABEL, NORID},\n+      {\"int\",  TYPESPEC, RID_INT,},\n+      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n       {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"do\",  DO, NORID,},\n       {\"\",}, \n-      {\"or\",  OROR, NORID,},\n-      {\"catch\",  CATCH, NORID,},\n-      {\"union\",  AGGR, RID_UNION,},\n-      {\"__signature__\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"bitand\",  '&', NORID,},\n-      {\"throw\",  THROW, NORID,},\n-      {\"register\",  SCSPEC, RID_REGISTER,},\n-      {\"for\",  FOR, NORID,},\n-      {\"const\",  CV_QUALIFIER, RID_CONST,},\n-      {\"static\",  SCSPEC, RID_STATIC,},\n-      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n-      {\"private\",  VISSPEC, RID_PRIVATE,},\n-      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n+      {\"char\",  TYPESPEC, RID_CHAR,},\n       {\"\",}, \n-      {\"inline\",  SCSPEC, RID_INLINE,},\n-      {\"do\",  DO, NORID,},\n+      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"while\",  WHILE, NORID,},\n+      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n       {\"\",}, \n-      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n-      {\"xor_eq\",  ASSIGN, NORID,},\n+      {\"continue\",  CONTINUE, NORID,},\n+      {\"namespace\",  NAMESPACE, NORID,},\n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"\",}, \n+      {\"volatile\",  CV_QUALIFIER, RID_VOLATILE,},\n       {\"\",}, \n-      {\"float\",  TYPESPEC, RID_FLOAT,},\n-      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n-      {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"xor\",  '^', NORID,},\n       {\"bitor\",  '|', NORID,},\n-      {\"__extension__\",  EXTENSION, NORID},\n-      {\"friend\",  SCSPEC, RID_FRIEND,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"this\",  THIS, NORID,},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"break\",  BREAK, NORID,},\n       {\"\",}, \n-      {\"if\",  IF, NORID,},\n+      {\"new\",  NEW, NORID,},\n+      {\"return\",  RETURN, NORID,},\n+      {\"and_eq\",  ASSIGN, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"volatile\",  CV_QUALIFIER, RID_VOLATILE,},\n+      {\"using\",  USING, NORID,},\n       {\"\",}, {\"\",}, \n-      {\"__sigof__\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"asm\",  ASM_KEYWORD, NORID,},\n       {\"\",}, {\"\",}, \n-      {\"const_cast\",  CONST_CAST, NORID,},\n+      {\"and\",  ANDAND, NORID,},\n+      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"union\",  AGGR, RID_UNION,},\n+      {\"\",}, \n+      {\"if\",  IF, NORID,},\n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n       {\"\",}, {\"\",}, \n-      {\"false\",  CXX_FALSE, NORID,},\n-      {\"sizeof\",  SIZEOF, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"goto\",  GOTO, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__typeof\",  TYPEOF, NORID},\n-      {\"class\",  AGGR, RID_CLASS,},\n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n       {\"\",}, {\"\",}, \n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"__sigof__\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"\",}, {\"\",}, \n+      {\"default\",  DEFAULT, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"operator\",  OPERATOR, NORID,},\n+      {\"register\",  SCSPEC, RID_REGISTER,},\n+      {\"throw\",  THROW, NORID,},\n+      {\"\",}, \n+      {\"bitand\",  '&', NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"operator\",  OPERATOR, NORID,},\n+      {\"\",}, \n+      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"\",}, \n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"__signature__\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"auto\",  SCSPEC, RID_AUTO,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "378629c78473df04ffd790d9fc30e45ba0572ce5", "filename": "gcc/cp/init.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -1252,7 +1252,7 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n \t via the copy constructor, even if the call is elided.  */\n       if (! (TREE_CODE (exp) == VAR_DECL && DECL_ARTIFICIAL (exp)\n \t     && TREE_CODE (init) == TARGET_EXPR && TREE_TYPE (init) == type))\n-\tinit = cp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n+\tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n       expand_assignment (exp, init, 0, 0);\n       return;\n@@ -1512,7 +1512,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t  if (init_list && TREE_CHAIN (init_list))\n \t    {\n \t      warning (\"initializer list being treated as compound expression\");\n-\t      init = convert (type, build_compound_expr (init_list));\n+\t      init = cp_convert (type, build_compound_expr (init_list));\n \t      if (init == error_mark_node)\n \t\treturn;\n \t    }\n@@ -2101,14 +2101,14 @@ resolve_offset_ref (exp)\n \n       basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (member));\n       addr = convert_pointer_to (basetype, addr);\n-      member = convert (ptrdiff_type_node,\n-\t\t\tbuild_unary_op (ADDR_EXPR, member, 0));\n+      member = cp_convert (ptrdiff_type_node,\n+\t\t\t   build_unary_op (ADDR_EXPR, member, 0));\n       \n       /* Pointer to data mebers are offset by one, so that a null\n \t pointer with a real value of 0 is distinguishable from an\n \t offset of the first member of a structure.  */\n       member = build_binary_op (MINUS_EXPR, member,\n-\t\t\t\tconvert (ptrdiff_type_node, integer_one_node),\n+\t\t\t\tcp_convert (ptrdiff_type_node, integer_one_node),\n \t\t\t\t0);\n \n       return build1 (INDIRECT_REF, type,\n@@ -2269,7 +2269,7 @@ build_new (placement, decl, init, use_global_new)\n \t\t}\n \t      else\n \t\t{\n-\t\t  this_nelts = save_expr (convert (sizetype, this_nelts));\n+\t\t  this_nelts = save_expr (cp_convert (sizetype, this_nelts));\n \t\t  absdcl = TREE_OPERAND (absdcl, 0);\n \t          if (this_nelts == integer_zero_node)\n \t\t    {\n@@ -2464,7 +2464,7 @@ build_new (placement, decl, init, use_global_new)\n     {\n       rval = build_opfncall (code, LOOKUP_GLOBAL|LOOKUP_COMPLAIN,\n \t\t\t     ptr_type_node, size, placement);\n-      rval = convert (build_pointer_type (true_type), rval);\n+      rval = cp_convert (build_pointer_type (true_type), rval);\n     }\n   else if (! has_array && flag_this_is_variable > 0\n \t   && TYPE_NEEDS_CONSTRUCTING (true_type) && init != void_type_node)\n@@ -2498,8 +2498,8 @@ build_new (placement, decl, init, use_global_new)\n     {\n       tree extra = BI_header_size;\n       tree cookie, exp1;\n-      rval = convert (ptr_type_node, rval);    /* convert to void * first */\n-      rval = convert (string_type_node, rval); /* lets not add void* and ints */\n+      rval = cp_convert (ptr_type_node, rval);    /* convert to void * first */\n+      rval = cp_convert (string_type_node, rval); /* lets not add void* and ints */\n       rval = save_expr (build_binary_op (PLUS_EXPR, rval, extra, 1));\n       /* Store header info.  */\n       cookie = build_indirect_ref (build (MINUS_EXPR, build_pointer_type (BI_header_type),\n@@ -2508,7 +2508,7 @@ build_new (placement, decl, init, use_global_new)\n \t\t    build_component_ref (cookie, nc_nelts_field_id, NULL_TREE, 0),\n \t\t    nelts);\n       TREE_SIDE_EFFECTS (exp1) = 1;\n-      rval = convert (build_pointer_type (true_type), rval);\n+      rval = cp_convert (build_pointer_type (true_type), rval);\n       TREE_CALLS_NEW (rval) = 1;\n       TREE_SIDE_EFFECTS (rval) = 1;\n       rval = build_compound_expr (tree_cons (NULL_TREE, exp1,\n@@ -2751,11 +2751,11 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n   if (auto_delete != integer_zero_node\n       && auto_delete != integer_two_node)\n     {\n-      tree base_tbd = convert (ptype,\n-\t\t\t       build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\tconvert (ptr_type_node, base),\n-\t\t\t\t\t\tBI_header_size,\n-\t\t\t\t\t\t1));\n+      tree base_tbd = cp_convert (ptype,\n+\t\t\t\t  build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\t   cp_convert (ptr_type_node, base),\n+\t\t\t\t\t\t   BI_header_size,\n+\t\t\t\t\t\t   1));\n       /* This is the real size */\n       virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n       body = build_tree_list (NULL_TREE,\n@@ -2808,11 +2808,11 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \tbase_tbd = base;\n       else\n \t{\n-\t  base_tbd = convert (ptype,\n-\t\t\t      build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t       convert (string_type_node, base),\n-\t\t\t\t\t       BI_header_size,\n-\t\t\t\t\t       1));\n+\t  base_tbd = cp_convert (ptype,\n+\t\t\t\t build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\t  cp_convert (string_type_node, base),\n+\t\t\t\t\t\t  BI_header_size,\n+\t\t\t\t\t\t  1));\n \t  /* True size with header.  */\n \t  virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n \t}\n@@ -2847,7 +2847,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n       return controller;\n     }\n   else\n-    return convert (void_type_node, body);\n+    return cp_convert (void_type_node, body);\n }\n \n /* Build a tree to cleanup partially built arrays.\n@@ -2891,7 +2891,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n   tree type = TREE_TYPE (TREE_TYPE (base));\n   tree size;\n \n-  maxindex = convert (ptrdiff_type_node, maxindex);\n+  maxindex = cp_convert (ptrdiff_type_node, maxindex);\n   if (maxindex == error_mark_node)\n     return error_mark_node;\n \n@@ -2909,9 +2909,9 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n   /* Set to zero in case size is <= 0.  Optimizer will delete this if\n      it is not needed.  */\n   rval = get_temp_regvar (build_pointer_type (type),\n-\t\t\t  convert (build_pointer_type (type), null_pointer_node));\n+\t\t\t  cp_convert (build_pointer_type (type), null_pointer_node));\n   base = default_conversion (base);\n-  base = convert (build_pointer_type (type), base);\n+  base = cp_convert (build_pointer_type (type), base);\n   expand_assignment (rval, base, 0, 0);\n   base = get_temp_regvar (build_pointer_type (type), base);\n "}, {"sha": "11f0db28cb8e78a0c0fadee465858bff6c81cc92", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -33,14 +33,14 @@ Boston, MA 02111-1307, USA.  */\n \t%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} %{MG}\\\n \t-undef -D__GNUC__=%v1 -D__GNUG__=%v1 -D__cplusplus -D__GNUC_MINOR__=%v2\\\n \t%{ansi:-trigraphs -$ -D__STRICT_ANSI__} %{!undef:%{!ansi:%p} %P}\\\n-        %c %{O*:%{!O0:-D__OPTIMIZE__}} %{traditional} %{ftraditional:-traditional}\\\n-        %{traditional-cpp:-traditional} %{trigraphs}\\\n+\t%{!fno-exceptions:-D__EXCEPTIONS}\\\n+        %c %{O*:%{!O0:-D__OPTIMIZE__}} %{trigraphs}\\\n \t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\\\n         %i %{!M:%{!MM:%{!E:%{!pipe:%g.ii}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\",\n    \"%{!M:%{!MM:%{!E:cc1plus %{!pipe:%g.ii} %1 %2\\\n \t\t\t    %{!Q:-quiet} -dumpbase %b.cc %{d*} %{m*} %{a}\\\n \t\t\t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\\\n-\t\t\t    %{traditional} %{v:-version} %{pg:-p} %{p}\\\n+\t\t\t    %{v:-version} %{pg:-p} %{p}\\\n \t\t\t    %{f*} %{+e*} %{aux-info*}\\\n \t\t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}}|\\n\\\n@@ -51,7 +51,7 @@ Boston, MA 02111-1307, USA.  */\n   {\"@c++-cpp-output\",\n    \"%{!M:%{!MM:%{!E:cc1plus %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n \t\t\t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\\\n-\t\t\t    %{traditional} %{v:-version} %{pg:-p} %{p}\\\n+\t\t\t    %{v:-version} %{pg:-p} %{p}\\\n \t\t\t    %{f*} %{+e*} %{aux-info*}\\\n \t\t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\"}, {"sha": "39f41cbc5e03646944951b949e2efa9bfd2f4dbc", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 139, "deletions": 86, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -639,6 +639,9 @@ init_lex ()\n   ridpointers[(int) RID_REGISTER] = get_identifier (\"register\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_REGISTER],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_REGISTER]));\n+  ridpointers[(int) RID_COMPLEX] = get_identifier (\"complex\");\n+  SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_COMPLEX],\n+\t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_COMPLEX]));\n \n   /* C++ extensions. These are probably not correctly named.  */\n   ridpointers[(int) RID_WCHAR] = get_identifier (\"__wchar_t\");\n@@ -806,6 +809,8 @@ init_lex ()\n       UNSET_RESERVED_WORD (\"signature\");\n       UNSET_RESERVED_WORD (\"sigof\");\n     }\n+  if (flag_no_gnu_keywords)\n+    UNSET_RESERVED_WORD (\"complex\");\n   if (flag_no_asm || flag_no_gnu_keywords)\n     UNSET_RESERVED_WORD (\"typeof\");\n   if (! flag_operator_names)\n@@ -2861,7 +2866,7 @@ real_yylex ()\n \t\t  p = extend_token_buffer (p);\n \n \t\t*p++ = c;\n-\t\tc = getc (finput);\n+\t\tc = getch (finput);\n \t      }\n \n \t    if (linemode && c == '\\n')\n@@ -3148,12 +3153,12 @@ real_yylex ()\n \tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS} floatflag\n \t  = NOT_FLOAT;\n \n-\tp = token_buffer;\n-\t*p++ = c;\n-\n \tfor (count = 0; count < TOTAL_PARTS; count++)\n \t  parts[count] = 0;\n \n+\tp = token_buffer;\n+\t*p++ = c;\n+\n \tif (c == '0')\n \t  {\n \t    *p++ = (c = getch ());\n@@ -3177,16 +3182,23 @@ real_yylex ()\n \twhile (c == '.'\n \t       || (isalnum (c) && (c != 'l') && (c != 'L')\n \t\t   && (c != 'u') && (c != 'U')\n+\t\t   && c != 'i' && c != 'I' && c != 'j' && c != 'J'\n \t\t   && (floatflag == NOT_FLOAT || ((c != 'f') && (c != 'F')))))\n \t  {\n \t    if (c == '.')\n \t      {\n \t\tif (base == 16)\n \t\t  error (\"floating constant may not be in radix 16\");\n-\t\tif (floatflag == AFTER_POINT)\n+\t\tif (floatflag == TOO_MANY_POINTS)\n+\t\t  /* We have already emitted an error.  Don't need another.  */\n+\t\t  ;\n+\t\telse if (floatflag == AFTER_POINT)\n \t\t  {\n \t\t    error (\"malformed floating constant\");\n \t\t    floatflag = TOO_MANY_POINTS;\n+\t\t    /* Avoid another error from atof by forcing all characters\n+\t\t       from here on to be ignored.  */\n+\t\t    p[-1] = '\\0';\n \t\t  }\n \t\telse\n \t\t  floatflag = AFTER_POINT;\n@@ -3286,9 +3298,8 @@ real_yylex ()\n \tif (floatflag != NOT_FLOAT)\n \t  {\n \t    tree type = double_type_node;\n-\t    char f_seen = 0;\n-\t    char l_seen = 0;\n-\t    int garbage_chars = 0;\n+\t    int exceeds_double = 0;\n+\t    int imag = 0;\n \t    REAL_VALUE_TYPE value;\n \t    jmp_buf handler;\n \n@@ -3327,76 +3338,117 @@ real_yylex ()\n \t      }\n \t    else\n \t      {\n+\t\tint fflag = 0, lflag = 0;\n+\t\t/* Copy token_buffer now, while it has just the number\n+\t\t   and not the suffixes; once we add `f' or `i',\n+\t\t   REAL_VALUE_ATOF may not work any more.  */\n+\t\tchar *copy = (char *) alloca (p - token_buffer + 1);\n+\t\tbcopy (token_buffer, copy, p - token_buffer + 1);\n+\n \t\tset_float_handler (handler);\n-\t\t/*  The second argument, machine_mode, of REAL_VALUE_ATOF\n-\t\t    tells the desired precision of the binary result of\n-\t\t    decimal-to-binary conversion.  */\n \n-\t\t/* Read the suffixes to choose a data type.  */\n-\t\tswitch (c)\n+\t\twhile (1)\n \t\t  {\n-\t\t  case 'f': case 'F':\n-\t\t    type = float_type_node;\n-\t\t    value = REAL_VALUE_ATOF (token_buffer, TYPE_MODE (type));\n-\t\t    garbage_chars = -1;\n-\t\t    break;\n+\t\t    int lose = 0;\n \n-\t\t  case 'l': case 'L':\n-\t\t    type = long_double_type_node;\n-\t\t    value = REAL_VALUE_ATOF (token_buffer, TYPE_MODE (type));\n-\t\t    garbage_chars = -1;\n-\t\t    break;\n+\t\t    /* Read the suffixes to choose a data type.  */\n+\t\t    switch (c)\n+\t\t      {\n+\t\t      case 'f': case 'F':\n+\t\t\tif (fflag)\n+\t\t\t  error (\"more than one `f' in numeric constant\");\n+\t\t\tfflag = 1;\n+\t\t\tbreak;\n+\n+\t\t      case 'l': case 'L':\n+\t\t\tif (lflag)\n+\t\t\t  error (\"more than one `l' in numeric constant\");\n+\t\t\tlflag = 1;\n+\t\t\tbreak;\n+\n+\t\t      case 'i': case 'I':\n+\t\t\tif (imag)\n+\t\t\t  error (\"more than one `i' or `j' in numeric constant\");\n+\t\t\telse if (pedantic)\n+\t\t\t  pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n+\t\t\timag = 1;\n+\t\t\tbreak;\n+\n+\t\t      default:\n+\t\t\tlose = 1;\n+\t\t      }\n \n-\t\t  default:\n-\t\t    value = REAL_VALUE_ATOF (token_buffer, TYPE_MODE (type));\n+\t\t    if (lose)\n+\t\t      break;\n+\n+\t\t    if (p >= token_buffer + maxtoken - 3)\n+\t\t      p = extend_token_buffer (p);\n+\t\t    *p++ = c;\n+\t\t    *p = 0;\n+\t\t    c = getch (finput);\n+\t\t  }\n+\n+\t\t/* The second argument, machine_mode, of REAL_VALUE_ATOF\n+\t\t   tells the desired precision of the binary result\n+\t\t   of decimal-to-binary conversion.  */\n+\n+\t\tif (fflag)\n+\t\t  {\n+\t\t    if (lflag)\n+\t\t      error (\"both `f' and `l' in floating constant\");\n+\n+\t\t    type = float_type_node;\n+\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    /* A diagnostic is required here by some ANSI C testsuites.\n+\t\t       This is not pedwarn, become some people don't want\n+\t\t       an error for this.  */\n+\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n+\t\t      warning (\"floating point number exceeds range of `float'\");\n+\t\t  }\n+\t\telse if (lflag)\n+\t\t  {\n+\t\t    type = long_double_type_node;\n+\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n+\t\t      warning (\"floating point number exceeds range of `long double'\");\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n+\t\t      warning (\"floating point number exceeds range of `double'\");\n \t\t  }\n+\n \t\tset_float_handler (NULL_PTR);\n \t      }\n-\t    if (pedantic\n-\t\t&& (REAL_VALUE_ISINF (value)\n #ifdef ERANGE\n-\t\t    || (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t\t&& errno == ERANGE\n-\t\t\t/* ERANGE is also reported for underflow, so test the\n-\t\t\t   value to distinguish overflow from that.  */\n-\t\t\t&& (REAL_VALUES_LESS (dconst1, value)\n-\t\t\t    || REAL_VALUES_LESS (value, dconstm1)))\n-#endif\n-\t\t    ))\n+\t    if (errno == ERANGE && pedantic)\n \t      {\n-\t\tpedwarn (\"floating point number exceeds range of `%s'\",\n-\t\t\t IDENTIFIER_POINTER (TYPE_IDENTIFIER (type)));\n-\t      }\n-\t    /* Note: garbage_chars is -1 if first char is *not* garbage.  */\n-\t    while (isalnum (c))\n-\t      {\n-\t\tif (c == 'f' || c == 'F')\n-\t\t  {\n-\t\t    if (f_seen)\n-\t\t      error (\"two `f's in floating constant\");\n-\t\t    f_seen = 1;\n-\t\t  }\n-\t\tif (c == 'l' || c == 'L')\n+  \t\t/* ERANGE is also reported for underflow,\n+  \t\t   so test the value to distinguish overflow from that.  */\n+\t\tif (REAL_VALUES_LESS (dconst1, value)\n+\t\t    || REAL_VALUES_LESS (value, dconstm1))\n \t\t  {\n-\t\t    if (l_seen)\n-\t\t      error (\"two `l's in floating constant\");\n-\t\t    l_seen = 1;\n+\t\t    pedwarn (\"floating point number exceeds range of `%s'\",\n+\t\t\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (type)));\n+\t\t    exceeds_double = 1;\n \t\t  }\n-\t\tif (p >= token_buffer + maxtoken - 3)\n-\t\t  p = extend_token_buffer (p);\n-\t\t*p++ = c;\n-\t\tc = getch ();\n-\t\tgarbage_chars++;\n \t      }\n+#endif\n \n-\t    if (garbage_chars > 0)\n-\t      error (\"garbage at end of number\");\n+\t    /* If the result is not a number, assume it must have been\n+\t       due to some error message above, so silently convert\n+\t       it to a zero.  */\n+\t    if (REAL_VALUE_ISNAN (value))\n+\t      value = dconst0;\n \n \t    /* Create a node with determined type and value.  */\n-\t    yylval.ttype = build_real (type, value);\n-\n-\t    put_back (c);\n-\t    *p = 0;\n+\t    if (imag)\n+\t      yylval.ttype = build_complex (NULL_TREE,\n+\t\t\t\t\t    cp_convert (type, integer_zero_node),\n+\t\t\t\t\t    build_real (type, value));\n+\t    else\n+\t      yylval.ttype = build_real (type, value);\n \t  }\n \telse\n \t  {\n@@ -3405,6 +3457,7 @@ real_yylex ()\n \t    int spec_unsigned = 0;\n \t    int spec_long = 0;\n \t    int spec_long_long = 0;\n+\t    int spec_imag = 0;\n \t    int bytes, warn;\n \n \t    while (1)\n@@ -3427,29 +3480,22 @@ real_yylex ()\n \t\t      }\n \t\t    spec_long = 1;\n \t\t  }\n-\t\telse\n+\t\telse if (c == 'i' || c == 'j' || c == 'I' || c == 'J')\n \t\t  {\n-\t\t    if (isalnum (c))\n-\t\t      {\n-\t\t\terror (\"garbage at end of number\");\n-\t\t\twhile (isalnum (c))\n-\t\t\t  {\n-\t\t\t    if (p >= token_buffer + maxtoken - 3)\n-\t\t\t      p = extend_token_buffer (p);\n-\t\t\t    *p++ = c;\n-\t\t\t    c = getch ();\n-\t\t\t  }\n-\t\t      }\n-\t\t    break;\n+\t\t    if (spec_imag)\n+\t\t      error (\"more than one `i' or `j' in numeric constant\");\n+\t\t    else if (pedantic)\n+\t\t      pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n+\t\t    spec_imag = 1;\n \t\t  }\n+\t\telse\n+\t\t  break;\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n \t\t*p++ = c;\n-\t\tc = getch ();\n+\t\tc = getch (finput);\n \t      }\n \n-\t    put_back (c);\n-\n \t    /* If the constant is not long long and it won't fit in an\n \t       unsigned long, or if the constant is long long and won't fit\n \t       in an unsigned long long, then warn that the constant is out\n@@ -3499,23 +3545,17 @@ real_yylex ()\n \t\t/* Nondecimal constants try unsigned even in traditional C.  */\n \t\ttype = unsigned_type_node;\n \t      }\n-\n \t    else if (!spec_unsigned && !spec_long_long\n \t\t     && int_fits_type_p (yylval.ttype, long_integer_type_node))\n \t      type = long_integer_type_node;\n-\n-\t    else if (! spec_long_long\n-\t\t     && int_fits_type_p (yylval.ttype,\n-\t\t\t\t\t long_unsigned_type_node))\n+\t    else if (! spec_long_long)\n \t      type = long_unsigned_type_node;\n-\n \t    else if (! spec_unsigned\n \t\t     /* Verify value does not overflow into sign bit.  */\n \t\t     && TREE_INT_CST_HIGH (yylval.ttype) >= 0\n \t\t     && int_fits_type_p (yylval.ttype,\n \t\t\t\t\t long_long_integer_type_node))\n \t      type = long_long_integer_type_node;\n-\n \t    else if (int_fits_type_p (yylval.ttype,\n \t\t\t\t      long_long_unsigned_type_node))\n \t      type = long_long_unsigned_type_node;\n@@ -3527,12 +3567,25 @@ real_yylex ()\n \n \t\tif (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n \t\t  warning (\"decimal integer constant is so large that it is unsigned\");\n+\t\tif (spec_imag)\n+\t\t  {\n+\t\t    if (TYPE_PRECISION (type)\n+\t\t\t<= TYPE_PRECISION (integer_type_node))\n+\t\t      yylval.ttype\n+\t\t\t= build_complex (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t cp_convert (integer_type_node,\n+\t\t\t\t\t\t     yylval.ttype));\n+\t\t    else\n+\t\t      error (\"complex integer constant is too wide for `complex int'\");\n+\t\t  }\n \t      }\n \n \t    TREE_TYPE (yylval.ttype) = type;\n-\t    *p = 0;\n \t  }\n \n+\tput_back (c);\n+\t*p = 0;\n+\n \tvalue = CONSTANT; break;\n       }\n "}, {"sha": "fcea57af7a40cd4325af0b114bdcdc525c4ed73a", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -62,6 +62,7 @@ enum rid\n   RID_SIGNED,\n   RID_AUTO,\n   RID_MUTABLE,\n+  RID_COMPLEX,\n \n   /* This is where grokdeclarator ends its search when setting the\n      specbits.  */\n@@ -81,7 +82,7 @@ enum rid\n #define NORID RID_UNUSED\n \n #define RID_FIRST_MODIFIER RID_EXTERN\n-#define RID_LAST_MODIFIER RID_MUTABLE\n+#define RID_LAST_MODIFIER RID_COMPLEX\n \n /* The type that can represent all values of RIDBIT.  */\n /* We assume that we can stick in at least 32 bits into this.  */"}, {"sha": "09acad4683145d4bad3b121949c3f7f2c77a0924", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -895,6 +895,11 @@ build_overload_name (parmtypes, begin, end)\n \t  else my_friendly_abort (74);\n \t  break;\n \n+\tcase COMPLEX_TYPE:\n+\t  OB_PUTC ('J');\n+\t  build_overload_name (TREE_TYPE (parmtype), 0, 0);\n+\t  break;\n+\n \tcase VOID_TYPE:\n \t  if (! just_one)\n \t    {"}, {"sha": "8a1ae5d530cd06c72dabbbb010a4ad8d50f1b8bf", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -140,6 +140,7 @@ empty_parms ()\n %token BREAK CONTINUE RETURN GOTO ASM_KEYWORD GCC_ASM_KEYWORD TYPEOF ALIGNOF\n %token SIGOF\n %token ATTRIBUTE EXTENSION LABEL\n+%token REALPART IMAGPART\n \n /* the reserved words... C++ extensions */\n %token <ttype> AGGR\n@@ -1104,6 +1105,10 @@ unary_expr:\n \t\t{ $$ = delete_sanity ($5, $3, 2, $1);\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX; }\n+\t| REALPART cast_expr %prec UNARY\n+\t\t{ $$ = build_x_unary_op (REALPART_EXPR, $2); }\n+\t| IMAGPART cast_expr %prec UNARY\n+\t\t{ $$ = build_x_unary_op (IMAGPART_EXPR, $2); }\n \t;\n \n new_placement:\n@@ -1542,7 +1547,7 @@ primary:\n \t\t      && (TREE_CODE (TREE_TYPE ($1)) \n \t\t\t  != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3)))))\n \t\t    cp_error (\"`%E' is not of type `%T'\", $1, $3);\n-\t\t  $$ = convert (void_type_node, $1);\n+\t\t  $$ = cp_convert (void_type_node, $1);\n \t\t}\n \t| object TYPESPEC SCOPE '~' TYPESPEC LEFT_RIGHT\n \t\t{\n@@ -1551,7 +1556,7 @@ primary:\n \t\t  if (TREE_CODE (TREE_TYPE ($1))\n \t\t      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($2))))\n \t\t    cp_error (\"`%E' is not of type `%T'\", $1, $2);\n-\t\t  $$ = convert (void_type_node, $1);\n+\t\t  $$ = cp_convert (void_type_node, $1);\n \t\t}\n \t| object error\n \t\t{\n@@ -2558,9 +2563,6 @@ left_curly:\n self_reference:\n \t  /* empty */\n \t\t{\n-\t\t  if (CLASSTYPE_TEMPLATE_INFO (current_class_type))\n-\t\t    $$ = NULL_TREE;\n-\t\t  else\n \t\t    $$ = build_self_reference ();\n \t\t}\n \t;"}, {"sha": "e06fa40768cdbc9105bfcaabc79d7d69aef49e86", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -133,7 +133,9 @@ process_template_parm (list, next)\n \t    error (\"  a template type parameter must begin with `class' or `typename'\");\n \t  TREE_TYPE (parm) = void_type_node;\n \t}\n-      else if (pedantic && TREE_CODE (TREE_TYPE (parm)) == REAL_TYPE)\n+      else if (pedantic\n+\t       && (TREE_CODE (TREE_TYPE (parm)) == REAL_TYPE\n+\t\t   || TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE))\n \tcp_pedwarn (\"`%T' is not a valid type for a template constant parameter\",\n \t\t    TREE_TYPE (parm));\n       tinfo = make_node (TEMPLATE_CONST_PARM);\n@@ -916,6 +918,7 @@ uses_template_parms (t)\n       return uses_template_parms (TYPE_MAX_VALUE (t));\n \n     case REAL_TYPE:\n+    case COMPLEX_TYPE:\n     case VOID_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n@@ -1205,12 +1208,13 @@ instantiate_class_template (type)\n \t{\n \t  tree e, newtag = tsubst_enum (tag, &TREE_VEC_ELT (args, 0),\n \t\t\t\t\tTREE_VEC_LENGTH (args));\n-\t  for (e = TYPE_VALUES (newtag); e; e = TREE_CHAIN (e))\n-\t    DECL_FIELD_CONTEXT (TREE_VALUE (e)) = type;\n \n \t  *field_chain = grok_enum_decls (newtag, NULL_TREE);\n \t  while (*field_chain)\n-\t    field_chain = &TREE_CHAIN (*field_chain);\n+\t    {\n+\t      DECL_FIELD_CONTEXT (*field_chain) = type;\n+\t      field_chain = &TREE_CHAIN (*field_chain);\n+\t    }\n \t}\n       else\n \ttsubst (tag, &TREE_VEC_ELT (args, 0),\n@@ -1387,6 +1391,7 @@ tsubst (t, args, nargs, in_decl)\n     case OP_IDENTIFIER:\n     case VOID_TYPE:\n     case REAL_TYPE:\n+    case COMPLEX_TYPE:\n     case BOOLEAN_TYPE:\n     case INTEGER_CST:\n     case REAL_CST:\n@@ -1413,14 +1418,18 @@ tsubst (t, args, nargs, in_decl)\n \treturn t;\n \n       {\n-\ttree max = tsubst_expr (TYPE_MAX_VALUE (t), args, nargs, in_decl);\n+\ttree max = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n+\tmax = tsubst_expr (max, args, nargs, in_decl);\n \tif (processing_template_decl)\n \t  {\n \t    tree itype = make_node (INTEGER_TYPE);\n \t    TYPE_MIN_VALUE (itype) = size_zero_node;\n-\t    TYPE_MAX_VALUE (itype) = max;\n+\t    TYPE_MAX_VALUE (itype) = build_min (MINUS_EXPR, sizetype, max,\n+\t\t\t\t\t\tinteger_one_node);\n \t    return itype;\n \t  }\n+\n+\tmax = fold (build_binary_op (MINUS_EXPR, max, integer_one_node, 1));\n \treturn build_index_2_type (size_zero_node, max);\n       }\n \n@@ -2796,6 +2805,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t\t    nsubsts, strict);\n \n     case REAL_TYPE:\n+    case COMPLEX_TYPE:\n     case INTEGER_TYPE:\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;"}, {"sha": "92b2c579f72ec1de10c8f95ddc258de051f02878", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -107,7 +107,7 @@ build_headof (exp)\n   type = build_type_variant (ptr_type_node, TREE_READONLY (exp),\n \t\t\t     TREE_THIS_VOLATILE (exp));\n   return build (PLUS_EXPR, type, exp,\n-\t\tconvert (ptrdiff_type_node, offset));\n+\t\tcp_convert (ptrdiff_type_node, offset));\n }\n \n /* Build a call to a generic entry point taking and returning void.  */\n@@ -240,7 +240,7 @@ build_x_typeid (exp)\n       && ! nonnull)\n     {\n       exp = stabilize_reference (exp);\n-      cond = convert (boolean_type_node, TREE_OPERAND (exp, 0));\n+      cond = cp_convert (boolean_type_node, TREE_OPERAND (exp, 0));\n     }\n \n   exp = get_tinfo_fn_dynamic (exp);\n@@ -256,7 +256,7 @@ build_x_typeid (exp)\n \n       bad = build_compound_expr\n \t(tree_cons (NULL_TREE, bad, build_tree_list\n-\t\t    (NULL_TREE, convert (type, integer_zero_node))));\n+\t\t    (NULL_TREE, cp_convert (type, integer_zero_node))));\n       exp = build (COND_EXPR, type, cond, exp, bad);\n     }\n \n@@ -292,7 +292,7 @@ get_tinfo_var (type)\n \t\t   (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0))))\n \tsize = 3 * POINTER_SIZE;\n       else\n-\tsize = 3 * POINTER_SIZE + INT_TYPE_SIZE;\n+\tsize = 3 * POINTER_SIZE + TYPE_PRECISION (sizetype);\n     }\n   else\n     size = 2 * POINTER_SIZE;\n@@ -398,7 +398,7 @@ ifnonnull (test, result)\n {\n   return build (COND_EXPR, TREE_TYPE (result),\n \t\tbuild (EQ_EXPR, boolean_type_node, test, integer_zero_node),\n-\t\tconvert (TREE_TYPE (result), integer_zero_node),\n+\t\tcp_convert (TREE_TYPE (result), integer_zero_node),\n \t\tresult);\n }\n \n@@ -611,15 +611,14 @@ build_dynamic_cast (type, expr)\n \t      expr1 = throw_bad_cast ();\n \t      expr1 = build_compound_expr\n \t\t(tree_cons (NULL_TREE, expr1,\n-\t\t\t    build_tree_list (NULL_TREE, convert\n-\t\t\t\t\t     (type, integer_zero_node))));\n+\t\t\t    build_tree_list (NULL_TREE, cp_convert (type, integer_zero_node))));\n \t      TREE_TYPE (expr1) = type;\n \t      result = save_expr (result);\n \t      return build (COND_EXPR, type, result, result, expr1);\n \t    }\n \n \t  /* Now back to the type we want from a void*.  */\n-\t  result = convert (type, result);\n+\t  result = cp_convert (type, result);\n           return ifnonnull (expr, result);\n \t}\n     }\n@@ -842,7 +841,8 @@ expand_class_desc (tdecl, type)\n     (NULL_TREE, decay_conversion (tdecl), tree_cons\n      (NULL_TREE, decay_conversion (name_string), tree_cons\n       (NULL_TREE, decay_conversion (elts), tree_cons\n-       (NULL_TREE, build_int_2 (base_cnt, 0), NULL_TREE))));\n+       (NULL_TREE, cp_convert (sizetype, build_int_2 (base_cnt, 0)),\n+\tNULL_TREE))));\n \n   fn = get_identifier (\"__rtti_class\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n@@ -1043,7 +1043,7 @@ synthesize_tinfo_fn (fndecl)\n   /* If the first word of the array (the vtable) is non-zero, we've already\n      initialized the object, so don't do it again.  */\n   addr = decay_conversion (tdecl);\n-  tmp = convert (build_pointer_type (ptr_type_node), addr);\n+  tmp = cp_convert (build_pointer_type (ptr_type_node), addr);\n   tmp = build_indirect_ref (tmp, 0);\n   tmp = build_binary_op (EQ_EXPR, tmp, integer_zero_node, 1);\n   expand_start_cond (tmp, 0);\n@@ -1084,7 +1084,7 @@ synthesize_tinfo_fn (fndecl)\n   expand_end_cond ();\n \n   /* OK, now return the type_info object.  */\n-  tmp = convert (build_pointer_type (type_info_type_node), addr);\n+  tmp = cp_convert (build_pointer_type (type_info_type_node), addr);\n   tmp = build_indirect_ref (tmp, 0);\n   c_expand_return (tmp);\n   finish_function (lineno, 0, 0);"}, {"sha": "c52b1d62cd6f7dd013e59a42480de16bff8ea230", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -620,20 +620,20 @@ build_signature_table_constructor (sig_ty, rhs)\n \t  pfn_decl = TREE_CHAIN (index_decl);\n \t  vt_off_decl = TREE_CHAIN (pfn_decl);\n \t  \n-\t  tag = convert (TREE_TYPE (tag_decl), tag);\n-\t  vb_off = convert (TREE_TYPE (vb_off_decl), vb_off);\n-\t  delta = convert (TREE_TYPE (delta_decl), delta);\n-\t  idx = convert (TREE_TYPE (index_decl), idx);\n+\t  tag = cp_convert (TREE_TYPE (tag_decl), tag);\n+\t  vb_off = cp_convert (TREE_TYPE (vb_off_decl), vb_off);\n+\t  delta = cp_convert (TREE_TYPE (delta_decl), delta);\n+\t  idx = cp_convert (TREE_TYPE (index_decl), idx);\n \n \t  if (DECL_VINDEX (rhs_method))\n \t    {\n-\t      vt_off = convert (TREE_TYPE (vt_off_decl), vt_off);\n+\t      vt_off = cp_convert (TREE_TYPE (vt_off_decl), vt_off);\n \n \t      tbl_entry = build_tree_list (vt_off_decl, vt_off);\n \t    }\n \t  else\n \t    {\n-\t      pfn = convert (TREE_TYPE (pfn_decl), pfn);\n+\t      pfn = cp_convert (TREE_TYPE (pfn_decl), pfn);\n \n \t      tbl_entry = build_tree_list (pfn_decl, pfn);\n \t    }\n@@ -956,11 +956,11 @@ build_signature_method_call (function, parms)\n     }\n \n   new_object_ptr = build (PLUS_EXPR, build_pointer_type (basetype),\n-\t\t\t  convert (ptrdiff_type_node, object_ptr),\n-\t\t\t  convert (ptrdiff_type_node, delta));\n+\t\t\t  cp_convert (ptrdiff_type_node, object_ptr),\n+\t\t\t  cp_convert (ptrdiff_type_node, delta));\n \n   parms = tree_cons (NULL_TREE,\n-\t\t     convert (build_pointer_type (basetype), object_ptr),\n+\t\t     cp_convert (build_pointer_type (basetype), object_ptr),\n \t\t     TREE_CHAIN (parms));\n   new_parms = tree_cons (NULL_TREE, new_object_ptr, TREE_CHAIN (parms));\n \n@@ -980,8 +980,8 @@ build_signature_method_call (function, parms)\n \n       vfld = build (PLUS_EXPR,\n \t\t    build_pointer_type (build_pointer_type (vtbl_type_node)),\n-\t\t    convert (ptrdiff_type_node, object_ptr),\n-\t\t    convert (ptrdiff_type_node, vt_off));\n+\t\t    cp_convert (ptrdiff_type_node, object_ptr),\n+\t\t    cp_convert (ptrdiff_type_node, vt_off));\n       vtbl = build_indirect_ref (build_indirect_ref (vfld, NULL_PTR),\n \t\t\t\t NULL_PTR);\n       aref = build_array_ref (vtbl, idx);"}, {"sha": "a0605306d911d1096d9e65e7cdc277941d356647", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -129,6 +129,8 @@ lvalue_p (ref)\n \t what they refer to are valid lvals.  */\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n     case COMPONENT_REF:\n     case SAVE_EXPR:\n       return lvalue_p (TREE_OPERAND (ref, 0));\n@@ -925,27 +927,27 @@ struct list_hash\n    and the hash code is computed differently for each of these.  */\n \n #define TYPE_HASH_SIZE 59\n-struct list_hash *list_hash_table[TYPE_HASH_SIZE];\n+static struct list_hash *list_hash_table[TYPE_HASH_SIZE];\n \n /* Compute a hash code for a list (chain of TREE_LIST nodes\n    with goodies in the TREE_PURPOSE, TREE_VALUE, and bits of the\n    TREE_COMMON slots), by adding the hash codes of the individual entries.  */\n \n-int\n-list_hash (list)\n-     tree list;\n+static int\n+list_hash (purpose, value, chain)\n+     tree purpose, value, chain;\n {\n   register int hashcode = 0;\n \n-  if (TREE_CHAIN (list))\n-    hashcode += TYPE_HASH (TREE_CHAIN (list));\n+  if (chain)\n+    hashcode += TYPE_HASH (chain);\n \n-  if (TREE_VALUE (list))\n-    hashcode += TYPE_HASH (TREE_VALUE (list));\n+  if (value)\n+    hashcode += TYPE_HASH (value);\n   else\n     hashcode += 1007;\n-  if (TREE_PURPOSE (list))\n-    hashcode += TYPE_HASH (TREE_PURPOSE (list));\n+  if (purpose)\n+    hashcode += TYPE_HASH (purpose);\n   else\n     hashcode += 1009;\n   return hashcode;\n@@ -954,31 +956,30 @@ list_hash (list)\n /* Look in the type hash table for a type isomorphic to TYPE.\n    If one is found, return it.  Otherwise return 0.  */\n \n-tree\n-list_hash_lookup (hashcode, list)\n-     int hashcode;\n-     tree list;\n+static tree\n+list_hash_lookup (hashcode, via_public, via_protected, via_virtual,\n+\t\t  purpose, value, chain)\n+     int hashcode, via_public, via_virtual, via_protected;\n+     tree purpose, value, chain;\n {\n   register struct list_hash *h;\n+\n   for (h = list_hash_table[hashcode % TYPE_HASH_SIZE]; h; h = h->next)\n     if (h->hashcode == hashcode\n-\t&& TREE_VIA_VIRTUAL (h->list) == TREE_VIA_VIRTUAL (list)\n-\t&& TREE_VIA_PUBLIC (h->list) == TREE_VIA_PUBLIC (list)\n-\t&& TREE_VIA_PROTECTED (h->list) == TREE_VIA_PROTECTED (list)\n-\t&& TREE_PURPOSE (h->list) == TREE_PURPOSE (list)\n-\t&& TREE_VALUE (h->list) == TREE_VALUE (list)\n-\t&& TREE_CHAIN (h->list) == TREE_CHAIN (list))\n-      {\n-\tmy_friendly_assert (TREE_TYPE (h->list) == TREE_TYPE (list), 299);\n-\treturn h->list;\n-      }\n+\t&& TREE_VIA_VIRTUAL (h->list) == via_virtual\n+\t&& TREE_VIA_PUBLIC (h->list) == via_public\n+\t&& TREE_VIA_PROTECTED (h->list) == via_protected\n+\t&& TREE_PURPOSE (h->list) == purpose\n+\t&& TREE_VALUE (h->list) == value\n+\t&& TREE_CHAIN (h->list) == chain)\n+      return h->list;\n   return 0;\n }\n \n /* Add an entry to the list-hash-table\n    for a list TYPE whose hash code is HASHCODE.  */\n \n-void\n+static void\n list_hash_add (hashcode, list)\n      int hashcode;\n      tree list;\n@@ -1007,29 +1008,6 @@ list_hash_add (hashcode, list)\n \n static int debug_no_list_hash = 0;\n \n-tree\n-list_hash_canon (hashcode, list)\n-     int hashcode;\n-     tree list;\n-{\n-  tree t1;\n-\n-  if (debug_no_list_hash)\n-    return list;\n-\n-  t1 = list_hash_lookup (hashcode, list);\n-  if (t1 != 0)\n-    {\n-      obstack_free (&class_obstack, list);\n-      return t1;\n-    }\n-\n-  /* If this is a new list, record it for later reuse.  */\n-  list_hash_add (hashcode, list);\n-\n-  return list;\n-}\n-\n tree\n hash_tree_cons (via_public, via_virtual, via_protected, purpose, value, chain)\n      int via_public, via_virtual, via_protected;\n@@ -1039,13 +1017,26 @@ hash_tree_cons (via_public, via_virtual, via_protected, purpose, value, chain)\n   tree t;\n   int hashcode;\n \n+  if (! debug_no_list_hash)\n+    {\n+      hashcode = list_hash (purpose, value, chain);\n+      t = list_hash_lookup (hashcode, via_public, via_protected, via_virtual,\n+\t\t\t    purpose, value, chain);\n+      if (t)\n+\treturn t;\n+    }\n+\n   current_obstack = &class_obstack;\n+\n   t = tree_cons (purpose, value, chain);\n   TREE_VIA_PUBLIC (t) = via_public;\n   TREE_VIA_PROTECTED (t) = via_protected;\n   TREE_VIA_VIRTUAL (t) = via_virtual;\n-  hashcode = list_hash (t);\n-  t = list_hash_canon (hashcode, t);\n+\n+  /* If this is a new list, record it for later reuse.  */\n+  if (! debug_no_list_hash)\n+    list_hash_add (hashcode, t);\n+\n   current_obstack = ambient_obstack;\n   return t;\n }\n@@ -1056,16 +1047,7 @@ tree\n hash_tree_chain (value, chain)\n      tree value, chain;\n {\n-  struct obstack *ambient_obstack = current_obstack;\n-  tree t;\n-  int hashcode;\n-\n-  current_obstack = &class_obstack;\n-  t = tree_cons (NULL_TREE, value, chain);\n-  hashcode = list_hash (t);\n-  t = list_hash_canon (hashcode, t);\n-  current_obstack = ambient_obstack;\n-  return t;\n+  return hash_tree_cons (0, 0, 0, NULL_TREE, value, chain);\n }\n \n /* Similar, but used for concatenating two lists.  */\n@@ -1595,6 +1577,12 @@ mapcar (t, func)\n \t mapcar (TREE_CHAIN (TYPE_ARG_TYPES (t)), func));\n       return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n \n+    case COMPLEX_CST:\n+      t = copy_node (t);\n+      TREE_REALPART (t) = mapcar (TREE_REALPART (t), func);\n+      TREE_IMAGPART (t) = mapcar (TREE_REALPART (t), func);\n+      return t;\n+\n     case CONSTRUCTOR:\n       t = copy_node (t);\n       CONSTRUCTOR_ELTS (t) = mapcar (CONSTRUCTOR_ELTS (t), func);"}, {"sha": "dd6415bac9cc1a10855882f472b1922f2a50e47d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 141, "deletions": 68, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -355,6 +355,24 @@ common_type (t1, t2)\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n+  /* If one type is complex, form the common type of the non-complex\n+     components, then make that complex.  Use T1 or T2 if it is the\n+     required type.  */\n+  if (code1 == COMPLEX_TYPE || code2 == COMPLEX_TYPE)\n+    {\n+      tree subtype1 = code1 == COMPLEX_TYPE ? TREE_TYPE (t1) : t1;\n+      tree subtype2 = code2 == COMPLEX_TYPE ? TREE_TYPE (t2) : t2;\n+      tree subtype = common_type (subtype1, subtype2);\n+\n+      if (code1 == COMPLEX_TYPE && TREE_TYPE (t1) == subtype)\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else if (code2 == COMPLEX_TYPE && TREE_TYPE (t2) == subtype)\n+\treturn build_type_attribute_variant (t2, attributes);\n+      else\n+\treturn build_type_attribute_variant (build_complex_type (subtype),\n+\t\t\t\t\t     attributes);\n+    }\n+\n   switch (code1)\n     {\n     case INTEGER_TYPE:\n@@ -1509,7 +1527,7 @@ decay_conversion (exp)\n \t\t\t      inner);\n \t      TREE_CONSTANT (inner) = TREE_CONSTANT (TREE_OPERAND (inner, 0));\n \t    }\n-\t  return convert (build_pointer_type (TREE_TYPE (type)), inner);\n+\t  return cp_convert (build_pointer_type (TREE_TYPE (type)), inner);\n \t}\n \n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n@@ -1558,7 +1576,7 @@ decay_conversion (exp)\n       /* This way is better for a COMPONENT_REF since it can\n \t simplify the offset for a component.  */\n       adr = build_unary_op (ADDR_EXPR, exp, 1);\n-      return convert (ptrtype, adr);\n+      return cp_convert (ptrtype, adr);\n     }\n \n   return exp;\n@@ -1580,7 +1598,7 @@ default_conversion (exp)\n     {\n       tree t = type_promotes_to (type);\n       if (t != type)\n-\treturn convert (t, exp);\n+\treturn cp_convert (t, exp);\n     }\n \n   return exp;\n@@ -2469,12 +2487,12 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t\t\t\t\t    index_identifier,\n \t\t\t\t\t    NULL_TREE, 0));\n       e1 = fold (build (GT_EXPR, boolean_type_node, idx,\n-\t\t\tconvert (delta_type_node, integer_zero_node)));\n-      delta = convert (ptrdiff_type_node,\n-\t\t       build_component_ref (function, delta_identifier, NULL_TREE, 0));\n+\t\t\tcp_convert (delta_type_node, integer_zero_node)));\n+      delta = cp_convert (ptrdiff_type_node,\n+\t\t\t  build_component_ref (function, delta_identifier, NULL_TREE, 0));\n       delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n \n-      /* convert down to the right base, before using the instance.  */\n+      /* Convert down to the right base, before using the instance.  */\n       instance\n \t= convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n \t\t\t\t   instance_ptr);\n@@ -2485,7 +2503,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       vtbl\n \t= build (PLUS_EXPR,\n \t\t build_pointer_type (build_pointer_type (vtable_entry_type)),\n-\t\t vtbl, convert (ptrdiff_type_node, delta2));\n+\t\t vtbl, cp_convert (ptrdiff_type_node, delta2));\n       vtbl = build_indirect_ref (vtbl, NULL_PTR);\n       aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n \t\t\t\t\t\t     idx,\n@@ -2845,7 +2863,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t      && (TYPE_PRECISION (TREE_TYPE (val))\n \t\t  < TYPE_PRECISION (double_type_node)))\n \t    /* Convert `float' to `double'.  */\n-\t    result = tree_cons (NULL_TREE, convert (double_type_node, val), result);\n+\t    result = tree_cons (NULL_TREE, cp_convert (double_type_node, val), result);\n \t  else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n \t\t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n \t    {\n@@ -3139,8 +3157,10 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == COMPLEX_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == COMPLEX_TYPE))\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST && integer_zerop (op1))\n \t    cp_warning (\"division by zero in `%E / 0'\", op0);\n@@ -3249,7 +3269,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n-\t    op1 = convert (integer_type_node, op1);\n+\t    op1 = cp_convert (integer_type_node, op1);\n \t  /* Avoid converting op1 to result_type later.  */\n \t  converted = 1;\n \t}\n@@ -3271,7 +3291,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n-\t    op1 = convert (integer_type_node, op1);\n+\t    op1 = cp_convert (integer_type_node, op1);\n \t  /* Avoid converting op1 to result_type later.  */\n \t  converted = 1;\n \t}\n@@ -3296,15 +3316,17 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n-\t    op1 = convert (integer_type_node, op1);\n+\t    op1 = cp_convert (integer_type_node, op1);\n \t}\n       break;\n \n     case EQ_EXPR:\n     case NE_EXPR:\n       build_type = boolean_type_node; \n-      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == COMPLEX_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == COMPLEX_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n@@ -3496,9 +3518,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       break;\n     }\n \n-  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-      && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n+      &&\n+      (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE))\n     {\n+      int none_complex = (code0 != COMPLEX_TYPE && code1 != COMPLEX_TYPE);\n+\n       if (shorten || common || short_compare)\n \tresult_type = common_type (type0, type1);\n \n@@ -3513,7 +3538,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t Eg, (short)-1 | (unsigned short)-1 is (int)-1\n \t but calculated in (unsigned short) it would be (unsigned short)-1.  */\n \n-      if (shorten)\n+      if (shorten && none_complex)\n \t{\n \t  int unsigned0, unsigned1;\n \t  tree arg0 = get_narrower (op0, &unsigned0);\n@@ -3608,7 +3633,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t\t\t\t   TREE_TYPE (arg0));\n \t      /* Convert value-to-be-shifted to that type.  */\n \t      if (TREE_TYPE (op0) != result_type)\n-\t\top0 = convert (result_type, op0);\n+\t\top0 = cp_convert (result_type, op0);\n \t      converted = 1;\n \t    }\n \t}\n@@ -3627,7 +3652,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  tree val \n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n \t  if (val != 0)\n-\t    return convert (boolean_type_node, val);\n+\t    return cp_convert (boolean_type_node, val);\n \t  op0 = xop0, op1 = xop1;\n \t  converted = 1;\n \t  resultcode = xresultcode;\n@@ -3758,9 +3783,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n   if (! converted)\n     {\n       if (TREE_TYPE (op0) != result_type)\n-\top0 = convert (result_type, op0); \n+\top0 = cp_convert (result_type, op0); \n       if (TREE_TYPE (op1) != result_type)\n-\top1 = convert (result_type, op1); \n+\top1 = cp_convert (result_type, op1); \n     }\n \n   if (build_type == NULL_TREE)\n@@ -3774,7 +3799,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n     if (folded == result)\n       TREE_CONSTANT (folded) = TREE_CONSTANT (op0) & TREE_CONSTANT (op1);\n     if (final_type != 0)\n-      return convert (final_type, folded);\n+      return cp_convert (final_type, folded);\n     return folded;\n   }\n }\n@@ -3851,15 +3876,15 @@ pointer_int_sum (resultcode, ptrop, intop)\n      so the multiply won't overflow spuriously.  */\n \n   if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype))\n-    intop = convert (type_for_size (TYPE_PRECISION (sizetype), 0), intop);\n+    intop = cp_convert (type_for_size (TYPE_PRECISION (sizetype), 0), intop);\n \n   /* Replace the integer argument with a suitable product by the object size.\n      Do this multiplication as signed, then convert to the appropriate\n      pointer type (actually unsigned integral).  */\n \n-  intop = convert (result_type,\n-\t\t   build_binary_op (MULT_EXPR, intop,\n-\t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n+  intop = cp_convert (result_type,\n+\t\t      build_binary_op (MULT_EXPR, intop,\n+\t\t\t\t       cp_convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n \n@@ -3898,7 +3923,7 @@ pointer_diff (op0, op1)\n      then drop through to build the divide operator.  */\n \n   op0 = build_binary_op (MINUS_EXPR,\n-\t\t\t convert (restype, op0), convert (restype, op1), 1);\n+\t\t\t cp_convert (restype, op0), cp_convert (restype, op1), 1);\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (op1))) == 0)\n@@ -3913,7 +3938,7 @@ pointer_diff (op0, op1)\n \n   /* Do the division.  */\n \n-  result = build (EXACT_DIV_EXPR, restype, op0, convert (restype, op1));\n+  result = build (EXACT_DIV_EXPR, restype, op0, cp_convert (restype, op1));\n \n   folded = fold (result);\n   if (folded == result)\n@@ -3964,7 +3989,7 @@ build_component_addr (arg, argtype, msg)\n \t\t\t\tsize_int (BITS_PER_UNIT));\n       int flag = TREE_CONSTANT (rval);\n       rval = fold (build (PLUS_EXPR, argtype,\n-\t\t\t  rval, convert (argtype, offset)));\n+\t\t\t  rval, cp_convert (argtype, offset)));\n       TREE_CONSTANT (rval) = flag;\n     }\n   return rval;\n@@ -4028,7 +4053,7 @@ condition_conversion (expr)\n   tree t;\n   if (processing_template_decl)\n     return expr;\n-  t = convert (boolean_type_node, expr);\n+  t = cp_convert (boolean_type_node, expr);\n   t = fold (build1 (CLEANUP_POINT_EXPR, boolean_type_node, t));\n   return t;\n }\n@@ -4082,7 +4107,14 @@ build_unary_op (code, xarg, noconvert)\n       break;\n \n     case BIT_NOT_EXPR:\n-      if (!(arg = build_expr_type_conversion (WANT_INT | WANT_ENUM, arg, 1)))\n+      if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n+\t{\n+\t  code = CONJ_EXPR;\n+\t  if (!noconvert)\n+\t    arg = default_conversion (arg);\n+\t}\n+      else if (!(arg = build_expr_type_conversion (WANT_INT | WANT_ENUM,\n+\t\t\t\t\t\t   arg, 1)))\n \terrstring = \"wrong type argument to bit-complement\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n@@ -4095,8 +4127,16 @@ build_unary_op (code, xarg, noconvert)\n \targ = default_conversion (arg);\n       break;\n \n+    case CONJ_EXPR:\n+      /* Conjugating a real value is a no-op, but allow it anyway.  */\n+      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, 1)))\n+\terrstring = \"wrong type argument to conjugation\";\n+      else if (!noconvert)\n+\targ = default_conversion (arg);\n+      break;\n+\n     case TRUTH_NOT_EXPR:\n-      arg = convert (boolean_type_node, arg);\n+      arg = cp_convert (boolean_type_node, arg);\n       val = invert_truthvalue (arg);\n       if (arg != error_mark_node)\n \treturn val;\n@@ -4106,6 +4146,22 @@ build_unary_op (code, xarg, noconvert)\n     case NOP_EXPR:\n       break;\n       \n+    case REALPART_EXPR:\n+      if (TREE_CODE (arg) == COMPLEX_CST)\n+\treturn TREE_REALPART (arg);\n+      else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n+\treturn fold (build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+      else\n+\treturn arg;\n+\n+    case IMAGPART_EXPR:\n+      if (TREE_CODE (arg) == COMPLEX_CST)\n+\treturn TREE_IMAGPART (arg);\n+      else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n+\treturn fold (build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+      else\n+\treturn cp_convert (TREE_TYPE (arg), integer_zero_node);\n+      \n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n@@ -4117,6 +4173,19 @@ build_unary_op (code, xarg, noconvert)\n       if (val != 0)\n \treturn val;\n \n+      /* Increment or decrement the real part of the value,\n+\t and don't change the imaginary part.  */\n+      if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n+\t{\n+\t  tree real, imag;\n+\n+\t  arg = stabilize_reference (arg);\n+\t  real = build_unary_op (REALPART_EXPR, arg, 1);\n+\t  imag = build_unary_op (IMAGPART_EXPR, arg, 1);\n+\t  return build (COMPLEX_EXPR, TREE_TYPE (arg),\n+\t\t\tbuild_unary_op (code, real, 1), imag);\n+\t}\n+\n       /* Report invalid types.  */\n \n       if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_POINTER,\n@@ -4176,7 +4245,7 @@ build_unary_op (code, xarg, noconvert)\n \telse\n \t  inc = integer_one_node;\n \n-\tinc = convert (argtype, inc);\n+\tinc = cp_convert (argtype, inc);\n \n \t/* Handle incrementing a cast-expression.  */\n \n@@ -4251,7 +4320,7 @@ build_unary_op (code, xarg, noconvert)\n \t  val = build (code, TREE_TYPE (arg), arg, inc);\n \n \tTREE_SIDE_EFFECTS (val) = 1;\n-\treturn convert (result_type, val);\n+\treturn cp_convert (result_type, val);\n       }\n \n     case ADDR_EXPR:\n@@ -4438,9 +4507,9 @@ convert_sequence (conversions, arg)\n     case FIX_FLOOR_EXPR:\n     case FIX_ROUND_EXPR:\n     case FIX_CEIL_EXPR:\n-      return convert (TREE_TYPE (conversions),\n-\t\t      convert_sequence (TREE_OPERAND (conversions, 0),\n-\t\t\t\t\targ));\n+      return cp_convert (TREE_TYPE (conversions),\n+\t\t\t convert_sequence (TREE_OPERAND (conversions, 0),\n+\t\t\t\t\t   arg));\n \n     default:\n       return arg;\n@@ -4556,7 +4625,7 @@ unary_complex_lvalue (code, arg)\n \t     data member of a structure.  */\n \t  offset = size_binop (PLUS_EXPR, offset, size_int (1));\n \n-\t  return convert (build_pointer_type (TREE_TYPE (arg)), offset);\n+\t  return cp_convert (build_pointer_type (TREE_TYPE (arg)), offset);\n \t}\n     }\n \n@@ -4608,6 +4677,8 @@ mark_addressable (exp)\n       case ADDR_EXPR:\n       case COMPONENT_REF:\n       case ARRAY_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n \tx = TREE_OPERAND (x, 0);\n \tbreak;\n \n@@ -4731,7 +4802,7 @@ build_conditional_expr (ifexp, op1, op2)\n       ifexp = op1 = save_expr (ifexp);\n     }\n \n-  ifexp = convert (boolean_type_node, ifexp);\n+  ifexp = cp_convert (boolean_type_node, ifexp);\n \n   if (TREE_CODE (ifexp) == ERROR_MARK)\n     return error_mark_node;\n@@ -5280,7 +5351,7 @@ build_reinterpret_cast (type, expr)\n       return error_mark_node;\n     }\n       \n-  return convert (type, expr);\n+  return cp_convert (type, expr);\n }\n \n tree\n@@ -5339,7 +5410,7 @@ build_const_cast (type, expr)\n   else if (TREE_CODE (type) == POINTER_TYPE\n \t   && TREE_CODE (intype) == POINTER_TYPE\n \t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n-    return convert (type, expr);\n+    return cp_convert (type, expr);\n \n   cp_error (\"const_cast from `%T' to `%T'\", intype, type);\n   return error_mark_node;\n@@ -5621,9 +5692,9 @@ build_modify_expr (lhs, modifycode, rhs)\n \t   so the code to compute it is only emitted once.  */\n \ttree cond\n \t  = build_conditional_expr (TREE_OPERAND (lhs, 0),\n-\t\t\t\t    build_modify_expr (convert (TREE_TYPE (lhs), TREE_OPERAND (lhs, 1)),\n+\t\t\t\t    build_modify_expr (cp_convert (TREE_TYPE (lhs), TREE_OPERAND (lhs, 1)),\n \t\t\t\t\t\t       modifycode, rhs),\n-\t\t\t\t    build_modify_expr (convert (TREE_TYPE (lhs), TREE_OPERAND (lhs, 2)),\n+\t\t\t\t    build_modify_expr (cp_convert (TREE_TYPE (lhs), TREE_OPERAND (lhs, 2)),\n \t\t\t\t\t\t       modifycode, rhs));\n \tif (cond == error_mark_node)\n \t  return cond;\n@@ -5632,7 +5703,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \treturn build (COMPOUND_EXPR, TREE_TYPE (lhs),\n \t\t      /* Case to void to suppress warning\n \t\t\t from warn_if_unused_value.  */\n-\t\t      convert (void_type_node, rhs), cond);\n+\t\t      cp_convert (void_type_node, rhs), cond);\n       }\n     }\n \n@@ -5779,11 +5850,11 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  pedwarn (\"ANSI C++ forbids cast to non-reference type used as lvalue\");\n \n \tresult = build_modify_expr (inner_lhs, NOP_EXPR,\n-\t\t\t\t    convert (TREE_TYPE (inner_lhs),\n-\t\t\t\t\t     convert (lhstype, newrhs)));\n+\t\t\t\t    cp_convert (TREE_TYPE (inner_lhs),\n+\t\t\t\t\t\tcp_convert (lhstype, newrhs)));\n \tif (result == error_mark_node)\n \t  return result;\n-\treturn convert (TREE_TYPE (lhs), result);\n+\treturn cp_convert (TREE_TYPE (lhs), result);\n       }\n     }\n \n@@ -5999,11 +6070,11 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  result\n \t    = build (COND_EXPR, result_type, cond,\n \t\t     build_modify_expr (lhs, modifycode,\n-\t\t\t\t\tconvert (result_type,\n-\t\t\t\t\t\t TREE_OPERAND (newrhs, 1))),\n+\t\t\t\t\tcp_convert (result_type,\n+\t\t\t\t\t\t    TREE_OPERAND (newrhs, 1))),\n \t\t     build_modify_expr (lhs1, modifycode,\n-\t\t\t\t\tconvert (result_type,\n-\t\t\t\t\t\t TREE_OPERAND (newrhs, 2))));\n+\t\t\t\t\tcp_convert (result_type,\n+\t\t\t\t\t\t    TREE_OPERAND (newrhs, 2))));\n \t}\n     }\n   else\n@@ -6116,7 +6187,7 @@ get_delta_difference (from, to, force)\n \t  warning (\"pointer to member conversion to virtual base class will only work if you are very careful\");\n \t}\n       delta = BINFO_OFFSET (binfo);\n-      delta = convert (ptrdiff_type_node, delta);\n+      delta = cp_convert (ptrdiff_type_node, delta);\n       \n       return build_binary_op (MINUS_EXPR,\n \t\t\t      integer_zero_node,\n@@ -6234,8 +6305,8 @@ build_ptrmemfunc (type, pfn, force)\n       if (type == TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))\n \treturn pfn;\n \n-      ndelta = convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n-      ndelta2 = convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n+      ndelta = cp_convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n+      ndelta2 = cp_convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n       idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n \n       n = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n@@ -6405,8 +6476,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n       return error_mark_node;\n     }\n   /* Arithmetic types all interconvert.  */\n-  if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == BOOLEAN_TYPE)\n-       && (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == BOOLEAN_TYPE))\n+  if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == BOOLEAN_TYPE\n+       || codel == COMPLEX_TYPE)\n+       && (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == BOOLEAN_TYPE\n+\t   || coder == COMPLEX_TYPE))\n     {\n       /* But we should warn if assigning REAL_TYPE to INTEGER_TYPE.  */\n       if (coder == REAL_TYPE && codel == INTEGER_TYPE)\n@@ -6444,7 +6517,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t   || (coder == ENUMERAL_TYPE\n \t       && (INTEGRAL_CODE_P (codel) || codel == REAL_TYPE)))\n     {\n-      return cp_convert (type, rhs, CONV_IMPLICIT, LOOKUP_NORMAL);\n+      return ocp_convert (type, rhs, CONV_IMPLICIT, LOOKUP_NORMAL);\n     }\n   /* Conversions among pointers */\n   else if (codel == POINTER_TYPE\n@@ -6678,7 +6751,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t      return error_mark_node;\n \t    }\n \t}\n-      return convert (type, rhs);\n+      return cp_convert (type, rhs);\n     }\n   else if (codel == POINTER_TYPE && coder == INTEGER_TYPE)\n     {\n@@ -6693,7 +6766,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t    cp_pedwarn (\"%s to `%T' from `%T' lacks a cast\",\n \t\t\terrtype, type, rhstype);\n \t}\n-      return convert (type, rhs);\n+      return cp_convert (type, rhs);\n     }\n   else if (codel == INTEGER_TYPE\n \t   && (coder == POINTER_TYPE\n@@ -6708,15 +6781,15 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n       else\n \tcp_pedwarn (\"%s to `%T' from `%T' lacks a cast\",\n \t\t    errtype, type, rhstype);\n-      return convert (type, rhs);\n+      return cp_convert (type, rhs);\n     }\n   else if (codel == BOOLEAN_TYPE\n \t   && (coder == POINTER_TYPE\n \t       || (coder == RECORD_TYPE\n \t\t   && (IS_SIGNATURE_POINTER (rhstype)\n \t\t       || TYPE_PTRMEMFUNC_FLAG (rhstype)\n \t\t       || IS_SIGNATURE_REFERENCE (rhstype)))))\n-    return convert (type, rhs);\n+    return cp_convert (type, rhs);\n \n   /* C++ */\n   else if (((coder == POINTER_TYPE\n@@ -6754,14 +6827,14 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n       return nrhs;\n     }\n   else if (TYPE_HAS_CONSTRUCTOR (type) || IS_AGGR_TYPE (TREE_TYPE (rhs)))\n-    return convert (type, rhs);\n+    return cp_convert (type, rhs);\n   /* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */\n   else if (TREE_CODE (type) == POINTER_TYPE\n \t   && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t       || TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n \t   && TREE_TYPE (rhs)\n \t   && TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n-    return convert (type, rhs);\n+    return cp_convert (type, rhs);\n \n   cp_error (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n   return error_mark_node;\n@@ -6881,7 +6954,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n       && (TYPE_NEEDS_CONSTRUCTING (type) || TREE_HAS_CONSTRUCTOR (rhs)))\n     {\n       if (flag_ansi_overloading)\n-\treturn cp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n+\treturn ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n       if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n \t{\n@@ -6952,8 +7025,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t  return rhs;\n \t}\n \n-      return cp_convert (type, rhs, CONV_OLD_CONVERT,\n-\t\t\t flags | LOOKUP_NO_CONVERSION);\n+      return ocp_convert (type, rhs, CONV_OLD_CONVERT,\n+\t\t\t  flags | LOOKUP_NO_CONVERSION);\n     }\n \n   if (type == TREE_TYPE (rhs))"}, {"sha": "afd4cd8f2050ad86f2c6a362ecd3287a6a937b23", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c46b43dba86b48bb19d9f7ed231385e02c1abd/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=37c46b43dba86b48bb19d9f7ed231385e02c1abd", "patch": "@@ -816,7 +816,7 @@ digest_init (type, init, tail)\n \n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n       || code == ENUMERAL_TYPE || code == REFERENCE_TYPE\n-      || code == BOOLEAN_TYPE\n+      || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n       || (code == RECORD_TYPE && ! raw_constructor\n \t  && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type))))\n     {"}]}