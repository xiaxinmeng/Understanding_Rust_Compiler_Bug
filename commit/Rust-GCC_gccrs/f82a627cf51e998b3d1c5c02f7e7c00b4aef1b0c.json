{"sha": "f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyYTYyN2NmNTFlOTk4YjNkMWM1YzAyZjdlN2MwMGI0YWVmMWIwYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-30T17:26:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-30T17:26:32Z"}, "message": "cgraphunit.c (cgraph_finalize_compilation_unit): Call finalize_size_functions before further processing.\n\n\t* cgraphunit.c (cgraph_finalize_compilation_unit): Call\n\tfinalize_size_functions before further processing.\n\t* stor-layout.c: Include cgraph.h, tree-inline.h and tree-dump.h.\n\t(variable_size): Call self_referential_size on size expressions\n\tthat contain a PLACEHOLDER_EXPR.\n\t(size_functions): New static variable.\n\t(copy_self_referential_tree_r): New static function.\n\t(self_referential_size): Likewise.\n\t(finalize_size_functions): New global function.\n\t* tree.c: Include tree-inline.h.\n\t(push_without_duplicates): New static function.\n\t(find_placeholder_in_expr): New global function.\n\t(substitute_in_expr) <tcc_declaration>: Return the replacement object\n\ton equality.\n\t<tcc_expression>: Likewise.\n\t<tcc_vl_exp>: If the replacement object is a constant, try to inline\n\tthe call in the expression.\n\t* tree.h (finalize_size_functions): Declare.\n\t(find_placeholder_in_expr): Likewise.\n\t(FIND_PLACEHOLDER_IN_EXPR): New macro.\n\t(substitute_placeholder_in_expr): Update comment.\n\t* tree-inline.c (remap_decl): Do not unshare trees if do_not_unshare\n\tis true.\n\t(copy_tree_body_r): Likewise.\n\t(copy_tree_body): New static function.\n\t(maybe_inline_call_in_expr): New global function.\n\t* tree-inline.h (struct copy_body_data): Add do_not_unshare field.\n\t(maybe_inline_call_in_expr): Declare.\n\t* Makefile.in (tree.o): Depend on TREE_INLINE_H.\n\t(stor-layout.o): Depend on CGRAPH_H, TREE_INLINE_H, TREE_DUMP_H and\n\tGIMPLE_H.\nada/\n\t* gcc-interface/decl.c: Include tree-inline.h.\n\t(annotate_value) <CALL_EXPR>: Try to inline the call in the expression.\n\t* gcc-interface/utils.c (max_size) <CALL_EXPR>: Likewise.\n\t* gcc-interface/utils2.c: Include tree-inline.\n\t(known_alignment) <CALL_EXPR>: Likewise.\n\nFrom-SVN: r149112", "tree": {"sha": "46e380a758cc2f203dbeec25be5417a9a9bca764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e380a758cc2f203dbeec25be5417a9a9bca764"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/comments", "author": null, "committer": null, "parents": [{"sha": "c1a5cfab17521708db174ed25707f2eee57727fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a5cfab17521708db174ed25707f2eee57727fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a5cfab17521708db174ed25707f2eee57727fe"}], "stats": {"total": 876, "additions": 856, "deletions": 20}, "files": [{"sha": "d55f4b8e2925bb8575f826e92c1c4ecc57a69620", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -1,3 +1,37 @@\n+2009-06-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* cgraphunit.c (cgraph_finalize_compilation_unit): Call\n+\tfinalize_size_functions before further processing.\n+\t* stor-layout.c: Include cgraph.h, tree-inline.h and tree-dump.h.\n+\t(variable_size): Call self_referential_size on size expressions\n+\tthat contain a PLACEHOLDER_EXPR.\n+\t(size_functions): New static variable.\n+\t(copy_self_referential_tree_r): New static function.\n+\t(self_referential_size): Likewise.\n+\t(finalize_size_functions): New global function.\n+\t* tree.c: Include tree-inline.h.\n+\t(push_without_duplicates): New static function.\n+\t(find_placeholder_in_expr): New global function.\n+\t(substitute_in_expr) <tcc_declaration>: Return the replacement object\n+\ton equality.\n+\t<tcc_expression>: Likewise.\n+\t<tcc_vl_exp>: If the replacement object is a constant, try to inline\n+\tthe call in the expression.\n+\t* tree.h (finalize_size_functions): Declare.\n+\t(find_placeholder_in_expr): Likewise.\n+\t(FIND_PLACEHOLDER_IN_EXPR): New macro.\n+\t(substitute_placeholder_in_expr): Update comment.\n+\t* tree-inline.c (remap_decl): Do not unshare trees if do_not_unshare\n+\tis true.\n+\t(copy_tree_body_r): Likewise.\n+\t(copy_tree_body): New static function.\n+\t(maybe_inline_call_in_expr): New global function.\n+\t* tree-inline.h (struct copy_body_data): Add do_not_unshare field.\n+\t(maybe_inline_call_in_expr): Declare.\n+\t* Makefile.in (tree.o): Depend on TREE_INLINE_H.\n+\t(stor-layout.o): Depend on CGRAPH_H, TREE_INLINE_H, TREE_DUMP_H and\n+\tGIMPLE_H.\n+\n 2009-06-30  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-dce.c (mark_all_reaching_defs_necessary_1): Always"}, {"sha": "c196aca04dd17e0db0faad604646020ecea92182", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -2127,8 +2127,8 @@ langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    all-tree.def $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \\\n    $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n-   $(REAL_H) gt-tree.h tree-iterator.h $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n-   $(OBSTACK_H) pointer-set.h fixed-value.h\n+   $(REAL_H) gt-tree.h $(TREE_INLINE_H) tree-iterator.h $(BASIC_BLOCK_H) \\\n+   $(TREE_FLOW_H) $(OBSTACK_H) pointer-set.h fixed-value.h\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TOPLEV_H) $(SPLAY_TREE_H) $(TREE_DUMP_H) \\\n    tree-iterator.h $(TREE_PASS_H) $(DIAGNOSTIC_H) $(REAL_H) fixed-value.h\n@@ -2144,7 +2144,7 @@ print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(PARAMS_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) output.h $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \\\n-   $(TOPLEV_H)\n+   $(TOPLEV_H) $(CGRAPH_H) $(TREE_INLINE_H) $(TREE_DUMP_H) $(GIMPLE_H)\n tree-ssa-structalias.o: tree-ssa-structalias.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) output.h \\"}, {"sha": "65d3720c33abffa63824a3b8422ab477c9598c1c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -1,3 +1,11 @@\n+2009-06-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c: Include tree-inline.h.\n+\t(annotate_value) <CALL_EXPR>: Try to inline the call in the expression.\n+\t* gcc-interface/utils.c (max_size) <CALL_EXPR>: Likewise.\n+\t* gcc-interface/utils2.c: Include tree-inline.\n+\t(known_alignment) <CALL_EXPR>: Likewise.\n+\n 2009-06-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* raise-gcc.c: Include dwarf2.h conditionally."}, {"sha": "f380213c87412b67dc4c74f6fe426ba1b42f4f8d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -33,6 +33,7 @@\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"expr.h\"\n+#include \"tree-inline.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -7190,6 +7191,15 @@ annotate_value (tree gnu_size)\n     case EQ_EXPR:\t\ttcode = Eq_Expr; break;\n     case NE_EXPR:\t\ttcode = Ne_Expr; break;\n \n+    case CALL_EXPR:\n+      {\n+\ttree t = maybe_inline_call_in_expr (gnu_size);\n+\tif (t)\n+\t  return annotate_value (t);\n+      }\n+\n+      /* Fall through... */\n+\n     default:\n       return No_Uint;\n     }"}, {"sha": "aa12eb77506fd545ec682e8c6083fd791970c595", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -2333,10 +2333,15 @@ max_size (tree exp, bool max_p)\n     case tcc_vl_exp:\n       if (code == CALL_EXPR)\n \t{\n-\t  tree *argarray;\n-\t  int i, n = call_expr_nargs (exp);\n-\t  gcc_assert (n > 0);\n+\t  tree t, *argarray;\n+\t  int n, i;\n+\n+\t  t = maybe_inline_call_in_expr (exp);\n+\t  if (t)\n+\t    return max_size (t, max_p);\n \n+\t  n = call_expr_nargs (exp);\n+\t  gcc_assert (n > 0);\n \t  argarray = (tree *) alloca (n * sizeof (tree));\n \t  for (i = 0; i < n; i++)\n \t    argarray[i] = max_size (CALL_EXPR_ARG (exp, i), max_p);"}, {"sha": "8ee9d4db918d964598913a0c527e3c030eda9802", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -31,6 +31,7 @@\n #include \"ggc.h\"\n #include \"flags.h\"\n #include \"output.h\"\n+#include \"tree-inline.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -215,6 +216,15 @@ known_alignment (tree exp)\n       this_alignment = expr_align (TREE_OPERAND (exp, 0));\n       break;\n \n+    case CALL_EXPR:\n+      {\n+\ttree t = maybe_inline_call_in_expr (exp);\n+\tif (t)\n+\t  return known_alignment (t);\n+      }\n+\n+      /* Fall through... */\n+\n     default:\n       /* For other pointer expressions, we assume that the pointed-to object\n \t is at least as aligned as the pointed-to type.  Beware that we can"}, {"sha": "97c28f43ea8d6f9cc83b86669b634a6a191b3698", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -1012,6 +1012,7 @@ cgraph_finalize_compilation_unit (void)\n   if (errorcount || sorrycount)\n     return;\n \n+  finalize_size_functions ();\n   finish_aliases_1 ();\n \n   if (!quiet_flag)"}, {"sha": "84f65e1d246fd2d1e0db47b55498c3149f547cf2", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 216, "deletions": 5, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -37,6 +37,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"regs.h\"\n #include \"params.h\"\n+#include \"cgraph.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-dump.h\"\n+#include \"gimple.h\"\n \n /* Data type for the expressions representing sizes of data types.\n    It is the first integer type laid out.  */\n@@ -53,6 +57,7 @@ unsigned int initial_max_fld_align = TARGET_DEFAULT_PACK_STRUCT;\n    called only by a front end.  */\n static int reference_types_internal = 0;\n \n+static tree self_referential_size (tree);\n static void finalize_record_size (record_layout_info);\n static void finalize_type_size (tree);\n static void place_union_field (record_layout_info, tree);\n@@ -117,13 +122,19 @@ variable_size (tree size)\n {\n   tree save;\n \n+  /* Obviously.  */\n+  if (TREE_CONSTANT (size))\n+    return size;\n+\n+  /* If the size is self-referential, we can't make a SAVE_EXPR (see\n+     save_expr for the rationale).  But we can do something else.  */\n+  if (CONTAINS_PLACEHOLDER_P (size))\n+    return self_referential_size (size);\n+\n   /* If the language-processor is to take responsibility for variable-sized\n      items (e.g., languages which have elaboration procedures like Ada),\n-     just return SIZE unchanged.  Likewise for self-referential sizes and\n-     constant sizes.  */\n-  if (TREE_CONSTANT (size)\n-      || lang_hooks.decls.global_bindings_p () < 0\n-      || CONTAINS_PLACEHOLDER_P (size))\n+     just return SIZE unchanged.  */\n+  if (lang_hooks.decls.global_bindings_p () < 0)\n     return size;\n \n   size = save_expr (size);\n@@ -157,6 +168,206 @@ variable_size (tree size)\n \n   return size;\n }\n+\n+/* An array of functions used for self-referential size computation.  */\n+static GTY(()) VEC (tree, gc) *size_functions;\n+\n+/* Similar to copy_tree_r but do not copy component references involving\n+   PLACEHOLDER_EXPRs.  These nodes are spotted in find_placeholder_in_expr\n+   and substituted in substitute_in_expr.  */\n+\n+static tree\n+copy_self_referential_tree_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  enum tree_code code = TREE_CODE (*tp);\n+\n+  /* Stop at types, decls, constants like copy_tree_r.  */\n+  if (TREE_CODE_CLASS (code) == tcc_type\n+      || TREE_CODE_CLASS (code) == tcc_declaration\n+      || TREE_CODE_CLASS (code) == tcc_constant)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  /* This is the pattern built in ada/make_aligning_type.  */\n+  else if (code == ADDR_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (*tp, 0)) == PLACEHOLDER_EXPR)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  /* Default case: the component reference.  */\n+  else if (code == COMPONENT_REF)\n+    {\n+      tree inner;\n+      for (inner = TREE_OPERAND (*tp, 0);\n+\t   REFERENCE_CLASS_P (inner);\n+\t   inner = TREE_OPERAND (inner, 0))\n+\t;\n+\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n+\t{\n+\t  *walk_subtrees = 0;\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  /* We're not supposed to have them in self-referential size trees\n+     because we wouldn't properly control when they are evaluated.\n+     However, not creating superfluous SAVE_EXPRs requires accurate\n+     tracking of readonly-ness all the way down to here, which we\n+     cannot always guarantee in practice.  So punt in this case.  */\n+  else if (code == SAVE_EXPR)\n+    return error_mark_node;\n+\n+  return copy_tree_r (tp, walk_subtrees, data);\n+}\n+\n+/* Given a SIZE expression that is self-referential, return an equivalent\n+   expression to serve as the actual size expression for a type.  */\n+\n+static tree\n+self_referential_size (tree size)\n+{\n+  static unsigned HOST_WIDE_INT fnno = 0;\n+  VEC (tree, heap) *self_refs = NULL;\n+  tree param_type_list = NULL, param_decl_list = NULL, arg_list = NULL;\n+  tree t, ref, return_type, fntype, fnname, fndecl;\n+  unsigned int i;\n+  char buf[128];\n+\n+  /* Do not factor out simple operations.  */\n+  t = skip_simple_arithmetic (size);\n+  if (TREE_CODE (t) == CALL_EXPR)\n+    return size;\n+\n+  /* Collect the list of self-references in the expression.  */\n+  find_placeholder_in_expr (size, &self_refs);\n+  gcc_assert (VEC_length (tree, self_refs) > 0);\n+\n+  /* Obtain a private copy of the expression.  */\n+  t = size;\n+  if (walk_tree (&t, copy_self_referential_tree_r, NULL, NULL) != NULL_TREE)\n+    return size;\n+  size = t;\n+\n+  /* Build the parameter and argument lists in parallel; also\n+     substitute the former for the latter in the expression.  */\n+  for (i = 0; VEC_iterate (tree, self_refs, i, ref); i++)\n+    {\n+      tree subst, param_name, param_type, param_decl;\n+\n+      if (DECL_P (ref))\n+\t{\n+\t  /* We shouldn't have true variables here.  */\n+\t  gcc_assert (TREE_READONLY (ref));\n+\t  subst = ref;\n+\t}\n+      /* This is the pattern built in ada/make_aligning_type.  */\n+      else if (TREE_CODE (ref) == ADDR_EXPR)\n+        subst = ref;\n+      /* Default case: the component reference.  */\n+      else\n+\tsubst = TREE_OPERAND (ref, 1);\n+\n+      sprintf (buf, \"p%d\", i);\n+      param_name = get_identifier (buf);\n+      param_type = TREE_TYPE (ref);\n+      param_decl\n+\t= build_decl (input_location, PARM_DECL, param_name, param_type);\n+      if (targetm.calls.promote_prototypes (NULL_TREE)\n+\t  && INTEGRAL_TYPE_P (param_type)\n+\t  && TYPE_PRECISION (param_type) < TYPE_PRECISION (integer_type_node))\n+\tDECL_ARG_TYPE (param_decl) = integer_type_node;\n+      else\n+\tDECL_ARG_TYPE (param_decl) = param_type;\n+      DECL_ARTIFICIAL (param_decl) = 1;\n+      TREE_READONLY (param_decl) = 1;\n+\n+      size = substitute_in_expr (size, subst, param_decl);\n+\n+      param_type_list = tree_cons (NULL_TREE, param_type, param_type_list);\n+      param_decl_list = chainon (param_decl, param_decl_list);\n+      arg_list = tree_cons (NULL_TREE, ref, arg_list);\n+    }\n+\n+  VEC_free (tree, heap, self_refs);\n+\n+  /* Append 'void' to indicate that the number of parameters is fixed.  */\n+  param_type_list = tree_cons (NULL_TREE, void_type_node, param_type_list);\n+\n+  /* The 3 lists have been created in reverse order.  */\n+  param_type_list = nreverse (param_type_list);\n+  param_decl_list = nreverse (param_decl_list);\n+  arg_list = nreverse (arg_list);\n+\n+  /* Build the function type.  */\n+  return_type = TREE_TYPE (size);\n+  fntype = build_function_type (return_type, param_type_list);\n+\n+  /* Build the function declaration.  */\n+  sprintf (buf, \"SZ\"HOST_WIDE_INT_PRINT_UNSIGNED, fnno++);\n+  fnname = get_file_function_name (buf);\n+  fndecl = build_decl (input_location, FUNCTION_DECL, fnname, fntype);\n+  for (t = param_decl_list; t; t = TREE_CHAIN (t))\n+    DECL_CONTEXT (t) = fndecl;\n+  DECL_ARGUMENTS (fndecl) = param_decl_list;\n+  DECL_RESULT (fndecl)\n+    = build_decl (input_location, RESULT_DECL, 0, return_type);\n+  DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n+\n+  /* The function has been created by the compiler and we don't\n+     want to emit debug info for it.  */\n+  DECL_ARTIFICIAL (fndecl) = 1;\n+  DECL_IGNORED_P (fndecl) = 1;\n+\n+  /* It is supposed to be \"const\" and never throw.  */\n+  TREE_READONLY (fndecl) = 1;\n+  TREE_NOTHROW (fndecl) = 1;\n+\n+  /* We want it to be inlined when this is deemed profitable, as\n+     well as discarded if every call has been integrated.  */\n+  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+\n+  /* It is made up of a unique return statement.  */\n+  DECL_INITIAL (fndecl) = make_node (BLOCK);\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n+  t = build2 (MODIFY_EXPR, return_type, DECL_RESULT (fndecl), size);\n+  DECL_SAVED_TREE (fndecl) = build1 (RETURN_EXPR, void_type_node, t);\n+  TREE_STATIC (fndecl) = 1;\n+\n+  /* Put it onto the list of size functions.  */\n+  VEC_safe_push (tree, gc, size_functions, fndecl);\n+\n+  /* Replace the original expression with a call to the size function.  */\n+  return build_function_call_expr (fndecl, arg_list);\n+}\n+\n+/* Take, queue and compile all the size functions.  It is essential that\n+   the size functions be gimplified at the very end of the compilation\n+   in order to guarantee transparent handling of self-referential sizes.\n+   Otherwise the GENERIC inliner would not be able to inline them back\n+   at each of their call sites, thus creating artificial non-constant\n+   size expressions which would trigger nasty problems later on.  */\n+\n+void\n+finalize_size_functions (void)\n+{\n+  unsigned int i;\n+  tree fndecl;\n+\n+  for (i = 0; VEC_iterate(tree, size_functions, i, fndecl); i++)\n+    {\n+      dump_function (TDI_original, fndecl);\n+      gimplify_function_tree (fndecl);\n+      dump_function (TDI_generic, fndecl);\n+      cgraph_finalize_function (fndecl, false);\n+    }\n+\n+  VEC_free (tree, gc, size_functions);\n+}\n \f\n #ifndef MAX_FIXED_MODE_SIZE\n #define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)"}, {"sha": "578be4d59b04d34a985624ddbd0f197ff052a5c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -1,3 +1,20 @@\n+2009-06-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/discr12.adb: New test.\n+\t* gnat.dg/discr12_pkg.ads: New helper.\n+\t* gnat.dg/discr13.adb: New test.\n+\t* gnat.dg/discr14.ad[sb]: Likewise.\n+\t* gnat.dg/discr15.adb: Likewise.\n+\t* gnat.dg/discr15_pkg.ads: New helper.\n+\t* gnat.dg/discr16.adb: New test.\n+\t* gnat.dg/discr16_g.ads: New helper.\n+\t* gnat.dg/discr16_pkg.ads: Likewise.\n+\t* gnat.dg/discr16_cont.ads: Likewise.\n+\t* gnat.dg/discr17.adb: New test.\n+\t* gnat.dg/discr18.adb: Likewise.\n+\t* gnat.dg/discr18_pkg.ads: New helper.\n+\t* gnat.dg/discr19.adb: New test.\n+\n 2009-06-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/40576"}, {"sha": "ae72850dd734effab05a5b97e0c3f6c392caf89e", "filename": "gcc/testsuite/gnat.dg/discr12.adb", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr12.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,35 @@\n+-- { dg-do compile }\n+\n+with Discr12_Pkg; use Discr12_Pkg;\n+\n+procedure Discr12 is\n+\n+  subtype Small_Int is Integer range 1..10;\n+\n+  package P is\n+\n+    type PT_W_Disc (D : Small_Int) is private;\n+\n+    type Rec_W_Private (D1 : Integer) is\n+    record\n+      C : PT_W_Disc (D1);\n+    end record;\n+\n+    type Rec_01 (D3 : Integer) is\n+    record\n+      C1 : Rec_W_Private (D3);\n+    end record;\n+\n+    type Arr is array (1 .. 5) of Rec_01(Dummy(0));\n+\n+  private\n+    type PT_W_Disc (D : Small_Int) is \n+    record\n+      Str : String (1 .. D);\n+    end record;\n+\n+  end P;\n+\n+begin\n+  Null;\n+end;"}, {"sha": "785146310bd19539121be217494e988ec3b702f3", "filename": "gcc/testsuite/gnat.dg/discr12_pkg.ads", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr12_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr12_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr12_pkg.ads?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,5 @@\n+package Discr12_Pkg is\n+\n+  function Dummy (I : Integer) return Integer;\n+\n+end Discr12_Pkg;"}, {"sha": "3dcf2150c80d61df1af342801a70eb59a9ae6d07", "filename": "gcc/testsuite/gnat.dg/discr13.adb", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr13.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,30 @@\n+-- { dg-do compile }\n+\n+with Discr12_Pkg; use Discr12_Pkg;\n+\n+procedure Discr13 is\n+\n+  function F1 return Integer is\n+  begin\n+    return Dummy (1);\n+  end F1;\n+\n+  protected type Poe (D3 : Integer := F1) is\n+    entry E (D3 .. F1);    -- F1 evaluated\n+    function Is_Ok (D3 : Integer; E_First : Integer; E_Last : Integer) return Boolean;\n+  end Poe;\n+\n+  protected body Poe is\n+    entry E (for I in D3 .. F1) when True is\n+    begin\n+      null;\n+    end E;\n+    function Is_Ok (D3 : Integer; E_First : Integer; E_Last : Integer) return Boolean is\n+    begin\n+      return False;\n+    end Is_Ok;\n+  end Poe;\n+\n+begin\n+  null;\n+end;"}, {"sha": "490ec4358298bbbe79e76f29e50ef060715f9cca", "filename": "gcc/testsuite/gnat.dg/discr14.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr14.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr14.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr14.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+\n+package body Discr14 is\n+\n+   procedure ASSIGN( TARGET : in out SW_TYPE_INFO ;\n+                     SOURCE : in     SW_TYPE_INFO ) is\n+   begin\n+      TARGET := new T_SW_TYPE_DESCRIPTOR( SOURCE.SW_TYPE, SOURCE.DIMENSION );\n+   end ASSIGN;\n+\n+end Discr14;"}, {"sha": "a6b5a0a87c26d4367c3265fc195d6b04b76bdaa0", "filename": "gcc/testsuite/gnat.dg/discr14.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr14.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr14.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr14.ads?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,42 @@\n+package Discr14 is\n+\n+  type COMPLETION_CODE is (SUCCESS, FAILURE, NONE);\n+\n+  type T_SW_TYPE is (NONE, COMPLETION_CODE_TYPE);       \n+\n+  type T_COMPLETION_CODE_RANGE (CONSTRAINED: BOOLEAN := FALSE) is\n+  record\n+     case CONSTRAINED is\n+        when TRUE =>\n+           FIRST  : COMPLETION_CODE := SUCCESS;\n+           LAST   : COMPLETION_CODE := FAILURE;\n+        when FALSE =>\n+           null;\n+     end case;\n+  end record;\n+\n+  type T_SW_DIMENSIONS is range 0 .. 3;\n+\n+  type T_SW_INDEX_LIST is array (T_SW_DIMENSIONS range <>) of POSITIVE;\n+\n+  type T_SW_TYPE_DESCRIPTOR (SW_TYPE   :  T_SW_TYPE       := NONE;\n+                             DIMENSION :  T_SW_DIMENSIONS := 0)  is\n+  record\n+     BOUNDS : T_SW_INDEX_LIST (1 .. DIMENSION);\n+\n+     case SW_TYPE is\n+\n+        when COMPLETION_CODE_TYPE  =>\n+           COMPLETION_CODE_RANGE   : T_COMPLETION_CODE_RANGE;\n+\n+        when OTHERS  =>\n+           null;\n+\n+     end case;\n+  end record;\n+\n+  type SW_TYPE_INFO is access T_SW_TYPE_DESCRIPTOR;\n+\n+  procedure ASSIGN(TARGET : in out SW_TYPE_INFO; SOURCE : in SW_TYPE_INFO) ;\n+\n+end Discr14;"}, {"sha": "0030ac7d9064710bc202fc23d47059f3cfa53616", "filename": "gcc/testsuite/gnat.dg/discr15.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr15.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr15.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr15.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,14 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+with Discr15_Pkg; use Discr15_Pkg;\n+\n+procedure Discr15 (History : in Rec_Multi_Moment_History) is\n+\n+  Sub: constant Rec_Multi_Moment_History := Sub_History_Of (History);\n+  subtype Vec is String(0..Sub.Last);\n+  Mmts : array(1..Sub.Size) of Vec;\n+\n+begin\n+  null;\n+end;"}, {"sha": "1f3bf286ba19448fc85ec3969927f64bf4dd19c2", "filename": "gcc/testsuite/gnat.dg/discr15_pkg.ads", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr15_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr15_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr15_pkg.ads?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,16 @@\n+package Discr15_Pkg is\n+\n+   type Moment is new Positive;\n+\n+   type Multi_Moment_History is array (Natural range <>, Moment range <>) of Float;\n+\n+   type Rec_Multi_Moment_History (Len : Natural; Size : Moment) is\n+   record\n+      Moments : Multi_Moment_History(0..Len, 1..Size);\n+      Last    : Natural;\n+   end record;\n+\n+   function Sub_History_Of (History : Rec_Multi_Moment_History)\n+      return Rec_Multi_Moment_History;\n+\n+end Discr15_Pkg;"}, {"sha": "c4c24fd4d9c1481025057b3be907570ec3006c9a", "filename": "gcc/testsuite/gnat.dg/discr16.adb", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,23 @@\n+-- { dg-do compile }\n+\n+with Discr16_G;\n+with Discr16_Cont; use Discr16_Cont;\n+\n+procedure Discr16 is\n+\n+  generic\n+    type T is (<>);\n+  function MAX_ADD_G(X : T; I : INTEGER) return T;\n+\n+  function MAX_ADD_G(X : T; I : INTEGER) return T is\n+  begin\n+    return T'val(T'pos(X) + LONG_INTEGER(I));\n+  end;\n+\n+  function MAX_ADD is new MAX_ADD_G(ES6A);\n+\n+  package P is new Discr16_G(ES6A, MAX_ADD);\n+\n+begin\n+  null;\n+end;"}, {"sha": "ea041cadfef90c2edfd7aa23923025aad2bb2142", "filename": "gcc/testsuite/gnat.dg/discr16_cont.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_cont.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_cont.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_cont.ads?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,7 @@\n+with Discr16_Pkg; use Discr16_Pkg;\n+\n+package Discr16_Cont is\n+\n+  type ES6a is new ET3a range E2..E4;\n+\n+end;"}, {"sha": "f163f75d9201cb67859de6ff83b2cf8fcc1f4df3", "filename": "gcc/testsuite/gnat.dg/discr16_g.ads", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_g.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_g.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_g.ads?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,18 @@\n+generic\n+\n+  type T is (<>);\n+  with function MAX_ADD(X : T; I : INTEGER) return T;\n+\n+package Discr16_G is\n+\n+  LO : T := T'val(T'pos(T'first));\n+  HI : T := T'val(T'pos(MAX_ADD(LO, 15)));\n+\n+  type A2 is array(T range <>) of T;\n+\n+  type R2(D : T) is\n+  record\n+    C : A2(LO..D);\n+  end record;\n+\n+end;"}, {"sha": "985785f660d268b32f5b2295a8efe31863fb5bf2", "filename": "gcc/testsuite/gnat.dg/discr16_pkg.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr16_pkg.ads?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,7 @@\n+package Discr16_Pkg is\n+\n+  type ET3a is (E1, E2, E3, E4, E5);\n+  for ET3a use (E1=> 32_001, E2=> 32_002, E3=> 32_003,\n+                E4=> 32_004, E5=> 32_005);\n+\n+end;"}, {"sha": "d7b480c07d940cde43b504464a0a8d87f982c8c7", "filename": "gcc/testsuite/gnat.dg/discr17.adb", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr17.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr17.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr17.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,66 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+procedure Discr17 is\n+\n+  F1_Poe : Integer := 18;\n+\n+  function F1 return Integer is\n+  begin\n+    F1_Poe := F1_Poe - 1;\n+    return F1_Poe;\n+ end F1;\n+\n+  generic\n+    type T is limited private;\n+    with function Is_Ok (X : T) return Boolean;\n+  procedure Check;\n+\n+  procedure Check is\n+  begin\n+\n+    declare\n+      type Poe is new T;\n+      X : Poe;\n+      Y : Poe;\n+    begin\n+      null;\n+    end;\n+\n+    declare\n+      type Poe is new T;\n+      type Arr is array (1 .. 2) of Poe;\n+      X : Arr;\n+      B : Boolean := Is_Ok (T (X (1)));\n+    begin\n+      null;\n+    end;\n+\n+ end;\n+\n+  protected type Poe (D3 : Integer := F1) is\n+    entry E (D3 .. F1);    -- F1 evaluated\n+    function Is_Ok return Boolean;\n+  end Poe;\n+\n+  protected body Poe is\n+    entry E (for I in D3 .. F1) when True is\n+    begin\n+      null;\n+    end E;\n+    function Is_Ok return Boolean is\n+    begin\n+      return False;\n+    end Is_Ok;\n+  end Poe;\n+\n+  function Is_Ok (C : Poe) return Boolean is\n+  begin\n+    return C.Is_Ok;\n+  end Is_Ok;\n+\n+  procedure Chk is new Check (Poe, Is_Ok);\n+\n+begin\n+   Chk;\n+end;"}, {"sha": "bd3fd7944594f33015b4e54357ac929d155c3d57", "filename": "gcc/testsuite/gnat.dg/discr18.adb", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr18.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr18.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr18.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,19 @@\n+-- { dg-do compile }\n+\n+with Discr18_Pkg; use Discr18_Pkg;\n+\n+procedure Discr18 is\n+\n+  String_10 : String (1..10) := \"1234567890\";\n+\n+  MD : Multiple_Discriminants (A => 10, B => 10) :=\n+         Multiple_Discriminants'(A  => 10,\n+                                 B  => 10,\n+                                 S1 => String_10,\n+                                 S2 => String_10);\n+  MDE : Multiple_Discriminant_Extension (C => 10) :=\n+          (MD with C  => 10, S3 => String_10);\n+\n+begin\n+  Do_Something(MDE);\n+end;"}, {"sha": "72f7fec9529c3e1ecdb08e9500c6d12efe382a6b", "filename": "gcc/testsuite/gnat.dg/discr18_pkg.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr18_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr18_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr18_pkg.ads?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,19 @@\n+package Discr18_Pkg is\n+\n+   subtype Length is Natural range 0..256;\n+\n+   type Multiple_Discriminants (A, B : Length) is tagged\n+      record\n+         S1 : String (1..A);\n+         S2 : String (1..B);\n+      end record;\n+\n+   procedure Do_Something (Rec : in out Multiple_Discriminants);\n+\n+   type Multiple_Discriminant_Extension (C : Length) is\n+      new Multiple_Discriminants (A => C, B => C)\n+      with record\n+         S3 : String (1..C);\n+      end record;\n+\n+end Discr18_Pkg;"}, {"sha": "8f5c56b3fb5d74a6ab29297469d7c89805f091ab", "filename": "gcc/testsuite/gnat.dg/discr19.adb", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr19.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr19.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr19.adb?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -0,0 +1,16 @@\n+-- { dg-do compile }\n+\n+procedure Discr19 is\n+\n+   type Arr_Int_T is array (Integer range <>) of Integer;\n+\n+   type Abs_Tag_Rec_T (N : Integer; M : Integer) is abstract tagged record\n+      Arr_Int : Arr_Int_T (1..M);\n+   end record;\n+\n+   type Tag_Rec_T (M : Integer)\n+     is new Abs_Tag_Rec_T (N => 1, M => M) with null record;\n+\n+begin\n+   null;\n+end;"}, {"sha": "648e30b47b366c1ec80b46c65951958571fd6a14", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -287,7 +287,10 @@ remap_decl (tree decl, copy_body_data *id)\n       return t;\n     }\n \n-  return unshare_expr (*n);\n+  if (id->do_not_unshare)\n+    return *n;\n+  else\n+    return unshare_expr (*n);\n }\n \n static tree\n@@ -997,7 +1000,10 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t\t but we absolutely rely on that.  As fold_indirect_ref\n \t         does other useful transformations, try that first, though.  */\n \t      tree type = TREE_TYPE (TREE_TYPE (*n));\n-\t      new_tree = unshare_expr (*n);\n+\t      if (id->do_not_unshare)\n+\t\tnew_tree = *n;\n+\t      else\n+\t\tnew_tree = unshare_expr (*n);\n \t      old = *tp;\n \t      *tp = gimple_fold_indirect_ref (new_tree);\n \t      if (! *tp)\n@@ -1993,6 +1999,20 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   return new_fndecl;\n }\n \n+/* Make a copy of the body of SRC_FN so that it can be inserted inline in\n+   another function.  */\n+\n+static tree\n+copy_tree_body (copy_body_data *id)\n+{\n+  tree fndecl = id->src_fn;\n+  tree body = DECL_SAVED_TREE (fndecl);\n+\n+  walk_tree (&body, copy_tree_body_r, id, NULL);\n+\n+  return body;\n+}\n+\n static tree\n copy_body (copy_body_data *id, gcov_type count, int frequency,\n \t   basic_block entry_block_map, basic_block exit_block_map)\n@@ -4605,6 +4625,60 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   return;\n }\n \n+/* EXP is CALL_EXPR present in a GENERIC expression tree.  Try to integrate\n+   the callee and return the inlined body on success.  */\n+\n+tree\n+maybe_inline_call_in_expr (tree exp)\n+{\n+  tree fn = get_callee_fndecl (exp);\n+\n+  /* We can only try to inline \"const\" functions.  */\n+  if (fn && TREE_READONLY (fn) && DECL_SAVED_TREE (fn))\n+    {\n+      struct pointer_map_t *decl_map = pointer_map_create ();\n+      call_expr_arg_iterator iter;\n+      copy_body_data id;\n+      tree param, arg, t;\n+\n+      /* Remap the parameters.  */\n+      for (param = DECL_ARGUMENTS (fn), arg = first_call_expr_arg (exp, &iter);\n+\t   param;\n+\t   param = TREE_CHAIN (param), arg = next_call_expr_arg (&iter))\n+\t*pointer_map_insert (decl_map, param) = arg;\n+\n+      memset (&id, 0, sizeof (id));\n+      id.src_fn = fn;\n+      id.dst_fn = current_function_decl;\n+      id.src_cfun = DECL_STRUCT_FUNCTION (fn);\n+      id.decl_map = decl_map;\n+\n+      id.copy_decl = copy_decl_no_change;\n+      id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+      id.transform_new_cfg = false;\n+      id.transform_return_to_modify = true;\n+      id.transform_lang_insert_block = false;\n+\n+      /* Make sure not to unshare trees behind the front-end's back\n+\t since front-end specific mechanisms may rely on sharing.  */\n+      id.regimplify = false;\n+      id.do_not_unshare = true;\n+\n+      /* We're not inside any EH region.  */\n+      id.eh_region = -1;\n+\n+      t = copy_tree_body (&id);\n+      pointer_map_destroy (decl_map);\n+\n+      /* We can only return something suitable for use in a GENERIC\n+\t expression tree.  */\n+      if (TREE_CODE (t) == MODIFY_EXPR)\n+\treturn TREE_OPERAND (t, 1);\n+    }\n+\n+   return NULL_TREE;\n+}\n+\n /* Duplicate a type, fields and all.  */\n \n tree"}, {"sha": "542eb729727eb05568a92e187094049a6013900e", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -102,6 +102,9 @@ typedef struct copy_body_data\n   /* True if this statement will need to be regimplified.  */\n   bool regimplify;\n \n+  /* True if trees should not be unshared.  */\n+  bool do_not_unshare;\n+\n   /* > 0 if we are remapping a type currently.  */\n   int remapping_type_depth;\n \n@@ -157,6 +160,7 @@ extern tree copy_tree_body_r (tree *, int *, void *);\n extern void insert_decl_map (copy_body_data *, tree, tree);\n \n unsigned int optimize_inline_calls (tree);\n+tree maybe_inline_call_in_expr (tree);\n bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree *, int *, void *);\n tree copy_decl_no_change (tree decl, copy_body_data *id);"}, {"sha": "ad81827052aaf764b01e9f10fccdb214ce09103e", "filename": "gcc/tree.c", "status": "modified", "additions": 118, "deletions": 5, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n+#include \"tree-inline.h\"\n #include \"tree-iterator.h\"\n #include \"basic-block.h\"\n #include \"tree-flow.h\"\n@@ -2678,11 +2679,102 @@ type_contains_placeholder_p (tree type)\n   return result;\n }\n \f\n+/* Push tree EXP onto vector QUEUE if it is not already present.  */\n+\n+static void\n+push_without_duplicates (tree exp, VEC (tree, heap) **queue)\n+{\n+  unsigned int i;\n+  tree iter;\n+\n+  for (i = 0; VEC_iterate (tree, *queue, i, iter); i++)\n+    if (simple_cst_equal (iter, exp) == 1)\n+      break;\n+\n+  if (!iter)\n+    VEC_safe_push (tree, heap, *queue, exp);\n+}\n+\n+/* Given a tree EXP, find all occurences of references to fields\n+   in a PLACEHOLDER_EXPR and place them in vector REFS without\n+   duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that\n+   we assume here that EXP contains only arithmetic expressions\n+   or CALL_EXPRs with PLACEHOLDER_EXPRs occurring only in their\n+   argument list.  */\n+\n+void\n+find_placeholder_in_expr (tree exp, VEC (tree, heap) **refs)\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  tree inner;\n+  int i;\n+\n+  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n+  if (code == TREE_LIST)\n+    {\n+      FIND_PLACEHOLDER_IN_EXPR (TREE_CHAIN (exp), refs);\n+      FIND_PLACEHOLDER_IN_EXPR (TREE_VALUE (exp), refs);\n+    }\n+  else if (code == COMPONENT_REF)\n+    {\n+      for (inner = TREE_OPERAND (exp, 0);\n+\t   REFERENCE_CLASS_P (inner);\n+\t   inner = TREE_OPERAND (inner, 0))\n+\t;\n+\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n+\tpush_without_duplicates (exp, refs);\n+      else\n+\tFIND_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), refs);\n+   }\n+  else\n+    switch (TREE_CODE_CLASS (code))\n+      {\n+      case tcc_constant:\n+\tbreak;\n+\n+      case tcc_declaration:\n+\t/* Variables allocated to static storage can stay.  */\n+        if (!TREE_STATIC (exp))\n+\t  push_without_duplicates (exp, refs);\n+\tbreak;\n+\n+      case tcc_expression:\n+\t/* This is the pattern built in ada/make_aligning_type.  */\n+\tif (code == ADDR_EXPR\n+\t    && TREE_CODE (TREE_OPERAND (exp, 0)) == PLACEHOLDER_EXPR)\n+\t  {\n+\t    push_without_duplicates (exp, refs);\n+\t    break;\n+\t  }\n+\n+        /* Fall through...  */\n+\n+      case tcc_exceptional:\n+      case tcc_unary:\n+      case tcc_binary:\n+      case tcc_comparison:\n+      case tcc_reference:\n+\tfor (i = 0; i < TREE_CODE_LENGTH (code); i++)\n+\t  FIND_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, i), refs);\n+\tbreak;\n+\n+      case tcc_vl_exp:\n+\tfor (i = 1; i < TREE_OPERAND_LENGTH (exp); i++)\n+\t  FIND_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, i), refs);\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+}\n+\n /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n    return a tree with all occurrences of references to F in a\n-   PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP\n-   contains only arithmetic expressions or a CALL_EXPR with a\n-   PLACEHOLDER_EXPR occurring only in its arglist.  */\n+   PLACEHOLDER_EXPR replaced by R.  Also handle VAR_DECLs and\n+   CONST_DECLs.  Note that we assume here that EXP contains only\n+   arithmetic expressions or CALL_EXPRs with PLACEHOLDER_EXPRs\n+   occurring only in their argument list.  */\n \n tree\n substitute_in_expr (tree exp, tree f, tree r)\n@@ -2733,14 +2825,24 @@ substitute_in_expr (tree exp, tree f, tree r)\n     switch (TREE_CODE_CLASS (code))\n       {\n       case tcc_constant:\n-      case tcc_declaration:\n \treturn exp;\n \n+      case tcc_declaration:\n+\tif (exp == f)\n+\t  return r;\n+\telse\n+\t  return exp;\n+\n+      case tcc_expression:\n+\tif (exp == f)\n+\t  return r;\n+\n+        /* Fall through...  */\n+\n       case tcc_exceptional:\n       case tcc_unary:\n       case tcc_binary:\n       case tcc_comparison:\n-      case tcc_expression:\n       case tcc_reference:\n \tswitch (TREE_CODE_LENGTH (code))\n \t  {\n@@ -2803,6 +2905,17 @@ substitute_in_expr (tree exp, tree f, tree r)\n \n \t  new_tree = NULL_TREE;\n \n+\t  /* If we are trying to replace F with a constant, inline back\n+\t     functions which do nothing else than computing a value from\n+\t     the arguments they are passed.  This makes it possible to\n+\t     fold partially or entirely the replacement expression.  */\n+\t  if (CONSTANT_CLASS_P (r) && code == CALL_EXPR)\n+\t    {\n+\t      tree t = maybe_inline_call_in_expr (exp);\n+\t      if (t)\n+\t\treturn SUBSTITUTE_IN_EXPR (t, f, r);\n+\t    }\n+\n \t  for (i = 1; i < TREE_OPERAND_LENGTH (exp); i++)\n \t    {\n \t      tree op = TREE_OPERAND (exp, i);"}, {"sha": "e2eb76e802102f73035463dfbdfff31f2d7bc26e", "filename": "gcc/tree.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f82a627cf51e998b3d1c5c02f7e7c00b4aef1b0c", "patch": "@@ -4216,6 +4216,7 @@ extern tree round_down (tree, int);\n extern tree get_pending_sizes (void);\n extern void put_pending_size (tree);\n extern void put_pending_sizes (tree);\n+extern void finalize_size_functions (void);\n \n /* Type for sizes of data-type.  */\n \n@@ -4361,10 +4362,30 @@ extern bool contains_placeholder_p (const_tree);\n \n extern bool type_contains_placeholder_p (tree);\n \n+/* Given a tree EXP, find all occurences of references to fields\n+   in a PLACEHOLDER_EXPR and place them in vector REFS without\n+   duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that\n+   we assume here that EXP contains only arithmetic expressions\n+   or CALL_EXPRs with PLACEHOLDER_EXPRs occurring only in their\n+   argument list.  */\n+\n+extern void find_placeholder_in_expr (tree, VEC (tree, heap) **);\n+\n+/* This macro calls the above function but short-circuits the common\n+   case of a constant to save time and also checks for NULL.  */\n+\n+#define FIND_PLACEHOLDER_IN_EXPR(EXP, V) \\\n+do {\t\t\t\t\t \\\n+  if((EXP) && !TREE_CONSTANT (EXP))\t \\\n+    find_placeholder_in_expr (EXP, V);\t \\\n+} while (0)\n+\n /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n    return a tree with all occurrences of references to F in a\n-   PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP\n-   contains only arithmetic expressions.  */\n+   PLACEHOLDER_EXPR replaced by R.  Also handle VAR_DECLs and\n+   CONST_DECLs.  Note that we assume here that EXP contains only\n+   arithmetic expressions or CALL_EXPRs with PLACEHOLDER_EXPRs\n+   occurring only in their argument list.  */\n \n extern tree substitute_in_expr (tree, tree, tree);\n "}]}