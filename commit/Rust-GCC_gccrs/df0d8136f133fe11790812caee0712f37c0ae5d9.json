{"sha": "df0d8136f133fe11790812caee0712f37c0ae5d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYwZDgxMzZmMTMzZmUxMTc5MDgxMmNhZWUwNzEyZjM3YzBhZTVkOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-11-16T21:01:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-11-16T21:01:45Z"}, "message": "* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::speculation_consistent_p): Constify.\n\t(ipa_polymorphic_call_context::meet_speculation_with): New function.\n\t(ipa_polymorphic_call_context::combine_with): Handle types in construction\n\tbetter.\n\t(ipa_polymorphic_call_context::equal_to): Do not bother about useless\n\tspeculation.\n\t(ipa_polymorphic_call_context::meet_with): New function.\n\t* cgraph.h (class ipa_polymorphic_call_context): Add\n\tmeet_width, meet_speculation_with; constify speculation_consistent_p.\n\t* ipa-cp.c (ipa_context_from_jfunc): Handle speculation; combine with incomming\n\tcontext.\n\t(propagate_context_accross_jump_function): Likewise; be more cureful.\n\tabout set_contains_variable.\n\t(ipa_get_indirect_edge_target_1): Fix handling of dynamic type changes.\n\t(find_more_scalar_values_for_callers_subset): Fix.\n\t(find_more_contexts_for_caller_subset): Perform meet operation.\n\nFrom-SVN: r217634", "tree": {"sha": "b591fcf9084565e571a8a71a0b47d8f967b437ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b591fcf9084565e571a8a71a0b47d8f967b437ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df0d8136f133fe11790812caee0712f37c0ae5d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0d8136f133fe11790812caee0712f37c0ae5d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df0d8136f133fe11790812caee0712f37c0ae5d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0d8136f133fe11790812caee0712f37c0ae5d9/comments", "author": null, "committer": null, "parents": [{"sha": "70486010428fdaeabd875022fee05122e9866424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70486010428fdaeabd875022fee05122e9866424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70486010428fdaeabd875022fee05122e9866424"}], "stats": {"total": 414, "additions": 375, "deletions": 39}, "files": [{"sha": "d385e334bf7a19446a15ca9009450c1d2b38a2c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df0d8136f133fe11790812caee0712f37c0ae5d9", "patch": "@@ -1,3 +1,23 @@\n+2014-11-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::speculation_consistent_p): Constify.\n+\t(ipa_polymorphic_call_context::meet_speculation_with): New function.\n+\t(ipa_polymorphic_call_context::combine_with): Handle types in construction\n+\tbetter.\n+\t(ipa_polymorphic_call_context::equal_to): Do not bother about useless\n+\tspeculation.\n+\t(ipa_polymorphic_call_context::meet_with): New function.\n+\t* cgraph.h (class ipa_polymorphic_call_context): Add\n+\tmeet_width, meet_speculation_with; constify speculation_consistent_p.\n+\t* ipa-cp.c (ipa_context_from_jfunc): Handle speculation; combine with incomming\n+\tcontext.\n+\t(propagate_context_accross_jump_function): Likewise; be more cureful.\n+\tabout set_contains_variable.\n+\t(ipa_get_indirect_edge_target_1): Fix handling of dynamic type changes.\n+\t(find_more_scalar_values_for_callers_subset): Fix.\n+\t(find_more_contexts_for_caller_subset): Perform meet operation.\n+\n 2014-11-16  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* passes.c (execute_one_pass): Do not apply all transforms prior"}, {"sha": "fc5fe82d1bec97f103561eac7ae96c5329062ac2", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=df0d8136f133fe11790812caee0712f37c0ae5d9", "patch": "@@ -1389,6 +1389,7 @@ class GTY(()) ipa_polymorphic_call_context {\n      If actual type the context is being used in is known, OTR_TYPE should be\n      set accordingly. This improves quality of combined result.  */\n   bool combine_with (ipa_polymorphic_call_context, tree otr_type = NULL);\n+  bool meet_with (ipa_polymorphic_call_context, tree otr_type = NULL);\n \n   /* Return TRUE if context is fully useless.  */\n   bool useless_p () const;\n@@ -1406,9 +1407,10 @@ class GTY(()) ipa_polymorphic_call_context {\n \n private:\n   bool combine_speculation_with (tree, HOST_WIDE_INT, bool, tree);\n+  bool meet_speculation_with (tree, HOST_WIDE_INT, bool, tree);\n   void set_by_decl (tree, HOST_WIDE_INT);\n   bool set_by_invariant (tree, tree, HOST_WIDE_INT);\n-  bool speculation_consistent_p (tree, HOST_WIDE_INT, bool, tree);\n+  bool speculation_consistent_p (tree, HOST_WIDE_INT, bool, tree) const;\n   void make_speculative (tree otr_type = NULL);\n };\n "}, {"sha": "375b49e5f918ae52c69129f5815944f5569643d0", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=df0d8136f133fe11790812caee0712f37c0ae5d9", "patch": "@@ -946,17 +946,17 @@ ipa_context_from_jfunc (ipa_node_params *info, cgraph_edge *cs, int csidx,\n     {\n       ipa_polymorphic_call_context srcctx;\n       int srcidx;\n+      bool type_preserved = true;\n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n \t{\n-\t  if (ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR\n-\t      || !ipa_get_jf_pass_through_type_preserved (jfunc))\n+\t  if (ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n \t    return ctx;\n+\t  type_preserved = ipa_get_jf_pass_through_type_preserved (jfunc);\n \t  srcidx = ipa_get_jf_pass_through_formal_id (jfunc);\n \t}\n       else\n \t{\n-\t  if (!ipa_get_jf_ancestor_type_preserved (jfunc))\n-\t    return ctx;\n+\t  type_preserved = ipa_get_jf_ancestor_type_preserved (jfunc);\n \t  srcidx = ipa_get_jf_ancestor_formal_id (jfunc);\n \t}\n       if (info->ipcp_orig_node)\n@@ -981,7 +981,10 @@ ipa_context_from_jfunc (ipa_node_params *info, cgraph_edge *cs, int csidx,\n \treturn ctx;\n       if (jfunc->type == IPA_JF_ANCESTOR)\n \tsrcctx.offset_by (ipa_get_jf_ancestor_offset (jfunc));\n-      ctx.combine_with (srcctx);\n+      if (!type_preserved)\n+\tsrcctx.possible_dynamic_type_change (cs->in_polymorphic_cdtor);\n+      srcctx.combine_with (ctx);\n+      return srcctx;\n     }\n \n   return ctx;\n@@ -1298,15 +1301,13 @@ propagate_context_accross_jump_function (cgraph_edge *cs,\n     return false;\n   bool ret = false;\n   bool added_sth = false;\n+  bool type_preserved = true;\n \n   ipa_polymorphic_call_context edge_ctx, *edge_ctx_ptr\n     = ipa_get_ith_polymorhic_call_context (args, idx);\n \n   if (edge_ctx_ptr)\n-    {\n-      edge_ctx = *edge_ctx_ptr;\n-      edge_ctx.clear_speculation ();\n-    }\n+    edge_ctx = *edge_ctx_ptr;\n \n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       || jfunc->type == IPA_JF_ANCESTOR)\n@@ -1320,15 +1321,14 @@ propagate_context_accross_jump_function (cgraph_edge *cs,\n \t not set instead of punting.  */\n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n \t{\n-\t  if (ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR\n-\t      || !ipa_get_jf_pass_through_type_preserved (jfunc))\n+\t  if (ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n \t    goto prop_fail;\n+\t  type_preserved = ipa_get_jf_pass_through_type_preserved (jfunc);\n \t  src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n \t}\n       else\n \t{\n-\t  if (!ipa_get_jf_ancestor_type_preserved (jfunc))\n-\t    goto prop_fail;\n+\t  type_preserved = ipa_get_jf_ancestor_type_preserved (jfunc);\n \t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n \t}\n \n@@ -1338,21 +1338,24 @@ propagate_context_accross_jump_function (cgraph_edge *cs,\n \t  && (src_lat->contains_variable\n \t      || (src_lat->values_count > 1)))\n \tgoto prop_fail;\n-      if (src_lat->contains_variable)\n-\t  ret |= dest_lat->set_contains_variable ();\n \n       ipcp_value<ipa_polymorphic_call_context> *src_val;\n       for (src_val = src_lat->values; src_val; src_val = src_val->next)\n \t{\n \t  ipa_polymorphic_call_context cur = src_val->value;\n+\n+\t  if (!type_preserved)\n+\t    cur.possible_dynamic_type_change (cs->in_polymorphic_cdtor);\n \t  if (jfunc->type == IPA_JF_ANCESTOR)\n \t    cur.offset_by (ipa_get_jf_ancestor_offset (jfunc));\n-\t  /* TODO: Perhaps attempt to look up some used OTR type? */\n-\t  cur.clear_speculation ();\n-\t  if (!edge_ctx.useless_p ())\n-\t    cur.combine_with (edge_ctx);\n+\t  /* TODO: In cases we know how the context is going to be used,\n+\t     we can improve the result by passing proper OTR_TYPE.  */\n+\t  cur.combine_with (edge_ctx);\n \t  if (!cur.useless_p ())\n \t    {\n+\t      if (src_lat->contains_variable\n+\t\t  && !edge_ctx.equal_to (cur))\n+\t\tret |= dest_lat->set_contains_variable ();\n \t      ret |= dest_lat->add_value (cur, cs, src_val, src_idx);\n \t      added_sth = true;\n \t    }\n@@ -1848,6 +1851,10 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   if (known_contexts.length () > (unsigned int) param_index)\n     {\n       context = known_contexts[param_index];\n+      context.offset_by (anc_offset);\n+      if (ie->indirect_info->vptr_changed)\n+\tcontext.possible_dynamic_type_change (ie->in_polymorphic_cdtor,\n+\t\t\t\t\t      ie->indirect_info->otr_type);\n       if (t)\n \t{\n \t  ipa_polymorphic_call_context ctx2 = ipa_polymorphic_call_context\n@@ -3160,6 +3167,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n       struct cgraph_edge *cs;\n       tree newval = NULL_TREE;\n       int j;\n+      bool first = true;\n \n       if (ipa_get_scalar_lat (info, i)->bottom || known_csts[i])\n \tcontinue;\n@@ -3178,13 +3186,15 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t  t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func);\n \t  if (!t\n \t      || (newval\n-\t\t  && !values_equal_for_ipcp_p (t, newval)))\n+\t\t  && !values_equal_for_ipcp_p (t, newval))\n+\t      || (!first && !newval))\n \t    {\n \t      newval = NULL_TREE;\n \t      break;\n \t    }\n \t  else\n \t    newval = t;\n+\t  first = false;\n \t}\n \n       if (newval)\n@@ -3226,7 +3236,7 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n \tcontinue;\n \n       ipa_polymorphic_call_context newval;\n-      bool found = false;\n+      bool first = true;\n       int j;\n \n       FOR_EACH_VEC_ELT (callers, j, cs)\n@@ -3238,21 +3248,18 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n \t  ipa_polymorphic_call_context ctx;\n \t  ctx = ipa_context_from_jfunc (IPA_NODE_REF (cs->caller), cs, i,\n \t\t\t\t\tjfunc);\n-\t  ctx.clear_speculation ();\n-\t  if (ctx.useless_p ()\n-\t      || (found && !values_equal_for_ipcp_p (newval, ctx)))\n-\t    {\n-\t      found = false;\n-\t      break;\n-\t    }\n-\t  else if (!found)\n+\t  if (first)\n \t    {\n-\t      found = true;\n \t      newval = ctx;\n+\t      first = false;\n \t    }\n+\t  else\n+\t    newval.meet_with (ctx);\n+\t  if (newval.useless_p ())\n+\t    break;\n \t}\n \n-      if (found)\n+      if (!newval.useless_p ())\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {"}, {"sha": "452f2d26a5a50e9c0774a23892991363733c1826", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 314, "deletions": 7, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0d8136f133fe11790812caee0712f37c0ae5d9/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=df0d8136f133fe11790812caee0712f37c0ae5d9", "patch": "@@ -1727,7 +1727,7 @@ bool\n ipa_polymorphic_call_context::speculation_consistent_p (tree spec_outer_type,\n \t\t\t\t\t\t\tHOST_WIDE_INT spec_offset,\n \t\t\t\t\t\t\tbool spec_maybe_derived_type,\n-\t\t\t\t\t\t\ttree otr_type)\n+\t\t\t\t\t\t\ttree otr_type) const\n {\n   if (!flag_devirtualize_speculatively)\n     return false;\n@@ -1873,6 +1873,102 @@ ipa_polymorphic_call_context::combine_speculation_with\n   return false;\n }\n \n+/* Make speculation less specific so\n+   NEW_OUTER_TYPE, NEW_OFFSET, NEW_MAYBE_DERIVED_TYPE is also included.\n+   If OTR_TYPE is set, assume the context is used with OTR_TYPE.  */\n+\n+bool\n+ipa_polymorphic_call_context::meet_speculation_with\n+   (tree new_outer_type, HOST_WIDE_INT new_offset, bool new_maybe_derived_type,\n+    tree otr_type)\n+{\n+  if (!new_outer_type && speculative_outer_type)\n+    {\n+      clear_speculation ();\n+      return true;\n+    }\n+\n+  /* restrict_to_inner_class may eliminate wrong speculation making our job\n+     easeier.  */\n+  if (otr_type)\n+    restrict_to_inner_class (otr_type);\n+\n+  if (!speculative_outer_type\n+      || !speculation_consistent_p (speculative_outer_type,\n+\t\t\t\t    speculative_offset,\n+\t\t\t\t    speculative_maybe_derived_type,\n+\t\t\t\t    otr_type))\n+    return false;\n+\n+  if (!speculation_consistent_p (new_outer_type, new_offset,\n+\t\t\t\t new_maybe_derived_type, otr_type))\n+    {\n+      clear_speculation ();\n+      return true;\n+    }\n+\n+  else if (types_must_be_same_for_odr (speculative_outer_type,\n+\t\t\t\t       new_outer_type))\n+    {\n+      if (speculative_offset != new_offset)\n+\t{\n+\t  clear_speculation ();\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  if (!speculative_maybe_derived_type && new_maybe_derived_type)\n+\t    {\n+\t      speculative_maybe_derived_type = true;\n+\t      return true;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+    }\n+  /* See if one type contains the other as a field (not base).  */\n+  else if (contains_type_p (new_outer_type, new_offset - speculative_offset,\n+\t\t\t    speculative_outer_type, false, false))\n+    return false;\n+  else if (contains_type_p (speculative_outer_type,\n+\t\t\t    speculative_offset - new_offset,\n+\t\t\t    new_outer_type, false, false))\n+    {\n+      speculative_outer_type = new_outer_type;\n+      speculative_offset = new_offset;\n+      speculative_maybe_derived_type = new_maybe_derived_type;\n+      return true;\n+    }\n+  /* See if OUTER_TYPE is base of CTX.OUTER_TYPE.  */\n+  else if (contains_type_p (new_outer_type,\n+\t\t\t    new_offset - speculative_offset,\n+\t\t\t    speculative_outer_type, false, true))\n+    {\n+      if (!speculative_maybe_derived_type)\n+\t{\n+\t  speculative_maybe_derived_type = true;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  /* See if CTX.OUTER_TYPE is base of OUTER_TYPE.  */\n+  else if (contains_type_p (speculative_outer_type,\n+\t\t\t    speculative_offset - new_offset, new_outer_type, false, true))\n+    {\n+      speculative_outer_type = new_outer_type;\n+      speculative_offset = new_offset;\n+      speculative_maybe_derived_type = true;\n+      return true;\n+    }\n+  else\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"Giving up on speculative meet\\n\");\n+      clear_speculation ();\n+      return true;\n+    }\n+}\n+\n /* Assume that both THIS and a given context is valid and strenghten THIS\n    if possible.  Return true if any strenghtening was made.\n    If actual type the context is being used in is known, OTR_TYPE should be\n@@ -2065,6 +2161,16 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \t\tfprintf (dump_file, \"First context does not permit base -> invalid\\n\");\n \t      goto invalidate;\n \t    }\n+\t  /* Pick the base type.  */\n+\t  else if (maybe_in_construction)\n+\t    {\n+\t      outer_type = ctx.outer_type;\n+\t      maybe_in_construction = ctx.maybe_in_construction;\n+\t      maybe_derived_type = ctx.maybe_derived_type;\n+\t      offset = ctx.offset;\n+\t      dynamic = ctx.dynamic;\n+\t      updated = true;\n+\t    }\n \t}\n     }\n   /* TODO handle merging using hiearchy. */\n@@ -2160,19 +2266,220 @@ ipa_polymorphic_call_context::equal_to\n   else if (x.outer_type)\n     return false;\n \n-  if (speculative_outer_type)\n+\n+  if (speculative_outer_type\n+      && speculation_consistent_p (speculative_outer_type, speculative_offset,\n+\t\t\t\t   speculative_maybe_derived_type, NULL_TREE))\n     {\n-      if (!x.speculative_outer_type\n-\t  || !types_odr_comparable (speculative_outer_type,\n-\t\t\t\t    x.speculative_outer_type)\n+      if (!x.speculative_outer_type)\n+\treturn false;\n+\n+      if (!types_odr_comparable (speculative_outer_type,\n+\t\t\t\t x.speculative_outer_type)\n \t  || !types_same_for_odr  (speculative_outer_type,\n-\t\t\t\t    x.speculative_outer_type)\n+\t\t\t\t   x.speculative_outer_type)\n \t  || speculative_offset != x.speculative_offset\n \t  || speculative_maybe_derived_type != x.speculative_maybe_derived_type)\n \treturn false;\n     }\n-  else if (x.speculative_outer_type)\n+  else if (x.speculative_outer_type\n+\t   && x.speculation_consistent_p (x.speculative_outer_type,\n+\t\t\t\t\t  x.speculative_offset,\n+\t\t\t\t  \t  x.speculative_maybe_derived_type,\n+\t\t\t\t\t  NULL))\n     return false;\n \n   return true;\n }\n+\n+/* Modify context to be strictly less restrictive than CTX.  */\n+\n+bool\n+ipa_polymorphic_call_context::meet_with (ipa_polymorphic_call_context ctx,\n+\t\t\t\t\t tree otr_type)\n+{\n+  bool updated = false;\n+\n+  if (useless_p () || ctx.invalid)\n+    return false;\n+\n+  /* Restricting context to inner type makes merging easier, however do not\n+     do that unless we know how the context is used (OTR_TYPE is non-NULL)  */\n+  if (otr_type && !useless_p () && !ctx.useless_p ())\n+    {\n+      restrict_to_inner_class (otr_type);\n+      ctx.restrict_to_inner_class (otr_type);\n+      if(invalid)\n+        return false;\n+    }\n+\n+  if (equal_to (ctx))\n+    return false;\n+\n+  if (ctx.useless_p () || invalid)\n+    {\n+      *this = ctx;\n+      return true;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Polymorphic call context meet:\");\n+      dump (dump_file);\n+      fprintf (dump_file, \"With context:                    \");\n+      ctx.dump (dump_file);\n+      if (otr_type)\n+\t{\n+          fprintf (dump_file, \"To be used with type:            \");\n+\t  print_generic_expr (dump_file, otr_type, TDF_SLIM);\n+          fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+\n+  if (!dynamic && ctx.dynamic)\n+    {\n+      dynamic = true;\n+      updated = true;\n+    }\n+\n+  /* If call is known to be invalid, we are done.  */\n+  if (!outer_type)\n+    ;\n+  else if (!ctx.outer_type)\n+    {\n+      clear_outer_type ();\n+      updated = true;\n+    }\n+  /* If types are known to be same, merging is quite easy.  */\n+  else if (types_must_be_same_for_odr (outer_type, ctx.outer_type))\n+    {\n+      if (offset != ctx.offset\n+\t  && TYPE_SIZE (outer_type)\n+\t  && TREE_CODE (TYPE_SIZE (outer_type)) == INTEGER_CST)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Outer types match, offset mismatch -> clearing\\n\");\n+\t  clear_outer_type ();\n+\t  return true;\n+\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"Outer types match, merging flags\\n\");\n+      if (!maybe_in_construction && ctx.maybe_in_construction)\n+\t{\n+\t  updated = true;\n+\t  maybe_in_construction = true;\n+\t}\n+      if (!maybe_derived_type && ctx.maybe_derived_type)\n+\t{\n+\t  updated = true;\n+\t  maybe_derived_type = true;\n+\t}\n+      if (!dynamic && ctx.dynamic)\n+\t{\n+\t  updated = true;\n+\t  dynamic = true;\n+\t}\n+    }\n+  /* See if one type contains the other as a field (not base).  */\n+  else if (contains_type_p (ctx.outer_type, ctx.offset - offset,\n+\t\t\t    outer_type, false, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Second type contain the first as a field\\n\");\n+\n+      /* The second type is more specified, so we keep the first.\n+         We need to set DYNAMIC flag to avoid declaring context INVALID\n+\t of OFFSET ends up being out of range.  */\n+      if (!dynamic\n+\t  && (ctx.dynamic\n+\t      || (!otr_type\n+\t\t  && (!TYPE_SIZE (ctx.outer_type)\n+\t\t      || !TYPE_SIZE (outer_type)\n+\t\t      || !operand_equal_p (TYPE_SIZE (ctx.outer_type),\n+\t\t\t\t\t   TYPE_SIZE (outer_type), 0)))))\n+\t{\n+\t  dynamic = true;\n+\t  updated = true;\n+\t}\n+    }\n+  else if (contains_type_p (outer_type, offset - ctx.offset,\n+\t\t\t    ctx.outer_type, false, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"First type contain the second as a field\\n\");\n+\n+      if (!dynamic\n+\t  && (ctx.dynamic\n+\t      || (!otr_type\n+\t\t  && (!TYPE_SIZE (ctx.outer_type)\n+\t\t      || !TYPE_SIZE (outer_type)\n+\t\t      || !operand_equal_p (TYPE_SIZE (ctx.outer_type),\n+\t\t\t\t\t   TYPE_SIZE (outer_type), 0)))))\n+\tdynamic = true;\n+      outer_type = ctx.outer_type;\n+      offset = ctx.offset;\n+      dynamic = ctx.dynamic;\n+      maybe_in_construction = ctx.maybe_in_construction;\n+      maybe_derived_type = ctx.maybe_derived_type;\n+      updated = true;\n+    }\n+  /* See if OUTER_TYPE is base of CTX.OUTER_TYPE.  */\n+  else if (contains_type_p (ctx.outer_type,\n+\t\t\t    ctx.offset - offset, outer_type, false, true))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"First type is base of second\\n\");\n+      if (!maybe_derived_type)\n+\t{\n+\t  maybe_derived_type = true;\n+\t  updated = true;\n+\t}\n+      if (!maybe_in_construction && ctx.maybe_in_construction)\n+\t{\n+\t  maybe_in_construction = true;\n+\t  updated = true;\n+\t}\n+      if (!dynamic && ctx.dynamic)\n+\t{\n+\t  dynamic = true;\n+\t  updated = true;\n+\t}\n+    }\n+  /* See if CTX.OUTER_TYPE is base of OUTER_TYPE.  */\n+  else if (contains_type_p (outer_type,\n+\t\t\t    offset - ctx.offset, ctx.outer_type, false, true))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Second type is base of first\\n\");\n+      outer_type = ctx.outer_type;\n+      offset = ctx.offset;\n+      updated = true;\n+      if (!maybe_derived_type)\n+\tmaybe_derived_type = true;\n+      if (!maybe_in_construction && ctx.maybe_in_construction)\n+\tmaybe_in_construction = true;\n+      if (!dynamic && ctx.dynamic)\n+\tdynamic = true;\n+    }\n+  /* TODO handle merging using hiearchy. */\n+  else\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"Giving up on meet\\n\");\n+      clear_outer_type ();\n+      updated = true;\n+    }\n+\n+  updated |= meet_speculation_with (ctx.speculative_outer_type,\n+\t\t\t\t    ctx.speculative_offset,\n+\t\t\t\t    ctx.speculative_maybe_derived_type,\n+\t\t\t\t    otr_type);\n+\n+  if (updated && dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Updated as:                      \");\n+      dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  return updated;\n+}"}]}