{"sha": "6d07ad98760362cd9615c673cf8302908ce60980", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQwN2FkOTg3NjAzNjJjZDk2MTVjNjczY2Y4MzAyOTA4Y2U2MDk4MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-08T15:13:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-08T15:13:01Z"}, "message": "tree-eh.c (cleanup_eh): When not optimizing, do not try EH merging.\n\n\t* tree-eh.c (cleanup_eh): When not optimizing, do not try EH merging.\n\t* function.h (rtl_eh): Remove exception_handler_label_map.\n\t* except.c (ehl_hash, ehl_eq, add_ehl_entry,\n\tremove_exception_handler_label, for_each_eh_label_1): Remove.\n\t(rtl_remove_unreachable_regions): Remove.\n\t(convert_from_eh_region_ranges): Do not remove unreachable regions.\n\t(find_exception_handler_labels): Don't build the hashtable.\n\t(maybe_remove_eh_handler): Remove.\n\t(for_each_eh_label): Rewrite to walk the tree.\n\t(rest_of_handle_eh): Do not cleanup cfg prior EH construction.\n\t* except.h (maybe_remove_eh_handler): Remove.\n\t* passes.c (init_optimization_passes): Schedule second EH cleanup\n\tbefore out-of-ssa.\n\t* cfgrtl.c (rtl_delete_block, rtl_merge_blocks,\n\tcfg_layout_merge_blocks): Do not call maybe_remove_eh_handler.\n\nFrom-SVN: r145747", "tree": {"sha": "dde23269eb49d700833365c7340d997fe20ae49d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dde23269eb49d700833365c7340d997fe20ae49d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d07ad98760362cd9615c673cf8302908ce60980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d07ad98760362cd9615c673cf8302908ce60980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d07ad98760362cd9615c673cf8302908ce60980", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d07ad98760362cd9615c673cf8302908ce60980/comments", "author": null, "committer": null, "parents": [{"sha": "7ddf71e3171fb2d809e7baf6a94c9243b8d9fcac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddf71e3171fb2d809e7baf6a94c9243b8d9fcac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ddf71e3171fb2d809e7baf6a94c9243b8d9fcac"}], "stats": {"total": 263, "additions": 45, "deletions": 218}, "files": [{"sha": "c6ec14d3b41f229b97987e181f71aeb7d74a422e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -1,3 +1,21 @@\n+2009-04-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-eh.c (cleanup_eh): When not optimizing, do not try EH merging.\n+\t* function.h (rtl_eh): Remove exception_handler_label_map.\n+\t* except.c (ehl_hash, ehl_eq, add_ehl_entry,\n+\tremove_exception_handler_label, for_each_eh_label_1): Remove.\n+\t(rtl_remove_unreachable_regions): Remove.\n+\t(convert_from_eh_region_ranges): Do not remove unreachable regions.\n+\t(find_exception_handler_labels): Don't build the hashtable.\n+\t(maybe_remove_eh_handler): Remove.\n+\t(for_each_eh_label): Rewrite to walk the tree.\n+\t(rest_of_handle_eh): Do not cleanup cfg prior EH construction.\n+\t* except.h (maybe_remove_eh_handler): Remove.\n+\t* passes.c (init_optimization_passes): Schedule second EH cleanup\n+\tbefore out-of-ssa.\n+\t* cfgrtl.c (rtl_delete_block, rtl_merge_blocks,\n+\tcfg_layout_merge_blocks): Do not call maybe_remove_eh_handler.\n+\n 2009-04-08  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* genoutput.c (validate_optab_operands): New."}, {"sha": "39aae8c46713f06d4ee7dc4d2dd7056f46e032ba", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -2198,8 +2198,6 @@ cleanup_cfg (int mode)\n static unsigned int\n rest_of_handle_jump (void)\n {\n-  delete_unreachable_blocks ();\n-\n   if (crtl->tail_call_emit)\n     fixup_tail_calls ();\n   return 0;"}, {"sha": "95d28ac1cfd01a949d041d54c30d5d5f11defa36", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -379,8 +379,6 @@ rtl_delete_block (basic_block b)\n      label for an exception handler which can't be reached.  We need\n      to remove the label from the exception_handler_label list.  */\n   insn = BB_HEAD (b);\n-  if (LABEL_P (insn))\n-    maybe_remove_eh_handler (insn);\n \n   end = get_last_bb_insn (b);\n \n@@ -572,10 +570,6 @@ rtl_merge_blocks (basic_block a, basic_block b)\n   /* If there was a CODE_LABEL beginning B, delete it.  */\n   if (LABEL_P (b_head))\n     {\n-      /* This might have been an EH label that no longer has incoming\n-\t EH edges.  Update data structures to match.  */\n-      maybe_remove_eh_handler (b_head);\n-\n       /* Detect basic blocks with nothing but a label.  This can happen\n \t in particular at the end of a function.  */\n       if (b_head == b_end)\n@@ -2598,10 +2592,6 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n   /* If there was a CODE_LABEL beginning B, delete it.  */\n   if (LABEL_P (BB_HEAD (b)))\n     {\n-      /* This might have been an EH label that no longer has incoming\n-\t EH edges.  Update data structures to match.  */\n-      maybe_remove_eh_handler (BB_HEAD (b));\n-\n       delete_insn (BB_HEAD (b));\n     }\n "}, {"sha": "7e89e06f703a473cac21b8c3926d4becf9757c6f", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 188, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -248,14 +248,9 @@ static void sjlj_emit_function_exit (void);\n static void sjlj_emit_dispatch_table (rtx, struct sjlj_lp_info *);\n static void sjlj_build_landing_pads (void);\n \n-static hashval_t ehl_hash (const void *);\n-static int ehl_eq (const void *, const void *);\n-static void add_ehl_entry (rtx, struct eh_region *);\n-static void remove_exception_handler_label (rtx);\n static void remove_eh_handler (struct eh_region *);\n static void remove_eh_handler_and_replace (struct eh_region *,\n \t\t\t\t\t   struct eh_region *);\n-static int for_each_eh_label_1 (void **, void *);\n \n /* The return value of reachable_next_level.  */\n enum reachable_code\n@@ -895,53 +890,11 @@ num_eh_regions (void)\n   return cfun->eh->last_region_number + 1;\n }\n \n-/* Remove all regions whose labels are not reachable from insns.  */\n-\n-static void\n-rtl_remove_unreachable_regions (rtx insns)\n-{\n-  int i, *uid_region_num;\n-  sbitmap reachable;\n-  struct eh_region *r;\n-  rtx insn;\n-\n-  uid_region_num = XCNEWVEC (int, get_max_uid ());\n-  reachable = sbitmap_alloc (cfun->eh->last_region_number + 1);\n-  sbitmap_zero (reachable);\n-\n-  for (i = cfun->eh->last_region_number; i > 0; --i)\n-    {\n-      r = VEC_index (eh_region, cfun->eh->region_array, i);\n-      if (!r || r->region_number != i)\n-\tcontinue;\n-\n-      if (r->resume)\n-\t{\n-\t  gcc_assert (!uid_region_num[INSN_UID (r->resume)]);\n-\t  uid_region_num[INSN_UID (r->resume)] = i;\n-\t}\n-      if (r->label)\n-\t{\n-\t  gcc_assert (!uid_region_num[INSN_UID (r->label)]);\n-\t  uid_region_num[INSN_UID (r->label)] = i;\n-\t}\n-    }\n-\n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    SET_BIT (reachable, uid_region_num[INSN_UID (insn)]);\n-\n-  remove_unreachable_regions (reachable, NULL);\n-\n-  sbitmap_free (reachable);\n-  free (uid_region_num);\n-}\n-\n /* Set up EH labels for RTL.  */\n \n void\n convert_from_eh_region_ranges (void)\n {\n-  rtx insns = get_insns ();\n   int i, n = cfun->eh->last_region_number;\n \n   /* Most of the work is already done at the tree level.  All we need to\n@@ -956,49 +909,13 @@ convert_from_eh_region_ranges (void)\n       if (region && region->tree_label)\n \tregion->label = DECL_RTL_IF_SET (region->tree_label);\n     }\n-\n-  rtl_remove_unreachable_regions (insns);\n-}\n-\n-static void\n-add_ehl_entry (rtx label, struct eh_region *region)\n-{\n-  struct ehl_map_entry **slot, *entry;\n-\n-  LABEL_PRESERVE_P (label) = 1;\n-\n-  entry = GGC_NEW (struct ehl_map_entry);\n-  entry->label = label;\n-  entry->region = region;\n-\n-  slot = (struct ehl_map_entry **)\n-    htab_find_slot (crtl->eh.exception_handler_label_map, entry, INSERT);\n-\n-  /* Before landing pad creation, each exception handler has its own\n-     label.  After landing pad creation, the exception handlers may\n-     share landing pads.  This is ok, since maybe_remove_eh_handler\n-     only requires the 1-1 mapping before landing pad creation.  */\n-  gcc_assert (!*slot || crtl->eh.built_landing_pads);\n-\n-  *slot = entry;\n }\n \n void\n find_exception_handler_labels (void)\n {\n   int i;\n \n-  if (crtl->eh.exception_handler_label_map)\n-    htab_empty (crtl->eh.exception_handler_label_map);\n-  else\n-    {\n-      /* ??? The expansion factor here (3/2) must be greater than the htab\n-\t occupancy factor (4/3) to avoid unnecessary resizing.  */\n-      crtl->eh.exception_handler_label_map\n-        = htab_create_ggc (cfun->eh->last_region_number * 3 / 2,\n-\t\t\t   ehl_hash, ehl_eq, NULL);\n-    }\n-\n   if (cfun->eh->region_tree == NULL)\n     return;\n \n@@ -1014,15 +931,7 @@ find_exception_handler_labels (void)\n \tlab = region->landing_pad;\n       else\n \tlab = region->label;\n-\n-      if (lab)\n-\tadd_ehl_entry (lab, region);\n     }\n-\n-  /* For sjlj exceptions, need the return label to remain live until\n-     after landing pad generation.  */\n-  if (USING_SJLJ_EXCEPTIONS && ! crtl->eh.built_landing_pads)\n-    add_ehl_entry (return_label, NULL);\n }\n \n /* Returns true if the current function has exception handling regions.  */\n@@ -2387,50 +2296,8 @@ finish_eh_generation (void)\n     }\n }\n \f\n-static hashval_t\n-ehl_hash (const void *pentry)\n-{\n-  const struct ehl_map_entry *const entry\n-    = (const struct ehl_map_entry *) pentry;\n-\n-  /* 2^32 * ((sqrt(5) - 1) / 2) */\n-  const hashval_t scaled_golden_ratio = 0x9e3779b9;\n-  return CODE_LABEL_NUMBER (entry->label) * scaled_golden_ratio;\n-}\n-\n-static int\n-ehl_eq (const void *pentry, const void *pdata)\n-{\n-  const struct ehl_map_entry *const entry\n-    = (const struct ehl_map_entry *) pentry;\n-  const struct ehl_map_entry *const data\n-    = (const struct ehl_map_entry *) pdata;\n-\n-  return entry->label == data->label;\n-}\n-\n /* This section handles removing dead code for flow.  */\n \n-/* Remove LABEL from exception_handler_label_map.  */\n-\n-static void\n-remove_exception_handler_label (rtx label)\n-{\n-  struct ehl_map_entry **slot, tmp;\n-\n-  /* If exception_handler_label_map was not built yet,\n-     there is nothing to do.  */\n-  if (crtl->eh.exception_handler_label_map == NULL)\n-    return;\n-\n-  tmp.label = label;\n-  slot = (struct ehl_map_entry **)\n-    htab_find_slot (crtl->eh.exception_handler_label_map, &tmp, NO_INSERT);\n-  gcc_assert (slot);\n-\n-  htab_clear_slot (crtl->eh.exception_handler_label_map, (void **) slot);\n-}\n-\n /* Splice REGION from the region tree and replace it by REPLACE etc.  */\n \n static void\n@@ -2473,9 +2340,6 @@ remove_eh_handler_and_replace (struct eh_region *region,\n     lab = region->landing_pad;\n   else\n     lab = region->label;\n-  if (lab)\n-    remove_exception_handler_label (lab);\n-\n   if (outer)\n     pp_start = &outer->inner;\n   else\n@@ -2536,45 +2400,6 @@ remove_eh_handler (struct eh_region *region)\n   remove_eh_handler_and_replace (region, region->outer);\n }\n \n-/* LABEL heads a basic block that is about to be deleted.  If this\n-   label corresponds to an exception region, we may be able to\n-   delete the region.  */\n-\n-void\n-maybe_remove_eh_handler (rtx label)\n-{\n-  struct ehl_map_entry **slot, tmp;\n-  struct eh_region *region;\n-\n-  /* ??? After generating landing pads, it's not so simple to determine\n-     if the region data is completely unused.  One must examine the\n-     landing pad and the post landing pad, and whether an inner try block\n-     is referencing the catch handlers directly.  */\n-  if (crtl->eh.built_landing_pads)\n-    return;\n-\n-  tmp.label = label;\n-  slot = (struct ehl_map_entry **)\n-    htab_find_slot (crtl->eh.exception_handler_label_map, &tmp, NO_INSERT);\n-  if (! slot)\n-    return;\n-  region = (*slot)->region;\n-  if (! region)\n-    return;\n-\n-  /* Flow will want to remove MUST_NOT_THROW regions as unreachable\n-     because there is no path to the fallback call to terminate.\n-     But the region continues to affect call-site data until there\n-     are no more contained calls, which we don't see here.  */\n-  if (region->type == ERT_MUST_NOT_THROW)\n-    {\n-      htab_clear_slot (crtl->eh.exception_handler_label_map, (void **) slot);\n-      region->label = NULL_RTX;\n-    }\n-  else\n-    remove_eh_handler (region);\n-}\n-\n /* Remove Eh region R that has turned out to have no code in its handler.  */\n \n void\n@@ -2592,18 +2417,14 @@ remove_eh_region (int r)\n void\n for_each_eh_label (void (*callback) (rtx))\n {\n-  htab_traverse (crtl->eh.exception_handler_label_map, for_each_eh_label_1,\n-\t\t (void *) &callback);\n-}\n-\n-static int\n-for_each_eh_label_1 (void **pentry, void *data)\n-{\n-  struct ehl_map_entry *entry = *(struct ehl_map_entry **)pentry;\n-  void (*callback) (rtx) = *(void (**) (rtx)) data;\n-\n-  (*callback) (entry->label);\n-  return 1;\n+  int i;\n+  for (i = 0; i < cfun->eh->last_region_number; i++)\n+    {\n+      struct eh_region *r = VEC_index (eh_region, cfun->eh->region_array, i);\n+      if (r && r->region_number == i && r->label\n+          && GET_CODE (r->label) == CODE_LABEL)\n+\t(*callback) (r->label);\n+    }\n }\n \n /* Invoke CALLBACK for every exception region in the current function.  */\n@@ -4333,7 +4154,6 @@ gate_handle_eh (void)\n static unsigned int\n rest_of_handle_eh (void)\n {\n-  cleanup_cfg (CLEANUP_NO_INSN_DEL);\n   finish_eh_generation ();\n   cleanup_cfg (CLEANUP_NO_INSN_DEL);\n   return 0;"}, {"sha": "24611a559c30e9f9b95f4be20415469f74e4cee9", "filename": "gcc/except.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -62,7 +62,6 @@ extern void init_eh (void);\n extern void init_eh_for_function (void);\n \n extern rtx reachable_handlers (rtx);\n-extern void maybe_remove_eh_handler (rtx);\n void remove_eh_region (int);\n \n extern void convert_from_eh_region_ranges (void);"}, {"sha": "5bee64b153f47ac91cae9a0b284a355803361c88", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -156,8 +156,6 @@ struct rtl_eh GTY(())\n   rtx sjlj_fc;\n   rtx sjlj_exit_after;\n \n-  htab_t GTY ((param_is (struct ehl_map_entry))) exception_handler_label_map;\n-\n   VEC(tree,gc) *ttype_data;\n   varray_type ehspec_data;\n   varray_type action_record_data;"}, {"sha": "f3f43d4941ac59a86939563e6d1db559c380f489", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -706,6 +706,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_uncprop);\n       NEXT_PASS (pass_local_pure_const);\n     }\n+  NEXT_PASS (pass_cleanup_eh);\n   NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_mark_used_blocks);"}, {"sha": "bc93ee14f3ef473cf86e79f7147c1bfcc9f50bd0", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d07ad98760362cd9615c673cf8302908ce60980/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=6d07ad98760362cd9615c673cf8302908ce60980", "patch": "@@ -3121,23 +3121,26 @@ cleanup_eh (void)\n       dump_eh_tree (dump_file, cfun);\n     }\n \n-  dominance_info_invalidated = false;\n-  /* We cannot use FOR_EACH_BB, since the basic blocks may get removed.  */\n-  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+  if (optimize)\n     {\n-      bb = BASIC_BLOCK (i);\n-      if (bb)\n-\tchanged |= cleanup_empty_eh (bb);\n-    }\n-  if (dominance_info_invalidated)\n-    {\n-      free_dominance_info (CDI_DOMINATORS);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-    }\n+      dominance_info_invalidated = false;\n+      /* We cannot use FOR_EACH_BB, since the basic blocks may get removed.  */\n+      for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n+\t{\n+\t  bb = BASIC_BLOCK (i);\n+\t  if (bb)\n+\t    changed |= cleanup_empty_eh (bb);\n+\t}\n+      if (dominance_info_invalidated)\n+\t{\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  free_dominance_info (CDI_POST_DOMINATORS);\n+\t}\n \n-  /* Removing contained cleanup can render MUST_NOT_THROW regions empty.  */\n-  if (changed)\n-    delete_unreachable_blocks ();\n+      /* Removing contained cleanup can render MUST_NOT_THROW regions empty.  */\n+      if (changed)\n+\tdelete_unreachable_blocks ();\n+    }\n \n   tree_remove_unreachable_handlers ();\n   if (dump_file)"}]}