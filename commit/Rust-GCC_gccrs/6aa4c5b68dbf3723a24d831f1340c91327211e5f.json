{"sha": "6aa4c5b68dbf3723a24d831f1340c91327211e5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFhNGM1YjY4ZGJmMzcyM2EyNGQ4MzFmMTM0MGM5MTMyNzIxMWU1Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-06-13T10:21:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-06-13T10:21:40Z"}, "message": "tree-ssa-pre.c (eliminate_dom_walker::before_dom_children): Rewrite to propagate the VN result into all uses where possible and to remove...\n\n2014-06-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children):\n\tRewrite to propagate the VN result into all uses where\n\tpossible and to remove stmts becoming dead because of that.\n\t(eliminate): Generalize stmt removal handling, remove in\n\treverse dominator order to support proper debug stmt\n\tgeneration.  Update stmts before removing stmts.\n\t* tree-ssa-propagate.c (propagate_tree_value): Remove\n\tbogus assert.\n\n\t* c-c++-common/pr46562-2.c: Adjust.\n\t* g++.dg/tree-ssa/pr8781.C: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-24.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-25.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-32.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-39.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-16.c: Likewise.\n\nFrom-SVN: r211625", "tree": {"sha": "f0759513076163a54325c7033fa3eea9a9c9db00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0759513076163a54325c7033fa3eea9a9c9db00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6aa4c5b68dbf3723a24d831f1340c91327211e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa4c5b68dbf3723a24d831f1340c91327211e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa4c5b68dbf3723a24d831f1340c91327211e5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa4c5b68dbf3723a24d831f1340c91327211e5f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80298c3b46400a8f24be35ddf9169ccc18e5cf9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80298c3b46400a8f24be35ddf9169ccc18e5cf9b"}], "stats": {"total": 717, "additions": 383, "deletions": 334}, "files": [{"sha": "1e30212e5fde9d8b0a52f08d59d2a0dec0946fd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -1,3 +1,14 @@\n+2014-06-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children):\n+\tRewrite to propagate the VN result into all uses where\n+\tpossible and to remove stmts becoming dead because of that.\n+\t(eliminate): Generalize stmt removal handling, remove in\n+\treverse dominator order to support proper debug stmt\n+\tgeneration.  Update stmts before removing stmts.\n+\t* tree-ssa-propagate.c (propagate_tree_value): Remove\n+\tbogus assert.\n+\n 2014-06-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR tree-optimization/61375"}, {"sha": "d6bb7043be29ea106b387f1fde587c6d77b9f69c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -1,3 +1,13 @@\n+2014-06-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* c-c++-common/pr46562-2.c: Adjust.\n+\t* g++.dg/tree-ssa/pr8781.C: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-24.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-25.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-32.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-39.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-16.c: Likewise.\n+\n 2014-06-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR tree-optimization/61375"}, {"sha": "e64432c27df42848d532f6d4b08d1d03a6ce8a2b", "filename": "gcc/testsuite/c-c++-common/pr46562-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr46562-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr46562-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr46562-2.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -9,5 +9,5 @@ int foo(void)\n   return *p;\n }\n \n-/* { dg-final { scan-tree-dump \"= 0;\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump \"return 0;\" \"fre1\" } } */\n /* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "19549c4f7379f50af494ddb605d3e81aa29d158a", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr8781.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr8781.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr8781.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr8781.C?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fno-tree-sra -fdump-tree-fre1-details\" } */\n+/* { dg-options \"-O -fno-tree-sra -fdump-tree-fre1\" } */\n \n int f();\n \n@@ -24,5 +24,5 @@ int x()\n \n /* We should optimize this to a direct call.  */\n \n-/* { dg-final { scan-tree-dump \"converting indirect call to function int f()\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"= f \\\\(\\\\);\" 1 \"fre1\" } } */\n /* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "833a1b99d389c614b735194d2f2b5ec608870186", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-24.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-24.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -30,5 +30,5 @@ int bazzoo (void)\n   return b.i;\n }\n \n-/* { dg-final { scan-tree-dump-times \"= 0;\" 5 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0;\" 4 \"fre1\" } } */\n /* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "5317a18c5f668c2f15d084afa536745dbdfa0cd3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-25.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -14,5 +14,5 @@ int foo (struct X *p)\n \n /* We should optimize this to return 0.  */\n \n-/* { dg-final { scan-tree-dump \"= 0;\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump \"return 0;\" \"fre1\" } } */\n /* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "ad4f1d08607eb669e5c58c523217f657eb09d5df", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-32.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-32.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -23,6 +23,6 @@ bar (_Complex float x)\n   return z;\n } \n \n-/* We should CSE all the way to replace the final assignment to z with x.  */\n-/* { dg-final { scan-tree-dump-times \"with x_1\\\\\\(D\\\\\\) in z\" 3 \"fre1\" } } */\n+/* We should CSE all the way to replace the return value with x.  */\n+/* { dg-final { scan-tree-dump-times \"return x_\\\\d\\+\\\\(D\\\\);\" 2 \"fre1\" } } */\n /* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "4c5ed0b7895b0e1d8666cb8c1b83648fe9c31835", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-39.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-39.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -15,5 +15,5 @@ int foo (int i)\n \n /* We should be able to value-number the final assignment to k to 1.  */\n \n-/* { dg-final { scan-tree-dump \"k_. = 1;\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump \"return 1;\" \"fre1\" } } */\n /* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "7bc1dd3aab772ddc1d8455b296db3363599dc927", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-16.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -11,5 +11,5 @@ int foo(int k, int *x)\n   }  while (++j<k);\n   return res;\n }\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\"} } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "b7550b9522bc88ae59edb0e7fca2b82bd91df7a0", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 353, "deletions": 320, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -4012,120 +4012,93 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n   /* Mark new bb.  */\n   el_avail_stack.safe_push (NULL_TREE);\n \n-  /* If this block is not reachable do nothing.  */\n-  edge_iterator ei;\n-  edge e;\n-  FOR_EACH_EDGE (e, ei, b->preds)\n-    if (e->flags & EDGE_EXECUTABLE)\n-      break;\n-  if (!e)\n-    return;\n+  /* ???  If we do nothing for unreachable blocks then this will confuse\n+     tailmerging.  Eventually we can reduce its reliance on SCCVN now\n+     that we fully copy/constant-propagate (most) things.  */\n \n   for (gsi = gsi_start_phis (b); !gsi_end_p (gsi);)\n     {\n-      gimple stmt, phi = gsi_stmt (gsi);\n-      tree sprime = NULL_TREE, res = PHI_RESULT (phi);\n-      gimple_stmt_iterator gsi2;\n-\n-      /* We want to perform redundant PHI elimination.  Do so by\n-\t replacing the PHI with a single copy if possible.\n-\t Do not touch inserted, single-argument or virtual PHIs.  */\n-      if (gimple_phi_num_args (phi) == 1\n-\t  || virtual_operand_p (res))\n-\t{\n-\t  gsi_next (&gsi);\n-\t  continue;\n-\t}\n+      gimple phi = gsi_stmt (gsi);\n+      tree res = PHI_RESULT (phi);\n \n-      sprime = eliminate_avail (res);\n-      if (!sprime\n-\t  || sprime == res)\n+      if (virtual_operand_p (res))\n \t{\n-\t  eliminate_push_avail (res);\n \t  gsi_next (&gsi);\n \t  continue;\n \t}\n-      else if (is_gimple_min_invariant (sprime))\n-\t{\n-\t  if (!useless_type_conversion_p (TREE_TYPE (res),\n-\t\t\t\t\t  TREE_TYPE (sprime)))\n-\t    sprime = fold_convert (TREE_TYPE (res), sprime);\n-\t}\n \n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      tree sprime = eliminate_avail (res);\n+      if (sprime\n+\t  && sprime != res)\n \t{\n-\t  fprintf (dump_file, \"Replaced redundant PHI node defining \");\n-\t  print_generic_expr (dump_file, res, 0);\n-\t  fprintf (dump_file, \" with \");\n-\t  print_generic_expr (dump_file, sprime, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      remove_phi_node (&gsi, false);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Replaced redundant PHI node defining \");\n+\t      print_generic_expr (dump_file, res, 0);\n+\t      fprintf (dump_file, \" with \");\n+\t      print_generic_expr (dump_file, sprime, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n \n-      if (inserted_exprs\n-\t  && !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res))\n-\t  && TREE_CODE (sprime) == SSA_NAME)\n-\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime), NECESSARY, true);\n-\n-      if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n-\tsprime = fold_convert (TREE_TYPE (res), sprime);\n-      stmt = gimple_build_assign (res, sprime);\n-      gimple_set_plf (stmt, NECESSARY, gimple_plf (phi, NECESSARY));\n-\n-      gsi2 = gsi_after_labels (b);\n-      gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n-      /* Queue the copy for eventual removal.  */\n-      el_to_remove.safe_push (stmt);\n-      /* If we inserted this PHI node ourself, it's not an elimination.  */\n-      if (inserted_exprs\n-\t  && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))\n-\tpre_stats.phis--;\n-      else\n-\tpre_stats.eliminations++;\n-    }\n+\t  /* If we inserted this PHI node ourself, it's not an elimination.  */\n+\t  if (inserted_exprs\n+\t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))\n+\t    pre_stats.phis--;\n+\t  else\n+\t    pre_stats.eliminations++;\n \n-  for (gsi = gsi_start_bb (b); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      tree lhs = NULL_TREE;\n-      tree rhs = NULL_TREE;\n+\t  /* If we will propagate into all uses don't bother to do\n+\t     anything.  */\n+\t  if (may_propagate_copy (res, sprime))\n+\t    {\n+\t      /* Mark the PHI for removal.  */\n+\t      el_to_remove.safe_push (phi);\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n \n-      stmt = gsi_stmt (gsi);\n+\t  remove_phi_node (&gsi, false);\n \n-      if (gimple_has_lhs (stmt))\n-\tlhs = gimple_get_lhs (stmt);\n+\t  if (inserted_exprs\n+\t      && !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res))\n+\t      && TREE_CODE (sprime) == SSA_NAME)\n+\t    gimple_set_plf (SSA_NAME_DEF_STMT (sprime), NECESSARY, true);\n \n-      if (gimple_assign_single_p (stmt))\n-\trhs = gimple_assign_rhs1 (stmt);\n+\t  if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n+\t    sprime = fold_convert (TREE_TYPE (res), sprime);\n+\t  gimple stmt = gimple_build_assign (res, sprime);\n+\t  /* ???  It cannot yet be necessary (DOM walk).  */\n+\t  gimple_set_plf (stmt, NECESSARY, gimple_plf (phi, NECESSARY));\n \n-      /* Lookup the RHS of the expression, see if we have an\n-\t available computation for it.  If so, replace the RHS with\n-\t the available computation.  */\n-      if (gimple_has_lhs (stmt)\n-\t  && TREE_CODE (lhs) == SSA_NAME\n-\t  && !gimple_has_volatile_ops  (stmt))\n-\t{\n-\t  tree sprime;\n-\t  gimple orig_stmt = stmt;\n+\t  gimple_stmt_iterator gsi2 = gsi_after_labels (b);\n+\t  gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n+\t  continue;\n+\t}\n \n-\t  sprime = eliminate_avail (lhs);\n-\t  /* If there is no usable leader mark lhs as leader for its value.  */\n-\t  if (!sprime)\n-\t    eliminate_push_avail (lhs);\n+      eliminate_push_avail (res);\n+      gsi_next (&gsi);\n+    }\n \n+  for (gsi = gsi_start_bb (b); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      tree sprime = NULL_TREE;\n+      stmt = gsi_stmt (gsi);\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME\n+\t  && !gimple_has_volatile_ops (stmt)\n \t  /* See PR43491.  Do not replace a global register variable when\n \t     it is a the RHS of an assignment.  Do replace local register\n \t     variables since gcc does not guarantee a local variable will\n \t     be allocated in register.\n-\t     Do not perform copy propagation or undo constant propagation.  */\n-\t  if (gimple_assign_single_p (stmt)\n-\t      && (TREE_CODE (rhs) == SSA_NAME\n-\t\t  || is_gimple_min_invariant (rhs)\n-\t\t  || (TREE_CODE (rhs) == VAR_DECL\n-\t\t      && is_global_var (rhs)\n-\t\t      && DECL_HARD_REGISTER (rhs))))\n-\t    continue;\n-\n+\t     ???  The fix isn't effective here.  This should instead\n+\t     be ensured by not value-numbering them the same but treating\n+\t     them like volatiles?  */\n+\t  && !(gimple_assign_single_p (stmt)\n+\t       && (TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL\n+\t\t   && DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt))\n+\t\t   && is_global_var (gimple_assign_rhs1 (stmt)))))\n+\t{\n+\t  sprime = eliminate_avail (lhs);\n \t  if (!sprime)\n \t    {\n \t      /* If there is no existing usable leader but SCCVN thinks\n@@ -4139,107 +4112,128 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t  && (sprime = eliminate_insert (&gsi, val)) != NULL_TREE)\n \t\teliminate_push_avail (sprime);\n \t    }\n-\t  else if (is_gimple_min_invariant (sprime))\n-\t    {\n-\t      /* If there is no existing leader but SCCVN knows this\n-\t\t value is constant, use that constant.  */\n-\t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n-\t\t\t\t\t      TREE_TYPE (sprime)))\n-\t\tsprime = fold_convert (TREE_TYPE (lhs), sprime);\n-\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"Replaced \");\n-\t\t  print_gimple_expr (dump_file, stmt, 0, 0);\n-\t\t  fprintf (dump_file, \" with \");\n-\t\t  print_generic_expr (dump_file, sprime, 0);\n-\t\t  fprintf (dump_file, \" in \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t}\n-\t      pre_stats.eliminations++;\n-\n-\t      tree vdef = gimple_vdef (stmt);\n-\t      tree vuse = gimple_vuse (stmt);\n-\t      propagate_tree_value_into_stmt (&gsi, sprime);\n-\t      stmt = gsi_stmt (gsi);\n-\t      update_stmt (stmt);\n-\t      if (vdef != gimple_vdef (stmt))\n-\t\tVN_INFO (vdef)->valnum = vuse;\n \n-\t      /* If we removed EH side-effects from the statement, clean\n-\t\t its EH information.  */\n-\t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n+\t  /* If this now constitutes a copy duplicate points-to\n+\t     and range info appropriately.  This is especially\n+\t     important for inserted code.  See tree-ssa-copy.c\n+\t     for similar code.  */\n+\t  if (sprime\n+\t      && TREE_CODE (sprime) == SSA_NAME)\n+\t    {\n+\t      basic_block sprime_b = gimple_bb (SSA_NAME_DEF_STMT (sprime));\n+\t      if (POINTER_TYPE_P (TREE_TYPE (lhs))\n+\t\t  && SSA_NAME_PTR_INFO (lhs)\n+\t\t  && !SSA_NAME_PTR_INFO (sprime))\n \t\t{\n-\t\t  bitmap_set_bit (need_eh_cleanup,\n-\t\t\t\t  gimple_bb (stmt)->index);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file, \"  Removed EH side-effects.\\n\");\n+\t\t  duplicate_ssa_name_ptr_info (sprime,\n+\t\t\t\t\t       SSA_NAME_PTR_INFO (lhs));\n+\t\t  if (b != sprime_b)\n+\t\t    mark_ptr_info_alignment_unknown\n+\t\t\t(SSA_NAME_PTR_INFO (sprime));\n \t\t}\n-\t      continue;\n+\t      else if (!POINTER_TYPE_P (TREE_TYPE (lhs))\n+\t\t       && SSA_NAME_RANGE_INFO (lhs)\n+\t\t       && !SSA_NAME_RANGE_INFO (sprime)\n+\t\t       && b == sprime_b)\n+\t\tduplicate_ssa_name_range_info (sprime,\n+\t\t\t\t\t       SSA_NAME_RANGE_TYPE (lhs),\n+\t\t\t\t\t       SSA_NAME_RANGE_INFO (lhs));\n \t    }\n \n+\t  /* Inhibit the use of an inserted PHI on a loop header when\n+\t     the address of the memory reference is a simple induction\n+\t     variable.  In other cases the vectorizer won't do anything\n+\t     anyway (either it's loop invariant or a complicated\n+\t     expression).  */\n \t  if (sprime\n-\t      && sprime != lhs\n-\t      && (rhs == NULL_TREE\n-\t\t  || TREE_CODE (rhs) != SSA_NAME\n-\t\t  || may_propagate_copy (rhs, sprime)))\n+\t      && TREE_CODE (sprime) == SSA_NAME\n+\t      && do_pre\n+\t      && flag_tree_loop_vectorize\n+\t      && loop_outer (b->loop_father)\n+\t      && has_zero_uses (sprime)\n+\t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))\n+\t      && gimple_assign_load_p (stmt))\n \t    {\n-\t      bool can_make_abnormal_goto\n-\t\t  = is_gimple_call (stmt)\n-\t\t  && stmt_can_make_abnormal_goto (stmt);\n-\n-\t      gcc_assert (sprime != rhs);\n-\n-\t      /* Inhibit the use of an inserted PHI on a loop header when\n-\t\t the address of the memory reference is a simple induction\n-\t\t variable.  In other cases the vectorizer won't do anything\n-\t\t anyway (either it's loop invariant or a complicated\n-\t\t expression).  */\n-\t      if (do_pre\n-\t\t  && flag_tree_loop_vectorize\n-\t\t  && gimple_assign_single_p (stmt)\n-\t\t  && TREE_CODE (sprime) == SSA_NAME\n-\t\t  && loop_outer (b->loop_father))\n+\t      gimple def_stmt = SSA_NAME_DEF_STMT (sprime);\n+\t      basic_block def_bb = gimple_bb (def_stmt);\n+\t      if (gimple_code (def_stmt) == GIMPLE_PHI\n+\t\t  && b->loop_father->header == def_bb)\n \t\t{\n-\t\t  gimple def_stmt = SSA_NAME_DEF_STMT (sprime);\n-\t\t  basic_block def_bb = gimple_bb (def_stmt);\n-\t\t  if (gimple_code (def_stmt) == GIMPLE_PHI\n-\t\t      && b->loop_father->header == def_bb\n-\t\t      && has_zero_uses (sprime))\n+\t\t  ssa_op_iter iter;\n+\t\t  tree op;\n+\t\t  bool found = false;\n+\t\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t\t    {\n-\t\t      ssa_op_iter iter;\n-\t\t      tree op;\n-\t\t      bool found = false;\n-\t\t      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+\t\t      affine_iv iv;\n+\t\t      def_bb = gimple_bb (SSA_NAME_DEF_STMT (op));\n+\t\t      if (def_bb\n+\t\t\t  && flow_bb_inside_loop_p (b->loop_father, def_bb)\n+\t\t\t  && simple_iv (b->loop_father,\n+\t\t\t\t\tb->loop_father, op, &iv, true))\n \t\t\t{\n-\t\t\t  affine_iv iv;\n-\t\t\t  def_bb = gimple_bb (SSA_NAME_DEF_STMT (op));\n-\t\t\t  if (def_bb\n-\t\t\t      && flow_bb_inside_loop_p (b->loop_father,\n-\t\t\t\t\t\t\tdef_bb)\n-\t\t\t      && simple_iv (b->loop_father,\n-\t\t\t\t\t    b->loop_father, op, &iv, true))\n-\t\t\t    {\n-\t\t\t      found = true;\n-\t\t\t      break;\n-\t\t\t    }\n+\t\t\t  found = true;\n+\t\t\t  break;\n \t\t\t}\n-\t\t      if (found)\n+\t\t    }\n+\t\t  if (found)\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t{\n-\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t    {\n-\t\t\t      fprintf (dump_file, \"Not replacing \");\n-\t\t\t      print_gimple_expr (dump_file, stmt, 0, 0);\n-\t\t\t      fprintf (dump_file, \" with \");\n-\t\t\t      print_generic_expr (dump_file, sprime, 0);\n-\t\t\t      fprintf (dump_file, \" which would add a loop\"\n-\t\t\t\t       \" carried dependence to loop %d\\n\",\n-\t\t\t\t       b->loop_father->num);\n-\t\t\t    }\n-\t\t\t  continue;\n+\t\t\t  fprintf (dump_file, \"Not replacing \");\n+\t\t\t  print_gimple_expr (dump_file, stmt, 0, 0);\n+\t\t\t  fprintf (dump_file, \" with \");\n+\t\t\t  print_generic_expr (dump_file, sprime, 0);\n+\t\t\t  fprintf (dump_file, \" which would add a loop\"\n+\t\t\t\t   \" carried dependence to loop %d\\n\",\n+\t\t\t\t   b->loop_father->num);\n \t\t\t}\n+\t\t      /* Don't keep sprime available.  */\n+\t\t      eliminate_push_avail (lhs);\n+\t\t      sprime = NULL_TREE;\n \t\t    }\n \t\t}\n+\t    }\n+\n+\t  if (sprime)\n+\t    {\n+\t      /* If we can propagate the value computed for LHS into\n+\t\t all uses don't bother doing anything with this stmt.  */\n+\t      if (may_propagate_copy (lhs, sprime))\n+\t\t{\n+\t\t  /* Mark it for removal.  */\n+\t\t  el_to_remove.safe_push (stmt);\n+\n+\t\t  /* ???  Don't count copy/constant propagations.  */\n+\t\t  if (gimple_assign_single_p (stmt)\n+\t\t      && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n+\t\t\t  || gimple_assign_rhs1 (stmt) == sprime))\n+\t\t    continue;\n+\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Replaced \");\n+\t\t      print_gimple_expr (dump_file, stmt, 0, 0);\n+\t\t      fprintf (dump_file, \" with \");\n+\t\t      print_generic_expr (dump_file, sprime, 0);\n+\t\t      fprintf (dump_file, \" in all uses of \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t    }\n+\n+\t\t  pre_stats.eliminations++;\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* If this is an assignment from our leader (which\n+\t         happens in the case the value-number is a constant)\n+\t\t then there is nothing to do.  */\n+\t      if (gimple_assign_single_p (stmt)\n+\t\t  && sprime == gimple_assign_rhs1 (stmt))\n+\t\tcontinue;\n+\n+\t      /* Else replace its RHS.  */\n+\t      bool can_make_abnormal_goto\n+\t\t  = is_gimple_call (stmt)\n+\t\t  && stmt_can_make_abnormal_goto (stmt);\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n@@ -4254,16 +4248,12 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      if (TREE_CODE (sprime) == SSA_NAME)\n \t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n \t\t\t\tNECESSARY, true);\n-\t      /* We need to make sure the new and old types actually match,\n-\t\t which may require adding a simple cast, which fold_convert\n-\t\t will do for us.  */\n-\t      if ((!rhs || TREE_CODE (rhs) != SSA_NAME)\n-\t\t  && !useless_type_conversion_p (gimple_expr_type (stmt),\n-\t\t\t\t\t\t TREE_TYPE (sprime)))\n-\t\tsprime = fold_convert (gimple_expr_type (stmt), sprime);\n \n \t      pre_stats.eliminations++;\n-\n+\t      gimple orig_stmt = stmt;\n+\t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t      TREE_TYPE (sprime)))\n+\t\tsprime = fold_convert (TREE_TYPE (lhs), sprime);\n \t      tree vdef = gimple_vdef (stmt);\n \t      tree vuse = gimple_vuse (stmt);\n \t      propagate_tree_value_into_stmt (&gsi, sprime);\n@@ -4291,135 +4281,183 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file, \"  Removed AB side-effects.\\n\");\n \t\t}\n+\n+\t      continue;\n \t    }\n \t}\n+\n       /* If the statement is a scalar store, see if the expression\n-\t has the same value number as its rhs.  If so, the store is\n-\t dead.  */\n-      else if (gimple_assign_single_p (stmt)\n-\t       && !gimple_has_volatile_ops (stmt)\n-\t       && !is_gimple_reg (gimple_assign_lhs (stmt))\n-\t       && (TREE_CODE (rhs) == SSA_NAME\n-\t\t   || is_gimple_min_invariant (rhs)))\n-\t{\n-\t  tree val;\n-\t  val = vn_reference_lookup (gimple_assign_lhs (stmt),\n-\t\t\t\t     gimple_vuse (stmt), VN_WALK, NULL);\n-\t  if (TREE_CODE (rhs) == SSA_NAME)\n-\t    rhs = VN_INFO (rhs)->valnum;\n-\t  if (val\n-\t      && operand_equal_p (val, rhs, 0))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"Deleted redundant store \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t}\n+         has the same value number as its rhs.  If so, the store is\n+         dead.  */\n+      if (gimple_assign_single_p (stmt)\n+\t  && !gimple_has_volatile_ops (stmt)\n+\t  && !is_gimple_reg (gimple_assign_lhs (stmt))\n+\t  && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n+\t      || is_gimple_min_invariant (gimple_assign_rhs1 (stmt))))\n+        {\n+          tree val;\n+\t  tree rhs = gimple_assign_rhs1 (stmt);\n+          val = vn_reference_lookup (gimple_assign_lhs (stmt),\n+                                     gimple_vuse (stmt), VN_WALK, NULL);\n+          if (TREE_CODE (rhs) == SSA_NAME)\n+            rhs = VN_INFO (rhs)->valnum;\n+          if (val\n+              && operand_equal_p (val, rhs, 0))\n+            {\n+              if (dump_file && (dump_flags & TDF_DETAILS))\n+                {\n+                  fprintf (dump_file, \"Deleted redundant store \");\n+                  print_gimple_stmt (dump_file, stmt, 0, 0);\n+                }\n+\n+              /* Queue stmt for removal.  */\n+              el_to_remove.safe_push (stmt);\n+\t      continue;\n+            }\n+        }\n \n-\t      /* Queue stmt for removal.  */\n-\t      el_to_remove.safe_push (stmt);\n-\t    }\n-\t}\n-      /* Visit COND_EXPRs and fold the comparison with the\n-\t available value-numbers.  */\n-      else if (gimple_code (stmt) == GIMPLE_COND)\n+      bool can_make_abnormal_goto = stmt_can_make_abnormal_goto (stmt);\n+      bool was_noreturn = (is_gimple_call (stmt)\n+\t\t\t   && gimple_call_noreturn_p (stmt));\n+      tree vdef = gimple_vdef (stmt);\n+      tree vuse = gimple_vuse (stmt);\n+\n+      /* If we didn't replace the whole stmt (or propagate the result\n+         into all uses), replace all uses on this stmt with their\n+\t leaders.  */\n+      use_operand_p use_p;\n+      ssa_op_iter iter;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \t{\n-\t  tree op0 = gimple_cond_lhs (stmt);\n-\t  tree op1 = gimple_cond_rhs (stmt);\n-\t  tree result;\n-\n-\t  if (TREE_CODE (op0) == SSA_NAME)\n-\t    op0 = VN_INFO (op0)->valnum;\n-\t  if (TREE_CODE (op1) == SSA_NAME)\n-\t    op1 = VN_INFO (op1)->valnum;\n-\t  result = fold_binary (gimple_cond_code (stmt), boolean_type_node,\n-\t\t\t\top0, op1);\n-\t  if (result && TREE_CODE (result) == INTEGER_CST)\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  /* ???  The call code above leaves stmt operands un-updated.  */\n+\t  if (TREE_CODE (use) != SSA_NAME)\n+\t    continue;\n+\t  tree sprime = eliminate_avail (use);\n+\t  if (sprime && sprime != use\n+\t      && may_propagate_copy (use, sprime)\n+\t      /* We substitute into debug stmts to avoid excessive\n+\t         debug temporaries created by removed stmts, but we need\n+\t\t to avoid doing so for inserted sprimes as we never want\n+\t\t to create debug temporaries for them.  */\n+\t      && (!inserted_exprs\n+\t\t  || TREE_CODE (sprime) != SSA_NAME\n+\t\t  || !is_gimple_debug (stmt)\n+\t\t  || !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))))\n \t    {\n-\t      if (integer_zerop (result))\n-\t\tgimple_cond_make_false (stmt);\n-\t      else\n-\t\tgimple_cond_make_true (stmt);\n-\t      update_stmt (stmt);\n-\t      el_todo = TODO_cleanup_cfg;\n+\t      propagate_value (use_p, sprime);\n+\t      gimple_set_modified (stmt, true);\n+\t      if (TREE_CODE (sprime) == SSA_NAME\n+\t\t  && !is_gimple_debug (stmt))\n+\t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n+\t\t\t\tNECESSARY, true);\n \t    }\n \t}\n+\n       /* Visit indirect calls and turn them into direct calls if\n-\t possible.  */\n+\t possible using the devirtualization machinery.  */\n       if (is_gimple_call (stmt))\n \t{\n-\t  tree orig_fn = gimple_call_fn (stmt);\n-\t  tree fn;\n-\t  if (!orig_fn)\n-\t    continue;\n-\t  if (TREE_CODE (orig_fn) == SSA_NAME)\n-\t    fn = VN_INFO (orig_fn)->valnum;\n-\t  else if (TREE_CODE (orig_fn) == OBJ_TYPE_REF\n-\t\t   && TREE_CODE (OBJ_TYPE_REF_EXPR (orig_fn)) == SSA_NAME)\n+\t  tree fn = gimple_call_fn (stmt);\n+\t  if (fn\n+\t      && TREE_CODE (fn) == OBJ_TYPE_REF\n+\t      && TREE_CODE (OBJ_TYPE_REF_EXPR (fn)) == SSA_NAME)\n \t    {\n-\t      fn = VN_INFO (OBJ_TYPE_REF_EXPR (orig_fn))->valnum;\n-\t      if (!gimple_call_addr_fndecl (fn))\n+\t      fn = ipa_intraprocedural_devirtualization (stmt);\n+\t      if (fn && dbg_cnt (devirt))\n \t\t{\n-\t\t  fn = ipa_intraprocedural_devirtualization (stmt);\n-\t\t  if (fn)\n-\t\t    fn = build_fold_addr_expr (fn);\n+\t\t  if (dump_enabled_p ())\n+\t\t    {\n+\t\t      location_t loc = gimple_location (stmt);\n+\t\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t\t\t       \"converting indirect call to \"\n+\t\t\t\t       \"function %s\\n\",\n+\t\t\t\t       cgraph_get_node (fn)->name ());\n+\t\t    }\n+\t\t  gimple_call_set_fndecl (stmt, fn);\n+\t\t  gimple_set_modified (stmt, true);\n \t\t}\n \t    }\n-\t  else\n-\t    continue;\n-\t  if (gimple_call_addr_fndecl (fn) != NULL_TREE\n-\t      && useless_type_conversion_p (TREE_TYPE (orig_fn),\n-\t\t\t\t\t    TREE_TYPE (fn))\n-              && dbg_cnt (devirt))\n-\t    {\n-\t      bool can_make_abnormal_goto\n-\t\t  = stmt_can_make_abnormal_goto (stmt);\n-\t      bool was_noreturn = gimple_call_noreturn_p (stmt);\n-\n-\t      if (dump_enabled_p ())\n-\t\t{\n-                  location_t loc = gimple_location (stmt);\n-                  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n-                                   \"converting indirect call to function %s\\n\",\n-                                   cgraph_get_node (gimple_call_addr_fndecl (fn))->name ());\n-\t\t}\n-\n-\t      gimple_call_set_fn (stmt, fn);\n-\t      tree vdef = gimple_vdef (stmt);\n-\t      tree vuse = gimple_vuse (stmt);\n-\t      update_stmt (stmt);\n-\t      if (vdef != gimple_vdef (stmt))\n-\t\tVN_INFO (vdef)->valnum = vuse;\n+\t}\n \n+      if (gimple_modified_p (stmt))\n+\t{\n+\t  /* If a formerly non-invariant ADDR_EXPR is turned into an\n+\t     invariant one it was on a separate stmt.  */\n+\t  if (gimple_assign_single_p (stmt)\n+\t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));\n+\t  gimple old_stmt = stmt;\n+\t  if (is_gimple_call (stmt))\n+\t    {\n+\t      /* ???  Only fold calls inplace for now, this may create new\n+\t\t SSA names which in turn will confuse free_scc_vn SSA name\n+\t\t release code.  */\n+\t      fold_stmt_inplace (&gsi);\n \t      /* When changing a call into a noreturn call, cfg cleanup\n \t\t is needed to fix up the noreturn call.  */\n \t      if (!was_noreturn && gimple_call_noreturn_p (stmt))\n \t\tel_todo |= TODO_cleanup_cfg;\n+\t    }\n+\t  else\n+\t    {\n+\t      fold_stmt (&gsi);\n+\t      stmt = gsi_stmt (gsi);\n+\t      if ((gimple_code (stmt) == GIMPLE_COND\n+\t\t   && (gimple_cond_true_p (stmt)\n+\t\t       || gimple_cond_false_p (stmt)))\n+\t\t  || (gimple_code (stmt) == GIMPLE_SWITCH\n+\t\t      && TREE_CODE (gimple_switch_index (stmt)) == INTEGER_CST))\n+\t\tel_todo |= TODO_cleanup_cfg;\n+\t    }\n+\t  /* If we removed EH side-effects from the statement, clean\n+\t     its EH information.  */\n+\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n+\t    {\n+\t      bitmap_set_bit (need_eh_cleanup,\n+\t\t\t      gimple_bb (stmt)->index);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  Removed EH side-effects.\\n\");\n+\t    }\n+\t  /* Likewise for AB side-effects.  */\n+\t  if (can_make_abnormal_goto\n+\t      && !stmt_can_make_abnormal_goto (stmt))\n+\t    {\n+\t      bitmap_set_bit (need_ab_cleanup,\n+\t\t\t      gimple_bb (stmt)->index);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  Removed AB side-effects.\\n\");\n+\t    }\n+\t  update_stmt (stmt);\n+\t  if (vdef != gimple_vdef (stmt))\n+\t    VN_INFO (vdef)->valnum = vuse;\n+\t}\n \n-\t      /* If we removed EH side-effects from the statement, clean\n-\t\t its EH information.  */\n-\t      if (maybe_clean_or_replace_eh_stmt (stmt, stmt))\n-\t\t{\n-\t\t  bitmap_set_bit (need_eh_cleanup,\n-\t\t\t\t  gimple_bb (stmt)->index);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file, \"  Removed EH side-effects.\\n\");\n-\t\t}\n-\n-\t      /* Likewise for AB side-effects.  */\n-\t      if (can_make_abnormal_goto\n-\t\t  && !stmt_can_make_abnormal_goto (stmt))\n-\t\t{\n-\t\t  bitmap_set_bit (need_ab_cleanup,\n-\t\t\t\t  gimple_bb (stmt)->index);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file, \"  Removed AB side-effects.\\n\");\n-\t\t}\n+      /* Make the new value available - for fully redundant LHS we\n+         continue with the next stmt above.  */\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\teliminate_push_avail (lhs);\n+    }\n \n-\t      /* Changing an indirect call to a direct call may\n-\t\t have exposed different semantics.  This may\n-\t\t require an SSA update.  */\n-\t      el_todo |= TODO_update_ssa_only_virtuals;\n+  /* Replace destination PHI arguments.  */\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, b->succs)\n+    {\n+      for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple phi = gsi_stmt (gsi);\n+\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  tree arg = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (arg) != SSA_NAME\n+\t      || virtual_operand_p (arg))\n+\t    continue;\n+\t  tree sprime = eliminate_avail (arg);\n+\t  if (sprime && may_propagate_copy (arg, sprime))\n+\t    {\n+\t      propagate_value (use_p, sprime);\n+\t      if (TREE_CODE (sprime) == SSA_NAME)\n+\t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime), NECESSARY, true);\n \t    }\n \t}\n     }\n@@ -4442,7 +4480,6 @@ eliminate (bool do_pre)\n {\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n-  unsigned i;\n \n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n   need_ab_cleanup = BITMAP_ALLOC (NULL);\n@@ -4460,41 +4497,37 @@ eliminate (bool do_pre)\n \n   /* We cannot remove stmts during BB walk, especially not release SSA\n      names there as this confuses the VN machinery.  The stmts ending\n-     up in el_to_remove are either stores or simple copies.  */\n-  FOR_EACH_VEC_ELT (el_to_remove, i, stmt)\n+     up in el_to_remove are either stores or simple copies.\n+     Remove stmts in reverse order to make debug stmt creation possible.  */\n+  while (!el_to_remove.is_empty ())\n     {\n-      tree lhs = gimple_assign_lhs (stmt);\n-      tree rhs = gimple_assign_rhs1 (stmt);\n-      use_operand_p use_p;\n-      gimple use_stmt;\n-\n-      /* If there is a single use only, propagate the equivalency\n-\t instead of keeping the copy.  */\n-      if (TREE_CODE (lhs) == SSA_NAME\n-\t  && TREE_CODE (rhs) == SSA_NAME\n-\t  && single_imm_use (lhs, &use_p, &use_stmt)\n-\t  && may_propagate_copy (USE_FROM_PTR (use_p), rhs))\n+      stmt = el_to_remove.pop ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  SET_USE (use_p, rhs);\n-\t  update_stmt (use_stmt);\n-\t  if (inserted_exprs\n-\t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (lhs))\n-\t      && TREE_CODE (rhs) == SSA_NAME)\n-\t    gimple_set_plf (SSA_NAME_DEF_STMT (rhs), NECESSARY, true);\n+\t  fprintf (dump_file, \"Removing dead stmt \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t}\n \n-      /* If this is a store or a now unused copy, remove it.  */\n-      if (TREE_CODE (lhs) != SSA_NAME\n-\t  || has_zero_uses (lhs))\n+      tree lhs;\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tlhs = gimple_phi_result (stmt);\n+      else\n+\tlhs = gimple_get_lhs (stmt);\n+\n+      if (inserted_exprs\n+\t  && TREE_CODE (lhs) == SSA_NAME)\n+\tbitmap_clear_bit (inserted_exprs, SSA_NAME_VERSION (lhs));\n+\n+      gsi = gsi_for_stmt (stmt);\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tremove_phi_node (&gsi, true);\n+      else\n \t{\n \t  basic_block bb = gimple_bb (stmt);\n-\t  gsi = gsi_for_stmt (stmt);\n \t  unlink_stmt_vdef (stmt);\n \t  if (gsi_remove (&gsi, true))\n \t    bitmap_set_bit (need_eh_cleanup, bb->index);\n-\t  if (inserted_exprs\n-\t      && TREE_CODE (lhs) == SSA_NAME)\n-\t    bitmap_clear_bit (inserted_exprs, SSA_NAME_VERSION (lhs));\n \t  release_defs (stmt);\n \t}\n     }"}, {"sha": "255bff94ab38ce7a9c4a2e0c443efd664051df0a", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa4c5b68dbf3723a24d831f1340c91327211e5f/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=6aa4c5b68dbf3723a24d831f1340c91327211e5f", "patch": "@@ -1410,11 +1410,6 @@ replace_exp (use_operand_p op_p, tree val)\n void\n propagate_tree_value (tree *op_p, tree val)\n {\n-  gcc_checking_assert (!(TREE_CODE (val) == SSA_NAME\n-\t\t\t && *op_p\n-\t\t\t && TREE_CODE (*op_p) == SSA_NAME\n-\t\t\t && !may_propagate_copy (*op_p, val)));\n-\n   if (TREE_CODE (val) == SSA_NAME)\n     *op_p = val;\n   else"}]}