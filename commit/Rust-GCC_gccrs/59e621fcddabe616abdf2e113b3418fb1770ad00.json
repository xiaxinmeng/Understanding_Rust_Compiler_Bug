{"sha": "59e621fcddabe616abdf2e113b3418fb1770ad00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTllNjIxZmNkZGFiZTYxNmFiZGYyZTExM2IzNDE4ZmIxNzcwYWQwMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-07-11T16:20:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-07-11T16:20:54Z"}, "message": "cplus-dem.c (string): Move definition before work_stuff.\n\n\t* cplus-dem.c (string): Move definition before work_stuff.\n\t(work_stuff): Add volatile_type, forgetting_types,\n\tprevious_argument, and nrepeats fields.\n\t(SCOPE_STRING): New macro.\n\t(demangle_template): Add `remember' parameter.  Add comment.\n\tRegister the `B' code type here, if remembering.  Tidy.  Fix crash\n\ton NULL tmpl_argvec.  Be consistent with use of tname/trawname.\n\t(demangle_nested_args): New function.\n\t(internal_cplus_demangle): Handle volatile-qualified member\n\tfunctions.\n\t(mop_up): Delete the previous_argument string if present.\n\t(demangle_signature): Tidy.  Handle volatile-qualified member\n\tfunctions.  Handle back-references using the `B' code.  Use extra\n\tparameter to demangle_template and SCOPE_STRING where appropriate.\n\t(demangle_template_value_parm): Fix thinko; 'B' is not an integral\n\tcode.\n\t(demangle_class): Use SCOPE_STRING.\n\t(gnu_special): Pass additional argument to demangle_template.\n\tUse SCOPE_STRING.\n\t(demangle_qualified): Save qualified types for later\n\tback-references.  Handle constructors and destructors for template\n\ttypes correctly.\n\t(do_type): Tidy.  Use SCOPE_STRING.  Pass extra argument to\n\tdemangle_template.  Use demangled_nested_args.  Don't remember\n\tqualified types here; that's now done in demangle_qualified.\n\tSimilarly for templates.\n\t(do_arg): Improve commment.  Handle 'n' repeat code.\n\t(remember_type): Check forgetting_types.\n\t(demangle_args): Deal with 'n' repeat codes.  Tidy.\n\t* method.c (flush_repeats): Add nrepeats parameter.\n\t(issue_nrepeats): Likewise.\n\t(is_back_referenceable_type): New function.  Don't back-reference\n\tTEMPLATE_TYPE_PARMs as well as simple types like integers.\n\t(build_mangled_name_for_type): Likewise.\n\t(build_mangled_name_for_type_with_Gcode): Likewise.\n\t(lasttype): Remove.\n\t(nrepeats): Likewise.\n\t(Nrepeats): Likewise.\n\t(start_squangling): Don't clear the variables removed above.\n\t(end_squangling): Likewise.\n\t(flush_repeats): Tidy.  Use nrepeats parameter rather than\n\tNrepeats global.\n\t(issue_nrepeats): Likewise, but with nrepeats global.  Use\n\tis_backreferenceable_type.\n\t(build_overload_nested_name): Tidy.  Add comment.  Use\n\tbuild_mangled_name_for_type.\n\t(build_underscore_int): Comment.\n\t(build_overload_scope_ref): Use build_mangled_name_for_type.\n\t(build_overload_int): Likewise.\n\t(build_template_template_parm_names): Tidy.\n\t(build_template_parm_names): Use build_mangled_name_for_type.\n\t(build_overload_identifier): Add comments.\n\t(build_mangled_name_for_type_with_Gcode): Split out from\n\tbuild_mangled_name.\n\t(build_mangled_name_for_type): Use it.\n\t(build_mangled_name): Rework to use build_mangled_name_for_type\n\tand to not use global nrepeats/Nrepeats.  Tidy.\n\t(process_modifiers): Tidy.\n\t(check_btype): Use is_backreferenceable_type.  Add comment.\n\tRename `node' to `type'.\n\t(process_overload_item): Set numeric_output_need_bar here.\n\tUse build_mangled_name_for_type.  Tidy.\n\t(build_decl_overload_real): Tidy.  Don't use Nrepeats.  Use\n\tbuild_mangled_name_for_type.\n\nFrom-SVN: r21062", "tree": {"sha": "d8664c3d171ecf5264e39c9fca37dc4dc6580f5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8664c3d171ecf5264e39c9fca37dc4dc6580f5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59e621fcddabe616abdf2e113b3418fb1770ad00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59e621fcddabe616abdf2e113b3418fb1770ad00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59e621fcddabe616abdf2e113b3418fb1770ad00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59e621fcddabe616abdf2e113b3418fb1770ad00/comments", "author": null, "committer": null, "parents": [{"sha": "6b9ab5cc45bfc38ce768e9c472cad34e81c857f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9ab5cc45bfc38ce768e9c472cad34e81c857f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9ab5cc45bfc38ce768e9c472cad34e81c857f7"}], "stats": {"total": 977, "additions": 601, "deletions": 376}, "files": [{"sha": "472cbd3cb15b35542ddcafe93f65fb10aff56928", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59e621fcddabe616abdf2e113b3418fb1770ad00", "patch": "@@ -1,3 +1,35 @@\n+Sat Jul 11 16:19:48 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cplus-dem.c (string): Move definition before work_stuff.\n+\t(work_stuff): Add volatile_type, forgetting_types,\n+\tprevious_argument, and nrepeats fields.\n+\t(SCOPE_STRING): New macro.\n+\t(demangle_template): Add `remember' parameter.  Add comment.\n+\tRegister the `B' code type here, if remembering.  Tidy.  Fix crash\n+\ton NULL tmpl_argvec.  Be consistent with use of tname/trawname.\n+\t(demangle_nested_args): New function.\n+\t(internal_cplus_demangle): Handle volatile-qualified member\n+\tfunctions. \n+\t(mop_up): Delete the previous_argument string if present.\n+\t(demangle_signature): Tidy.  Handle volatile-qualified member\n+\tfunctions.  Handle back-references using the `B' code.  Use extra\n+\tparameter to demangle_template and SCOPE_STRING where appropriate.\n+\t(demangle_template_value_parm): Fix thinko; 'B' is not an integral\n+\tcode. \n+\t(demangle_class): Use SCOPE_STRING.\n+\t(gnu_special): Pass additional argument to demangle_template.\n+\tUse SCOPE_STRING.\n+\t(demangle_qualified): Save qualified types for later\n+\tback-references.  Handle constructors and destructors for template\n+\ttypes correctly.\n+\t(do_type): Tidy.  Use SCOPE_STRING.  Pass extra argument to\n+\tdemangle_template.  Use demangled_nested_args.  Don't remember\n+\tqualified types here; that's now done in demangle_qualified.\n+\tSimilarly for templates.\n+\t(do_arg): Improve commment.  Handle 'n' repeat code.\n+\t(remember_type): Check forgetting_types.\n+\t(demangle_args): Deal with 'n' repeat codes.  Tidy.\n+\t\n Sat Jul 11 02:59:08 1998  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (extendhisi2_mem, movhi, movhi_bytes): Propagate the volatile"}, {"sha": "d72b442df2b3c94809e565e978de256e935b63b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=59e621fcddabe616abdf2e113b3418fb1770ad00", "patch": "@@ -1,5 +1,41 @@\n 1998-07-11  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* method.c (flush_repeats): Add nrepeats parameter.\n+\t(issue_nrepeats): Likewise.\n+\t(is_back_referenceable_type): New function.  Don't back-reference\n+\tTEMPLATE_TYPE_PARMs as well as simple types like integers.\n+\t(build_mangled_name_for_type): Likewise.\n+\t(build_mangled_name_for_type_with_Gcode): Likewise.\n+\t(lasttype): Remove.\n+\t(nrepeats): Likewise.\n+\t(Nrepeats): Likewise.\n+\t(start_squangling): Don't clear the variables removed above.\n+\t(end_squangling): Likewise.\n+\t(flush_repeats): Tidy.  Use nrepeats parameter rather than\n+\tNrepeats global.\n+\t(issue_nrepeats): Likewise, but with nrepeats global.  Use\n+\tis_backreferenceable_type.\n+\t(build_overload_nested_name): Tidy.  Add comment.  Use\n+\tbuild_mangled_name_for_type.\n+\t(build_underscore_int): Comment.\n+\t(build_overload_scope_ref): Use build_mangled_name_for_type.\n+\t(build_overload_int): Likewise.\n+\t(build_template_template_parm_names): Tidy.\n+\t(build_template_parm_names): Use build_mangled_name_for_type.\n+\t(build_overload_identifier): Add comments.\n+\t(build_mangled_name_for_type_with_Gcode): Split out from\n+\tbuild_mangled_name.\n+\t(build_mangled_name_for_type): Use it.\n+\t(build_mangled_name): Rework to use build_mangled_name_for_type\n+\tand to not use global nrepeats/Nrepeats.  Tidy.\n+\t(process_modifiers): Tidy.\n+\t(check_btype): Use is_backreferenceable_type.  Add comment.\n+\tRename `node' to `type'.\n+\t(process_overload_item): Set numeric_output_need_bar here.\n+\tUse build_mangled_name_for_type.  Tidy.\n+\t(build_decl_overload_real): Tidy.  Don't use Nrepeats.  Use\n+\tbuild_mangled_name_for_type.\n+\n \t* pt.c (push_template_decl_real): Don't look at DECL_TEMPLATE_INFO\n \tfor TYPE_DECLs.\n "}, {"sha": "23f52c2679d9fa620d29b85814e50a290c4fcd41", "filename": "gcc/cp/method.c", "status": "modified", "additions": 288, "deletions": 261, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=59e621fcddabe616abdf2e113b3418fb1770ad00", "patch": "@@ -57,14 +57,14 @@ static char *scratch_firstobj;\n \n static void icat PROTO((HOST_WIDE_INT));\n static void dicat PROTO((HOST_WIDE_INT, HOST_WIDE_INT));\n-static void flush_repeats PROTO((tree));\n+static void flush_repeats PROTO((int, tree));\n static void build_overload_identifier PROTO((tree));\n static void build_overload_nested_name PROTO((tree));\n static void build_overload_int PROTO((tree, int));\n static void build_overload_identifier PROTO((tree));\n static void build_qualified_name PROTO((tree));\n static void build_overload_value PROTO((tree, tree, int));\n-static void issue_nrepeats PROTO((tree));\n+static void issue_nrepeats PROTO((int, tree));\n static char *build_mangled_name PROTO((tree,int,int));\n static void process_modifiers PROTO((tree));\n static void process_overload_item PROTO((tree,int));\n@@ -82,7 +82,10 @@ static int check_ktype PROTO((tree, int));\n static int issue_ktype PROTO((tree));\n static void build_overload_scope_ref PROTO((tree));\n static void build_mangled_template_parm_index PROTO((char *, tree));\n+static int is_back_referenceable_type PROTO((tree));\n static int check_btype PROTO((tree));\n+static void build_mangled_name_for_type PROTO((tree));\n+static void build_mangled_name_for_type_with_Gcode PROTO((tree, int));\n \n # define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n # define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n@@ -173,17 +176,13 @@ do_inline_function_hair (type, friend_list)\n /* type tables for K and B type compression */\n static tree *btypelist = NULL;\n static tree *ktypelist = NULL;\n-static tree lasttype = NULL;\n static int maxbsize = 0;\n static int maxksize = 0;\n \n /* number of each type seen */\n static int maxbtype = 0;\n static int maxktype = 0;\n \n-/* Number of occurrences of last b type seen.  */\n-static int nrepeats = 0;\n-\n /* Array of types seen so far in top-level call to `build_mangled_name'.\n    Allocated and deallocated by caller.  */\n static tree *typevec = NULL;\n@@ -192,9 +191,6 @@ static int  typevec_size;\n /* Number of types interned by `build_mangled_name' so far.  */\n static int maxtype = 0;\n \n-/* Number of occurrences of last type seen.  */\n-static int Nrepeats = 0;\n-\n /* Nonzero if we should not try folding parameter types.  */\n static int nofold;\n \n@@ -207,9 +203,7 @@ start_squangling ()\n {\n   if (flag_do_squangling)\n     {\n-      lasttype = NULL;\n       nofold = 0;\n-      nrepeats = 0;\n       maxbtype = 0;\n       maxktype = 0;\n       maxbsize = 50;\n@@ -224,7 +218,6 @@ end_squangling ()\n {\n   if (flag_do_squangling)\n     {\n-      lasttype = NULL;\n       if (ktypelist)\n         free (ktypelist);\n       if (btypelist)\n@@ -305,59 +298,83 @@ dicat (lo, hi)\n   OB_PUTC ('0' + ulo);\n }\n \n-static __inline void\n-flush_repeats (type)\n+__inline void\n+flush_repeats (nrepeats, type)\n+     int nrepeats;\n      tree type;\n {\n   int tindex = 0;\n \n   while (typevec[tindex] != type)\n     tindex++;\n \n-  if (Nrepeats > 1)\n+  if (nrepeats > 1)\n     {\n       OB_PUTC ('N');\n-      icat (Nrepeats);\n-      if (Nrepeats > 9)\n+      icat (nrepeats);\n+      if (nrepeats > 9)\n \tOB_PUTC ('_');\n     }\n   else\n     OB_PUTC ('T');\n-  Nrepeats = 0;\n   icat (tindex);\n   if (tindex > 9)\n     OB_PUTC ('_');\n }\n \n+/* Returns nonzero iff this is a type to which we will want to make\n+   back-references (using the `B' code).  */\n \n-/* issue squangling type repeating */\n-static void\n-issue_nrepeats (lasttype)\n-     tree lasttype;\n+int\n+is_back_referenceable_type (type)\n+     tree type;\n {\n-  if (nrepeats == 1)\n+  if (btypelist == NULL)\n+    /* We're not generating any back-references.  */\n+    return 0;\n+\n+  switch (TREE_CODE (type)) \n     {\n-      switch (TREE_CODE (lasttype))\n-        {\n-          case INTEGER_TYPE:\n-          case REAL_TYPE:\n-          case VOID_TYPE:\n-          case BOOLEAN_TYPE:\n-            process_overload_item (lasttype, FALSE);\n-            nrepeats = 0;\n-            return;\n-\n-          default:\n-            break;\n-        }\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+      /* These types have single-character manglings, so there's no\n+\t point in generating back-references.  */\n+      return 0;         \n+\n+    case TEMPLATE_TYPE_PARM:\n+      /* It would be a bit complex to demangle signatures correctly if\n+\t we generated back-references to these, and the manglings of\n+\t type parameters are short.  */\n+      return 0;\n+\n+    default:\n+      return 1;\n     }\n-  OB_PUTC ('n');\n-  icat (nrepeats);\n-  if (nrepeats > 9)\n-    OB_PUTC ('_');\n-  nrepeats = 0;\n }\n \n+/* Issue the squangling code indicating NREPEATS repetitions of TYPE,\n+   which was the last parameter type output.  */\n+\n+static void\n+issue_nrepeats (nrepeats, type)\n+     int nrepeats;\n+     tree type;\n+{\n+  if (nrepeats == 1 && !is_back_referenceable_type (type))\n+    /* For types whose manglings are short, don't bother using the\n+       repetition code if there's only one repetition, since the\n+       repetition code will be about as long as the ordinary mangling.  */ \n+    build_mangled_name_for_type (type);\n+  else\n+    {\n+      OB_PUTC ('n');\n+      icat (nrepeats);\n+      if (nrepeats > 9)\n+\tOB_PUTC ('_');\n+    }\n+}\n \n /* Check to see if a tree node has been entered into the Kcode typelist    */\n /* if not, add it. Return -1 if it isn't found, otherwise return the index */\n@@ -410,12 +427,16 @@ issue_ktype (decl)\n     }\n   return FALSE;\n }\n+  \n+/* Build a representation for DECL, which may be an entity not at\n+   global scope.  If so, a marker indicating that the name is\n+   qualified has already been output, but the qualifying context has\n+   not.  */\n \n static void\n build_overload_nested_name (decl)\n      tree decl;\n {\n-\n   tree context;\n \n   if (ktypelist && issue_ktype (decl))\n@@ -433,7 +454,7 @@ build_overload_nested_name (decl)\n        rather than 'T' or some such. */\n     if (TREE_CODE (context) == TEMPLATE_TYPE_PARM\n         || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n-      build_mangled_name (context, 0, 0);\n+      build_mangled_name_for_type (context);\n     else\n     {\n       if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n@@ -462,6 +483,9 @@ build_overload_nested_name (decl)\n     build_overload_identifier (decl);\n }\n \n+/* Output the decimal representation of I.  If I > 9, the decimal\n+   representation is preceeded and followed by an underscore.  */\n+\n static void\n build_underscore_int (i)\n      int i;\n@@ -479,7 +503,7 @@ build_overload_scope_ref (value)\n {\n   OB_PUTC2 ('Q', '2');\n   numeric_output_need_bar = 0;\n-  build_mangled_name (TREE_OPERAND (value, 0), 0, 0);\n+  build_mangled_name_for_type (TREE_OPERAND (value, 0));\n   build_overload_identifier (TREE_OPERAND (value, 1));\n }\n \n@@ -539,7 +563,7 @@ build_overload_int (value, in_template)\n \t\t/* We can get here with sizeof, e.g.:\n \t\t     \n \t\t   template <class T> void f(A<sizeof(T)>);  */\n-\t\tprocess_overload_item (operand, 0);\n+\t\tbuild_mangled_name_for_type (operand);\n \t      else if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (tc)))\n \t\tbuild_overload_int (operand, in_template);\n \t      else\n@@ -825,10 +849,8 @@ build_template_template_parm_names (parmlist)\n \t  build_template_template_parm_names (DECL_INNERMOST_TEMPLATE_PARMS (parm));\n \t}\n       else\n-\t{\n-\t  /* It's a PARM_DECL.  */\n-\t  build_mangled_name (TREE_TYPE (parm), 0, 0);\n-\t}\n+\t/* It's a PARM_DECL.  */\n+\tbuild_mangled_name_for_type (TREE_TYPE (parm));\n     }\n }\n \n@@ -853,14 +875,14 @@ build_template_parm_names (parmlist, arglist)\n \t{\n \t  /* This parameter is a type.  */\n \t  OB_PUTC ('Z');\n-\t  build_mangled_name (arg, 0, 0);\n+\t  build_mangled_name_for_type (arg);\n \t}\n       else if (TREE_CODE (parm) == TEMPLATE_DECL)\n \t{\n \t  /* This parameter is a template. */\n \t  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n \t    /* Output parameter declaration, argument index and level */\n-\t    build_mangled_name (arg, 0, 0);\n+\t    build_mangled_name_for_type (arg);\n \t  else\n \t    {\n \t      /* A TEMPLATE_DECL node, output the parameter declaration \n@@ -876,12 +898,14 @@ build_template_parm_names (parmlist, arglist)\n \t{\n \t  parm = tsubst (parm, arglist, NULL_TREE);\n \t  /* It's a PARM_DECL.  */\n-\t  build_mangled_name (TREE_TYPE (parm), 0, 0);\n+\t  build_mangled_name_for_type (TREE_TYPE (parm));\n \t  build_overload_value (parm, arg, uses_template_parms (arglist));\n \t}\n     }\n  }\n \n+/* Output the representation for NAME, which is either a TYPE_DECL or\n+   an IDENTIFIER.  */\n \n static void\n build_overload_identifier (name)\n@@ -895,6 +919,7 @@ build_overload_identifier (name)\n \t\t\t\t       (TREE_TYPE (name))))\n \t      == FUNCTION_DECL)))\n     {\n+      /* NAME is the TYPE_DECL for a template specialization.  */\n       tree template, parmlist, arglist, tname;\n       template = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name));\n       arglist = innermost_args (TREE_VALUE (template), 0);\n@@ -969,6 +994,32 @@ build_qualified_name (decl)\n   build_overload_nested_name (decl);\n }\n \n+/* Output the mangled representation for TYPE.  If EXTRA_GCODE is\n+   non-zero, mangled names for structure/union types are intentionally\n+   mangled differently from the method described in the ARM.  */\n+\n+void \n+build_mangled_name_for_type_with_Gcode (type, extra_Gcode)\n+     tree type;\n+     int extra_Gcode;\n+{\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+  type = CANONICAL_TYPE_VARIANT (type);\n+  process_modifiers (type);\n+  process_overload_item (type, extra_Gcode);\n+}\n+\n+/* Like build_mangled_name_for_type_with_Gcode, but never outputs the\n+   `G'.  */\n+\n+void\n+build_mangled_name_for_type (type)\n+     tree type;\n+{\n+  build_mangled_name_for_type_with_Gcode (type, 0);\n+}\n+\n /* Given a list of parameters in PARMTYPES, create an unambiguous\n    overload string. Should distinguish any type that C (or C++) can\n    distinguish. I.e., pointers to functions are treated correctly.\n@@ -993,107 +1044,116 @@ build_overload_name (parmtypes, begin, end)\n   return ret ;\n }\n \n+/* Output the mangled representation for PARMTYPES.  If PARMTYPES is a\n+   TREE_LIST, then it is a list of parameter types.  Otherwise,\n+   PARMTYPES must be a single type.  */\n+\n static char *\n build_mangled_name (parmtypes, begin, end)\n      tree parmtypes;\n      int begin, end;\n {\n-  tree parmtype;\n-\n   if (begin) \n     OB_INIT ();\n-  numeric_output_need_bar = 0;\n \n-  if (TREE_CODE (parmtypes) != TREE_LIST)  /* just one item */\n+  if (TREE_CODE (parmtypes) != TREE_LIST)  \n+    /* There is only one type.  */\n+    build_mangled_name_for_type (parmtypes);\n+  else  \n     {\n-      if (TYPE_PTRMEMFUNC_P (parmtypes))\n-        parmtypes = TYPE_PTRMEMFUNC_FN_TYPE (parmtypes);\n-      parmtypes = CANONICAL_TYPE_VARIANT (parmtypes);\n-      process_modifiers (parmtypes);\n-      process_overload_item (parmtypes, FALSE);\n-    }\n-  else  {\n-    for ( ; parmtypes!=NULL; parmtypes = TREE_CHAIN (parmtypes))\n-      {\n-        parmtype = CANONICAL_TYPE_VARIANT (TREE_VALUE (parmtypes));\n-        if (flag_do_squangling)       /* squangling style repeats */\n-          {\n-            if (parmtype == lasttype) \n-              {\n-                nrepeats++;\n-                continue;\n-              }\n-            else \n-              if (nrepeats != 0) \n-                {\n-                  issue_nrepeats (lasttype);\n-                }\n-            lasttype = parmtype;\n-          }\n-        else \n-          if (!nofold && typevec)\n-            {\n-              /* Every argument gets counted.  */\n+      /* There are several types in a parameter list.  */\n+      int nrepeats = 0;\n+      int old_style_repeats = !flag_do_squangling && !nofold && typevec;\n+      tree last_type = NULL_TREE;\n+\n+      for (; parmtypes && parmtypes != void_list_node;\n+\t   parmtypes = TREE_CHAIN (parmtypes))\n+\t{\n+\t  tree parmtype = CANONICAL_TYPE_VARIANT (TREE_VALUE (parmtypes));\n+\n+\t  if (old_style_repeats)\n+\t    {\n+\t      /* Every argument gets counted.  */\n \t      my_friendly_assert (maxtype < typevec_size, 387);\n-              typevec[maxtype++] = parmtype;\n+\t      typevec[maxtype++] = parmtype;\n+\t    }\n \n-              if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2]\n-\t\t  && ! TYPE_FOR_JAVA (parmtype))\n-                {\n-                  Nrepeats++;\n-                  continue;\n-                }\n+\t  if (parmtype == last_type)\n+\t    {\n+\t      if (flag_do_squangling \n+\t\t  || (old_style_repeats && TREE_USED (parmtype)\n+\t\t      && !TYPE_FOR_JAVA (parmtype)))\n+\t\t{\n+\t\t  /* The next type is the same as this one.  Keep\n+\t\t     track of the repetition, and output the repeat\n+\t\t     count later.  */\n+\t\t  nrepeats++;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else if (nrepeats != 0)\n+\t    {\n+\t      /* Indicate how many times the previous parameter was\n+\t\t repeated.  */\n+\t      if (old_style_repeats)\n+\t\tflush_repeats (nrepeats, last_type);\n+\t      else\n+\t\tissue_nrepeats (nrepeats, last_type);\n+\t      nrepeats = 0;\n+\t    }\n+\t  \n+\t  last_type = parmtype;\n \n-              if (Nrepeats)\n-                flush_repeats (typevec[maxtype-2]);\n+\t  if (old_style_repeats)\n+\t    {\n+\t      if (nrepeats)\n+\t\t{\n+\t\t  flush_repeats (nrepeats, last_type);\n+\t\t  nrepeats = 0;\n+\t\t}\n \n-              if (TREE_USED (parmtype))\n-                {\n+\t      if (TREE_USED (parmtype))\n+\t\t{\n #if 0\n-                  /* We can turn this on at some point when we want\n-                     improved symbol mangling.  */\n-                  Nrepeats++;\n+\t\t  /* We can turn this on at some point when we want\n+\t\t     improved symbol mangling.  */\n+\t\t  nrepeats++;\n #else\n-                  /* This is bug compatible with 2.7.x  */\n-                  flush_repeats (parmtype);\n+\t\t  /* This is bug compatible with 2.7.x  */\n+\t\t  flush_repeats (nrepeats, parmtype);\n #endif\n-                  continue;\n-                }\n-\n-              /* Only cache types which take more than one character.  */\n-              if ((parmtype != TYPE_MAIN_VARIANT (parmtype)\n+\t\t  nrepeats = 0;\n+\t\t  continue;\n+\t\t}\n+\t      \n+\t      /* Only cache types which take more than one character.  */\n+\t      if ((parmtype != TYPE_MAIN_VARIANT (parmtype)\n \t\t   || (TREE_CODE (parmtype) != INTEGER_TYPE\n \t\t       && TREE_CODE (parmtype) != REAL_TYPE))\n \t\t  && ! TYPE_FOR_JAVA (parmtype))\n-                TREE_USED (parmtype) = 1;\n-            }\n-        if (TYPE_PTRMEMFUNC_P (parmtype))\n-          parmtype = TYPE_PTRMEMFUNC_FN_TYPE (parmtype);\n-        process_modifiers (parmtype);\n-        if (TREE_CODE(parmtype)==VOID_TYPE) \n-\t  {\n-#if 0\n-\t      extern tree void_list_node;\n+\t\tTREE_USED (parmtype) = 1;\n+\t    }\n+\n+\t  /* Output the PARMTYPE.  */\n+\t  build_mangled_name_for_type_with_Gcode (parmtype, 1);\n+\t}\n+\n+      /* Output the repeat count for the last parameter, if\n+\t necessary.  */\n+      if (nrepeats != 0)\n+\t{\n+\t  if (old_style_repeats)\n+\t    flush_repeats (nrepeats, last_type);\n+\t  else\n+\t    issue_nrepeats (nrepeats, last_type);\n+\t  nrepeats = 0;\n+\t}\n+\n+      if (!parmtypes)\n+\t/* The parameter list ends in an ellipsis.  */\n+\tOB_PUTC ('e');\n+    }\n \n-\t      /* See if anybody is wasting memory.  */\n-\t      my_friendly_assert (parmtypes == void_list_node, 247);\n-#endif\n-\t      /* This is the end of a parameter list.  */\n-\t      if (end) \n-                OB_FINISH ();\n-\t      return (char *)obstack_base (&scratch_obstack);\n-\t  }\n-        process_overload_item (parmtype, TRUE);\n-      }\n-      if (flag_do_squangling && nrepeats != 0)\n-        issue_nrepeats (lasttype);\n-      else \n-        if (Nrepeats && typevec)\n-          flush_repeats (typevec[maxtype-1]);\n-\n-      /* To get here, parms must end with `...'.  */\n-      OB_PUTC ('e');\n-  }\n   if (end) \n     OB_FINISH ();\n   return (char *)obstack_base (&scratch_obstack);\n@@ -1104,63 +1164,57 @@ void\n process_modifiers (parmtype) \n      tree parmtype;\n {\n-\n-\n   if (TREE_READONLY (parmtype))\n     OB_PUTC ('C');\n   if (TREE_CODE (parmtype) == INTEGER_TYPE\n       && (TYPE_MAIN_VARIANT (parmtype)\n \t  == unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n       && ! TYPE_FOR_JAVA (parmtype))\n-    {\n-      OB_PUTC ('U');\n-    }\n+    OB_PUTC ('U');\n   if (TYPE_VOLATILE (parmtype))\n     OB_PUTC ('V');\n }\n \n-/* Check to see if a tree node has been entered into the Bcode typelist \n-   if not, add it. Otherwise emit the code and return TRUE */\n-static int \n-check_btype (node) \n-     tree node;\n+/* Check to see if TYPE has been entered into the Bcode typelist.  If\n+   so, return 1 and emit a backreference to TYPE.  Otherwise, add TYPE\n+   to the list of back-referenceable types and return 0.  */\n+\n+int \n+check_btype (type) \n+     tree type;\n {\n   int x;\n \n   if (btypelist == NULL)\n     return 0;\n \n-  switch (TREE_CODE (node)) \n-    {\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case VOID_TYPE:\n-    case BOOLEAN_TYPE:\n-      return 0;         /* don't compress single char basic types */\n+  if (!is_back_referenceable_type (type))\n+    return 0;\n \n-    default:\n-      break;\n-    }\n+  /* We assume that our caller has put out any necessary\n+     qualifiers.  */\n+  type = TYPE_MAIN_VARIANT (type);\n \n-  node = TYPE_MAIN_VARIANT (node);\n   for (x = 0; x < maxbtype; x++) \n-    {\n-      if (node == btypelist[x]) \n-        {\n-          OB_PUTC ('B');\n-          icat (x);\n-          if (x > 9)\n-            OB_PUTC ('_');\n-          return 1 ;\n-        }\n-    }\n-  /* didn't find it, so add it here */\n+    if (type == btypelist[x]) \n+      {\n+\tOB_PUTC ('B');\n+\ticat (x);\n+\tif (x > 9)\n+\t  OB_PUTC ('_');\n+\treturn 1 ;\n+      }\n+\n   if (maxbsize <= maxbtype) \n     {\n+      /* Enlarge the table.  */\n       maxbsize = maxbsize * 3 / 2;\n       btypelist = (tree *)xrealloc (btypelist, sizeof (tree) * maxbsize); \n     }\n-  btypelist[maxbtype++] = node;\n+  \n+  /* Register the TYPE.  */\n+  btypelist[maxbtype++] = type;\n+\n   return 0;\n }\n \n@@ -1170,6 +1224,7 @@ process_overload_item (parmtype, extra_Gcode)\n   tree parmtype;\n   int extra_Gcode;\n {\n+  numeric_output_need_bar = 0;\n \n   /* These tree types are considered modifiers for B code squangling , */\n   /* and therefore should not get entries in the Btypelist             */\n@@ -1206,85 +1261,65 @@ process_overload_item (parmtype, extra_Gcode)\n     case POINTER_TYPE:\n       OB_PUTC ('P');\n     more:\n-      build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+      build_mangled_name_for_type (TREE_TYPE (parmtype));\n       return;\n       break;\n \n     default:\n       break;\n     }\n   \n-  /* check if type is already in the typelist. If not, add it now */\n-\n-  if (flag_do_squangling && btypelist != NULL) {\n-    if (check_btype (parmtype))    /* emits the code if it finds it */\n-      return;\n-  }\n+  if (flag_do_squangling && check_btype (parmtype)) \n+    /* If PARMTYPE is already in the list of back-referenceable types,\n+       then check_btype will output the appropriate reference, and\n+       there's nothing more to do.  */\n+    return;\n \n   switch (TREE_CODE (parmtype))\n     {\n     case OFFSET_TYPE:\n       OB_PUTC ('O');\n-      build_mangled_name (TYPE_OFFSET_BASETYPE (parmtype), 0, 0);\n+      build_mangled_name_for_type (TYPE_OFFSET_BASETYPE (parmtype));\n       OB_PUTC ('_');\n-      build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+      build_mangled_name_for_type (TREE_TYPE (parmtype));\n       break;\n \n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n-        tree firstarg = TYPE_ARG_TYPES (parmtype);\n-        /* Otherwise have to implement reentrant typevecs,\n-           unmark and remark types, etc.  */\n-        int old_nofold = nofold;\n-        if (!flag_do_squangling) {\n-          nofold = 1;\n-          if (Nrepeats)\n-            flush_repeats (typevec[maxtype-1]);\n-        }\n-        else \n-          if (nrepeats != 0)\n-            issue_nrepeats (lasttype);\n+        tree parms = TYPE_ARG_TYPES (parmtype);\n \n-        /* @@ It may be possible to pass a function type in\n-           which is not preceded by a 'P'.  */\n-        if (TREE_CODE (parmtype) == FUNCTION_TYPE)\n-          {\n-            OB_PUTC ('F');\n-            if (firstarg == NULL_TREE)\n-              OB_PUTC ('e');\n-            else if (firstarg == void_list_node)\n-              OB_PUTC ('v');\n-            else\n-              build_mangled_name (firstarg, 0, 0);\n-          }\n-        else\n-          {\n-            int constp = TYPE_READONLY (TREE_TYPE (TREE_VALUE (firstarg)));\n-            int volatilep = TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (firstarg)));\n+\t/* Rather than implementing a reentrant TYPEVEC, we turn off\n+\t   repeat codes here, unless we're squangling.  Squangling\n+\t   doesn't make use of the TYPEVEC, so there's no reentrancy\n+\t   problem.  */\n+\tint old_nofold = nofold;\n+\tif (!flag_do_squangling)\n+\t  nofold = 1;\n+\n+\tif (TREE_CODE (parmtype) == METHOD_TYPE)\n+\t  {\n+\t    /* Mark this as a method.  */\n             OB_PUTC ('M');\n-            firstarg = TREE_CHAIN (firstarg);\n-\n-            build_mangled_name (TYPE_METHOD_BASETYPE (parmtype), 0, 0);\n-            if (constp)\n-              OB_PUTC ('C');\n-            if (volatilep)\n-              OB_PUTC ('V');\n-\n-            /* For cfront 2.0 compatibility.  */\n-            OB_PUTC ('F');\n-\n-            if (firstarg == NULL_TREE)\n-              OB_PUTC ('e');\n-            else if (firstarg == void_list_node)\n-              OB_PUTC ('v');\n-            else\n-              build_mangled_name (firstarg, 0, 0);\n-          }\n+\t    /* Output the class of which this method is a member.  */\n+            build_mangled_name_for_type (TYPE_METHOD_BASETYPE (parmtype));\n+\t    /* Output any qualifiers for the `this' parameter.  */\n+\t    process_modifiers (TREE_TYPE (TREE_VALUE (parms)));\n+\t  }\n \n-        /* Separate args from return type.  */\n+\t/* Output the parameter types.  */\n+\tOB_PUTC ('F');\n+\tif (parms == NULL_TREE)\n+\t  OB_PUTC ('e');\n+\telse if (parms == void_list_node)\n+\t  OB_PUTC ('v');\n+\telse\n+\t  build_mangled_name (parms, 0, 0);\n+\n+        /* Output the return type.  */\n         OB_PUTC ('_');\n-        build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+        build_mangled_name_for_type (TREE_TYPE (parmtype));\n+\n         nofold = old_nofold;\n         break;\n       }\n@@ -1350,7 +1385,7 @@ process_overload_item (parmtype, extra_Gcode)\n \n     case COMPLEX_TYPE:\n       OB_PUTC ('J');\n-      build_mangled_name (TREE_TYPE (parmtype), 0, 0);\n+      build_mangled_name_for_type (TREE_TYPE (parmtype));\n       break;\n \n     case VOID_TYPE:\n@@ -1492,41 +1527,20 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n      and figure out its name without any extra encoding.  */\n \n   OB_PUTC2 ('_', '_');\n-  if (for_method)\n-    {\n-#if 0\n-      /* We can get away without doing this.  */\n-      OB_PUTC ('M');\n-#endif\n-      if (tparms != NULL_TREE)\n-\tOB_PUTC ('H');\n-      {\n-\ttree this_type = TREE_VALUE (parms);\n-\n-\tif (TREE_CODE (this_type) == RECORD_TYPE)  /* a signature pointer */\n-\t  parms = temp_tree_cons (NULL_TREE, SIGNATURE_TYPE (this_type),\n-\t\t\t\t  TREE_CHAIN (parms));\n-\telse\n-\t  parms = temp_tree_cons (NULL_TREE, TREE_TYPE (this_type),\n-\t\t\t\t  TREE_CHAIN (parms));\n-      }\n-    }\n-  else if (tparms)\n-    OB_PUTC ('H');\n-  /* XXX this works only if we call this in the same namespace\n-     as the declaration. Unfortunately, we don't have the _DECL,\n-     only its name */\n-  else if (current_namespace == global_namespace)\n-    OB_PUTC ('F');\n \n   if (tparms)\n     {\n+      OB_PUTC ('H');\n       build_template_parm_names (tparms, targs);\n       OB_PUTC ('_');\n     }\n-\n-  /* qualify with namespace */\n-  if (!for_method && current_namespace != global_namespace)\n+  else if (!for_method && current_namespace == global_namespace)\n+    /* XXX this works only if we call this in the same namespace\n+       as the declaration. Unfortunately, we don't have the _DECL,\n+       only its name */\n+    OB_PUTC ('F');\n+  else if (!for_method)\n+    /* qualify with namespace */\n     build_qualified_name (current_namespace);\n \n   if (parms == NULL_TREE)\n@@ -1538,23 +1552,36 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n       if (!flag_do_squangling)    /* Allocate typevec array. */\n         {\n           maxtype = 0;\n-          Nrepeats = 0;\n \t  typevec_size = list_length (parms);\n \t  if (!for_method && current_namespace != global_namespace)\n \t    /* the namespace of a global function needs one slot */\n \t    typevec_size++;\n           typevec = (tree *)alloca (typevec_size * sizeof (tree));\n         }\n       nofold = 0;\n+\n       if (for_method)\n \t{\n-\t  build_mangled_name (TREE_VALUE (parms), 0, 0);\n+\t  tree this_type = TREE_VALUE (parms);\n \n-          if (!flag_do_squangling) {\n-\t    my_friendly_assert (maxtype < typevec_size, 387);\n-            typevec[maxtype++] = TREE_VALUE (parms);\n-            TREE_USED (TREE_VALUE (parms)) = 1;\n-          }\n+\t  if (TREE_CODE (this_type) == RECORD_TYPE)  /* a signature pointer */\n+\t    this_type = SIGNATURE_TYPE (this_type);\n+\t  else\n+\t    this_type = TREE_TYPE (this_type);\n+\n+\t  build_mangled_name_for_type (this_type);\n+\n+          if (!flag_do_squangling) \n+\t    {\n+\t      my_friendly_assert (maxtype < typevec_size, 387);\n+\t      typevec[maxtype++] = this_type;\n+\t      TREE_USED (this_type) = 1;\n+\n+\t      /* By setting up PARMS in this way, the loop below will\n+\t\t automatically clear TREE_USED on THIS_TYPE.  */\n+\t      parms = temp_tree_cons (NULL_TREE, this_type,\n+\t\t\t\t      TREE_CHAIN (parms));\n+\t    }\n \n \t  if (TREE_CHAIN (parms))\n \t    build_mangled_name (TREE_CHAIN (parms), 0, 0);\n@@ -1594,7 +1621,7 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n     {\n       /* Add the return type. */\n       OB_PUTC ('_');\n-      build_mangled_name (ret_type, 0, 0);\n+      build_mangled_name_for_type (ret_type);\n     }\n \n   OB_FINISH ();"}, {"sha": "ce67d2288e4e6bf76e6b7a55ec316ed4f716a897", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 245, "deletions": 115, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e621fcddabe616abdf2e113b3418fb1770ad00/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=59e621fcddabe616abdf2e113b3418fb1770ad00", "patch": "@@ -94,6 +94,13 @@ set_cplus_marker_for_demangling (ch)\n   cplus_markers[0] = ch;\n }\n \n+typedef struct string\t\t/* Beware: these aren't required to be */\n+{\t\t\t\t/*  '\\0' terminated.  */\n+  char *b;\t\t\t/* pointer to start of string */\n+  char *p;\t\t\t/* pointer after last character */\n+  char *e;\t\t\t/* pointer after end of allocated space */\n+} string;\n+\n /* Stuff that is shared between sub-routines.\n    Using a shared structure allows cplus_demangle to be reentrant.  */\n \n@@ -113,8 +120,14 @@ struct work_stuff\n   int destructor;\n   int static_type;\t/* A static member function */\n   int const_type;\t/* A const member function */\n+  int volatile_type;    /* A volatile member function */\n   char **tmpl_argvec;   /* Template function arguments. */\n   int ntmpl_args;       /* The number of template function arguments. */\n+  int forgetting_types; /* Nonzero if we are not remembering the types\n+\t\t\t   we see.  */\n+  string* previous_argument; /* The last function argument demangled.  */\n+  int nrepeats;         /* The number of times to repeat the previous\n+\t\t\t   argument.  */\n };\n \n #define PRINT_ANSI_QUALIFIERS (work -> options & DMGL_ANSI)\n@@ -208,20 +221,17 @@ static const struct optable\n };\n \n \n-typedef struct string\t\t/* Beware: these aren't required to be */\n-{\t\t\t\t/*  '\\0' terminated.  */\n-  char *b;\t\t\t/* pointer to start of string */\n-  char *p;\t\t\t/* pointer after last character */\n-  char *e;\t\t\t/* pointer after end of allocated space */\n-} string;\n-\n #define STRING_EMPTY(str)\t((str) -> b == (str) -> p)\n #define PREPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_prepend(str, \" \");}\n #define APPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_append(str, \" \");}\n #define LEN_STRING(str)         ( (STRING_EMPTY(str))?0:((str)->p - (str)->b))\n \n+/* The scope separator appropriate for the language being demangled.  */\n+#define SCOPE_STRING(work) \\\n+  (((work)->options & DMGL_JAVA) ? \".\" : \"::\")\n+\n #define ARM_VTABLE_STRING \"__vtbl__\"\t/* Lucid/ARM virtual table prefix */\n #define ARM_VTABLE_STRLEN 8\t\t/* strlen (ARM_VTABLE_STRING) */\n \n@@ -247,7 +257,7 @@ demangle_template_template_parm PARAMS ((struct work_stuff *work,\n \n static int\n demangle_template PARAMS ((struct work_stuff *work, const char **, string *,\n-\t\t\t   string *, int));\n+\t\t\t   string *, int, int));\n \n static int\n arm_pt PARAMS ((struct work_stuff *, const char *, int, const char **,\n@@ -325,6 +335,9 @@ consume_count_with_underscores PARAMS ((const char**));\n static int\n demangle_args PARAMS ((struct work_stuff *, const char **, string *));\n \n+static int\n+demangle_nested_args PARAMS ((struct work_stuff*, const char**, string*));\n+\n static int\n do_type PARAMS ((struct work_stuff *, const char **, string *));\n \n@@ -631,12 +644,15 @@ internal_cplus_demangle (work, mangled)\n   int success = 0;\n   char *demangled = NULL;\n   int s1,s2,s3,s4;\n+  int saved_volatile_type;\n   s1 = work->constructor;\n   s2 = work->destructor;\n   s3 = work->static_type;\n   s4 = work->const_type;\n+  saved_volatile_type = work->volatile_type;\n   work->constructor = work->destructor = 0;\n   work->static_type = work->const_type = 0;\n+  work->volatile_type = 0;\n \n   if ((mangled != NULL) && (*mangled != '\\0'))\n     {\n@@ -677,6 +693,7 @@ internal_cplus_demangle (work, mangled)\n   work->destructor = s2;\n   work->static_type = s3;\n   work->const_type = s4;\n+  work->volatile_type = saved_volatile_type;\n   return (demangled);\n }\n \n@@ -727,6 +744,11 @@ mop_up (work, declp, success)\n       free ((char*) work->tmpl_argvec);\n       work->tmpl_argvec = NULL;\n     }\n+  if (work->previous_argument)\n+    {\n+      string_delete (work->previous_argument);\n+      free ((char*) work->previous_argument);\n+    }\n \n   /* If demangling was successful, ensure that the demangled string is null\n      terminated and return it.  Otherwise, free the demangling decl.  */\n@@ -795,13 +817,9 @@ demangle_signature (work, mangled, declp)\n \t  oldmangled = *mangled;\n \t  success = demangle_qualified (work, mangled, declp, 1, 0);\n \t  if (success)\n-\t    {\n-\t      remember_type (work, oldmangled, *mangled - oldmangled);\n-\t    }\n+\t    remember_type (work, oldmangled, *mangled - oldmangled);\n \t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n-\t    {\n-\t      expect_func = 1;\n-\t    }\n+\t    expect_func = 1;\n \t  oldmangled = NULL;\n \t  break;\n \n@@ -826,13 +844,16 @@ demangle_signature (work, mangled, declp)\n \t  break;\n \n \tcase 'C':\n-\t  /* a const member function */\n+\tcase 'V':\n+\t  if (**mangled == 'C')\n+\t    work -> const_type = 1;\n+\t  else\n+\t    work->volatile_type = 1;\n+\n+\t  /* a qualified member function */\n \t  if (oldmangled == NULL)\n-\t    {\n-\t      oldmangled = *mangled;\n-\t    }\n+\t    oldmangled = *mangled;\n \t  (*mangled)++;\n-\t  work -> const_type = 1;\n \t  break;\n \t  \n \tcase '0': case '1': case '2': case '3': case '4':\n@@ -852,7 +873,21 @@ demangle_signature (work, mangled, declp)\n \t    }\n \t  oldmangled = NULL;\n \t  break;\n-\t  \n+\n+\tcase 'B':\n+\t  {\n+\t    string s;\n+\t    success = do_type (work, mangled, &s);\n+\t    if (success)\n+\t      {\n+\t\tstring_append (&s, SCOPE_STRING (work));\n+\t\tstring_prepends (declp, &s);\n+\t      }\n+\t    oldmangled = NULL;\n+\t    expect_func = 1;\n+\t  }\n+\t  break;\n+\n \tcase 'F':\n \t  /* Function */\n \t  /* ARM style demangling includes a specific 'F' character after\n@@ -884,12 +919,13 @@ demangle_signature (work, mangled, declp)\n \t    {\n \t      oldmangled = *mangled;\n \t    }\n-\t  success = demangle_template (work, mangled, &tname, &trawname, 1);\n+\t  success = demangle_template (work, mangled, &tname,\n+\t\t\t\t       &trawname, 1, 1);\n \t  if (success)\n \t    {\n \t      remember_type (work, oldmangled, *mangled - oldmangled);\n \t    }\n-\t  string_append(&tname, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n+\t  string_append(&tname, SCOPE_STRING (work));\n \t  string_prepends(declp, &tname);\n \t  if (work -> destructor & 1)\n \t    {\n@@ -936,7 +972,8 @@ demangle_signature (work, mangled, declp)\n \t  if (GNU_DEMANGLING) \n \t    {\n \t      /* A G++ template function.  Read the template arguments. */\n-\t      success = demangle_template (work, mangled, declp, 0, 0);\n+\t      success = demangle_template (work, mangled, declp, 0, 0,\n+\t\t\t\t\t   0);\n \t      if (!(work->constructor & 1))\n \t\texpect_return_type = 1;\n \t      (*mangled)++;\n@@ -993,13 +1030,12 @@ demangle_signature (work, mangled, declp)\n \t}\n     }\n   if (success && work -> static_type && PRINT_ARG_TYPES)\n-    {\n-      string_append (declp, \" static\");\n-    }\n+    string_append (declp, \" static\");\n   if (success && work -> const_type && PRINT_ARG_TYPES)\n-    {\n-      string_append (declp, \" const\");\n-    }\n+    string_append (declp, \" const\");\n+  else if (success && work->volatile_type && PRINT_ARG_TYPES)\n+    string_append (declp, \" volatile\");\n+\n   return (success);\n }\n \n@@ -1211,12 +1247,10 @@ demangle_template_value_parm (work, mangled, s)\n \t  continue;\n \tcase 'E':       /* expression */\n \tcase 'Q':\t/* qualified name */\n-\tcase 'K':\t/* qualified name */\n-\t  done = is_integral = 1;\n-\t  break;\n-\tcase 'B':\t/* squangled name */\n+\tcase 'K':       /* qualified name */\n \t  done = is_integral = 1;\n \t  break;\n+\tcase 'B':\t/* remembered type */\n \tcase 'T':\t/* remembered type */\n \t  abort ();\n \t  break;\n@@ -1360,13 +1394,22 @@ demangle_template_value_parm (work, mangled, s)\n   return success;\n }\n \n+/* Demangle the template name in MANGLED.  The full name of the\n+   template (e.g., S<int>) is placed in TNAME.  The name without the\n+   template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is\n+   non-NULL.  If IS_TYPE is nonzero, this template is a type template,\n+   not a function template.  If both IS_TYPE and REMEMBER are nonzero,\n+   the tmeplate is remembered in the list of back-referenceable\n+   types.  */\n+\n static int\n-demangle_template (work, mangled, tname, trawname, is_type)\n+demangle_template (work, mangled, tname, trawname, is_type, remember)\n      struct work_stuff *work;\n      const char **mangled;\n      string *tname;\n      string *trawname;\n      int is_type;\n+     int remember;\n {\n   int i;\n   int r;\n@@ -1375,10 +1418,13 @@ demangle_template (work, mangled, tname, trawname, is_type)\n   const char *start;\n   int is_java_array = 0;\n   string temp;\n+  int bindex;\n \n   (*mangled)++;\n   if (is_type)\n     {\n+      if (remember)\n+\tbindex = register_Btype (work);\n       start = *mangled;\n       /* get template name */\n       if (**mangled == 'z')\n@@ -1391,9 +1437,8 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t  if (idx == -1 \n \t      || (work->tmpl_argvec && idx >= work->ntmpl_args)\n \t      || consume_count_with_underscores (mangled) == -1)\n-\t    {\n-\t      return (0);\n-\t    }\n+\t    return (0);\n+\n \t  if (work->tmpl_argvec)\n \t    {\n \t      string_append (tname, work->tmpl_argvec[idx]);\n@@ -1406,7 +1451,7 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t      sprintf(buf, \"T%d\", idx);\n \t      string_append (tname, buf);\n \t      if (trawname)\n-\t\tstring_append (trawname, work->tmpl_argvec[idx]);\n+\t\tstring_append (trawname, buf);\n \t    }\n \t}\n       else\n@@ -1415,13 +1460,13 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t    {\n \t      return (0);\n \t    }\n-\t  if (trawname)\n-\t    string_appendn (trawname, *mangled, r);\n \t  is_java_array = (work -> options & DMGL_JAVA)\n \t    && strncmp (*mangled, \"JArray1Z\", 8) == 0;\n \t  if (! is_java_array)\n \t    {\n \t      string_appendn (tname, *mangled, r);\n+\t      if (trawname)\n+\t\tstring_appendn (trawname, *mangled, r);\n \t    }\n \t  *mangled += r;\n \t}\n@@ -1565,6 +1610,9 @@ demangle_template (work, mangled, tname, trawname, is_type)\n       string_append (tname, \">\");\n     }\n   \n+  if (is_type && remember)\n+    remember_Btype (work, tname->b, LEN_STRING (tname), bindex);\n+\n   /*\n     if (work -> static_type)\n     {\n@@ -1722,7 +1770,7 @@ demangle_class (work, mangled, declp)\n \t}\n       remember_Ktype (work, class_name.b, LEN_STRING(&class_name));\n       remember_Btype (work, class_name.b, LEN_STRING(&class_name), btype);\n-      string_prepend (declp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n+      string_prepend (declp, SCOPE_STRING (work));\n       string_prepends (declp, &class_name);\n       success = 1;\n     }\n@@ -1996,7 +2044,8 @@ gnu_special (work, mangled, declp)\n \t      success = demangle_qualified (work, mangled, declp, 0, 1);\n \t      break;\n \t    case 't':\n-\t      success = demangle_template (work, mangled, declp, 0, 1);\n+\t      success = demangle_template (work, mangled, declp, 0, 1,\n+\t\t\t\t\t   1);\n \t      break;\n \t    default:\n \t      if (isdigit(*mangled[0]))\n@@ -2024,8 +2073,7 @@ gnu_special (work, mangled, declp)\n \t    {\n \t      if (p != NULL)\n \t\t{\n-\t\t  string_append (declp,\n-\t\t\t\t (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n+\t\t  string_append (declp, SCOPE_STRING (work));\n \t\t  (*mangled)++;\n \t\t}\n \t    }\n@@ -2051,7 +2099,7 @@ gnu_special (work, mangled, declp)\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n-\t  success = demangle_template (work, mangled, declp, 0, 1);\n+\t  success = demangle_template (work, mangled, declp, 0, 1, 1);\n \t  break;\n \tdefault:\n \t  n = consume_count (mangled);\n@@ -2063,7 +2111,7 @@ gnu_special (work, mangled, declp)\n \t  /* Consumed everything up to the cplus_marker, append the\n \t     variable name.  */\n \t  (*mangled)++;\n-\t  string_append (declp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n+\t  string_append (declp, SCOPE_STRING (work));\n \t  n = strlen (*mangled);\n \t  string_appendn (declp, *mangled, n);\n \t  (*mangled) += n;\n@@ -2104,7 +2152,7 @@ gnu_special (work, mangled, declp)\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n-\t  success = demangle_template (work, mangled, declp, 0, 1);\n+\t  success = demangle_template (work, mangled, declp, 0, 1, 1);\n \t  break;\n \tdefault:\n \t  success = demangle_fund_type (work, mangled, declp);\n@@ -2236,13 +2284,20 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n      int append;\n {\n   int qualifiers = 0;\n-  int namelength;\n   int success = 1;\n   const char *p;\n   char num[2];\n   string temp;\n+  string last_name;\n+  int bindex = register_Btype (work);\n+\n+  /* We only make use of ISFUNCNAME if the entity is a constructor or\n+     destructor.  */\n+  isfuncname = (isfuncname \n+\t\t&& ((work->constructor & 1) || (work->destructor & 1)));\n \n   string_init (&temp);\n+  string_init (&last_name);\n \n   if ((*mangled)[0] == 'K')\n     {\n@@ -2315,18 +2370,24 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n   while (qualifiers-- > 0)\n     {\n       int remember_K = 1;\n+      string_clear (&last_name);\n+\n       if (*mangled[0] == '_') \n-\t*mangled = *mangled + 1;\n+\t(*mangled)++;\n+\n       if (*mangled[0] == 't')\n \t{\n-\t  success = demangle_template(work, mangled, &temp, 0, 1);\n-\t  if (!success) break;\n-\t}\n-      else if (*mangled[0] == 'X')\n-\t{\n-\t  success = do_type (work, mangled, &temp);\n-\t  if (!success) break;\n-\t}\n+\t  /* Here we always append to TEMP since we will want to use\n+\t     the template name without the template parameters as a\n+\t     constructor or destructor name.  The appropriate\n+\t     (parameter-less) value is returned by demangle_template\n+\t     in LAST_NAME.  We do not remember the template type here,\n+\t     in order to match the G++ mangling algorithm.  */\n+\t  success = demangle_template(work, mangled, &temp, \n+\t\t\t\t      &last_name, 1, 0);\n+\t  if (!success) \n+\t    break;\n+\t} \n       else if (*mangled[0] == 'K')\n \t{\n           int idx;\n@@ -2341,60 +2402,48 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \t  if (!success) break;\n \t}\n       else\n-        {\t\n-\t  namelength = consume_count (mangled);\n-      \t  if (strlen (*mangled) < namelength)\n-\t    {\n-\t      /* Simple sanity check failed */\n-\t      success = 0;\n-\t      break;\n-\t    }\n-      \t  string_appendn (&temp, *mangled, namelength);\n-      \t  *mangled += namelength;\n+\t{\n+\t  success = do_type (work, mangled, &last_name);\n+\t  if (!success)\n+\t    break;\n+\t  string_appends (&temp, &last_name);\n \t}\n \n       if (remember_K)\n-        {\n-        remember_Ktype (work, temp.b, LEN_STRING (&temp));\n-        }\n+\tremember_Ktype (work, temp.b, LEN_STRING (&temp));\n \n       if (qualifiers > 0)\n-        {\n-          string_append (&temp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n-        }\n+\tstring_append (&temp, SCOPE_STRING (work));\n     }\n \n+  remember_Btype (work, temp.b, LEN_STRING (&temp), bindex);\n+\n   /* If we are using the result as a function name, we need to append\n      the appropriate '::' separated constructor or destructor name.\n      We do this here because this is the most convenient place, where\n      we already have a pointer to the name and the length of the name.  */\n \n-  if (isfuncname && (work->constructor & 1 || work->destructor & 1))\n+  if (isfuncname) \n     {\n-      string_append (&temp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n+      string_append (&temp, SCOPE_STRING (work));\n       if (work -> destructor & 1)\n-\t{\n-\t  string_append (&temp, \"~\");\n-\t}\n-      string_appendn (&temp, (*mangled) - namelength, namelength);\n+\tstring_append (&temp, \"~\");\n+      string_appends (&temp, &last_name);\n     }\n \n   /* Now either prepend the temp buffer to the result, or append it, \n      depending upon the state of the append flag.  */\n \n   if (append)\n-    {\n-      string_appends (result, &temp);\n-    }\n+    string_appends (result, &temp);\n   else\n     {\n       if (!STRING_EMPTY (result))\n-\t{\n-\t  string_append (&temp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n-\t}\n+\tstring_append (&temp, SCOPE_STRING (work));\n       string_prepends (result, &temp);\n     }\n \n+  string_delete (&last_name);\n   string_delete (&temp);\n   return (success);\n }\n@@ -2542,15 +2591,14 @@ do_type (work, mangled, result)\n \t  /* After picking off the function args, we expect to either find the\n \t     function return type (preceded by an '_') or the end of the\n \t     string.  */\n-\t  if (!demangle_args (work, mangled, &decl)\n+\t  if (!demangle_nested_args (work, mangled, &decl)\n \t      || (**mangled != '_' && **mangled != '\\0'))\n \t    {\n \t      success = 0;\n+\t      break;\n \t    }\n \t  if (success && (**mangled == '_'))\n-\t    {\n-\t      (*mangled)++;\n-\t    }\n+\t    (*mangled)++;\n \t  break;\n \n \tcase 'M':\n@@ -2568,7 +2616,7 @@ do_type (work, mangled, result)\n \t      }\n \n \t    string_append (&decl, \")\");\n-\t    string_prepend (&decl, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n+\t    string_prepend (&decl, SCOPE_STRING (work));\n \t    if (isdigit (**mangled)) \n \t      {\n \t\tn = consume_count (mangled);\n@@ -2584,7 +2632,8 @@ do_type (work, mangled, result)\n \t      {\n \t\tstring temp;\n \t\tstring_init (&temp);\n-\t\tsuccess = demangle_template (work, mangled, &temp, NULL, 1);\n+\t\tsuccess = demangle_template (work, mangled, &temp,\n+\t\t\t\t\t     NULL, 1, 1);\n \t\tif (success)\n \t\t  {\n \t\t    string_prependn (&decl, temp.b, temp.p - temp.b);\n@@ -2612,7 +2661,7 @@ do_type (work, mangled, result)\n \t\t    break;\n \t\t  }\n \t      }\n-\t    if ((member && !demangle_args (work, mangled, &decl))\n+\t    if ((member && !demangle_nested_args (work, mangled, &decl))\n \t\t|| **mangled != '_')\n \t      {\n \t\tsuccess = 0;\n@@ -2673,10 +2722,7 @@ do_type (work, mangled, result)\n     case 'Q':\n     case 'K':\n       {\n-        int btype = register_Btype (work);\n         success = demangle_qualified (work, mangled, result, 0, 1);\n-        remember_Btype (work, result->b, LEN_STRING (result), btype);\n-\n         break;\n       }\n \n@@ -2906,9 +2952,7 @@ demangle_fund_type (work, mangled, result)\n       }\n     case 't':\n       {\n-        int bindex= register_Btype (work);\n-        success = demangle_template (work, mangled, &btype, 0, 1);\n-        remember_Btype (work, btype.b, LEN_STRING (&btype), bindex);\n+        success = demangle_template (work, mangled, &btype, 0, 1, 1);\n         string_appends (result, &btype);\n         break;\n       }\n@@ -2920,25 +2964,77 @@ demangle_fund_type (work, mangled, result)\n   return (success);\n }\n \n-/* `result' will be initialized in do_type; it will be freed on failure */\n+/* Demangle the next argument, given by MANGLED into RESULT, which\n+   *should be an uninitialized* string.  It will be initialized here,\n+   and free'd should anything go wrong.  */\n \n static int\n do_arg (work, mangled, result)\n      struct work_stuff *work;\n      const char **mangled;\n      string *result;\n {\n+  /* Remember where we started so that we can record the type, for\n+     non-squangling type remembering.  */\n   const char *start = *mangled;\n \n-  if (!do_type (work, mangled, result))\n+  string_init (result);\n+\n+  if (work->nrepeats > 0)\n     {\n-      return (0);\n+      --work->nrepeats;\n+\n+      if (work->previous_argument == 0)\n+\treturn 0;\n+\n+      /* We want to reissue the previous type in this argument list.  */ \n+      string_appends (result, work->previous_argument);\n+      return 1;\n+    }\n+\n+  if (**mangled == 'n')\n+    {\n+      /* A squangling-style repeat.  */\n+      (*mangled)++;\n+      work->nrepeats = consume_count(mangled);\n+\n+      if (work->nrepeats == 0)\n+\t/* This was not a repeat count after all.  */\n+\treturn 0;\n+\n+      if (work->nrepeats > 9)\n+\t{\n+\t  if (**mangled != '_')\n+\t    /* The repeat count should be followed by an '_' in this\n+\t       case.  */\n+\t    return 0;\n+\t  else\n+\t    (*mangled)++;\n+\t}\n+      \n+      /* Now, the repeat is all set up.  */\n+      return do_arg (work, mangled, result);\n     }\n+\n+  /* Save the result in WORK->previous_argument so that we can find it\n+     if it's repeated.  Note that saving START is not good enough: we\n+     do not want to add additional types to the back-referenceable\n+     type vector when processing a repeated type.  */\n+  if (work->previous_argument)\n+    string_clear (work->previous_argument);\n   else\n     {\n-      remember_type (work, start, *mangled - start);\n-      return (1);\n+      work->previous_argument = (string*) xmalloc (sizeof (string));\n+      string_init (work->previous_argument);\n     }\n+\n+  if (!do_type (work, mangled, work->previous_argument))\n+    return 0;\n+\n+  string_appends (result, work->previous_argument);\n+\n+  remember_type (work, start, *mangled - start);\n+  return 1;\n }\n \n static void\n@@ -2949,6 +3045,9 @@ remember_type (work, start, len)\n {\n   char *tem;\n \n+  if (work->forgetting_types)\n+    return;\n+\n   if (work -> ntypes >= work -> typevec_size)\n     {\n       if (work -> typevec_size == 0)\n@@ -3160,7 +3259,8 @@ demangle_args (work, mangled, declp)\n \t}\n     }\n \n-  while (**mangled != '_' && **mangled != '\\0' && **mangled != 'e')\n+  while ((**mangled != '_' && **mangled != '\\0' && **mangled != 'e')\n+\t || work->nrepeats > 0)\n     {\n       if ((**mangled == 'N') || (**mangled == 'T'))\n \t{\n@@ -3207,7 +3307,7 @@ demangle_args (work, mangled, declp)\n \t    {\n \t      return (0);\n \t    }\n-\t  while (--r >= 0)\n+\t  while (work->nrepeats > 0 || --r >= 0)\n \t    {\n \t      tem = work -> typevec[t];\n \t      if (need_comma && PRINT_ARG_TYPES)\n@@ -3228,18 +3328,12 @@ demangle_args (work, mangled, declp)\n \t}\n       else\n \t{\n-\t  if (need_comma & PRINT_ARG_TYPES)\n-\t    {\n-\t      string_append (declp, \", \");\n-\t    }\n+\t  if (need_comma && PRINT_ARG_TYPES)\n+\t    string_append (declp, \", \");\n \t  if (!do_arg (work, mangled, &arg))\n-\t    {\n-\t      return (0);\n-\t    }\n+\t    return (0);\n \t  if (PRINT_ARG_TYPES)\n-\t    {\n-\t      string_appends (declp, &arg);\n-\t    }\n+\t    string_appends (declp, &arg);\n \t  string_delete (&arg);\n \t  need_comma = 1;\n \t}\n@@ -3265,6 +3359,42 @@ demangle_args (work, mangled, declp)\n   return (1);\n }\n \n+/* Like demangle_args, but for demangling the argument lists of function\n+   and method pointers or references, not top-level declarations.  */\n+\n+int\n+demangle_nested_args (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  string* saved_previous_argument;\n+  int result;\n+  int saved_nrepeats;\n+\n+  /* The G++ name-mangling algorithm does not remember types on nested\n+     argument lists, unless -fsquangling is used, and in that case the\n+     type vector updated by remember_type is not used.  So, we turn\n+     off remembering of types here.  */\n+  ++work->forgetting_types;\n+\n+  /* For the repeat codes used with -fsquangling, we must keep track of\n+     the last argument.  */\n+  saved_previous_argument = work->previous_argument;\n+  saved_nrepeats = work->nrepeats;\n+  work->previous_argument = 0;\n+  work->nrepeats = 0;\n+\n+  /* Actually demangle the arguments.  */\n+  result = demangle_args (work, mangled, declp);\n+  \n+  /* Restore the previous_argument field.  */\n+  if (work->previous_argument)\n+    string_delete (work->previous_argument);\n+  work->previous_argument = saved_previous_argument;\n+  work->nrepeats = saved_nrepeats;\n+}\n+\n static void\n demangle_function_name (work, mangled, declp, scan)\n      struct work_stuff *work;"}]}