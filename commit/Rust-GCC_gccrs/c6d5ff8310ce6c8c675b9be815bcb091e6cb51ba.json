{"sha": "c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZkNWZmODMxMGNlNmM4YzY3NWI5YmU4MTViY2IwOTFlNmNiNTFiYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-03-20T15:50:27Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-03-20T15:50:27Z"}, "message": "predicates.md (indexed_address, [...]): New predicates.\n\n[gcc]\n2013-03-20  Pat Haugen <pthaugen@us.ibm.com>\n\n\t* config/rs6000/predicates.md (indexed_address, update_address_mem\n\tupdate_indexed_address_mem): New predicates.\n\t* config/rs6000/vsx.md (vsx_extract_<mode>_zero): Set correct \"type\"\n\tattribute for load/store instructions.\n\t* config/rs6000/dfp.md (movsd_store): Likewise.\n\t(movsd_load): Likewise.\n\t* config/rs6000/rs6000.md (zero_extend<mode>di2_internal1): Likewise.\n\t(unnamed HI->DI extend define_insn): Likewise.\n\t(unnamed SI->DI extend define_insn): Likewise.\n\t(unnamed QI->SI extend define_insn): Likewise.\n\t(unnamed QI->HI extend define_insn): Likewise.\n\t(unnamed HI->SI extend define_insn): Likewise.\n\t(unnamed HI->SI extend define_insn): Likewise.\n\t(extendsfdf2_fpr): Likewise.\n\t(movsi_internal1): Likewise.\n\t(movsi_internal1_single): Likewise.\n\t(movhi_internal): Likewise.\n\t(movqi_internal): Likewise.\n\t(movcc_internal1): Correct mnemonic for stw insn. Set correct \"type\"\n\tattribute for load/store instructions.\n\t(mov<mode>_hardfloat): Set correct \"type\" attribute for load/store\n\tinstructions.\n\t(mov<mode>_softfloat): Likewise.\n\t(mov<mode>_hardfloat32): Likewise.\n\t(mov<mode>_hardfloat64): Likewise.\n\t(mov<mode>_softfloat64): Likewise.\n\t(movdi_internal32): Likewise.\n\t(movdi_internal64): Likewise.\n\t(probe_stack_<mode>): Likewise.\n\n2013-03-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/vector.md (VEC_R): Add 32-bit integer, binary\n\tfloating point, and decimal floating point to reload iterator.\n\n\t* config/rs6000/constraints.md (wl constraint): New constraints to\n\treturn FLOAT_REGS if certain options are used to reduce the number\n\tof separate patterns that exist in the file.\n\t(wx constraint): Likewise.\n\t(wz constraint): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): If\n\t-mdebug=reg, print wg, wl, wx, and wz constraints.\n\t(rs6000_init_hard_regno_mode_ok): Initialize new constraints.\n\tInitialize the reload functions for 64-bit binary/decimal floating\n\tpoint types.\n\t(reg_offset_addressing_ok_p): If we are on a power7 or later, use\n\tLFIWZX and STFIWX to load/store 32-bit decimal types, and don't\n\tcreate the buffer on the stack to overcome not having a 32-bit\n\tload and store.\n\t(rs6000_emit_move): Likewise.\n\t(rs6000_secondary_memory_needed_rtx): Likewise.\n\t(rs6000_alloc_sdmode_stack_slot): Likewise.\n\t(rs6000_preferred_reload_class): On VSX, we can create SFmode 0.0f\n\tvia xxlxor, just like DFmode 0.0.\n\n\t* config/rs6000/rs6000.h (TARGET_NO_SDMODE_STACK): New macro,\n\tdefine as 1 if we are running on a power7 or newer.\n\t(enum r6000_reg_class_enum): Add new constraints.\n\n\t* config/rs6000/dfp.md (movsd): Delete, combine with binary\n\tfloating point moves in rs6000.md.  Combine power6x (mfpgpr) moves\n\twith other moves by using conditional constraits (wg).  Use LFIWZX\n\tand STFIWX for loading SDmode on power7.  Use xxlxor to create\n\t0.0f.\n\t(movsd splitter): Likewise.\n\t(movsd_hardfloat): Likewise.\n\t(movsd_softfloat): Likewise.\n\n\t* config/rs6000/rs6000.md (FMOVE32): New iterators to combine\n\tbinary and decimal floating point moves.\n\t(fmove_ok): New attributes to combine binary and decimal floating\n\tpoint moves, and to combine power6x (mfpgpr) moves along normal\n\tfloating moves.\n\t(real_value_to_target): Likewise.\n\t(f32_lr): Likewise.\n\t(f32_lm): Likewise.\n\t(f32_li): Likewise.\n\t(f32_sr): Likewise.\n\t(f32_sm): Likewise.\n\t(f32_si): Likewise.\n\t(movsf): Combine binary and decimal floating point moves.  Combine\n\tpower6x (mfpgpr) moves with other moves by using conditional\n\tconstraits (wg).  Use LFIWZX and STFIWX for loading SDmode on\n\tpower7.\n\t(mov<mode> for SFmode/SDmode); Likewise.\n\t(SFmode/SDmode splitters): Likewise.\n\t(movsf_hardfloat): Likewise.\n\t(mov<mode>_hardfloat for SFmode/SDmode): Likewise.\n\t(movsf_softfloat): Likewise.\n\t(mov<mode>_softfloat for SFmode/SDmode): Likewise.\n\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wl,\n\twx and wz constraints.\n\n\t* config/rs6000/constraints.md (wg constraint): New constraint to\n\treturn FLOAT_REGS if -mmfpgpr (power6x) was used.\n\n\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add wg\n\tconstraint.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): If\n\t-mdebug=reg, print wg, wl, wx, and wz constraints.\n\t(rs6000_init_hard_regno_mode_ok): Initialize new constraints.\n\tInitialize the reload functions for 64-bit binary/decimal floating\n\tpoint types.\n\t(reg_offset_addressing_ok_p): If we are on a power7 or later, use\n\tLFIWZX and STFIWX to load/store 32-bit decimal types, and don't\n\tcreate the buffer on the stack to overcome not having a 32-bit\n\tload and store.\n\t(rs6000_emit_move): Likewise.\n\t(rs6000_secondary_memory_needed_rtx): Likewise.\n\t(rs6000_alloc_sdmode_stack_slot): Likewise.\n\t(rs6000_preferred_reload_class): On VSX, we can create SFmode 0.0f\n\tvia xxlxor, just like DFmode 0.0.\n\n\n\t* config/rs6000/dfp.md (movdd): Delete, combine with binary\n\tfloating point moves in rs6000.md.  Combine power6x (mfpgpr) moves\n\twith other moves by using conditional constraits (wg).  Use LFIWZX\n\tand STFIWX for loading SDmode on power7.\n\t(movdd splitters): Likewise.\n\t(movdd_hardfloat32): Likewise.\n\t(movdd_softfloat32): Likewise.\n\t(movdd_hardfloat64_mfpgpr): Likewise.\n\t(movdd_hardfloat64): Likewise.\n\t(movdd_softfloat64): Likewise.\n\n\t* config/rs6000/rs6000.md (FMOVE64): New iterators to combine\n\t64-bit binary and decimal floating point moves.\n\t(FMOVE64X): Likewise.\n\t(movdf): Combine 64-bit binary and decimal floating point moves.\n\tCombine power6x (mfpgpr) moves with other moves by using\n\tconditional constraits (wg).\n\t(mov<mode> for DFmode/DDmode): Likewise.\n\t(DFmode/DDmode splitters): Likewise.\n\t(movdf_hardfloat32): Likewise.\n\t(mov<mode>_hardfloat32 for DFmode/DDmode): Likewise.\n\t(movdf_softfloat32): Likewise.\n\t(movdf_hardfloat64_mfpgpr): Likewise.\n\t(movdf_hardfloat64): Likewise.\n\t(mov<mode>_hardfloat64 for DFmode/DDmode): Likewise.\n\t(movdf_softfloat64): Likewise.\n\t(mov<mode>_softfloat64 for DFmode/DDmode): Likewise.\n\t(reload_<mode>_load): Move to later in the file so they aren't in\n\tthe middle of the floating point move insns.\n\t(reload_<mode>_store): Likewise.\n\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wg\n\tconstraint.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print out wg\n\tconstraint if -mdebug=reg.\n\t(rs6000_initi_hard_regno_mode_ok): Enable wg constraint if\n\t-mfpgpr.  Enable using dd reload support if needed.\n\n\t* config/rs6000/dfp.md (movtd): Delete, combine with 128-bit\n\tbinary and decimal floating point moves in rs6000.md.\n\t(movtd_internal): Likewise.\n\n\t* config/rs6000/rs6000.md (FMOVE128): Combine 128-bit binary and\n\tdecimal floating point moves.\n\t(movtf): Likewise.\n\t(movtf_internal): Likewise.\n\t(mov<mode>_internal, TDmode/TFmode): Likewise.\n\t(movtf_softfloat): Likewise.\n\t(mov<mode>_softfloat, TDmode/TFmode): Likewise.\n\n\t* config/rs6000/rs6000.md (movdi_mfpgpr): Delete, combine with\n\tmovdi_internal64, using wg constraint for move direct operations.\n\t(movdi_internal64): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print\n\tMODES_TIEABLE_P for selected modes.  Print the numerical value of\n\tthe various virtual registers. Use GPR/FPR first/last values,\n\tinstead of hard coding the register numbers.  Print which modes\n\thave reload functions registered.\n\t(rs6000_option_override_internal): If -mdebug=reg, trace the\n\toptions settings before/after setting cpu, target and subtarget\n\tsettings.\n\t(rs6000_secondary_reload_trace): Improve the RTL dump for\n\t-mdebug=addr and for secondary reload failures in\n\trs6000_secondary_reload_inner.\n\t(rs6000_secondary_reload_fail): Likewise.\n\t(rs6000_secondary_reload_inner): Likewise.\n\n\t* config/rs6000/rs6000.md (FIRST_GPR_REGNO): Add convenience\n\tmacros for first/last GPR and FPR registers.\n\t(LAST_GPR_REGNO): Likewise.\n\t(FIRST_FPR_REGNO): Likewise.\n\t(LAST_FPR_REGNO): Likewise.\n\n\t* config/rs6000/vector.md (mul<mode>3): Use the combined macro\n\tVECTOR_UNIT_ALTIVEC_OR_VSX_P instead of separate calls to\n\tVECTOR_UNIT_ALTIVEC_P and VECTOR_UNIT_VSX_P.\n\t(vcond<mode><mode>): Likewise.\n\t(vcondu<mode><mode>): Likewise.\n\t(vector_gtu<mode>): Likewise.\n\t(vector_gte<mode>): Likewise.\n\t(xor<mode>3): Don't allow logical operations on TImode in 32-bit\n\tto prevent the compiler from converting DImode operations to\n\tTImode.\n\t(ior<mode>3): Likewise.\n\t(and<mode>3): Likewise.\n\t(one_cmpl<mode>2): Likewise.\n\t(nor<mode>3): Likewise.\n\t(andc<mode>3): Likewise.\n\n\t* config/rs6000/constraints.md (wt constraint): New constraint\n\tthat returns VSX_REGS if TImode is allowed in VSX registers.\n\n\t* config/rs6000/predicates.md (easy_fp_constant): 0.0f is an easy\n\tconstant under VSX.\n\n\t* config/rs6000/rs6000-modes.def (PTImode): Define, PTImode is\n\tsimilar to TImode, but it is restricted to being in the GPRs.\n\n\t* config/rs6000/rs6000.opt (-mvsx-timode): New switch to allow\n\tTImode to occupy a single VSX register.\n\n\t* config/rs6000/rs6000-cpus.def (ISA_2_6_MASKS_SERVER): Default to\n\t-mvsx-timode for power7/power8.\n\t(power7 cpu): Likewise.\n\t(power8 cpu): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Make\n\tsure that TFmode/TDmode take up two registers if they are ever\n\tallowed in the upper VSX registers.\n\t(rs6000_hard_regno_mode_ok): If -mvsx-timode, allow TImode in VSX\n\tregisters.\n\t(rs6000_init_hard_regno_mode_ok): Likewise.\n\t(rs6000_debug_reg_global): Add debugging for PTImode and wt\n\tconstraint.  Print if LRA is turned on.\n\t(rs6000_option_override_internal): Give an error if -mvsx-timode\n\tand VSX is not enabled.\n\t(invalid_e500_subreg): Handle PTImode, restricting it to GPRs.  If\n\t-mvsx-timode, restrict TImode to reg+reg addressing, and PTImode\n\tto reg+offset addressing.  Use PTImode when checking offset\n\taddresses for validity.\n\t(reg_offset_addressing_ok_p): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_legitimize_reload_address): Likewise.\n\t(rs6000_legitimate_address_p): Likewise.\n\t(rs6000_eliminate_indexed_memrefs): Likewise.\n\t(rs6000_emit_move): Likewise.\n\t(rs6000_secondary_reload): Likewise.\n\t(rs6000_secondary_reload_inner): Handle PTImode.  Allow 64-bit\n\treloads to fpr registers to continue to use reg+offset addressing,\n\tbut 64-bit reloads to altivec registers need reg+reg addressing.\n\tDrop test for PRE_MODIFY, since VSX loads/stores no longer support\n\tit.  Treat LO_SUM like a PLUS operation.\n\t(rs6000_secondary_reload_class): If type is 64-bit, prefer to use\n\tFLOAT_REGS instead of VSX_RGS to allow use of reg+offset\n\taddressing.\n\t(rs6000_cannot_change_mode_class): Do not allow TImode in VSX\n\tregisters to share a register with a smaller sized type, since VSX\n\tputs scalars in the upper 64-bits.\n\t(print_operand): Add support for PTImode.\n\t(rs6000_register_move_cost): Use VECTOR_MEM_VSX_P instead of\n\tVECTOR_UNIT_VSX_P to catch types that can be loaded in VSX\n\tregisters, but don't have arithmetic support.\n\t(rs6000_memory_move_cost): Add test for VSX.\n\t(rs6000_opt_masks): Add -mvsx-timode.\n\n\t* config/rs6000/vsx.md (VSm): Change to use 64-bit aligned moves\n\tfor TImode.\n\t(VSs): Likewise.\n\t(VSr): Use wt constraint for TImode.\n\t(VSv): Drop TImode support.\n\t(vsx_movti): Delete, replace with versions for 32-bit and 64-bit.\n\t(vsx_movti_64bit): Likewise.\n\t(vsx_movti_32bit): Likewise.\n\t(vec_store_<mode>): Use VSX iterator instead of vector iterator.\n\t(vsx_and<mode>3): Delete use of '?' constraint on inputs, just put\n\tone '?' on the appropriate output constraint.  Do not allow TImode\n\tlogical operations on 32-bit systems.\n\t(vsx_ior<mode>3): Likewise.\n\t(vsx_xor<mode>3): Likewise.\n\t(vsx_one_cmpl<mode>2): Likewise.\n\t(vsx_nor<mode>3): Likewise.\n\t(vsx_andc<mode>3): Likewise.\n\t(vsx_concat_<mode>): Likewise.\n\t(vsx_xxpermdi_<mode>): Fix thinko for non V2DF/V2DI modes.\n\n\t* config/rs6000/rs6000.h (MASK_VSX_TIMODE): Map from\n\tOPTION_MASK_VSX_TIMODE.\n\t(enum rs6000_reg_class_enum): Add RS6000_CONSTRAINT_wt.\n\t(STACK_SAVEAREA_MODE): Use PTImode instead of TImode.\n\n\t* config/rs6000/rs6000.md (INT mode attribute): Add PTImode.\n\t(TI2 iterator): New iterator for TImode, PTImode.\n\t(wd mode attribute): Add values for vector types.\n\t(movti_string): Replace TI move operations with operations for\n\tTImode and PTImode.  Add support for TImode being allowed in VSX\n\tregisters.\n\t(mov<mode>_string, TImode/PTImode): Likewise.\n\t(movti_ppc64): Likewise.\n\t(mov<mode>_ppc64, TImode/PTImode): Likewise.\n\t(TI mode splitters): Likewise.\n\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wt\n\tconstraint.\n\n[gcc/testsuite]\n2013-03-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/mmfpgpr.c: New test.\n\t* gcc.target/powerpc/sd-vsx.c: Likewise.\n\t* gcc.target/powerpc/sd-pwr6.c: Likewise.\n\t* gcc.target/powerpc/vsx-float0.c: Likewise.\n\nFrom-SVN: r196831", "tree": {"sha": "7ddc5f969143226c5041ddec506b0119effbfb42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ddc5f969143226c5041ddec506b0119effbfb42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/comments", "author": null, "committer": null, "parents": [{"sha": "1fc5eced1bd73eef1975f803279b799f4b47c879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc5eced1bd73eef1975f803279b799f4b47c879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc5eced1bd73eef1975f803279b799f4b47c879"}], "stats": {"total": 2304, "additions": 1655, "deletions": 649}, "files": [{"sha": "1cc25b054b1eaae0f41830abe96c4e2eb257baff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -1,3 +1,309 @@\n+2013-03-20  Pat Haugen <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/predicates.md (indexed_address, update_address_mem\n+\tupdate_indexed_address_mem): New predicates.\n+\t* config/rs6000/vsx.md (vsx_extract_<mode>_zero): Set correct \"type\"\n+\tattribute for load/store instructions.\n+\t* config/rs6000/dfp.md (movsd_store): Likewise.\n+\t(movsd_load): Likewise.\n+\t* config/rs6000/rs6000.md (zero_extend<mode>di2_internal1): Likewise.\n+\t(unnamed HI->DI extend define_insn): Likewise.\n+\t(unnamed SI->DI extend define_insn): Likewise.\n+\t(unnamed QI->SI extend define_insn): Likewise.\n+\t(unnamed QI->HI extend define_insn): Likewise.\n+\t(unnamed HI->SI extend define_insn): Likewise.\n+\t(unnamed HI->SI extend define_insn): Likewise.\n+\t(extendsfdf2_fpr): Likewise.\n+\t(movsi_internal1): Likewise.\n+\t(movsi_internal1_single): Likewise.\n+\t(movhi_internal): Likewise.\n+\t(movqi_internal): Likewise.\n+\t(movcc_internal1): Correct mnemonic for stw insn. Set correct \"type\"\n+\tattribute for load/store instructions.\n+\t(mov<mode>_hardfloat): Set correct \"type\" attribute for load/store\n+\tinstructions.\n+\t(mov<mode>_softfloat): Likewise.\n+\t(mov<mode>_hardfloat32): Likewise.\n+\t(mov<mode>_hardfloat64): Likewise.\n+\t(mov<mode>_softfloat64): Likewise.\n+\t(movdi_internal32): Likewise.\n+\t(movdi_internal64): Likewise.\n+\t(probe_stack_<mode>): Likewise.\n+\n+2013-03-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/vector.md (VEC_R): Add 32-bit integer, binary\n+\tfloating point, and decimal floating point to reload iterator.\n+\n+\t* config/rs6000/constraints.md (wl constraint): New constraints to\n+\treturn FLOAT_REGS if certain options are used to reduce the number\n+\tof separate patterns that exist in the file.\n+\t(wx constraint): Likewise.\n+\t(wz constraint): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): If\n+\t-mdebug=reg, print wg, wl, wx, and wz constraints.\n+\t(rs6000_init_hard_regno_mode_ok): Initialize new constraints.\n+\tInitialize the reload functions for 64-bit binary/decimal floating\n+\tpoint types.\n+\t(reg_offset_addressing_ok_p): If we are on a power7 or later, use\n+\tLFIWZX and STFIWX to load/store 32-bit decimal types, and don't\n+\tcreate the buffer on the stack to overcome not having a 32-bit\n+\tload and store.\n+\t(rs6000_emit_move): Likewise.\n+\t(rs6000_secondary_memory_needed_rtx): Likewise.\n+\t(rs6000_alloc_sdmode_stack_slot): Likewise.\n+\t(rs6000_preferred_reload_class): On VSX, we can create SFmode 0.0f\n+\tvia xxlxor, just like DFmode 0.0.\n+\n+\t* config/rs6000/rs6000.h (TARGET_NO_SDMODE_STACK): New macro,\n+\tdefine as 1 if we are running on a power7 or newer.\n+\t(enum r6000_reg_class_enum): Add new constraints.\n+\n+\t* config/rs6000/dfp.md (movsd): Delete, combine with binary\n+\tfloating point moves in rs6000.md.  Combine power6x (mfpgpr) moves\n+\twith other moves by using conditional constraits (wg).  Use LFIWZX\n+\tand STFIWX for loading SDmode on power7.  Use xxlxor to create\n+\t0.0f.\n+\t(movsd splitter): Likewise.\n+\t(movsd_hardfloat): Likewise.\n+\t(movsd_softfloat): Likewise.\n+\n+\t* config/rs6000/rs6000.md (FMOVE32): New iterators to combine\n+\tbinary and decimal floating point moves.\n+\t(fmove_ok): New attributes to combine binary and decimal floating\n+\tpoint moves, and to combine power6x (mfpgpr) moves along normal\n+\tfloating moves.\n+\t(real_value_to_target): Likewise.\n+\t(f32_lr): Likewise.\n+\t(f32_lm): Likewise.\n+\t(f32_li): Likewise.\n+\t(f32_sr): Likewise.\n+\t(f32_sm): Likewise.\n+\t(f32_si): Likewise.\n+\t(movsf): Combine binary and decimal floating point moves.  Combine\n+\tpower6x (mfpgpr) moves with other moves by using conditional\n+\tconstraits (wg).  Use LFIWZX and STFIWX for loading SDmode on\n+\tpower7.\n+\t(mov<mode> for SFmode/SDmode); Likewise.\n+\t(SFmode/SDmode splitters): Likewise.\n+\t(movsf_hardfloat): Likewise.\n+\t(mov<mode>_hardfloat for SFmode/SDmode): Likewise.\n+\t(movsf_softfloat): Likewise.\n+\t(mov<mode>_softfloat for SFmode/SDmode): Likewise.\n+\n+\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wl,\n+\twx and wz constraints.\n+\n+\t* config/rs6000/constraints.md (wg constraint): New constraint to\n+\treturn FLOAT_REGS if -mmfpgpr (power6x) was used.\n+\n+\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add wg\n+\tconstraint.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): If\n+\t-mdebug=reg, print wg, wl, wx, and wz constraints.\n+\t(rs6000_init_hard_regno_mode_ok): Initialize new constraints.\n+\tInitialize the reload functions for 64-bit binary/decimal floating\n+\tpoint types.\n+\t(reg_offset_addressing_ok_p): If we are on a power7 or later, use\n+\tLFIWZX and STFIWX to load/store 32-bit decimal types, and don't\n+\tcreate the buffer on the stack to overcome not having a 32-bit\n+\tload and store.\n+\t(rs6000_emit_move): Likewise.\n+\t(rs6000_secondary_memory_needed_rtx): Likewise.\n+\t(rs6000_alloc_sdmode_stack_slot): Likewise.\n+\t(rs6000_preferred_reload_class): On VSX, we can create SFmode 0.0f\n+\tvia xxlxor, just like DFmode 0.0.\n+\n+\n+\t* config/rs6000/dfp.md (movdd): Delete, combine with binary\n+\tfloating point moves in rs6000.md.  Combine power6x (mfpgpr) moves\n+\twith other moves by using conditional constraits (wg).  Use LFIWZX\n+\tand STFIWX for loading SDmode on power7.\n+\t(movdd splitters): Likewise.\n+\t(movdd_hardfloat32): Likewise.\n+\t(movdd_softfloat32): Likewise.\n+\t(movdd_hardfloat64_mfpgpr): Likewise.\n+\t(movdd_hardfloat64): Likewise.\n+\t(movdd_softfloat64): Likewise.\n+\n+\t* config/rs6000/rs6000.md (FMOVE64): New iterators to combine\n+\t64-bit binary and decimal floating point moves.\n+\t(FMOVE64X): Likewise.\n+\t(movdf): Combine 64-bit binary and decimal floating point moves.\n+\tCombine power6x (mfpgpr) moves with other moves by using\n+\tconditional constraits (wg).\n+\t(mov<mode> for DFmode/DDmode): Likewise.\n+\t(DFmode/DDmode splitters): Likewise.\n+\t(movdf_hardfloat32): Likewise.\n+\t(mov<mode>_hardfloat32 for DFmode/DDmode): Likewise.\n+\t(movdf_softfloat32): Likewise.\n+\t(movdf_hardfloat64_mfpgpr): Likewise.\n+\t(movdf_hardfloat64): Likewise.\n+\t(mov<mode>_hardfloat64 for DFmode/DDmode): Likewise.\n+\t(movdf_softfloat64): Likewise.\n+\t(mov<mode>_softfloat64 for DFmode/DDmode): Likewise.\n+\t(reload_<mode>_load): Move to later in the file so they aren't in\n+\tthe middle of the floating point move insns.\n+\t(reload_<mode>_store): Likewise.\n+\n+\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wg\n+\tconstraint.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print out wg\n+\tconstraint if -mdebug=reg.\n+\t(rs6000_initi_hard_regno_mode_ok): Enable wg constraint if\n+\t-mfpgpr.  Enable using dd reload support if needed.\n+\n+\t* config/rs6000/dfp.md (movtd): Delete, combine with 128-bit\n+\tbinary and decimal floating point moves in rs6000.md.\n+\t(movtd_internal): Likewise.\n+\n+\t* config/rs6000/rs6000.md (FMOVE128): Combine 128-bit binary and\n+\tdecimal floating point moves.\n+\t(movtf): Likewise.\n+\t(movtf_internal): Likewise.\n+\t(mov<mode>_internal, TDmode/TFmode): Likewise.\n+\t(movtf_softfloat): Likewise.\n+\t(mov<mode>_softfloat, TDmode/TFmode): Likewise.\n+\n+\t* config/rs6000/rs6000.md (movdi_mfpgpr): Delete, combine with\n+\tmovdi_internal64, using wg constraint for move direct operations.\n+\t(movdi_internal64): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print\n+\tMODES_TIEABLE_P for selected modes.  Print the numerical value of\n+\tthe various virtual registers. Use GPR/FPR first/last values,\n+\tinstead of hard coding the register numbers.  Print which modes\n+\thave reload functions registered.\n+\t(rs6000_option_override_internal): If -mdebug=reg, trace the\n+\toptions settings before/after setting cpu, target and subtarget\n+\tsettings.\n+\t(rs6000_secondary_reload_trace): Improve the RTL dump for\n+\t-mdebug=addr and for secondary reload failures in\n+\trs6000_secondary_reload_inner.\n+\t(rs6000_secondary_reload_fail): Likewise.\n+\t(rs6000_secondary_reload_inner): Likewise.\n+\n+\t* config/rs6000/rs6000.md (FIRST_GPR_REGNO): Add convenience\n+\tmacros for first/last GPR and FPR registers.\n+\t(LAST_GPR_REGNO): Likewise.\n+\t(FIRST_FPR_REGNO): Likewise.\n+\t(LAST_FPR_REGNO): Likewise.\n+\n+\t* config/rs6000/vector.md (mul<mode>3): Use the combined macro\n+\tVECTOR_UNIT_ALTIVEC_OR_VSX_P instead of separate calls to\n+\tVECTOR_UNIT_ALTIVEC_P and VECTOR_UNIT_VSX_P.\n+\t(vcond<mode><mode>): Likewise.\n+\t(vcondu<mode><mode>): Likewise.\n+\t(vector_gtu<mode>): Likewise.\n+\t(vector_gte<mode>): Likewise.\n+\t(xor<mode>3): Don't allow logical operations on TImode in 32-bit\n+\tto prevent the compiler from converting DImode operations to\n+\tTImode.\n+\t(ior<mode>3): Likewise.\n+\t(and<mode>3): Likewise.\n+\t(one_cmpl<mode>2): Likewise.\n+\t(nor<mode>3): Likewise.\n+\t(andc<mode>3): Likewise.\n+\n+\t* config/rs6000/constraints.md (wt constraint): New constraint\n+\tthat returns VSX_REGS if TImode is allowed in VSX registers.\n+\n+\t* config/rs6000/predicates.md (easy_fp_constant): 0.0f is an easy\n+\tconstant under VSX.\n+\n+\t* config/rs6000/rs6000-modes.def (PTImode): Define, PTImode is\n+\tsimilar to TImode, but it is restricted to being in the GPRs.\n+\n+\t* config/rs6000/rs6000.opt (-mvsx-timode): New switch to allow\n+\tTImode to occupy a single VSX register.\n+\n+\t* config/rs6000/rs6000-cpus.def (ISA_2_6_MASKS_SERVER): Default to\n+\t-mvsx-timode for power7/power8.\n+\t(power7 cpu): Likewise.\n+\t(power8 cpu): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Make\n+\tsure that TFmode/TDmode take up two registers if they are ever\n+\tallowed in the upper VSX registers.\n+\t(rs6000_hard_regno_mode_ok): If -mvsx-timode, allow TImode in VSX\n+\tregisters.\n+\t(rs6000_init_hard_regno_mode_ok): Likewise.\n+\t(rs6000_debug_reg_global): Add debugging for PTImode and wt\n+\tconstraint.  Print if LRA is turned on.\n+\t(rs6000_option_override_internal): Give an error if -mvsx-timode\n+\tand VSX is not enabled.\n+\t(invalid_e500_subreg): Handle PTImode, restricting it to GPRs.  If\n+\t-mvsx-timode, restrict TImode to reg+reg addressing, and PTImode\n+\tto reg+offset addressing.  Use PTImode when checking offset\n+\taddresses for validity.\n+\t(reg_offset_addressing_ok_p): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_legitimize_reload_address): Likewise.\n+\t(rs6000_legitimate_address_p): Likewise.\n+\t(rs6000_eliminate_indexed_memrefs): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t(rs6000_secondary_reload): Likewise.\n+\t(rs6000_secondary_reload_inner): Handle PTImode.  Allow 64-bit\n+\treloads to fpr registers to continue to use reg+offset addressing,\n+\tbut 64-bit reloads to altivec registers need reg+reg addressing.\n+\tDrop test for PRE_MODIFY, since VSX loads/stores no longer support\n+\tit.  Treat LO_SUM like a PLUS operation.\n+\t(rs6000_secondary_reload_class): If type is 64-bit, prefer to use\n+\tFLOAT_REGS instead of VSX_RGS to allow use of reg+offset\n+\taddressing.\n+\t(rs6000_cannot_change_mode_class): Do not allow TImode in VSX\n+\tregisters to share a register with a smaller sized type, since VSX\n+\tputs scalars in the upper 64-bits.\n+\t(print_operand): Add support for PTImode.\n+\t(rs6000_register_move_cost): Use VECTOR_MEM_VSX_P instead of\n+\tVECTOR_UNIT_VSX_P to catch types that can be loaded in VSX\n+\tregisters, but don't have arithmetic support.\n+\t(rs6000_memory_move_cost): Add test for VSX.\n+\t(rs6000_opt_masks): Add -mvsx-timode.\n+\n+\t* config/rs6000/vsx.md (VSm): Change to use 64-bit aligned moves\n+\tfor TImode.\n+\t(VSs): Likewise.\n+\t(VSr): Use wt constraint for TImode.\n+\t(VSv): Drop TImode support.\n+\t(vsx_movti): Delete, replace with versions for 32-bit and 64-bit.\n+\t(vsx_movti_64bit): Likewise.\n+\t(vsx_movti_32bit): Likewise.\n+\t(vec_store_<mode>): Use VSX iterator instead of vector iterator.\n+\t(vsx_and<mode>3): Delete use of '?' constraint on inputs, just put\n+\tone '?' on the appropriate output constraint.  Do not allow TImode\n+\tlogical operations on 32-bit systems.\n+\t(vsx_ior<mode>3): Likewise.\n+\t(vsx_xor<mode>3): Likewise.\n+\t(vsx_one_cmpl<mode>2): Likewise.\n+\t(vsx_nor<mode>3): Likewise.\n+\t(vsx_andc<mode>3): Likewise.\n+\t(vsx_concat_<mode>): Likewise.\n+\t(vsx_xxpermdi_<mode>): Fix thinko for non V2DF/V2DI modes.\n+\n+\t* config/rs6000/rs6000.h (MASK_VSX_TIMODE): Map from\n+\tOPTION_MASK_VSX_TIMODE.\n+\t(enum rs6000_reg_class_enum): Add RS6000_CONSTRAINT_wt.\n+\t(STACK_SAVEAREA_MODE): Use PTImode instead of TImode.\n+\n+\t* config/rs6000/rs6000.md (INT mode attribute): Add PTImode.\n+\t(TI2 iterator): New iterator for TImode, PTImode.\n+\t(wd mode attribute): Add values for vector types.\n+\t(movti_string): Replace TI move operations with operations for\n+\tTImode and PTImode.  Add support for TImode being allowed in VSX\n+\tregisters.\n+\t(mov<mode>_string, TImode/PTImode): Likewise.\n+\t(movti_ppc64): Likewise.\n+\t(mov<mode>_ppc64, TImode/PTImode): Likewise.\n+\t(TI mode splitters): Likewise.\n+\n+\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wt\n+\tconstraint.\n+\n 2013-03-20  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/56355"}, {"sha": "463d69c6ba4647ffd071e650aa0bec8d3b09456a", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -64,10 +64,27 @@\n (define_register_constraint \"ws\" \"rs6000_constraints[RS6000_CONSTRAINT_ws]\"\n   \"@internal\")\n \n+;; TImode in VSX registers\n+(define_register_constraint \"wt\" \"rs6000_constraints[RS6000_CONSTRAINT_wt]\"\n+  \"@internal\")\n+\n ;; any VSX register\n (define_register_constraint \"wa\" \"rs6000_constraints[RS6000_CONSTRAINT_wa]\"\n   \"@internal\")\n \n+;; Register constraints to simplify move patterns\n+(define_register_constraint \"wg\" \"rs6000_constraints[RS6000_CONSTRAINT_wg]\"\n+  \"Floating point register if -mmfpgpr is used, or NO_REGS.\")\n+\n+(define_register_constraint \"wl\" \"rs6000_constraints[RS6000_CONSTRAINT_wl]\"\n+  \"Floating point register if the LFIWAX instruction is enabled or NO_REGS.\")\n+\n+(define_register_constraint \"wx\" \"rs6000_constraints[RS6000_CONSTRAINT_wx]\"\n+  \"Floating point register if the STFIWX instruction is enabled or NO_REGS.\")\n+\n+(define_register_constraint \"wz\" \"rs6000_constraints[RS6000_CONSTRAINT_wz]\"\n+  \"Floating point register if the LFIWZX instruction is enabled or NO_REGS.\")\n+\n ;; Altivec style load/store that ignores the bottom bits of the address\n (define_memory_constraint \"wZ\"\n   \"Indexed or indirect memory operand, ignoring the bottom 4 bits\""}, {"sha": "052ac482e0f487b21c0f89df430e3672cefac84a", "filename": "gcc/config/rs6000/dfp.md", "status": "modified", "additions": 16, "deletions": 299, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -29,77 +29,6 @@\n   ])\n \n \n-(define_expand \"movsd\"\n-  [(set (match_operand:SD 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SD 1 \"any_operand\" \"\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], SDmode); DONE; }\")\n-\n-(define_split\n-  [(set (match_operand:SD 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:SD 1 \"const_double_operand\" \"\"))]\n-  \"reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 3))]\n-  \"\n-{\n-  long l;\n-  REAL_VALUE_TYPE rv;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_DECIMAL32 (rv, l);\n-\n-  if (! TARGET_POWERPC64)\n-    operands[2] = operand_subword (operands[0], 0, 0, SDmode);\n-  else\n-    operands[2] = gen_lowpart (SImode, operands[0]);\n-\n-  operands[3] = gen_int_mode (l, SImode);\n-}\")\n-\n-(define_insn \"movsd_hardfloat\"\n-  [(set (match_operand:SD 0 \"nonimmediate_operand\" \"=r,r,m,f,*c*l,!r,*h,!r,!r\")\n-\t(match_operand:SD 1 \"input_operand\"        \"r,m,r,f,r,h,0,G,Fn\"))]\n-  \"(gpc_reg_operand (operands[0], SDmode)\n-   || gpc_reg_operand (operands[1], SDmode))\n-   && (TARGET_HARD_FLOAT && TARGET_FPRS)\"\n-  \"@\n-   mr %0,%1\n-   lwz%U1%X1 %0,%1\n-   stw%U0%X0 %1,%0\n-   fmr %0,%1\n-   mt%0 %1\n-   mf%1 %0\n-   nop\n-   #\n-   #\"\n-  [(set_attr \"type\" \"*,load,store,fp,mtjmpr,mfjmpr,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,8\")])\n-\n-(define_insn \"movsd_softfloat\"\n-  [(set (match_operand:SD 0 \"nonimmediate_operand\" \"=r,cl,r,r,m,r,r,r,r,r,*h\")\n-\t(match_operand:SD 1 \"input_operand\" \"r,r,h,m,r,I,L,R,G,Fn,0\"))]\n-  \"(gpc_reg_operand (operands[0], SDmode)\n-   || gpc_reg_operand (operands[1], SDmode))\n-   && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\"\n-  \"@\n-   mr %0,%1\n-   mt%0 %1\n-   mf%1 %0\n-   lwz%U1%X1 %0,%1\n-   stw%U0%X0 %1,%0\n-   li %0,%1\n-   lis %0,%v1\n-   la %0,%a1\n-   #\n-   #\n-   nop\"\n-  [(set_attr \"type\" \"*,mtjmpr,mfjmpr,load,store,*,*,*,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,4\")])\n-\n (define_insn \"movsd_store\"\n   [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=m\")\n \t(unspec:DD [(match_operand:SD 1 \"input_operand\" \"d\")]\n@@ -108,7 +37,14 @@\n    || gpc_reg_operand (operands[1], SDmode))\n    && TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"stfd%U0%X0 %1,%0\"\n-  [(set_attr \"type\" \"fpstore\")\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t(const_string \"fpstore_ux\")\n+\t(if_then_else\n+\t  (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t  (const_string \"fpstore_u\")\n+\t  (const_string \"fpstore\"))))\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"movsd_load\"\n@@ -119,7 +55,14 @@\n    || gpc_reg_operand (operands[1], DDmode))\n    && TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"lfd%U1%X1 %0,%1\"\n-  [(set_attr \"type\" \"fpload\")\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t(const_string \"fpload_ux\")\n+\t(if_then_else\n+\t  (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t  (const_string \"fpload_u\")\n+\t  (const_string \"fpload\"))))\n    (set_attr \"length\" \"4\")])\n \n ;; Hardware support for decimal floating point operations.\n@@ -182,211 +125,6 @@\n   \"fnabs %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"movdd\"\n-  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:DD 1 \"any_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], DDmode); DONE; }\")\n-\n-(define_split\n-  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DD 1 \"const_int_operand\" \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 1))]\n-  \"\n-{\n-  int endian = (WORDS_BIG_ENDIAN == 0);\n-  HOST_WIDE_INT value = INTVAL (operands[1]);\n-\n-  operands[2] = operand_subword (operands[0], endian, 0, DDmode);\n-  operands[3] = operand_subword (operands[0], 1 - endian, 0, DDmode);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n-#else\n-  operands[4] = GEN_INT (value >> 32);\n-  operands[1] = GEN_INT (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);\n-#endif\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DD 1 \"const_double_operand\" \"\"))]\n-  \"! TARGET_POWERPC64 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-  \"\n-{\n-  int endian = (WORDS_BIG_ENDIAN == 0);\n-  long l[2];\n-  REAL_VALUE_TYPE rv;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_DECIMAL64 (rv, l);\n-\n-  operands[2] = operand_subword (operands[0], endian, 0, DDmode);\n-  operands[3] = operand_subword (operands[0], 1 - endian, 0, DDmode);\n-  operands[4] = gen_int_mode (l[endian], SImode);\n-  operands[5] = gen_int_mode (l[1 - endian], SImode);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DD 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n-  [(set (match_dup 2) (match_dup 3))]\n-  \"\n-{\n-  int endian = (WORDS_BIG_ENDIAN == 0);\n-  long l[2];\n-  REAL_VALUE_TYPE rv;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  HOST_WIDE_INT val;\n-#endif\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_DECIMAL64 (rv, l);\n-\n-  operands[2] = gen_lowpart (DImode, operands[0]);\n-  /* HIGHPART is lower memory address when WORDS_BIG_ENDIAN.  */\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  val = ((HOST_WIDE_INT)(unsigned long)l[endian] << 32\n-\t | ((HOST_WIDE_INT)(unsigned long)l[1 - endian]));\n-\n-  operands[3] = gen_int_mode (val, DImode);\n-#else\n-  operands[3] = immed_double_const (l[1 - endian], l[endian], DImode);\n-#endif\n-}\")\n-\n-;; Don't have reload use general registers to load a constant.  First,\n-;; it might not work if the output operand is the equivalent of\n-;; a non-offsettable memref, but also it is less efficient than loading\n-;; the constant into an FP register, since it will probably be used there.\n-;; The \"??\" is a kludge until we can figure out a more reasonable way\n-;; of handling these non-offsettable values.\n-(define_insn \"*movdd_hardfloat32\"\n-  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=!r,??r,m,d,d,m,!r,!r,!r\")\n-\t(match_operand:DD 1 \"input_operand\" \"r,m,r,d,m,d,G,H,F\"))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS\n-   && (gpc_reg_operand (operands[0], DDmode)\n-       || gpc_reg_operand (operands[1], DDmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case 0:\n-    case 1:\n-    case 2:\n-      return \\\"#\\\";\n-    case 3:\n-      return \\\"fmr %0,%1\\\";\n-    case 4:\n-      return \\\"lfd%U1%X1 %0,%1\\\";\n-    case 5:\n-      return \\\"stfd%U0%X0 %1,%0\\\";\n-    case 6:\n-    case 7:\n-    case 8:\n-      return \\\"#\\\";\n-    }\n-}\"\n-  [(set_attr \"type\" \"two,load,store,fp,fpload,fpstore,*,*,*\")\n-   (set_attr \"length\" \"8,16,16,4,4,4,8,12,16\")])\n-\n-(define_insn \"*movdd_softfloat32\"\n-  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n-\t(match_operand:DD 1 \"input_operand\" \"r,m,r,G,H,F\"))]\n-  \"! TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n-   && (gpc_reg_operand (operands[0], DDmode)\n-       || gpc_reg_operand (operands[1], DDmode))\"\n-  \"#\"\n-  [(set_attr \"type\" \"two,load,store,*,*,*\")\n-   (set_attr \"length\" \"8,8,8,8,12,16\")])\n-\n-; ld/std require word-aligned displacements -> 'Y' constraint.\n-; List Y->r and r->Y before r->r for reload.\n-(define_insn \"*movdd_hardfloat64_mfpgpr\"\n-  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=Y,r,!r,d,d,m,*c*l,!r,*h,!r,!r,!r,r,d\")\n-\t(match_operand:DD 1 \"input_operand\" \"r,Y,r,d,m,d,r,h,0,G,H,F,d,r\"))]\n-  \"TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS\n-   && (gpc_reg_operand (operands[0], DDmode)\n-       || gpc_reg_operand (operands[1], DDmode))\"\n-  \"@\n-   std%U0%X0 %1,%0\n-   ld%U1%X1 %0,%1\n-   mr %0,%1\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n-   stfd%U0%X0 %1,%0\n-   mt%0 %1\n-   mf%1 %0\n-   nop\n-   #\n-   #\n-   #\n-   mftgpr %0,%1\n-   mffgpr %0,%1\"\n-  [(set_attr \"type\" \"store,load,*,fp,fpload,fpstore,mtjmpr,mfjmpr,*,*,*,*,mftgpr,mffgpr\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,12,16,4,4\")])\n-\n-; ld/std require word-aligned displacements -> 'Y' constraint.\n-; List Y->r and r->Y before r->r for reload.\n-(define_insn \"*movdd_hardfloat64\"\n-  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=Y,r,!r,d,d,m,*c*l,!r,*h,!r,!r,!r\")\n-\t(match_operand:DD 1 \"input_operand\" \"r,Y,r,d,m,d,r,h,0,G,H,F\"))]\n-  \"TARGET_POWERPC64 && !TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS\n-   && (gpc_reg_operand (operands[0], DDmode)\n-       || gpc_reg_operand (operands[1], DDmode))\"\n-  \"@\n-   std%U0%X0 %1,%0\n-   ld%U1%X1 %0,%1\n-   mr %0,%1\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n-   stfd%U0%X0 %1,%0\n-   mt%0 %1\n-   mf%1 %0\n-   nop\n-   #\n-   #\n-   #\"\n-  [(set_attr \"type\" \"store,load,*,fp,fpload,fpstore,mtjmpr,mfjmpr,*,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,12,16\")])\n-\n-(define_insn \"*movdd_softfloat64\"\n-  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=r,Y,r,cl,r,r,r,r,*h\")\n-\t(match_operand:DD 1 \"input_operand\" \"Y,r,r,r,h,G,H,F,0\"))]\n-  \"TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n-   && (gpc_reg_operand (operands[0], DDmode)\n-       || gpc_reg_operand (operands[1], DDmode))\"\n-  \"@\n-   ld%U1%X1 %0,%1\n-   std%U0%X0 %1,%0\n-   mr %0,%1\n-   mt%0 %1\n-   mf%1 %0\n-   #\n-   #\n-   #\n-   nop\"\n-  [(set_attr \"type\" \"load,store,*,mtjmpr,mfjmpr,*,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,8,12,16,4\")])\n-\n (define_expand \"negtd2\"\n   [(set (match_operand:TD 0 \"gpc_reg_operand\" \"\")\n \t(neg:TD (match_operand:TD 1 \"gpc_reg_operand\" \"\")))]\n@@ -420,27 +158,6 @@\n   \"fnabs %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"movtd\"\n-  [(set (match_operand:TD 0 \"general_operand\" \"\")\n-\t(match_operand:TD 1 \"any_operand\" \"\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], TDmode); DONE; }\")\n-\n-; It's important to list the Y->r and r->Y moves before r->r because\n-; otherwise reload, given m->r, will try to pick r->r and reload it,\n-; which doesn't make progress.\n-(define_insn_and_split \"*movtd_internal\"\n-  [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n-\t(match_operand:TD 1 \"input_operand\"         \"d,m,d,r,YGHF,r\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\n-   && (gpc_reg_operand (operands[0], TDmode)\n-       || gpc_reg_operand (operands[1], TDmode))\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(pc)]\n-{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n-  [(set_attr \"length\" \"8,8,8,20,20,16\")])\n-\n ;; Hardware support for decimal floating point operations.\n \n (define_insn \"extendddtd2\""}, {"sha": "8112f26fe19883903da2c9303350650fab82ec8d", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -329,6 +329,11 @@\n       && mode != DImode)\n     return 1;\n \n+  /* The constant 0.0 is easy under VSX.  */\n+  if ((mode == SFmode || mode == DFmode || mode == SDmode || mode == DDmode)\n+      && VECTOR_UNIT_VSX_P (DFmode) && op == CONST0_RTX (mode))\n+    return 1;\n+\n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return 0;\n \n@@ -552,6 +557,28 @@\n \t\t\t&& REG_P (XEXP (op, 1)))\")\n        (match_operand 0 \"address_operand\")))\n \n+;; Return 1 if the operand is an index-form address.\n+(define_special_predicate \"indexed_address\"\n+  (match_test \"(GET_CODE (op) == PLUS\n+\t\t&& REG_P (XEXP (op, 0))\n+\t\t&& REG_P (XEXP (op, 1)))\"))\n+\n+;; Return 1 if the operand is a MEM with an update-form address. This may\n+;; also include update-indexed form.\n+(define_special_predicate \"update_address_mem\"\n+  (match_test \"(MEM_P (op)\n+\t\t&& (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t\t    || GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t\t    || GET_CODE (XEXP (op, 0)) == PRE_MODIFY))\"))\n+\n+;; Return 1 if the operand is a MEM with an update-indexed-form address. Note\n+;; that PRE_INC/PRE_DEC will always be non-indexed (i.e. non X-form) since the\n+;; increment is based on the mode size and will therefor always be a const.\n+(define_special_predicate \"update_indexed_address_mem\"\n+  (match_test \"(MEM_P (op)\n+\t\t&& GET_CODE (XEXP (op, 0)) == PRE_MODIFY\n+\t\t&& indexed_address (XEXP (XEXP (op, 0), 1), mode))\"))\n+\n ;; Used for the destination of the fix_truncdfsi2 expander.\n ;; If stfiwx will be used, the result goes to memory; otherwise,\n ;; we're going to emit a store and a load of a subreg, so the dest is a"}, {"sha": "0564018b3f01ed85df818a8eb5eb3834c4c96503", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -42,7 +42,8 @@\n #define ISA_2_6_MASKS_SERVER\t(ISA_2_5_MASKS_SERVER\t\t\t\\\n \t\t\t\t | OPTION_MASK_POPCNTD\t\t\t\\\n \t\t\t\t | OPTION_MASK_ALTIVEC\t\t\t\\\n-\t\t\t\t | OPTION_MASK_VSX)\n+\t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n+\t\t\t\t | OPTION_MASK_VSX_TIMODE)\n \n #define POWERPC_7400_MASK\t(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)\n \n@@ -76,7 +77,8 @@\n \t\t\t\t | OPTION_MASK_RECIP_PRECISION\t\t\\\n \t\t\t\t | OPTION_MASK_SOFT_FLOAT\t\t\\\n \t\t\t\t | OPTION_MASK_STRICT_ALIGN_OPTIONAL\t\\\n-\t\t\t\t | OPTION_MASK_VSX)\n+\t\t\t\t | OPTION_MASK_VSX\t\t\t\\\n+\t\t\t\t | OPTION_MASK_VSX_TIMODE)\n \n #endif\n \n@@ -165,11 +167,11 @@ RS6000_CPU (\"power6x\", PROCESSOR_POWER6, MASK_POWERPC64 | MASK_PPC_GPOPT\n RS6000_CPU (\"power7\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n \t    POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n \t    | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t    | MASK_VSX | MASK_RECIP_PRECISION)\n+\t    | MASK_VSX | MASK_RECIP_PRECISION | MASK_VSX_TIMODE)\n RS6000_CPU (\"power8\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n \t    POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n \t    | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t    | MASK_VSX | MASK_RECIP_PRECISION)\n+\t    | MASK_VSX | MASK_RECIP_PRECISION | MASK_VSX_TIMODE)\n RS6000_CPU (\"powerpc\", PROCESSOR_POWERPC, 0)\n RS6000_CPU (\"powerpc64\", PROCESSOR_POWERPC64, MASK_PPC_GFXOPT | MASK_POWERPC64)\n RS6000_CPU (\"rs64\", PROCESSOR_RS64A, MASK_PPC_GFXOPT | MASK_POWERPC64)"}, {"sha": "54548be703858dd326febba1ac764127aea11e1c", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -41,3 +41,6 @@ VECTOR_MODE (INT, DI, 1);\n VECTOR_MODES (FLOAT, 8);      /*             V4HF V2SF */\n VECTOR_MODES (FLOAT, 16);     /*       V8HF  V4SF V2DF */\n VECTOR_MODES (FLOAT, 32);     /*       V16HF V8SF V4DF */\n+\n+/* Replacement for TImode that only is allowed in GPRs.  */\n+PARTIAL_INT_MODE (TI);"}, {"sha": "921ff4b04161d5d6b6021d1801436eaa4a9b78ed", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 383, "deletions": 79, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -1516,8 +1516,9 @@ rs6000_hard_regno_nregs_internal (int regno, enum machine_mode mode)\n {\n   unsigned HOST_WIDE_INT reg_size;\n \n+  /* TF/TD modes are special in that they always take 2 registers.  */\n   if (FP_REGNO_P (regno))\n-    reg_size = (VECTOR_MEM_VSX_P (mode)\n+    reg_size = ((VECTOR_MEM_VSX_P (mode) && mode != TDmode && mode != TFmode)\n \t\t? UNITS_PER_VSX_WORD\n \t\t: UNITS_PER_FP_WORD);\n \n@@ -1561,14 +1562,18 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \treturn ALTIVEC_REGNO_P (last_regno);\n     }\n \n+  /* Allow TImode in all VSX registers if the user asked for it.  Note, PTImode\n+     can only go in GPRs.  */\n+  if (mode == TImode && TARGET_VSX_TIMODE && VSX_REGNO_P (regno))\n+    return 1;\n+\n   /* The GPRs can hold any mode, but values bigger than one register\n      cannot go past R31.  */\n   if (INT_REGNO_P (regno))\n     return INT_REGNO_P (last_regno);\n \n   /* The float registers (except for VSX vector modes) can only hold floating\n-     modes and DImode.  This excludes the 32-bit decimal float mode for\n-     now.  */\n+     modes and DImode.  */\n   if (FP_REGNO_P (regno))\n     {\n       if (SCALAR_FLOAT_MODE_P (mode)\n@@ -1602,9 +1607,8 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n     return 1;\n \n-  /* We cannot put TImode anywhere except general register and it must be able\n-     to fit within the register set.  In the future, allow TImode in the\n-     Altivec or VSX registers.  */\n+  /* We cannot put non-VSX TImode or PTImode anywhere except general register\n+     and it must be able to fit within the register set.  */\n \n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n@@ -1693,6 +1697,7 @@ rs6000_debug_reg_global (void)\n   static const char *const tf[2] = { \"false\", \"true\" };\n   const char *nl = (const char *)0;\n   int m;\n+  size_t m1, m2, v;\n   char costly_num[20];\n   char nop_num[20];\n   char flags_buffer[40];\n@@ -1713,10 +1718,67 @@ rs6000_debug_reg_global (void)\n     \"other\"\n   };\n \n-  fprintf (stderr, \"Register information: (last virtual reg = %d)\\n\",\n-\t   LAST_VIRTUAL_REGISTER);\n-  rs6000_debug_reg_print (0, 31, \"gr\");\n-  rs6000_debug_reg_print (32, 63, \"fp\");\n+  /* Modes we want tieable information on.  */\n+  static const enum machine_mode print_tieable_modes[] = {\n+    QImode,\n+    HImode,\n+    SImode,\n+    DImode,\n+    TImode,\n+    PTImode,\n+    SFmode,\n+    DFmode,\n+    TFmode,\n+    SDmode,\n+    DDmode,\n+    TDmode,\n+    V8QImode,\n+    V4HImode,\n+    V2SImode,\n+    V16QImode,\n+    V8HImode,\n+    V4SImode,\n+    V2DImode,\n+    V32QImode,\n+    V16HImode,\n+    V8SImode,\n+    V4DImode,\n+    V2SFmode,\n+    V4SFmode,\n+    V2DFmode,\n+    V8SFmode,\n+    V4DFmode,\n+    CCmode,\n+    CCUNSmode,\n+    CCEQmode,\n+  };\n+\n+  /* Virtual regs we are interested in.  */\n+  const static struct {\n+    int regno;\t\t\t/* register number.  */\n+    const char *name;\t\t/* register name.  */\n+  } virtual_regs[] = {\n+    { STACK_POINTER_REGNUM,\t\t\t\"stack pointer:\" },\n+    { TOC_REGNUM,\t\t\t\t\"toc:          \" },\n+    { STATIC_CHAIN_REGNUM,\t\t\t\"static chain: \" },\n+    { RS6000_PIC_OFFSET_TABLE_REGNUM,\t\t\"pic offset:   \" },\n+    { HARD_FRAME_POINTER_REGNUM,\t\t\"hard frame:   \" },\n+    { ARG_POINTER_REGNUM,\t\t\t\"arg pointer:  \" },\n+    { FRAME_POINTER_REGNUM,\t\t\t\"frame pointer:\" },\n+    { FIRST_PSEUDO_REGISTER,\t\t\t\"first pseudo: \" },\n+    { FIRST_VIRTUAL_REGISTER,\t\t\t\"first virtual:\" },\n+    { VIRTUAL_INCOMING_ARGS_REGNUM,\t\t\"incoming_args:\" },\n+    { VIRTUAL_STACK_VARS_REGNUM,\t\t\"stack_vars:   \" },\n+    { VIRTUAL_STACK_DYNAMIC_REGNUM,\t\t\"stack_dynamic:\" },\n+    { VIRTUAL_OUTGOING_ARGS_REGNUM,\t\t\"outgoing_args:\" },\n+    { VIRTUAL_CFA_REGNUM,\t\t\t\"cfa (frame):  \" },\n+    { VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM,\t\"stack boundry:\" },\n+    { LAST_VIRTUAL_REGISTER,\t\t\t\"last virtual: \" },\n+  };\n+\n+  fputs (\"\\nHard register information:\\n\", stderr);\n+  rs6000_debug_reg_print (FIRST_GPR_REGNO, LAST_GPR_REGNO, \"gr\");\n+  rs6000_debug_reg_print (FIRST_FPR_REGNO, LAST_FPR_REGNO, \"fp\");\n   rs6000_debug_reg_print (FIRST_ALTIVEC_REGNO,\n \t\t\t  LAST_ALTIVEC_REGNO,\n \t\t\t  \"vs\");\n@@ -1729,6 +1791,10 @@ rs6000_debug_reg_global (void)\n   rs6000_debug_reg_print (SPE_ACC_REGNO, SPE_ACC_REGNO, \"spe_a\");\n   rs6000_debug_reg_print (SPEFSCR_REGNO, SPEFSCR_REGNO, \"spe_f\");\n \n+  fputs (\"\\nVirtual/stack/frame registers:\\n\", stderr);\n+  for (v = 0; v < ARRAY_SIZE (virtual_regs); v++)\n+    fprintf (stderr, \"%s regno = %3d\\n\", virtual_regs[v].name, virtual_regs[v].regno);\n+\n   fprintf (stderr,\n \t   \"\\n\"\n \t   \"d  reg_class = %s\\n\"\n@@ -1737,28 +1803,74 @@ rs6000_debug_reg_global (void)\n \t   \"wa reg_class = %s\\n\"\n \t   \"wd reg_class = %s\\n\"\n \t   \"wf reg_class = %s\\n\"\n-\t   \"ws reg_class = %s\\n\\n\",\n+\t   \"wg reg_class = %s\\n\"\n+\t   \"wl reg_class = %s\\n\"\n+\t   \"ws reg_class = %s\\n\"\n+\t   \"wt reg_class = %s\\n\"\n+\t   \"wx reg_class = %s\\n\"\n+\t   \"wz reg_class = %s\\n\"\n+\t   \"\\n\",\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_d]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_f]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_v]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wa]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wd]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wf]],\n-\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_ws]]);\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wg]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wl]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_ws]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wt]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wx]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wz]]);\n \n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-    if (rs6000_vector_unit[m] || rs6000_vector_mem[m])\n+    if (rs6000_vector_unit[m] || rs6000_vector_mem[m]\n+\t|| (rs6000_vector_reload[m][0] != CODE_FOR_nothing)\n+\t|| (rs6000_vector_reload[m][1] != CODE_FOR_nothing))\n       {\n \tnl = \"\\n\";\n-\tfprintf (stderr, \"Vector mode: %-5s arithmetic: %-8s move: %-8s\\n\",\n+\tfprintf (stderr,\n+\t\t \"Vector mode: %-5s arithmetic: %-10s move: %-10s \"\n+\t\t \"reload-out: %c reload-in: %c\\n\",\n \t\t GET_MODE_NAME (m),\n \t\t rs6000_debug_vector_unit[ rs6000_vector_unit[m] ],\n-\t\t rs6000_debug_vector_unit[ rs6000_vector_mem[m] ]);\n+\t\t rs6000_debug_vector_unit[ rs6000_vector_mem[m] ],\n+\t\t (rs6000_vector_reload[m][0] != CODE_FOR_nothing) ? 'y' : 'n',\n+\t\t (rs6000_vector_reload[m][1] != CODE_FOR_nothing) ? 'y' : 'n');\n       }\n \n   if (nl)\n     fputs (nl, stderr);\n \n+  for (m1 = 0; m1 < ARRAY_SIZE (print_tieable_modes); m1++)\n+    {\n+      enum machine_mode mode1 = print_tieable_modes[m1];\n+      bool first_time = true;\n+\n+      nl = (const char *)0;\n+      for (m2 = 0; m2 < ARRAY_SIZE (print_tieable_modes); m2++)\n+\t{\n+\t  enum machine_mode mode2 = print_tieable_modes[m2];\n+\t  if (mode1 != mode2 && MODES_TIEABLE_P (mode1, mode2))\n+\t    {\n+\t      if (first_time)\n+\t\t{\n+\t\t  fprintf (stderr, \"Tieable modes %s:\", GET_MODE_NAME (mode1));\n+\t\t  nl = \"\\n\";\n+\t\t  first_time = false;\n+\t\t}\n+\n+\t      fprintf (stderr, \" %s\", GET_MODE_NAME (mode2));\n+\t    }\n+\t}\n+\n+      if (!first_time)\n+\tfputs (\"\\n\", stderr);\n+    }\n+\n+  if (nl)\n+    fputs (nl, stderr);\n+\n   if (rs6000_recip_control)\n     {\n       fprintf (stderr, \"\\nReciprocal mask = 0x%x\\n\", rs6000_recip_control);\n@@ -1938,6 +2050,9 @@ rs6000_debug_reg_global (void)\n   if (TARGET_LINK_STACK)\n     fprintf (stderr, DEBUG_FMT_S, \"link_stack\", \"true\");\n \n+  if (targetm.lra_p ())\n+    fprintf (stderr, DEBUG_FMT_S, \"lra\", \"true\");\n+\n   fprintf (stderr, DEBUG_FMT_S, \"plt-format\",\n \t   TARGET_SECURE_PLT ? \"secure\" : \"bss\");\n   fprintf (stderr, DEBUG_FMT_S, \"struct-return\",\n@@ -2083,6 +2198,13 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_vector_align[DFmode] = align64;\n     }\n \n+  /* Allow TImode in VSX register and set the VSX memory macros.  */\n+  if (TARGET_VSX && TARGET_VSX_TIMODE)\n+    {\n+      rs6000_vector_mem[TImode] = VECTOR_VSX;\n+      rs6000_vector_align[TImode] = align64;\n+    }\n+\n   /* TODO add SPE and paired floating point vector support.  */\n \n   /* Register class constraints for the constraints that depend on compile\n@@ -2106,11 +2228,27 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_constraints[RS6000_CONSTRAINT_ws] = (TARGET_VSX_SCALAR_MEMORY\n \t\t\t\t\t\t  ? VSX_REGS\n \t\t\t\t\t\t  : FLOAT_REGS);\n+      if (TARGET_VSX_TIMODE)\n+\trs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;\n     }\n \n+  /* Add conditional constraints based on various options, to allow us to\n+     collapse multiple insn patterns.  */\n   if (TARGET_ALTIVEC)\n     rs6000_constraints[RS6000_CONSTRAINT_v] = ALTIVEC_REGS;\n \n+  if (TARGET_MFPGPR)\n+    rs6000_constraints[RS6000_CONSTRAINT_wg] = FLOAT_REGS;\n+\n+  if (TARGET_LFIWAX)\n+    rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;\n+\n+  if (TARGET_STFIWX)\n+    rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;\n+\n+  if (TARGET_LFIWZX)\n+    rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;\n+\n   /* Set up the reload helper functions.  */\n   if (TARGET_VSX || TARGET_ALTIVEC)\n     {\n@@ -2132,6 +2270,13 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t    {\n \t      rs6000_vector_reload[DFmode][0]  = CODE_FOR_reload_df_di_store;\n \t      rs6000_vector_reload[DFmode][1]  = CODE_FOR_reload_df_di_load;\n+\t      rs6000_vector_reload[DDmode][0]  = CODE_FOR_reload_dd_di_store;\n+\t      rs6000_vector_reload[DDmode][1]  = CODE_FOR_reload_dd_di_load;\n+\t    }\n+\t  if (TARGET_VSX_TIMODE)\n+\t    {\n+\t      rs6000_vector_reload[TImode][0]  = CODE_FOR_reload_ti_di_store;\n+\t      rs6000_vector_reload[TImode][1]  = CODE_FOR_reload_ti_di_load;\n \t    }\n \t}\n       else\n@@ -2152,6 +2297,13 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t    {\n \t      rs6000_vector_reload[DFmode][0]  = CODE_FOR_reload_df_si_store;\n \t      rs6000_vector_reload[DFmode][1]  = CODE_FOR_reload_df_si_load;\n+\t      rs6000_vector_reload[DDmode][0]  = CODE_FOR_reload_dd_si_store;\n+\t      rs6000_vector_reload[DDmode][1]  = CODE_FOR_reload_dd_si_load;\n+\t    }\n+\t  if (TARGET_VSX_TIMODE)\n+\t    {\n+\t      rs6000_vector_reload[TImode][0]  = CODE_FOR_reload_ti_si_store;\n+\t      rs6000_vector_reload[TImode][1]  = CODE_FOR_reload_ti_si_load;\n \t    }\n \t}\n     }\n@@ -2641,6 +2793,9 @@ rs6000_option_override_internal (bool global_init_p)\n \t}\n     }\n \n+  if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n+    rs6000_print_isa_options (stderr, 0, \"before defaults\", rs6000_isa_flags);\n+\n   /* For the newer switches (vsx, dfp, etc.) set some of the older options,\n      unless the user explicitly used the -mno-<option> to disable the code.  */\n   if (TARGET_VSX)\n@@ -2658,6 +2813,16 @@ rs6000_option_override_internal (bool global_init_p)\n   else if (TARGET_ALTIVEC)\n     rs6000_isa_flags |= (OPTION_MASK_PPC_GFXOPT & ~rs6000_isa_flags_explicit);\n \n+  if (TARGET_VSX_TIMODE && !TARGET_VSX)\n+    {\n+      if (rs6000_isa_flags_explicit & OPTION_MASK_VSX_TIMODE)\n+\terror (\"-mvsx-timode requires -mvsx\");\n+      rs6000_isa_flags &= ~OPTION_MASK_VSX_TIMODE;\n+    }\n+\n+  if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n+    rs6000_print_isa_options (stderr, 0, \"after defaults\", rs6000_isa_flags);\n+\n   /* E500mc does \"better\" if we inline more aggressively.  Respect the\n      user's opinion, though.  */\n   if (rs6000_block_move_inline_limit == 0\n@@ -2784,6 +2949,9 @@ rs6000_option_override_internal (bool global_init_p)\n   if (flag_section_anchors)\n     TARGET_NO_FP_IN_TOC = 1;\n \n+  if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n+    rs6000_print_isa_options (stderr, 0, \"before subtarget\", rs6000_isa_flags);\n+\n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n@@ -2794,6 +2962,9 @@ rs6000_option_override_internal (bool global_init_p)\n   SUB3TARGET_OVERRIDE_OPTIONS;\n #endif\n \n+  if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n+    rs6000_print_isa_options (stderr, 0, \"after subtarget\", rs6000_isa_flags);\n+\n   /* For the E500 family of cores, reset the single/double FP flags to let us\n      check that they remain constant across attributes or pragmas.  Also,\n      clear a possible request for string instructions, not supported and which\n@@ -4932,7 +5103,7 @@ invalid_e500_subreg (rtx op, enum machine_mode mode)\n \t purpose.  */\n       if (GET_CODE (op) == SUBREG\n \t  && (mode == SImode || mode == DImode || mode == TImode\n-\t      || mode == DDmode || mode == TDmode)\n+\t      || mode == DDmode || mode == TDmode || mode == PTImode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DFmode\n \t      || GET_MODE (SUBREG_REG (op)) == TFmode))\n@@ -4945,6 +5116,7 @@ invalid_e500_subreg (rtx op, enum machine_mode mode)\n \t  && REG_P (SUBREG_REG (op))\n \t  && (GET_MODE (SUBREG_REG (op)) == DImode\n \t      || GET_MODE (SUBREG_REG (op)) == TImode\n+\t      || GET_MODE (SUBREG_REG (op)) == PTImode\n \t      || GET_MODE (SUBREG_REG (op)) == DDmode\n \t      || GET_MODE (SUBREG_REG (op)) == TDmode))\n \treturn true;\n@@ -5164,7 +5336,11 @@ reg_offset_addressing_ok_p (enum machine_mode mode)\n     case V4SImode:\n     case V2DFmode:\n     case V2DImode:\n-      /* AltiVec/VSX vector modes.  Only reg+reg addressing is valid.  */\n+    case TImode:\n+      /* AltiVec/VSX vector modes.  Only reg+reg addressing is valid.  While\n+\t TImode is not a vector mode, if we want to use the VSX registers to\n+\t move it around, we need to restrict ourselves to reg+reg\n+\t addressing.  */\n       if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n \treturn false;\n       break;\n@@ -5178,6 +5354,13 @@ reg_offset_addressing_ok_p (enum machine_mode mode)\n         return false;\n       break;\n \n+    case SDmode:\n+      /* If we can do direct load/stores of SDmode, restrict it to reg+reg\n+\t addressing for the LFIWZX and STFIWX instructions.  */\n+      if (TARGET_NO_SDMODE_STACK)\n+\treturn false;\n+      break;\n+\n     default:\n       break;\n     }\n@@ -5410,7 +5593,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x,\n \n       /* If we are using VSX scalar loads, restrict ourselves to reg+reg\n \t addressing.  */\n-      if (mode == DFmode && VECTOR_MEM_VSX_P (DFmode))\n+      if (VECTOR_MEM_VSX_P (mode))\n \treturn false;\n \n       if (!worst_case)\n@@ -5424,6 +5607,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x,\n     case TFmode:\n     case TDmode:\n     case TImode:\n+    case PTImode:\n       if (TARGET_E500_DOUBLE)\n \treturn (SPE_CONST_OFFSET_OK (offset)\n \t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n@@ -5597,11 +5781,12 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     case TFmode:\n     case TDmode:\n     case TImode:\n+    case PTImode:\n       /* As in legitimate_offset_address_p we do not assume\n \t worst-case.  The mode here is just a hint as to the registers\n \t used.  A TImode is usually in gprs, but may actually be in\n \t fprs.  Leave worst-case scenario for reload to handle via\n-\t insn constraints.  */\n+\t insn constraints.  PTImode is only GPRs.  */\n       extra = 8;\n       break;\n     default:\n@@ -6332,7 +6517,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n \t\t\t\t  || mode == DDmode || mode == TDmode\n \t\t\t\t  || mode == DImode))\n-      && VECTOR_MEM_NONE_P (mode))\n+      && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n       HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n@@ -6363,7 +6548,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \n   if (GET_CODE (x) == SYMBOL_REF\n       && reg_offset_p\n-      && VECTOR_MEM_NONE_P (mode)\n+      && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode))\n       && !SPE_VECTOR_MODE (mode)\n #if TARGET_MACHO\n       && DEFAULT_ABI == ABI_DARWIN\n@@ -6389,6 +6574,8 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \t mem is sufficiently aligned.  */\n       && mode != TFmode\n       && mode != TDmode\n+      && (mode != TImode || !TARGET_VSX_TIMODE)\n+      && mode != PTImode\n       && (mode != DImode || TARGET_POWERPC64)\n       && ((mode != DFmode && mode != DDmode) || TARGET_POWERPC64\n \t  || (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)))\n@@ -6510,10 +6697,12 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n   if (legitimate_indirect_address_p (x, reg_ok_strict))\n     return 1;\n   if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n-      && !VECTOR_MEM_ALTIVEC_OR_VSX_P (mode)\n+      && !ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n       && !SPE_VECTOR_MODE (mode)\n       && mode != TFmode\n       && mode != TDmode\n+      && mode != TImode\n+      && mode != PTImode\n       /* Restrict addressing for DI because of our SUBREG hackery.  */\n       && !(TARGET_E500_DOUBLE\n \t   && (mode == DFmode || mode == DDmode || mode == DImode))\n@@ -6538,26 +6727,28 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n     return 1;\n   if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict, false))\n     return 1;\n-  if (mode != TImode\n-      && mode != TFmode\n+  if (mode != TFmode\n       && mode != TDmode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n \t  || TARGET_POWERPC64\n \t  || (mode != DFmode && mode != DDmode)\n \t  || (TARGET_E500_DOUBLE && mode != DDmode))\n       && (TARGET_POWERPC64 || mode != DImode)\n+      && (mode != TImode || VECTOR_MEM_VSX_P (TImode))\n+      && mode != PTImode\n       && !avoiding_indexed_address_p (mode)\n       && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n   if (GET_CODE (x) == PRE_MODIFY\n       && mode != TImode\n+      && mode != PTImode\n       && mode != TFmode\n       && mode != TDmode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n \t  || TARGET_POWERPC64\n \t  || ((mode != DFmode && mode != DDmode) || TARGET_E500_DOUBLE))\n       && (TARGET_POWERPC64 || mode != DImode)\n-      && !VECTOR_MEM_ALTIVEC_OR_VSX_P (mode)\n+      && !ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n       && !SPE_VECTOR_MODE (mode)\n       /* Restrict addressing for DI because of our SUBREG hackery.  */\n       && !(TARGET_E500_DOUBLE\n@@ -7000,7 +7191,7 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n }\n \n /* Helper for the following.  Get rid of [r+r] memory refs\n-   in cases where it won't work (TImode, TFmode, TDmode).  */\n+   in cases where it won't work (TImode, TFmode, TDmode, PTImode).  */\n \n static void\n rs6000_eliminate_indexed_memrefs (rtx operands[2])\n@@ -7145,6 +7336,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \n   if (reload_in_progress\n       && mode == SDmode\n+      && cfun->machine->sdmode_stack_slot != NULL_RTX\n       && MEM_P (operands[0])\n       && rtx_equal_p (operands[0], cfun->machine->sdmode_stack_slot)\n       && REG_P (operands[1]))\n@@ -7169,6 +7361,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       && mode == SDmode\n       && REG_P (operands[0])\n       && MEM_P (operands[1])\n+      && cfun->machine->sdmode_stack_slot != NULL_RTX\n       && rtx_equal_p (operands[1], cfun->machine->sdmode_stack_slot))\n     {\n       if (FP_REGNO_P (REGNO (operands[0])))\n@@ -7382,6 +7575,11 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       break;\n \n     case TImode:\n+      if (!VECTOR_MEM_VSX_P (TImode))\n+\trs6000_eliminate_indexed_memrefs (operands);\n+      break;\n+\n+    case PTImode:\n       rs6000_eliminate_indexed_memrefs (operands);\n       break;\n \n@@ -13624,7 +13822,7 @@ rs6000_secondary_memory_needed_rtx (enum machine_mode mode)\n   static bool eliminated = false;\n   rtx ret;\n \n-  if (mode != SDmode)\n+  if (mode != SDmode || TARGET_NO_SDMODE_STACK)\n     ret = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n   else\n     {\n@@ -13751,7 +13949,7 @@ rs6000_secondary_reload (bool in_p,\n \t  if (rclass == GENERAL_REGS || rclass == BASE_REGS)\n \t    {\n \t      if (!legitimate_indirect_address_p (addr, false)\n-\t\t  && !rs6000_legitimate_offset_address_p (TImode, addr,\n+\t\t  && !rs6000_legitimate_offset_address_p (PTImode, addr,\n \t\t\t\t\t\t\t  false, true))\n \t\t{\n \t\t  sri->icode = icode;\n@@ -13761,8 +13959,20 @@ rs6000_secondary_reload (bool in_p,\n \t\t\t\t     + ((GET_CODE (addr) == AND) ? 1 : 0));\n \t\t}\n \t    }\n-\t  /* Loads to and stores from vector registers can only do reg+reg\n-\t     addressing.  Altivec registers can also do (reg+reg)&(-16).  */\n+         /* Allow scalar loads to/from the traditional floating point\n+            registers, even if VSX memory is set.  */\n+         else if ((rclass == FLOAT_REGS || rclass == NO_REGS)\n+                  && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n+                  && (legitimate_indirect_address_p (addr, false)\n+                      || legitimate_indirect_address_p (XEXP (addr, 0), false)\n+                      || rs6000_legitimate_offset_address_p (mode, addr,\n+                                                             false, true)))\n+\n+           ;\n+         /* Loads to and stores from vector registers can only do reg+reg\n+            addressing.  Altivec registers can also do (reg+reg)&(-16).  Allow\n+            scalar modes loading up the traditional floating point registers\n+            to use offset addresses.  */\n \t  else if (rclass == VSX_REGS || rclass == ALTIVEC_REGS\n \t\t   || rclass == FLOAT_REGS || rclass == NO_REGS)\n \t    {\n@@ -13938,6 +14148,36 @@ rs6000_secondary_reload (bool in_p,\n   return ret;\n }\n \n+/* Better tracing for rs6000_secondary_reload_inner.  */\n+\n+static void\n+rs6000_secondary_reload_trace (int line, rtx reg, rtx mem, rtx scratch,\n+\t\t\t       bool store_p)\n+{\n+  rtx set, clobber;\n+\n+  gcc_assert (reg != NULL_RTX && mem != NULL_RTX && scratch != NULL_RTX);\n+\n+  fprintf (stderr, \"rs6000_secondary_reload_inner:%d, type = %s\\n\", line,\n+\t   store_p ? \"store\" : \"load\");\n+\n+  if (store_p)\n+    set = gen_rtx_SET (VOIDmode, mem, reg);\n+  else\n+    set = gen_rtx_SET (VOIDmode, reg, mem);\n+\n+  clobber = gen_rtx_CLOBBER (VOIDmode, scratch);\n+  debug_rtx (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n+}\n+\n+static void\n+rs6000_secondary_reload_fail (int line, rtx reg, rtx mem, rtx scratch,\n+\t\t\t      bool store_p)\n+{\n+  rs6000_secondary_reload_trace (line, reg, mem, scratch, store_p);\n+  gcc_unreachable ();\n+}\n+\n /* Fixup reload addresses for Altivec or VSX loads/stores to change SP+offset\n    to SP+reg addressing.  */\n \n@@ -13956,19 +14196,14 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n   rtx cc_clobber;\n \n   if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr, \"\\nrs6000_secondary_reload_inner, type = %s\\n\",\n-\t       store_p ? \"store\" : \"load\");\n-      fprintf (stderr, \"reg:\\n\");\n-      debug_rtx (reg);\n-      fprintf (stderr, \"mem:\\n\");\n-      debug_rtx (mem);\n-      fprintf (stderr, \"scratch:\\n\");\n-      debug_rtx (scratch);\n-    }\n+    rs6000_secondary_reload_trace (__LINE__, reg, mem, scratch, store_p);\n+\n+  if (regno < 0 || regno >= FIRST_PSEUDO_REGISTER)\n+    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n+\n+  if (GET_CODE (mem) != MEM)\n+    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n \n-  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n-  gcc_assert (GET_CODE (mem) == MEM);\n   rclass = REGNO_REG_CLASS (regno);\n   addr = XEXP (mem, 0);\n \n@@ -13987,19 +14222,24 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n       if (GET_CODE (addr) == PRE_MODIFY)\n \t{\n \t  scratch_or_premodify = XEXP (addr, 0);\n-\t  gcc_assert (REG_P (scratch_or_premodify));\n-\t  gcc_assert (GET_CODE (XEXP (addr, 1)) == PLUS);\n+\t  if (!REG_P (scratch_or_premodify))\n+\t    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n+\n+\t  if (GET_CODE (XEXP (addr, 1)) != PLUS)\n+\t    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n+\n \t  addr = XEXP (addr, 1);\n \t}\n \n       if (GET_CODE (addr) == PLUS\n \t  && (and_op2 != NULL_RTX\n-\t      || !rs6000_legitimate_offset_address_p (TImode, addr,\n+\t      || !rs6000_legitimate_offset_address_p (PTImode, addr,\n \t\t\t\t\t\t      false, true)))\n \t{\n \t  addr_op1 = XEXP (addr, 0);\n \t  addr_op2 = XEXP (addr, 1);\n-\t  gcc_assert (legitimate_indirect_address_p (addr_op1, false));\n+\t  if (!legitimate_indirect_address_p (addr_op1, false))\n+\t    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n \n \t  if (!REG_P (addr_op2)\n \t      && (GET_CODE (addr_op2) != CONST_INT\n@@ -14027,7 +14267,7 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t  scratch_or_premodify = scratch;\n \t}\n       else if (!legitimate_indirect_address_p (addr, false)\n-\t       && !rs6000_legitimate_offset_address_p (TImode, addr,\n+\t       && !rs6000_legitimate_offset_address_p (PTImode, addr,\n \t\t\t\t\t\t       false, true))\n \t{\n \t  if (TARGET_DEBUG_ADDR)\n@@ -14043,9 +14283,21 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t}\n       break;\n \n-      /* Float/Altivec registers can only handle reg+reg addressing.  Move\n-\t other addresses into a scratch register.  */\n+      /* Float registers can do offset+reg addressing for scalar types.  */\n     case FLOAT_REGS:\n+      if (legitimate_indirect_address_p (addr, false)\t/* reg */\n+\t  || legitimate_indexed_address_p (addr, false)\t/* reg+reg */\n+\t  || ((GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n+\t      && and_op2 == NULL_RTX\n+\t      && scratch_or_premodify == scratch\n+\t      && rs6000_legitimate_offset_address_p (mode, addr, false, false)))\n+\tbreak;\n+\n+      /* If this isn't a legacy floating point load/store, fall through to the\n+\t VSX defaults.  */\n+\n+      /* VSX/Altivec registers can only handle reg+reg addressing.  Move other\n+\t addresses into a scratch register.  */\n     case VSX_REGS:\n     case ALTIVEC_REGS:\n \n@@ -14065,36 +14317,38 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n       /* If we aren't using a VSX load, save the PRE_MODIFY register and use it\n \t as the address later.  */\n       if (GET_CODE (addr) == PRE_MODIFY\n-\t  && (!VECTOR_MEM_VSX_P (mode)\n+\t  && ((ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n+\t       && (rclass != FLOAT_REGS\n+\t\t   || (GET_MODE_SIZE (mode) != 4 && GET_MODE_SIZE (mode) != 8)))\n \t      || and_op2 != NULL_RTX\n \t      || !legitimate_indexed_address_p (XEXP (addr, 1), false)))\n \t{\n \t  scratch_or_premodify = XEXP (addr, 0);\n-\t  gcc_assert (legitimate_indirect_address_p (scratch_or_premodify,\n-\t\t\t\t\t\t     false));\n-\t  gcc_assert (GET_CODE (XEXP (addr, 1)) == PLUS);\n+\t  if (!legitimate_indirect_address_p (scratch_or_premodify, false))\n+\t    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n+\n+\t  if (GET_CODE (XEXP (addr, 1)) != PLUS)\n+\t    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n+\n \t  addr = XEXP (addr, 1);\n \t}\n \n       if (legitimate_indirect_address_p (addr, false)\t/* reg */\n \t  || legitimate_indexed_address_p (addr, false)\t/* reg+reg */\n-\t  || GET_CODE (addr) == PRE_MODIFY\t\t/* VSX pre-modify */\n \t  || (GET_CODE (addr) == AND\t\t\t/* Altivec memory */\n+\t      && rclass == ALTIVEC_REGS\n \t      && GET_CODE (XEXP (addr, 1)) == CONST_INT\n \t      && INTVAL (XEXP (addr, 1)) == -16\n-\t      && VECTOR_MEM_ALTIVEC_P (mode))\n-\t  || (rclass == FLOAT_REGS\t\t\t/* legacy float mem */\n-\t      && GET_MODE_SIZE (mode) == 8\n-\t      && and_op2 == NULL_RTX\n-\t      && scratch_or_premodify == scratch\n-\t      && rs6000_legitimate_offset_address_p (mode, addr, false, false)))\n+\t      && (legitimate_indirect_address_p (XEXP (addr, 0), false)\n+\t\t  || legitimate_indexed_address_p (XEXP (addr, 0), false))))\n \t;\n \n       else if (GET_CODE (addr) == PLUS)\n \t{\n \t  addr_op1 = XEXP (addr, 0);\n \t  addr_op2 = XEXP (addr, 1);\n-\t  gcc_assert (REG_P (addr_op1));\n+\t  if (!REG_P (addr_op1))\n+\t    rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n \n \t  if (TARGET_DEBUG_ADDR)\n \t    {\n@@ -14113,7 +14367,8 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t}\n \n       else if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == CONST\n-\t       || GET_CODE (addr) == CONST_INT || REG_P (addr))\n+\t       || GET_CODE (addr) == CONST_INT || GET_CODE (addr) == LO_SUM\n+\t       || REG_P (addr))\n \t{\n \t  if (TARGET_DEBUG_ADDR)\n \t    {\n@@ -14129,12 +14384,12 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t}\n \n       else\n-\tgcc_unreachable ();\n+\trs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n \n       break;\n \n     default:\n-      gcc_unreachable ();\n+      rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n     }\n \n   /* If the original address involved a pre-modify that we couldn't use the VSX\n@@ -14246,8 +14501,10 @@ rs6000_secondary_reload_gpr (rtx reg, rtx mem, rtx scratch, bool store_p)\n   return;\n }\n \n-/* Allocate a 64-bit stack slot to be used for copying SDmode\n-   values through if this function has any SDmode references.  */\n+/* Allocate a 64-bit stack slot to be used for copying SDmode values through if\n+   this function has any SDmode references.  If we are on a power7 or later, we\n+   don't need the 64-bit stack slot since the LFIWZX and STIFWX instructions\n+   can load/store the value.  */\n \n static void\n rs6000_alloc_sdmode_stack_slot (void)\n@@ -14258,6 +14515,9 @@ rs6000_alloc_sdmode_stack_slot (void)\n \n   gcc_assert (cfun->machine->sdmode_stack_slot == NULL_RTX);\n \n+  if (TARGET_NO_SDMODE_STACK)\n+    return;\n+\n   FOR_EACH_BB (bb)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n@@ -14318,8 +14578,7 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n-  if (VECTOR_UNIT_VSX_P (mode)\n-      && x == CONST0_RTX (mode) && VSX_REG_CLASS_P (rclass))\n+  if (TARGET_VSX && x == CONST0_RTX (mode) && VSX_REG_CLASS_P (rclass))\n     return rclass;\n \n   if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (mode)\n@@ -14494,11 +14753,17 @@ rs6000_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n     return (mode != SDmode) ? NO_REGS : GENERAL_REGS;\n \n   /* Memory, and FP/altivec registers can go into fp/altivec registers under\n-     VSX.  */\n+     VSX.  However, for scalar variables, use the traditional floating point\n+     registers so that we can use offset+register addressing.  */\n   if (TARGET_VSX\n       && (regno == -1 || VSX_REGNO_P (regno))\n       && VSX_REG_CLASS_P (rclass))\n-    return NO_REGS;\n+    {\n+      if (GET_MODE_SIZE (mode) < 16)\n+\treturn FLOAT_REGS;\n+\n+      return NO_REGS;\n+    }\n \n   /* Memory, and AltiVec registers can go into AltiVec registers.  */\n   if ((regno == -1 || ALTIVEC_REGNO_P (regno))\n@@ -14543,8 +14808,35 @@ rs6000_cannot_change_mode_class (enum machine_mode from,\n   if (from_size != to_size)\n     {\n       enum reg_class xclass = (TARGET_VSX) ? VSX_REGS : FLOAT_REGS;\n-      return ((from_size < 8 || to_size < 8 || TARGET_IEEEQUAD)\n-\t      && reg_classes_intersect_p (xclass, rclass));\n+\n+      if (reg_classes_intersect_p (xclass, rclass))\n+\t{\n+\t  unsigned to_nregs = hard_regno_nregs[FIRST_FPR_REGNO][to];\n+\t  unsigned from_nregs = hard_regno_nregs[FIRST_FPR_REGNO][from];\n+\n+\t  /* Don't allow 64-bit types to overlap with 128-bit types that take a\n+\t     single register under VSX because the scalar part of the register\n+\t     is in the upper 64-bits, and not the lower 64-bits.  Types like\n+\t     TFmode/TDmode that take 2 scalar register can overlap.  128-bit\n+\t     IEEE floating point can't overlap, and neither can small\n+\t     values.  */\n+\n+\t  if (TARGET_IEEEQUAD && (to == TFmode || from == TFmode))\n+\t    return true;\n+\n+\t  if (from_size < 8 || to_size < 8)\n+\t    return true;\n+\n+\t  if (from_size == 8 && (8 * to_nregs) != to_size)\n+\t    return true;\n+\n+\t  if (to_size == 8 && (8 * from_nregs) != from_size)\n+\t    return true;\n+\n+\t  return false;\n+\t}\n+      else\n+\treturn false;\n     }\n \n   if (TARGET_E500_DOUBLE\n@@ -14558,9 +14850,18 @@ rs6000_cannot_change_mode_class (enum machine_mode from,\n   /* Since the VSX register set includes traditional floating point registers\n      and altivec registers, just check for the size being different instead of\n      trying to check whether the modes are vector modes.  Otherwise it won't\n-     allow say DF and DI to change classes.  */\n+     allow say DF and DI to change classes.  For types like TFmode and TDmode\n+     that take 2 64-bit registers, rather than a single 128-bit register, don't\n+     allow subregs of those types to other 128 bit types.  */\n   if (TARGET_VSX && VSX_REG_CLASS_P (rclass))\n-    return (from_size != 8 && from_size != 16);\n+    {\n+      unsigned num_regs = (from_size + 15) / 16;\n+      if (hard_regno_nregs[FIRST_FPR_REGNO][to] > num_regs\n+\t  || hard_regno_nregs[FIRST_FPR_REGNO][from] > num_regs)\n+\treturn true;\n+\n+      return (from_size != 8 && from_size != 16);\n+    }\n \n   if (TARGET_ALTIVEC && rclass == ALTIVEC_REGS\n       && (ALTIVEC_VECTOR_MODE (from) + ALTIVEC_VECTOR_MODE (to)) == 1)\n@@ -15295,7 +15596,7 @@ print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case 'Y':\n-      /* Like 'L', for third word of TImode  */\n+      /* Like 'L', for third word of TImode/PTImode  */\n       if (REG_P (x))\n \tfputs (reg_names[REGNO (x) + 2], file);\n       else if (MEM_P (x))\n@@ -15345,7 +15646,7 @@ print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case 'Z':\n-      /* Like 'L', for last word of TImode.  */\n+      /* Like 'L', for last word of TImode/PTImode.  */\n       if (REG_P (x))\n \tfputs (reg_names[REGNO (x) + 3], file);\n       else if (MEM_P (x))\n@@ -15376,7 +15677,8 @@ print_operand (FILE *file, rtx x, int code)\n \tif ((TARGET_SPE || TARGET_E500_DOUBLE)\n \t    && (GET_MODE_SIZE (GET_MODE (x)) == 8\n \t\t|| GET_MODE (x) == TFmode\n-\t\t|| GET_MODE (x) == TImode))\n+\t\t|| GET_MODE (x) == TImode\n+\t\t|| GET_MODE (x) == PTImode))\n \t  {\n \t    /* Handle [reg].  */\n \t    if (REG_P (tmp))\n@@ -26429,7 +26731,7 @@ rs6000_register_move_cost (enum machine_mode mode,\n     }\n \n   /* If we have VSX, we can easily move between FPR or Altivec registers.  */\n-  else if (VECTOR_UNIT_VSX_P (mode)\n+  else if (VECTOR_MEM_VSX_P (mode)\n \t   && reg_classes_intersect_p (to, VSX_REGS)\n \t   && reg_classes_intersect_p (from, VSX_REGS))\n     ret = 2 * hard_regno_nregs[32][mode];\n@@ -26470,7 +26772,8 @@ rs6000_memory_move_cost (enum machine_mode mode, reg_class_t rclass,\n \n   if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n     ret = 4 * hard_regno_nregs[0][mode];\n-  else if (reg_classes_intersect_p (rclass, FLOAT_REGS))\n+  else if ((reg_classes_intersect_p (rclass, FLOAT_REGS)\n+\t    || reg_classes_intersect_p (rclass, VSX_REGS)))\n     ret = 4 * hard_regno_nregs[32][mode];\n   else if (reg_classes_intersect_p (rclass, ALTIVEC_REGS))\n     ret = 4 * hard_regno_nregs[FIRST_ALTIVEC_REGNO][mode];\n@@ -27684,6 +27987,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"recip-precision\",\t\tOPTION_MASK_RECIP_PRECISION,\tfalse, true  },\n   { \"string\",\t\t\tOPTION_MASK_STRING,\t\tfalse, true  },\n   { \"vsx\",\t\t\tOPTION_MASK_VSX,\t\tfalse, true  },\n+  { \"vsx-timode\",\t\tOPTION_MASK_VSX_TIMODE,\t\tfalse, true  },\n #ifdef OPTION_MASK_64BIT\n #if TARGET_AIX_OS\n   { \"aix64\",\t\t\tOPTION_MASK_64BIT,\t\tfalse, false },"}, {"sha": "b7b415d69c050590f07413b5cf37d1162a58d052", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -479,6 +479,11 @@ extern int rs6000_vector_align[];\n #define TARGET_FCTIDUZ\tTARGET_POPCNTD\n #define TARGET_FCTIWUZ\tTARGET_POPCNTD\n \n+/* Power7 has both 32-bit load and store integer for the FPRs, so we don't need\n+   to allocate the SDmode stack slot to get the value into the proper location\n+   in the register.  */\n+#define TARGET_NO_SDMODE_STACK\t(TARGET_LFIWZX && TARGET_STFIWX && TARGET_DFP)\n+\n /* In switching from using target_flags to using rs6000_isa_flags, the options\n    machinery creates OPTION_MASK_<xxx> instead of MASK_<xxx>.  For now map\n    OPTION_MASK_<xxx> back into MASK_<xxx>.  */\n@@ -505,6 +510,7 @@ extern int rs6000_vector_align[];\n #define MASK_STRING\t\t\tOPTION_MASK_STRING\n #define MASK_UPDATE\t\t\tOPTION_MASK_UPDATE\n #define MASK_VSX\t\t\tOPTION_MASK_VSX\n+#define MASK_VSX_TIMODE\t\t\tOPTION_MASK_VSX_TIMODE\n \n #ifndef IN_LIBGCC2\n #define MASK_POWERPC64\t\t\tOPTION_MASK_POWERPC64\n@@ -1325,8 +1331,13 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_v,\t\t/* Altivec registers */\n   RS6000_CONSTRAINT_wa,\t\t/* Any VSX register */\n   RS6000_CONSTRAINT_wd,\t\t/* VSX register for V2DF */\n+  RS6000_CONSTRAINT_wg,\t\t/* FPR register for -mmfpgpr */\n   RS6000_CONSTRAINT_wf,\t\t/* VSX register for V4SF */\n+  RS6000_CONSTRAINT_wl,\t\t/* FPR register for LFIWAX */\n   RS6000_CONSTRAINT_ws,\t\t/* VSX register for DF */\n+  RS6000_CONSTRAINT_wt,\t\t/* VSX register for TImode */\n+  RS6000_CONSTRAINT_wx,\t\t/* FPR register for STFIWX */\n+  RS6000_CONSTRAINT_wz,\t\t/* FPR register for LFIWZX */\n   RS6000_CONSTRAINT_MAX\n };\n \n@@ -1511,7 +1522,7 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n    NONLOCAL needs twice Pmode to maintain both backchain and SP.  */\n #define STACK_SAVEAREA_MODE(LEVEL)\t\\\n   (LEVEL == SAVE_FUNCTION ? VOIDmode\t\\\n-  : LEVEL == SAVE_NONLOCAL ? (TARGET_32BIT ? DImode : TImode) : Pmode)\n+  : LEVEL == SAVE_NONLOCAL ? (TARGET_32BIT ? DImode : PTImode) : Pmode)\n \n /* Minimum and maximum general purpose registers used to hold arguments.  */\n #define GP_ARG_MIN_REG 3"}, {"sha": "0a5d32728a1a171f182d6616eb81b55e5c2070ad", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 648, "deletions": 215, "changes": 863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -25,10 +25,14 @@\n ;;\n \n (define_constants\n-  [(STACK_POINTER_REGNUM\t1)\n+  [(FIRST_GPR_REGNO\t\t0)\n+   (STACK_POINTER_REGNUM\t1)\n    (TOC_REGNUM\t\t\t2)\n    (STATIC_CHAIN_REGNUM\t\t11)\n    (HARD_FRAME_POINTER_REGNUM\t31)\n+   (LAST_GPR_REGNO\t\t31)\n+   (FIRST_FPR_REGNO\t\t32)\n+   (LAST_FPR_REGNO\t\t63)\n    (LR_REGNO\t\t\t65)\n    (CTR_REGNO\t\t\t66)\n    (ARG_POINTER_REGNUM\t\t67)\n@@ -215,7 +219,7 @@\n (define_mode_iterator GPR [SI (DI \"TARGET_POWERPC64\")])\n \n ; Any supported integer mode.\n-(define_mode_iterator INT [QI HI SI DI TI])\n+(define_mode_iterator INT [QI HI SI DI TI PTI])\n \n ; Any supported integer mode that fits in one register.\n (define_mode_iterator INT1 [QI HI SI (DI \"TARGET_POWERPC64\")])\n@@ -230,6 +234,10 @@\n ; (one with a '.') will compare; and the size used for arithmetic carries.\n (define_mode_iterator P [(SI \"TARGET_32BIT\") (DI \"TARGET_64BIT\")])\n \n+; Iterator to add PTImode along with TImode (TImode can go in VSX registers,\n+; PTImode is GPR only)\n+(define_mode_iterator TI2 [TI PTI])\n+\n ; Any hardware-supported floating-point mode\n (define_mode_iterator FP [\n   (SF \"TARGET_HARD_FLOAT \n@@ -253,6 +261,35 @@\n   (V2DF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V2DFmode)\")\n   ])\n \n+; Floating point move iterators to combine binary and decimal moves\n+(define_mode_iterator FMOVE32 [SF SD])\n+(define_mode_iterator FMOVE64 [DF DD])\n+(define_mode_iterator FMOVE64X [DI DF DD])\n+(define_mode_iterator FMOVE128 [(TF \"!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\")\n+\t\t\t\t(TD \"TARGET_HARD_FLOAT && TARGET_FPRS\")])\n+\n+; Whether a floating point move is ok, don't allow SD without hardware FP\n+(define_mode_attr fmove_ok [(SF \"\")\n+\t\t\t    (DF \"\")\n+\t\t\t    (SD \"TARGET_HARD_FLOAT && TARGET_FPRS\")\n+\t\t\t    (DD \"\")])\n+\n+; Convert REAL_VALUE to the appropriate bits\n+(define_mode_attr real_value_to_target [(SF \"REAL_VALUE_TO_TARGET_SINGLE\")\n+\t\t\t\t\t(DF \"REAL_VALUE_TO_TARGET_DOUBLE\")\n+\t\t\t\t\t(SD \"REAL_VALUE_TO_TARGET_DECIMAL32\")\n+\t\t\t\t\t(DD \"REAL_VALUE_TO_TARGET_DECIMAL64\")])\n+\n+; Definitions for load to 32-bit fpr register\n+(define_mode_attr f32_lr [(SF \"f\")\t\t (SD \"wz\")])\n+(define_mode_attr f32_lm [(SF \"m\")\t\t (SD \"Z\")])\n+(define_mode_attr f32_li [(SF \"lfs%U1%X1 %0,%1\") (SD \"lfiwzx %0,%y1\")])\n+\n+; Definitions for store from 32-bit fpr register\n+(define_mode_attr f32_sr [(SF \"f\")\t\t  (SD \"wx\")])\n+(define_mode_attr f32_sm [(SF \"m\")\t\t  (SD \"Z\")])\n+(define_mode_attr f32_si [(SF \"stfs%U0%X0 %1,%0\") (SD \"stfiwx %1,%y0\")])\n+\n ; These modes do not fit in integer registers in 32-bit mode.\n ; but on e500v2, the gpr are 64 bit registers\n (define_mode_iterator DIFD [DI (DF \"!TARGET_E500_DOUBLE\") DD])\n@@ -271,7 +308,14 @@\n \n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd.\n-(define_mode_attr wd [(QI \"b\") (HI \"h\") (SI \"w\") (DI \"d\")])\n+(define_mode_attr wd [(QI    \"b\")\n+\t\t      (HI    \"h\")\n+\t\t      (SI    \"w\")\n+\t\t      (DI    \"d\")\n+\t\t      (V16QI \"b\")\n+\t\t      (V8HI  \"h\")\n+\t\t      (V4SI  \"w\")\n+\t\t      (V2DI  \"d\")])\n \n ; DImode bits\n (define_mode_attr dbits [(QI \"56\") (HI \"48\") (SI \"32\")])\n@@ -328,7 +372,15 @@\n   \"@\n    l<wd>z%U1%X1 %0,%1\n    rldicl %0,%1,0,<dbits>\"\n-  [(set_attr \"type\" \"load,*\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")])])\n \n (define_insn \"*zero_extend<mode>di2_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n@@ -454,7 +506,15 @@\n   \"@\n    lha%U1%X1 %0,%1\n    extsh %0,%1\"\n-  [(set_attr \"type\" \"load_ext,exts\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ext_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_ext_u\")\n+\t   (const_string \"load_ext\")))\n+       (const_string \"exts\")])])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n@@ -528,7 +588,15 @@\n   \"@\n    lwa%U1%X1 %0,%1\n    extsw %0,%1\"\n-  [(set_attr \"type\" \"load_ext,exts\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ext_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_ext_u\")\n+\t   (const_string \"load_ext\")))\n+       (const_string \"exts\")])])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n@@ -602,7 +670,15 @@\n   \"@\n    lbz%U1%X1 %0,%1\n    rlwinm %0,%1,0,0xff\"\n-  [(set_attr \"type\" \"load,*\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")])])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n@@ -722,7 +798,15 @@\n   \"@\n    lbz%U1%X1 %0,%1\n    rlwinm %0,%1,0,0xff\"\n-  [(set_attr \"type\" \"load,*\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")])])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n@@ -848,7 +932,15 @@\n   \"@\n    lhz%U1%X1 %0,%1\n    rlwinm %0,%1,0,0xffff\"\n-  [(set_attr \"type\" \"load,*\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")])])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n@@ -915,7 +1007,15 @@\n   \"@\n    lha%U1%X1 %0,%1\n    extsh %0,%1\"\n-  [(set_attr \"type\" \"load_ext,exts\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ext_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_ext_u\")\n+\t   (const_string \"load_ext\")))\n+       (const_string \"exts\")])])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n@@ -4498,7 +4598,16 @@\n   emit_note (NOTE_INSN_DELETED);\n   DONE;\n }\n-  [(set_attr \"type\" \"fp,fp,fpload\")])\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"fp\")\n+       (const_string \"fp\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))])])\n \n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -7723,7 +7832,31 @@\n    mt%0 %1\n    mt%0 %1\n    nop\"\n-  [(set_attr \"type\" \"*,*,load,store,*,*,*,mfjmpr,mtjmpr,*,*\")\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"*\")\n+       (const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"*\")\n+       (const_string \"*\")])\n+\n    (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4\")])\n \n (define_insn \"*movsi_internal1_single\"\n@@ -7745,7 +7878,44 @@\n    nop\n    stfs%U0%X0 %1,%0\n    lfs%U1%X1 %0,%1\"\n-  [(set_attr \"type\" \"*,*,load,store,*,*,*,mfjmpr,mtjmpr,*,*,*,*\")\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"*\")\n+       (const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"fpstore_u\")\n+\t   (const_string \"fpstore\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))])\n    (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4,4\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n@@ -7808,7 +7978,26 @@\n    mf%1 %0\n    mt%0 %1\n    nop\"\n-  [(set_attr \"type\" \"*,load,store,*,mfjmpr,mtjmpr,*\")])\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (const_string \"*\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"*\")])])\n \n (define_expand \"mov<mode>\"\n   [(set (match_operand:INT 0 \"general_operand\" \"\")\n@@ -7829,7 +8018,26 @@\n    mf%1 %0\n    mt%0 %1\n    nop\"\n-  [(set_attr \"type\" \"*,load,store,*,mfjmpr,mtjmpr,*\")])\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (const_string \"*\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"*\")])])\n \f\n ;; Here is how to move condition codes around.  When we store CC data in\n ;; an integer register or memory, we store just the high-order 4 bits.\n@@ -7857,7 +8065,7 @@\n    mf%1 %0\n    mt%0 %1\n    lwz%U1%X1 %0,%1\n-   stw%U0%U1 %1,%0\"\n+   stw%U0%X0 %1,%0\"\n   [(set (attr \"type\")\n      (cond [(eq_attr \"alternative\" \"0,3\")\n \t\t(const_string \"cr_logical\")\n@@ -7870,9 +8078,23 @@\n \t    (eq_attr \"alternative\" \"9\")\n \t\t(const_string \"mtjmpr\")\n \t    (eq_attr \"alternative\" \"10\")\n-\t\t(const_string \"load\")\n+\t\t(if_then_else\n+\t\t  (match_test \"update_indexed_address_mem (operands[1],\n+\t\t\t\t\t\t\t   VOIDmode)\")\n+\t\t  (const_string \"load_ux\")\n+\t\t  (if_then_else\n+\t\t    (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t\t    (const_string \"load_u\")\n+\t\t    (const_string \"load\")))\n \t    (eq_attr \"alternative\" \"11\")\n-\t\t(const_string \"store\")\n+\t\t(if_then_else\n+\t\t  (match_test \"update_indexed_address_mem (operands[0],\n+\t\t\t\t\t\t\t   VOIDmode)\")\n+\t\t  (const_string \"store_ux\")\n+\t\t  (if_then_else\n+\t\t    (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t\t    (const_string \"store_u\")\n+\t\t    (const_string \"store\")))\n \t    (match_test \"TARGET_MFCRF\")\n \t\t(const_string \"mfcrf\")\n \t   ]\n@@ -7884,15 +8106,17 @@\n ;; can produce floating-point values in fixed-point registers.  Unless the\n ;; value is a simple constant or already in memory, we deal with this by\n ;; allocating memory and copying the value explicitly via that memory location.\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SF 1 \"any_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], SFmode); DONE; }\")\n+\n+;; Move 32-bit binary/decimal floating point\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:FMOVE32 1 \"any_operand\" \"\"))]\n+  \"<fmove_ok>\"\n+  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n \n (define_split\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  [(set (match_operand:FMOVE32 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:FMOVE32 1 \"const_double_operand\" \"\"))]\n   \"reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n@@ -7905,42 +8129,81 @@\n   REAL_VALUE_TYPE rv;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+  <real_value_to_target> (rv, l);\n \n   if (! TARGET_POWERPC64)\n-    operands[2] = operand_subword (operands[0], 0, 0, SFmode);\n+    operands[2] = operand_subword (operands[0], 0, 0, <MODE>mode);\n   else\n     operands[2] = gen_lowpart (SImode, operands[0]);\n \n   operands[3] = gen_int_mode (l, SImode);\n }\")\n \n-(define_insn \"*movsf_hardfloat\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=!r,!r,m,f,f,m,*c*l,!r,*h,!r,!r\")\n-\t(match_operand:SF 1 \"input_operand\" \"r,m,r,f,m,f,r,h,0,G,Fn\"))]\n-  \"(gpc_reg_operand (operands[0], SFmode)\n-   || gpc_reg_operand (operands[1], SFmode))\n+(define_insn \"mov<mode>_hardfloat\"\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,wa,wa,<f32_lr>,<f32_sm>,*c*l,!r,*h,!r,!r\")\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,wa,j,<f32_lm>,<f32_sr>,r,h,0,G,Fn\"))]\n+  \"(gpc_reg_operand (operands[0], <MODE>mode)\n+   || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)\"\n   \"@\n    mr %0,%1\n    lwz%U1%X1 %0,%1\n    stw%U0%X0 %1,%0\n    fmr %0,%1\n-   lfs%U1%X1 %0,%1\n-   stfs%U0%X0 %1,%0\n+   xxlor %x0,%x1,%x1\n+   xxlxor %x0,%x0,%x0\n+   <f32_li>\n+   <f32_si>\n    mt%0 %1\n    mf%1 %0\n    nop\n    #\n    #\"\n-  [(set_attr \"type\" \"*,load,store,fp,fpload,fpstore,mtjmpr,mfjmpr,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,8\")])\n-\n-(define_insn \"*movsf_softfloat\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,cl,r,r,m,r,r,r,r,*h\")\n-\t(match_operand:SF 1 \"input_operand\" \"r,r,h,m,r,I,L,G,Fn,0\"))]\n-  \"(gpc_reg_operand (operands[0], SFmode)\n-   || gpc_reg_operand (operands[1], SFmode))\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (const_string \"fp\")\n+       (const_string \"vecsimple\")\n+       (const_string \"vecsimple\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"fpstore_u\")\n+\t   (const_string \"fpstore\")))\n+       (const_string \"mtjmpr\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,8\")])\n+\n+(define_insn \"*mov<mode>_softfloat\"\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=r,cl,r,r,m,r,r,r,r,*h\")\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r, r,h,m,r,I,L,G,Fn,0\"))]\n+  \"(gpc_reg_operand (operands[0], <MODE>mode)\n+   || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\"\n   \"@\n    mr %0,%1\n@@ -7953,19 +8216,42 @@\n    #\n    #\n    nop\"\n-  [(set_attr \"type\" \"*,mtjmpr,mfjmpr,load,store,*,*,*,*,*\")\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"*\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"mfjmpr\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")])\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,8,4\")])\n \n \f\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:DF 1 \"any_operand\" \"\"))]\n+;; Move 64-bit binary/decimal floating point\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:FMOVE64 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], DFmode); DONE; }\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n \n (define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n+  [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:FMOVE64 1 \"const_int_operand\" \"\"))]\n   \"! TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n@@ -7978,8 +8264,8 @@\n   int endian = (WORDS_BIG_ENDIAN == 0);\n   HOST_WIDE_INT value = INTVAL (operands[1]);\n \n-  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n-  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n+  operands[2] = operand_subword (operands[0], endian, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, <MODE>mode);\n #if HOST_BITS_PER_WIDE_INT == 32\n   operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n #else\n@@ -7989,8 +8275,8 @@\n }\")\n \n (define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:FMOVE64 1 \"const_double_operand\" \"\"))]\n   \"! TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n@@ -8005,17 +8291,17 @@\n   REAL_VALUE_TYPE rv;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n+  <real_value_to_target> (rv, l);\n \n-  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n-  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n+  operands[2] = operand_subword (operands[0], endian, 0, <MODE>mode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, <MODE>mode);\n   operands[4] = gen_int_mode (l[endian], SImode);\n   operands[5] = gen_int_mode (l[1 - endian], SImode);\n }\")\n \n (define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:FMOVE64 1 \"const_double_operand\" \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG\n@@ -8032,7 +8318,7 @@\n #endif\n \n   REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-  REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n+  <real_value_to_target> (rv, l);\n \n   operands[2] = gen_lowpart (DImode, operands[0]);\n   /* HIGHPART is lower memory address when WORDS_BIG_ENDIAN.  */\n@@ -8057,12 +8343,12 @@\n ;; since the D-form version of the memory instructions does not need a GPR for\n ;; reloading.\n \n-(define_insn \"*movdf_hardfloat32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,d,d,ws,?wa,Z,?Z,ws,?wa,wa,Y,r,!r,!r,!r,!r\")\n-\t(match_operand:DF 1 \"input_operand\" \"d,m,d,Z,Z,ws,wa,ws,wa,j,r,Y,r,G,H,F\"))]\n+(define_insn \"*mov<mode>_hardfloat32\"\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,ws,?wa,Z,?Z,ws,?wa,wa,Y,r,!r,!r,!r,!r\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,Z,ws,wa,ws,wa,j,r,Y,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n-   && (gpc_reg_operand (operands[0], DFmode)\n-       || gpc_reg_operand (operands[1], DFmode))\"\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n    stfd%U0%X0 %1,%0\n    lfd%U1%X1 %0,%1\n@@ -8080,115 +8366,157 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpload,fpstore,fpstore,vecsimple,vecsimple,vecsimple,store,load,two,fp,fp,*\")\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"fpstore_u\")\n+\t   (const_string \"fpstore\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))\n+       (const_string \"fp\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (const_string \"fpload\"))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (const_string \"fpload\"))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (const_string \"fpstore\"))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (const_string \"fpstore\"))\n+       (const_string \"vecsimple\")\n+       (const_string \"vecsimple\")\n+       (const_string \"vecsimple\")\n+       (const_string \"store\")\n+       (const_string \"load\")\n+       (const_string \"two\")\n+       (const_string \"fp\")\n+       (const_string \"fp\")\n+       (const_string \"*\")])\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,8,8,8,8,12,16\")])\n \n-(define_insn \"*movdf_softfloat32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,Y,r,G,H,F\"))]\n+(define_insn \"*mov<mode>_softfloat32\"\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"r,Y,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 \n    && ((TARGET_FPRS && TARGET_SINGLE_FLOAT) \n        || TARGET_SOFT_FLOAT || TARGET_E500_SINGLE)\n-   && (gpc_reg_operand (operands[0], DFmode)\n-       || gpc_reg_operand (operands[1], DFmode))\"\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n   [(set_attr \"type\" \"store,load,two,*,*,*\")\n    (set_attr \"length\" \"8,8,8,8,12,16\")])\n \n-;; Reload patterns to support gpr load/store with misaligned mem.\n-;; and multiple gpr load/store at offset >= 0xfffc\n-(define_expand \"reload_<mode>_store\"\n-  [(parallel [(match_operand 0 \"memory_operand\" \"=m\")\n-              (match_operand 1 \"gpc_reg_operand\" \"r\")\n-              (match_operand:GPR 2 \"register_operand\" \"=&b\")])]\n-  \"\"\n-{\n-  rs6000_secondary_reload_gpr (operands[1], operands[0], operands[2], true);\n-  DONE;\n-})\n-\n-(define_expand \"reload_<mode>_load\"\n-  [(parallel [(match_operand 0 \"gpc_reg_operand\" \"=r\")\n-              (match_operand 1 \"memory_operand\" \"m\")\n-              (match_operand:GPR 2 \"register_operand\" \"=b\")])]\n-  \"\"\n-{\n-  rs6000_secondary_reload_gpr (operands[0], operands[1], operands[2], false);\n-  DONE;\n-})\n-\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n-(define_insn \"*movdf_hardfloat64_mfpgpr\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,!r,ws,?wa,ws,?wa,Z,?Z,m,d,d,wa,*c*l,!r,*h,!r,!r,!r,r,d\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,Y,r,ws,?wa,Z,Z,ws,wa,d,m,d,j,r,h,0,G,H,F,d,r\"))]\n-  \"TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS \n-   && TARGET_DOUBLE_FLOAT\n-   && (gpc_reg_operand (operands[0], DFmode)\n-       || gpc_reg_operand (operands[1], DFmode))\"\n+(define_insn \"*mov<mode>_hardfloat64\"\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,ws,?wa,Z,?Z,ws,?wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,Z,ws,wa,ws,wa,j,r,Y,r,r,h,0,G,H,F,wg,r\"))]\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n-   std%U0%X0 %1,%0\n-   ld%U1%X1 %0,%1\n-   mr %0,%1\n-   xxlor %x0,%x1,%x1\n-   xxlor %x0,%x1,%x1\n-   lxsd%U1x %x0,%y1\n-   lxsd%U1x %x0,%y1\n-   stxsd%U0x %x1,%y0\n-   stxsd%U0x %x1,%y0\n    stfd%U0%X0 %1,%0\n    lfd%U1%X1 %0,%1\n    fmr %0,%1\n-   xxlxor %x0,%x0,%x0\n-   mt%0 %1\n-   mf%1 %0\n-   nop\n-   #\n-   #\n-   #\n-   mftgpr %0,%1\n-   mffgpr %0,%1\"\n-  [(set_attr \"type\" \"store,load,*,fp,fp,fpload,fpload,fpstore,fpstore,fpstore,fpload,fp,vecsimple,mtjmpr,mfjmpr,*,*,*,*,mftgpr,mffgpr\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4\")])\n-\n-; ld/std require word-aligned displacements -> 'Y' constraint.\n-; List Y->r and r->Y before r->r for reload.\n-(define_insn \"*movdf_hardfloat64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,!r,ws,?wa,Z,?Z,ws,?wa,wa,*c*l,!r,*h,!r,!r,!r\")\n-\t(match_operand:DF 1 \"input_operand\" \"d,m,d,r,Y,r,Z,Z,ws,wa,ws,wa,j,r,h,0,G,H,F\"))]\n-  \"TARGET_POWERPC64 && !TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS \n-   && TARGET_DOUBLE_FLOAT\n-   && (gpc_reg_operand (operands[0], DFmode)\n-       || gpc_reg_operand (operands[1], DFmode))\"\n-  \"@\n-   stfd%U0%X0 %1,%0\n-   lfd%U1%X1 %0,%1\n-   fmr %0,%1\n-   std%U0%X0 %1,%0\n-   ld%U1%X1 %0,%1\n-   mr %0,%1\n    lxsd%U1x %x0,%y1\n    lxsd%U1x %x0,%y1\n    stxsd%U0x %x1,%y0\n    stxsd%U0x %x1,%y0\n    xxlor %x0,%x1,%x1\n    xxlor %x0,%x1,%x1\n    xxlxor %x0,%x0,%x0\n+   std%U0%X0 %1,%0\n+   ld%U1%X1 %0,%1\n+   mr %0,%1\n    mt%0 %1\n    mf%1 %0\n    nop\n    #\n    #\n-   #\"\n-  [(set_attr \"type\" \"fpstore,fpload,fp,store,load,*,fpload,fpload,fpstore,fpstore,vecsimple,vecsimple,vecsimple,mtjmpr,mfjmpr,*,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16\")])\n+   #\n+   mftgpr %0,%1\n+   mffgpr %0,%1\"\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"fpstore_u\")\n+\t   (const_string \"fpstore\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))\n+       (const_string \"fp\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (const_string \"fpload\"))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (const_string \"fpload\"))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (const_string \"fpstore\"))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (const_string \"fpstore\"))\n+       (const_string \"vecsimple\")\n+       (const_string \"vecsimple\")\n+       (const_string \"vecsimple\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"mftgpr\")\n+       (const_string \"mffgpr\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4\")])\n \n-(define_insn \"*movdf_softfloat64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,r,cl,r,r,r,r,*h\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,Y,r,r,h,G,H,F,0\"))]\n+(define_insn \"*mov<mode>_softfloat64\"\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,cl,r,r,r,r,*h\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"r,Y,r,r,h,G,H,F,0\"))]\n   \"TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n-   && (gpc_reg_operand (operands[0], DFmode)\n-       || gpc_reg_operand (operands[1], DFmode))\"\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n    std%U0%X0 %1,%0\n    ld%U1%X1 %0,%1\n@@ -8199,38 +8527,57 @@\n    #\n    #\n    nop\"\n-  [(set_attr \"type\" \"store,load,*,mtjmpr,mfjmpr,*,*,*,*\")\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")])\n    (set_attr \"length\" \"4,4,4,4,4,8,12,16,4\")])\n \f\n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"\")\n-\t(match_operand:TF 1 \"any_operand\" \"\"))]\n-  \"!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], TFmode); DONE; }\")\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:FMOVE128 0 \"general_operand\" \"\")\n+\t(match_operand:FMOVE128 1 \"any_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n \n ;; It's important to list Y->r and r->Y before r->r because otherwise\n ;; reload, given m->r, will try to pick r->r and reload it, which\n ;; doesn't make progress.\n-(define_insn_and_split \"*movtf_internal\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n-\t(match_operand:TF 1 \"input_operand\" \"d,m,d,r,YGHF,r\"))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\n-   && (gpc_reg_operand (operands[0], TFmode)\n-       || gpc_reg_operand (operands[1], TFmode))\"\n+(define_insn_and_split \"*mov<mode>_internal\"\n+  [(set (match_operand:FMOVE128 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n+\t(match_operand:FMOVE128 1 \"input_operand\" \"d,m,d,r,YGHF,r\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n   [(set_attr \"length\" \"8,8,8,20,20,16\")])\n \n-(define_insn_and_split \"*movtf_softfloat\"\n-  [(set (match_operand:TF 0 \"rs6000_nonimmediate_operand\" \"=Y,r,r\")\n-\t(match_operand:TF 1 \"input_operand\"         \"r,YGHF,r\"))]\n-  \"!TARGET_IEEEQUAD\n-   && (TARGET_SOFT_FLOAT || !TARGET_FPRS) && TARGET_LONG_DOUBLE_128\n-   && (gpc_reg_operand (operands[0], TFmode)\n-       || gpc_reg_operand (operands[1], TFmode))\"\n+(define_insn_and_split \"*mov<mode>_softfloat\"\n+  [(set (match_operand:FMOVE128 0 \"rs6000_nonimmediate_operand\" \"=Y,r,r\")\n+\t(match_operand:FMOVE128 1 \"input_operand\" \"r,YGHF,r\"))]\n+  \"(TARGET_SOFT_FLOAT || !TARGET_FPRS)\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n@@ -8514,6 +8861,33 @@\n   operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n   operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n }\")\n+\f\n+;; Reload helper functions used by rs6000_secondary_reload.  The patterns all\n+;; must have 3 arguments, and scratch register constraint must be a single\n+;; constraint.\n+\n+;; Reload patterns to support gpr load/store with misaligned mem.\n+;; and multiple gpr load/store at offset >= 0xfffc\n+(define_expand \"reload_<mode>_store\"\n+  [(parallel [(match_operand 0 \"memory_operand\" \"=m\")\n+              (match_operand 1 \"gpc_reg_operand\" \"r\")\n+              (match_operand:GPR 2 \"register_operand\" \"=&b\")])]\n+  \"\"\n+{\n+  rs6000_secondary_reload_gpr (operands[1], operands[0], operands[2], true);\n+  DONE;\n+})\n+\n+(define_expand \"reload_<mode>_load\"\n+  [(parallel [(match_operand 0 \"gpc_reg_operand\" \"=r\")\n+              (match_operand 1 \"memory_operand\" \"m\")\n+              (match_operand:GPR 2 \"register_operand\" \"=b\")])]\n+  \"\"\n+{\n+  rs6000_secondary_reload_gpr (operands[0], operands[1], operands[2], false);\n+  DONE;\n+})\n+\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n@@ -8537,7 +8911,27 @@\n    fmr %0,%1\n    #\n    xxlxor %x0,%x0,%x0\"\n-  [(set_attr \"type\" \"store,load,*,fpstore,fpload,fp,*,vecsimple\")])\n+  [(set_attr_alternative \"type\"\n+      [(const_string \"store\")\n+       (const_string \"load\")\n+       (const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"fpstore_u\")\n+\t   (const_string \"fpstore\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))\n+       (const_string \"fp\")\n+       (const_string \"*\")\n+       (const_string \"vecsimple\")])])\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n@@ -8569,10 +8963,10 @@\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n-(define_insn \"*movdi_mfpgpr\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*d\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,*h,r,0,*d,r\"))]\n-  \"TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS\n+(define_insn \"*movdi_internal64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,?Z,?wa,?wa,r,*h,*h,?wa,r,?*wg\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,wa,Z,wa,*h,r,0,O,*wg,r\"))]\n+  \"TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n   \"@\n@@ -8585,36 +8979,65 @@\n    stfd%U0%X0 %1,%0\n    lfd%U1%X1 %0,%1\n    fmr %0,%1\n+   stxsd%U0x %x1,%y0\n+   lxsd%U1x %x0,%y1\n+   xxlor %x0,%x1,%x1\n    mf%1 %0\n    mt%0 %1\n    nop\n+   xxlxor %x0,%x0,%x0\n    mftgpr %0,%1\n    mffgpr %0,%1\"\n-  [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,fp,mfjmpr,mtjmpr,*,mftgpr,mffgpr\")\n-   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4\")])\n-\n-(define_insn \"*movdi_internal64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,?wa\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,*h,r,0,O\"))]\n-  \"TARGET_POWERPC64 && (!TARGET_MFPGPR || !TARGET_HARD_FLOAT || !TARGET_FPRS)\n-   && (gpc_reg_operand (operands[0], DImode)\n-       || gpc_reg_operand (operands[1], DImode))\"\n-  \"@\n-   std%U0%X0 %1,%0\n-   ld%U1%X1 %0,%1\n-   mr %0,%1\n-   li %0,%1\n-   lis %0,%v1\n-   #\n-   stfd%U0%X0 %1,%0\n-   lfd%U1%X1 %0,%1\n-   fmr %0,%1\n-   mf%1 %0\n-   mt%0 %1\n-   nop\n-   xxlxor %x0,%x0,%x0\"\n-  [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,fp,mfjmpr,mtjmpr,*,vecsimple\")\n-   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4\")])\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"store_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"store_u\")\n+\t   (const_string \"store\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (const_string \"*\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"fpstore_u\")\n+\t   (const_string \"fpstore\")))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))\n+       (const_string \"fp\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (const_string \"fpstore\"))\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (const_string \"fpload\"))\n+       (const_string \"vecsimple\")\n+       (const_string \"mfjmpr\")\n+       (const_string \"mtjmpr\")\n+       (const_string \"*\")\n+       (const_string \"vecsimple\")\n+       (const_string \"mftgpr\")\n+       (const_string \"mffgpr\")])\n+   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4,4\")])\n \n ;; immediate value valid for a single instruction hiding in a const_double\n (define_insn \"\"\n@@ -8677,14 +9100,16 @@\n     FAIL;\n }\")\n \f\n-;; TImode is similar, except that we usually want to compute the address into\n-;; a register and use lsi/stsi (the exception is during reload).\n+;; TImode/PTImode is similar, except that we usually want to compute the\n+;; address into a register and use lsi/stsi (the exception is during reload).\n \n-(define_insn \"*movti_string\"\n-  [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,Y,????r,????r,????r,r\")\n-\t(match_operand:TI 1 \"input_operand\" \"r,r,Q,Y,r,n\"))]\n+(define_insn \"*mov<mode>_string\"\n+  [(set (match_operand:TI2 0 \"reg_or_mem_operand\" \"=Q,Y,????r,????r,????r,r\")\n+\t(match_operand:TI2 1 \"input_operand\" \"r,r,Q,Y,r,n\"))]\n   \"! TARGET_POWERPC64\n-   && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n+   && (<MODE>mode != TImode || VECTOR_MEM_NONE_P (TImode))\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"*\n {\n   switch (which_alternative)\n@@ -8714,27 +9139,28 @@\n    \t\t\t                  (const_string \"always\")\n \t\t\t\t\t  (const_string \"conditional\")))])\n \n-(define_insn \"*movti_ppc64\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Y,r,r\")\n-\t(match_operand:TI 1 \"input_operand\" \"r,Y,r\"))]\n-  \"(TARGET_POWERPC64 && (gpc_reg_operand (operands[0], TImode)\n-    || gpc_reg_operand (operands[1], TImode)))\n-   && VECTOR_MEM_NONE_P (TImode)\"\n+(define_insn \"*mov<mode>_ppc64\"\n+  [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"=Y,r,r\")\n+\t(match_operand:TI2 1 \"input_operand\" \"r,Y,r\"))]\n+  \"(TARGET_POWERPC64\n+   && (<MODE>mode != TImode || VECTOR_MEM_NONE_P (TImode))\n+   && (gpc_reg_operand (operands[0], <MODE>mode)\n+       || gpc_reg_operand (operands[1], <MODE>mode)))\"\n   \"#\"\n   [(set_attr \"type\" \"store,load,*\")])\n \n (define_split\n-  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:TI 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_NONE_P (TImode)\"\n+  [(set (match_operand:TI2 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:TI2 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_POWERPC64\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n   \"\n {\n   operands[2] = operand_subword_force (operands[0], WORDS_BIG_ENDIAN == 0,\n-\t\t\t\t       TImode);\n+\t\t\t\t       <MODE>mode);\n   operands[3] = operand_subword_force (operands[0], WORDS_BIG_ENDIAN != 0,\n-\t\t\t\t       TImode);\n+\t\t\t\t       <MODE>mode);\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n     {\n       operands[4] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n@@ -8750,9 +9176,9 @@\n }\")\n \n (define_split\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:TI 1 \"input_operand\" \"\"))]\n-  \"reload_completed && VECTOR_MEM_NONE_P (TImode)\n+  [(set (match_operand:TI2 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TI2 1 \"input_operand\" \"\"))]\n+  \"reload_completed\n    && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n@@ -11252,7 +11678,14 @@\n   operands[1] = gen_rtx_REG (Pmode, 0);\n   return \"st<wd>%U0%X0 %1,%0\";\n }\n-  [(set_attr \"type\" \"store\")\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t(const_string \"store_ux\")\n+\t(if_then_else\n+\t  (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t  (const_string \"store_u\")\n+\t  (const_string \"store\"))))\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"probe_stack_range<P:mode>\""}, {"sha": "17b77629fa1761ef201618b3afa6e393df6de72e", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -514,3 +514,7 @@ Use/do not use r11 to hold the static link in calls to functions via pointers.\n msave-toc-indirect\n Target Report Var(TARGET_SAVE_TOC_INDIRECT) Save\n Control whether we save the TOC in the prologue for indirect calls or generate the save inline\n+\n+mvsx-timode\n+Target Undocumented Mask(VSX_TIMODE) Var(rs6000_isa_flags)\n+; Allow/disallow TImode in VSX registers"}, {"sha": "c1d00ca2a9be5fb13c38a272b2ea4f55e32c6019", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -54,7 +54,7 @@\n (define_mode_iterator VEC_64 [V2DI V2DF])\n \n ;; Vector reload iterator\n-(define_mode_iterator VEC_R [V16QI V8HI V4SI V2DI V4SF V2DF DF TI])\n+(define_mode_iterator VEC_R [V16QI V8HI V4SI V2DI V4SF V2DF SF SD SI DF DD DI TI])\n \n ;; Base type from vector mode\n (define_mode_attr VEC_base [(V16QI \"QI\")\n@@ -249,7 +249,7 @@\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n \t(mult:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\" \"\")\n \t\t    (match_operand:VEC_F 2 \"vfloat_operand\" \"\")))]\n-  \"VECTOR_UNIT_VSX_P (<MODE>mode) || VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   if (<MODE>mode == V4SFmode && VECTOR_UNIT_ALTIVEC_P (<MODE>mode))\n     {\n@@ -395,7 +395,7 @@\n \t\t\t  (match_operand:VEC_I 5 \"vint_operand\" \"\")])\n \t (match_operand:VEC_I 1 \"vint_operand\" \"\")\n \t (match_operand:VEC_I 2 \"vint_operand\" \"\")))]\n-  \"VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n@@ -451,7 +451,7 @@\n \t\t\t  (match_operand:VEC_I 5 \"vint_operand\" \"\")])\n \t (match_operand:VEC_I 1 \"vint_operand\" \"\")\n \t (match_operand:VEC_I 2 \"vint_operand\" \"\")))]\n-  \"VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\n {\n   if (rs6000_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n@@ -505,14 +505,14 @@\n   [(set (match_operand:VEC_I 0 \"vint_operand\" \"\")\n \t(gtu:VEC_I (match_operand:VEC_I 1 \"vint_operand\" \"\")\n \t\t   (match_operand:VEC_I 2 \"vint_operand\" \"\")))]\n-  \"VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n (define_expand \"vector_geu<mode>\"\n   [(set (match_operand:VEC_I 0 \"vint_operand\" \"\")\n \t(geu:VEC_I (match_operand:VEC_I 1 \"vint_operand\" \"\")\n \t\t   (match_operand:VEC_I 2 \"vint_operand\" \"\")))]\n-  \"VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\")\n \n (define_insn_and_split \"*vector_uneq<mode>\"\n@@ -709,45 +709,55 @@\n \n \f\n ;; Vector logical instructions\n+;; Do not support TImode logical instructions on 32-bit at present, because the\n+;; compiler will see that we have a TImode and when it wanted DImode, and\n+;; convert the DImode to TImode, store it on the stack, and load it in a VSX\n+;; register.\n (define_expand \"xor<mode>3\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n         (xor:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n \t\t   (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n \n (define_expand \"ior<mode>3\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n         (ior:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n \t\t   (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n \n (define_expand \"and<mode>3\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n         (and:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n \t\t   (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n \n (define_expand \"one_cmpl<mode>2\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n         (not:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n \n (define_expand \"nor<mode>3\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n         (not:VEC_L (ior:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n \t\t\t      (match_operand:VEC_L 2 \"vlogical_operand\" \"\"))))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n \n (define_expand \"andc<mode>3\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n         (and:VEC_L (not:VEC_L (match_operand:VEC_L 2 \"vlogical_operand\" \"\"))\n \t\t   (match_operand:VEC_L 1 \"vlogical_operand\" \"\")))]\n-  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n \n ;; Same size conversions"}, {"sha": "042bb5c73d64f90e9a37f0c782add7c663bdf9b0", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 112, "deletions": 39, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -48,7 +48,7 @@\n \t\t\t(V2DF  \"vd2\")\n \t\t\t(V2DI  \"vd2\")\n \t\t\t(DF    \"d\")\n-\t\t\t(TI    \"vw4\")])\n+\t\t\t(TI    \"vd2\")])\n \n ;; Map into the appropriate suffix based on the type\n (define_mode_attr VSs\t[(V16QI \"sp\")\n@@ -59,7 +59,7 @@\n \t\t\t (V2DI  \"dp\")\n \t\t\t (DF    \"dp\")\n \t\t\t (SF\t\"sp\")\n-\t\t\t (TI    \"sp\")])\n+\t\t\t (TI    \"dp\")])\n \n ;; Map the register class used\n (define_mode_attr VSr\t[(V16QI \"v\")\n@@ -70,7 +70,7 @@\n \t\t\t (V2DF  \"wd\")\n \t\t\t (DF    \"ws\")\n \t\t\t (SF\t\"d\")\n-\t\t\t (TI    \"wd\")])\n+\t\t\t (TI    \"wt\")])\n \n ;; Map the register class used for float<->int conversions\n (define_mode_attr VSr2\t[(V2DF  \"wd\")\n@@ -115,7 +115,6 @@\n \t\t\t (V4SF  \"v\")\n \t\t\t (V2DI  \"v\")\n \t\t\t (V2DF  \"v\")\n-\t\t\t (TI    \"v\")\n \t\t\t (DF    \"s\")])\n \n ;; Appropriate type for add ops (and other simple FP ops)\n@@ -268,12 +267,13 @@\n }\n   [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecstore,vecload,vecsimple,*,*,*,vecsimple,vecsimple,*,vecstore,vecload\")])\n \n-;; Unlike other VSX moves, allow the GPRs, since a normal use of TImode is for\n-;; unions.  However for plain data movement, slightly favor the vector loads\n-(define_insn \"*vsx_movti\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,?Y,?r,?r,wa,v,v,wZ\")\n-\t(match_operand:TI 1 \"input_operand\" \"wa,Z,wa,r,Y,r,j,W,wZ,v\"))]\n-  \"VECTOR_MEM_VSX_P (TImode)\n+;; Unlike other VSX moves, allow the GPRs even for reloading, since a normal\n+;; use of TImode is for unions.  However for plain data movement, slightly\n+;; favor the vector loads\n+(define_insn \"*vsx_movti_64bit\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v, v,wZ,?Y,?r,?r\")\n+\t(match_operand:TI 1 \"input_operand\"        \"wa, Z,wa, j,W,wZ, v, r, Y, r\"))]\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n    && (register_operand (operands[0], TImode) \n        || register_operand (operands[1], TImode))\"\n {\n@@ -289,27 +289,87 @@\n       return \"xxlor %x0,%x1,%x1\";\n \n     case 3:\n+      return \"xxlxor %x0,%x0,%x0\";\n+\n     case 4:\n+      return output_vec_const_move (operands);\n+\n     case 5:\n-      return \"#\";\n+      return \"stvx %1,%y0\";\n \n     case 6:\n-      return \"xxlxor %x0,%x0,%x0\";\n+      return \"lvx %0,%y1\";\n \n     case 7:\n+    case 8:\n+    case 9:\n+      return \"#\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,vecsimple,vecstore,vecload,*,*,*\")\n+   (set_attr \"length\" \"     4,      4,        4,       4,         8,       4,      4,8,8,8\")])\n+\n+(define_insn \"*vsx_movti_32bit\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v, v,wZ,Q,Y,????r,????r,????r,r\")\n+\t(match_operand:TI 1 \"input_operand\"        \"wa, Z,wa, j,W,wZ, v,r,r,    Q,    Y,    r,n\"))]\n+  \"! TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n+   && (register_operand (operands[0], TImode)\n+       || register_operand (operands[1], TImode))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"stxvd2x %x1,%y0\";\n+\n+    case 1:\n+      return \"lxvd2x %x0,%y1\";\n+\n+    case 2:\n+      return \"xxlor %x0,%x1,%x1\";\n+\n+    case 3:\n+      return \"xxlxor %x0,%x0,%x0\";\n+\n+    case 4:\n       return output_vec_const_move (operands);\n \n-    case 8:\n+    case 5:\n       return \"stvx %1,%y0\";\n \n-    case 9:\n+    case 6:\n       return \"lvx %0,%y1\";\n \n+    case 7:\n+      if (TARGET_STRING)\n+        return \\\"stswi %1,%P0,16\\\";\n+\n+    case 8:\n+      return \\\"#\\\";\n+\n+    case 9:\n+      /* If the address is not used in the output, we can use lsi.  Otherwise,\n+\t fall through to generating four loads.  */\n+      if (TARGET_STRING\n+          && ! reg_overlap_mentioned_p (operands[0], operands[1]))\n+\treturn \\\"lswi %0,%P1,16\\\";\n+      /* ... fall through ...  */\n+\n+    case 10:\n+    case 11:\n+    case 12:\n+      return \\\"#\\\";\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,*,*,*,vecsimple,*,vecstore,vecload\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,vecsimple,vecstore,vecload,store_ux,store_ux,load_ux,load_ux, *, *\")\n+   (set_attr \"length\" \"     4,      4,        4,       4,         8,       4,      4,      16,      16,     16,     16,16,16\")\n+   (set (attr \"cell_micro\") (if_then_else (match_test \"TARGET_STRING\")\n+   \t\t\t                  (const_string \"always\")\n+\t\t\t\t\t  (const_string \"conditional\")))])\n \n ;; Explicit  load/store expanders for the builtin functions\n (define_expand \"vsx_load_<mode>\"\n@@ -319,8 +379,8 @@\n   \"\")\n \n (define_expand \"vsx_store_<mode>\"\n-  [(set (match_operand:VEC_M 0 \"memory_operand\" \"\")\n-\t(match_operand:VEC_M 1 \"vsx_register_operand\" \"\"))]\n+  [(set (match_operand:VSX_M 0 \"memory_operand\" \"\")\n+\t(match_operand:VSX_M 1 \"vsx_register_operand\" \"\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"\")\n \n@@ -1026,38 +1086,46 @@\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n \f\n-;; Logical and permute operations\n+;; Logical operations\n+;; Do not support TImode logical instructions on 32-bit at present, because the\n+;; compiler will see that we have a TImode and when it wanted DImode, and\n+;; convert the DImode to TImode, store it on the stack, and load it in a VSX\n+;; register.\n (define_insn \"*vsx_and<mode>3\"\n   [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n         (and:VSX_L\n-\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,?wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"xxland %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"*vsx_ior<mode>3\"\n   [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (ior:VSX_L (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n-\t\t   (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,?wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+        (ior:VSX_L (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t\t   (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"xxlor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"*vsx_xor<mode>3\"\n   [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n         (xor:VSX_L\n-\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,?wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"xxlxor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn \"*vsx_one_cmpl<mode>2\"\n   [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n         (not:VSX_L\n-\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"xxlnor %x0,%x1,%x1\"\n   [(set_attr \"type\" \"vecsimple\")])\n   \n@@ -1067,7 +1135,8 @@\n \t (ior:VSX_L\n \t  (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n \t  (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,?wa\"))))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"xxlnor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n@@ -1077,7 +1146,8 @@\n \t (not:VSX_L\n \t  (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,?wa\"))\n \t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"xxlandc %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n@@ -1086,11 +1156,10 @@\n \n ;; Build a V2DF/V2DI vector from two scalars\n (define_insn \"vsx_concat_<mode>\"\n-  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,?wa\")\n-\t(unspec:VSX_D\n-\t [(match_operand:<VS_scalar> 1 \"vsx_register_operand\" \"ws,wa\")\n-\t  (match_operand:<VS_scalar> 2 \"vsx_register_operand\" \"ws,wa\")]\n-\t UNSPEC_VSX_CONCAT))]\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+\t(vec_concat:VSX_D\n+\t (match_operand:<VS_scalar> 1 \"vsx_register_operand\" \"ws,wa\")\n+\t (match_operand:<VS_scalar> 2 \"vsx_register_operand\" \"ws,wa\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxpermdi %x0,%x1,%x2,0\"\n   [(set_attr \"type\" \"vecperm\")])\n@@ -1148,7 +1217,11 @@\n \t (parallel [(const_int 0)])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && WORDS_BIG_ENDIAN\"\n   \"lxsd%U1x %x0,%y1\"\n-  [(set_attr \"type\" \"fpload\")\n+  [(set (attr \"type\")\n+      (if_then_else\n+\t(match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t(const_string \"fpload_ux\")\n+\t(const_string \"fpload\")))\n    (set_attr \"length\" \"4\")])  \n \n ;; Extract a SF element from V4SF\n@@ -1212,8 +1285,8 @@\n       if (<MODE>mode != V2DImode)\n \t{\n \t  target = gen_lowpart (V2DImode, target);\n-\t  op0 = gen_lowpart (V2DImode, target);\n-\t  op1 = gen_lowpart (V2DImode, target);\n+\t  op0 = gen_lowpart (V2DImode, op0);\n+\t  op1 = gen_lowpart (V2DImode, op1);\n \t}\n     }\n   emit_insn (gen (target, op0, op1, perm0, perm1));"}, {"sha": "6729eb691fd60d88ca26cc44bd657540c46def39", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -2075,9 +2075,24 @@ VSX vector register to hold vector double data\n @item wf\n VSX vector register to hold vector float data\n \n+@item wg\n+If @option{-mmfpgpr} was used, a floating point register\n+\n+@item wl\n+If the LFIWAX instruction is enabled, a floating point register\n+\n @item ws\n VSX vector register to hold scalar float data\n \n+@item wt\n+VSX vector register to hold 128 bit integer\n+\n+@item wx\n+If the STFIWX instruction is enabled, a floating point register\n+\n+@item wz\n+If the LFIWZX instruction is enabled, a floating point register\n+\n @item wa\n Any VSX register\n "}, {"sha": "93d02bbd166f884652c8016e4e90946ac81a2f00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -1,3 +1,10 @@\n+2013-03-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/mmfpgpr.c: New test.\n+\t* gcc.target/powerpc/sd-vsx.c: Likewise.\n+\t* gcc.target/powerpc/sd-pwr6.c: Likewise.\n+\t* gcc.target/powerpc/vsx-float0.c: Likewise.\n+\n 2013-03-20  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/56355"}, {"sha": "7f2d3d3eff984ccf50a6d415e5766d23097a05e7", "filename": "gcc/testsuite/gcc.target/powerpc/mmfpgpr.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmmfpgpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmmfpgpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmmfpgpr.c?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power6x -mmfpgpr\" } */\n+/* { dg-final { scan-assembler \"mffgpr\" } } */\n+/* { dg-final { scan-assembler \"mftgpr\" } } */\n+\n+/* Test that we generate the instructions to move between the GPR and FPR\n+   registers under power6x.  */\n+\n+extern long return_long (void);\n+extern double return_double (void);\n+\n+double return_double2 (void)\n+{\n+  return (double) return_long ();\n+}\n+\n+long return_long2 (void)\n+{\n+  return (long) return_double ();\n+}"}, {"sha": "947382b7f7bcb2045b1b1e23d3654c61d78411d7", "filename": "gcc/testsuite/gcc.target/powerpc/sd-pwr6.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsd-pwr6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsd-pwr6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsd-pwr6.c?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power6 -mhard-dfp\" } */\n+/* { dg-final { scan-assembler-not   \"lfiwzx\"   } } */\n+/* { dg-final { scan-assembler-times \"lfd\"    2 } } */\n+/* { dg-final { scan-assembler-times \"dctdp\"  2 } } */\n+/* { dg-final { scan-assembler-times \"dadd\"   1 } } */\n+/* { dg-final { scan-assembler-times \"drsp\"   1 } } */\n+\n+/* Test that for power6 we need to use a bounce buffer on the stack to load\n+   SDmode variables because the power6 does not have a way to directly load\n+   32-bit values from memory.  */\n+_Decimal32 a;\n+\n+void inc_dec32 (void)\n+{\n+  a += (_Decimal32) 1.0;\n+}"}, {"sha": "7e41e1e84cc95ee82b4637de642750e4501627f8", "filename": "gcc/testsuite/gcc.target/powerpc/sd-vsx.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsd-vsx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsd-vsx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsd-vsx.c?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7 -mhard-dfp\" } */\n+/* { dg-final { scan-assembler-times \"lfiwzx\" 2 } } */\n+/* { dg-final { scan-assembler-times \"stfiwx\" 1 } } */\n+/* { dg-final { scan-assembler-not   \"lfd\"      } } */\n+/* { dg-final { scan-assembler-not   \"stfd\"     } } */\n+/* { dg-final { scan-assembler-times \"dctdp\"  2 } } */\n+/* { dg-final { scan-assembler-times \"dadd\"   1 } } */\n+/* { dg-final { scan-assembler-times \"drsp\"   1 } } */\n+\n+/* Test that power7 can directly load/store SDmode variables without using a\n+   bounce buffer.  */\n+_Decimal32 a;\n+\n+void inc_dec32 (void)\n+{\n+  a += (_Decimal32) 1.0;\n+}"}, {"sha": "7e4fea6895760af1370463b60907383fd93d2bed", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-float0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-float0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-float0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-float0.c?ref=c6d5ff8310ce6c8c675b9be815bcb091e6cb51ba", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler \"xxlxor\" } } */\n+\n+/* Test that we generate xxlor to clear a SFmode register.  */\n+\n+float sum (float *p, unsigned long n)\n+{\n+  float sum = 0.0f;\t/* generate xxlxor instead of load */\n+  while (n-- > 0)\n+    sum += *p++;\n+\n+  return sum;\n+}"}]}