{"sha": "37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdlYzYwZWQyYzk3M2FhMzgwNDRlMTllM2QxNmI1ZmExZTVjMGE2Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2008-06-21T10:36:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2008-06-21T10:36:27Z"}, "message": "typeck.c (composite_pointer_type_r, [...]): Change pedwarn to permerror.\n\n\t* typeck.c (composite_pointer_type_r, cxx_sizeof_expr,\n\tcxx_alignof_expr, check_template_keyword, cp_build_binary_op,\n\tpointer_diff, cp_build_unary_op, build_x_compound_expr_from_list,\n\tbuild_reinterpret_cast_1, cp_build_c_cast, check_return_expr): Change\n\tpedwarn to permerror.\n\t* init.c (perform_member_init, build_new_1, build_new): Likewise.\n\t* decl.c (warn_extern_redeclared_static, duplicate_decls,\n\t* identify_goto, check_previous_goto_1, check_goto, define_label,\n\tcheck_tag_decl, start_decl, check_class_member_definition_namespace,\n\tgrokfndecl, grokdeclarator): Likewise.\n\t* except.c (check_handlers): Likewise.\n\t* typeck2.c (digest_init): Likewise.\n\t* pt.c (check_specialization_namespace,\n\tcheck_explicit_instantiation_namespace,\n\tmaybe_process_partial_specialization, check_explicit_specialization,\n\tconvert_template_argument, do_decl_instantiation,\n\tdo_type_instantiation, instantiate_decl): Likewise.\n\t* semantics.c (finish_template_type_parm): Likewise.\n\t* name-lookup.c (pushdecl_maybe_friend,\n\tcheck_for_out_of_scope_variable): Likewise.\n\t* decl2.c (finish_static_data_member_decl, build_anon_union_vars,\n\tcoerce_new_type): Likewise.\n\t* parser.c (cp_parser_nested_name_specifier_opt,\n\tcp_parser_mem_initializer, cp_parser_elaborated_type_specifier,\n\tcp_parser_class_head, cp_parser_check_class_key): Likewise.\n\t(cp_parser_parameter_declaration): Check flag_permissive instead of\n\tflag_pedantic_errors.\n\t* call.c (joust): Change pedwarn to warning.\n\t* friend.c (make_friend_class): Likewise.\n\nFrom-SVN: r136999", "tree": {"sha": "cb7e944c3d3117169e18ab65ba86da1ea5ad04f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb7e944c3d3117169e18ab65ba86da1ea5ad04f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c813b1005d86bcfc33a4dfdf12cadf425191a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c813b1005d86bcfc33a4dfdf12cadf425191a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c813b1005d86bcfc33a4dfdf12cadf425191a30"}], "stats": {"total": 358, "additions": 201, "deletions": 157}, "files": [{"sha": "78f1d87a44719f0371ad5be069b081aa5c4c9011", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -1,3 +1,35 @@\n+2008-06-21  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* typeck.c (composite_pointer_type_r, cxx_sizeof_expr,\n+\tcxx_alignof_expr, check_template_keyword, cp_build_binary_op,\n+\tpointer_diff, cp_build_unary_op, build_x_compound_expr_from_list,\n+\tbuild_reinterpret_cast_1, cp_build_c_cast, check_return_expr): Change\n+\tpedwarn to permerror.\n+\t* init.c (perform_member_init, build_new_1, build_new): Likewise.\n+\t* decl.c (warn_extern_redeclared_static, duplicate_decls,\n+\t* identify_goto, check_previous_goto_1, check_goto, define_label,\n+\tcheck_tag_decl, start_decl, check_class_member_definition_namespace,\n+\tgrokfndecl, grokdeclarator): Likewise.\n+\t* except.c (check_handlers): Likewise.\n+\t* typeck2.c (digest_init): Likewise.\n+\t* pt.c (check_specialization_namespace,\n+\tcheck_explicit_instantiation_namespace,\n+\tmaybe_process_partial_specialization, check_explicit_specialization,\n+\tconvert_template_argument, do_decl_instantiation,\n+\tdo_type_instantiation, instantiate_decl): Likewise.\n+\t* semantics.c (finish_template_type_parm): Likewise.\n+\t* name-lookup.c (pushdecl_maybe_friend,\n+\tcheck_for_out_of_scope_variable): Likewise.\n+\t* decl2.c (finish_static_data_member_decl, build_anon_union_vars,\n+\tcoerce_new_type): Likewise.\n+\t* parser.c (cp_parser_nested_name_specifier_opt,\n+\tcp_parser_mem_initializer, cp_parser_elaborated_type_specifier,\n+\tcp_parser_class_head, cp_parser_check_class_key): Likewise.\n+\t(cp_parser_parameter_declaration): Check flag_permissive instead of\n+\tflag_pedantic_errors.\n+\t* call.c (joust): Change pedwarn to warning.\n+\t* friend.c (make_friend_class): Likewise.\n+\n 2008-06-16  Jan Hubicka  <jh@suse.cz>\n \n \t* method.c: Include cgraph.h."}, {"sha": "7f4c0168483d93fdd3d312385471a0164bbac02f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -6563,10 +6563,10 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t{\n \t  if (warn)\n \t    {\n-\t      pedwarn (\"\\\n-ISO C++ says that these are ambiguous, even \\\n-though the worst conversion for the first is better than \\\n-the worst conversion for the second:\");\n+\t      warning (0,\n+\t      \"ISO C++ says that these are ambiguous, even \"\n+\t      \"though the worst conversion for the first is better than \"\n+\t      \"the worst conversion for the second:\");\n \t      print_z_candidate (_(\"candidate 1:\"), w);\n \t      print_z_candidate (_(\"candidate 2:\"), l);\n \t    }"}, {"sha": "8b4e2e9d410d7656942c4187f568faed83280721", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -1055,8 +1055,8 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n     return;\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n-  pedwarn (\"%qD was declared %<extern%> and later %<static%>\", newdecl);\n-  pedwarn (\"previous declaration of %q+D\", olddecl);\n+  permerror (\"%qD was declared %<extern%> and later %<static%>\", newdecl);\n+  permerror (\"previous declaration of %q+D\", olddecl);\n }\n \n /* NEW_DECL is a redeclaration of OLD_DECL; both are functions or\n@@ -1539,9 +1539,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\tif (1 == simple_cst_equal (TREE_PURPOSE (t1),\n \t\t\t\t\t   TREE_PURPOSE (t2)))\n \t\t  {\n-\t\t    pedwarn (\"default argument given for parameter %d of %q#D\",\n-\t\t\t     i, newdecl);\n-\t\t    pedwarn (\"after previous specification in %q+#D\", olddecl);\n+\t\t    permerror (\"default argument given for parameter %d of %q#D\",\n+\t\t\t       i, newdecl);\n+\t\t    permerror (\"after previous specification in %q+#D\", olddecl);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -2458,11 +2458,11 @@ static void\n identify_goto (tree decl, const location_t *locus)\n {\n   if (decl)\n-    pedwarn (\"jump to label %qD\", decl);\n+    permerror (\"jump to label %qD\", decl);\n   else\n-    pedwarn (\"jump to case label\");\n+    permerror (\"jump to case label\");\n   if (locus)\n-    pedwarn (\"%H  from here\", locus);\n+    permerror (\"%H  from here\", locus);\n }\n \n /* Check that a single previously seen jump to a newly defined label\n@@ -2504,7 +2504,7 @@ check_previous_goto_1 (tree decl, struct cp_binding_level* level, tree names,\n \t  if (problem > 1)\n \t    error (\"  crosses initialization of %q+#D\", new_decls);\n \t  else\n-\t    pedwarn (\"  enters scope of non-POD %q+#D\", new_decls);\n+\t    permerror (\"  enters scope of non-POD %q+#D\", new_decls);\n \t}\n \n       if (b == level)\n@@ -2600,8 +2600,8 @@ check_goto (tree decl)\n   if (ent->in_try_scope || ent->in_catch_scope\n       || ent->in_omp_scope || ent->bad_decls)\n     {\n-      pedwarn (\"jump to label %q+D\", decl);\n-      pedwarn (\"  from here\");\n+      permerror (\"jump to label %q+D\", decl);\n+      permerror (\"  from here\");\n       identified = true;\n     }\n \n@@ -2619,7 +2619,7 @@ check_goto (tree decl)\n       else if (u > 1)\n \terror (\"  skips initialization of %q+#D\", b);\n       else\n-\tpedwarn (\"  enters scope of non-POD %q+#D\", b);\n+\tpermerror (\"  enters scope of non-POD %q+#D\", b);\n     }\n \n   if (ent->in_try_scope)\n@@ -2640,8 +2640,8 @@ check_goto (tree decl)\n \t    {\n \t      if (!identified)\n \t\t{\n-\t\t  pedwarn (\"jump to label %q+D\", decl);\n-\t\t  pedwarn (\"  from here\");\n+\t\t  permerror (\"jump to label %q+D\", decl);\n+\t\t  permerror (\"  from here\");\n \t\t  identified = true;\n \t\t}\n \t      error (\"  exits OpenMP structured block\");\n@@ -2693,7 +2693,7 @@ define_label (location_t location, tree name)\n     p->more_cleanups_ok = 0;\n \n   if (name == get_identifier (\"wchar_t\"))\n-    pedwarn (\"label named wchar_t\");\n+    permerror (\"label named wchar_t\");\n \n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {\n@@ -3767,8 +3767,8 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n   else if (declspecs->redefined_builtin_type)\n     {\n       if (!in_system_header)\n-\tpedwarn (\"redeclaration of C++ built-in type %qT\",\n-\t\t declspecs->redefined_builtin_type);\n+\tpermerror (\"redeclaration of C++ built-in type %qT\",\n+\t\t   declspecs->redefined_builtin_type);\n       return NULL_TREE;\n     }\n \n@@ -3781,7 +3781,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n   else if (declspecs->type == error_mark_node)\n     error_p = true;\n   if (declared_type == NULL_TREE && ! saw_friend && !error_p)\n-    pedwarn (\"declaration does not declare anything\");\n+    permerror (\"declaration does not declare anything\");\n   /* Check for an anonymous union.  */\n   else if (declared_type && RECORD_OR_UNION_CODE_P (TREE_CODE (declared_type))\n \t   && TYPE_ANONYMOUS_P (declared_type))\n@@ -4054,10 +4054,10 @@ start_decl (const cp_declarator *declarator,\n \t      if (DECL_CONTEXT (field) != context)\n \t\t{\n \t\t  if (!same_type_p (DECL_CONTEXT (field), context))\n-\t\t    pedwarn (\"ISO C++ does not permit %<%T::%D%> \"\n-\t\t\t     \"to be defined as %<%T::%D%>\",\n-\t\t\t     DECL_CONTEXT (field), DECL_NAME (decl),\n-\t\t\t     context, DECL_NAME (decl));\n+\t\t    permerror (\"ISO C++ does not permit %<%T::%D%> \"\n+\t\t\t       \"to be defined as %<%T::%D%>\",\n+\t\t\t       DECL_CONTEXT (field), DECL_NAME (decl),\n+\t\t\t       context, DECL_NAME (decl));\n \t\t  DECL_CONTEXT (decl) = DECL_CONTEXT (field);\n \t\t}\n \t      if (processing_specialization\n@@ -4110,8 +4110,8 @@ start_decl (const cp_declarator *declarator,\n \t}\n \n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n-\tpedwarn (\"declaration of %q#D outside of class is not definition\",\n-\t\t decl);\n+\tpermerror (\"declaration of %q#D outside of class is not definition\",\n+\t\t   decl);\n     }\n \n   was_public = TREE_PUBLIC (decl);\n@@ -6319,8 +6319,8 @@ check_class_member_definition_namespace (tree decl)\n      The definition for a static data member shall appear in a\n      namespace scope enclosing the member's class definition.  */\n   if (!is_ancestor (current_namespace, DECL_CONTEXT (decl)))\n-    pedwarn (\"definition of %qD is not in namespace enclosing %qT\",\n-\t     decl, DECL_CONTEXT (decl));\n+    permerror (\"definition of %qD is not in namespace enclosing %qT\",\n+\t       decl, DECL_CONTEXT (decl));\n }\n \n /* Build a PARM_DECL for the \"this\" parameter.  TYPE is the\n@@ -6553,16 +6553,16 @@ grokfndecl (tree ctype,\n \t\t/* Allow this; it's pretty common in C.  */;\n \t      else\n \t\t{\n-\t\t  pedwarn (\"non-local function %q#D uses anonymous type\",\n+\t\t  permerror (\"non-local function %q#D uses anonymous type\",\n \t\t\t      decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    pedwarn (\"%q+#D does not refer to the unqualified \"\n-\t\t\t     \"type, so it is not used for linkage\",\n-\t\t\t     TYPE_NAME (t));\n+\t\t    permerror (\"%q+#D does not refer to the unqualified \"\n+\t\t\t       \"type, so it is not used for linkage\",\n+\t\t\t       TYPE_NAME (t));\n \t\t}\n \t    }\n \t  else\n-\t    pedwarn (\"non-local function %q#D uses local type %qT\", decl, t);\n+\t    permerror (\"non-local function %q#D uses local type %qT\", decl, t);\n \t}\n     }\n \n@@ -7706,7 +7706,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t/* We've already issued an error, don't complain more.  */;\n       else if (in_system_header || flag_ms_extensions)\n \t/* Allow it, sigh.  */;\n-      else if (pedantic || ! is_main)\n+      else if (! is_main)\n+\tpermerror (\"ISO C++ forbids declaration of %qs with no type\", name);\n+      else if (pedantic)\n \tpedwarn (\"ISO C++ forbids declaration of %qs with no type\", name);\n       else\n \twarning (OPT_Wreturn_type,\n@@ -8157,7 +8159,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      explicitp = 2;\n \t\t    if (virtualp)\n \t\t      {\n-\t\t\tpedwarn (\"constructors cannot be declared virtual\");\n+\t\t\tpermerror (\"constructors cannot be declared virtual\");\n \t\t\tvirtualp = 0;\n \t\t      }\n \t\t    if (decl_context == FIELD\n@@ -8380,12 +8382,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  if (friendp)\n \t    {\n-\t      pedwarn (\"member functions are implicitly friends of their class\");\n+\t      permerror (\"member functions are implicitly friends of their class\");\n \t      friendp = 0;\n \t    }\n \t  else\n-\t    pedwarn (\"extra qualification %<%T::%> on member %qs\",\n-\t\t     ctype, name);\n+\t    permerror (\"extra qualification %<%T::%> on member %qs\",\n+\t\t       ctype, name);\n \t}\n       else if (/* If the qualifying type is already complete, then we\n \t\t  can skip the following checks.  */\n@@ -8569,9 +8571,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t    DECL_ABSTRACT (decl) = 1;\n \t}\n       else if (constructor_name_p (unqualified_id, current_class_type))\n-\tpedwarn (\"ISO C++ forbids nested type %qD with same name \"\n-\t\t \"as enclosing class\",\n-\t\t unqualified_id);\n+\tpermerror (\"ISO C++ forbids nested type %qD with same name \"\n+\t\t   \"as enclosing class\",\n+\t\t   unqualified_id);\n \n       /* If the user declares \"typedef struct {...} foo\" then the\n \t struct will have an anonymous name.  Fill that name in now.\n@@ -8694,15 +8696,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t    {\n \t      /* Don't allow friend declaration without a class-key.  */\n \t      if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n-\t\tpedwarn (\"template parameters cannot be friends\");\n+\t\tpermerror (\"template parameters cannot be friends\");\n \t      else if (TREE_CODE (type) == TYPENAME_TYPE)\n-\t\tpedwarn (\"friend declaration requires class-key, \"\n-\t\t\t \"i.e. %<friend class %T::%D%>\",\n-\t\t\t TYPE_CONTEXT (type), TYPENAME_TYPE_FULLNAME (type));\n+\t\tpermerror (\"friend declaration requires class-key, \"\n+\t\t\t   \"i.e. %<friend class %T::%D%>\",\n+\t\t\t   TYPE_CONTEXT (type), TYPENAME_TYPE_FULLNAME (type));\n \t      else\n-\t\tpedwarn (\"friend declaration requires class-key, \"\n-\t\t\t \"i.e. %<friend %#T%>\",\n-\t\t\t type);\n+\t\tpermerror (\"friend declaration requires class-key, \"\n+\t\t\t   \"i.e. %<friend %#T%>\",\n+\t\t\t   type);\n \t    }\n \n \t  /* Only try to do this stuff if we didn't already give up.  */\n@@ -8987,7 +8989,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  {\n \t    /* Friends are treated specially.  */\n \t    if (ctype == current_class_type)\n-\t      ;  /* We already issued a pedwarn.  */\n+\t      ;  /* We already issued a permerror.  */\n \t    else if (decl && DECL_NAME (decl))\n \t      {\n \t\tif (template_class_depth (current_class_type) == 0)\n@@ -9028,9 +9030,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t       the rest of the compiler does not correctly\n \t\t       handle the initialization unless the member is\n \t\t       static so we make it static below.  */\n-\t\t    pedwarn (\"ISO C++ forbids initialization of member %qD\",\n-\t\t\t     unqualified_id);\n-\t\t    pedwarn (\"making %qD static\", unqualified_id);\n+\t\t    permerror (\"ISO C++ forbids initialization of member %qD\",\n+\t\t\t       unqualified_id);\n+\t\t    permerror (\"making %qD static\", unqualified_id);\n \t\t    staticp = 1;\n \t\t  }\n \n@@ -9152,8 +9154,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t       declaring main to be static.  */\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      {\n-\t\tpedwarn (\"cannot declare member function %qD to have \"\n-\t\t\t \"static linkage\", decl);\n+\t\tpermerror (\"cannot declare member function %qD to have \"\n+\t\t\t   \"static linkage\", decl);\n \t\tinvalid_static = 1;\n \t      }\n \t    else if (current_function_decl)\n@@ -9189,8 +9191,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t    DECL_CONTEXT (decl) = ctype;\n \t    if (staticp == 1)\n \t      {\n-\t\tpedwarn (\"%<static%> may not be used when defining \"\n-\t\t\t \"(as opposed to declaring) a static data member\");\n+\t\tpermerror (\"%<static%> may not be used when defining \"\n+\t\t\t   \"(as opposed to declaring) a static data member\");\n \t\tstaticp = 0;\n \t\tstorage_class = sc_none;\n \t      }"}, {"sha": "ee229f4e87858bffac6794a9fa564b0177d6fdff", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -716,8 +716,8 @@ finish_static_data_member_decl (tree decl,\n     VEC_safe_push (tree, gc, pending_statics, decl);\n \n   if (LOCAL_CLASS_P (current_class_type))\n-    pedwarn (\"local class %q#T shall not have static data member %q#D\",\n-\t     current_class_type, decl);\n+    permerror (\"local class %q#T shall not have static data member %q#D\",\n+\t       current_class_type, decl);\n \n   /* Static consts need not be initialized in the class definition.  */\n   if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n@@ -1233,15 +1233,15 @@ build_anon_union_vars (tree type, tree object)\n \tcontinue;\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n-\t  pedwarn (\"%q+#D invalid; an anonymous union can only \"\n-\t\t   \"have non-static data members\", field);\n+\t  permerror (\"%q+#D invalid; an anonymous union can only \"\n+\t\t     \"have non-static data members\", field);\n \t  continue;\n \t}\n \n       if (TREE_PRIVATE (field))\n-\tpedwarn (\"private member %q+#D in anonymous union\", field);\n+\tpermerror (\"private member %q+#D in anonymous union\", field);\n       else if (TREE_PROTECTED (field))\n-\tpedwarn (\"protected member %q+#D in anonymous union\", field);\n+\tpermerror (\"protected member %q+#D in anonymous union\", field);\n \n       if (processing_template_decl)\n \tref = build_min_nt (COMPONENT_REF, object,\n@@ -1376,8 +1376,8 @@ coerce_new_type (tree type)\n     e = 2;\n \n   if (e == 2)\n-    pedwarn (\"%<operator new%> takes type %<size_t%> (%qT) \"\n-\t     \"as first parameter\", size_type_node);\n+    permerror (\"%<operator new%> takes type %<size_t%> (%qT) \"\n+\t       \"as first parameter\", size_type_node);\n \n   switch (e)\n   {"}, {"sha": "3070cda4d54d1d75a706e3bf1dccf581e8ca0ce6", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -1015,8 +1015,8 @@ check_handlers (tree handlers)\n \tif (tsi_end_p (i))\n \t  break;\n \tif (TREE_TYPE (handler) == NULL_TREE)\n-\t  pedwarn (\"%H%<...%> handler must be the last handler for\"\n-\t\t   \" its try block\", EXPR_LOCUS (handler));\n+\t  permerror (\"%H%<...%> handler must be the last handler for\"\n+\t\t     \" its try block\", EXPR_LOCUS (handler));\n \telse\n \t  check_handlers_1 (handler, i);\n       }"}, {"sha": "96c6dc653ba4592c7ef50ba8a2e58ea3954cf643", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -253,7 +253,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n   else if (same_type_p (type, friend_type))\n     {\n       if (complain)\n-\tpedwarn (\"class %qT is implicitly friends with itself\",\n+\twarning (0, \"class %qT is implicitly friends with itself\",\n \t\t type);\n       return;\n     }"}, {"sha": "0c38a7fcb0cf217391c4ad631eb744d9b31fe5a6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -533,11 +533,11 @@ perform_member_init (tree member, tree init)\n \t    }\n \t  /* member traversal: note it leaves init NULL */\n \t  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t    pedwarn (\"%Juninitialized reference member %qD\",\n-\t\t     current_function_decl, member);\n+\t    permerror (\"%Juninitialized reference member %qD\",\n+\t\t       current_function_decl, member);\n \t  else if (CP_TYPE_CONST_P (type))\n-\t    pedwarn (\"%Juninitialized member %qD with %<const%> type %qT\",\n-\t\t     current_function_decl, member, type);\n+\t    permerror (\"%Juninitialized member %qD with %<const%> type %qT\",\n+\t\t       current_function_decl, member, type);\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n \t/* There was an explicit member initialization.  Do some work\n@@ -2158,7 +2158,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t  else if (init)\n             {\n               if (complain & tf_error)\n-                pedwarn (\"ISO C++ forbids initialization in array new\");\n+                permerror (\"ISO C++ forbids initialization in array new\");\n               else\n                 return error_mark_node;\n             }\n@@ -2370,7 +2370,7 @@ build_new (tree placement, tree type, tree nelts, tree init,\n       if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, nelts, false))\n         {\n           if (complain & tf_error)\n-            pedwarn (\"size in array new must have integral type\");\n+            permerror (\"size in array new must have integral type\");\n           else\n             return error_mark_node;\n         }"}, {"sha": "290cb7030b537780600574e24cd3daf6d237af7f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -846,8 +846,8 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t      && TREE_CODE (decl) == TREE_CODE (x)\n \t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n \t    {\n-\t      pedwarn (\"type mismatch with previous external decl of %q#D\", x);\n-\t      pedwarn (\"previous external decl of %q+#D\", decl);\n+\t      permerror (\"type mismatch with previous external decl of %q#D\", x);\n+\t      permerror (\"previous external decl of %q+#D\", decl);\n \t    }\n \t}\n \n@@ -1165,17 +1165,27 @@ check_for_out_of_scope_variable (tree decl)\n \n   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     {\n-      error (\"name lookup of %qD changed for new ISO %<for%> scoping\",\n+      error (\"name lookup of %qD changed for ISO %<for%> scoping\",\n \t     DECL_NAME (decl));\n       error (\"  cannot use obsolete binding at %q+D because \"\n \t     \"it has a destructor\", decl);\n       return error_mark_node;\n     }\n   else\n     {\n-      pedwarn (\"name lookup of %qD changed for new ISO %<for%> scoping\",\n-\t       DECL_NAME (decl));\n-      pedwarn (\"  using obsolete binding at %q+D\", decl);\n+      permerror (\"name lookup of %qD changed for ISO %<for%> scoping\",\n+\t         DECL_NAME (decl));\n+      if (flag_permissive)\n+        permerror (\"  using obsolete binding at %q+D\", decl);\n+      else\n+\t{\n+\t  static bool hint;\n+\t  if (!hint)\n+\t    {\n+\t      inform (\"(if you use %<-fpermissive%> G++ will accept your code)\");\n+\t      hint = true;\n+\t    }\n+\t}\n     }\n \n   return decl;"}, {"sha": "81cd03fc86388b4ef9babc67625a4a556555a18e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -4111,10 +4111,10 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t  && !(TREE_CODE (new_scope) == TYPENAME_TYPE\n \t       && (TREE_CODE (TYPENAME_TYPE_FULLNAME (new_scope))\n \t\t   == TEMPLATE_ID_EXPR)))\n-\tpedwarn (TYPE_P (new_scope)\n-\t\t ? \"%qT is not a template\"\n-\t\t : \"%qD is not a template\",\n-\t\t new_scope);\n+\tpermerror (TYPE_P (new_scope)\n+\t\t   ? \"%qT is not a template\"\n+\t\t   : \"%qD is not a template\",\n+\t\t   new_scope);\n       /* If it is a class scope, try to complete it; we are about to\n \t be looking up names inside the class.  */\n       if (TYPE_P (new_scope)\n@@ -8928,7 +8928,7 @@ cp_parser_mem_initializer (cp_parser* parser)\n   /* Find out what is being initialized.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      pedwarn (\"anachronistic old-style base class initializer\");\n+      permerror (\"anachronistic old-style base class initializer\");\n       mem_initializer_id = NULL_TREE;\n     }\n   else\n@@ -9845,7 +9845,7 @@ cp_parser_template_id (cp_parser *parser,\n \t  static bool hint;\n \t  if (!hint)\n \t    {\n-\t      inform (\"(if you use -fpermissive G++ will accept your code)\");\n+\t      inform (\"(if you use %<-fpermissive%> G++ will accept your code)\");\n \t      hint = true;\n \t    }\n \t}\n@@ -11186,7 +11186,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       tag_type = typename_type;\n       /* The `typename' keyword is only allowed in templates.  */\n       if (!processing_template_decl)\n-\tpedwarn (\"using %<typename%> outside of template\");\n+\tpermerror (\"using %<typename%> outside of template\");\n     }\n   /* Otherwise it must be a class-key.  */\n   else\n@@ -13865,7 +13865,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \n       if (!parser->default_arg_ok_p)\n \t{\n-\t  if (!flag_pedantic_errors)\n+\t  if (flag_permissive)\n \t    warning (0, \"deprecated use of default argument for parameter of non-function\");\n \t  else\n \t    {\n@@ -14758,7 +14758,7 @@ cp_parser_class_head (cp_parser* parser,\n \t class member of a namespace outside of its namespace.  */\n       if (scope == nested_name_specifier)\n \t{\n-\t  pedwarn (\"extra qualification ignored\");\n+\t  permerror (\"extra qualification not allowed\");\n \t  nested_name_specifier = NULL_TREE;\n \t  num_templates = 0;\n \t}\n@@ -18121,7 +18121,7 @@ static void\n cp_parser_check_class_key (enum tag_types class_key, tree type)\n {\n   if ((TREE_CODE (type) == UNION_TYPE) != (class_key == union_type))\n-    pedwarn (\"%qs tag used in naming %q#T\",\n+    permerror (\"%qs tag used in naming %q#T\",\n \t    class_key == union_type ? \"union\"\n \t     : class_key == record_type ? \"struct\" : \"class\",\n \t     type);"}, {"sha": "9926f3d834fd553abfef9d5f375ce38785ba7e4e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -710,8 +710,8 @@ check_specialization_namespace (tree tmpl)\n     return true;\n   else\n     {\n-      pedwarn (\"specialization of %qD in different namespace\", tmpl);\n-      pedwarn (\"  from definition of %q+#D\", tmpl);\n+      permerror (\"specialization of %qD in different namespace\", tmpl);\n+      permerror (\"  from definition of %q+#D\", tmpl);\n       return false;\n     }\n }\n@@ -728,9 +728,9 @@ check_explicit_instantiation_namespace (tree spec)\n      namespace of its template.  */\n   ns = decl_namespace_context (spec);\n   if (!is_ancestor (current_namespace, ns))\n-    pedwarn (\"explicit instantiation of %qD in namespace %qD \"\n-\t     \"(which does not enclose namespace %qD)\",\n-\t     spec, current_namespace, ns);\n+    permerror (\"explicit instantiation of %qD in namespace %qD \"\n+\t       \"(which does not enclose namespace %qD)\",\n+\t       spec, current_namespace, ns);\n }\n \n /* The TYPE is being declared.  If it is a template type, that means it\n@@ -811,9 +811,9 @@ maybe_process_partial_specialization (tree type)\n \t  if (current_namespace\n \t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n \t    {\n-\t      pedwarn (\"specializing %q#T in different namespace\", type);\n-\t      pedwarn (\"  from definition of %q+#D\",\n-\t\t       CLASSTYPE_TI_TEMPLATE (type));\n+\t      permerror (\"specializing %q#T in different namespace\", type);\n+\t      permerror (\"  from definition of %q+#D\",\n+\t\t         CLASSTYPE_TI_TEMPLATE (type));\n \t    }\n \n \t  /* Check for invalid specialization after instantiation:\n@@ -2006,7 +2006,7 @@ check_explicit_specialization (tree declarator,\n       for (; t; t = TREE_CHAIN (t))\n \tif (TREE_PURPOSE (t))\n \t  {\n-\t    pedwarn\n+\t    permerror\n \t      (\"default argument specified in explicit specialization\");\n \t    break;\n \t  }\n@@ -4942,8 +4942,8 @@ convert_template_argument (tree parm,\n   if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n     {\n-      pedwarn (\"to refer to a type member of a template parameter, \"\n-\t       \"use %<typename %E%>\", orig_arg);\n+      permerror (\"to refer to a type member of a template parameter, \"\n+\t         \"use %<typename %E%>\", orig_arg);\n \n       orig_arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\t     TREE_OPERAND (arg, 1),\n@@ -14567,7 +14567,7 @@ do_decl_instantiation (tree decl, tree storage)\n \t the first instantiation was `extern' and the second is not,\n \t and EXTERN_P for the opposite case.  */\n       if (DECL_NOT_REALLY_EXTERN (result) && !extern_p)\n-\tpedwarn (\"duplicate explicit instantiation of %q#D\", result);\n+\tpermerror (\"duplicate explicit instantiation of %q#D\", result);\n       /* If an \"extern\" explicit instantiation follows an ordinary\n \t explicit instantiation, the template is instantiated.  */\n       if (extern_p)\n@@ -14580,7 +14580,7 @@ do_decl_instantiation (tree decl, tree storage)\n     }\n   else if (!DECL_TEMPLATE_INFO (result))\n     {\n-      pedwarn (\"explicit instantiation of non-template %q#D\", result);\n+      permerror (\"explicit instantiation of non-template %q#D\", result);\n       return;\n     }\n \n@@ -14721,7 +14721,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n       if (!previous_instantiation_extern_p && !extern_p\n \t  && (complain & tf_error))\n-\tpedwarn (\"duplicate explicit instantiation of %q#T\", t);\n+\tpermerror (\"duplicate explicit instantiation of %q#T\", t);\n \n       /* If we've already instantiated the template, just return now.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t))\n@@ -15168,7 +15168,7 @@ instantiate_decl (tree d, int defer_ok,\n \t   member function or static data member of a class template\n \t   shall be present in every translation unit in which it is\n \t   explicitly instantiated.  */\n-\tpedwarn\n+\tpermerror\n \t  (\"explicit instantiation of %qD but no definition available\", d);\n \n       /* ??? Historically, we have instantiated inline functions, even"}, {"sha": "2400aeb37da258d4ee4ef16ae767cc53d336efc9", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -2170,7 +2170,7 @@ finish_template_type_parm (tree aggr, tree identifier)\n {\n   if (aggr != class_type_node)\n     {\n-      pedwarn (\"template type parameters must use the keyword %<class%> or %<typename%>\");\n+      permerror (\"template type parameters must use the keyword %<class%> or %<typename%>\");\n       aggr = class_type_node;\n     }\n "}, {"sha": "8fd3be2c68dd302075c2f7755871bfc768cf9ac9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -435,9 +435,9 @@ composite_pointer_type_r (tree t1, tree t2, const char* location,\n   else\n     {\n       if (complain & tf_error)\n-\tpedwarn (\"%s between distinct pointer types %qT and %qT \"\n-\t\t \"lacks a cast\",\n-\t\t location, t1, t2);\n+\tpermerror (\"%s between distinct pointer types %qT and %qT \"\n+\t\t   \"lacks a cast\",\n+\t\t   location, t1, t2);\n       result_type = void_type_node;\n     }\n   result_type = cp_build_qualified_type (result_type,\n@@ -450,9 +450,9 @@ composite_pointer_type_r (tree t1, tree t2, const char* location,\n       if (!same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n \t\t\tTYPE_PTRMEM_CLASS_TYPE (t2))\n \t  && (complain & tf_error))\n-\tpedwarn (\"%s between distinct pointer types %qT and %qT \"\n-\t\t \"lacks a cast\",\n-\t\t location, t1, t2);\n+\tpermerror (\"%s between distinct pointer types %qT and %qT \"\n+\t\t   \"lacks a cast\",\n+\t\t   location, t1, t2);\n       result_type = build_ptrmem_type (TYPE_PTRMEM_CLASS_TYPE (t1),\n \t\t\t\t       result_type);\n     }\n@@ -1355,8 +1355,8 @@ cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n   else if (is_overloaded_fn (e))\n     {\n       if (complain & tf_error)\n-        pedwarn (\"ISO C++ forbids applying %<sizeof%> to an expression of \"\n-                 \"function type\");\n+        permerror (\"ISO C++ forbids applying %<sizeof%> to an expression of \"\n+                   \"function type\");\n       else\n         return error_mark_node;\n       e = char_type_node;\n@@ -1415,8 +1415,8 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)\n   else if (is_overloaded_fn (e))\n     {\n       if (complain & tf_error)\n-        pedwarn (\"ISO C++ forbids applying %<__alignof%> to an expression of \"\n-                 \"function type\");\n+        permerror (\"ISO C++ forbids applying %<__alignof%> to an expression of \"\n+                   \"function type\");\n       else\n         return error_mark_node;\n       if (TREE_CODE (e) == FUNCTION_DECL)\n@@ -2146,7 +2146,7 @@ check_template_keyword (tree decl)\n       && TREE_CODE (decl) != TEMPLATE_ID_EXPR)\n     {\n       if (!is_overloaded_fn (decl))\n-\tpedwarn (\"%qD is not a template\", decl);\n+\tpermerror (\"%qD is not a template\", decl);\n       else\n \t{\n \t  tree fns;\n@@ -2166,7 +2166,7 @@ check_template_keyword (tree decl)\n \t      fns = OVL_NEXT (fns);\n \t    }\n \t  if (!fns)\n-\t    pedwarn (\"%qD is not a template\", decl);\n+\t    permerror (\"%qD is not a template\", decl);\n \t}\n     }\n }\n@@ -3258,8 +3258,8 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (t != error_mark_node)\n \t{\n \t  if (complain & tf_error)\n-\t    pedwarn (\"assuming cast to type %qT from overloaded function\",\n-\t\t     TREE_TYPE (t));\n+\t    permerror (\"assuming cast to type %qT from overloaded function\",\n+\t\t       TREE_TYPE (t));\n \t  op0 = t;\n \t}\n     }\n@@ -3269,8 +3269,8 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (t != error_mark_node)\n \t{\n \t  if (complain & tf_error)\n-\t    pedwarn (\"assuming cast to type %qT from overloaded function\",\n-\t\t     TREE_TYPE (t));\n+\t    permerror (\"assuming cast to type %qT from overloaded function\",\n+\t\t       TREE_TYPE (t));\n \t  op1 = t;\n \t}\n     }\n@@ -3544,15 +3544,15 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t{\n \t  result_type = type0;\n \t  if (complain & tf_error) \n-            pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+            permerror (\"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n \t  if (complain & tf_error)\n-\t    pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+\t    permerror (\"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n@@ -3732,15 +3732,15 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t{\n \t  result_type = type0;\n \t  if (complain & tf_error)\n-\t    pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+\t    permerror (\"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n \t  if (complain & tf_error)\n-\t    pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+\t    permerror (\"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n@@ -4111,11 +4111,11 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n   if (pedantic || warn_pointer_arith)\n     {\n       if (TREE_CODE (target_type) == VOID_TYPE)\n-\tpedwarn (\"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n+\tpermerror (\"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n       if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-\tpedwarn (\"ISO C++ forbids using pointer to a function in subtraction\");\n+\tpermerror (\"ISO C++ forbids using pointer to a function in subtraction\");\n       if (TREE_CODE (target_type) == METHOD_TYPE)\n-\tpedwarn (\"ISO C++ forbids using pointer to a method in subtraction\");\n+\tpermerror (\"ISO C++ forbids using pointer to a method in subtraction\");\n     }\n \n   /* First do the subtraction as integers;\n@@ -4481,9 +4481,9 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \tif (TREE_CODE (argtype) == ENUMERAL_TYPE)\n           {\n             if (complain & tf_error)\n-              pedwarn ((code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-                       ? G_(\"ISO C++ forbids incrementing an enum\")\n-                       : G_(\"ISO C++ forbids decrementing an enum\"));\n+              permerror ((code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n+                         ? G_(\"ISO C++ forbids incrementing an enum\")\n+                         : G_(\"ISO C++ forbids decrementing an enum\"));\n             else\n               return error_mark_node;\n           }\n@@ -4509,11 +4509,11 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t\t     && !TYPE_PTROB_P (argtype)) \n               {\n                 if (complain & tf_error)\n-                  pedwarn ((code == PREINCREMENT_EXPR\n-                            || code == POSTINCREMENT_EXPR)\n-                           ? G_(\"ISO C++ forbids incrementing a pointer of type %qT\")\n-                           : G_(\"ISO C++ forbids decrementing a pointer of type %qT\"),\n-                           argtype);\n+                  permerror ((code == PREINCREMENT_EXPR\n+                              || code == POSTINCREMENT_EXPR)\n+                             ? G_(\"ISO C++ forbids incrementing a pointer of type %qT\")\n+                             : G_(\"ISO C++ forbids decrementing a pointer of type %qT\"),\n+                             argtype);\n                 else\n                   return error_mark_node;\n               }\n@@ -4570,7 +4570,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n         {\n           /* ARM $3.4 */\n           if (complain & tf_error)\n-            pedwarn (\"ISO C++ forbids taking address of function %<::main%>\");\n+            permerror (\"ISO C++ forbids taking address of function %<::main%>\");\n           else\n             return error_mark_node;\n         }\n@@ -4631,15 +4631,15 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t      else if (current_class_type\n                        && TREE_OPERAND (arg, 0) == current_class_ref)\n                   /* An expression like &memfn.  */\n-                pedwarn (\"ISO C++ forbids taking the address of an unqualified\"\n-                         \" or parenthesized non-static member function to form\"\n-                         \" a pointer to member function.  Say %<&%T::%D%>\",\n-                         base, name);\n+                permerror (\"ISO C++ forbids taking the address of an unqualified\"\n+                           \" or parenthesized non-static member function to form\"\n+                           \" a pointer to member function.  Say %<&%T::%D%>\",\n+                           base, name);\n \t      else\n-\t\tpedwarn (\"ISO C++ forbids taking the address of a bound member\"\n-\t\t\t \" function to form a pointer to member function.\"\n-\t\t\t \"  Say %<&%T::%D%>\",\n-\t\t\t base, name);\n+\t\tpermerror (\"ISO C++ forbids taking the address of a bound member\"\n+\t\t\t   \" function to form a pointer to member function.\"\n+\t\t\t   \"  Say %<&%T::%D%>\",\n+\t\t\t   base, name);\n \t    }\n \t  arg = build_offset_ref (base, fn, /*address_p=*/true);\n \t}\n@@ -4665,7 +4665,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t  if (! lvalue_p (arg) && (pedantic || complain == tf_none))\n             {\n               if (complain & tf_error)\n-                pedwarn (\"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n+                permerror (\"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n               else\n                 return error_mark_node;\n             }\n@@ -5010,7 +5010,7 @@ tree build_x_compound_expr_from_list (tree list, const char *msg)\n   if (TREE_CHAIN (list))\n     {\n       if (msg)\n-\tpedwarn (\"%s expression list treated as compound expression\", msg);\n+\tpermerror (\"%s expression list treated as compound expression\", msg);\n \n       for (list = TREE_CHAIN (list); list; list = TREE_CHAIN (list))\n \texpr = build_x_compound_expr (expr, TREE_VALUE (list), \n@@ -5561,8 +5561,8 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n         {\n           if (complain & tf_error)\n-            pedwarn (\"cast from %qT to %qT loses precision\",\n-                     intype, type);\n+            permerror (\"cast from %qT to %qT loses precision\",\n+                       intype, type);\n           else\n             return error_mark_node;\n         }\n@@ -5838,7 +5838,7 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n           if (complain & tf_error)\n-            pedwarn (\"ISO C++ forbids casting to an array type %qT\", type);\n+            permerror (\"ISO C++ forbids casting to an array type %qT\", type);\n           else\n             return error_mark_node;\n \t  type = build_pointer_type (TREE_TYPE (type));\n@@ -6964,8 +6964,8 @@ check_return_expr (tree retval, bool *no_warning)\n      that's supposed to return a value.  */\n   if (!retval && fn_returns_value_p)\n     {\n-      pedwarn (\"return-statement with no value, in function returning %qT\",\n-\t       valtype);\n+      permerror (\"return-statement with no value, in function returning %qT\",\n+\t         valtype);\n       /* Clear this, so finish_function won't say that we reach the\n \t end of a non-void function (which we don't, we gave a\n \t return!).  */\n@@ -6985,8 +6985,8 @@ check_return_expr (tree retval, bool *no_warning)\n \t   its side-effects.  */\n \t  finish_expr_stmt (retval);\n       else\n-\tpedwarn (\"return-statement with a value, in function \"\n-\t\t \"returning 'void'\");\n+\tpermerror (\"return-statement with a value, in function \"\n+\t\t   \"returning 'void'\");\n \n       current_function_returns_null = 1;\n "}, {"sha": "05e88b9002ecd95d7c91a65bcdafc9ba960e786c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=37ec60ed2c973aa38044e19e3d16b5fa1e5c0a6b", "patch": "@@ -694,7 +694,7 @@ digest_init (tree type, tree init)\n \t\t counted in the length of the constant, but in C++ this would\n \t\t be invalid.  */\n \t      if (size < TREE_STRING_LENGTH (init))\n-\t\tpedwarn (\"initializer-string for array of chars is too long\");\n+\t\tpermerror (\"initializer-string for array of chars is too long\");\n \t    }\n \t  return init;\n \t}"}]}