{"sha": "b0ff8d7af505e40e4bbb82f31604b99b59f67231", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmZjhkN2FmNTA1ZTQwZTRiYmI4MmYzMTYwNGI5OWI1OWY2NzIzMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-11-25T10:34:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-11-25T10:34:11Z"}, "message": "re PR middle-end/38151 (structures with _Complex arguments are not passed correctly)\n\n2008-11-25  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/38151\n\tPR middle-end/38236\n\t* tree-ssa-alias.c (struct alias_info): Remove written_vars.\n\tRemove dereferenced_ptrs_store and dereferenced_ptrs_load\n\tin favor of dereferenced_ptrs.\n\t(init_alias_info): Adjust.\n\t(delete_alias_info): Likewise.\n\t(compute_flow_insensitive_aliasing): Properly\n\tinclude all aliased variables.\n\t(update_alias_info_1): Use dereferenced_ptrs.\n\t(setup_pointers_and_addressables): Likewise.\n\t(get_smt_for): Honor ref-all pointers and pointers with known alias\n\tset properly.\n\t* config/i386/i386.c (ix86_gimplify_va_arg): Use ref-all pointers.\n\n\t* gcc.c-torture/execute/pr38151.c: New testcase.\n\t* gcc.c-torture/execute/pr38236.c: Likewise.\n\nFrom-SVN: r142189", "tree": {"sha": "66195ff5e829f7ad937e47fa9dff36f5dc63057b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66195ff5e829f7ad937e47fa9dff36f5dc63057b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0ff8d7af505e40e4bbb82f31604b99b59f67231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ff8d7af505e40e4bbb82f31604b99b59f67231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ff8d7af505e40e4bbb82f31604b99b59f67231", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ff8d7af505e40e4bbb82f31604b99b59f67231/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "abb370e4618c535561f2b8e942aaeb41114fdfd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abb370e4618c535561f2b8e942aaeb41114fdfd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abb370e4618c535561f2b8e942aaeb41114fdfd0"}], "stats": {"total": 188, "additions": 130, "deletions": 58}, "files": [{"sha": "148e7b2f3094e707190568189cf502859f8c4489", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0ff8d7af505e40e4bbb82f31604b99b59f67231", "patch": "@@ -1,3 +1,20 @@\n+2008-11-25  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/38151\n+\tPR middle-end/38236\n+\t* tree-ssa-alias.c (struct alias_info): Remove written_vars.\n+\tRemove dereferenced_ptrs_store and dereferenced_ptrs_load\n+\tin favor of dereferenced_ptrs.\n+\t(init_alias_info): Adjust.\n+\t(delete_alias_info): Likewise.\n+\t(compute_flow_insensitive_aliasing): Properly\n+\tinclude all aliased variables.\n+\t(update_alias_info_1): Use dereferenced_ptrs.\n+\t(setup_pointers_and_addressables): Likewise.\n+\t(get_smt_for): Honor ref-all pointers and pointers with known alias\n+\tset properly.\n+\t* config/i386/i386.c (ix86_gimplify_va_arg): Use ref-all pointers.\n+\n 2008-11-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/38254"}, {"sha": "8f4680db4bc08d69830c03d70fc991ebfe026f02", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b0ff8d7af505e40e4bbb82f31604b99b59f67231", "patch": "@@ -6753,6 +6753,8 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t      enum machine_mode mode = GET_MODE (reg);\n \t      tree piece_type = lang_hooks.types.type_for_mode (mode, 1);\n \t      tree addr_type = build_pointer_type (piece_type);\n+\t      tree daddr_type = build_pointer_type_for_mode (piece_type,\n+\t\t\t\t\t\t\t     ptr_mode, true);\n \t      tree src_addr, src;\n \t      int src_offset;\n \t      tree dest_addr, dest;\n@@ -6772,8 +6774,8 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t\t\t\t      size_int (src_offset));\n \t      src = build_va_arg_indirect_ref (src_addr);\n \n-\t      dest_addr = fold_convert (addr_type, addr);\n-\t      dest_addr = fold_build2 (POINTER_PLUS_EXPR, addr_type, dest_addr,\n+\t      dest_addr = fold_convert (daddr_type, addr);\n+\t      dest_addr = fold_build2 (POINTER_PLUS_EXPR, daddr_type, dest_addr,\n \t\t\t\t       size_int (INTVAL (XEXP (slot, 1))));\n \t      dest = build_va_arg_indirect_ref (dest_addr);\n "}, {"sha": "860fa8c4e99733fb939cdad91fcc6dcffface106", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b0ff8d7af505e40e4bbb82f31604b99b59f67231", "patch": "@@ -1,3 +1,10 @@\n+2008-11-25  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/38151\n+\tPR middle-end/38236\n+\t* gcc.c-torture/execute/pr38151.c: New testcase.\n+\t* gcc.c-torture/execute/pr38236.c: Likewise.\n+\n 2008-11-24  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* g++.dg/eh/weak1.C: Don't xfail hppa*64*-*-*."}, {"sha": "113a255b15e9ae62929aeeec25abb928ea65444c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr38151.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr38151.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr38151.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr38151.c?ref=b0ff8d7af505e40e4bbb82f31604b99b59f67231", "patch": "@@ -0,0 +1,46 @@\n+void abort (void);\n+\n+struct S2848\n+{\n+  unsigned int a;\n+  _Complex int b;\n+  struct\n+  {\n+  } __attribute__ ((aligned)) c;\n+};\n+\n+struct S2848 s2848;\n+\n+int fails;\n+\n+void  __attribute__((noinline))\n+check2848va (int z, ...)\n+{\n+  struct S2848 arg;\n+  __builtin_va_list ap;\n+\n+  __builtin_va_start (ap, z);\n+\n+  arg = __builtin_va_arg (ap, struct S2848);\n+\n+  if (s2848.a != arg.a)\n+    ++fails;\n+  if (s2848.b != arg.b)\n+    ++fails;\n+\n+  __builtin_va_end (ap);\n+}\n+\n+int main (void)\n+{\n+  s2848.a = 4027477739U;\n+  s2848.b = (723419448 + -218144346 * __extension__ 1i);\n+\n+  check2848va (1, s2848);\n+\n+  if (fails)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "d781542c7ccab5590b7ff1885ad4889aa215d1f5", "filename": "gcc/testsuite/gcc.c-torture/execute/pr38236.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr38236.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr38236.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr38236.c?ref=b0ff8d7af505e40e4bbb82f31604b99b59f67231", "patch": "@@ -0,0 +1,22 @@\n+struct X { int i; };\n+\n+int __attribute__((noinline))\n+foo (struct X *p, int *q, int a, int b)\n+{\n+  struct X x, y;\n+  if (a)\n+    p = &x;\n+  if (b)\n+    q = &x.i;\n+  else\n+    q = &y.i;\n+  *q = 1;\n+  return p->i; \n+}\n+extern void abort (void);\n+int main()\n+{\n+  if (foo((void *)0, (void *)0, 1, 1) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "6155809631dbc793d8441101e8e18cb3dbd46f27", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff8d7af505e40e4bbb82f31604b99b59f67231/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b0ff8d7af505e40e4bbb82f31604b99b59f67231", "patch": "@@ -188,15 +188,8 @@ struct alias_info\n   struct alias_map_d **pointers;\n   size_t num_pointers;\n \n-  /* Variables that have been written to directly (i.e., not through a\n-     pointer dereference).  */\n-  struct pointer_set_t *written_vars;\n-\n-  /* Pointers that have been used in an indirect store operation.  */\n-  struct pointer_set_t *dereferenced_ptrs_store;\n-\n-  /* Pointers that have been used in an indirect load operation.  */\n-  struct pointer_set_t *dereferenced_ptrs_load;\n+  /* Pointers that have been used in an indirect load/store operation.  */\n+  struct pointer_set_t *dereferenced_ptrs;\n };\n \n \n@@ -2073,9 +2066,7 @@ init_alias_info (void)\n   ai->ssa_names_visited = sbitmap_alloc (num_ssa_names);\n   sbitmap_zero (ai->ssa_names_visited);\n   ai->processed_ptrs = VEC_alloc (tree, heap, 50);\n-  ai->written_vars = pointer_set_create ();\n-  ai->dereferenced_ptrs_store = pointer_set_create ();\n-  ai->dereferenced_ptrs_load = pointer_set_create ();\n+  ai->dereferenced_ptrs = pointer_set_create ();\n \n   /* Clear out all memory reference stats.  */\n   init_mem_ref_stats ();\n@@ -2123,9 +2114,7 @@ delete_alias_info (struct alias_info *ai)\n     free (ai->pointers[i]);\n   free (ai->pointers);\n \n-  pointer_set_destroy (ai->written_vars);\n-  pointer_set_destroy (ai->dereferenced_ptrs_store);\n-  pointer_set_destroy (ai->dereferenced_ptrs_load);\n+  pointer_set_destroy (ai->dereferenced_ptrs);\n   free (ai);\n \n   delete_mem_ref_stats (cfun);\n@@ -2361,23 +2350,18 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t{\n \t  struct alias_map_d *v_map;\n \t  var_ann_t v_ann;\n-\t  bool tag_stored_p, var_stored_p;\n \t  \n \t  v_map = ai->addressable_vars[j];\n \t  var = v_map->var;\n \t  v_ann = var_ann (var);\n \n-\t  /* Skip memory tags and variables that have never been\n-\t     written to.  We also need to check if the variables are\n-\t     call-clobbered because they may be overwritten by\n-\t     function calls.  */\n-\t  tag_stored_p = pointer_set_contains (ai->written_vars, tag)\n-\t                 || is_call_clobbered (tag);\n-\t  var_stored_p = pointer_set_contains (ai->written_vars, var)\n-\t                 || is_call_clobbered (var);\n-\t  if (!tag_stored_p && !var_stored_p)\n-\t    continue;\n-\t     \n+\t  /* We used to skip variables that have never been written to\n+\t     if the memory tag has been never written to directly (or\n+\t     either of them were call clobbered).  This is not enough\n+\t     though, as this misses writes through the tags aliases.\n+\t     So, for correctness we need to include any aliased\n+\t     variable here.  */\n+\n \t  if (may_alias_p (p_map->var, p_map->set, var, v_map->set, false))\n \t    {\n \t      /* Add VAR to TAG's may-aliases set.  */\n@@ -2618,13 +2602,8 @@ update_alias_info_1 (gimple stmt, struct alias_info *ai)\n \t  /* ???  For always executed direct dereferences we can\n \t     apply TBAA-pruning to their escape set.  */\n \n-\t  /* If this is a store operation, mark OP as being\n-\t     dereferenced to store, otherwise mark it as being\n-\t     dereferenced to load.  */\n-\t  if (num_stores > 0)\n-\t    pointer_set_insert (ai->dereferenced_ptrs_store, var);\n-\t  else\n-\t    pointer_set_insert (ai->dereferenced_ptrs_load, var);\n+\t  /* Mark OP as being dereferenced.  */\n+\t  pointer_set_insert (ai->dereferenced_ptrs, var);\n \n \t  /* Update the frequency estimate for all the dereferences of\n \t     pointer OP.  */\n@@ -2649,7 +2628,7 @@ update_alias_info_1 (gimple stmt, struct alias_info *ai)\n \t  if (is_gimple_call (stmt)\n \t      || stmt_escape_type == ESCAPE_STORED_IN_GLOBAL)\n \t    {\n-\t      pointer_set_insert (ai->dereferenced_ptrs_store, var);\n+\t      pointer_set_insert (ai->dereferenced_ptrs, var);\n \t      pi->memory_tag_needed = 1;\n \t    }\n \t}\n@@ -2667,17 +2646,6 @@ update_alias_info_1 (gimple stmt, struct alias_info *ai)\n \n       mem_ref_stats->num_mem_stmts++;\n \n-      /* Add all decls written to to the list of written variables.  */\n-      if (gimple_has_lhs (stmt)\n-\t  && TREE_CODE (gimple_get_lhs (stmt)) != SSA_NAME)\n-\t{\n-\t  tree lhs = gimple_get_lhs (stmt);\n-\t  while (handled_component_p (lhs))\n-\t    lhs = TREE_OPERAND (lhs, 0);\n-\t  if (DECL_P (lhs))\n-\t    pointer_set_insert (ai->written_vars, lhs);\n-\t}\n-\n       /* Notice that we only update memory reference stats for symbols\n \t loaded and stored by the statement if the statement does not\n \t contain pointer dereferences and it is not a call/asm site.\n@@ -2770,7 +2738,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t  /* Since we don't keep track of volatile variables, assume that\n \t     these pointers are used in indirect store operations.  */\n \t  if (TREE_THIS_VOLATILE (var))\n-\t    pointer_set_insert (ai->dereferenced_ptrs_store, var);\n+\t    pointer_set_insert (ai->dereferenced_ptrs, var);\n \n \t  num_pointers++;\n \t}\n@@ -2845,8 +2813,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          array and create a symbol memory tag for them.  */\n       if (POINTER_TYPE_P (TREE_TYPE (var)))\n \t{\n-\t  if ((pointer_set_contains (ai->dereferenced_ptrs_store, var)\n-\t       || pointer_set_contains (ai->dereferenced_ptrs_load, var)))\n+\t  if (pointer_set_contains (ai->dereferenced_ptrs, var))\n \t    {\n \t      tree tag, old_tag;\n \t      var_ann_t t_ann;\n@@ -2872,11 +2839,6 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n \t      /* Associate the tag with pointer VAR.  */\n \t      set_symbol_mem_tag (var, tag);\n-\n-\t      /* If pointer VAR has been used in a store operation,\n-\t\t then its memory tag must be marked as written-to.  */\n-\t      if (pointer_set_contains (ai->dereferenced_ptrs_store, var))\n-\t\tpointer_set_insert (ai->written_vars, tag);\n \t    }\n \t  else\n \t    {\n@@ -3298,7 +3260,22 @@ get_smt_for (tree ptr, struct alias_info *ai)\n   size_t i;\n   tree tag;\n   tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n-  alias_set_type tag_set = get_alias_set (tag_type);\n+  alias_set_type tag_set;\n+\n+  /* Get the alias set to be used for the pointed-to memory.  If that\n+     differs from what we would get from looking at the type adjust\n+     the tag_type to void to make sure we get a proper alias set from\n+     just looking at the SMT we create.  */\n+  tag_set = get_alias_set (tag_type);\n+  if (TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (ptr))\n+      /* This is overly conservative but we do not want to assign\n+         restrict alias sets here (which if they are not assigned\n+         are -2 but still \"known\").  */\n+      || DECL_POINTER_ALIAS_SET_KNOWN_P (ptr))\n+    {\n+      tag_set = 0;\n+      tag_type = void_type_node;\n+    }\n \n   /* To avoid creating unnecessary memory tags, only create one memory tag\n      per alias set class.  Note that it may be tempting to group\n@@ -3329,7 +3306,8 @@ get_smt_for (tree ptr, struct alias_info *ai)\n \t artificial variable representing the memory location\n \t pointed-to by PTR.  */\n       tag = symbol_mem_tag (ptr);\n-      if (tag == NULL_TREE)\n+      if (tag == NULL_TREE\n+\t  || tag_set != get_alias_set (tag))\n \ttag = create_memory_tag (tag_type, true);\n \n       /* Add PTR to the POINTERS array.  Note that we are not interested in"}]}