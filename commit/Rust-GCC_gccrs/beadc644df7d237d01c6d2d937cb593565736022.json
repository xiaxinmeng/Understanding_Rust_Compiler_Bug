{"sha": "beadc644df7d237d01c6d2d937cb593565736022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVhZGM2NDRkZjdkMjM3ZDAxYzZkMmQ5MzdjYjU5MzU2NTczNjAyMg==", "commit": {"author": {"name": "Chris Demetriou", "email": "cgd@broadcom.com", "date": "2003-08-22T22:36:42Z"}, "committer": {"name": "Chris Demetriou", "email": "cgd@gcc.gnu.org", "date": "2003-08-22T22:36:42Z"}, "message": "mips.h (MASK_FIX_SB1, [...]): New defines.\n\n2003-08-22  Chris Demetriou  <cgd@broadcom.com>\n\n        * config/mips/mips.h (MASK_FIX_SB1, TARGET_FIX_SB1): New defines.\n        (TARGET_SWITCHES): Add -mfix-sb1 and -mno-fix-sb1.\n        * config/mips/mips.md (divdf3, divsf3, sqrtdf2, sqrtsf2): Work\n        around SB-1 errata if TARGET_FIX_SB1 is set.\n        (recip.d insn, recip.s insn, rsqrt.d insn, rsqrt.s insn): Likewise.\n        * doc/invoke.texi: Document MIPS -mfix-sb1 and -mno-fix-sb1.\n\nFrom-SVN: r70707", "tree": {"sha": "696b3199dad4763226cb2c4ca1d91a77a4c97568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/696b3199dad4763226cb2c4ca1d91a77a4c97568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beadc644df7d237d01c6d2d937cb593565736022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beadc644df7d237d01c6d2d937cb593565736022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beadc644df7d237d01c6d2d937cb593565736022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beadc644df7d237d01c6d2d937cb593565736022/comments", "author": null, "committer": null, "parents": [{"sha": "4ae2e3e9225dbd7b2eb6d08577b045bd0a0d017f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae2e3e9225dbd7b2eb6d08577b045bd0a0d017f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ae2e3e9225dbd7b2eb6d08577b045bd0a0d017f"}], "stats": {"total": 166, "additions": 148, "deletions": 18}, "files": [{"sha": "85e8b8778e0635bd04bfe451bf67fea0c38126ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beadc644df7d237d01c6d2d937cb593565736022/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beadc644df7d237d01c6d2d937cb593565736022/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=beadc644df7d237d01c6d2d937cb593565736022", "patch": "@@ -1,3 +1,12 @@\n+2003-08-22  Chris Demetriou  <cgd@broadcom.com>\n+\n+\t* config/mips/mips.h (MASK_FIX_SB1, TARGET_FIX_SB1): New defines.\n+\t(TARGET_SWITCHES): Add -mfix-sb1 and -mno-fix-sb1.\n+\t* config/mips/mips.md (divdf3, divsf3, sqrtdf2, sqrtsf2): Work\n+\taround SB-1 errata if TARGET_FIX_SB1 is set.\n+\t(recip.d insn, recip.s insn, rsqrt.d insn, rsqrt.s insn): Likewise.\n+\t* doc/invoke.texi: Document MIPS -mfix-sb1 and -mno-fix-sb1.\n+\n 2003-08-22  Roger Sayle  <roger@eyesopen.com>\n \n \t* hashtable.c (ht_expand): Avoid calculating rehash for the common"}, {"sha": "38aa951048735e4cb6fabedeede5ad4616de19e6", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beadc644df7d237d01c6d2d937cb593565736022/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beadc644df7d237d01c6d2d937cb593565736022/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=beadc644df7d237d01c6d2d937cb593565736022", "patch": "@@ -170,6 +170,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define MASK_UNINIT_CONST_IN_RODATA \\\n \t\t\t   0x00800000\t/* Store uninitialized\n \t\t\t\t\t   consts in rodata */\n+#define MASK_FIX_SB1       0x01000000   /* Work around SB-1 errata. */\n \n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0\t\t/* unused */\n@@ -255,6 +256,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n \n #define TARGET_BRANCHLIKELY\t(target_flags & MASK_BRANCHLIKELY)\n \n+#define TARGET_FIX_SB1\t\t(target_flags & MASK_FIX_SB1)\n \n /* True if we should use NewABI-style relocation operators for\n    symbolic addresses.  This is never true for mips16 code,\n@@ -580,6 +582,10 @@ extern const struct mips_cpu_info *mips_tune_info;\n      N_(\"Work around early 4300 hardware bug\")},\t\t\t\\\n   {\"no-fix4300\",         -MASK_4300_MUL_FIX,\t\t\t\t\\\n      N_(\"Don't work around early 4300 hardware bug\")},\t\t\t\\\n+  {\"fix-sb1\",             MASK_FIX_SB1,\t\t\t\t\t\\\n+     N_(\"Work around errata for early SB-1 revision 2 cores\")},\t\t\\\n+  {\"no-fix-sb1\",         -MASK_FIX_SB1,\t\t\t\t\t\\\n+     N_(\"Don't work around errata for early SB-1 revision 2 cores\")},\t\\\n   {\"check-zero-division\",-MASK_NO_CHECK_ZERO_DIV,\t\t\t\\\n      N_(\"Trap on integer divide by zero\")},\t\t\t\t\\\n   {\"no-check-zero-division\", MASK_NO_CHECK_ZERO_DIV,\t\t\t\\"}, {"sha": "e843d53734ceafde209d79c78cd3e2f9f69e9588", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 124, "deletions": 17, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beadc644df7d237d01c6d2d937cb593565736022/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beadc644df7d237d01c6d2d937cb593565736022/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=beadc644df7d237d01c6d2d937cb593565736022", "patch": "@@ -2365,41 +2365,104 @@\n ;;  ....................\n ;;\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum:\n+;;\n+;; If an mfc1 or dmfc1 happens to access the floating point register\n+;; file at the same time a long latency operation (div, sqrt, recip,\n+;; sqrt) iterates an intermediate result back through the floating\n+;; point register file bypass, then instead returning the correct\n+;; register value the mfc1 or dmfc1 operation returns the intermediate\n+;; result of the long latency operation.\n+;;\n+;; The workaround is to insert an unconditional 'mov' from/to the\n+;; long latency op destination register.\n (define_insn \"divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"div.d\\t%0,%1,%2\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"div.d\\t%0,%1,%2\\;mov.d\\t%0,%0\";\n+  else\n+    return \"div.d\\t%0,%1,%2\";\n+}\n   [(set_attr \"type\"\t\"fdiv\")\n-   (set_attr \"mode\"\t\"DF\")])\n+   (set_attr \"mode\"\t\"DF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n+\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"divdf3\" comment for details).\n+;;\n+;; This pattern works around the early SB-1 rev2 core \"F2\" erratum:\n+;;\n+;; In certain cases, div.s and div.ps may have a rounding error\n+;; and/or wrong inexact flag.\n+;;\n+;; Therefore, we only allow div.s if not working around SB-1 rev2\n+;; errata, or if working around those errata and a slight loss of\n+;; precision is OK (i.e., flag_unsafe_math_optimizations is set).\n (define_insn \"divsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n-  \"div.s\\t%0,%1,%2\"\n+  \"TARGET_HARD_FLOAT && (!TARGET_FIX_SB1 || flag_unsafe_math_optimizations)\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"div.s\\t%0,%1,%2\\;mov.s\\t%0,%0\";\n+  else\n+    return \"div.s\\t%0,%1,%2\";\n+}\n   [(set_attr \"type\"\t\"fdiv\")\n-   (set_attr \"mode\"\t\"SF\")])\n+   (set_attr \"mode\"\t\"SF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n \t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n-  \"recip.d\\t%0,%2\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"recip.d\\t%0,%2\\;mov.d\\t%0,%0\";\n+  else\n+    return \"recip.d\\t%0,%2\";\n+}\n   [(set_attr \"type\"\t\"fdiv\")\n-   (set_attr \"mode\"\t\"DF\")])\n+   (set_attr \"mode\"\t\"DF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n \t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n-  \"recip.s\\t%0,%2\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"recip.s\\t%0,%2\\;mov.s\\t%0,%0\";\n+  else\n+    return \"recip.s\\t%0,%2\";\n+}\n   [(set_attr \"type\"\t\"fdiv\")\n-   (set_attr \"mode\"\t\"SF\")])\n+   (set_attr \"mode\"\t\"SF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n \n (define_insn \"divmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n@@ -2456,39 +2519,83 @@\n ;;\n ;;  ....................\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"divdf3\" comment for details).\n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && HAVE_SQRT_P() && TARGET_DOUBLE_FLOAT\"\n-  \"sqrt.d\\t%0,%1\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"sqrt.d\\t%0,%1\\;mov.d\\t%0,%0\";\n+  else\n+    return \"sqrt.d\\t%0,%1\";\n+}\n   [(set_attr \"type\"\t\"fsqrt\")\n-   (set_attr \"mode\"\t\"DF\")])\n+   (set_attr \"mode\"\t\"DF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"divdf3\" comment for details).\n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && HAVE_SQRT_P()\"\n-  \"sqrt.s\\t%0,%1\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"sqrt.s\\t%0,%1\\;mov.s\\t%0,%0\";\n+  else\n+    return \"sqrt.s\\t%0,%1\";\n+}\n   [(set_attr \"type\"\t\"fsqrt\")\n-   (set_attr \"mode\"\t\"SF\")])\n+   (set_attr \"mode\"\t\"SF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n \t\t(sqrt:DF (match_operand:DF 2 \"register_operand\" \"f\"))))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n-  \"rsqrt.d\\t%0,%2\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"rsqrt.d\\t%0,%2\\;mov.d\\t%0,%0\";\n+  else\n+    return \"rsqrt.d\\t%0,%2\";\n+}\n   [(set_attr \"type\"\t\"frsqrt\")\n-   (set_attr \"mode\"\t\"DF\")])\n+   (set_attr \"mode\"\t\"DF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n \n+;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n \t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"f\"))))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n-  \"rsqrt.s\\t%0,%2\"\n+{\n+  if (TARGET_FIX_SB1)\n+    return \"rsqrt.s\\t%0,%2\\;mov.s\\t%0,%0\";\n+  else\n+    return \"rsqrt.s\\t%0,%2\";\n+}\n   [(set_attr \"type\"\t\"frsqrt\")\n-   (set_attr \"mode\"\t\"SF\")])\n+   (set_attr \"mode\"\t\"SF\")\n+   (set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n+                      (const_int 8)\n+                      (const_int 4)))])\n \f\n ;;\n ;;  ...................."}, {"sha": "d68eb0efaf8f8c9304af14f52b4c0e36a2312227", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beadc644df7d237d01c6d2d937cb593565736022/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beadc644df7d237d01c6d2d937cb593565736022/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=beadc644df7d237d01c6d2d937cb593565736022", "patch": "@@ -479,7 +479,8 @@ in the following sections.\n -m4650  -msingle-float  -mmad @gol\n -EL  -EB  -G @var{num}  -nocpp @gol\n -mabi=32  -mabi=n32  -mabi=64  -mabi=eabi  -mabi-fake-default @gol\n--mfix7000  -mno-crt0 -mflush-func=@var{func} -mno-flush-func @gol\n+-mfix7000  -mfix-sb1  -mno-fix-sb1 @gol\n+-mno-crt0 -mflush-func=@var{func} -mno-flush-func @gol\n -mbranch-likely -mno-branch-likely}\n \n @emph{i386 and x86-64 Options}\n@@ -8168,6 +8169,13 @@ Pass an option to gas which will cause nops to be inserted if\n the read of the destination register of an mfhi or mflo instruction\n occurs in the following two instructions.\n \n+@item -mfix-sb1\n+@itemx -mno-fix-sb1\n+@opindex mfix-sb1\n+Work around certain SB-1 CPU core errata.\n+(This flag currently works around the SB-1 revision 2\n+``F1'' and ``F2'' floating point errata.)\n+\n @item -no-crt0\n @opindex no-crt0\n Do not include the default crt0."}]}