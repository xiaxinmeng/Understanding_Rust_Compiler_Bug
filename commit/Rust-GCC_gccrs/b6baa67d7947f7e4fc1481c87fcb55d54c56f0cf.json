{"sha": "b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZiYWE2N2Q3OTQ3ZjdlNGZjMTQ4MWM4N2ZjYjU1ZDU0YzU2ZjBjZg==", "commit": {"author": {"name": "Kris Van Hees", "email": "kris.van.hees@oracle.com", "date": "2008-04-18T13:58:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-04-18T13:58:08Z"}, "message": "cpp-id-data.h (UC): Was U, conflicts with U...\n\nlibcpp/ChangeLog:\n2008-04-14  Kris Van Hees <kris.van.hees@oracle.com>\n\n* include/cpp-id-data.h (UC): Was U, conflicts with U... literal.\n* include/cpplib.h (CHAR16, CHAR32, STRING16, STRING32): New tokens.\n(struct cpp_options): Added uliterals.\n(cpp_interpret_string): Update prototype.\n(cpp_interpret_string_notranslate): Idem.\n* charset.c (init_iconv_desc): New width member in cset_converter.\n(cpp_init_iconv): Add support for char{16,32}_cset_desc.\n(convert_ucn): Idem.\n(emit_numeric_escape): Idem.\n(convert_hex): Idem.\n(convert_oct): Idem.\n(convert_escape): Idem.\n(converter_for_type): New function.\n(cpp_interpret_string): Use converter_for_type, support u and U prefix.\n(cpp_interpret_string_notranslate): Match changed prototype.\n(wide_str_to_charconst): Use converter_for_type.\n(cpp_interpret_charconst): Add support for CPP_CHAR{16,32}.\n* directives.c (linemarker_dir): Macro U changed to UC.\n(parse_include): Idem.\n(register_pragma_1): Idem.\n(restore_registered_pragmas): Idem.\n(get__Pragma_string): Support CPP_STRING{16,32}.\n* expr.c (eval_token): Support CPP_CHAR{16,32}.\n* init.c (struct lang_flags): Added uliterals.\n(lang_defaults): Idem.\n* internal.h (struct cset_converter) <width>: New field.\n(struct cpp_reader) <char16_cset_desc>: Idem.\n(struct cpp_reader) <char32_cset_desc>: Idem.\n* lex.c (digraph_spellings): Macro U changed to UC.\n(OP, TK): Idem.\n(lex_string): Add support for u'...', U'...', u... and U....\n(_cpp_lex_direct): Idem.\n* macro.c (_cpp_builtin_macro_text): Macro U changed to UC.\n(stringify_arg): Support CPP_CHAR{16,32} and CPP_STRING{16,32}.\n\ngcc/ChangeLog:\n2008-04-14  Kris Van Hees <kris.van.hees@oracle.com>\n  \n* c-common.c (CHAR16_TYPE, CHAR32_TYPE): New macros.\n(fname_as_string): Match updated cpp_interpret_string prototype.\n(fix_string_type): Support char16_t* and char32_t*.\n(c_common_nodes_and_builtins): Add char16_t and char32_t (and\nderivative) nodes.  Register as builtin if C++0x.\n(c_parse_error): Support CPP_CHAR{16,32}.\n* c-common.h (RID_CHAR16, RID_CHAR32): New elements. \n(enum c_tree_index) <CTI_CHAR16_TYPE, CTI_SIGNED_CHAR16_TYPE,\nCTI_UNSIGNED_CHAR16_TYPE, CTI_CHAR32_TYPE, CTI_SIGNED_CHAR32_TYPE,\nCTI_UNSIGNED_CHAR32_TYPE, CTI_CHAR16_ARRAY_TYPE,\nCTI_CHAR32_ARRAY_TYPE>: New elements.\n(char16_type_node, signed_char16_type_node, unsigned_char16_type_node,\nchar32_type_node, signed_char32_type_node, char16_array_type_node,\nchar32_array_type_node): New defines.\n* c-lex.c (cb_ident): Match updated cpp_interpret_string prototype.\n(c_lex_with_flags): Support CPP_CHAR{16,32} and CPP_STRING{16,32}.\n(lex_string): Support CPP_STRING{16,32}, match updated\ncpp_interpret_string and cpp_interpret_string_notranslate prototypes.\n(lex_charconst): Support CPP_CHAR{16,32}.\n* c-parser.c (c_parser_postfix_expression): Support CPP_CHAR{16,32}\nand CPP_STRING{16,32}.\n\ngcc/cp/ChangeLog:\n2008-04-14  Kris Van Hees <kris.van.hees@oracle.com>\n\n* cvt.c (type_promotes_to): Support char16_t and char32_t.\n* decl.c (grokdeclarator): Disallow signed/unsigned/short/long on\nchar16_t and char32_t.\n* lex.c (reswords): Add char16_t and char32_t (for c++0x).\n* mangle.c (write_builtin_type): Mangle char16_t/char32_t as vendor\nextended builtin type u8char32_t.\n* parser.c (cp_lexer_next_token_is_decl_specifier_keyword): Support\nRID_CHAR{16,32}.\n(cp_lexer_print_token): Support CPP_STRING{16,32}.\n(cp_parser_is_string_literal): Idem.\n(cp_parser_string_literal): Idem.\n(cp_parser_primary_expression): Support CPP_CHAR{16,32} and\nCPP_STRING{16,32}.\n(cp_parser_simple_type_specifier): Support RID_CHAR{16,32}. \n* tree.c (char_type_p): Support char16_t and char32_t as char types.\n* typeck.c (string_conv_p): Support char16_t and char32_t.\n\ngcc/testsuite/ChangeLog:\n2008-04-14  Kris Van Hees <kris.van.hees@oracle.com>\n\nTests for char16_t and char32_t support.\n* g++.dg/ext/utf-cvt.C: New\n* g++.dg/ext/utf-cxx0x.C: New\n* g++.dg/ext/utf-cxx98.C: New\n* g++.dg/ext/utf-dflt.C: New\n* g++.dg/ext/utf-gnuxx0x.C: New\n* g++.dg/ext/utf-gnuxx98.C: New\n* g++.dg/ext/utf-mangle.C: New\n* g++.dg/ext/utf-typedef-cxx0x.C: New\n* g++.dg/ext/utf-typedef-\n* g++.dg/ext/utf-typespec.C: New\n* g++.dg/ext/utf16-1.C: New\n* g++.dg/ext/utf16-2.C: New\n* g++.dg/ext/utf16-3.C: New\n* g++.dg/ext/utf16-4.C: New\n* g++.dg/ext/utf32-1.C: New\n* g++.dg/ext/utf32-2.C: New\n* g++.dg/ext/utf32-3.C: New\n* g++.dg/ext/utf32-4.C: New\n* gcc.dg/utf-cvt.c: New\n* gcc.dg/utf-dflt.c: New\n* gcc.dg/utf16-1.c: New\n* gcc.dg/utf16-2.c: New\n* gcc.dg/utf16-3.c: New\n* gcc.dg/utf16-4.c: New\n* gcc.dg/utf32-1.c: New\n* gcc.dg/utf32-2.c: New\n* gcc.dg/utf32-3.c: New\n* gcc.dg/utf32-4.c: New\n\nlibiberty/ChangeLog:\n2008-04-14  Kris Van Hees <kris.van.hees@oracle.com>\n\n* testsuite/demangle-expected: Added tests for char16_t and char32_t.\n\nFrom-SVN: r134438", "tree": {"sha": "7a2e1b1d5ba3460de2699e7cd1bc2b1739fc3119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a2e1b1d5ba3460de2699e7cd1bc2b1739fc3119"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/comments", "author": {"login": "kvanhees", "id": 36747794, "node_id": "MDQ6VXNlcjM2NzQ3Nzk0", "avatar_url": "https://avatars.githubusercontent.com/u/36747794?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kvanhees", "html_url": "https://github.com/kvanhees", "followers_url": "https://api.github.com/users/kvanhees/followers", "following_url": "https://api.github.com/users/kvanhees/following{/other_user}", "gists_url": "https://api.github.com/users/kvanhees/gists{/gist_id}", "starred_url": "https://api.github.com/users/kvanhees/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kvanhees/subscriptions", "organizations_url": "https://api.github.com/users/kvanhees/orgs", "repos_url": "https://api.github.com/users/kvanhees/repos", "events_url": "https://api.github.com/users/kvanhees/events{/privacy}", "received_events_url": "https://api.github.com/users/kvanhees/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14a8726b8a54cf83654426302e4fe91877cad971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14a8726b8a54cf83654426302e4fe91877cad971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14a8726b8a54cf83654426302e4fe91877cad971"}], "stats": {"total": 1608, "additions": 1482, "deletions": 126}, "files": [{"sha": "a053bf4c27a846a55afc9099f68020528369bd91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1,3 +1,27 @@\n+2008-04-18  Kris Van Hees <kris.van.hees@oracle.com>\n+\t  \n+\t* c-common.c (CHAR16_TYPE, CHAR32_TYPE): New macros.\n+\t(fname_as_string): Match updated cpp_interpret_string prototype.\n+\t(fix_string_type): Support char16_t* and char32_t*.\n+\t(c_common_nodes_and_builtins): Add char16_t and char32_t (and\n+\tderivative) nodes.  Register as builtin if C++0x.\n+\t(c_parse_error): Support CPP_CHAR{16,32}.\n+\t* c-common.h (RID_CHAR16, RID_CHAR32): New elements. \n+\t(enum c_tree_index) <CTI_CHAR16_TYPE, CTI_SIGNED_CHAR16_TYPE,\n+\tCTI_UNSIGNED_CHAR16_TYPE, CTI_CHAR32_TYPE, CTI_SIGNED_CHAR32_TYPE,\n+\tCTI_UNSIGNED_CHAR32_TYPE, CTI_CHAR16_ARRAY_TYPE,\n+\tCTI_CHAR32_ARRAY_TYPE>: New elements.\n+\t(char16_type_node, signed_char16_type_node, unsigned_char16_type_node,\n+\tchar32_type_node, signed_char32_type_node, char16_array_type_node,\n+\tchar32_array_type_node): New defines.\n+\t* c-lex.c (cb_ident): Match updated cpp_interpret_string prototype.\n+\t(c_lex_with_flags): Support CPP_CHAR{16,32} and CPP_STRING{16,32}.\n+\t(lex_string): Support CPP_STRING{16,32}, match updated\n+\tcpp_interpret_string and cpp_interpret_string_notranslate prototypes.\n+\t(lex_charconst): Support CPP_CHAR{16,32}.\n+\t* c-parser.c (c_parser_postfix_expression): Support CPP_CHAR{16,32}\n+\tand CPP_STRING{16,32}.\n+\n 2008-04-18  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR bootstrap/35457"}, {"sha": "351c62831d397eb9350e01ab96c9b2e7b19d9bd6", "filename": "gcc/c-common.c", "status": "modified", "additions": 99, "deletions": 9, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -66,6 +66,14 @@ cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n #define PID_TYPE \"int\"\n #endif\n \n+#ifndef CHAR16_TYPE\n+#define CHAR16_TYPE \"short unsigned int\"\n+#endif\n+\n+#ifndef CHAR32_TYPE\n+#define CHAR32_TYPE \"unsigned int\"\n+#endif\n+\n #ifndef WCHAR_TYPE\n #define WCHAR_TYPE \"int\"\n #endif\n@@ -123,6 +131,9 @@ cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \ttree signed_wchar_type_node;\n \ttree unsigned_wchar_type_node;\n \n+\ttree char16_type_node;\n+\ttree char32_type_node;\n+\n \ttree float_type_node;\n \ttree double_type_node;\n \ttree long_double_type_node;\n@@ -174,6 +185,16 @@ cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n \ttree wchar_array_type_node;\n \n+   Type `char16_t[SOMENUMBER]' or something like it.\n+   Used when a UTF-16 string literal is created.\n+\n+\ttree char16_array_type_node;\n+\n+   Type `char32_t[SOMENUMBER]' or something like it.\n+   Used when a UTF-32 string literal is created.\n+\n+\ttree char32_array_type_node;\n+\n    Type `int ()' -- used for implicit declaration of functions.\n \n \ttree default_function_type;\n@@ -777,7 +798,7 @@ fname_as_string (int pretty_p)\n   strname.text = (unsigned char *) namep;\n   strname.len = len - 1;\n \n-  if (cpp_interpret_string (parse_in, &strname, 1, &cstr, false))\n+  if (cpp_interpret_string (parse_in, &strname, 1, &cstr, CPP_STRING))\n     {\n       XDELETEVEC (namep);\n       return (const char *) cstr.text;\n@@ -857,14 +878,31 @@ fname_decl (unsigned int rid, tree id)\n tree\n fix_string_type (tree value)\n {\n-  const int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n-  const int wide_flag = TREE_TYPE (value) == wchar_array_type_node;\n   int length = TREE_STRING_LENGTH (value);\n   int nchars;\n   tree e_type, i_type, a_type;\n \n   /* Compute the number of elements, for the array type.  */\n-  nchars = wide_flag ? length / wchar_bytes : length;\n+  if (TREE_TYPE (value) == char_array_type_node || !TREE_TYPE (value))\n+    {\n+      nchars = length;\n+      e_type = char_type_node;\n+    }\n+  else if (TREE_TYPE (value) == char16_array_type_node)\n+    {\n+      nchars = length / (TYPE_PRECISION (char16_type_node) / BITS_PER_UNIT);\n+      e_type = char16_type_node;\n+    }\n+  else if (TREE_TYPE (value) == char32_array_type_node)\n+    {\n+      nchars = length / (TYPE_PRECISION (char32_type_node) / BITS_PER_UNIT);\n+      e_type = char32_type_node;\n+    }\n+  else\n+    {\n+      nchars = length / (TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT);\n+      e_type = wchar_type_node;\n+    }\n \n   /* C89 2.2.4.1, C99 5.2.4.1 (Translation limits).  The analogous\n      limit in C++98 Annex B is very large (65536) and is not normative,\n@@ -899,7 +937,6 @@ fix_string_type (tree value)\n      construct the matching unqualified array type first.  The C front\n      end does not require this, but it does no harm, so we do it\n      unconditionally.  */\n-  e_type = wide_flag ? wchar_type_node : char_type_node;\n   i_type = build_index_type (build_int_cst (NULL_TREE, nchars - 1));\n   a_type = build_array_type (e_type, i_type);\n   if (c_dialect_cxx() || warn_write_strings)\n@@ -3629,6 +3666,8 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n void\n c_common_nodes_and_builtins (void)\n {\n+  int char16_type_size;\n+  int char32_type_size;\n   int wchar_type_size;\n   tree array_domain_type;\n   tree va_list_ref_type_node;\n@@ -3878,6 +3917,38 @@ c_common_nodes_and_builtins (void)\n   wchar_array_type_node\n     = build_array_type (wchar_type_node, array_domain_type);\n \n+  /* Define 'char16_t'.  */\n+  char16_type_node = get_identifier (CHAR16_TYPE);\n+  char16_type_node = TREE_TYPE (identifier_global_value (char16_type_node));\n+  char16_type_size = TYPE_PRECISION (char16_type_node);\n+  if (c_dialect_cxx ())\n+    {\n+      char16_type_node = make_unsigned_type (char16_type_size);\n+\n+      if (cxx_dialect == cxx0x)\n+\trecord_builtin_type (RID_CHAR16, \"char16_t\", char16_type_node);\n+    }\n+\n+  /* This is for UTF-16 string constants.  */\n+  char16_array_type_node\n+    = build_array_type (char16_type_node, array_domain_type);\n+\n+  /* Define 'char32_t'.  */\n+  char32_type_node = get_identifier (CHAR32_TYPE);\n+  char32_type_node = TREE_TYPE (identifier_global_value (char32_type_node));\n+  char32_type_size = TYPE_PRECISION (char32_type_node);\n+  if (c_dialect_cxx ())\n+    {\n+      char32_type_node = make_unsigned_type (char32_type_size);\n+\n+      if (cxx_dialect == cxx0x)\n+\trecord_builtin_type (RID_CHAR32, \"char32_t\", char32_type_node);\n+    }\n+\n+  /* This is for UTF-32 string constants.  */\n+  char32_array_type_node\n+    = build_array_type (char32_type_node, array_domain_type);\n+\n   wint_type_node =\n     TREE_TYPE (identifier_global_value (get_identifier (WINT_TYPE)));\n \n@@ -6662,20 +6733,39 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token, tree value)\n \n   if (token == CPP_EOF)\n     message = catenate_messages (gmsgid, \" at end of input\");\n-  else if (token == CPP_CHAR || token == CPP_WCHAR)\n+  else if (token == CPP_CHAR || token == CPP_WCHAR || token == CPP_CHAR16\n+\t   || token == CPP_CHAR32)\n     {\n       unsigned int val = TREE_INT_CST_LOW (value);\n-      const char *const ell = (token == CPP_CHAR) ? \"\" : \"L\";\n+      const char *prefix;\n+\n+      switch (token)\n+\t{\n+\tdefault:\n+\t  prefix = \"\";\n+\t  break;\n+\tcase CPP_WCHAR:\n+\t  prefix = \"L\";\n+\t  break;\n+\tcase CPP_CHAR16:\n+\t  prefix = \"u\";\n+\t  break;\n+\tcase CPP_CHAR32:\n+\t  prefix = \"U\";\n+\t  break;\n+        }\n+\n       if (val <= UCHAR_MAX && ISGRAPH (val))\n \tmessage = catenate_messages (gmsgid, \" before %s'%c'\");\n       else\n \tmessage = catenate_messages (gmsgid, \" before %s'\\\\x%x'\");\n \n-      error (message, ell, val);\n+      error (message, prefix, val);\n       free (message);\n       message = NULL;\n     }\n-  else if (token == CPP_STRING || token == CPP_WSTRING)\n+  else if (token == CPP_STRING || token == CPP_WSTRING || token == CPP_STRING16\n+\t   || token == CPP_STRING32)\n     message = catenate_messages (gmsgid, \" before string constant\");\n   else if (token == CPP_NUMBER)\n     message = catenate_messages (gmsgid, \" before numeric constant\");"}, {"sha": "3ca3c8bf0c4ec33e20eb440ca8b9c044c77747de", "filename": "gcc/c-common.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -85,7 +85,7 @@ enum rid\n   RID_NEW,      RID_OFFSETOF, RID_OPERATOR,\n   RID_THIS,     RID_THROW,    RID_TRUE,\n   RID_TRY,      RID_TYPENAME, RID_TYPEID,\n-  RID_USING,\n+  RID_USING,    RID_CHAR16,   RID_CHAR32,\n \n   /* casts */\n   RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n@@ -143,6 +143,8 @@ extern GTY ((length (\"(int) RID_MAX\"))) tree *ridpointers;\n \n enum c_tree_index\n {\n+    CTI_CHAR16_TYPE,\n+    CTI_CHAR32_TYPE,\n     CTI_WCHAR_TYPE,\n     CTI_SIGNED_WCHAR_TYPE,\n     CTI_UNSIGNED_WCHAR_TYPE,\n@@ -155,6 +157,8 @@ enum c_tree_index\n     CTI_WIDEST_UINT_LIT_TYPE,\n \n     CTI_CHAR_ARRAY_TYPE,\n+    CTI_CHAR16_ARRAY_TYPE,\n+    CTI_CHAR32_ARRAY_TYPE,\n     CTI_WCHAR_ARRAY_TYPE,\n     CTI_INT_ARRAY_TYPE,\n     CTI_STRING_TYPE,\n@@ -190,6 +194,8 @@ struct c_common_identifier GTY(())\n   struct cpp_hashnode node;\n };\n \n+#define char16_type_node\t\tc_global_trees[CTI_CHAR16_TYPE]\n+#define char32_type_node\t\tc_global_trees[CTI_CHAR32_TYPE]\n #define wchar_type_node\t\t\tc_global_trees[CTI_WCHAR_TYPE]\n #define signed_wchar_type_node\t\tc_global_trees[CTI_SIGNED_WCHAR_TYPE]\n #define unsigned_wchar_type_node\tc_global_trees[CTI_UNSIGNED_WCHAR_TYPE]\n@@ -206,6 +212,8 @@ struct c_common_identifier GTY(())\n #define truthvalue_false_node\t\tc_global_trees[CTI_TRUTHVALUE_FALSE]\n \n #define char_array_type_node\t\tc_global_trees[CTI_CHAR_ARRAY_TYPE]\n+#define char16_array_type_node\t\tc_global_trees[CTI_CHAR16_ARRAY_TYPE]\n+#define char32_array_type_node\t\tc_global_trees[CTI_CHAR32_ARRAY_TYPE]\n #define wchar_array_type_node\t\tc_global_trees[CTI_WCHAR_ARRAY_TYPE]\n #define int_array_type_node\t\tc_global_trees[CTI_INT_ARRAY_TYPE]\n #define string_type_node\t\tc_global_trees[CTI_STRING_TYPE]"}, {"sha": "c3e7f6e3a166f73a6de7d6d195fda71f8b6d508e", "filename": "gcc/c-lex.c", "status": "modified", "additions": 66, "deletions": 22, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -174,7 +174,7 @@ cb_ident (cpp_reader * ARG_UNUSED (pfile),\n     {\n       /* Convert escapes in the string.  */\n       cpp_string cstr = { 0, 0 };\n-      if (cpp_interpret_string (pfile, str, 1, &cstr, false))\n+      if (cpp_interpret_string (pfile, str, 1, &cstr, CPP_STRING))\n \t{\n \t  ASM_OUTPUT_IDENT (asm_out_file, (const char *) cstr.text);\n \t  free (CONST_CAST (unsigned char *, cstr.text));\n@@ -361,6 +361,8 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \n \t    case CPP_STRING:\n \t    case CPP_WSTRING:\n+\t    case CPP_STRING16:\n+\t    case CPP_STRING32:\n \t      type = lex_string (tok, value, true, true);\n \t      break;\n \n@@ -410,11 +412,15 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \n     case CPP_CHAR:\n     case CPP_WCHAR:\n+    case CPP_CHAR16:\n+    case CPP_CHAR32:\n       *value = lex_charconst (tok);\n       break;\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n       if ((lex_flags & C_LEX_RAW_STRINGS) == 0)\n \t{\n \t  type = lex_string (tok, value, false,\n@@ -822,12 +828,12 @@ interpret_fixed (const cpp_token *token, unsigned int flags)\n   return value;\n }\n \n-/* Convert a series of STRING and/or WSTRING tokens into a tree,\n-   performing string constant concatenation.  TOK is the first of\n-   these.  VALP is the location to write the string into.  OBJC_STRING\n-   indicates whether an '@' token preceded the incoming token.\n+/* Convert a series of STRING, WSTRING, STRING16 and/or STRING32 tokens\n+   into a tree, performing string constant concatenation.  TOK is the\n+   first of these.  VALP is the location to write the string into.\n+   OBJC_STRING indicates whether an '@' token preceded the incoming token.\n    Returns the CPP token type of the result (CPP_STRING, CPP_WSTRING,\n-   or CPP_OBJC_STRING).\n+   CPP_STRING32, CPP_STRING16, or CPP_OBJC_STRING).\n \n    This is unfortunately more work than it should be.  If any of the\n    strings in the series has an L prefix, the result is a wide string\n@@ -842,19 +848,16 @@ static enum cpp_ttype\n lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n {\n   tree value;\n-  bool wide = false;\n   size_t concats = 0;\n   struct obstack str_ob;\n   cpp_string istr;\n+  enum cpp_ttype type = tok->type;\n \n   /* Try to avoid the overhead of creating and destroying an obstack\n      for the common case of just one string.  */\n   cpp_string str = tok->val.str;\n   cpp_string *strs = &str;\n \n-  if (tok->type == CPP_WSTRING)\n-    wide = true;\n-\n  retry:\n   tok = cpp_get_token (parse_in);\n   switch (tok->type)\n@@ -873,8 +876,15 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n       break;\n \n     case CPP_WSTRING:\n-      wide = true;\n-      /* FALLTHROUGH */\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n+      if (type != tok->type)\n+\t{\n+\t  if (type == CPP_STRING)\n+\t    type = tok->type;\n+\t  else\n+\t    error (\"unsupported non-standard concatenation of string literals\");\n+\t}\n \n     case CPP_STRING:\n       if (!concats)\n@@ -899,7 +909,7 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n \n   if ((translate\n        ? cpp_interpret_string : cpp_interpret_string_notranslate)\n-      (parse_in, strs, concats + 1, &istr, wide))\n+      (parse_in, strs, concats + 1, &istr, type))\n     {\n       value = build_string (istr.len, (const char *) istr.text);\n       free (CONST_CAST (unsigned char *, istr.text));\n@@ -909,22 +919,52 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n       /* Callers cannot generally handle error_mark_node in this context,\n \t so return the empty string instead.  cpp_interpret_string has\n \t issued an error.  */\n-      if (wide)\n-\tvalue = build_string (TYPE_PRECISION (wchar_type_node)\n-\t\t\t      / TYPE_PRECISION (char_type_node),\n-\t\t\t      \"\\0\\0\\0\");  /* widest supported wchar_t\n-\t\t\t\t\t     is 32 bits */\n-      else\n-\tvalue = build_string (1, \"\");\n+      switch (type)\n+\t{\n+\tdefault:\n+\tcase CPP_STRING:\n+\t  value = build_string (1, \"\");\n+\t  break;\n+\tcase CPP_STRING16:\n+\t  value = build_string (TYPE_PRECISION (char16_type_node)\n+\t\t\t\t/ TYPE_PRECISION (char_type_node),\n+\t\t\t\t\"\\0\");  /* char16_t is 16 bits */\n+\t  break;\n+\tcase CPP_STRING32:\n+\t  value = build_string (TYPE_PRECISION (char32_type_node)\n+\t\t\t\t/ TYPE_PRECISION (char_type_node),\n+\t\t\t\t\"\\0\\0\\0\");  /* char32_t is 32 bits */\n+\t  break;\n+\tcase CPP_WSTRING:\n+\t  value = build_string (TYPE_PRECISION (wchar_type_node)\n+\t\t\t\t/ TYPE_PRECISION (char_type_node),\n+\t\t\t\t\"\\0\\0\\0\");  /* widest supported wchar_t\n+\t\t\t\t\t       is 32 bits */\n+\t  break;\n+        }\n     }\n \n-  TREE_TYPE (value) = wide ? wchar_array_type_node : char_array_type_node;\n+  switch (type)\n+    {\n+    default:\n+    case CPP_STRING:\n+      TREE_TYPE (value) = char_array_type_node;\n+      break;\n+    case CPP_STRING16:\n+      TREE_TYPE (value) = char16_array_type_node;\n+      break;\n+    case CPP_STRING32:\n+      TREE_TYPE (value) = char32_array_type_node;\n+      break;\n+    case CPP_WSTRING:\n+      TREE_TYPE (value) = wchar_array_type_node;\n+    }\n   *valp = fix_string_type (value);\n \n   if (concats)\n     obstack_free (&str_ob, 0);\n \n-  return objc_string ? CPP_OBJC_STRING : wide ? CPP_WSTRING : CPP_STRING;\n+  return objc_string ? CPP_OBJC_STRING : type;\n }\n \n /* Converts a (possibly wide) character constant token into a tree.  */\n@@ -941,6 +981,10 @@ lex_charconst (const cpp_token *token)\n \n   if (token->type == CPP_WCHAR)\n     type = wchar_type_node;\n+  else if (token->type == CPP_CHAR32)\n+    type = char32_type_node;\n+  else if (token->type == CPP_CHAR16)\n+    type = char16_type_node;\n   /* In C, a character constant has type 'int'.\n      In C++ 'char', but multi-char charconsts have type 'int'.  */\n   else if (!c_dialect_cxx () || chars_seen > 1)"}, {"sha": "d98640d0b9e8360ac0983f69ff715ca274df7e68", "filename": "gcc/c-parser.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -5163,12 +5163,16 @@ c_parser_postfix_expression (c_parser *parser)\n     {\n     case CPP_NUMBER:\n     case CPP_CHAR:\n+    case CPP_CHAR16:\n+    case CPP_CHAR32:\n     case CPP_WCHAR:\n       expr.value = c_parser_peek_token (parser)->value;\n       expr.original_code = ERROR_MARK;\n       c_parser_consume_token (parser);\n       break;\n     case CPP_STRING:\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n     case CPP_WSTRING:\n       expr.value = c_parser_peek_token (parser)->value;\n       expr.original_code = STRING_CST;"}, {"sha": "b348c0d13490bfac2bb0eceb448d74f150b2c67e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1,3 +1,22 @@\n+2008-04-18  Kris Van Hees <kris.van.hees@oracle.com>\n+\n+\t* cvt.c (type_promotes_to): Support char16_t and char32_t.\n+\t* decl.c (grokdeclarator): Disallow signed/unsigned/short/long on\n+\tchar16_t and char32_t.\n+\t* lex.c (reswords): Add char16_t and char32_t (for c++0x).\n+\t* mangle.c (write_builtin_type): Mangle char16_t/char32_t as vendor\n+\textended builtin type \"u8char{16,32}_t\".\n+\t* parser.c (cp_lexer_next_token_is_decl_specifier_keyword): Support\n+\tRID_CHAR{16,32}.\n+\t(cp_lexer_print_token): Support CPP_STRING{16,32}.\n+\t(cp_parser_is_string_literal): Idem.\n+\t(cp_parser_string_literal): Idem.\n+\t(cp_parser_primary_expression): Support CPP_CHAR{16,32} and\n+\tCPP_STRING{16,32}.\n+\t(cp_parser_simple_type_specifier): Support RID_CHAR{16,32}. \n+\t* tree.c (char_type_p): Support char16_t and char32_t as char types.\n+\t* typeck.c (string_conv_p): Support char16_t and char32_t.\n+\n 2008-04-17  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/35773"}, {"sha": "b2c17c547dbc89222b7124a78dded62093c6fbd3", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1219,6 +1219,8 @@ type_promotes_to (tree type)\n   /* Normally convert enums to int, but convert wide enums to something\n      wider.  */\n   else if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t   || type == char16_type_node\n+\t   || type == char32_type_node\n \t   || type == wchar_type_node)\n     {\n       int precision = MAX (TYPE_PRECISION (type),"}, {"sha": "d16cb78d06b6005e691cb657dc18fb5f5d8a8a1e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -7732,6 +7732,13 @@ grokdeclarator (const cp_declarator *declarator,\n \terror (\"%<long%> or %<short%> specified with char for %qs\", name);\n       else if (long_p && short_p)\n \terror (\"%<long%> and %<short%> specified together for %qs\", name);\n+      else if (type == char16_type_node || type == char32_type_node)\n+\t{\n+\t  if (signed_p || unsigned_p)\n+\t    error (\"%<signed%> or %<unsigned%> invalid for %qs\", name);\n+\t  else if (short_p || long_p)\n+\t    error (\"%<short%> or %<long%> invalid for %qs\", name);\n+\t}\n       else\n \t{\n \t  ok = 1;"}, {"sha": "8484a4b33910515baf1f449f86f1ab9a39ad85e9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -241,6 +241,8 @@ static const struct resword reswords[] =\n   { \"case\",\t\tRID_CASE,\t0 },\n   { \"catch\",\t\tRID_CATCH,\t0 },\n   { \"char\",\t\tRID_CHAR,\t0 },\n+  { \"char16_t\",\t\tRID_CHAR16,\tD_CXX0X },\n+  { \"char32_t\",\t\tRID_CHAR32,\tD_CXX0X },\n   { \"class\",\t\tRID_CLASS,\t0 },\n   { \"const\",\t\tRID_CONST,\t0 },\n   { \"const_cast\",\tRID_CONSTCAST,\t0 },"}, {"sha": "5ac5bcee04ea3f426703aa5c4b15b0073f74a04d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1782,10 +1782,14 @@ write_builtin_type (tree type)\n       break;\n \n     case INTEGER_TYPE:\n-      /* TYPE may still be wchar_t, since that isn't in\n-\t integer_type_nodes.  */\n+      /* TYPE may still be wchar_t, char16_t, or char32_t, since that\n+\t isn't in integer_type_nodes.  */\n       if (type == wchar_type_node)\n \twrite_char ('w');\n+      else if (type == char16_type_node)\n+\twrite_string (\"u8char16_t\");\n+      else if (type == char32_type_node)\n+\twrite_string (\"u8char32_t\");\n       else if (TYPE_FOR_JAVA (type))\n \twrite_java_integer_type_codes (type);\n       else"}, {"sha": "f2acddbb255f9a4baab5d346634a1e40830fc114", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -556,6 +556,8 @@ cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n     case RID_TYPENAME:\n       /* Simple type specifiers.  */\n     case RID_CHAR:\n+    case RID_CHAR16:\n+    case RID_CHAR32:\n     case RID_WCHAR:\n     case RID_BOOL:\n     case RID_SHORT:\n@@ -789,6 +791,8 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n       break;\n \n     case CPP_STRING:\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n     case CPP_WSTRING:\n       fprintf (stream, \" \\\"%s\\\"\", TREE_STRING_POINTER (token->u.value));\n       break;\n@@ -2033,7 +2037,10 @@ cp_parser_parsing_tentatively (cp_parser* parser)\n static bool\n cp_parser_is_string_literal (cp_token* token)\n {\n-  return (token->type == CPP_STRING || token->type == CPP_WSTRING);\n+  return (token->type == CPP_STRING ||\n+\t  token->type == CPP_STRING16 ||\n+\t  token->type == CPP_STRING32 ||\n+\t  token->type == CPP_WSTRING);\n }\n \n /* Returns nonzero if TOKEN is the indicated KEYWORD.  */\n@@ -2867,11 +2874,11 @@ static tree\n cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n {\n   tree value;\n-  bool wide = false;\n   size_t count;\n   struct obstack str_ob;\n   cpp_string str, istr, *strs;\n   cp_token *tok;\n+  enum cpp_ttype type;\n \n   tok = cp_lexer_peek_token (parser->lexer);\n   if (!cp_parser_is_string_literal (tok))\n@@ -2880,6 +2887,8 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n       return error_mark_node;\n     }\n \n+  type = tok->type;\n+\n   /* Try to avoid the overhead of creating and destroying an obstack\n      for the common case of just one string.  */\n   if (!cp_parser_is_string_literal\n@@ -2890,8 +2899,6 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n       str.text = (const unsigned char *)TREE_STRING_POINTER (tok->u.value);\n       str.len = TREE_STRING_LENGTH (tok->u.value);\n       count = 1;\n-      if (tok->type == CPP_WSTRING)\n-\twide = true;\n \n       strs = &str;\n     }\n@@ -2906,8 +2913,14 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t  count++;\n \t  str.text = (const unsigned char *)TREE_STRING_POINTER (tok->u.value);\n \t  str.len = TREE_STRING_LENGTH (tok->u.value);\n-\t  if (tok->type == CPP_WSTRING)\n-\t    wide = true;\n+\n+\t  if (type != tok->type)\n+\t    {\n+\t      if (type == CPP_STRING)\n+\t\ttype = tok->type;\n+\t      else if (tok->type != CPP_STRING)\n+\t\terror (\"unsupported non-standard concatenation of string literals\");\n+\t    }\n \n \t  obstack_grow (&str_ob, &str, sizeof (cpp_string));\n \n@@ -2918,19 +2931,35 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n       strs = (cpp_string *) obstack_finish (&str_ob);\n     }\n \n-  if (wide && !wide_ok)\n+  if (type != CPP_STRING && !wide_ok)\n     {\n       cp_parser_error (parser, \"a wide string is invalid in this context\");\n-      wide = false;\n+      type = CPP_STRING;\n     }\n \n   if ((translate ? cpp_interpret_string : cpp_interpret_string_notranslate)\n-      (parse_in, strs, count, &istr, wide))\n+      (parse_in, strs, count, &istr, type))\n     {\n       value = build_string (istr.len, (const char *)istr.text);\n       free (CONST_CAST (unsigned char *, istr.text));\n \n-      TREE_TYPE (value) = wide ? wchar_array_type_node : char_array_type_node;\n+      switch (type)\n+\t{\n+\tdefault:\n+\tcase CPP_STRING:\n+\t  TREE_TYPE (value) = char_array_type_node;\n+\t  break;\n+\tcase CPP_STRING16:\n+\t  TREE_TYPE (value) = char16_array_type_node;\n+\t  break;\n+\tcase CPP_STRING32:\n+\t  TREE_TYPE (value) = char32_array_type_node;\n+\t  break;\n+\tcase CPP_WSTRING:\n+\t  TREE_TYPE (value) = wchar_array_type_node;\n+\t  break;\n+\t}\n+\n       value = fix_string_type (value);\n     }\n   else\n@@ -3085,6 +3114,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t   string-literal\n \t   boolean-literal  */\n     case CPP_CHAR:\n+    case CPP_CHAR16:\n+    case CPP_CHAR32:\n     case CPP_WCHAR:\n     case CPP_NUMBER:\n       token = cp_lexer_consume_token (parser->lexer);\n@@ -3136,6 +3167,8 @@ cp_parser_primary_expression (cp_parser *parser,\n       return token->u.value;\n \n     case CPP_STRING:\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n     case CPP_WSTRING:\n       /* ??? Should wide strings be allowed when parser->translate_strings_p\n \t is false (i.e. in attributes)?  If not, we can kill the third\n@@ -10762,6 +10795,8 @@ cp_parser_type_specifier (cp_parser* parser,\n    simple-type-specifier:\n      auto\n      decltype ( expression )   \n+     char16_t\n+     char32_t\n \n    GNU Extension:\n \n@@ -10791,6 +10826,12 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \tdecl_specs->explicit_char_p = true;\n       type = char_type_node;\n       break;\n+    case RID_CHAR16:\n+      type = char16_type_node;\n+      break;\n+    case RID_CHAR32:\n+      type = char32_type_node;\n+      break;\n     case RID_WCHAR:\n       type = wchar_type_node;\n       break;\n@@ -17754,13 +17795,16 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n {\n   decl_specs->any_specifiers_p = true;\n \n-  /* If the user tries to redeclare bool or wchar_t (with, for\n-     example, in \"typedef int wchar_t;\") we remember that this is what\n-     happened.  In system headers, we ignore these declarations so\n-     that G++ can work with system headers that are not C++-safe.  */\n+  /* If the user tries to redeclare bool, char16_t, char32_t, or wchar_t\n+     (with, for example, in \"typedef int wchar_t;\") we remember that\n+     this is what happened.  In system headers, we ignore these\n+     declarations so that G++ can work with system headers that are not\n+     C++-safe.  */\n   if (decl_specs->specs[(int) ds_typedef]\n       && !user_defined_p\n       && (type_spec == boolean_type_node\n+\t  || type_spec == char16_type_node\n+\t  || type_spec == char32_type_node\n \t  || type_spec == wchar_type_node)\n       && (decl_specs->type\n \t  || decl_specs->specs[(int) ds_long]"}, {"sha": "73adbb50725125c867609cf08614757c317cb7b5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -2474,6 +2474,8 @@ char_type_p (tree type)\n   return (same_type_p (type, char_type_node)\n \t  || same_type_p (type, unsigned_char_type_node)\n \t  || same_type_p (type, signed_char_type_node)\n+\t  || same_type_p (type, char16_type_node)\n+\t  || same_type_p (type, char32_type_node)\n \t  || same_type_p (type, wchar_type_node));\n }\n "}, {"sha": "9e9d46151a92c75faaec67cda7e3dbf11a618c02", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1722,12 +1722,14 @@ string_conv_p (const_tree totype, const_tree exp, int warn)\n \n   t = TREE_TYPE (totype);\n   if (!same_type_p (t, char_type_node)\n+      && !same_type_p (t, char16_type_node)\n+      && !same_type_p (t, char32_type_node)\n       && !same_type_p (t, wchar_type_node))\n     return 0;\n \n   if (TREE_CODE (exp) == STRING_CST)\n     {\n-      /* Make sure that we don't try to convert between char and wchar_t.  */\n+      /* Make sure that we don't try to convert between char and wide chars.  */\n       if (!same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (exp))), t))\n \treturn 0;\n     }"}, {"sha": "e839cde86308c6eea4e6c5c12162cef18aaa7643", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1,3 +1,35 @@\n+2008-04-18  Kris Van Hees <kris.van.hees@oracle.com>\n+\n+\tTests for char16_t and char32_t support.\n+\t* g++.dg/ext/utf-cvt.C: New\n+\t* g++.dg/ext/utf-cxx0x.C: New\n+\t* g++.dg/ext/utf-cxx98.C: New\n+\t* g++.dg/ext/utf-dflt.C: New\n+\t* g++.dg/ext/utf-gnuxx0x.C: New\n+\t* g++.dg/ext/utf-gnuxx98.C: New\n+\t* g++.dg/ext/utf-mangle.C: New\n+\t* g++.dg/ext/utf-typedef-cxx0x.C: New\n+\t* g++.dg/ext/utf-typedef-cxx98.C: New\n+\t* g++.dg/ext/utf-typespec.C: New\n+\t* g++.dg/ext/utf16-1.C: New\n+\t* g++.dg/ext/utf16-2.C: New\n+\t* g++.dg/ext/utf16-3.C: New\n+\t* g++.dg/ext/utf16-4.C: New\n+\t* g++.dg/ext/utf32-1.C: New\n+\t* g++.dg/ext/utf32-2.C: New\n+\t* g++.dg/ext/utf32-3.C: New\n+\t* g++.dg/ext/utf32-4.C: New\n+\t* gcc.dg/utf-cvt.c: New\n+\t* gcc.dg/utf-dflt.c: New\n+\t* gcc.dg/utf16-1.c: New\n+\t* gcc.dg/utf16-2.c: New\n+\t* gcc.dg/utf16-3.c: New\n+\t* gcc.dg/utf16-4.c: New\n+\t* gcc.dg/utf32-1.c: New\n+\t* gcc.dg/utf32-2.c: New\n+\t* gcc.dg/utf32-3.c: New\n+\t* gcc.dg/utf32-4.c: New\n+\n 2008-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/varsize_return.ads: New test."}, {"sha": "bab020e4fe37532fb36d07d8b47ebb49c2bef45b", "filename": "gcc/testsuite/g++.dg/ext/utf-badconcat.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-badconcat.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-badconcat.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-badconcat.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,22 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test unsupported concatenation of char16_t/char32_t* string literals. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++0x\" } */\n+\n+const void *s0\t= u\"a\"  \"b\";\n+const void *s1\t=  \"a\" u\"b\";\n+const void *s2\t= u\"a\" U\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+const void *s3\t= U\"a\" u\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+const void *s4\t= u\"a\" L\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+const void *s5\t= L\"a\" u\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+const void *s6\t= u\"a\" u\"b\";\n+const void *s7\t= U\"a\"  \"b\";\n+const void *s8\t=  \"a\" U\"b\";\n+const void *s9\t= U\"a\" L\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+const void *sa\t= L\"a\" U\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+const void *sb\t= U\"a\" U\"b\";\n+const void *sc\t= L\"a\"  \"b\";\n+const void *sd\t=  \"a\" L\"b\";\n+const void *se\t= L\"a\" L\"b\";\n+\n+int main () {}"}, {"sha": "0e6b17a5ad1380b29a129cb37d896a17e79060e7", "filename": "gcc/testsuite/g++.dg/ext/utf-cvt.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cvt.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cvt.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cvt.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,46 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the char16_t and char32_t promotion rules. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++0x -Wall -Wconversion -Wsign-conversion -Wsign-promo\" } */\n+\n+extern void f_c (char);\n+extern void fsc (signed char);\n+extern void fuc (unsigned char);\n+extern void f_s (short);\n+extern void fss (signed short);\n+extern void fus (unsigned short);\n+extern void f_i (int);\n+extern void fsi (signed int);\n+extern void fui (unsigned int);\n+extern void f_l (long);\n+extern void fsl (signed long);\n+extern void ful (unsigned long);\n+\n+void m(char16_t c0, char32_t c1)\n+{\n+    f_c (c0);\t\t\t/* { dg-warning \"alter its value\" } */\n+    fsc (c0);\t\t\t/* { dg-warning \"alter its value\" } */\n+    fuc (c0);\t\t\t/* { dg-warning \"alter its value\" } */\n+    f_s (c0);\t\t\t/* { dg-warning \"change the sign\" } */\n+    fss (c0);\t\t\t/* { dg-warning \"change the sign\" } */\n+    fus (c0);\n+    f_i (c0);\n+    fsi (c0);\n+    fui (c0);\n+    f_l (c0);\n+    fsl (c0);\n+    ful (c0);\n+\n+    f_c (c1);\t\t\t/* { dg-warning \"alter its value\" } */\n+    fsc (c1);\t\t\t/* { dg-warning \"alter its value\" } */\n+    fuc (c1);\t\t\t/* { dg-warning \"alter its value\" } */\n+    f_s (c1);\t\t\t/* { dg-warning \"alter its value\" } */\n+    fss (c1);\t\t\t/* { dg-warning \"alter its value\" } */\n+    fus (c1);\t\t\t/* { dg-warning \"alter its value\" } */\n+    f_i (c1);\t\t\t/* { dg-warning \"change the sign\" } */\n+    fsi (c1);\t\t\t/* { dg-warning \"change the sign\" } */\n+    fui (c1);\n+    f_l (c1);\t\t\t/* { dg-warning \"change the sign\" } */\n+    fsl (c1);\t\t\t/* { dg-warning \"change the sign\" } */\n+    ful (c1);\n+}"}, {"sha": "1daa0dee487fa848d8f975c9197e12b5272b4bdf", "filename": "gcc/testsuite/g++.dg/ext/utf-cxx0x.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cxx0x.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cxx0x.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cxx0x.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,14 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test parsing of u and U prefixes when also used as macros. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++0x\" } */\n+\n+#define u\tL\n+#define U\tL\n+\n+const unsigned short\tc2\t= u'a';\n+const unsigned long\tc3\t= U'a';\n+const void\t\t*s0\t= u\"a\";\n+const void\t\t*s1\t= U\"a\";\n+\n+int main () {}"}, {"sha": "a8dd13a4e346ec1450ca18f4a6eec20c918e1900", "filename": "gcc/testsuite/g++.dg/ext/utf-cxx98.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cxx98.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cxx98.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-cxx98.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,29 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Expected errors for char16_t/char32_t in c++98. */\n+/* Ensure u and U prefixes are parsed as separate tokens in c++98. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++98\" } */\n+\n+const static char16_t\tc0\t= 'a';\t/* { dg-error \"not name a type\" } */\n+const static char32_t\tc1\t= 'a';\t/* { dg-error \"not name a type\" } */\n+\n+const unsigned short\tc2\t= u'a';\t/* { dg-error \"not declared\" } */\n+\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 10 } */\n+const unsigned long\tc3\t= U'a';\t/* { dg-error \"not declared\" } */\n+\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 12 } */\n+\n+#define u\t1 +\n+#define U\t2 +\n+\n+const unsigned short\tc5\t= u'a';\n+const unsigned long\tc6\t= U'a';\n+\n+#undef u\n+#undef U\n+#define u\t\"a\"\n+#define U\t\"b\"\n+\n+const void\t\t*s0\t= u\"a\";\n+const void\t\t*s1\t= U\"a\";\n+\n+int main () {}"}, {"sha": "942f2b26d38bbc50b5e46256a1ccee8e7b24e5a0", "filename": "gcc/testsuite/g++.dg/ext/utf-dflt.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-dflt.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-dflt.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-dflt.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,29 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Expected errors for char16_t/char32_t in default std. */\n+/* Ensure u and U prefixes are parsed as separate tokens in default std. */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+const static char16_t\tc0\t= 'a';\t/* { dg-error \"not name a type\" } */\n+const static char32_t\tc1\t= 'a';\t/* { dg-error \"not name a type\" } */\n+\n+const unsigned short\tc2\t= u'a';\t/* { dg-error \"not declared\" } */\n+\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 10 } */\n+const unsigned long\tc3\t= U'a';\t/* { dg-error \"not declared\" } */\n+\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 12 } */\n+\n+#define u\t1 +\n+#define U\t2 +\n+\n+const unsigned short\tc4\t= u'a';\n+const unsigned long\tc5\t= U'a';\n+\n+#undef u\n+#undef U\n+#define u\t\"a\"\n+#define U\t\"b\"\n+\n+const void\t\t*s0\t= u\"a\";\n+const void\t\t*s1\t= U\"a\";\n+\n+int main () {}"}, {"sha": "0a6967fe40db77c2e37c5cf6dce0736e6811d81d", "filename": "gcc/testsuite/g++.dg/ext/utf-gnuxx0x.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-gnuxx0x.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-gnuxx0x.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-gnuxx0x.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,14 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test parsing of u and U prefixes when also used as macros. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu++0x\" } */\n+\n+#define u\tL\n+#define U\tL\n+\n+const unsigned short\tc2\t= u'a';\n+const unsigned long\tc3\t= U'a';\n+const void\t\t*s0\t= u\"a\";\n+const void\t\t*s1\t= U\"a\";\n+\n+int main () {}"}, {"sha": "fc8068b7e99f6dcb3d2019f3bd32a874db2a709b", "filename": "gcc/testsuite/g++.dg/ext/utf-gnuxx98.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-gnuxx98.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-gnuxx98.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-gnuxx98.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,29 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Expected errors for char16_t/char32_t in gnu++98. */\n+/* Ensure u and U prefixes are parsed as separate tokens in gnu++98. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu++98\" } */\n+\n+const static char16_t\tc0\t= 'a';\t/* { dg-error \"not name a type\" } */\n+const static char32_t\tc1\t= 'a';\t/* { dg-error \"not name a type\" } */\n+\n+const unsigned short\tc2\t= u'a';\t/* { dg-error \"not declared\" } */\n+\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 10 } */\n+const unsigned long\tc3\t= U'a';\t/* { dg-error \"not declared\" } */\n+\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 12 } */\n+\n+#define u\t1 +\n+#define U\t2 +\n+\n+const unsigned short\tc5\t= u'a';\n+const unsigned long\tc6\t= U'a';\n+\n+#undef u\n+#undef U\n+#define u\t\"a\"\n+#define U\t\"b\"\n+\n+const void\t\t*s0\t= u\"a\";\n+const void\t\t*s1\t= U\"a\";\n+\n+int main () {}"}, {"sha": "bb5e3822adcad68f78e2b54bc53dc7681edb0d79", "filename": "gcc/testsuite/g++.dg/ext/utf-mangle.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-mangle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-mangle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-mangle.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,14 @@\n+// Contributed by Kris Van Hees <kris.van.hees@oracle.com>\n+// Test the support for char16_t character constants.\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+void f0 (char16_t c) {}\n+void f1 (char32_t c) {}\n+void f2 (char16_t *s) {}\n+void f3 (char32_t *s) {}\n+\n+// { dg-final { scan-assembler \"_Z2f0u8char16_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f1u8char32_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f2Pu8char16_t:\" } }\n+// { dg-final { scan-assembler \"_Z2f3Pu8char32_t:\" } }"}, {"sha": "789d08b9cc202f77fd8077af6ecc84c865c29ad7", "filename": "gcc/testsuite/g++.dg/ext/utf-typedef-cxx0x.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typedef-cxx0x.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typedef-cxx0x.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typedef-cxx0x.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,7 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Ensure that a typedef to char16_t/char32_t issues a warning in c++0x. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++0x\" } */\n+\n+typedef short unsigned int\tchar16_t; /* { dg-warning \"redeclaration\" } */\n+typedef unsigned int\t\tchar32_t; /* { dg-warning \"redeclaration\" } */"}, {"sha": "8922856c2e20493aa5c273ac9717e94f729f5cea", "filename": "gcc/testsuite/g++.dg/ext/utf-typedef-cxx98.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typedef-cxx98.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typedef-cxx98.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typedef-cxx98.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,7 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Ensure that a typedef to char16_t/char32_t is fine in c++98. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++98\" } */\n+\n+typedef short unsigned int\tchar16_t;\n+typedef unsigned int\t\tchar32_t;"}, {"sha": "6a4af25598a2649f58198be552dd280d87238aab", "filename": "gcc/testsuite/g++.dg/ext/utf-typespec.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typespec.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typespec.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-typespec.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,25 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Ensure that type specifiers are not allowed for char16_t/char32_t. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++0x\" } */\n+\n+signed char16_t\t\tc0;\t\t/* { dg-error \"signed\" } */\n+signed char32_t\t\tc1;\t\t/* { dg-error \"signed\" } */\n+unsigned char16_t\tc2;\t\t/* { dg-error \"unsigned\" } */\n+unsigned char32_t\tc3;\t\t/* { dg-error \"unsigned\" } */\n+\n+short char16_t\t\tc4;\t\t/* { dg-error \"short\" } */\n+long char16_t\t\tc5;\t\t/* { dg-error \"long\" } */\n+short char32_t\t\tc6;\t\t/* { dg-error \"short\" } */\n+long char32_t\t\tc7;\t\t/* { dg-error \"long\" } */\n+\n+signed short char16_t\tc8;\t\t/* { dg-error \"signed\" } */\n+signed short char32_t\tc9;\t\t/* { dg-error \"signed\" } */\n+signed long char16_t\tca;\t\t/* { dg-error \"signed\" } */\n+signed long char32_t\tcb;\t\t/* { dg-error \"signed\" } */\n+unsigned short char16_t\tcc;\t\t/* { dg-error \"unsigned\" } */\n+unsigned short char32_t\tcd;\t\t/* { dg-error \"unsigned\" } */\n+unsigned long char16_t\tce;\t\t/* { dg-error \"unsigned\" } */\n+unsigned long char32_t\tcf;\t\t/* { dg-error \"unsigned\" } */\n+\n+int main () {}"}, {"sha": "fa07de912d5c17d7f919deda5984213d2293ad66", "filename": "gcc/testsuite/g++.dg/ext/utf16-1.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-1.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,65 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char16_t character constants. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c++0x -Wall -Werror\" } */\n+\n+extern \"C\" void abort (void);\n+\n+const static char16_t\tc0 = u'a';\n+const static char16_t\tc1 = u'\\0';\n+const static char16_t\tc2 = u'\\u0024';\n+const static char16_t\tc3 = u'\\u2029';\n+const static char16_t\tc4 = u'\\u8010';\n+\n+const static char16_t\tc5 = 'a';\n+const static char16_t\tc6 = U'a';\n+const static char16_t\tc7 = U'\\u2029';\n+const static char16_t\tc8 = U'\\u8010';\n+const static char16_t\tc9 = L'a';\n+const static char16_t\tca = L'\\u2029';\n+const static char16_t\tcb = L'\\u8010';\n+\n+#define A\t0x0061\n+#define D\t0x0024\n+#define X\t0x2029\n+#define Y\t0x8010\n+\n+int main ()\n+{\n+    if (sizeof (u'a') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\0') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\u0024') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\u2029') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\u8010') != sizeof (char16_t))\n+\tabort ();\n+\n+    if (c0 != A)\n+\tabort ();\n+    if (c1 != 0x0000)\n+\tabort ();\n+    if (c2 != D)\n+\tabort ();\n+    if (c3 != X)\n+\tabort ();\n+    if (c4 != Y)\n+\tabort ();\n+\n+    if (c5 != A)\n+\tabort ();\n+    if (c6 != A)\n+\tabort ();\n+    if (c7 != X)\n+\tabort ();\n+    if (c8 != Y)\n+\tabort ();\n+    if (c9 != A)\n+\tabort ();\n+    if (ca != X)\n+\tabort ();\n+    if (cb != Y)\n+\tabort ();\n+}"}, {"sha": "d7a6056f81c6ca77445f683bd5b9d6c77e5afcc2", "filename": "gcc/testsuite/g++.dg/ext/utf16-2.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-2.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,30 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char16_t* string literals. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c++0x -Wall -Werror\" } */\n+\n+extern \"C\" void abort (void);\n+\n+const static char16_t\t*s0 = u\"ab\";\n+const static char16_t\t*s1 = u\"a\\u0024\";\n+const static char16_t\t*s2 = u\"a\\u2029\";\n+const static char16_t\t*s3 = u\"a\\U00064321\";\n+\n+#define A\t0x0061\n+#define B\t0x0062\n+#define D\t0x0024\n+#define X\t0x2029\n+#define Y1\t0xD950\n+#define Y2\t0xDF21\n+\n+int main ()\n+{\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x0000)\n+\tabort ();\n+    if (s1[0] != A || s1[1] != D || s0[2] != 0x0000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != X || s0[2] != 0x0000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != Y1 || s3[2] != Y2 || s3[3] != 0x0000)\n+\tabort ();\n+}"}, {"sha": "183347b6ee9c7c6c908cf98453a89cd3144ac038", "filename": "gcc/testsuite/g++.dg/ext/utf16-3.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-3.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,47 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test concatenation of char16_t* string literals. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c++0x -Wall -Werror\" } */\n+\n+extern \"C\" void abort (void);\n+\n+const static char16_t\t*s0 = u\"a\" u\"b\";\n+\n+const static char16_t\t*s1 = u\"a\" \"b\";\n+const static char16_t\t*s2 = \"a\" u\"b\";\n+const static char16_t\t*s3 = u\"a\" \"\\u2029\";\n+const static char16_t\t*s4 = \"\\u2029\" u\"b\";\n+const static char16_t\t*s5 = u\"a\" \"\\U00064321\";\n+const static char16_t\t*s6 = \"\\U00064321\" u\"b\";\n+\n+#define A\t0x0061\n+#define B\t0x0062\n+#define X\t0x2029\n+#define Y1\t0xD950\n+#define Y2\t0xDF21\n+\n+int main ()\n+{\n+    if (sizeof ((u\"a\" u\"b\")[0]) != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof ((u\"a\"  \"b\")[0]) != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (( \"a\" u\"b\")[0]) != sizeof (char16_t))\n+\tabort ();\n+\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x0000)\n+\tabort ();\n+\n+    if (s1[0] != A || s1[1] != B || s1[2] != 0x0000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != B || s2[2] != 0x0000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != X || s3[2] != 0x0000)\n+\tabort ();\n+    if (s4[0] != X || s4[1] != B || s4[2] != 0x0000)\n+\tabort ();\n+    if (s5[0] != A || s5[1] != Y1 || s5[2] != Y2 || s5[3] != 0x0000)\n+\tabort ();\n+    if (s6[0] != Y1 || s6[1] != Y2 || s6[2] != B || s6[3] != 0x0000)\n+\tabort ();\n+}"}, {"sha": "0fb7459c21ead01546be716fb4851e71679b417c", "filename": "gcc/testsuite/g++.dg/ext/utf16-4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf16-4.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,18 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Expected errors for char16_t character constants. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++0x\" } */\n+\n+const static char16_t\tc0 = u'';\t\t/* { dg-error \"empty character\" } */\n+const static char16_t\tc1 = u'ab';\t\t/* { dg-warning \"constant too long\" } */\n+const static char16_t\tc2 = u'\\U00064321';\t/* { dg-warning \"constant too long\" } */\n+\n+const static char16_t\tc3 = 'a';\n+const static char16_t\tc4 = U'a';\n+const static char16_t\tc5 = U'\\u2029';\n+const static char16_t\tc6 = U'\\U00064321';\t/* { dg-warning \"implicitly truncated\" } */\n+const static char16_t\tc7 = L'a';\n+const static char16_t\tc8 = L'\\u2029';\n+const static char16_t\tc9 = L'\\U00064321';\t/* { dg-warning \"implicitly truncated\" } */\n+\n+int main () {}"}, {"sha": "98465a0a1b9202b1ff2d16f830fc0a5411176d21", "filename": "gcc/testsuite/g++.dg/ext/utf32-1.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-1.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,42 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char32_t character constants. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c++0x -Wall -Werror\" } */\n+\n+extern \"C\" void abort (void);\n+\n+const static char32_t\tc0 = U'a';\n+const static char32_t\tc1 = U'\\0';\n+const static char32_t\tc2 = U'\\u0024';\n+const static char32_t\tc3 = U'\\u2029';\n+const static char32_t\tc4 = U'\\U00064321';\n+\n+#define A\t0x00000061\n+#define D\t0x00000024\n+#define X\t0x00002029\n+#define Y\t0x00064321\n+\n+int main ()\n+{\n+    if (sizeof (U'a') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\0') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\u0024') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\u2029') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\U00064321') != sizeof (char32_t))\n+\tabort ();\n+\n+    if (c0 != A)\n+\tabort ();\n+    if (c1 != 0x0000)\n+\tabort ();\n+    if (c2 != D)\n+\tabort ();\n+    if (c3 != X)\n+\tabort ();\n+    if (c4 != Y)\n+\tabort ();\n+}"}, {"sha": "e2256ba7464cc180abb44274bb3da6f70798761a", "filename": "gcc/testsuite/g++.dg/ext/utf32-2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-2.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,29 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char32_t* string constants. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c++0x -Wall -Werror\" } */\n+\n+extern \"C\" void abort (void);\n+\n+const static char32_t\t*s0 = U\"ab\";\n+const static char32_t\t*s1 = U\"a\\u0024\";\n+const static char32_t\t*s2 = U\"a\\u2029\";\n+const static char32_t\t*s3 = U\"a\\U00064321\";\n+\n+#define A\t0x00000061\n+#define B\t0x00000062\n+#define D\t0x00000024\n+#define X\t0x00002029\n+#define Y\t0x00064321\n+\n+int main ()\n+{\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x00000000)\n+\tabort ();\n+    if (s1[0] != A || s1[1] != D || s0[2] != 0x00000000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != X || s0[2] != 0x00000000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != Y || s3[2] != 0x00000000)\n+\tabort ();\n+}"}, {"sha": "bba893cef5a4bd60a923f263acc6ee7b07bcc873", "filename": "gcc/testsuite/g++.dg/ext/utf32-3.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-3.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,46 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test concatenation of char32_t* string literals. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c++0x -Wall -Werror\" } */\n+\n+extern \"C\" void abort (void);\n+\n+const static char32_t\t*s0 = U\"a\" U\"b\";\n+\n+const static char32_t\t*s1 = U\"a\" \"b\";\n+const static char32_t\t*s2 = \"a\" U\"b\";\n+const static char32_t\t*s3 = U\"a\" \"\\u2029\";\n+const static char32_t\t*s4 = \"\\u2029\" U\"b\";\n+const static char32_t\t*s5 = U\"a\" \"\\U00064321\";\n+const static char32_t\t*s6 = \"\\U00064321\" U\"b\";\n+\n+#define A\t0x00000061\n+#define B\t0x00000062\n+#define X\t0x00002029\n+#define Y\t0x00064321\n+\n+int main ()\n+{\n+    if (sizeof ((U\"a\" U\"b\")[0]) != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof ((U\"a\"  \"b\")[0]) != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (( \"a\" U\"b\")[0]) != sizeof (char32_t))\n+\tabort ();\n+\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x00000000)\n+\tabort ();\n+\n+    if (s1[0] != A || s1[1] != B || s1[2] != 0x00000000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != B || s2[2] != 0x00000000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != X || s3[2] != 0x00000000)\n+\tabort ();\n+    if (s4[0] != X || s4[1] != B || s4[2] != 0x00000000)\n+\tabort ();\n+    if (s5[0] != A || s5[1] != Y || s5[2] != 0x00000000)\n+\tabort ();\n+    if (s6[0] != Y || s6[1] != B || s6[2] != 0x00000000)\n+\tabort ();\n+}"}, {"sha": "af2fa8db1b12702fcdd1fcb5a1b9bc5d7f2b2f3a", "filename": "gcc/testsuite/g++.dg/ext/utf32-4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf32-4.C?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,18 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Expected errors for char32_t character constants. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++0x\" } */\n+\n+const static char32_t\tc0 = U'';\t\t/* { dg-error \"empty character\" } */\n+const static char32_t\tc1 = U'ab';\t\t/* { dg-warning \"constant too long\" } */\n+const static char32_t\tc2 = U'\\U00064321';\n+\n+const static char32_t\tc3 = 'a';\n+const static char32_t\tc4 = u'a';\n+const static char32_t\tc5 = u'\\u2029';\n+const static char32_t\tc6 = u'\\U00064321';\t/* { dg-warning \"constant too long\" } */\n+const static char32_t\tc7 = L'a';\n+const static char32_t\tc8 = L'\\u2029';\n+const static char32_t\tc9 = L'\\U00064321';\n+\n+int main () {}"}, {"sha": "61ce495ed3d8b7791df5ae6b3e69fc2ce0b7e03a", "filename": "gcc/testsuite/gcc.dg/utf-badconcat.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf-badconcat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf-badconcat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf-badconcat.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,22 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test unsupported concatenation of char16_t/char32_t* string literals. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+void\t*s0\t= u\"a\"  \"b\";\n+void\t*s1\t=  \"a\" u\"b\";\n+void\t*s2\t= u\"a\" U\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s3\t= U\"a\" u\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s4\t= u\"a\" L\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s5\t= L\"a\" u\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s6\t= u\"a\" u\"b\";\n+void\t*s7\t= U\"a\"  \"b\";\n+void\t*s8\t=  \"a\" U\"b\";\n+void\t*s9\t= U\"a\" L\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*sa\t= L\"a\" U\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*sb\t= U\"a\" U\"b\";\n+void\t*sc\t= L\"a\"  \"b\";\n+void\t*sd\t=  \"a\" L\"b\";\n+void\t*se\t= L\"a\" L\"b\";\n+\n+int main () {}"}, {"sha": "e4bc624ac35d909d214943a1874ba88dc69ce406", "filename": "gcc/testsuite/gcc.dg/utf-cvt.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf-cvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf-cvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf-cvt.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,49 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the char16_t and char32_t promotion rules. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wall -Wconversion -Wsign-conversion\" } */\n+\n+typedef unsigned short\tchar16_t;\n+typedef unsigned int\tchar32_t;\n+\n+extern void f_c (char);\n+extern void fsc (signed char);\n+extern void fuc (unsigned char);\n+extern void f_s (short);\n+extern void fss (signed short);\n+extern void fus (unsigned short);\n+extern void f_i (int);\n+extern void fsi (signed int);\n+extern void fui (unsigned int);\n+extern void f_l (long);\n+extern void fsl (signed long);\n+extern void ful (unsigned long);\n+\n+void m (char16_t c0, char32_t c1)\n+{\n+    f_c (c0);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    fsc (c0);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    fuc (c0);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    f_s (c0);\t\t\t\t/* { dg-warning \"change the sign\" } */\n+    fss (c0);\t\t\t\t/* { dg-warning \"change the sign\" } */\n+    fus (c0);\n+    f_i (c0);\n+    fsi (c0);\n+    fui (c0);\n+    f_l (c0);\n+    fsl (c0);\n+    ful (c0);\n+\n+    f_c (c1);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    fsc (c1);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    fuc (c1);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    f_s (c1);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    fss (c1);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    fus (c1);\t\t\t\t/* { dg-warning \"alter its value\" } */\n+    f_i (c1);\t\t\t\t/* { dg-warning \"change the sign\" } */\n+    fsi (c1);\t\t\t\t/* { dg-warning \"change the sign\" } */\n+    fui (c1);\n+    f_l (c1);\t\t\t\t/* { dg-warning \"change the sign\" } */\n+    fsl (c1);\t\t\t\t/* { dg-warning \"change the sign\" } */\n+    ful (c1);\n+}"}, {"sha": "7281ef3c73e7f0d31cdb3fd0990f6002fd403bd5", "filename": "gcc/testsuite/gcc.dg/utf-dflt.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf-dflt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf-dflt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf-dflt.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,25 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* If not gnu99, the u and U prefixes should be parsed as separate tokens. */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+const unsigned short\tc0\t= u'a';\t\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 6 } */\n+const unsigned long\tc1\t= U'a';\t\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 8 } */\n+\n+#define u\t1 +\n+#define U\t2 +\n+\n+const unsigned short\tc2\t= u'a';\n+const unsigned long\tc3\t= U'a';\n+\n+#undef u\n+#undef U\n+#define u\t\"a\"\n+#define U\t\"b\"\n+\n+const void\t\t*s0\t= u\"a\";\n+const void\t\t*s1\t= U\"a\";\n+\n+int main () {}"}, {"sha": "b2c65c0c034148fc4f27d47ea288b6353cf42e64", "filename": "gcc/testsuite/gcc.dg/utf16-1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-1.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,67 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char16_t character constants. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -Wall -Werror\" } */\n+\n+typedef short unsigned int char16_t;\n+\n+extern void abort (void);\n+\n+char16_t\tc0 = u'a';\n+char16_t\tc1 = u'\\0';\n+char16_t\tc2 = u'\\u0024';\n+char16_t\tc3 = u'\\u2029';\n+char16_t\tc4 = u'\\u8010';\n+\n+char16_t\tc5 = 'a';\n+char16_t\tc6 = U'a';\n+char16_t\tc7 = U'\\u2029';\n+char16_t\tc8 = U'\\u8010';\n+char16_t\tc9 = L'a';\n+char16_t\tca = L'\\u2029';\n+char16_t\tcb = L'\\u8010';\n+\n+#define A\t0x0061\n+#define D\t0x0024\n+#define X\t0x2029\n+#define Y\t0x8010\n+\n+int main ()\n+{\n+    if (sizeof (u'a') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\0') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\u0024') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\u2029') != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (u'\\u8010') != sizeof (char16_t))\n+\tabort ();\n+\n+    if (c0 != A)\n+\tabort ();\n+    if (c1 != 0x0000)\n+\tabort ();\n+    if (c2 != D)\n+\tabort ();\n+    if (c3 != X)\n+\tabort ();\n+    if (c4 != Y)\n+\tabort ();\n+\n+    if (c5 != A)\n+\tabort ();\n+    if (c6 != A)\n+\tabort ();\n+    if (c7 != X)\n+\tabort ();\n+    if (c8 != Y)\n+\tabort ();\n+    if (c9 != A)\n+\tabort ();\n+    if (ca != X)\n+\tabort ();\n+    if (cb != Y)\n+\tabort ();\n+}"}, {"sha": "ad99a1a7a11bdb656437a51af6e5ccbd78d10cc9", "filename": "gcc/testsuite/gcc.dg/utf16-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-2.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,32 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char16_t* string literals. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -Wall -Werror\" } */\n+\n+typedef short unsigned int char16_t;\n+\n+extern void abort (void);\n+\n+char16_t\t*s0 = u\"ab\";\n+char16_t\t*s1 = u\"a\\u0024\";\n+char16_t\t*s2 = u\"a\\u2029\";\n+char16_t\t*s3 = u\"a\\U00064321\";\n+\n+#define A\t0x0061\n+#define B\t0x0062\n+#define D\t0x0024\n+#define X\t0x2029\n+#define Y1\t0xD950\n+#define Y2\t0xDF21\n+\n+int main ()\n+{\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x0000)\n+\tabort ();\n+    if (s1[0] != A || s1[1] != D || s0[2] != 0x0000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != X || s0[2] != 0x0000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != Y1 || s3[2] != Y2 || s3[3] != 0x0000)\n+\tabort ();\n+}"}, {"sha": "d5e31b205fcc5e1514a9cf522edcee46317fa602", "filename": "gcc/testsuite/gcc.dg/utf16-3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-3.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,49 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test concatenation of char16_t* string literals. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -Wall -Werror\" } */\n+\n+typedef short unsigned int char16_t;\n+\n+extern void abort (void);\n+\n+char16_t\t*s0 = u\"a\" u\"b\";\n+\n+char16_t\t*s1 = u\"a\" \"b\";\n+char16_t\t*s2 = \"a\" u\"b\";\n+char16_t\t*s3 = u\"a\" \"\\u2029\";\n+char16_t\t*s4 = \"\\u2029\" u\"b\";\n+char16_t\t*s5 = u\"a\" \"\\U00064321\";\n+char16_t\t*s6 = \"\\U00064321\" u\"b\";\n+\n+#define A\t0x0061\n+#define B\t0x0062\n+#define X\t0x2029\n+#define Y1\t0xD950\n+#define Y2\t0xDF21\n+\n+int main ()\n+{\n+    if (sizeof ((u\"a\" u\"b\")[0]) != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof ((u\"a\"  \"b\")[0]) != sizeof (char16_t))\n+\tabort ();\n+    if (sizeof (( \"a\" u\"b\")[0]) != sizeof (char16_t))\n+\tabort ();\n+\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x0000)\n+\tabort ();\n+\n+    if (s1[0] != A || s1[1] != B || s1[2] != 0x0000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != B || s2[2] != 0x0000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != X || s3[2] != 0x0000)\n+\tabort ();\n+    if (s4[0] != X || s4[1] != B || s4[2] != 0x0000)\n+\tabort ();\n+    if (s5[0] != A || s5[1] != Y1 || s5[2] != Y2 || s5[3] != 0x0000)\n+\tabort ();\n+    if (s6[0] != Y1 || s6[1] != Y2 || s6[2] != B || s6[3] != 0x0000)\n+\tabort ();\n+}"}, {"sha": "812c8d2cd4af2713ddc23c0d3664674e189c8f5c", "filename": "gcc/testsuite/gcc.dg/utf16-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf16-4.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,20 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Expected errors for char16_t character constants. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+typedef short unsigned int char16_t;\n+\n+char16_t\tc0 = u'';\t\t/* { dg-error \"empty character\" } */\n+char16_t\tc1 = u'ab';\t\t/* { dg-warning \"constant too long\" } */\n+char16_t\tc2 = u'\\U00064321';\t/* { dg-warning \"constant too long\" } */\n+\n+char16_t\tc3 = 'a';\n+char16_t\tc4 = U'a';\n+char16_t\tc5 = U'\\u2029';\n+char16_t\tc6 = U'\\U00064321';\t/* { dg-warning \"implicitly truncated\" } */\n+char16_t\tc7 = L'a';\n+char16_t\tc8 = L'\\u2029';\n+char16_t\tc9 = L'\\U00064321';\t/* { dg-warning \"implicitly truncated\" } */\n+\n+int main () {}"}, {"sha": "1807d57f6abe1d6c194acf5cc417e0c428da3f6f", "filename": "gcc/testsuite/gcc.dg/utf32-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-1.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,44 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char32_t character constants. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -Wall -Werror\" } */\n+\n+typedef unsigned int char32_t;\n+\n+extern void abort (void);\n+\n+char32_t\tc0 = U'a';\n+char32_t\tc1 = U'\\0';\n+char32_t\tc2 = U'\\u0024';\n+char32_t\tc3 = U'\\u2029';\n+char32_t\tc4 = U'\\U00064321';\n+\n+#define A\t0x00000061\n+#define D\t0x00000024\n+#define X\t0x00002029\n+#define Y\t0x00064321\n+\n+int main ()\n+{\n+    if (sizeof (U'a') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\0') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\u0024') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\u2029') != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (U'\\U00064321') != sizeof (char32_t))\n+\tabort ();\n+\n+    if (c0 != A)\n+\tabort ();\n+    if (c1 != 0x0000)\n+\tabort ();\n+    if (c2 != D)\n+\tabort ();\n+    if (c3 != X)\n+\tabort ();\n+    if (c4 != Y)\n+\tabort ();\n+}"}, {"sha": "820eb8c41aebdc2b7db78c5b546cd138ab6ee3b1", "filename": "gcc/testsuite/gcc.dg/utf32-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-2.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,31 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test the support for char32_t* string constants. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -Wall -Werror\" } */\n+\n+typedef unsigned int char32_t;\n+\n+extern void abort (void);\n+\n+char32_t\t*s0 = U\"ab\";\n+char32_t\t*s1 = U\"a\\u0024\";\n+char32_t\t*s2 = U\"a\\u2029\";\n+char32_t\t*s3 = U\"a\\U00064321\";\n+\n+#define A\t0x00000061\n+#define B\t0x00000062\n+#define D\t0x00000024\n+#define X\t0x00002029\n+#define Y\t0x00064321\n+\n+int main ()\n+{\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x00000000)\n+\tabort ();\n+    if (s1[0] != A || s1[1] != D || s0[2] != 0x00000000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != X || s0[2] != 0x00000000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != Y || s3[2] != 0x00000000)\n+\tabort ();\n+}"}, {"sha": "20cbc78e5f5a698fc00bfd0ce1aafa663432e821", "filename": "gcc/testsuite/gcc.dg/utf32-3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-3.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,48 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Test concatenation of char32_t* string literals. */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -Wall -Werror\" } */\n+\n+typedef unsigned int char32_t;\n+\n+extern void abort (void);\n+\n+char32_t\t*s0 = U\"a\" U\"b\";\n+\n+char32_t\t*s1 = U\"a\" \"b\";\n+char32_t\t*s2 = \"a\" U\"b\";\n+char32_t\t*s3 = U\"a\" \"\\u2029\";\n+char32_t\t*s4 = \"\\u2029\" U\"b\";\n+char32_t\t*s5 = U\"a\" \"\\U00064321\";\n+char32_t\t*s6 = \"\\U00064321\" U\"b\";\n+\n+#define A\t0x00000061\n+#define B\t0x00000062\n+#define X\t0x00002029\n+#define Y\t0x00064321\n+\n+int main ()\n+{\n+    if (sizeof ((U\"a\" U\"b\")[0]) != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof ((U\"a\"  \"b\")[0]) != sizeof (char32_t))\n+\tabort ();\n+    if (sizeof (( \"a\" U\"b\")[0]) != sizeof (char32_t))\n+\tabort ();\n+\n+    if (s0[0] != A || s0[1] != B || s0[2] != 0x00000000)\n+\tabort ();\n+\n+    if (s1[0] != A || s1[1] != B || s1[2] != 0x00000000)\n+\tabort ();\n+    if (s2[0] != A || s2[1] != B || s2[2] != 0x00000000)\n+\tabort ();\n+    if (s3[0] != A || s3[1] != X || s3[2] != 0x00000000)\n+\tabort ();\n+    if (s4[0] != X || s4[1] != B || s4[2] != 0x00000000)\n+\tabort ();\n+    if (s5[0] != A || s5[1] != Y || s5[2] != 0x00000000)\n+\tabort ();\n+    if (s6[0] != Y || s6[1] != B || s6[2] != 0x00000000)\n+\tabort ();\n+}"}, {"sha": "dd05a9a6c398c4607a2005d9129c33caf7496eb9", "filename": "gcc/testsuite/gcc.dg/utf32-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf32-4.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -0,0 +1,20 @@\n+/* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */\n+/* Expected errors for char32_t character constants. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+typedef unsigned int char32_t;\n+\n+char32_t\tc0 = U'';\t\t/* { dg-error \"empty character\" } */\n+char32_t\tc1 = U'ab';\t\t/* { dg-warning \"constant too long\" } */\n+char32_t\tc2 = U'\\U00064321';\n+\n+char32_t\tc3 = 'a';\n+char32_t\tc4 = u'a';\n+char32_t\tc5 = u'\\u2029';\n+char32_t\tc6 = u'\\U00064321';\t/* { dg-warning \"constant too long\" } */\n+char32_t\tc7 = L'a';\n+char32_t\tc8 = L'\\u2029';\n+char32_t\tc9 = L'\\U00064321';\n+\n+int main () {}"}, {"sha": "9eef6efb3e9e0b04b860dd33a7e5cc97cd33a4fd", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1,3 +1,40 @@\n+2008-04-18  Kris Van Hees <kris.van.hees@oracle.com>\n+\n+\t* include/cpp-id-data.h (UC): Was U, conflicts with U\"...\" literal.\n+\t* include/cpplib.h (CHAR16, CHAR32, STRING16, STRING32): New tokens.\n+\t(struct cpp_options): Added uliterals.\n+\t(cpp_interpret_string): Update prototype.\n+\t(cpp_interpret_string_notranslate): Idem.\n+\t* charset.c (init_iconv_desc): New width member in cset_converter.\n+\t(cpp_init_iconv): Add support for char{16,32}_cset_desc.\n+\t(convert_ucn): Idem.\n+\t(emit_numeric_escape): Idem.\n+\t(convert_hex): Idem.\n+\t(convert_oct): Idem.\n+\t(convert_escape): Idem.\n+\t(converter_for_type): New function.\n+\t(cpp_interpret_string): Use converter_for_type, support u and U prefix.\n+\t(cpp_interpret_string_notranslate): Match changed prototype.\n+\t(wide_str_to_charconst): Use converter_for_type.\n+\t(cpp_interpret_charconst): Add support for CPP_CHAR{16,32}.\n+\t* directives.c (linemarker_dir): Macro U changed to UC.\n+\t(parse_include): Idem.\n+\t(register_pragma_1): Idem.\n+\t(restore_registered_pragmas): Idem.\n+\t(get__Pragma_string): Support CPP_STRING{16,32}.\n+\t* expr.c (eval_token): Support CPP_CHAR{16,32}.\n+\t* init.c (struct lang_flags): Added uliterals.\n+\t(lang_defaults): Idem.\n+\t* internal.h (struct cset_converter) <width>: New field.\n+\t(struct cpp_reader) <char16_cset_desc>: Idem.\n+\t(struct cpp_reader) <char32_cset_desc>: Idem.\n+\t* lex.c (digraph_spellings): Macro U changed to UC.\n+\t(OP, TK): Idem.\n+\t(lex_string): Add support for u'...', U'...', u\"...\" and U\"...\".\n+\t(_cpp_lex_direct): Idem.\n+\t* macro.c (_cpp_builtin_macro_text): Macro U changed to UC.\n+\t(stringify_arg): Support CPP_CHAR{16,32} and CPP_STRING{16,32}.\n+\n 2008-04-18  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR bootstrap/35457"}, {"sha": "225cdb4915e5bf8850cc3ae982aa8aacf1e575df", "filename": "libcpp/charset.c", "status": "modified", "additions": 77, "deletions": 38, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -642,6 +642,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n     {\n       ret.func = convert_no_conversion;\n       ret.cd = (iconv_t) -1;\n+      ret.width = -1;\n       return ret;\n     }\n \n@@ -655,6 +656,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n       {\n \tret.func = conversion_tab[i].func;\n \tret.cd = conversion_tab[i].fake_cd;\n+\tret.width = -1;\n \treturn ret;\n       }\n \n@@ -663,6 +665,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n     {\n       ret.func = convert_using_iconv;\n       ret.cd = iconv_open (to, from);\n+      ret.width = -1;\n \n       if (ret.cd == (iconv_t) -1)\n \t{\n@@ -683,6 +686,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n \t\t from, to);\n       ret.func = convert_no_conversion;\n       ret.cd = (iconv_t) -1;\n+      ret.width = -1;\n     }\n   return ret;\n }\n@@ -716,7 +720,17 @@ cpp_init_iconv (cpp_reader *pfile)\n     wcset = default_wcset;\n \n   pfile->narrow_cset_desc = init_iconv_desc (pfile, ncset, SOURCE_CHARSET);\n+  pfile->narrow_cset_desc.width = CPP_OPTION (pfile, char_precision);\n+  pfile->char16_cset_desc = init_iconv_desc (pfile,\n+\t\t\t\t\t     be ? \"UTF-16BE\" : \"UTF-16LE\",\n+\t\t\t\t\t     SOURCE_CHARSET);\n+  pfile->char16_cset_desc.width = 16;\n+  pfile->char32_cset_desc = init_iconv_desc (pfile,\n+\t\t\t\t\t     be ? \"UTF-32BE\" : \"UTF-32LE\",\n+\t\t\t\t\t     SOURCE_CHARSET);\n+  pfile->char32_cset_desc.width = 32;\n   pfile->wide_cset_desc = init_iconv_desc (pfile, wcset, SOURCE_CHARSET);\n+  pfile->wide_cset_desc.width = CPP_OPTION (pfile, wchar_precision);\n }\n \n /* Destroy iconv(3) descriptors set up by cpp_init_iconv, if necessary.  */\n@@ -1051,15 +1065,13 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n    An advanced pointer is returned.  Issues all relevant diagnostics.  */\n static const uchar *\n convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct _cpp_strbuf *tbuf, bool wide)\n+\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt)\n {\n   cppchar_t ucn;\n   uchar buf[6];\n   uchar *bufp = buf;\n   size_t bytesleft = 6;\n   int rval;\n-  struct cset_converter cvt\n-    = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n   struct normalize_state nst = INITIAL_NORMALIZE_STATE;\n \n   from++;  /* Skip u/U.  */\n@@ -1086,14 +1098,15 @@ convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n    function issues no diagnostics and never fails.  */\n static void\n emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n-\t\t     struct _cpp_strbuf *tbuf, bool wide)\n+\t\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt)\n {\n-  if (wide)\n+  size_t width = cvt.width;\n+\n+  if (width != CPP_OPTION (pfile, char_precision))\n     {\n       /* We have to render this into the target byte order, which may not\n \t be our byte order.  */\n       bool bigend = CPP_OPTION (pfile, bytes_big_endian);\n-      size_t width = CPP_OPTION (pfile, wchar_precision);\n       size_t cwidth = CPP_OPTION (pfile, char_precision);\n       size_t cmask = width_to_mask (cwidth);\n       size_t nbwc = width / cwidth;\n@@ -1136,12 +1149,11 @@ emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n    number.  You can, e.g. generate surrogate pairs this way.  */\n static const uchar *\n convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct _cpp_strbuf *tbuf, bool wide)\n+\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt)\n {\n   cppchar_t c, n = 0, overflow = 0;\n   int digits_found = 0;\n-  size_t width = (wide ? CPP_OPTION (pfile, wchar_precision)\n-\t\t  : CPP_OPTION (pfile, char_precision));\n+  size_t width = cvt.width;\n   size_t mask = width_to_mask (width);\n \n   if (CPP_WTRADITIONAL (pfile))\n@@ -1174,7 +1186,7 @@ convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n       n &= mask;\n     }\n \n-  emit_numeric_escape (pfile, n, tbuf, wide);\n+  emit_numeric_escape (pfile, n, tbuf, cvt);\n \n   return from;\n }\n@@ -1187,12 +1199,11 @@ convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n    number.  */\n static const uchar *\n convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct _cpp_strbuf *tbuf, bool wide)\n+\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt)\n {\n   size_t count = 0;\n   cppchar_t c, n = 0;\n-  size_t width = (wide ? CPP_OPTION (pfile, wchar_precision)\n-\t\t  : CPP_OPTION (pfile, char_precision));\n+  size_t width = cvt.width;\n   size_t mask = width_to_mask (width);\n   bool overflow = false;\n \n@@ -1213,7 +1224,7 @@ convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n       n &= mask;\n     }\n \n-  emit_numeric_escape (pfile, n, tbuf, wide);\n+  emit_numeric_escape (pfile, n, tbuf, cvt);\n \n   return from;\n }\n@@ -1224,7 +1235,7 @@ convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n    pointer.  Handles all relevant diagnostics.  */\n static const uchar *\n convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t\tstruct _cpp_strbuf *tbuf, bool wide)\n+\t\tstruct _cpp_strbuf *tbuf, struct cset_converter cvt)\n {\n   /* Values of \\a \\b \\e \\f \\n \\r \\t \\v respectively.  */\n #if HOST_CHARSET == HOST_CHARSET_ASCII\n@@ -1236,23 +1247,21 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n #endif\n \n   uchar c;\n-  struct cset_converter cvt\n-    = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n \n   c = *from;\n   switch (c)\n     {\n       /* UCNs, hex escapes, and octal escapes are processed separately.  */\n     case 'u': case 'U':\n-      return convert_ucn (pfile, from, limit, tbuf, wide);\n+      return convert_ucn (pfile, from, limit, tbuf, cvt);\n \n     case 'x':\n-      return convert_hex (pfile, from, limit, tbuf, wide);\n+      return convert_hex (pfile, from, limit, tbuf, cvt);\n       break;\n \n     case '0':  case '1':  case '2':  case '3':\n     case '4':  case '5':  case '6':  case '7':\n-      return convert_oct (pfile, from, limit, tbuf, wide);\n+      return convert_oct (pfile, from, limit, tbuf, cvt);\n \n       /* Various letter escapes.  Get the appropriate host-charset\n \t value into C.  */\n@@ -1312,6 +1321,27 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n   return from + 1;\n }\n \f\n+/* TYPE is a token type.  The return value is the conversion needed to\n+   convert from source to execution character set for the given type. */\n+static struct cset_converter\n+converter_for_type (cpp_reader *pfile, enum cpp_ttype type)\n+{\n+  switch (type)\n+    {\n+    default:\n+\treturn pfile->narrow_cset_desc;\n+    case CPP_CHAR16:\n+    case CPP_STRING16:\n+\treturn pfile->char16_cset_desc;\n+    case CPP_CHAR32:\n+    case CPP_STRING32:\n+\treturn pfile->char32_cset_desc;\n+    case CPP_WCHAR:\n+    case CPP_WSTRING:\n+\treturn pfile->wide_cset_desc;\n+    }\n+}\n+\n /* FROM is an array of cpp_string structures of length COUNT.  These\n    are to be converted from the source to the execution character set,\n    escape sequences translated, and finally all are to be\n@@ -1320,13 +1350,12 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n    false for failure.  */\n bool\n cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n-\t\t      cpp_string *to, bool wide)\n+\t\t      cpp_string *to,  enum cpp_ttype type)\n {\n   struct _cpp_strbuf tbuf;\n   const uchar *p, *base, *limit;\n   size_t i;\n-  struct cset_converter cvt\n-    = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n+  struct cset_converter cvt = converter_for_type (pfile, type);\n \n   tbuf.asize = MAX (OUTBUF_BLOCK_SIZE, from->len);\n   tbuf.text = XNEWVEC (uchar, tbuf.asize);\n@@ -1335,7 +1364,7 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n   for (i = 0; i < count; i++)\n     {\n       p = from[i].text;\n-      if (*p == 'L') p++;\n+      if (*p == 'L' || *p == 'u' || *p == 'U') p++;\n       p++; /* Skip leading quote.  */\n       limit = from[i].text + from[i].len - 1; /* Skip trailing quote.  */\n \n@@ -1354,12 +1383,12 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n \t  if (p == limit)\n \t    break;\n \n-\t  p = convert_escape (pfile, p + 1, limit, &tbuf, wide);\n+\t  p = convert_escape (pfile, p + 1, limit, &tbuf, cvt);\n \t}\n     }\n   /* NUL-terminate the 'to' buffer and translate it to a cpp_string\n      structure.  */\n-  emit_numeric_escape (pfile, 0, &tbuf, wide);\n+  emit_numeric_escape (pfile, 0, &tbuf, cvt);\n   tbuf.text = XRESIZEVEC (uchar, tbuf.text, tbuf.len);\n   to->text = tbuf.text;\n   to->len = tbuf.len;\n@@ -1375,15 +1404,16 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n    in a string, but do not perform character set conversion.  */\n bool\n cpp_interpret_string_notranslate (cpp_reader *pfile, const cpp_string *from,\n-\t\t\t\t  size_t count,\tcpp_string *to, bool wide)\n+\t\t\t\t  size_t count,\tcpp_string *to,\n+\t\t\t\t  enum cpp_ttype type ATTRIBUTE_UNUSED)\n {\n   struct cset_converter save_narrow_cset_desc = pfile->narrow_cset_desc;\n   bool retval;\n \n   pfile->narrow_cset_desc.func = convert_no_conversion;\n   pfile->narrow_cset_desc.cd = (iconv_t) -1;\n \n-  retval = cpp_interpret_string (pfile, from, count, to, wide);\n+  retval = cpp_interpret_string (pfile, from, count, to, CPP_STRING);\n \n   pfile->narrow_cset_desc = save_narrow_cset_desc;\n   return retval;\n@@ -1462,13 +1492,14 @@ narrow_str_to_charconst (cpp_reader *pfile, cpp_string str,\n /* Subroutine of cpp_interpret_charconst which performs the conversion\n    to a number, for wide strings.  STR is the string structure returned\n    by cpp_interpret_string.  PCHARS_SEEN and UNSIGNEDP are as for\n-   cpp_interpret_charconst.  */\n+   cpp_interpret_charconst.  TYPE is the token type.  */\n static cppchar_t\n wide_str_to_charconst (cpp_reader *pfile, cpp_string str,\n-\t\t       unsigned int *pchars_seen, int *unsignedp)\n+\t\t       unsigned int *pchars_seen, int *unsignedp,\n+\t\t       enum cpp_ttype type)\n {\n   bool bigend = CPP_OPTION (pfile, bytes_big_endian);\n-  size_t width = CPP_OPTION (pfile, wchar_precision);\n+  size_t width = converter_for_type (pfile, type).width;\n   size_t cwidth = CPP_OPTION (pfile, char_precision);\n   size_t mask = width_to_mask (width);\n   size_t cmask = width_to_mask (cwidth);\n@@ -1490,21 +1521,28 @@ wide_str_to_charconst (cpp_reader *pfile, cpp_string str,\n   /* Wide character constants have type wchar_t, and a single\n      character exactly fills a wchar_t, so a multi-character wide\n      character constant is guaranteed to overflow.  */\n-  if (off > 0)\n+  if (str.len > nbwc * 2)\n     cpp_error (pfile, CPP_DL_WARNING,\n \t       \"character constant too long for its type\");\n \n   /* Truncate the constant to its natural width, and simultaneously\n      sign- or zero-extend to the full width of cppchar_t.  */\n   if (width < BITS_PER_CPPCHAR_T)\n     {\n-      if (CPP_OPTION (pfile, unsigned_wchar) || !(result & (1 << (width - 1))))\n+      if (type == CPP_CHAR16 || type == CPP_CHAR32\n+\t  || CPP_OPTION (pfile, unsigned_wchar)\n+\t  || !(result & (1 << (width - 1))))\n \tresult &= mask;\n       else\n \tresult |= ~mask;\n     }\n \n-  *unsignedp = CPP_OPTION (pfile, unsigned_wchar);\n+  if (type == CPP_CHAR16 || type == CPP_CHAR32\n+      || CPP_OPTION (pfile, unsigned_wchar))\n+    *unsignedp = 1;\n+  else\n+    *unsignedp = 0;\n+\n   *pchars_seen = 1;\n   return result;\n }\n@@ -1518,20 +1556,21 @@ cpp_interpret_charconst (cpp_reader *pfile, const cpp_token *token,\n \t\t\t unsigned int *pchars_seen, int *unsignedp)\n {\n   cpp_string str = { 0, 0 };\n-  bool wide = (token->type == CPP_WCHAR);\n+  bool wide = (token->type != CPP_CHAR);\n   cppchar_t result;\n \n-  /* an empty constant will appear as L'' or '' */\n+  /* an empty constant will appear as L'', u'', U'' or '' */\n   if (token->val.str.len == (size_t) (2 + wide))\n     {\n       cpp_error (pfile, CPP_DL_ERROR, \"empty character constant\");\n       return 0;\n     }\n-  else if (!cpp_interpret_string (pfile, &token->val.str, 1, &str, wide))\n+  else if (!cpp_interpret_string (pfile, &token->val.str, 1, &str, token->type))\n     return 0;\n \n   if (wide)\n-    result = wide_str_to_charconst (pfile, str, pchars_seen, unsignedp);\n+    result = wide_str_to_charconst (pfile, str, pchars_seen, unsignedp,\n+\t\t\t\t    token->type);\n   else\n     result = narrow_str_to_charconst (pfile, str, pchars_seen, unsignedp);\n "}, {"sha": "3478cd5047ace5cc2c6caff4efe14674ed182348", "filename": "libcpp/directives.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -188,7 +188,7 @@ DIRECTIVE_TABLE\n    did use this notation in its preprocessed output.  */\n static const directive linemarker_dir =\n {\n-  do_linemarker, U\"#\", 1, KANDR, IN_I\n+  do_linemarker, UC\"#\", 1, KANDR, IN_I\n };\n \n #define SEEN_EOL() (pfile->cur_token[-1].type == CPP_EOF)\n@@ -697,7 +697,7 @@ parse_include (cpp_reader *pfile, int *pangle_brackets,\n       const unsigned char *dir;\n \n       if (pfile->directive == &dtable[T_PRAGMA])\n-\tdir = U\"pragma dependency\";\n+\tdir = UC\"pragma dependency\";\n       else\n \tdir = pfile->directive->name;\n       cpp_error (pfile, CPP_DL_ERROR, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\",\n@@ -1085,7 +1085,7 @@ register_pragma_1 (cpp_reader *pfile, const char *space, const char *name,\n \n   if (space)\n     {\n-      node = cpp_lookup (pfile, U space, strlen (space));\n+      node = cpp_lookup (pfile, UC space, strlen (space));\n       entry = lookup_pragma_entry (*chain, node);\n       if (!entry)\n \t{\n@@ -1114,7 +1114,7 @@ register_pragma_1 (cpp_reader *pfile, const char *space, const char *name,\n     }\n \n   /* Check for duplicates.  */\n-  node = cpp_lookup (pfile, U name, strlen (name));\n+  node = cpp_lookup (pfile, UC name, strlen (name));\n   entry = lookup_pragma_entry (*chain, node);\n   if (entry == NULL)\n     {\n@@ -1262,7 +1262,7 @@ restore_registered_pragmas (cpp_reader *pfile, struct pragma_entry *pe,\n     {\n       if (pe->is_nspace)\n \tsd = restore_registered_pragmas (pfile, pe->u.space, sd);\n-      pe->pragma = cpp_lookup (pfile, U *sd, strlen (*sd));\n+      pe->pragma = cpp_lookup (pfile, UC *sd, strlen (*sd));\n       free (*sd);\n       sd++;\n     }\n@@ -1491,7 +1491,8 @@ get__Pragma_string (cpp_reader *pfile)\n   string = get_token_no_padding (pfile);\n   if (string->type == CPP_EOF)\n     _cpp_backup_tokens (pfile, 1);\n-  if (string->type != CPP_STRING && string->type != CPP_WSTRING)\n+  if (string->type != CPP_STRING && string->type != CPP_WSTRING\n+      && string->type != CPP_STRING32 && string->type != CPP_STRING16)\n     return NULL;\n \n   paren = get_token_no_padding (pfile);"}, {"sha": "00149b2422d2922590eb0f29ab3ac15cbd8b7314", "filename": "libcpp/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -705,6 +705,8 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n \n     case CPP_WCHAR:\n     case CPP_CHAR:\n+    case CPP_CHAR16:\n+    case CPP_CHAR32:\n       {\n \tcppchar_t cc = cpp_interpret_charconst (pfile, token,\n \t\t\t\t\t\t&temp, &unsignedp);\n@@ -863,6 +865,8 @@ _cpp_parse_expr (cpp_reader *pfile)\n \tcase CPP_NUMBER:\n \tcase CPP_CHAR:\n \tcase CPP_WCHAR:\n+\tcase CPP_CHAR16:\n+\tcase CPP_CHAR32:\n \tcase CPP_NAME:\n \tcase CPP_HASH:\n \t  if (!want_value)"}, {"sha": "db37c2becccf362a52066694728580534627573a", "filename": "libcpp/include/cpp-id-data.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finclude%2Fcpp-id-data.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finclude%2Fcpp-id-data.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpp-id-data.h?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -22,7 +22,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */\n typedef unsigned char uchar;\n #endif\n \n-#define U (const unsigned char *)  /* Intended use: U\"string\" */\n+#define UC (const unsigned char *)  /* Intended use: UC\"string\" */\n \n /* Chained list of answers to an assertion.  */\n struct answer GTY(())"}, {"sha": "483c54331fb9c1fe873d6435b4078cf962b75e39", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -123,10 +123,14 @@ struct _cpp_file;\n \t\t\t\t\t\t\t\t\t\\\n   TK(CHAR,\t\tLITERAL) /* 'char' */\t\t\t\t\\\n   TK(WCHAR,\t\tLITERAL) /* L'char' */\t\t\t\t\\\n+  TK(CHAR16,\t\tLITERAL) /* u'char' */\t\t\t\t\\\n+  TK(CHAR32,\t\tLITERAL) /* U'char' */\t\t\t\t\\\n   TK(OTHER,\t\tLITERAL) /* stray punctuation */\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   TK(STRING,\t\tLITERAL) /* \"string\" */\t\t\t\t\\\n   TK(WSTRING,\t\tLITERAL) /* L\"string\" */\t\t\t\\\n+  TK(STRING16,\t\tLITERAL) /* u\"string\" */\t\t\t\\\n+  TK(STRING32,\t\tLITERAL) /* U\"string\" */\t\t\t\\\n   TK(OBJC_STRING,\tLITERAL) /* @\"string\" - Objective-C */\t\t\\\n   TK(HEADER_NAME,\tLITERAL) /* <stdio.h> in #include */\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -291,6 +295,9 @@ struct cpp_options\n   /* Nonzero means to allow hexadecimal floats and LL suffixes.  */\n   unsigned char extended_numbers;\n \n+  /* Nonzero means process u/U prefix literals (UTF-16/32).  */\n+  unsigned char uliterals;\n+\n   /* Nonzero means print names of header files (-H).  */\n   unsigned char print_include_names;\n \n@@ -712,10 +719,10 @@ extern cppchar_t cpp_interpret_charconst (cpp_reader *, const cpp_token *,\n /* Evaluate a vector of CPP_STRING or CPP_WSTRING tokens.  */\n extern bool cpp_interpret_string (cpp_reader *,\n \t\t\t\t  const cpp_string *, size_t,\n-\t\t\t\t  cpp_string *, bool);\n+\t\t\t\t  cpp_string *, enum cpp_ttype);\n extern bool cpp_interpret_string_notranslate (cpp_reader *,\n \t\t\t\t\t      const cpp_string *, size_t,\n-\t\t\t\t\t      cpp_string *, bool);\n+\t\t\t\t\t      cpp_string *, enum cpp_ttype);\n \n /* Convert a host character constant to the execution character set.  */\n extern cppchar_t cpp_host_to_exec_charset (cpp_reader *, cppchar_t);"}, {"sha": "040bf2a04897a5a37791c987a2a61ba37ec999bb", "filename": "libcpp/init.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -76,20 +76,21 @@ struct lang_flags\n   char std;\n   char cplusplus_comments;\n   char digraphs;\n+  char uliterals;\n };\n \n static const struct lang_flags lang_defaults[] =\n-{ /*              c99 c++ xnum xid std  //   digr  */\n-  /* GNUC89   */  { 0,  0,  1,   0,  0,   1,   1     },\n-  /* GNUC99   */  { 1,  0,  1,   0,  0,   1,   1     },\n-  /* STDC89   */  { 0,  0,  0,   0,  1,   0,   0     },\n-  /* STDC94   */  { 0,  0,  0,   0,  1,   0,   1     },\n-  /* STDC99   */  { 1,  0,  1,   0,  1,   1,   1     },\n-  /* GNUCXX   */  { 0,  1,  1,   0,  0,   1,   1     },\n-  /* CXX98    */  { 0,  1,  1,   0,  1,   1,   1     },\n-  /* GNUCXX0X */  { 1,  1,  1,   0,  0,   1,   1     },\n-  /* CXX0X    */  { 1,  1,  1,   0,  1,   1,   1     },\n-  /* ASM      */  { 0,  0,  1,   0,  0,   1,   0     }\n+{ /*              c99 c++ xnum xid std  //   digr ulit */\n+  /* GNUC89   */  { 0,  0,  1,   0,  0,   1,   1,   0 },\n+  /* GNUC99   */  { 1,  0,  1,   0,  0,   1,   1,   1 },\n+  /* STDC89   */  { 0,  0,  0,   0,  1,   0,   0,   0 },\n+  /* STDC94   */  { 0,  0,  0,   0,  1,   0,   1,   0 },\n+  /* STDC99   */  { 1,  0,  1,   0,  1,   1,   1,   0 },\n+  /* GNUCXX   */  { 0,  1,  1,   0,  0,   1,   1,   0 },\n+  /* CXX98    */  { 0,  1,  1,   0,  1,   1,   1,   0 },\n+  /* GNUCXX0X */  { 1,  1,  1,   0,  0,   1,   1,   1 },\n+  /* CXX0X    */  { 1,  1,  1,   0,  1,   1,   1,   1 },\n+  /* ASM      */  { 0,  0,  1,   0,  0,   1,   0,   0 }\n   /* xid should be 1 for GNUC99, STDC99, GNUCXX, CXX98, GNUCXX0X, and\n      CXX0X when no longer experimental (when all uses of identifiers\n      in the compiler have been audited for correct handling of\n@@ -112,6 +113,7 @@ cpp_set_lang (cpp_reader *pfile, enum c_lang lang)\n   CPP_OPTION (pfile, trigraphs)\t\t\t = l->std;\n   CPP_OPTION (pfile, cplusplus_comments)\t = l->cplusplus_comments;\n   CPP_OPTION (pfile, digraphs)\t\t\t = l->digraphs;\n+  CPP_OPTION (pfile, uliterals)\t\t\t = l->uliterals;\n }\n \n /* Initialize library global state.  */"}, {"sha": "bf6c5f8c8d2e9ac8e4792fd8334fbcfe06c5826f", "filename": "libcpp/internal.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -48,6 +48,7 @@ struct cset_converter\n {\n   convert_f func;\n   iconv_t cd;\n+  int width;\n };\n \n #define BITS_PER_CPPCHAR_T (CHAR_BIT * sizeof (cppchar_t))\n@@ -398,6 +399,14 @@ struct cpp_reader\n      execution character set.  */\n   struct cset_converter narrow_cset_desc;\n \n+  /* Descriptor for converting from the source character set to the\n+     UTF-16 execution character set.  */\n+  struct cset_converter char16_cset_desc;\n+\n+  /* Descriptor for converting from the source character set to the\n+     UTF-32 execution character set.  */\n+  struct cset_converter char32_cset_desc;\n+\n   /* Descriptor for converting from the source character set to the\n      wide execution character set.  */\n   struct cset_converter wide_cset_desc;"}, {"sha": "772a8701654b8af476488df89e1d3e1b69c9f26d", "filename": "libcpp/lex.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -39,10 +39,10 @@ struct token_spelling\n };\n \n static const unsigned char *const digraph_spellings[] =\n-{ U\"%:\", U\"%:%:\", U\"<:\", U\":>\", U\"<%\", U\"%>\" };\n+{ UC\"%:\", UC\"%:%:\", UC\"<:\", UC\":>\", UC\"<%\", UC\"%>\" };\n \n-#define OP(e, s) { SPELL_OPERATOR, U s  },\n-#define TK(e, s) { SPELL_ ## s,    U #e },\n+#define OP(e, s) { SPELL_OPERATOR, UC s  },\n+#define TK(e, s) { SPELL_ ## s,    UC #e },\n static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n #undef OP\n #undef TK\n@@ -611,8 +611,8 @@ create_literal (cpp_reader *pfile, cpp_token *token, const uchar *base,\n \n /* Lexes a string, character constant, or angle-bracketed header file\n    name.  The stored string contains the spelling, including opening\n-   quote and leading any leading 'L'.  It returns the type of the\n-   literal, or CPP_OTHER if it was not properly terminated.\n+   quote and leading any leading 'L', 'u' or 'U'.  It returns the type\n+   of the literal, or CPP_OTHER if it was not properly terminated.\n \n    The spelling is NUL-terminated, but it is not guaranteed that this\n    is the first NUL since embedded NULs are preserved.  */\n@@ -626,12 +626,16 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \n   cur = base;\n   terminator = *cur++;\n-  if (terminator == 'L')\n+  if (terminator == 'L' || terminator == 'u' || terminator == 'U')\n     terminator = *cur++;\n   if (terminator == '\\\"')\n-    type = *base == 'L' ? CPP_WSTRING: CPP_STRING;\n+    type = (*base == 'L' ? CPP_WSTRING :\n+\t    *base == 'U' ? CPP_STRING32 :\n+\t    *base == 'u' ? CPP_STRING16 : CPP_STRING);\n   else if (terminator == '\\'')\n-    type = *base == 'L' ? CPP_WCHAR: CPP_CHAR;\n+    type = (*base == 'L' ? CPP_WCHAR :\n+\t    *base == 'U' ? CPP_CHAR32 :\n+\t    *base == 'u' ? CPP_CHAR16 : CPP_CHAR);\n   else\n     terminator = '>', type = CPP_HEADER_NAME;\n \n@@ -965,24 +969,29 @@ _cpp_lex_direct (cpp_reader *pfile)\n       }\n \n     case 'L':\n-      /* 'L' may introduce wide characters or strings.  */\n-      if (*buffer->cur == '\\'' || *buffer->cur == '\"')\n+    case 'u':\n+    case 'U':\n+      /* 'L', 'u' or 'U' may introduce wide characters or strings.  */\n+      if (c == 'L' || CPP_OPTION (pfile, uliterals))\n \t{\n-\t  lex_string (pfile, result, buffer->cur - 1);\n-\t  break;\n+\t  if (*buffer->cur == '\\'' || *buffer->cur == '\"')\n+\t    {\n+\t      lex_string (pfile, result, buffer->cur - 1);\n+\t      break;\n+\t    }\n \t}\n       /* Fall through.  */\n \n     case '_':\n     case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n     case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n     case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n-    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+    case 's': case 't':           case 'v': case 'w': case 'x':\n     case 'y': case 'z':\n     case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n     case 'G': case 'H': case 'I': case 'J': case 'K':\n     case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n-    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+    case 'S': case 'T':           case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n       result->type = CPP_NAME;\n       {"}, {"sha": "016754bc9529566ce2929bd1801bf13942b2f39c", "filename": "libcpp/macro.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -158,7 +158,7 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n \t\t  {\n \t\t    cpp_errno (pfile, CPP_DL_WARNING,\n \t\t\t\"could not determine file timestamp\");\n-\t\t    pbuffer->timestamp = U\"\\\"??? ??? ?? ??:??:?? ????\\\"\";\n+\t\t    pbuffer->timestamp = UC\"\\\"??? ??? ?? ??:??:?? ????\\\"\";\n \t\t  }\n \t      }\n \t  }\n@@ -256,8 +256,8 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n \t      cpp_errno (pfile, CPP_DL_WARNING,\n \t\t\t \"could not determine date and time\");\n \t\t\n-\t      pfile->date = U\"\\\"??? ?? ????\\\"\";\n-\t      pfile->time = U\"\\\"??:??:??\\\"\";\n+\t      pfile->date = UC\"\\\"??? ?? ????\\\"\";\n+\t      pfile->time = UC\"\\\"??:??:??\\\"\";\n \t    }\n \t}\n \n@@ -375,8 +375,10 @@ stringify_arg (cpp_reader *pfile, macro_arg *arg)\n \t  continue;\n \t}\n \n-      escape_it = (token->type == CPP_STRING || token->type == CPP_WSTRING\n-\t\t   || token->type == CPP_CHAR || token->type == CPP_WCHAR);\n+      escape_it = (token->type == CPP_STRING || token->type == CPP_CHAR\n+\t\t   || token->type == CPP_WSTRING || token->type == CPP_STRING\n+\t\t   || token->type == CPP_STRING32 || token->type == CPP_CHAR32\n+\t\t   || token->type == CPP_STRING16 || token->type == CPP_CHAR16);\n \n       /* Room for each char being written in octal, initial space and\n \t final quote and NUL.  */"}, {"sha": "807182529844928582138e0b46198eb1f7787259", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -1,3 +1,7 @@\n+2008-04-18  Kris Van Hees <kris.van.hees@oracle.com>\n+\n+\t* testsuite/demangle-expected: Added tests for char16_t and char32_t.\n+\n 2008-04-18  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR bootstrap/35457"}, {"sha": "2745dd3d13b525dc2ca3422dbf69f34c6abc0606", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=b6baa67d7947f7e4fc1481c87fcb55d54c56f0cf", "patch": "@@ -3399,6 +3399,26 @@ foo(char)\n foo\n #\n --format=gnu-v3 --no-params\n+_Z2f0u8char16_t\n+f0(char16_t)\n+f0\n+#\n+--format=gnu-v3 --no-params\n+_Z2f0Pu8char16_t\n+f0(char16_t*)\n+f0\n+#\n+--format=gnu-v3 --no-params\n+_Z2f0u8char32_t\n+f0(char32_t)\n+f0\n+#\n+--format=gnu-v3 --no-params\n+_Z2f0Pu8char32_t\n+f0(char32_t*)\n+f0\n+#\n+--format=gnu-v3 --no-params\n 2CBIL_Z3foocEE\n CB<foo(char)>\n CB<foo(char)>"}]}