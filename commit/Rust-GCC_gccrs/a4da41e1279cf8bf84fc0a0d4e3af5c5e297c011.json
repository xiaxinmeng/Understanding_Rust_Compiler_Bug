{"sha": "a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkYTQxZTEyNzljZjhiZjg0ZmMwYTBkNGUzYWY1YzVlMjk3YzAxMQ==", "commit": {"author": {"name": "Easwaran Raman", "email": "eraman@google.com", "date": "2012-10-16T05:28:08Z"}, "committer": {"name": "Easwaran Raman", "email": "eraman@gcc.gnu.org", "date": "2012-10-16T05:28:08Z"}, "message": "[multiple changes]\n\n2012-10-15   Easwaran Raman  <eraman@google.com>\n\n        * optabs.c (emit_cmp_and_jump_insn_1): Add a new parameter to\n        specificy the probability of taking the jump.\n        (emit_cmp_and_jump_insns): Likewise.\n        (expand_compare_and_swap_loop): Make the jump predicted not taken.\n        * dojump.c (do_compare_rtx_and_jump): Remove the code attaching\n        REG_BR_PROB note and pass probability to emit_cmp_and_jump_insns.\n        * cfgbuild.c (compute_outgoing_frequencies): Do not guess outgoing\n        probabilities for branches with more than two successors.\n        * expr.c (emit_block_move_via_loop): Predict the loop backedge loop\n        to be highly taken.\n        (try_casesi): Pass the probability of jumping to the default label.\n        (try_tablejump): Likewise.\n        (do_tablejump): Likewise.\n        * expr.h (try_tablejump): Add a new parameter.\n        (try_casesi): Likewise.\n        (emit_cmp_and_jump_insns): Add probability as default parameter with a\n        default value of -1.\n        * except.c (sjlj_emit_function_enter): Pass probability to\n        emit_cmp_and_jump_insns.\n        * stmt.c (case_node): Add new fields PROB and SUBTREE_PROB.\n        (do_jump_if_equal): Pass probability for REG_BR_PROB note.\n        (add_case_node): Pass estimated probability of jumping to the case\n        label.\n        (emit_case_decision_tree): Pass default_prob to emit_case_nodes.\n        (get_outgoing_edge_probs): New function.\n        (conditional_probability): Likewise.\n        (reset_out_edges_aux): Likewise.\n        (compute_cases_per_edge): Likewise.\n        (emit_case_dispatch_table): Update probabilities of edges coming out\n        of the switch statement.\n        (expand_case): Compute and propagate default edge probability to\n        emit_case_dispatch_table.\n        (expand_sjlj_dispatch_table): Update calls to add_case_node and\n        emit_case_dispatch_table.\n        (balance_case_nodes): Update subtree_prob values.\n        (emit_case_nodes): Compute edge probabilities and add pass them to\n        emit_cmp_and_jump_insns.\n\ntestsuite/ChangeLog:\n2012-10-15   Easwaran Raman  <eraman@google.com> \n        * gcc.dg/tree-prof/switch-case-1.c: New test case.\n        * gcc.dg/tree-prof/switch-case-2.c: New test case.\n\nFrom-SVN: r192488", "tree": {"sha": "73e706f18d0cfa88bafa5eb814ff70dbc3d9885c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73e706f18d0cfa88bafa5eb814ff70dbc3d9885c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/comments", "author": null, "committer": null, "parents": [{"sha": "07a1164095855c3556b24245e6d89a2f59b626b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a1164095855c3556b24245e6d89a2f59b626b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a1164095855c3556b24245e6d89a2f59b626b0"}], "stats": {"total": 643, "additions": 509, "deletions": 134}, "files": [{"sha": "b56c773ebc93a1866f675387ab0a545673ade3d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -1,3 +1,43 @@\n+2012-10-15   Easwaran Raman  <eraman@google.com>\n+\n+\t* optabs.c (emit_cmp_and_jump_insn_1): Add a new parameter to\n+\tspecificy the probability of taking the jump.\n+\t(emit_cmp_and_jump_insns): Likewise.\n+\t(expand_compare_and_swap_loop): Make the jump predicted not taken.\n+\t* dojump.c (do_compare_rtx_and_jump): Remove the code attaching\n+\tREG_BR_PROB note and pass probability to emit_cmp_and_jump_insns.\n+\t* cfgbuild.c (compute_outgoing_frequencies): Do not guess outgoing\n+\tprobabilities for branches with more than two successors.\n+\t* expr.c (emit_block_move_via_loop): Predict the loop backedge loop\n+\tto be highly taken.\n+\t(try_casesi): Pass the probability of jumping to the default label.\n+\t(try_tablejump): Likewise.\n+\t(do_tablejump): Likewise.\n+\t* expr.h (try_tablejump): Add a new parameter.\n+\t(try_casesi): Likewise.\n+\t(emit_cmp_and_jump_insns): Add probability as default parameter with a\n+\tdefault value of -1.\n+\t* except.c (sjlj_emit_function_enter): Pass probability to\n+\temit_cmp_and_jump_insns.\n+\t* stmt.c (case_node): Add new fields PROB and SUBTREE_PROB.\n+\t(do_jump_if_equal): Pass probability for REG_BR_PROB note.\n+\t(add_case_node): Pass estimated probability of jumping to the case\n+\tlabel.\n+\t(emit_case_decision_tree): Pass default_prob to emit_case_nodes.\n+\t(get_outgoing_edge_probs): New function.\n+\t(conditional_probability): Likewise.\n+\t(reset_out_edges_aux): Likewise.\n+\t(compute_cases_per_edge): Likewise.\n+\t(emit_case_dispatch_table): Update probabilities of edges coming out\n+\tof the switch statement.\n+\t(expand_case): Compute and propagate default edge probability to\n+\temit_case_dispatch_table.\n+\t(expand_sjlj_dispatch_table): Update calls to add_case_node and\n+\temit_case_dispatch_table.\n+\t(balance_case_nodes): Update subtree_prob values.\n+\t(emit_case_nodes): Compute edge probabilities and add pass them to\n+\temit_cmp_and_jump_insns.\n+\n 2012-10-15  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "6e5c6ef75a70b483ee879f4b0f63e9c013164fda", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -559,16 +559,35 @@ compute_outgoing_frequencies (basic_block b)\n \t  f->count = b->count - e->count;\n \t  return;\n \t}\n+      else\n+        {\n+          guess_outgoing_edge_probabilities (b);\n+        }\n     }\n-\n-  if (single_succ_p (b))\n+  else if (single_succ_p (b))\n     {\n       e = single_succ_edge (b);\n       e->probability = REG_BR_PROB_BASE;\n       e->count = b->count;\n       return;\n     }\n-  guess_outgoing_edge_probabilities (b);\n+  else\n+    {\n+      /* We rely on BBs with more than two successors to have sane probabilities\n+         and do not guess them here. For BBs terminated by switch statements\n+         expanded to jump-table jump, we have done the right thing during\n+         expansion. For EH edges, we still guess the probabilities here.  */\n+      bool complex_edge = false;\n+      FOR_EACH_EDGE (e, ei, b->succs)\n+        if (e->flags & EDGE_COMPLEX)\n+          {\n+            complex_edge = true;\n+            break;\n+          }\n+      if (complex_edge)\n+        guess_outgoing_edge_probabilities (b);\n+    }\n+\n   if (b->count)\n     FOR_EACH_EDGE (e, ei, b->succs)\n       e->count = ((b->count * e->probability + REG_BR_PROB_BASE / 2)"}, {"sha": "35cb2cf62ebc8e4892af3f96e5e532128effdab9", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -886,7 +886,6 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n {\n   rtx tem;\n   rtx dummy_label = NULL_RTX;\n-  rtx last;\n \n   /* Reverse the comparison if that is safe and we want to jump if it is\n      false.  Also convert to the reverse comparison if the target can\n@@ -1069,25 +1068,8 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t    }\n \t}\n \n-      last = get_last_insn ();\n       emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n-\t\t\t       if_true_label);\n-      if (prob != -1 && profile_status != PROFILE_ABSENT)\n-\t{\n-\t  for (last = NEXT_INSN (last);\n-\t       last && NEXT_INSN (last);\n-\t       last = NEXT_INSN (last))\n-\t    if (JUMP_P (last))\n-\t      break;\n-\t  if (last\n-\t      && JUMP_P (last)\n-\t      && ! NEXT_INSN (last)\n-\t      && any_condjump_p (last))\n-\t    {\n-\t      gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n-\t      add_reg_note (last, REG_BR_PROB, GEN_INT (prob));\n-\t    }\n-\t}\n+\t\t\t       if_true_label, prob);\n     }\n \n   if (if_false_label)"}, {"sha": "adafe8ccb05514580894c38be19983c219d75c64", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -1161,13 +1161,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n \n       emit_cmp_and_jump_insns (x, const0_rtx, NE, 0,\n \t\t\t       TYPE_MODE (integer_type_node), 0,\n-\t\t\t       dispatch_label);\n-      last = get_last_insn ();\n-      if (JUMP_P (last) && any_condjump_p (last))\n-\t{\n-\t  gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));\n-\t  add_reg_note (last, REG_BR_PROB, GEN_INT (REG_BR_PROB_BASE / 100));\n-\t}\n+\t\t\t       dispatch_label, REG_BR_PROB_BASE / 100);\n #else\n       expand_builtin_setjmp_setup (plus_constant (Pmode, XEXP (fc, 0),\n \t\t\t\t\t\t  sjlj_fc_jbuf_ofs),"}, {"sha": "3043176364954ccdc38d5818199dbbd6d7507354", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -154,7 +154,7 @@ static rtx do_store_flag (sepops, rtx, enum machine_mode);\n #ifdef PUSH_ROUNDING\n static void emit_single_push_insn (enum machine_mode, rtx, tree);\n #endif\n-static void do_tablejump (rtx, enum machine_mode, rtx, rtx, rtx);\n+static void do_tablejump (rtx, enum machine_mode, rtx, rtx, rtx, int);\n static rtx const_vector_from_tree (tree);\n static void write_complex_part (rtx, rtx, bool);\n \n@@ -1483,7 +1483,7 @@ emit_block_move_via_loop (rtx x, rtx y, rtx size,\n   emit_label (cmp_label);\n \n   emit_cmp_and_jump_insns (iter, size, LT, NULL_RTX, iter_mode,\n-\t\t\t   true, top_label);\n+\t\t\t   true, top_label, REG_BR_PROB_BASE * 90 / 100);\n }\n \f\n /* Copy all or part of a value X into registers starting at REGNO.\n@@ -10824,10 +10824,14 @@ do_store_flag (sepops ops, rtx target, enum machine_mode mode)\n #endif\n \n /* Attempt to generate a casesi instruction.  Returns 1 if successful,\n-   0 otherwise (i.e. if there is no casesi instruction).  */\n+   0 otherwise (i.e. if there is no casesi instruction).\n+\n+   DEFAULT_PROBABILITY is the probability of jumping to the default\n+   label.  */\n int\n try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n-\t    rtx table_label, rtx default_label, rtx fallback_label)\n+\t    rtx table_label, rtx default_label, rtx fallback_label,\n+            int default_probability)\n {\n   struct expand_operand ops[5];\n   enum machine_mode index_mode = SImode;\n@@ -10849,7 +10853,8 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n       index = expand_normal (index_expr);\n       if (default_label)\n         emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n-\t\t\t\t omode, 1, default_label);\n+\t\t\t\t omode, 1, default_label,\n+                                 default_probability);\n       /* Now we can safely truncate.  */\n       index = convert_to_mode (index_mode, index, 0);\n     }\n@@ -10895,11 +10900,13 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n    TABLE_LABEL is a CODE_LABEL rtx for the table itself.\n \n    DEFAULT_LABEL is a CODE_LABEL rtx to jump to if the\n-   index value is out of range.  */\n+   index value is out of range.\n+   DEFAULT_PROBABILITY is the probability of jumping to\n+   the default label.  */\n \n static void\n do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n-\t      rtx default_label)\n+\t      rtx default_label, int default_probability)\n {\n   rtx temp, vector;\n \n@@ -10916,7 +10923,8 @@ do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n \n   if (default_label)\n     emit_cmp_and_jump_insns (index, range, GTU, NULL_RTX, mode, 1,\n-\t\t\t     default_label);\n+\t\t\t     default_label, default_probability);\n+\n \n   /* If index is in range, it must fit in Pmode.\n      Convert to Pmode so we can index with it.  */\n@@ -10959,7 +10967,7 @@ do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n \n int\n try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n-\t       rtx table_label, rtx default_label)\n+\t       rtx table_label, rtx default_label, int default_probability)\n {\n   rtx index;\n \n@@ -10977,7 +10985,7 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n \t\t\t       TYPE_MODE (TREE_TYPE (range)),\n \t\t\t       expand_normal (range),\n \t\t\t       TYPE_UNSIGNED (TREE_TYPE (range))),\n-\t\ttable_label, default_label);\n+\t\ttable_label, default_label, default_probability);\n   return 1;\n }\n "}, {"sha": "562ffe03aca68e503f8cfa3f382f8c0574e25ccd", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -190,7 +190,7 @@ extern int have_sub2_insn (rtx, rtx);\n /* Emit a pair of rtl insns to compare two rtx's and to jump\n    to a label if the comparison is true.  */\n extern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t     enum machine_mode, int, rtx);\n+\t\t\t\t     enum machine_mode, int, rtx, int prob=-1);\n \n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n extern void emit_indirect_jump (rtx);\n@@ -485,8 +485,8 @@ extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n \t\t\t\t     enum machine_mode, rtx, rtx, rtx, int);\n \n /* Two different ways of generating switch statements.  */\n-extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx);\n-extern int try_tablejump (tree, tree, tree, tree, rtx, rtx);\n+extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx, int);\n+extern int try_tablejump (tree, tree, tree, tree, rtx, rtx, int);\n \n /* Functions from alias.c */\n #include \"alias.h\""}, {"sha": "e22031615fac49016df4a5219841edea76d7c661", "filename": "gcc/optabs.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -4249,19 +4249,30 @@ prepare_operand (enum insn_code icode, rtx x, int opnum, enum machine_mode mode,\n    we can do the branch.  */\n \n static void\n-emit_cmp_and_jump_insn_1 (rtx test, enum machine_mode mode, rtx label)\n+emit_cmp_and_jump_insn_1 (rtx test, enum machine_mode mode, rtx label, int prob)\n {\n   enum machine_mode optab_mode;\n   enum mode_class mclass;\n   enum insn_code icode;\n+  rtx insn;\n \n   mclass = GET_MODE_CLASS (mode);\n   optab_mode = (mclass == MODE_CC) ? CCmode : mode;\n   icode = optab_handler (cbranch_optab, optab_mode);\n \n   gcc_assert (icode != CODE_FOR_nothing);\n   gcc_assert (insn_operand_matches (icode, 0, test));\n-  emit_jump_insn (GEN_FCN (icode) (test, XEXP (test, 0), XEXP (test, 1), label));\n+  insn = emit_jump_insn (GEN_FCN (icode) (test, XEXP (test, 0),\n+                                          XEXP (test, 1), label));\n+  if (prob != -1\n+      && profile_status != PROFILE_ABSENT\n+      && insn\n+      && JUMP_P (insn)\n+      && any_condjump_p (insn))\n+    {\n+      gcc_assert (!find_reg_note (insn, REG_BR_PROB, 0));\n+      add_reg_note (insn, REG_BR_PROB, GEN_INT (prob));\n+    }\n }\n \n /* Generate code to compare X with Y so that the condition codes are\n@@ -4279,11 +4290,14 @@ emit_cmp_and_jump_insn_1 (rtx test, enum machine_mode mode, rtx label)\n \n    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n    It will be potentially converted into an unsigned variant based on\n-   UNSIGNEDP to select a proper jump instruction.  */\n+   UNSIGNEDP to select a proper jump instruction.\n+   \n+   PROB is the probability of jumping to LABEL.  */\n \n void\n emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n-\t\t\t enum machine_mode mode, int unsignedp, rtx label)\n+\t\t\t enum machine_mode mode, int unsignedp, rtx label,\n+                         int prob)\n {\n   rtx op0 = x, op1 = y;\n   rtx test;\n@@ -4307,7 +4321,7 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n   prepare_cmp_insn (op0, op1, comparison, size, unsignedp, OPTAB_LIB_WIDEN,\n \t\t    &test, &mode);\n-  emit_cmp_and_jump_insn_1 (test, mode, label);\n+  emit_cmp_and_jump_insn_1 (test, mode, label, prob);\n }\n \n \f\n@@ -6952,9 +6966,9 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n   if (oldval != cmp_reg)\n     emit_move_insn (cmp_reg, oldval);\n \n-  /* ??? Mark this jump predicted not taken?  */\n+  /* Mark this jump predicted not taken.  */\n   emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,\n-\t\t\t   GET_MODE (success), 1, label);\n+\t\t\t   GET_MODE (success), 1, label, 0);\n   return true;\n }\n "}, {"sha": "14a28abcc58a2246881d373803b18245d47596a8", "filename": "gcc/stmt.c", "status": "modified", "additions": 319, "deletions": 85, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -94,11 +94,15 @@ struct case_node\n   tree\t\t\tlow;\t/* Lowest index value for this label */\n   tree\t\t\thigh;\t/* Highest index value for this label */\n   tree\t\t\tcode_label; /* Label to jump to when node matches */\n+  int                   prob; /* Probability of taking this case.  */\n+  /* Probability of reaching subtree rooted at this node */\n+  int                   subtree_prob;\n };\n \n typedef struct case_node case_node;\n typedef struct case_node *case_node_ptr;\n \n+extern basic_block label_to_block_fn (struct function *, tree);\n \f\n static int n_occurrences (int, const char *);\n static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n@@ -112,7 +116,7 @@ static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n-static void emit_case_nodes (rtx, case_node_ptr, rtx, tree);\n+static void emit_case_nodes (rtx, case_node_ptr, rtx, int, tree);\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n    creating it if necessary.  */\n@@ -1648,23 +1652,29 @@ expand_stack_restore (tree var)\n   fixup_args_size_notes (prev, get_last_insn (), 0);\n }\n \n-/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.  */\n+/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE. PROB\n+   is the probability of jumping to LABEL.  */\n static void\n do_jump_if_equal (enum machine_mode mode, rtx op0, rtx op1, rtx label,\n-\t\t  int unsignedp)\n+\t\t  int unsignedp, int prob)\n {\n+  gcc_assert (prob <= REG_BR_PROB_BASE);\n   do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, label, -1);\n+\t\t\t   NULL_RTX, NULL_RTX, label, prob);\n }\n \f\n /* Do the insertion of a case label into case_list.  The labels are\n    fed to us in descending order from the sorted vector of case labels used\n    in the tree part of the middle end.  So the list we construct is\n-   sorted in ascending order.  */\n+   sorted in ascending order.\n+   \n+   LABEL is the case label to be inserted. LOW and HIGH are the bounds\n+   against which the index is compared to jump to LABEL and PROB is the\n+   estimated probability LABEL is reached from the switch statement.  */\n \n static struct case_node *\n add_case_node (struct case_node *head, tree low, tree high,\n-               tree label, alloc_pool case_node_pool)\n+               tree label, int prob, alloc_pool case_node_pool)\n {\n   struct case_node *r;\n \n@@ -1677,6 +1687,8 @@ add_case_node (struct case_node *head, tree low, tree high,\n   r->high = high;\n   r->code_label = label;\n   r->parent = r->left = NULL;\n+  r->prob = prob;\n+  r->subtree_prob = prob;\n   r->right = head;\n   return r;\n }\n@@ -1778,6 +1790,8 @@ expand_switch_as_decision_tree_p (tree range,\n \n /* Generate a decision tree, switching on INDEX_EXPR and jumping to\n    one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n+   DEFAULT_PROB is the estimated probability that it jumps to\n+   DEFAULT_LABEL.\n    \n    We generate a binary decision tree to select the appropriate target\n    code.  This is done as follows:\n@@ -1803,7 +1817,8 @@ expand_switch_as_decision_tree_p (tree range,\n \n static void\n emit_case_decision_tree (tree index_expr, tree index_type,\n-\t\t\t struct case_node *case_list, rtx default_label)\n+\t\t\t struct case_node *case_list, rtx default_label,\n+                         int default_prob)\n {\n   rtx index = expand_normal (index_expr);\n \n@@ -1839,15 +1854,47 @@ emit_case_decision_tree (tree index_expr, tree index_type,\n       dump_case_nodes (dump_file, case_list, indent_step, 0);\n     }\n \n-  emit_case_nodes (index, case_list, default_label, index_type);\n+  emit_case_nodes (index, case_list, default_label, default_prob, index_type);\n   if (default_label)\n     emit_jump (default_label);\n }\n \n+/* Return the sum of probabilities of outgoing edges of basic block BB.  */\n+\n+static int\n+get_outgoing_edge_probs (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  int prob_sum = 0;\n+  FOR_EACH_EDGE(e, ei, bb->succs)\n+    prob_sum += e->probability;\n+  return prob_sum;\n+}\n+\n+/* Computes the conditional probability of jumping to a target if the branch\n+   instruction is executed.\n+   TARGET_PROB is the estimated probability of jumping to a target relative\n+   to some basic block BB.\n+   BASE_PROB is the probability of reaching the branch instruction relative\n+   to the same basic block BB.  */\n+\n+static inline int\n+conditional_probability (int target_prob, int base_prob)\n+{\n+  if (base_prob > 0)\n+    {\n+      gcc_assert (target_prob >= 0);\n+      gcc_assert (target_prob <= base_prob);\n+      return RDIV (target_prob * REG_BR_PROB_BASE, base_prob);\n+    }\n+  return -1;\n+}\n+\n /* Generate a dispatch tabler, switching on INDEX_EXPR and jumping to\n    one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n    MINVAL, MAXVAL, and RANGE are the extrema and range of the case\n-   labels in CASE_LIST.\n+   labels in CASE_LIST. STMT_BB is the basic block containing the statement.\n \n    First, a jump insn is emitted.  First we try \"casesi\".  If that\n    fails, try \"tablejump\".   A target *must* have one of them (or both).\n@@ -1860,19 +1907,27 @@ emit_case_decision_tree (tree index_expr, tree index_type,\n static void\n emit_case_dispatch_table (tree index_expr, tree index_type,\n \t\t\t  struct case_node *case_list, rtx default_label,\n-\t\t\t  tree minval, tree maxval, tree range)\n+\t\t\t  tree minval, tree maxval, tree range,\n+                          basic_block stmt_bb)\n {\n   int i, ncases;\n   struct case_node *n;\n   rtx *labelvec;\n   rtx fallback_label = label_rtx (case_list->code_label);\n   rtx table_label = gen_label_rtx ();\n+  bool has_gaps = false;\n+  edge default_edge = EDGE_SUCC(stmt_bb, 0);\n+  int default_prob = default_edge->probability;\n+  int base = get_outgoing_edge_probs (stmt_bb);\n+  bool try_with_tablejump = false;\n+\n+  int new_default_prob = conditional_probability (default_prob,\n+                                                  base);\n \n   if (! try_casesi (index_type, index_expr, minval, range,\n-\t\t    table_label, default_label, fallback_label))\n+\t\t    table_label, default_label, fallback_label,\n+                    new_default_prob))\n     {\n-      bool ok;\n-\n       /* Index jumptables from zero for suitable values of minval to avoid\n \t a subtraction.  For the rationale see:\n \t \"http://gcc.gnu.org/ml/gcc-patches/2001-10/msg01234.html\".  */\n@@ -1882,11 +1937,9 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n \t{\n \t  minval = build_int_cst (index_type, 0);\n \t  range = maxval;\n+          has_gaps = true;\n \t}\n-\n-      ok = try_tablejump (index_type, index_expr, minval, range,\n-\t\t\t  table_label, default_label);\n-      gcc_assert (ok);\n+      try_with_tablejump = true;\n     }\n \n   /* Get table of labels to jump to, in order of case index.  */\n@@ -1921,8 +1974,48 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n     default_label = fallback_label;\n   for (i = 0; i < ncases; i++)\n     if (labelvec[i] == 0)\n-      labelvec[i] = gen_rtx_LABEL_REF (Pmode, default_label);\n+      {\n+        has_gaps = true;\n+        labelvec[i] = gen_rtx_LABEL_REF (Pmode, default_label);\n+      }\n+\n+  if (has_gaps)\n+    {\n+      /* There is at least one entry in the jump table that jumps\n+         to default label. The default label can either be reached\n+         through the indirect jump or the direct conditional jump\n+         before that. Split the probability of reaching the\n+         default label among these two jumps.  */\n+      new_default_prob = conditional_probability (default_prob/2,\n+                                                  base);\n+      default_prob /= 2;\n+      base -= default_prob;\n+    }\n+  else\n+    {\n+      base -= default_prob;\n+      default_prob = 0;\n+    }\n+\n+  default_edge->probability = default_prob;\n+\n+  /* We have altered the probability of the default edge. So the probabilities\n+     of all other edges need to be adjusted so that it sums up to\n+     REG_BR_PROB_BASE.  */\n+  if (base)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, stmt_bb->succs)\n+        e->probability = RDIV (e->probability * REG_BR_PROB_BASE,  base);\n+    }\n \n+  if (try_with_tablejump)\n+    {\n+      bool ok = try_tablejump (index_type, index_expr, minval, range,\n+                               table_label, default_label, new_default_prob);\n+      gcc_assert (ok);\n+    }\n   /* Output the table.  */\n   emit_label (table_label);\n \n@@ -1939,6 +2032,36 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n   emit_barrier ();\n }\n \n+/* Reset the aux field of all outgoing edges of basic block BB.  */\n+\n+static inline void\n+reset_out_edges_aux (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE(e, ei, bb->succs)\n+    e->aux = (void *)0;\n+}\n+\n+/* Compute the number of case labels that correspond to each outgoing edge of\n+   STMT. Record this information in the aux field of the edge.  */\n+\n+static inline void\n+compute_cases_per_edge (gimple stmt)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+  reset_out_edges_aux (bb);\n+  int ncases = gimple_switch_num_labels (stmt);\n+  for (int i = ncases - 1; i >= 1; --i)\n+    {\n+      tree elt = gimple_switch_label (stmt, i);\n+      tree lab = CASE_LABEL (elt);\n+      basic_block case_bb = label_to_block_fn (cfun, lab);\n+      edge case_edge = find_edge (bb, case_bb);\n+      case_edge->aux = (void *)((long)(case_edge->aux) + 1);\n+    }\n+}\n+\n /* Terminate a case (Pascal/Ada) or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n    If ORIG_TYPE is not NULL, it is the original ORIG_INDEX\n@@ -1956,6 +2079,7 @@ expand_case (gimple stmt)\n   tree index_expr = gimple_switch_index (stmt);\n   tree index_type = TREE_TYPE (index_expr);\n   tree elt;\n+  basic_block bb = gimple_bb (stmt);\n \n   /* A list of case labels; it is first built as a list and it may then\n      be rearranged into a nearly balanced binary tree.  */\n@@ -1981,6 +2105,8 @@ expand_case (gimple stmt)\n \n   /* Find the default case target label.  */\n   default_label = label_rtx (CASE_LABEL (gimple_switch_default_label (stmt)));\n+  edge default_edge = EDGE_SUCC(bb, 0);\n+  int default_prob = default_edge->probability;\n \n   /* Get upper and lower bounds of case values.  */\n   elt = gimple_switch_label (stmt, 1);\n@@ -1999,7 +2125,9 @@ expand_case (gimple stmt)\n   uniq = 0;\n   count = 0;\n   struct pointer_set_t *seen_labels = pointer_set_create ();\n-  for (i = gimple_switch_num_labels (stmt) - 1; i >= 1; --i)\n+  compute_cases_per_edge (stmt);\n+\n+  for (i = ncases - 1; i >= 1; --i)\n     {\n       elt = gimple_switch_label (stmt, i);\n       tree low = CASE_LOW (elt);\n@@ -2041,10 +2169,15 @@ expand_case (gimple stmt)\n \t\t\t\t   TREE_INT_CST_LOW (high),\n \t\t\t\t   TREE_INT_CST_HIGH (high));\n \n-      case_list = add_case_node (case_list, low, high, lab,\n-\t\t\t\t case_node_pool);\n+      basic_block case_bb = label_to_block_fn (cfun, lab);\n+      edge case_edge = find_edge (bb, case_bb);\n+      case_list = add_case_node (\n+          case_list, low, high, lab,\n+          case_edge->probability / (long)(case_edge->aux),\n+          case_node_pool);\n     }\n   pointer_set_destroy (seen_labels);\n+  reset_out_edges_aux (bb);\n \n   /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n      destination, such as one with a default case only.\n@@ -2060,11 +2193,12 @@ expand_case (gimple stmt)\n \n   if (expand_switch_as_decision_tree_p (range, uniq, count))\n     emit_case_decision_tree (index_expr, index_type,\n-\t\t\t     case_list, default_label);\n+                             case_list, default_label,\n+                             default_prob);\n   else\n     emit_case_dispatch_table (index_expr, index_type,\n \t\t\t      case_list, default_label,\n-\t\t\t      minval, maxval, range);\n+\t\t\t      minval, maxval, range, bb);\n \n   reorder_insns (NEXT_INSN (before_case), get_last_insn (), before_case);\n \n@@ -2126,7 +2260,7 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n         {\n \t  tree elt = VEC_index (tree, dispatch_table, i);\n \t  rtx lab = label_rtx (CASE_LABEL (elt));\n-\t  do_jump_if_equal (index_mode, index, zero, lab, 0);\n+\t  do_jump_if_equal (index_mode, index, zero, lab, 0, -1);\n \t  force_expand_binop (index_mode, sub_optab,\n \t\t\t      index, CONST1_RTX (index_mode),\n \t\t\t      index, 0, OPTAB_DIRECT);\n@@ -2150,12 +2284,12 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n \t  tree elt = VEC_index (tree, dispatch_table, i);\n \t  tree low = CASE_LOW (elt);\n \t  tree lab = CASE_LABEL (elt);\n-\t  case_list = add_case_node (case_list, low, low, lab, case_node_pool);\n+\t  case_list = add_case_node (case_list, low, low, lab, 0, case_node_pool);\n \t}\n \n       emit_case_dispatch_table (index_expr, index_type,\n \t\t\t\tcase_list, default_label,\n-\t\t\t\tminval, maxval, range);\n+\t\t\t\tminval, maxval, range, NULL);\n       emit_label (default_label);\n       free_alloc_pool (case_node_pool);\n     }\n@@ -2237,15 +2371,22 @@ balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n \t  /* Optimize each of the two split parts.  */\n \t  balance_case_nodes (&np->left, np);\n \t  balance_case_nodes (&np->right, np);\n+          np->subtree_prob = np->prob;\n+          np->subtree_prob += np->left->subtree_prob;\n+          np->subtree_prob += np->right->subtree_prob;\n \t}\n       else\n \t{\n \t  /* Else leave this branch as one level,\n \t     but fill in `parent' fields.  */\n \t  np = *head;\n \t  np->parent = parent;\n+          np->subtree_prob = np->prob;\n \t  for (; np->right; np = np->right)\n-\t    np->right->parent = np;\n+            {\n+\t      np->right->parent = np;\n+              (*head)->subtree_prob += np->right->subtree_prob;\n+            }\n \t}\n     }\n }\n@@ -2358,6 +2499,7 @@ node_is_bounded (case_node_ptr node, tree index_type)\n \t  && node_has_high_bound (node, index_type));\n }\n \f\n+\n /* Emit step-by-step code to select a case for the value of INDEX.\n    The thus generated decision tree follows the form of the\n    case-node binary tree NODE, whose nodes represent test conditions.\n@@ -2386,10 +2528,12 @@ node_is_bounded (case_node_ptr node, tree index_type)\n \n static void\n emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n-\t\t tree index_type)\n+\t\t int default_prob, tree index_type)\n {\n   /* If INDEX has an unsigned type, we must make unsigned branches.  */\n   int unsignedp = TYPE_UNSIGNED (index_type);\n+  int probability;\n+  int prob = node->prob, subtree_prob = node->subtree_prob;\n   enum machine_mode mode = GET_MODE (index);\n   enum machine_mode imode = TYPE_MODE (index_type);\n \n@@ -2404,15 +2548,17 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \n   else if (tree_int_cst_equal (node->low, node->high))\n     {\n+      probability = conditional_probability (prob, subtree_prob + default_prob);\n       /* Node is single valued.  First see if the index expression matches\n \t this node and then check our children, if any.  */\n-\n       do_jump_if_equal (mode, index,\n \t\t\tconvert_modes (mode, imode,\n \t\t\t\t       expand_normal (node->low),\n \t\t\t\t       unsignedp),\n-\t\t\tlabel_rtx (node->code_label), unsignedp);\n-\n+\t\t\tlabel_rtx (node->code_label), unsignedp, probability);\n+      /* Since this case is taken at this point, reduce its weight from\n+         subtree_weight.  */\n+      subtree_prob -= prob;\n       if (node->right != 0 && node->left != 0)\n \t{\n \t  /* This node has children on both sides.\n@@ -2423,26 +2569,35 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \n \t  if (node_is_bounded (node->right, index_type))\n \t    {\n+              probability = conditional_probability (\n+                  node->right->prob,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->high),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (node->right->code_label));\n-\t      emit_case_nodes (index, node->left, default_label, index_type);\n+\t\t\t\t       label_rtx (node->right->code_label),\n+                                       probability);\n+\t      emit_case_nodes (index, node->left, default_label, default_prob,\n+                               index_type);\n \t    }\n \n \t  else if (node_is_bounded (node->left, index_type))\n \t    {\n+              probability = conditional_probability (\n+                  node->left->prob,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->high),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (node->left->code_label));\n-\t      emit_case_nodes (index, node->right, default_label, index_type);\n+\t\t\t\t       label_rtx (node->left->code_label),\n+                                       probability);\n+\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n \t    }\n \n \t  /* If both children are single-valued cases with no\n@@ -2460,21 +2615,27 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \n \t      /* See if the value matches what the right hand side\n \t\t wants.  */\n+              probability = conditional_probability (\n+                  node->right->prob,\n+                  subtree_prob + default_prob);\n \t      do_jump_if_equal (mode, index,\n \t\t\t\tconvert_modes (mode, imode,\n \t\t\t\t\t       expand_normal (node->right->low),\n \t\t\t\t\t       unsignedp),\n \t\t\t\tlabel_rtx (node->right->code_label),\n-\t\t\t\tunsignedp);\n+\t\t\t\tunsignedp, probability);\n \n \t      /* See if the value matches what the left hand side\n \t\t wants.  */\n+              probability = conditional_probability (\n+                  node->left->prob,\n+                  subtree_prob + default_prob);\n \t      do_jump_if_equal (mode, index,\n \t\t\t\tconvert_modes (mode, imode,\n \t\t\t\t\t       expand_normal (node->left->low),\n \t\t\t\t\t       unsignedp),\n \t\t\t\tlabel_rtx (node->left->code_label),\n-\t\t\t\tunsignedp);\n+\t\t\t\tunsignedp, probability);\n \t    }\n \n \t  else\n@@ -2486,26 +2647,34 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t= build_decl (curr_insn_location (),\n \t\t\t      LABEL_DECL, NULL_TREE, NULL_TREE);\n \n+              /* The default label could be reached either through the right\n+                 subtree or the left subtree. Divide the probability\n+                 equally.  */\n+              probability = conditional_probability (\n+                  node->right->subtree_prob + default_prob/2,\n+                  subtree_prob + default_prob);\n \t      /* See if the value is on the right.  */\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->high),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (test_label));\n+\t\t\t\t       label_rtx (test_label),\n+                                       probability);\n+              default_prob /= 2;\n \n \t      /* Value must be on the left.\n \t\t Handle the left-hand subtree.  */\n-\t      emit_case_nodes (index, node->left, default_label, index_type);\n+\t      emit_case_nodes (index, node->left, default_label, default_prob, index_type);\n \t      /* If left-hand subtree does nothing,\n \t\t go to default.  */\n \t      if (default_label)\n \t        emit_jump (default_label);\n \n \t      /* Code branches here for the right-hand subtree.  */\n \t      expand_label (test_label);\n-\t      emit_case_nodes (index, node->right, default_label, index_type);\n+\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n \t    }\n \t}\n \n@@ -2523,28 +2692,38 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t    {\n \t      if (!node_has_low_bound (node, index_type))\n \t\t{\n+                  probability = conditional_probability (\n+                      default_prob/2,\n+                      subtree_prob + default_prob);\n \t\t  emit_cmp_and_jump_insns (index,\n \t\t\t\t\t   convert_modes\n \t\t\t\t\t   (mode, imode,\n \t\t\t\t\t    expand_normal (node->high),\n \t\t\t\t\t    unsignedp),\n \t\t\t\t\t   LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t\t   default_label);\n+\t\t\t\t\t   default_label,\n+                                           probability);\n+                  default_prob /= 2;\n \t\t}\n \n-\t      emit_case_nodes (index, node->right, default_label, index_type);\n+\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n \t    }\n \t  else\n-\t    /* We cannot process node->right normally\n-\t       since we haven't ruled out the numbers less than\n-\t       this node's value.  So handle node->right explicitly.  */\n-\t    do_jump_if_equal (mode, index,\n-\t\t\t      convert_modes\n-\t\t\t      (mode, imode,\n-\t\t\t       expand_normal (node->right->low),\n-\t\t\t       unsignedp),\n-\t\t\t      label_rtx (node->right->code_label), unsignedp);\n-\t}\n+            {\n+              probability = conditional_probability (\n+                  node->right->subtree_prob,\n+                  subtree_prob + default_prob);\n+\t      /* We cannot process node->right normally\n+\t         since we haven't ruled out the numbers less than\n+\t         this node's value.  So handle node->right explicitly.  */\n+\t      do_jump_if_equal (mode, index,\n+\t\t\t        convert_modes\n+\t\t\t        (mode, imode,\n+\t\t\t         expand_normal (node->right->low),\n+\t\t\t         unsignedp),\n+\t\t\t        label_rtx (node->right->code_label), unsignedp, probability);\n+            }\n+\t  }\n \n       else if (node->right == 0 && node->left != 0)\n \t{\n@@ -2554,27 +2733,38 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t    {\n \t      if (!node_has_high_bound (node, index_type))\n \t\t{\n+                  probability = conditional_probability (\n+                      default_prob/2,\n+                      subtree_prob + default_prob);\n \t\t  emit_cmp_and_jump_insns (index,\n \t\t\t\t\t   convert_modes\n \t\t\t\t\t   (mode, imode,\n \t\t\t\t\t    expand_normal (node->high),\n \t\t\t\t\t    unsignedp),\n \t\t\t\t\t   GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t\t   default_label);\n+\t\t\t\t\t   default_label,\n+                                           probability);\n+                  default_prob /= 2;\n \t\t}\n \n-\t      emit_case_nodes (index, node->left, default_label, index_type);\n+\t      emit_case_nodes (index, node->left, default_label,\n+                               default_prob, index_type);\n \t    }\n \t  else\n-\t    /* We cannot process node->left normally\n-\t       since we haven't ruled out the numbers less than\n-\t       this node's value.  So handle node->left explicitly.  */\n-\t    do_jump_if_equal (mode, index,\n-\t\t\t      convert_modes\n-\t\t\t      (mode, imode,\n-\t\t\t       expand_normal (node->left->low),\n-\t\t\t       unsignedp),\n-\t\t\t      label_rtx (node->left->code_label), unsignedp);\n+            {\n+              probability = conditional_probability (\n+                  node->left->subtree_prob,\n+                  subtree_prob + default_prob);\n+\t      /* We cannot process node->left normally\n+\t         since we haven't ruled out the numbers less than\n+\t         this node's value.  So handle node->left explicitly.  */\n+\t      do_jump_if_equal (mode, index,\n+\t\t\t        convert_modes\n+\t\t\t        (mode, imode,\n+\t\t\t         expand_normal (node->left->low),\n+\t\t\t         unsignedp),\n+\t\t\t        label_rtx (node->left->code_label), unsignedp, probability);\n+            }\n \t}\n     }\n   else\n@@ -2593,43 +2783,58 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t  tree test_label = 0;\n \n \t  if (node_is_bounded (node->right, index_type))\n-\t    /* Right hand node is fully bounded so we can eliminate any\n-\t       testing and branch directly to the target code.  */\n-\t    emit_cmp_and_jump_insns (index,\n-\t\t\t\t     convert_modes\n-\t\t\t\t     (mode, imode,\n-\t\t\t\t      expand_normal (node->high),\n-\t\t\t\t      unsignedp),\n-\t\t\t\t     GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t     label_rtx (node->right->code_label));\n+            {\n+\t      /* Right hand node is fully bounded so we can eliminate any\n+\t         testing and branch directly to the target code.  */\n+              probability = conditional_probability (\n+                  node->right->subtree_prob,\n+                  subtree_prob + default_prob);\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t        expand_normal (node->high),\n+\t\t\t\t        unsignedp),\n+\t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n+\t\t\t\t       label_rtx (node->right->code_label),\n+                                       probability);\n+            }\n \t  else\n \t    {\n \t      /* Right hand node requires testing.\n \t\t Branch to a label where we will handle it later.  */\n \n \t      test_label = build_decl (curr_insn_location (),\n \t\t\t\t       LABEL_DECL, NULL_TREE, NULL_TREE);\n+              probability = conditional_probability (\n+                  node->right->subtree_prob + default_prob/2,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->high),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       label_rtx (test_label));\n+\t\t\t\t       label_rtx (test_label),\n+                                       probability);\n+              default_prob /= 2;\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n+          probability = conditional_probability (\n+              prob,\n+              subtree_prob + default_prob);\n \t  emit_cmp_and_jump_insns (index,\n \t\t\t\t   convert_modes\n \t\t\t\t   (mode, imode,\n \t\t\t\t    expand_normal (node->low),\n \t\t\t\t    unsignedp),\n \t\t\t\t   GE, NULL_RTX, mode, unsignedp,\n-\t\t\t\t   label_rtx (node->code_label));\n+\t\t\t\t   label_rtx (node->code_label),\n+                                   probability);\n \n \t  /* Handle the left-hand subtree.  */\n-\t  emit_case_nodes (index, node->left, default_label, index_type);\n+\t  emit_case_nodes (index, node->left, default_label, default_prob, index_type);\n \n \t  /* If right node had to be handled later, do that now.  */\n \n@@ -2641,7 +2846,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\temit_jump (default_label);\n \n \t      expand_label (test_label);\n-\t      emit_case_nodes (index, node->right, default_label, index_type);\n+\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n \t    }\n \t}\n \n@@ -2651,26 +2856,35 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t     if they are possible.  */\n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n+              probability = conditional_probability (\n+                  default_prob/2,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->low),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label);\n+\t\t\t\t       default_label,\n+                                       probability);\n+              default_prob /= 2;\n \t    }\n \n \t  /* Value belongs to this node or to the right-hand subtree.  */\n \n+          probability = conditional_probability (\n+              prob,\n+              subtree_prob + default_prob);\n \t  emit_cmp_and_jump_insns (index,\n \t\t\t\t   convert_modes\n \t\t\t\t   (mode, imode,\n \t\t\t\t    expand_normal (node->high),\n \t\t\t\t    unsignedp),\n \t\t\t\t   LE, NULL_RTX, mode, unsignedp,\n-\t\t\t\t   label_rtx (node->code_label));\n+\t\t\t\t   label_rtx (node->code_label),\n+                                   probability);\n \n-\t  emit_case_nodes (index, node->right, default_label, index_type);\n+\t  emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n \t}\n \n       else if (node->right == 0 && node->left != 0)\n@@ -2679,26 +2893,35 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t     if they are possible.  */\n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n+              probability = conditional_probability (\n+                  default_prob/2,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->high),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label);\n+\t\t\t\t       default_label,\n+                                       probability);\n+              default_prob /= 2;\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n+          probability = conditional_probability (\n+              prob,\n+              subtree_prob + default_prob);\n \t  emit_cmp_and_jump_insns (index,\n \t\t\t\t   convert_modes\n \t\t\t\t   (mode, imode,\n \t\t\t\t    expand_normal (node->low),\n \t\t\t\t    unsignedp),\n \t\t\t\t   GE, NULL_RTX, mode, unsignedp,\n-\t\t\t\t   label_rtx (node->code_label));\n+\t\t\t\t   label_rtx (node->code_label),\n+                                   probability);\n \n-\t  emit_case_nodes (index, node->left, default_label, index_type);\n+\t  emit_case_nodes (index, node->left, default_label, default_prob, index_type);\n \t}\n \n       else\n@@ -2711,24 +2934,32 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \n \t  if (!high_bound && low_bound)\n \t    {\n+              probability = conditional_probability (\n+                  default_prob,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->high),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label);\n+\t\t\t\t       default_label,\n+                                       probability);\n \t    }\n \n \t  else if (!low_bound && high_bound)\n \t    {\n+              probability = conditional_probability (\n+                  default_prob,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,\n \t\t\t\t\texpand_normal (node->low),\n \t\t\t\t\tunsignedp),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n-\t\t\t\t       default_label);\n+\t\t\t\t       default_label,\n+                                       probability);\n \t    }\n \t  else if (!low_bound && !high_bound)\n \t    {\n@@ -2748,8 +2979,11 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\t\t\t\t    high, low),\n \t\t\t\t       NULL_RTX, mode, EXPAND_NORMAL);\n \n+              probability = conditional_probability (\n+                  default_prob,\n+                  subtree_prob + default_prob);\n \t      emit_cmp_and_jump_insns (new_index, new_bound, GT, NULL_RTX,\n-\t\t\t\t       mode, 1, default_label);\n+\t\t\t\t       mode, 1, default_label, probability);\n \t    }\n \n \t  emit_jump (label_rtx (node->code_label));"}, {"sha": "f384ebe3814d7ea9983fb8d11567fcd2f7339f68", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -1,3 +1,7 @@\n+2012-10-15   Easwaran Raman  <eraman@google.com>\n+\t* gcc.dg/tree-prof/switch-case-1.c: New test case.\n+\t* gcc.dg/tree-prof/switch-case-2.c: New test case.\n+\n 2012-10-16  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* gcc.dg/torture/stackalign/builtin-apply-2.c,"}, {"sha": "50ee9e44fd4ed21784040f663018feceef925945", "filename": "gcc/testsuite/gcc.dg/tree-prof/switch-case-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fswitch-case-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fswitch-case-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fswitch-case-1.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-options \"-O2 -fdump-rtl-expand-all\" } */\n+int g;\n+\n+__attribute__((noinline)) void foo (int  n)\n+{\n+  switch (n)\n+    {\n+    case 1:\n+      g++; break;\n+    case 2:\n+      g += 2; break;\n+    case 3:\n+      g += 1; break;\n+    case 4:\n+      g += 3; break;\n+    case 5:\n+      g += 4; break;\n+    case 6:\n+      g += 5; break;\n+    case 7:\n+      g += 6; break;\n+    case 8:\n+      g += 7; break;\n+    case 9:\n+      g += 8; break;\n+    default:\n+      g += 8; break;\n+   }\n+}\n+\n+int main ()\n+{\n+ int i;\n+ for (i = 0; i < 10000; i++)\n+   foo ((i * i) % 5);\n+ return 0;\n+}\n+/* { dg-final-use { scan-rtl-dump-times \";; basic block\\[^\\\\n\\]*count 4000\" 2 \"expand\"} } */\n+/* { dg-final-use { scan-rtl-dump-times \";; basic block\\[^\\\\n\\]*count 2000\" 1 \"expand\"} } */\n+/* { dg-final-use { cleanup-rtl-dump \"expand\" } } */"}, {"sha": "07d4363d39528e29a015a2e11c3a61ba0a646893", "filename": "gcc/testsuite/gcc.dg/tree-prof/switch-case-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fswitch-case-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fswitch-case-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fswitch-case-2.c?ref=a4da41e1279cf8bf84fc0a0d4e3af5c5e297c011", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-options \"-O2 -fdump-rtl-expand-all\" } */\n+int g;\n+\n+__attribute__((noinline)) void foo (int  n)\n+{\n+  switch (n)\n+    {\n+    case 99:\n+      g += 2; break;\n+    case 1:\n+      g++; break;\n+    case 100:\n+      g += 1; break;\n+    case 4:\n+      g += 3; break;\n+    case 5:\n+      g += 4; break;\n+    case 6:\n+      g += 5; break;\n+    case 7:\n+      g += 6; break;\n+    case 8:\n+      g += 7; break;\n+    case 9:\n+      g += 8; break;\n+    default:\n+      g += 8; break;\n+   }\n+}\n+\n+int main ()\n+{\n+ int i;\n+ for (i = 0; i < 10000; i++)\n+   foo ((i * i) % 5);\n+ return 0;\n+}\n+/* { dg-final-use { scan-rtl-dump-times \";; basic block\\[^\\\\n\\]*count 4000\" 2 \"expand\"} } */\n+/* { dg-final-use { scan-rtl-dump-times \";; basic block\\[^\\\\n\\]*count 2000\" 1 \"expand\"} } */\n+/* { dg-final-use { cleanup-rtl-dump \"expand\" } } */"}]}