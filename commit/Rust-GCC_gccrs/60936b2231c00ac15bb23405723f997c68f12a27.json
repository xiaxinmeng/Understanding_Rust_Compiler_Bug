{"sha": "60936b2231c00ac15bb23405723f997c68f12a27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA5MzZiMjIzMWMwMGFjMTViYjIzNDA1NzIzZjk5N2M2OGYxMmEyNw==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2010-03-18T03:10:04Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2010-03-18T03:10:04Z"}, "message": "re PR target/42427 (invalid assembly code for 301.apsi for -fnon-call-exceptions)\n\ngcc/\n\tPR target/42427\n\t* config/rs6000/rs6000.c (rs6000_split_multireg_move): Add support for\n\tnon-offsettable and pre_modify update addressing.\n\t* config/rs6000/dfp.md (*movdd_hardfloat32): Make the \"0\", \"1\"\n\tand \"2\" alternatives \"#\".\n\t(*movdd_softfloat32): Make all alternatives \"#\";\n\t* config/rs6000/rs6000.md (DIFD): New define_mode_iterator.\n\t(*movdf_hardfloat32): Make the \"0\", \"1\" and \"2\" alternatives \"#\".\n\t(*movdf_softfloat32): Make all alternatives \"#\";\n\t(movdi): Use the new DIFD mode iterator to create a common splitter\n\tfor movdi, movdf and movdd patterns.\n\ngcc/testsuite/\n\tPR target/42427\n\t* gcc.dg/pr42427.c: New test.\n\nFrom-SVN: r157530", "tree": {"sha": "99a2c67272095b5f19d06010443c8263b8287984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99a2c67272095b5f19d06010443c8263b8287984"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60936b2231c00ac15bb23405723f997c68f12a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60936b2231c00ac15bb23405723f997c68f12a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60936b2231c00ac15bb23405723f997c68f12a27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60936b2231c00ac15bb23405723f997c68f12a27/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "316fc112aec50de832334fd8b1cb00e01d0178d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/316fc112aec50de832334fd8b1cb00e01d0178d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/316fc112aec50de832334fd8b1cb00e01d0178d9"}], "stats": {"total": 303, "additions": 102, "deletions": 201}, "files": [{"sha": "69edc12851c76fd4316ab3425a5e68258103001a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60936b2231c00ac15bb23405723f997c68f12a27", "patch": "@@ -1,3 +1,17 @@\n+2010-03-17  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\tPR target/42427\n+\t* config/rs6000/rs6000.c (rs6000_split_multireg_move): Add support for\n+\tnon-offsettable and pre_modify update addressing.\n+\t* config/rs6000/dfp.md (*movdd_hardfloat32): Make the \"0\", \"1\"\n+\tand \"2\" alternatives \"#\".\n+\t(*movdd_softfloat32): Make all alternatives \"#\";\n+\t* config/rs6000/rs6000.md (DIFD): New define_mode_iterator.\n+\t(*movdf_hardfloat32): Make the \"0\", \"1\" and \"2\" alternatives \"#\".\n+\t(*movdf_softfloat32): Make all alternatives \"#\";\n+\t(movdi): Use the new DIFD mode iterator to create a common splitter\n+\tfor movdi, movdf and movdd patterns.\n+\n 2010-03-18  Shujing Zhao  <pearly.zhao@oracle.com>\n \n \t* common.opt (dumpdir): Remove redundant tab."}, {"sha": "8326d6be0a618a1a5257f4cbf38d796912a84f57", "filename": "gcc/config/rs6000/dfp.md", "status": "modified", "additions": 2, "deletions": 95, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=60936b2231c00ac15bb23405723f997c68f12a27", "patch": "@@ -293,71 +293,9 @@\n     default:\n       gcc_unreachable ();\n     case 0:\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register\n-\t of operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n     case 1:\n-      if (rs6000_offsettable_memref_p (operands[1])\n-\t  || (GET_CODE (operands[1]) == MEM\n-\t      && (GET_CODE (XEXP (operands[1], 0)) == LO_SUM\n-\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_INC\n-\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)))\n-\t{\n-\t  /* If the low-address word is used in the address, we must load\n-\t     it last.  Otherwise, load it first.  Note that we cannot have\n-\t     auto-increment in that case since the address register is\n-\t     known to be dead.  */\n-\t  if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t\t operands[1], 0))\n-\t    return \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n-\t  else\n-\t    return \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n-\t}\n-      else\n-\t{\n-\t  rtx addreg;\n-\n-\t  addreg = find_addr_reg (XEXP (operands[1], 0));\n-\t  if (refers_to_regno_p (REGNO (operands[0]),\n-\t\t\t\t REGNO (operands[0]) + 1,\n-\t\t\t\t operands[1], 0))\n-\t    {\n-\t      output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n-\t      output_asm_insn (\\\"{lx|lwzx} %L0,%1\\\", operands);\n-\t      output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n-\t      return \\\"{lx|lwzx} %0,%1\\\";\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\\\"{lx|lwzx} %0,%1\\\", operands);\n-\t      output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n-\t      output_asm_insn (\\\"{lx|lwzx} %L0,%1\\\", operands);\n-\t      output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n-\t      return \\\"\\\";\n-\t    }\n-\t}\n     case 2:\n-      if (rs6000_offsettable_memref_p (operands[0])\n-\t  || (GET_CODE (operands[0]) == MEM\n-\t      && (GET_CODE (XEXP (operands[0], 0)) == LO_SUM\n-\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_INC\n-\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)))\n-\treturn \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n-      else\n-\t{\n-\t  rtx addreg;\n-\n-\t  addreg = find_addr_reg (XEXP (operands[0], 0));\n-\t  output_asm_insn (\\\"{stx|stwx} %1,%0\\\", operands);\n-\t  output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n-\t  output_asm_insn (\\\"{stx|stwx} %L1,%0\\\", operands);\n-\t  output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n-\t  return \\\"\\\";\n-\t}\n+      return \\\"#\\\";\n     case 3:\n       return \\\"fmr %0,%1\\\";\n     case 4:\n@@ -379,38 +317,7 @@\n   \"! TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n    && (gpc_reg_operand (operands[0], DDmode)\n        || gpc_reg_operand (operands[1], DDmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case 0:\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n-    case 1:\n-      /* If the low-address word is used in the address, we must load\n-\t it last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is\n-\t known to be dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands[1], 0))\n-\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n-      else\n-\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n-    case 2:\n-      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n-    case 3:\n-    case 4:\n-    case 5:\n-      return \\\"#\\\";\n-    }\n-}\"\n+  \"#\"\n   [(set_attr \"type\" \"two,load,store,*,*,*\")\n    (set_attr \"length\" \"8,8,8,8,12,16\")])\n "}, {"sha": "dea0271b91a65df56769d363b4b9a48fd867561f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=60936b2231c00ac15bb23405723f997c68f12a27", "patch": "@@ -16724,6 +16724,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n       int i;\n       int j = -1;\n       bool used_update = false;\n+      rtx restore_basereg = NULL_RTX;\n \n       if (MEM_P (src) && INT_REGNO_P (reg))\n \t{\n@@ -16742,10 +16743,27 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t    }\n \t  else if (! rs6000_offsettable_memref_p (src))\n \t    {\n-\t      rtx basereg;\n-\t      basereg = gen_rtx_REG (Pmode, reg);\n-\t      emit_insn (gen_rtx_SET (VOIDmode, basereg, XEXP (src, 0)));\n-\t      src = replace_equiv_address (src, basereg);\n+\t      if (GET_CODE (XEXP (src, 0)) == PRE_MODIFY)\n+\t\t{\n+\t\t  rtx basereg = XEXP (XEXP (src, 0), 0);\n+\t\t  if (TARGET_UPDATE)\n+\t\t    {\n+\t\t      rtx ndst = simplify_gen_subreg (reg_mode, dst, mode, 0);\n+\t\t      emit_insn (gen_rtx_SET (VOIDmode, ndst,\n+\t\t\t\t gen_rtx_MEM (reg_mode, XEXP (src, 0))));\n+\t\t      used_update = true;\n+\t\t    }\n+\t\t  else\n+\t\t    emit_insn (gen_rtx_SET (VOIDmode, basereg,\n+\t\t\t       XEXP (XEXP (src, 0), 1)));\n+\t\t  src = replace_equiv_address (src, basereg);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx basereg = gen_rtx_REG (Pmode, reg);\n+\t\t  emit_insn (gen_rtx_SET (VOIDmode, basereg, XEXP (src, 0)));\n+\t\t  src = replace_equiv_address (src, basereg);\n+\t\t}\n \t    }\n \n \t  breg = XEXP (src, 0);\n@@ -16759,8 +16777,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t      && REGNO (breg) < REGNO (dst) + nregs)\n \t    j = REGNO (breg) - REGNO (dst);\n \t}\n-\n-      if (GET_CODE (dst) == MEM && INT_REGNO_P (reg))\n+      else if (MEM_P (dst) && INT_REGNO_P (reg))\n \t{\n \t  rtx breg;\n \n@@ -16790,7 +16807,34 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\temit_insn (gen_add3_insn (breg, breg, delta_rtx));\n \t      dst = replace_equiv_address (dst, breg);\n \t    }\n-\t  else\n+\t  else if (!rs6000_offsettable_memref_p (dst)\n+\t\t   && GET_CODE (XEXP (dst, 0)) != LO_SUM)\n+\t    {\n+\t      if (GET_CODE (XEXP (dst, 0)) == PRE_MODIFY)\n+\t\t{\n+\t\t  rtx basereg = XEXP (XEXP (dst, 0), 0);\n+\t\t  if (TARGET_UPDATE)\n+\t\t    {\n+\t\t      rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n+\t\t      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t gen_rtx_MEM (reg_mode, XEXP (dst, 0)), nsrc));\n+\t\t      used_update = true;\n+\t\t    }\n+\t\t  else\n+\t\t    emit_insn (gen_rtx_SET (VOIDmode, basereg,\n+\t\t\t       XEXP (XEXP (dst, 0), 1)));\n+\t\t  dst = replace_equiv_address (dst, basereg);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx basereg = XEXP (XEXP (dst, 0), 0);\n+\t\t  rtx offsetreg = XEXP (XEXP (dst, 0), 1);\n+\t\t  emit_insn (gen_add3_insn (basereg, basereg, offsetreg));\n+\t\t  restore_basereg = gen_sub3_insn (basereg, basereg, offsetreg);\n+\t\t  dst = replace_equiv_address (dst, basereg);\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (XEXP (dst, 0)) != LO_SUM)\n \t    gcc_assert (rs6000_offsettable_memref_p (dst));\n \t}\n \n@@ -16812,6 +16856,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t\t\t  simplify_gen_subreg (reg_mode, src, mode,\n \t\t\t\t\t\t       j * reg_mode_size)));\n \t}\n+      if (restore_basereg != NULL_RTX)\n+\temit_insn (restore_basereg);\n     }\n }\n "}, {"sha": "50c4d618053c137b4f49cda49769b3e28e08c1a1", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 7, "deletions": 99, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=60936b2231c00ac15bb23405723f997c68f12a27", "patch": "@@ -217,6 +217,9 @@\n   (DD \"TARGET_DFP\")\n   (TD \"TARGET_DFP\")])\n \n+; These modes do not fit in integer registers in 32-bit mode.\n+(define_mode_iterator DIFD [DI DF DD])\n+\n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd.\n (define_mode_attr wd [(QI \"b\") (HI \"h\") (SI \"w\") (DI \"d\")])\n@@ -9148,73 +9151,9 @@\n     default:\n       gcc_unreachable ();\n     case 0:\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register\n-\t of operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n     case 1:\n-      if (rs6000_offsettable_memref_p (operands[1])\n-\t  || (GET_CODE (operands[1]) == MEM\n-\t      && (GET_CODE (XEXP (operands[1], 0)) == LO_SUM\n-\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_INC\n-\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC\n-\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_MODIFY)))\n-\t{\n-\t  /* If the low-address word is used in the address, we must load\n-\t     it last.  Otherwise, load it first.  Note that we cannot have\n-\t     auto-increment in that case since the address register is\n-\t     known to be dead.  */\n-\t  if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t\t operands[1], 0))\n-\t    return \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n-\t  else\n-\t    return \\\"{l%U1%X1|lwz%U1%X1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n-\t}\n-      else\n-\t{\n-\t  rtx addreg;\n-\n-\t  addreg = find_addr_reg (XEXP (operands[1], 0));\n-\t  if (refers_to_regno_p (REGNO (operands[0]),\n-\t\t\t\t REGNO (operands[0]) + 1,\n-\t\t\t\t operands[1], 0))\n-\t    {\n-\t      output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n-\t      output_asm_insn (\\\"{l%X1|lwz%X1} %L0,%1\\\", operands);\n-\t      output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n-\t      return \\\"{l%X1|lwz%X1} %0,%1\\\";\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\\\"{l%X1|lwz%X1} %0,%1\\\", operands);\n-\t      output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n-\t      output_asm_insn (\\\"{l%X1|lwz%X1} %L0,%1\\\", operands);\n-\t      output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n-\t      return \\\"\\\";\n-\t    }\n-\t}\n     case 2:\n-      if (rs6000_offsettable_memref_p (operands[0])\n-\t  || (GET_CODE (operands[0]) == MEM\n-\t      && (GET_CODE (XEXP (operands[0], 0)) == LO_SUM\n-\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_INC\n-\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n-\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)))\n-\treturn \\\"{st%U0%X0|stw%U0%X0} %1,%0\\;{st|stw} %L1,%L0\\\";\n-      else\n-\t{\n-\t  rtx addreg;\n-\n-\t  addreg = find_addr_reg (XEXP (operands[0], 0));\n-\t  output_asm_insn (\\\"{st%X0|stw%X0} %1,%0\\\", operands);\n-\t  output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n-\t  output_asm_insn (\\\"{st%X0|stw%X0} %L1,%0\\\", operands);\n-\t  output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n-\t  return \\\"\\\";\n-\t}\n+      return \\\"#\\\";\n     case 3:\n     case 4:\n       return \\\"xxlor %x0,%x1,%x1\\\";\n@@ -9249,38 +9188,7 @@\n        || TARGET_SOFT_FLOAT || TARGET_E500_SINGLE)\n    && (gpc_reg_operand (operands[0], DFmode)\n        || gpc_reg_operand (operands[1], DFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case 0:\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n-    case 1:\n-      /* If the low-address word is used in the address, we must load\n-\t it last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is\n-\t known to be dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands[1], 0))\n-\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n-      else\n-\treturn \\\"{l%U1%X1|lwz%U1%X1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n-    case 2:\n-      return \\\"{st%U0%X0|stw%U0%X0} %1,%0\\;{st|stw} %L1,%L0\\\";\n-    case 3:\n-    case 4:\n-    case 5:\n-      return \\\"#\\\";\n-    }\n-}\"\n+  \"#\"\n   [(set_attr \"type\" \"two,load,store,*,*,*\")\n    (set_attr \"length\" \"8,8,8,8,12,16\")])\n \n@@ -9729,8 +9637,8 @@\n }\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"rs6000_nonimmediate_operand\" \"\")\n-        (match_operand:DI 1 \"input_operand\" \"\"))]\n+  [(set (match_operand:DIFD 0 \"rs6000_nonimmediate_operand\" \"\")\n+        (match_operand:DIFD 1 \"input_operand\" \"\"))]\n   \"reload_completed && !TARGET_POWERPC64\n    && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(pc)]"}, {"sha": "5797626bc56a120ff3ec82eb8f507c1161a38092", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60936b2231c00ac15bb23405723f997c68f12a27", "patch": "@@ -1,3 +1,8 @@\n+2010-03-17  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\tPR target/42427\n+\t* gcc.dg/pr42427.c: New test.\n+\n 2010-03-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/43265"}, {"sha": "1961313bc5fa92b2b8c390ee229714bcdb446741", "filename": "gcc/testsuite/gcc.dg/pr42427.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42427.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60936b2231c00ac15bb23405723f997c68f12a27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42427.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42427.c?ref=60936b2231c00ac15bb23405723f997c68f12a27", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O2 -fexceptions -fnon-call-exceptions -fpeel-loops\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+#include <complex.h>\n+\n+extern double myabs (complex double);\n+\n+void\n+test (double *help, complex double *wm, long nz)\n+{\n+  long k;\n+  double znew;\n+  double zold;\n+  for (k = 0; k < nz; k++)\n+    {\n+      znew = myabs (wm[k]);\n+      zold = help[k];\n+      help[k] = znew;\n+    }\n+}"}]}