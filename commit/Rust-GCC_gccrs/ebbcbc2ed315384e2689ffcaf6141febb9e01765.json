{"sha": "ebbcbc2ed315384e2689ffcaf6141febb9e01765", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiY2JjMmVkMzE1Mzg0ZTI2ODlmZmNhZjYxNDFmZWJiOWUwMTc2NQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-11T19:17:17Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-11-11T19:17:17Z"}, "message": "re PR target/47440 (Use LCM for vzeroupper insertion)\n\n\tPR target/47440\n\t* config/i386/i386.c (check_avx256_stores): Remove.\n\t(ix86_check_avx256_register): New.\n\t(ix86_avx_u128_mode_needed): Use ix86_check_avx256_register.\n\tCheck the whole RTX for 256bit registers using for_each_rtx.\n\t(ix86_check_avx_stores): New.\n\t(ix86_avx_u128_mode_after): Change mode of CALL RTX to AVX_U128_CLEAN\n\tif there are no 256bit registers used in the function return register.\n\t(ix86_avx_u128_mode_entry): Use ix86_check_avx256_register.\n\t(ix86_avx_u128_mode_exit): Ditto.\n\nFrom-SVN: r193409", "tree": {"sha": "ac8da306839f28c4b0dcf24f0d0f4c1111751736", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac8da306839f28c4b0dcf24f0d0f4c1111751736"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebbcbc2ed315384e2689ffcaf6141febb9e01765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbcbc2ed315384e2689ffcaf6141febb9e01765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebbcbc2ed315384e2689ffcaf6141febb9e01765", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbcbc2ed315384e2689ffcaf6141febb9e01765/comments", "author": null, "committer": null, "parents": [{"sha": "2059f70d74ecc06262ea6e8351299846f2e3e530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2059f70d74ecc06262ea6e8351299846f2e3e530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2059f70d74ecc06262ea6e8351299846f2e3e530"}], "stats": {"total": 88, "additions": 54, "deletions": 34}, "files": [{"sha": "8149a85288e2d7c14a10510f3ab8f1ddba7aa952", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbcbc2ed315384e2689ffcaf6141febb9e01765/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbcbc2ed315384e2689ffcaf6141febb9e01765/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebbcbc2ed315384e2689ffcaf6141febb9e01765", "patch": "@@ -1,10 +1,23 @@\n+2012-11-10  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/47440\n+\t* config/i386/i386.c (check_avx256_stores): Remove.\n+\t(ix86_check_avx256_register): New.\n+\t(ix86_avx_u128_mode_needed): Use ix86_check_avx256_register.\n+\tCheck the whole RTX for 256bit registers using for_each_rtx.\n+\t(ix86_check_avx_stores): New.\n+\t(ix86_avx_u128_mode_after): Change mode of CALL RTX to AVX_U128_CLEAN\n+\tif there are no 256bit registers used in the function return register.\n+\t(ix86_avx_u128_mode_entry): Use ix86_check_avx256_register.\n+\t(ix86_avx_u128_mode_exit): Ditto.\n+\n 2012-11-10  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/48636\n \t* ipa-inline.c (want_inline_small_function_p): Take aray index hint.\n \t(edge_badness): Likewise.\n \t* ipa-inline.h (inline_hints_vals): Add array_index and comments.\n-\t(inline_summary_: Add ARRAY_INDEX.\n+\t(inline_summary): Add ARRAY_INDEX.\n \t* ipa-inline-analysis.c (dump_inline_hints): Dump array_index hint.\n \t(reset_inline_summary): Handle array_index hint.\n \t(inline_node_duplication_hook): Likewise.\n@@ -27,7 +40,7 @@\n \n 2012-11-10  Sandra Loosemore  <sandra@codesourcery.com>\n \n-\t* doc/extend.texi: Copy-edit to fix incorrect uses of \"which\" \n+\t* doc/extend.texi: Copy-edit to fix incorrect uses of \"which\"\n \tand \"that\" throughout the file.\n \n 2012-11-10  Andrew Pinski  <apinski@cavium.com>"}, {"sha": "0872295c2aa9e48f76392cff5f4d2255ea6f622c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbcbc2ed315384e2689ffcaf6141febb9e01765/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbcbc2ed315384e2689ffcaf6141febb9e01765/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ebbcbc2ed315384e2689ffcaf6141febb9e01765", "patch": "@@ -14942,29 +14942,23 @@ output_387_binary_op (rtx insn, rtx *operands)\n   return buf;\n }\n \n-/* Check if a 256bit AVX register is referenced in stores.   */\n+/* Check if a 256bit AVX register is referenced inside of EXP.   */\n \n-static void\n-check_avx256_stores (rtx dest, const_rtx set, void *data)\n+static int\n+ix86_check_avx256_register (rtx *exp, void *data ATTRIBUTE_UNUSED)\n {\n-  if (((REG_P (dest) || MEM_P (dest))\n-       && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (dest)))\n-      || (GET_CODE (set) == SET\n-\t  && (REG_P (SET_SRC (set)) || MEM_P (SET_SRC (set)))\n-\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (SET_SRC (set)))))\n-    {\n-      bool *used = (bool *) data;\n-      *used = true;\n-    }\n+  if (REG_P (*exp)\n+      && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (*exp)))\n+    return 1;\n+\n+  return 0;\n }\n \n /* Return needed mode for entity in optimize_mode_switching pass.  */\n \n static int\n ix86_avx_u128_mode_needed (rtx insn)\n {\n-  bool avx_u128_used;\n-\n   if (CALL_P (insn))\n     {\n       rtx link;\n@@ -14979,19 +14973,19 @@ ix86_avx_u128_mode_needed (rtx insn)\n \t    {\n \t      rtx arg = XEXP (XEXP (link, 0), 0);\n \n-\t      if (REG_P (arg)\n-\t\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (arg)))\n+\t      if (ix86_check_avx256_register (&arg, NULL))\n \t\treturn AVX_U128_ANY;\n \t    }\n \t}\n \n       return AVX_U128_CLEAN;\n     }\n \n-  /* Check if a 256bit AVX register is referenced in stores.  */\n-  avx_u128_used = false;\n-  note_stores (PATTERN (insn), check_avx256_stores, &avx_u128_used);\n-  if (avx_u128_used)\n+  /* Require DIRTY mode if a 256bit AVX register is referenced.  Hardware\n+     changes state only when a 256bit register is written to, but we need\n+     to prevent the compiler from moving optimal insertion point above\n+     eventual read from 256bit register.  */\n+  if (for_each_rtx (&PATTERN (insn), ix86_check_avx256_register, NULL))\n     return AVX_U128_DIRTY;\n \n   return AVX_U128_ANY;\n@@ -15071,28 +15065,42 @@ ix86_mode_needed (int entity, rtx insn)\n   return 0;\n }\n \n+/* Check if a 256bit AVX register is referenced in stores.   */\n+ \n+static void\n+ix86_check_avx256_stores (rtx dest, const_rtx set ATTRIBUTE_UNUSED, void *data)\n+ {\n+   if (ix86_check_avx256_register (&dest, NULL))\n+    {\n+      bool *used = (bool *) data;\n+      *used = true;\n+    }\n+ } \n+\n /* Calculate mode of upper 128bit AVX registers after the insn.  */\n \n static int\n ix86_avx_u128_mode_after (int mode, rtx insn)\n {\n   rtx pat = PATTERN (insn);\n-  bool avx_u128_used;\n \n   if (vzeroupper_operation (pat, VOIDmode)\n       || vzeroall_operation (pat, VOIDmode))\n     return AVX_U128_CLEAN;\n \n-  /* Check if a 256bit AVX register is referenced in stores.  */\n-  avx_u128_used = false;\n-  note_stores (pat, check_avx256_stores, &avx_u128_used);\n-  if (avx_u128_used)\n-    return AVX_U128_DIRTY;\n   /* We know that state is clean after CALL insn if there are no\n-     256bit modes used in the function return register.  */\n-  else if (CALL_P (insn))\n-    return AVX_U128_CLEAN;\n+     256bit registers used in the function return register.  */\n+  if (CALL_P (insn))\n+    {\n+      bool avx_reg256_found = false;\n+      note_stores (pat, ix86_check_avx256_stores, &avx_reg256_found);\n+      if (!avx_reg256_found)\n+\treturn AVX_U128_CLEAN;\n+    }\n \n+  /* Otherwise, return current mode.  Remember that if insn\n+     references AVX 256bit registers, the mode was already changed\n+     to DIRTY from MODE_NEEDED.  */\n   return mode;\n }\n \n@@ -15127,8 +15135,7 @@ ix86_avx_u128_mode_entry (void)\n     {\n       rtx incoming = DECL_INCOMING_RTL (arg);\n \n-      if (incoming && REG_P (incoming)\n-\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (incoming)))\n+      if (incoming && ix86_check_avx256_register (&incoming, NULL))\n \treturn AVX_U128_DIRTY;\n     }\n \n@@ -15162,7 +15169,7 @@ ix86_avx_u128_mode_exit (void)\n \n   /* Exit mode is set to AVX_U128_DIRTY if there are\n      256bit modes used in the function return register.  */\n-  if (reg && REG_P (reg) && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (reg)))\n+  if (reg && ix86_check_avx256_register (&reg, NULL))\n     return AVX_U128_DIRTY;\n \n   return AVX_U128_CLEAN;"}]}