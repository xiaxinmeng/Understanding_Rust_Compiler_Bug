{"sha": "e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVkMWFmOGEwN2FlOWZjYzQwZWE1Yzc4MWMzYWQ0NmQyMGVhMTJhNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-15T20:21:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-15T20:21:17Z"}, "message": "c++: Fix handling of decls with flexible array members initialized with side-effects [PR88578]\n\n> > Note, if the flexible array member is initialized only with non-constant\n> > initializers, we have a worse bug that this patch doesn't solve, the\n> > splitting of initializers into constant and dynamic initialization removes\n> > the initializer and we don't have just wrong DECL_*SIZE, but nothing is\n> > emitted when emitting those vars into assembly either and so the dynamic\n> > initialization clobbers other vars that may overlap the variable.\n> > I think we need keep an empty CONSTRUCTOR elt in DECL_INITIAL for the\n> > flexible array member in that case.\n>\n> Makes sense.\n\nSo, the following patch fixes that.\n\nThe typeck2.c change makes sure we keep those CONSTRUCTORs around (although\nthey should be empty because all their elts had side-effects/was\nnon-constant if it was removed earlier), and the varasm.c change is to avoid\nICEs on those as well as ICEs on other flex array members that had some\ninitializers without side-effects, but not on the last array element.\n\nThe code was already asserting that the (index of the last elt in the\nCONSTRUCTOR + 1) times elt size is equal to TYPE_SIZE_UNIT of the local->val\ntype, which is true for C flex arrays or for C++ if they don't have any\nside-effects or the last elt doesn't have side-effects, this patch changes\nthat to assertion that the TYPE_SIZE_UNIT is greater than equal to the\noffset of the end of last element in the CONSTRUCTOR and uses TYPE_SIZE_UNIT\n(int_size_in_bytes) in the code later on.\n\n2021-09-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/88578\n\tPR c++/102295\ngcc/\n\t* varasm.c (output_constructor_regular_field): Instead of assertion\n\tthat array_size_for_constructor result is equal to size of\n\tTREE_TYPE (local->val) in bytes, assert that the type size is greater\n\tor equal to array_size_for_constructor result and use type size as\n\tfieldsize.\ngcc/cp/\n\t* typeck2.c (split_nonconstant_init_1): Don't throw away empty\n\tinitializers of flexible array members if they have non-zero type\n\tsize.\ngcc/testsuite/\n\t* g++.dg/ext/flexary39.C: New test.\n\t* g++.dg/ext/flexary40.C: New test.", "tree": {"sha": "d7fcafbe23d57f089ee8933f3d7ca0dd9f98fdd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7fcafbe23d57f089ee8933f3d7ca0dd9f98fdd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ab5c3d5457f0d480c6423ee7ac52ce1f98592c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab5c3d5457f0d480c6423ee7ac52ce1f98592c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ab5c3d5457f0d480c6423ee7ac52ce1f98592c9"}], "stats": {"total": 142, "additions": 138, "deletions": 4}, "files": [{"sha": "abfd7dabd607833491a46bfa1a27b52bae5ccfff", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "patch": "@@ -524,7 +524,20 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested)\n \t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE);\n \n-\t      if (!split_nonconstant_init_1 (sub, value, true))\n+\t      if (!split_nonconstant_init_1 (sub, value, true)\n+\t\t      /* For flexible array member with initializer we\n+\t\t\t can't remove the initializer, because only the\n+\t\t\t initializer determines how many elements the\n+\t\t\t flexible array member has.  */\n+\t\t  || (!array_type_p\n+\t\t      && TREE_CODE (inner_type) == ARRAY_TYPE\n+\t\t      && TYPE_DOMAIN (inner_type) == NULL\n+\t\t      && TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n+\t\t      && COMPLETE_TYPE_P (TREE_TYPE (value))\n+\t\t      && !integer_zerop (TYPE_SIZE (TREE_TYPE (value)))\n+\t\t      && idx == CONSTRUCTOR_NELTS (init) - 1\n+\t\t      && TYPE_HAS_TRIVIAL_DESTRUCTOR\n+\t\t\t\t(strip_array_types (inner_type))))\n \t\tcomplete_p = false;\n \t      else\n \t\t{"}, {"sha": "8eb81f26cf5ae0efcf27a025bd55c14b193b0c9f", "filename": "gcc/testsuite/g++.dg/ext/flexary39.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary39.C?ref=e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "patch": "@@ -0,0 +1,65 @@\n+// PR c++/88578\n+// { dg-do run }\n+// { dg-options -Wno-pedantic }\n+\n+#define STR(s) #s\n+#define ASSERT(exp) \\\n+  ((exp) ? (void)0 : (void)(__builtin_printf (\"%s:%i: assertion %s failed\\n\", \\\n+                     __FILE__, __LINE__, STR(exp)), \\\n+                      __builtin_abort ()))\n+\n+typedef int int32_t __attribute__((mode (__SI__)));\n+\n+struct Ax { int32_t n, a[]; };\n+struct AAx { int32_t i; Ax ax; };\n+\n+int32_t i = 12345678;\n+\n+void\n+test ()\n+{\n+  {\n+    // OK.  Does not assign any elements to flexible array.\n+    Ax s = { 0 };\n+    ASSERT (s.n == 0);\n+  }\n+  {\n+    // OK only for statically allocated objects, otherwise error.\n+    static Ax s = { 0, { } };\n+    ASSERT (s.n == 0);\n+  }\n+  {\n+    static Ax s = { 1, { 2 } };\n+    ASSERT (s.n == 1 && s.a [0] == 2);\n+  }\n+  {\n+    static Ax s = { 2, { 3, 4 } };\n+    ASSERT (s.n = 2 && s.a [0] == 3 && s.a [1] == 4);\n+  }\n+  {\n+    static Ax s = { 123, i };\n+    ASSERT (s.n == 123 && s.a [0] == i);\n+  }\n+  {\n+    static Ax s = { 456, { i } };\n+    ASSERT (s.n == 456 && s.a [0] == i);\n+  }\n+  {\n+    int32_t j = i + 1, k = j + 1;\n+    static Ax s = { 3, { i, j, k } };\n+    ASSERT (s.n == 3 && s.a [0] == i && s.a [1] == j && s.a [2] == k);\n+  }\n+\n+  {\n+    // OK.  Does not assign any elements to flexible array.\n+    AAx s = { 1, { 2 } };\n+    ASSERT (s.i == 1 && s.ax.n == 2);\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  test ();\n+  test ();\n+}"}, {"sha": "ee824c29d3a2ff850c892fa3b1f0bafaad660558", "filename": "gcc/testsuite/g++.dg/ext/flexary40.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary40.C?ref=e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "patch": "@@ -0,0 +1,50 @@\n+// PR c++/102295\n+// { dg-do run }\n+// { dg-options \"\" }\n+\n+struct A { int a; int b[]; };\n+struct B { B (); int k; };\n+struct C { int l; B m[]; };\n+\n+int x[4];\n+A c = { 42, { ++x[0], ++x[1], ++x[2], ++x[3] } };\n+A d = { 43, { 0, ++x[0], ++x[1], ++x[2], ++x[3] } };\n+A e = { 44, { ++x[0], ++x[1], ++x[2], 17 } };\n+A f = { 45 };\n+C n = { 50, { B (), B () } };\n+C o = { 51, {} };\n+\n+int\n+main ()\n+{\n+  static A g = { 46, { ++x[0], ++x[1], ++x[2], ++x[3] } };\n+  static A h = { 47, { 0, ++x[0], ++x[1], ++x[2], ++x[3] } };\n+  static A i = { 48, { ++x[0], ++x[1], ++x[2], 18 } };\n+  static A j = { 49 };\n+  if (c.a != 42 || c.b[0] != 1 || c.b[1] != 1 || c.b[2] != 1 || c.b[3] != 1)\n+    __builtin_abort ();\n+  if (d.a != 43 || d.b[0] != 0 || d.b[1] != 2 || d.b[2] != 2 || d.b[3] != 2 || d.b[4] != 2)\n+    __builtin_abort ();\n+  if (e.a != 44 || e.b[0] != 3 || e.b[1] != 3 || e.b[2] != 3 || e.b[3] != 17)\n+    __builtin_abort ();\n+  if (f.a != 45)\n+    __builtin_abort ();\n+  if (g.a != 46 || g.b[0] != 4 || g.b[1] != 4 || g.b[2] != 4 || g.b[3] != 3)\n+    __builtin_abort ();\n+  if (h.a != 47 || h.b[0] != 0 || h.b[1] != 5 || h.b[2] != 5 || h.b[3] != 5 || h.b[4] != 4)\n+    __builtin_abort ();\n+  if (i.a != 48 || i.b[0] != 6 || i.b[1] != 6 || i.b[2] != 6 || i.b[3] != 18)\n+    __builtin_abort ();\n+  if (j.a != 49)\n+    __builtin_abort ();\n+  if (n.l != 50 || n.m[0].k != 42 || n.m[1].k != 42)\n+    __builtin_abort ();\n+  if (o.l != 51)\n+    __builtin_abort ();\n+  if (x[0] != 6 || x[1] != 6 || x[2] != 6 || x[3] != 4)\n+    __builtin_abort ();\n+}\n+\n+B::B () : k (42)\n+{\n+}"}, {"sha": "2d261b353bf9318e0478f61b6ca8a1bdbdef2d1d", "filename": "gcc/varasm.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e5d1af8a07ae9fcc40ea5c781c3ad46d20ea12a6", "patch": "@@ -5531,14 +5531,20 @@ output_constructor_regular_field (oc_local_state *local)\n \t  && (!TYPE_DOMAIN (TREE_TYPE (local->field))\n \t      || !TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (local->field)))))\n \t{\n-\t  fieldsize = array_size_for_constructor (local->val);\n+\t  unsigned HOST_WIDE_INT fldsize\n+\t    = array_size_for_constructor (local->val);\n+\t  fieldsize = int_size_in_bytes (TREE_TYPE (local->val));\n+\t  /* In most cases fieldsize == fldsize as the size of the initializer\n+\t     determines how many elements the flexible array member has.  For\n+\t     C++ fldsize can be smaller though, if the last or several last or\n+\t     all initializers of the flexible array member have side-effects\n+\t     and the FE splits them into dynamic initialization.  */\n+\t  gcc_checking_assert (fieldsize >= fldsize);\n \t  /* Given a non-empty initialization, this field had better\n \t     be last.  Given a flexible array member, the next field\n \t     on the chain is a TYPE_DECL of the enclosing struct.  */\n \t  const_tree next = DECL_CHAIN (local->field);\n \t  gcc_assert (!fieldsize || !next || TREE_CODE (next) != FIELD_DECL);\n-\t  tree size = TYPE_SIZE_UNIT (TREE_TYPE (local->val));\n-\t  gcc_checking_assert (compare_tree_int (size, fieldsize) == 0);\n \t}\n       else\n \tfieldsize = tree_to_uhwi (DECL_SIZE_UNIT (local->field));"}]}