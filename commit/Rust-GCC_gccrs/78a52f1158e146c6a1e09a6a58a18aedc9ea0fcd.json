{"sha": "78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhhNTJmMTE1OGUxNDZjNmExZTA5YTZhNThhMThhZWRjOWVhMGZjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-30T03:08:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-30T03:08:18Z"}, "message": "target.h (targetm.calls.arg_partial_bytes): New.\n\n\t* target.h (targetm.calls.arg_partial_bytes): New.\n\t* target-def.h (TARGET_ARG_PARTIAL_BYTES): New.\n\t* calls.c (store_unaligned_arguments_into_pseudos): Update for\n\tpartial in bytes.\n\t(load_register_parameters): Likewise.\n\t(store_one_arg): Likewise.\n\t(initialize_argument_information): Use targetm.calls.arg_partial_bytes.\n\t(emit_library_call_value_1): Likewise.\n\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n\t(emit_push_insn): Update for partial in bytes.\n\t* expr.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* function.c (assign_parm_find_entry_rtl): Use\n\ttargetm.calls.arg_partial_bytes.  Update for result in bytes.\n\t(locate_and_pad_parm): Update for partial in bytes.\n\t* system.h (FUNCTION_ARG_PARTIAL_NREGS): Poison.\n\t* targhooks.c (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): New.\n\t* targhooks.h (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Declare.\n\t* doc/tm.texi (TARGET_ARG_PARTIAL_BYTES): Rename and update from\n\tFUNCTION_ARG_PARTIAL_NREGS.\n\n\t* config/arc/arc.h, config/c4x/c4x.h, config/i386/i386.h,\n\tconfig/i860/i860.h, config/m68hc11/m68hc11.h, config/m68k/m68k.h,\n\tconfig/pdp11/pdp11.h, config/s390/s390.h, config/stormy16/stormy16.h,\n\tconfig/xtensa/xtensa.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\n\t* config/alpha/alpha.c (alpha_arg_partial_bytes): New.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/alpha/alpha.h, config/alpha/unicosmk.h,\n\tconfig/alpha/vms.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\n\t* config/arm/arm.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n\t* config/arm/arm.c (arm_arg_partial_bytes): ... here.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\n\t* config/cris/cris.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n\t* config/cris/cris.c (cris_arg_partial_bytes): ... here.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\n\t* config/fr30/fr30.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/fr30/fr30.c (fr30_arg_partial_bytes): Rename from\n\tfr30_function_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/fr30/fr30-protos.h: Update.\n\n\t* config/frv/frv.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/frv/frv.c (frv_arg_partial_bytes): Rename from\n\tfrv_function_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/frv/frv-protos.h: Update.\n\n\t* config/ia64/ia64.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/ia64/ia64.c (ia64_arg_partial_bytes): Rename from\n\tia64_function_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/ia64/ia64-protos.h: Update.\n\n\t* config/iq2000/iq2000.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/iq2000/iq2000.c (iq2000_arg_partial_bytes): Rename from\n\tfunction_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/iq2000/iq2000-protos.h: Update.\n\n\t* config/m32r/m32r.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/m32r/m32r.c (m32r_arg_partial_bytes): Rename from\n\tfunction_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/m32r/m32r-protos.h: Update.\n\n\t* config/mcore/mcore.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/mcore/mcore.c (mcore_arg_partial_bytes): Rename from\n\tmcore_function_arg_partial_nregs.  Adjust to return bytes.\n        (TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/mcore/mcore-protos.h: Update.\n\n\t* config/mips/mips.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/mips/mips.c (mips_arg_partial_bytes): Rename from\n\tfunction_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/mips/mips-protos.h: Update.\n\n\t* config/mn10300/mn10300.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/mn10300/mn10300.c (mn10300_arg_partial_bytes): Rename from\n\tfunction_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/mn10300/mn10300-protos.h: Update.\n\n\t* config/ns32k/ns32k.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n\t* config/ns32k/ns32k.c (ns32k_arg_partial_bytes): ... here.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\n\t* config/pa/pa.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/pa/pa.c (pa_arg_partial_bytes): Rename from\n\tfunction_arg_partial_nregs.  Handle 32-bit.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/pa/pa-protos.h: Update.\n\n\t* config/rs6000/rs6000.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/rs6000/rs6000.c (rs6000_arg_partial_bytes): Rename from\n\tfunction_arg_partial_nregs.  Adjust to return bytes.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/rs6000/rs6000-protos.h: Update.\n\n\t* config/sh/sh.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n\t* config/sh/sh.c (sh_arg_partial_bytes): ... here.\n\t(TARGET_ARG_PARTIAL_BYTES): New.\n\n\t* config/sparc/sparc.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/sparc/sparc.c (sparc_arg_partial_bytes): Rename from\n\tfunction_arg_partial_nregs.  Adjust to return bytes.\n        (TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/sparc/sparc-protos.h: Update.\n\n\t* config/v850/v850.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n\t* config/v850/v850.c (v850_arg_partial_bytes): Rename from\n        function_arg_partial_nregs.  Adjust to return bytes.\n        (TARGET_ARG_PARTIAL_BYTES): New.\n\t* config/v850/v850-protos.h: Update.\n\nFrom-SVN: r92726", "tree": {"sha": "89b8670b5e2c1cd0fc2446517dc71747b11ef273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89b8670b5e2c1cd0fc2446517dc71747b11ef273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/comments", "author": null, "committer": null, "parents": [{"sha": "86cdac113375a75b96ad79412b667838bf3c00f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cdac113375a75b96ad79412b667838bf3c00f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86cdac113375a75b96ad79412b667838bf3c00f0"}], "stats": {"total": 888, "additions": 464, "deletions": 424}, "files": [{"sha": "b03786d34ae952d0c1f29e626f352189af6fb614", "filename": "gcc/ChangeLog", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1,3 +1,123 @@\n+2004-12-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* target.h (targetm.calls.arg_partial_bytes): New.\n+\t* target-def.h (TARGET_ARG_PARTIAL_BYTES): New.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Update for\n+\tpartial in bytes.\n+\t(load_register_parameters): Likewise.\n+\t(store_one_arg): Likewise.\n+\t(initialize_argument_information): Use targetm.calls.arg_partial_bytes.\n+\t(emit_library_call_value_1): Likewise.\n+\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n+\t(emit_push_insn): Update for partial in bytes.\n+\t* expr.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* function.c (assign_parm_find_entry_rtl): Use\n+\ttargetm.calls.arg_partial_bytes.  Update for result in bytes.\n+\t(locate_and_pad_parm): Update for partial in bytes.\n+\t* system.h (FUNCTION_ARG_PARTIAL_NREGS): Poison.\n+\t* targhooks.c (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): New.\n+\t* targhooks.h (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Declare.\n+\t* doc/tm.texi (TARGET_ARG_PARTIAL_BYTES): Rename and update from\n+\tFUNCTION_ARG_PARTIAL_NREGS.\n+\n+\t* config/arc/arc.h, config/c4x/c4x.h, config/i386/i386.h,\n+\tconfig/i860/i860.h, config/m68hc11/m68hc11.h, config/m68k/m68k.h,\n+\tconfig/pdp11/pdp11.h, config/s390/s390.h, config/stormy16/stormy16.h, \n+\tconfig/xtensa/xtensa.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\n+\t* config/alpha/alpha.c (alpha_arg_partial_bytes): New.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/alpha/alpha.h, config/alpha/unicosmk.h,\n+\tconfig/alpha/vms.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\n+\t* config/arm/arm.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n+\t* config/arm/arm.c (arm_arg_partial_bytes): ... here.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\n+\t* config/cris/cris.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n+\t* config/cris/cris.c (cris_arg_partial_bytes): ... here.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\n+\t* config/fr30/fr30.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/fr30/fr30.c (fr30_arg_partial_bytes): Rename from\n+\tfr30_function_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/fr30/fr30-protos.h: Update.\n+\n+\t* config/frv/frv.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/frv/frv.c (frv_arg_partial_bytes): Rename from \n+\tfrv_function_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/frv/frv-protos.h: Update.\n+\n+\t* config/ia64/ia64.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/ia64/ia64.c (ia64_arg_partial_bytes): Rename from\n+\tia64_function_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/ia64/ia64-protos.h: Update.\n+\n+\t* config/iq2000/iq2000.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/iq2000/iq2000.c (iq2000_arg_partial_bytes): Rename from\n+\tfunction_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/iq2000/iq2000-protos.h: Update.\n+\n+\t* config/m32r/m32r.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/m32r/m32r.c (m32r_arg_partial_bytes): Rename from\n+\tfunction_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/m32r/m32r-protos.h: Update.\n+\n+\t* config/mcore/mcore.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/mcore/mcore.c (mcore_arg_partial_bytes): Rename from\n+\tmcore_function_arg_partial_nregs.  Adjust to return bytes.\n+        (TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/mcore/mcore-protos.h: Update.\n+\n+\t* config/mips/mips.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/mips/mips.c (mips_arg_partial_bytes): Rename from\n+\tfunction_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/mips/mips-protos.h: Update.\n+\n+\t* config/mn10300/mn10300.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/mn10300/mn10300.c (mn10300_arg_partial_bytes): Rename from\t\n+\tfunction_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\n+\t* config/ns32k/ns32k.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n+\t* config/ns32k/ns32k.c (ns32k_arg_partial_bytes): ... here.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\n+\t* config/pa/pa.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/pa/pa.c (pa_arg_partial_bytes): Rename from \n+\tfunction_arg_partial_nregs.  Handle 32-bit.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/pa/pa-protos.h: Update.\n+\n+\t* config/rs6000/rs6000.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/rs6000/rs6000.c (rs6000_arg_partial_bytes): Rename from \n+\tfunction_arg_partial_nregs.  Adjust to return bytes.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/rs6000/rs6000-protos.h: Update.\n+\n+\t* config/sh/sh.h (FUNCTION_ARG_PARTIAL_NREGS): Move ...\n+\t* config/sh/sh.c (sh_arg_partial_bytes): ... here.\n+\t(TARGET_ARG_PARTIAL_BYTES): New.\n+\n+\t* config/sparc/sparc.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/sparc/sparc.c (sparc_arg_partial_bytes): Rename from\n+\tfunction_arg_partial_nregs.  Adjust to return bytes.\n+        (TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/sparc/sparc-protos.h: Update.\n+\n+\t* config/v850/v850.h (FUNCTION_ARG_PARTIAL_NREGS): Remove.\n+\t* config/v850/v850.c (v850_arg_partial_bytes): Rename from\n+        function_arg_partial_nregs.  Adjust to return bytes.\n+        (TARGET_ARG_PARTIAL_BYTES): New.\n+\t* config/v850/v850-protos.h: Update.\n+\n 2004-12-30  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* config/mmix/mmix.h (ASM_OUTPUT_INTERNAL_LABEL): Define."}, {"sha": "0d0c0f262029a3a36fe47bf5d4b16f0107962ec8", "filename": "gcc/calls.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -832,10 +832,19 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t    < (unsigned int) MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n       {\n \tint bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n-\tint nregs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \tint endian_correction = 0;\n \n-\targs[i].n_aligned_regs = args[i].partial ? args[i].partial : nregs;\n+\tif (args[i].partial)\n+\t  {\n+\t    gcc_assert (args[i].partial % UNITS_PER_WORD == 0);\n+\t    args[i].n_aligned_regs = args[i].partial / UNITS_PER_WORD;\n+\t  }\n+\telse\n+\t  {\n+\t    args[i].n_aligned_regs\n+\t      = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\t  }\n+\n \targs[i].aligned_regs = xmalloc (sizeof (rtx) * args[i].n_aligned_regs);\n \n \t/* Structures smaller than a word are normally aligned to the\n@@ -973,7 +982,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t args[i].reg is nonzero if all or part is passed in registers.\n \n \t args[i].partial is nonzero if part but not all is passed in registers,\n-\t and the exact value says how many words are passed in registers.\n+\t and the exact value says how many bytes are passed in registers.\n \n \t args[i].pass_on_stack is nonzero if the argument must at least be\n \t computed on the stack.  It may then be loaded back into registers\n@@ -1079,8 +1088,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n       if (args[i].reg)\n \targs[i].partial\n-\t  = FUNCTION_ARG_PARTIAL_NREGS (*args_so_far, mode, type,\n-\t\t\t\t\targpos < n_named_args);\n+\t  = targetm.calls.arg_partial_bytes (args_so_far, mode, type,\n+\t\t\t\t\t     argpos < n_named_args);\n \n       args[i].pass_on_stack = targetm.calls.must_pass_in_stack (mode, type);\n \n@@ -1454,8 +1463,13 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t     we just use a normal move insn.  This value can be zero if the\n \t     argument is a zero size structure with no fields.  */\n \t  nregs = -1;\n-\t  if (partial)\n-\t    nregs = partial;\n+\t  if (GET_CODE (reg) == PARALLEL)\n+\t    ;\n+\t  else if (partial)\n+\t    {\n+\t      gcc_assert (partial % UNITS_PER_WORD == 0);\n+\t      nregs = partial / UNITS_PER_WORD;\n+\t    }\n \t  else if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode)\n \t    {\n \t      size = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n@@ -3286,7 +3300,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   if (mem_value && struct_value == 0 && ! pcc_struct_value)\n     {\n       rtx addr = XEXP (mem_value, 0);\n-      int partial;\n       \n       nargs++;\n \n@@ -3300,8 +3313,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       argvec[count].partial = 0;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, Pmode, NULL_TREE, 1);\n-      partial = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, Pmode, NULL_TREE, 1);\n-      gcc_assert (!partial);\n+      gcc_assert (targetm.calls.arg_partial_bytes (&args_so_far, Pmode,\n+\t\t\t\t\t\t   NULL_TREE, 1) == 0);\n \n       locate_and_pad_parm (Pmode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n@@ -3387,7 +3400,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n \n       argvec[count].partial\n-\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n+\t= targetm.calls.arg_partial_bytes (&args_so_far, mode, NULL_TREE, 1);\n \n       locate_and_pad_parm (mode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n@@ -4097,20 +4110,11 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t}\n       else\n \t{\n-\t  /* PUSH_ROUNDING has no effect on us, because\n-\t     emit_push_insn for BLKmode is careful to avoid it.  */\n-\t  if (reg && GET_CODE (reg) == PARALLEL)\n-\t  {\n-\t    /* Use the size of the elt to compute excess.  */\n-\t    rtx elt = XEXP (XVECEXP (reg, 0, 0), 0);\n-\t    excess = (arg->locate.size.constant\n-\t\t      - int_size_in_bytes (TREE_TYPE (pval))\n-\t\t      + partial * GET_MODE_SIZE (GET_MODE (elt)));\n-\t  }\n-\t  else\n-\t    excess = (arg->locate.size.constant\n-\t\t      - int_size_in_bytes (TREE_TYPE (pval))\n-\t\t      + partial * UNITS_PER_WORD);\n+\t  /* PUSH_ROUNDING has no effect on us, because emit_push_insn\n+\t     for BLKmode is careful to avoid it.  */\n+\t  excess = (arg->locate.size.constant\n+\t\t    - int_size_in_bytes (TREE_TYPE (pval))\n+\t\t    + partial);\n \t  size_rtx = expand_expr (size_in_bytes (TREE_TYPE (pval)),\n \t\t\t\t  NULL_RTX, TYPE_MODE (sizetype), 0);\n \t}"}, {"sha": "a7fe7da29988cdd4ffcbb524ca095efb75bbf8aa", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -5190,6 +5190,31 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n   return gen_rtx_REG (mode, num_args + basereg);\n }\n \n+static int\n+alpha_arg_partial_bytes (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t bool named ATTRIBUTE_UNUSED)\n+{\n+  int words = 0;\n+\n+#if TARGET_ABI_OPEN_VMS\n+  if (cum->num_args < 6\n+      && 6 < cum->num_args + ALPHA_ARG_SIZE (mode, type, named))\n+    words = 6 - (CUM).num_args;\n+#elif TARGET_ABI_UNICOSMK\n+  /* Never any split arguments.  */\n+#elif TARGET_ABI_OSF\n+  if (*cum < 6 && 6 < *cum + ALPHA_ARG_SIZE (mode, type, named))\n+    words = 6 - *cum;\n+#else\n+#error Unhandled ABI\n+#endif\n+\n+  return words * UNITS_PER_WORD;\n+}\n+\n+\n /* Return true if TYPE must be returned in memory, instead of in registers.  */\n \n static bool\n@@ -9453,6 +9478,8 @@ alpha_init_libfuncs (void)\n #define TARGET_SPLIT_COMPLEX_ARG alpha_split_complex_arg\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR alpha_gimplify_va_arg\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES alpha_arg_partial_bytes\n \n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P alpha_scalar_mode_supported_p"}, {"sha": "e9a409816a17080aeec01a80a54cfc8a8d21c956", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1067,14 +1067,6 @@ extern int alpha_memory_latency;\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n   function_arg((CUM), (MODE), (TYPE), (NAMED))\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n-((CUM) < 6 && 6 < (CUM) + ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\t\\\n- ? 6 - (CUM) : 0)\n-\n /* Try to output insns to set TARGET equal to the constant C if it can be\n    done in less than N insns.  Do all computations in MODE.  Returns the place\n    where the output has been placed if it can be done and the insns have been"}, {"sha": "02b3dde3db58946fa1c34bbe32dbda5ab1f89e56", "filename": "gcc/config/alpha/unicosmk.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -210,11 +210,6 @@ do {\t\t\t\t\t\t\t\t\\\n   ++(CUM).num_args;\t\t\t\t\t\t\\\n } while(0)\n \n-/* An argument is passed either entirely in registers or entirely on stack.  */\n- \n-#undef FUNCTION_ARG_PARTIAL_NREGS\n-/* #define FUNCTION_ARG_PARTIAL_NREGS(CUM,MODE,TYPE,NAMED) 0 */\n-\n /* This ensures that $15 increments/decrements in leaf functions won't get\n    eliminated.  */\n "}, {"sha": "c660f37a8b016178377eded25946a3a47f12d77b", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -189,16 +189,6 @@ typedef struct {int num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n      (CUM).num_args += ALPHA_ARG_SIZE (MODE, TYPE, NAMED);\t\t\\\n     }\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#undef FUNCTION_ARG_PARTIAL_NREGS\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n-((CUM).num_args < 6 && 6 < (CUM).num_args\t\t\t\t\\\n-   + ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\t\t\t\t\t\\\n- ? 6 - (CUM).num_args : 0)\n-\n /* ABI has stack checking, but it's broken.  */\n #undef STACK_CHECK_BUILTIN\n #define STACK_CHECK_BUILTIN 0"}, {"sha": "b5259a71015228b94c3c7b2f8b0f8073132750d5", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -681,21 +681,6 @@ extern enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n  ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n  : 0)\n \n-/* A C expression for the number of words, at the beginning of an\n-   argument, must be put in registers.  The value must be zero for\n-   arguments that are passed entirely in registers or that are entirely\n-   pushed on the stack.\n-\n-   On some machines, certain arguments must be passed partially in\n-   registers and partially in memory.  On these machines, typically the\n-   first @var{n} words of arguments are passed in registers, and the rest\n-   on the stack.  If a multi-word argument (a @code{double} or a\n-   structure) crosses that boundary, its first few words must be passed\n-   in registers and the rest must be pushed.  This macro tells the\n-   compiler when this occurs, and how many of the words should go in\n-   registers.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */"}, {"sha": "91850cb95a7249b711ff2c6ac8580c1dc940d672", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -147,6 +147,8 @@ static rtx arm_expand_binop_builtin (enum insn_code, tree, rtx);\n static rtx arm_expand_unop_builtin (enum insn_code, tree, rtx, int);\n static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static void emit_constant_insn (rtx cond, rtx pattern);\n+static int arm_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t  tree, bool);\n \n #ifndef ARM_PE\n static void arm_encode_section_info (tree, rtx, int);\n@@ -272,6 +274,8 @@ static unsigned HOST_WIDE_INT arm_shift_truncation_mask (enum machine_mode);\n #define TARGET_PROMOTE_PROTOTYPES arm_promote_prototypes\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE arm_pass_by_reference\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES arm_arg_partial_bytes\n \n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX arm_struct_value_rtx\n@@ -2527,6 +2531,23 @@ arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n   return gen_rtx_REG (mode, pcum->nregs);\n }\n \n+static int\n+arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+\t\t       tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  int nregs = pcum->nregs;\n+\n+  if (arm_vector_mode_supported_p (mode))\n+    return 0;\n+\n+  if (NUM_ARG_REGS > nregs\n+      && (NUM_ARG_REGS < nregs + ARM_NUM_REGS2 (mode, type))\n+      && pcum->can_split)\n+    return (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;\n+\n+  return 0;\n+}\n+\n /* Variable sized types are passed by reference.  This is a GCC\n    extension to the ARM ABI.  */\n "}, {"sha": "54fcef2e356fc7c9926da34bd3e52ec9c0e31b07", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1743,16 +1743,6 @@ typedef struct\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   arm_function_arg (&(CUM), (MODE), (TYPE), (NAMED))\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t        \\\n-  (arm_vector_mode_supported_p (MODE) ? 0 :\t\t\t\t\\\n-       NUM_ARG_REGS > (CUM).nregs\t\t\t\t        \\\n-   && (NUM_ARG_REGS < ((CUM).nregs + ARM_NUM_REGS2 (MODE, TYPE))\t\\\n-   && (CUM).can_split)\t\t\t\t\t\t        \\\n-   ?   NUM_ARG_REGS - (CUM).nregs : 0)\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0."}, {"sha": "1112ab82736fd77a57fd0013e55271d3e3ee7d1c", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1128,8 +1128,6 @@ CUMULATIVE_ARGS;\n \n #define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n /* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(REGNO) \\"}, {"sha": "d023d009f64a610cb4b3f9f067b30099c2d358e3", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -117,6 +117,8 @@ static bool cris_rtx_costs (rtx, int, int, int *);\n static int cris_address_cost (rtx);\n static bool cris_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    tree, bool);\n+static int cris_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t   tree, bool);\n \n /* The function cris_target_asm_function_epilogue puts the last insn to\n    output here.  It always fits; there won't be a symbol operand.  Used in\n@@ -191,6 +193,8 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #define TARGET_SETUP_INCOMING_VARARGS cris_setup_incoming_varargs\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE cris_pass_by_reference\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES cris_arg_partial_bytes\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -3184,6 +3188,20 @@ cris_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n }\n \n \n+static int\n+cris_arg_partial_bytes (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  if (ca->regs == CRIS_MAX_ARGS_IN_REGS - 1\n+      && !targetm.calls.must_pass_in_stack (mode, type)\n+      && CRIS_FUNCTION_ARG_SIZE (mode, type) > 4\n+      && CRIS_FUNCTION_ARG_SIZE (mode, type) <= 8)\n+    return UNITS_PER_WORD;\n+  else\n+    return 0;\n+}\n+\n+\n #if 0\n /* Various small functions to replace macros.  Only called from a\n    debugger.  They might collide with gcc functions or system functions,"}, {"sha": "a8a4f0d97f2b56a633dc419f6e94645e09b330d9", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -953,13 +953,6 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n   ? gen_rtx_REG (MODE, CRIS_FIRST_ARG_REG + (CUM).regs)\t\t\\\n   : NULL_RTX)\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n- (((CUM).regs == (CRIS_MAX_ARGS_IN_REGS - 1)\t\t\t\\\n-   && !targetm.calls.must_pass_in_stack (MODE, TYPE)\t\t\\\n-   && CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) > 4\t\t\t\\\n-   && CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) <= 8)\t\t\t\\\n-  ? 1 : 0)\n-\n /* Contrary to what you'd believe, defining FUNCTION_ARG_CALLEE_COPIES\n    seems like a (small total) loss, at least for gcc-2.7.2 compiling and\n    running gcc-2.1 (small win in size, small loss running -- 100.1%),"}, {"sha": "cf69a82e9ada5393e19dd49a5fec4b8eca2cafee", "filename": "gcc/config/fr30/fr30-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffr30%2Ffr30-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffr30%2Ffr30-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -29,8 +29,6 @@ extern void  fr30_print_operand_address (FILE *, rtx);\n extern rtx   fr30_move_double (rtx *);\n #ifdef TREE_CODE\n extern int   fr30_num_arg_regs (enum machine_mode, tree);\n-extern int   fr30_function_arg_partial_nregs (CUMULATIVE_ARGS,\n-\t\t\t\t\t      enum machine_mode, tree, int);\n #endif /* TREE_CODE */\n #ifdef HAVE_MACHINE_MODES\n #define Mmode enum machine_mode"}, {"sha": "31b37e477c54e5e658de4d7f0da3f1cbc56f2891", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -124,6 +124,9 @@ static struct fr30_frame_info \tzero_frame_info;\n static void fr30_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static bool fr30_must_pass_in_stack (enum machine_mode, tree);\n+static int fr30_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t   tree, bool);\n+\n \n #define FRAME_POINTER_MASK \t(1 << (FRAME_POINTER_REGNUM))\n #define RETURN_POINTER_MASK \t(1 << (RETURN_POINTER_REGNUM))\n@@ -154,6 +157,8 @@ static bool fr30_must_pass_in_stack (enum machine_mode, tree);\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n #undef  TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE hook_pass_by_reference_must_pass_in_stack\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES fr30_arg_partial_bytes\n \n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS fr30_setup_incoming_varargs\n@@ -697,22 +702,21 @@ fr30_num_arg_regs (enum machine_mode mode, tree type)\n   return (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n-/* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.\n-   Returns the number of argument registers required to hold *part* of\n-   a parameter of machine mode MODE and tree type TYPE (which may be\n-   NULL if the type is not known).  If the argument fits entirely in\n-   the argument registers, or entirely on the stack, then 0 is returned.\n+/* Returns the number of bytes in which *part* of a parameter of machine\n+   mode MODE and tree type TYPE (which may be NULL if the type is not known).\n+   If the argument fits entirely in the argument registers, or entirely on\n+   the stack, then 0 is returned.\n    CUM is the number of argument registers already used by earlier\n    parameters to the function.  */\n \n-int\n-fr30_function_arg_partial_nregs (CUMULATIVE_ARGS cum, enum machine_mode mode,\n-\t\t\t\t tree type, int named)\n+static int\n+fr30_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\ttree type, bool named)\n {\n   /* Unnamed arguments, i.e. those that are prototyped as ...\n      are always passed on the stack.\n      Also check here to see if all the argument registers are full.  */\n-  if (named == 0 || cum >= FR30_NUM_ARG_REGS)\n+  if (named == 0 || *cum >= FR30_NUM_ARG_REGS)\n     return 0;\n \n   /* Work out how many argument registers would be needed if this\n@@ -721,11 +725,10 @@ fr30_function_arg_partial_nregs (CUMULATIVE_ARGS cum, enum machine_mode mode,\n      are needed because the parameter must be passed on the stack)\n      then return zero, as this parameter does not require partial\n      register, partial stack stack space.  */\n-  if (cum + fr30_num_arg_regs (mode, type) <= FR30_NUM_ARG_REGS)\n+  if (*cum + fr30_num_arg_regs (mode, type) <= FR30_NUM_ARG_REGS)\n     return 0;\n   \n-  /* Otherwise return the number of registers that would be used.  */\n-  return FR30_NUM_ARG_REGS - cum;\n+  return (FR30_NUM_ARG_REGS - *cum) * UNITS_PER_WORD;\n }\n \n /*}}}*/"}, {"sha": "7847a7672bda0c4e42f965ab72751bbd55ab422e", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -676,24 +676,6 @@ enum reg_class\n    the number of bytes of argument accumulated so far.  */\n #define CUMULATIVE_ARGS int\n \n-/* A C expression for the number of words, at the beginning of an argument,\n-   must be put in registers.  The value must be zero for arguments that are\n-   passed entirely in registers or that are entirely pushed on the stack.\n-\n-   On some machines, certain arguments must be passed partially in registers\n-   and partially in memory.  On these machines, typically the first N words of\n-   arguments are passed in registers, and the rest on the stack.  If a\n-   multi-word argument (a `double' or a structure) crosses that boundary, its\n-   first few words must be passed in registers and the rest must be pushed.\n-   This macro tells the compiler when this occurs, and how many of the words\n-   should go in registers.\n-\n-   `FUNCTION_ARG' for these arguments should return the first register to be\n-   used by the caller for this argument; likewise `FUNCTION_INCOMING_ARG', for\n-   the called function.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\\\n-  fr30_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n-\n /* A C statement (sans semicolon) for initializing the variable CUM for the\n    state at the beginning of the argument list.  The variable has type\n    `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node for the data type"}, {"sha": "63b43b990fd0d822ea2a0087c6fa5255ade8aa29", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -84,10 +84,6 @@ extern void frv_function_arg_advance\t\t(CUMULATIVE_ARGS *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, int);\n \n-extern int frv_function_arg_partial_nregs\t(CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t tree, int);\n-\n extern void frv_expand_builtin_va_start\t\t(tree, rtx);\n #endif /* TREE_CODE */\n "}, {"sha": "cdf9744bf54006c613315f89daf7bcbb584995ca", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -376,6 +376,8 @@ static void frv_output_const_unspec\t\t(FILE *,\n static bool frv_function_ok_for_sibcall\t\t(tree, tree);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n static bool frv_must_pass_in_stack (enum machine_mode mode, tree type);\n+static int frv_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t  tree, bool);\n \f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n@@ -418,6 +420,8 @@ static bool frv_must_pass_in_stack (enum machine_mode mode, tree type);\n #define TARGET_MUST_PASS_IN_STACK frv_must_pass_in_stack\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE hook_pass_by_reference_must_pass_in_stack\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES frv_arg_partial_bytes\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS frv_expand_builtin_saveregs\n@@ -3192,11 +3196,9 @@ frv_function_arg_advance (CUMULATIVE_ARGS *cum,\n    used by the caller for this argument; likewise `FUNCTION_INCOMING_ARG', for\n    the called function.  */\n \n-int\n-frv_function_arg_partial_nregs (CUMULATIVE_ARGS *cum,\n-                                enum machine_mode mode,\n-                                tree type ATTRIBUTE_UNUSED,\n-                                int named ATTRIBUTE_UNUSED)\n+static int\n+frv_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t       tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n {\n   enum machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n   int bytes = GET_MODE_SIZE (xmode);\n@@ -3207,12 +3209,12 @@ frv_function_arg_partial_nregs (CUMULATIVE_ARGS *cum,\n   ret = ((arg_num <= LAST_ARG_REGNUM && arg_num + words > LAST_ARG_REGNUM+1)\n \t ? LAST_ARG_REGNUM - arg_num + 1\n \t : 0);\n+  ret *= UNITS_PER_WORD;\n \n   if (TARGET_DEBUG_ARG && ret)\n-    fprintf (stderr, \"function_arg_partial_nregs: %d\\n\", ret);\n+    fprintf (stderr, \"frv_arg_partial_bytes: %d\\n\", ret);\n \n   return ret;\n-\n }\n \n \f"}, {"sha": "ed62183f66e9981d5d7ed131b8b1eb49988a99f0", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1884,26 +1884,6 @@ struct machine_function GTY(())\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n   frv_function_arg (&CUM, MODE, TYPE, NAMED, TRUE)\n \n-/* A C expression for the number of words, at the beginning of an argument,\n-   must be put in registers.  The value must be zero for arguments that are\n-   passed entirely in registers or that are entirely pushed on the stack.\n-\n-   On some machines, certain arguments must be passed partially in registers\n-   and partially in memory.  On these machines, typically the first N words of\n-   arguments are passed in registers, and the rest on the stack.  If a\n-   multi-word argument (a `double' or a structure) crosses that boundary, its\n-   first few words must be passed in registers and the rest must be pushed.\n-   This macro tells the compiler when this occurs, and how many of the words\n-   should go in registers.\n-\n-   `FUNCTION_ARG' for these arguments should return the first register to be\n-   used by the caller for this argument; likewise `FUNCTION_INCOMING_ARG', for\n-   the called function.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n-  frv_function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n-\n-/* extern int frv_function_arg_partial_nregs (CUMULATIVE_ARGS, int, Tree, int);  */\n-\n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the type\n    `int' suffices and can hold the number of bytes of argument so far."}, {"sha": "47d7035d46674a34eb785e08f2e86270567d61eb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1777,12 +1777,6 @@ typedef struct ix86_args {\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&(CUM), (MODE), (TYPE), (NAMED))\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n /* Implement `va_start' for varargs and stdarg.  */\n #define EXPAND_BUILTIN_VA_START(VALIST, NEXTARG) \\\n   ix86_va_start (VALIST, NEXTARG)"}, {"sha": "f1c46ec86f545afb918028a45806d8c4736489b9", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -529,12 +529,6 @@ struct cumulative_args { int ints, floats; };\n      : 0)\t\t\t\t\t\t\\\n   : 0)\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n /* If defined, a C expression that gives the alignment boundary, in\n    bits, of an argument with the specified mode and type.  If it is\n    not defined,  `PARM_BOUNDARY' is used for all arguments.  */"}, {"sha": "30ea5e1ba6569faf19a6a658c25e12c2a9cc71a6", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -73,8 +73,6 @@ extern rtx ia64_va_arg (tree, tree);\n extern rtx ia64_function_value (tree, tree);\n #endif /* RTX_CODE */\n \n-extern int ia64_function_arg_partial_nregs (CUMULATIVE_ARGS *,\n-\t\t\t\t\t    enum machine_mode, tree, int);\n extern void ia64_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       tree, int);\n extern int ia64_function_arg_boundary (enum machine_mode, tree);"}, {"sha": "6478cb1ba213d41d91e3f81029a837e4d94fe3c2", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -191,6 +191,8 @@ static void ia64_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static bool ia64_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    tree, bool);\n+static int ia64_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t   tree, bool);\n static bool ia64_function_ok_for_sibcall (tree, tree);\n static bool ia64_return_in_memory (tree, tree);\n static bool ia64_rtx_costs (rtx, int, int, int *);\n@@ -362,6 +364,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ia64_function_ok_for_sibcall\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE ia64_pass_by_reference\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES ia64_arg_partial_bytes\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK ia64_output_mi_thunk\n@@ -3250,13 +3254,13 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n     }\n }\n \n-/* Return number of words, at the beginning of the argument, that must be\n+/* Return number of bytes, at the beginning of the argument, that must be\n    put in registers.  0 is the argument is entirely in registers or entirely\n    in memory.  */\n \n-int\n-ia64_function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t\t tree type, int named ATTRIBUTE_UNUSED)\n+static int\n+ia64_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n   int words = ia64_function_arg_words (type, mode);\n   int offset = ia64_function_arg_offset (cum, type, words);\n@@ -3273,7 +3277,7 @@ ia64_function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (words + cum->words + offset <= MAX_ARGUMENT_SLOTS)\n     return 0;\n \n-  return MAX_ARGUMENT_SLOTS - cum->words - offset;\n+  return (MAX_ARGUMENT_SLOTS - cum->words - offset) * UNITS_PER_WORD;\n }\n \n /* Update CUM to point after this argument.  This is patterned after"}, {"sha": "c38854b8bbbdb49238b5399cb493dcb5e7f70558", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1326,13 +1326,6 @@ enum reg_class\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n   ia64_function_arg (&CUM, MODE, TYPE, NAMED, 1)\n \n-/* A C expression for the number of words, at the beginning of an argument,\n-   must be put in registers.  The value must be zero for arguments that are\n-   passed entirely in registers or that are entirely pushed on the stack.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n- ia64_function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n-\n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the type\n    `int' suffices and can hold the number of bytes of argument so far.  */"}, {"sha": "8d210b1c77e201597951202a7e2ec0a33cb7f80e", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -49,7 +49,6 @@ extern void             gen_conditional_branch (rtx *, enum rtx_code);\n extern void             init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n extern void             function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern struct rtx_def * function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n-extern int              function_arg_partial_nregs (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void             iq2000_va_start (tree, rtx);\n extern rtx              iq2000_function_value (tree, tree);\n #endif"}, {"sha": "80f5a4cd7cb20675ead1cf37cc2d05ad8c007be1", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -174,6 +174,8 @@ static void iq2000_select_section     (tree, int, unsigned HOST_WIDE_INT);\n static bool iq2000_return_in_memory   (tree, tree);\n static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       tree, bool);\n+static int  iq2000_arg_partial_bytes  (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t       tree, bool);\n \n #undef  TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS \t\tiq2000_init_builtins\n@@ -201,6 +203,8 @@ static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_PASS_BY_REFERENCE\tiq2000_pass_by_reference\n #undef  TARGET_CALLEE_COPIES\n #define TARGET_CALLEE_COPIES\t\thook_callee_copies_named\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES\tiq2000_arg_partial_bytes\n \n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS\tiq2000_setup_incoming_varargs\n@@ -1552,18 +1556,16 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   return ret;\n }\n \n-int\n-function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t    tree type ATTRIBUTE_UNUSED,\n-\t\t\t    int named ATTRIBUTE_UNUSED)\n+static int\n+iq2000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t  tree type ATTRIBUTE_UNUSED,\n+\t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n-  if (mode == DImode\n-\t   && cum->arg_words == MAX_ARGS_IN_REGISTERS - (unsigned)1)\n+  if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS - 1)\n     {\n       if (TARGET_DEBUG_D_MODE)\n-\tfprintf (stderr, \"function_arg_partial_nregs = 1\\n\");\n-\n-      return 1;\n+\tfprintf (stderr, \"iq2000_arg_partial_bytes=%d\\n\", UNITS_PER_WORD);\n+      return UNITS_PER_WORD;\n     }\n \n   return 0;"}, {"sha": "2e10efbea636f878886a2c073a73e0ce218b754f", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -438,9 +438,6 @@ enum reg_class\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (& CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (& CUM, MODE, TYPE, NAMED)\n-\n #define MAX_ARGS_IN_REGISTERS 8\n \n typedef struct iq2000_args"}, {"sha": "2ea6a59ab0dbb119d2cb0b93262bfa5e73a3f7bb", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -35,10 +35,6 @@ extern void   m32r_load_pic_register (void);\n \n #ifdef TREE_CODE\n extern enum m32r_function_type m32r_compute_function_type (tree);\n-\n-#ifdef HAVE_MACHINE_MODES\n-extern int    function_arg_partial_nregs (CUMULATIVE_ARGS *, Mmode, tree, int);\n-#endif\n #endif /* TREE_CODE */\n \n #ifdef RTX_CODE"}, {"sha": "170c4c67b4cfb66105d91f3ba4625f37731d25aa", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -102,6 +102,8 @@ static void init_idents (void);\n static bool m32r_rtx_costs (rtx, int, int, int *);\n static bool m32r_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    tree, bool);\n+static int m32r_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t   tree, bool);\n \f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ATTRIBUTE_TABLE\n@@ -145,6 +147,8 @@ static bool m32r_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n #undef  TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE m32r_pass_by_reference\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES m32r_arg_partial_bytes\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -1321,27 +1325,25 @@ gen_split_move_double (rtx operands[])\n }\n \n \f\n-/* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.  */\n-\n-int\n-function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n+static int\n+m32r_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n-  int ret;\n+  int words;\n   unsigned int size =\n     (((mode == BLKmode && type)\n       ? (unsigned int) int_size_in_bytes (type)\n       : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1)\n     / UNITS_PER_WORD;\n \n   if (*cum >= M32R_MAX_PARM_REGS)\n-    ret = 0;\n+    words = 0;\n   else if (*cum + size > M32R_MAX_PARM_REGS)\n-    ret = (*cum + size) - M32R_MAX_PARM_REGS;\n+    words = (*cum + size) - M32R_MAX_PARM_REGS;\n   else\n-    ret = 0;\n+    words = 0;\n \n-  return ret;\n+  return words * UNITS_PER_WORD;\n }\n \n /* Worker function for TARGET_RETURN_IN_MEMORY.  */"}, {"sha": "2ebda2a6e603d5e94d6bea619e7f77410e4ee986", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1099,22 +1099,6 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n    : 0)\n \n-/* A C expression for the number of words, at the beginning of an\n-   argument, must be put in registers.  The value must be zero for\n-   arguments that are passed entirely in registers or that are entirely\n-   pushed on the stack.\n-\n-   On some machines, certain arguments must be passed partially in\n-   registers and partially in memory.  On these machines, typically the\n-   first @var{n} words of arguments are passed in registers, and the rest\n-   on the stack.  If a multi-word argument (a @code{double} or a\n-   structure) crosses that boundary, its first few words must be passed\n-   in registers and the rest must be pushed.  This macro tells the\n-   compiler when this occurs, and how many of the words should go in\n-   registers.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (&CUM, (int)MODE, TYPE, NAMED)\n-\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */"}, {"sha": "2bd886326b0d984b9e125c88d0666322ef961a1f", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1083,14 +1083,6 @@ typedef struct m68hc11_args\n    caller saving results in spill failure.  */\n #define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.\n-\n-   Passing an arg partly in register and memory does not work at all.\n-   Don't do that.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)\n-\n /* 1 if N is a possible register number for function argument passing.\n    D is for 16-bit values, X is for 32-bit (X+D).  */\n #define FUNCTION_ARG_REGNO_P(N)\t\\"}, {"sha": "4a832b4ccda851fba093436a0d90d9db16c2b506", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -733,7 +733,6 @@ extern enum reg_class regno_reg_class[];\n \n /* On the m68k all args are always pushed.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n #define FUNCTION_PROFILER(FILE, LABELNO)  \\\n   asm_fprintf (FILE, \"\\tlea %LLP%d,%Ra0\\n\\tjsr mcount\\n\", (LABELNO))"}, {"sha": "b035e9b7e75edc0602c68595e18bbd6d39ee7bb8", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -36,7 +36,6 @@ extern int          mcore_naked_function_p       \t(void);\n \n #ifdef TREE_CODE\n #ifdef HAVE_MACHINE_MODES\n-extern int          mcore_function_arg_partial_nregs\t(CUMULATIVE_ARGS, enum machine_mode, tree, int);\n extern int          mcore_num_arg_regs           \t(enum machine_mode, tree);\n #endif /* HAVE_MACHINE_MODES */\n "}, {"sha": "6b0b4fb8bc603f50306eccc0aaa0567dc3ad4da5", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -149,6 +149,9 @@ static int        mcore_ior_cost               \t(rtx);\n static bool       mcore_rtx_costs\t\t(rtx, int, int, int *);\n static void       mcore_external_libcall\t(rtx);\n static bool       mcore_return_in_memory\t(tree, tree);\n+static int        mcore_arg_partial_bytes       (CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, bool);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -197,6 +200,8 @@ static bool       mcore_return_in_memory\t(tree, tree);\n #define TARGET_MUST_PASS_IN_STACK\tmust_pass_in_stack_var_size\n #undef  TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE  hook_pass_by_reference_must_pass_in_stack\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES\tmcore_arg_partial_bytes\n \n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS\tmcore_setup_incoming_varargs\n@@ -3107,19 +3112,18 @@ mcore_function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode,\n   return 0;\n }\n \n-/* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.\n-   Returns the number of argument registers required to hold *part* of\n-   a parameter of machine mode MODE and type TYPE (which may be NULL if\n+/* Returns the number of bytes of argument registers required to hold *part*\n+   of a parameter of machine mode MODE and type TYPE (which may be NULL if\n    the type is not known).  If the argument fits entirely in the argument\n    registers, or entirely on the stack, then 0 is returned.  CUM is the\n    number of argument registers already used by earlier parameters to\n    the function.  */\n \n-int\n-mcore_function_arg_partial_nregs (CUMULATIVE_ARGS cum, enum machine_mode mode,\n-\t\t\t\t  tree type, int named)\n+static int\n+mcore_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t tree type, bool named)\n {\n-  int reg = ROUND_REG (cum, mode);\n+  int reg = ROUND_REG (*cum, mode);\n \n   if (named == 0)\n     return 0;\n@@ -3148,7 +3152,7 @@ mcore_function_arg_partial_nregs (CUMULATIVE_ARGS cum, enum machine_mode mode,\n   reg = NPARM_REGS - reg;\n \n   /* Return partially in registers and partially on the stack.  */\n-  return reg;\n+  return reg * UNITS_PER_WORD;\n }\n \f\n /* Return nonzero if SYMBOL is marked as being dllexport'd.  */"}, {"sha": "4f68c632300683ffd012290b9363df188ee57b9e", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -704,14 +704,6 @@ extern const enum reg_class reg_class_from_letter[];\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   mcore_function_arg (CUM, MODE, TYPE, NAMED)\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.\n-   Any arg that starts in the first NPARM_REGS regs but won't entirely\n-   fit in them needs partial registers on the MCore.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  mcore_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n-\n /* Call the function profiler with a given profile label.  */\n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\\\n {\t\t\t\t\t\t\t\\"}, {"sha": "8569d429959b8fe145aaa2bf0fa32ab7a5c31f53", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -141,8 +141,6 @@ extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int);\n extern struct rtx_def *function_arg (const CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, int);\n-extern int function_arg_partial_nregs (const CUMULATIVE_ARGS *,\n-\t\t\t\t       enum machine_mode, tree, int);\n extern int function_arg_boundary (enum machine_mode, tree);\n extern bool mips_pad_arg_upward (enum machine_mode, tree);\n extern bool mips_pad_reg_upward (enum machine_mode, tree);"}, {"sha": "450b01d4659c097e28c0a39f10f9713f92807c7f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -352,6 +352,8 @@ static bool mips_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode mode,\n \t\t\t\t    tree, bool);\n static bool mips_callee_copies (CUMULATIVE_ARGS *, enum machine_mode mode,\n \t\t\t\ttree, bool);\n+static int mips_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode mode,\n+\t\t\t\t   tree, bool);\n static bool mips_valid_pointer_mode (enum machine_mode);\n static bool mips_scalar_mode_supported_p (enum machine_mode);\n static bool mips_vector_mode_supported_p (enum machine_mode);\n@@ -798,6 +800,8 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #define TARGET_PASS_BY_REFERENCE mips_pass_by_reference\n #undef TARGET_CALLEE_COPIES\n #define TARGET_CALLEE_COPIES mips_callee_copies\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES mips_arg_partial_bytes\n \n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P mips_vector_mode_supported_p\n@@ -3316,16 +3320,16 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n \n-/* Implement FUNCTION_ARG_PARTIAL_NREGS.  */\n+/* Implement TARGET_ARG_PARTIAL_BYTES.  */\n \n-int\n-function_arg_partial_nregs (const CUMULATIVE_ARGS *cum,\n-\t\t\t    enum machine_mode mode, tree type, int named)\n+static int\n+mips_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+\t\t\tenum machine_mode mode, tree type, bool named)\n {\n   struct mips_arg_info info;\n \n   mips_arg_info (cum, mode, type, named, &info);\n-  return info.stack_words > 0 ? info.reg_words : 0;\n+  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n }\n \n "}, {"sha": "495b8190f4bf82cea62cdaf1dce8077294c53335", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -2279,13 +2279,6 @@ typedef struct mips_args {\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg( &CUM, MODE, TYPE, NAMED)\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n-\n #define FUNCTION_ARG_BOUNDARY function_arg_boundary\n \n #define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\\"}, {"sha": "77af9a9b131f41d42176a701e50efc61489454dc", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -50,8 +50,6 @@ extern bool mn10300_wide_const_load_uses_clr (rtx operands[2]);\n #ifdef TREE_CODE\n extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, int);\n-extern int function_arg_partial_nregs (CUMULATIVE_ARGS *,\n-\t\t\t\t       enum machine_mode, tree, int);\n #endif /* TREE_CODE */\n \n extern void expand_prologue (void);"}, {"sha": "16832054c0d5def29c1561718278067d846748e6", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -73,6 +73,8 @@ static bool mn10300_return_in_memory (tree, tree);\n static rtx mn10300_builtin_saveregs (void);\n static bool mn10300_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       tree, bool);\n+static int mn10300_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t      tree, bool);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -99,6 +101,8 @@ static bool mn10300_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_PASS_BY_REFERENCE mn10300_pass_by_reference\n #undef TARGET_CALLEE_COPIES\n #define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES mn10300_arg_partial_bytes\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS mn10300_builtin_saveregs\n@@ -1528,12 +1532,12 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   return result;\n }\n \n-/* Return the number of registers to use for an argument passed partially\n-   in registers and partially in memory.  */\n+/* Return the number of bytes of registers to use for an argument passed\n+   partially in registers and partially in memory.  */\n \n-int\n-function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n+static int\n+mn10300_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t   tree type, bool named ATTRIBUTE_UNUSED)\n {\n   int size, align;\n \n@@ -1565,7 +1569,7 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && cum->nbytes + size > nregs * UNITS_PER_WORD)\n     return 0;\n \n-  return (nregs * UNITS_PER_WORD - cum->nbytes) / UNITS_PER_WORD;\n+  return nregs * UNITS_PER_WORD - cum->nbytes;\n }\n \n /* Output a tst insn.  */"}, {"sha": "121d087a1e545d5ea47a4124238360a11e09e746", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -609,9 +609,6 @@ struct cum_arg {int nbytes; };\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n-\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;"}, {"sha": "bad908d49d5675401b708ec8a21b87fea2b84e92", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -74,6 +74,8 @@ static void ns32k_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static bool ns32k_rtx_costs (rtx, int, int, int *);\n static int ns32k_address_cost (rtx);\n static rtx ns32k_struct_value_rtx (tree, int);\n+static int ns32k_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t    tree, bool);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -100,6 +102,9 @@ static rtx ns32k_struct_value_rtx (tree, int);\n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX ns32k_struct_value_rtx\n \n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES ns32k_arg_partial_bytes\n+\n #undef TARGET_ASM_FILE_START_APP_OFF\n #define TARGET_ASM_FILE_START_APP_OFF true\n \n@@ -1639,3 +1644,27 @@ ns32k_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n       && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n     abort ();\n }\n+\n+/* Implement TARGET_ARG_PARTIAL_BYTES.  */\n+\n+static int\n+ns32k_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+\t\t\t tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  int cum = *pcum;\n+\n+  if (TARGET_REGPARM && cum < 8)\n+    {\n+      HOST_WIDE_INT size;\n+\n+      if (mode == BLKmode)\n+\tsize = int_size_in_bytes (type);\n+      else\n+\tsize = GET_MODE_SIZE (mode);\n+\n+      if (8 < cum + size)\n+\treturn 8 - cum;\n+    }\n+\n+  return 0;\n+}"}, {"sha": "414656b6053f6271ab2453edfdd2adba5badd619", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -708,17 +708,6 @@ enum reg_class\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n ((TARGET_REGPARM && (CUM) < 8) ? gen_rtx_REG ((MODE), (CUM) / 4) : 0)\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n-((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n-  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n-\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n-\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n- ? 2 - (CUM) / 4 : 0)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.\n "}, {"sha": "a5bc0240b1e7466cd900b83abf8eea100f4e1890", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -160,9 +160,6 @@ extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t tree, int);\n extern rtx function_value (tree, tree);\n #endif\n-extern int function_arg_partial_nregs (CUMULATIVE_ARGS *,\n-\t\t\t\t       enum machine_mode,\n-\t\t\t\t       tree, int);\n extern bool pa_return_in_memory (tree, tree);\n #endif /* TREE_CODE */\n "}, {"sha": "762f24e1b4ef75c4a1e652197f29c638857e412e", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -141,8 +141,10 @@ static void output_deferred_plabels (void);\n static void pa_hpux_init_libfuncs (void);\n #endif\n static rtx pa_struct_value_rtx (tree, int);\n-static bool pa_pass_by_reference (CUMULATIVE_ARGS *ca, enum machine_mode,\n+static bool pa_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, bool);\n+static int pa_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t tree, bool);\n static struct machine_function * pa_init_machine_status (void);\n \n \n@@ -282,6 +284,8 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_PASS_BY_REFERENCE pa_pass_by_reference\n #undef TARGET_CALLEE_COPIES\n #define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES pa_arg_partial_bytes\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS hppa_builtin_saveregs\n@@ -9069,7 +9073,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   arg_size = FUNCTION_ARG_SIZE (mode, type);\n \n   /* If this arg would be passed partially or totally on the stack, then\n-     this routine should return zero.  FUNCTION_ARG_PARTIAL_NREGS will\n+     this routine should return zero.  pa_arg_partial_bytes will\n      handle arguments which are split between regs and stack slots if\n      the ABI mandates split arguments.  */\n   if (! TARGET_64BIT)\n@@ -9238,15 +9242,18 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n \n \n /* If this arg would be passed totally in registers or totally on the stack,\n-   then this routine should return zero. It is currently called only for\n-   the 64-bit target.  */\n-int\n-function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n+   then this routine should return zero.  */\n+\n+static int\n+pa_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t      tree type, bool named ATTRIBUTE_UNUSED)\n {\n   unsigned int max_arg_words = 8;\n   unsigned int offset = 0;\n \n+  if (!TARGET_64BIT)\n+    return 0;\n+\n   if (FUNCTION_ARG_SIZE (mode, type) > 1 && (cum->words & 1))\n     offset = 1;\n \n@@ -9258,7 +9265,7 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     return 0;\n   else\n     /* Arg is split.  */\n-    return max_arg_words - cum->words - offset;\n+    return (max_arg_words - cum->words - offset) * UNITS_PER_WORD;\n }\n \n "}, {"sha": "450775910efaa7eacf6c798e2617bc027fa93eaa", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -923,15 +923,6 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-/* For PA32 there are never split arguments. PA64, on the other hand, can\n-   pass arguments partially in registers and partially in memory.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  (TARGET_64BIT ? function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED) : 0)\n-\n /* If defined, a C expression that gives the alignment boundary, in\n    bits, of an argument with the specified mode and type.  If it is\n    not defined,  `PARM_BOUNDARY' is used for all arguments.  */"}, {"sha": "72ca1a57508cbddba6781bdf627bf5716e39e7c1", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -628,12 +628,6 @@ maybe ac0 ? - as option someday! */\n   FUNCTION_ARG (CUM, MODE, TYPE, NAMED)\n */\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n "}, {"sha": "4a4fcde8e2da0139f4526dbea4d5e29f550011cc", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -160,8 +160,6 @@ extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n extern int function_arg_boundary (enum machine_mode, tree);\n extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, int);\n-extern int function_arg_partial_nregs (CUMULATIVE_ARGS *,\n-\t\t\t\t       enum machine_mode, tree, int);\n extern rtx rs6000_function_value (tree, tree);\n extern rtx rs6000_libcall_value (enum machine_mode);\n extern struct rtx_def *rs6000_va_arg (tree, tree);"}, {"sha": "bf340dcb28bdda07b2fde57d57d563436ea94c75", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -756,6 +756,8 @@ static void setup_incoming_varargs (CUMULATIVE_ARGS *,\n \t\t\t\t    int *, int);\n static bool rs6000_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t      tree, bool);\n+static int rs6000_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t     tree, bool);\n #if TARGET_MACHO\n static void macho_branch_islands (void);\n static void add_compiler_branch_island (tree, tree, int);\n@@ -991,6 +993,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_MUST_PASS_IN_STACK rs6000_must_pass_in_stack\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE rs6000_pass_by_reference\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES rs6000_arg_partial_bytes\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST rs6000_build_builtin_va_list\n@@ -5306,6 +5310,8 @@ rs6000_mixed_function_arg (enum machine_mode mode, tree type, int align_words)\n        In any case, the code to store the whole arg to memory is often\n        more efficient than code to store pieces, and we know that space\n        is available in the right place for the whole arg.  */\n+    /* FIXME: This should be fixed since the conversion to\n+       TARGET_ARG_PARTIAL_BYTES.  */\n     rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n \n   i = 0;\n@@ -5606,11 +5612,11 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    the number of registers used.  For args passed entirely in registers\n    or entirely in memory, zero.  When an arg is described by a PARALLEL,\n    perhaps using more than one register type, this function returns the\n-   number of registers used by the first element of the PARALLEL.  */\n+   number of bytes of registers used by the PARALLEL.  */\n \n-int\n-function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t    tree type, int named)\n+static int\n+rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t  tree type, bool named)\n {\n   int ret = 0;\n   int align;\n@@ -5648,8 +5654,10 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && GP_ARG_NUM_REG < align_words + rs6000_arg_size (mode, type))\n     ret = GP_ARG_NUM_REG - align_words;\n \n+  ret *= (TARGET_32BIT ? 4 : 8);\n+\n   if (ret != 0 && TARGET_DEBUG_ARG)\n-    fprintf (stderr, \"function_arg_partial_nregs: %d\\n\", ret);\n+    fprintf (stderr, \"rs6000_arg_partial_bytes: %d\\n\", ret);\n \n   return ret;\n }"}, {"sha": "63c1b839c2d747986581eb24ee87c7260a6273f8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1744,13 +1744,6 @@ typedef struct rs6000_args\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n-\n /* If defined, a C expression which determines whether, and in which\n    direction, to pad out an argument with extra space.  The value\n    should be of type `enum direction': either `upward' to pad above"}, {"sha": "d2b23badaab3e1533b6bb4d023264e7186d67613", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -717,8 +717,6 @@ CUMULATIVE_ARGS;\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)   \\\n   s390_function_arg (&CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n /* Arguments can be placed in general registers 2 to 6,\n    or in floating point registers 0 and 2.  */\n #define FUNCTION_ARG_REGNO_P(N) (((N) >=2 && (N) <7) || \\"}, {"sha": "358f9b7e8353247c61234252aa1525dbfd199be4", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -286,6 +286,8 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, bool);\n static bool sh_callee_copies (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t      tree, bool);\n+static int sh_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t         tree, bool);\n static int sh_dwarf_calling_convention (tree);\n \n \f\n@@ -444,6 +446,8 @@ static int sh_dwarf_calling_convention (tree);\n #define TARGET_PASS_BY_REFERENCE sh_pass_by_reference\n #undef TARGET_CALLEE_COPIES\n #define TARGET_CALLEE_COPIES sh_callee_copies\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES sh_arg_partial_bytes\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST sh_build_builtin_va_list\n@@ -6668,6 +6672,30 @@ sh_callee_copies (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      % SH_MIN_ALIGN_FOR_CALLEE_COPY == 0));\n }\n \n+static int\n+sh_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t      tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  int words = 0;\n+\n+  if (!TARGET_SH5\n+      && PASS_IN_REG_P (*cum, mode, type)\n+      && !(TARGET_SH4 || TARGET_SH2A_DOUBLE)\n+      && (ROUND_REG (*cum, mode)\n+\t  + (mode != BLKmode\n+\t     ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n+\t     : ROUND_ADVANCE (int_size_in_bytes (type)))\n+\t  > NPARM_REGS (mode)))\n+    words = NPARM_REGS (mode) - ROUND_REG (*cum, mode);\n+\n+  else if (!TARGET_SHCOMPACT\n+\t   && SH5_WOULD_BE_PARTIAL_NREGS (*cum, mode, type, named))\n+    words = NPARM_REGS (SImode) - cum->arg_count[SH_ARG_INT];\n+\n+  return words * UNITS_PER_WORD;\n+}\n+\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument."}, {"sha": "edeb135714b57085f3ab510794cdd3a7e1ba3ee4", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -2204,27 +2204,6 @@ struct sh_args {\n \t\t\t\t\t\t\t  (REG)),\t\\\n \t\t\t\t   const0_rtx))))\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.\n-\n-   We sometimes split args.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  ((! TARGET_SH5 \\\n-    && PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\\\n-    && ! (TARGET_SH4 || TARGET_SH2A_DOUBLE)\t\t\t\t\t\t\\\n-    && (ROUND_REG ((CUM), (MODE))\t\t\t\t\\\n-\t+ ((MODE) != BLKmode\t\t\t\t\t\\\n-\t   ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\t\\\n-\t   : ROUND_ADVANCE (int_size_in_bytes (TYPE)))\t\t\\\n-\t> NPARM_REGS (MODE)))\t\t\t\t\t\\\n-   ? NPARM_REGS (MODE) - ROUND_REG ((CUM), (MODE))\t\t\\\n-   : (SH5_WOULD_BE_PARTIAL_NREGS ((CUM), (MODE), (TYPE), (NAMED)) \\\n-      && ! TARGET_SHCOMPACT)\t\t\t\t\t\\\n-   ? NPARM_REGS (SImode) - (CUM).arg_count[(int) SH_ARG_INT]\t\\\n-   : 0)\n-\n #define SH5_WOULD_BE_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   (TARGET_SH5\t\t\t\t\t\t\t\\\n    && ((MODE) == BLKmode || (MODE) == TImode || (MODE) == CDImode \\"}, {"sha": "74fba0c3408645363f8ec1fcdb301c7bd2059e98", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -30,8 +30,6 @@ extern void function_arg_advance (CUMULATIVE_ARGS *,\n \t\t\t\t  enum machine_mode, tree, int);\n extern struct rtx_def *function_arg (const CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, int, int);\n-extern int function_arg_partial_nregs (const CUMULATIVE_ARGS *,\n-\t\t\t\t       enum machine_mode, tree, int);\n #ifdef RTX_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern void sparc_va_start (tree, rtx);"}, {"sha": "c15a406d1f90263f1915221d04ec0a5cf3af8b55", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -356,6 +356,8 @@ static tree sparc_gimplify_va_arg (tree, tree, tree *, tree *);\n static bool sparc_vector_mode_supported_p (enum machine_mode);\n static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, bool);\n+static int sparc_arg_partial_bytes (CUMULATIVE_ARGS *,\n+\t\t\t\t    enum machine_mode, tree, bool);\n static void sparc_dwarf_handle_frame_unspec (const char *, rtx, int);\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n const struct attribute_spec sparc_attribute_table[];\n@@ -469,6 +471,8 @@ enum processor_type sparc_cpu;\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE sparc_pass_by_reference\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES sparc_arg_partial_bytes\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS sparc_builtin_saveregs\n@@ -5618,7 +5622,7 @@ function_arg_record_value (tree type, enum machine_mode mode,\n   /* If at least one field must be passed on the stack, generate\n      (parallel [(expr_list (nil) ...) ...]) so that all fields will\n      also be passed on the stack.  We can't do much better because the\n-     semantics of FUNCTION_ARG_PARTIAL_NREGS doesn't handle the case\n+     semantics of TARGET_ARG_PARTIAL_BYTES doesn't handle the case\n      of structures for which the fields passed exclusively in registers\n      are not at the beginning of the structure.  */\n   if (parms.stack)\n@@ -5857,9 +5861,8 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n   return reg;\n }\n \n-/* Handle the FUNCTION_ARG_PARTIAL_NREGS macro.\n-   For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of bytes of registers used.\n    For args passed entirely in registers or entirely in memory, zero.\n \n    Any arg that starts in the first 6 regs but won't entirely fit in them\n@@ -5868,9 +5871,9 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n    values that begin in the last fp reg [where \"last fp reg\" varies with the\n    mode] will be split between that reg and memory.  */\n \n-int\n-function_arg_partial_nregs (const struct sparc_args *cum,\n-\t\t\t    enum machine_mode mode, tree type, int named)\n+static int\n+sparc_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t tree type, bool named)\n {\n   int slotno, regno, padding;\n \n@@ -5886,21 +5889,21 @@ function_arg_partial_nregs (const struct sparc_args *cum,\n \t\t     ? ROUND_ADVANCE (int_size_in_bytes (type))\n \t\t     : ROUND_ADVANCE (GET_MODE_SIZE (mode))))\n \t  > SPARC_INT_ARG_MAX)\n-\treturn SPARC_INT_ARG_MAX - slotno;\n+\treturn (SPARC_INT_ARG_MAX - slotno) * UNITS_PER_WORD;\n     }\n   else\n     {\n       /* We are guaranteed by pass_by_reference that the size of the\n-\t argument is not greater than 16 bytes, so we only need to\n-\t return 1 if the argument is partially passed in registers.  */\n+\t argument is not greater than 16 bytes, so we only need to return\n+\t one word if the argument is partially passed in registers.  */\n \n       if (type && AGGREGATE_TYPE_P (type))\n \t{\n \t  int size = int_size_in_bytes (type);\n \n \t  if (size > UNITS_PER_WORD\n \t      && slotno == SPARC_INT_ARG_MAX - 1)\n-\t    return 1;\n+\t    return UNITS_PER_WORD;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n \t       || (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n@@ -5909,13 +5912,13 @@ function_arg_partial_nregs (const struct sparc_args *cum,\n \t  /* The complex types are passed as packed types.  */\n \t  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n \t      && slotno == SPARC_INT_ARG_MAX - 1)\n-\t    return 1;\n+\t    return UNITS_PER_WORD;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n \t{\n \t  if ((slotno + GET_MODE_SIZE (mode) / UNITS_PER_WORD)\n \t      > SPARC_FP_ARG_MAX)\n-\t    return 1;\n+\t    return UNITS_PER_WORD;\n \t}\n     }\n "}, {"sha": "3b6ea6c67ef8747ede3e062e0babe555fd9bb572", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1737,13 +1737,6 @@ function_arg (& (CUM), (MODE), (TYPE), (NAMED), 0)\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n function_arg (& (CUM), (MODE), (TYPE), (NAMED), 1)\n \n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-function_arg_partial_nregs (& (CUM), (MODE), (TYPE), (NAMED))\n-\n /* If defined, a C expression which determines whether, and in which direction,\n    to pad out an argument with extra space.  The value should be of type\n    `enum direction': either `upward' to pad above the argument,"}, {"sha": "a9f97792a778042ba81271760994fa465a1d6ac6", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -417,8 +417,6 @@ enum reg_class\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n \txstormy16_function_arg (CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n /* For this platform, the value of CUMULATIVE_ARGS is the number of words\n    of arguments that have been passed in registers so far.  */\n #define CUMULATIVE_ARGS int"}, {"sha": "cb36601996bda8cf4f14c3864a3715e9af7415d9", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -80,9 +80,6 @@ extern void   v850_output_aligned_bss       (FILE *, tree, const char *, int, in\n extern void   v850_output_common            (FILE *, tree, const char *, int, int);\n extern void   v850_output_local             (FILE *, tree, const char *, int, int);\n extern v850_data_area v850_get_data_area    (tree);\n-#ifdef HAVE_MACHINE_MODES\n-extern int    function_arg_partial_nregs    (CUMULATIVE_ARGS *, Mmode, tree, int);\n-#endif\n #endif\n \n extern void ghs_pragma_section\t\t    (struct cpp_reader *);"}, {"sha": "f3a165d28f484be4681cdac494b18a72af70e354", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -69,6 +69,8 @@ static void v850_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static bool v850_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    tree, bool);\n+static int v850_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t   tree, bool);\n \n /* Information about the various small memory areas.  */\n struct small_memory_info small_memory[ (int)SMALL_MEMORY_max ] =\n@@ -137,6 +139,9 @@ static int v850_interrupt_p = FALSE;\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS v850_setup_incoming_varargs\n \n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES v850_arg_partial_bytes\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -257,14 +262,12 @@ function_arg (CUMULATIVE_ARGS * cum,\n }\n \n \f\n-/* Return the number of words which must be put into registers\n+/* Return the number of bytes which must be put into registers\n    for values which are part in registers and part in memory.  */\n \n-int\n-function_arg_partial_nregs (CUMULATIVE_ARGS * cum,\n-                            enum machine_mode mode,\n-                            tree type,\n-                            int named)\n+static int\n+v850_arg_partial_bytes (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n+                        tree type, bool named)\n {\n   int size, align;\n \n@@ -293,7 +296,7 @@ function_arg_partial_nregs (CUMULATIVE_ARGS * cum,\n       && cum->nbytes + size > 4 * UNITS_PER_WORD)\n     return 0;\n \n-  return (4 * UNITS_PER_WORD - cum->nbytes) / UNITS_PER_WORD;\n+  return 4 * UNITS_PER_WORD - cum->nbytes;\n }\n \n \f"}, {"sha": "3c2ba9322f43dd5944f97e42772215c8293d52dc", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -746,9 +746,6 @@ struct cum_arg { int nbytes; int anonymous_args; };\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */"}, {"sha": "01c0caef91de70a7918d200c59e95cb8e8b5e5d3", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -762,9 +762,6 @@ typedef struct xtensa_args\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, TRUE)\n \n-/* Arguments are never passed partly in memory and partly in registers.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)\n-\n /* Specify function argument alignment.  */\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n   ((TYPE) != 0\t\t\t\t\t\t\t\t\\"}, {"sha": "52cb78b1e897558c6fc90561af01599b426c50f2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -3748,25 +3748,24 @@ If @code{FUNCTION_INCOMING_ARG} is not defined, @code{FUNCTION_ARG}\n serves both purposes.\n @end defmac\n \n-@defmac FUNCTION_ARG_PARTIAL_NREGS (@var{cum}, @var{mode}, @var{type}, @var{named})\n-A C expression for the number of words, at the beginning of an\n-argument, that must be put in registers.  The value must be zero for\n+@deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n+This target hook returns the number of bytes at the beginning of an\n+argument that must be put in registers.  The value must be zero for\n arguments that are passed entirely in registers or that are entirely\n pushed on the stack.\n \n On some machines, certain arguments must be passed partially in\n registers and partially in memory.  On these machines, typically the\n-first @var{n} words of arguments are passed in registers, and the rest\n+first few words of arguments are passed in registers, and the rest\n on the stack.  If a multi-word argument (a @code{double} or a\n structure) crosses that boundary, its first few words must be passed\n in registers and the rest must be pushed.  This macro tells the\n-compiler when this occurs, and how many of the words should go in\n-registers.\n+compiler when this occurs, and how many bytes should go in registers.\n \n @code{FUNCTION_ARG} for these arguments should return the first\n register to be used by the caller for this argument; likewise\n @code{FUNCTION_INCOMING_ARG}, for the called function.\n-@end defmac\n+@end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n This target hook should return @code{true} if an argument at the"}, {"sha": "de34675ded923e646130a1dfcccaaba282660730", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -1220,8 +1220,7 @@ block_move_libcall_safe_for_call_parm (void)\n \trtx tmp = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n \tif (!tmp || !REG_P (tmp))\n \t  return false;\n-\tif (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode,\n-\t\t\t\t\tNULL_TREE, 1))\n+\tif (targetm.calls.arg_partial_bytes (&args_so_far, mode, NULL, 1))\n \t  return false;\n \tFUNCTION_ARG_ADVANCE (args_so_far, mode, NULL_TREE, 1);\n       }\n@@ -3343,9 +3342,8 @@ emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n    ALIGN (in bits) is maximum alignment we can assume.\n \n    If PARTIAL and REG are both nonzero, then copy that many of the first\n-   words of X into registers starting with REG, and push the rest of X.\n-   The amount of space pushed is decreased by PARTIAL words,\n-   rounded *down* to a multiple of PARM_BOUNDARY.\n+   bytes of X into registers starting with REG, and push the rest of X.\n+   The amount of space pushed is decreased by PARTIAL bytes.\n    REG must be a hard register in this case.\n    If REG is zero but PARTIAL is not, take any all others actions for an\n    argument partially in registers, but do not actually load any\n@@ -3397,24 +3395,15 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n       /* Copy a block into the stack, entirely or partially.  */\n \n       rtx temp;\n-      int used = partial * UNITS_PER_WORD;\n+      int used;\n       int offset;\n       int skip;\n \n-      if (reg && GET_CODE (reg) == PARALLEL)\n-\t{\n-\t  /* Use the size of the elt to compute offset.  */\n-\t  rtx elt = XEXP (XVECEXP (reg, 0, 0), 0);\n-\t  used = partial * GET_MODE_SIZE (GET_MODE (elt));\n-\t  offset = used % (PARM_BOUNDARY / BITS_PER_UNIT);\n-\t}\n-      else\n-\toffset = used % (PARM_BOUNDARY / BITS_PER_UNIT);\n+      offset = partial % (PARM_BOUNDARY / BITS_PER_UNIT);\n+      used = partial - offset;\n \n       gcc_assert (size);\n \n-      used -= offset;\n-\n       /* USED is now the # of bytes we need not copy to the stack\n \t because registers will take care of them.  */\n \n@@ -3525,7 +3514,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n       int size = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n       int i;\n       int not_stack;\n-      /* # words of start of argument\n+      /* # bytes of start of argument\n \t that we must make space for but need not store.  */\n       int offset = partial % (PARM_BOUNDARY / BITS_PER_WORD);\n       int args_offset = INTVAL (args_so_far);\n@@ -3546,7 +3535,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \n       /* Now NOT_STACK gets the number of words that we don't need to\n \t allocate on the stack.  */\n-      not_stack = partial - offset;\n+      not_stack = (partial - offset) / UNITS_PER_WORD;\n \n       /* If the partial register-part of the arg counts in its stack size,\n \t skip the part of stack space corresponding to the registers.\n@@ -3630,7 +3619,10 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n       if (GET_CODE (reg) == PARALLEL)\n \temit_group_load (reg, x, type, -1);\n       else\n-\tmove_block_to_reg (REGNO (reg), x, partial, mode);\n+\t{\n+\t  gcc_assert (partial % UNITS_PER_WORD == 0);\n+\t  move_block_to_reg (REGNO (reg), x, partial / UNITS_PER_WORD, mode);\n+\t}\n     }\n \n   if (extra && args_addr == 0 && where_pad == stack_direction)"}, {"sha": "3e6571c0333f029f4d8b1c3c419db1244c5e9b41", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -183,10 +183,6 @@ do {\t\t\t\t\t\t\t\\\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n #endif\n \n-#ifndef FUNCTION_ARG_PARTIAL_NREGS\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-#endif\n-\n /* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n    Normally move_insn, so Pmode stack pointer.  */\n "}, {"sha": "eb1e14e5d7e589317c8340440d930a3a5f9d3c35", "filename": "gcc/function.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -2296,10 +2296,10 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n     {\n       int partial;\n \n-      partial = FUNCTION_ARG_PARTIAL_NREGS (all->args_so_far,\n-\t\t\t\t\t    data->promoted_mode,\n-\t\t\t\t\t    data->passed_type,\n-\t\t\t\t\t    data->named_arg);\n+      partial = targetm.calls.arg_partial_bytes (&all->args_so_far,\n+\t\t\t\t\t\t data->promoted_mode,\n+\t\t\t\t\t\t data->passed_type,\n+\t\t\t\t\t\t data->named_arg);\n       data->partial = partial;\n \n       /* The caller might already have allocated stack space for the\n@@ -2325,7 +2325,7 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n \t     argument on the stack.  */\n \t  gcc_assert (!all->extra_pretend_bytes && !all->pretend_args_size);\n \n-\t  pretend_bytes = partial * UNITS_PER_WORD;\n+\t  pretend_bytes = partial;\n \t  all->pretend_args_size = CEIL_ROUND (pretend_bytes, STACK_BYTES);\n \n \t  /* We want to align relative to the actual stack pointer, so\n@@ -2449,8 +2449,11 @@ assign_parm_adjust_entry_rtl (struct assign_parm_data_one *data)\n \t\t\t  data->passed_type, \n \t\t\t  int_size_in_bytes (data->passed_type));\n       else\n-\tmove_block_from_reg (REGNO (entry_parm), validize_mem (stack_parm),\n-\t\t\t     data->partial);\n+\t{\n+\t  gcc_assert (data->partial % UNITS_PER_WORD == 0);\n+\t  move_block_from_reg (REGNO (entry_parm), validize_mem (stack_parm),\n+\t\t\t       data->partial / UNITS_PER_WORD);\n+\t}\n \n       entry_parm = stack_parm;\n     }\n@@ -3399,11 +3402,7 @@ locate_and_pad_parm (enum machine_mode passed_mode, tree type, int in_regs,\n     }\n #endif /* REG_PARM_STACK_SPACE */\n \n-  part_size_in_regs = 0;\n-  if (reg_parm_stack_space == 0)\n-    part_size_in_regs = ((partial * UNITS_PER_WORD)\n-\t\t\t / (PARM_BOUNDARY / BITS_PER_UNIT)\n-\t\t\t * (PARM_BOUNDARY / BITS_PER_UNIT));\n+  part_size_in_regs = (reg_parm_stack_space == 0 ? partial : 0);\n \n   sizetree\n     = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));"}, {"sha": "752c2542b2661e4d07e9a31a175150dca182e66c", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -614,7 +614,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tDEFAULT_SHORT_ENUMS SPLIT_COMPLEX_ARGS MD_ASM_CLOBBERS\t\t\\\n \tHANDLE_PRAGMA_REDEFINE_EXTNAME HANDLE_PRAGMA_EXTERN_PREFIX\t\\\n \tMUST_PASS_IN_STACK FUNCTION_ARG_PASS_BY_REFERENCE               \\\n-        VECTOR_MODE_SUPPORTED_P TARGET_SUPPORTS_HIDDEN\n+        VECTOR_MODE_SUPPORTED_P TARGET_SUPPORTS_HIDDEN \t\t\t\\\n+\tFUNCTION_ARG_PARTIAL_NREGS\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "499d37fb9f2c8530c2f9861310d162f65115b8c0", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -399,6 +399,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size_or_pad\n #define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n+#define TARGET_ARG_PARTIAL_BYTES hook_int_CUMULATIVE_ARGS_mode_tree_bool_0\n \n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n@@ -414,7 +415,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n    TARGET_SPLIT_COMPLEX_ARG,\t\t\t\t\t\\\n    TARGET_MUST_PASS_IN_STACK,\t\t\t\t\t\\\n-   TARGET_CALLEE_COPIES\t\t\t\t\t\t\\\n+   TARGET_CALLEE_COPIES,\t\t\t\t\t\\\n+   TARGET_ARG_PARTIAL_BYTES\t\t\t\t\t\\\n    }\n \n "}, {"sha": "0a54c6f7bb4ab49b9779d168075044f494cf7137", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -537,6 +537,12 @@ struct gcc_target\n        the caller.  It is never called for TYPE requiring constructors.  */\n     bool (* callee_copies) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n \t\t\t    tree type, bool named);\n+\n+    /* Return zero for arguments passed entirely on the stack or entirely\n+       in registers.  If passed in both, return the number of bytes passed\n+       in registers; the balance is therefore passed on the stack.  */\n+    int (* arg_partial_bytes) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\t       tree type, bool named);\n   } calls;\n \n   /* Functions specific to the C++ frontend.  */"}, {"sha": "56070931e017b1fd434dea5b7d72e366576d1ad1", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -279,3 +279,12 @@ hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true (\n {\n   return true;\n }\n+\n+int\n+hook_int_CUMULATIVE_ARGS_mode_tree_bool_0 (\n+\tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\ttree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}"}, {"sha": "9c0b173c05c3e2520897d6f0562634daf3bb0c72", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=78a52f1158e146c6a1e09a6a58a18aedc9ea0fcd", "patch": "@@ -58,3 +58,5 @@ extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n   (CUMULATIVE_ARGS *, enum machine_mode, tree, bool);\n extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n   (CUMULATIVE_ARGS *, enum machine_mode, tree, bool);\n+extern int hook_int_CUMULATIVE_ARGS_mode_tree_bool_0\n+  (CUMULATIVE_ARGS *, enum machine_mode, tree, bool);"}]}