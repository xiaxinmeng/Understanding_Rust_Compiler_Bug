{"sha": "8a9271e1921d0eac46bda889da6508cf94d32682", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE5MjcxZTE5MjFkMGVhYzQ2YmRhODg5ZGE2NTA4Y2Y5NGQzMjY4Mg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-06T16:52:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-06T16:52:46Z"}, "message": "Merge #657\n\n657: Add building blocks for enum support r=philberty a=philberty\n\nsee https://gcc.gnu.org/pipermail/gcc-rust/2021-September/000174.html\r\n\r\nThis set of patches adds support for parsing, name resolution and HIR lowering for enums.\r\nTypechecking and code-generation are still in progress but these patches are ready to merge now.\n\nCo-authored-by: Mark Wielaard <mark@klomp.org>", "tree": {"sha": "e31ad30bd83f58c5944d9b66b7666190f0b338f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e31ad30bd83f58c5944d9b66b7666190f0b338f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a9271e1921d0eac46bda889da6508cf94d32682", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhNkdeCRBK7hj4Ov3rIwAAfhYIADzwxdun/SBhZIGh2ELmL1eA\nN6yMP+IECvWLDB/jfxO2dVBC3yDd0hjX0mLcKz3NJgAx4ey66HF5T0ulULHKSfwu\nAS6Q9qTT3xyP9eMinpZYmgGbtFfsNNXNAIxO0u6ec+ElUPiX6ZeaQAfhiTJO4X5A\nY94VVHkjmWkLyfB2WOqJLlSoaKtLW4rc+PVvxP3y/vFUgkjf3I5ULW2Q8jI6AwzD\nq/GJ6BudmIrVcYGXsa6EjD3ZFRTINuiOHhyaw55tmnVA4nss+4x7zdhmNOkmYo/j\nj4Z5kOulQ6CXt1MYoXTvjfDaXMf4IxOgywUOCE01+x2GMJ8fmDDtvBeB6ID7I4k=\n=C1qt\n-----END PGP SIGNATURE-----\n", "payload": "tree e31ad30bd83f58c5944d9b66b7666190f0b338f1\nparent 50623899998de5a8ffe47227a351c2b3dd29aa0a\nparent eaf5bc5c38412514a5abb028fca343c838ac51ca\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630947166 +0000\ncommitter GitHub <noreply@github.com> 1630947166 +0000\n\nMerge #657\n\n657: Add building blocks for enum support r=philberty a=philberty\n\nsee https://gcc.gnu.org/pipermail/gcc-rust/2021-September/000174.html\r\n\r\nThis set of patches adds support for parsing, name resolution and HIR lowering for enums.\r\nTypechecking and code-generation are still in progress but these patches are ready to merge now.\n\nCo-authored-by: Mark Wielaard <mark@klomp.org>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9271e1921d0eac46bda889da6508cf94d32682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9271e1921d0eac46bda889da6508cf94d32682", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9271e1921d0eac46bda889da6508cf94d32682/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50623899998de5a8ffe47227a351c2b3dd29aa0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50623899998de5a8ffe47227a351c2b3dd29aa0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50623899998de5a8ffe47227a351c2b3dd29aa0a"}, {"sha": "eaf5bc5c38412514a5abb028fca343c838ac51ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf5bc5c38412514a5abb028fca343c838ac51ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf5bc5c38412514a5abb028fca343c838ac51ca"}], "stats": {"total": 852, "additions": 698, "deletions": 154}, "files": [{"sha": "2477d7400a7f11752aba1d5455fa050f04d6413e", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -3311,10 +3311,8 @@ StructExprStructFields::as_string () const\n std::string\n EnumItem::as_string () const\n {\n-  // outer attributes\n-  std::string str = append_attributes (outer_attrs, OUTER);\n-\n-  str += \"\\n\" + variant_name;\n+  std::string str = VisItem::as_string ();\n+  str += variant_name;\n \n   return str;\n }"}, {"sha": "881a888f0927a35771317e51ce34163d92d98937", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -2119,53 +2119,44 @@ class TupleStruct : public Struct\n };\n \n /* An item used in an \"enum\" tagged union - not abstract: base represents a\n- * name-only enum */\n-class EnumItem\n+ * name-only enum. EnumItems (variants) syntactically allow a Visibility\n+ * annotation. */\n+class EnumItem : public VisItem\n {\n-  // bool has_attrs;\n-  std::vector<Attribute> outer_attrs;\n-\n   Identifier variant_name;\n \n   Location locus;\n \n public:\n   virtual ~EnumItem () {}\n \n-  // Returns whether enum item has outer attributes.\n-  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n-\n-  EnumItem (Identifier variant_name, std::vector<Attribute> outer_attrs,\n-\t    Location locus)\n-    : outer_attrs (std::move (outer_attrs)),\n+  EnumItem (Identifier variant_name, Visibility vis,\n+\t    std::vector<Attribute> outer_attrs, Location locus)\n+    : VisItem (std::move (vis), std::move (outer_attrs)),\n       variant_name (std::move (variant_name)), locus (locus)\n   {}\n \n   // Unique pointer custom clone function\n   std::unique_ptr<EnumItem> clone_enum_item () const\n   {\n-    return std::unique_ptr<EnumItem> (clone_enum_item_impl ());\n+    return std::unique_ptr<EnumItem> (clone_item_impl ());\n   }\n \n   virtual std::string as_string () const;\n \n   // not pure virtual as not abstract\n   virtual void accept_vis (ASTVisitor &vis);\n \n+  Location get_locus () const { return locus; }\n+\n+  Identifier get_identifier () const { return variant_name; }\n+\n   // Based on idea that name is never empty.\n   void mark_for_strip () { variant_name = \"\"; }\n   bool is_marked_for_strip () const { return variant_name.empty (); }\n \n-  // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n-  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n-\n protected:\n-  // Clone function implementation as (not pure) virtual method\n-  virtual EnumItem *clone_enum_item_impl () const\n-  {\n-    return new EnumItem (*this);\n-  }\n+  EnumItem *clone_item_impl () const override { return new EnumItem (*this); }\n };\n \n // A tuple item used in an \"enum\" tagged union\n@@ -2178,9 +2169,11 @@ class EnumItemTuple : public EnumItem\n   // Returns whether tuple enum item has tuple fields.\n   bool has_tuple_fields () const { return !tuple_fields.empty (); }\n \n-  EnumItemTuple (Identifier variant_name, std::vector<TupleField> tuple_fields,\n+  EnumItemTuple (Identifier variant_name, Visibility vis,\n+\t\t std::vector<TupleField> tuple_fields,\n \t\t std::vector<Attribute> outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+    : EnumItem (std::move (variant_name), std::move (vis),\n+\t\tstd::move (outer_attrs), locus),\n       tuple_fields (std::move (tuple_fields))\n   {}\n \n@@ -2197,7 +2190,7 @@ class EnumItemTuple : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemTuple *clone_enum_item_impl () const override\n+  EnumItemTuple *clone_item_impl () const override\n   {\n     return new EnumItemTuple (*this);\n   }\n@@ -2213,10 +2206,11 @@ class EnumItemStruct : public EnumItem\n   // Returns whether struct enum item has struct fields.\n   bool has_struct_fields () const { return !struct_fields.empty (); }\n \n-  EnumItemStruct (Identifier variant_name,\n+  EnumItemStruct (Identifier variant_name, Visibility vis,\n \t\t  std::vector<StructField> struct_fields,\n \t\t  std::vector<Attribute> outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+    : EnumItem (std::move (variant_name), std::move (vis),\n+\t\tstd::move (outer_attrs), locus),\n       struct_fields (std::move (struct_fields))\n   {}\n \n@@ -2233,7 +2227,7 @@ class EnumItemStruct : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemStruct *clone_enum_item_impl () const override\n+  EnumItemStruct *clone_item_impl () const override\n   {\n     return new EnumItemStruct (*this);\n   }\n@@ -2245,9 +2239,11 @@ class EnumItemDiscriminant : public EnumItem\n   std::unique_ptr<Expr> expression;\n \n public:\n-  EnumItemDiscriminant (Identifier variant_name, std::unique_ptr<Expr> expr,\n+  EnumItemDiscriminant (Identifier variant_name, Visibility vis,\n+\t\t\tstd::unique_ptr<Expr> expr,\n \t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+    : EnumItem (std::move (variant_name), std::move (vis),\n+\t\tstd::move (outer_attrs), locus),\n       expression (std::move (expr))\n   {}\n \n@@ -2284,7 +2280,7 @@ class EnumItemDiscriminant : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemDiscriminant *clone_enum_item_impl () const override\n+  EnumItemDiscriminant *clone_item_impl () const override\n   {\n     return new EnumItemDiscriminant (*this);\n   }\n@@ -2374,6 +2370,8 @@ class Enum : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Identifier get_identifier () const { return enum_name; }\n+\n   // Invalid if name is empty, so base stripping on that.\n   void mark_for_strip () override { enum_name = \"\"; }\n   bool is_marked_for_strip () const override { return enum_name.empty (); }"}, {"sha": "333cb7ba3fbf6066cab4ecd067d4ec40585ebaaa", "filename": "gcc/rust/hir/rust-ast-lower-enumitem.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -0,0 +1,192 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_ENUMITEM\n+#define RUST_AST_LOWER_ENUMITEM\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringEnumItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::EnumItem *translate (AST::EnumItem *item)\n+  {\n+    ASTLoweringEnumItem resolver;\n+    item->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::EnumItem &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    translated = new HIR::EnumItem (mapping, item.get_identifier (),\n+\t\t\t\t    item.get_outer_attrs (), item.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    std::vector<HIR::TupleField> fields;\n+    for (auto &field : item.get_tuple_fields ())\n+      {\n+\tHIR::Visibility vis = HIR::Visibility::create_public ();\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping field_mapping (\n+\t  crate_num, field.get_node_id (),\n+\t  mappings->get_next_hir_id (crate_num),\n+\t  mappings->get_next_localdef_id (crate_num));\n+\n+\tHIR::TupleField translated_field (field_mapping,\n+\t\t\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t  vis, field.get_locus (),\n+\t\t\t\t\t  field.get_outer_attrs ());\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    translated\n+      = new HIR::EnumItemTuple (mapping, item.get_identifier (),\n+\t\t\t\tstd::move (fields), item.get_outer_attrs (),\n+\t\t\t\titem.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    std::vector<HIR::StructField> fields;\n+    for (auto &field : item.get_struct_fields ())\n+      {\n+\tHIR::Visibility vis = HIR::Visibility::create_public ();\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping field_mapping (\n+\t  crate_num, field.get_node_id (),\n+\t  mappings->get_next_hir_id (crate_num),\n+\t  mappings->get_next_localdef_id (crate_num));\n+\n+\tHIR::StructField translated_field (field_mapping,\n+\t\t\t\t\t   field.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, field.get_locus (),\n+\t\t\t\t\t   field.get_outer_attrs ());\n+\n+\tif (struct_field_name_exists (fields, translated_field))\n+\t  break;\n+\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    translated\n+      = new HIR::EnumItemStruct (mapping, item.get_identifier (),\n+\t\t\t\t std::move (fields), item.get_outer_attrs (),\n+\t\t\t\t item.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_vis ().as_string ().c_str ());\n+\n+    HIR::Expr *expr = ASTLoweringExpr::translate (item.get_expr ().get ());\n+    translated\n+      = new HIR::EnumItemDiscriminant (mapping, item.get_identifier (),\n+\t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t       item.get_outer_attrs (),\n+\t\t\t\t       item.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       item.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringEnumItem () : translated (nullptr) {}\n+  HIR::EnumItem *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_ENUMITEM"}, {"sha": "dfc2612608becd1bece922f5cbc6244fc3e6655f", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-diagnostics.h\"\n \n #include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-enumitem.h\"\n #include \"rust-ast-lower-type.h\"\n #include \"rust-ast-lower-implitem.h\"\n #include \"rust-ast-lower-stmt.h\"\n@@ -65,7 +66,7 @@ class ASTLoweringItem : public ASTLoweringBase\n     // should be lowered from module.get_vis()\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    auto items = std::vector<std::unique_ptr<Item> > ();\n+    auto items = std::vector<std::unique_ptr<Item>> ();\n \n     for (auto &item : module.get_items ())\n       {\n@@ -93,11 +94,11 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::TypeAlias &alias) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (alias.has_generics ())\n       generic_params = lower_generic_params (alias.get_generic_params ());\n \n@@ -125,14 +126,14 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -175,35 +176,16 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n-  /* Checks whether the name of a field already exists.  Returns true\n-     and produces an error if so.  */\n-  static bool struct_field_name_exists (std::vector<HIR::StructField> &fields,\n-\t\t\t\t\tHIR::StructField &new_field)\n-  {\n-    for (auto &field : fields)\n-      {\n-\tif (field.get_field_name ().compare (new_field.get_field_name ()) == 0)\n-\t  {\n-\t    RichLocation r (new_field.get_locus ());\n-\t    r.add_range (field.get_locus ());\n-\t    rust_error_at (r, \"duplicate field name %qs\",\n-\t\t\t   field.get_field_name ().c_str ());\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -251,16 +233,55 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (enum_decl.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (enum_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // bool is_unit = enum_decl.is_zero_variant ();\n+    std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tHIR::EnumItem *hir_item\n+\t  = ASTLoweringEnumItem::translate (variant.get ());\n+\titems.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t\tstd::move (generic_params),\n+\t\t\t\tstd::move (where_clause), /* is_unit, */\n+\t\t\t\tstd::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t\tenum_decl.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       enum_decl.get_locus ());\n+  }\n+\n   void visit (AST::Union &union_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (union_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (union_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -359,14 +380,14 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::Function &function) override\n   {\n     // ignore for now and leave empty\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers (\n       HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     // need\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (function.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (function.get_generic_params ());\n@@ -443,12 +464,12 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (impl_block.has_generics ())\n       {\n \tgeneric_params\n@@ -486,7 +507,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    std::vector<std::unique_ptr<HIR::ImplItem> > impl_items;\n+    std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n     std::vector<HirId> impl_item_ids;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n@@ -523,12 +544,12 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::Trait &trait) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (trait.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (trait.get_generic_params ());\n@@ -557,9 +578,9 @@ class ASTLoweringItem : public ASTLoweringBase\n \t  }\n       }\n \n-    std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+    std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n \n-    std::vector<std::unique_ptr<HIR::TraitItem> > trait_items;\n+    std::vector<std::unique_ptr<HIR::TraitItem>> trait_items;\n     std::vector<HirId> trait_item_ids;\n     for (auto &item : trait.get_trait_items ())\n       {\n@@ -595,12 +616,12 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::TraitImpl &impl_block) override\n   {\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (impl_block.has_generics ())\n       {\n \tgeneric_params\n@@ -640,7 +661,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    std::vector<std::unique_ptr<HIR::ImplItem> > impl_items;\n+    std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n     std::vector<HirId> impl_item_ids;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n@@ -680,7 +701,7 @@ class ASTLoweringItem : public ASTLoweringBase\n   {\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n-    std::vector<std::unique_ptr<HIR::ExternalItem> > extern_items;\n+    std::vector<std::unique_ptr<HIR::ExternalItem>> extern_items;\n     for (auto &item : extern_block.get_extern_items ())\n       {\n \tHIR::ExternalItem *lowered"}, {"sha": "ee9b675b76b58b288f8df80d7e6a533f9cef68f5", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-diagnostics.h\"\n \n #include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-enumitem.h\"\n #include \"rust-ast-lower-type.h\"\n #include \"rust-ast-lower-block.h\"\n #include \"rust-ast-lower-expr.h\"\n@@ -110,14 +111,14 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -159,35 +160,16 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n-  /* Checks whether the name of a field already exists.  Returns true\n-     and produces an error if so.  */\n-  static bool struct_field_name_exists (std::vector<HIR::StructField> &fields,\n-\t\t\t\t\tHIR::StructField &new_field)\n-  {\n-    for (auto &field : fields)\n-      {\n-\tif (field.get_field_name ().compare (new_field.get_field_name ()) == 0)\n-\t  {\n-\t    RichLocation r (new_field.get_locus ());\n-\t    r.add_range (field.get_locus ());\n-\t    rust_error_at (r, \"duplicate field name %qs\",\n-\t\t\t   field.get_field_name ().c_str ());\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (struct_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (struct_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -236,14 +218,14 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   void visit (AST::Union &union_decl) override\n   {\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (union_decl.has_generics ())\n       {\n \tgeneric_params\n \t  = lower_generic_params (union_decl.get_generic_params ());\n       }\n \n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -288,6 +270,44 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t       union_decl.get_locus ());\n   }\n \n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (enum_decl.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (enum_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // bool is_unit = enum_decl.is_zero_variant ();\n+    std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tHIR::EnumItem *hir_item\n+\t  = ASTLoweringEnumItem::translate (variant.get ());\n+\titems.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t\tstd::move (generic_params),\n+\t\t\t\tstd::move (where_clause), /* is_unit, */\n+\t\t\t\tstd::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t\tenum_decl.get_locus ());\n+\n+    mappings->insert_hir_stmt (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       enum_decl.get_locus ());\n+  }\n+\n   void visit (AST::EmptyStmt &empty) override\n   {\n     auto crate_num = mappings->get_current_crate ();\n@@ -306,14 +326,14 @@ class ASTLoweringStmt : public ASTLoweringBase\n   void visit (AST::Function &function) override\n   {\n     // ignore for now and leave empty\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers (\n       HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     // need\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n     if (function.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (function.get_generic_params ());"}, {"sha": "b64e1a05438c91dfefd2e364ca01a78d45ad281a", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -520,5 +520,25 @@ ASTLoweringBase::lower_bound (AST::TypeParamBound *bound)\n   return ASTLoweringTypeBounds::translate (bound);\n }\n \n+/* Checks whether the name of a field already exists.  Returns true\n+   and produces an error if so.  */\n+bool\n+struct_field_name_exists (std::vector<HIR::StructField> &fields,\n+\t\t\t  HIR::StructField &new_field)\n+{\n+  for (auto &field : fields)\n+    {\n+      if (field.get_field_name ().compare (new_field.get_field_name ()) == 0)\n+\t{\n+\t  RichLocation r (new_field.get_locus ());\n+\t  r.add_range (field.get_locus ());\n+\t  rust_error_at (r, \"duplicate field name %qs\",\n+\t\t\t field.get_field_name ().c_str ());\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "254f68649dbd3d45c3199c035eab3fd398f12764", "filename": "gcc/rust/hir/rust-ast-lower.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -27,6 +27,11 @@\n namespace Rust {\n namespace HIR {\n \n+/* Checks whether the name of a field already exists.  Returns true\n+   and produces an error if so.  */\n+bool\n+struct_field_name_exists (std::vector<HIR::StructField> &fields,\n+\t\t\t  HIR::StructField &new_field);\n class ASTLowering\n {\n public:"}, {"sha": "b0e418c166b0819127cd070b36519a261a876e9f", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -3086,23 +3086,8 @@ StructExprStructFields::as_string () const\n std::string\n EnumItem::as_string () const\n {\n-  // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n\" + variant_name;\n+  std::string str = Item::as_string ();\n+  str += variant_name;\n \n   return str;\n }"}, {"sha": "35b1c64e6d2aea3e6cf7e9102c5303bdde38af9a", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -1636,44 +1636,41 @@ class TupleStruct : public Struct\n };\n \n /* An item used in an \"enum\" tagged union - not abstract: base represents a\n- * name-only enum */\n-class EnumItem\n+   name-only enum. Syntactically EnumItem's can have a Visibility. But not\n+   Semantically. So check there is no Visibility when lowering and make this\n+   an Item, not an VisItem.  */\n+class EnumItem : public Item\n {\n-  // bool has_attrs;\n-  AST::AttrVec outer_attrs;\n-\n   Identifier variant_name;\n \n   Location locus;\n \n public:\n   virtual ~EnumItem () {}\n \n-  // Returns whether enum item has outer attributes.\n-  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n-\n-  EnumItem (Identifier variant_name, AST::AttrVec outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)),\n+  EnumItem (Analysis::NodeMapping mappings, Identifier variant_name,\n+\t    AST::AttrVec outer_attrs, Location locus)\n+    : Item (std::move (mappings), std::move (outer_attrs)),\n       variant_name (std::move (variant_name)), locus (locus)\n   {}\n \n   // Unique pointer custom clone function\n   std::unique_ptr<EnumItem> clone_enum_item () const\n   {\n-    return std::unique_ptr<EnumItem> (clone_enum_item_impl ());\n+    return std::unique_ptr<EnumItem> (clone_item_impl ());\n   }\n \n   virtual std::string as_string () const;\n \n   // not pure virtual as not abstract\n   virtual void accept_vis (HIRVisitor &vis);\n \n+  Location get_locus () const { return locus; }\n+\n+  Identifier get_identifier () const { return variant_name; }\n+\n protected:\n-  // Clone function implementation as (not pure) virtual method\n-  virtual EnumItem *clone_enum_item_impl () const\n-  {\n-    return new EnumItem (*this);\n-  }\n+  EnumItem *clone_item_impl () const override { return new EnumItem (*this); }\n };\n \n // A tuple item used in an \"enum\" tagged union\n@@ -1686,9 +1683,11 @@ class EnumItemTuple : public EnumItem\n   // Returns whether tuple enum item has tuple fields.\n   bool has_tuple_fields () const { return !tuple_fields.empty (); }\n \n-  EnumItemTuple (Identifier variant_name, std::vector<TupleField> tuple_fields,\n-\t\t AST::AttrVec outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+  EnumItemTuple (Analysis::NodeMapping mappings, Identifier variant_name,\n+\t\t std::vector<TupleField> tuple_fields, AST::AttrVec outer_attrs,\n+\t\t Location locus)\n+    : EnumItem (std::move (mappings), std::move (variant_name),\n+\t\tstd::move (outer_attrs), locus),\n       tuple_fields (std::move (tuple_fields))\n   {}\n \n@@ -1698,7 +1697,7 @@ class EnumItemTuple : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemTuple *clone_enum_item_impl () const override\n+  EnumItemTuple *clone_item_impl () const override\n   {\n     return new EnumItemTuple (*this);\n   }\n@@ -1714,10 +1713,11 @@ class EnumItemStruct : public EnumItem\n   // Returns whether struct enum item has struct fields.\n   bool has_struct_fields () const { return !struct_fields.empty (); }\n \n-  EnumItemStruct (Identifier variant_name,\n+  EnumItemStruct (Analysis::NodeMapping mappings, Identifier variant_name,\n \t\t  std::vector<StructField> struct_fields,\n \t\t  AST::AttrVec outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+    : EnumItem (std::move (mappings), std::move (variant_name),\n+\t\tstd::move (outer_attrs), locus),\n       struct_fields (std::move (struct_fields))\n   {}\n \n@@ -1727,7 +1727,7 @@ class EnumItemStruct : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemStruct *clone_enum_item_impl () const override\n+  EnumItemStruct *clone_item_impl () const override\n   {\n     return new EnumItemStruct (*this);\n   }\n@@ -1739,9 +1739,11 @@ class EnumItemDiscriminant : public EnumItem\n   std::unique_ptr<Expr> expression;\n \n public:\n-  EnumItemDiscriminant (Identifier variant_name, std::unique_ptr<Expr> expr,\n-\t\t\tAST::AttrVec outer_attrs, Location locus)\n-    : EnumItem (std::move (variant_name), std::move (outer_attrs), locus),\n+  EnumItemDiscriminant (Analysis::NodeMapping mappings, Identifier variant_name,\n+\t\t\tstd::unique_ptr<Expr> expr, AST::AttrVec outer_attrs,\n+\t\t\tLocation locus)\n+    : EnumItem (std::move (mappings), std::move (variant_name),\n+\t\tstd::move (outer_attrs), locus),\n       expression (std::move (expr))\n   {}\n \n@@ -1771,7 +1773,7 @@ class EnumItemDiscriminant : public EnumItem\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n-  EnumItemDiscriminant *clone_enum_item_impl () const override\n+  EnumItemDiscriminant *clone_item_impl () const override\n   {\n     return new EnumItemDiscriminant (*this);\n   }\n@@ -1861,6 +1863,8 @@ class Enum : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_identifier () const { return enum_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "8cce9332350847dc044c07e9efb023dddfd16840", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -4431,6 +4431,9 @@ Parser<ManagedTokenSource>::parse_enum_item ()\n   // parse outer attributes if they exist\n   AST::AttrVec outer_attrs = parse_outer_attributes ();\n \n+  // parse visibility, which may or may not exist\n+  AST::Visibility vis = parse_visibility ();\n+\n   // parse name for enum item, which is required\n   const_TokenPtr item_name_tok = lexer.peek_token ();\n   if (item_name_tok->get_id () != IDENTIFIER)\n@@ -4463,7 +4466,7 @@ Parser<ManagedTokenSource>::parse_enum_item ()\n \t  }\n \n \treturn std::unique_ptr<AST::EnumItemTuple> (new AST::EnumItemTuple (\n-\t  std::move (item_name), std::move (tuple_fields),\n+\t  std::move (item_name), std::move (vis), std::move (tuple_fields),\n \t  std::move (outer_attrs), item_name_tok->get_locus ()));\n       }\n       case LEFT_CURLY: {\n@@ -4480,7 +4483,7 @@ Parser<ManagedTokenSource>::parse_enum_item ()\n \t  }\n \n \treturn std::unique_ptr<AST::EnumItemStruct> (new AST::EnumItemStruct (\n-\t  std::move (item_name), std::move (struct_fields),\n+\t  std::move (item_name), std::move (vis), std::move (struct_fields),\n \t  std::move (outer_attrs), item_name_tok->get_locus ()));\n       }\n       case EQUAL: {\n@@ -4490,15 +4493,16 @@ Parser<ManagedTokenSource>::parse_enum_item ()\n \tstd::unique_ptr<AST::Expr> discriminant_expr = parse_expr ();\n \n \treturn std::unique_ptr<AST::EnumItemDiscriminant> (\n-\t  new AST::EnumItemDiscriminant (std::move (item_name),\n+\t  new AST::EnumItemDiscriminant (std::move (item_name), std::move (vis),\n \t\t\t\t\t std::move (discriminant_expr),\n \t\t\t\t\t std::move (outer_attrs),\n \t\t\t\t\t item_name_tok->get_locus ()));\n       }\n     default:\n       // regular enum with just an identifier\n       return std::unique_ptr<AST::EnumItem> (\n-\tnew AST::EnumItem (std::move (item_name), std::move (outer_attrs),\n+\tnew AST::EnumItem (std::move (item_name), std::move (vis),\n+\t\t\t   std::move (outer_attrs),\n \t\t\t   item_name_tok->get_locus ()));\n     }\n }"}, {"sha": "2a2f956a3854f2491cb54797c7b3fc0304541bc0", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -260,6 +260,42 @@ class ResolveItem : public ResolverBase\n     resolver->get_type_scope ().pop ();\n   }\n \n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    NodeId scope_node_id = enum_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (enum_decl.has_generics ())\n+      {\n+\tfor (auto &generic : enum_decl.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n+\t  }\n+      }\n+\n+    /* The actual fields are inside the variants.  */\n+    for (auto &variant : enum_decl.get_variants ())\n+      ResolveItem::go (variant.get ());\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  /* EnumItem doesn't need to be handled, no fields.  */\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    for (auto &field : item.get_tuple_fields ())\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    for (auto &field : item.get_struct_fields ())\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+  }\n+\n+  /* EnumItemDiscriminant doesn't need to be handled, no fields.  */\n+\n   void visit (AST::StructStruct &struct_decl) override\n   {\n     NodeId scope_node_id = struct_decl.get_node_id ();"}, {"sha": "43bf0a421d692109fb194910a4bd947a204bec79", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -33,9 +33,11 @@ class ResolveStmt : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Stmt *stmt, NodeId parent)\n+  static void go (AST::Stmt *stmt, NodeId parent,\n+\t\t  const CanonicalPath &enum_prefix\n+\t\t  = CanonicalPath::create_empty ())\n   {\n-    ResolveStmt resolver (parent);\n+    ResolveStmt resolver (parent, enum_prefix);\n     stmt->accept_vis (resolver);\n   };\n \n@@ -98,6 +100,97 @@ class ResolveStmt : public ResolverBase\n     resolver->get_type_scope ().pop ();\n   }\n \n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    auto enum_path = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\t     enum_decl.get_identifier ());\n+    resolver->get_type_scope ().insert (\n+      enum_path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (enum_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId scope_node_id = enum_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (enum_decl.has_generics ())\n+      {\n+\tfor (auto &generic : enum_decl.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n+\t  }\n+      }\n+\n+    for (auto &variant : enum_decl.get_variants ())\n+      ResolveStmt::go (variant.get (), parent, enum_path);\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::EnumItem &item) override\n+  {\n+    auto path = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // Done, no fields.\n+  }\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    auto path = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &field : item.get_tuple_fields ())\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    auto path = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &field : item.get_struct_fields ())\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+  }\n+\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto path = enum_prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    // Done, no fields.\n+  }\n+\n   void visit (AST::StructStruct &struct_decl) override\n   {\n     auto path = CanonicalPath::new_seg (struct_decl.get_node_id (),\n@@ -219,7 +312,13 @@ class ResolveStmt : public ResolverBase\n   }\n \n private:\n-  ResolveStmt (NodeId parent) : ResolverBase (parent) {}\n+  ResolveStmt (NodeId parent, const CanonicalPath &enum_prefix)\n+    : ResolverBase (parent), enum_prefix (enum_prefix)\n+  {}\n+\n+  /* item declaration statements are not given a canonical path, but enum items\n+   * (variants) do inherit the enum path/identifier name.  */\n+  const CanonicalPath &enum_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "6f802a5b6e8459d7cefee39c76b572c52020f6b6", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -88,6 +88,75 @@ class ResolveTopLevel : public ResolverBase\n       });\n   }\n \n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    auto path\n+      = prefix.append (CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\t       enum_decl.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (enum_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &variant : enum_decl.get_variants ())\n+      ResolveTopLevel::go (variant.get (), path);\n+  }\n+\n+  void visit (AST::EnumItem &item) override\n+  {\n+    auto path = prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    auto path = prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    auto path = prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto path = prefix.append (\n+      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, item.get_node_id (), item.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (item.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n   void visit (AST::StructStruct &struct_decl) override\n   {\n     auto path"}, {"sha": "e7fd5edb9811c2acca873b4e7d3eb9f9083b4d6e", "filename": "gcc/testsuite/rust/compile/bad_pub_enumitems.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_pub_enumitems.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_pub_enumitems.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_pub_enumitems.rs?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -0,0 +1,47 @@\n+pub enum E\n+{\n+  pub A { a: i32 }, // { dg-error \"visibility qualifier\" }\n+  B (u8),\n+  pub C, // { dg-error \"visibility qualifier\" }\n+  D\n+}\n+\n+enum E1\n+{\n+  A,\n+  pub B = 42, // { dg-error \"visibility qualifier\" }\n+  C = 3,\n+  D,\n+  pub E // { dg-error \"visibility qualifier\" }\n+}\n+\n+enum E2\n+{\n+  pub A (u8, i32, u64), // { dg-error \"visibility qualifier\" }\n+  B { a: u8, a: u8 }  // { dg-error \"duplicate field\" }}\n+}\n+\n+fn main ()\n+{\n+  enum EE\n+    {\n+      Alpha { alpha: i32 },\n+      pub Beta (u8), // { dg-error \"visibility qualifier\" }\n+      pub Gamma, // { dg-error \"visibility qualifier\" }\n+      Delta { delta: u32 }\n+    }\n+\n+  enum EE1\n+    {\n+      pub Alpha, // { dg-error \"visibility qualifier\" }\n+      Beta = 41,\n+      pub Gamma = 3, // { dg-error \"visibility qualifier\" }\n+      Delta,\n+    }\n+\n+  enum E2\n+    {\n+      Alpha { a: u8, a: u8 },  // { dg-error \"duplicate field\" }}\n+      pub Beta (u8, i32, u64) // { dg-error \"visibility qualifier\" }\n+    }\n+}"}, {"sha": "7b09a94fd2745968f969df263570943b21625a48", "filename": "gcc/testsuite/rust/compile/bad_stmt_enums.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_stmt_enums.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_stmt_enums.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_stmt_enums.rs?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -0,0 +1,22 @@\n+fn main ()\n+{\n+  enum EE\n+    {\n+      Alpha { alpha: i32 },\n+      pub Beta (u8),\n+      pub Gamma,\n+      Gamma { gamma: u32 } // { dg-error \"redefined\" }\n+    }\n+\n+  struct EE2 { }\n+  enum EE2 { } // { dg-error \"redefined\" }\n+\n+  enum EE1\n+    {\n+      pub Alpha,\n+      Beta = 41,\n+      Beta = 42, // { dg-error \"redefined\" }\n+      pub Gamma = 3,\n+      D,\n+    }\n+}"}, {"sha": "b655e30a93da402b21c3397493189a264c3f1355", "filename": "gcc/testsuite/rust/compile/bad_toplevel_enums.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_toplevel_enums.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_toplevel_enums.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_toplevel_enums.rs?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -0,0 +1,19 @@\n+pub enum E\n+{\n+  pub A { a: i32 },\n+  B (u8),\n+  pub C,\n+  B // { dg-error \"redefined\" }\n+}\n+\n+enum E2 { }\n+struct E2 { } // { dg-error \"redefined\" }\n+\n+enum E1\n+{\n+  A,\n+  pub B = 42,\n+  C = 3,\n+  A { a: u8 }, // { dg-error \"redefined\" }\n+  pub D\n+}"}, {"sha": "f65bd3b5c69bf05f7ecd55f8b9af848a16a43049", "filename": "gcc/testsuite/rust/compile/torture/tuple_enum_variants.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftuple_enum_variants.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9271e1921d0eac46bda889da6508cf94d32682/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftuple_enum_variants.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftuple_enum_variants.rs?ref=8a9271e1921d0eac46bda889da6508cf94d32682", "patch": "@@ -1,4 +1,9 @@\n-enum E { T0(), T1(i32), T2(i32,u32) }\n+enum E        // { dg-warning \"unused name\" }\n+{\n+  T0(),       // { dg-warning \"unused name\" }\n+  T1(i32),    // { dg-warning \"unused name\" }\n+  T2(i32,u32) // { dg-warning \"unused name\" }\n+}\n \n /* The following doesn't parse yet...\n fn f(e0: E, e1: E, e2: E) -> (E,E,E,())"}]}