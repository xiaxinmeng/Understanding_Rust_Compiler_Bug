{"sha": "2fe0a4da436b928900220c84c24fd5955df58dae", "node_id": "C_kwDOANBUbNoAKDJmZTBhNGRhNDM2YjkyODkwMDIyMGM4NGMyNGZkNTk1NWRmNThkYWU", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-14T09:38:08Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-14T11:27:36Z"}, "message": "parser: Refactor generic parameter parsing\n\nThis allows us to parse lifetimes and types (and later const generics)\nin any order without necessarily erroring out. It also simplifies the\ncode greatly and makes it easier to modify.\n\nFinally, this commit removes an unused duplicate parse_generic_params function", "tree": {"sha": "993af40f037411fae5f10aafac0fcfa8477a713e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/993af40f037411fae5f10aafac0fcfa8477a713e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fe0a4da436b928900220c84c24fd5955df58dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe0a4da436b928900220c84c24fd5955df58dae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe0a4da436b928900220c84c24fd5955df58dae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe0a4da436b928900220c84c24fd5955df58dae/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c679d7f42834a72956d6fb39c8d298dd6dc4b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c679d7f42834a72956d6fb39c8d298dd6dc4b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c679d7f42834a72956d6fb39c8d298dd6dc4b4e"}], "stats": {"total": 393, "additions": 77, "deletions": 316}, "files": [{"sha": "0fd381c7b724f2ae4467f8f92c633a650515df14", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 74, "deletions": 315, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a4da436b928900220c84c24fd5955df58dae/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a4da436b928900220c84c24fd5955df58dae/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=2fe0a4da436b928900220c84c24fd5955df58dae", "patch": "@@ -2793,197 +2793,87 @@ Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n   return generic_params;\n }\n \n-/* Parse generic (lifetime or type) params NOT INSIDE ANGLE BRACKETS!!! Almost\n- * always parse_generic_params_in_angles is what is wanted. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::GenericParam>>\n-Parser<ManagedTokenSource>::parse_generic_params ()\n+template <typename EndTokenPred>\n+std::unique_ptr<AST::GenericParam>\n+Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n-\n-  // can't parse lifetime and type params separately due to lookahead issues\n-  // thus, parse them all here\n+  auto token = lexer.peek_token ();\n+  auto outer_attrs = parse_outer_attribute ();\n+  std::unique_ptr<AST::GenericParam> param;\n \n-  // DEBUG\n-  rust_debug (\"starting to parse generic params (inside angle brackets)\");\n-\n-  /* HACK: used to retain attribute data if a lifetime param is tentatively\n-   * parsed but it turns out to be type param */\n-  AST::Attribute parsed_outer_attr = AST::Attribute::create_empty ();\n-\n-  /* HACK: generic params always in angle brackets with current syntax, so have\n-   * that as end char */\n-  const_TokenPtr t = lexer.peek_token ();\n-  // parse lifetime params\n-  while (!is_right_angle_tok (t->get_id ()))\n-    {\n-      // HACK: reimpl of lifetime param parsing\n-      AST::Attribute outer_attr = parse_outer_attribute ();\n-\n-      // move attribute outward if type param\n-      if (lexer.peek_token ()->get_id () != LIFETIME)\n-\t{\n-\t  parsed_outer_attr = std::move (outer_attr);\n-\n-\t  // DEBUG\n-\t  rust_debug (\n-\t    \"broke from parsing lifetime params as next token isn't lifetime - \"\n-\t    \"saved attribute\");\n-\n-\t  break;\n-\t}\n-\n-      Location locus = lexer.peek_token ()->get_locus ();\n-      AST::Lifetime lifetime = parse_lifetime ();\n-\n-      // DEBUG\n-      rust_debug (\"parsed lifetime in lifetime params\");\n-\n-      // parse optional bounds\n-      std::vector<AST::Lifetime> lifetime_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\t  // parse required bounds\n-\t  lifetime_bounds = parse_lifetime_bounds (\n-\t    [] (TokenId id) { return is_right_angle_tok (id) || id == COMMA; });\n-\t}\n-\n-      std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime),\n-\t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr), locus));\n-      generic_params.push_back (std::move (param));\n-\n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n-      lexer.skip_token ();\n-\n-      t = lexer.peek_token ();\n-    }\n-\n-  // parse type params (reimpl required for first one but not others)\n-  if (!is_right_angle_tok (lexer.peek_token ()->get_id ())\n-      && !parsed_outer_attr.is_empty ())\n+  switch (token->get_id ())\n     {\n-      // DEBUG\n-      rust_debug (\"as parsed outer attr isn't empty, started parsing type \"\n-\t\t  \"param reimpl\");\n-\n-      // reimpl as type param definitely exists\n-      const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n-      if (ident_tok == nullptr)\n-\t{\n-\t  Error error (\n-\t    lexer.peek_token ()->get_locus (),\n-\t    \"failed to parse identifier in type param in generic params\");\n-\t  add_error (std::move (error));\n-\n-\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n-\t}\n-      Identifier ident = ident_tok->get_str ();\n-\n-      // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse optional type param bounds\n-\t  type_param_bounds = parse_type_param_bounds ();\n-\t}\n-\n-      // parse optional type\n-      std::unique_ptr<AST::Type> type = nullptr;\n-      if (lexer.peek_token ()->get_id () == EQUAL)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse required type\n-\t  type = parse_type ();\n-\t  if (type == nullptr)\n-\t    {\n-\t      Error error (\n-\t\tlexer.peek_token ()->get_locus (),\n-\t\t\"failed to parse type in type param in generic params\");\n-\t      add_error (std::move (error));\n-\n-\t      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n-\t    }\n-\t}\n-\n-      std::unique_ptr<AST::TypeParam> param (\n-\tnew AST::TypeParam (std::move (ident), ident_tok->get_locus (),\n-\t\t\t    std::move (type_param_bounds), std::move (type),\n-\t\t\t    std::move (parsed_outer_attr)));\n-      generic_params.push_back (std::move (param));\n-\n-      // handle comma\n-      if (lexer.peek_token ()->get_id () == COMMA)\n-\t{\n-\t  lexer.skip_token ();\n-\t}\n-    }\n-\n-  // DEBUG\n-  rust_debug (\n-    \"about to start parsing normally-parsed type params in generic params\");\n+      case LIFETIME: {\n+\tauto lifetime = parse_lifetime ();\n+\tif (lifetime.is_error ())\n+\t  {\n+\t    rust_error_at (\n+\t      token->get_locus (),\n+\t      \"failed to parse lifetime in generic parameter list\");\n+\t    return nullptr;\n+\t  }\n \n-  // parse rest of type params - reimpl due to right angle tokens\n-  t = lexer.peek_token ();\n-  while (!is_right_angle_tok (t->get_id ()))\n-    {\n-      std::unique_ptr<AST::TypeParam> type_param = parse_type_param ();\n+\tstd::vector<AST::Lifetime> lifetime_bounds;\n+\tif (lexer.peek_token ()->get_id () == COLON)\n+\t  {\n+\t    lexer.skip_token ();\n+\t    // parse required bounds\n+\t    lifetime_bounds\n+\t      = parse_lifetime_bounds ([is_end_token] (TokenId id) {\n+\t\t  return is_end_token (id) || id == COMMA;\n+\t\t});\n+\t  }\n \n-      if (type_param == nullptr)\n-\t{\n-\t  Error error (lexer.peek_token ()->get_locus (),\n-\t\t       \"failed to parse type param in generic params\");\n-\t  add_error (std::move (error));\n+\tparam = std::unique_ptr<AST::LifetimeParam> (new AST::LifetimeParam (\n+\t  std::move (lifetime), std::move (lifetime_bounds),\n+\t  std::move (outer_attrs), token->get_locus ()));\n+\tbreak;\n+      }\n+      case IDENTIFIER: {\n+\tauto type_ident = token->get_str ();\n+\tlexer.skip_token ();\n \n-\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n-\t}\n+\tstd::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n+\tif (lexer.peek_token ()->get_id () == COLON)\n+\t  {\n+\t    lexer.skip_token ();\n \n-      // DEBUG\n-      rust_debug (\"successfully parsed type param\");\n+\t    // parse optional type param bounds\n+\t    type_param_bounds = parse_type_param_bounds ();\n+\t  }\n \n-      generic_params.push_back (std::move (type_param));\n+\tstd::unique_ptr<AST::Type> type = nullptr;\n+\tif (lexer.peek_token ()->get_id () == EQUAL)\n+\t  {\n+\t    lexer.skip_token ();\n \n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n-      // skip commas, including trailing commas\n-      lexer.skip_token ();\n+\t    // parse required type\n+\t    type = parse_type ();\n+\t    if (!type)\n+\t      {\n+\t\trust_error_at (\n+\t\t  lexer.peek_token ()->get_locus (),\n+\t\t  \"failed to parse type in type param in generic params\");\n+\t\treturn nullptr;\n+\t      }\n+\t  }\n \n-      t = lexer.peek_token ();\n+\tparam = std::unique_ptr<AST::TypeParam> (\n+\t  new AST::TypeParam (std::move (type_ident), token->get_locus (),\n+\t\t\t      std::move (type_param_bounds), std::move (type),\n+\t\t\t      std::move (outer_attrs)));\n+\tbreak;\n+      }\n+    default:\n+      // FIXME: Can we clean this last call with a method call?\n+      rust_error_at (token->get_locus (),\n+\t\t     \"unexpected token when parsing generic parameters: %qs\",\n+\t\t     token->get_str ().c_str ());\n+      return nullptr;\n     }\n \n-  // old code\n-  /*\n-  // parse lifetime params (optional), allowed to end with a trailing comma\n-  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params\n-    = parse_lifetime_params();\n-  if (!lifetime_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(lifetime_params.begin()),\n-\tstd::make_move_iterator(lifetime_params.end()));\n-  }\n-\n-  // parse type params (optional)\n-  std::vector<std::unique_ptr<AST::TypeParam>> type_params =\n-  parse_type_params(); if (!type_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(type_params.begin()),\n-\tstd::make_move_iterator(type_params.end()));\n-  }*/\n-\n-  generic_params.shrink_to_fit ();\n-  return generic_params;\n+  return param;\n }\n \n /* Parse generic (lifetime or type) params NOT INSIDE ANGLE BRACKETS!!! Almost\n@@ -3002,150 +2892,19 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n    * parsed but it turns out to be type param */\n   AST::Attribute parsed_outer_attr = AST::Attribute::create_empty ();\n \n-  const_TokenPtr t = lexer.peek_token ();\n   // parse lifetime params\n-  while (!is_end_token (t->get_id ()))\n-    {\n-      // HACK: reimpl of lifetime param parsing\n-      AST::Attribute outer_attr = parse_outer_attribute ();\n-\n-      // move attribute outward if type param\n-      if (lexer.peek_token ()->get_id () != LIFETIME)\n-\t{\n-\t  parsed_outer_attr = std::move (outer_attr);\n-\t  break;\n-\t}\n-\n-      Location locus = lexer.peek_token ()->get_locus ();\n-      AST::Lifetime lifetime = parse_lifetime ();\n-\n-      // parse optional bounds\n-      std::vector<AST::Lifetime> lifetime_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\t  // parse required bounds\n-\t  lifetime_bounds = parse_lifetime_bounds ([is_end_token] (TokenId id) {\n-\t    return is_end_token (id) || id == COMMA;\n-\t  });\n-\t}\n-\n-      std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime),\n-\t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr), locus));\n-      generic_params.push_back (std::move (param));\n-\n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\tbreak;\n-\n-      lexer.skip_token ();\n-      t = lexer.peek_token ();\n-    }\n-\n-  // parse type params (reimpl required for first one but not others)\n-  if (!is_end_token (lexer.peek_token ()->get_id ())\n-      && !parsed_outer_attr.is_empty ())\n-    {\n-      // reimpl as type param definitely exists\n-      const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n-      if (ident_tok == nullptr)\n-\t{\n-\t  Error error (\n-\t    lexer.peek_token ()->get_locus (),\n-\t    \"failed to parse identifier in type param in generic params\");\n-\t  add_error (std::move (error));\n-\n-\t  return {};\n-\t}\n-      Identifier ident = ident_tok->get_str ();\n-\n-      // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse optional type param bounds\n-\t  type_param_bounds = parse_type_param_bounds ();\n-\t}\n-\n-      // parse optional type\n-      std::unique_ptr<AST::Type> type = nullptr;\n-      if (lexer.peek_token ()->get_id () == EQUAL)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse required type\n-\t  type = parse_type ();\n-\t  if (type == nullptr)\n-\t    {\n-\t      Error error (\n-\t\tlexer.peek_token ()->get_locus (),\n-\t\t\"failed to parse type in type param in generic params\");\n-\t      add_error (std::move (error));\n-\n-\t      return {};\n-\t    }\n-\t}\n-\n-      std::unique_ptr<AST::TypeParam> param (\n-\tnew AST::TypeParam (std::move (ident), ident_tok->get_locus (),\n-\t\t\t    std::move (type_param_bounds), std::move (type),\n-\t\t\t    std::move (parsed_outer_attr)));\n-      generic_params.push_back (std::move (param));\n-\n-      // handle comma\n-      if (lexer.peek_token ()->get_id () == COMMA)\n-\tlexer.skip_token ();\n-    }\n-\n-  // parse rest of type params - reimpl due to right angle tokens\n-  t = lexer.peek_token ();\n-  while (!is_end_token (t->get_id ()))\n+  while (!is_end_token (lexer.peek_token ()->get_id ()))\n     {\n-      std::unique_ptr<AST::TypeParam> type_param = parse_type_param ();\n-\n-      if (type_param == nullptr)\n+      auto param = parse_generic_param (is_end_token);\n+      if (param)\n \t{\n-\t  Error error (lexer.peek_token ()->get_locus (),\n-\t\t       \"failed to parse type param in generic params\");\n-\t  add_error (std::move (error));\n-\n-\t  return {};\n+\t  generic_params.emplace_back (std::move (param));\n+\t  maybe_skip_token (COMMA);\n \t}\n \n-      generic_params.push_back (std::move (type_param));\n-\n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\tbreak;\n-\n-      // skip commas, including trailing commas\n-      lexer.skip_token ();\n-      t = lexer.peek_token ();\n+      // error out if lifetime after type\n     }\n \n-  // old code\n-  /*\n-  // parse lifetime params (optional), allowed to end with a trailing comma\n-  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params\n-    = parse_lifetime_params();\n-  if (!lifetime_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(lifetime_params.begin()),\n-\tstd::make_move_iterator(lifetime_params.end()));\n-  }\n-\n-  // parse type params (optional)\n-  std::vector<std::unique_ptr<AST::TypeParam>> type_params =\n-  parse_type_params(); if (!type_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(type_params.begin()),\n-\tstd::make_move_iterator(type_params.end()));\n-  }*/\n-\n   generic_params.shrink_to_fit ();\n   return generic_params;\n }"}, {"sha": "d19bc71d3105d02b4946ad2a7122685162680b14", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe0a4da436b928900220c84c24fd5955df58dae/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe0a4da436b928900220c84c24fd5955df58dae/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=2fe0a4da436b928900220c84c24fd5955df58dae", "patch": "@@ -223,10 +223,12 @@ template <typename ManagedTokenSource> class Parser\n   AST::FunctionQualifiers parse_function_qualifiers ();\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params_in_angles ();\n-  std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params (EndTokenPred is_end_token);\n+  template <typename EndTokenPred>\n+  std::unique_ptr<AST::GenericParam>\n+  parse_generic_param (EndTokenPred is_end_token);\n \n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::LifetimeParam> >"}]}