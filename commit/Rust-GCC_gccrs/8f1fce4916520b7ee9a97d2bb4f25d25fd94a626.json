{"sha": "8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "node_id": "C_kwDOANBUbNoAKDhmMWZjZTQ5MTY1MjBiN2VlOWE5N2QyYmI0ZjI1ZDI1ZmQ5NGE2MjY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2023-02-05T00:56:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-05T00:56:44Z"}, "message": "Merge #1739\n\n1739: Initial type bounds checking for all type checks r=philberty a=philberty\n\nThis patchset is my branch for general improvements to the type-system and\r\nfor improved type bounds checking in preparation for opaque types.\r\n\r\nFixes #1773 #1786\n\nCo-authored-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "fb2b8f475720233153b06864ffd4d5fc72ed35df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb2b8f475720233153b06864ffd4d5fc72ed35df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj3v7MCRBK7hj4Ov3rIwAAkIoIAKi8loLbG+iqRhsEx4jfUejQ\npLFw8xXchAwzQOSbjqO3l9Mx26JxyP6U3X8X6MAiR3vmfdvMchs8M8fLBDZIl4lT\nq5gpbMsthsqu5Hok7spdmVj9KVHO7wey8ZbABoAhnN2XgrKuvMZ1zyu2Jqh1ugqk\nlNHCNybzOiPKxNvv6jhg8h09XQibNIvKgoqTb5oxHalDnKwkHdPWwzmp97bXgT23\ngFgHA2cwQIW7a2L9KdVsYdcLzJpwicK8l/r6z3702m2ohSUMYPWqWY8nT0eQ2U9w\nvvn9knwhxm4ps4YvnVK8mYEnOsaXLYZI5UzOJE7pzXssrcvraDwoFje7HCGBjPA=\n=kTqW\n-----END PGP SIGNATURE-----\n", "payload": "tree fb2b8f475720233153b06864ffd4d5fc72ed35df\nparent 47a9a9e949d7660ae7fc7cd4642f668bf438c970\nparent 6d7a7b22882433d46bf4e4efe8c43343892c91eb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1675558604 +0000\ncommitter GitHub <noreply@github.com> 1675558604 +0000\n\nMerge #1739\n\n1739: Initial type bounds checking for all type checks r=philberty a=philberty\n\nThis patchset is my branch for general improvements to the type-system and\r\nfor improved type bounds checking in preparation for opaque types.\r\n\r\nFixes #1773 #1786\n\nCo-authored-by: Philip Herron <herron.philip@googlemail.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47a9a9e949d7660ae7fc7cd4642f668bf438c970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a9a9e949d7660ae7fc7cd4642f668bf438c970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a9a9e949d7660ae7fc7cd4642f668bf438c970"}, {"sha": "6d7a7b22882433d46bf4e4efe8c43343892c91eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7a7b22882433d46bf4e4efe8c43343892c91eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d7a7b22882433d46bf4e4efe8c43343892c91eb"}], "stats": {"total": 11073, "additions": 6625, "deletions": 4448}, "files": [{"sha": "6038c84c99384e5120af46d242886aacca30df16", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -115,8 +115,10 @@ GRS_OBJS = \\\n     rust/rust-pub-restricted-visitor.o \\\n     rust/rust-privacy-reporter.o \\\n     rust/rust-tyty.o \\\n+    rust/rust-tyty-util.o \\\n     rust/rust-tyty-call.o \\\n-    rust/rust-tyctx.o \\\n+    rust/rust-tyty-subst.o \\\n+    rust/rust-typecheck-context.o \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n@@ -132,6 +134,7 @@ GRS_OBJS = \\\n     rust/rust-hir-path-probe.o \\\n     rust/rust-coercion.o \\\n     rust/rust-casts.o \\\n+    rust/rust-unify.o \\\n     rust/rust-hir-type-check-base.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\"}, {"sha": "1890b578598ccd7c1341897dd3a7c4dfca0b83c0", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-compile-block.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-constexpr.h\"\n+#include \"rust-unify.h\"\n #include \"rust-gcc.h\"\n \n #include \"fold-const.h\"\n@@ -2006,7 +2007,10 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \t{\n \t  TyTy::BaseType *infer_impl_call\n \t    = candidate_call->infer_substitions (expr_locus);\n-\t  monomorphized = infer_impl_call->unify (fntype);\n+\t  monomorphized = Resolver::UnifyRules::Resolve (\n+\t    TyTy::TyWithLocation (infer_impl_call),\n+\t    TyTy::TyWithLocation (fntype), expr_locus, true /* commit */,\n+\t    true /* emit_errors */);\n \t}\n \n       return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);"}, {"sha": "623607868f9ab0f1b456d7b5f333abb82e450ac1", "filename": "gcc/rust/typecheck/rust-coercion.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-hir-type-check-base.h\"\n #include \"rust-coercion.h\"\n+#include \"rust-unify.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -218,7 +219,10 @@ TypeCoercionRules::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n \t// we might be able to replace this with a can_eq because we default\n \t// back to a final unity anyway\n \trust_debug (\"coerce_borrowed_pointer -- unify\");\n-\tTyTy::BaseType *result = receiver->unify (expected);\n+\tTyTy::BaseType *result\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (receiver),\n+\t\t\t\t TyTy::TyWithLocation (expected), locus,\n+\t\t\t\t true /* commit */, true /* emit_errors */);\n \treturn CoercionResult{{}, result};\n       }\n     }"}, {"sha": "be89ceb864574e24f3fc4ef1aa3082e90a4e7c0a", "filename": "gcc/rust/typecheck/rust-hir-path-probe.cc", "status": "modified", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -18,10 +18,277 @@\n \n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-type-check-item.h\"\n+#include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n \n+// PathProbeCandidate\n+\n+PathProbeCandidate::Candidate::Candidate (EnumItemCandidate enum_field)\n+  : enum_field (enum_field)\n+{}\n+\n+PathProbeCandidate::Candidate::Candidate (ImplItemCandidate impl) : impl (impl)\n+{}\n+\n+PathProbeCandidate::Candidate::Candidate (TraitItemCandidate trait)\n+  : trait (trait)\n+{}\n+\n+PathProbeCandidate::PathProbeCandidate (CandidateType type, TyTy::BaseType *ty,\n+\t\t\t\t\tLocation locus,\n+\t\t\t\t\tEnumItemCandidate enum_field)\n+  : type (type), ty (ty), locus (locus), item (enum_field)\n+{}\n+\n+PathProbeCandidate::PathProbeCandidate (CandidateType type, TyTy::BaseType *ty,\n+\t\t\t\t\tLocation locus, ImplItemCandidate impl)\n+  : type (type), ty (ty), locus (locus), item (impl)\n+{}\n+\n+PathProbeCandidate::PathProbeCandidate (CandidateType type, TyTy::BaseType *ty,\n+\t\t\t\t\tLocation locus,\n+\t\t\t\t\tTraitItemCandidate trait)\n+  : type (type), ty (ty), locus (locus), item (trait)\n+{}\n+\n+std::string\n+PathProbeCandidate::as_string () const\n+{\n+  return \"PathProbe candidate TODO - as_string\";\n+}\n+\n+bool\n+PathProbeCandidate::is_enum_candidate () const\n+{\n+  return type == ENUM_VARIANT;\n+}\n+\n+bool\n+PathProbeCandidate::is_impl_candidate () const\n+{\n+  return type == IMPL_CONST || type == IMPL_TYPE_ALIAS || type == IMPL_FUNC;\n+}\n+\n+bool\n+PathProbeCandidate::is_trait_candidate () const\n+{\n+  return type == TRAIT_ITEM_CONST || type == TRAIT_TYPE_ALIAS\n+\t || type == TRAIT_FUNC;\n+}\n+\n+bool\n+PathProbeCandidate::is_full_trait_item_candidate () const\n+{\n+  return is_trait_candidate () && item.trait.impl == nullptr;\n+}\n+\n+PathProbeCandidate\n+PathProbeCandidate::get_error ()\n+{\n+  return PathProbeCandidate (ERROR, nullptr, Location (),\n+\t\t\t     ImplItemCandidate{nullptr, nullptr});\n+}\n+\n+bool\n+PathProbeCandidate::is_error () const\n+{\n+  return type == ERROR;\n+}\n+\n+DefId\n+PathProbeCandidate::get_defid () const\n+{\n+  switch (type)\n+    {\n+    case ENUM_VARIANT:\n+      return item.enum_field.variant->get_defid ();\n+      break;\n+\n+    case IMPL_CONST:\n+    case IMPL_TYPE_ALIAS:\n+    case IMPL_FUNC:\n+      return item.impl.impl_item->get_impl_mappings ().get_defid ();\n+      break;\n+\n+    case TRAIT_ITEM_CONST:\n+    case TRAIT_TYPE_ALIAS:\n+    case TRAIT_FUNC:\n+      return item.trait.item_ref->get_mappings ().get_defid ();\n+      break;\n+\n+    case ERROR:\n+    default:\n+      return UNKNOWN_DEFID;\n+    }\n+\n+  return UNKNOWN_DEFID;\n+}\n+\n+bool\n+PathProbeCandidate::operator< (const PathProbeCandidate &c) const\n+{\n+  return get_defid () < c.get_defid ();\n+}\n+\n+// PathProbeType\n+\n+PathProbeType::PathProbeType (const TyTy::BaseType *receiver,\n+\t\t\t      const HIR::PathIdentSegment &query,\n+\t\t\t      DefId specific_trait_id)\n+  : TypeCheckBase (), receiver (receiver), search (query),\n+    current_impl (nullptr), specific_trait_id (specific_trait_id)\n+{}\n+\n+std::set<PathProbeCandidate>\n+PathProbeType::Probe (const TyTy::BaseType *receiver,\n+\t\t      const HIR::PathIdentSegment &segment_name,\n+\t\t      bool probe_impls, bool probe_bounds,\n+\t\t      bool ignore_mandatory_trait_items,\n+\t\t      DefId specific_trait_id)\n+{\n+  PathProbeType probe (receiver, segment_name, specific_trait_id);\n+  if (probe_impls)\n+    {\n+      if (receiver->get_kind () == TyTy::TypeKind::ADT)\n+\t{\n+\t  const TyTy::ADTType *adt\n+\t    = static_cast<const TyTy::ADTType *> (receiver);\n+\t  if (adt->is_enum ())\n+\t    probe.process_enum_item_for_candiates (adt);\n+\t}\n+\n+      probe.process_impl_items_for_candidates ();\n+    }\n+\n+  if (!probe_bounds)\n+    return probe.candidates;\n+\n+  if (!probe.is_reciever_generic ())\n+    {\n+      std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n+\t= TypeBoundsProbe::Probe (receiver);\n+      for (auto &candidate : probed_bounds)\n+\t{\n+\t  const TraitReference *trait_ref = candidate.first;\n+\t  if (specific_trait_id != UNKNOWN_DEFID)\n+\t    {\n+\t      if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n+\t\tcontinue;\n+\t    }\n+\n+\t  HIR::ImplBlock *impl = candidate.second;\n+\t  probe.process_associated_trait_for_candidates (\n+\t    trait_ref, impl, ignore_mandatory_trait_items);\n+\t}\n+    }\n+\n+  for (const TyTy::TypeBoundPredicate &predicate :\n+       receiver->get_specified_bounds ())\n+    {\n+      const TraitReference *trait_ref = predicate.get ();\n+      if (specific_trait_id != UNKNOWN_DEFID)\n+\t{\n+\t  if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n+\t    continue;\n+\t}\n+\n+      probe.process_predicate_for_candidates (predicate,\n+\t\t\t\t\t      ignore_mandatory_trait_items);\n+    }\n+\n+  return probe.candidates;\n+}\n+\n+void\n+PathProbeType::visit (HIR::TypeAlias &alias)\n+{\n+  Identifier name = alias.get_new_type_name ();\n+  if (search.as_string ().compare (name) == 0)\n+    {\n+      HirId tyid = alias.get_mappings ().get_hirid ();\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = query_type (tyid, &ty);\n+      rust_assert (ok);\n+\n+      PathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n+\t\t\t\t\t\t\t\tcurrent_impl};\n+      PathProbeCandidate candidate{\n+\tPathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n+\talias.get_locus (), impl_item_candidate};\n+      candidates.insert (std::move (candidate));\n+    }\n+}\n+\n+void\n+PathProbeType::visit (HIR::ConstantItem &constant)\n+{\n+  Identifier name = constant.get_identifier ();\n+  if (search.as_string ().compare (name) == 0)\n+    {\n+      HirId tyid = constant.get_mappings ().get_hirid ();\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = query_type (tyid, &ty);\n+      rust_assert (ok);\n+\n+      PathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n+\t\t\t\t\t\t\t\tcurrent_impl};\n+      PathProbeCandidate candidate{\n+\tPathProbeCandidate::CandidateType::IMPL_CONST, ty,\n+\tconstant.get_locus (), impl_item_candidate};\n+      candidates.insert (std::move (candidate));\n+    }\n+}\n+\n+void\n+PathProbeType::visit (HIR::Function &function)\n+{\n+  Identifier name = function.get_function_name ();\n+  if (search.as_string ().compare (name) == 0)\n+    {\n+      HirId tyid = function.get_mappings ().get_hirid ();\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = query_type (tyid, &ty);\n+      rust_assert (ok);\n+\n+      PathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n+\t\t\t\t\t\t\t\tcurrent_impl};\n+      PathProbeCandidate candidate{PathProbeCandidate::CandidateType::IMPL_FUNC,\n+\t\t\t\t   ty, function.get_locus (),\n+\t\t\t\t   impl_item_candidate};\n+      candidates.insert (std::move (candidate));\n+    }\n+}\n+\n+void\n+PathProbeType::process_enum_item_for_candiates (const TyTy::ADTType *adt)\n+{\n+  if (specific_trait_id != UNKNOWN_DEFID)\n+    return;\n+\n+  TyTy::VariantDef *v;\n+  if (!adt->lookup_variant (search.as_string (), &v))\n+    return;\n+\n+  PathProbeCandidate::EnumItemCandidate enum_item_candidate{adt, v};\n+  PathProbeCandidate candidate{PathProbeCandidate::CandidateType::ENUM_VARIANT,\n+\t\t\t       receiver->clone (),\n+\t\t\t       mappings->lookup_location (adt->get_ty_ref ()),\n+\t\t\t       enum_item_candidate};\n+  candidates.insert (std::move (candidate));\n+}\n+\n+void\n+PathProbeType::process_impl_items_for_candidates ()\n+{\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+}\n+\n void\n PathProbeType::process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n \t\t\t\t\t    HIR::ImplBlock *impl)\n@@ -42,5 +309,191 @@ PathProbeType::process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n   item->accept_vis (*this);\n }\n \n+void\n+PathProbeType::process_associated_trait_for_candidates (\n+  const TraitReference *trait_ref, HIR::ImplBlock *impl,\n+  bool ignore_mandatory_trait_items)\n+{\n+  const TraitItemReference *trait_item_ref = nullptr;\n+  if (!trait_ref->lookup_trait_item (search.as_string (), &trait_item_ref))\n+    return;\n+\n+  bool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n+  if (ignore_mandatory_trait_items && trait_item_needs_implementation)\n+    return;\n+\n+  PathProbeCandidate::CandidateType candidate_type;\n+  switch (trait_item_ref->get_trait_item_type ())\n+    {\n+    case TraitItemReference::TraitItemType::FN:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+      break;\n+    case TraitItemReference::TraitItemType::CONST:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+      break;\n+    case TraitItemReference::TraitItemType::TYPE:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+      break;\n+\n+    case TraitItemReference::TraitItemType::ERROR:\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n+\n+  // we can substitute the Self with the receiver here\n+  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+      TyTy::SubstitutionParamMapping *param = nullptr;\n+      for (auto &param_mapping : fn->get_substs ())\n+\t{\n+\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t    {\n+\t      param = &param_mapping;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (param != nullptr);\n+\n+      std::vector<TyTy::SubstitutionArg> mappings;\n+      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+      Location locus; // FIXME\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings), {}, locus);\n+      trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+    }\n+\n+  PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t      trait_item_ref,\n+\t\t\t\t\t\t\t      impl};\n+\n+  PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n+\t\t\t       trait_item_ref->get_locus (),\n+\t\t\t       trait_item_candidate};\n+  candidates.insert (std::move (candidate));\n+}\n+\n+void\n+PathProbeType::process_predicate_for_candidates (\n+  const TyTy::TypeBoundPredicate &predicate, bool ignore_mandatory_trait_items)\n+{\n+  const TraitReference *trait_ref = predicate.get ();\n+\n+  TyTy::TypeBoundPredicateItem item\n+    = predicate.lookup_associated_item (search.as_string ());\n+  if (item.is_error ())\n+    return;\n+\n+  if (ignore_mandatory_trait_items && item.needs_implementation ())\n+    return;\n+\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n+  PathProbeCandidate::CandidateType candidate_type;\n+  switch (trait_item_ref->get_trait_item_type ())\n+    {\n+    case TraitItemReference::TraitItemType::FN:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+      break;\n+    case TraitItemReference::TraitItemType::CONST:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+      break;\n+    case TraitItemReference::TraitItemType::TYPE:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+      break;\n+\n+    case TraitItemReference::TraitItemType::ERROR:\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  TyTy::BaseType *trait_item_tyty = item.get_tyty_for_receiver (receiver);\n+  PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t      trait_item_ref,\n+\t\t\t\t\t\t\t      nullptr};\n+  PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n+\t\t\t       trait_item_ref->get_locus (),\n+\t\t\t       trait_item_candidate};\n+  candidates.insert (std::move (candidate));\n+}\n+\n+std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+PathProbeType::union_bounds (\n+  const std::vector<std::pair</*const*/ TraitReference *, HIR::ImplBlock *>> a,\n+  const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> b)\n+  const\n+{\n+  std::map<DefId, std::pair<const TraitReference *, HIR::ImplBlock *>> mapper;\n+  for (auto &ref : a)\n+    {\n+      mapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n+    }\n+  for (auto &ref : b)\n+    {\n+      mapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n+    }\n+\n+  std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> union_set;\n+  for (auto it = mapper.begin (); it != mapper.end (); it++)\n+    {\n+      union_set.push_back ({it->second.first, it->second.second});\n+    }\n+  return union_set;\n+}\n+\n+bool\n+PathProbeType::is_reciever_generic () const\n+{\n+  const TyTy::BaseType *root = receiver->get_root ();\n+  bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+  bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  return receiver_is_type_param || receiver_is_dyn;\n+}\n+\n+// PathProbImplTrait\n+\n+PathProbeImplTrait::PathProbeImplTrait (const TyTy::BaseType *receiver,\n+\t\t\t\t\tconst HIR::PathIdentSegment &query,\n+\t\t\t\t\tconst TraitReference *trait_reference)\n+  : PathProbeType (receiver, query, UNKNOWN_DEFID),\n+    trait_reference (trait_reference)\n+{}\n+\n+std::set<PathProbeCandidate>\n+PathProbeImplTrait::Probe (const TyTy::BaseType *receiver,\n+\t\t\t   const HIR::PathIdentSegment &segment_name,\n+\t\t\t   const TraitReference *trait_reference)\n+{\n+  PathProbeImplTrait probe (receiver, segment_name, trait_reference);\n+  // iterate all impls for this trait and receiver\n+  // then search for possible candidates using base class behaviours\n+  probe.process_trait_impl_items_for_candidates ();\n+  return probe.candidates;\n+}\n+\n+void\n+PathProbeImplTrait::process_trait_impl_items_for_candidates ()\n+{\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      // just need to check if this is an impl block for this trait the next\n+      // function checks the receiver\n+      if (!impl->has_trait_ref ())\n+\treturn true;\n+\n+      TraitReference *resolved\n+\t= TraitResolver::Lookup (*(impl->get_trait_ref ().get ()));\n+      if (!trait_reference->is_equal (*resolved))\n+\treturn true;\n+\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "0bb3b9949574da87fe55652681ac89b4507c2a82", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 30, "deletions": 352, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -73,89 +73,37 @@ struct PathProbeCandidate\n     ImplItemCandidate impl;\n     TraitItemCandidate trait;\n \n-    Candidate (EnumItemCandidate enum_field) : enum_field (enum_field) {}\n-    Candidate (ImplItemCandidate impl) : impl (impl) {}\n-    Candidate (TraitItemCandidate trait) : trait (trait) {}\n+    Candidate (EnumItemCandidate enum_field);\n+    Candidate (ImplItemCandidate impl);\n+    Candidate (TraitItemCandidate trait);\n   } item;\n \n   PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n-\t\t      EnumItemCandidate enum_field)\n-    : type (type), ty (ty), locus (locus), item (enum_field)\n-  {}\n+\t\t      EnumItemCandidate enum_field);\n \n   PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n-\t\t      ImplItemCandidate impl)\n-    : type (type), ty (ty), locus (locus), item (impl)\n-  {}\n+\t\t      ImplItemCandidate impl);\n \n   PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n-\t\t      TraitItemCandidate trait)\n-    : type (type), ty (ty), locus (locus), item (trait)\n-  {}\n+\t\t      TraitItemCandidate trait);\n \n-  std::string as_string () const\n-  {\n-    return \"PathProbe candidate TODO - as_string\";\n-  }\n+  std::string as_string () const;\n \n-  bool is_enum_candidate () const { return type == ENUM_VARIANT; }\n+  bool is_enum_candidate () const;\n \n-  bool is_impl_candidate () const\n-  {\n-    return type == IMPL_CONST || type == IMPL_TYPE_ALIAS || type == IMPL_FUNC;\n-  }\n+  bool is_impl_candidate () const;\n \n-  bool is_trait_candidate () const\n-  {\n-    return type == TRAIT_ITEM_CONST || type == TRAIT_TYPE_ALIAS\n-\t   || type == TRAIT_FUNC;\n-  }\n+  bool is_trait_candidate () const;\n \n-  bool is_full_trait_item_candidate () const\n-  {\n-    return is_trait_candidate () && item.trait.impl == nullptr;\n-  }\n+  bool is_full_trait_item_candidate () const;\n \n-  static PathProbeCandidate get_error ()\n-  {\n-    return PathProbeCandidate (ERROR, nullptr, Location (),\n-\t\t\t       ImplItemCandidate{nullptr, nullptr});\n-  }\n+  static PathProbeCandidate get_error ();\n \n-  bool is_error () const { return type == ERROR; }\n+  bool is_error () const;\n \n-  DefId get_defid () const\n-  {\n-    switch (type)\n-      {\n-      case ENUM_VARIANT:\n-\treturn item.enum_field.variant->get_defid ();\n-\tbreak;\n-\n-      case IMPL_CONST:\n-      case IMPL_TYPE_ALIAS:\n-      case IMPL_FUNC:\n-\treturn item.impl.impl_item->get_impl_mappings ().get_defid ();\n-\tbreak;\n-\n-      case TRAIT_ITEM_CONST:\n-      case TRAIT_TYPE_ALIAS:\n-      case TRAIT_FUNC:\n-\treturn item.trait.item_ref->get_mappings ().get_defid ();\n-\tbreak;\n-\n-      case ERROR:\n-      default:\n-\treturn UNKNOWN_DEFID;\n-      }\n-\n-    return UNKNOWN_DEFID;\n-  }\n+  DefId get_defid () const;\n \n-  bool operator< (const PathProbeCandidate &c) const\n-  {\n-    return get_defid () < c.get_defid ();\n-  }\n+  bool operator< (const PathProbeCandidate &c) const;\n };\n \n class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n@@ -165,301 +113,41 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n \t bool probe_bounds, bool ignore_mandatory_trait_items,\n-\t DefId specific_trait_id = UNKNOWN_DEFID)\n-  {\n-    PathProbeType probe (receiver, segment_name, specific_trait_id);\n-    if (probe_impls)\n-      {\n-\tif (receiver->get_kind () == TyTy::TypeKind::ADT)\n-\t  {\n-\t    const TyTy::ADTType *adt\n-\t      = static_cast<const TyTy::ADTType *> (receiver);\n-\t    if (adt->is_enum ())\n-\t      probe.process_enum_item_for_candiates (adt);\n-\t  }\n-\n-\tprobe.process_impl_items_for_candidates ();\n-      }\n-\n-    if (!probe_bounds)\n-      return probe.candidates;\n-\n-    if (!probe.is_reciever_generic ())\n-      {\n-\tstd::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n-\t  = TypeBoundsProbe::Probe (receiver);\n-\tfor (auto &candidate : probed_bounds)\n-\t  {\n-\t    const TraitReference *trait_ref = candidate.first;\n-\t    if (specific_trait_id != UNKNOWN_DEFID)\n-\t      {\n-\t\tif (trait_ref->get_mappings ().get_defid ()\n-\t\t    != specific_trait_id)\n-\t\t  continue;\n-\t      }\n-\n-\t    HIR::ImplBlock *impl = candidate.second;\n-\t    probe.process_associated_trait_for_candidates (\n-\t      trait_ref, impl, ignore_mandatory_trait_items);\n-\t  }\n-      }\n-\n-    for (const TyTy::TypeBoundPredicate &predicate :\n-\t receiver->get_specified_bounds ())\n-      {\n-\tconst TraitReference *trait_ref = predicate.get ();\n-\tif (specific_trait_id != UNKNOWN_DEFID)\n-\t  {\n-\t    if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n-\t      continue;\n-\t  }\n-\n-\tprobe.process_predicate_for_candidates (predicate,\n-\t\t\t\t\t\tignore_mandatory_trait_items);\n-      }\n-\n-    return probe.candidates;\n-  }\n-\n-  void visit (HIR::TypeAlias &alias) override\n-  {\n-    Identifier name = alias.get_new_type_name ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = alias.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = query_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n-\t\t\t\t\t\t\t\t  current_impl};\n-\tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n-\t  alias.get_locus (), impl_item_candidate};\n-\tcandidates.insert (std::move (candidate));\n-      }\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    Identifier name = constant.get_identifier ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = constant.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = query_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n-\t\t\t\t\t\t\t\t  current_impl};\n-\tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_CONST, ty,\n-\t  constant.get_locus (), impl_item_candidate};\n-\tcandidates.insert (std::move (candidate));\n-      }\n-  }\n+\t DefId specific_trait_id = UNKNOWN_DEFID);\n \n-  void visit (HIR::Function &function) override\n-  {\n-    Identifier name = function.get_function_name ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = function.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = query_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n-\t\t\t\t\t\t\t\t  current_impl};\n-\tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_FUNC, ty,\n-\t  function.get_locus (), impl_item_candidate};\n-\tcandidates.insert (std::move (candidate));\n-      }\n-  }\n+  void visit (HIR::TypeAlias &alias) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::Function &function) override;\n \n protected:\n-  void process_enum_item_for_candiates (const TyTy::ADTType *adt)\n-  {\n-    if (specific_trait_id != UNKNOWN_DEFID)\n-      return;\n-\n-    TyTy::VariantDef *v;\n-    if (!adt->lookup_variant (search.as_string (), &v))\n-      return;\n-\n-    PathProbeCandidate::EnumItemCandidate enum_item_candidate{adt, v};\n-    PathProbeCandidate candidate{\n-      PathProbeCandidate::CandidateType::ENUM_VARIANT, receiver->clone (),\n-      mappings->lookup_location (adt->get_ty_ref ()), enum_item_candidate};\n-    candidates.insert (std::move (candidate));\n-  }\n+  void process_enum_item_for_candiates (const TyTy::ADTType *adt);\n \n-  void process_impl_items_for_candidates ()\n-  {\n-    mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n-\t\t\t\t       HIR::ImplBlock *impl) mutable -> bool {\n-      process_impl_item_candidate (id, item, impl);\n-      return true;\n-    });\n-  }\n+  void process_impl_items_for_candidates ();\n \n   void process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n \t\t\t\t    HIR::ImplBlock *impl);\n \n   void\n   process_associated_trait_for_candidates (const TraitReference *trait_ref,\n \t\t\t\t\t   HIR::ImplBlock *impl,\n-\t\t\t\t\t   bool ignore_mandatory_trait_items)\n-  {\n-    const TraitItemReference *trait_item_ref = nullptr;\n-    if (!trait_ref->lookup_trait_item (search.as_string (), &trait_item_ref))\n-      return;\n-\n-    bool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n-    if (ignore_mandatory_trait_items && trait_item_needs_implementation)\n-      return;\n-\n-    PathProbeCandidate::CandidateType candidate_type;\n-    switch (trait_item_ref->get_trait_item_type ())\n-      {\n-      case TraitItemReference::TraitItemType::FN:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::CONST:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::TYPE:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n-\tbreak;\n-\n-      case TraitItemReference::TraitItemType::ERROR:\n-      default:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n-\n-    TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n-\n-    // we can substitute the Self with the receiver here\n-    if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-      {\n-\tTyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n-\tTyTy::SubstitutionParamMapping *param = nullptr;\n-\tfor (auto &param_mapping : fn->get_substs ())\n-\t  {\n-\t    const HIR::TypeParam &type_param\n-\t      = param_mapping.get_generic_param ();\n-\t    if (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t      {\n-\t\tparam = &param_mapping;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\trust_assert (param != nullptr);\n-\n-\tstd::vector<TyTy::SubstitutionArg> mappings;\n-\tmappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n-\n-\tLocation locus; // FIXME\n-\tTyTy::SubstitutionArgumentMappings args (std::move (mappings), {},\n-\t\t\t\t\t\t locus);\n-\ttrait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n-      }\n-\n-    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n-\t\t\t\t\t\t\t\ttrait_item_ref,\n-\t\t\t\t\t\t\t\timpl};\n-\n-    PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n-\t\t\t\t trait_item_ref->get_locus (),\n-\t\t\t\t trait_item_candidate};\n-    candidates.insert (std::move (candidate));\n-  }\n+\t\t\t\t\t   bool ignore_mandatory_trait_items);\n \n   void\n   process_predicate_for_candidates (const TyTy::TypeBoundPredicate &predicate,\n-\t\t\t\t    bool ignore_mandatory_trait_items)\n-  {\n-    const TraitReference *trait_ref = predicate.get ();\n-\n-    TyTy::TypeBoundPredicateItem item\n-      = predicate.lookup_associated_item (search.as_string ());\n-    if (item.is_error ())\n-      return;\n-\n-    if (ignore_mandatory_trait_items && item.needs_implementation ())\n-      return;\n-\n-    const TraitItemReference *trait_item_ref = item.get_raw_item ();\n-    PathProbeCandidate::CandidateType candidate_type;\n-    switch (trait_item_ref->get_trait_item_type ())\n-      {\n-      case TraitItemReference::TraitItemType::FN:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::CONST:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::TYPE:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n-\tbreak;\n-\n-      case TraitItemReference::TraitItemType::ERROR:\n-      default:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n-\n-    TyTy::BaseType *trait_item_tyty = item.get_tyty_for_receiver (receiver);\n-    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n-\t\t\t\t\t\t\t\ttrait_item_ref,\n-\t\t\t\t\t\t\t\tnullptr};\n-    PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n-\t\t\t\t trait_item_ref->get_locus (),\n-\t\t\t\t trait_item_candidate};\n-    candidates.insert (std::move (candidate));\n-  }\n+\t\t\t\t    bool ignore_mandatory_trait_items);\n \n protected:\n   PathProbeType (const TyTy::BaseType *receiver,\n-\t\t const HIR::PathIdentSegment &query, DefId specific_trait_id)\n-    : TypeCheckBase (), receiver (receiver), search (query),\n-      current_impl (nullptr), specific_trait_id (specific_trait_id)\n-  {}\n+\t\t const HIR::PathIdentSegment &query, DefId specific_trait_id);\n \n   std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n   union_bounds (\n     const std::vector<std::pair</*const*/ TraitReference *, HIR::ImplBlock *>>\n       a,\n     const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> b)\n-    const\n-  {\n-    std::map<DefId, std::pair<const TraitReference *, HIR::ImplBlock *>> mapper;\n-    for (auto &ref : a)\n-      {\n-\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n-      }\n-    for (auto &ref : b)\n-      {\n-\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n-      }\n-\n-    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> union_set;\n-    for (auto it = mapper.begin (); it != mapper.end (); it++)\n-      {\n-\tunion_set.push_back ({it->second.first, it->second.second});\n-      }\n-    return union_set;\n-  }\n+    const;\n \n-  bool is_reciever_generic () const\n-  {\n-    const TyTy::BaseType *root = receiver->get_root ();\n-    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n-    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n-    return receiver_is_type_param || receiver_is_dyn;\n-  }\n+  bool is_reciever_generic () const;\n \n   const TyTy::BaseType *receiver;\n   const HIR::PathIdentSegment &search;\n@@ -489,24 +177,14 @@ class PathProbeImplTrait : public PathProbeType\n   static std::set<PathProbeCandidate>\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name,\n-\t const TraitReference *trait_reference)\n-  {\n-    PathProbeImplTrait probe (receiver, segment_name, trait_reference);\n-    // iterate all impls for this trait and receiver\n-    // then search for possible candidates using base class behaviours\n-    probe.process_trait_impl_items_for_candidates ();\n-    return probe.candidates;\n-  }\n+\t const TraitReference *trait_reference);\n \n private:\n-  void process_trait_impl_items_for_candidates ();\n-\n   PathProbeImplTrait (const TyTy::BaseType *receiver,\n \t\t      const HIR::PathIdentSegment &query,\n-\t\t      const TraitReference *trait_reference)\n-    : PathProbeType (receiver, query, UNKNOWN_DEFID),\n-      trait_reference (trait_reference)\n-  {}\n+\t\t      const TraitReference *trait_reference);\n+\n+  void process_trait_impl_items_for_candidates ();\n \n   const TraitReference *trait_reference;\n };"}, {"sha": "aec1dd56bccb88dec9ca108190c3e9d8ba94a6ce", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.h", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -496,9 +496,11 @@ class AssociatedImplTrait\n   HIR::ImplBlock *get_impl_block () { return impl; }\n \n   TyTy::BaseType *get_self () { return self; }\n+  const TyTy::BaseType *get_self () const { return self; }\n \n-  void setup_associated_types (const TyTy::BaseType *self,\n-\t\t\t       const TyTy::TypeBoundPredicate &bound);\n+  TyTy::BaseType *\n+  setup_associated_types (const TyTy::BaseType *self,\n+\t\t\t  const TyTy::TypeBoundPredicate &bound);\n \n   void reset_associated_types ();\n ", "previous_filename": "gcc/rust/typecheck/rust-hir-trait-ref.h"}, {"sha": "a7e073551f0c8b0c45bcaa3fc1fde77059b59828", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -22,6 +22,16 @@\n namespace Rust {\n namespace Resolver {\n \n+TraitItemReference\n+ResolveTraitItemToRef::Resolve (\n+  HIR::TraitItem &item, TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+{\n+  ResolveTraitItemToRef resolver (self, std::move (substitutions));\n+  item.accept_vis (resolver);\n+  return std::move (resolver.resolved);\n+}\n+\n void\n ResolveTraitItemToRef::visit (HIR::TraitItemType &type)\n {\n@@ -367,13 +377,10 @@ TraitItemReference::associated_type_reset () const\n   placeholder->clear_associated_type ();\n }\n \n-void\n+TyTy::BaseType *\n AssociatedImplTrait::setup_associated_types (\n   const TyTy::BaseType *self, const TyTy::TypeBoundPredicate &bound)\n {\n-  if (!bound.contains_associated_types ())\n-    return;\n-\n   // compute the constrained impl block generic arguments based on self and the\n   // higher ranked trait bound\n   TyTy::BaseType *receiver = self->clone ();\n@@ -476,6 +483,7 @@ AssociatedImplTrait::setup_associated_types (\n     TyTy::TyWithLocation (receiver), TyTy::TyWithLocation (impl_self_infer),\n     impl_predicate.get_locus ());\n   rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n+  TyTy::BaseType *self_result = result;\n \n   // unify the bounds arguments\n   std::vector<TyTy::BaseType *> hrtb_bound_arguments;\n@@ -490,7 +498,7 @@ AssociatedImplTrait::setup_associated_types (\n     }\n \n   if (impl_trait_predicate_args.size () != hrtb_bound_arguments.size ())\n-    return;\n+    return self_result;\n \n   for (size_t i = 0; i < impl_trait_predicate_args.size (); i++)\n     {\n@@ -544,6 +552,8 @@ AssociatedImplTrait::setup_associated_types (\n     resolved_trait_item->associated_type_set (substituted);\n   });\n   iter.go ();\n+\n+  return self_result;\n }\n \n void\n@@ -594,27 +604,5 @@ TraitItemReference::is_object_safe () const\n   return false;\n }\n \n-// rust-hir-path-probe.h\n-\n-void\n-PathProbeImplTrait::process_trait_impl_items_for_candidates ()\n-{\n-  mappings->iterate_impl_items (\n-    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n-      // just need to check if this is an impl block for this trait the next\n-      // function checks the receiver\n-      if (!impl->has_trait_ref ())\n-\treturn true;\n-\n-      TraitReference *resolved\n-\t= TraitResolver::Lookup (*(impl->get_trait_ref ().get ()));\n-      if (!trait_reference->is_equal (*resolved))\n-\treturn true;\n-\n-      process_impl_item_candidate (id, item, impl);\n-      return true;\n-    });\n-}\n-\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "39365e0f7577e1279bbac42ccff575044dfffce1", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -19,9 +19,7 @@\n #ifndef RUST_HIR_TRAIT_RESOLVE_H\n #define RUST_HIR_TRAIT_RESOLVE_H\n \n-#include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-trait-ref.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -32,12 +30,7 @@ class ResolveTraitItemToRef : public TypeCheckBase,\n public:\n   static TraitItemReference\n   Resolve (HIR::TraitItem &item, TyTy::BaseType *self,\n-\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-  {\n-    ResolveTraitItemToRef resolver (self, std::move (substitutions));\n-    item.accept_vis (resolver);\n-    return std::move (resolver.resolved);\n-  }\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions);\n \n   void visit (HIR::TraitItemType &type) override;\n "}, {"sha": "6a6313287febbbf6310dc3db642ebc2ce690c33a", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-implitem.h\"\n #include \"rust-coercion.h\"\n+#include \"rust-unify.h\"\n #include \"rust-casts.h\"\n \n namespace Rust {\n@@ -359,18 +360,8 @@ TypeCheckBase::unify_site (HirId id, TyTy::TyWithLocation lhs,\n   rust_debug (\"unify_site id={%u} expected={%s} expr={%s}\", id,\n \t      expected->debug_str ().c_str (), expr->debug_str ().c_str ());\n \n-  TyTy::BaseType *unified = expected->unify (expr);\n-  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n-    {\n-      RichLocation r (unify_locus);\n-      r.add_range (lhs.get_locus ());\n-      r.add_range (rhs.get_locus ());\n-      rust_error_at (r, \"expected %<%s%> got %<%s%>\",\n-\t\t     expected->get_name ().c_str (),\n-\t\t     expr->get_name ().c_str ());\n-    }\n-\n-  return unified;\n+  return UnifyRules::Resolve (lhs, rhs, unify_locus, true /*commit*/,\n+\t\t\t      true /*emit_error*/);\n }\n \n TyTy::BaseType *"}, {"sha": "1625eda373b69f10b9913974dc62d3fbbca54a7e", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -379,16 +379,36 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \n       if (associated_impl_block != nullptr)\n \t{\n-\t  // get the type of the parent Self\n-\t  HirId impl_ty_id\n-\t    = associated_impl_block->get_type ()->get_mappings ().get_hirid ();\n+\t  // associated types\n+\t  HirId impl_block_id\n+\t    = associated_impl_block->get_mappings ().get_hirid ();\n+\n+\t  AssociatedImplTrait *associated = nullptr;\n+\t  bool found_impl_trait\n+\t    = context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t     &associated);\n \t  TyTy::BaseType *impl_block_ty = nullptr;\n-\t  bool ok = query_type (impl_ty_id, &impl_block_ty);\n-\t  rust_assert (ok);\n+\t  if (found_impl_trait)\n+\t    {\n+\t      TyTy::TypeBoundPredicate predicate (*associated->get_trait (),\n+\t\t\t\t\t\t  seg.get_locus ());\n+\t      impl_block_ty\n+\t\t= associated->setup_associated_types (prev_segment, predicate);\n+\t    }\n+\t  else\n+\t    {\n+\t      // get the type of the parent Self\n+\t      HirId impl_ty_id = associated_impl_block->get_type ()\n+\t\t\t\t   ->get_mappings ()\n+\t\t\t\t   .get_hirid ();\n \n-\t  if (impl_block_ty->needs_generic_substitutions ())\n-\t    impl_block_ty\n-\t      = SubstMapper::InferSubst (impl_block_ty, seg.get_locus ());\n+\t      bool ok = query_type (impl_ty_id, &impl_block_ty);\n+\t      rust_assert (ok);\n+\n+\t      if (impl_block_ty->needs_generic_substitutions ())\n+\t\timpl_block_ty\n+\t\t  = SubstMapper::InferSubst (impl_block_ty, seg.get_locus ());\n+\t    }\n \n \t  prev_segment = unify_site (seg.get_mappings ().get_hirid (),\n \t\t\t\t     TyTy::TyWithLocation (prev_segment),"}, {"sha": "ee77497d1b2046ed2d7f68b5159afe2b243660a1", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 49, "deletions": 285, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -22,7 +22,7 @@\n #include \"rust-hir-full-decls.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-tyty.h\"\n-#include \"rust-hir-trait-ref.h\"\n+#include \"rust-hir-trait-reference.h\"\n #include \"rust-autoderef.h\"\n \n namespace Rust {\n@@ -38,37 +38,17 @@ class TypeCheckContextItem\n     TRAIT_ITEM,\n   };\n \n-  TypeCheckContextItem (HIR::Function *item)\n-    : type (ItemType::ITEM), item (item)\n-  {}\n+  TypeCheckContextItem (HIR::Function *item);\n+  TypeCheckContextItem (HIR::ImplBlock *impl_block, HIR::Function *item);\n+  TypeCheckContextItem (HIR::TraitItemFunc *trait_item);\n \n-  TypeCheckContextItem (HIR::ImplBlock *impl_block, HIR::Function *item)\n-    : type (ItemType::IMPL_ITEM), item (impl_block, item)\n-  {}\n+  ItemType get_type () const;\n \n-  TypeCheckContextItem (HIR::TraitItemFunc *trait_item)\n-    : type (ItemType::TRAIT_ITEM), item (trait_item)\n-  {}\n+  HIR::Function *get_item ();\n \n-  ItemType get_type () const { return type; }\n+  std::pair<HIR::ImplBlock *, HIR::Function *> &get_impl_item ();\n \n-  HIR::Function *get_item ()\n-  {\n-    rust_assert (get_type () == ItemType::ITEM);\n-    return item.item;\n-  }\n-\n-  std::pair<HIR::ImplBlock *, HIR::Function *> &get_impl_item ()\n-  {\n-    rust_assert (get_type () == ItemType::IMPL_ITEM);\n-    return item.impl_item;\n-  };\n-\n-  HIR::TraitItemFunc *get_trait_item ()\n-  {\n-    rust_assert (get_type () == ItemType::TRAIT_ITEM);\n-    return item.trait_item;\n-  }\n+  HIR::TraitItemFunc *get_trait_item ();\n \n   TyTy::FnType *get_context_type ();\n \n@@ -79,13 +59,9 @@ class TypeCheckContextItem\n     std::pair<HIR::ImplBlock *, HIR::Function *> impl_item;\n     HIR::TraitItemFunc *trait_item;\n \n-    Item (HIR::Function *item) : item (item) {}\n-\n-    Item (HIR::ImplBlock *impl_block, HIR::Function *item)\n-      : impl_item ({impl_block, item})\n-    {}\n-\n-    Item (HIR::TraitItemFunc *trait_item) : trait_item (trait_item) {}\n+    Item (HIR::Function *item);\n+    Item (HIR::ImplBlock *impl_block, HIR::Function *item);\n+    Item (HIR::TraitItemFunc *trait_item);\n   };\n \n   ItemType type;\n@@ -118,283 +94,71 @@ class TypeCheckContext\n   void push_return_type (TypeCheckContextItem item,\n \t\t\t TyTy::BaseType *return_type);\n   void pop_return_type ();\n+  void iterate (std::function<bool (HirId, TyTy::BaseType *)> cb);\n \n-  void iterate (std::function<bool (HirId, TyTy::BaseType *)> cb)\n-  {\n-    for (auto it = resolved.begin (); it != resolved.end (); it++)\n-      {\n-\tif (!cb (it->first, it->second))\n-\t  return;\n-      }\n-  }\n-\n-  bool have_loop_context () const { return !loop_type_stack.empty (); }\n-\n-  void push_new_loop_context (HirId id, Location locus)\n-  {\n-    TyTy::BaseType *infer_var\n-      = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL,\n-\t\t\t     locus);\n-    loop_type_stack.push_back (infer_var);\n-  }\n-\n-  void push_new_while_loop_context (HirId id)\n-  {\n-    TyTy::BaseType *infer_var = new TyTy::ErrorType (id);\n-    loop_type_stack.push_back (infer_var);\n-  }\n-\n-  TyTy::BaseType *peek_loop_context () { return loop_type_stack.back (); }\n-\n-  TyTy::BaseType *pop_loop_context ()\n-  {\n-    auto back = peek_loop_context ();\n-    loop_type_stack.pop_back ();\n-    return back;\n-  }\n-\n-  void swap_head_loop_context (TyTy::BaseType *val)\n-  {\n-    loop_type_stack.pop_back ();\n-    loop_type_stack.push_back (val);\n-  }\n-\n-  void insert_trait_reference (DefId id, TraitReference &&ref)\n-  {\n-    rust_assert (trait_context.find (id) == trait_context.end ());\n-    trait_context.emplace (id, std::move (ref));\n-  }\n-\n-  bool lookup_trait_reference (DefId id, TraitReference **ref)\n-  {\n-    auto it = trait_context.find (id);\n-    if (it == trait_context.end ())\n-      return false;\n+  bool have_loop_context () const;\n+  void push_new_loop_context (HirId id, Location locus);\n+  void push_new_while_loop_context (HirId id);\n+  TyTy::BaseType *peek_loop_context ();\n+  TyTy::BaseType *pop_loop_context ();\n \n-    *ref = &it->second;\n-    return true;\n-  }\n-\n-  void insert_receiver (HirId id, TyTy::BaseType *t)\n-  {\n-    receiver_context[id] = t;\n-  }\n+  void swap_head_loop_context (TyTy::BaseType *val);\n \n-  bool lookup_receiver (HirId id, TyTy::BaseType **ref)\n-  {\n-    auto it = receiver_context.find (id);\n-    if (it == receiver_context.end ())\n-      return false;\n+  void insert_trait_reference (DefId id, TraitReference &&ref);\n+  bool lookup_trait_reference (DefId id, TraitReference **ref);\n \n-    *ref = it->second;\n-    return true;\n-  }\n+  void insert_receiver (HirId id, TyTy::BaseType *t);\n+  bool lookup_receiver (HirId id, TyTy::BaseType **ref);\n \n-  void insert_associated_trait_impl (HirId id, AssociatedImplTrait &&associated)\n-  {\n-    rust_assert (associated_impl_traits.find (id)\n-\t\t == associated_impl_traits.end ());\n-    associated_impl_traits.emplace (id, std::move (associated));\n-  }\n+  void insert_associated_trait_impl (HirId id,\n+\t\t\t\t     AssociatedImplTrait &&associated);\n+  bool lookup_associated_trait_impl (HirId id,\n+\t\t\t\t     AssociatedImplTrait **associated);\n \n-  bool lookup_associated_trait_impl (HirId id, AssociatedImplTrait **associated)\n-  {\n-    auto it = associated_impl_traits.find (id);\n-    if (it == associated_impl_traits.end ())\n-      return false;\n-\n-    *associated = &it->second;\n-    return true;\n-  }\n-\n-  void insert_associated_type_mapping (HirId id, HirId mapping)\n-  {\n-    associated_type_mappings[id] = mapping;\n-  }\n-\n-  void clear_associated_type_mapping (HirId id)\n-  {\n-    auto it = associated_type_mappings.find (id);\n-    if (it != associated_type_mappings.end ())\n-      associated_type_mappings.erase (it);\n-  }\n+  void insert_associated_type_mapping (HirId id, HirId mapping);\n+  void clear_associated_type_mapping (HirId id);\n \n   // lookup any associated type mappings, the out parameter of mapping is\n   // allowed to be nullptr which allows this interface to do a simple does exist\n   // check\n-  bool lookup_associated_type_mapping (HirId id, HirId *mapping)\n-  {\n-    auto it = associated_type_mappings.find (id);\n-    if (it == associated_type_mappings.end ())\n-      return false;\n-\n-    if (mapping != nullptr)\n-      *mapping = it->second;\n-\n-    return true;\n-  }\n+  bool lookup_associated_type_mapping (HirId id, HirId *mapping);\n \n   void insert_associated_impl_mapping (HirId trait_id,\n \t\t\t\t       const TyTy::BaseType *impl_type,\n-\t\t\t\t       HirId impl_id)\n-  {\n-    auto it = associated_traits_to_impls.find (trait_id);\n-    if (it == associated_traits_to_impls.end ())\n-      {\n-\tassociated_traits_to_impls[trait_id] = {};\n-      }\n-\n-    associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n-  }\n-\n+\t\t\t\t       HirId impl_id);\n   bool lookup_associated_impl_mapping_for_self (HirId trait_id,\n \t\t\t\t\t\tconst TyTy::BaseType *self,\n-\t\t\t\t\t\tHirId *mapping)\n-  {\n-    auto it = associated_traits_to_impls.find (trait_id);\n-    if (it == associated_traits_to_impls.end ())\n-      return false;\n-\n-    for (auto &item : it->second)\n-      {\n-\tif (item.first->can_eq (self, false))\n-\t  {\n-\t    *mapping = item.second;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+\t\t\t\t\t\tHirId *mapping);\n \n   void insert_autoderef_mappings (HirId id,\n-\t\t\t\t  std::vector<Adjustment> &&adjustments)\n-  {\n-    rust_assert (autoderef_mappings.find (id) == autoderef_mappings.end ());\n-    autoderef_mappings.emplace (id, std::move (adjustments));\n-  }\n-\n+\t\t\t\t  std::vector<Adjustment> &&adjustments);\n   bool lookup_autoderef_mappings (HirId id,\n-\t\t\t\t  std::vector<Adjustment> **adjustments)\n-  {\n-    auto it = autoderef_mappings.find (id);\n-    if (it == autoderef_mappings.end ())\n-      return false;\n-\n-    *adjustments = &it->second;\n-    return true;\n-  }\n+\t\t\t\t  std::vector<Adjustment> **adjustments);\n \n   void insert_cast_autoderef_mappings (HirId id,\n-\t\t\t\t       std::vector<Adjustment> &&adjustments)\n-  {\n-    rust_assert (cast_autoderef_mappings.find (id)\n-\t\t == cast_autoderef_mappings.end ());\n-    cast_autoderef_mappings.emplace (id, std::move (adjustments));\n-  }\n-\n+\t\t\t\t       std::vector<Adjustment> &&adjustments);\n   bool lookup_cast_autoderef_mappings (HirId id,\n-\t\t\t\t       std::vector<Adjustment> **adjustments)\n-  {\n-    auto it = cast_autoderef_mappings.find (id);\n-    if (it == cast_autoderef_mappings.end ())\n-      return false;\n+\t\t\t\t       std::vector<Adjustment> **adjustments);\n \n-    *adjustments = &it->second;\n-    return true;\n-  }\n+  void insert_variant_definition (HirId id, HirId variant);\n+  bool lookup_variant_definition (HirId id, HirId *variant);\n \n-  void insert_variant_definition (HirId id, HirId variant)\n-  {\n-    auto it = variants.find (id);\n-    rust_assert (it == variants.end ());\n+  void insert_operator_overload (HirId id, TyTy::FnType *call_site);\n+  bool lookup_operator_overload (HirId id, TyTy::FnType **call);\n \n-    variants[id] = variant;\n-  }\n+  void insert_unconstrained_check_marker (HirId id, bool status);\n+  bool have_checked_for_unconstrained (HirId id, bool *result);\n \n-  bool lookup_variant_definition (HirId id, HirId *variant)\n-  {\n-    auto it = variants.find (id);\n-    if (it == variants.end ())\n-      return false;\n+  void insert_resolved_predicate (HirId id, TyTy::TypeBoundPredicate predicate);\n+  bool lookup_predicate (HirId id, TyTy::TypeBoundPredicate *result);\n \n-    *variant = it->second;\n-    return true;\n-  }\n-\n-  void insert_operator_overload (HirId id, TyTy::FnType *call_site)\n-  {\n-    auto it = operator_overloads.find (id);\n-    rust_assert (it == operator_overloads.end ());\n-\n-    operator_overloads[id] = call_site;\n-  }\n-\n-  bool lookup_operator_overload (HirId id, TyTy::FnType **call)\n-  {\n-    auto it = operator_overloads.find (id);\n-    if (it == operator_overloads.end ())\n-      return false;\n-\n-    *call = it->second;\n-    return true;\n-  }\n+  void insert_query (HirId id);\n+  void query_completed (HirId id);\n+  bool query_in_progress (HirId id) const;\n \n-  void insert_unconstrained_check_marker (HirId id, bool status)\n-  {\n-    unconstrained[id] = status;\n-  }\n-\n-  bool have_checked_for_unconstrained (HirId id, bool *result)\n-  {\n-    auto it = unconstrained.find (id);\n-    bool found = it != unconstrained.end ();\n-    if (!found)\n-      return false;\n-\n-    *result = it->second;\n-    return true;\n-  }\n-\n-  void insert_resolved_predicate (HirId id, TyTy::TypeBoundPredicate predicate)\n-  {\n-    auto it = predicates.find (id);\n-    rust_assert (it == predicates.end ());\n-\n-    predicates.insert ({id, predicate});\n-  }\n-\n-  bool lookup_predicate (HirId id, TyTy::TypeBoundPredicate *result)\n-  {\n-    auto it = predicates.find (id);\n-    bool found = it != predicates.end ();\n-    if (!found)\n-      return false;\n-\n-    *result = it->second;\n-    return true;\n-  }\n-\n-  void insert_query (HirId id) { querys_in_progress.insert (id); }\n-\n-  void query_completed (HirId id) { querys_in_progress.erase (id); }\n-\n-  bool query_in_progress (HirId id) const\n-  {\n-    return querys_in_progress.find (id) != querys_in_progress.end ();\n-  }\n-\n-  void insert_trait_query (DefId id) { trait_queries_in_progress.insert (id); }\n-\n-  void trait_query_completed (DefId id)\n-  {\n-    trait_queries_in_progress.erase (id);\n-  }\n-\n-  bool trait_query_in_progress (DefId id) const\n-  {\n-    return trait_queries_in_progress.find (id)\n-\t   != trait_queries_in_progress.end ();\n-  }\n+  void insert_trait_query (DefId id);\n+  void trait_query_completed (DefId id);\n+  bool trait_query_in_progress (DefId id) const;\n \n private:\n   TypeCheckContext ();"}, {"sha": "9ccb80bf2a56d9f6486911271af6c29a073dbd5a", "filename": "gcc/rust/typecheck/rust-substitution-mapper.cc", "status": "modified", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -22,6 +22,116 @@\n namespace Rust {\n namespace Resolver {\n \n+SubstMapper::SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n+  : resolved (new TyTy::ErrorType (ref)), generics (generics), locus (locus)\n+{}\n+\n+TyTy::BaseType *\n+SubstMapper::Resolve (TyTy::BaseType *base, Location locus,\n+\t\t      HIR::GenericArgs *generics)\n+{\n+  SubstMapper mapper (base->get_ref (), generics, locus);\n+  base->accept_vis (mapper);\n+  rust_assert (mapper.resolved != nullptr);\n+  return mapper.resolved;\n+}\n+\n+TyTy::BaseType *\n+SubstMapper::InferSubst (TyTy::BaseType *base, Location locus)\n+{\n+  return SubstMapper::Resolve (base, locus, nullptr);\n+}\n+\n+bool\n+SubstMapper::have_generic_args () const\n+{\n+  return generics != nullptr;\n+}\n+\n+void\n+SubstMapper::visit (TyTy::FnType &type)\n+{\n+  TyTy::FnType *concrete = nullptr;\n+  if (!have_generic_args ())\n+    {\n+      TyTy::BaseType *substs = type.infer_substitions (locus);\n+      rust_assert (substs->get_kind () == TyTy::TypeKind::FNDEF);\n+      concrete = static_cast<TyTy::FnType *> (substs);\n+    }\n+  else\n+    {\n+      TyTy::SubstitutionArgumentMappings mappings\n+\t= type.get_mappings_from_generic_args (*generics);\n+      if (mappings.is_error ())\n+\treturn;\n+\n+      concrete = type.handle_substitions (mappings);\n+    }\n+\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+void\n+SubstMapper::visit (TyTy::ADTType &type)\n+{\n+  TyTy::ADTType *concrete = nullptr;\n+  if (!have_generic_args ())\n+    {\n+      TyTy::BaseType *substs = type.infer_substitions (locus);\n+      rust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+      concrete = static_cast<TyTy::ADTType *> (substs);\n+    }\n+  else\n+    {\n+      TyTy::SubstitutionArgumentMappings mappings\n+\t= type.get_mappings_from_generic_args (*generics);\n+      if (mappings.is_error ())\n+\treturn;\n+\n+      concrete = type.handle_substitions (mappings);\n+    }\n+\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+void\n+SubstMapper::visit (TyTy::PlaceholderType &type)\n+{\n+  rust_assert (type.can_resolve ());\n+  resolved = SubstMapper::Resolve (type.resolve (), locus, generics);\n+}\n+\n+void\n+SubstMapper::visit (TyTy::ProjectionType &type)\n+{\n+  TyTy::ProjectionType *concrete = nullptr;\n+  if (!have_generic_args ())\n+    {\n+      TyTy::BaseType *substs = type.infer_substitions (locus);\n+      rust_assert (substs->get_kind () == TyTy::TypeKind::PROJECTION);\n+      concrete = static_cast<TyTy::ProjectionType *> (substs);\n+    }\n+  else\n+    {\n+      TyTy::SubstitutionArgumentMappings mappings\n+\t= type.get_mappings_from_generic_args (*generics);\n+      if (mappings.is_error ())\n+\treturn;\n+\n+      concrete = type.handle_substitions (mappings);\n+    }\n+\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+SubstMapperInternal::SubstMapperInternal (\n+  HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n+  : resolved (new TyTy::ErrorType (ref)), mappings (mappings)\n+{}\n+\n TyTy::BaseType *\n SubstMapperInternal::Resolve (TyTy::BaseType *base,\n \t\t\t      TyTy::SubstitutionArgumentMappings &mappings)\n@@ -73,5 +183,238 @@ SubstMapperInternal::mappings_are_bound (\n   return false;\n }\n \n+void\n+SubstMapperInternal::visit (TyTy::FnType &type)\n+{\n+  TyTy::SubstitutionArgumentMappings adjusted\n+    = type.adjust_mappings_for_this (mappings);\n+  if (adjusted.is_error ())\n+    return;\n+\n+  TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ADTType &type)\n+{\n+  TyTy::SubstitutionArgumentMappings adjusted\n+    = type.adjust_mappings_for_this (mappings);\n+  if (adjusted.is_error ())\n+    return;\n+\n+  TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+  if (concrete != nullptr)\n+    resolved = concrete;\n+}\n+\n+// these don't support generic arguments but might contain a type param\n+void\n+SubstMapperInternal::visit (TyTy::TupleType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ReferenceType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::PointerType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ParamType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::PlaceholderType &type)\n+{\n+  rust_assert (type.can_resolve ());\n+  if (mappings.trait_item_mode ())\n+    {\n+      resolved = type.resolve ();\n+    }\n+  else\n+    {\n+      resolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n+    }\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ProjectionType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ClosureType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::ArrayType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+void\n+SubstMapperInternal::visit (TyTy::SliceType &type)\n+{\n+  resolved = type.handle_substitions (mappings);\n+}\n+\n+// nothing to do for these\n+void\n+SubstMapperInternal::visit (TyTy::InferType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::FnPtr &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::BoolType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::IntType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::UintType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::FloatType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::USizeType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::ISizeType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::ErrorType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::CharType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::StrType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::NeverType &type)\n+{\n+  resolved = type.clone ();\n+}\n+void\n+SubstMapperInternal::visit (TyTy::DynamicObjectType &type)\n+{\n+  resolved = type.clone ();\n+}\n+\n+// SubstMapperFromExisting\n+\n+SubstMapperFromExisting::SubstMapperFromExisting (TyTy::BaseType *concrete,\n+\t\t\t\t\t\t  TyTy::BaseType *receiver)\n+  : concrete (concrete), receiver (receiver), resolved (nullptr)\n+{}\n+\n+TyTy::BaseType *\n+SubstMapperFromExisting::Resolve (TyTy::BaseType *concrete,\n+\t\t\t\t  TyTy::BaseType *receiver)\n+{\n+  rust_assert (concrete->get_kind () == receiver->get_kind ());\n+\n+  SubstMapperFromExisting mapper (concrete, receiver);\n+  concrete->accept_vis (mapper);\n+  return mapper.resolved;\n+}\n+\n+void\n+SubstMapperFromExisting::visit (TyTy::FnType &type)\n+{\n+  rust_assert (type.was_substituted ());\n+\n+  TyTy::FnType *to_sub = static_cast<TyTy::FnType *> (receiver);\n+  resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+}\n+\n+void\n+SubstMapperFromExisting::visit (TyTy::ADTType &type)\n+{\n+  rust_assert (type.was_substituted ());\n+\n+  TyTy::ADTType *to_sub = static_cast<TyTy::ADTType *> (receiver);\n+  resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+}\n+\n+void\n+SubstMapperFromExisting::visit (TyTy::ClosureType &type)\n+{\n+  rust_assert (type.was_substituted ());\n+\n+  TyTy::ClosureType *to_sub = static_cast<TyTy::ClosureType *> (receiver);\n+  resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+}\n+\n+// GetUsedSubstArgs\n+\n+GetUsedSubstArgs::GetUsedSubstArgs ()\n+  : args (TyTy::SubstitutionArgumentMappings::error ())\n+{}\n+\n+TyTy::SubstitutionArgumentMappings\n+GetUsedSubstArgs::From (const TyTy::BaseType *from)\n+{\n+  GetUsedSubstArgs mapper;\n+  from->accept_vis (mapper);\n+  return mapper.args;\n+}\n+\n+void\n+GetUsedSubstArgs::visit (const TyTy::FnType &type)\n+{\n+  args = type.get_substitution_arguments ();\n+}\n+\n+void\n+GetUsedSubstArgs::visit (const TyTy::ADTType &type)\n+{\n+  args = type.get_substitution_arguments ();\n+}\n+\n+void\n+GetUsedSubstArgs::visit (const TyTy::ClosureType &type)\n+{\n+  args = type.get_substitution_arguments ();\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "047034ef0e2fa9e09507a61910228b40a691c41e", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 43, "deletions": 243, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -29,95 +29,16 @@ class SubstMapper : public TyTy::TyVisitor\n {\n public:\n   static TyTy::BaseType *Resolve (TyTy::BaseType *base, Location locus,\n-\t\t\t\t  HIR::GenericArgs *generics = nullptr)\n-  {\n-    SubstMapper mapper (base->get_ref (), generics, locus);\n-    base->accept_vis (mapper);\n-    rust_assert (mapper.resolved != nullptr);\n-    return mapper.resolved;\n-  }\n+\t\t\t\t  HIR::GenericArgs *generics = nullptr);\n \n-  static TyTy::BaseType *InferSubst (TyTy::BaseType *base, Location locus)\n-  {\n-    return SubstMapper::Resolve (base, locus, nullptr);\n-  }\n+  static TyTy::BaseType *InferSubst (TyTy::BaseType *base, Location locus);\n \n-  bool have_generic_args () const { return generics != nullptr; }\n+  bool have_generic_args () const;\n \n-  void visit (TyTy::FnType &type) override\n-  {\n-    TyTy::FnType *concrete = nullptr;\n-    if (!have_generic_args ())\n-      {\n-\tTyTy::BaseType *substs = type.infer_substitions (locus);\n-\trust_assert (substs->get_kind () == TyTy::TypeKind::FNDEF);\n-\tconcrete = static_cast<TyTy::FnType *> (substs);\n-      }\n-    else\n-      {\n-\tTyTy::SubstitutionArgumentMappings mappings\n-\t  = type.get_mappings_from_generic_args (*generics);\n-\tif (mappings.is_error ())\n-\t  return;\n-\n-\tconcrete = type.handle_substitions (mappings);\n-      }\n-\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  void visit (TyTy::ADTType &type) override\n-  {\n-    TyTy::ADTType *concrete = nullptr;\n-    if (!have_generic_args ())\n-      {\n-\tTyTy::BaseType *substs = type.infer_substitions (locus);\n-\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n-\tconcrete = static_cast<TyTy::ADTType *> (substs);\n-      }\n-    else\n-      {\n-\tTyTy::SubstitutionArgumentMappings mappings\n-\t  = type.get_mappings_from_generic_args (*generics);\n-\tif (mappings.is_error ())\n-\t  return;\n-\n-\tconcrete = type.handle_substitions (mappings);\n-      }\n-\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  void visit (TyTy::PlaceholderType &type) override\n-  {\n-    rust_assert (type.can_resolve ());\n-    resolved = SubstMapper::Resolve (type.resolve (), locus, generics);\n-  }\n-\n-  void visit (TyTy::ProjectionType &type) override\n-  {\n-    TyTy::ProjectionType *concrete = nullptr;\n-    if (!have_generic_args ())\n-      {\n-\tTyTy::BaseType *substs = type.infer_substitions (locus);\n-\trust_assert (substs->get_kind () == TyTy::TypeKind::PROJECTION);\n-\tconcrete = static_cast<TyTy::ProjectionType *> (substs);\n-      }\n-    else\n-      {\n-\tTyTy::SubstitutionArgumentMappings mappings\n-\t  = type.get_mappings_from_generic_args (*generics);\n-\tif (mappings.is_error ())\n-\t  return;\n-\n-\tconcrete = type.handle_substitions (mappings);\n-      }\n-\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n+  void visit (TyTy::FnType &type) override;\n+  void visit (TyTy::ADTType &type) override;\n+  void visit (TyTy::PlaceholderType &type) override;\n+  void visit (TyTy::ProjectionType &type) override;\n \n   // nothing to do for these\n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n@@ -142,9 +63,7 @@ class SubstMapper : public TyTy::TyVisitor\n   void visit (TyTy::ClosureType &) override { gcc_unreachable (); }\n \n private:\n-  SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n-    : resolved (new TyTy::ErrorType (ref)), generics (generics), locus (locus)\n-  {}\n+  SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus);\n \n   TyTy::BaseType *resolved;\n   HIR::GenericArgs *generics;\n@@ -160,106 +79,33 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   static bool mappings_are_bound (TyTy::BaseType *ty,\n \t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n \n-  void visit (TyTy::FnType &type) override\n-  {\n-    TyTy::SubstitutionArgumentMappings adjusted\n-      = type.adjust_mappings_for_this (mappings);\n-    if (adjusted.is_error ())\n-      return;\n-\n-    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  void visit (TyTy::ADTType &type) override\n-  {\n-    TyTy::SubstitutionArgumentMappings adjusted\n-      = type.adjust_mappings_for_this (mappings);\n-    if (adjusted.is_error ())\n-      return;\n-\n-    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n-    if (concrete != nullptr)\n-      resolved = concrete;\n-  }\n-\n-  // these don't support generic arguments but might contain a type param\n-  void visit (TyTy::TupleType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ReferenceType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::PointerType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ParamType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::PlaceholderType &type) override\n-  {\n-    rust_assert (type.can_resolve ());\n-    if (mappings.trait_item_mode ())\n-      {\n-\tresolved = type.resolve ();\n-      }\n-    else\n-      {\n-\tresolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n-      }\n-  }\n-\n-  void visit (TyTy::ProjectionType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ClosureType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::ArrayType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  void visit (TyTy::SliceType &type) override\n-  {\n-    resolved = type.handle_substitions (mappings);\n-  }\n-\n-  // nothing to do for these\n-  void visit (TyTy::InferType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::FnPtr &type) override { resolved = type.clone (); }\n-  void visit (TyTy::BoolType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::IntType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::UintType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::FloatType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::USizeType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::ISizeType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::ErrorType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::CharType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::StrType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::NeverType &type) override { resolved = type.clone (); }\n-  void visit (TyTy::DynamicObjectType &type) override\n-  {\n-    resolved = type.clone ();\n-  }\n+  void visit (TyTy::FnType &type) override;\n+  void visit (TyTy::ADTType &type) override;\n+  void visit (TyTy::TupleType &type) override;\n+  void visit (TyTy::ReferenceType &type) override;\n+  void visit (TyTy::PointerType &type) override;\n+  void visit (TyTy::ParamType &type) override;\n+  void visit (TyTy::PlaceholderType &type) override;\n+  void visit (TyTy::ProjectionType &type) override;\n+  void visit (TyTy::ClosureType &type) override;\n+  void visit (TyTy::ArrayType &type) override;\n+  void visit (TyTy::SliceType &type) override;\n+  void visit (TyTy::InferType &type) override;\n+  void visit (TyTy::FnPtr &type) override;\n+  void visit (TyTy::BoolType &type) override;\n+  void visit (TyTy::IntType &type) override;\n+  void visit (TyTy::UintType &type) override;\n+  void visit (TyTy::FloatType &type) override;\n+  void visit (TyTy::USizeType &type) override;\n+  void visit (TyTy::ISizeType &type) override;\n+  void visit (TyTy::ErrorType &type) override;\n+  void visit (TyTy::CharType &type) override;\n+  void visit (TyTy::StrType &type) override;\n+  void visit (TyTy::NeverType &type) override;\n+  void visit (TyTy::DynamicObjectType &type) override;\n \n private:\n-  SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n-    : resolved (new TyTy::ErrorType (ref)), mappings (mappings)\n-  {}\n+  SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings);\n \n   TyTy::BaseType *resolved;\n   TyTy::SubstitutionArgumentMappings &mappings;\n@@ -269,38 +115,11 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n {\n public:\n   static TyTy::BaseType *Resolve (TyTy::BaseType *concrete,\n-\t\t\t\t  TyTy::BaseType *receiver)\n-  {\n-    rust_assert (concrete->get_kind () == receiver->get_kind ());\n-\n-    SubstMapperFromExisting mapper (concrete, receiver);\n-    concrete->accept_vis (mapper);\n-    return mapper.resolved;\n-  }\n+\t\t\t\t  TyTy::BaseType *receiver);\n \n-  void visit (TyTy::FnType &type) override\n-  {\n-    rust_assert (type.was_substituted ());\n-\n-    TyTy::FnType *to_sub = static_cast<TyTy::FnType *> (receiver);\n-    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n-  }\n-\n-  void visit (TyTy::ADTType &type) override\n-  {\n-    rust_assert (type.was_substituted ());\n-\n-    TyTy::ADTType *to_sub = static_cast<TyTy::ADTType *> (receiver);\n-    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n-  }\n-\n-  void visit (TyTy::ClosureType &type) override\n-  {\n-    rust_assert (type.was_substituted ());\n-\n-    TyTy::ClosureType *to_sub = static_cast<TyTy::ClosureType *> (receiver);\n-    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n-  }\n+  void visit (TyTy::FnType &type) override;\n+  void visit (TyTy::ADTType &type) override;\n+  void visit (TyTy::ClosureType &type) override;\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n   void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n@@ -325,40 +144,21 @@ class SubstMapperFromExisting : public TyTy::TyVisitor\n   void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n \n private:\n-  SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver)\n-    : concrete (concrete), receiver (receiver), resolved (nullptr)\n-  {}\n+  SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver);\n \n   TyTy::BaseType *concrete;\n   TyTy::BaseType *receiver;\n-\n   TyTy::BaseType *resolved;\n };\n \n class GetUsedSubstArgs : public TyTy::TyConstVisitor\n {\n public:\n-  static TyTy::SubstitutionArgumentMappings From (const TyTy::BaseType *from)\n-  {\n-    GetUsedSubstArgs mapper;\n-    from->accept_vis (mapper);\n-    return mapper.args;\n-  }\n-\n-  void visit (const TyTy::FnType &type) override\n-  {\n-    args = type.get_substitution_arguments ();\n-  }\n-\n-  void visit (const TyTy::ADTType &type) override\n-  {\n-    args = type.get_substitution_arguments ();\n-  }\n+  static TyTy::SubstitutionArgumentMappings From (const TyTy::BaseType *from);\n \n-  void visit (const TyTy::ClosureType &type) override\n-  {\n-    args = type.get_substitution_arguments ();\n-  }\n+  void visit (const TyTy::FnType &type) override;\n+  void visit (const TyTy::ADTType &type) override;\n+  void visit (const TyTy::ClosureType &type) override;\n \n   void visit (const TyTy::InferType &) override {}\n   void visit (const TyTy::TupleType &) override {}\n@@ -383,7 +183,7 @@ class GetUsedSubstArgs : public TyTy::TyConstVisitor\n   void visit (const TyTy::DynamicObjectType &) override {}\n \n private:\n-  GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}\n+  GetUsedSubstArgs ();\n \n   TyTy::SubstitutionArgumentMappings args;\n };"}, {"sha": "34b60b37644722db9f89afe28e44949c30419b1f", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a9a9e949d7660ae7fc7cd4642f668bf438c970/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a9a9e949d7660ae7fc7cd4642f668bf438c970/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=47a9a9e949d7660ae7fc7cd4642f668bf438c970", "patch": "@@ -1,190 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include \"rust-hir-type-check.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-TypeCheckContext *\n-TypeCheckContext::get ()\n-{\n-  static TypeCheckContext *instance;\n-  if (instance == nullptr)\n-    instance = new TypeCheckContext ();\n-\n-  return instance;\n-}\n-\n-TypeCheckContext::TypeCheckContext () {}\n-\n-TypeCheckContext::~TypeCheckContext () {}\n-\n-bool\n-TypeCheckContext::lookup_builtin (NodeId id, TyTy::BaseType **type)\n-{\n-  auto ref_it = node_id_refs.find (id);\n-  if (ref_it == node_id_refs.end ())\n-    return false;\n-\n-  auto it = resolved.find (ref_it->second);\n-  if (it == resolved.end ())\n-    return false;\n-\n-  *type = it->second;\n-  return true;\n-}\n-\n-bool\n-TypeCheckContext::lookup_builtin (std::string name, TyTy::BaseType **type)\n-{\n-  for (auto &builtin : builtins)\n-    {\n-      if (name.compare (builtin->as_string ()) == 0)\n-\t{\n-\t  *type = builtin.get ();\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-void\n-TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::BaseType *type)\n-{\n-  node_id_refs[ref] = id;\n-  resolved[id] = type;\n-  builtins.push_back (std::unique_ptr<TyTy::BaseType> (type));\n-}\n-\n-void\n-TypeCheckContext::insert_type (const Analysis::NodeMapping &mappings,\n-\t\t\t       TyTy::BaseType *type)\n-{\n-  rust_assert (type != nullptr);\n-  NodeId ref = mappings.get_nodeid ();\n-  HirId id = mappings.get_hirid ();\n-  node_id_refs[ref] = id;\n-  resolved[id] = type;\n-}\n-\n-void\n-TypeCheckContext::insert_implicit_type (TyTy::BaseType *type)\n-{\n-  rust_assert (type != nullptr);\n-  resolved[type->get_ref ()] = type;\n-}\n-\n-void\n-TypeCheckContext::insert_implicit_type (HirId id, TyTy::BaseType *type)\n-{\n-  rust_assert (type != nullptr);\n-  resolved[id] = type;\n-}\n-\n-bool\n-TypeCheckContext::lookup_type (HirId id, TyTy::BaseType **type) const\n-{\n-  auto it = resolved.find (id);\n-  if (it == resolved.end ())\n-    return false;\n-\n-  *type = it->second;\n-  return true;\n-}\n-\n-void\n-TypeCheckContext::insert_type_by_node_id (NodeId ref, HirId id)\n-{\n-  rust_assert (node_id_refs.find (ref) == node_id_refs.end ());\n-  node_id_refs[ref] = id;\n-}\n-\n-bool\n-TypeCheckContext::lookup_type_by_node_id (NodeId ref, HirId *id)\n-{\n-  auto it = node_id_refs.find (ref);\n-  if (it == node_id_refs.end ())\n-    return false;\n-\n-  *id = it->second;\n-  return true;\n-}\n-\n-TyTy::BaseType *\n-TypeCheckContext::peek_return_type ()\n-{\n-  rust_assert (!return_type_stack.empty ());\n-  return return_type_stack.back ().second;\n-}\n-\n-void\n-TypeCheckContext::push_return_type (TypeCheckContextItem item,\n-\t\t\t\t    TyTy::BaseType *return_type)\n-{\n-  return_type_stack.push_back ({std::move (item), return_type});\n-}\n-\n-void\n-TypeCheckContext::pop_return_type ()\n-{\n-  rust_assert (!return_type_stack.empty ());\n-  return_type_stack.pop_back ();\n-}\n-\n-TypeCheckContextItem &\n-TypeCheckContext::peek_context ()\n-{\n-  rust_assert (!return_type_stack.empty ());\n-  return return_type_stack.back ().first;\n-}\n-\n-// TypeCheckContextItem\n-\n-TyTy::FnType *\n-TypeCheckContextItem::get_context_type ()\n-{\n-  auto &context = *TypeCheckContext::get ();\n-\n-  HirId reference = UNKNOWN_HIRID;\n-  switch (get_type ())\n-    {\n-    case ITEM:\n-      reference = get_item ()->get_mappings ().get_hirid ();\n-      break;\n-\n-    case IMPL_ITEM:\n-      reference = get_impl_item ().second->get_mappings ().get_hirid ();\n-      break;\n-\n-    case TRAIT_ITEM:\n-      reference = get_trait_item ()->get_mappings ().get_hirid ();\n-      break;\n-    }\n-\n-  rust_assert (reference != UNKNOWN_HIRID);\n-\n-  TyTy::BaseType *lookup = nullptr;\n-  bool ok = context.lookup_type (reference, &lookup);\n-  rust_assert (ok);\n-  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-  return static_cast<TyTy::FnType *> (lookup);\n-}\n-\n-} // namespace Resolver\n-} // namespace Rust"}, {"sha": "ba4d3228c22663ab89406f50ac932119e56dfdf0", "filename": "gcc/rust/typecheck/rust-typecheck-context.cc", "status": "added", "additions": 569, "deletions": 0, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-typecheck-context.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-typecheck-context.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-typecheck-context.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,569 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckContext *\n+TypeCheckContext::get ()\n+{\n+  static TypeCheckContext *instance;\n+  if (instance == nullptr)\n+    instance = new TypeCheckContext ();\n+\n+  return instance;\n+}\n+\n+TypeCheckContext::TypeCheckContext () {}\n+\n+TypeCheckContext::~TypeCheckContext () {}\n+\n+bool\n+TypeCheckContext::lookup_builtin (NodeId id, TyTy::BaseType **type)\n+{\n+  auto ref_it = node_id_refs.find (id);\n+  if (ref_it == node_id_refs.end ())\n+    return false;\n+\n+  auto it = resolved.find (ref_it->second);\n+  if (it == resolved.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n+bool\n+TypeCheckContext::lookup_builtin (std::string name, TyTy::BaseType **type)\n+{\n+  for (auto &builtin : builtins)\n+    {\n+      if (name.compare (builtin->as_string ()) == 0)\n+\t{\n+\t  *type = builtin.get ();\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+void\n+TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::BaseType *type)\n+{\n+  node_id_refs[ref] = id;\n+  resolved[id] = type;\n+  builtins.push_back (std::unique_ptr<TyTy::BaseType> (type));\n+}\n+\n+void\n+TypeCheckContext::insert_type (const Analysis::NodeMapping &mappings,\n+\t\t\t       TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  NodeId ref = mappings.get_nodeid ();\n+  HirId id = mappings.get_hirid ();\n+  node_id_refs[ref] = id;\n+  resolved[id] = type;\n+}\n+\n+void\n+TypeCheckContext::insert_implicit_type (TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  resolved[type->get_ref ()] = type;\n+}\n+\n+void\n+TypeCheckContext::insert_implicit_type (HirId id, TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  resolved[id] = type;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type (HirId id, TyTy::BaseType **type) const\n+{\n+  auto it = resolved.find (id);\n+  if (it == resolved.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_type_by_node_id (NodeId ref, HirId id)\n+{\n+  rust_assert (node_id_refs.find (ref) == node_id_refs.end ());\n+  node_id_refs[ref] = id;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type_by_node_id (NodeId ref, HirId *id)\n+{\n+  auto it = node_id_refs.find (ref);\n+  if (it == node_id_refs.end ())\n+    return false;\n+\n+  *id = it->second;\n+  return true;\n+}\n+\n+TyTy::BaseType *\n+TypeCheckContext::peek_return_type ()\n+{\n+  rust_assert (!return_type_stack.empty ());\n+  return return_type_stack.back ().second;\n+}\n+\n+void\n+TypeCheckContext::push_return_type (TypeCheckContextItem item,\n+\t\t\t\t    TyTy::BaseType *return_type)\n+{\n+  return_type_stack.push_back ({std::move (item), return_type});\n+}\n+\n+void\n+TypeCheckContext::pop_return_type ()\n+{\n+  rust_assert (!return_type_stack.empty ());\n+  return_type_stack.pop_back ();\n+}\n+\n+TypeCheckContextItem &\n+TypeCheckContext::peek_context ()\n+{\n+  rust_assert (!return_type_stack.empty ());\n+  return return_type_stack.back ().first;\n+}\n+\n+void\n+TypeCheckContext::iterate (std::function<bool (HirId, TyTy::BaseType *)> cb)\n+{\n+  for (auto it = resolved.begin (); it != resolved.end (); it++)\n+    {\n+      if (!cb (it->first, it->second))\n+\treturn;\n+    }\n+}\n+\n+bool\n+TypeCheckContext::have_loop_context () const\n+{\n+  return !loop_type_stack.empty ();\n+}\n+\n+void\n+TypeCheckContext::push_new_loop_context (HirId id, Location locus)\n+{\n+  TyTy::BaseType *infer_var\n+    = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL, locus);\n+  loop_type_stack.push_back (infer_var);\n+}\n+\n+void\n+TypeCheckContext::push_new_while_loop_context (HirId id)\n+{\n+  TyTy::BaseType *infer_var = new TyTy::ErrorType (id);\n+  loop_type_stack.push_back (infer_var);\n+}\n+\n+TyTy::BaseType *\n+TypeCheckContext::peek_loop_context ()\n+{\n+  return loop_type_stack.back ();\n+}\n+\n+TyTy::BaseType *\n+TypeCheckContext::pop_loop_context ()\n+{\n+  auto back = peek_loop_context ();\n+  loop_type_stack.pop_back ();\n+  return back;\n+}\n+\n+void\n+TypeCheckContext::swap_head_loop_context (TyTy::BaseType *val)\n+{\n+  loop_type_stack.pop_back ();\n+  loop_type_stack.push_back (val);\n+}\n+\n+void\n+TypeCheckContext::insert_trait_reference (DefId id, TraitReference &&ref)\n+{\n+  rust_assert (trait_context.find (id) == trait_context.end ());\n+  trait_context.emplace (id, std::move (ref));\n+}\n+\n+bool\n+TypeCheckContext::lookup_trait_reference (DefId id, TraitReference **ref)\n+{\n+  auto it = trait_context.find (id);\n+  if (it == trait_context.end ())\n+    return false;\n+\n+  *ref = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_receiver (HirId id, TyTy::BaseType *t)\n+{\n+  receiver_context[id] = t;\n+}\n+\n+bool\n+TypeCheckContext::lookup_receiver (HirId id, TyTy::BaseType **ref)\n+{\n+  auto it = receiver_context.find (id);\n+  if (it == receiver_context.end ())\n+    return false;\n+\n+  *ref = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_associated_trait_impl (\n+  HirId id, AssociatedImplTrait &&associated)\n+{\n+  rust_assert (associated_impl_traits.find (id)\n+\t       == associated_impl_traits.end ());\n+  associated_impl_traits.emplace (id, std::move (associated));\n+}\n+\n+bool\n+TypeCheckContext::lookup_associated_trait_impl (\n+  HirId id, AssociatedImplTrait **associated)\n+{\n+  auto it = associated_impl_traits.find (id);\n+  if (it == associated_impl_traits.end ())\n+    return false;\n+\n+  *associated = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_associated_type_mapping (HirId id, HirId mapping)\n+{\n+  associated_type_mappings[id] = mapping;\n+}\n+\n+void\n+TypeCheckContext::clear_associated_type_mapping (HirId id)\n+{\n+  auto it = associated_type_mappings.find (id);\n+  if (it != associated_type_mappings.end ())\n+    associated_type_mappings.erase (it);\n+}\n+\n+// lookup any associated type mappings, the out parameter of mapping is\n+// allowed to be nullptr which allows this interface to do a simple does exist\n+// check\n+bool\n+TypeCheckContext::lookup_associated_type_mapping (HirId id, HirId *mapping)\n+{\n+  auto it = associated_type_mappings.find (id);\n+  if (it == associated_type_mappings.end ())\n+    return false;\n+\n+  if (mapping != nullptr)\n+    *mapping = it->second;\n+\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_associated_impl_mapping (\n+  HirId trait_id, const TyTy::BaseType *impl_type, HirId impl_id)\n+{\n+  auto it = associated_traits_to_impls.find (trait_id);\n+  if (it == associated_traits_to_impls.end ())\n+    {\n+      associated_traits_to_impls[trait_id] = {};\n+    }\n+\n+  associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n+}\n+\n+bool\n+TypeCheckContext::lookup_associated_impl_mapping_for_self (\n+  HirId trait_id, const TyTy::BaseType *self, HirId *mapping)\n+{\n+  auto it = associated_traits_to_impls.find (trait_id);\n+  if (it == associated_traits_to_impls.end ())\n+    return false;\n+\n+  for (auto &item : it->second)\n+    {\n+      if (item.first->can_eq (self, false))\n+\t{\n+\t  *mapping = item.second;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+void\n+TypeCheckContext::insert_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> &&adjustments)\n+{\n+  rust_assert (autoderef_mappings.find (id) == autoderef_mappings.end ());\n+  autoderef_mappings.emplace (id, std::move (adjustments));\n+}\n+\n+bool\n+TypeCheckContext::lookup_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> **adjustments)\n+{\n+  auto it = autoderef_mappings.find (id);\n+  if (it == autoderef_mappings.end ())\n+    return false;\n+\n+  *adjustments = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_cast_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> &&adjustments)\n+{\n+  rust_assert (cast_autoderef_mappings.find (id)\n+\t       == cast_autoderef_mappings.end ());\n+  cast_autoderef_mappings.emplace (id, std::move (adjustments));\n+}\n+\n+bool\n+TypeCheckContext::lookup_cast_autoderef_mappings (\n+  HirId id, std::vector<Adjustment> **adjustments)\n+{\n+  auto it = cast_autoderef_mappings.find (id);\n+  if (it == cast_autoderef_mappings.end ())\n+    return false;\n+\n+  *adjustments = &it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_variant_definition (HirId id, HirId variant)\n+{\n+  auto it = variants.find (id);\n+  rust_assert (it == variants.end ());\n+\n+  variants[id] = variant;\n+}\n+\n+bool\n+TypeCheckContext::lookup_variant_definition (HirId id, HirId *variant)\n+{\n+  auto it = variants.find (id);\n+  if (it == variants.end ())\n+    return false;\n+\n+  *variant = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_operator_overload (HirId id, TyTy::FnType *call_site)\n+{\n+  auto it = operator_overloads.find (id);\n+  rust_assert (it == operator_overloads.end ());\n+\n+  operator_overloads[id] = call_site;\n+}\n+\n+bool\n+TypeCheckContext::lookup_operator_overload (HirId id, TyTy::FnType **call)\n+{\n+  auto it = operator_overloads.find (id);\n+  if (it == operator_overloads.end ())\n+    return false;\n+\n+  *call = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_unconstrained_check_marker (HirId id, bool status)\n+{\n+  unconstrained[id] = status;\n+}\n+\n+bool\n+TypeCheckContext::have_checked_for_unconstrained (HirId id, bool *result)\n+{\n+  auto it = unconstrained.find (id);\n+  bool found = it != unconstrained.end ();\n+  if (!found)\n+    return false;\n+\n+  *result = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_resolved_predicate (HirId id,\n+\t\t\t\t\t     TyTy::TypeBoundPredicate predicate)\n+{\n+  auto it = predicates.find (id);\n+  rust_assert (it == predicates.end ());\n+\n+  predicates.insert ({id, predicate});\n+}\n+\n+bool\n+TypeCheckContext::lookup_predicate (HirId id, TyTy::TypeBoundPredicate *result)\n+{\n+  auto it = predicates.find (id);\n+  bool found = it != predicates.end ();\n+  if (!found)\n+    return false;\n+\n+  *result = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_query (HirId id)\n+{\n+  querys_in_progress.insert (id);\n+}\n+\n+void\n+TypeCheckContext::query_completed (HirId id)\n+{\n+  querys_in_progress.erase (id);\n+}\n+\n+bool\n+TypeCheckContext::query_in_progress (HirId id) const\n+{\n+  return querys_in_progress.find (id) != querys_in_progress.end ();\n+}\n+\n+void\n+TypeCheckContext::insert_trait_query (DefId id)\n+{\n+  trait_queries_in_progress.insert (id);\n+}\n+\n+void\n+TypeCheckContext::trait_query_completed (DefId id)\n+{\n+  trait_queries_in_progress.erase (id);\n+}\n+\n+bool\n+TypeCheckContext::trait_query_in_progress (DefId id) const\n+{\n+  return trait_queries_in_progress.find (id)\n+\t != trait_queries_in_progress.end ();\n+}\n+\n+// TypeCheckContextItem\n+\n+TypeCheckContextItem::Item::Item (HIR::Function *item) : item (item) {}\n+\n+TypeCheckContextItem::Item::Item (HIR::ImplBlock *impl_block,\n+\t\t\t\t  HIR::Function *item)\n+  : impl_item ({impl_block, item})\n+{}\n+\n+TypeCheckContextItem::Item::Item (HIR::TraitItemFunc *trait_item)\n+  : trait_item (trait_item)\n+{}\n+\n+TypeCheckContextItem::TypeCheckContextItem (HIR::Function *item)\n+  : type (ItemType::ITEM), item (item)\n+{}\n+\n+TypeCheckContextItem::TypeCheckContextItem (HIR::ImplBlock *impl_block,\n+\t\t\t\t\t    HIR::Function *item)\n+  : type (ItemType::IMPL_ITEM), item (impl_block, item)\n+{}\n+\n+TypeCheckContextItem::TypeCheckContextItem (HIR::TraitItemFunc *trait_item)\n+  : type (ItemType::TRAIT_ITEM), item (trait_item)\n+{}\n+\n+HIR::Function *\n+TypeCheckContextItem::get_item ()\n+{\n+  rust_assert (get_type () == ItemType::ITEM);\n+  return item.item;\n+}\n+\n+std::pair<HIR::ImplBlock *, HIR::Function *> &\n+TypeCheckContextItem::get_impl_item ()\n+{\n+  rust_assert (get_type () == ItemType::IMPL_ITEM);\n+  return item.impl_item;\n+}\n+\n+HIR::TraitItemFunc *\n+TypeCheckContextItem::get_trait_item ()\n+{\n+  rust_assert (get_type () == ItemType::TRAIT_ITEM);\n+  return item.trait_item;\n+}\n+\n+TypeCheckContextItem::ItemType\n+TypeCheckContextItem::get_type () const\n+{\n+  return type;\n+}\n+\n+TyTy::FnType *\n+TypeCheckContextItem::get_context_type ()\n+{\n+  auto &context = *TypeCheckContext::get ();\n+\n+  HirId reference = UNKNOWN_HIRID;\n+  switch (get_type ())\n+    {\n+    case ITEM:\n+      reference = get_item ()->get_mappings ().get_hirid ();\n+      break;\n+\n+    case IMPL_ITEM:\n+      reference = get_impl_item ().second->get_mappings ().get_hirid ();\n+      break;\n+\n+    case TRAIT_ITEM:\n+      reference = get_trait_item ()->get_mappings ().get_hirid ();\n+      break;\n+    }\n+\n+  rust_assert (reference != UNKNOWN_HIRID);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = context.lookup_type (reference, &lookup);\n+  rust_assert (ok);\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+  return static_cast<TyTy::FnType *> (lookup);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "414111c7ba783a9775f49ea21e93cf874227b9e3", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -364,6 +364,30 @@ TypeBoundPredicate::lookup_associated_item (const std::string &search) const\n   return TypeBoundPredicateItem (this, trait_item_ref);\n }\n \n+TypeBoundPredicateItem::TypeBoundPredicateItem (\n+  const TypeBoundPredicate *parent,\n+  const Resolver::TraitItemReference *trait_item_ref)\n+  : parent (parent), trait_item_ref (trait_item_ref)\n+{}\n+\n+TypeBoundPredicateItem\n+TypeBoundPredicateItem::error ()\n+{\n+  return TypeBoundPredicateItem (nullptr, nullptr);\n+}\n+\n+bool\n+TypeBoundPredicateItem::is_error () const\n+{\n+  return parent == nullptr || trait_item_ref == nullptr;\n+}\n+\n+const TypeBoundPredicate *\n+TypeBoundPredicateItem::get_parent () const\n+{\n+  return parent;\n+}\n+\n TypeBoundPredicateItem\n TypeBoundPredicate::lookup_associated_item (\n   const Resolver::TraitItemReference *ref) const\n@@ -420,7 +444,7 @@ TypeBoundPredicate::is_error () const\n \n BaseType *\n TypeBoundPredicate::handle_substitions (\n-  SubstitutionArgumentMappings subst_mappings)\n+  SubstitutionArgumentMappings &subst_mappings)\n {\n   for (auto &sub : get_substs ())\n     {"}, {"sha": "44839bd0b4097d62a320362d489eb7bf1d95058c", "filename": "gcc/rust/typecheck/rust-tyty-bounds.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_BOUNDS_H\n+#define RUST_TYTY_BOUNDS_H\n+\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+\n+namespace Resolver {\n+class TraitReference;\n+class TraitItemReference;\n+class AssociatedImplTrait;\n+} // namespace Resolver\n+\n+namespace TyTy {\n+\n+class BaseType;\n+class TypeBoundPredicate;\n+class TypeBoundPredicateItem\n+{\n+public:\n+  TypeBoundPredicateItem (const TypeBoundPredicate *parent,\n+\t\t\t  const Resolver::TraitItemReference *trait_item_ref);\n+\n+  static TypeBoundPredicateItem error ();\n+\n+  bool is_error () const;\n+\n+  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n+\n+  const Resolver::TraitItemReference *get_raw_item () const;\n+\n+  bool needs_implementation () const;\n+\n+  const TypeBoundPredicate *get_parent () const;\n+\n+  Location get_locus () const;\n+\n+private:\n+  const TypeBoundPredicate *parent;\n+  const Resolver::TraitItemReference *trait_item_ref;\n+};\n+\n+class TypeBoundsMappings\n+{\n+protected:\n+  TypeBoundsMappings (std::vector<TypeBoundPredicate> specified_bounds);\n+\n+public:\n+  std::vector<TypeBoundPredicate> &get_specified_bounds ();\n+\n+  const std::vector<TypeBoundPredicate> &get_specified_bounds () const;\n+\n+  size_t num_specified_bounds () const;\n+\n+  std::string raw_bounds_as_string () const;\n+\n+  std::string bounds_as_string () const;\n+\n+  std::string raw_bounds_as_name () const;\n+\n+protected:\n+  void add_bound (TypeBoundPredicate predicate);\n+\n+  std::vector<TypeBoundPredicate> specified_bounds;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_BOUNDS_H"}, {"sha": "4010c6079ccf50a615a2f5452cc746701a086fcc", "filename": "gcc/rust/typecheck/rust-tyty-call.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -85,7 +85,6 @@ TypeCheckCallExpr::visit (ADTType &type)\n void\n TypeCheckCallExpr::visit (FnType &type)\n {\n-  type.monomorphize ();\n   if (call.num_params () != type.num_params ())\n     {\n       if (type.is_varadic ())\n@@ -141,8 +140,6 @@ TypeCheckCallExpr::visit (FnType &type)\n \t    argument->get_locus ());\n \t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t    {\n-\t      rust_error_at (argument->get_locus (),\n-\t\t\t     \"Type Resolution failure on parameter\");\n \t      return;\n \t    }\n \t}\n@@ -194,8 +191,6 @@ TypeCheckCallExpr::visit (FnPtr &type)\n \tTyWithLocation (argument_expr_tyty, arg_locus), argument->get_locus ());\n       if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n-\t  rust_error_at (argument->get_locus (),\n-\t\t\t \"Type Resolution failure on parameter\");\n \t  return;\n \t}\n \n@@ -302,7 +297,6 @@ TypeCheckMethodCallExpr::check (FnType &type)\n \tTyWithLocation (argument_expr_tyty, arg_locus), arg_locus);\n       if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n-\t  rust_error_at (arg_locus, \"Type Resolution failure on parameter\");\n \t  return new ErrorType (type.get_ref ());\n \t}\n "}, {"sha": "dbb808b644ee52880beeab3d57216c9b154d771b", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "removed", "additions": 0, "deletions": 1406, "changes": 1406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a9a9e949d7660ae7fc7cd4642f668bf438c970/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a9a9e949d7660ae7fc7cd4642f668bf438c970/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=47a9a9e949d7660ae7fc7cd4642f668bf438c970", "patch": "@@ -1,1406 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYTY_RULES\n-#define RUST_TYTY_RULES\n-\n-#include \"rust-diagnostics.h\"\n-#include \"rust-tyty.h\"\n-#include \"rust-tyty-visitor.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-hir-type-check.h\"\n-\n-namespace Rust {\n-namespace TyTy {\n-\n-/* Rules specify how to unify two Ty. For example, the result of unifying the\n-   two tuples (u64, A) and (B, i64) would be (u64, i64).\n-\n-   Performing a unification requires a double dispatch. To illustrate, suppose\n-   we want to unify `ty1` and `ty2`. Here's what it looks like:\n-     1. The caller calls `ty1.unify(ty2)`. This is the first dispatch.\n-     2. `ty1` creates a rule specific to its type(e.g. TupleRules).\n-     3. The rule calls `ty2.accept_vis(rule)`. This is the second dispatch.\n-     4. `ty2` calls `rule.visit(*this)`, which will method-overload to the\n-\t      correct implementation at compile time.\n-\n-   The nice thing about Rules is that they seperate unification logic from the\n-   representation of Ty. To support unifying a new Ty, implement its\n-   `accept_vis` and `unify` method to pass the unification request to Rules.\n-   Then, create a new `XXXRules` class and implement one `visit` method for\n-   every Ty it can unify with. */\n-class BaseRules : public TyVisitor\n-{\n-public:\n-  virtual ~BaseRules () {}\n-\n-  /* Unify two ty. Returns a pointer to the newly-created unified ty, or nullptr\n-     if the two types cannot be unified. The caller is responsible for releasing\n-     the memory of the returned ty.\n-\n-     This method is meant to be used internally by Ty. If you're trying to unify\n-     two ty, you can simply call `unify` on ty themselves. */\n-  virtual BaseType *unify (BaseType *other)\n-  {\n-    if (other->get_kind () == TypeKind::PARAM)\n-      {\n-\tParamType *p = static_cast<ParamType *> (other);\n-\tother = p->resolve ();\n-      }\n-    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n-      {\n-\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n-\tif (p->can_resolve ())\n-\t  {\n-\t    other = p->resolve ();\n-\t    return get_base ()->unify (other);\n-\t  }\n-      }\n-    else if (other->get_kind () == TypeKind::PROJECTION)\n-      {\n-\tProjectionType *p = static_cast<ProjectionType *> (other);\n-\tother = p->get ();\n-\treturn get_base ()->unify (other);\n-      }\n-\n-    other->accept_vis (*this);\n-    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-      return resolved;\n-\n-    resolved->append_reference (get_base ()->get_ref ());\n-    resolved->append_reference (other->get_ref ());\n-    for (auto ref : get_base ()->get_combined_refs ())\n-      resolved->append_reference (ref);\n-    for (auto ref : other->get_combined_refs ())\n-      resolved->append_reference (ref);\n-\n-    other->append_reference (resolved->get_ref ());\n-    other->append_reference (get_base ()->get_ref ());\n-    get_base ()->append_reference (resolved->get_ref ());\n-    get_base ()->append_reference (other->get_ref ());\n-\n-    bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n-    bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n-    bool results_is_non_general_infer_var\n-      = (result_is_infer_var\n-\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n-\t      != TyTy::InferType::GENERAL);\n-    if (result_resolved || results_is_non_general_infer_var)\n-      {\n-\tfor (auto &ref : resolved->get_combined_refs ())\n-\t  {\n-\t    TyTy::BaseType *ref_tyty = nullptr;\n-\t    bool ok = context->lookup_type (ref, &ref_tyty);\n-\t    if (!ok)\n-\t      continue;\n-\n-\t    // if any of the types are inference variables lets fix them\n-\t    if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n-\t      {\n-\t\tcontext->insert_type (\n-\t\t  Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t UNKNOWN_NODEID, ref,\n-\t\t\t\t\t UNKNOWN_LOCAL_DEFID),\n-\t\t  resolved->clone ());\n-\t      }\n-\t  }\n-      }\n-    return resolved;\n-  }\n-\n-  virtual void visit (TupleType &) override {}\n-\n-  virtual void visit (ADTType &) override {}\n-\n-  virtual void visit (InferType &) override {}\n-\n-  virtual void visit (FnType &) override {}\n-\n-  virtual void visit (FnPtr &) override {}\n-\n-  virtual void visit (ArrayType &) override {}\n-\n-  virtual void visit (SliceType &) override {}\n-\n-  virtual void visit (BoolType &) override {}\n-\n-  virtual void visit (IntType &) override {}\n-\n-  virtual void visit (UintType &) override {}\n-\n-  virtual void visit (USizeType &) override {}\n-\n-  virtual void visit (ISizeType &) override {}\n-\n-  virtual void visit (FloatType &) override {}\n-\n-  virtual void visit (ErrorType &) override {}\n-\n-  virtual void visit (CharType &) override {}\n-\n-  virtual void visit (ReferenceType &) override {}\n-\n-  virtual void visit (PointerType &) override {}\n-\n-  virtual void visit (ParamType &) override {}\n-\n-  virtual void visit (StrType &) override {}\n-\n-  virtual void visit (NeverType &) override {}\n-\n-  virtual void visit (PlaceholderType &) override {}\n-\n-  virtual void visit (ProjectionType &) override {}\n-\n-  virtual void visit (DynamicObjectType &) override {}\n-\n-  virtual void visit (ClosureType &) override {}\n-\n-protected:\n-  BaseRules (BaseType *base)\n-    : mappings (Analysis::Mappings::get ()),\n-      context (Resolver::TypeCheckContext::get ()),\n-      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n-  {}\n-\n-  Analysis::Mappings *mappings;\n-  Resolver::TypeCheckContext *context;\n-\n-  /* Temporary storage for the result of a unification.\n-     We could return the result directly instead of storing it in the rule\n-     object, but that involves modifying the visitor pattern to accommodate\n-     the return value, which is too complex. */\n-  BaseType *resolved;\n-\n-private:\n-  /* Returns a pointer to the ty that created this rule. */\n-  virtual BaseType *get_base () = 0;\n-};\n-\n-class InferRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  InferRules (InferType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (IntType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (UintType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (USizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ISizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (FloatType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ArrayType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (SliceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ADTType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (TupleType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (base->get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = type.clone ();\n-\treturn;\n-\n-\tcase InferType::InferTypeKind::INTEGRAL: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-\n-\tcase InferType::InferTypeKind::FLOAT: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (CharType &type) override\n-  {\n-    {\n-      bool is_valid\n-\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-      if (is_valid)\n-\t{\n-\t  resolved = type.clone ();\n-\t  return;\n-\t}\n-\n-      BaseRules::visit (type);\n-    }\n-  }\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (PointerType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (DynamicObjectType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-  void visit (ClosureType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseRules::visit (type);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  InferType *base;\n-};\n-\n-class FnRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  FnRules (FnType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto a = base->param_at (i).second;\n-\tauto b = type.param_at (i).second;\n-\n-\tauto unified_param = a->unify (b);\n-\tif (unified_param == nullptr)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    auto unified_return\n-      = base->get_return_type ()->unify (type.get_return_type ());\n-    if (unified_return == nullptr)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnType *base;\n-};\n-\n-class FnptrRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  FnptrRules (FnPtr *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnPtr &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i);\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i).second;\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnPtr *base;\n-};\n-\n-class ClosureRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ClosureRules (ClosureType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (ClosureType &type) override\n-  {\n-    if (base->get_def_id () != type.get_def_id ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *args_res\n-      = base->get_parameters ().unify (&type.get_parameters ());\n-    if (args_res == nullptr || args_res->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *res\n-      = base->get_result_type ().unify (&type.get_result_type ());\n-    if (res == nullptr || res->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ClosureType *base;\n-};\n-\n-class ArrayRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ArrayRules (ArrayType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (ArrayType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n-\t\t       TyVar (base_resolved->get_ref ()));\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ArrayType *base;\n-};\n-\n-class SliceRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  SliceRules (SliceType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (SliceType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_ident ().locus,\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  SliceType *base;\n-};\n-\n-class BoolRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  BoolRules (BoolType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (type.get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = base->clone ();\n-\tbreak;\n-\n-      default:\n-\tBaseRules::visit (type);\n-\tbreak;\n-      }\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  BoolType *base;\n-};\n-\n-class IntRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  IntRules (IntType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override\n-  {\n-    if (type.get_int_kind () != base->get_int_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_int_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  IntType *base;\n-};\n-\n-class UintRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  UintRules (UintType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (UintType &type) override\n-  {\n-    if (type.get_uint_kind () != base->get_uint_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new UintType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t     type.get_uint_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  UintType *base;\n-};\n-\n-class FloatRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  FloatRules (FloatType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FloatType &type) override\n-  {\n-    if (type.get_float_kind () != base->get_float_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new FloatType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_float_kind ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FloatType *base;\n-};\n-\n-class ADTRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ADTRules (ADTType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (ADTType &type) override\n-  {\n-    if (base->get_adt_kind () != type.get_adt_kind ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->number_of_variants () != type.number_of_variants ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < type.number_of_variants (); ++i)\n-      {\n-\tTyTy::VariantDef *a = base->get_variants ().at (i);\n-\tTyTy::VariantDef *b = type.get_variants ().at (i);\n-\n-\tif (a->num_fields () != b->num_fields ())\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n-\n-\tfor (size_t j = 0; j < a->num_fields (); j++)\n-\t  {\n-\t    TyTy::StructFieldType *base_field = a->get_field_at_index (j);\n-\t    TyTy::StructFieldType *other_field = b->get_field_at_index (j);\n-\n-\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n-\n-\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-      }\n-\n-    // generic args for the unit-struct case\n-    if (type.is_unit () && base->is_unit ())\n-      {\n-\trust_assert (type.get_num_substitutions ()\n-\t\t     == base->get_num_substitutions ());\n-\n-\tfor (size_t i = 0; i < type.get_num_substitutions (); i++)\n-\t  {\n-\t    auto &a = base->get_substs ().at (i);\n-\t    auto &b = type.get_substs ().at (i);\n-\n-\t    auto pa = a.get_param_ty ();\n-\t    auto pb = b.get_param_ty ();\n-\n-\t    auto res = pa->unify (pb);\n-\t    if (res->get_kind () == TyTy::TypeKind::ERROR)\n-\t      {\n-\t\treturn;\n-\t      }\n-\t  }\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ADTType *base;\n-};\n-\n-class TupleRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  TupleRules (TupleType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (TupleType &type) override\n-  {\n-    if (base->num_fields () != type.num_fields ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    std::vector<TyVar> fields;\n-    for (size_t i = 0; i < base->num_fields (); i++)\n-      {\n-\tBaseType *bo = base->get_field (i);\n-\tBaseType *fo = type.get_field (i);\n-\n-\tBaseType *unified_ty = bo->unify (fo);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-\n-\tfields.push_back (TyVar (unified_ty->get_ref ()));\n-      }\n-\n-    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t\t    type.get_ident ().locus, fields);\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  TupleType *base;\n-};\n-\n-class USizeRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  USizeRules (USizeType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  USizeType *base;\n-};\n-\n-class ISizeRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ISizeRules (ISizeType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ISizeType *base;\n-};\n-\n-class CharRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  CharRules (CharType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (CharType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  CharType *base;\n-};\n-\n-class ReferenceRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ReferenceRules (ReferenceType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    // rust is permissive about mutablity here you can always go from mutable to\n-    // immutable but not the otherway round\n-    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n-    if (!mutability_ok)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new ReferenceType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\t  TyVar (base_resolved->get_ref ()),\n-\t\t\t\t  base->mutability ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ReferenceType *base;\n-};\n-\n-class PointerRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  PointerRules (PointerType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (PointerType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    // rust is permissive about mutablity here you can always go from mutable to\n-    // immutable but not the otherway round\n-    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n-    if (!mutability_ok)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new PointerType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\tTyVar (base_resolved->get_ref ()),\n-\t\t\t\tbase->mutability ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PointerType *base;\n-};\n-\n-class ParamRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  ParamRules (ParamType *base) : BaseRules (base), base (base) {}\n-\n-  // param types are a placeholder we shouldn't have cases where we unify\n-  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n-  //\n-  // foo<i32>{ a: 123 }.\n-  // Then this enforces the i32 type to be referenced on the\n-  // field via an hirid.\n-  //\n-  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n-  // to handle the typing of the struct\n-  BaseType *unify (BaseType *other) override final\n-  {\n-    if (!base->can_resolve ())\n-      return BaseRules::unify (other);\n-\n-    auto lookup = base->resolve ();\n-    return lookup->unify (other);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ParamType *base;\n-};\n-\n-class StrRules : public BaseRules\n-{\n-  // FIXME we will need a enum for the StrType like ByteBuf etc..\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  StrRules (StrType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (StrType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  StrType *base;\n-};\n-\n-class NeverRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  NeverRules (NeverType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (NeverType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  NeverType *base;\n-};\n-\n-class PlaceholderRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  PlaceholderRules (PlaceholderType *base) : BaseRules (base), base (base) {}\n-\n-  BaseType *unify (BaseType *other) override final\n-  {\n-    if (!base->can_resolve ())\n-      return BaseRules::unify (other);\n-\n-    BaseType *lookup = base->resolve ();\n-    return lookup->unify (other);\n-  }\n-\n-  void visit (PlaceholderType &type) override\n-  {\n-    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PlaceholderType *base;\n-};\n-\n-class DynamicRules : public BaseRules\n-{\n-  using Rust::TyTy::BaseRules::visit;\n-\n-public:\n-  DynamicRules (DynamicObjectType *base) : BaseRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-  void visit (DynamicObjectType &type) override\n-  {\n-    if (base->num_specified_bounds () != type.num_specified_bounds ())\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    if (!base->bounds_compatible (type, ref_locus, true))\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  DynamicObjectType *base;\n-};\n-\n-} // namespace TyTy\n-} // namespace Rust\n-\n-#endif // RUST_TYTY_RULES"}, {"sha": "3dfe95873bce23c602ae07f8a411b090a0dc6ddf", "filename": "gcc/rust/typecheck/rust-tyty-subst.cc", "status": "added", "additions": 1027, "deletions": 0, "changes": 1027, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,1027 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty-subst.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-check-type.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+SubstitutionParamMapping::SubstitutionParamMapping (\n+  const HIR::TypeParam &generic, ParamType *param)\n+  : generic (generic), param (param)\n+{}\n+\n+SubstitutionParamMapping::SubstitutionParamMapping (\n+  const SubstitutionParamMapping &other)\n+  : generic (other.generic), param (other.param)\n+{}\n+\n+std::string\n+SubstitutionParamMapping::as_string () const\n+{\n+  if (param == nullptr)\n+    return \"nullptr\";\n+\n+  return param->get_name ();\n+}\n+\n+SubstitutionParamMapping\n+SubstitutionParamMapping::clone () const\n+{\n+  return SubstitutionParamMapping (generic,\n+\t\t\t\t   static_cast<ParamType *> (param->clone ()));\n+}\n+\n+ParamType *\n+SubstitutionParamMapping::get_param_ty ()\n+{\n+  return param;\n+}\n+\n+const ParamType *\n+SubstitutionParamMapping::get_param_ty () const\n+{\n+  return param;\n+}\n+\n+const HIR::TypeParam &\n+SubstitutionParamMapping::get_generic_param () const\n+{\n+  return generic;\n+}\n+\n+bool\n+SubstitutionParamMapping::needs_substitution () const\n+{\n+  return !(get_param_ty ()->is_concrete ());\n+}\n+\n+Location\n+SubstitutionParamMapping::get_param_locus () const\n+{\n+  return generic.get_locus ();\n+}\n+\n+bool\n+SubstitutionParamMapping::param_has_default_ty () const\n+{\n+  return generic.has_type ();\n+}\n+\n+BaseType *\n+SubstitutionParamMapping::get_default_ty () const\n+{\n+  TyVar var (generic.get_type_mappings ().get_hirid ());\n+  return var.get_tyty ();\n+}\n+\n+bool\n+SubstitutionParamMapping::need_substitution () const\n+{\n+  if (!param->can_resolve ())\n+    return true;\n+\n+  auto resolved = param->resolve ();\n+  return !resolved->is_concrete ();\n+}\n+\n+bool\n+SubstitutionParamMapping::fill_param_ty (\n+  SubstitutionArgumentMappings &subst_mappings, Location locus)\n+{\n+  SubstitutionArg arg = SubstitutionArg::error ();\n+  bool ok = subst_mappings.get_argument_for_symbol (get_param_ty (), &arg);\n+  if (!ok)\n+    return true;\n+\n+  TyTy::BaseType &type = *arg.get_tyty ();\n+  if (type.get_kind () == TyTy::TypeKind::INFER)\n+    {\n+      type.inherit_bounds (*param);\n+    }\n+  else\n+    {\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+    }\n+\n+  if (type.get_kind () == TypeKind::PARAM)\n+    {\n+      // delete param;\n+      param = static_cast<ParamType *> (type.clone ());\n+    }\n+  else\n+    {\n+      // check the substitution is compatible with bounds\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+\n+      // recursively pass this down to all HRTB's\n+      for (auto &bound : param->get_specified_bounds ())\n+\tbound.handle_substitions (subst_mappings);\n+\n+      param->set_ty_ref (type.get_ref ());\n+      subst_mappings.on_param_subst (*param, arg);\n+    }\n+\n+  return true;\n+}\n+\n+void\n+SubstitutionParamMapping::override_context ()\n+{\n+  if (!param->can_resolve ())\n+    return;\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       param->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tparam->resolve ());\n+}\n+\n+SubstitutionArg::SubstitutionArg (const SubstitutionParamMapping *param,\n+\t\t\t\t  BaseType *argument)\n+  : param (param), argument (argument)\n+{}\n+\n+SubstitutionArg::SubstitutionArg (const SubstitutionArg &other)\n+  : param (other.param), argument (other.argument)\n+{}\n+\n+SubstitutionArg &\n+SubstitutionArg::operator= (const SubstitutionArg &other)\n+{\n+  param = other.param;\n+  argument = other.argument;\n+  return *this;\n+}\n+\n+BaseType *\n+SubstitutionArg::get_tyty ()\n+{\n+  return argument;\n+}\n+\n+const BaseType *\n+SubstitutionArg::get_tyty () const\n+{\n+  return argument;\n+}\n+\n+const SubstitutionParamMapping *\n+SubstitutionArg::get_param_mapping () const\n+{\n+  return param;\n+}\n+\n+SubstitutionArg\n+SubstitutionArg::error ()\n+{\n+  return SubstitutionArg (nullptr, nullptr);\n+}\n+\n+bool\n+SubstitutionArg::is_error () const\n+{\n+  return param == nullptr || argument == nullptr;\n+}\n+\n+bool\n+SubstitutionArg::is_conrete () const\n+{\n+  if (argument == nullptr)\n+    return false;\n+\n+  if (argument->get_kind () == TyTy::TypeKind::PARAM)\n+    return false;\n+\n+  return argument->is_concrete ();\n+}\n+\n+std::string\n+SubstitutionArg::as_string () const\n+{\n+  return param->as_string ()\n+\t + (argument != nullptr ? \":\" + argument->as_string () : \"\");\n+}\n+\n+// SubstitutionArgumentMappings\n+\n+SubstitutionArgumentMappings::SubstitutionArgumentMappings (\n+  std::vector<SubstitutionArg> mappings,\n+  std::map<std::string, BaseType *> binding_args, Location locus,\n+  ParamSubstCb param_subst_cb, bool trait_item_flag)\n+  : mappings (mappings), binding_args (binding_args), locus (locus),\n+    param_subst_cb (param_subst_cb), trait_item_flag (trait_item_flag)\n+{}\n+\n+SubstitutionArgumentMappings::SubstitutionArgumentMappings (\n+  const SubstitutionArgumentMappings &other)\n+  : mappings (other.mappings), binding_args (other.binding_args),\n+    locus (other.locus), param_subst_cb (nullptr),\n+    trait_item_flag (other.trait_item_flag)\n+{}\n+\n+SubstitutionArgumentMappings &\n+SubstitutionArgumentMappings::operator= (\n+  const SubstitutionArgumentMappings &other)\n+{\n+  mappings = other.mappings;\n+  binding_args = other.binding_args;\n+  locus = other.locus;\n+  param_subst_cb = nullptr;\n+  trait_item_flag = other.trait_item_flag;\n+\n+  return *this;\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionArgumentMappings::error ()\n+{\n+  return SubstitutionArgumentMappings ({}, {}, Location (), nullptr, false);\n+}\n+\n+bool\n+SubstitutionArgumentMappings::is_error () const\n+{\n+  return mappings.size () == 0;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::get_argument_for_symbol (\n+  const ParamType *param_to_find, SubstitutionArg *argument)\n+{\n+  for (auto &mapping : mappings)\n+    {\n+      const SubstitutionParamMapping *param = mapping.get_param_mapping ();\n+      const ParamType *p = param->get_param_ty ();\n+\n+      if (p->get_symbol ().compare (param_to_find->get_symbol ()) == 0)\n+\t{\n+\t  *argument = mapping;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::get_argument_at (size_t index,\n+\t\t\t\t\t       SubstitutionArg *argument)\n+{\n+  if (index > mappings.size ())\n+    return false;\n+\n+  *argument = mappings.at (index);\n+  return true;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::is_concrete () const\n+{\n+  for (auto &mapping : mappings)\n+    {\n+      if (!mapping.is_conrete ())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+Location\n+SubstitutionArgumentMappings::get_locus () const\n+{\n+  return locus;\n+}\n+\n+size_t\n+SubstitutionArgumentMappings::size () const\n+{\n+  return mappings.size ();\n+}\n+\n+bool\n+SubstitutionArgumentMappings::is_empty () const\n+{\n+  return size () == 0;\n+}\n+\n+std::vector<SubstitutionArg> &\n+SubstitutionArgumentMappings::get_mappings ()\n+{\n+  return mappings;\n+}\n+\n+const std::vector<SubstitutionArg> &\n+SubstitutionArgumentMappings::get_mappings () const\n+{\n+  return mappings;\n+}\n+\n+std::map<std::string, BaseType *> &\n+SubstitutionArgumentMappings::get_binding_args ()\n+{\n+  return binding_args;\n+}\n+\n+const std::map<std::string, BaseType *> &\n+SubstitutionArgumentMappings::get_binding_args () const\n+{\n+  return binding_args;\n+}\n+\n+std::string\n+SubstitutionArgumentMappings::as_string () const\n+{\n+  std::string buffer;\n+  for (auto &mapping : mappings)\n+    {\n+      buffer += mapping.as_string () + \", \";\n+    }\n+  return \"<\" + buffer + \">\";\n+}\n+\n+void\n+SubstitutionArgumentMappings::on_param_subst (const ParamType &p,\n+\t\t\t\t\t      const SubstitutionArg &a) const\n+{\n+  if (param_subst_cb == nullptr)\n+    return;\n+\n+  param_subst_cb (p, a);\n+}\n+\n+ParamSubstCb\n+SubstitutionArgumentMappings::get_subst_cb () const\n+{\n+  return param_subst_cb;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::trait_item_mode () const\n+{\n+  return trait_item_flag;\n+}\n+\n+// SubstitutionRef\n+\n+SubstitutionRef::SubstitutionRef (\n+  std::vector<SubstitutionParamMapping> substitutions,\n+  SubstitutionArgumentMappings arguments)\n+  : substitutions (substitutions), used_arguments (arguments)\n+{}\n+\n+bool\n+SubstitutionRef::has_substitutions () const\n+{\n+  return substitutions.size () > 0;\n+}\n+\n+std::string\n+SubstitutionRef::subst_as_string () const\n+{\n+  std::string buffer;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      const SubstitutionParamMapping &sub = substitutions.at (i);\n+      buffer += sub.as_string ();\n+\n+      if ((i + 1) < substitutions.size ())\n+\tbuffer += \", \";\n+    }\n+\n+  return buffer.empty () ? \"\" : \"<\" + buffer + \">\";\n+}\n+\n+bool\n+SubstitutionRef::supports_associated_bindings () const\n+{\n+  return get_num_associated_bindings () > 0;\n+}\n+\n+size_t\n+SubstitutionRef::get_num_associated_bindings () const\n+{\n+  return 0;\n+}\n+\n+TypeBoundPredicateItem\n+SubstitutionRef::lookup_associated_type (const std::string &search)\n+{\n+  return TypeBoundPredicateItem::error ();\n+}\n+\n+size_t\n+SubstitutionRef::get_num_substitutions () const\n+{\n+  return substitutions.size ();\n+}\n+\n+std::vector<SubstitutionParamMapping> &\n+SubstitutionRef::get_substs ()\n+{\n+  return substitutions;\n+}\n+\n+const std::vector<SubstitutionParamMapping> &\n+SubstitutionRef::get_substs () const\n+{\n+  return substitutions;\n+}\n+\n+std::vector<SubstitutionParamMapping>\n+SubstitutionRef::clone_substs () const\n+{\n+  std::vector<SubstitutionParamMapping> clone;\n+\n+  for (auto &sub : substitutions)\n+    clone.push_back (sub.clone ());\n+\n+  return clone;\n+}\n+\n+void\n+SubstitutionRef::override_context ()\n+{\n+  for (auto &sub : substitutions)\n+    {\n+      sub.override_context ();\n+    }\n+}\n+\n+bool\n+SubstitutionRef::needs_substitution () const\n+{\n+  for (auto &sub : substitutions)\n+    {\n+      if (sub.need_substitution ())\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+bool\n+SubstitutionRef::was_substituted () const\n+{\n+  return !needs_substitution ();\n+}\n+\n+SubstitutionArgumentMappings &\n+SubstitutionRef::get_substitution_arguments ()\n+{\n+  return used_arguments;\n+}\n+\n+const SubstitutionArgumentMappings &\n+SubstitutionRef::get_substitution_arguments () const\n+{\n+  return used_arguments;\n+}\n+\n+size_t\n+SubstitutionRef::num_required_substitutions () const\n+{\n+  size_t n = 0;\n+  for (auto &p : substitutions)\n+    {\n+      if (p.needs_substitution ())\n+\tn++;\n+    }\n+  return n;\n+}\n+\n+size_t\n+SubstitutionRef::min_required_substitutions () const\n+{\n+  size_t n = 0;\n+  for (auto &p : substitutions)\n+    {\n+      if (p.needs_substitution () && !p.param_has_default_ty ())\n+\tn++;\n+    }\n+  return n;\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::get_used_arguments () const\n+{\n+  return used_arguments;\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n+{\n+  std::map<std::string, BaseType *> binding_arguments;\n+  if (args.get_binding_args ().size () > 0)\n+    {\n+      if (supports_associated_bindings ())\n+\t{\n+\t  if (args.get_binding_args ().size () > get_num_associated_bindings ())\n+\t    {\n+\t      RichLocation r (args.get_locus ());\n+\n+\t      rust_error_at (r,\n+\t\t\t     \"generic item takes at most %lu type binding \"\n+\t\t\t     \"arguments but %lu were supplied\",\n+\t\t\t     (unsigned long) get_num_associated_bindings (),\n+\t\t\t     (unsigned long) args.get_binding_args ().size ());\n+\t      return SubstitutionArgumentMappings::error ();\n+\t    }\n+\n+\t  for (auto &binding : args.get_binding_args ())\n+\t    {\n+\t      BaseType *resolved\n+\t\t= Resolver::TypeCheckType::Resolve (binding.get_type ().get ());\n+\t      if (resolved == nullptr\n+\t\t  || resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t{\n+\t\t  rust_error_at (binding.get_locus (),\n+\t\t\t\t \"failed to resolve type arguments\");\n+\t\t  return SubstitutionArgumentMappings::error ();\n+\t\t}\n+\n+\t      // resolve to relevant binding\n+\t      auto binding_item\n+\t\t= lookup_associated_type (binding.get_identifier ());\n+\t      if (binding_item.is_error ())\n+\t\t{\n+\t\t  rust_error_at (binding.get_locus (),\n+\t\t\t\t \"unknown associated type binding: %s\",\n+\t\t\t\t binding.get_identifier ().c_str ());\n+\t\t  return SubstitutionArgumentMappings::error ();\n+\t\t}\n+\n+\t      binding_arguments[binding.get_identifier ()] = resolved;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  RichLocation r (args.get_locus ());\n+\t  for (auto &binding : args.get_binding_args ())\n+\t    r.add_range (binding.get_locus ());\n+\n+\t  rust_error_at (r, \"associated type bindings are not allowed here\");\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n+    }\n+\n+  // for inherited arguments\n+  size_t offs = used_arguments.size ();\n+  if (args.get_type_args ().size () + offs > substitutions.size ())\n+    {\n+      RichLocation r (args.get_locus ());\n+      r.add_range (substitutions.front ().get_param_locus ());\n+\n+      rust_error_at (\n+\tr,\n+\t\"generic item takes at most %lu type arguments but %lu were supplied\",\n+\t(unsigned long) substitutions.size (),\n+\t(unsigned long) args.get_type_args ().size ());\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  if (args.get_type_args ().size () + offs < min_required_substitutions ())\n+    {\n+      RichLocation r (args.get_locus ());\n+      r.add_range (substitutions.front ().get_param_locus ());\n+\n+      rust_error_at (\n+\tr,\n+\t\"generic item takes at least %lu type arguments but %lu were supplied\",\n+\t(unsigned long) (min_required_substitutions () - offs),\n+\t(unsigned long) args.get_type_args ().size ());\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  std::vector<SubstitutionArg> mappings = used_arguments.get_mappings ();\n+  for (auto &arg : args.get_type_args ())\n+    {\n+      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n+      if (resolved == nullptr || resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (args.get_locus (), \"failed to resolve type arguments\");\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n+\n+      SubstitutionArg subst_arg (&substitutions.at (offs), resolved);\n+      offs++;\n+      mappings.push_back (std::move (subst_arg));\n+    }\n+\n+  // we must need to fill out defaults\n+  size_t left_over\n+    = num_required_substitutions () - min_required_substitutions ();\n+  if (left_over > 0)\n+    {\n+      for (size_t offs = mappings.size (); offs < substitutions.size (); offs++)\n+\t{\n+\t  SubstitutionParamMapping &param = substitutions.at (offs);\n+\t  rust_assert (param.param_has_default_ty ());\n+\n+\t  BaseType *resolved = param.get_default_ty ();\n+\t  if (resolved->get_kind () == TypeKind::ERROR)\n+\t    return SubstitutionArgumentMappings::error ();\n+\n+\t  // this resolved default might already contain default parameters\n+\t  if (resolved->contains_type_parameters ())\n+\t    {\n+\t      SubstitutionArgumentMappings intermediate (mappings,\n+\t\t\t\t\t\t\t binding_arguments,\n+\t\t\t\t\t\t\t args.get_locus ());\n+\t      resolved = Resolver::SubstMapperInternal::Resolve (resolved,\n+\t\t\t\t\t\t\t\t intermediate);\n+\n+\t      if (resolved->get_kind () == TypeKind::ERROR)\n+\t\treturn SubstitutionArgumentMappings::error ();\n+\t    }\n+\n+\t  SubstitutionArg subst_arg (&param, resolved);\n+\t  mappings.push_back (std::move (subst_arg));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (mappings, binding_arguments,\n+\t\t\t\t       args.get_locus ());\n+}\n+\n+BaseType *\n+SubstitutionRef::infer_substitions (Location locus)\n+{\n+  std::vector<SubstitutionArg> args;\n+  std::map<std::string, BaseType *> argument_mappings;\n+  for (auto &p : get_substs ())\n+    {\n+      if (p.needs_substitution ())\n+\t{\n+\t  const std::string &symbol = p.get_param_ty ()->get_symbol ();\n+\t  auto it = argument_mappings.find (symbol);\n+\t  bool have_mapping = it != argument_mappings.end ();\n+\n+\t  if (have_mapping)\n+\t    {\n+\t      args.push_back (SubstitutionArg (&p, it->second));\n+\t    }\n+\t  else\n+\t    {\n+\t      TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n+\t      args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t      argument_mappings[symbol] = infer_var.get_tyty ();\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  args.push_back (SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t}\n+    }\n+\n+  // FIXME do we need to add inference variables to all the possible bindings?\n+  // it might just lead to inference variable hell not 100% sure if rustc does\n+  // this i think the language might needs this to be explicitly set\n+\n+  SubstitutionArgumentMappings infer_arguments (std::move (args),\n+\t\t\t\t\t\t{} /* binding_arguments */,\n+\t\t\t\t\t\tlocus);\n+  return handle_substitions (infer_arguments);\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::adjust_mappings_for_this (\n+  SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      auto &subst = substitutions.at (i);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      if (mappings.size () == substitutions.size ())\n+\t{\n+\t  mappings.get_argument_at (i, &arg);\n+\t}\n+      else\n+\t{\n+\t  if (subst.needs_substitution ())\n+\t    {\n+\t      // get from passed in mappings\n+\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+\t    }\n+\t  else\n+\t    {\n+\t      // we should already have this somewhere\n+\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n+\t\t\t\t\t\t      &arg);\n+\t    }\n+\t}\n+\n+      bool ok = !arg.is_error ();\n+      if (ok)\n+\t{\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  if (resolved_mappings.empty ())\n+    return SubstitutionArgumentMappings::error ();\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_binding_args (),\n+\t\t\t\t       mappings.get_locus (),\n+\t\t\t\t       mappings.get_subst_cb (),\n+\t\t\t\t       mappings.trait_item_mode ());\n+}\n+\n+bool\n+SubstitutionRef::are_mappings_bound (SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      auto &subst = substitutions.at (i);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      if (mappings.size () == substitutions.size ())\n+\t{\n+\t  mappings.get_argument_at (i, &arg);\n+\t}\n+      else\n+\t{\n+\t  if (subst.needs_substitution ())\n+\t    {\n+\t      // get from passed in mappings\n+\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+\t    }\n+\t  else\n+\t    {\n+\t      // we should already have this somewhere\n+\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n+\t\t\t\t\t\t      &arg);\n+\t    }\n+\t}\n+\n+      bool ok = !arg.is_error ();\n+      if (ok)\n+\t{\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return !resolved_mappings.empty ();\n+}\n+\n+// this function assumes that the mappings being passed are for the same type as\n+// this new substitution reference so ordering matters here\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_mappings_from_receiver_for_self (\n+  SubstitutionArgumentMappings &mappings) const\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  rust_assert (mappings.size () == get_num_substitutions ());\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      const SubstitutionParamMapping &param_mapping = substitutions.at (i);\n+      SubstitutionArg &arg = mappings.get_mappings ().at (i);\n+\n+      if (param_mapping.needs_substitution ())\n+\t{\n+\t  SubstitutionArg adjusted (&param_mapping, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_binding_args (),\n+\t\t\t\t       mappings.get_locus ());\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n+\t\t\t\t\t\t   SubstitutionRef &to)\n+{\n+  rust_assert (!ref.needs_substitution ());\n+  rust_assert (needs_substitution ());\n+  rust_assert (get_num_substitutions () == ref.get_num_substitutions ());\n+\n+  Location locus = used_arguments.get_locus ();\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  std::map<HirId, std::pair<ParamType *, BaseType *>> substs;\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      SubstitutionParamMapping &a = substitutions.at (i);\n+      SubstitutionParamMapping &b = ref.substitutions.at (i);\n+\n+      if (a.need_substitution ())\n+\t{\n+\t  const BaseType *root = a.get_param_ty ()->resolve ()->get_root ();\n+\t  rust_assert (root->get_kind () == TyTy::TypeKind::PARAM);\n+\t  const ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+\n+\t  substs[p->get_ty_ref ()] = {static_cast<ParamType *> (p->clone ()),\n+\t\t\t\t      b.get_param_ty ()->resolve ()};\n+\t}\n+    }\n+\n+  for (auto it = substs.begin (); it != substs.end (); it++)\n+    {\n+      HirId param_id = it->first;\n+      BaseType *arg = it->second.second;\n+\n+      const SubstitutionParamMapping *associate_param = nullptr;\n+      for (SubstitutionParamMapping &p : to.substitutions)\n+\t{\n+\t  if (p.get_param_ty ()->get_ty_ref () == param_id)\n+\t    {\n+\t      associate_param = &p;\n+\t      break;\n+\t    }\n+\t}\n+\n+      rust_assert (associate_param != nullptr);\n+      SubstitutionArg argument (associate_param, arg);\n+      resolved_mappings.push_back (std::move (argument));\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings, {}, locus);\n+}\n+\n+bool\n+SubstitutionRef::monomorphize ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  for (const auto &subst : get_substs ())\n+    {\n+      const TyTy::ParamType *pty = subst.get_param_ty ();\n+\n+      if (!pty->can_resolve ())\n+\tcontinue;\n+\n+      const TyTy::BaseType *binding = pty->resolve ();\n+      if (binding->get_kind () == TyTy::TypeKind::PARAM)\n+\tcontinue;\n+\n+      for (const auto &bound : pty->get_specified_bounds ())\n+\t{\n+\t  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n+\n+\t  // setup any associated type mappings for the specified bonds and this\n+\t  // type\n+\t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n+\t  std::vector<Resolver::AssociatedImplTrait *> associated_impl_traits;\n+\t  for (auto &probed_bound : candidates)\n+\t    {\n+\t      const Resolver::TraitReference *bound_trait_ref\n+\t\t= probed_bound.first;\n+\t      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+\t      HirId impl_block_id\n+\t\t= associated_impl->get_mappings ().get_hirid ();\n+\t      Resolver::AssociatedImplTrait *associated = nullptr;\n+\t      bool found_impl_trait\n+\t\t= context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t\t &associated);\n+\t      if (found_impl_trait)\n+\t\t{\n+\t\t  bool found_trait\n+\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t\t  bool found_self\n+\t\t    = associated->get_self ()->can_eq (binding, false);\n+\t\t  if (found_trait && found_self)\n+\t\t    {\n+\t\t      associated_impl_traits.push_back (associated);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (!associated_impl_traits.empty ())\n+\t    {\n+\t      // This code is important when you look at slices for example when\n+\t      // you have a slice such as:\n+\t      //\n+\t      // let slice = &array[1..3]\n+\t      //\n+\t      // the higher ranked bounds will end up having an Index trait\n+\t      // implementation for Range<usize> so we need this code to resolve\n+\t      // that we have an integer inference variable that needs to become\n+\t      // a usize\n+\t      //\n+\t      // The other complicated issue is that we might have an intrinsic\n+\t      // which requires the :Clone or Copy bound but the libcore adds\n+\t      // implementations for all the integral types so when there are\n+\t      // multiple candidates we need to resolve to the default\n+\t      // implementation for that type otherwise its an error for\n+\t      // ambiguous type bounds\n+\n+\t      if (associated_impl_traits.size () == 1)\n+\t\t{\n+\t\t  Resolver::AssociatedImplTrait *associate_impl_trait\n+\t\t    = associated_impl_traits.at (0);\n+\t\t  associate_impl_trait->setup_associated_types (binding, bound);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // if we have a non-general inference variable we need to be\n+\t\t  // careful about the selection here\n+\t\t  bool is_infer_var\n+\t\t    = binding->get_kind () == TyTy::TypeKind::INFER;\n+\t\t  bool is_integer_infervar\n+\t\t    = is_infer_var\n+\t\t      && static_cast<const TyTy::InferType *> (binding)\n+\t\t\t     ->get_infer_kind ()\n+\t\t\t   == TyTy::InferType::InferTypeKind::INTEGRAL;\n+\t\t  bool is_float_infervar\n+\t\t    = is_infer_var\n+\t\t      && static_cast<const TyTy::InferType *> (binding)\n+\t\t\t     ->get_infer_kind ()\n+\t\t\t   == TyTy::InferType::InferTypeKind::FLOAT;\n+\n+\t\t  Resolver::AssociatedImplTrait *associate_impl_trait = nullptr;\n+\t\t  if (is_integer_infervar)\n+\t\t    {\n+\t\t      TyTy::BaseType *type = nullptr;\n+\t\t      bool ok = context->lookup_builtin (\"i32\", &type);\n+\t\t      rust_assert (ok);\n+\n+\t\t      for (auto &impl : associated_impl_traits)\n+\t\t\t{\n+\t\t\t  bool found = impl->get_self ()->is_equal (*type);\n+\t\t\t  if (found)\n+\t\t\t    {\n+\t\t\t      associate_impl_trait = impl;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (is_float_infervar)\n+\t\t    {\n+\t\t      TyTy::BaseType *type = nullptr;\n+\t\t      bool ok = context->lookup_builtin (\"f64\", &type);\n+\t\t      rust_assert (ok);\n+\n+\t\t      for (auto &impl : associated_impl_traits)\n+\t\t\t{\n+\t\t\t  bool found = impl->get_self ()->is_equal (*type);\n+\t\t\t  if (found)\n+\t\t\t    {\n+\t\t\t      associate_impl_trait = impl;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  if (associate_impl_trait == nullptr)\n+\t\t    {\n+\t\t      // go for the first one? or error out?\n+\t\t      auto &mappings = *Analysis::Mappings::get ();\n+\t\t      const auto &type_param = subst.get_generic_param ();\n+\t\t      const auto *trait_ref = bound.get ();\n+\n+\t\t      RichLocation r (type_param.get_locus ());\n+\t\t      r.add_range (bound.get_locus ());\n+\t\t      r.add_range (\n+\t\t\tmappings.lookup_location (binding->get_ref ()));\n+\n+\t\t      rust_error_at (\n+\t\t\tr, \"ambiguous type bound for trait %s and type %s\",\n+\t\t\ttrait_ref->get_name ().c_str (),\n+\t\t\tbinding->get_name ().c_str ());\n+\n+\t\t      return false;\n+\t\t    }\n+\n+\t\t  associate_impl_trait->setup_associated_types (binding, bound);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "982861e9bc663939d2bd3a290e1832ad328c3db0", "filename": "gcc/rust/typecheck/rust-tyty-subst.h", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,317 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_SUBST_H\n+#define RUST_TYTY_SUBST_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-location.h\"\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-tyty-bounds.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseType;\n+class ParamType;\n+class SubstitutionArgumentMappings;\n+class SubstitutionParamMapping\n+{\n+public:\n+  SubstitutionParamMapping (const HIR::TypeParam &generic, ParamType *param);\n+\n+  SubstitutionParamMapping (const SubstitutionParamMapping &other);\n+\n+  std::string as_string () const;\n+\n+  bool fill_param_ty (SubstitutionArgumentMappings &subst_mappings,\n+\t\t      Location locus);\n+\n+  SubstitutionParamMapping clone () const;\n+\n+  ParamType *get_param_ty ();\n+\n+  const ParamType *get_param_ty () const;\n+\n+  const HIR::TypeParam &get_generic_param () const;\n+\n+  // this is used for the backend to override the HirId ref of the param to\n+  // what the concrete type is for the rest of the context\n+  void override_context ();\n+\n+  bool needs_substitution () const;\n+\n+  Location get_param_locus () const;\n+\n+  bool param_has_default_ty () const;\n+\n+  BaseType *get_default_ty () const;\n+\n+  bool need_substitution () const;\n+\n+private:\n+  const HIR::TypeParam &generic;\n+  ParamType *param;\n+};\n+\n+class SubstitutionArg\n+{\n+public:\n+  SubstitutionArg (const SubstitutionParamMapping *param, BaseType *argument);\n+\n+  // FIXME\n+  // the copy constructors need removed - they are unsafe see\n+  // TypeBoundPredicate\n+  SubstitutionArg (const SubstitutionArg &other);\n+\n+  SubstitutionArg &operator= (const SubstitutionArg &other);\n+\n+  BaseType *get_tyty ();\n+\n+  const BaseType *get_tyty () const;\n+\n+  const SubstitutionParamMapping *get_param_mapping () const;\n+\n+  static SubstitutionArg error ();\n+\n+  bool is_error () const;\n+\n+  bool is_conrete () const;\n+\n+  std::string as_string () const;\n+\n+private:\n+  const SubstitutionParamMapping *param;\n+  BaseType *argument;\n+};\n+\n+typedef std::function<void (const ParamType &, const SubstitutionArg &)>\n+  ParamSubstCb;\n+class SubstitutionArgumentMappings\n+{\n+public:\n+  SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n+\t\t\t\tstd::map<std::string, BaseType *> binding_args,\n+\t\t\t\tLocation locus,\n+\t\t\t\tParamSubstCb param_subst_cb = nullptr,\n+\t\t\t\tbool trait_item_flag = false);\n+\n+  SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other);\n+  SubstitutionArgumentMappings &\n+  operator= (const SubstitutionArgumentMappings &other);\n+\n+  SubstitutionArgumentMappings (SubstitutionArgumentMappings &&other) = default;\n+  SubstitutionArgumentMappings &operator= (SubstitutionArgumentMappings &&other)\n+    = default;\n+\n+  static SubstitutionArgumentMappings error ();\n+\n+  bool is_error () const;\n+\n+  bool get_argument_for_symbol (const ParamType *param_to_find,\n+\t\t\t\tSubstitutionArg *argument);\n+\n+  bool get_argument_at (size_t index, SubstitutionArg *argument);\n+\n+  // is_concrete means if the used args is non error, ie: non empty this will\n+  // verify if actual real types have been put in place of are they still\n+  // ParamTy\n+  bool is_concrete () const;\n+\n+  Location get_locus () const;\n+\n+  size_t size () const;\n+\n+  bool is_empty () const;\n+\n+  std::vector<SubstitutionArg> &get_mappings ();\n+\n+  const std::vector<SubstitutionArg> &get_mappings () const;\n+\n+  std::map<std::string, BaseType *> &get_binding_args ();\n+\n+  const std::map<std::string, BaseType *> &get_binding_args () const;\n+\n+  std::string as_string () const;\n+\n+  void on_param_subst (const ParamType &p, const SubstitutionArg &a) const;\n+\n+  ParamSubstCb get_subst_cb () const;\n+\n+  bool trait_item_mode () const;\n+\n+private:\n+  std::vector<SubstitutionArg> mappings;\n+  std::map<std::string, BaseType *> binding_args;\n+  Location locus;\n+  ParamSubstCb param_subst_cb;\n+  bool trait_item_flag;\n+};\n+\n+class SubstitutionRef\n+{\n+public:\n+  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions,\n+\t\t   SubstitutionArgumentMappings arguments);\n+\n+  bool has_substitutions () const;\n+\n+  std::string subst_as_string () const;\n+\n+  bool supports_associated_bindings () const;\n+\n+  // this is overridden in TypeBoundPredicate\n+  // which support bindings we don't add them directly to the SubstitutionRef\n+  // base class because this class represents the fn<X: Foo, Y: Bar>. The only\n+  // construct which supports associated types\n+  virtual size_t get_num_associated_bindings () const;\n+\n+  // this is overridden in TypeBoundPredicate\n+  virtual TypeBoundPredicateItem\n+  lookup_associated_type (const std::string &search);\n+\n+  size_t get_num_substitutions () const;\n+\n+  std::vector<SubstitutionParamMapping> &get_substs ();\n+\n+  const std::vector<SubstitutionParamMapping> &get_substs () const;\n+\n+  std::vector<SubstitutionParamMapping> clone_substs () const;\n+\n+  void override_context ();\n+\n+  bool needs_substitution () const;\n+\n+  bool was_substituted () const;\n+\n+  SubstitutionArgumentMappings &get_substitution_arguments ();\n+  const SubstitutionArgumentMappings &get_substitution_arguments () const;\n+\n+  // this is the count of type params that are not substituted fuly\n+  size_t num_required_substitutions () const;\n+\n+  // this is the count of type params that need substituted taking into account\n+  // possible defaults\n+  size_t min_required_substitutions () const;\n+\n+  // We are trying to subst <i32, f32> into Struct Foo<X,Y> {}\n+  // in the case of Foo<i32,f32>{...}\n+  //\n+  // the substitions we have here define X,Y but the arguments have no bindings\n+  // so its a matter of ordering\n+  SubstitutionArgumentMappings\n+  get_mappings_from_generic_args (HIR::GenericArgs &args);\n+\n+  // Recursive substitutions\n+  // Foo <A,B> { a:A, b: B}; Bar <X,Y,Z>{a:X, b: Foo<Y,Z>}\n+  //\n+  // we have bindings for X Y Z and need to propagate the binding Y,Z into Foo\n+  // Which binds to A,B\n+  SubstitutionArgumentMappings\n+  adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n+\n+  // Are the mappings here actually bound to this type. For example imagine the\n+  // case:\n+  //\n+  // struct Foo<T>(T);\n+  // impl<T> Foo<T> {\n+  //   fn test(self) { ... }\n+  // }\n+  //\n+  // In this case we have a generic ADT of Foo and an impl block of a generic T\n+  // on Foo for the Self type. When we it comes to path resolution we can have:\n+  //\n+  // Foo::<i32>::test()\n+  //\n+  // This means the first segment of Foo::<i32> returns the ADT Foo<i32> not the\n+  // Self ADT bound to the T from the impl block. This means when it comes to\n+  // the next segment of test which resolves to the function we need to check\n+  // wether the arguments in the struct definition of foo can be bound here\n+  // before substituting the previous segments type here. This functions acts as\n+  // a guard for the solve_mappings_from_receiver_for_self to handle the case\n+  // where arguments are not bound. This is important for this next case:\n+  //\n+  // struct Baz<A, B>(A, B);\n+  // impl Baz<i32, f32> {\n+  //   fn test<X>(a: X) -> X {\n+  //       a\n+  //   }\n+  // }\n+  //\n+  // In this case Baz has been already substituted for the impl's Self to become\n+  // ADT<i32, f32> so that the function test only has 1 generic argument of X.\n+  // The path for this will be:\n+  //\n+  // Baz::test::<_>(123)\n+  //\n+  // So the first segment here will be Baz<_, _> to try and infer the arguments\n+  // which will be taken from the impl's Self type in this case since it is\n+  // already substituted and like the previous case the check to see if we need\n+  // to inherit the previous segments generic arguments takes place but the\n+  // generic arguments are not bound to this type as they have already been\n+  // substituted.\n+  //\n+  // Its important to remember from the first example the FnType actually looks\n+  // like:\n+  //\n+  // fn <T>test(self :Foo<T>(T))\n+  //\n+  // As the generic parameters are \"bound\" to each of the items in the impl\n+  // block. So this check is about wether the arguments we have here can\n+  // actually be bound to this type.\n+  bool are_mappings_bound (SubstitutionArgumentMappings &mappings);\n+\n+  // struct Foo<A, B>(A, B);\n+  //\n+  // impl<T> Foo<T, f32>;\n+  //     -> fn test<X>(self, a: X) -> X\n+  //\n+  // We might invoke this via:\n+  //\n+  // a = Foo(123, 456f32);\n+  // b = a.test::<bool>(false);\n+  //\n+  // we need to figure out relevant generic arguemts for self to apply to the\n+  // fntype\n+  SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n+    SubstitutionArgumentMappings &mappings) const;\n+\n+  // TODO comment\n+  SubstitutionArgumentMappings\n+  solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n+\n+  // TODO comment\n+  BaseType *infer_substitions (Location locus);\n+\n+  // TODO comment\n+  bool monomorphize ();\n+\n+  // TODO comment\n+  virtual BaseType *handle_substitions (SubstitutionArgumentMappings &mappings)\n+    = 0;\n+\n+  SubstitutionArgumentMappings get_used_arguments () const;\n+\n+protected:\n+  std::vector<SubstitutionParamMapping> substitutions;\n+  SubstitutionArgumentMappings used_arguments;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+#endif // RUST_TYTY_SUBST_H"}, {"sha": "5037f68cb3f184f4dd04dc00b641dddbaf90c34f", "filename": "gcc/rust/typecheck/rust-tyty-util.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-util.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,116 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+TyVar::TyVar (HirId ref) : ref (ref)\n+{\n+  // ensure this reference is defined within the context\n+  auto context = Resolver::TypeCheckContext::get ();\n+  BaseType *lookup = nullptr;\n+  bool ok = context->lookup_type (ref, &lookup);\n+  rust_assert (ok);\n+}\n+\n+BaseType *\n+TyVar::get_tyty () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  BaseType *lookup = nullptr;\n+  bool ok = context->lookup_type (ref, &lookup);\n+  rust_assert (ok);\n+  return lookup;\n+}\n+\n+TyVar\n+TyVar::get_implicit_infer_var (Location locus)\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  InferType *infer = new InferType (mappings->get_next_hir_id (),\n+\t\t\t\t    InferType::InferTypeKind::GENERAL, locus);\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       infer->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tinfer);\n+  mappings->insert_location (infer->get_ref (), locus);\n+\n+  return TyVar (infer->get_ref ());\n+}\n+\n+TyVar\n+TyVar::subst_covariant_var (TyTy::BaseType *orig, TyTy::BaseType *subst)\n+{\n+  if (orig->get_kind () != TyTy::TypeKind::PARAM)\n+    return TyVar (subst->get_ty_ref ());\n+  else if (subst->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (subst);\n+      if (p->resolve ()->get_kind () == TyTy::TypeKind::PARAM)\n+\t{\n+\t  return TyVar (subst->get_ty_ref ());\n+\t}\n+    }\n+\n+  return TyVar (subst->get_ref ());\n+}\n+\n+TyVar\n+TyVar::clone () const\n+{\n+  TyTy::BaseType *c = get_tyty ()->clone ();\n+  return TyVar (c->get_ref ());\n+}\n+\n+TyVar\n+TyVar::monomorphized_clone () const\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  // this needs a new hirid\n+  TyTy::BaseType *c = get_tyty ()->monomorphized_clone ();\n+  c->set_ref (mappings->get_next_hir_id ());\n+\n+  // insert it\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID, c->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tc);\n+\n+  return TyVar (c->get_ref ());\n+}\n+\n+TyWithLocation::TyWithLocation (BaseType *ty, Location locus)\n+  : ty (ty), locus (locus)\n+{}\n+\n+TyWithLocation::TyWithLocation (BaseType *ty) : ty (ty)\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  locus = mappings->lookup_location (ty->get_ref ());\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "eccbb4423d54252e0ce219603e2ac4bf26addfba", "filename": "gcc/rust/typecheck/rust-tyty-util.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-util.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_UTIL_H\n+#define RUST_TYTY_UTIL_H\n+\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseType;\n+\n+// this is a placeholder for types that can change like inference variables\n+class TyVar\n+{\n+public:\n+  explicit TyVar (HirId ref);\n+\n+  HirId get_ref () const { return ref; }\n+\n+  BaseType *get_tyty () const;\n+\n+  TyVar clone () const;\n+\n+  TyVar monomorphized_clone () const;\n+\n+  static TyVar get_implicit_infer_var (Location locus);\n+\n+  static TyVar subst_covariant_var (TyTy::BaseType *orig,\n+\t\t\t\t    TyTy::BaseType *subst);\n+\n+private:\n+  HirId ref;\n+};\n+\n+class TyWithLocation\n+{\n+public:\n+  explicit TyWithLocation (BaseType *ty, Location locus);\n+  explicit TyWithLocation (BaseType *ty);\n+\n+  BaseType *get_ty () const { return ty; }\n+  Location get_locus () const { return locus; }\n+\n+private:\n+  BaseType *ty;\n+  Location locus;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_UTIL_H"}, {"sha": "8c3bed456a4e6bf92a731e930af4f61828a8ad40", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 1138, "deletions": 669, "changes": 1807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -17,17 +17,21 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-tyty.h\"\n-#include \"rust-tyty-visitor.h\"\n-#include \"rust-tyty-call.h\"\n+\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-type.h\"\n-#include \"rust-tyty-rules.h\"\n-#include \"rust-tyty-cmp.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty-call.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-location.h\"\n+#include \"rust-linemap.h\"\n+\n #include \"rust-substitution-mapper.h\"\n-#include \"rust-hir-trait-ref.h\"\n+#include \"rust-hir-trait-reference.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-trait-resolve.h\"\n+#include \"rust-tyty-cmp.h\"\n+\n #include \"options.h\"\n \n namespace Rust {\n@@ -146,6 +150,122 @@ is_primitive_type_kind (TypeKind kind)\n     }\n }\n \n+// BASE TYPE\n+\n+BaseType::BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n+\t\t    std::set<HirId> refs)\n+  : TypeBoundsMappings ({}), kind (kind), ref (ref), ty_ref (ty_ref),\n+    combined (refs), ident (ident), mappings (Analysis::Mappings::get ())\n+{}\n+\n+BaseType::BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n+\t\t    std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t    std::set<HirId> refs)\n+  : TypeBoundsMappings (specified_bounds), kind (kind), ref (ref),\n+    ty_ref (ty_ref), combined (refs), ident (ident),\n+    mappings (Analysis::Mappings::get ())\n+{}\n+\n+BaseType::~BaseType () {}\n+\n+HirId\n+BaseType::get_ref () const\n+{\n+  return ref;\n+}\n+\n+void\n+BaseType::set_ref (HirId id)\n+{\n+  if (id != ref)\n+    append_reference (ref);\n+  ref = id;\n+}\n+\n+HirId\n+BaseType::get_ty_ref () const\n+{\n+  return ty_ref;\n+}\n+\n+void\n+BaseType::set_ty_ref (HirId id)\n+{\n+  ty_ref = id;\n+}\n+\n+bool\n+BaseType::is_equal (const BaseType &other) const\n+{\n+  return get_kind () == other.get_kind ();\n+}\n+\n+bool\n+BaseType::is_unit () const\n+{\n+  return false;\n+}\n+\n+TypeKind\n+BaseType::get_kind () const\n+{\n+  return kind;\n+}\n+\n+std::set<HirId>\n+BaseType::get_combined_refs () const\n+{\n+  return combined;\n+}\n+\n+void\n+BaseType::append_reference (HirId id)\n+{\n+  combined.insert (id);\n+}\n+\n+bool\n+BaseType::supports_substitutions () const\n+{\n+  return false;\n+}\n+\n+bool\n+BaseType::has_subsititions_defined () const\n+{\n+  return false;\n+}\n+\n+bool\n+BaseType::can_substitute () const\n+{\n+  return supports_substitutions () && has_subsititions_defined ();\n+}\n+\n+bool\n+BaseType::needs_generic_substitutions () const\n+{\n+  return false;\n+}\n+\n+bool\n+BaseType::contains_type_parameters () const\n+{\n+  return !is_concrete ();\n+}\n+\n+const RustIdent &\n+BaseType::get_ident () const\n+{\n+  return ident;\n+}\n+\n+Location\n+BaseType::get_locus () const\n+{\n+  return ident.locus;\n+}\n+\n bool\n BaseType::satisfies_bound (const TypeBoundPredicate &predicate) const\n {\n@@ -255,6 +375,58 @@ BaseType::get_root () const\n   return root;\n }\n \n+BaseType *\n+BaseType::destructure ()\n+{\n+  int recurisve_ops = 0;\n+  BaseType *x = this;\n+  while (true)\n+    {\n+      if (recurisve_ops++ >= rust_max_recursion_depth)\n+\t{\n+\t  rust_error_at (\n+\t    Location (),\n+\t    \"%<recursion depth%> count exceeds limit of %i (use \"\n+\t    \"%<frust-max-recursion-depth=%> to increase the limit)\",\n+\t    rust_max_recursion_depth);\n+\t  return new ErrorType (get_ref ());\n+\t}\n+\n+      switch (x->get_kind ())\n+\t{\n+\t  case TyTy::TypeKind::PARAM: {\n+\t    TyTy::ParamType *p = static_cast<TyTy::ParamType *> (x);\n+\t    TyTy::BaseType *pr = p->resolve ();\n+\t    if (pr == x)\n+\t      return pr;\n+\n+\t    x = pr;\n+\t  }\n+\t  break;\n+\n+\t  case TyTy::TypeKind::PLACEHOLDER: {\n+\t    TyTy::PlaceholderType *p = static_cast<TyTy::PlaceholderType *> (x);\n+\t    if (!p->can_resolve ())\n+\t      return p;\n+\n+\t    x = p->resolve ();\n+\t  }\n+\t  break;\n+\n+\t  case TyTy::TypeKind::PROJECTION: {\n+\t    TyTy::ProjectionType *p = static_cast<TyTy::ProjectionType *> (x);\n+\t    x = p->get ();\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  return x;\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n const BaseType *\n BaseType::destructure () const\n {\n@@ -276,14 +448,20 @@ BaseType::destructure () const\n \t{\n \t  case TyTy::TypeKind::PARAM: {\n \t    const TyTy::ParamType *p = static_cast<const TyTy::ParamType *> (x);\n-\t    x = p->resolve ();\n+\t    const TyTy::BaseType *pr = p->resolve ();\n+\t    if (pr == x)\n+\t      return pr;\n+\n+\t    x = pr;\n \t  }\n \t  break;\n \n \t  case TyTy::TypeKind::PLACEHOLDER: {\n \t    const TyTy::PlaceholderType *p\n \t      = static_cast<const TyTy::PlaceholderType *> (x);\n-\t    rust_assert (p->can_resolve ());\n+\t    if (!p->can_resolve ())\n+\t      return p;\n+\n \t    x = p->resolve ();\n \t  }\n \t  break;\n@@ -330,94 +508,38 @@ BaseType::debug () const\n \t      debug_str ().c_str ());\n }\n \n-TyVar::TyVar (HirId ref) : ref (ref)\n-{\n-  // ensure this reference is defined within the context\n-  auto context = Resolver::TypeCheckContext::get ();\n-  BaseType *lookup = nullptr;\n-  bool ok = context->lookup_type (ref, &lookup);\n-  rust_assert (ok);\n-}\n-\n-BaseType *\n-TyVar::get_tyty () const\n-{\n-  auto context = Resolver::TypeCheckContext::get ();\n-  BaseType *lookup = nullptr;\n-  bool ok = context->lookup_type (ref, &lookup);\n-  rust_assert (ok);\n-  return lookup;\n-}\n+// InferType\n \n-TyVar\n-TyVar::get_implicit_infer_var (Location locus)\n-{\n-  auto mappings = Analysis::Mappings::get ();\n-  auto context = Resolver::TypeCheckContext::get ();\n-\n-  InferType *infer = new InferType (mappings->get_next_hir_id (),\n-\t\t\t\t    InferType::InferTypeKind::GENERAL, locus);\n-  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t       UNKNOWN_NODEID,\n-\t\t\t\t\t       infer->get_ref (),\n-\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n-\t\t\tinfer);\n-  mappings->insert_location (infer->get_ref (), locus);\n-\n-  return TyVar (infer->get_ref ());\n-}\n-\n-TyVar\n-TyVar::subst_covariant_var (TyTy::BaseType *orig, TyTy::BaseType *subst)\n-{\n-  if (orig->get_kind () != TyTy::TypeKind::PARAM)\n-    return TyVar (subst->get_ty_ref ());\n-  else if (subst->get_kind () == TyTy::TypeKind::PARAM)\n-    {\n-      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (subst);\n-      if (p->resolve ()->get_kind () == TyTy::TypeKind::PARAM)\n-\t{\n-\t  return TyVar (subst->get_ty_ref ());\n-\t}\n-    }\n+InferType::InferType (HirId ref, InferTypeKind infer_kind, Location locus,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::INFER,\n+\t      {Resolver::CanonicalPath::create_empty (), locus}, refs),\n+    infer_kind (infer_kind)\n+{}\n \n-  return TyVar (subst->get_ref ());\n-}\n+InferType::InferType (HirId ref, HirId ty_ref, InferTypeKind infer_kind,\n+\t\t      Location locus, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::INFER,\n+\t      {Resolver::CanonicalPath::create_empty (), locus}, refs),\n+    infer_kind (infer_kind)\n+{}\n \n-TyVar\n-TyVar::clone () const\n+InferType::InferTypeKind\n+InferType::get_infer_kind () const\n {\n-  TyTy::BaseType *c = get_tyty ()->clone ();\n-  return TyVar (c->get_ref ());\n+  return infer_kind;\n }\n \n-TyVar\n-TyVar::monomorphized_clone () const\n+std::string\n+InferType::get_name () const\n {\n-  auto mappings = Analysis::Mappings::get ();\n-  auto context = Resolver::TypeCheckContext::get ();\n-\n-  // this needs a new hirid\n-  TyTy::BaseType *c = get_tyty ()->monomorphized_clone ();\n-  c->set_ref (mappings->get_next_hir_id ());\n-\n-  // insert it\n-  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t       UNKNOWN_NODEID, c->get_ref (),\n-\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n-\t\t\tc);\n-\n-  return TyVar (c->get_ref ());\n+  return as_string ();\n }\n \n-TyWithLocation::TyWithLocation (BaseType *ty, Location locus)\n-  : ty (ty), locus (locus)\n-{}\n-\n-TyWithLocation::TyWithLocation (BaseType *ty) : ty (ty)\n+bool\n+InferType::is_concrete () const\n {\n-  auto mappings = Analysis::Mappings::get ();\n-  locus = mappings->lookup_location (ty->get_ref ());\n+  return true;\n }\n \n void\n@@ -447,13 +569,6 @@ InferType::as_string () const\n   return \"<infer::error>\";\n }\n \n-BaseType *\n-InferType::unify (BaseType *other)\n-{\n-  InferRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n InferType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -525,6 +640,35 @@ InferType::default_type (BaseType **type) const\n   return false;\n }\n \n+// ErrorType\n+\n+ErrorType::ErrorType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::ERROR,\n+\t      {Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n+{}\n+\n+ErrorType::ErrorType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::ERROR,\n+\t      {Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n+{}\n+\n+bool\n+ErrorType::is_unit () const\n+{\n+  return true;\n+}\n+bool\n+ErrorType::is_concrete () const\n+{\n+  return false;\n+}\n+\n+std::string\n+ErrorType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n void\n ErrorType::accept_vis (TyVisitor &vis)\n {\n@@ -543,12 +687,6 @@ ErrorType::as_string () const\n   return \"<tyty::error>\";\n }\n \n-BaseType *\n-ErrorType::unify (BaseType *other)\n-{\n-  return this;\n-}\n-\n bool\n ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -567,6 +705,55 @@ ErrorType::monomorphized_clone () const\n   return clone ();\n }\n \n+// Struct Field type\n+\n+StructFieldType::StructFieldType (HirId ref, std::string name, BaseType *ty,\n+\t\t\t\t  Location locus)\n+  : ref (ref), name (name), ty (ty), locus (locus)\n+{}\n+\n+HirId\n+StructFieldType::get_ref () const\n+{\n+  return ref;\n+}\n+\n+std::string\n+StructFieldType::get_name () const\n+{\n+  return name;\n+}\n+\n+BaseType *\n+StructFieldType::get_field_type () const\n+{\n+  return ty;\n+}\n+\n+void\n+StructFieldType::set_field_type (BaseType *fty)\n+{\n+  ty = fty;\n+}\n+\n+bool\n+StructFieldType::is_concrete () const\n+{\n+  return ty->is_concrete ();\n+}\n+\n+void\n+StructFieldType::debug () const\n+{\n+  rust_debug (\"%s\", as_string ().c_str ());\n+}\n+\n+Location\n+StructFieldType::get_locus () const\n+{\n+  return locus;\n+}\n+\n std::string\n StructFieldType::as_string () const\n {\n@@ -604,472 +791,241 @@ StructFieldType::monomorphized_clone () const\n \t\t\t      get_field_type ()->monomorphized_clone (), locus);\n }\n \n-bool\n-SubstitutionParamMapping::need_substitution () const\n-{\n-  if (!param->can_resolve ())\n-    return true;\n-\n-  auto resolved = param->resolve ();\n-  return !resolved->is_concrete ();\n-}\n+// VariantDef\n \n-bool\n-SubstitutionParamMapping::fill_param_ty (\n-  SubstitutionArgumentMappings &subst_mappings, Location locus)\n+std::string\n+VariantDef::variant_type_string (VariantType type)\n {\n-  SubstitutionArg arg = SubstitutionArg::error ();\n-  bool ok = subst_mappings.get_argument_for_symbol (get_param_ty (), &arg);\n-  if (!ok)\n-    return true;\n-\n-  TyTy::BaseType &type = *arg.get_tyty ();\n-  if (type.get_kind () == TyTy::TypeKind::INFER)\n-    {\n-      type.inherit_bounds (*param);\n-    }\n-  else\n-    {\n-      if (!param->bounds_compatible (type, locus, true))\n-\treturn false;\n-    }\n-\n-  if (type.get_kind () == TypeKind::PARAM)\n-    {\n-      // delete param;\n-      param = static_cast<ParamType *> (type.clone ());\n-    }\n-  else\n+  switch (type)\n     {\n-      // check the substitution is compatible with bounds\n-      if (!param->bounds_compatible (type, locus, true))\n-\treturn false;\n-\n-      // recursively pass this down to all HRTB's\n-      for (auto &bound : param->get_specified_bounds ())\n-\tbound.handle_substitions (subst_mappings);\n-\n-      param->set_ty_ref (type.get_ref ());\n+    case NUM:\n+      return \"enumeral\";\n+    case TUPLE:\n+      return \"tuple\";\n+    case STRUCT:\n+      return \"struct\";\n     }\n-\n-  return true;\n+  gcc_unreachable ();\n+  return \"\";\n }\n \n-void\n-SubstitutionParamMapping::override_context ()\n-{\n-  if (!param->can_resolve ())\n-    return;\n+VariantDef::VariantDef (HirId id, DefId defid, std::string identifier,\n+\t\t\tRustIdent ident, HIR::Expr *discriminant)\n+  : id (id), defid (defid), identifier (identifier), ident (ident),\n+    discriminant (discriminant)\n \n-  auto mappings = Analysis::Mappings::get ();\n-  auto context = Resolver::TypeCheckContext::get ();\n-\n-  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t       UNKNOWN_NODEID,\n-\t\t\t\t\t       param->get_ref (),\n-\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n-\t\t\tparam->resolve ());\n-}\n-\n-SubstitutionArgumentMappings\n-SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n {\n-  std::map<std::string, BaseType *> binding_arguments;\n-  if (args.get_binding_args ().size () > 0)\n-    {\n-      if (supports_associated_bindings ())\n-\t{\n-\t  if (args.get_binding_args ().size () > get_num_associated_bindings ())\n-\t    {\n-\t      RichLocation r (args.get_locus ());\n-\n-\t      rust_error_at (r,\n-\t\t\t     \"generic item takes at most %lu type binding \"\n-\t\t\t     \"arguments but %lu were supplied\",\n-\t\t\t     (unsigned long) get_num_associated_bindings (),\n-\t\t\t     (unsigned long) args.get_binding_args ().size ());\n-\t      return SubstitutionArgumentMappings::error ();\n-\t    }\n-\n-\t  for (auto &binding : args.get_binding_args ())\n-\t    {\n-\t      BaseType *resolved\n-\t\t= Resolver::TypeCheckType::Resolve (binding.get_type ().get ());\n-\t      if (resolved == nullptr\n-\t\t  || resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t\t{\n-\t\t  rust_error_at (binding.get_locus (),\n-\t\t\t\t \"failed to resolve type arguments\");\n-\t\t  return SubstitutionArgumentMappings::error ();\n-\t\t}\n-\n-\t      // resolve to relevant binding\n-\t      auto binding_item\n-\t\t= lookup_associated_type (binding.get_identifier ());\n-\t      if (binding_item.is_error ())\n-\t\t{\n-\t\t  rust_error_at (binding.get_locus (),\n-\t\t\t\t \"unknown associated type binding: %s\",\n-\t\t\t\t binding.get_identifier ().c_str ());\n-\t\t  return SubstitutionArgumentMappings::error ();\n-\t\t}\n-\n-\t      binding_arguments[binding.get_identifier ()] = resolved;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  RichLocation r (args.get_locus ());\n-\t  for (auto &binding : args.get_binding_args ())\n-\t    r.add_range (binding.get_locus ());\n-\n-\t  rust_error_at (r, \"associated type bindings are not allowed here\");\n-\t  return SubstitutionArgumentMappings::error ();\n-\t}\n-    }\n-\n-  // for inherited arguments\n-  size_t offs = used_arguments.size ();\n-  if (args.get_type_args ().size () + offs > substitutions.size ())\n-    {\n-      RichLocation r (args.get_locus ());\n-      r.add_range (substitutions.front ().get_param_locus ());\n-\n-      rust_error_at (\n-\tr,\n-\t\"generic item takes at most %lu type arguments but %lu were supplied\",\n-\t(unsigned long) substitutions.size (),\n-\t(unsigned long) args.get_type_args ().size ());\n-      return SubstitutionArgumentMappings::error ();\n-    }\n-\n-  if (args.get_type_args ().size () + offs < min_required_substitutions ())\n-    {\n-      RichLocation r (args.get_locus ());\n-      r.add_range (substitutions.front ().get_param_locus ());\n-\n-      rust_error_at (\n-\tr,\n-\t\"generic item takes at least %lu type arguments but %lu were supplied\",\n-\t(unsigned long) (min_required_substitutions () - offs),\n-\t(unsigned long) args.get_type_args ().size ());\n-      return SubstitutionArgumentMappings::error ();\n-    }\n-\n-  std::vector<SubstitutionArg> mappings = used_arguments.get_mappings ();\n-  for (auto &arg : args.get_type_args ())\n-    {\n-      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n-      if (resolved == nullptr || resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (args.get_locus (), \"failed to resolve type arguments\");\n-\t  return SubstitutionArgumentMappings::error ();\n-\t}\n-\n-      SubstitutionArg subst_arg (&substitutions.at (offs), resolved);\n-      offs++;\n-      mappings.push_back (std::move (subst_arg));\n-    }\n-\n-  // we must need to fill out defaults\n-  size_t left_over\n-    = num_required_substitutions () - min_required_substitutions ();\n-  if (left_over > 0)\n-    {\n-      for (size_t offs = mappings.size (); offs < substitutions.size (); offs++)\n-\t{\n-\t  SubstitutionParamMapping &param = substitutions.at (offs);\n-\t  rust_assert (param.param_has_default_ty ());\n-\n-\t  BaseType *resolved = param.get_default_ty ();\n-\t  if (resolved->get_kind () == TypeKind::ERROR)\n-\t    return SubstitutionArgumentMappings::error ();\n-\n-\t  // this resolved default might already contain default parameters\n-\t  if (resolved->contains_type_parameters ())\n-\t    {\n-\t      SubstitutionArgumentMappings intermediate (mappings,\n-\t\t\t\t\t\t\t binding_arguments,\n-\t\t\t\t\t\t\t args.get_locus ());\n-\t      resolved = Resolver::SubstMapperInternal::Resolve (resolved,\n-\t\t\t\t\t\t\t\t intermediate);\n-\n-\t      if (resolved->get_kind () == TypeKind::ERROR)\n-\t\treturn SubstitutionArgumentMappings::error ();\n-\t    }\n-\n-\t  SubstitutionArg subst_arg (&param, resolved);\n-\t  mappings.push_back (std::move (subst_arg));\n-\t}\n-    }\n-\n-  return SubstitutionArgumentMappings (mappings, binding_arguments,\n-\t\t\t\t       args.get_locus ());\n+  type = VariantType::NUM;\n+  fields = {};\n }\n \n-BaseType *\n-SubstitutionRef::infer_substitions (Location locus)\n+VariantDef::VariantDef (HirId id, DefId defid, std::string identifier,\n+\t\t\tRustIdent ident, VariantType type,\n+\t\t\tHIR::Expr *discriminant,\n+\t\t\tstd::vector<StructFieldType *> fields)\n+  : id (id), defid (defid), identifier (identifier), ident (ident), type (type),\n+    discriminant (discriminant), fields (fields)\n {\n-  std::vector<SubstitutionArg> args;\n-  std::map<std::string, BaseType *> argument_mappings;\n-  for (auto &p : get_substs ())\n-    {\n-      if (p.needs_substitution ())\n-\t{\n-\t  const std::string &symbol = p.get_param_ty ()->get_symbol ();\n-\t  auto it = argument_mappings.find (symbol);\n-\t  bool have_mapping = it != argument_mappings.end ();\n+  rust_assert ((type == VariantType::NUM && fields.empty ())\n+\t       || (type == VariantType::TUPLE || type == VariantType::STRUCT));\n+}\n \n-\t  if (have_mapping)\n-\t    {\n-\t      args.push_back (SubstitutionArg (&p, it->second));\n-\t    }\n-\t  else\n-\t    {\n-\t      TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n-\t      args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n-\t      argument_mappings[symbol] = infer_var.get_tyty ();\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  args.push_back (SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n-\t}\n-    }\n+VariantDef::VariantDef (const VariantDef &other)\n+  : id (other.id), defid (other.defid), identifier (other.identifier),\n+    ident (other.ident), type (other.type), discriminant (other.discriminant),\n+    fields (other.fields)\n+{}\n \n-  // FIXME do we need to add inference variables to all the possible bindings?\n-  // it might just lead to inference variable hell not 100% sure if rustc does\n-  // this i think the language might needs this to be explicitly set\n+VariantDef &\n+VariantDef::operator= (const VariantDef &other)\n+{\n+  id = other.id;\n+  identifier = other.identifier;\n+  type = other.type;\n+  discriminant = other.discriminant;\n+  fields = other.fields;\n+  ident = other.ident;\n \n-  SubstitutionArgumentMappings infer_arguments (std::move (args),\n-\t\t\t\t\t\t{} /* binding_arguments */,\n-\t\t\t\t\t\tlocus);\n-  return handle_substitions (std::move (infer_arguments));\n+  return *this;\n }\n \n-SubstitutionArgumentMappings\n-SubstitutionRef::adjust_mappings_for_this (\n-  SubstitutionArgumentMappings &mappings)\n+VariantDef &\n+VariantDef::get_error_node ()\n {\n-  std::vector<SubstitutionArg> resolved_mappings;\n-  for (size_t i = 0; i < substitutions.size (); i++)\n-    {\n-      auto &subst = substitutions.at (i);\n-\n-      SubstitutionArg arg = SubstitutionArg::error ();\n-      if (mappings.size () == substitutions.size ())\n-\t{\n-\t  mappings.get_argument_at (i, &arg);\n-\t}\n-      else\n-\t{\n-\t  if (subst.needs_substitution ())\n-\t    {\n-\t      // get from passed in mappings\n-\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n-\t    }\n-\t  else\n-\t    {\n-\t      // we should already have this somewhere\n-\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n-\t\t\t\t\t\t      &arg);\n-\t    }\n-\t}\n-\n-      bool ok = !arg.is_error ();\n-      if (ok)\n-\t{\n-\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n-\t  resolved_mappings.push_back (std::move (adjusted));\n-\t}\n-    }\n-\n-  if (resolved_mappings.empty ())\n-    return SubstitutionArgumentMappings::error ();\n+  static VariantDef node\n+    = VariantDef (UNKNOWN_HIRID, UNKNOWN_DEFID, \"\",\n+\t\t  {Resolver::CanonicalPath::create_empty (),\n+\t\t   Linemap::unknown_location ()},\n+\t\t  nullptr);\n \n-  return SubstitutionArgumentMappings (resolved_mappings,\n-\t\t\t\t       mappings.get_binding_args (),\n-\t\t\t\t       mappings.get_locus (),\n-\t\t\t\t       mappings.get_subst_cb (),\n-\t\t\t\t       mappings.trait_item_mode ());\n+  return node;\n }\n \n bool\n-SubstitutionRef::are_mappings_bound (SubstitutionArgumentMappings &mappings)\n+VariantDef::is_error () const\n {\n-  std::vector<SubstitutionArg> resolved_mappings;\n-  for (size_t i = 0; i < substitutions.size (); i++)\n-    {\n-      auto &subst = substitutions.at (i);\n+  return get_id () == UNKNOWN_HIRID;\n+}\n \n-      SubstitutionArg arg = SubstitutionArg::error ();\n-      if (mappings.size () == substitutions.size ())\n-\t{\n-\t  mappings.get_argument_at (i, &arg);\n-\t}\n-      else\n-\t{\n-\t  if (subst.needs_substitution ())\n-\t    {\n-\t      // get from passed in mappings\n-\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n-\t    }\n-\t  else\n-\t    {\n-\t      // we should already have this somewhere\n-\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n-\t\t\t\t\t\t      &arg);\n-\t    }\n-\t}\n+HirId\n+VariantDef::get_id () const\n+{\n+  return id;\n+}\n \n-      bool ok = !arg.is_error ();\n-      if (ok)\n-\t{\n-\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n-\t  resolved_mappings.push_back (std::move (adjusted));\n-\t}\n-    }\n+DefId\n+VariantDef::get_defid () const\n+{\n+  return defid;\n+}\n \n-  return !resolved_mappings.empty ();\n+VariantDef::VariantType\n+VariantDef::get_variant_type () const\n+{\n+  return type;\n }\n \n-// this function assumes that the mappings being passed are for the same type as\n-// this new substitution reference so ordering matters here\n-SubstitutionArgumentMappings\n-SubstitutionRef::solve_mappings_from_receiver_for_self (\n-  SubstitutionArgumentMappings &mappings) const\n+bool\n+VariantDef::is_data_variant () const\n {\n-  std::vector<SubstitutionArg> resolved_mappings;\n+  return type != VariantType::NUM;\n+}\n \n-  rust_assert (mappings.size () == get_num_substitutions ());\n-  for (size_t i = 0; i < get_num_substitutions (); i++)\n-    {\n-      const SubstitutionParamMapping &param_mapping = substitutions.at (i);\n-      SubstitutionArg &arg = mappings.get_mappings ().at (i);\n+bool\n+VariantDef::is_dataless_variant () const\n+{\n+  return type == VariantType::NUM;\n+}\n \n-      if (param_mapping.needs_substitution ())\n-\t{\n-\t  SubstitutionArg adjusted (&param_mapping, arg.get_tyty ());\n-\t  resolved_mappings.push_back (std::move (adjusted));\n-\t}\n-    }\n+std::string\n+VariantDef::get_identifier () const\n+{\n+  return identifier;\n+}\n \n-  return SubstitutionArgumentMappings (resolved_mappings,\n-\t\t\t\t       mappings.get_binding_args (),\n-\t\t\t\t       mappings.get_locus ());\n+size_t\n+VariantDef::num_fields () const\n+{\n+  return fields.size ();\n }\n \n-SubstitutionArgumentMappings\n-SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n-\t\t\t\t\t\t   SubstitutionRef &to)\n+StructFieldType *\n+VariantDef::get_field_at_index (size_t index)\n {\n-  rust_assert (!ref.needs_substitution ());\n-  rust_assert (needs_substitution ());\n-  rust_assert (get_num_substitutions () == ref.get_num_substitutions ());\n+  rust_assert (index < fields.size ());\n+  return fields.at (index);\n+}\n \n-  Location locus = used_arguments.get_locus ();\n-  std::vector<SubstitutionArg> resolved_mappings;\n+std::vector<StructFieldType *> &\n+VariantDef::get_fields ()\n+{\n+  rust_assert (type != NUM);\n+  return fields;\n+}\n \n-  std::map<HirId, std::pair<ParamType *, BaseType *>> substs;\n-  for (size_t i = 0; i < get_num_substitutions (); i++)\n+bool\n+VariantDef::lookup_field (const std::string &lookup,\n+\t\t\t  StructFieldType **field_lookup, size_t *index) const\n+{\n+  size_t i = 0;\n+  for (auto &field : fields)\n     {\n-      SubstitutionParamMapping &a = substitutions.at (i);\n-      SubstitutionParamMapping &b = ref.substitutions.at (i);\n-\n-      if (a.need_substitution ())\n+      if (field->get_name ().compare (lookup) == 0)\n \t{\n-\t  const BaseType *root = a.get_param_ty ()->resolve ()->get_root ();\n-\t  rust_assert (root->get_kind () == TyTy::TypeKind::PARAM);\n-\t  const ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+\t  if (index != nullptr)\n+\t    *index = i;\n \n-\t  substs[p->get_ty_ref ()] = {static_cast<ParamType *> (p->clone ()),\n-\t\t\t\t      b.get_param_ty ()->resolve ()};\n+\t  if (field_lookup != nullptr)\n+\t    *field_lookup = field;\n+\n+\t  return true;\n \t}\n+      i++;\n     }\n+  return false;\n+}\n \n-  for (auto it = substs.begin (); it != substs.end (); it++)\n-    {\n-      HirId param_id = it->first;\n-      BaseType *arg = it->second.second;\n+HIR::Expr *\n+VariantDef::get_discriminant () const\n+{\n+  rust_assert (discriminant != nullptr);\n+  return discriminant;\n+}\n \n-      const SubstitutionParamMapping *associate_param = nullptr;\n-      for (SubstitutionParamMapping &p : to.substitutions)\n-\t{\n-\t  if (p.get_param_ty ()->get_ty_ref () == param_id)\n-\t    {\n-\t      associate_param = &p;\n-\t      break;\n-\t    }\n-\t}\n+std::string\n+VariantDef::as_string () const\n+{\n+  if (type == VariantType::NUM)\n+    return identifier + \" = \" + discriminant->as_string ();\n \n-      rust_assert (associate_param != nullptr);\n-      SubstitutionArg argument (associate_param, arg);\n-      resolved_mappings.push_back (std::move (argument));\n+  std::string buffer;\n+  for (size_t i = 0; i < fields.size (); ++i)\n+    {\n+      buffer += fields.at (i)->as_string ();\n+      if ((i + 1) < fields.size ())\n+\tbuffer += \", \";\n     }\n \n-  return SubstitutionArgumentMappings (resolved_mappings, {}, locus);\n+  if (type == VariantType::TUPLE)\n+    return identifier + \" (\" + buffer + \")\";\n+  else\n+    return identifier + \" {\" + buffer + \"}\";\n }\n \n bool\n-SubstitutionRef::monomorphize ()\n+VariantDef::is_equal (const VariantDef &other) const\n {\n-  auto context = Resolver::TypeCheckContext::get ();\n-  for (const auto &subst : get_substs ())\n-    {\n-      const TyTy::ParamType *pty = subst.get_param_ty ();\n-\n-      if (!pty->can_resolve ())\n-\tcontinue;\n-\n-      const TyTy::BaseType *binding = pty->resolve ();\n-      if (binding->get_kind () == TyTy::TypeKind::PARAM)\n-\tcontinue;\n+  if (type != other.type)\n+    return false;\n \n-      for (const auto &bound : pty->get_specified_bounds ())\n-\t{\n-\t  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n+  if (identifier.compare (other.identifier) != 0)\n+    return false;\n \n-\t  // setup any associated type mappings for the specified bonds and this\n-\t  // type\n-\t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n+  if (discriminant != other.discriminant)\n+    return false;\n \n-\t  Resolver::AssociatedImplTrait *associated_impl_trait = nullptr;\n-\t  for (auto &probed_bound : candidates)\n-\t    {\n-\t      const Resolver::TraitReference *bound_trait_ref\n-\t\t= probed_bound.first;\n-\t      const HIR::ImplBlock *associated_impl = probed_bound.second;\n-\n-\t      HirId impl_block_id\n-\t\t= associated_impl->get_mappings ().get_hirid ();\n-\t      Resolver::AssociatedImplTrait *associated = nullptr;\n-\t      bool found_impl_trait\n-\t\t= context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t\t &associated);\n-\t      if (found_impl_trait)\n-\t\t{\n-\t\t  bool found_trait\n-\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n-\t\t  bool found_self\n-\t\t    = associated->get_self ()->can_eq (binding, false);\n-\t\t  if (found_trait && found_self)\n-\t\t    {\n-\t\t      associated_impl_trait = associated;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n+  if (fields.size () != other.fields.size ())\n+    return false;\n \n-\t  if (associated_impl_trait != nullptr)\n-\t    {\n-\t      associated_impl_trait->setup_associated_types (binding, bound);\n-\t    }\n-\t}\n+  for (size_t i = 0; i < fields.size (); i++)\n+    {\n+      if (!fields.at (i)->is_equal (*other.fields.at (i)))\n+\treturn false;\n     }\n \n   return true;\n }\n \n+VariantDef *\n+VariantDef::clone () const\n+{\n+  std::vector<StructFieldType *> cloned_fields;\n+  for (auto &f : fields)\n+    cloned_fields.push_back ((StructFieldType *) f->clone ());\n+\n+  return new VariantDef (id, defid, identifier, ident, type, discriminant,\n+\t\t\t cloned_fields);\n+}\n+\n+VariantDef *\n+VariantDef::monomorphized_clone () const\n+{\n+  std::vector<StructFieldType *> cloned_fields;\n+  for (auto &f : fields)\n+    cloned_fields.push_back ((StructFieldType *) f->monomorphized_clone ());\n+\n+  return new VariantDef (id, defid, identifier, ident, type, discriminant,\n+\t\t\t cloned_fields);\n+}\n+\n+const RustIdent &\n+VariantDef::get_ident () const\n+{\n+  return ident;\n+}\n+\n+// ADTType\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -1097,13 +1053,6 @@ ADTType::as_string () const\n   return identifier + subst_as_string () + \"{\" + variants_buffer + \"}\";\n }\n \n-BaseType *\n-ADTType::unify (BaseType *other)\n-{\n-  ADTRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ADTType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1236,7 +1185,7 @@ handle_substitions (SubstitutionArgumentMappings &subst_mappings,\n }\n \n ADTType *\n-ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+ADTType::handle_substitions (SubstitutionArgumentMappings &subst_mappings)\n {\n   ADTType *adt = static_cast<ADTType *> (clone ());\n   adt->set_ty_ref (mappings->get_next_hir_id ());\n@@ -1267,6 +1216,57 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n   return adt;\n }\n \n+// TupleType\n+\n+TupleType::TupleType (HirId ref, Location locus, std::vector<TyVar> fields,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::TUPLE,\n+\t      {Resolver::CanonicalPath::create_empty (), locus}, refs),\n+    fields (fields)\n+{}\n+\n+TupleType::TupleType (HirId ref, HirId ty_ref, Location locus,\n+\t\t      std::vector<TyVar> fields, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::TUPLE,\n+\t      {Resolver::CanonicalPath::create_empty (), locus}, refs),\n+    fields (fields)\n+{}\n+\n+TupleType *\n+TupleType::get_unit_type (HirId ref)\n+{\n+  return new TupleType (ref, Linemap::predeclared_location ());\n+}\n+\n+bool\n+TupleType::is_unit () const\n+{\n+  return this->fields.empty ();\n+}\n+\n+size_t\n+TupleType::num_fields () const\n+{\n+  return fields.size ();\n+}\n+\n+bool\n+TupleType::is_concrete () const\n+{\n+  for (size_t i = 0; i < num_fields (); i++)\n+    {\n+      if (!get_field (i)->is_concrete ())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+const std::vector<TyVar> &\n+TupleType::get_fields () const\n+{\n+  return fields;\n+}\n+\n void\n TupleType::accept_vis (TyVisitor &vis)\n {\n@@ -1315,13 +1315,6 @@ TupleType::get_field (size_t index) const\n   return fields.at (index).get_tyty ();\n }\n \n-BaseType *\n-TupleType::unify (BaseType *other)\n-{\n-  TupleRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n TupleType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1370,7 +1363,7 @@ TupleType::monomorphized_clone () const\n }\n \n TupleType *\n-TupleType::handle_substitions (SubstitutionArgumentMappings mappings)\n+TupleType::handle_substitions (SubstitutionArgumentMappings &mappings)\n {\n   auto mappings_table = Analysis::Mappings::get ();\n \n@@ -1422,13 +1415,6 @@ FnType::as_string () const\n   return \"fn\" + subst_as_string () + \" (\" + params_str + \") -> \" + ret_str;\n }\n \n-BaseType *\n-FnType::unify (BaseType *other)\n-{\n-  FnRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n FnType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1511,7 +1497,7 @@ FnType::monomorphized_clone () const\n }\n \n FnType *\n-FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+FnType::handle_substitions (SubstitutionArgumentMappings &subst_mappings)\n {\n   FnType *fn = static_cast<FnType *> (clone ());\n   fn->set_ty_ref (mappings->get_next_hir_id ());\n@@ -1653,13 +1639,6 @@ FnPtr::as_string () const\n   return \"fnptr (\" + params_str + \") -> \" + get_return_type ()->as_string ();\n }\n \n-BaseType *\n-FnPtr::unify (BaseType *other)\n-{\n-  FnptrRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1733,13 +1712,6 @@ ClosureType::as_string () const\n   return \"|\" + params_buf + \"| {\" + result_type.get_tyty ()->as_string () + \"}\";\n }\n \n-BaseType *\n-ClosureType::unify (BaseType *other)\n-{\n-  ClosureRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1779,7 +1751,7 @@ ClosureType::monomorphized_clone () const\n }\n \n ClosureType *\n-ClosureType::handle_substitions (SubstitutionArgumentMappings mappings)\n+ClosureType::handle_substitions (SubstitutionArgumentMappings &mappings)\n {\n   gcc_unreachable ();\n   return nullptr;\n@@ -1849,13 +1821,6 @@ ArrayType::as_string () const\n   return \"[\" + get_element_type ()->as_string () + \":\" + \"CAPACITY\" + \"]\";\n }\n \n-BaseType *\n-ArrayType::unify (BaseType *other)\n-{\n-  ArrayRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1899,7 +1864,7 @@ ArrayType::monomorphized_clone () const\n }\n \n ArrayType *\n-ArrayType::handle_substitions (SubstitutionArgumentMappings mappings)\n+ArrayType::handle_substitions (SubstitutionArgumentMappings &mappings)\n {\n   auto mappings_table = Analysis::Mappings::get ();\n \n@@ -1932,13 +1897,6 @@ SliceType::as_string () const\n   return \"[\" + get_element_type ()->as_string () + \"]\";\n }\n \n-BaseType *\n-SliceType::unify (BaseType *other)\n-{\n-  SliceRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n SliceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1982,7 +1940,7 @@ SliceType::monomorphized_clone () const\n }\n \n SliceType *\n-SliceType::handle_substitions (SubstitutionArgumentMappings mappings)\n+SliceType::handle_substitions (SubstitutionArgumentMappings &mappings)\n {\n   auto mappings_table = Analysis::Mappings::get ();\n \n@@ -1997,6 +1955,34 @@ SliceType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return ref;\n }\n \n+// BoolType\n+\n+BoolType::BoolType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::BOOL,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+BoolType::BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::BOOL,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+BoolType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+BoolType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n BoolType::accept_vis (TyVisitor &vis)\n {\n@@ -2015,13 +2001,6 @@ BoolType::as_string () const\n   return \"bool\";\n }\n \n-BaseType *\n-BoolType::unify (BaseType *other)\n-{\n-  BoolRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n BoolType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2041,6 +2020,36 @@ BoolType::monomorphized_clone () const\n   return clone ();\n }\n \n+// IntType\n+\n+IntType::IntType (HirId ref, IntKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::INT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    int_kind (kind)\n+{}\n+\n+IntType::IntType (HirId ref, HirId ty_ref, IntKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::INT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    int_kind (kind)\n+{}\n+\n+std::string\n+IntType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+IntType::IntKind\n+IntType::get_int_kind () const\n+{\n+  return int_kind;\n+}\n+\n void\n IntType::accept_vis (TyVisitor &vis)\n {\n@@ -2073,13 +2082,6 @@ IntType::as_string () const\n   return \"__unknown_int_type\";\n }\n \n-BaseType *\n-IntType::unify (BaseType *other)\n-{\n-  IntRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n IntType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2110,6 +2112,43 @@ IntType::is_equal (const BaseType &other) const\n   return get_int_kind () == o.get_int_kind ();\n }\n \n+bool\n+IntType::is_concrete () const\n+{\n+  return true;\n+}\n+\n+// UintType\n+\n+UintType::UintType (HirId ref, UintKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::UINT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    uint_kind (kind)\n+{}\n+\n+UintType::UintType (HirId ref, HirId ty_ref, UintKind kind,\n+\t\t    std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::UINT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    uint_kind (kind)\n+{}\n+\n+std::string\n+UintType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+UintType::UintKind\n+UintType::get_uint_kind () const\n+{\n+  return uint_kind;\n+}\n+\n void\n UintType::accept_vis (TyVisitor &vis)\n {\n@@ -2142,13 +2181,6 @@ UintType::as_string () const\n   return \"__unknown_uint_type\";\n }\n \n-BaseType *\n-UintType::unify (BaseType *other)\n-{\n-  UintRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n UintType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2179,6 +2211,49 @@ UintType::is_equal (const BaseType &other) const\n   return get_uint_kind () == o.get_uint_kind ();\n }\n \n+bool\n+UintType::is_concrete () const\n+{\n+  return true;\n+}\n+\n+// FloatType\n+\n+FloatType::FloatType (HirId ref, FloatKind kind, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::FLOAT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    float_kind (kind)\n+{}\n+\n+FloatType::FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::FLOAT,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    float_kind (kind)\n+{}\n+\n+std::string\n+FloatType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+FloatType::FloatKind\n+FloatType::get_float_kind () const\n+{\n+  return float_kind;\n+}\n+\n+bool\n+FloatType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n FloatType::accept_vis (TyVisitor &vis)\n {\n@@ -2205,13 +2280,6 @@ FloatType::as_string () const\n   return \"__unknown_float_type\";\n }\n \n-BaseType *\n-FloatType::unify (BaseType *other)\n-{\n-  FloatRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n FloatType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2242,6 +2310,34 @@ FloatType::is_equal (const BaseType &other) const\n   return get_float_kind () == o.get_float_kind ();\n }\n \n+// UsizeType\n+\n+USizeType::USizeType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::USIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+USizeType::USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::USIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+USizeType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+USizeType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n USizeType::accept_vis (TyVisitor &vis)\n {\n@@ -2260,13 +2356,6 @@ USizeType::as_string () const\n   return \"usize\";\n }\n \n-BaseType *\n-USizeType::unify (BaseType *other)\n-{\n-  USizeRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n USizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2283,7 +2372,35 @@ USizeType::clone () const\n BaseType *\n USizeType::monomorphized_clone () const\n {\n-  return clone ();\n+  return clone ();\n+}\n+\n+// ISizeType\n+\n+ISizeType::ISizeType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::ISIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+ISizeType::ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::ISIZE,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+ISizeType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+ISizeType::is_concrete () const\n+{\n+  return true;\n }\n \n void\n@@ -2304,13 +2421,6 @@ ISizeType::as_string () const\n   return \"isize\";\n }\n \n-BaseType *\n-ISizeType::unify (BaseType *other)\n-{\n-  ISizeRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2330,6 +2440,34 @@ ISizeType::monomorphized_clone () const\n   return clone ();\n }\n \n+// Char Type\n+\n+CharType::CharType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::CHAR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+CharType::CharType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::CHAR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+bool\n+CharType::is_concrete () const\n+{\n+  return true;\n+}\n+\n+std::string\n+CharType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n void\n CharType::accept_vis (TyVisitor &vis)\n {\n@@ -2348,13 +2486,6 @@ CharType::as_string () const\n   return \"char\";\n }\n \n-BaseType *\n-CharType::unify (BaseType *other)\n-{\n-  CharRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n CharType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2374,6 +2505,76 @@ CharType::monomorphized_clone () const\n   return clone ();\n }\n \n+// Reference Type\n+\n+ReferenceType::ReferenceType (HirId ref, TyVar base, Mutability mut,\n+\t\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::REF,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+ReferenceType::ReferenceType (HirId ref, HirId ty_ref, TyVar base,\n+\t\t\t      Mutability mut, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::REF,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+bool\n+ReferenceType::is_concrete () const\n+{\n+  return get_base ()->is_concrete ();\n+}\n+\n+Mutability\n+ReferenceType::mutability () const\n+{\n+  return mut;\n+}\n+\n+bool\n+ReferenceType::is_mutable () const\n+{\n+  return mut == Mutability::Mut;\n+}\n+\n+bool\n+ReferenceType::is_dyn_object () const\n+{\n+  return is_dyn_slice_type () || is_dyn_str_type ();\n+}\n+\n+bool\n+ReferenceType::is_dyn_slice_type (const TyTy::SliceType **slice) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::SLICE)\n+    return false;\n+  if (slice == nullptr)\n+    return true;\n+\n+  *slice = static_cast<const TyTy::SliceType *> (element);\n+  return true;\n+}\n+\n+bool\n+ReferenceType::is_dyn_str_type (const TyTy::StrType **str) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::STR)\n+    return false;\n+  if (str == nullptr)\n+    return true;\n+\n+  *str = static_cast<const TyTy::StrType *> (element);\n+  return true;\n+}\n+\n void\n ReferenceType::accept_vis (TyVisitor &vis)\n {\n@@ -2400,13 +2601,6 @@ ReferenceType::get_name () const\n \t + get_base ()->get_name ();\n }\n \n-BaseType *\n-ReferenceType::unify (BaseType *other)\n-{\n-  ReferenceRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2449,7 +2643,7 @@ ReferenceType::monomorphized_clone () const\n }\n \n ReferenceType *\n-ReferenceType::handle_substitions (SubstitutionArgumentMappings mappings)\n+ReferenceType::handle_substitions (SubstitutionArgumentMappings &mappings)\n {\n   auto mappings_table = Analysis::Mappings::get ();\n \n@@ -2464,6 +2658,82 @@ ReferenceType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return ref;\n }\n \n+// PointerType\n+\n+PointerType::PointerType (HirId ref, TyVar base, Mutability mut,\n+\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::POINTER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+PointerType::PointerType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n+\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::POINTER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    base (base), mut (mut)\n+{}\n+\n+bool\n+PointerType::is_concrete () const\n+{\n+  return get_base ()->is_concrete ();\n+}\n+\n+Mutability\n+PointerType::mutability () const\n+{\n+  return mut;\n+}\n+\n+bool\n+PointerType::is_mutable () const\n+{\n+  return mut == Mutability::Mut;\n+}\n+\n+bool\n+PointerType::is_const () const\n+{\n+  return mut == Mutability::Imm;\n+}\n+\n+bool\n+PointerType::is_dyn_object () const\n+{\n+  return is_dyn_slice_type () || is_dyn_str_type ();\n+}\n+\n+bool\n+PointerType::is_dyn_slice_type (const TyTy::SliceType **slice) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::SLICE)\n+    return false;\n+  if (slice == nullptr)\n+    return true;\n+\n+  *slice = static_cast<const TyTy::SliceType *> (element);\n+  return true;\n+}\n+\n+bool\n+PointerType::is_dyn_str_type (const TyTy::StrType **str) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::STR)\n+    return false;\n+  if (str == nullptr)\n+    return true;\n+\n+  *str = static_cast<const TyTy::StrType *> (element);\n+  return true;\n+}\n+\n void\n PointerType::accept_vis (TyVisitor &vis)\n {\n@@ -2490,13 +2760,6 @@ PointerType::get_name () const\n \t + get_base ()->get_name ();\n }\n \n-BaseType *\n-PointerType::unify (BaseType *other)\n-{\n-  PointerRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n PointerType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2539,7 +2802,7 @@ PointerType::monomorphized_clone () const\n }\n \n PointerType *\n-PointerType::handle_substitions (SubstitutionArgumentMappings mappings)\n+PointerType::handle_substitions (SubstitutionArgumentMappings &mappings)\n {\n   auto mappings_table = Analysis::Mappings::get ();\n \n@@ -2554,6 +2817,52 @@ PointerType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return ref;\n }\n \n+// PARAM Type\n+\n+ParamType::ParamType (std::string symbol, Location locus, HirId ref,\n+\t\t      HIR::GenericParam &param,\n+\t\t      std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::PARAM,\n+\t      {Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t       locus},\n+\t      specified_bounds, refs),\n+    symbol (symbol), param (param)\n+{}\n+\n+ParamType::ParamType (std::string symbol, Location locus, HirId ref,\n+\t\t      HirId ty_ref, HIR::GenericParam &param,\n+\t\t      std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t      std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::PARAM,\n+\t      {Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n+\t       locus},\n+\t      specified_bounds, refs),\n+    symbol (symbol), param (param)\n+{}\n+\n+HIR::GenericParam &\n+ParamType::get_generic_param ()\n+{\n+  return param;\n+}\n+\n+bool\n+ParamType::can_resolve () const\n+{\n+  return get_ref () != get_ty_ref ();\n+}\n+\n+bool\n+ParamType::is_concrete () const\n+{\n+  auto r = resolve ();\n+  if (r == this)\n+    return false;\n+\n+  return r->is_concrete ();\n+}\n+\n void\n ParamType::accept_vis (TyVisitor &vis)\n {\n@@ -2587,13 +2896,6 @@ ParamType::get_name () const\n   return resolve ()->get_name ();\n }\n \n-BaseType *\n-ParamType::unify (BaseType *other)\n-{\n-  ParamRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n ParamType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2670,7 +2972,7 @@ ParamType::is_equal (const BaseType &other) const\n }\n \n ParamType *\n-ParamType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+ParamType::handle_substitions (SubstitutionArgumentMappings &subst_mappings)\n {\n   SubstitutionArg arg = SubstitutionArg::error ();\n   bool ok = subst_mappings.get_argument_for_symbol (this, &arg);\n@@ -2695,6 +2997,34 @@ ParamType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n   return p;\n }\n \n+// StrType\n+\n+StrType::StrType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::STR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+StrType::StrType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::STR,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+StrType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+StrType::is_concrete () const\n+{\n+  return true;\n+}\n+\n BaseType *\n StrType::clone () const\n {\n@@ -2725,13 +3055,6 @@ StrType::as_string () const\n   return \"str\";\n }\n \n-BaseType *\n-StrType::unify (BaseType *other)\n-{\n-  StrRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n StrType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2745,6 +3068,40 @@ StrType::is_equal (const BaseType &other) const\n   return get_kind () == other.get_kind ();\n }\n \n+// Never Type\n+\n+NeverType::NeverType (HirId ref, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::NEVER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+NeverType::NeverType (HirId ref, HirId ty_ref, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::NEVER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs)\n+{}\n+\n+std::string\n+NeverType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+NeverType::is_unit () const\n+{\n+  return true;\n+}\n+\n+bool\n+NeverType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n NeverType::accept_vis (TyVisitor &vis)\n {\n@@ -2763,13 +3120,6 @@ NeverType::as_string () const\n   return \"!\";\n }\n \n-BaseType *\n-NeverType::unify (BaseType *other)\n-{\n-  NeverRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n NeverType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2791,6 +3141,52 @@ NeverType::monomorphized_clone () const\n \n // placeholder type\n \n+PlaceholderType::PlaceholderType (std::string symbol, HirId ref,\n+\t\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::PLACEHOLDER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    symbol (symbol)\n+{}\n+\n+PlaceholderType::PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n+\t\t\t\t  std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    symbol (symbol)\n+{}\n+\n+std::string\n+PlaceholderType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+PlaceholderType::is_unit () const\n+{\n+  rust_assert (can_resolve ());\n+  return resolve ()->is_unit ();\n+}\n+\n+std::string\n+PlaceholderType::get_symbol () const\n+{\n+  return symbol;\n+}\n+\n+bool\n+PlaceholderType::is_concrete () const\n+{\n+  if (!can_resolve ())\n+    return true;\n+\n+  return resolve ()->is_concrete ();\n+}\n+\n void\n PlaceholderType::accept_vis (TyVisitor &vis)\n {\n@@ -2810,13 +3206,6 @@ PlaceholderType::as_string () const\n \t + \">\";\n }\n \n-BaseType *\n-PlaceholderType::unify (BaseType *other)\n-{\n-  PlaceholderRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2890,6 +3279,78 @@ PlaceholderType::is_equal (const BaseType &other) const\n \n // Projection type\n \n+ProjectionType::ProjectionType (\n+  HirId ref, BaseType *base, const Resolver::TraitReference *trait, DefId item,\n+  std::vector<SubstitutionParamMapping> subst_refs,\n+  SubstitutionArgumentMappings generic_arguments, std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::PROJECTION,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+    base (base), trait (trait), item (item)\n+{}\n+\n+ProjectionType::ProjectionType (\n+  HirId ref, HirId ty_ref, BaseType *base,\n+  const Resolver::TraitReference *trait, DefId item,\n+  std::vector<SubstitutionParamMapping> subst_refs,\n+  SubstitutionArgumentMappings generic_arguments, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::PROJECTION,\n+\t      {Resolver::CanonicalPath::create_empty (),\n+\t       Linemap::predeclared_location ()},\n+\t      refs),\n+    SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n+    base (base), trait (trait), item (item)\n+{}\n+\n+bool\n+ProjectionType::is_unit () const\n+{\n+  return false;\n+}\n+\n+std::string\n+ProjectionType::get_name () const\n+{\n+  return as_string ();\n+}\n+\n+bool\n+ProjectionType::needs_generic_substitutions () const\n+{\n+  return needs_substitution ();\n+}\n+\n+bool\n+ProjectionType::supports_substitutions () const\n+{\n+  return true;\n+}\n+\n+bool\n+ProjectionType::has_subsititions_defined () const\n+{\n+  return has_substitutions ();\n+}\n+\n+const BaseType *\n+ProjectionType::get () const\n+{\n+  return base;\n+}\n+BaseType *\n+ProjectionType::get ()\n+{\n+  return base;\n+}\n+\n+bool\n+ProjectionType::is_concrete () const\n+{\n+  return base->is_concrete ();\n+}\n+\n void\n ProjectionType::accept_vis (TyVisitor &vis)\n {\n@@ -2908,12 +3369,6 @@ ProjectionType::as_string () const\n   return \"<Projection=\" + subst_as_string () + \"::\" + base->as_string () + \">\";\n }\n \n-BaseType *\n-ProjectionType::unify (BaseType *other)\n-{\n-  return base->unify (other);\n-}\n-\n bool\n ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2935,7 +3390,8 @@ ProjectionType::monomorphized_clone () const\n }\n \n ProjectionType *\n-ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+ProjectionType::handle_substitions (\n+  SubstitutionArgumentMappings &subst_mappings)\n {\n   // // do we really need to substitute this?\n   // if (base->needs_generic_substitutions () || base->contains_type_parameters\n@@ -3006,6 +3462,26 @@ ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n   return projection;\n }\n \n+// DynObjectType\n+\n+DynamicObjectType::DynamicObjectType (\n+  HirId ref, RustIdent ident, std::vector<TypeBoundPredicate> specified_bounds,\n+  std::set<HirId> refs)\n+  : BaseType (ref, ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n+{}\n+\n+DynamicObjectType::DynamicObjectType (\n+  HirId ref, HirId ty_ref, RustIdent ident,\n+  std::vector<TypeBoundPredicate> specified_bounds, std::set<HirId> refs)\n+  : BaseType (ref, ty_ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n+{}\n+\n+bool\n+DynamicObjectType::is_concrete () const\n+{\n+  return true;\n+}\n+\n void\n DynamicObjectType::accept_vis (TyVisitor &vis)\n {\n@@ -3024,13 +3500,6 @@ DynamicObjectType::as_string () const\n   return \"dyn [\" + raw_bounds_as_string () + \"]\";\n }\n \n-BaseType *\n-DynamicObjectType::unify (BaseType *other)\n-{\n-  DynamicRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n {"}, {"sha": "89c320960a29996eb170bf942f76bc7316778c75", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 193, "deletions": 1227, "changes": 1420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -20,11 +20,12 @@\n #define RUST_TYTY\n \n #include \"rust-hir-map.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-diagnostics.h\"\n-#include \"rust-abi.h\"\n #include \"rust-common.h\"\n #include \"rust-identifier.h\"\n+#include \"rust-abi.h\"\n+#include \"rust-tyty-bounds.h\"\n+#include \"rust-tyty-util.h\"\n+#include \"rust-tyty-subst.h\"\n \n namespace Rust {\n \n@@ -76,65 +77,6 @@ class TypeKindFormat\n   static std::string to_string (TypeKind kind);\n };\n \n-class BaseType;\n-class TypeBoundPredicate;\n-class TypeBoundPredicateItem\n-{\n-public:\n-  TypeBoundPredicateItem (const TypeBoundPredicate *parent,\n-\t\t\t  const Resolver::TraitItemReference *trait_item_ref)\n-    : parent (parent), trait_item_ref (trait_item_ref)\n-  {}\n-\n-  static TypeBoundPredicateItem error ()\n-  {\n-    return TypeBoundPredicateItem (nullptr, nullptr);\n-  }\n-\n-  bool is_error () const\n-  {\n-    return parent == nullptr || trait_item_ref == nullptr;\n-  }\n-\n-  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n-\n-  const Resolver::TraitItemReference *get_raw_item () const;\n-\n-  bool needs_implementation () const;\n-\n-  const TypeBoundPredicate *get_parent () const { return parent; }\n-\n-  Location get_locus () const;\n-\n-private:\n-  const TypeBoundPredicate *parent;\n-  const Resolver::TraitItemReference *trait_item_ref;\n-};\n-\n-class TypeBoundsMappings\n-{\n-protected:\n-  TypeBoundsMappings (std::vector<TypeBoundPredicate> specified_bounds);\n-\n-public:\n-  std::vector<TypeBoundPredicate> &get_specified_bounds ();\n-\n-  const std::vector<TypeBoundPredicate> &get_specified_bounds () const;\n-\n-  size_t num_specified_bounds () const;\n-\n-  std::string raw_bounds_as_string () const;\n-\n-  std::string bounds_as_string () const;\n-\n-  std::string raw_bounds_as_name () const;\n-\n-protected:\n-  void add_bound (TypeBoundPredicate predicate);\n-\n-  std::vector<TypeBoundPredicate> specified_bounds;\n-};\n-\n extern void\n set_cmp_autoderef_mode ();\n extern void\n@@ -145,20 +87,15 @@ class TyConstVisitor;\n class BaseType : public TypeBoundsMappings\n {\n public:\n-  virtual ~BaseType () {}\n+  virtual ~BaseType ();\n \n-  HirId get_ref () const { return ref; }\n+  HirId get_ref () const;\n \n-  void set_ref (HirId id)\n-  {\n-    if (id != ref)\n-      append_reference (ref);\n-    ref = id;\n-  }\n+  void set_ref (HirId id);\n \n-  HirId get_ty_ref () const { return ty_ref; }\n+  HirId get_ty_ref () const;\n \n-  void set_ty_ref (HirId id) { ty_ref = id; }\n+  void set_ty_ref (HirId id);\n \n   virtual void accept_vis (TyVisitor &vis) = 0;\n \n@@ -168,11 +105,6 @@ class BaseType : public TypeBoundsMappings\n \n   virtual std::string get_name () const = 0;\n \n-  // Unify two types. Returns a pointer to the newly-created unified ty, or\n-  // nullptr if the two ty cannot be unified. The caller is responsible for\n-  // releasing the memory of the returned ty.\n-  virtual BaseType *unify (BaseType *other) = 0;\n-\n   // similar to unify but does not actually perform type unification but\n   // determines whether they are compatible. Consider the following\n   //\n@@ -189,10 +121,7 @@ class BaseType : public TypeBoundsMappings\n   //   ty are considered equal if they're of the same kind, and\n   //     1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n   //     2. (For functions) have the same signature\n-  virtual bool is_equal (const BaseType &other) const\n-  {\n-    return get_kind () == other.get_kind ();\n-  }\n+  virtual bool is_equal (const BaseType &other) const;\n \n   bool satisfies_bound (const TypeBoundPredicate &predicate) const;\n \n@@ -204,11 +133,11 @@ class BaseType : public TypeBoundsMappings\n   void inherit_bounds (\n     const std::vector<TyTy::TypeBoundPredicate> &specified_bounds);\n \n-  virtual bool is_unit () const { return false; }\n+  virtual bool is_unit () const;\n \n   virtual bool is_concrete () const = 0;\n \n-  TypeKind get_kind () const { return kind; }\n+  TypeKind get_kind () const;\n \n   /* Returns a pointer to a clone of this. The caller is responsible for\n    * releasing the memory of the returned ty. */\n@@ -218,22 +147,19 @@ class BaseType : public TypeBoundsMappings\n   virtual BaseType *monomorphized_clone () const = 0;\n \n   // get_combined_refs returns the chain of node refs involved in unification\n-  std::set<HirId> get_combined_refs () const { return combined; }\n+  std::set<HirId> get_combined_refs () const;\n \n-  void append_reference (HirId id) { combined.insert (id); }\n+  void append_reference (HirId id);\n \n-  virtual bool supports_substitutions () const { return false; }\n+  virtual bool supports_substitutions () const;\n \n-  virtual bool has_subsititions_defined () const { return false; }\n+  virtual bool has_subsititions_defined () const;\n \n-  virtual bool can_substitute () const\n-  {\n-    return supports_substitutions () && has_subsititions_defined ();\n-  }\n+  virtual bool can_substitute () const;\n \n-  virtual bool needs_generic_substitutions () const { return false; }\n+  virtual bool needs_generic_substitutions () const;\n \n-  bool contains_type_parameters () const { return !is_concrete (); }\n+  bool contains_type_parameters () const;\n \n   std::string mappings_str () const;\n \n@@ -246,26 +172,20 @@ class BaseType : public TypeBoundsMappings\n \n   // This will get the monomorphized type from Params, Placeholders or\n   // Projections if available or error\n+  BaseType *destructure ();\n   const BaseType *destructure () const;\n \n-  const RustIdent &get_ident () const { return ident; }\n+  const RustIdent &get_ident () const;\n \n-  Location get_locus () const { return ident.locus; }\n+  Location get_locus () const;\n \n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n-\t    std::set<HirId> refs = std::set<HirId> ())\n-    : TypeBoundsMappings ({}), kind (kind), ref (ref), ty_ref (ty_ref),\n-      combined (refs), ident (ident), mappings (Analysis::Mappings::get ())\n-  {}\n+\t    std::set<HirId> refs = std::set<HirId> ());\n \n   BaseType (HirId ref, HirId ty_ref, TypeKind kind, RustIdent ident,\n \t    std::vector<TypeBoundPredicate> specified_bounds,\n-\t    std::set<HirId> refs = std::set<HirId> ())\n-    : TypeBoundsMappings (specified_bounds), kind (kind), ref (ref),\n-      ty_ref (ty_ref), combined (refs), ident (ident),\n-      mappings (Analysis::Mappings::get ())\n-  {}\n+\t    std::set<HirId> refs = std::set<HirId> ());\n \n   TypeKind kind;\n   HirId ref;\n@@ -276,43 +196,6 @@ class BaseType : public TypeBoundsMappings\n   Analysis::Mappings *mappings;\n };\n \n-// this is a placeholder for types that can change like inference variables\n-class TyVar\n-{\n-public:\n-  explicit TyVar (HirId ref);\n-\n-  HirId get_ref () const { return ref; }\n-\n-  BaseType *get_tyty () const;\n-\n-  TyVar clone () const;\n-\n-  TyVar monomorphized_clone () const;\n-\n-  static TyVar get_implicit_infer_var (Location locus);\n-\n-  static TyVar subst_covariant_var (TyTy::BaseType *orig,\n-\t\t\t\t    TyTy::BaseType *subst);\n-\n-private:\n-  HirId ref;\n-};\n-\n-class TyWithLocation\n-{\n-public:\n-  explicit TyWithLocation (BaseType *ty, Location locus);\n-  explicit TyWithLocation (BaseType *ty);\n-\n-  BaseType *get_ty () const { return ty; }\n-  Location get_locus () const { return locus; }\n-\n-private:\n-  BaseType *ty;\n-  Location locus;\n-};\n-\n class InferType : public BaseType\n {\n public:\n@@ -324,38 +207,28 @@ class InferType : public BaseType\n   };\n \n   InferType (HirId ref, InferTypeKind infer_kind, Location locus,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::INFER,\n-\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n-      infer_kind (infer_kind)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   InferType (HirId ref, HirId ty_ref, InferTypeKind infer_kind, Location locus,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::INFER,\n-\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n-      infer_kind (infer_kind)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n-\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  InferTypeKind get_infer_kind () const { return infer_kind; }\n+  InferTypeKind get_infer_kind () const;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   bool default_type (BaseType **type) const;\n \n-  bool is_concrete () const final override { return true; }\n+  bool is_concrete () const final override;\n \n private:\n   InferTypeKind infer_kind;\n@@ -364,93 +237,66 @@ class InferType : public BaseType\n class ErrorType : public BaseType\n {\n public:\n-  ErrorType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ERROR,\n-\t\t{Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n-  {}\n+  ErrorType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n \n-  ErrorType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ERROR,\n-\t\t{Resolver::CanonicalPath::create_empty (), Location ()}, refs)\n-  {}\n+  ErrorType (HirId ref, HirId ty_ref,\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n-  bool is_unit () const override { return true; }\n+  bool is_unit () const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  bool is_concrete () const final override { return false; }\n+  bool is_concrete () const final override;\n };\n \n-class SubstitutionArgumentMappings;\n class ParamType : public BaseType\n {\n public:\n   ParamType (std::string symbol, Location locus, HirId ref,\n \t     HIR::GenericParam &param,\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PARAM,\n-\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n-\t\t locus},\n-\t\tspecified_bounds, refs),\n-      symbol (symbol), param (param)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   ParamType (std::string symbol, Location locus, HirId ref, HirId ty_ref,\n \t     HIR::GenericParam &param,\n \t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PARAM,\n-\t\t{Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, symbol),\n-\t\t locus},\n-\t\tspecified_bounds, refs),\n-      symbol (symbol), param (param)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n   std::string get_symbol () const;\n \n-  HIR::GenericParam &get_generic_param () { return param; }\n+  HIR::GenericParam &get_generic_param ();\n \n-  bool can_resolve () const { return get_ref () != get_ty_ref (); }\n+  bool can_resolve () const;\n \n   BaseType *resolve () const;\n \n   std::string get_name () const override final;\n \n   bool is_equal (const BaseType &other) const override;\n \n-  bool is_concrete () const override final\n-  {\n-    auto r = resolve ();\n-    if (r == this)\n-      return false;\n-\n-    return r->is_concrete ();\n-  }\n+  bool is_concrete () const override final;\n \n-  ParamType *handle_substitions (SubstitutionArgumentMappings mappings);\n+  ParamType *handle_substitions (SubstitutionArgumentMappings &mappings);\n \n private:\n   std::string symbol;\n@@ -460,563 +306,74 @@ class ParamType : public BaseType\n class StructFieldType\n {\n public:\n-  StructFieldType (HirId ref, std::string name, BaseType *ty, Location locus)\n-    : ref (ref), name (name), ty (ty), locus (locus)\n-  {}\n-\n-  HirId get_ref () const { return ref; }\n+  StructFieldType (HirId ref, std::string name, BaseType *ty, Location locus);\n \n-  std::string as_string () const;\n+  HirId get_ref () const;\n \n   bool is_equal (const StructFieldType &other) const;\n \n-  std::string get_name () const { return name; }\n-\n-  BaseType *get_field_type () const { return ty; }\n+  std::string get_name () const;\n \n-  void set_field_type (BaseType *fty) { ty = fty; }\n+  BaseType *get_field_type () const;\n+  void set_field_type (BaseType *fty);\n \n   StructFieldType *clone () const;\n-\n   StructFieldType *monomorphized_clone () const;\n \n-  bool is_concrete () const { return ty->is_concrete (); }\n-\n-  void debug () const { rust_debug (\"%s\", as_string ().c_str ()); }\n+  bool is_concrete () const;\n \n-  Location get_locus () const { return locus; }\n-\n-private:\n-  HirId ref;\n-  std::string name;\n-  BaseType *ty;\n-  Location locus;\n-};\n-\n-class TupleType : public BaseType\n-{\n-public:\n-  TupleType (HirId ref, Location locus,\n-\t     std::vector<TyVar> fields = std::vector<TyVar> (),\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::TUPLE,\n-\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n-      fields (fields)\n-  {}\n-\n-  TupleType (HirId ref, HirId ty_ref, Location locus,\n-\t     std::vector<TyVar> fields = std::vector<TyVar> (),\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::TUPLE,\n-\t\t{Resolver::CanonicalPath::create_empty (), locus}, refs),\n-      fields (fields)\n-  {}\n-\n-  static TupleType *get_unit_type (HirId ref)\n-  {\n-    return new TupleType (ref, Linemap::predeclared_location ());\n-  }\n-\n-  void accept_vis (TyVisitor &vis) override;\n-  void accept_vis (TyConstVisitor &vis) const override;\n-\n-  bool is_unit () const override { return this->fields.empty (); }\n-\n-  std::string as_string () const override;\n-\n-  BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-\n-  bool is_equal (const BaseType &other) const override;\n-\n-  size_t num_fields () const { return fields.size (); }\n-\n-  BaseType *get_field (size_t index) const;\n-\n-  BaseType *clone () const final override;\n-  BaseType *monomorphized_clone () const final override;\n-\n-  bool is_concrete () const override final\n-  {\n-    for (size_t i = 0; i < num_fields (); i++)\n-      {\n-\tif (!get_field (i)->is_concrete ())\n-\t  return false;\n-      }\n-    return true;\n-  }\n-\n-  const std::vector<TyVar> &get_fields () const { return fields; }\n-\n-  std::string get_name () const override final;\n-\n-  TupleType *handle_substitions (SubstitutionArgumentMappings mappings);\n-\n-private:\n-  std::vector<TyVar> fields;\n-};\n-\n-class SubstitutionParamMapping\n-{\n-public:\n-  SubstitutionParamMapping (const HIR::TypeParam &generic, ParamType *param)\n-    : generic (generic), param (param)\n-  {}\n-\n-  SubstitutionParamMapping (const SubstitutionParamMapping &other)\n-    : generic (other.generic), param (other.param)\n-  {}\n-\n-  std::string as_string () const\n-  {\n-    if (param == nullptr)\n-      return \"nullptr\";\n-\n-    return param->get_name ();\n-  }\n-\n-  bool fill_param_ty (SubstitutionArgumentMappings &subst_mappings,\n-\t\t      Location locus);\n-\n-  SubstitutionParamMapping clone () const\n-  {\n-    return SubstitutionParamMapping (generic, static_cast<ParamType *> (\n-\t\t\t\t\t\tparam->clone ()));\n-  }\n-\n-  ParamType *get_param_ty () { return param; }\n-\n-  const ParamType *get_param_ty () const { return param; }\n-\n-  const HIR::TypeParam &get_generic_param () { return generic; };\n-\n-  // this is used for the backend to override the HirId ref of the param to\n-  // what the concrete type is for the rest of the context\n-  void override_context ();\n-\n-  bool needs_substitution () const\n-  {\n-    return !(get_param_ty ()->is_concrete ());\n-  }\n-\n-  Location get_param_locus () const { return generic.get_locus (); }\n-\n-  bool param_has_default_ty () const { return generic.has_type (); }\n-\n-  BaseType *get_default_ty () const\n-  {\n-    TyVar var (generic.get_type_mappings ().get_hirid ());\n-    return var.get_tyty ();\n-  }\n-\n-  bool need_substitution () const;\n-\n-private:\n-  const HIR::TypeParam &generic;\n-  ParamType *param;\n-};\n-\n-class SubstitutionArg\n-{\n-public:\n-  SubstitutionArg (const SubstitutionParamMapping *param, BaseType *argument)\n-    : param (param), argument (argument)\n-  {}\n-\n-  // FIXME\n-  // the copy constructors need removed - they are unsafe see\n-  // TypeBoundPredicate\n-  SubstitutionArg (const SubstitutionArg &other)\n-    : param (other.param), argument (other.argument)\n-  {}\n-\n-  SubstitutionArg &operator= (const SubstitutionArg &other)\n-  {\n-    param = other.param;\n-    argument = other.argument;\n-    return *this;\n-  }\n-\n-  BaseType *get_tyty () { return argument; }\n-\n-  const BaseType *get_tyty () const { return argument; }\n-\n-  const SubstitutionParamMapping *get_param_mapping () const { return param; }\n-\n-  static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n-\n-  bool is_error () const { return param == nullptr || argument == nullptr; }\n-\n-  bool is_conrete () const\n-  {\n-    if (argument != nullptr)\n-      return true;\n-\n-    if (argument->get_kind () == TyTy::TypeKind::PARAM)\n-      return false;\n-\n-    return argument->is_concrete ();\n-  }\n-\n-  std::string as_string () const\n-  {\n-    return param->as_string ()\n-\t   + (argument != nullptr ? \":\" + argument->as_string () : \"\");\n-  }\n-\n-private:\n-  const SubstitutionParamMapping *param;\n-  BaseType *argument;\n-};\n-\n-typedef std::function<void (const ParamType &, const SubstitutionArg &)>\n-  ParamSubstCb;\n-class SubstitutionArgumentMappings\n-{\n-public:\n-  SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n-\t\t\t\tstd::map<std::string, BaseType *> binding_args,\n-\t\t\t\tLocation locus,\n-\t\t\t\tParamSubstCb param_subst_cb = nullptr,\n-\t\t\t\tbool trait_item_flag = false)\n-    : mappings (mappings), binding_args (binding_args), locus (locus),\n-      param_subst_cb (param_subst_cb), trait_item_flag (trait_item_flag)\n-  {}\n-\n-  SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other)\n-    : mappings (other.mappings), binding_args (other.binding_args),\n-      locus (other.locus), param_subst_cb (other.param_subst_cb),\n-      trait_item_flag (other.trait_item_flag)\n-  {}\n-\n-  SubstitutionArgumentMappings &\n-  operator= (const SubstitutionArgumentMappings &other)\n-  {\n-    mappings = other.mappings;\n-    binding_args = other.binding_args;\n-    locus = other.locus;\n-    param_subst_cb = other.param_subst_cb;\n-    trait_item_flag = other.trait_item_flag;\n-\n-    return *this;\n-  }\n-\n-  SubstitutionArgumentMappings (SubstitutionArgumentMappings &&other) = default;\n-  SubstitutionArgumentMappings &operator= (SubstitutionArgumentMappings &&other)\n-    = default;\n-\n-  static SubstitutionArgumentMappings error ()\n-  {\n-    return SubstitutionArgumentMappings ({}, {}, Location (), nullptr, false);\n-  }\n-\n-  bool is_error () const { return mappings.size () == 0; }\n-\n-  bool get_argument_for_symbol (const ParamType *param_to_find,\n-\t\t\t\tSubstitutionArg *argument)\n-  {\n-    for (auto &mapping : mappings)\n-      {\n-\tconst SubstitutionParamMapping *param = mapping.get_param_mapping ();\n-\tconst ParamType *p = param->get_param_ty ();\n-\n-\tif (p->get_symbol ().compare (param_to_find->get_symbol ()) == 0)\n-\t  {\n-\t    *argument = mapping;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n-  bool get_argument_at (size_t index, SubstitutionArg *argument)\n-  {\n-    if (index > mappings.size ())\n-      return false;\n-\n-    *argument = mappings.at (index);\n-    return true;\n-  }\n-\n-  // is_concrete means if the used args is non error, ie: non empty this will\n-  // verify if actual real types have been put in place of are they still\n-  // ParamTy\n-  bool is_concrete () const\n-  {\n-    for (auto &mapping : mappings)\n-      {\n-\tif (!mapping.is_conrete ())\n-\t  return false;\n-      }\n-    return true;\n-  }\n-\n-  Location get_locus () const { return locus; }\n-\n-  size_t size () const { return mappings.size (); }\n-\n-  bool is_empty () const { return size () == 0; }\n-\n-  std::vector<SubstitutionArg> &get_mappings () { return mappings; }\n-\n-  const std::vector<SubstitutionArg> &get_mappings () const { return mappings; }\n-\n-  std::map<std::string, BaseType *> &get_binding_args ()\n-  {\n-    return binding_args;\n-  }\n-\n-  const std::map<std::string, BaseType *> &get_binding_args () const\n-  {\n-    return binding_args;\n-  }\n-\n-  std::string as_string () const\n-  {\n-    std::string buffer;\n-    for (auto &mapping : mappings)\n-      {\n-\tbuffer += mapping.as_string () + \", \";\n-      }\n-    return \"<\" + buffer + \">\";\n-  }\n-\n-  void on_param_subst (const ParamType &p, const SubstitutionArg &a) const\n-  {\n-    if (param_subst_cb == nullptr)\n-      return;\n-\n-    param_subst_cb (p, a);\n-  }\n-\n-  ParamSubstCb get_subst_cb () const { return param_subst_cb; }\n-\n-  bool trait_item_mode () const { return trait_item_flag; }\n+  void debug () const;\n+  Location get_locus () const;\n+  std::string as_string () const;\n \n private:\n-  std::vector<SubstitutionArg> mappings;\n-  std::map<std::string, BaseType *> binding_args;\n-  Location locus;\n-  ParamSubstCb param_subst_cb;\n-  bool trait_item_flag;\n-};\n-\n-class SubstitutionRef\n-{\n-public:\n-  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions,\n-\t\t   SubstitutionArgumentMappings arguments)\n-    : substitutions (substitutions), used_arguments (arguments)\n-  {}\n-\n-  bool has_substitutions () const { return substitutions.size () > 0; }\n-\n-  std::string subst_as_string () const\n-  {\n-    std::string buffer;\n-    for (size_t i = 0; i < substitutions.size (); i++)\n-      {\n-\tconst SubstitutionParamMapping &sub = substitutions.at (i);\n-\tbuffer += sub.as_string ();\n-\n-\tif ((i + 1) < substitutions.size ())\n-\t  buffer += \", \";\n-      }\n-\n-    return buffer.empty () ? \"\" : \"<\" + buffer + \">\";\n-  }\n-\n-  bool supports_associated_bindings () const\n-  {\n-    return get_num_associated_bindings () > 0;\n-  }\n-\n-  // this is overridden in TypeBoundPredicate\n-  // which support bindings we don't add them directly to the SubstitutionRef\n-  // base class because this class represents the fn<X: Foo, Y: Bar>. The only\n-  // construct which supports associated types\n-  virtual size_t get_num_associated_bindings () const { return 0; }\n-\n-  // this is overridden in TypeBoundPredicate\n-  virtual TypeBoundPredicateItem\n-  lookup_associated_type (const std::string &search)\n-  {\n-    return TypeBoundPredicateItem::error ();\n-  }\n-\n-  size_t get_num_substitutions () const { return substitutions.size (); }\n-\n-  std::vector<SubstitutionParamMapping> &get_substs () { return substitutions; }\n-\n-  const std::vector<SubstitutionParamMapping> &get_substs () const\n-  {\n-    return substitutions;\n-  }\n-\n-  std::vector<SubstitutionParamMapping> clone_substs () const\n-  {\n-    std::vector<SubstitutionParamMapping> clone;\n-\n-    for (auto &sub : substitutions)\n-      clone.push_back (sub.clone ());\n-\n-    return clone;\n-  }\n+  HirId ref;\n+  std::string name;\n+  BaseType *ty;\n+  Location locus;\n+};\n \n-  void override_context ()\n-  {\n-    for (auto &sub : substitutions)\n-      {\n-\tsub.override_context ();\n-      }\n-  }\n+class TupleType : public BaseType\n+{\n+public:\n+  TupleType (HirId ref, Location locus,\n+\t     std::vector<TyVar> fields = std::vector<TyVar> (),\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n-  bool needs_substitution () const\n-  {\n-    for (auto &sub : substitutions)\n-      {\n-\tif (sub.need_substitution ())\n-\t  return true;\n-      }\n-    return false;\n-  }\n+  TupleType (HirId ref, HirId ty_ref, Location locus,\n+\t     std::vector<TyVar> fields = std::vector<TyVar> (),\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n-  bool was_substituted () const { return !needs_substitution (); }\n+  static TupleType *get_unit_type (HirId ref);\n \n-  SubstitutionArgumentMappings get_substitution_arguments () const\n-  {\n-    return used_arguments;\n-  }\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n \n-  // this is the count of type params that are not substituted fuly\n-  size_t num_required_substitutions () const\n-  {\n-    size_t n = 0;\n-    for (auto &p : substitutions)\n-      {\n-\tif (p.needs_substitution ())\n-\t  n++;\n-      }\n-    return n;\n-  }\n+  bool is_unit () const override;\n \n-  // this is the count of type params that need substituted taking into account\n-  // possible defaults\n-  size_t min_required_substitutions () const\n-  {\n-    size_t n = 0;\n-    for (auto &p : substitutions)\n-      {\n-\tif (p.needs_substitution () && !p.param_has_default_ty ())\n-\t  n++;\n-      }\n-    return n;\n-  }\n+  std::string as_string () const override;\n \n-  // We are trying to subst <i32, f32> into Struct Foo<X,Y> {}\n-  // in the case of Foo<i32,f32>{...}\n-  //\n-  // the substitions we have here define X,Y but the arguments have no bindings\n-  // so its a matter of ordering\n-  SubstitutionArgumentMappings\n-  get_mappings_from_generic_args (HIR::GenericArgs &args);\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  // Recursive substitutions\n-  // Foo <A,B> { a:A, b: B}; Bar <X,Y,Z>{a:X, b: Foo<Y,Z>}\n-  //\n-  // we have bindings for X Y Z and need to propagate the binding Y,Z into Foo\n-  // Which binds to A,B\n-  SubstitutionArgumentMappings\n-  adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n+  bool is_equal (const BaseType &other) const override;\n \n-  // Are the mappings here actually bound to this type. For example imagine the\n-  // case:\n-  //\n-  // struct Foo<T>(T);\n-  // impl<T> Foo<T> {\n-  //   fn test(self) { ... }\n-  // }\n-  //\n-  // In this case we have a generic ADT of Foo and an impl block of a generic T\n-  // on Foo for the Self type. When we it comes to path resolution we can have:\n-  //\n-  // Foo::<i32>::test()\n-  //\n-  // This means the first segment of Foo::<i32> returns the ADT Foo<i32> not the\n-  // Self ADT bound to the T from the impl block. This means when it comes to\n-  // the next segment of test which resolves to the function we need to check\n-  // wether the arguments in the struct definition of foo can be bound here\n-  // before substituting the previous segments type here. This functions acts as\n-  // a guard for the solve_mappings_from_receiver_for_self to handle the case\n-  // where arguments are not bound. This is important for this next case:\n-  //\n-  // struct Baz<A, B>(A, B);\n-  // impl Baz<i32, f32> {\n-  //   fn test<X>(a: X) -> X {\n-  //       a\n-  //   }\n-  // }\n-  //\n-  // In this case Baz has been already substituted for the impl's Self to become\n-  // ADT<i32, f32> so that the function test only has 1 generic argument of X.\n-  // The path for this will be:\n-  //\n-  // Baz::test::<_>(123)\n-  //\n-  // So the first segment here will be Baz<_, _> to try and infer the arguments\n-  // which will be taken from the impl's Self type in this case since it is\n-  // already substituted and like the previous case the check to see if we need\n-  // to inherit the previous segments generic arguments takes place but the\n-  // generic arguments are not bound to this type as they have already been\n-  // substituted.\n-  //\n-  // Its important to remember from the first example the FnType actually looks\n-  // like:\n-  //\n-  // fn <T>test(self :Foo<T>(T))\n-  //\n-  // As the generic parameters are \"bound\" to each of the items in the impl\n-  // block. So this check is about wether the arguments we have here can\n-  // actually be bound to this type.\n-  bool are_mappings_bound (SubstitutionArgumentMappings &mappings);\n+  size_t num_fields () const;\n \n-  // struct Foo<A, B>(A, B);\n-  //\n-  // impl<T> Foo<T, f32>;\n-  //     -> fn test<X>(self, a: X) -> X\n-  //\n-  // We might invoke this via:\n-  //\n-  // a = Foo(123, 456f32);\n-  // b = a.test::<bool>(false);\n-  //\n-  // we need to figure out relevant generic arguemts for self to apply to the\n-  // fntype\n-  SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n-    SubstitutionArgumentMappings &mappings) const;\n+  BaseType *get_field (size_t index) const;\n \n-  // TODO comment\n-  SubstitutionArgumentMappings\n-  solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n+  BaseType *clone () const final override;\n+  BaseType *monomorphized_clone () const final override;\n \n-  // TODO comment\n-  BaseType *infer_substitions (Location locus);\n+  bool is_concrete () const override final;\n \n-  // TODO comment\n-  bool monomorphize ();\n+  const std::vector<TyVar> &get_fields () const;\n \n-  // TODO comment\n-  virtual BaseType *handle_substitions (SubstitutionArgumentMappings mappings)\n-    = 0;\n+  std::string get_name () const override final;\n \n-  SubstitutionArgumentMappings get_used_arguments () const\n-  {\n-    return used_arguments;\n-  }\n+  TupleType *handle_substitions (SubstitutionArgumentMappings &mappings);\n \n-protected:\n-  std::vector<SubstitutionParamMapping> substitutions;\n-  SubstitutionArgumentMappings used_arguments;\n+private:\n+  std::vector<TyVar> fields;\n };\n \n class TypeBoundPredicate : public SubstitutionRef\n@@ -1061,7 +418,7 @@ class TypeBoundPredicate : public SubstitutionRef\n \n   // WARNING THIS WILL ALWAYS RETURN NULLPTR\n   BaseType *\n-  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+  handle_substitions (SubstitutionArgumentMappings &mappings) override final;\n \n   bool is_error () const;\n \n@@ -1095,185 +452,48 @@ class VariantDef\n     STRUCT\n   };\n \n-  static std::string variant_type_string (VariantType type)\n-  {\n-    switch (type)\n-      {\n-      case NUM:\n-\treturn \"enumeral\";\n-      case TUPLE:\n-\treturn \"tuple\";\n-      case STRUCT:\n-\treturn \"struct\";\n-      }\n-    gcc_unreachable ();\n-    return \"\";\n-  }\n+  static std::string variant_type_string (VariantType type);\n \n   VariantDef (HirId id, DefId defid, std::string identifier, RustIdent ident,\n-\t      HIR::Expr *discriminant)\n-    : id (id), defid (defid), identifier (identifier), ident (ident),\n-      discriminant (discriminant)\n-\n-  {\n-    type = VariantType::NUM;\n-    fields = {};\n-  }\n+\t      HIR::Expr *discriminant);\n \n   VariantDef (HirId id, DefId defid, std::string identifier, RustIdent ident,\n \t      VariantType type, HIR::Expr *discriminant,\n-\t      std::vector<StructFieldType *> fields)\n-    : id (id), defid (defid), identifier (identifier), ident (ident),\n-      type (type), discriminant (discriminant), fields (fields)\n-  {\n-    rust_assert (\n-      (type == VariantType::NUM && fields.empty ())\n-      || (type == VariantType::TUPLE || type == VariantType::STRUCT));\n-  }\n-\n-  VariantDef (const VariantDef &other)\n-    : id (other.id), defid (other.defid), identifier (other.identifier),\n-      ident (other.ident), type (other.type), discriminant (other.discriminant),\n-      fields (other.fields)\n-  {}\n-\n-  VariantDef &operator= (const VariantDef &other)\n-  {\n-    id = other.id;\n-    identifier = other.identifier;\n-    type = other.type;\n-    discriminant = other.discriminant;\n-    fields = other.fields;\n-    ident = other.ident;\n-\n-    return *this;\n-  }\n+\t      std::vector<StructFieldType *> fields);\n \n-  static VariantDef &get_error_node ()\n-  {\n-    static VariantDef node\n-      = VariantDef (UNKNOWN_HIRID, UNKNOWN_DEFID, \"\",\n-\t\t    {Resolver::CanonicalPath::create_empty (),\n-\t\t     Linemap::unknown_location ()},\n-\t\t    nullptr);\n+  VariantDef (const VariantDef &other);\n \n-    return node;\n-  }\n+  VariantDef &operator= (const VariantDef &other);\n \n-  bool is_error () const { return get_id () == UNKNOWN_HIRID; }\n+  static VariantDef &get_error_node ();\n+  bool is_error () const;\n \n-  HirId get_id () const { return id; }\n-  DefId get_defid () const { return defid; }\n+  HirId get_id () const;\n+  DefId get_defid () const;\n \n-  VariantType get_variant_type () const { return type; }\n-  bool is_data_variant () const { return type != VariantType::NUM; }\n-  bool is_dataless_variant () const { return type == VariantType::NUM; }\n+  VariantType get_variant_type () const;\n+  bool is_data_variant () const;\n+  bool is_dataless_variant () const;\n \n-  std::string get_identifier () const { return identifier; }\n+  std::string get_identifier () const;\n \n-  size_t num_fields () const { return fields.size (); }\n-  StructFieldType *get_field_at_index (size_t index)\n-  {\n-    rust_assert (index < fields.size ());\n-    return fields.at (index);\n-  }\n+  size_t num_fields () const;\n+  StructFieldType *get_field_at_index (size_t index);\n \n-  std::vector<StructFieldType *> &get_fields ()\n-  {\n-    rust_assert (type != NUM);\n-    return fields;\n-  }\n+  std::vector<StructFieldType *> &get_fields ();\n \n   bool lookup_field (const std::string &lookup, StructFieldType **field_lookup,\n-\t\t     size_t *index) const\n-  {\n-    size_t i = 0;\n-    for (auto &field : fields)\n-      {\n-\tif (field->get_name ().compare (lookup) == 0)\n-\t  {\n-\t    if (index != nullptr)\n-\t      *index = i;\n-\n-\t    if (field_lookup != nullptr)\n-\t      *field_lookup = field;\n-\n-\t    return true;\n-\t  }\n-\ti++;\n-      }\n-    return false;\n-  }\n-\n-  HIR::Expr *get_discriminant () const\n-  {\n-    rust_assert (discriminant != nullptr);\n-    return discriminant;\n-  }\n-\n-  std::string as_string () const\n-  {\n-    if (type == VariantType::NUM)\n-      return identifier + \" = \" + discriminant->as_string ();\n-\n-    std::string buffer;\n-    for (size_t i = 0; i < fields.size (); ++i)\n-      {\n-\tbuffer += fields.at (i)->as_string ();\n-\tif ((i + 1) < fields.size ())\n-\t  buffer += \", \";\n-      }\n-\n-    if (type == VariantType::TUPLE)\n-      return identifier + \" (\" + buffer + \")\";\n-    else\n-      return identifier + \" {\" + buffer + \"}\";\n-  }\n-\n-  bool is_equal (const VariantDef &other) const\n-  {\n-    if (type != other.type)\n-      return false;\n-\n-    if (identifier.compare (other.identifier) != 0)\n-      return false;\n+\t\t     size_t *index) const;\n \n-    if (discriminant != other.discriminant)\n-      return false;\n-\n-    if (fields.size () != other.fields.size ())\n-      return false;\n-\n-    for (size_t i = 0; i < fields.size (); i++)\n-      {\n-\tif (!fields.at (i)->is_equal (*other.fields.at (i)))\n-\t  return false;\n-      }\n-\n-    return true;\n-  }\n-\n-  VariantDef *clone () const\n-  {\n-    std::vector<StructFieldType *> cloned_fields;\n-    for (auto &f : fields)\n-      cloned_fields.push_back ((StructFieldType *) f->clone ());\n+  HIR::Expr *get_discriminant () const;\n \n-    return new VariantDef (id, defid, identifier, ident, type, discriminant,\n-\t\t\t   cloned_fields);\n-  }\n-\n-  VariantDef *monomorphized_clone () const\n-  {\n-    std::vector<StructFieldType *> cloned_fields;\n-    for (auto &f : fields)\n-      cloned_fields.push_back ((StructFieldType *) f->monomorphized_clone ());\n+  std::string as_string () const;\n \n-    return new VariantDef (id, defid, identifier, ident, type, discriminant,\n-\t\t\t   cloned_fields);\n-  }\n+  bool is_equal (const VariantDef &other) const;\n+  VariantDef *clone () const;\n+  VariantDef *monomorphized_clone () const;\n \n-  const RustIdent &get_ident () const { return ident; }\n+  const RustIdent &get_ident () const;\n \n private:\n   HirId id;\n@@ -1369,7 +589,6 @@ class ADTType : public BaseType, public SubstitutionRef\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1453,7 +672,7 @@ class ADTType : public BaseType, public SubstitutionRef\n   }\n \n   ADTType *\n-  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+  handle_substitions (SubstitutionArgumentMappings &mappings) override final;\n \n private:\n   std::string identifier;\n@@ -1509,7 +728,6 @@ class FnType : public BaseType, public SubstitutionRef\n \n   std::string get_identifier () const { return identifier; }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1586,7 +804,7 @@ class FnType : public BaseType, public SubstitutionRef\n   }\n \n   FnType *\n-  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+  handle_substitions (SubstitutionArgumentMappings &mappings) override final;\n \n   ABI get_abi () const { return abi; }\n \n@@ -1629,7 +847,6 @@ class FnPtr : public BaseType\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1709,7 +926,6 @@ class ClosureType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n   std::string get_name () const override final { return as_string (); }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1736,7 +952,7 @@ class ClosureType : public BaseType, public SubstitutionRef\n   }\n \n   ClosureType *\n-  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+  handle_substitions (SubstitutionArgumentMappings &mappings) override final;\n \n   TyTy::TupleType &get_parameters () const { return *parameters; }\n   TyTy::BaseType &get_result_type () const { return *result_type.get_tyty (); }\n@@ -1778,7 +994,6 @@ class ArrayType : public BaseType\n \n   std::string get_name () const override final { return as_string (); }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1795,7 +1010,7 @@ class ArrayType : public BaseType\n \n   HIR::Expr &get_capacity_expr () const { return capacity_expr; }\n \n-  ArrayType *handle_substitions (SubstitutionArgumentMappings mappings);\n+  ArrayType *handle_substitions (SubstitutionArgumentMappings &mappings);\n \n private:\n   TyVar element_type;\n@@ -1826,7 +1041,6 @@ class SliceType : public BaseType\n \n   std::string get_name () const override final { return as_string (); }\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -1841,7 +1055,7 @@ class SliceType : public BaseType\n     return get_element_type ()->is_concrete ();\n   }\n \n-  SliceType *handle_substitions (SubstitutionArgumentMappings mappings);\n+  SliceType *handle_substitions (SubstitutionArgumentMappings &mappings);\n \n private:\n   TyVar element_type;\n@@ -1850,33 +1064,21 @@ class SliceType : public BaseType\n class BoolType : public BaseType\n {\n public:\n-  BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::BOOL,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::BOOL,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class IntType : public BaseType\n@@ -1891,40 +1093,26 @@ class IntType : public BaseType\n     I128\n   };\n \n-  IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::INT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      int_kind (kind)\n-  {}\n-\n+  IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ());\n   IntType (HirId ref, HirId ty_ref, IntKind kind,\n-\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::INT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      int_kind (kind)\n-  {}\n+\t   std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  IntKind get_int_kind () const { return int_kind; }\n+  IntKind get_int_kind () const;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n private:\n   IntKind int_kind;\n@@ -1942,40 +1130,27 @@ class UintType : public BaseType\n     U128\n   };\n \n-  UintType (HirId ref, UintKind kind, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::UINT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      uint_kind (kind)\n-  {}\n-\n+  UintType (HirId ref, UintKind kind,\n+\t    std::set<HirId> refs = std::set<HirId> ());\n   UintType (HirId ref, HirId ty_ref, UintKind kind,\n-\t    std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::UINT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      uint_kind (kind)\n-  {}\n+\t    std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  UintKind get_uint_kind () const { return uint_kind; }\n+  UintKind get_uint_kind () const;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n private:\n   UintKind uint_kind;\n@@ -1991,40 +1166,25 @@ class FloatType : public BaseType\n   };\n \n   FloatType (HirId ref, FloatKind kind,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::FLOAT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      float_kind (kind)\n-  {}\n-\n+\t     std::set<HirId> refs = std::set<HirId> ());\n   FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FLOAT,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      float_kind (kind)\n-  {}\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n+  std::string get_name () const override final;\n \n-  std::string get_name () const override final { return as_string (); }\n-\n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  FloatKind get_float_kind () const { return float_kind; }\n+  FloatKind get_float_kind () const;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n private:\n   FloatKind float_kind;\n@@ -2033,153 +1193,91 @@ class FloatType : public BaseType\n class USizeType : public BaseType\n {\n public:\n-  USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::USIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::USIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  USizeType (HirId ref, HirId ty_ref,\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n+  std::string get_name () const override final;\n \n-  std::string get_name () const override final { return as_string (); }\n-\n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class ISizeType : public BaseType\n {\n public:\n-  ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ISIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ISIZE,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  ISizeType (HirId ref, HirId ty_ref,\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n+  std::string get_name () const override final;\n \n-  std::string get_name () const override final { return as_string (); }\n-\n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class CharType : public BaseType\n {\n public:\n-  CharType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::CHAR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  CharType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::CHAR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  CharType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  CharType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n+  std::string get_name () const override final;\n \n-  std::string get_name () const override final { return as_string (); }\n-\n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class StrType : public BaseType\n {\n public:\n-  StrType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::STR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  StrType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  StrType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ());\n \n-  StrType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::STR,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n };\n \n class ReferenceType : public BaseType\n {\n public:\n   ReferenceType (HirId ref, TyVar base, Mutability mut,\n-\t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::REF,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n-\n+\t\t std::set<HirId> refs = std::set<HirId> ());\n   ReferenceType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n-\t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::REF,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n+\t\t std::set<HirId> refs = std::set<HirId> ());\n \n   BaseType *get_base () const;\n \n@@ -2190,53 +1288,26 @@ class ReferenceType : public BaseType\n \n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  bool is_concrete () const override final\n-  {\n-    return get_base ()->is_concrete ();\n-  }\n-\n-  ReferenceType *handle_substitions (SubstitutionArgumentMappings mappings);\n-\n-  Mutability mutability () const { return mut; }\n+  bool is_concrete () const override final;\n \n-  bool is_mutable () const { return mut == Mutability::Mut; }\n+  ReferenceType *handle_substitions (SubstitutionArgumentMappings &mappings);\n \n-  bool is_dyn_object () const\n-  {\n-    return is_dyn_slice_type () || is_dyn_str_type ();\n-  }\n+  Mutability mutability () const;\n \n-  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::SLICE)\n-      return false;\n-    if (slice == nullptr)\n-      return true;\n+  bool is_mutable () const;\n \n-    *slice = static_cast<const TyTy::SliceType *> (element);\n-    return true;\n-  }\n+  bool is_dyn_object () const;\n \n-  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::STR)\n-      return false;\n-    if (str == nullptr)\n-      return true;\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const;\n \n-    *str = static_cast<const TyTy::StrType *> (element);\n-    return true;\n-  }\n+  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const;\n \n private:\n   TyVar base;\n@@ -2247,22 +1318,9 @@ class PointerType : public BaseType\n {\n public:\n   PointerType (HirId ref, TyVar base, Mutability mut,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::POINTER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n-\n+\t       std::set<HirId> refs = std::set<HirId> ());\n   PointerType (HirId ref, HirId ty_ref, TyVar base, Mutability mut,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::POINTER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      base (base), mut (mut)\n-  {}\n+\t       std::set<HirId> refs = std::set<HirId> ());\n \n   BaseType *get_base () const;\n \n@@ -2272,55 +1330,24 @@ class PointerType : public BaseType\n   std::string as_string () const override;\n   std::string get_name () const override final;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  bool is_concrete () const override final\n-  {\n-    return get_base ()->is_concrete ();\n-  }\n-\n-  PointerType *handle_substitions (SubstitutionArgumentMappings mappings);\n-\n-  Mutability mutability () const { return mut; }\n-\n-  bool is_mutable () const { return mut == Mutability::Mut; }\n-\n-  bool is_const () const { return mut == Mutability::Imm; }\n-\n-  bool is_dyn_object () const\n-  {\n-    return is_dyn_slice_type () || is_dyn_str_type ();\n-  }\n-\n-  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::SLICE)\n-      return false;\n-    if (slice == nullptr)\n-      return true;\n+  bool is_concrete () const override final;\n \n-    *slice = static_cast<const TyTy::SliceType *> (element);\n-    return true;\n-  }\n+  PointerType *handle_substitions (SubstitutionArgumentMappings &mappings);\n \n-  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const\n-  {\n-    const TyTy::BaseType *element = get_base ()->destructure ();\n-    if (element->get_kind () != TyTy::TypeKind::STR)\n-      return false;\n-    if (str == nullptr)\n-      return true;\n+  Mutability mutability () const;\n+  bool is_mutable () const;\n+  bool is_const () const;\n+  bool is_dyn_object () const;\n \n-    *str = static_cast<const TyTy::StrType *> (element);\n-    return true;\n-  }\n+  bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const;\n+  bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const;\n \n private:\n   TyVar base;\n@@ -2340,35 +1367,24 @@ class PointerType : public BaseType\n class NeverType : public BaseType\n {\n public:\n-  NeverType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::NEVER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n-\n-  NeverType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::NEVER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs)\n-  {}\n+  NeverType (HirId ref, std::set<HirId> refs = std::set<HirId> ());\n+  NeverType (HirId ref, HirId ty_ref,\n+\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  bool is_unit () const override { return true; }\n-  bool is_concrete () const override final { return true; }\n+  bool is_unit () const override;\n+  bool is_concrete () const override final;\n };\n \n // used at the type in associated types in traits\n@@ -2377,43 +1393,25 @@ class PlaceholderType : public BaseType\n {\n public:\n   PlaceholderType (std::string symbol, HirId ref,\n-\t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PLACEHOLDER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      symbol (symbol)\n-  {}\n-\n+\t\t   std::set<HirId> refs = std::set<HirId> ());\n   PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n-\t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      symbol (symbol)\n-  {}\n+\t\t   std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  bool is_unit () const override\n-  {\n-    rust_assert (can_resolve ());\n-    return resolve ()->is_unit ();\n-  }\n+  bool is_unit () const override;\n \n-  std::string get_symbol () const { return symbol; }\n+  std::string get_symbol () const;\n \n   void set_associated_type (HirId ref);\n \n@@ -2425,13 +1423,7 @@ class PlaceholderType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  bool is_concrete () const override final\n-  {\n-    if (!can_resolve ())\n-      return true;\n-\n-    return resolve ()->is_concrete ();\n-  }\n+  bool is_concrete () const override final;\n \n private:\n   std::string symbol;\n@@ -2445,63 +1437,42 @@ class ProjectionType : public BaseType, public SubstitutionRef\n \t\t  std::vector<SubstitutionParamMapping> subst_refs,\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n-\t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PROJECTION,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      base (base), trait (trait), item (item)\n-  {}\n+\t\t  std::set<HirId> refs = std::set<HirId> ());\n \n   ProjectionType (HirId ref, HirId ty_ref, BaseType *base,\n \t\t  const Resolver::TraitReference *trait, DefId item,\n \t\t  std::vector<SubstitutionParamMapping> subst_refs,\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n-\t\t  std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PROJECTION,\n-\t\t{Resolver::CanonicalPath::create_empty (),\n-\t\t Linemap::predeclared_location ()},\n-\t\trefs),\n-      SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      base (base), trait (trait), item (item)\n-  {}\n+\t\t  std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n-  std::string get_name () const override final { return as_string (); }\n+  std::string get_name () const override final;\n \n-  bool is_unit () const override { return false; }\n+  bool is_unit () const override;\n \n-  bool needs_generic_substitutions () const override final\n-  {\n-    return needs_substitution ();\n-  }\n+  bool needs_generic_substitutions () const override final;\n \n-  bool supports_substitutions () const override final { return true; }\n+  bool supports_substitutions () const override final;\n \n-  bool has_subsititions_defined () const override final\n-  {\n-    return has_substitutions ();\n-  }\n+  bool has_subsititions_defined () const override final;\n \n-  const BaseType *get () const { return base; }\n-  BaseType *get () { return base; }\n+  const BaseType *get () const;\n+  BaseType *get ();\n \n-  bool is_concrete () const override final { return base->is_concrete (); }\n+  bool is_concrete () const override final;\n \n   ProjectionType *\n-  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+  handle_substitions (SubstitutionArgumentMappings &mappings) override final;\n \n private:\n   BaseType *base;\n@@ -2514,22 +1485,17 @@ class DynamicObjectType : public BaseType\n public:\n   DynamicObjectType (HirId ref, RustIdent ident,\n \t\t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n-  {}\n+\t\t     std::set<HirId> refs = std::set<HirId> ());\n \n   DynamicObjectType (HirId ref, HirId ty_ref, RustIdent ident,\n \t\t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::DYNAMIC, ident, specified_bounds, refs)\n-  {}\n+\t\t     std::set<HirId> refs = std::set<HirId> ());\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n \n   std::string as_string () const override;\n \n-  BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   bool is_equal (const BaseType &other) const override;\n@@ -2539,7 +1505,7 @@ class DynamicObjectType : public BaseType\n \n   std::string get_name () const override final;\n \n-  bool is_concrete () const override final { return true; }\n+  bool is_concrete () const override final;\n \n   // this returns a flat list of items including super trait bounds\n   const std::vector<"}, {"sha": "415ffcdc6eaa85ae091b28d8a82679b7a9933b30", "filename": "gcc/rust/typecheck/rust-unify.cc", "status": "added", "additions": 1651, "deletions": 0, "changes": 1651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-unify.cc?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,1651 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-unify.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+UnifyRules::UnifyRules (TyTy::TyWithLocation lhs, TyTy::TyWithLocation rhs,\n+\t\t\tLocation locus, bool commit_flag, bool emit_error)\n+  : lhs (lhs), rhs (rhs), locus (locus), commit_flag (commit_flag),\n+    emit_error (emit_error), mappings (*Analysis::Mappings::get ()),\n+    context (*TypeCheckContext::get ())\n+{}\n+\n+TyTy::BaseType *\n+UnifyRules::Resolve (TyTy::TyWithLocation lhs, TyTy::TyWithLocation rhs,\n+\t\t     Location locus, bool commit_flag, bool emit_error)\n+{\n+  UnifyRules r (lhs, rhs, locus, commit_flag, emit_error);\n+  TyTy::BaseType *result = r.go ();\n+\n+  if (r.commit_flag)\n+    r.commit (result);\n+\n+  bool failed = result->get_kind () == TyTy::TypeKind::ERROR;\n+  if (failed && r.emit_error)\n+    r.emit_type_mismatch ();\n+\n+  return result;\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::get_base ()\n+{\n+  return lhs.get_ty ()->destructure ();\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::get_other ()\n+{\n+  return rhs.get_ty ()->destructure ();\n+}\n+\n+void\n+UnifyRules::commit (TyTy::BaseType *resolved)\n+{\n+  resolved->append_reference (get_base ()->get_ref ());\n+  resolved->append_reference (get_other ()->get_ref ());\n+  for (auto ref : get_base ()->get_combined_refs ())\n+    resolved->append_reference (ref);\n+  for (auto ref : get_other ()->get_combined_refs ())\n+    resolved->append_reference (ref);\n+\n+  get_other ()->append_reference (resolved->get_ref ());\n+  get_other ()->append_reference (get_base ()->get_ref ());\n+  get_base ()->append_reference (resolved->get_ref ());\n+  get_base ()->append_reference (get_other ()->get_ref ());\n+\n+  bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n+  bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n+  bool results_is_non_general_infer_var\n+    = (result_is_infer_var\n+       && (static_cast<TyTy::InferType *> (resolved))->get_infer_kind ()\n+\t    != TyTy::InferType::GENERAL);\n+  if (result_resolved || results_is_non_general_infer_var)\n+    {\n+      for (auto &ref : resolved->get_combined_refs ())\n+\t{\n+\t  TyTy::BaseType *ref_tyty = nullptr;\n+\t  bool ok = context.lookup_type (ref, &ref_tyty);\n+\t  if (!ok)\n+\t    continue;\n+\n+\t  // if any of the types are inference variables lets fix them\n+\t  if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n+\t    {\n+\t      auto node = Analysis::NodeMapping (mappings.get_current_crate (),\n+\t\t\t\t\t\t UNKNOWN_NODEID, ref,\n+\t\t\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\t      context.insert_type (node, resolved->clone ());\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+UnifyRules::emit_type_mismatch () const\n+{\n+  TyTy::BaseType *expected = lhs.get_ty ();\n+  TyTy::BaseType *expr = rhs.get_ty ();\n+\n+  RichLocation r (locus);\n+  r.add_range (lhs.get_locus ());\n+  r.add_range (rhs.get_locus ());\n+  rust_error_at (r, \"expected %<%s%> got %<%s%>\",\n+\t\t expected->get_name ().c_str (), expr->get_name ().c_str ());\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::go ()\n+{\n+  TyTy::BaseType *ltype = lhs.get_ty ();\n+  TyTy::BaseType *rtype = rhs.get_ty ();\n+\n+  ltype = lhs.get_ty ()->destructure ();\n+  rtype = rhs.get_ty ()->destructure ();\n+\n+  rust_debug (\"unify::go ltype={%s} rtype={%s}\", ltype->debug_str ().c_str (),\n+\t      rtype->debug_str ().c_str ());\n+\n+  // check bounds\n+  if (ltype->num_specified_bounds () > 0)\n+    {\n+      if (!ltype->bounds_compatible (*rtype, locus, true))\n+\t{\n+\t  // already emitted an error\n+\t  emit_error = false;\n+\t  return new TyTy::ErrorType (0);\n+\t}\n+    }\n+\n+  switch (ltype->get_kind ())\n+    {\n+    case TyTy::INFER:\n+      return expect_inference_variable (static_cast<TyTy::InferType *> (ltype),\n+\t\t\t\t\trtype);\n+\n+    case TyTy::ADT:\n+      return expect_adt (static_cast<TyTy::ADTType *> (ltype), rtype);\n+\n+    case TyTy::STR:\n+      return expect_str (static_cast<TyTy::StrType *> (ltype), rtype);\n+\n+    case TyTy::REF:\n+      return expect_reference (static_cast<TyTy::ReferenceType *> (ltype),\n+\t\t\t       rtype);\n+\n+    case TyTy::POINTER:\n+      return expect_pointer (static_cast<TyTy::PointerType *> (ltype), rtype);\n+\n+    case TyTy::PARAM:\n+      return expect_param (static_cast<TyTy::ParamType *> (ltype), rtype);\n+\n+    case TyTy::ARRAY:\n+      return expect_array (static_cast<TyTy::ArrayType *> (ltype), rtype);\n+\n+    case TyTy::SLICE:\n+      return expect_slice (static_cast<TyTy::SliceType *> (ltype), rtype);\n+\n+    case TyTy::FNDEF:\n+      return expect_fndef (static_cast<TyTy::FnType *> (ltype), rtype);\n+\n+    case TyTy::FNPTR:\n+      return expect_fnptr (static_cast<TyTy::FnPtr *> (ltype), rtype);\n+\n+    case TyTy::TUPLE:\n+      return expect_tuple (static_cast<TyTy::TupleType *> (ltype), rtype);\n+\n+    case TyTy::BOOL:\n+      return expect_bool (static_cast<TyTy::BoolType *> (ltype), rtype);\n+\n+    case TyTy::CHAR:\n+      return expect_char (static_cast<TyTy::CharType *> (ltype), rtype);\n+\n+    case TyTy::INT:\n+      return expect_int (static_cast<TyTy::IntType *> (ltype), rtype);\n+\n+    case TyTy::UINT:\n+      return expect_uint (static_cast<TyTy::UintType *> (ltype), rtype);\n+\n+    case TyTy::FLOAT:\n+      return expect_float (static_cast<TyTy::FloatType *> (ltype), rtype);\n+\n+    case TyTy::USIZE:\n+      return expect_usize (static_cast<TyTy::USizeType *> (ltype), rtype);\n+\n+    case TyTy::ISIZE:\n+      return expect_isize (static_cast<TyTy::ISizeType *> (ltype), rtype);\n+\n+    case TyTy::NEVER:\n+      return expect_never (static_cast<TyTy::NeverType *> (ltype), rtype);\n+\n+    case TyTy::PLACEHOLDER:\n+      return expect_placeholder (static_cast<TyTy::PlaceholderType *> (ltype),\n+\t\t\t\t rtype);\n+\n+    case TyTy::PROJECTION:\n+      return expect_projection (static_cast<TyTy::ProjectionType *> (ltype),\n+\t\t\t\trtype);\n+\n+    case TyTy::DYNAMIC:\n+      return expect_dyn (static_cast<TyTy::DynamicObjectType *> (ltype), rtype);\n+\n+    case TyTy::CLOSURE:\n+      return expect_closure (static_cast<TyTy::ClosureType *> (ltype), rtype);\n+\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_inference_variable (TyTy::InferType *ltype,\n+\t\t\t\t       TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tswitch (ltype->get_infer_kind ())\n+\t  {\n+\t  case TyTy::InferType::InferTypeKind::GENERAL:\n+\t    return rtype->clone ();\n+\n+\t    case TyTy::InferType::InferTypeKind::INTEGRAL: {\n+\t      bool is_valid = r->get_infer_kind ()\n+\t\t\t\t== TyTy::InferType::InferTypeKind::INTEGRAL\n+\t\t\t      || r->get_infer_kind ()\n+\t\t\t\t   == TyTy::InferType::InferTypeKind::GENERAL;\n+\t      if (is_valid)\n+\t\treturn rtype->clone ();\n+\t    }\n+\t    break;\n+\n+\t    case TyTy::InferType::InferTypeKind::FLOAT: {\n+\t      bool is_valid\n+\t\t= r->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT\n+\t\t  || r->get_infer_kind ()\n+\t\t       == TyTy::InferType::InferTypeKind::GENERAL;\n+\t      if (is_valid)\n+\t\treturn rtype->clone ();\n+\t    }\n+\t    break;\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+      case TyTy::ISIZE: {\n+\tbool is_valid = (ltype->get_infer_kind ()\n+\t\t\t == TyTy::InferType::InferTypeKind::GENERAL)\n+\t\t\t|| (ltype->get_infer_kind ()\n+\t\t\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+\tif (is_valid)\n+\t  return rtype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FLOAT: {\n+\tbool is_valid = (ltype->get_infer_kind ()\n+\t\t\t == TyTy::InferType::InferTypeKind::GENERAL)\n+\t\t\t|| (ltype->get_infer_kind ()\n+\t\t\t    == TyTy::InferType::InferTypeKind::FLOAT);\n+\tif (is_valid)\n+\t  return rtype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+      case TyTy::CLOSURE: {\n+\tbool is_valid = (ltype->get_infer_kind ()\n+\t\t\t == TyTy::InferType::InferTypeKind::GENERAL);\n+\tif (is_valid)\n+\t  return rtype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_adt (TyTy::ADTType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::ADT: {\n+\tTyTy::ADTType &type = *static_cast<TyTy::ADTType *> (rtype);\n+\tif (ltype->get_adt_kind () != type.get_adt_kind ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (ltype->get_identifier ().compare (type.get_identifier ()) != 0)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (ltype->number_of_variants () != type.number_of_variants ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < type.number_of_variants (); ++i)\n+\t  {\n+\t    TyTy::VariantDef *a = ltype->get_variants ().at (i);\n+\t    TyTy::VariantDef *b = type.get_variants ().at (i);\n+\n+\t    if (a->num_fields () != b->num_fields ())\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\n+\t    for (size_t j = 0; j < a->num_fields (); j++)\n+\t      {\n+\t\tTyTy::StructFieldType *base_field = a->get_field_at_index (j);\n+\t\tTyTy::StructFieldType *other_field = b->get_field_at_index (j);\n+\n+\t\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t\tTyTy::BaseType *unified_ty\n+\t\t  = UnifyRules::Resolve (TyTy::TyWithLocation (this_field_ty),\n+\t\t\t\t\t TyTy::TyWithLocation (other_field_ty),\n+\t\t\t\t\t locus, commit_flag,\n+\t\t\t\t\t false /* emit_error */);\n+\t\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t  {\n+\t\t    return new TyTy::ErrorType (0);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\t// generic args for the unit-struct case\n+\tif (type.is_unit () && ltype->is_unit ())\n+\t  {\n+\t    rust_assert (type.get_num_substitutions ()\n+\t\t\t == ltype->get_num_substitutions ());\n+\n+\t    for (size_t i = 0; i < type.get_num_substitutions (); i++)\n+\t      {\n+\t\tauto &a = ltype->get_substs ().at (i);\n+\t\tauto &b = type.get_substs ().at (i);\n+\n+\t\tauto pa = a.get_param_ty ();\n+\t\tauto pb = b.get_param_ty ();\n+\n+\t\tauto res\n+\t\t  = UnifyRules::Resolve (TyTy::TyWithLocation (pa),\n+\t\t\t\t\t TyTy::TyWithLocation (pb), locus,\n+\t\t\t\t\t commit_flag, false /* emit_error */);\n+\t\tif (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t  {\n+\t\t    return new TyTy::ErrorType (0);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\treturn type.clone ();\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_str (TyTy::StrType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+      return rtype->clone ();\n+\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_reference (TyTy::ReferenceType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::REF: {\n+\tTyTy::ReferenceType &type = *static_cast<TyTy::ReferenceType *> (rtype);\n+\tauto base_type = ltype->get_base ();\n+\tauto other_base_type = type.get_base ();\n+\n+\tTyTy::BaseType *base_resolved\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (base_type),\n+\t\t\t\t TyTy::TyWithLocation (other_base_type), locus,\n+\t\t\t\t commit_flag, false /* emit_error */);\n+\tif (base_resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\t// rust is permissive about mutablity here you can always go from\n+\t// mutable to immutable but not the otherway round\n+\tbool mutability_ok = ltype->is_mutable () ? type.is_mutable () : true;\n+\tif (!mutability_ok)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn new TyTy::ReferenceType (ltype->get_ref (), ltype->get_ty_ref (),\n+\t\t\t\t\tTyTy::TyVar (base_resolved->get_ref ()),\n+\t\t\t\t\tltype->mutability ());\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_pointer (TyTy::PointerType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::POINTER: {\n+\tTyTy::PointerType &type = *static_cast<TyTy::PointerType *> (rtype);\n+\tauto base_type = ltype->get_base ();\n+\tauto other_base_type = type.get_base ();\n+\n+\tTyTy::BaseType *base_resolved\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (base_type),\n+\t\t\t\t TyTy::TyWithLocation (other_base_type), locus,\n+\t\t\t\t commit_flag, false /* emit_error */);\n+\tif (base_resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\t// rust is permissive about mutablity here you can always go from\n+\t// mutable to immutable but not the otherway round\n+\tbool mutability_ok = ltype->is_mutable () ? type.is_mutable () : true;\n+\tif (!mutability_ok)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn new TyTy::PointerType (ltype->get_ref (), ltype->get_ty_ref (),\n+\t\t\t\t      TyTy::TyVar (base_resolved->get_ref ()),\n+\t\t\t\t      ltype->mutability ());\n+      }\n+      break;\n+\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_param (TyTy::ParamType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::PARAM: {\n+\tTyTy::ParamType &type = *static_cast<TyTy::ParamType *> (rtype);\n+\t// bool symbol_matches\n+\t//   = ltype->get_symbol ().compare (type.get_symbol ()) == 0;\n+\t// // TODO\n+\t// // I think rustc checks a debruinj index\n+\t// if (symbol_matches)\n+\t//   {\n+\t//     return type.clone ();\n+\t//   }\n+\n+\t// matching symbol is not going to work when we mix symbol's and have\n+\t// nested generics\n+\n+\t// bounds match? FIXME\n+\n+\treturn type.clone ();\n+      }\n+      break;\n+\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_array (TyTy::ArrayType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::ARRAY: {\n+\tTyTy::ArrayType &type = *static_cast<TyTy::ArrayType *> (rtype);\n+\tTyTy::BaseType *element_unify = UnifyRules::Resolve (\n+\t  TyTy::TyWithLocation (ltype->get_element_type ()),\n+\t  TyTy::TyWithLocation (type.get_element_type ()), locus, commit_flag,\n+\t  false /* emit_error*/);\n+\n+\tif (element_unify->get_kind () != TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t\ttype.get_ident ().locus,\n+\t\t\t\t\ttype.get_capacity_expr (),\n+\t\t\t\t\tTyTy::TyVar (\n+\t\t\t\t\t  element_unify->get_ref ()));\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_slice (TyTy::SliceType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::SLICE: {\n+\tTyTy::SliceType &type = *static_cast<TyTy::SliceType *> (rtype);\n+\tTyTy::BaseType *element_unify = UnifyRules::Resolve (\n+\t  TyTy::TyWithLocation (ltype->get_element_type ()),\n+\t  TyTy::TyWithLocation (type.get_element_type ()), locus, commit_flag,\n+\t  false /* emit_error*/);\n+\n+\tif (element_unify->get_kind () != TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::SliceType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t\ttype.get_ident ().locus,\n+\t\t\t\t\tTyTy::TyVar (\n+\t\t\t\t\t  element_unify->get_ref ()));\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_fndef (TyTy::FnType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FNDEF: {\n+\tTyTy::FnType &type = *static_cast<TyTy::FnType *> (rtype);\n+\tif (ltype->num_params () != type.num_params ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < ltype->num_params (); i++)\n+\t  {\n+\t    auto a = ltype->param_at (i).second;\n+\t    auto b = type.param_at (i).second;\n+\n+\t    auto unified_param\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (a),\n+\t\t\t\t     TyTy::TyWithLocation (b), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_param->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\t  }\n+\n+\tauto unified_return\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (\n+\t\t\t\t   ltype->get_return_type ()),\n+\t\t\t\t TyTy::TyWithLocation (type.get_return_type ()),\n+\t\t\t\t locus, commit_flag, false /* emit_errors */);\n+\tif (unified_return->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNPTR:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_fnptr (TyTy::FnPtr *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FNPTR: {\n+\tTyTy::FnPtr &type = *static_cast<TyTy::FnPtr *> (rtype);\n+\tif (ltype->num_params () != type.num_params ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < ltype->num_params (); i++)\n+\t  {\n+\t    auto a = ltype->param_at (i);\n+\t    auto b = type.param_at (i);\n+\n+\t    auto unified_param\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (a),\n+\t\t\t\t     TyTy::TyWithLocation (b), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_param->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\t  }\n+\n+\tauto unified_return\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (\n+\t\t\t\t   ltype->get_return_type ()),\n+\t\t\t\t TyTy::TyWithLocation (type.get_return_type ()),\n+\t\t\t\t locus, commit_flag, false /* emit_errors */);\n+\tif (unified_return->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FNDEF: {\n+\tTyTy::FnType &type = *static_cast<TyTy::FnType *> (rtype);\n+\tauto this_ret_type = ltype->get_return_type ();\n+\tauto other_ret_type = type.get_return_type ();\n+\n+\tauto unified_result\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (this_ret_type),\n+\t\t\t\t TyTy::TyWithLocation (other_ret_type), locus,\n+\t\t\t\t commit_flag, false /*emit_errors*/);\n+\tif (unified_result->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (ltype->num_params () != type.num_params ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tfor (size_t i = 0; i < ltype->num_params (); i++)\n+\t  {\n+\t    auto this_param = ltype->param_at (i);\n+\t    auto other_param = type.param_at (i).second;\n+\n+\t    auto unified_param\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (this_param),\n+\t\t\t\t     TyTy::TyWithLocation (other_param), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_param->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn new TyTy::ErrorType (0);\n+\t      }\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_tuple (TyTy::TupleType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::TUPLE: {\n+\tTyTy::TupleType &type = *static_cast<TyTy::TupleType *> (rtype);\n+\tif (ltype->num_fields () != type.num_fields ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tstd::vector<TyTy::TyVar> fields;\n+\tfor (size_t i = 0; i < ltype->num_fields (); i++)\n+\t  {\n+\t    TyTy::BaseType *bo = ltype->get_field (i);\n+\t    TyTy::BaseType *fo = type.get_field (i);\n+\n+\t    TyTy::BaseType *unified_ty\n+\t      = UnifyRules::Resolve (TyTy::TyWithLocation (bo),\n+\t\t\t\t     TyTy::TyWithLocation (fo), locus,\n+\t\t\t\t     commit_flag, false /* emit_errors */);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return new TyTy::ErrorType (0);\n+\n+\t    fields.push_back (TyTy::TyVar (unified_ty->get_ref ()));\n+\t  }\n+\n+\treturn new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_ident ().locus, fields);\n+      }\n+      break;\n+\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_bool (TyTy::BoolType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::BOOL:\n+      return rtype->clone ();\n+\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_char (TyTy::CharType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::CHAR:\n+      return rtype->clone ();\n+\n+    case TyTy::INT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_int (TyTy::IntType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL\n+\t    || r->get_infer_kind () == TyTy::InferType::InferTypeKind::INTEGRAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::INT: {\n+\tTyTy::IntType &type = *static_cast<TyTy::IntType *> (rtype);\n+\tbool is_valid = ltype->get_int_kind () == type.get_int_kind ();\n+\tif (is_valid)\n+\t  return new TyTy::IntType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_int_kind ());\n+      }\n+      break;\n+\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_uint (TyTy::UintType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL\n+\t    || r->get_infer_kind () == TyTy::InferType::InferTypeKind::INTEGRAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::UINT: {\n+\tTyTy::UintType &type = *static_cast<TyTy::UintType *> (rtype);\n+\tbool is_valid = ltype->get_uint_kind () == type.get_uint_kind ();\n+\tif (is_valid)\n+\t  return new TyTy::UintType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t     type.get_uint_kind ());\n+      }\n+      break;\n+\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_float (TyTy::FloatType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL\n+\t    || r->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::FLOAT: {\n+\tTyTy::FloatType &type = *static_cast<TyTy::FloatType *> (rtype);\n+\tbool is_valid = ltype->get_float_kind () == type.get_float_kind ();\n+\tif (is_valid)\n+\t  return new TyTy::FloatType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t      type.get_float_kind ());\n+      }\n+      break;\n+\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_isize (TyTy::ISizeType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () != TyTy::InferType::InferTypeKind::FLOAT;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::ISIZE:\n+      return rtype->clone ();\n+\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_usize (TyTy::USizeType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () != TyTy::InferType::InferTypeKind::FLOAT;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::USIZE:\n+      return rtype->clone ();\n+\n+    case TyTy::ADT:\n+    case TyTy::STR:\n+    case TyTy::REF:\n+    case TyTy::POINTER:\n+    case TyTy::PARAM:\n+    case TyTy::ARRAY:\n+    case TyTy::SLICE:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_never (TyTy::NeverType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::NEVER:\n+      return rtype->clone ();\n+\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_placeholder (TyTy::PlaceholderType *ltype,\n+\t\t\t\tTyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::PLACEHOLDER: {\n+\tTyTy::PlaceholderType &type\n+\t  = *static_cast<TyTy::PlaceholderType *> (rtype);\n+\tbool symbol_match\n+\t  = ltype->get_symbol ().compare (type.get_symbol ()) == 0;\n+\tif (symbol_match)\n+\t  {\n+\t    return type.clone ();\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_projection (TyTy::ProjectionType *ltype,\n+\t\t\t       TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      // FIXME\n+    case TyTy::PROJECTION:\n+      gcc_unreachable ();\n+      break;\n+\n+    case TyTy::DYNAMIC:\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_dyn (TyTy::DynamicObjectType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::DYNAMIC: {\n+\tTyTy::DynamicObjectType &type\n+\t  = *static_cast<TyTy::DynamicObjectType *> (rtype);\n+\tif (ltype->num_specified_bounds () != type.num_specified_bounds ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tif (!ltype->bounds_compatible (type, locus, true))\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::CLOSURE:\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+TyTy::BaseType *\n+UnifyRules::expect_closure (TyTy::ClosureType *ltype, TyTy::BaseType *rtype)\n+{\n+  switch (rtype->get_kind ())\n+    {\n+      case TyTy::INFER: {\n+\tTyTy::InferType *r = static_cast<TyTy::InferType *> (rtype);\n+\tbool is_valid\n+\t  = r->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n+\tif (is_valid)\n+\t  return ltype->clone ();\n+      }\n+      break;\n+\n+      case TyTy::CLOSURE: {\n+\tTyTy::ClosureType &type = *static_cast<TyTy::ClosureType *> (rtype);\n+\tif (ltype->get_def_id () != type.get_def_id ())\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tTyTy::BaseType *args_res\n+\t  = UnifyRules::Resolve (TyTy::TyWithLocation (\n+\t\t\t\t   &ltype->get_parameters ()),\n+\t\t\t\t TyTy::TyWithLocation (&type.get_parameters ()),\n+\t\t\t\t locus, commit_flag, false /* emit_error */);\n+\tif (args_res->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\tTyTy::BaseType *res = UnifyRules::Resolve (\n+\t  TyTy::TyWithLocation (&ltype->get_result_type ()),\n+\t  TyTy::TyWithLocation (&type.get_result_type ()), locus, commit_flag,\n+\t  false /* emit_error */);\n+\tif (res == nullptr || res->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    return new TyTy::ErrorType (0);\n+\t  }\n+\n+\treturn ltype->clone ();\n+      }\n+      break;\n+\n+    case TyTy::SLICE:\n+    case TyTy::PARAM:\n+    case TyTy::POINTER:\n+    case TyTy::STR:\n+    case TyTy::ADT:\n+    case TyTy::REF:\n+    case TyTy::ARRAY:\n+    case TyTy::FNDEF:\n+    case TyTy::FNPTR:\n+    case TyTy::TUPLE:\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::NEVER:\n+    case TyTy::PLACEHOLDER:\n+    case TyTy::PROJECTION:\n+    case TyTy::DYNAMIC:\n+    case TyTy::ERROR:\n+      return new TyTy::ErrorType (0);\n+    }\n+  return new TyTy::ErrorType (0);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "6e46b9642a60ae577aff78ded2ff5a5b3394f83a", "filename": "gcc/rust/typecheck/rust-unify.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-unify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Ftypecheck%2Frust-unify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-unify.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_UNIFY\n+#define RUST_UNIFY\n+\n+#include \"rust-tyty-util.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class UnifyRules\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::TyWithLocation lhs,\n+\t\t\t\t  TyTy::TyWithLocation rhs, Location locus,\n+\t\t\t\t  bool commit_flag, bool emit_error);\n+\n+protected:\n+  TyTy::BaseType *expect_inference_variable (TyTy::InferType *ltype,\n+\t\t\t\t\t     TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_adt (TyTy::ADTType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_str (TyTy::StrType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_reference (TyTy::ReferenceType *ltype,\n+\t\t\t\t    TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_pointer (TyTy::PointerType *ltype,\n+\t\t\t\t  TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_param (TyTy::ParamType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_array (TyTy::ArrayType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_slice (TyTy::SliceType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_fndef (TyTy::FnType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_fnptr (TyTy::FnPtr *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_tuple (TyTy::TupleType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_bool (TyTy::BoolType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_char (TyTy::CharType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_int (TyTy::IntType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_uint (TyTy::UintType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_float (TyTy::FloatType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_isize (TyTy::ISizeType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_usize (TyTy::USizeType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_never (TyTy::NeverType *ltype, TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_placeholder (TyTy::PlaceholderType *ltype,\n+\t\t\t\t      TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_projection (TyTy::ProjectionType *ltype,\n+\t\t\t\t     TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_dyn (TyTy::DynamicObjectType *ltype,\n+\t\t\t      TyTy::BaseType *rtype);\n+  TyTy::BaseType *expect_closure (TyTy::ClosureType *ltype,\n+\t\t\t\t  TyTy::BaseType *rtype);\n+\n+private:\n+  UnifyRules (TyTy::TyWithLocation lhs, TyTy::TyWithLocation rhs,\n+\t      Location locus, bool commit_flag, bool emit_error);\n+\n+  void emit_type_mismatch () const;\n+  void commit (TyTy::BaseType *resolved);\n+  TyTy::BaseType *go ();\n+\n+  TyTy::BaseType *get_base ();\n+  TyTy::BaseType *get_other ();\n+\n+  TyTy::TyWithLocation lhs;\n+  TyTy::TyWithLocation rhs;\n+  Location locus;\n+  bool commit_flag;\n+  bool emit_error;\n+\n+  Analysis::Mappings &mappings;\n+  TypeCheckContext &context;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_UNIFY"}, {"sha": "5bad08ae7c10f594346d8323b55be8af626a464e", "filename": "gcc/rust/util/rust-lang-item.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Futil%2Frust-lang-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Frust%2Futil%2Frust-lang-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-lang-item.h?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -80,6 +80,12 @@ class RustLangItem\n     FN_ONCE,\n     FN_ONCE_OUTPUT,\n \n+    // markers\n+    COPY,\n+    CLONE,\n+    SIZED,\n+\n+    // delimiter\n     UNKNOWN,\n   };\n \n@@ -237,6 +243,18 @@ class RustLangItem\n       {\n \treturn ItemType::FN_ONCE_OUTPUT;\n       }\n+    else if (item.compare (\"copy\") == 0)\n+      {\n+\treturn ItemType::COPY;\n+      }\n+    else if (item.compare (\"clone\") == 0)\n+      {\n+\treturn ItemType::CLONE;\n+      }\n+    else if (item.compare (\"sized\") == 0)\n+      {\n+\treturn ItemType::SIZED;\n+      }\n \n     return ItemType::UNKNOWN;\n   }\n@@ -321,6 +339,12 @@ class RustLangItem\n \treturn \"fn_once\";\n       case FN_ONCE_OUTPUT:\n \treturn \"fn_once_output\";\n+      case COPY:\n+\treturn \"copy\";\n+      case CLONE:\n+\treturn \"clone\";\n+      case SIZED:\n+\treturn \"sized\";\n \n       case UNKNOWN:\n \treturn \"<UNKNOWN>\";"}, {"sha": "665836088beffc63842a698f7f733b92b6a1a9cd", "filename": "gcc/testsuite/rust/bounds1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fbounds1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fbounds1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fbounds1.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,19 @@\n+mod core {\n+    mod ops {\n+        #[lang = \"add\"]\n+        pub trait Add<Rhs = Self> {\n+            type Output;\n+\n+            fn add(self, rhs: Rhs) -> Self::Output;\n+        }\n+    }\n+}\n+\n+pub fn foo<T: core::ops::Add<Output = i32>>(a: T) -> i32 {\n+    // { dg-error \"bounds not satisfied for f32 .Add. is not satisfied\" \"\" { target *-*-* } .-1 }\n+    a + a\n+}\n+\n+pub fn main() {\n+    foo(123f32);\n+}"}, {"sha": "002e5c90ab5cb1f5183d75c7e8a7354ea131995e", "filename": "gcc/testsuite/rust/compile/func3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -5,5 +5,4 @@ fn test(a: i32, b: i32) -> i32 {\n fn main() {\n     let a = test(1, true);\n     // { dg-error \"expected .i32. got .bool.\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"Type Resolution failure on parameter\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "c627ac09cecbca2538525d1dac1fe7569558fd5b", "filename": "gcc/testsuite/rust/compile/issue-1773.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1773.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1773.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1773.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,20 @@\n+trait Foo<T> {\n+    type A;\n+\n+    fn test(a: Self::A) -> Self::A {\n+        a\n+    }\n+}\n+\n+struct Bar<T>(T);\n+impl<T> Foo<T> for Bar<i32> {\n+    type A = T;\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b;\n+    b = Bar::test(a.0);\n+}"}, {"sha": "f73b63d0cb679ad38217120acfb6b0387d5af51c", "filename": "gcc/testsuite/rust/compile/issue-1786.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1786.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1786.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1786.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,23 @@\n+#[lang = \"clone\"]\n+trait Clone {\n+    fn clone(&self) -> Self;\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        *self = source.clone()\n+    }\n+}\n+\n+#[lang = \"copy\"]\n+pub trait Copy: Clone {\n+    // Empty.\n+}\n+\n+mod impls {\n+    use super::Clone;\n+\n+    impl Clone for char {\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+}"}, {"sha": "8d56176fee3ec58b6734a35002fa7e634e71ef34", "filename": "gcc/testsuite/rust/compile/never_type1.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fnever_type1.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -1,8 +1,7 @@\n fn test() {\n     let a;\n \n-    // FIXME: Unimplemented features\n-    a = if true { // { dg-error \"expected .T.. got .!.\" }\n+    a = if true {\n         return;\n     } else {\n         return;", "previous_filename": "gcc/testsuite/rust/compile/never_type_err1.rs"}, {"sha": "4e09f1089b01aa2f41574b40ec8c68f90f77e4ee", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-4.rs", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-4.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -1,10 +1,67 @@\n-trait Copy {}\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"clone\"]\n+pub trait Clone: Sized {\n+    fn clone(&self) -> Self;\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        *self = source.clone()\n+    }\n+}\n+\n+mod impls {\n+    use super::Clone;\n+\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Clone for $t {\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n+\n+#[lang = \"copy\"]\n+pub trait Copy: Clone {\n+    // Empty.\n+}\n+\n+mod copy_impls {\n+    use super::Copy;\n+\n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n \n extern \"rust-intrinsic\" {\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n     pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n     pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n-    // pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n }\n \n fn main() {\n@@ -15,6 +72,6 @@ fn main() {\n         atomic_store_seqcst(&mut dst, new_value);\n         atomic_store_release(&mut dst, new_value);\n         atomic_store_relaxed(&mut dst, new_value);\n-        // atomic_store_unordered(&mut dst, new_value);\n+        atomic_store_unordered(&mut dst, new_value);\n     }\n }"}, {"sha": "ffad0bd3a853aa5d232b9ba3750e8e3442fffc3d", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-5.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -1,4 +1,61 @@\n-trait Copy {}\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"clone\"]\n+pub trait Clone: Sized {\n+    fn clone(&self) -> Self;\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        *self = source.clone()\n+    }\n+}\n+\n+mod impls {\n+    use super::Clone;\n+\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Clone for $t {\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n+\n+#[lang = \"copy\"]\n+pub trait Copy: Clone {\n+    // Empty.\n+}\n+\n+mod copy_impls {\n+    use super::Copy;\n+\n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n \n extern \"rust-intrinsic\" {\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, value: T);\n@@ -24,6 +81,13 @@ impl VeryLargeType {\n     }\n }\n \n+impl Clone for VeryLargeType {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+impl Copy for VeryLargeType {}\n+\n fn main() {\n     let mut dst = VeryLargeType::new(0);\n     let mut b = false;"}, {"sha": "6e7383aa7e908215abedf37493e2f28fd3938b96", "filename": "gcc/testsuite/rust/execute/torture/atomic_load.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -1,4 +1,61 @@\n-trait Copy {}\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"clone\"]\n+pub trait Clone: Sized {\n+    fn clone(&self) -> Self;\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        *self = source.clone()\n+    }\n+}\n+\n+mod impls {\n+    use super::Clone;\n+\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Clone for $t {\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n+\n+#[lang = \"copy\"]\n+pub trait Copy: Clone {\n+    // Empty.\n+}\n+\n+mod copy_impls {\n+    use super::Copy;\n+\n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n \n extern \"rust-intrinsic\" {\n     pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;"}, {"sha": "46960a7a1868961ed11eb3d12ed6b700df411a59", "filename": "gcc/testsuite/rust/execute/torture/atomic_store.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_store.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -1,4 +1,61 @@\n-trait Copy {}\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"clone\"]\n+pub trait Clone: Sized {\n+    fn clone(&self) -> Self;\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        *self = source.clone()\n+    }\n+}\n+\n+mod impls {\n+    use super::Clone;\n+\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Clone for $t {\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n+\n+#[lang = \"copy\"]\n+pub trait Copy: Clone {\n+    // Empty.\n+}\n+\n+mod copy_impls {\n+    use super::Copy;\n+\n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                impl Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 // u128\n+        isize i8 i16 i32 i64 // i128\n+        f32 f64\n+        bool char\n+    }\n+}\n \n extern \"rust-intrinsic\" {\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);"}, {"sha": "35833dbb813a23ca6b595019e340a44a7330ee71", "filename": "gcc/testsuite/rust/execute/torture/issue-1720-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1720-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f1fce4916520b7ee9a97d2bb4f25d25fd94a626/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1720-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1720-2.rs?ref=8f1fce4916520b7ee9a97d2bb4f25d25fd94a626", "patch": "@@ -0,0 +1,30 @@\n+mod core {\n+    mod ops {\n+        #[lang = \"add\"]\n+        pub trait Add<Rhs = Self> {\n+            type Output;\n+\n+            fn add(self, rhs: Rhs) -> Self::Output;\n+        }\n+    }\n+}\n+\n+struct Foo(i32);\n+\n+impl core::ops::Add for Foo {\n+    type Output = i32;\n+\n+    fn add(self, rhs: Foo) -> Self::Output {\n+        self.0 + rhs.0\n+    }\n+}\n+\n+pub fn bar<T: core::ops::Add<Output = i32>>(a: T) -> i32 {\n+    a + a\n+}\n+\n+pub fn main() -> i32 {\n+    let a = Foo(1);\n+\n+    bar(a) - 2\n+}"}]}