{"sha": "040e64b09d4422c7d3c51bee098043782112b924", "node_id": "C_kwDOANBUbNoAKDA0MGU2NGIwOWQ0NDIyYzdkM2M1MWJlZTA5ODA0Mzc4MjExMmI5MjQ", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-04-14T09:35:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-04-14T09:43:18Z"}, "message": "Fix vect-simd-clone testcase dump scanning\n\nThis replaces i686*-*-* && { ! lp64 } with the appropriate\n{ i?86-*-* x86_64-*-* } && { ! lp64 } for the testcases and\nalso amends the e variants checking last variant for avx.\nI've used avx in the dump scanning, not avx_runtime, since\nthe dumps get produced when one would not execute but only\ncompile them.  The f varaints lack AVX checking, I didn't\nrectify this with this patch.\n\n\t* gcc.dg/vect/vect-simd-clone-16e.c: Fix x86 lp64 checking\n\tand add missing avx guard.\n\t* gcc.dg/vect/vect-simd-clone-17e.c: Likewise.\n\t* gcc.dg/vect/vect-simd-clone-18e.c: Likewise.\n\t* gcc.dg/vect/vect-simd-clone-16f.c: Fix x86 lp64 checking.\n\t* gcc.dg/vect/vect-simd-clone-17f.c: Likewise.\n\t* gcc.dg/vect/vect-simd-clone-18f.c: Likewise.", "tree": {"sha": "38d15885d722bbb945d258bfc7a956b921f9df70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38d15885d722bbb945d258bfc7a956b921f9df70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/040e64b09d4422c7d3c51bee098043782112b924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040e64b09d4422c7d3c51bee098043782112b924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040e64b09d4422c7d3c51bee098043782112b924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040e64b09d4422c7d3c51bee098043782112b924/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d1a6119590ef828f9782a7083d03e535bc2f2cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1a6119590ef828f9782a7083d03e535bc2f2cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1a6119590ef828f9782a7083d03e535bc2f2cf"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "9d3392924b310e29a0d15e5b9abf4127df83ae65", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16e.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16e.c?ref=040e64b09d4422c7d3c51bee098043782112b924", "patch": "@@ -8,9 +8,9 @@\n /* Ensure the the in-branch simd clones are used on targets that support them.\n    Some targets use another call for the epilogue loops.\n    Some targets use pairs of vectors and do twice the calls.  */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx_runtime } && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx } && { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx && { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { { ! avx } && { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } */\n \n /* The LTO test produces two dump files and we scan the wrong one.  */\n /* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "1e2b6056db101c01bb304a99229e02651b9441d6", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16f.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16f.c?ref=040e64b09d4422c7d3c51bee098043782112b924", "patch": "@@ -7,8 +7,8 @@\n \n /* Ensure the the in-branch simd clones are used on targets that support them.\n    Some targets use pairs of vectors and do twice the calls.  */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { i686*-*-* && { ! lp64 } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { { i?86*-*-* x86_64-*-* } && { ! lp64 } } } } } */\n \n /* The LTO test produces two dump files and we scan the wrong one.  */\n /* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "769727e6db16ee0499b79f71f64042897addd6ab", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17e.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17e.c?ref=040e64b09d4422c7d3c51bee098043782112b924", "patch": "@@ -8,9 +8,9 @@\n /* Ensure the the in-branch simd clones are used on targets that support them.\n    Some targets use another call for the epilogue loops.\n    Some targets use pairs of vectors and do twice the calls.  */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx_runtime } && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx } && { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx && { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { { ! avx } && { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } */\n \n /* The LTO test produces two dump files and we scan the wrong one.  */\n /* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "c1dc420d2ca9520bc729afd9fdcac097bb9c0e15", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17f.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17f.c?ref=040e64b09d4422c7d3c51bee098043782112b924", "patch": "@@ -7,8 +7,8 @@\n \n /* Ensure the the in-branch simd clones are used on targets that support them.\n    Some targets use pairs of vectors and do twice the calls.  */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { i686*-*-* && { ! lp64 } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { { i?86*-*-* x86_64-*-* } && { ! lp64 } } } } } */\n \n /* The LTO test produces two dump files and we scan the wrong one.  */\n /* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "caa3d70763f6256844db85ace9a13000b580874d", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18e.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18e.c?ref=040e64b09d4422c7d3c51bee098043782112b924", "patch": "@@ -8,9 +8,9 @@\n /* Ensure the the in-branch simd clones are used on targets that support them.\n    Some targets use another call for the epilogue loops.\n    Some targets use pairs of vectors and do twice the calls.  */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx_runtime } && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx } && { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx && { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { { ! avx } && { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } */\n \n /* The LTO test produces two dump files and we scan the wrong one.  */\n /* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "df630c2a40b69b3ad07a35d58d6f58f295870080", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18f.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040e64b09d4422c7d3c51bee098043782112b924/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18f.c?ref=040e64b09d4422c7d3c51bee098043782112b924", "patch": "@@ -7,8 +7,8 @@\n \n /* Ensure the the in-branch simd clones are used on targets that support them.\n    Some targets use pairs of vectors and do twice the calls.  */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { i686*-*-* && { ! lp64 } } } } } } */\n-/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { { i?86*-*-* x86_64-*-* } && { ! lp64 } } } } } */\n \n /* The LTO test produces two dump files and we scan the wrong one.  */\n /* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}]}