{"sha": "59f8d7a2343cd326e905be618c820387cf13afb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlmOGQ3YTIzNDNjZDMyNmU5MDViZTYxOGM4MjAzODdjZjEzYWZiNw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-14T16:13:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-14T16:13:49Z"}, "message": "Merge #492 #493\n\n492: HIR should not contain any macros r=philberty a=philberty\n\nThis removes the macros tree's from HIR. HIR should be an expanded and\r\nsimplifed representation of the compilation unit.\r\n\r\nFixes #70\r\n\n\n493: Path resolution fixes r=philberty a=philberty\n\nIn order to support Modules, we need to do path resolution properly. The old code assumed a basic A::B but this is not generic enough in order to support modules.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "d112d5403dd6d549d7b4731413a6c46e56977e8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d112d5403dd6d549d7b4731413a6c46e56977e8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59f8d7a2343cd326e905be618c820387cf13afb7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgx4A9CRBK7hj4Ov3rIwAA/sAIAGMnZUt+WV8UZHrhcXVdOMQ2\nOPuCmgVq0MGn+p9VIS6mSmdVBsrbv7CVkU71eMWmAZVmhUAyrMAEllAPVu4F4a5W\nXAKvbXjS5BzrFMA/XoLLJke14D0IIPd8uZix6VTRet3J2M9TwEPNNZ4AZXS6M1YR\ns7ywgTKKTlOWz5wBNM4fUQJpUsdeOF/kPXs75RlZEahmNHHHip94b1/PztOHs8bu\nSY3dnmTrXPJHQ4geJA/aTakv55tWb4iyK/hHmZVhJvkmV2t4bIlbymYGDoVD2pbm\nLgxltSO2sx8tXbr1IOiq5O9jeAuN5XeWlYnArHniGZa26nkQSKlZPRK6iXYRWM8=\n=jkx5\n-----END PGP SIGNATURE-----\n", "payload": "tree d112d5403dd6d549d7b4731413a6c46e56977e8e\nparent df36e6b9abb197ceb0ff5d1020482c75c6f1424a\nparent d8d7deb33511c5776997447bb070279e770ab4be\nparent b3090f174b35f764f609695e6d33f8c6765e24ab\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623687229 +0000\ncommitter GitHub <noreply@github.com> 1623687229 +0000\n\nMerge #492 #493\n\n492: HIR should not contain any macros r=philberty a=philberty\n\nThis removes the macros tree's from HIR. HIR should be an expanded and\r\nsimplifed representation of the compilation unit.\r\n\r\nFixes #70\r\n\n\n493: Path resolution fixes r=philberty a=philberty\n\nIn order to support Modules, we need to do path resolution properly. The old code assumed a basic A::B but this is not generic enough in order to support modules.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f8d7a2343cd326e905be618c820387cf13afb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59f8d7a2343cd326e905be618c820387cf13afb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f8d7a2343cd326e905be618c820387cf13afb7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df36e6b9abb197ceb0ff5d1020482c75c6f1424a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df36e6b9abb197ceb0ff5d1020482c75c6f1424a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df36e6b9abb197ceb0ff5d1020482c75c6f1424a"}, {"sha": "d8d7deb33511c5776997447bb070279e770ab4be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d7deb33511c5776997447bb070279e770ab4be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8d7deb33511c5776997447bb070279e770ab4be"}, {"sha": "b3090f174b35f764f609695e6d33f8c6765e24ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3090f174b35f764f609695e6d33f8c6765e24ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3090f174b35f764f609695e6d33f8c6765e24ab"}], "stats": {"total": 1225, "additions": 187, "deletions": 1038}, "files": [{"sha": "e8a1682a51668bdaef3bb97f063587e6a6e57cd1", "filename": "gcc/rust/analysis/rust-hir-liveness-base.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fanalysis%2Frust-hir-liveness-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fanalysis%2Frust-hir-liveness-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-hir-liveness-base.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -32,7 +32,7 @@ class LivenessBase : public HIR::HIRVisitor\n {\n public:\n   virtual ~LivenessBase () {}\n-  virtual void visit (HIR::Token &) override {}\n+\n   virtual void visit (HIR::IdentifierExpr &) override {}\n   virtual void visit (HIR::Lifetime &) override {}\n   virtual void visit (HIR::LifetimeParam &) override {}\n@@ -151,12 +151,6 @@ class LivenessBase : public HIR::HIRVisitor\n   virtual void visit (HIR::ExternalFunctionItem &) override {}\n   virtual void visit (HIR::ExternBlock &) override {}\n \n-  virtual void visit (HIR::MacroMatchFragment &) override {}\n-  virtual void visit (HIR::MacroMatchRepetition &) override {}\n-  virtual void visit (HIR::MacroMatcher &) override {}\n-  virtual void visit (HIR::MacroRulesDefinition &) override {}\n-  virtual void visit (HIR::MacroInvocation &) override {}\n-\n   virtual void visit (HIR::LiteralPattern &) override {}\n   virtual void visit (HIR::IdentifierPattern &) override {}\n   virtual void visit (HIR::WildcardPattern &) override {}"}, {"sha": "b071a30bb1e03fd50c4e525cde98e9ff3b05da8e", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -32,19 +32,9 @@ class HIRCompileBase : public HIR::HIRVisitor\n   virtual ~HIRCompileBase () {}\n \n   // rust-ast.h\n-  virtual void visit (HIR::Token &tok) {}\n-  // virtual void visit(Stmt& stmt) {}\n-  // virtual void visit(Expr& expr) {}\n   virtual void visit (HIR::IdentifierExpr &ident_expr) {}\n-  // virtual void visit(Pattern& pattern) {}\n-  // virtual void visit(Type& type) {}\n-  // virtual void visit(TypeParamBound& type_param_bound) {}\n   virtual void visit (HIR::Lifetime &lifetime) {}\n-  // virtual void visit(GenericParam& generic_param) {}\n   virtual void visit (HIR::LifetimeParam &lifetime_param) {}\n-  // virtual void visit(TraitItem& trait_item) {}\n-  // virtual void visit(InherentImplItem& inherent_impl_item) {}\n-  // virtual void visit(TraitImplItem& trait_impl_item) {}\n \n   // rust-path.h\n   virtual void visit (HIR::PathInExpression &path) {}\n@@ -164,13 +154,6 @@ class HIRCompileBase : public HIR::HIRVisitor\n   virtual void visit (HIR::ExternalFunctionItem &item) {}\n   virtual void visit (HIR::ExternBlock &block) {}\n \n-  // rust-macro.h\n-  virtual void visit (HIR::MacroMatchFragment &match) {}\n-  virtual void visit (HIR::MacroMatchRepetition &match) {}\n-  virtual void visit (HIR::MacroMatcher &matcher) {}\n-  virtual void visit (HIR::MacroRulesDefinition &rules_def) {}\n-  virtual void visit (HIR::MacroInvocation &macro_invoc) {}\n-\n   // rust-pattern.h\n   virtual void visit (HIR::LiteralPattern &pattern) {}\n   virtual void visit (HIR::IdentifierPattern &pattern) {}"}, {"sha": "6fae193171c127593ff3798dccc0a651ea9ebd9c", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -18,15 +18,10 @@\n \n #ifndef RUST_HIR_FULL_DECLS_H\n #define RUST_HIR_FULL_DECLS_H\n-// Forward declarations for all HIR classes. Useful for not having to include\n-// all definitions.\n \n namespace Rust {\n namespace HIR {\n-// rust-ast.h\n-class TokenTree;\n-class MacroMatch;\n-class Token;\n+\n struct Literal;\n class Stmt;\n class Item;\n@@ -40,7 +35,7 @@ class TypeParamBound;\n class Lifetime;\n class GenericParam;\n class LifetimeParam;\n-class MacroItem;\n+\n class TraitItem;\n class InherentImplItem;\n class TraitImplItem;\n@@ -208,15 +203,6 @@ struct NamedFunctionParam;\n class ExternalFunctionItem;\n class ExternBlock;\n \n-// rust-macro.h\n-class MacroMatchFragment;\n-class MacroMatchRepetition;\n-class MacroMatcher;\n-struct MacroTranscriber;\n-struct MacroRule;\n-class MacroRulesDefinition;\n-class MacroInvocation;\n-\n // rust-pattern.h\n class LiteralPattern;\n class IdentifierPattern;"}, {"sha": "d080d8b2da8a6ddae9e73bac13df3195bfc9000d", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -69,45 +69,6 @@ get_string_in_delims (std::string str_input, AST::DelimType delim_type)\n   gcc_unreachable ();\n }\n \n-// Converts a frag spec enum item to a string form.\n-std::string\n-frag_spec_to_str (MacroFragSpec frag_spec)\n-{\n-  switch (frag_spec)\n-    {\n-    case BLOCK:\n-      return \"block\";\n-    case EXPR:\n-      return \"expr\";\n-    case IDENT:\n-      return \"ident\";\n-    case ITEM:\n-      return \"item\";\n-    case LIFETIME:\n-      return \"lifetime\";\n-    case LITERAL:\n-      return \"literal\";\n-    case META:\n-      return \"meta\";\n-    case PAT:\n-      return \"pat\";\n-    case PATH:\n-      return \"path\";\n-    case STMT:\n-      return \"stmt\";\n-    case TT:\n-      return \"tt\";\n-    case TY:\n-      return \"ty\";\n-    case VIS:\n-      return \"vis\";\n-    case INVALID:\n-      return \"INVALID_FRAG_SPEC\";\n-    default:\n-      return \"ERROR_MARK_STRING - unknown frag spec\";\n-    }\n-}\n-\n std::string\n Crate::as_string () const\n {\n@@ -163,18 +124,6 @@ Crate::as_string () const\n   return str + \"\\n::\" + get_mappings ().as_string () + \"\\n\";\n }\n \n-std::string\n-Token::as_string () const\n-{\n-  /* FIXME: only works when not identifier or literal or whatever, i.e. when\n-   * doesn't store string value */\n-  // return get_token_description(token_id);\n-\n-  // maybe fixed - stores everything as string though, so storage-inefficient\n-  std::string quote = is_string_lit () ? \"\\\"\" : \"\";\n-  return quote + str + quote;\n-}\n-\n std::string\n Visibility::as_string () const\n {\n@@ -1300,66 +1249,6 @@ ExternBlock::as_string () const\n   return str;\n }\n \n-std::string\n-MacroRule::as_string () const\n-{\n-  std::string str (\"Macro rule: \");\n-\n-  str += \"\\n Matcher: \\n  \";\n-  str += matcher.as_string ();\n-\n-  str += \"\\n Transcriber: \\n  \";\n-  str += transcriber.as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-MacroRulesDefinition::as_string () const\n-{\n-  std::string str (\"macro_rules!\");\n-\n-  str += rule_name;\n-\n-  str += \"\\n Macro rules: \";\n-  if (rules.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &rule : rules)\n-\t{\n-\t  str += \"\\n  \" + rule.as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n Delim type: \";\n-  switch (delim_type)\n-    {\n-    case AST::DelimType::PARENS:\n-      str += \"parentheses\";\n-      break;\n-    case AST::DelimType::SQUARE:\n-      str += \"square\";\n-      break;\n-    case AST::DelimType::CURLY:\n-      str += \"curly\";\n-      break;\n-    default:\n-      return \"ERROR_MARK_STRING - delim type in macro invocation\";\n-    }\n-\n-  return str;\n-}\n-\n-std::string\n-MacroInvocation::as_string () const\n-{\n-  return \"MacroInvocation: \" + path.as_string () + \"!\"\n-\t + token_tree.as_string ();\n-}\n-\n std::string\n PathInExpression::as_string () const\n {\n@@ -2332,45 +2221,6 @@ TraitBound::as_string () const\n   return str;\n }\n \n-std::string\n-MacroMatcher::as_string () const\n-{\n-  std::string str (\"Macro matcher: \");\n-\n-  str += \"\\n Delim type: \";\n-\n-  switch (delim_type)\n-    {\n-    case AST::DelimType::PARENS:\n-      str += \"parentheses\";\n-      break;\n-    case AST::DelimType::SQUARE:\n-      str += \"square\";\n-      break;\n-    case AST::DelimType::CURLY:\n-      str += \"curly\";\n-      break;\n-    default:\n-      return \"ERROR_MARK_STRING - macro matcher delim\";\n-    }\n-\n-  str += \"\\n Matches: \";\n-\n-  if (matches.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &match : matches)\n-\t{\n-\t  str += \"\\n  \" + match->as_string ();\n-\t}\n-    }\n-\n-  return str;\n-}\n-\n std::string\n LifetimeParam::as_string () const\n {\n@@ -2404,12 +2254,6 @@ LifetimeParam::as_string () const\n   return str;\n }\n \n-std::string\n-MacroMatchFragment::as_string () const\n-{\n-  return \"$\" + ident + \": \" + frag_spec_to_str (frag_spec);\n-}\n-\n std::string\n QualifiedPathInType::as_string () const\n {\n@@ -2423,56 +2267,6 @@ QualifiedPathInType::as_string () const\n   return str;\n }\n \n-std::string\n-MacroMatchRepetition::as_string () const\n-{\n-  std::string str (\"Macro match repetition: \");\n-\n-  str += \"\\n Matches: \";\n-  if (matches.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &match : matches)\n-\t{\n-\t  str += \"\\n  \" + match->as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n Sep: \";\n-  if (!has_sep ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      str += sep->as_string ();\n-    }\n-\n-  str += \"\\n Op: \";\n-  switch (op)\n-    {\n-    case ASTERISK:\n-      str += \"*\";\n-      break;\n-    case PLUS:\n-      str += \"+\";\n-      break;\n-    case QUESTION_MARK:\n-      str += \"?\";\n-      break;\n-    case NONE:\n-      str += \"no op? shouldn't be allowed\";\n-      break;\n-    default:\n-      return \"ERROR_MARK_STRING - unknown op in macro match repetition\";\n-    }\n-\n-  return str;\n-}\n-\n std::string\n Lifetime::as_string () const\n {\n@@ -4280,27 +4074,6 @@ ModuleBodied::add_crate_name (std::vector<std::string> &names) const\n     item->add_crate_name (names);\n }\n \n-std::vector<std::unique_ptr<Token> >\n-Token::to_token_stream () const\n-{\n-  /* initialisation list doesn't work as it needs copy constructor, so have to\n-   * do this */\n-  std::vector<std::unique_ptr<Token> > dummy_vector;\n-  dummy_vector.reserve (1);\n-  dummy_vector.push_back (std::unique_ptr<Token> (clone_token_impl ()));\n-  return dummy_vector;\n-}\n-\n-/* Visitor implementations - these are short but inlining can't happen anyway\n- * due to virtual functions and I didn't want to make the ast header includes\n- * any longer than they already are. */\n-\n-void\n-Token::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n IdentifierExpr::accept_vis (HIRVisitor &vis)\n {\n@@ -4943,36 +4716,6 @@ ExternBlock::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-MacroMatchFragment::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MacroMatchRepetition::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MacroMatcher::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MacroRulesDefinition::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MacroInvocation::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n LiteralPattern::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "3d4ed0ff7368af6aadcdced07b215acb44e1b874", "filename": "gcc/rust/hir/tree/rust-hir-full.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -19,14 +19,12 @@\n #ifndef RUST_HIR_FULL_H\n #define RUST_HIR_FULL_H\n \n-// Use as a fast way of including all aspects of the HIR (i.e. all headers)\n #include \"rust-hir.h\"\n #include \"rust-hir-expr.h\"\n #include \"rust-hir-item.h\"\n #include \"rust-hir-path.h\"\n #include \"rust-hir-pattern.h\"\n #include \"rust-hir-stmt.h\"\n #include \"rust-hir-type.h\"\n-#include \"rust-hir-macro.h\"\n \n #endif // RUST_HIR_FULL_H"}, {"sha": "775c92f3c754cf6609911b4c09b8d03697dd16c2", "filename": "gcc/rust/hir/tree/rust-hir-macro.h", "status": "removed", "additions": 0, "deletions": 400, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df36e6b9abb197ceb0ff5d1020482c75c6f1424a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df36e6b9abb197ceb0ff5d1020482c75c6f1424a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h?ref=df36e6b9abb197ceb0ff5d1020482c75c6f1424a", "patch": "@@ -1,400 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_HIR_MACRO_H\n-#define RUST_HIR_MACRO_H\n-\n-#include \"rust-ast-full-decls.h\"\n-#include \"rust-hir.h\"\n-\n-namespace Rust {\n-namespace HIR {\n-// Decls as definitions moved to rust-ast.h\n-class MacroItem;\n-\n-enum MacroFragSpec\n-{\n-  BLOCK,\n-  EXPR,\n-  IDENT,\n-  ITEM,\n-  LIFETIME,\n-  LITERAL,\n-  META,\n-  PAT,\n-  PATH,\n-  STMT,\n-  TT,\n-  TY,\n-  VIS,\n-  INVALID // not really a specifier, but used to mark invalid one passed in\n-};\n-\n-inline MacroFragSpec\n-get_frag_spec_from_str (std::string str)\n-{\n-  if (str == \"block\")\n-    return BLOCK;\n-  else if (str == \"expr\")\n-    return EXPR;\n-  else if (str == \"ident\")\n-    return IDENT;\n-  else if (str == \"item\")\n-    return ITEM;\n-  else if (str == \"lifetime\")\n-    return LIFETIME;\n-  else if (str == \"literal\")\n-    return LITERAL;\n-  else if (str == \"meta\")\n-    return META;\n-  else if (str == \"pat\")\n-    return PAT;\n-  else if (str == \"path\")\n-    return PATH;\n-  else if (str == \"stmt\")\n-    return STMT;\n-  else if (str == \"tt\")\n-    return TT;\n-  else if (str == \"ty\")\n-    return TY;\n-  else if (str == \"vis\")\n-    return VIS;\n-  else\n-    {\n-      // error_at(\"invalid string '%s' used as fragment specifier\",\n-      // str->c_str());\n-      return INVALID;\n-    }\n-}\n-\n-// A macro match that has an identifier and fragment spec\n-class MacroMatchFragment : public MacroMatch\n-{\n-  Identifier ident;\n-  MacroFragSpec frag_spec;\n-\n-  // TODO: should store location information?\n-\n-public:\n-  MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec)\n-    : ident (std::move (ident)), frag_spec (frag_spec)\n-  {}\n-\n-  // Returns whether macro match fragment is in an error state.\n-  bool is_error () const { return frag_spec == INVALID; }\n-\n-  // Creates an error state macro match fragment.\n-  static MacroMatchFragment create_error ()\n-  {\n-    return MacroMatchFragment (std::string (\"\"), INVALID);\n-  }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroMatchFragment *clone_macro_match_impl () const override\n-  {\n-    return new MacroMatchFragment (*this);\n-  }\n-};\n-\n-// A repetition macro match\n-class MacroMatchRepetition : public MacroMatch\n-{\n-public:\n-  enum MacroRepOp\n-  {\n-    NONE,\n-    ASTERISK,\n-    PLUS,\n-    QUESTION_MARK\n-  };\n-\n-private:\n-  std::vector<std::unique_ptr<MacroMatch> > matches;\n-  MacroRepOp op;\n-\n-  // bool has_sep;\n-  typedef Token MacroRepSep;\n-  // any token except delimiters and repetition operators\n-  std::unique_ptr<MacroRepSep> sep;\n-\n-  // TODO: should store location information?\n-\n-public:\n-  // Returns whether macro match repetition has separator token.\n-  bool has_sep () const { return sep != NULL; }\n-\n-  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n-\t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n-    : matches (std::move (matches)), op (op), sep (std::move (sep))\n-  {}\n-\n-  // Copy constructor with clone\n-  MacroMatchRepetition (MacroMatchRepetition const &other)\n-    : op (other.op), sep (other.sep->clone_token ())\n-  {\n-    matches.reserve (other.matches.size ());\n-    for (const auto &e : other.matches)\n-      matches.push_back (e->clone_macro_match ());\n-  }\n-\n-  // Overloaded assignment operator to clone\n-  MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n-  {\n-    op = other.op;\n-    sep = other.sep->clone_token ();\n-\n-    matches.reserve (other.matches.size ());\n-    for (const auto &e : other.matches)\n-      matches.push_back (e->clone_macro_match ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  MacroMatchRepetition (MacroMatchRepetition &&other) = default;\n-  MacroMatchRepetition &operator= (MacroMatchRepetition &&other) = default;\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroMatchRepetition *clone_macro_match_impl () const override\n-  {\n-    return new MacroMatchRepetition (*this);\n-  }\n-};\n-\n-// can't inline due to polymorphism\n-class MacroMatcher : public MacroMatch\n-{\n-  AST::DelimType delim_type;\n-  std::vector<std::unique_ptr<MacroMatch> > matches;\n-\n-  // TODO: think of way to mark invalid that doesn't take up more space\n-  bool is_invalid;\n-\n-  // TODO: should store location information?\n-\n-public:\n-  MacroMatcher (AST::DelimType delim_type,\n-\t\tstd::vector<std::unique_ptr<MacroMatch> > matches)\n-    : delim_type (delim_type), matches (std::move (matches)), is_invalid (false)\n-  {}\n-\n-  // copy constructor with vector clone\n-  MacroMatcher (MacroMatcher const &other) : delim_type (other.delim_type)\n-  {\n-    matches.reserve (other.matches.size ());\n-    for (const auto &e : other.matches)\n-      matches.push_back (e->clone_macro_match ());\n-  }\n-\n-  // overloaded assignment operator with vector clone\n-  MacroMatcher &operator= (MacroMatcher const &other)\n-  {\n-    delim_type = other.delim_type;\n-\n-    matches.reserve (other.matches.size ());\n-    for (const auto &e : other.matches)\n-      matches.push_back (e->clone_macro_match ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  MacroMatcher (MacroMatcher &&other) = default;\n-  MacroMatcher &operator= (MacroMatcher &&other) = default;\n-\n-  // Creates an error state macro matcher.\n-  static MacroMatcher create_error () { return MacroMatcher (true); }\n-\n-  // Returns whether MacroMatcher is in an error state.\n-  bool is_error () const { return is_invalid; }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroMatcher *clone_macro_match_impl () const override\n-  {\n-    return new MacroMatcher (*this);\n-  }\n-\n-  // constructor only used to create error matcher\n-  MacroMatcher (bool is_invalid)\n-    : delim_type (AST::DelimType::PARENS), is_invalid (is_invalid)\n-  {}\n-};\n-\n-// TODO: inline?\n-struct MacroTranscriber\n-{\n-private:\n-  AST::DelimTokenTree token_tree;\n-\n-  // TODO: should store location information?\n-\n-public:\n-  MacroTranscriber (AST::DelimTokenTree token_tree)\n-    : token_tree (std::move (token_tree))\n-  {}\n-\n-  std::string as_string () const { return token_tree.as_string (); }\n-};\n-\n-// A macro rule? Matcher and transcriber pair?\n-struct MacroRule\n-{\n-private:\n-  MacroMatcher matcher;\n-  MacroTranscriber transcriber;\n-\n-  // TODO: should store location information?\n-\n-public:\n-  MacroRule (MacroMatcher matcher, MacroTranscriber transcriber)\n-    : matcher (std::move (matcher)), transcriber (std::move (transcriber))\n-  {}\n-\n-  // Returns whether macro rule is in error state.\n-  bool is_error () const { return matcher.is_error (); }\n-\n-  // Creates an error state macro rule.\n-  static MacroRule create_error ()\n-  {\n-    return MacroRule (MacroMatcher::create_error (),\n-\t\t      MacroTranscriber (AST::DelimTokenTree::create_empty ()));\n-  }\n-\n-  std::string as_string () const;\n-};\n-\n-// A macro rules definition item HIR node\n-class MacroRulesDefinition : public MacroItem\n-{\n-  Identifier rule_name;\n-  // MacroRulesDef rules_def; // TODO: inline\n-  // only curly without required semicolon at end\n-  AST::DelimType delim_type;\n-  // MacroRules rules;\n-  std::vector<MacroRule> rules; // inlined form\n-\n-  Location locus;\n-\n-public:\n-  std::string as_string () const override;\n-\n-  MacroRulesDefinition (Analysis::NodeMapping mappings, Identifier rule_name,\n-\t\t\tAST::DelimType delim_type, std::vector<MacroRule> rules,\n-\t\t\tAST::AttrVec outer_attrs, Location locus)\n-    : MacroItem (std::move (mappings), std::move (outer_attrs)),\n-      rule_name (std::move (rule_name)), delim_type (delim_type),\n-      rules (std::move (rules)), locus (locus)\n-  {}\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroRulesDefinition *clone_item_impl () const override\n-  {\n-    return new MacroRulesDefinition (*this);\n-  }\n-};\n-\n-/* HIR node of a macro invocation, which is replaced by the macro result at\n- * compile time */\n-class MacroInvocation : public TypeNoBounds,\n-\t\t\tpublic Pattern,\n-\t\t\tpublic ExprWithoutBlock\n-{\n-  AST::SimplePath path;\n-  AST::DelimTokenTree token_tree;\n-  Location locus;\n-\n-public:\n-  std::string as_string () const override;\n-\n-  MacroInvocation (Analysis::NodeMapping mappings, AST::SimplePath path,\n-\t\t   AST::DelimTokenTree token_tree, AST::AttrVec outer_attrs,\n-\t\t   Location locus)\n-    : TypeNoBounds (mappings),\n-      ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n-      path (std::move (path)), token_tree (std::move (token_tree)),\n-      locus (locus)\n-  {}\n-\n-  Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_pattern_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_expr_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_expr_without_block_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_type_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_type_no_bounds_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-};\n-\n-} // namespace HIR\n-} // namespace Rust\n-\n-#endif"}, {"sha": "2efbbcff4a0a02f8fb747b99b43cba3b03173307", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -18,55 +18,26 @@\n \n #ifndef RUST_HIR_VISITOR_H\n #define RUST_HIR_VISITOR_H\n-// Visitor base for HIR\n \n-// full include not required - only forward decls\n #include \"rust-hir-full-decls.h\"\n \n namespace Rust {\n namespace HIR {\n-/* Pure abstract class that provides an interface for accessing different\n- * classes of the HIR. */\n+\n class HIRVisitor\n {\n public:\n-  // only concrete class overloads are required\n-\n-  // rust-ast.h\n-  // virtual void visit(AttrInput& attr_input) = 0;\n-  // virtual void visit(TokenTree& token_tree) = 0;\n-  // virtual void visit(MacroMatch& macro_match) = 0;\n-  virtual void visit (Token &tok) = 0;\n-  // virtual void visit (DelimTokenTree &delim_tok_tree) = 0;\n-  // virtual void visit (AttrInputMetaItemContainer &input) = 0;\n-  // virtual void visit(MetaItem& meta_item) = 0;\n-  // virtual void visit(Stmt& stmt) = 0;\n-  // virtual void visit(Expr& expr) = 0;\n   virtual void visit (IdentifierExpr &ident_expr) = 0;\n-  // virtual void visit(Pattern& pattern) = 0;\n-  // virtual void visit(Type& type) = 0;\n-  // virtual void visit(TypeParamBound& type_param_bound) = 0;\n   virtual void visit (Lifetime &lifetime) = 0;\n-  // virtual void visit(GenericParam& generic_param) = 0;\n   virtual void visit (LifetimeParam &lifetime_param) = 0;\n-  // virtual void visit(TraitItem& trait_item) = 0;\n-  // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n-  // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n-\n-  // rust-path.h\n   virtual void visit (PathInExpression &path) = 0;\n   virtual void visit (TypePathSegment &segment) = 0;\n   virtual void visit (TypePathSegmentGeneric &segment) = 0;\n   virtual void visit (TypePathSegmentFunction &segment) = 0;\n   virtual void visit (TypePath &path) = 0;\n   virtual void visit (QualifiedPathInExpression &path) = 0;\n   virtual void visit (QualifiedPathInType &path) = 0;\n-\n-  // rust-expr.h\n   virtual void visit (LiteralExpr &expr) = 0;\n-  // virtual void visit (AttrInputLiteral &attr_input) = 0;\n-  // virtual void visit (MetaItemLitExpr &meta_item) = 0;\n-  // virtual void visit (MetaItemPathLit &meta_item) = 0;\n   virtual void visit (BorrowExpr &expr) = 0;\n   virtual void visit (DereferenceExpr &expr) = 0;\n   virtual void visit (ErrorPropagationExpr &expr) = 0;\n@@ -77,23 +48,20 @@ class HIRVisitor\n   virtual void visit (TypeCastExpr &expr) = 0;\n   virtual void visit (AssignmentExpr &expr) = 0;\n   virtual void visit (GroupedExpr &expr) = 0;\n-  // virtual void visit(ArrayElems& elems) = 0;\n   virtual void visit (ArrayElemsValues &elems) = 0;\n   virtual void visit (ArrayElemsCopied &elems) = 0;\n   virtual void visit (ArrayExpr &expr) = 0;\n   virtual void visit (ArrayIndexExpr &expr) = 0;\n   virtual void visit (TupleExpr &expr) = 0;\n   virtual void visit (TupleIndexExpr &expr) = 0;\n   virtual void visit (StructExprStruct &expr) = 0;\n-  // virtual void visit(StructExprField& field) = 0;\n   virtual void visit (StructExprFieldIdentifier &field) = 0;\n   virtual void visit (StructExprFieldIdentifierValue &field) = 0;\n   virtual void visit (StructExprFieldIndexValue &field) = 0;\n   virtual void visit (StructExprStructFields &expr) = 0;\n   virtual void visit (StructExprStructBase &expr) = 0;\n   virtual void visit (StructExprTuple &expr) = 0;\n   virtual void visit (StructExprUnit &expr) = 0;\n-  // virtual void visit(EnumExprField& field) = 0;\n   virtual void visit (EnumExprFieldIdentifier &field) = 0;\n   virtual void visit (EnumExprFieldIdentifierValue &field) = 0;\n   virtual void visit (EnumExprFieldIndexValue &field) = 0;\n@@ -128,23 +96,16 @@ class HIRVisitor\n   virtual void visit (IfLetExprConseqElse &expr) = 0;\n   virtual void visit (IfLetExprConseqIf &expr) = 0;\n   virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n-  // virtual void visit(MatchCase& match_case) = 0;\n-  // virtual void visit (MatchCaseBlockExpr &match_case) = 0;\n-  // virtual void visit (MatchCaseExpr &match_case) = 0;\n   virtual void visit (MatchExpr &expr) = 0;\n   virtual void visit (AwaitExpr &expr) = 0;\n   virtual void visit (AsyncBlockExpr &expr) = 0;\n-\n-  // rust-item.h\n   virtual void visit (TypeParam &param) = 0;\n-  // virtual void visit(WhereClauseItem& item) = 0;\n   virtual void visit (LifetimeWhereClauseItem &item) = 0;\n   virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n   virtual void visit (Method &method) = 0;\n   virtual void visit (ModuleBodied &module) = 0;\n   virtual void visit (ModuleNoBody &module) = 0;\n   virtual void visit (ExternCrate &crate) = 0;\n-  // virtual void visit(UseTree& use_tree) = 0;\n   virtual void visit (UseTreeGlob &use_tree) = 0;\n   virtual void visit (UseTreeList &use_tree) = 0;\n   virtual void visit (UseTreeRebind &use_tree) = 0;\n@@ -168,57 +129,33 @@ class HIRVisitor\n   virtual void visit (Trait &trait) = 0;\n   virtual void visit (InherentImpl &impl) = 0;\n   virtual void visit (TraitImpl &impl) = 0;\n-  // virtual void visit(ExternalItem& item) = 0;\n   virtual void visit (ExternalStaticItem &item) = 0;\n   virtual void visit (ExternalFunctionItem &item) = 0;\n   virtual void visit (ExternBlock &block) = 0;\n-\n-  // rust-macro.h\n-  virtual void visit (MacroMatchFragment &match) = 0;\n-  virtual void visit (MacroMatchRepetition &match) = 0;\n-  virtual void visit (MacroMatcher &matcher) = 0;\n-  virtual void visit (MacroRulesDefinition &rules_def) = 0;\n-  virtual void visit (MacroInvocation &macro_invoc) = 0;\n-  // virtual void visit (MetaItemPath &meta_item) = 0;\n-  // virtual void visit (MetaItemSeq &meta_item) = 0;\n-  // virtual void visit (MetaWord &meta_item) = 0;\n-  // virtual void visit (MetaNameValueStr &meta_item) = 0;\n-  // virtual void visit (MetaListPaths &meta_item) = 0;\n-  // virtual void visit (MetaListNameValueStr &meta_item) = 0;\n-\n-  // rust-pattern.h\n   virtual void visit (LiteralPattern &pattern) = 0;\n   virtual void visit (IdentifierPattern &pattern) = 0;\n   virtual void visit (WildcardPattern &pattern) = 0;\n-  // virtual void visit(RangePatternBound& bound) = 0;\n   virtual void visit (RangePatternBoundLiteral &bound) = 0;\n   virtual void visit (RangePatternBoundPath &bound) = 0;\n   virtual void visit (RangePatternBoundQualPath &bound) = 0;\n   virtual void visit (RangePattern &pattern) = 0;\n   virtual void visit (ReferencePattern &pattern) = 0;\n-  // virtual void visit(StructPatternField& field) = 0;\n   virtual void visit (StructPatternFieldTuplePat &field) = 0;\n   virtual void visit (StructPatternFieldIdentPat &field) = 0;\n   virtual void visit (StructPatternFieldIdent &field) = 0;\n   virtual void visit (StructPattern &pattern) = 0;\n-  // virtual void visit(TupleStructItems& tuple_items) = 0;\n   virtual void visit (TupleStructItemsNoRange &tuple_items) = 0;\n   virtual void visit (TupleStructItemsRange &tuple_items) = 0;\n   virtual void visit (TupleStructPattern &pattern) = 0;\n-  // virtual void visit(TuplePatternItems& tuple_items) = 0;\n   virtual void visit (TuplePatternItemsMultiple &tuple_items) = 0;\n   virtual void visit (TuplePatternItemsRanged &tuple_items) = 0;\n   virtual void visit (TuplePattern &pattern) = 0;\n   virtual void visit (GroupedPattern &pattern) = 0;\n   virtual void visit (SlicePattern &pattern) = 0;\n-\n-  // rust-stmt.h\n   virtual void visit (EmptyStmt &stmt) = 0;\n   virtual void visit (LetStmt &stmt) = 0;\n   virtual void visit (ExprStmtWithoutBlock &stmt) = 0;\n   virtual void visit (ExprStmtWithBlock &stmt) = 0;\n-\n-  // rust-type.h\n   virtual void visit (TraitBound &bound) = 0;\n   virtual void visit (ImplTraitType &type) = 0;\n   virtual void visit (TraitObjectType &type) = 0;\n@@ -233,9 +170,8 @@ class HIRVisitor\n   virtual void visit (SliceType &type) = 0;\n   virtual void visit (InferredType &type) = 0;\n   virtual void visit (BareFunctionType &type) = 0;\n-\n-  // TODO: rust-cond-compilation.h visiting? not currently used\n };\n+\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "795e8e4d8378b53258eb74cefa19ac0d610eb387", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -37,155 +37,6 @@ class HIRVisitor;\n // forward decl for use in token tree method\n class Token;\n \n-// A tree of tokens (or a single token) - abstract base class\n-class TokenTree\n-{\n-public:\n-  virtual ~TokenTree () {}\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<TokenTree> clone_token_tree () const\n-  {\n-    return std::unique_ptr<TokenTree> (clone_token_tree_impl ());\n-  }\n-\n-  virtual std::string as_string () const = 0;\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n-\n-  /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n-   * mutual dependency with Token. */\n-  virtual std::vector<std::unique_ptr<Token> > to_token_stream () const = 0;\n-\n-protected:\n-  // pure virtual clone implementation\n-  virtual TokenTree *clone_token_tree_impl () const = 0;\n-};\n-\n-// Abstract base class for a macro match\n-class MacroMatch\n-{\n-public:\n-  virtual ~MacroMatch () {}\n-\n-  virtual std::string as_string () const = 0;\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<MacroMatch> clone_macro_match () const\n-  {\n-    return std::unique_ptr<MacroMatch> (clone_macro_match_impl ());\n-  }\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n-\n-protected:\n-  // pure virtual clone implementation\n-  virtual MacroMatch *clone_macro_match_impl () const = 0;\n-};\n-\n-// A token is a kind of token tree (except delimiter tokens)\n-class Token : public TokenTree, public MacroMatch\n-{\n-  // A token is a kind of token tree (except delimiter tokens)\n-  // A token is a kind of MacroMatch (except $ and delimiter tokens)\n-  // TODO: improve member variables - current ones are the same as lexer token\n-  // Token kind.\n-  TokenId token_id;\n-  // Token location.\n-  Location locus;\n-  // Associated text (if any) of token.\n-  std::string str;\n-  // Token type hint (if any).\n-  PrimitiveCoreType type_hint;\n-\n-public:\n-  // Unique pointer custom clone function\n-  std::unique_ptr<Token> clone_token () const\n-  {\n-    return std::unique_ptr<Token> (clone_token_impl ());\n-  }\n-\n-  /* constructor from general text - avoid using if lexer const_TokenPtr is\n-   * available */\n-  Token (TokenId token_id, Location locus, std::string str,\n-\t PrimitiveCoreType type_hint)\n-    : token_id (token_id), locus (locus), str (std::move (str)),\n-      type_hint (type_hint)\n-  {}\n-\n-  // Constructor from lexer const_TokenPtr\n-  /* TODO: find workaround for std::string being nullptr - probably have to\n-   * introduce new method in lexer Token, or maybe make conversion method\n-   * there */\n-  Token (const_TokenPtr lexer_token_ptr)\n-    : token_id (lexer_token_ptr->get_id ()),\n-      locus (lexer_token_ptr->get_locus ()), str (\"\"),\n-      type_hint (lexer_token_ptr->get_type_hint ())\n-  {\n-    // FIXME: change to \"should have str\" later?\n-    if (lexer_token_ptr->has_str ())\n-      {\n-\tstr = lexer_token_ptr->get_str ();\n-\n-\t// DEBUG\n-\trust_debug (\"ast token created with str '%s'\", str.c_str ());\n-      }\n-    else\n-      {\n-\t// FIXME: is this returning correct thing?\n-\tstr = lexer_token_ptr->get_token_description ();\n-\n-\t// DEBUG\n-\trust_debug (\"ast token created with string '%s'\", str.c_str ());\n-      }\n-\n-    // DEBUG\n-    if (lexer_token_ptr->should_have_str () && !lexer_token_ptr->has_str ())\n-      {\n-\trust_debug (\"BAD: for token '%s', should have string but does not!\",\n-\t\t    lexer_token_ptr->get_token_description ());\n-      }\n-  }\n-\n-  bool is_string_lit () const\n-  {\n-    switch (token_id)\n-      {\n-      case STRING_LITERAL:\n-      case BYTE_STRING_LITERAL:\n-\treturn true;\n-      default:\n-\treturn false;\n-      }\n-  }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  // Return copy of itself but in token stream form.\n-  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n-\n-  TokenId get_id () const { return token_id; }\n-\n-  Location get_locus () const { return locus; }\n-\n-protected:\n-  // No virtual for now as not polymorphic but can be in future\n-  /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  Token *clone_token_tree_impl () const override { return clone_token_impl (); }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  Token *clone_macro_match_impl () const override\n-  {\n-    return clone_token_impl ();\n-  }\n-};\n-\n // A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n struct Literal\n {"}, {"sha": "74ad4b8eae08657423820eac59b31ccd58cc8dde", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -537,61 +537,65 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       AST::PathExprSegment &seg = expr->get_segments ().at (i);\n       auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n       path = path.append (s);\n-    }\n \n-  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n-    {\n-      resolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  // check the type scope\n-  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n-    {\n-      resolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  else\n-    {\n-      // attempt to fully resolve the path which is allowed to fail given the\n-      // following scenario\n-      //\n-      // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n-      // resolved fully here, there are limitations though imagine:\n-      //\n-      // struct Foo<A> (A);\n-      //\n-      // impl Foo<isize> {\n-      //    fn test() -> ...\n-      //\n-      // impl Foo<f32> {\n-      //    fn test() -> ...\n-      //\n-      // fn main() {\n-      //    let a:i32 = Foo::test();\n-      //\n-      // there are multiple paths that test can resolve to Foo::<?>::test here\n-      // so we cannot resolve this case\n-      //\n-      // canonical names:\n-      //\n-      // struct Foo<A>            -> Foo\n-      // impl Foo<isize>::fn test -> Foo::isize::test\n-      // impl Foo<f32>::fn test   -> Foo::f32::test\n-      //\n-      // Since there is the case we have the following paths for test:\n-      //\n-      // Foo::isize::test\n-      // Foo::f32::test\n-      // vs\n-      // Foo::test\n-      //\n-      // but the lookup was simply Foo::test we must rely on type resolution to\n-      // figure this type out in a similar fashion to method resolution with a\n-      // probe phase\n+      if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t{\n+\t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n+\t  resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t\t   Definition{expr->get_node_id (),\n+\t\t\t\t\t\t      parent});\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t{\n+\t  resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n+\t  resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t\t   Definition{expr->get_node_id (),\n+\t\t\t\t\t\t      parent});\n+\t}\n+      else\n+\t{\n+\t  // attempt to fully resolve the path which is allowed to fail given\n+\t  // the following scenario\n+\t  //\n+\t  // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n+\t  // resolved fully here, there are limitations though imagine:\n+\t  //\n+\t  // struct Foo<A> (A);\n+\t  //\n+\t  // impl Foo<isize> {\n+\t  //    fn test() -> ...\n+\t  //\n+\t  // impl Foo<f32> {\n+\t  //    fn test() -> ...\n+\t  //\n+\t  // fn main() {\n+\t  //    let a:i32 = Foo::test();\n+\t  //\n+\t  // there are multiple paths that test can resolve to Foo::<?>::test\n+\t  // here so we cannot resolve this case\n+\t  //\n+\t  // canonical names:\n+\t  //\n+\t  // struct Foo<A>            -> Foo\n+\t  // impl Foo<isize>::fn test -> Foo::isize::test\n+\t  // impl Foo<f32>::fn test   -> Foo::f32::test\n+\t  //\n+\t  // Since there is the case we have the following paths for test:\n+\t  //\n+\t  // Foo::isize::test\n+\t  // Foo::f32::test\n+\t  // vs\n+\t  // Foo::test\n+\t  //\n+\t  // but the lookup was simply Foo::test we must rely on type resolution\n+\t  // to figure this type out in a similar fashion to method resolution\n+\t  // with a probe phase\n+\n+\t  // nothing more we can do we need the type resolver to try and resolve\n+\t  // this\n+\t  return;\n+\t}\n     }\n }\n "}, {"sha": "fce24d9e85bda05208101cdcd7e68a1305f8856d", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -35,7 +35,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n public:\n   virtual ~ConstFoldBase () {}\n \n-  virtual void visit (HIR::Token &) override {}\n   virtual void visit (HIR::IdentifierExpr &) override {}\n   virtual void visit (HIR::Lifetime &) override {}\n   virtual void visit (HIR::LifetimeParam &) override {}\n@@ -154,12 +153,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual void visit (HIR::ExternalFunctionItem &) override {}\n   virtual void visit (HIR::ExternBlock &) override {}\n \n-  virtual void visit (HIR::MacroMatchFragment &) override {}\n-  virtual void visit (HIR::MacroMatchRepetition &) override {}\n-  virtual void visit (HIR::MacroMatcher &) override {}\n-  virtual void visit (HIR::MacroRulesDefinition &) override {}\n-  virtual void visit (HIR::MacroInvocation &) override {}\n-\n   virtual void visit (HIR::LiteralPattern &) override {}\n   virtual void visit (HIR::IdentifierPattern &) override {}\n   virtual void visit (HIR::WildcardPattern &) override {}"}, {"sha": "3b2853c347e82e3db7ec509df30ac16b377090ab", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -34,7 +34,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n public:\n   virtual ~TypeCheckBase () {}\n \n-  virtual void visit (HIR::Token &) override {}\n   virtual void visit (HIR::IdentifierExpr &) override {}\n   virtual void visit (HIR::Lifetime &) override {}\n   virtual void visit (HIR::LifetimeParam &) override {}\n@@ -153,12 +152,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual void visit (HIR::ExternalFunctionItem &) override {}\n   virtual void visit (HIR::ExternBlock &) override {}\n \n-  virtual void visit (HIR::MacroMatchFragment &) override {}\n-  virtual void visit (HIR::MacroMatchRepetition &) override {}\n-  virtual void visit (HIR::MacroMatcher &) override {}\n-  virtual void visit (HIR::MacroRulesDefinition &) override {}\n-  virtual void visit (HIR::MacroInvocation &) override {}\n-\n   virtual void visit (HIR::LiteralPattern &) override {}\n   virtual void visit (HIR::IdentifierPattern &) override {}\n   virtual void visit (HIR::WildcardPattern &) override {}"}, {"sha": "578753194a87b0dea8add2bea6fd60796bb5fcc8", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 124, "deletions": 56, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f8d7a2343cd326e905be618c820387cf13afb7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=59f8d7a2343cd326e905be618c820387cf13afb7", "patch": "@@ -864,11 +864,15 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::PathInExpression &expr) override\n   {\n-    // resolve root_segment\n-    TyTy::BaseType *tyseg = resolve_root_path (expr);\n+    NodeId resolved_node_id = UNKNOWN_NODEID;\n+\n+    size_t offset = -1;\n+    TyTy::BaseType *tyseg\n+      = resolve_root_path (expr, &offset, &resolved_node_id);\n     if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n-    else if (expr.get_num_segments () == 1)\n+\n+    if (expr.get_num_segments () == 1)\n       {\n \tLocation locus = expr.get_segments ().back ().get_locus ();\n \n@@ -886,8 +890,7 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::BaseType *prev_segment = tyseg;\n-    NodeId resolved_node_id = UNKNOWN_NODEID;\n-    for (size_t i = 1; i < expr.get_num_segments (); i++)\n+    for (size_t i = offset; i < expr.get_num_segments (); i++)\n       {\n \tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n \n@@ -1088,69 +1091,134 @@ class TypeCheckExpr : public TypeCheckBase\n       folded_array_capacity (nullptr), inside_loop (inside_loop)\n   {}\n \n-  TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr)\n+  TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n+\t\t\t\t     size_t *offset,\n+\t\t\t\t     NodeId *root_resolved_node_id)\n   {\n-    HIR::PathExprSegment &root = expr.get_root_seg ();\n-    NodeId ast_node_id = root.get_mappings ().get_nodeid ();\n-\n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    TyTy::BaseType *root_tyty = nullptr;\n+    *offset = 0;\n+    for (size_t i = 0; i < expr.get_num_segments (); i++)\n       {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\tbool have_more_segments = i < expr.get_num_segments ();\n+\tbool is_root = *offset == 0;\n+\tNodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n+\n+\t// then lookup the reference_node_id\n+\tNodeId ref_node_id = UNKNOWN_NODEID;\n+\tif (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n \t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    // these ref_node_ids will resolve to a pattern declaration but we\n+\t    // are interested in the definition that this refers to get the\n+\t    // parent id\n+\t    Definition def;\n+\t    if (!resolver->lookup_definition (ref_node_id, &def))\n+\t      {\n+\t\trust_error_at (expr.get_locus (),\n+\t\t\t       \"unknown reference for resolved name\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    ref_node_id = def.parent;\n+\t  }\n+\telse\n+\t  {\n+\t    resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n \t  }\n-\tref_node_id = def.parent;\n-      }\n-    else\n-      {\n-\tresolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n-      }\n \n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (root.get_locus (),\n-\t\t       \"failed to type resolve root segment\");\n-\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-      }\n+\tif (ref_node_id == UNKNOWN_NODEID)\n+\t  {\n+\t    if (is_root)\n+\t      {\n+\t\trust_error_at (seg.get_locus (),\n+\t\t\t       \"failed to type resolve root segment\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    return root_tyty;\n+\t  }\n \n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-      }\n+\t// node back to HIR\n+\tHirId ref;\n+\tif (!mappings->lookup_node_to_hir (\n+\t      expr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+\t  {\n+\t    if (is_root)\n+\t      {\n+\t\trust_error_at (seg.get_locus (), \"reverse lookup failure\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    return root_tyty;\n+\t  }\n \n-    TyTy::BaseType *lookup = nullptr;\n-    if (!context->lookup_type (ref, &lookup))\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to resolve root segment\");\n-\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-      }\n+\t// FIXME\n+\t// modules are not going to have an explicit TyTy.In this case we\n+\t// can probably do some kind of check. By looking up if the HirId ref\n+\t// node is a module and continue. If the path expression is single\n+\t// segment of module we can error with expected value but found module\n+\t// or something.\n+\t//\n+\t// Something like this\n+\t//\n+\t// bool seg_is_module = mappings->lookup_module (ref);\n+\t// if (seg_is_module)\n+\t//   {\n+\t//     if (have_more_segments)\n+\t//       continue;\n+\t//\n+\t//     rust_error_at (seg.get_locus (), \"expected value\");\n+\t//     return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t//   }\n+\n+\tTyTy::BaseType *lookup = nullptr;\n+\tif (!context->lookup_type (ref, &lookup))\n+\t  {\n+\t    if (is_root)\n+\t      {\n+\t\trust_error_at (seg.get_locus (),\n+\t\t\t       \"failed to resolve root segment\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    return root_tyty;\n+\t  }\n \n-    // turbo-fish segment path::<ty>\n-    if (root.has_generic_args ())\n-      {\n-\tif (!lookup->can_substitute ())\n+\t// if we have a previous segment type\n+\tif (root_tyty != nullptr)\n \t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"substitutions not supported for %s\",\n-\t\t\t   lookup->as_string ().c_str ());\n-\t    return new TyTy::ErrorType (lookup->get_ref ());\n+\t    // if this next segment needs substitution we must apply the\n+\t    // previous type arguments\n+\t    //\n+\t    // such as: GenericStruct::<_>::new(123, 456)\n+\t    if (lookup->needs_generic_substitutions ())\n+\t      {\n+\t\tif (!root_tyty->needs_generic_substitutions ())\n+\t\t  {\n+\t\t    auto used_args_in_prev_segment\n+\t\t      = GetUsedSubstArgs::From (root_tyty);\n+\t\t    lookup = SubstMapperInternal::Resolve (\n+\t\t      lookup, used_args_in_prev_segment);\n+\t\t  }\n+\t      }\n \t  }\n-\tlookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n-\t\t\t\t       &root.get_generic_args ());\n+\n+\t// turbo-fish segment path::<ty>\n+\tif (seg.has_generic_args ())\n+\t  {\n+\t    if (!lookup->can_substitute ())\n+\t      {\n+\t\trust_error_at (seg.get_locus (),\n+\t\t\t       \"substitutions not supported for %s\",\n+\t\t\t       lookup->as_string ().c_str ());\n+\t\treturn new TyTy::ErrorType (lookup->get_ref ());\n+\t      }\n+\t    lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t\t\t\t\t   &seg.get_generic_args ());\n+\t  }\n+\n+\t*root_resolved_node_id = ref_node_id;\n+\t*offset = *offset + 1;\n+\troot_tyty = lookup;\n       }\n \n-    return lookup;\n+    return root_tyty;\n   }\n \n   bool"}]}