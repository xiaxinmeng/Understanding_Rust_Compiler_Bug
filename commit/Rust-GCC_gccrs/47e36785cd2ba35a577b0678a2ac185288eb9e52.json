{"sha": "47e36785cd2ba35a577b0678a2ac185288eb9e52", "node_id": "C_kwDOANBUbNoAKDQ3ZTM2Nzg1Y2QyYmEzNWE1NzdiMDY3OGEyYWMxODUyODhlYjllNTI", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-27T14:51:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-30T11:52:40Z"}, "message": "c++: Note macro locations\n\nIn order to prune ordinary locations, we need to note the locations of\nmacros we'll be writing out.  This rearanges the macro processing to achieve\nthat.  Also drop an unneeded parameter from macro reading & writing.\n\nFix some it's/its errors.\n\n\tgcc/cp/\n\t* module.cc (module_state::write_define): Drop located param.\n\t(module_state::read_define): Likewise.\n\t(module_state::prepare_macros): New, broken out of ...\n\t(module_state::write_macros): ... here.  Adjust.\n\t(module_state::write_begin): Adjust.\n\tgcc/testsuite/\n\t* g++.dg/modules/inext-1.H: Check include-next happened.", "tree": {"sha": "4949582e913de3f384752784f4c855426709338f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4949582e913de3f384752784f4c855426709338f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47e36785cd2ba35a577b0678a2ac185288eb9e52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e36785cd2ba35a577b0678a2ac185288eb9e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e36785cd2ba35a577b0678a2ac185288eb9e52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e36785cd2ba35a577b0678a2ac185288eb9e52/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00193676a5a3e7e50e1fa6646bb5abb5a7b2acbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00193676a5a3e7e50e1fa6646bb5abb5a7b2acbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00193676a5a3e7e50e1fa6646bb5abb5a7b2acbb"}], "stats": {"total": 99, "additions": 67, "deletions": 32}, "files": [{"sha": "238a5eb74d2a57981a84947c355e74c6d8fdf0f4", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e36785cd2ba35a577b0678a2ac185288eb9e52/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e36785cd2ba35a577b0678a2ac185288eb9e52/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=47e36785cd2ba35a577b0678a2ac185288eb9e52", "patch": "@@ -2281,7 +2281,7 @@ class depset {\n     EK_EXPLICIT_HWM,  \n     EK_BINDING = EK_EXPLICIT_HWM, /* Implicitly encoded.  */\n     EK_FOR_BINDING,\t/* A decl being inserted for a binding.  */\n-    EK_INNER_DECL,\t/* A decl defined outside of it's imported\n+    EK_INNER_DECL,\t/* A decl defined outside of its imported\n \t\t\t   context.  */\n     EK_DIRECT_HWM = EK_PARTIAL + 1,\n \n@@ -3663,9 +3663,10 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n   bool read_macro_maps (unsigned);\n \n  private:\n-  void write_define (bytes_out &, const cpp_macro *, bool located = true);\n-  cpp_macro *read_define (bytes_in &, cpp_reader *, bool located = true) const;\n-  unsigned write_macros (elf_out *to, cpp_reader *, unsigned *crc_ptr);\n+  void write_define (bytes_out &, const cpp_macro *);\n+  cpp_macro *read_define (bytes_in &, cpp_reader *) const;\n+  vec<cpp_hashnode *> *prepare_macros (cpp_reader *);\n+  unsigned write_macros (elf_out *to, vec<cpp_hashnode *> *, unsigned *crc_ptr);\n   bool read_macros ();\n   void install_macros ();\n \n@@ -7136,7 +7137,7 @@ trees_in::tree_node_vals (tree t)\n }\n \n \n-/* If T is a back reference, fixed reference or NULL, write out it's\n+/* If T is a back reference, fixed reference or NULL, write out its\n    code and return WK_none.  Otherwise return WK_value if we must write\n    by value, or WK_normal otherwise.  */\n \n@@ -10605,7 +10606,7 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \n /* DECL is a new declaration that may be duplicated in OVL.  Use RET &\n    ARGS to find its clone, or NULL.  If DECL's DECL_NAME is NULL, this\n-   has been found by a proxy.  It will be an enum type located by it's\n+   has been found by a proxy.  It will be an enum type located by its\n    first member.\n \n    We're conservative with matches, so ambiguous decls will be\n@@ -11615,7 +11616,7 @@ trees_in::read_var_def (tree decl, tree maybe_template)\n }\n \n /* If MEMBER doesn't have an independent life outside the class,\n-   return it (or it's TEMPLATE_DECL).  Otherwise NULL.  */\n+   return it (or its TEMPLATE_DECL).  Otherwise NULL.  */\n \n static tree\n member_owned_by_class (tree member)\n@@ -15405,7 +15406,7 @@ module_state::read_entities (unsigned count, unsigned lwm, unsigned hwm)\n    sure the specified entities are loaded.\n \n    An optimization might be to have a flag in each key-entity saying\n-   that it's top key might be in the entity table.  It's not clear to\n+   that its top key might be in the entity table.  It's not clear to\n    me how to set that flag cheaply -- cheaper than just looking.\n \n    FIXME: It'd be nice to have a bit in decls to tell us whether to\n@@ -16444,7 +16445,7 @@ module_state::read_macro_maps (unsigned num_macro_locs)\n /* Serialize the definition of MACRO.  */\n \n void\n-module_state::write_define (bytes_out &sec, const cpp_macro *macro, bool located)\n+module_state::write_define (bytes_out &sec, const cpp_macro *macro)\n {\n   sec.u (macro->count);\n \n@@ -16453,8 +16454,7 @@ module_state::write_define (bytes_out &sec, const cpp_macro *macro, bool located\n   sec.b (macro->syshdr);\n   sec.bflush ();\n \n-  if (located)\n-    write_location (sec, macro->line);\n+  write_location (sec, macro->line);\n   if (macro->fun_like)\n     {\n       sec.u (macro->paramc);\n@@ -16467,8 +16467,7 @@ module_state::write_define (bytes_out &sec, const cpp_macro *macro, bool located\n   for (unsigned ix = 0; ix != macro->count; ix++)\n     {\n       const cpp_token *token = &macro->exp.tokens[ix];\n-      if (located)\n-\twrite_location (sec, token->src_loc);\n+      write_location (sec, token->src_loc);\n       sec.u (token->type);\n       sec.u (token->flags);\n       switch (cpp_token_val_index (token))\n@@ -16533,11 +16532,11 @@ module_state::write_define (bytes_out &sec, const cpp_macro *macro, bool located\n /* Read a macro definition.  */\n \n cpp_macro *\n-module_state::read_define (bytes_in &sec, cpp_reader *reader, bool located) const\n+module_state::read_define (bytes_in &sec, cpp_reader *reader) const\n {\n   unsigned count = sec.u ();\n   /* We rely on knowing cpp_reader's hash table is ident_hash, and\n-     it's subobject allocator is stringpool_ggc_alloc and that is just\n+     its subobject allocator is stringpool_ggc_alloc and that is just\n      a wrapper for ggc_alloc_atomic.  */\n   cpp_macro *macro\n     = (cpp_macro *)ggc_alloc_atomic (sizeof (cpp_macro)\n@@ -16553,7 +16552,7 @@ module_state::read_define (bytes_in &sec, cpp_reader *reader, bool located) cons\n   macro->syshdr = sec.b ();\n   sec.bflush ();\n \n-  macro->line = located ? read_location (sec) : loc;\n+  macro->line = read_location (sec);\n \n   if (macro->fun_like)\n     {\n@@ -16570,7 +16569,7 @@ module_state::read_define (bytes_in &sec, cpp_reader *reader, bool located) cons\n   for (unsigned ix = 0; ix != count && !sec.get_overrun (); ix++)\n     {\n       cpp_token *token = &macro->exp.tokens[ix];\n-      token->src_loc = located ? read_location (sec) : loc;\n+      token->src_loc = read_location (sec);\n       token->type = cpp_ttype (sec.u ());\n       token->flags = sec.u ();\n       switch (cpp_token_val_index (token))\n@@ -16899,31 +16898,62 @@ macro_loc_cmp (const void *a_, const void *b_)\n     return 0;\n }\n \n+/* Gather the macro definitions and undefinitions that we will need to\n+   write out.   */\n+\n+vec<cpp_hashnode *> *\n+module_state::prepare_macros (cpp_reader *reader)\n+{\n+  vec<cpp_hashnode *> *macros;\n+  vec_alloc (macros, 100);\n+\n+  cpp_forall_identifiers (reader, maybe_add_macro, macros);\n+\n+  dump (dumper::MACRO) && dump (\"No more than %u macros\", macros->length ());\n+\n+  macros->qsort (macro_loc_cmp);\n+\n+  // Note the locations.\n+  for (unsigned ix = macros->length (); ix--;)\n+    {\n+      cpp_hashnode *node = (*macros)[ix];\n+      macro_import::slot &slot = (*macro_imports)[node->deferred - 1][0];\n+      macro_export &mac = (*macro_exports)[slot.offset];\n+\n+      if (IDENTIFIER_KEYWORD_P (identifier (node)))\n+\tcontinue;\n+\n+      if (mac.undef_loc != UNKNOWN_LOCATION)\n+\tnote_location (mac.undef_loc);\n+      if (mac.def)\n+\t{\n+\t  note_location (mac.def->line);\n+\t  for (unsigned ix = 0; ix != mac.def->count; ix++)\n+\t    note_location (mac.def->exp.tokens[ix].src_loc);\n+\t}\n+    }\n+\n+  return macros;\n+}\n+\n /* Write out the exported defines.  This is two sections, one\n    containing the definitions, the other a table of node names.  */\n \n unsigned\n-module_state::write_macros (elf_out *to, cpp_reader *reader, unsigned *crc_p)\n+module_state::write_macros (elf_out *to, vec<cpp_hashnode *> *macros,\n+\t\t\t    unsigned *crc_p)\n {\n   dump () && dump (\"Writing macros\");\n   dump.indent ();\n \n-  vec<cpp_hashnode *> macros;\n-  macros.create (100);\n-  cpp_forall_identifiers (reader, maybe_add_macro, &macros);\n-\n-  dump (dumper::MACRO) && dump (\"No more than %u macros\", macros.length ());\n-\n-  macros.qsort (macro_loc_cmp);\n-\n   /* Write the defs */\n   bytes_out sec (to);\n   sec.begin ();\n \n   unsigned count = 0;\n-  for (unsigned ix = macros.length (); ix--;)\n+  for (unsigned ix = macros->length (); ix--;)\n     {\n-      cpp_hashnode *node = macros[ix];\n+      cpp_hashnode *node = (*macros)[ix];\n       macro_import::slot &slot = (*macro_imports)[node->deferred - 1][0];\n       gcc_assert (!slot.get_module () && slot.get_defness ());\n \n@@ -16967,9 +16997,9 @@ module_state::write_macros (elf_out *to, cpp_reader *reader, unsigned *crc_p)\n       sec.begin ();\n       sec.u (count);\n \n-      for (unsigned ix = macros.length (); ix--;)\n+      for (unsigned ix = macros->length (); ix--;)\n \t{\n-\t  const cpp_hashnode *node = macros[ix];\n+\t  const cpp_hashnode *node = (*macros)[ix];\n \t  macro_import::slot &slot = (*macro_imports)[node->deferred - 1][0];\n \n \t  if (slot.offset)\n@@ -16982,7 +17012,6 @@ module_state::write_macros (elf_out *to, cpp_reader *reader, unsigned *crc_p)\n       sec.end (to, to->name (MOD_SNAME_PFX \".mac\"), crc_p);\n     }\n \n-  macros.release ();\n   dump.outdent ();\n   return count;\n }\n@@ -17752,6 +17781,10 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n     }\n   ool->qsort (ool_cmp);\n \n+  vec<cpp_hashnode *> *macros = nullptr;\n+  if (is_header ())\n+    macros = prepare_macros (reader);\n+\n   location_map_info map_info = write_prepare_maps (&config);\n   unsigned counts[MSC_HWM];\n \n@@ -17898,8 +17931,9 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n \n   if (is_header ())\n     {\n-      counts[MSC_macros] = write_macros (to, reader, &crc);\n+      counts[MSC_macros] = write_macros (to, macros, &crc);\n       counts[MSC_inits] = write_inits (to, table, &crc);\n+      vec_free (macros);\n     }\n \n   unsigned clusters = counts[MSC_sec_hwm] - counts[MSC_sec_lwm];"}, {"sha": "25a9b26a6df4d04fab5fdc72f34eb8f10083d98d", "filename": "gcc/testsuite/g++.dg/modules/inext-1.H", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e36785cd2ba35a577b0678a2ac185288eb9e52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finext-1.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e36785cd2ba35a577b0678a2ac185288eb9e52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finext-1.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finext-1.H?ref=47e36785cd2ba35a577b0678a2ac185288eb9e52", "patch": "@@ -9,3 +9,4 @@\n \n #endif\n \n+// { dg-final { scan-lang-dump {Wrote section:1 named-by:'::foo'} module } }"}]}