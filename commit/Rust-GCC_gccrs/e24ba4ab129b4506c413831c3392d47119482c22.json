{"sha": "e24ba4ab129b4506c413831c3392d47119482c22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI0YmE0YWIxMjliNDUwNmM0MTM4MzFjMzM5MmQ0NzExOTQ4MmMyMg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-05-16T08:09:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-05-16T08:09:52Z"}, "message": "2015-05-16  Mikael Morin  <mikael@gcc.gnu.org\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/65792\n\t* trans-expr.c (gfc_trans_subcomponent_assign): Always assign\n\tthe expression component to the destination. In addition, if\n\tthe component has allocatable components, copy them and\n\tdeallocate those of the expression, if it is not a variable.\n\tThe expression is fixed if not a variable to prevent multiple\n\tevaluations.\n\n2015-05-16  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/65792\n\t* gfortran.dg/derived_constructor_components_5: New test\n\nFrom-SVN: r223234", "tree": {"sha": "7b9dec81021cac5ea71da5192b1c5d992cc8ca68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b9dec81021cac5ea71da5192b1c5d992cc8ca68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e24ba4ab129b4506c413831c3392d47119482c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24ba4ab129b4506c413831c3392d47119482c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24ba4ab129b4506c413831c3392d47119482c22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24ba4ab129b4506c413831c3392d47119482c22/comments", "author": null, "committer": null, "parents": [{"sha": "30a5d3e6185a5fa01aec283ae9efe8b739dffdf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a5d3e6185a5fa01aec283ae9efe8b739dffdf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30a5d3e6185a5fa01aec283ae9efe8b739dffdf9"}], "stats": {"total": 99, "additions": 93, "deletions": 6}, "files": [{"sha": "c06627e32c917ad4d1490884394cf162dcacd93b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e24ba4ab129b4506c413831c3392d47119482c22", "patch": "@@ -1,3 +1,14 @@\n+2015-05-16  Mikael Morin  <mikael@gcc.gnu.org\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/65792\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): Always assign\n+\tthe expression component to the destination. In addition, if\n+\tthe component has allocatable components, copy them and\n+\tdeallocate those of the expression, if it is not a variable.\n+\tThe expression is fixed if not a variable to prevent multiple\n+\tevaluations.\n+\n 2015-05-12  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/66111\n@@ -133,12 +144,12 @@\n \tto be referenced always.\n \t(build_class_array_ref): Adapt retrieval of array descriptor.\n \t(build_array_ref): Likewise.\n-\t(gfc_conv_array_ref): Hand the vptr or the descriptor to \n+\t(gfc_conv_array_ref): Hand the vptr or the descriptor to\n \tbuild_array_ref depending whether the sym is class or not.\n \t(gfc_trans_array_cobounds):  Select correct gfc_array_spec for\n \tregular and class arrays.\n \t(gfc_trans_array_bounds): Likewise.\n-\t(gfc_trans_dummy_array_bias): Likewise. \n+\t(gfc_trans_dummy_array_bias): Likewise.\n \t(gfc_get_dataptr_offset): Correcting call of build_array_ref.\n \t(gfc_conv_expr_descriptor): Set the array's offset to -1 when\n \tlbound in inner most dim is 1 and symbol non-pointer/assoc."}, {"sha": "9be8a4206faa84cb9aced1e0a6bda667c0100c53", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=e24ba4ab129b4506c413831c3392d47119482c22", "patch": "@@ -7050,19 +7050,31 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n     {\n       if (expr->expr_type != EXPR_STRUCTURE)\n \t{\n+\t  tree dealloc = NULL_TREE;\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&block, &se.pre);\n+\t  /* Prevent repeat evaluations in gfc_copy_alloc_comp by fixing the\n+\t     expression in  a temporary variable and deallocate the allocatable\n+\t     components. Then we can the copy the expression to the result.  */\n \t  if (cm->ts.u.derived->attr.alloc_comp\n-\t      && expr->expr_type == EXPR_VARIABLE)\n+\t      && expr->expr_type != EXPR_VARIABLE)\n+\t    {\n+\t      se.expr = gfc_evaluate_now (se.expr, &block);\n+\t      dealloc = gfc_deallocate_alloc_comp (cm->ts.u.derived, se.expr,\n+\t\t\t\t\t\t   expr->rank);\n+\t    }\n+\t  gfc_add_modify (&block, dest,\n+\t\t\t  fold_convert (TREE_TYPE (dest), se.expr));\n+\t  if (cm->ts.u.derived->attr.alloc_comp\n+\t      && expr->expr_type != EXPR_NULL)\n \t    {\n \t      tmp = gfc_copy_alloc_comp (cm->ts.u.derived, se.expr,\n \t\t\t\t\t dest, expr->rank);\n \t      gfc_add_expr_to_block (&block, tmp);\n+\t      if (dealloc != NULL_TREE)\n+\t\tgfc_add_expr_to_block (&block, dealloc);\n \t    }\n-\t  else\n-\t    gfc_add_modify (&block, dest,\n-\t\t\t    fold_convert (TREE_TYPE (dest), se.expr));\n \t  gfc_add_block_to_block (&block, &se.post);\n \t}\n       else"}, {"sha": "7d58a1883a15df3e15a49bcde96b68ba3ae7eb52", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e24ba4ab129b4506c413831c3392d47119482c22", "patch": "@@ -1,3 +1,8 @@\n+2015-05-16  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/65792\n+\t* gfortran.dg/derived_constructor_components_5: New test\n+\n 2015-05-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/66140"}, {"sha": "083c1313042b1beac6634150f8d3b42c502e5b22", "filename": "gcc/testsuite/gfortran.dg/derived_constructor_comps_5.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24ba4ab129b4506c413831c3392d47119482c22/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_5.f90?ref=e24ba4ab129b4506c413831c3392d47119482c22", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\r\n+!\r\n+! PR fortran/65792\r\n+! The evaluation of the argument in the call to new_prt_spec2\r\n+! failed to properly initialize the comp component.\r\n+! While the array contents were properly copied, the array bounds remained\r\n+! uninitialized.\r\n+!\r\n+! Contributed by Dominique D'Humieres <dominiq@lps.ens.fr>\r\n+\r\n+program main\r\n+  implicit none\r\n+\r\n+  integer, parameter :: n = 2\r\n+\r\n+  type :: string_t\r\n+     character(LEN=1), dimension(:), allocatable :: chars\r\n+  end type string_t\r\n+\r\n+  type :: string_container_t\r\n+     type(string_t) :: comp\r\n+  end type string_container_t\r\n+\r\n+  type(string_t) :: prt_in, tmp, tmpa(n)\r\n+  type(string_container_t) :: tmpc, tmpca(n)\r\n+  integer :: i, j, k\r\n+\r\n+  do i=1,2\r\n+\r\n+! scalar elemental function with structure constructor\r\n+     prt_in = string_t([\"D\"])\r\n+     tmpc = new_prt_spec2 (string_container_t(prt_in))\r\n+     if (any(tmpc%comp%chars .ne. [\"D\"])) call abort\r\n+     deallocate (prt_in%chars)\r\n+     deallocate(tmpc%comp%chars)\r\n+! Check that function arguments are OK too\r\n+     tmpc = new_prt_spec2 (string_container_t(new_str_t([\"h\",\"e\",\"l\",\"l\",\"o\"])))\r\n+     if (any(tmpc%comp%chars .ne. [\"h\",\"e\",\"l\",\"l\",\"o\"])) call abort\r\n+     deallocate(tmpc%comp%chars)\r\n+\r\n+  end do\r\n+\r\n+contains\r\n+\r\n+  impure elemental function new_prt_spec2 (name) result (prt_spec)\r\n+    type(string_container_t), intent(in) :: name\r\n+    type(string_container_t) :: prt_spec\r\n+    prt_spec = name\r\n+  end function new_prt_spec2\r\n+\r\n+\r\n+  function new_str_t (name) result (prt_spec)\r\n+    character (*), intent(in), dimension (:) :: name\r\n+    type(string_t) :: prt_spec\r\n+    prt_spec = string_t(name)\r\n+  end function new_str_t\r\n+\r\n+end program main\r\n+\r"}]}