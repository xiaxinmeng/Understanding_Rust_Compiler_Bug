{"sha": "a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ5YWUyMTc5NDA5Y2Y5ZWQ3ZTc4ZTkzNjQzZWM0ODkxZTlhZThmZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-14T01:53:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-14T01:53:35Z"}, "message": "ira-int.h (struct ira_object): New.\n\n\t* ira-int.h (struct ira_object): New.\n\t(ira_object_t): New typedef.  Add DEF_VEC_P and DEF_VEC_ALLOC_P\n\tfor it.\n\t(struct ira_allocno): Remove members min, max,\n\tconflict_allocno_array, conflict_id, conflict_allocno_array_size,\n\tconflict_allocnos_num and conflict_vec_p.  Add new member object.\n\t(OBJECT_CONFLICT_ARRAY, OBJECT_CONFLICT_VEC_P,\n\tOBJECT_NUM_CONFLICTS, OBJECT_CONFLICT_ARRAY_SIZE,\n\tOBJECT_CONFLICT_HARD_REGS, OBJECT_TOTAL_CONFLICT_HARD_REGS,\n\tOBJECT_MIN, OBJECT_MAX, OBJECT_CONFLICT_ID): Renamed from\n\tALLOCNO_CONFLICT_ALLOCNO_ARRAY, ALLOCNO_CONFLICT_VEC_P,\n\tALLOCNO_CONFLICT_ALLOCNOS_NUM, ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE,\n\tALLOCNO_CONFLICT_HARD_REGS, ALLOCNO_TOTAL_CONFLICT_HARD_REGS)\n\tALLOCNO_MIN, ALLOCNO_MAX, and ALLOCNO_CONFLICT_ID; now operate on\n\tan ira_object_t rather than ira_allocno_t.  All uses changed.\n\t(ira_object_id_map): Renamed from ira_conflict_id_allocno_map; now\n\tcontains a vector of ira_object_t; all uses changed.\n\t(ira_objects_num): Declare variable.\n\t(ira_create_allocno_object): Declare function.\n\t(ira_conflict_vector_profitable_p): Adjust prototype.\n\t(ira_allocate_conflict_vec): Renamed from\n\tira_allocate_allocno_conflict_vec; first arg now ira_object_t.\n\t(ira_allocate_object_conflicts): Renamed from\n\tira_allocate_allocno_conflicts; first arg now ira_object_t.\n\t(struct ira_object_iterator): New.\n\t(ira_object_iter_init, ira_object_iter_cond, FOR_EACH_OBJECT): New.\n\t(ira_allocno_conflict_iterator): Renamed member allocno_conflict_vec_p\n\tto conflict_vec_p.  All uses changed.\n\t(ira_allocno_conflict_iter_init, ira_allocno_conflict_iter_cond):\n\tChanged to take into account that conflicts are now tracked for\n\tobjects.\n\t* ira-conflicts.c (OBJECTS_CONFLICT_P): Renamed from\n\tCONFLICT_ALLOCNO_P.  Args changed to accept ira_object_t.  All\n\tuses changed.\n\t(allocnos_conflict_p): New static function.\n\t(collected_conflict_objects): Renamed from collected_allocno_objects;\n\tnow a vector of ira_object_t.  All uses changed.\n\t(build_conflict_bit_table): Changed to take into account that\n\tconflicts are now tracked for objects.\n\t(process_regs_for_copy, propagate_copies, build_allocno_conflicts)\n\t(print_allocno_conflicts, ira_build_conflicts): Likewise.\n\t* ira-color.c (assign_hard_reg, setup_allocno_available_regs_num)\n\tsetup_allocno_left_conflicts_size, allocno_reload_assign,\n\tfast_allocation): Likewise.\n\t* ira-lives.c (make_hard_regno_born, make_allocno_born)\n\tprocess_single_reg_class_operands, process_bb_node_lives): Likewise.\n\t* ira-emit.c (modify_move_list, add_range_and_copies_from_move_list):\n\tLikewise.\n\t* ira-build.c (ira_objects_num): New variable.\n\t(ira_object_id_map): Renamed from ira_conflict_id_allocno_map; now\n\tcontains a vector of ira_object_t; all uses changed.\n\t(ira_object_id_map_vec): Corresponding change.\n\t(object_pool): New static variable.\n\t(initiate_allocnos): Initialize it.\n\t(finish_allocnos): Free it.\n\t(ira_create_object, ira_create_allocno_object, create_allocno_objects):\n\tNew functions.\n\t(ira_create_allocno): Don't set members that were removed.\n\t(ira_set_allocno_cover_class): Don't change conflict hard regs.\n\t(merge_hard_reg_conflicts): Changed to take into account that\n\tconflicts are now tracked for objects.\n\t(ira_conflict_vector_profitable_p, ira_allocate_conflict_vec,\n\tallocate_conflict_bit_vec, ira_allocate_object_conflicts,\n\tcompress_conflict_vecs, remove_low_level_allocnos, ira_flattening,\n\tsetup_min_max_allocno_live_range_point, allocno_range_compare_func,\n\tsetup_min_max_conflict_allocno_ids, ):  Likewise.\n\t((add_to_conflicts): Renamed from add_to_allocno_conflicts, args changed\n\tto ira_object_t; all callers changed.\n\t(ira_add_conflict): Renamed from ira_add_allocno_conflict, args changed\n\tto ira_object_t, all callers changed.\n\t(clear_conflicts): Renamed from clear_allocno_conflicts, arg changed\n\tto ira_object_t, all callers changed.\n\t(conflict_check, curr_conflict_check_tick): Renamed from\n\tallocno_conflict_check and curr_allocno_conflict_check_tick; all uses\n\tchanged.\n\t(compress_conflict_vec): Renamed from compress_allocno_conflict_vec,\n\targ changed to ira_object_t, all callers changed.\n\t(create_cap_allocno): Call ira_create_allocno_object.\n\t(finish_allocno): Free the corresponding object.\n\t(sort_conflict_id_map): Renamed from sort_conflict_id_allocno_map; all\n\tcallers changed.  Adjusted for dealing with objects.\n\t(ira_build): Call create_allocno_objects after ira_costs.  Adjusted for\n\tdealing with objects.\n\t* ira.c (ira_bad_reload_regno_1): Adjusted for dealing with objects.\n\nFrom-SVN: r162166", "tree": {"sha": "fe78855d67c4408f0380b53d7b9fc52d0f6ffd91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe78855d67c4408f0380b53d7b9fc52d0f6ffd91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/comments", "author": null, "committer": null, "parents": [{"sha": "5e0bf6cdff5aad73aae672df571cbe2823af121a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0bf6cdff5aad73aae672df571cbe2823af121a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e0bf6cdff5aad73aae672df571cbe2823af121a"}], "stats": {"total": 1073, "additions": 664, "deletions": 409}, "files": [{"sha": "1c31c2d83096c4d129af6a583c29104a02c6bdcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -1,3 +1,90 @@\n+2010-07-14  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* ira-int.h (struct ira_object): New.\n+\t(ira_object_t): New typedef.  Add DEF_VEC_P and DEF_VEC_ALLOC_P\n+\tfor it.\n+\t(struct ira_allocno): Remove members min, max,\n+\tconflict_allocno_array, conflict_id, conflict_allocno_array_size,\n+\tconflict_allocnos_num and conflict_vec_p.  Add new member object.\n+\t(OBJECT_CONFLICT_ARRAY, OBJECT_CONFLICT_VEC_P,\n+\tOBJECT_NUM_CONFLICTS, OBJECT_CONFLICT_ARRAY_SIZE,\n+\tOBJECT_CONFLICT_HARD_REGS, OBJECT_TOTAL_CONFLICT_HARD_REGS,\n+\tOBJECT_MIN, OBJECT_MAX, OBJECT_CONFLICT_ID): Renamed from\n+\tALLOCNO_CONFLICT_ALLOCNO_ARRAY, ALLOCNO_CONFLICT_VEC_P,\n+\tALLOCNO_CONFLICT_ALLOCNOS_NUM, ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE,\n+\tALLOCNO_CONFLICT_HARD_REGS, ALLOCNO_TOTAL_CONFLICT_HARD_REGS)\n+\tALLOCNO_MIN, ALLOCNO_MAX, and ALLOCNO_CONFLICT_ID; now operate on\n+\tan ira_object_t rather than ira_allocno_t.  All uses changed.\n+\t(ira_object_id_map): Renamed from ira_conflict_id_allocno_map; now\n+\tcontains a vector of ira_object_t; all uses changed.\n+\t(ira_objects_num): Declare variable.\n+\t(ira_create_allocno_object): Declare function.\n+\t(ira_conflict_vector_profitable_p): Adjust prototype.\n+\t(ira_allocate_conflict_vec): Renamed from\n+\tira_allocate_allocno_conflict_vec; first arg now ira_object_t.\n+\t(ira_allocate_object_conflicts): Renamed from\n+\tira_allocate_allocno_conflicts; first arg now ira_object_t.\n+\t(struct ira_object_iterator): New.\n+\t(ira_object_iter_init, ira_object_iter_cond, FOR_EACH_OBJECT): New.\n+\t(ira_allocno_conflict_iterator): Renamed member allocno_conflict_vec_p\n+\tto conflict_vec_p.  All uses changed.\n+\t(ira_allocno_conflict_iter_init, ira_allocno_conflict_iter_cond):\n+\tChanged to take into account that conflicts are now tracked for\n+\tobjects.\n+\t* ira-conflicts.c (OBJECTS_CONFLICT_P): Renamed from\n+\tCONFLICT_ALLOCNO_P.  Args changed to accept ira_object_t.  All\n+\tuses changed.\n+\t(allocnos_conflict_p): New static function.\n+\t(collected_conflict_objects): Renamed from collected_allocno_objects;\n+\tnow a vector of ira_object_t.  All uses changed.\n+\t(build_conflict_bit_table): Changed to take into account that\n+\tconflicts are now tracked for objects.\n+\t(process_regs_for_copy, propagate_copies, build_allocno_conflicts)\n+\t(print_allocno_conflicts, ira_build_conflicts): Likewise.\n+\t* ira-color.c (assign_hard_reg, setup_allocno_available_regs_num)\n+\tsetup_allocno_left_conflicts_size, allocno_reload_assign,\n+\tfast_allocation): Likewise.\n+\t* ira-lives.c (make_hard_regno_born, make_allocno_born)\n+\tprocess_single_reg_class_operands, process_bb_node_lives): Likewise.\n+\t* ira-emit.c (modify_move_list, add_range_and_copies_from_move_list):\n+\tLikewise.\n+\t* ira-build.c (ira_objects_num): New variable.\n+\t(ira_object_id_map): Renamed from ira_conflict_id_allocno_map; now\n+\tcontains a vector of ira_object_t; all uses changed.\n+\t(ira_object_id_map_vec): Corresponding change.\n+\t(object_pool): New static variable.\n+\t(initiate_allocnos): Initialize it.\n+\t(finish_allocnos): Free it.\n+\t(ira_create_object, ira_create_allocno_object, create_allocno_objects):\n+\tNew functions.\n+\t(ira_create_allocno): Don't set members that were removed.\n+\t(ira_set_allocno_cover_class): Don't change conflict hard regs.\n+\t(merge_hard_reg_conflicts): Changed to take into account that\n+\tconflicts are now tracked for objects.\n+\t(ira_conflict_vector_profitable_p, ira_allocate_conflict_vec,\n+\tallocate_conflict_bit_vec, ira_allocate_object_conflicts,\n+\tcompress_conflict_vecs, remove_low_level_allocnos, ira_flattening,\n+\tsetup_min_max_allocno_live_range_point, allocno_range_compare_func,\n+\tsetup_min_max_conflict_allocno_ids, ):  Likewise.\n+\t((add_to_conflicts): Renamed from add_to_allocno_conflicts, args changed\n+\tto ira_object_t; all callers changed.\n+\t(ira_add_conflict): Renamed from ira_add_allocno_conflict, args changed\n+\tto ira_object_t, all callers changed.\n+\t(clear_conflicts): Renamed from clear_allocno_conflicts, arg changed\n+\tto ira_object_t, all callers changed.\n+\t(conflict_check, curr_conflict_check_tick): Renamed from\n+\tallocno_conflict_check and curr_allocno_conflict_check_tick; all uses\n+\tchanged.\n+\t(compress_conflict_vec): Renamed from compress_allocno_conflict_vec,\n+\targ changed to ira_object_t, all callers changed.\n+\t(create_cap_allocno): Call ira_create_allocno_object.\n+\t(finish_allocno): Free the corresponding object.\n+\t(sort_conflict_id_map): Renamed from sort_conflict_id_allocno_map; all\n+\tcallers changed.  Adjusted for dealing with objects.\n+\t(ira_build): Call create_allocno_objects after ira_costs.  Adjusted for\n+\tdealing with objects.\n+\t* ira.c (ira_bad_reload_regno_1): Adjusted for dealing with objects.\n+\n 2010-07-13  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR other/44874"}, {"sha": "34e3149af0d35c68a9f7d031c060e7538ef7f80e", "filename": "gcc/ira-build.c", "status": "modified", "additions": 264, "deletions": 195, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -72,9 +72,12 @@ ira_allocno_t *ira_allocnos;\n /* Sizes of the previous array.  */\n int ira_allocnos_num;\n \n-/* Map conflict id -> allocno with given conflict id (see comments for\n-   allocno member `conflict_id').  */\n-ira_allocno_t *ira_conflict_id_allocno_map;\n+/* Count of conflict record structures we've created, used when creating\n+   a new conflict id.  */\n+int ira_objects_num;\n+\n+/* Map a conflict id to its conflict record.  */\n+ira_object_t *ira_object_id_map;\n \n /* Array of references to all copies.  The order number of the copy\n    corresponds to the index in the array.  Removed copies have NULL\n@@ -381,19 +384,18 @@ rebuild_regno_allocno_maps (void)\n \tloop_tree_node->regno_allocno_map[regno] = a;\n     }\n }\n-\n \f\n \n-/* Pools for allocnos and live ranges.  */\n-static alloc_pool allocno_pool, live_range_pool;\n+/* Pools for allocnos, allocno live ranges and objects.  */\n+static alloc_pool allocno_pool, live_range_pool, object_pool;\n \n /* Vec containing references to all created allocnos.  It is a\n    container of array allocnos.  */\n static VEC(ira_allocno_t,heap) *allocno_vec;\n \n-/* Vec containing references to all created allocnos.  It is a\n-   container of ira_conflict_id_allocno_map.  */\n-static VEC(ira_allocno_t,heap) *ira_conflict_id_allocno_map_vec;\n+/* Vec containing references to all created ira_objects.  It is a\n+   container of ira_object_id_map.  */\n+static VEC(ira_object_t,heap) *ira_object_id_map_vec;\n \n /* Initialize data concerning allocnos.  */\n static void\n@@ -404,17 +406,48 @@ initiate_allocnos (void)\n \t\t\t sizeof (struct live_range), 100);\n   allocno_pool\n     = create_alloc_pool (\"allocnos\", sizeof (struct ira_allocno), 100);\n+  object_pool\n+    = create_alloc_pool (\"objects\", sizeof (struct ira_object), 100);\n   allocno_vec = VEC_alloc (ira_allocno_t, heap, max_reg_num () * 2);\n   ira_allocnos = NULL;\n   ira_allocnos_num = 0;\n-  ira_conflict_id_allocno_map_vec\n-    = VEC_alloc (ira_allocno_t, heap, max_reg_num () * 2);\n-  ira_conflict_id_allocno_map = NULL;\n+  ira_objects_num = 0;\n+  ira_object_id_map_vec\n+    = VEC_alloc (ira_object_t, heap, max_reg_num () * 2);\n+  ira_object_id_map = NULL;\n   ira_regno_allocno_map\n     = (ira_allocno_t *) ira_allocate (max_reg_num () * sizeof (ira_allocno_t));\n   memset (ira_regno_allocno_map, 0, max_reg_num () * sizeof (ira_allocno_t));\n }\n \n+/* Create and return an object corresponding to a new allocno A.  */\n+static ira_object_t\n+ira_create_object (ira_allocno_t a)\n+{\n+  enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n+  ira_object_t obj = (ira_object_t) pool_alloc (object_pool);\n+\n+  OBJECT_ALLOCNO (obj) = a;\n+  OBJECT_CONFLICT_ID (obj) = ira_objects_num;\n+  OBJECT_CONFLICT_VEC_P (obj) = false;\n+  OBJECT_CONFLICT_ARRAY (obj) = NULL;\n+  OBJECT_NUM_CONFLICTS (obj) = 0;\n+  COPY_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), ira_no_alloc_regs);\n+  COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), ira_no_alloc_regs);\n+  IOR_COMPL_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n+\t\t\t  reg_class_contents[cover_class]);\n+  IOR_COMPL_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t  reg_class_contents[cover_class]);\n+  OBJECT_MIN (obj) = INT_MAX;\n+  OBJECT_MAX (obj) = -1;\n+\n+  VEC_safe_push (ira_object_t, heap, ira_object_id_map_vec, obj);\n+  ira_object_id_map\n+    = VEC_address (ira_object_t, ira_object_id_map_vec);\n+  ira_objects_num = VEC_length (ira_object_t, ira_object_id_map_vec);\n+  return obj;\n+}\n+\n /* Create and return the allocno corresponding to REGNO in\n    LOOP_TREE_NODE.  Add the allocno to the list of allocnos with the\n    same regno if CAP_P is FALSE.  */\n@@ -440,10 +473,6 @@ ira_create_allocno (int regno, bool cap_p, ira_loop_tree_node_t loop_tree_node)\n   ALLOCNO_CAP_MEMBER (a) = NULL;\n   ALLOCNO_NUM (a) = ira_allocnos_num;\n   bitmap_set_bit (loop_tree_node->all_allocnos, ALLOCNO_NUM (a));\n-  ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) = NULL;\n-  ALLOCNO_CONFLICT_ALLOCNOS_NUM (a) = 0;\n-  COPY_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a), ira_no_alloc_regs);\n-  COPY_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), ira_no_alloc_regs);\n   ALLOCNO_NREFS (a) = 0;\n   ALLOCNO_FREQ (a) = 0;\n   ALLOCNO_HARD_REGNO (a) = -1;\n@@ -463,7 +492,6 @@ ira_create_allocno (int regno, bool cap_p, ira_loop_tree_node_t loop_tree_node)\n   ALLOCNO_ASSIGNED_P (a) = false;\n   ALLOCNO_MAY_BE_SPILLED_P (a) = false;\n   ALLOCNO_SPLAY_REMOVED_P (a) = false;\n-  ALLOCNO_CONFLICT_VEC_P (a) = false;\n   ALLOCNO_MODE (a) = (regno < 0 ? VOIDmode : PSEUDO_REGNO_MODE (regno));\n   ALLOCNO_COPIES (a) = NULL;\n   ALLOCNO_HARD_REG_COSTS (a) = NULL;\n@@ -482,15 +510,10 @@ ira_create_allocno (int regno, bool cap_p, ira_loop_tree_node_t loop_tree_node)\n   ALLOCNO_FIRST_COALESCED_ALLOCNO (a) = a;\n   ALLOCNO_NEXT_COALESCED_ALLOCNO (a) = a;\n   ALLOCNO_LIVE_RANGES (a) = NULL;\n-  ALLOCNO_MIN (a) = INT_MAX;\n-  ALLOCNO_MAX (a) = -1;\n-  ALLOCNO_CONFLICT_ID (a) = ira_allocnos_num;\n+\n   VEC_safe_push (ira_allocno_t, heap, allocno_vec, a);\n   ira_allocnos = VEC_address (ira_allocno_t, allocno_vec);\n   ira_allocnos_num = VEC_length (ira_allocno_t, allocno_vec);\n-  VEC_safe_push (ira_allocno_t, heap, ira_conflict_id_allocno_map_vec, a);\n-  ira_conflict_id_allocno_map\n-    = VEC_address (ira_allocno_t, ira_conflict_id_allocno_map_vec);\n   return a;\n }\n \n@@ -499,10 +522,24 @@ void\n ira_set_allocno_cover_class (ira_allocno_t a, enum reg_class cover_class)\n {\n   ALLOCNO_COVER_CLASS (a) = cover_class;\n-  IOR_COMPL_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n-\t\t\t  reg_class_contents[cover_class]);\n-  IOR_COMPL_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n-\t\t\t  reg_class_contents[cover_class]);\n+}\n+\n+/* Allocate an object for allocno A and set ALLOCNO_OBJECT.  */\n+void\n+ira_create_allocno_object (ira_allocno_t a)\n+{\n+  ALLOCNO_OBJECT (a) = ira_create_object (a);\n+}\n+\n+/* For each allocno, create the corresponding ALLOCNO_OBJECT structure.  */\n+static void\n+create_allocno_objects (void)\n+{\n+  ira_allocno_t a;\n+  ira_allocno_iterator ai;\n+\n+  FOR_EACH_ALLOCNO (a, ai)\n+    ira_create_allocno_object (a);\n }\n \n /* Merge hard register conflicts from allocno FROM into allocno TO.  If\n@@ -511,11 +548,13 @@ static void\n merge_hard_reg_conflicts (ira_allocno_t from, ira_allocno_t to,\n \t\t\t  bool total_only)\n {\n+  ira_object_t from_obj = ALLOCNO_OBJECT (from);\n+  ira_object_t to_obj = ALLOCNO_OBJECT (to);\n   if (!total_only)\n-    IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (to),\n-\t\t      ALLOCNO_CONFLICT_HARD_REGS (from));\n-  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (to),\n-\t\t    ALLOCNO_TOTAL_CONFLICT_HARD_REGS (from));\n+    IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (to_obj),\n+\t\t      OBJECT_CONFLICT_HARD_REGS (from_obj));\n+  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (to_obj),\n+\t\t    OBJECT_TOTAL_CONFLICT_HARD_REGS (from_obj));\n #ifdef STACK_REGS\n   if (!total_only && ALLOCNO_NO_STACK_REG_P (from))\n     ALLOCNO_NO_STACK_REG_P (to) = true;\n@@ -524,111 +563,110 @@ merge_hard_reg_conflicts (ira_allocno_t from, ira_allocno_t to,\n #endif\n }\n \n-/* Return TRUE if the conflict vector with NUM elements is more\n-   profitable than conflict bit vector for A.  */\n+/* Return TRUE if a conflict vector with NUM elements is more\n+   profitable than a conflict bit vector for OBJ.  */\n bool\n-ira_conflict_vector_profitable_p (ira_allocno_t a, int num)\n+ira_conflict_vector_profitable_p (ira_object_t obj, int num)\n {\n   int nw;\n+  int max = OBJECT_MAX (obj);\n+  int min = OBJECT_MIN (obj);\n \n-  if (ALLOCNO_MAX (a) < ALLOCNO_MIN (a))\n-    /* We prefer bit vector in such case because it does not result in\n-       allocation.  */\n+  if (max < min)\n+    /* We prefer a bit vector in such case because it does not result\n+       in allocation.  */\n     return false;\n \n-  nw = (ALLOCNO_MAX (a) - ALLOCNO_MIN (a) + IRA_INT_BITS) / IRA_INT_BITS;\n-  return (2 * sizeof (ira_allocno_t) * (num + 1)\n+  nw = (max - min + IRA_INT_BITS) / IRA_INT_BITS;\n+  return (2 * sizeof (ira_object_t) * (num + 1)\n \t  < 3 * nw * sizeof (IRA_INT_TYPE));\n }\n \n-/* Allocates and initialize the conflict vector of A for NUM\n-   conflicting allocnos.  */\n+/* Allocates and initialize the conflict vector of OBJ for NUM\n+   conflicting objects.  */\n void\n-ira_allocate_allocno_conflict_vec (ira_allocno_t a, int num)\n+ira_allocate_conflict_vec (ira_object_t obj, int num)\n {\n   int size;\n-  ira_allocno_t *vec;\n+  ira_object_t *vec;\n \n-  ira_assert (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) == NULL);\n+  ira_assert (OBJECT_CONFLICT_ARRAY (obj) == NULL);\n   num++; /* for NULL end marker  */\n-  size = sizeof (ira_allocno_t) * num;\n-  ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) = ira_allocate (size);\n-  vec = (ira_allocno_t *) ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a);\n+  size = sizeof (ira_object_t) * num;\n+  OBJECT_CONFLICT_ARRAY (obj) = ira_allocate (size);\n+  vec = (ira_object_t *) OBJECT_CONFLICT_ARRAY (obj);\n   vec[0] = NULL;\n-  ALLOCNO_CONFLICT_ALLOCNOS_NUM (a) = 0;\n-  ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a) = size;\n-  ALLOCNO_CONFLICT_VEC_P (a) = true;\n+  OBJECT_NUM_CONFLICTS (obj) = 0;\n+  OBJECT_CONFLICT_ARRAY_SIZE (obj) = size;\n+  OBJECT_CONFLICT_VEC_P (obj) = true;\n }\n \n-/* Allocate and initialize the conflict bit vector of A.  */\n+/* Allocate and initialize the conflict bit vector of OBJ.  */\n static void\n-allocate_allocno_conflict_bit_vec (ira_allocno_t a)\n+allocate_conflict_bit_vec (ira_object_t obj)\n {\n   unsigned int size;\n \n-  ira_assert (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) == NULL);\n-  size = ((ALLOCNO_MAX (a) - ALLOCNO_MIN (a) + IRA_INT_BITS)\n+  ira_assert (OBJECT_CONFLICT_ARRAY (obj) == NULL);\n+  size = ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n \t  / IRA_INT_BITS * sizeof (IRA_INT_TYPE));\n-  ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) = ira_allocate (size);\n-  memset (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a), 0, size);\n-  ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a) = size;\n-  ALLOCNO_CONFLICT_VEC_P (a) = false;\n+  OBJECT_CONFLICT_ARRAY (obj) = ira_allocate (size);\n+  memset (OBJECT_CONFLICT_ARRAY (obj), 0, size);\n+  OBJECT_CONFLICT_ARRAY_SIZE (obj) = size;\n+  OBJECT_CONFLICT_VEC_P (obj) = false;\n }\n \n /* Allocate and initialize the conflict vector or conflict bit vector\n    of A for NUM conflicting allocnos whatever is more profitable.  */\n void\n-ira_allocate_allocno_conflicts (ira_allocno_t a, int num)\n+ira_allocate_object_conflicts (ira_object_t a, int num)\n {\n   if (ira_conflict_vector_profitable_p (a, num))\n-    ira_allocate_allocno_conflict_vec (a, num);\n+    ira_allocate_conflict_vec (a, num);\n   else\n-    allocate_allocno_conflict_bit_vec (a);\n+    allocate_conflict_bit_vec (a);\n }\n \n-/* Add A2 to the conflicts of A1.  */\n+/* Add OBJ2 to the conflicts of OBJ1.  */\n static void\n-add_to_allocno_conflicts (ira_allocno_t a1, ira_allocno_t a2)\n+add_to_conflicts (ira_object_t obj1, ira_object_t obj2)\n {\n   int num;\n   unsigned int size;\n \n-  if (ALLOCNO_CONFLICT_VEC_P (a1))\n+  if (OBJECT_CONFLICT_VEC_P (obj1))\n     {\n-      ira_allocno_t *vec;\n-\n-      num = ALLOCNO_CONFLICT_ALLOCNOS_NUM (a1) + 2;\n-      if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1)\n-\t  >=  num * sizeof (ira_allocno_t))\n-\tvec = (ira_allocno_t *) ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1);\n-      else\n+      ira_object_t *vec = OBJECT_CONFLICT_VEC (obj1);\n+      int curr_num = OBJECT_NUM_CONFLICTS (obj1);\n+      num = curr_num + 2;\n+      if (OBJECT_CONFLICT_ARRAY_SIZE (obj1) < num * sizeof (ira_object_t))\n \t{\n+\t  ira_object_t *newvec;\n \t  size = (3 * num / 2 + 1) * sizeof (ira_allocno_t);\n-\t  vec = (ira_allocno_t *) ira_allocate (size);\n-\t  memcpy (vec, ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1),\n-\t\t  sizeof (ira_allocno_t) * ALLOCNO_CONFLICT_ALLOCNOS_NUM (a1));\n-\t  ira_free (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1));\n-\t  ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1) = vec;\n-\t  ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1) = size;\n+\t  newvec = (ira_object_t *) ira_allocate (size);\n+\t  memcpy (newvec, vec, curr_num * sizeof (ira_object_t));\n+\t  ira_free (vec);\n+\t  vec = newvec;\n+\t  OBJECT_CONFLICT_ARRAY (obj1) = vec;\n+\t  OBJECT_CONFLICT_ARRAY_SIZE (obj1) = size;\n \t}\n-      vec[num - 2] = a2;\n+      vec[num - 2] = obj2;\n       vec[num - 1] = NULL;\n-      ALLOCNO_CONFLICT_ALLOCNOS_NUM (a1)++;\n+      OBJECT_NUM_CONFLICTS (obj1)++;\n     }\n   else\n     {\n       int nw, added_head_nw, id;\n-      IRA_INT_TYPE *vec;\n+      IRA_INT_TYPE *vec = OBJECT_CONFLICT_BITVEC (obj1);\n \n-      id = ALLOCNO_CONFLICT_ID (a2);\n-      vec = (IRA_INT_TYPE *) ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1);\n-      if (ALLOCNO_MIN (a1) > id)\n+      id = OBJECT_CONFLICT_ID (obj2);\n+      if (OBJECT_MIN (obj1) > id)\n \t{\n \t  /* Expand head of the bit vector.  */\n-\t  added_head_nw = (ALLOCNO_MIN (a1) - id - 1) / IRA_INT_BITS + 1;\n-\t  nw = (ALLOCNO_MAX (a1) - ALLOCNO_MIN (a1)) / IRA_INT_BITS + 1;\n+\t  added_head_nw = (OBJECT_MIN (obj1) - id - 1) / IRA_INT_BITS + 1;\n+\t  nw = (OBJECT_MAX (obj1) - OBJECT_MIN (obj1)) / IRA_INT_BITS + 1;\n \t  size = (nw + added_head_nw) * sizeof (IRA_INT_TYPE);\n-\t  if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1) >= size)\n+\t  if (OBJECT_CONFLICT_ARRAY_SIZE (obj1) >= size)\n \t    {\n \t      memmove ((char *) vec + added_head_nw * sizeof (IRA_INT_TYPE),\n \t\t       vec, nw * sizeof (IRA_INT_TYPE));\n@@ -640,97 +678,93 @@ add_to_allocno_conflicts (ira_allocno_t a1, ira_allocno_t a2)\n \t\t= (3 * (nw + added_head_nw) / 2 + 1) * sizeof (IRA_INT_TYPE);\n \t      vec = (IRA_INT_TYPE *) ira_allocate (size);\n \t      memcpy ((char *) vec + added_head_nw * sizeof (IRA_INT_TYPE),\n-\t\t      ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1),\n-\t\t      nw * sizeof (IRA_INT_TYPE));\n+\t\t      OBJECT_CONFLICT_ARRAY (obj1), nw * sizeof (IRA_INT_TYPE));\n \t      memset (vec, 0, added_head_nw * sizeof (IRA_INT_TYPE));\n \t      memset ((char *) vec\n \t\t      + (nw + added_head_nw) * sizeof (IRA_INT_TYPE),\n \t\t      0, size - (nw + added_head_nw) * sizeof (IRA_INT_TYPE));\n-\t      ira_free (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1));\n-\t      ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1) = vec;\n-\t      ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1) = size;\n+\t      ira_free (OBJECT_CONFLICT_ARRAY (obj1));\n+\t      OBJECT_CONFLICT_ARRAY (obj1) = vec;\n+\t      OBJECT_CONFLICT_ARRAY_SIZE (obj1) = size;\n \t    }\n-\t  ALLOCNO_MIN (a1) -= added_head_nw * IRA_INT_BITS;\n+\t  OBJECT_MIN (obj1) -= added_head_nw * IRA_INT_BITS;\n \t}\n-      else if (ALLOCNO_MAX (a1) < id)\n+      else if (OBJECT_MAX (obj1) < id)\n \t{\n-\t  nw = (id - ALLOCNO_MIN (a1)) / IRA_INT_BITS + 1;\n+\t  nw = (id - OBJECT_MIN (obj1)) / IRA_INT_BITS + 1;\n \t  size = nw * sizeof (IRA_INT_TYPE);\n-\t  if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1) < size)\n+\t  if (OBJECT_CONFLICT_ARRAY_SIZE (obj1) < size)\n \t    {\n \t      /* Expand tail of the bit vector.  */\n \t      size = (3 * nw / 2 + 1) * sizeof (IRA_INT_TYPE);\n \t      vec = (IRA_INT_TYPE *) ira_allocate (size);\n-\t      memcpy (vec, ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1),\n-\t\t      ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1));\n-\t      memset ((char *) vec + ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1),\n-\t\t      0, size - ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1));\n-\t      ira_free (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1));\n-\t      ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a1) = vec;\n-\t      ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a1) = size;\n+\t      memcpy (vec, OBJECT_CONFLICT_ARRAY (obj1), OBJECT_CONFLICT_ARRAY_SIZE (obj1));\n+\t      memset ((char *) vec + OBJECT_CONFLICT_ARRAY_SIZE (obj1),\n+\t\t      0, size - OBJECT_CONFLICT_ARRAY_SIZE (obj1));\n+\t      ira_free (OBJECT_CONFLICT_ARRAY (obj1));\n+\t      OBJECT_CONFLICT_ARRAY (obj1) = vec;\n+\t      OBJECT_CONFLICT_ARRAY_SIZE (obj1) = size;\n \t    }\n-\t  ALLOCNO_MAX (a1) = id;\n+\t  OBJECT_MAX (obj1) = id;\n \t}\n-      SET_MINMAX_SET_BIT (vec, id, ALLOCNO_MIN (a1), ALLOCNO_MAX (a1));\n+      SET_MINMAX_SET_BIT (vec, id, OBJECT_MIN (obj1), OBJECT_MAX (obj1));\n     }\n }\n \n-/* Add A1 to the conflicts of A2 and vise versa.  */\n-void\n-ira_add_allocno_conflict (ira_allocno_t a1, ira_allocno_t a2)\n+/* Add OBJ1 to the conflicts of OBJ2 and vice versa.  */\n+static void\n+ira_add_conflict (ira_object_t obj1, ira_object_t obj2)\n {\n-  add_to_allocno_conflicts (a1, a2);\n-  add_to_allocno_conflicts (a2, a1);\n+  add_to_conflicts (obj1, obj2);\n+  add_to_conflicts (obj2, obj1);\n }\n \n-/* Clear all conflicts of allocno A.  */\n+/* Clear all conflicts of OBJ.  */\n static void\n-clear_allocno_conflicts (ira_allocno_t a)\n+clear_conflicts (ira_object_t obj)\n {\n-  if (ALLOCNO_CONFLICT_VEC_P (a))\n+  if (OBJECT_CONFLICT_VEC_P (obj))\n     {\n-      ALLOCNO_CONFLICT_ALLOCNOS_NUM (a) = 0;\n-      ((ira_allocno_t *) ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a))[0] = NULL;\n+      OBJECT_NUM_CONFLICTS (obj) = 0;\n+      OBJECT_CONFLICT_VEC (obj)[0] = NULL;\n     }\n-  else if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a) != 0)\n+  else if (OBJECT_CONFLICT_ARRAY_SIZE (obj) != 0)\n     {\n       int nw;\n \n-      nw = (ALLOCNO_MAX (a) - ALLOCNO_MIN (a)) / IRA_INT_BITS + 1;\n-      memset (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a), 0,\n-\t      nw * sizeof (IRA_INT_TYPE));\n+      nw = (OBJECT_MAX (obj) - OBJECT_MIN (obj)) / IRA_INT_BITS + 1;\n+      memset (OBJECT_CONFLICT_BITVEC (obj), 0, nw * sizeof (IRA_INT_TYPE));\n     }\n }\n \n /* The array used to find duplications in conflict vectors of\n    allocnos.  */\n-static int *allocno_conflict_check;\n+static int *conflict_check;\n \n /* The value used to mark allocation presence in conflict vector of\n    the current allocno.  */\n-static int curr_allocno_conflict_check_tick;\n+static int curr_conflict_check_tick;\n \n-/* Remove duplications in conflict vector of A.  */\n+/* Remove duplications in conflict vector of OBJ.  */\n static void\n-compress_allocno_conflict_vec (ira_allocno_t a)\n+compress_conflict_vec (ira_object_t obj)\n {\n-  ira_allocno_t *vec, conflict_a;\n+  ira_object_t *vec, conflict_obj;\n   int i, j;\n \n-  ira_assert (ALLOCNO_CONFLICT_VEC_P (a));\n-  vec = (ira_allocno_t *) ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a);\n-  curr_allocno_conflict_check_tick++;\n-  for (i = j = 0; (conflict_a = vec[i]) != NULL; i++)\n+  ira_assert (OBJECT_CONFLICT_VEC_P (obj));\n+  vec = OBJECT_CONFLICT_VEC (obj);\n+  curr_conflict_check_tick++;\n+  for (i = j = 0; (conflict_obj = vec[i]) != NULL; i++)\n     {\n-      if (allocno_conflict_check[ALLOCNO_NUM (conflict_a)]\n-\t  != curr_allocno_conflict_check_tick)\n+      int id = OBJECT_CONFLICT_ID (conflict_obj);\n+      if (conflict_check[id] != curr_conflict_check_tick)\n \t{\n-\t  allocno_conflict_check[ALLOCNO_NUM (conflict_a)]\n-\t    = curr_allocno_conflict_check_tick;\n-\t  vec[j++] = conflict_a;\n+\t  conflict_check[id] = curr_conflict_check_tick;\n+\t  vec[j++] = conflict_obj;\n \t}\n     }\n-  ALLOCNO_CONFLICT_ALLOCNOS_NUM (a) = j;\n+  OBJECT_NUM_CONFLICTS (obj) = j;\n   vec[j] = NULL;\n }\n \n@@ -741,14 +775,16 @@ compress_conflict_vecs (void)\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n \n-  allocno_conflict_check\n-    = (int *) ira_allocate (sizeof (int) * ira_allocnos_num);\n-  memset (allocno_conflict_check, 0, sizeof (int) * ira_allocnos_num);\n-  curr_allocno_conflict_check_tick = 0;\n+  conflict_check = (int *) ira_allocate (sizeof (int) * ira_objects_num);\n+  memset (conflict_check, 0, sizeof (int) * ira_objects_num);\n+  curr_conflict_check_tick = 0;\n   FOR_EACH_ALLOCNO (a, ai)\n-    if (ALLOCNO_CONFLICT_VEC_P (a))\n-      compress_allocno_conflict_vec (a);\n-  ira_free (allocno_conflict_check);\n+    {\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n+      if (OBJECT_CONFLICT_VEC_P (obj))\n+\tcompress_conflict_vec (obj);\n+    }\n+  ira_free (conflict_check);\n }\n \n /* This recursive function outputs allocno A and if it is a cap the\n@@ -787,6 +823,7 @@ create_cap_allocno (ira_allocno_t a)\n   ALLOCNO_MODE (cap) = ALLOCNO_MODE (a);\n   cover_class = ALLOCNO_COVER_CLASS (a);\n   ira_set_allocno_cover_class (cap, cover_class);\n+  ira_create_allocno_object (cap);\n   ALLOCNO_AVAILABLE_REGS_NUM (cap) = ALLOCNO_AVAILABLE_REGS_NUM (a);\n   ALLOCNO_CAP_MEMBER (cap) = a;\n   ALLOCNO_CAP (a) = cap;\n@@ -995,11 +1032,9 @@ static void\n finish_allocno (ira_allocno_t a)\n {\n   enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n+  ira_object_t obj = ALLOCNO_OBJECT (a);\n \n   ira_allocnos[ALLOCNO_NUM (a)] = NULL;\n-  ira_conflict_id_allocno_map[ALLOCNO_CONFLICT_ID (a)] = NULL;\n-  if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) != NULL)\n-    ira_free (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a));\n   if (ALLOCNO_HARD_REG_COSTS (a) != NULL)\n     ira_free_cost_vector (ALLOCNO_HARD_REG_COSTS (a), cover_class);\n   if (ALLOCNO_CONFLICT_HARD_REG_COSTS (a) != NULL)\n@@ -1011,6 +1046,11 @@ finish_allocno (ira_allocno_t a)\n \t\t\t  cover_class);\n   ira_finish_allocno_live_range_list (ALLOCNO_LIVE_RANGES (a));\n   pool_free (allocno_pool, a);\n+\n+  ira_object_id_map[OBJECT_CONFLICT_ID (obj)] = NULL;\n+  if (OBJECT_CONFLICT_ARRAY (obj) != NULL)\n+    ira_free (OBJECT_CONFLICT_ARRAY (obj));\n+  pool_free (object_pool, obj);\n }\n \n /* Free the memory allocated for all allocnos.  */\n@@ -1023,9 +1063,10 @@ finish_allocnos (void)\n   FOR_EACH_ALLOCNO (a, ai)\n     finish_allocno (a);\n   ira_free (ira_regno_allocno_map);\n-  VEC_free (ira_allocno_t, heap, ira_conflict_id_allocno_map_vec);\n+  VEC_free (ira_object_t, heap, ira_object_id_map_vec);\n   VEC_free (ira_allocno_t, heap, allocno_vec);\n   free_alloc_pool (allocno_pool);\n+  free_alloc_pool (object_pool);\n   free_alloc_pool (live_range_pool);\n }\n \n@@ -2080,11 +2121,13 @@ remove_low_level_allocnos (void)\n       regno = ALLOCNO_REGNO (a);\n       if (ira_loop_tree_root->regno_allocno_map[regno] == a)\n \t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a);\n+\n \t  ira_regno_allocno_map[regno] = a;\n \t  ALLOCNO_NEXT_REGNO_ALLOCNO (a) = NULL;\n \t  ALLOCNO_CAP_MEMBER (a) = NULL;\n-\t  COPY_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n-\t\t\t     ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+\t  COPY_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n+\t\t\t     OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n #ifdef STACK_REGS\n \t  if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n \t    ALLOCNO_NO_STACK_REG_P (a) = true;\n@@ -2203,47 +2246,54 @@ setup_min_max_allocno_live_range_point (void)\n \n   FOR_EACH_ALLOCNO (a, ai)\n     {\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n       r = ALLOCNO_LIVE_RANGES (a);\n       if (r == NULL)\n \tcontinue;\n-      ALLOCNO_MAX (a) = r->finish;\n+      OBJECT_MAX (obj) = r->finish;\n       for (; r->next != NULL; r = r->next)\n \t;\n-      ALLOCNO_MIN (a) = r->start;\n+      OBJECT_MIN (obj) = r->start;\n     }\n   for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n     for (a = ira_regno_allocno_map[i];\n \t a != NULL;\n \t a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n       {\n-\tif (ALLOCNO_MAX (a) < 0)\n+\tira_object_t obj = ALLOCNO_OBJECT (a);\n+\tira_object_t parent_obj;\n+\n+\tif (OBJECT_MAX (obj) < 0)\n \t  continue;\n \tira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n \t/* Accumulation of range info.  */\n \tif (ALLOCNO_CAP (a) != NULL)\n \t  {\n \t    for (cap = ALLOCNO_CAP (a); cap != NULL; cap = ALLOCNO_CAP (cap))\n \t      {\n-\t\tif (ALLOCNO_MAX (cap) < ALLOCNO_MAX (a))\n-\t\t  ALLOCNO_MAX (cap) = ALLOCNO_MAX (a);\n-\t\tif (ALLOCNO_MIN (cap) > ALLOCNO_MIN (a))\n-\t\t  ALLOCNO_MIN (cap) = ALLOCNO_MIN (a);\n+\t\tira_object_t cap_obj = ALLOCNO_OBJECT (cap);\n+\t\tif (OBJECT_MAX (cap_obj) < OBJECT_MAX (obj))\n+\t\t  OBJECT_MAX (cap_obj) = OBJECT_MAX (obj);\n+\t\tif (OBJECT_MIN (cap_obj) > OBJECT_MIN (obj))\n+\t\t  OBJECT_MIN (cap_obj) = OBJECT_MIN (obj);\n \t      }\n \t    continue;\n \t  }\n \tif ((parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) == NULL)\n \t  continue;\n \tparent_a = parent->regno_allocno_map[i];\n-\tif (ALLOCNO_MAX (parent_a) < ALLOCNO_MAX (a))\n-\t  ALLOCNO_MAX (parent_a) = ALLOCNO_MAX (a);\n-\tif (ALLOCNO_MIN (parent_a) > ALLOCNO_MIN (a))\n-\t  ALLOCNO_MIN (parent_a) = ALLOCNO_MIN (a);\n+\tparent_obj = ALLOCNO_OBJECT (parent_a);\n+\tif (OBJECT_MAX (parent_obj) < OBJECT_MAX (obj))\n+\t  OBJECT_MAX (parent_obj) = OBJECT_MAX (obj);\n+\tif (OBJECT_MIN (parent_obj) > OBJECT_MIN (obj))\n+\t  OBJECT_MIN (parent_obj) = OBJECT_MIN (obj);\n       }\n #ifdef ENABLE_IRA_CHECKING\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n-      if ((0 <= ALLOCNO_MIN (a) && ALLOCNO_MIN (a) <= ira_max_point)\n-\t  && (0 <= ALLOCNO_MAX (a) && ALLOCNO_MAX (a) <= ira_max_point))\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n+      if ((0 <= OBJECT_MIN (obj) && OBJECT_MIN (obj) <= ira_max_point)\n+\t  && (0 <= OBJECT_MAX (obj) && OBJECT_MAX (obj) <= ira_max_point))\n \tcontinue;\n       gcc_unreachable ();\n     }\n@@ -2252,45 +2302,49 @@ setup_min_max_allocno_live_range_point (void)\n \n /* Sort allocnos according to their live ranges.  Allocnos with\n    smaller cover class are put first unless we use priority coloring.\n-   Allocnos with the same cove class are ordered according their start\n+   Allocnos with the same cover class are ordered according their start\n    (min).  Allocnos with the same start are ordered according their\n    finish (max).  */\n static int\n allocno_range_compare_func (const void *v1p, const void *v2p)\n {\n   int diff;\n-  ira_allocno_t a1 = *(const ira_allocno_t *) v1p;\n-  ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n+  ira_object_t obj1 = *(const ira_object_t *) v1p;\n+  ira_object_t obj2 = *(const ira_object_t *) v2p;\n+  ira_allocno_t a1 = OBJECT_ALLOCNO (obj1);\n+  ira_allocno_t a2 = OBJECT_ALLOCNO (obj2);\n \n   if (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n       && (diff = ALLOCNO_COVER_CLASS (a1) - ALLOCNO_COVER_CLASS (a2)) != 0)\n     return diff;\n-  if ((diff = ALLOCNO_MIN (a1) - ALLOCNO_MIN (a2)) != 0)\n+  if ((diff = OBJECT_MIN (obj1) - OBJECT_MIN (obj2)) != 0)\n     return diff;\n-  if ((diff = ALLOCNO_MAX (a1) - ALLOCNO_MAX (a2)) != 0)\n+  if ((diff = OBJECT_MAX (obj1) - OBJECT_MAX (obj2)) != 0)\n      return diff;\n   return ALLOCNO_NUM (a1) - ALLOCNO_NUM (a2);\n }\n \n-/* Sort ira_conflict_id_allocno_map and set up conflict id of\n-   allocnos.  */\n+/* Sort ira_object_id_map and set up conflict id of allocnos.  */\n static void\n-sort_conflict_id_allocno_map (void)\n+sort_conflict_id_map (void)\n {\n   int i, num;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n \n   num = 0;\n   FOR_EACH_ALLOCNO (a, ai)\n-    ira_conflict_id_allocno_map[num++] = a;\n-  qsort (ira_conflict_id_allocno_map, num, sizeof (ira_allocno_t),\n+    ira_object_id_map[num++] = ALLOCNO_OBJECT (a);\n+  qsort (ira_object_id_map, num, sizeof (ira_object_t),\n \t allocno_range_compare_func);\n   for (i = 0; i < num; i++)\n-    if ((a = ira_conflict_id_allocno_map[i]) != NULL)\n-      ALLOCNO_CONFLICT_ID (a) = i;\n-  for (i = num; i < ira_allocnos_num; i++)\n-    ira_conflict_id_allocno_map[i] = NULL;\n+    {\n+      ira_object_t obj = ira_object_id_map[i];\n+      gcc_assert (obj != NULL);\n+      OBJECT_CONFLICT_ID (obj) = i;\n+    }\n+  for (i = num; i < ira_objects_num; i++)\n+    ira_object_id_map[i] = NULL;\n }\n \n /* Set up minimal and maximal conflict ids of allocnos with which\n@@ -2303,14 +2357,17 @@ setup_min_max_conflict_allocno_ids (void)\n   int *live_range_min, *last_lived;\n   ira_allocno_t a;\n \n-  live_range_min = (int *) ira_allocate (sizeof (int) * ira_allocnos_num);\n+  live_range_min = (int *) ira_allocate (sizeof (int) * ira_objects_num);\n   cover_class = -1;\n   first_not_finished = -1;\n-  for (i = 0; i < ira_allocnos_num; i++)\n+  for (i = 0; i < ira_objects_num; i++)\n     {\n-      a = ira_conflict_id_allocno_map[i];\n-      if (a == NULL)\n+      ira_object_t obj = ira_object_id_map[i];\n+      if (obj == NULL)\n \tcontinue;\n+\n+      a = OBJECT_ALLOCNO (obj);\n+\n       if (cover_class < 0\n \t  || (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n \t      && cover_class != (int) ALLOCNO_COVER_CLASS (a)))\n@@ -2321,13 +2378,13 @@ setup_min_max_conflict_allocno_ids (void)\n \t}\n       else\n \t{\n-\t  start = ALLOCNO_MIN (a);\n+\t  start = OBJECT_MIN (obj);\n \t  /* If we skip an allocno, the allocno with smaller ids will\n \t     be also skipped because of the secondary sorting the\n \t     range finishes (see function\n \t     allocno_range_compare_func).  */\n \t  while (first_not_finished < i\n-\t\t && start > ALLOCNO_MAX (ira_conflict_id_allocno_map\n+\t\t && start > OBJECT_MAX (ira_object_id_map\n \t\t\t\t\t [first_not_finished]))\n \t    first_not_finished++;\n \t  min = first_not_finished;\n@@ -2336,17 +2393,19 @@ setup_min_max_conflict_allocno_ids (void)\n \t/* We could increase min further in this case but it is good\n \t   enough.  */\n \tmin++;\n-      live_range_min[i] = ALLOCNO_MIN (a);\n-      ALLOCNO_MIN (a) = min;\n+      live_range_min[i] = OBJECT_MIN (obj);\n+      OBJECT_MIN (obj) = min;\n     }\n   last_lived = (int *) ira_allocate (sizeof (int) * ira_max_point);\n   cover_class = -1;\n   filled_area_start = -1;\n-  for (i = ira_allocnos_num - 1; i >= 0; i--)\n+  for (i = ira_objects_num - 1; i >= 0; i--)\n     {\n-      a = ira_conflict_id_allocno_map[i];\n-      if (a == NULL)\n+      ira_object_t obj = ira_object_id_map[i];\n+      if (obj == NULL)\n \tcontinue;\n+\n+      a = OBJECT_ALLOCNO (obj);\n       if (cover_class < 0\n \t  || (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n \t      && cover_class != (int) ALLOCNO_COVER_CLASS (a)))\n@@ -2357,13 +2416,13 @@ setup_min_max_conflict_allocno_ids (void)\n \t  filled_area_start = ira_max_point;\n \t}\n       min = live_range_min[i];\n-      finish = ALLOCNO_MAX (a);\n+      finish = OBJECT_MAX (obj);\n       max = last_lived[finish];\n       if (max < 0)\n \t/* We could decrease max further in this case but it is good\n \t   enough.  */\n-\tmax = ALLOCNO_CONFLICT_ID (a) - 1;\n-      ALLOCNO_MAX (a) = max;\n+\tmax = OBJECT_CONFLICT_ID (obj) - 1;\n+      OBJECT_MAX (obj) = max;\n       /* In filling, we can go further A range finish to recognize\n \t intersection quickly because if the finish of subsequently\n \t processed allocno (it has smaller conflict id) range is\n@@ -2518,13 +2577,14 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n   new_pseudos_p = merged_p = false;\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n       if (ALLOCNO_CAP_MEMBER (a) != NULL)\n \t/* Caps are not in the regno allocno maps and they are never\n \t   will be transformed into allocnos existing after IR\n \t   flattening.  */\n \tcontinue;\n-      COPY_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n-\t\t\t ALLOCNO_CONFLICT_HARD_REGS (a));\n+      COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n+\t\t\t OBJECT_CONFLICT_HARD_REGS (obj));\n #ifdef STACK_REGS\n       ALLOCNO_TOTAL_NO_STACK_REG_P (a) = ALLOCNO_NO_STACK_REG_P (a);\n #endif\n@@ -2612,7 +2672,7 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t    continue;\n \t  for (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = r->next)\n \t    ira_assert (r->allocno == a);\n-\t  clear_allocno_conflicts (a);\n+\t  clear_conflicts (ALLOCNO_OBJECT (a));\n \t}\n       allocnos_live = sparseset_alloc (ira_allocnos_num);\n       for (i = 0; i < ira_max_point; i++)\n@@ -2634,7 +2694,11 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t\t      [cover_class][ALLOCNO_COVER_CLASS (live_a)]\n \t\t      /* Don't set up conflict for the allocno with itself.  */\n \t\t      && num != (int) n)\n-\t\t    ira_add_allocno_conflict (a, live_a);\n+\t\t    {\n+\t\t      ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t\t      ira_object_t live_obj = ALLOCNO_OBJECT (live_a);\n+\t\t      ira_add_conflict (obj, live_obj);\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -2826,6 +2890,7 @@ ira_build (bool loops_p)\n   form_loop_tree ();\n   create_allocnos ();\n   ira_costs ();\n+  create_allocno_objects ();\n   ira_create_allocno_live_ranges ();\n   remove_unnecessary_regions (false);\n   ira_compress_allocno_live_ranges ();\n@@ -2841,7 +2906,7 @@ ira_build (bool loops_p)\n   check_allocno_creation ();\n #endif\n   setup_min_max_allocno_live_range_point ();\n-  sort_conflict_id_allocno_map ();\n+  sort_conflict_id_map ();\n   setup_min_max_conflict_allocno_ids ();\n   ira_build_conflicts ();\n   update_conflict_hard_reg_costs ();\n@@ -2862,9 +2927,10 @@ ira_build (bool loops_p)\n       FOR_EACH_ALLOCNO (a, ai)\n \tif (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \t  {\n-\t    IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n+\t    ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t    IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n \t\t\t      call_used_reg_set);\n-\t    IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t    IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n \t\t\t      call_used_reg_set);\n \t  }\n     }\n@@ -2879,7 +2945,10 @@ ira_build (bool loops_p)\n \n       n = 0;\n       FOR_EACH_ALLOCNO (a, ai)\n-\tn += ALLOCNO_CONFLICT_ALLOCNOS_NUM (a);\n+\t{\n+\t  ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t  n += OBJECT_NUM_CONFLICTS (obj);\n+\t}\n       nr = 0;\n       FOR_EACH_ALLOCNO (a, ai)\n \tfor (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = r->next)"}, {"sha": "b938b0af0f37faadf7e4c33cd8b564b169fdf071", "filename": "gcc/ira-color.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -477,9 +477,11 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n+\n       mem_cost += ALLOCNO_UPDATED_MEMORY_COST (a);\n       IOR_HARD_REG_SET (conflicting_regs,\n-\t\t\tALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+\t\t\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n       ira_allocate_and_copy_costs (&ALLOCNO_UPDATED_HARD_REG_COSTS (a),\n \t\t\t\t   cover_class, ALLOCNO_HARD_REG_COSTS (a));\n       a_costs = ALLOCNO_UPDATED_HARD_REG_COSTS (a);\n@@ -1376,7 +1378,8 @@ setup_allocno_available_regs_num (ira_allocno_t allocno)\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      IOR_HARD_REG_SET (temp_set, ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n+      IOR_HARD_REG_SET (temp_set, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n       if (a == allocno)\n \tbreak;\n     }\n@@ -1412,7 +1415,8 @@ setup_allocno_left_conflicts_size (ira_allocno_t allocno)\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      IOR_HARD_REG_SET (temp_set, ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n+      IOR_HARD_REG_SET (temp_set, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n       if (a == allocno)\n \tbreak;\n     }\n@@ -2791,11 +2795,12 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n   enum reg_class cover_class;\n   int regno = ALLOCNO_REGNO (a);\n   HARD_REG_SET saved;\n+  ira_object_t obj = ALLOCNO_OBJECT (a);\n \n-  COPY_HARD_REG_SET (saved, ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n-  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), forbidden_regs);\n+  COPY_HARD_REG_SET (saved, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), forbidden_regs);\n   if (! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-    IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), call_used_reg_set);\n+    IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), call_used_reg_set);\n   ALLOCNO_ASSIGNED_P (a) = false;\n   cover_class = ALLOCNO_COVER_CLASS (a);\n   update_curr_costs (a);\n@@ -2834,7 +2839,7 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n     }\n   else if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"\\n\");\n-  COPY_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), saved);\n+  COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), saved);\n   return reg_renumber[regno] >= 0;\n }\n \n@@ -3262,8 +3267,10 @@ fast_allocation (void)\n \t allocno_priority_compare_func);\n   for (i = 0; i < num; i++)\n     {\n+      ira_object_t obj;\n       a = sorted_allocnos[i];\n-      COPY_HARD_REG_SET (conflict_hard_regs, ALLOCNO_CONFLICT_HARD_REGS (a));\n+      obj = ALLOCNO_OBJECT (a);\n+      COPY_HARD_REG_SET (conflict_hard_regs, OBJECT_CONFLICT_HARD_REGS (obj));\n       for (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = r->next)\n \tfor (j =  r->start; j <= r->finish; j++)\n \t  IOR_HARD_REG_SET (conflict_hard_regs, used_hard_regs[j]);"}, {"sha": "df6d0689ce305e04c528a867f4f99a8759733f2f", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 130, "deletions": 102, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -51,40 +51,38 @@ along with GCC; see the file COPYING3.  If not see\n    corresponding allocnos see function build_allocno_conflicts.  */\n static IRA_INT_TYPE **conflicts;\n \n-/* Macro to test a conflict of A1 and A2 in `conflicts'.  */\n-#define CONFLICT_ALLOCNO_P(A1, A2)\t\t\t\t\t\\\n-  (ALLOCNO_MIN (A1) <= ALLOCNO_CONFLICT_ID (A2)\t\t\t\t\\\n-   && ALLOCNO_CONFLICT_ID (A2) <= ALLOCNO_MAX (A1)\t\t\t\\\n-   && TEST_MINMAX_SET_BIT (conflicts[ALLOCNO_NUM (A1)],\t\t\t\\\n-\t\t\t   ALLOCNO_CONFLICT_ID (A2),\t\t\t\\\n-\t\t\t   ALLOCNO_MIN (A1),\t\t\t\t\\\n-\t\t\t   ALLOCNO_MAX (A1)))\n+/* Macro to test a conflict of C1 and C2 in `conflicts'.  */\n+#define OBJECTS_CONFLICT_P(C1, C2)\t\t\t\t\\\n+  (OBJECT_MIN (C1) <= OBJECT_CONFLICT_ID (C2)\t\t\t\t\\\n+   && OBJECT_CONFLICT_ID (C2) <= OBJECT_MAX (C1)\t\t\t\\\n+   && TEST_MINMAX_SET_BIT (conflicts[OBJECT_CONFLICT_ID (C1)],\t\t\\\n+\t\t\t   OBJECT_CONFLICT_ID (C2),\t\t\t\\\n+\t\t\t   OBJECT_MIN (C1), OBJECT_MAX (C1)))\n \n \f\n-\n /* Build allocno conflict table by processing allocno live ranges.\n    Return true if the table was built.  The table is not built if it\n    is too big.  */\n static bool\n build_conflict_bit_table (void)\n {\n-  int i, num, id, allocated_words_num, conflict_bit_vec_words_num;\n+  int i;\n   unsigned int j;\n   enum reg_class cover_class;\n-  ira_allocno_t allocno, live_a;\n+  int object_set_words, allocated_words_num, conflict_bit_vec_words_num;\n   live_range_t r;\n+  ira_allocno_t allocno;\n   ira_allocno_iterator ai;\n-  sparseset allocnos_live;\n-  int allocno_set_words;\n+  sparseset objects_live;\n \n-  allocno_set_words = (ira_allocnos_num + IRA_INT_BITS - 1) / IRA_INT_BITS;\n   allocated_words_num = 0;\n   FOR_EACH_ALLOCNO (allocno, ai)\n     {\n-      if (ALLOCNO_MAX (allocno) < ALLOCNO_MIN (allocno))\n+      ira_object_t obj = ALLOCNO_OBJECT (allocno);\n+      if (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n \t  continue;\n       conflict_bit_vec_words_num\n-\t= ((ALLOCNO_MAX (allocno) - ALLOCNO_MIN (allocno) + IRA_INT_BITS)\n+\t= ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n \t   / IRA_INT_BITS);\n       allocated_words_num += conflict_bit_vec_words_num;\n       if ((unsigned long long) allocated_words_num * sizeof (IRA_INT_TYPE)\n@@ -98,70 +96,90 @@ build_conflict_bit_table (void)\n \t  return false;\n \t}\n     }\n-  allocnos_live = sparseset_alloc (ira_allocnos_num);\n+\n   conflicts = (IRA_INT_TYPE **) ira_allocate (sizeof (IRA_INT_TYPE *)\n-\t\t\t\t\t      * ira_allocnos_num);\n+\t\t\t\t\t      * ira_objects_num);\n   allocated_words_num = 0;\n   FOR_EACH_ALLOCNO (allocno, ai)\n     {\n-      num = ALLOCNO_NUM (allocno);\n-      if (ALLOCNO_MAX (allocno) < ALLOCNO_MIN (allocno))\n+      ira_object_t obj = ALLOCNO_OBJECT (allocno);\n+      int id = OBJECT_CONFLICT_ID (obj);\n+      if (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n \t{\n-\t  conflicts[num] = NULL;\n+\t  conflicts[id] = NULL;\n \t  continue;\n \t}\n       conflict_bit_vec_words_num\n-\t= ((ALLOCNO_MAX (allocno) - ALLOCNO_MIN (allocno) + IRA_INT_BITS)\n+\t= ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n \t   / IRA_INT_BITS);\n       allocated_words_num += conflict_bit_vec_words_num;\n-      conflicts[num]\n+      conflicts[id]\n \t= (IRA_INT_TYPE *) ira_allocate (sizeof (IRA_INT_TYPE)\n \t\t\t\t\t * conflict_bit_vec_words_num);\n-      memset (conflicts[num], 0,\n+      memset (conflicts[id], 0,\n \t      sizeof (IRA_INT_TYPE) * conflict_bit_vec_words_num);\n     }\n+\n+  object_set_words = (ira_objects_num + IRA_INT_BITS - 1) / IRA_INT_BITS;\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     fprintf\n       (ira_dump_file,\n        \"+++Allocating %ld bytes for conflict table (uncompressed size %ld)\\n\",\n        (long) allocated_words_num * sizeof (IRA_INT_TYPE),\n-       (long) allocno_set_words * ira_allocnos_num * sizeof (IRA_INT_TYPE));\n+       (long) object_set_words * ira_objects_num * sizeof (IRA_INT_TYPE));\n+\n+  objects_live = sparseset_alloc (ira_objects_num);\n   for (i = 0; i < ira_max_point; i++)\n     {\n       for (r = ira_start_point_ranges[i]; r != NULL; r = r->start_next)\n \t{\n-\t  allocno = r->allocno;\n-\t  num = ALLOCNO_NUM (allocno);\n-\t  id = ALLOCNO_CONFLICT_ID (allocno);\n+\t  ira_allocno_t allocno = r->allocno;\n+\t  ira_object_t obj = ALLOCNO_OBJECT (allocno);\n+\t  int id = OBJECT_CONFLICT_ID (obj);\n+\n \t  cover_class = ALLOCNO_COVER_CLASS (allocno);\n-\t  sparseset_set_bit (allocnos_live, num);\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n+\t  sparseset_set_bit (objects_live, id);\n+\t  EXECUTE_IF_SET_IN_SPARSESET (objects_live, j)\n \t    {\n-\t      live_a = ira_allocnos[j];\n-\t      if (ira_reg_classes_intersect_p\n-\t\t  [cover_class][ALLOCNO_COVER_CLASS (live_a)]\n+\t      ira_object_t live_cr = ira_object_id_map[j];\n+\t      ira_allocno_t live_a = OBJECT_ALLOCNO (live_cr);\n+\t      enum reg_class live_cover_class = ALLOCNO_COVER_CLASS (live_a);\n+\n+\t      if (ira_reg_classes_intersect_p[cover_class][live_cover_class]\n \t\t  /* Don't set up conflict for the allocno with itself.  */\n-\t\t  && num != (int) j)\n+\t\t  && id != (int) j)\n \t\t{\n-\t\t  SET_MINMAX_SET_BIT (conflicts[num],\n-\t\t\t\t      ALLOCNO_CONFLICT_ID (live_a),\n-\t\t\t\t      ALLOCNO_MIN (allocno),\n-\t\t\t\t      ALLOCNO_MAX (allocno));\n+\t\t  SET_MINMAX_SET_BIT (conflicts[id], j,\n+\t\t\t\t      OBJECT_MIN (obj),\n+\t\t\t\t      OBJECT_MAX (obj));\n \t\t  SET_MINMAX_SET_BIT (conflicts[j], id,\n-\t\t\t\t      ALLOCNO_MIN (live_a),\n-\t\t\t\t      ALLOCNO_MAX (live_a));\n+\t\t\t\t      OBJECT_MIN (live_cr),\n+\t\t\t\t      OBJECT_MAX (live_cr));\n \t\t}\n \t    }\n \t}\n \n       for (r = ira_finish_point_ranges[i]; r != NULL; r = r->finish_next)\n-\tsparseset_clear_bit (allocnos_live, ALLOCNO_NUM (r->allocno));\n+\t{\n+\t  ira_allocno_t allocno = r->allocno;\n+\t  ira_object_t obj = ALLOCNO_OBJECT (allocno);\n+\t  sparseset_clear_bit (objects_live, OBJECT_CONFLICT_ID (obj));\n+\t}\n     }\n-  sparseset_free (allocnos_live);\n+  sparseset_free (objects_live);\n   return true;\n }\n-\n \f\n+/* Return true iff allocnos A1 and A2 cannot be allocated to the same\n+   register due to conflicts.  */\n+\n+static bool\n+allocnos_conflict_p (ira_allocno_t a1, ira_allocno_t a2)\n+{\n+  ira_object_t obj1 = ALLOCNO_OBJECT (a1);\n+  ira_object_t obj2 = ALLOCNO_OBJECT (a2);\n+  return OBJECTS_CONFLICT_P (obj1, obj2);\n+}\n \n /* Return TRUE if the operand constraint STR is commutative.  */\n static bool\n@@ -366,19 +384,21 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n       allocno_preferenced_hard_regno = REGNO (reg2) + offset2 - offset1;\n       a = ira_curr_regno_allocno_map[REGNO (reg1)];\n     }\n-  else if (!CONFLICT_ALLOCNO_P (ira_curr_regno_allocno_map[REGNO (reg1)],\n-\t\t\t\tira_curr_regno_allocno_map[REGNO (reg2)])\n-\t   && offset1 == offset2)\n+  else\n     {\n-      cp = ira_add_allocno_copy (ira_curr_regno_allocno_map[REGNO (reg1)],\n-\t\t\t\t ira_curr_regno_allocno_map[REGNO (reg2)],\n-\t\t\t\t freq, constraint_p, insn,\n-\t\t\t\t ira_curr_loop_tree_node);\n-      bitmap_set_bit (ira_curr_loop_tree_node->local_copies, cp->num);\n-      return true;\n+      ira_allocno_t a1 = ira_curr_regno_allocno_map[REGNO (reg1)];\n+      ira_allocno_t a2 = ira_curr_regno_allocno_map[REGNO (reg2)];\n+      if (!allocnos_conflict_p (a1, a2) && offset1 == offset2)\n+\t{\n+\t  cp = ira_add_allocno_copy (a1, a2, freq, constraint_p, insn,\n+\t\t\t\t     ira_curr_loop_tree_node);\n+\t  bitmap_set_bit (ira_curr_loop_tree_node->local_copies, cp->num);\n+\t  return true;\n+\t}\n+      else\n+\treturn false;\n     }\n-  else\n-    return false;\n+\n   if (! IN_RANGE (allocno_preferenced_hard_regno, 0, FIRST_PSEUDO_REGISTER - 1))\n     /* Can not be tied.  */\n     return false;\n@@ -448,7 +468,7 @@ add_insn_allocno_copies (rtx insn)\n   const char *str;\n   bool commut_p, bound_p[MAX_RECOG_OPERANDS];\n   int i, j, n, freq;\n-  \n+\n   freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n   if (freq == 0)\n     freq = 1;\n@@ -541,14 +561,14 @@ propagate_copies (void)\n       parent_a1 = ira_parent_or_cap_allocno (a1);\n       parent_a2 = ira_parent_or_cap_allocno (a2);\n       ira_assert (parent_a1 != NULL && parent_a2 != NULL);\n-      if (! CONFLICT_ALLOCNO_P (parent_a1, parent_a2))\n+      if (! allocnos_conflict_p (parent_a1, parent_a2))\n \tira_add_allocno_copy (parent_a1, parent_a2, cp->freq,\n \t\t\t      cp->constraint_p, cp->insn, cp->loop_tree_node);\n     }\n }\n \n /* Array used to collect all conflict allocnos for given allocno.  */\n-static ira_allocno_t *collected_conflict_allocnos;\n+static ira_object_t *collected_conflict_objects;\n \n /* Build conflict vectors or bit conflict vectors (whatever is more\n    profitable) for allocno A from the conflict table and propagate the\n@@ -558,50 +578,56 @@ build_allocno_conflicts (ira_allocno_t a)\n {\n   int i, px, parent_num;\n   int conflict_bit_vec_words_num;\n-  ira_allocno_t parent_a, another_a, another_parent_a;\n-  ira_allocno_t *vec;\n+  ira_allocno_t parent_a, another_parent_a;\n+  ira_object_t *vec;\n   IRA_INT_TYPE *allocno_conflicts;\n+  ira_object_t obj, parent_obj;\n   minmax_set_iterator asi;\n \n-  allocno_conflicts = conflicts[ALLOCNO_NUM (a)];\n+  obj = ALLOCNO_OBJECT (a);\n+  allocno_conflicts = conflicts[OBJECT_CONFLICT_ID (obj)];\n   px = 0;\n   FOR_EACH_BIT_IN_MINMAX_SET (allocno_conflicts,\n-\t\t\t      ALLOCNO_MIN (a), ALLOCNO_MAX (a), i, asi)\n+\t\t\t      OBJECT_MIN (obj), OBJECT_MAX (obj), i, asi)\n     {\n-      another_a = ira_conflict_id_allocno_map[i];\n+      ira_object_t another_obj = ira_object_id_map[i];\n+      ira_allocno_t another_a = OBJECT_ALLOCNO (obj);\n       ira_assert (ira_reg_classes_intersect_p\n \t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n-      collected_conflict_allocnos[px++] = another_a;\n+      collected_conflict_objects[px++] = another_obj;\n     }\n-  if (ira_conflict_vector_profitable_p (a, px))\n+  if (ira_conflict_vector_profitable_p (obj, px))\n     {\n-      ira_allocate_allocno_conflict_vec (a, px);\n-      vec = (ira_allocno_t*) ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a);\n-      memcpy (vec, collected_conflict_allocnos, sizeof (ira_allocno_t) * px);\n+      ira_allocate_conflict_vec (obj, px);\n+      vec = OBJECT_CONFLICT_VEC (obj);\n+      memcpy (vec, collected_conflict_objects, sizeof (ira_object_t) * px);\n       vec[px] = NULL;\n-      ALLOCNO_CONFLICT_ALLOCNOS_NUM (a) = px;\n+      OBJECT_NUM_CONFLICTS (obj) = px;\n     }\n   else\n     {\n-      ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) = conflicts[ALLOCNO_NUM (a)];\n-      if (ALLOCNO_MAX (a) < ALLOCNO_MIN (a))\n+      OBJECT_CONFLICT_ARRAY (obj) = allocno_conflicts;\n+      if (OBJECT_MAX (obj) < OBJECT_MIN (obj))\n \tconflict_bit_vec_words_num = 0;\n       else\n \tconflict_bit_vec_words_num\n-\t  = ((ALLOCNO_MAX (a) - ALLOCNO_MIN (a) + IRA_INT_BITS)\n+\t  = ((OBJECT_MAX (obj) - OBJECT_MIN (obj) + IRA_INT_BITS)\n \t     / IRA_INT_BITS);\n-      ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE (a)\n+      OBJECT_CONFLICT_ARRAY_SIZE (obj)\n \t= conflict_bit_vec_words_num * sizeof (IRA_INT_TYPE);\n     }\n   parent_a = ira_parent_or_cap_allocno (a);\n   if (parent_a == NULL)\n     return;\n   ira_assert (ALLOCNO_COVER_CLASS (a) == ALLOCNO_COVER_CLASS (parent_a));\n-  parent_num = ALLOCNO_NUM (parent_a);\n+  parent_obj = ALLOCNO_OBJECT (parent_a);\n+  parent_num = OBJECT_CONFLICT_ID (parent_obj);\n   FOR_EACH_BIT_IN_MINMAX_SET (allocno_conflicts,\n-\t\t\t      ALLOCNO_MIN (a), ALLOCNO_MAX (a), i, asi)\n+\t\t\t      OBJECT_MIN (obj), OBJECT_MAX (obj), i, asi)\n     {\n-      another_a = ira_conflict_id_allocno_map[i];\n+      ira_object_t another_obj = ira_object_id_map[i];\n+      ira_allocno_t another_a = OBJECT_ALLOCNO (another_obj);\n+\n       ira_assert (ira_reg_classes_intersect_p\n \t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n       another_parent_a = ira_parent_or_cap_allocno (another_a);\n@@ -611,9 +637,9 @@ build_allocno_conflicts (ira_allocno_t a)\n       ira_assert (ALLOCNO_COVER_CLASS (another_a)\n \t\t  == ALLOCNO_COVER_CLASS (another_parent_a));\n       SET_MINMAX_SET_BIT (conflicts[parent_num],\n-\t\t\t  ALLOCNO_CONFLICT_ID (another_parent_a),\n-\t\t\t  ALLOCNO_MIN (parent_a),\n-\t\t\t  ALLOCNO_MAX (parent_a));\n+\t\t\t  OBJECT_CONFLICT_ID (ALLOCNO_OBJECT (another_parent_a)),\n+\t\t\t  OBJECT_MIN (parent_obj),\n+\t\t\t  OBJECT_MAX (parent_obj));\n     }\n }\n \n@@ -625,9 +651,9 @@ build_conflicts (void)\n   int i;\n   ira_allocno_t a, cap;\n \n-  collected_conflict_allocnos\n-    = (ira_allocno_t *) ira_allocate (sizeof (ira_allocno_t)\n-\t\t\t\t      * ira_allocnos_num);\n+  collected_conflict_objects\n+    = (ira_object_t *) ira_allocate (sizeof (ira_object_t)\n+\t\t\t\t\t  * ira_objects_num);\n   for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n     for (a = ira_regno_allocno_map[i];\n \t a != NULL;\n@@ -637,7 +663,7 @@ build_conflicts (void)\n \tfor (cap = ALLOCNO_CAP (a); cap != NULL; cap = ALLOCNO_CAP (cap))\n \t  build_allocno_conflicts (cap);\n       }\n-  ira_free (collected_conflict_allocnos);\n+  ira_free (collected_conflict_objects);\n }\n \n \f\n@@ -675,6 +701,7 @@ static void\n print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n {\n   HARD_REG_SET conflicting_hard_regs;\n+  ira_object_t obj;\n   ira_allocno_t conflict_a;\n   ira_allocno_conflict_iterator aci;\n   basic_block bb;\n@@ -690,8 +717,10 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n         fprintf (file, \"l%d\", ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n       putc (')', file);\n     }\n+\n   fputs (\" conflicts:\", file);\n-  if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) != NULL)\n+  obj = ALLOCNO_OBJECT (a);\n+  if (OBJECT_CONFLICT_ARRAY (obj) != NULL)\n     FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n       {\n         if (reg_p)\n@@ -707,15 +736,15 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n \t\t       ALLOCNO_LOOP_TREE_NODE (conflict_a)->loop->num);\n \t  }\n       }\n-  COPY_HARD_REG_SET (conflicting_hard_regs,\n-\t\t     ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+\n+  COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n   AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n   AND_HARD_REG_SET (conflicting_hard_regs,\n \t\t    reg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n   print_hard_reg_set (file, \"\\n;;     total conflict hard regs:\",\n \t\t      conflicting_hard_regs);\n-  COPY_HARD_REG_SET (conflicting_hard_regs,\n-\t\t     ALLOCNO_CONFLICT_HARD_REGS (a));\n+\n+  COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_CONFLICT_HARD_REGS (obj));\n   AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n   AND_HARD_REG_SET (conflicting_hard_regs,\n \t\t    reg_class_contents[ALLOCNO_COVER_CLASS (a)]);\n@@ -760,19 +789,22 @@ ira_build_conflicts (void)\n       ira_conflicts_p = build_conflict_bit_table ();\n       if (ira_conflicts_p)\n \t{\n+\t  ira_object_t obj;\n+\t  ira_object_iterator oi;\n+\n \t  build_conflicts ();\n \t  ira_traverse_loop_tree (true, ira_loop_tree_root, NULL, add_copies);\n \t  /* We need finished conflict table for the subsequent call.  */\n \t  if (flag_ira_region == IRA_REGION_ALL\n \t      || flag_ira_region == IRA_REGION_MIXED)\n \t    propagate_copies ();\n+\n \t  /* Now we can free memory for the conflict table (see function\n \t     build_allocno_conflicts for details).  */\n-\t  FOR_EACH_ALLOCNO (a, ai)\n+\t  FOR_EACH_OBJECT (obj, oi)\n \t    {\n-\t      if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a)\n-\t\t  != conflicts[ALLOCNO_NUM (a)])\n-\t\tira_free (conflicts[ALLOCNO_NUM (a)]);\n+\t      if (OBJECT_CONFLICT_ARRAY (obj) != conflicts[OBJECT_CONFLICT_ID (obj)])\n+\t\tira_free (conflicts[OBJECT_CONFLICT_ID (obj)]);\n \t    }\n \t  ira_free (conflicts);\n \t}\n@@ -788,6 +820,7 @@ ira_build_conflicts (void)\n     }\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n+      ira_object_t obj = ALLOCNO_OBJECT (a);\n       reg_attrs *attrs;\n       tree decl;\n \n@@ -800,21 +833,16 @@ ira_build_conflicts (void)\n \t      && VAR_OR_FUNCTION_DECL_P (decl)\n \t      && ! DECL_ARTIFICIAL (decl)))\n \t{\n-\t  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n-\t\t\t    call_used_reg_set);\n-\t  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n-\t\t\t    call_used_reg_set);\n+\t  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), call_used_reg_set);\n+\t  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), call_used_reg_set);\n \t}\n       else if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \t{\n-\t  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n-\t\t\t    no_caller_save_reg_set);\n-\t  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n-\t\t\t    temp_hard_reg_set);\n-\t  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n \t\t\t    no_caller_save_reg_set);\n-\t  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n-\t\t\t    temp_hard_reg_set);\n+\t  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), temp_hard_reg_set);\n+\t  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), no_caller_save_reg_set);\n+\t  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), temp_hard_reg_set);\n \t}\n     }\n   if (optimize && ira_conflicts_p"}, {"sha": "b5bfb8ccce2315ac5a87f0e55046eee008f0e8c8", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -646,7 +646,7 @@ static move_t\n modify_move_list (move_t list)\n {\n   int i, n, nregs, hard_regno;\n-  ira_allocno_t to, from, new_allocno;\n+  ira_allocno_t to, from;\n   move_t move, new_move, set_move, first, last;\n \n   if (list == NULL)\n@@ -715,6 +715,9 @@ modify_move_list (move_t list)\n \t\t&& ALLOCNO_HARD_REGNO\n \t\t   (hard_regno_last_set[hard_regno + i]->to) >= 0)\n \t      {\n+\t\tira_allocno_t new_allocno;\n+\t\tira_object_t new_obj;\n+\n \t\tset_move = hard_regno_last_set[hard_regno + i];\n \t\t/* It does not matter what loop_tree_node (of TO or\n \t\t   FROM) to use for the new allocno because of\n@@ -726,16 +729,19 @@ modify_move_list (move_t list)\n \t\tALLOCNO_MODE (new_allocno) = ALLOCNO_MODE (set_move->to);\n \t\tira_set_allocno_cover_class\n \t\t  (new_allocno, ALLOCNO_COVER_CLASS (set_move->to));\n+\t\tira_create_allocno_object (new_allocno);\n \t\tALLOCNO_ASSIGNED_P (new_allocno) = true;\n \t\tALLOCNO_HARD_REGNO (new_allocno) = -1;\n \t\tALLOCNO_REG (new_allocno)\n \t\t  = create_new_reg (ALLOCNO_REG (set_move->to));\n-\t\tALLOCNO_CONFLICT_ID (new_allocno) = ALLOCNO_NUM (new_allocno);\n+\n+\t\tnew_obj = ALLOCNO_OBJECT (new_allocno);\n+\n \t\t/* Make it possibly conflicting with all earlier\n \t\t   created allocnos.  Cases where temporary allocnos\n \t\t   created to remove the cycles are quite rare.  */\n-\t\tALLOCNO_MIN (new_allocno) = 0;\n-\t\tALLOCNO_MAX (new_allocno) = ira_allocnos_num - 1;\n+\t\tOBJECT_MIN (new_obj) = 0;\n+\t\tOBJECT_MAX (new_obj) = ira_objects_num - 1;\n \t\tnew_move = create_move (set_move->to, new_allocno);\n \t\tset_move->to = new_allocno;\n \t\tVEC_safe_push (move_t, heap, move_vec, new_move);\n@@ -911,7 +917,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n   int start, n;\n   unsigned int regno;\n   move_t move;\n-  ira_allocno_t to, from, a;\n+  ira_allocno_t a;\n   ira_copy_t cp;\n   live_range_t r;\n   bitmap_iterator bi;\n@@ -929,22 +935,23 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n   start = ira_max_point;\n   for (move = list; move != NULL; move = move->next)\n     {\n-      from = move->from;\n-      to = move->to;\n-      if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (to) == NULL)\n+      ira_allocno_t from = move->from;\n+      ira_allocno_t to = move->to;\n+      ira_object_t from_obj = ALLOCNO_OBJECT (from);\n+      ira_object_t to_obj = ALLOCNO_OBJECT (to);\n+      if (OBJECT_CONFLICT_ARRAY (to_obj) == NULL)\n \t{\n \t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \t    fprintf (ira_dump_file, \"    Allocate conflicts for a%dr%d\\n\",\n \t\t     ALLOCNO_NUM (to), REGNO (ALLOCNO_REG (to)));\n-\t  ira_allocate_allocno_conflicts (to, n);\n+\t  ira_allocate_object_conflicts (to_obj, n);\n \t}\n       bitmap_clear_bit (live_through, ALLOCNO_REGNO (from));\n       bitmap_clear_bit (live_through, ALLOCNO_REGNO (to));\n-      IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (from), hard_regs_live);\n-      IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (to), hard_regs_live);\n-      IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (from),\n-\t\t\thard_regs_live);\n-      IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (to), hard_regs_live);\n+      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (from_obj), hard_regs_live);\n+      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (to_obj), hard_regs_live);\n+      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (from_obj), hard_regs_live);\n+      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (to_obj), hard_regs_live);\n       update_costs (from, true, freq);\n       update_costs (to, false, freq);\n       cp = ira_add_allocno_copy (from, to, freq, false, move->insn, NULL);\n@@ -994,6 +1001,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n     }\n   EXECUTE_IF_SET_IN_BITMAP (live_through, FIRST_PSEUDO_REGISTER, regno, bi)\n     {\n+      ira_allocno_t to;\n       a = node->regno_allocno_map[regno];\n       if ((to = ALLOCNO_MEM_OPTIMIZED_DEST (a)) != NULL)\n \ta = to;"}, {"sha": "5cabf9ee10449fb1fe0eed6551a74220b8a7ab42", "filename": "gcc/ira-int.h", "status": "modified", "additions": 126, "deletions": 77, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -62,10 +62,13 @@ extern FILE *ira_dump_file;\n typedef struct live_range *live_range_t;\n typedef struct ira_allocno *ira_allocno_t;\n typedef struct ira_allocno_copy *ira_copy_t;\n+typedef struct ira_object *ira_object_t;\n \n /* Definition of vector of allocnos and copies.  */\n DEF_VEC_P(ira_allocno_t);\n DEF_VEC_ALLOC_P(ira_allocno_t, heap);\n+DEF_VEC_P(ira_object_t);\n+DEF_VEC_ALLOC_P(ira_object_t, heap);\n DEF_VEC_P(ira_copy_t);\n DEF_VEC_ALLOC_P(ira_copy_t, heap);\n \n@@ -222,6 +225,43 @@ extern int ira_max_point;\n    live ranges with given start/finish point.  */\n extern live_range_t *ira_start_point_ranges, *ira_finish_point_ranges;\n \n+/* A structure representing conflict information for an allocno\n+   (or one of its subwords).  */\n+struct ira_object\n+{\n+  /* The allocno associated with this record.  */\n+  ira_allocno_t allocno;\n+  /* Vector of accumulated conflicting conflict_redords with NULL end\n+     marker (if OBJECT_CONFLICT_VEC_P is true) or conflict bit vector\n+     otherwise.  Only objects belonging to allocnos with the\n+     same cover class are in the vector or in the bit vector.  */\n+  void *conflicts_array;\n+  /* Allocated size of the previous array.  */\n+  unsigned int conflicts_array_size;\n+  /* A unique number for every instance of this structure which is used\n+     to represent it in conflict bit vectors.  */\n+  int id;\n+  /* Before building conflicts, MIN and MAX are initialized to\n+     correspondingly minimal and maximal points of the accumulated\n+     allocno live ranges.  Afterwards, they hold the minimal and\n+     maximal ids of other objects that this one can conflict\n+     with.  */\n+  int min, max;\n+  /* Initial and accumulated hard registers conflicting with this\n+     conflict record and as a consequences can not be assigned to the\n+     allocno.  All non-allocatable hard regs and hard regs of cover\n+     classes different from given allocno one are included in the\n+     sets.  */\n+  HARD_REG_SET conflict_hard_regs, total_conflict_hard_regs;\n+  /* Number of accumulated conflicts in the vector of conflicting\n+     conflict records.  */\n+  int num_accumulated_conflicts;\n+  /* TRUE if conflicts are represented by a vector of pointers to\n+     ira_object structures.  Otherwise, we use a bit vector indexed\n+     by conflict ID numbers.  */\n+  unsigned int conflict_vec_p : 1;\n+};\n+\n /* A structure representing an allocno (allocation entity).  Allocno\n    represents a pseudo-register in an allocation region.  If\n    pseudo-register does not live in a region but it lives in the\n@@ -306,30 +346,9 @@ struct ira_allocno\n      ranges in the list are not intersected and ordered by decreasing\n      their program points*.  */\n   live_range_t live_ranges;\n-  /* Before building conflicts the two member values are\n-     correspondingly minimal and maximal points of the accumulated\n-     allocno live ranges.  After building conflicts the values are\n-     correspondingly minimal and maximal conflict ids of allocnos with\n-     which given allocno can conflict.  */\n-  int min, max;\n-  /* Vector of accumulated conflicting allocnos with NULL end marker\n-     (if CONFLICT_VEC_P is true) or conflict bit vector otherwise.\n-     Only allocnos with the same cover class are in the vector or in\n-     the bit vector.  */\n-  void *conflict_allocno_array;\n-  /* The unique member value represents given allocno in conflict bit\n-     vectors.  */\n-  int conflict_id;\n-  /* Allocated size of the previous array.  */\n-  unsigned int conflict_allocno_array_size;\n-  /* Initial and accumulated hard registers conflicting with this\n-     allocno and as a consequences can not be assigned to the allocno.\n-     All non-allocatable hard regs and hard regs of cover classes\n-     different from given allocno one are included in the sets.  */\n-  HARD_REG_SET conflict_hard_regs, total_conflict_hard_regs;\n-  /* Number of accumulated conflicts in the vector of conflicting\n-     allocnos.  */\n-  int conflict_allocnos_num;\n+  /* Pointer to a structure describing conflict information about this\n+     allocno.  */\n+  ira_object_t object;\n   /* Accumulated frequency of calls which given allocno\n      intersects.  */\n   int call_freq;\n@@ -374,11 +393,6 @@ struct ira_allocno\n   /* TRUE if the allocno was removed from the splay tree used to\n      choose allocn for spilling (see ira-color.c::.  */\n   unsigned int splay_removed_p : 1;\n-  /* TRUE if conflicts for given allocno are represented by vector of\n-     pointers to the conflicting allocnos.  Otherwise, we use a bit\n-     vector where a bit with given index represents allocno with the\n-     same number.  */\n-  unsigned int conflict_vec_p : 1;\n   /* Non NULL if we remove restoring value from given allocno to\n      MEM_OPTIMIZED_DEST at loop exit (see ira-emit.c) because the\n      allocno value is not changed inside the loop.  */\n@@ -429,13 +443,6 @@ struct ira_allocno\n #define ALLOCNO_LOOP_TREE_NODE(A) ((A)->loop_tree_node)\n #define ALLOCNO_CAP(A) ((A)->cap)\n #define ALLOCNO_CAP_MEMBER(A) ((A)->cap_member)\n-#define ALLOCNO_CONFLICT_ALLOCNO_ARRAY(A) ((A)->conflict_allocno_array)\n-#define ALLOCNO_CONFLICT_ALLOCNO_ARRAY_SIZE(A) \\\n-  ((A)->conflict_allocno_array_size)\n-#define ALLOCNO_CONFLICT_ALLOCNOS_NUM(A) \\\n-  ((A)->conflict_allocnos_num)\n-#define ALLOCNO_CONFLICT_HARD_REGS(A) ((A)->conflict_hard_regs)\n-#define ALLOCNO_TOTAL_CONFLICT_HARD_REGS(A) ((A)->total_conflict_hard_regs)\n #define ALLOCNO_NREFS(A) ((A)->nrefs)\n #define ALLOCNO_FREQ(A) ((A)->freq)\n #define ALLOCNO_HARD_REGNO(A) ((A)->hard_regno)\n@@ -455,7 +462,6 @@ struct ira_allocno\n #define ALLOCNO_ASSIGNED_P(A) ((A)->assigned_p)\n #define ALLOCNO_MAY_BE_SPILLED_P(A) ((A)->may_be_spilled_p)\n #define ALLOCNO_SPLAY_REMOVED_P(A) ((A)->splay_removed_p)\n-#define ALLOCNO_CONFLICT_VEC_P(A) ((A)->conflict_vec_p)\n #define ALLOCNO_MODE(A) ((A)->mode)\n #define ALLOCNO_COPIES(A) ((A)->allocno_copies)\n #define ALLOCNO_HARD_REG_COSTS(A) ((A)->hard_reg_costs)\n@@ -478,9 +484,20 @@ struct ira_allocno\n #define ALLOCNO_FIRST_COALESCED_ALLOCNO(A) ((A)->first_coalesced_allocno)\n #define ALLOCNO_NEXT_COALESCED_ALLOCNO(A) ((A)->next_coalesced_allocno)\n #define ALLOCNO_LIVE_RANGES(A) ((A)->live_ranges)\n-#define ALLOCNO_MIN(A) ((A)->min)\n-#define ALLOCNO_MAX(A) ((A)->max)\n-#define ALLOCNO_CONFLICT_ID(A) ((A)->conflict_id)\n+#define ALLOCNO_OBJECT(A) ((A)->object)\n+\n+#define OBJECT_ALLOCNO(C) ((C)->allocno)\n+#define OBJECT_CONFLICT_ARRAY(C) ((C)->conflicts_array)\n+#define OBJECT_CONFLICT_VEC(C) ((ira_object_t *)(C)->conflicts_array)\n+#define OBJECT_CONFLICT_BITVEC(C) ((IRA_INT_TYPE *)(C)->conflicts_array)\n+#define OBJECT_CONFLICT_ARRAY_SIZE(C) ((C)->conflicts_array_size)\n+#define OBJECT_CONFLICT_VEC_P(C) ((C)->conflict_vec_p)\n+#define OBJECT_NUM_CONFLICTS(C) ((C)->num_accumulated_conflicts)\n+#define OBJECT_CONFLICT_HARD_REGS(C) ((C)->conflict_hard_regs)\n+#define OBJECT_TOTAL_CONFLICT_HARD_REGS(C) ((C)->total_conflict_hard_regs)\n+#define OBJECT_MIN(C) ((C)->min)\n+#define OBJECT_MAX(C) ((C)->max)\n+#define OBJECT_CONFLICT_ID(C) ((C)->id)\n \n /* Map regno -> allocnos with given regno (see comments for\n    allocno member `next_regno_allocno').  */\n@@ -491,12 +508,14 @@ extern ira_allocno_t *ira_regno_allocno_map;\n    have NULL element value.  */\n extern ira_allocno_t *ira_allocnos;\n \n-/* Sizes of the previous array.  */\n+/* The size of the previous array.  */\n extern int ira_allocnos_num;\n \n-/* Map conflict id -> allocno with given conflict id (see comments for\n-   allocno member `conflict_id').  */\n-extern ira_allocno_t *ira_conflict_id_allocno_map;\n+/* Map a conflict id to its corresponding ira_object structure.  */\n+extern ira_object_t *ira_object_id_map;\n+\n+/* The size of the previous array.  */\n+extern int ira_objects_num;\n \n /* The following structure represents a copy of two allocnos.  The\n    copies represent move insns or potential move insns usually because\n@@ -910,11 +929,11 @@ extern void ira_traverse_loop_tree (bool, ira_loop_tree_node_t,\n extern ira_allocno_t ira_parent_allocno (ira_allocno_t);\n extern ira_allocno_t ira_parent_or_cap_allocno (ira_allocno_t);\n extern ira_allocno_t ira_create_allocno (int, bool, ira_loop_tree_node_t);\n+extern void ira_create_allocno_object (ira_allocno_t);\n extern void ira_set_allocno_cover_class (ira_allocno_t, enum reg_class);\n-extern bool ira_conflict_vector_profitable_p (ira_allocno_t, int);\n-extern void ira_allocate_allocno_conflict_vec (ira_allocno_t, int);\n-extern void ira_allocate_allocno_conflicts (ira_allocno_t, int);\n-extern void ira_add_allocno_conflict (ira_allocno_t, ira_allocno_t);\n+extern bool ira_conflict_vector_profitable_p (ira_object_t, int);\n+extern void ira_allocate_conflict_vec (ira_object_t, int);\n+extern void ira_allocate_object_conflicts (ira_object_t, int);\n extern void ira_print_expanded_allocno (ira_allocno_t);\n extern live_range_t ira_create_allocno_live_range (ira_allocno_t, int, int,\n \t\t\t\t\t\t   live_range_t);\n@@ -1037,8 +1056,43 @@ ira_allocno_iter_cond (ira_allocno_iterator *i, ira_allocno_t *a)\n #define FOR_EACH_ALLOCNO(A, ITER)\t\t\t\\\n   for (ira_allocno_iter_init (&(ITER));\t\t\t\\\n        ira_allocno_iter_cond (&(ITER), &(A));)\n+\f\n+/* The iterator for all objects.  */\n+typedef struct {\n+  /* The number of the current element in IRA_OBJECT_ID_MAP.  */\n+  int n;\n+} ira_object_iterator;\n \n+/* Initialize the iterator I.  */\n+static inline void\n+ira_object_iter_init (ira_object_iterator *i)\n+{\n+  i->n = 0;\n+}\n+\n+/* Return TRUE if we have more objects to visit, in which case *OBJ is\n+   set to the object to be visited.  Otherwise, return FALSE.  */\n+static inline bool\n+ira_object_iter_cond (ira_object_iterator *i, ira_object_t *obj)\n+{\n+  int n;\n \n+  for (n = i->n; n < ira_objects_num; n++)\n+    if (ira_object_id_map[n] != NULL)\n+      {\n+\t*obj = ira_object_id_map[n];\n+\ti->n = n + 1;\n+\treturn true;\n+      }\n+  return false;\n+}\n+\n+/* Loop over all objects.  In each iteration, A is set to the next\n+   conflict.  ITER is an instance of ira_object_iterator used to iterate\n+   the objects.  */\n+#define FOR_EACH_OBJECT(OBJ, ITER)\t\t\t\\\n+  for (ira_object_iter_init (&(ITER));\t\t\t\\\n+       ira_object_iter_cond (&(ITER), &(OBJ));)\n \f\n \n /* The iterator for copies.  */\n@@ -1077,38 +1131,33 @@ ira_copy_iter_cond (ira_copy_iterator *i, ira_copy_t *cp)\n #define FOR_EACH_COPY(C, ITER)\t\t\t\t\\\n   for (ira_copy_iter_init (&(ITER));\t\t\t\\\n        ira_copy_iter_cond (&(ITER), &(C));)\n-\n-\n \f\n-\n /* The iterator for allocno conflicts.  */\n typedef struct {\n-\n-  /* TRUE if the conflicts are represented by vector of allocnos.  */\n-  bool allocno_conflict_vec_p;\n+  /* TRUE if the conflicts are represented by vector of objects.  */\n+  bool conflict_vec_p;\n \n   /* The conflict vector or conflict bit vector.  */\n   void *vec;\n \n   /* The number of the current element in the vector (of type\n-     ira_allocno_t or IRA_INT_TYPE).  */\n+     ira_object_t or IRA_INT_TYPE).  */\n   unsigned int word_num;\n \n   /* The bit vector size.  It is defined only if\n-     ALLOCNO_CONFLICT_VEC_P is FALSE.  */\n+     OBJECT_CONFLICT_VEC_P is FALSE.  */\n   unsigned int size;\n \n   /* The current bit index of bit vector.  It is defined only if\n-     ALLOCNO_CONFLICT_VEC_P is FALSE.  */\n+     OBJECT_CONFLICT_VEC_P is FALSE.  */\n   unsigned int bit_num;\n \n-  /* Allocno conflict id corresponding to the 1st bit of the bit\n-     vector.  It is defined only if ALLOCNO_CONFLICT_VEC_P is\n-     FALSE.  */\n+  /* The object id corresponding to the 1st bit of the bit vector.  It\n+     is defined only if OBJECT_CONFLICT_VEC_P is FALSE.  */\n   int base_conflict_id;\n \n   /* The word of bit vector currently visited.  It is defined only if\n-     ALLOCNO_CONFLICT_VEC_P is FALSE.  */\n+     OBJECT_CONFLICT_VEC_P is FALSE.  */\n   unsigned IRA_INT_TYPE word;\n } ira_allocno_conflict_iterator;\n \n@@ -1117,21 +1166,22 @@ static inline void\n ira_allocno_conflict_iter_init (ira_allocno_conflict_iterator *i,\n \t\t\t\tira_allocno_t allocno)\n {\n-  i->allocno_conflict_vec_p = ALLOCNO_CONFLICT_VEC_P (allocno);\n-  i->vec = ALLOCNO_CONFLICT_ALLOCNO_ARRAY (allocno);\n+  ira_object_t obj = ALLOCNO_OBJECT (allocno);\n+  i->conflict_vec_p = OBJECT_CONFLICT_VEC_P (obj);\n+  i->vec = OBJECT_CONFLICT_ARRAY (obj);\n   i->word_num = 0;\n-  if (i->allocno_conflict_vec_p)\n+  if (i->conflict_vec_p)\n     i->size = i->bit_num = i->base_conflict_id = i->word = 0;\n   else\n     {\n-      if (ALLOCNO_MIN (allocno) > ALLOCNO_MAX (allocno))\n+      if (OBJECT_MIN (obj) > OBJECT_MAX (obj))\n \ti->size = 0;\n       else\n-\ti->size = ((ALLOCNO_MAX (allocno) - ALLOCNO_MIN (allocno)\n+\ti->size = ((OBJECT_MAX (obj) - OBJECT_MIN (obj)\n \t\t    + IRA_INT_BITS)\n \t\t   / IRA_INT_BITS) * sizeof (IRA_INT_TYPE);\n       i->bit_num = 0;\n-      i->base_conflict_id = ALLOCNO_MIN (allocno);\n+      i->base_conflict_id = OBJECT_MIN (obj);\n       i->word = (i->size == 0 ? 0 : ((IRA_INT_TYPE *) i->vec)[0]);\n     }\n }\n@@ -1143,15 +1193,13 @@ static inline bool\n ira_allocno_conflict_iter_cond (ira_allocno_conflict_iterator *i,\n \t\t\t\tira_allocno_t *a)\n {\n-  ira_allocno_t conflict_allocno;\n+  ira_object_t obj;\n \n-  if (i->allocno_conflict_vec_p)\n+  if (i->conflict_vec_p)\n     {\n-      conflict_allocno = ((ira_allocno_t *) i->vec)[i->word_num];\n-      if (conflict_allocno == NULL)\n+      obj = ((ira_object_t *) i->vec)[i->word_num];\n+      if (obj == NULL)\n \treturn false;\n-      *a = conflict_allocno;\n-      return true;\n     }\n   else\n     {\n@@ -1171,17 +1219,18 @@ ira_allocno_conflict_iter_cond (ira_allocno_conflict_iterator *i,\n       for (; (i->word & 1) == 0; i->word >>= 1)\n \ti->bit_num++;\n \n-      *a = ira_conflict_id_allocno_map[i->bit_num + i->base_conflict_id];\n-\n-      return true;\n+      obj = ira_object_id_map[i->bit_num + i->base_conflict_id];\n     }\n+\n+  *a = OBJECT_ALLOCNO (obj);\n+  return true;\n }\n \n /* Advance to the next conflicting allocno.  */\n static inline void\n ira_allocno_conflict_iter_next (ira_allocno_conflict_iterator *i)\n {\n-  if (i->allocno_conflict_vec_p)\n+  if (i->conflict_vec_p)\n     i->word_num++;\n   else\n     {"}, {"sha": "5e37ea462d707c3f347f7849353b7e3f1a7de824", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -92,10 +92,10 @@ make_hard_regno_born (int regno)\n   SET_HARD_REG_BIT (hard_regs_live, regno);\n   EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n     {\n-      SET_HARD_REG_BIT (ALLOCNO_CONFLICT_HARD_REGS (ira_allocnos[i]),\n-\t\t\tregno);\n-      SET_HARD_REG_BIT (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (ira_allocnos[i]),\n-\t\t\tregno);\n+      ira_allocno_t allocno = ira_allocnos[i];\n+      ira_object_t obj = ALLOCNO_OBJECT (allocno);\n+      SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);\n+      SET_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno);\n     }\n }\n \n@@ -114,10 +114,11 @@ static void\n make_allocno_born (ira_allocno_t a)\n {\n   live_range_t p = ALLOCNO_LIVE_RANGES (a);\n+  ira_object_t obj = ALLOCNO_OBJECT (a);\n \n   sparseset_set_bit (allocnos_live, ALLOCNO_NUM (a));\n-  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a), hard_regs_live);\n-  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), hard_regs_live);\n+  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), hard_regs_live);\n+  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), hard_regs_live);\n \n   if (p == NULL\n       || (p->finish != curr_point && p->finish + 1 != curr_point))\n@@ -840,12 +841,14 @@ process_single_reg_class_operands (bool in_p, int freq)\n \t  a = ira_allocnos[px];\n \t  if (a != operand_a)\n \t    {\n+\t      ira_object_t obj = ALLOCNO_OBJECT (a);\n+\n \t      /* We could increase costs of A instead of making it\n \t\t conflicting with the hard register.  But it works worse\n \t\t because it will be spilled in reload in anyway.  */\n-\t      IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n \t\t\t\treg_class_contents[cl]);\n-\t      IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n+\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n \t\t\t\treg_class_contents[cl]);\n \t    }\n \t}\n@@ -1030,14 +1033,16 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t      || find_reg_note (insn, REG_SETJMP,\n \t\t\t\t\tNULL_RTX) != NULL_RTX)\n \t\t    {\n-\t\t      SET_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a));\n-\t\t      SET_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+\t\t      ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t\t      SET_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj));\n+\t\t      SET_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n \t\t    }\n \t\t  if (can_throw_internal (insn))\n \t\t    {\n-\t\t      IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n+\t\t      ira_object_t obj = ALLOCNO_OBJECT (a);\n+\t\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n \t\t\t\t\tcall_used_reg_set);\n-\t\t      IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n \t\t\t\t\tcall_used_reg_set);\n \t\t    }\n \t\t}"}, {"sha": "08a333362c9b068ea401d1c92bc3d798b6ae1531", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a49ae2179409cf9ed7e78e93643ec4891e9ae8fe/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=a49ae2179409cf9ed7e78e93643ec4891e9ae8fe", "patch": "@@ -1243,6 +1243,7 @@ ira_bad_reload_regno_1 (int regno, rtx x)\n {\n   int x_regno;\n   ira_allocno_t a;\n+  ira_object_t obj;\n   enum reg_class pref;\n \n   /* We only deal with pseudo regs.  */\n@@ -1262,7 +1263,8 @@ ira_bad_reload_regno_1 (int regno, rtx x)\n   /* If the pseudo conflicts with REGNO, then we consider REGNO a\n      poor choice for a reload regno.  */\n   a = ira_regno_allocno_map[x_regno];\n-  if (TEST_HARD_REG_BIT (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), regno))\n+  obj = ALLOCNO_OBJECT (a);\n+  if (TEST_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), regno))\n     return true;\n \n   return false;"}]}