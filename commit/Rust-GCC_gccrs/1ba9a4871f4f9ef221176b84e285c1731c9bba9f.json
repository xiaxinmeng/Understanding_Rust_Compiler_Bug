{"sha": "1ba9a4871f4f9ef221176b84e285c1731c9bba9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJhOWE0ODcxZjRmOWVmMjIxMTc2Yjg0ZTI4NWMxNzMxYzliYmE5Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-07T22:26:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-12-07T22:26:06Z"}, "message": "(give_switch): Add new arg, INCLUDE_BLANKS.\n\n(handle_braces): All callers changed.\nAdd support for new construct: %{S*^}.\n\nFrom-SVN: r13223", "tree": {"sha": "29453fa3a326f13934cde39f4e2d40e51571a3eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29453fa3a326f13934cde39f4e2d40e51571a3eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ba9a4871f4f9ef221176b84e285c1731c9bba9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba9a4871f4f9ef221176b84e285c1731c9bba9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ba9a4871f4f9ef221176b84e285c1731c9bba9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba9a4871f4f9ef221176b84e285c1731c9bba9f/comments", "author": null, "committer": null, "parents": [{"sha": "610c62ac70ceda33a0bf569819478e86913db62f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c62ac70ceda33a0bf569819478e86913db62f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610c62ac70ceda33a0bf569819478e86913db62f"}], "stats": {"total": 36, "additions": 28, "deletions": 8}, "files": [{"sha": "3bea4ee48b45d85ea2e04d7b466aa85a5074389d", "filename": "gcc/gcc.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba9a4871f4f9ef221176b84e285c1731c9bba9f/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba9a4871f4f9ef221176b84e285c1731c9bba9f/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=1ba9a4871f4f9ef221176b84e285c1731c9bba9f", "patch": "@@ -253,7 +253,7 @@ static char *find_file\t\tPROTO((char *));\n static int is_directory\t\tPROTO((char *, char *, int));\n static void validate_switches\tPROTO((char *));\n static void validate_all_switches PROTO((void));\n-static void give_switch\t\tPROTO((int, int));\n+static void give_switch\t\tPROTO((int, int, int));\n static int used_arg\t\tPROTO((char *, int));\n static int default_arg\t\tPROTO((char *, int));\n static void set_multilib_dir\tPROTO((void));\n@@ -362,6 +362,7 @@ or with constant text in a single argument.\n \targuments.  CC considers `-o foo' as being one switch whose\n \tname starts with `o'.  %{o*} would substitute this text,\n \tincluding the space; thus, two arguments would be generated.\n+ %{S*^} likewise, but don't put a blank between a switch and any args.\n  %{S*:X} substitutes X if one or more switches whose names start with -S are\n \tspecified to CC.  Note that the tail part of the -S option\n \t(i.e. the part matched by the `*') will be substituted for each\n@@ -3813,7 +3814,19 @@ handle_braces (p)\n       for (i = 0; i < n_switches; i++)\n \tif (!strncmp (switches[i].part1, filter, p - filter)\n \t    && check_live_switch (i, p - filter))\n-\t  give_switch (i, 0);\n+\t  give_switch (i, 0, 1);\n+    }\n+  else if (p[-1] == '*' && p[0] == '^' && p[1] == '}')\n+    {\n+      /* Substitute all matching switches as separate args, but don't\n+\t write a blank between the first part and any args, even if they\n+\t were present.  */\n+      register int i;\n+      --p;\n+      for (i = 0; i < n_switches; i++)\n+\tif (!strncmp (switches[i].part1, filter, p - filter)\n+\t    && check_live_switch (i, p - filter))\n+\t  give_switch (i, 0, 0);\n     }\n   else\n     {\n@@ -3852,7 +3865,7 @@ handle_braces (p)\n \t\t  {\n \t\t    do_spec_1 (string, 0, &switches[i].part1[hard_match_len]);\n \t\t    /* Pass any arguments this switch has.  */\n-\t\t    give_switch (i, 1);\n+\t\t    give_switch (i, 1, 1);\n \t\t  }\n \n \t      return q;\n@@ -3896,7 +3909,7 @@ handle_braces (p)\n \t{\n \t  if (*p == '}')\n \t    {\n-\t      give_switch (i, 0);\n+\t      give_switch (i, 0, 1);\n \t    }\n \t  else\n \t    {\n@@ -3997,28 +4010,35 @@ check_live_switch (switchnum, prefix_length)\n    the vector of switches gcc received, which is `switches'.\n    This cannot fail since it never finishes a command line.\n \n-   If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */\n+   If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.\n+\n+   If INCLUDE_BLANKS is nonzero, then we include blanks before each argument\n+   of the switch.  */\n \n static void\n-give_switch (switchnum, omit_first_word)\n+give_switch (switchnum, omit_first_word, include_blanks)\n      int switchnum;\n      int omit_first_word;\n+     int include_blanks;\n {\n   if (!omit_first_word)\n     {\n       do_spec_1 (\"-\", 0, NULL_PTR);\n       do_spec_1 (switches[switchnum].part1, 1, NULL_PTR);\n     }\n-  do_spec_1 (\" \", 0, NULL_PTR);\n+\n   if (switches[switchnum].args != 0)\n     {\n       char **p;\n       for (p = switches[switchnum].args; *p; p++)\n \t{\n+\t  if (include_blanks)\n+\t    do_spec_1 (\" \", 0, NULL_PTR);\n \t  do_spec_1 (*p, 1, NULL_PTR);\n-\t  do_spec_1 (\" \", 0, NULL_PTR);\n \t}\n     }\n+\n+  do_spec_1 (\" \", 0, NULL_PTR);\n   switches[switchnum].valid = 1;\n }\n \f"}]}