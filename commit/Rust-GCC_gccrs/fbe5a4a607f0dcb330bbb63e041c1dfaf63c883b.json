{"sha": "fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJlNWE0YTYwN2YwZGNiMzMwYmJiNjNlMDQxYzFkZmFmNjNjODgzYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-17T14:24:24Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-17T14:24:24Z"}, "message": "et-forest.c: Fix comment typos.\n\n\t* et-forest.c: Fix comment typos.\n\t* et-forest.h: Likewise.\n\t* except.c: Likewise.\n\t* expr.c: Likewise.\n\t* flags.h: Likewise.\n\t* flow.c: Likewise.\n\t* gcc.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattrtab.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* gengtype.c: Likewise.\n\t* genrecog.c: Likewise.\n\t* global.c: Likewise.\n\t* gthr-rtems.h: Likewise.\n\nFrom-SVN: r61443", "tree": {"sha": "2cb49286c2dc56eb4c87f9c8f6bf3d0ed54ea367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cb49286c2dc56eb4c87f9c8f6bf3d0ed54ea367"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/comments", "author": null, "committer": null, "parents": [{"sha": "095f90933f648fbf24528d7a7aecf76399f3e743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095f90933f648fbf24528d7a7aecf76399f3e743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095f90933f648fbf24528d7a7aecf76399f3e743"}], "stats": {"total": 113, "additions": 65, "deletions": 48}, "files": [{"sha": "6a5d4f5fc018e8fa4f42b47af7714e6e6dcd2a4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -1,3 +1,20 @@\n+2003-01-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* et-forest.c: Fix comment typos.\n+\t* et-forest.h: Likewise.\n+\t* except.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* flags.h: Likewise.\n+\t* flow.c: Likewise.\n+\t* gcc.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattrtab.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* gengtype.c: Likewise.\n+\t* genrecog.c: Likewise.\n+\t* global.c: Likewise.\n+\t* gthr-rtems.h: Likewise.\n+\n 2003-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* i386.c (x86_function_profiler): Fix format specifier."}, {"sha": "b54f3f769b4f24bd076d5482d4bfed011a469613", "filename": "gcc/et-forest.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -105,7 +105,7 @@ find_rightmost_node (occ)\n }\n \n \n-/* Operation splay for splay tree structure representing ocuurences.  */\n+/* Operation splay for splay tree structure representing occurrences.  */\n static et_forest_occurrence_t\n splay (node)\n      et_forest_occurrence_t node;\n@@ -337,7 +337,7 @@ splay (node)\n   return node;\n }\n \n-/* Remove all occurences of the given node before destroying the node.  */\n+/* Remove all occurrences of the given node before destroying the node.  */\n static void\n remove_all_occurrences (forest, forest_node)\n      et_forest_t forest;\n@@ -371,7 +371,7 @@ remove_all_occurrences (forest, forest_node)\n \n       prev_node = splay (find_rightmost_node (first->left));\n       next_node = splay (find_leftmost_node (last->right));\n-      /* prev_node and next_node are consecutive occurencies\n+      /* prev_node and next_node are consecutive occurrences\n \t of the same node.  */\n       if (prev_node->next != next_node)\n \tabort ();\n@@ -487,7 +487,7 @@ et_forest_add_node (forest, value)\n   return node;\n }\n \n-/* Add new edge to the tree, return 1 if succesfull.\n+/* Add new edge to the tree, return 1 if successful.\n    0 indicates that creation of the edge will close the cycle in graph.  */\n int\n et_forest_add_edge (forest, parent_node, child_node)\n@@ -545,7 +545,7 @@ et_forest_remove_node (forest, node)\n   pool_free (forest->node_pool, node);\n }\n \n-/* Remove edge from the tree, return 1 if sucesfull,\n+/* Remove edge from the tree, return 1 if successful,\n    0 indicates nonexisting edge.  */\n int\n et_forest_remove_edge (forest, parent_node, child_node)\n@@ -672,7 +672,7 @@ et_forest_enumerate_sons (forest, node, array)\n   et_forest_occurrence_t occ = node->first, stop = node->last, occ1;\n \n   /* Parent is the rightmost node of the left successor.\n-     Look for all occurences having no right succesor\n+     Look for all occurrences having no right successor\n      and lookup the sons.  */\n   while (occ != stop)\n     {"}, {"sha": "8ef8e30b49438a2cdd0e921edf213af4d1d25cc2", "filename": "gcc/et-forest.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -18,7 +18,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n /* This package implements ET forest data structure. Each tree in \n    the structure maintains a tree structure and offers logarithmic time\n    for tree operations (insertion and removal of nodes and edges) and\n-   poly-logarithmic time for nearest common ancesto.\n+   poly-logarithmic time for nearest common ancestor.\n  \n    ET tree strores its structue as a sequence of symbols obtained \n    by dfs(root)"}, {"sha": "16613c4deeac8f268f2ede33d0d59b56787e383e", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -2693,7 +2693,7 @@ reachable_next_level (region, type_thrown, info)\n       return RNL_MAYBE_CAUGHT;\n \n     case ERT_CATCH:\n-      /* Catch regions are handled by their controling try region.  */\n+      /* Catch regions are handled by their controlling try region.  */\n       return RNL_NOT_CAUGHT;\n \n     case ERT_MUST_NOT_THROW:"}, {"sha": "e3c457943bf735a58d33a526f901d10846cdf896", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -6503,7 +6503,7 @@ expand_expr (exp, target, tmode, modifier)\n \n #ifdef MAX_INTEGER_COMPUTATION_MODE\n   /* Only check stuff here if the mode we want is different from the mode\n-     of the expression; if it's the same, check_max_integer_computiation_mode\n+     of the expression; if it's the same, check_max_integer_computation_mode\n      will handle it.  Do we really need to check this stuff at all?  */\n \n   if (target"}, {"sha": "e7923e8ac1fad32968816fdc3f51300a5322bb27", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -560,7 +560,7 @@ extern int flag_instrument_function_entry_exit;\n /* Perform a peephole pass before sched2.  */\n extern int flag_peephole2;\n \n-/* Try to guess branch probablities.  */\n+/* Try to guess branch probabilities.  */\n extern int flag_guess_branch_prob;\n \n /* -fcheck-bounds causes gcc to generate array bounds checks.\n@@ -676,7 +676,7 @@ extern int flag_signaling_nans;\n   (MODE_HAS_INFINITIES (MODE) && !flag_finite_math_only)\n \n /* Like HONOR_NANS, but true if the given mode distinguishes between\n-   postive and negative zero, and the sign of zero is important.  */\n+   positive and negative zero, and the sign of zero is important.  */\n #define HONOR_SIGNED_ZEROS(MODE) \\\n   (MODE_HAS_SIGNED_ZEROS (MODE) && !flag_unsafe_math_optimizations)\n "}, {"sha": "5e51818de0bd0a2916928a53953651e55633323e", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -274,7 +274,7 @@ struct propagate_block_info\n   /* Nonzero if the value of CC0 is live.  */\n   int cc0_live;\n \n-  /* Flags controling the set of information propagate_block collects.  */\n+  /* Flags controlling the set of information propagate_block collects.  */\n   int flags;\n };\n \n@@ -1680,7 +1680,7 @@ propagate_one_insn (pbi, insn)\n \t    }\n \n \t  /* Similarly if INSN contains a LIBCALL note, remove the\n-\t     dnagling REG_RETVAL note.  */\n+\t     dangling REG_RETVAL note.  */\n \t  note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n \t  if (note)\n \t    {\n@@ -4231,7 +4231,7 @@ dump_regset (r, outf)\n     });\n }\n \n-/* Print a human-reaable representation of R on the standard error\n+/* Print a human-readable representation of R on the standard error\n    stream.  This function is designed to be used from within the\n    debugger.  */\n "}, {"sha": "7c22f925bf85ebefe2461df47f3b1100470d1870", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -2539,7 +2539,7 @@ enum path_prefix_priority\n   PREFIX_PRIORITY_LAST\n };\n \n-/* Add an entry for PREFIX in PLIST.  The PLIST is kept in assending\n+/* Add an entry for PREFIX in PLIST.  The PLIST is kept in ascending\n    order according to PRIORITY.  Within each PRIORITY, new entries are\n    appended.\n \n@@ -2735,7 +2735,7 @@ execute ()\n     }\n \n #ifdef ENABLE_VALGRIND_CHECKING\n-  /* Run the each command through valgrind.  To simplifiy prepending the\n+  /* Run the each command through valgrind.  To simplify prepending the\n      path to valgrind and the option \"-q\" (for quiet operation unless\n      something triggers), we allocate a separate argv array.  */\n "}, {"sha": "3fdf47e97a5b1a4741573065fb50bef63220340b", "filename": "gcc/gcse.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -1260,7 +1260,7 @@ record_set_info (dest, setter, data)\n /* Scan the function and record each set of each pseudo-register.\n \n    This is called once, at the start of the gcse pass.  See the comments for\n-   `reg_set_table' for further documenation.  */\n+   `reg_set_table' for further documentation.  */\n \n static void\n compute_sets (f)\n@@ -1593,7 +1593,7 @@ hash_expr_1 (x, mode, do_not_record_p)\n   const char *fmt;\n \n   /* Used to turn recursion into iteration.  We can't rely on GCC's\n-     tail-recursion eliminatio since we need to keep accumulating values\n+     tail-recursion elimination since we need to keep accumulating values\n      in HASH.  */\n \n   if (x == 0)\n@@ -3952,7 +3952,7 @@ try_replace_reg (from, to, insn)\n \n   /* REG_EQUAL may get simplified into register.\n      We don't allow that. Remove that note. This code ought\n-     not to hapen, because previous code ought to syntetize\n+     not to happen, because previous code ought to synthesize\n      reg-reg move, but be on the safe side.  */\n   if (note && REG_P (XEXP (note, 0)))\n     remove_note (insn, note);\n@@ -4032,7 +4032,7 @@ find_avail_set (regno, insn)\n \n /* Subroutine of cprop_insn that tries to propagate constants into\n    JUMP_INSNS.  JUMP must be a conditional jump.  If SETCC is non-NULL\n-   it is the instruction that immediately preceeds JUMP, and must be a\n+   it is the instruction that immediately precedes JUMP, and must be a\n    single SET of a register.  FROM is what we will try to replace,\n    SRC is the constant we will try to substitute for it.  Returns nonzero\n    if a change was made.  */\n@@ -4292,7 +4292,7 @@ do_local_cprop (x, insn, alter_jumps, libcall_sp)\n       if (newcnst && constprop_register (insn, x, newcnst, alter_jumps))\n \t{\n \t  /* If we find a case where we can't fix the retval REG_EQUAL notes\n-\t     match the new register, we either have to abandom this replacement\n+\t     match the new register, we either have to abandon this replacement\n \t     or fix delete_trivially_dead_insns to preserve the setting insn,\n \t     or make it delete the REG_EUAQL note, and fix up all passes that\n \t     require the REG_EQUAL note there.  */\n@@ -4697,7 +4697,7 @@ bypass_conditional_jumps ()\n     }\n \n   /* If we bypassed any register setting insns, we inserted a\n-     copy on the redirected edge.  These need to be commited.  */\n+     copy on the redirected edge.  These need to be committed.  */\n   if (changed)\n     commit_edge_insertions();\n \n@@ -5039,7 +5039,7 @@ insert_insn_end_bb (expr, bb, pre)\n       /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n \t we search backward and place the instructions before the first\n \t parameter is loaded.  Do this for everyone for consistency and a\n-\t presumtion that we'll get better code elsewhere as well.\n+\t presumption that we'll get better code elsewhere as well.\n \n \t It should always be the case that we can put these instructions\n \t anywhere in the basic block with performing PRE optimizations.\n@@ -5684,7 +5684,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n     }\n \n   /* Now compute global properties based on the local properties.   This\n-     is a classic global availablity algorithm.  */\n+     is a classic global availability algorithm.  */\n   compute_available (nonnull_local, nonnull_killed,\n \t\t     nonnull_avout, nonnull_avin);\n \n@@ -5765,7 +5765,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n    reference of that form, then we know the register can not have the value\n    zero at the conditional branch.\n \n-   So we merely need to compute the local properies and propagate that data\n+   So we merely need to compute the local properties and propagate that data\n    around the cfg, then optimize where possible.\n \n    We run this pass two times.  Once before CSE, then again after CSE.  This\n@@ -6947,7 +6947,7 @@ store_killed_after (x, insn, bb)\n      Note that if registers are changed ANYWHERE in the block, we'll\n      decide we can't move it, regardless of whether it changed above\n      or below the store. This could be improved by checking the register\n-     operands while lookinng for aliasing in each insn.  */\n+     operands while looking for aliasing in each insn.  */\n   if (!store_ops_ok (XEXP (x, 0), bb))\n     return 1;\n \n@@ -6974,7 +6974,7 @@ store_killed_before (x, insn, bb)\n      Note that if registers are changed ANYWHERE in the block, we'll\n      decide we can't move it, regardless of whether it changed above\n      or below the store. This could be improved by checking the register\n-     operands while lookinng for aliasing in each insn.  */\n+     operands while looking for aliasing in each insn.  */\n   if (!store_ops_ok (XEXP (x, 0), bb))\n     return 1;\n \n@@ -7020,7 +7020,7 @@ build_store_vectors ()\n \n \t  if (!store_killed_after (ptr->pattern, insn, bb))\n \t    {\n-\t      /* If we've already seen an availale expression in this block,\n+\t      /* If we've already seen an available expression in this block,\n \t\t we can delete the one we saw already (It occurs earlier in\n \t\t the block), and replace it with this one). We'll copy the\n \t\t old SRC expression to an unused register in case there\n@@ -7084,7 +7084,7 @@ build_store_vectors ()\n \t      Load in the middle here if we push the store down. It happens in\n \t\t    gcc.c-torture/execute/960311-1.c with -O3\n \t      If we always kill it in this case, we'll sometimes do\n-\t      uneccessary work, but it shouldn't actually hurt anything.\n+\t      unnecessary work, but it shouldn't actually hurt anything.\n \t    if (!TEST_BIT (ae_gen[b], ptr->index)).  */\n \t    SET_BIT (ae_kill[b->index], ptr->index);\n \t  }\n@@ -7107,7 +7107,7 @@ build_store_vectors ()\n     }\n }\n \n-/* Insert an instruction at the begining of a basic block, and update\n+/* Insert an instruction at the beginning of a basic block, and update\n    the BLOCK_HEAD if needed.  */\n \n static void"}, {"sha": "b1f04bb5e7a8cec9cdf3c70f768ad8c32b3a142b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -2085,7 +2085,7 @@ expand_units ()\n \t     every possible C.\n \n \t     The issue delay function for C is op->issue_exp and is used to\n-\t     write the `<name>_unit_conflict_cost' function.  Symbolicly\n+\t     write the `<name>_unit_conflict_cost' function.  Symbolically\n \t     this is \"ISSUE-DELAY (E,C)\".\n \n \t     The pipeline delay results form the FIFO constraint on the\n@@ -3198,8 +3198,8 @@ attr_rtx_cost (x)\n \f\n \n /* Simplify test expression and use temporary obstack in order to avoid\n-   memory bloat.  Use ATTR_IND_SIMPLIFIED to avoid unnecesary simplifications\n-   and avoid unnecesary copying if possible.  */\n+   memory bloat.  Use ATTR_IND_SIMPLIFIED to avoid unnecessary simplifications\n+   and avoid unnecessary copying if possible.  */\n \n static rtx\n simplify_test_exp_in_temp (exp, insn_code, insn_index)"}, {"sha": "d3d6a8b38181c90ebf4ed56ad965591e73686866", "filename": "gcc/genautomata.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -39,8 +39,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    following:\n \n    1. New operator `|' (alternative) is permitted in functional unit\n-      reservation which can be treated deterministicly and\n-      non-deterministicly.\n+      reservation which can be treated deterministically and\n+      non-deterministically.\n \n    2. Possibility of usage of nondeterministic automata too.\n \n@@ -1156,7 +1156,7 @@ struct arc\n    of automaton insn or which is part of NDFA.  */\n struct alt_state\n {\n-  /* The following field is a determinist state which characterizes\n+  /* The following field is a deterministic state which characterizes\n      unit reservations of the instruction.  */\n   state_t state;\n   /* The following field refers to the next state which characterizes\n@@ -1212,7 +1212,7 @@ struct ainsn\n   int important_p;\n };\n \n-/* The folowing describes an automaton for PHR.  */\n+/* The following describes an automaton for PHR.  */\n struct automaton\n {\n   /* The following field value is the list of insn declarations for\n@@ -1605,7 +1605,7 @@ next_sep_el (pstr, sep, par_flag)\n \n /* Given a string and a separator, return the number of separated\n    elements in it, taking parentheses into account if PAR_FLAG has\n-   nonzero value.  Return 0 for the null string, -1 if parantheses is\n+   nonzero value.  Return 0 for the null string, -1 if parentheses is\n    not balanced.  */\n static int\n n_sep_els (s, sep, par_flag)\n@@ -4001,7 +4001,7 @@ reserv_sets_are_intersected (operand_1, operand_2)\n \n /* The function sets up RESULT bits by bits of OPERAND shifted on one\n    cpu cycle.  The remaining bits of OPERAND (representing the last\n-   cycle unit reservations) are not chenged.  */\n+   cycle unit reservations) are not changed.  */\n static void\n reserv_sets_shift (result, operand)\n      reserv_sets_t result;\n@@ -5411,7 +5411,7 @@ transform_regexp (regexp)\n   return regexp;\n }\n \n-/* The function applys all transformations for reservations of all\n+/* The function applies all transformations for reservations of all\n    insn declarations.  */\n static void\n transform_insn_regexps ()\n@@ -7205,7 +7205,7 @@ longest_path_length (state)\n        advance' arcs -- see comment below.  */\n     abort ();\n   else if (state->longest_path_length != UNDEFINED_LONGEST_PATH_LENGTH)\n-    /* We alreday visited the state.  */\n+    /* We already visited the state.  */\n     return state->longest_path_length;\n \n   result = 0;\n@@ -8359,7 +8359,7 @@ output_max_insn_queue_index_def ()\n }\n \n \n-/* The function outputs switch cases for insn reseravtions using\n+/* The function outputs switch cases for insn reservations using\n    function *output_automata_list_code.  */\n static void\n output_insn_code_cases (output_automata_list_code)"}, {"sha": "cbaf7ac6d67b2f87769f096dd53049306156955c", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -814,7 +814,7 @@ adjust_field_type (t, opt)\n }\n \n /* Create a union for YYSTYPE, as yacc would do it, given a fieldlist FIELDS\n-   and information about the correspondance between token types and fields\n+   and information about the correspondence between token types and fields\n    in TYPEINFO.  POS is used for error messages.  */\n \n void"}, {"sha": "baf8c7fffbc714a0ecbfe7c20a5df06bf89a62b3", "filename": "gcc/genrecog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -67,7 +67,7 @@ static char **insn_name_ptr = 0;\n static int insn_name_ptr_size = 0;\n \n /* A listhead of decision trees.  The alternatives to a node are kept\n-   in a doublely-linked list so we can easily add nodes to the proper\n+   in a doubly-linked list so we can easily add nodes to the proper\n    place when merging.  */\n \n struct decision_head\n@@ -1968,7 +1968,7 @@ write_switch (start, depth)\n     }\n   else\n     {\n-      /* None of the other tests are ameanable.  */\n+      /* None of the other tests are amenable.  */\n       return p;\n     }\n }"}, {"sha": "b35777ee6d632174b4d15fb18232ad7fdb0ae581", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -695,7 +695,7 @@ global_conflicts ()\n \t\t2. Y is live at some instruction on the path that\n \t\t   evaluates X.\n \n-\t\t3. Either X or Y is not evaluted on the path to P\n+\t\t3. Either X or Y is not evaluated on the path to P\n \t\t   (ie it is used uninitialized) and thus the\n \t\t   conflict can be ignored.\n "}, {"sha": "30cb6254329c19e33ecbad15f1c1fa1a79ce2996", "filename": "gcc/gthr-rtems.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgthr-rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b/gcc%2Fgthr-rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-rtems.h?ref=fbe5a4a607f0dcb330bbb63e041c1dfaf63c883b", "patch": "@@ -1,4 +1,4 @@\n-/* RTEMS threads compatibily routines for libgcc2 and libobjc.\n+/* RTEMS threads compatibility routines for libgcc2 and libobjc.\n    by: Rosimildo da Silva( rdasilva@connecttel.com ) */\n /* Compile this one with gcc.  */\n /* Copyright (C) 1997, 1999, 2000, 2002 Free Software Foundation, Inc.\n@@ -39,7 +39,7 @@ extern \"C\" {\n #define __GTHREAD_ONCE_INIT  0\n #define __GTHREAD_MUTEX_INIT_FUNCTION  rtems_gxx_mutex_init\n \n-/* avoid depedency on rtems specific headers */\n+/* Avoid dependency on rtems specific headers.  */\n typedef void *__gthread_key_t;\n typedef int   __gthread_once_t;\n typedef void *__gthread_mutex_t;"}]}