{"sha": "ec53a6da66d89c335c60585eb62ad469cf9922f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM1M2E2ZGE2NmQ4OWMzMzVjNjA1ODVlYjYyYWQ0NjljZjk5MjJmMg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-09-05T07:54:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:54:48Z"}, "message": "itypes.ads, itypes.adb (Create_Null_Excluding_Itype): New subprogram that given an entity T creates and returns an Itype that...\n\n2005-09-01  Javier Miranda  <miranda@adacore.com>\n\n\t* itypes.ads, itypes.adb (Create_Null_Excluding_Itype): New subprogram\n\tthat given an entity T creates and returns an Itype that duplicates the\n\tcontents of T. The returned Itype has the null-exclusion\n\tattribute set to True, and its Etype attribute references T\n\tto keep the association between the two entities.\n\tUpdate copyright notice\n\n\t* sem_aggr.adb (Check_Can_Never_Be_Null,\n\tAggregate_Constraint_Checks, Resolve_Aggregate,\n\tResolve_Array_Aggregate, Resolve_Record_Aggregate): Code cleanup.\n\n\t* sem_ch5.adb (Analyze_Assignment): Code cleanup.\n\nFrom-SVN: r103868", "tree": {"sha": "d7a5a8f5007bee419ecccaf73a6db9e7c78b677e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7a5a8f5007bee419ecccaf73a6db9e7c78b677e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec53a6da66d89c335c60585eb62ad469cf9922f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec53a6da66d89c335c60585eb62ad469cf9922f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec53a6da66d89c335c60585eb62ad469cf9922f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec53a6da66d89c335c60585eb62ad469cf9922f2/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f5a932436112de4e93366915c8dbc77a8f821ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f5a932436112de4e93366915c8dbc77a8f821ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f5a932436112de4e93366915c8dbc77a8f821ff"}], "stats": {"total": 224, "additions": 156, "deletions": 68}, "files": [{"sha": "f9f86d57e2e401a5b2b4305b2864651ae41fe609", "filename": "gcc/ada/itypes.adb", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fitypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fitypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.adb?ref=ec53a6da66d89c335c60585eb62ad469cf9922f2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,10 +25,8 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n with Opt;      use Opt;\n with Sem;      use Sem;\n-with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n \n@@ -74,4 +72,40 @@ package body Itypes is\n       return Typ;\n    end Create_Itype;\n \n+   ---------------------------------\n+   -- Create_Null_Excluding_Itype --\n+   ---------------------------------\n+\n+   function Create_Null_Excluding_Itype\n+      (T           : Entity_Id;\n+       Related_Nod : Node_Id;\n+       Scope_Id    : Entity_Id := Current_Scope) return Entity_Id\n+   is\n+      I_Typ        : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Access_Type (T));\n+\n+      I_Typ := Create_Itype (Ekind       => E_Access_Subtype,\n+                             Related_Nod => Related_Nod,\n+                             Scope_Id    => Scope_Id);\n+\n+      Set_Directly_Designated_Type (I_Typ,\n+         Directly_Designated_Type (T));\n+      Set_Etype              (I_Typ, T);\n+      Init_Size_Align        (I_Typ);\n+      Set_Depends_On_Private (I_Typ, Depends_On_Private (T));\n+      Set_Is_Public          (I_Typ, Is_Public (T));\n+      Set_From_With_Type     (I_Typ, From_With_Type (T));\n+      Set_Is_Access_Constant (I_Typ, Is_Access_Constant (T));\n+      Set_Is_Generic_Type    (I_Typ, Is_Generic_Type (T));\n+      Set_Is_Volatile        (I_Typ, Is_Volatile (T));\n+      Set_Treat_As_Volatile  (I_Typ, Treat_As_Volatile (T));\n+      Set_Is_Atomic          (I_Typ, Is_Atomic (T));\n+      Set_Is_Ada_2005        (I_Typ, Is_Ada_2005 (T));\n+      Set_Can_Never_Be_Null  (I_Typ);\n+\n+      return I_Typ;\n+   end Create_Null_Excluding_Itype;\n+\n end Itypes;"}, {"sha": "e4dcffce707fa3e970ee111ed1f3e21301d3966a", "filename": "gcc/ada/itypes.ads", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fitypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fitypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.ads?ref=ec53a6da66d89c335c60585eb62ad469cf9922f2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -110,4 +110,32 @@ package Itypes is\n    --  The Scope_Id parameter specifies the scope of the created type, and\n    --  is normally the Current_Scope as shown, but can be set otherwise.\n \n+   ---------------------------------\n+   -- Create_Null_Excluding_Itype --\n+   ---------------------------------\n+\n+   function Create_Null_Excluding_Itype\n+      (T           : Entity_Id;\n+       Related_Nod : Node_Id;\n+       Scope_Id    : Entity_Id := Current_Scope) return Entity_Id;\n+   --  Ada 2005 (AI-231): T is an access type and this subprogram creates and\n+   --  returns an internal access-subtype declaration of T that has the null\n+   --  exclusion attribute set to True.\n+   --\n+   --  Usage of null-excluding itypes\n+   --  ------------------------------\n+   --\n+   --      type T1 is access ...\n+   --      type T2 is not null T1;\n+   --\n+   --      type Rec is record\n+   --         Comp : not null T1;\n+   --      end record;\n+   --\n+   --      type Arr is array (...) of not null T1;\n+   --\n+   --  Instead of associating the not-null attribute with the defining ids of\n+   --  these declarations, we generate an internal subtype declaration of T1\n+   --  that has the null exclusion attribute set to true.\n+\n end Itypes;"}, {"sha": "b8fc284b501252acaaf41981d38d71e2fe5cfb2e", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 74, "deletions": 50, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=ec53a6da66d89c335c60585eb62ad469cf9922f2", "patch": "@@ -77,7 +77,7 @@ package body Sem_Aggr is\n    --  statement of variant part will usually be small and probably in near\n    --  sorted order.\n \n-   procedure Check_Can_Never_Be_Null (N : Node_Id; Expr : Node_Id);\n+   procedure Check_Can_Never_Be_Null (Typ : Node_Id; Expr : Node_Id);\n    --  Ada 2005 (AI-231): Check bad usage of the null-exclusion issue\n \n    ------------------------------------------------------\n@@ -477,7 +477,7 @@ package body Sem_Aggr is\n       elsif Is_Access_Type (Check_Typ)\n         and then ((Is_Local_Anonymous_Access (Check_Typ))\n                     or else (Can_Never_Be_Null (Check_Typ)\n-                              and then not Can_Never_Be_Null (Exp_Typ)))\n+                               and then not Can_Never_Be_Null (Exp_Typ)))\n       then\n          Rewrite (Exp, Convert_To (Check_Typ, Relocate_Node (Exp)));\n          Analyze_And_Resolve (Exp, Check_Typ);\n@@ -495,14 +495,14 @@ package body Sem_Aggr is\n       return Entity_Id\n    is\n       Aggr_Dimension : constant Pos := Number_Dimensions (Typ);\n-      --  Number of aggregate index dimensions.\n+      --  Number of aggregate index dimensions\n \n       Aggr_Range : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n-      --  Constrained N_Range of each index dimension in our aggregate itype.\n+      --  Constrained N_Range of each index dimension in our aggregate itype\n \n       Aggr_Low   : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n       Aggr_High  : array (1 .. Aggr_Dimension) of Node_Id := (others => Empty);\n-      --  Low and High bounds for each index dimension in our aggregate itype.\n+      --  Low and High bounds for each index dimension in our aggregate itype\n \n       Is_Fully_Positional : Boolean := True;\n \n@@ -511,6 +511,7 @@ package body Sem_Aggr is\n       --  (sub-)aggregate N. This procedure collects the constrained N_Range\n       --  nodes corresponding to each index dimension of our aggregate itype.\n       --  These N_Range nodes are collected in Aggr_Range above.\n+      --\n       --  Likewise collect in Aggr_Low & Aggr_High above the low and high\n       --  bounds of each index dimension. If, when collecting, two bounds\n       --  corresponding to the same dimension are static and found to differ,\n@@ -522,11 +523,11 @@ package body Sem_Aggr is\n \n       procedure Collect_Aggr_Bounds (N : Node_Id; Dim : Pos) is\n          This_Range : constant Node_Id := Aggregate_Bounds (N);\n-         --  The aggregate range node of this specific sub-aggregate.\n+         --  The aggregate range node of this specific sub-aggregate\n \n          This_Low  : constant Node_Id := Low_Bound (Aggregate_Bounds (N));\n          This_High : constant Node_Id := High_Bound (Aggregate_Bounds (N));\n-         --  The aggregate bounds of this specific sub-aggregate.\n+         --  The aggregate bounds of this specific sub-aggregate\n \n          Assoc : Node_Id;\n          Expr  : Node_Id;\n@@ -601,7 +602,7 @@ package body Sem_Aggr is\n       --  the final itype of the overall aggregate\n \n       Index_Constraints : constant List_Id := New_List;\n-      --  The list of index constraints of the aggregate itype.\n+      --  The list of index constraints of the aggregate itype\n \n    --  Start of processing for Array_Aggr_Subtype\n \n@@ -612,7 +613,7 @@ package body Sem_Aggr is\n       Set_Parent (Index_Constraints, N);\n       Collect_Aggr_Bounds (N, 1);\n \n-      --  Build the list of constrained indices of our aggregate itype.\n+      --  Build the list of constrained indices of our aggregate itype\n \n       for J in 1 .. Aggr_Dimension loop\n          Create_Index : declare\n@@ -816,7 +817,7 @@ package body Sem_Aggr is\n          Next_Component (Comp);\n       end loop;\n \n-      --  On exit, all components have statically known sizes.\n+      --  On exit, all components have statically known sizes\n \n       Set_Size_Known_At_Compile_Time (T);\n    end Check_Static_Discriminated_Subtype;\n@@ -987,13 +988,6 @@ package body Sem_Aggr is\n \n             Set_Etype (N, Aggr_Typ);  --  may be overridden later on\n \n-            --  Ada 2005 (AI-231): Propagate the null_exclusion attribute to\n-            --  the components of the array aggregate\n-\n-            if Ada_Version >= Ada_05 then\n-               Set_Can_Never_Be_Null (Aggr_Typ, Can_Never_Be_Null (Typ));\n-            end if;\n-\n             if Is_Constrained (Typ) and then\n               (Pkind = N_Assignment_Statement      or else\n                Pkind = N_Parameter_Association     or else\n@@ -1106,7 +1100,7 @@ package body Sem_Aggr is\n       --  warning if not and sets the Raises_Constraint_Error Flag in N.\n \n       function Dynamic_Or_Null_Range (L, H : Node_Id) return Boolean;\n-      --  Returns True if range L .. H is dynamic or null.\n+      --  Returns True if range L .. H is dynamic or null\n \n       procedure Get (Value : out Uint; From : Node_Id; OK : out Boolean);\n       --  Given expression node From, this routine sets OK to False if it\n@@ -1368,10 +1362,10 @@ package body Sem_Aggr is\n       is\n          Nxt_Ind        : constant Node_Id := Next_Index (Index);\n          Nxt_Ind_Constr : constant Node_Id := Next_Index (Index_Constr);\n-         --  Index is the current index corresponding to the expresion.\n+         --  Index is the current index corresponding to the expresion\n \n          Resolution_OK : Boolean := True;\n-         --  Set to False if resolution of the expression failed.\n+         --  Set to False if resolution of the expression failed\n \n       begin\n          --  If the array type against which we are resolving the aggregate\n@@ -1584,7 +1578,7 @@ package body Sem_Aggr is\n             --  in the current association.\n \n          begin\n-            --  STEP 2 (A): Check discrete choices validity.\n+            --  STEP 2 (A): Check discrete choices validity\n \n             Assoc := First (Component_Associations (N));\n             while Present (Assoc) loop\n@@ -1637,7 +1631,7 @@ package body Sem_Aggr is\n                   if Etype (Choice) = Any_Type then\n                      return Failure;\n \n-                  --  If the discrete choice raises CE get its original bounds.\n+                  --  If the discrete choice raises CE get its original bounds\n \n                   elsif Nkind (Choice) = N_Raise_Constraint_Error then\n                      Set_Raises_Constraint_Error (N);\n@@ -1681,7 +1675,9 @@ package body Sem_Aggr is\n \n                --  Ada 2005 (AI-231)\n \n-               if Ada_Version >= Ada_05 then\n+               if Ada_Version >= Ada_05\n+                 and then Nkind (Expression (Assoc)) = N_Null\n+               then\n                   Check_Can_Never_Be_Null (Etype (N), Expression (Assoc));\n                end if;\n \n@@ -1811,7 +1807,9 @@ package body Sem_Aggr is\n \n             --  Ada 2005 (AI-231)\n \n-            if Ada_Version >= Ada_05 then\n+            if Ada_Version >= Ada_05\n+              and then Nkind (Expr) = N_Null\n+            then\n                Check_Can_Never_Be_Null (Etype (N), Expr);\n             end if;\n \n@@ -1827,7 +1825,9 @@ package body Sem_Aggr is\n \n             --  Ada 2005 (AI-231)\n \n-            if Ada_Version >= Ada_05 then\n+            if Ada_Version >= Ada_05\n+              and then Nkind (Expression (Assoc)) = N_Null\n+            then\n                Check_Can_Never_Be_Null\n                  (Etype (N), Expression (Assoc));\n             end if;\n@@ -2231,18 +2231,19 @@ package body Sem_Aggr is\n             return True;\n          end if;\n \n-         --  Now look to see if Discr was specified in the ancestor part.\n-\n-         Orig_Discr := Original_Record_Component (Discr);\n-         D          := First_Discriminant (Ancestor_Typ);\n+         --  Now look to see if Discr was specified in the ancestor part\n \n          if Ancestor_Is_Subtyp then\n             D_Val := First_Elmt (Discriminant_Constraint (Entity (Ancestor)));\n          end if;\n \n+         Orig_Discr := Original_Record_Component (Discr);\n+\n+         D := First_Discriminant (Ancestor_Typ);\n          while Present (D) loop\n-            --  If Ancestor has already specified Disc value than\n-            --  insert its value in the final aggregate.\n+\n+            --  If Ancestor has already specified Disc value than insert its\n+            --  value in the final aggregate.\n \n             if Original_Record_Component (D) = Orig_Discr then\n                if Ancestor_Is_Subtyp then\n@@ -2506,16 +2507,16 @@ package body Sem_Aggr is\n \n             --  For each range in an array type where a discriminant has been\n             --  replaced with the constraint, check that this range is within\n-            --  the range of the base type. This checks is done in the\n-            --  init proc for regular objects, but has to be done here for\n+            --  the range of the base type. This checks is done in the init\n+            --  proc for regular objects, but has to be done here for\n             --  aggregates since no init proc is called for them.\n \n             if Is_Array_Type (Expr_Type) then\n                declare\n-                  Index          : Node_Id := First_Index (Expr_Type);\n-                  --  Range of the current constrained index in the array.\n+                  Index : Node_Id := First_Index (Expr_Type);\n+                  --  Range of the current constrained index in the array\n \n-                  Orig_Index     : Node_Id := First_Index (Etype (Component));\n+                  Orig_Index : Node_Id := First_Index (Etype (Component));\n                   --  Range corresponding to the range Index above in the\n                   --  original unconstrained record type. The bounds of this\n                   --  range may be governed by discriminants.\n@@ -2697,7 +2698,9 @@ package body Sem_Aggr is\n \n                --  Ada 2005 (AI-231)\n \n-               if Ada_Version >= Ada_05 then\n+               if Ada_Version >= Ada_05\n+                 and then Nkind (Positional_Expr) = N_Null\n+               then\n                   Check_Can_Never_Be_Null (Discrim, Positional_Expr);\n                end if;\n \n@@ -2790,7 +2793,7 @@ package body Sem_Aggr is\n                 Subtype_Indication  => Indic);\n             Set_Parent (Subtyp_Decl, Parent (N));\n \n-            --  Itypes must be analyzed with checks off (see itypes.ads).\n+            --  Itypes must be analyzed with checks off (see itypes.ads)\n \n             Analyze (Subtyp_Decl, Suppress => All_Checks);\n \n@@ -2884,7 +2887,7 @@ package body Sem_Aggr is\n                end if;\n             end loop;\n \n-            --  Now collect components from all other ancestors.\n+            --  Now collect components from all other ancestors\n \n             Parent_Elmt := First_Elmt (Parent_Typ_List);\n             while Present (Parent_Elmt) loop\n@@ -2934,7 +2937,9 @@ package body Sem_Aggr is\n \n          --  Ada 2005 (AI-231)\n \n-         if Ada_Version >= Ada_05 then\n+         if Ada_Version >= Ada_05\n+           and then Nkind (Positional_Expr) = N_Null\n+         then\n             Check_Can_Never_Be_Null (Component, Positional_Expr);\n          end if;\n \n@@ -3087,19 +3092,38 @@ package body Sem_Aggr is\n    -- Check_Can_Never_Be_Null --\n    -----------------------------\n \n-   procedure Check_Can_Never_Be_Null (N : Node_Id; Expr : Node_Id) is\n+   procedure Check_Can_Never_Be_Null (Typ : Node_Id; Expr : Node_Id) is\n+      Comp_Typ : Entity_Id;\n+\n    begin\n-      pragma Assert (Ada_Version >= Ada_05);\n+      pragma Assert (Ada_Version >= Ada_05\n+        and then Present (Expr)\n+        and then Nkind (Expr) = N_Null);\n \n-      if Nkind (Expr) = N_Null\n-        and then Can_Never_Be_Null (N)\n+      case Ekind (Typ) is\n+         when E_Array_Type  =>\n+            Comp_Typ := Component_Type (Typ);\n+\n+         when E_Component    |\n+              E_Discriminant =>\n+            Comp_Typ := Etype (Typ);\n+\n+         when others =>\n+            return;\n+      end case;\n+\n+      if Present (Expr)\n+        and then Can_Never_Be_Null (Comp_Typ)\n       then\n-         Apply_Compile_Time_Constraint_Error\n-           (N      => Expr,\n-            Msg    => \"(Ada 2005) NULL not allowed in\"\n-                       & \" null-excluding components?\",\n-            Reason => CE_Null_Not_Allowed,\n-            Rep    => False);\n+         Error_Msg_N\n+           (\"(Ada 2005) NULL not allowed in null-excluding components?\", Expr);\n+         Error_Msg_NEL\n+           (\"\\& will be raised at run time!?\",\n+            Expr, Standard_Constraint_Error, Sloc (Expr));\n+\n+         Set_Etype                    (Expr, Comp_Typ);\n+         Set_Analyzed                 (Expr);\n+         Install_Null_Excluding_Check (Expr);\n       end if;\n    end Check_Can_Never_Be_Null;\n "}, {"sha": "2c5e0642bf00ad10be594d929bcf43e0e7b4e5dc", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53a6da66d89c335c60585eb62ad469cf9922f2/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=ec53a6da66d89c335c60585eb62ad469cf9922f2", "patch": "@@ -375,9 +375,7 @@ package body Sem_Ch5 is\n \n       T2 := Etype (Rhs);\n \n-      if Covers (T1, T2) then\n-         null;\n-      else\n+      if not Covers (T1, T2) then\n          Wrong_Type (Rhs, Etype (Lhs));\n          return;\n       end if;\n@@ -448,17 +446,21 @@ package body Sem_Ch5 is\n       --  Ada 2005 (AI-231)\n \n       if Ada_Version >= Ada_05\n-        and then Nkind (Rhs) = N_Null\n-        and then Is_Access_Type (T1)\n+        and then Can_Never_Be_Null (T1)\n         and then not Assignment_OK (Lhs)\n-        and then ((Is_Entity_Name (Lhs)\n-                     and then Can_Never_Be_Null (Entity (Lhs)))\n-                   or else Can_Never_Be_Null (Etype (Lhs)))\n       then\n-         Apply_Compile_Time_Constraint_Error\n-           (N      => Lhs,\n-            Msg    => \"(Ada 2005) NULL not allowed in null-excluding objects?\",\n-            Reason => CE_Null_Not_Allowed);\n+         if Nkind (Rhs) = N_Null then\n+            Apply_Compile_Time_Constraint_Error\n+              (N   => Rhs,\n+               Msg => \"(Ada 2005) NULL not allowed in null-excluding objects?\",\n+               Reason => CE_Null_Not_Allowed);\n+            return;\n+\n+         elsif not Can_Never_Be_Null (T2) then\n+            Rewrite (Rhs,\n+              Convert_To (T1, Relocate_Node (Rhs)));\n+            Analyze_And_Resolve (Rhs, T1);\n+         end if;\n       end if;\n \n       if Is_Scalar_Type (T1) then\n@@ -550,7 +552,7 @@ package body Sem_Ch5 is\n \n       Ent := Entity (Lhs);\n \n-      --  Capture value if save to do so\n+      --  Capture value if safe to do so\n \n       if Safe_To_Capture_Value (N, Ent) then\n          Set_Current_Value (Ent, Rhs);\n@@ -1274,7 +1276,7 @@ package body Sem_Ch5 is\n       --  Start of processing for Process_Bounds\n \n       begin\n-         --  Determine expected type of range by analyzing separate copy.\n+         --  Determine expected type of range by analyzing separate copy\n \n          Set_Parent (R_Copy, Parent (R));\n          Pre_Analyze_And_Resolve (R_Copy);"}]}