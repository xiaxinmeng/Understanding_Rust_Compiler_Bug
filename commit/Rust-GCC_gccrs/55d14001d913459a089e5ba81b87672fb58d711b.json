{"sha": "55d14001d913459a089e5ba81b87672fb58d711b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVkMTQwMDFkOTEzNDU5YTA4OWU1YmE4MWI4NzY3MmZiNThkNzExYg==", "commit": {"author": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2017-08-25T15:08:30Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2017-08-25T15:08:30Z"}, "message": "re PR target/81504 (gcc-7 regression: vec_st  in loop misoptimized)\n\n2017-08-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR target/81504\n\t* config/rs6000/rs6000-p8swap.c (find_alignment_op): Add reference\n\tparameter and_insn and return it.\n\t(recombine_lvx_pattern): Insert a copy to ensure availability of\n\tthe base register of the copied masking operation at the point of\n\tthe instruction replacement.\n\t(recombine_stvx_pattern): Likewise.\n\nFrom-SVN: r251355", "tree": {"sha": "bdae587840d4003efa2e43ede75a1501d8470b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdae587840d4003efa2e43ede75a1501d8470b69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55d14001d913459a089e5ba81b87672fb58d711b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d14001d913459a089e5ba81b87672fb58d711b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d14001d913459a089e5ba81b87672fb58d711b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d14001d913459a089e5ba81b87672fb58d711b/comments", "author": null, "committer": null, "parents": [{"sha": "56b26dd40956052f62cf5ed5ff678d2cd758e0ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b26dd40956052f62cf5ed5ff678d2cd758e0ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b26dd40956052f62cf5ed5ff678d2cd758e0ec"}], "stats": {"total": 59, "additions": 50, "deletions": 9}, "files": [{"sha": "d509afbcd04b90efdc4007a1b94b2ce47e57c5a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d14001d913459a089e5ba81b87672fb58d711b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d14001d913459a089e5ba81b87672fb58d711b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55d14001d913459a089e5ba81b87672fb58d711b", "patch": "@@ -1,4 +1,14 @@\n-2017-08-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+2017-08-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR target/81504\n+\t* config/rs6000/rs6000-p8swap.c (find_alignment_op): Add reference\n+\tparameter and_insn and return it.\n+\t(recombine_lvx_pattern): Insert a copy to ensure availability of\n+\tthe base register of the copied masking operation at the point of\n+\tthe instruction replacement.\n+\t(recombine_stvx_pattern): Likewise.\n+\n+2017-08-25  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.opt (-mpower9-dform-scalar): Delete\n \tundocumented switches."}, {"sha": "7d2c97fab8af9e8f2474f9ebcbc84a66de0d3e6b", "filename": "gcc/config/rs6000/rs6000-p8swap.c", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d14001d913459a089e5ba81b87672fb58d711b/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d14001d913459a089e5ba81b87672fb58d711b/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c?ref=55d14001d913459a089e5ba81b87672fb58d711b", "patch": "@@ -1431,9 +1431,10 @@ alignment_mask (rtx_insn *insn)\n }\n \n /* Given INSN that's a load or store based at BASE_REG, look for a\n-   feeding computation that aligns its address on a 16-byte boundary.  */\n+   feeding computation that aligns its address on a 16-byte boundary.\n+   Return the rtx and its containing AND_INSN.  */\n static rtx\n-find_alignment_op (rtx_insn *insn, rtx base_reg)\n+find_alignment_op (rtx_insn *insn, rtx base_reg, rtx_insn **and_insn)\n {\n   df_ref base_use;\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n@@ -1454,8 +1455,8 @@ find_alignment_op (rtx_insn *insn, rtx base_reg)\n       if (DF_REF_IS_ARTIFICIAL (base_def_link->ref))\n \tbreak;\n \n-      rtx_insn *and_insn = DF_REF_INSN (base_def_link->ref);\n-      and_operation = alignment_mask (and_insn);\n+      *and_insn = DF_REF_INSN (base_def_link->ref);\n+      and_operation = alignment_mask (*and_insn);\n       if (and_operation != 0)\n \tbreak;\n     }\n@@ -1477,7 +1478,8 @@ recombine_lvx_pattern (rtx_insn *insn, del_info *to_delete)\n   rtx mem = XEXP (SET_SRC (body), 0);\n   rtx base_reg = XEXP (mem, 0);\n \n-  rtx and_operation = find_alignment_op (insn, base_reg);\n+  rtx_insn *and_insn;\n+  rtx and_operation = find_alignment_op (insn, base_reg, &and_insn);\n \n   if (and_operation != 0)\n     {\n@@ -1501,7 +1503,21 @@ recombine_lvx_pattern (rtx_insn *insn, del_info *to_delete)\n \t  to_delete[INSN_UID (swap_insn)].replace = true;\n \t  to_delete[INSN_UID (swap_insn)].replace_insn = swap_insn;\n \n-\t  XEXP (mem, 0) = and_operation;\n+\t  /* However, first we must be sure that we make the\n+\t     base register from the AND operation available\n+\t     in case the register has been overwritten.  Copy\n+\t     the base register to a new pseudo and use that\n+\t     as the base register of the AND operation in\n+\t     the new LVX instruction.  */\n+\t  rtx and_base = XEXP (and_operation, 0);\n+\t  rtx new_reg = gen_reg_rtx (GET_MODE (and_base));\n+\t  rtx copy = gen_rtx_SET (new_reg, and_base);\n+\t  rtx_insn *new_insn = emit_insn_after (copy, and_insn);\n+\t  set_block_for_insn (new_insn, BLOCK_FOR_INSN (and_insn));\n+\t  df_insn_rescan (new_insn);\n+\n+\t  XEXP (mem, 0) = gen_rtx_AND (GET_MODE (and_base), new_reg,\n+\t\t\t\t       XEXP (and_operation, 1));\n \t  SET_SRC (body) = mem;\n \t  INSN_CODE (insn) = -1; /* Force re-recognition.  */\n \t  df_insn_rescan (insn);\n@@ -1524,7 +1540,8 @@ recombine_stvx_pattern (rtx_insn *insn, del_info *to_delete)\n   rtx mem = SET_DEST (body);\n   rtx base_reg = XEXP (mem, 0);\n \n-  rtx and_operation = find_alignment_op (insn, base_reg);\n+  rtx_insn *and_insn;\n+  rtx and_operation = find_alignment_op (insn, base_reg, &and_insn);\n \n   if (and_operation != 0)\n     {\n@@ -1552,7 +1569,21 @@ recombine_stvx_pattern (rtx_insn *insn, del_info *to_delete)\n \t  to_delete[INSN_UID (swap_insn)].replace = true;\n \t  to_delete[INSN_UID (swap_insn)].replace_insn = swap_insn;\n \n-\t  XEXP (mem, 0) = and_operation;\n+\t  /* However, first we must be sure that we make the\n+\t     base register from the AND operation available\n+\t     in case the register has been overwritten.  Copy\n+\t     the base register to a new pseudo and use that\n+\t     as the base register of the AND operation in\n+\t     the new STVX instruction.  */\n+\t  rtx and_base = XEXP (and_operation, 0);\n+\t  rtx new_reg = gen_reg_rtx (GET_MODE (and_base));\n+\t  rtx copy = gen_rtx_SET (new_reg, and_base);\n+\t  rtx_insn *new_insn = emit_insn_after (copy, and_insn);\n+\t  set_block_for_insn (new_insn, BLOCK_FOR_INSN (and_insn));\n+\t  df_insn_rescan (new_insn);\n+\n+\t  XEXP (mem, 0) = gen_rtx_AND (GET_MODE (and_base), new_reg,\n+\t\t\t\t       XEXP (and_operation, 1));\n \t  SET_SRC (body) = src_reg;\n \t  INSN_CODE (insn) = -1; /* Force re-recognition.  */\n \t  df_insn_rescan (insn);"}]}