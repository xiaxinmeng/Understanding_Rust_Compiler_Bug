{"sha": "1eee5628bd63cd0d6d58700f06f431570db29de0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVlZTU2MjhiZDYzY2QwZDZkNTg3MDBmMDZmNDMxNTcwZGIyOWRlMA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-01-08T09:23:26Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-01-08T09:23:26Z"}, "message": "re PR fortran/25829 ([F03] Asynchronous IO support)\n\n2010-01-08  Tobias Burnus  <burnus@net-b.de\n\n        PR/fortran 25829\n        * symbol.c (check_conflict, gfc_copy_attr): Add\n        ASYNCHRONOUS support.\n        (gfc_add_asynchronous): New function.\n        * decl.c (match_attr_spec): Add ASYNCHRONOUS support.\n        (gfc_match_asynchronous): New function.\n        * dump-parse-tree.c (show_attr): Add ASYNCHRONOUS support.\n        * gfortran.h (symbol_attribute): New ASYNCHRONOUS bit.\n        (gfc_add_asynchronous): New Prototype.\n        * module.c (ab_attribute, mio_symbol_attribute): Add\n        ASYNCHRONOUS support.\n        * resolve.c (was_declared): Ditto.\n        * match.h (gfc_match_asynchronous): New prototype.\n        * parse.c (decode_specification_statement,decode_statement):\n        Add ASYNCHRONOUS support.\n\n2010-01-08  Tobias Burnus  <burnus@net-b.de\n\n        PR/fortran 25829\n        * gfortran.dg/asynchronous_1.f90: New test.\n        * gfortran.dg/asynchronous_2.f90: New test.\n        * gfortran.dg/conflicts.f90: Update error message.\n\nFrom-SVN: r155732", "tree": {"sha": "422915f53f5c95d2a683bd9a849b37b940093dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/422915f53f5c95d2a683bd9a849b37b940093dec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eee5628bd63cd0d6d58700f06f431570db29de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eee5628bd63cd0d6d58700f06f431570db29de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eee5628bd63cd0d6d58700f06f431570db29de0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eee5628bd63cd0d6d58700f06f431570db29de0/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e98c66c4fa2d8f4cb09d589ad909895eb247880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e98c66c4fa2d8f4cb09d589ad909895eb247880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e98c66c4fa2d8f4cb09d589ad909895eb247880"}], "stats": {"total": 225, "additions": 214, "deletions": 11}, "files": [{"sha": "79b5174deade6df8757927ae2773645ac9c7dcd9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -1,3 +1,21 @@\n+2010-01-08  Tobias Burnus  <burnus@net-b.de\n+\n+\tPR/fortran 25829\n+\t* symbol.c (check_conflict, gfc_copy_attr): Add\n+\tASYNCHRONOUS support.\n+\t(gfc_add_asynchronous): New function.\n+\t* decl.c (match_attr_spec): Add ASYNCHRONOUS support.\n+\t(gfc_match_asynchronous): New function.\n+\t* dump-parse-tree.c (show_attr): Add ASYNCHRONOUS support.\n+\t* gfortran.h (symbol_attribute): New ASYNCHRONOUS bit.\n+\t(gfc_add_asynchronous): New Prototype.\n+\t* module.c (ab_attribute, mio_symbol_attribute): Add\n+\tASYNCHRONOUS support.\n+\t* resolve.c (was_declared): Ditto.\n+\t* match.h (gfc_match_asynchronous): New prototype.\n+\t* parse.c (decode_specification_statement,decode_statement):\n+\tAdd ASYNCHRONOUS support.\n+\n 2010-01-07  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/42597"}, {"sha": "9f65fe41eec0314a18e4eb60b8ff7f9d2e995a15", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -2819,7 +2819,7 @@ match_attr_spec (void)\n     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,\n     DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,\n     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,\n-    DECL_IS_BIND_C, DECL_NONE,\n+    DECL_IS_BIND_C, DECL_ASYNCHRONOUS, DECL_NONE,\n     GFC_DECL_END /* Sentinel */\n   }\n   decl_types;\n@@ -2864,9 +2864,25 @@ match_attr_spec (void)\n \t  switch (gfc_peek_ascii_char ())\n \t    {\n \t    case 'a':\n-\t      if (match_string_p (\"allocatable\"))\n-\t\td = DECL_ALLOCATABLE;\n-\t      break;\n+\t      gfc_next_ascii_char ();\n+\t      switch (gfc_next_ascii_char ())\n+\t\t{\n+\t\tcase 'l':\n+\t\t  if (match_string_p (\"locatable\"))\n+\t\t    {\n+\t\t      /* Matched \"allocatable\".  */\n+\t\t      d = DECL_ALLOCATABLE;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase 's':\n+\t\t  if (match_string_p (\"ynchronous\"))\n+\t\t    {\n+\t\t      /* Matched \"asynchronous\".  */\n+\t\t      d = DECL_ASYNCHRONOUS;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n \n \t    case 'b':\n \t      /* Try and match the bind(c).  */\n@@ -3047,6 +3063,9 @@ match_attr_spec (void)\n \t  case DECL_ALLOCATABLE:\n \t    attr = \"ALLOCATABLE\";\n \t    break;\n+\t  case DECL_ASYNCHRONOUS:\n+\t    attr = \"ASYNCHRONOUS\";\n+\t    break;\n \t  case DECL_DIMENSION:\n \t    attr = \"DIMENSION\";\n \t    break;\n@@ -3173,6 +3192,15 @@ match_attr_spec (void)\n \t  t = gfc_add_allocatable (&current_attr, &seen_at[d]);\n \t  break;\n \n+\tcase DECL_ASYNCHRONOUS:\n+\t  if (gfc_notify_std (GFC_STD_F2003,\n+\t\t\t      \"Fortran 2003: ASYNCHRONOUS attribute at %C\")\n+\t      == FAILURE)\n+\t    t = FAILURE;\n+\t  else\n+\t    t = gfc_add_asynchronous (&current_attr, NULL, &seen_at[d]);\n+\t  break;\n+\n \tcase DECL_DIMENSION:\n \t  t = gfc_add_dimension (&current_attr, NULL, &seen_at[d]);\n \t  break;\n@@ -6485,6 +6513,59 @@ gfc_match_volatile (void)\n }\n \n \n+match\n+gfc_match_asynchronous (void)\n+{\n+  gfc_symbol *sym;\n+  match m;\n+\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ASYNCHRONOUS statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n+    {\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_eos () == MATCH_YES)\n+    goto syntax;\n+\n+  for(;;)\n+    {\n+      /* ASYNCHRONOUS is special because it can be added to host-associated \n+\t symbols locally.  */\n+      m = gfc_match_symbol (&sym, 1);\n+      switch (m)\n+\t{\n+\tcase MATCH_YES:\n+\t  if (gfc_add_asynchronous (&sym->attr, sym->name, &gfc_current_locus)\n+\t      == FAILURE)\n+\t    return MATCH_ERROR;\n+\t  goto next_item;\n+\n+\tcase MATCH_NO:\n+\t  break;\n+\n+\tcase MATCH_ERROR:\n+\t  return MATCH_ERROR;\n+\t}\n+\n+    next_item:\n+      if (gfc_match_eos () == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in ASYNCHRONOUS statement at %C\");\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Match a module procedure statement.  Note that we have to modify\n    symbols in the parent's namespace because the current one was there\n    to receive symbols that are in an interface's formal argument list.  */"}, {"sha": "f3638167dfb402a9bc6a5ff1751691dde8b6a4fe", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -589,6 +589,8 @@ show_attr (symbol_attribute *attr)\n \n   if (attr->allocatable)\n     fputs (\" ALLOCATABLE\", dumpfile);\n+  if (attr->asynchronous)\n+    fputs (\" ASYNCHRONOUS\", dumpfile);\n   if (attr->dimension)\n     fputs (\" DIMENSION\", dumpfile);\n   if (attr->external)"}, {"sha": "345a7015dce3c2ae9537147497a152a3513bb507", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -652,7 +652,7 @@ typedef struct\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, target:1, value:1, volatile_:1, temporary:1,\n     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,\n-    implied_index:1, subref_array_pointer:1, proc_pointer:1;\n+    implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1;\n \n   /* For CLASS containers, the pointer attribute is sometimes set internally\n      even though it was not directly specified.  In this case, keep the\n@@ -741,8 +741,8 @@ typedef struct\n   /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n   unsigned ext_attr:EXT_ATTR_NUM;\n \n-  /* The namespace where the VOLATILE attribute has been set.  */\n-  struct gfc_namespace *volatile_ns;\n+  /* The namespace where the attribute has been set.  */\n+  struct gfc_namespace *volatile_ns, *asynchronous_ns;\n }\n symbol_attribute;\n \n@@ -2426,6 +2426,7 @@ gfc_try gfc_add_recursive (symbol_attribute *, locus *);\n gfc_try gfc_add_function (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_asynchronous (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_proc (symbol_attribute *attr, const char *name, locus *where);\n gfc_try gfc_add_abstract (symbol_attribute* attr, locus* where);\n "}, {"sha": "3c0f1c0de496343b50985d2d63ae74728f774bea", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -162,6 +162,7 @@ void gfc_set_constant_character_len (int, gfc_expr *, int);\n \n /* Matchers for attribute declarations.  */\n match gfc_match_allocatable (void);\n+match gfc_match_asynchronous (void);\n match gfc_match_dimension (void);\n match gfc_match_external (void);\n match gfc_match_gcc_attributes (void);"}, {"sha": "140f2e2d5745d5c1be93fae92e2d4d8742c39fa8", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -1671,13 +1671,14 @@ typedef enum\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n-  AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER\n+  AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS\n }\n ab_attribute;\n \n static const mstring attr_bits[] =\n {\n     minit (\"ALLOCATABLE\", AB_ALLOCATABLE),\n+    minit (\"ASYNCHRONOUS\", AB_ASYNCHRONOUS),\n     minit (\"DIMENSION\", AB_DIMENSION),\n     minit (\"EXTERNAL\", AB_EXTERNAL),\n     minit (\"INTRINSIC\", AB_INTRINSIC),\n@@ -1792,6 +1793,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n     {\n       if (attr->allocatable)\n \tMIO_NAME (ab_attribute) (AB_ALLOCATABLE, attr_bits);\n+      if (attr->asynchronous)\n+\tMIO_NAME (ab_attribute) (AB_ASYNCHRONOUS, attr_bits);\n       if (attr->dimension)\n \tMIO_NAME (ab_attribute) (AB_DIMENSION, attr_bits);\n       if (attr->external)\n@@ -1887,6 +1890,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_ALLOCATABLE:\n \t      attr->allocatable = 1;\n \t      break;\n+\t    case AB_ASYNCHRONOUS:\n+\t      attr->asynchronous = 1;\n+\t      break;\n \t    case AB_DIMENSION:\n \t      attr->dimension = 1;\n \t      break;"}, {"sha": "8f7ec29f1ad7f60e32110f0f87aff6614f530b5f", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -129,6 +129,8 @@ decode_specification_statement (void)\n     case 'a':\n       match (\"abstract% interface\", gfc_match_abstract_interface,\n \t     ST_INTERFACE);\n+      match (\"allocatable\", gfc_match_asynchronous, ST_ATTR_DECL);\n+      match (\"asynchronous\", gfc_match_asynchronous, ST_ATTR_DECL);\n       break;\n \n     case 'b':\n@@ -328,6 +330,7 @@ decode_statement (void)\n       match (\"allocate\", gfc_match_allocate, ST_ALLOCATE);\n       match (\"allocatable\", gfc_match_allocatable, ST_ATTR_DECL);\n       match (\"assign\", gfc_match_assign, ST_LABEL_ASSIGNMENT);\n+      match (\"asynchronous\", gfc_match_asynchronous, ST_ATTR_DECL);\n       break;\n \n     case 'b':"}, {"sha": "0378d4fa14ad9ebb94de9f82f3a160c2f97e681e", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -937,7 +937,8 @@ was_declared (gfc_symbol *sym)\n \n   if (a.allocatable || a.dimension || a.dummy || a.external || a.intrinsic\n       || a.optional || a.pointer || a.save || a.target || a.volatile_\n-      || a.value || a.access != ACCESS_UNKNOWN || a.intent != INTENT_UNKNOWN)\n+      || a.value || a.access != ACCESS_UNKNOWN || a.intent != INTENT_UNKNOWN\n+      || a.asynchronous)\n     return 1;\n \n   return 0;"}, {"sha": "750aa2d6a16ee503981f492db4d726944f5d95e8", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -369,7 +369,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     *use_assoc = \"USE ASSOCIATED\", *cray_pointer = \"CRAY POINTER\",\n     *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *value = \"VALUE\",\n     *volatile_ = \"VOLATILE\", *is_protected = \"PROTECTED\",\n-    *is_bind_c = \"BIND(C)\", *procedure = \"PROCEDURE\";\n+    *is_bind_c = \"BIND(C)\", *procedure = \"PROCEDURE\",\n+    *asynchronous = \"ASYNCHRONOUS\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n@@ -559,6 +560,9 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (is_protected, external)\n   conf (is_protected, in_common)\n \n+  conf (asynchronous, intrinsic)\n+  conf (asynchronous, external)\n+\n   conf (volatile_, intrinsic)\n   conf (volatile_, external)\n \n@@ -576,6 +580,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (procedure, target)\n   conf (procedure, value)\n   conf (procedure, volatile_)\n+  conf (procedure, asynchronous)\n   conf (procedure, entry)\n \n   a1 = gfc_code2string (flavors, attr->flavor);\n@@ -598,6 +603,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (dimension);\n       conf2 (dummy);\n       conf2 (volatile_);\n+      conf2 (asynchronous);\n       conf2 (pointer);\n       conf2 (is_protected);\n       conf2 (target);\n@@ -640,8 +646,11 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n       if (attr->subroutine)\n \t{\n+\t  a1 = subroutine;\n \t  conf2 (target);\n \t  conf2 (allocatable);\n+\t  conf2 (volatile_);\n+\t  conf2 (asynchronous);\n \t  conf2 (in_namelist);\n \t  conf2 (dimension);\n \t  conf2 (function);\n@@ -708,6 +717,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (in_common);\n       conf2 (value);\n       conf2 (volatile_);\n+      conf2 (asynchronous);\n       conf2 (threadprivate);\n       conf2 (value);\n       conf2 (is_bind_c);\n@@ -1099,6 +1109,25 @@ gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n+gfc_try\n+gfc_add_asynchronous (symbol_attribute *attr, const char *name, locus *where)\n+{\n+  /* No check_used needed as 11.2.1 of the F2003 standard allows\n+     that the local identifier made accessible by a use statement can be\n+     given a ASYNCHRONOUS attribute.  */\n+\n+  if (attr->asynchronous && attr->asynchronous_ns == gfc_current_ns)\n+    if (gfc_notify_std (GFC_STD_LEGACY, \n+        \t\t\"Duplicate ASYNCHRONOUS attribute specified at %L\",\n+\t\t\twhere) == FAILURE)\n+      return FAILURE;\n+\n+  attr->asynchronous = 1;\n+  attr->asynchronous_ns = gfc_current_ns;\n+  return check_conflict (attr, name, where);\n+}\n+\n+\n gfc_try\n gfc_add_threadprivate (symbol_attribute *attr, const char *name, locus *where)\n {\n@@ -1659,6 +1688,8 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n     goto fail;\n   if (src->volatile_ && gfc_add_volatile (dest, NULL, where) == FAILURE)\n     goto fail;\n+  if (src->asynchronous && gfc_add_asynchronous (dest, NULL, where) == FAILURE)\n+    goto fail;\n   if (src->threadprivate\n       && gfc_add_threadprivate (dest, NULL, where) == FAILURE)\n     goto fail;"}, {"sha": "e96fbd2d4a47f9639cdbed70f5fe099629597f64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -1,3 +1,10 @@\n+2010-01-08  Tobias Burnus  <burnus@net-b.de\n+\n+\tPR/fortran 25829\n+\t* gfortran.dg/asynchronous_1.f90: New test.\n+\t* gfortran.dg/asynchronous_2.f90: New test.\n+\t* gfortran.dg/conflicts.f90: Update error message.\n+\n 2010-01-07  Dodji Seketeli  <dodji@redhat.com>\n \n \tc++/40155"}, {"sha": "bc8821453efe1bb6d7764c5f7982c885b7c91f46", "filename": "gcc/testsuite/gfortran.dg/asynchronous_1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_1.f90?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+!\n+! PR/fortran 25829\n+!\n+! Check parsing and checking of ASYNCHRONOUS\n+!\n+type(t) function func0()\n+  asynchronous :: a\n+  integer, asynchronous:: b\n+  allocatable :: c\n+  volatile :: d\n+  type t\n+    sequence\n+    integer :: i = 5\n+  end type t\n+end function func0\n+\n+integer function func()\n+  asynchronous :: func\n+  integer, asynchronous:: b\n+  allocatable :: c\n+  volatile :: func\n+  type t\n+    sequence\n+    integer :: i = 5\n+  end type t\n+end function func\n+\n+function func2() result(res)\n+  volatile res\n+  asynchronous res\n+end function func2\n+\n+subroutine sub()\n+  asynchronous sub ! { dg-error \"SUBROUTINE attribute conflicts with ASYNCHRONOUS\" }\n+  volatile sub     ! { dg-error \"SUBROUTINE attribute conflicts with VOLATILE\" }\n+end subroutine sub\n+\n+program main\n+  asynchronous main ! { dg-error \"PROGRAM attribute conflicts with ASYNCHRONOUS\" }\n+  volatile main     ! { dg-error \"PROGRAM attribute conflicts with VOLATILE\" }\n+end program main"}, {"sha": "939c9e2f637e5645affb465caae248c521a779f0", "filename": "gcc/testsuite/gfortran.dg/asynchronous_2.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fasynchronous_2.f90?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+!\n+! PR/fortran 25829\n+!\n+! Check parsing ASYNCHRONOUS\n+!\n+function func2() result(res)\n+  asynchronous res ! { dg-error \"Fortran 2003: ASYNCHRONOUS\" }\n+end function func2"}, {"sha": "d17cb041db6dbe6e1e9610657801279aa4a30cd6", "filename": "gcc/testsuite/gfortran.dg/conflicts.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2Fgfortran.dg%2Fconflicts.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eee5628bd63cd0d6d58700f06f431570db29de0/gcc%2Ftestsuite%2Fgfortran.dg%2Fconflicts.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fconflicts.f90?ref=1eee5628bd63cd0d6d58700f06f431570db29de0", "patch": "@@ -17,7 +17,7 @@ end function f2\n \n subroutine f3()\n   implicit none\n-  dimension f3(3) ! { dg-error \"PROCEDURE attribute conflicts with DIMENSION attribute\" }\n+  dimension f3(3) ! { dg-error \"SUBROUTINE attribute conflicts with DIMENSION attribute\" }\n end subroutine f3\n \n subroutine f4(b)"}]}