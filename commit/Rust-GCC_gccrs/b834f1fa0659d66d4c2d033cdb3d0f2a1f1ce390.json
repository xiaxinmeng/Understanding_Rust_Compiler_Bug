{"sha": "b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgzNGYxZmEwNjU5ZDY2ZDRjMmQwMzNjZGIzZDBmMmExZjFjZTM5MA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-03-28T02:22:24Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-03-28T02:22:24Z"}, "message": "Makefile.in: New #defines and friends for Thread.h.\n\n        * Makefile.in: New #defines and friends for Thread.h.\n        * posix-threads.cc: (struct starter): Remove `object'.\n        (_Jv_CondWait): Use interruptable condition variables and new\n        recursive mutexes. New return codes on interrupt or non-ownership\n        of mutex.\n        (_Jv_CondNotify): Ditto.\n        (_Jv_CondNotifyAll): Ditto.\n        (_Jv_ThreadInterrupt): Set thread interrupt flag directly. Interrupt\n        the target thread by signaling its wait condition.\n        (_Jv_ThreadInitData): Set `thread_obj' in the thread data struct,\n        not the starter struct. Initialize wait_mutex and wait_cond.\n        (_Jv_MutexLock): New recursive mutex implementation. Moved from\n        posix-threads.h.\n        (_Jv_MutexUnlock): Ditto.\n        (really_start): Set info->data->thread from pthread_self() to work\n        around a race condition. Destroy wait_mutex and wait_cond when run()\n        returns.\n        * java/lang/Thread.java: (isInterrupted_): Renamed to overloaded\n        `isInterrupted(boolean)'. Clear interrupted flag if clear_flag is\n        set.\n        startable_flag: New private field.\n        (Thread): Initialize `startable_flag'.\n        (toString): Check for null thread group.\n        * java/lang/natThread.cc: (struct natThread): New fields\n        `join_mutex', `join_cond'. Removed fields `joiner', `next'.\n        (class locker): Removed.\n        (initialize_native): Initialize `join_cond' and `join_mutex'.\n        (interrupt): Now just calls _Jv_ThreadInterrupt().\n        (join): Simplified. Just wait on the target thread's join condition.\n        (finish_): Remove join list code. Unset thread group. Signal\n        potential joiners by notifying the dying threads join_cond.\n        (start): Check for illegal restarts.\n        * java/lang/natObject.cc: Check for return value of _Jv_CondWait and\n        act appropriatly.\n        * include/posix-threads.h: Remove all HAVE_RECURSIVE_MUTEX related\n        #defines and #ifdefs.\n        (struct _Jv_Thread_t): New fields `thread_obj', `wait_cond',\n        `wait_mutex', `next'.\n        (struct _Jv_ConditionVariable_t): Define as a struct instead of\n        directly mapping to pthread_cond_t.\n        (struct _Jv_Mutex_t): New recursive implementation.\n        (_Jv_PthreadCheckMonitor): Reimplemented. Simple `owner' check.\n        _Jv_HaveCondDestroy: Never define this for posix-threads.\n        (_Jv_CondNotify): Remove inline implementation(s), prototype instead.\n        (_Jv_CondNotifyAll): Ditto.\n        (_Jv_MutexLock): Ditto.\n        (_Jv_MutexUnlock): Ditto.\n        (_Jv_MutexInit): Changed to reflect new mutex implementation.\n        (_Jv_MutexDestroy): Ditto.\n        (_Jv_CondDestroy): Removed.\n        (_Jv_PthreadGetMutex): Removed.\n        * include/win32-threads.h: (_Jv_CondNotify): Guess _JV_NOT_OWNER on an\n        error. Add a FIXME about this.\n        (_Jv_CondNotifyAll): Ditto.\n        * win32-threads.cc: (_Jv_CondWait): Return 0 on a timeout. Guess\n        _JV_NOT_OWNER on other errors. Add FIXME.\n\nFrom-SVN: r32773", "tree": {"sha": "1644e34b97bb6d57435386decdbf6dbeadd31a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1644e34b97bb6d57435386decdbf6dbeadd31a58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/comments", "author": null, "committer": null, "parents": [{"sha": "73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73780b74b37175aa1c9afd20bfb81b66e6a96c1a"}], "stats": {"total": 864, "additions": 382, "deletions": 482}, "files": [{"sha": "6aee33f3701baa35ecd6e2891cb0b58cda147737", "filename": "libjava/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -1,3 +1,62 @@\n+2000-03-27  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* Makefile.in: New #defines and friends for Thread.h.\n+\t* posix-threads.cc: (struct starter): Remove `object'.\n+\t(_Jv_CondWait): Use interruptable condition variables and new\n+\trecursive mutexes. New return codes on interrupt or non-ownership\n+\tof mutex.\n+\t(_Jv_CondNotify): Ditto.\n+\t(_Jv_CondNotifyAll): Ditto.\n+\t(_Jv_ThreadInterrupt): Set thread interrupt flag directly. Interrupt\n+\tthe target thread by signaling its wait condition.\n+\t(_Jv_ThreadInitData): Set `thread_obj' in the thread data struct,\n+\tnot the starter struct. Initialize wait_mutex and wait_cond.\n+\t(_Jv_MutexLock): New recursive mutex implementation. Moved from \n+\tposix-threads.h.\n+\t(_Jv_MutexUnlock): Ditto.\n+\t(really_start): Set info->data->thread from pthread_self() to work \n+\taround a race condition. Destroy wait_mutex and wait_cond when run()\n+\treturns.\n+\t* java/lang/Thread.java: (isInterrupted_): Renamed to overloaded\n+\t`isInterrupted(boolean)'. Clear interrupted flag if clear_flag is\n+\tset.\n+\tstartable_flag: New private field.\n+\t(Thread): Initialize `startable_flag'.\n+\t(toString): Check for null thread group.\n+\t* java/lang/natThread.cc: (struct natThread): New fields \n+\t`join_mutex', `join_cond'. Removed fields `joiner', `next'.\n+\t(class locker): Removed.\n+\t(initialize_native): Initialize `join_cond' and `join_mutex'.\n+\t(interrupt): Now just calls _Jv_ThreadInterrupt().\n+\t(join): Simplified. Just wait on the target thread's join condition.\n+\t(finish_): Remove join list code. Unset thread group. Signal\n+\tpotential joiners by notifying the dying threads join_cond.\n+\t(start): Check for illegal restarts.\n+\t* java/lang/natObject.cc: Check for return value of _Jv_CondWait and\n+\tact appropriatly.\n+\t* include/posix-threads.h: Remove all HAVE_RECURSIVE_MUTEX related\n+\t#defines and #ifdefs.\n+\t(struct _Jv_Thread_t): New fields `thread_obj', `wait_cond',\n+\t`wait_mutex', `next'.\n+\t(struct _Jv_ConditionVariable_t): Define as a struct instead of \n+\tdirectly mapping to pthread_cond_t.\n+\t(struct _Jv_Mutex_t): New recursive implementation.\n+\t(_Jv_PthreadCheckMonitor): Reimplemented. Simple `owner' check.\n+\t_Jv_HaveCondDestroy: Never define this for posix-threads.\n+\t(_Jv_CondNotify): Remove inline implementation(s), prototype instead.\n+\t(_Jv_CondNotifyAll): Ditto.\n+\t(_Jv_MutexLock): Ditto.\n+\t(_Jv_MutexUnlock): Ditto.\n+\t(_Jv_MutexInit): Changed to reflect new mutex implementation.\n+\t(_Jv_MutexDestroy): Ditto.\n+\t(_Jv_CondDestroy): Removed.\n+\t(_Jv_PthreadGetMutex): Removed.\n+\t* include/win32-threads.h: (_Jv_CondNotify): Guess _JV_NOT_OWNER on an \n+\terror. Add a FIXME about this.\n+\t(_Jv_CondNotifyAll): Ditto.\n+\t* win32-threads.cc: (_Jv_CondWait): Return 0 on a timeout. Guess \n+\t_JV_NOT_OWNER on other errors. Add FIXME.\n+\n 2000-03-26  Tom Tromey  <tromey@cygnus.com>\n \n \t* jni.cc (_Jv_JNI_PopSystemFrame): If environment has exception"}, {"sha": "22f6717e82db06422fe0dfc29043e286b34f7579", "filename": "libjava/include/posix-threads.h", "status": "modified", "additions": 51, "deletions": 166, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -20,81 +20,56 @@ details.  */\n #include <pthread.h>\n #include <sched.h>\n \n-#if defined (HAVE_PTHREAD_MUTEXATTR_SETTYPE) || defined (HAVE_PTHREAD_MUTEXATTR_SETKIND_NP)\n-#  define HAVE_RECURSIVE_MUTEX 1\n-#endif\n-\n-\n //\n // Typedefs.\n //\n \n-typedef pthread_cond_t _Jv_ConditionVariable_t;\n-\n-#if defined (PTHREAD_MUTEX_HAVE_M_COUNT) || defined (PTHREAD_MUTEX_HAVE___M_COUNT)\n+typedef struct _Jv_Thread_t\n+{\n+  // Flag values are defined in implementation.\n+  int flags;\n \n-// On Linux we use implementation details of mutexes in order to get\n-// faster results.\n-typedef pthread_mutex_t _Jv_Mutex_t;\n+  // Actual thread id.\n+  pthread_t thread;\n+  \n+  // Java Thread object.\n+  java::lang::Thread *thread_obj;\n+  \n+  // Condition variable and corresponding mutex, used to implement the\n+  // interruptable wait/notify mechanism.\n+  pthread_cond_t wait_cond;\n+  pthread_mutex_t wait_mutex;\n+\n+  // Next thread for Condition Variable wait-list chain.\n+  _Jv_Thread_t *next;\n+  \n+} _Jv_Thread_t;\n \n-#else /* LINUX_THREADS */\n+typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n \n-#define PTHREAD_MUTEX_IS_STRUCT\n \n+// Condition Variables used to implement wait/notify/sleep/interrupt.\n typedef struct\n {\n-  // Mutex used when locking this structure transiently.\n-  pthread_mutex_t mutex;\n-#ifndef HAVE_RECURSIVE_MUTEX\n-  // Some systems do not have recursive mutexes, so we must simulate\n-  // them.  Solaris is one such system.\n-\n-  // Mutex the thread holds the entire time this mutex is held.  This\n-  // is used to make condition variables work properly.\n-  pthread_mutex_t mutex2;\n-  // Condition variable used when waiting for this lock.\n-  pthread_cond_t cond;\n-  // Thread holding this mutex.  If COUNT is 0, no thread is holding.\n-  pthread_t thread;\n-#endif /* HAVE_RECURSIVE_MUTEX */\n-\n-  // Number of times mutex is held.  If 0, the lock is not held.  We\n-  // do this even if we have a native recursive mutex so that we can\n-  // keep track of whether the lock is held; this lets us do error\n-  // checking.  FIXME it would be nice to optimize this; on some\n-  // systems we could do so by relying on implementation details of\n-  // recursive mutexes.\n-  int count;\n-} _Jv_Mutex_t;\n+  // Linked list of Threads that are waiting to be notified.\n+  _Jv_Thread_t *first;\n \n-#endif\n+} _Jv_ConditionVariable_t;\n \n typedef struct\n {\n-  // Flag values are defined in implementation.\n-  int flags;\n-\n-  // Actual thread id.\n-  pthread_t thread;\n-} _Jv_Thread_t;\n-typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n+  // For compatibility, simplicity, and correctness, we do not use the native\n+  // pthreads recursive mutex implementation, but simulate them instead.\n \n+  // Mutex the thread holds the entire time this mutex is held. \n+  pthread_mutex_t mutex;\n \n-// This convenience function is used to return the POSIX mutex\n-// corresponding to our mutex.\n-inline pthread_mutex_t *\n-_Jv_PthreadGetMutex (_Jv_Mutex_t *mu)\n-{\n-#if ! defined (PTHREAD_MUTEX_IS_STRUCT)\n-  return mu;\n-#elif defined (HAVE_RECURSIVE_MUTEX)\n-  return &mu->mutex;\n-#else\n-  return &mu->mutex2;\n-#endif\n-}\n+  // Thread holding this mutex.\n+  pthread_t owner;\n \n-#include <stdio.h>\n+  // Number of times mutex is held (lock depth).  If 0, the lock is not held.\n+  int count;\n+} _Jv_Mutex_t;\n \n // This is a convenience function used only by the pthreads thread\n // implementation.  This is slow, but that's too bad -- we need to do\n@@ -104,95 +79,44 @@ _Jv_PthreadGetMutex (_Jv_Mutex_t *mu)\n inline int\n _Jv_PthreadCheckMonitor (_Jv_Mutex_t *mu)\n {\n-  pthread_mutex_t *pmu;\n-#ifdef HAVE_RECURSIVE_MUTEX\n-  pmu = _Jv_PthreadGetMutex (mu);\n-  // See if the mutex is locked by this thread.\n-  if (pthread_mutex_trylock (pmu))\n-    return 1;\n-\n-#if defined (PTHREAD_MUTEX_HAVE_M_COUNT)\n-  // On Linux we exploit knowledge of the implementation.\n-  int r = pmu->m_count == 1;\n-#elif defined (PTHREAD_MUTEX_HAVE___M_COUNT)\n-  // In glibc 2.1, the first time the mutex is grabbed __m_count is\n-  // set to 0 and __m_owner is set to pthread_self().\n-  int r = ! pmu->__m_count;\n-#else\n-  int r = mu->count == 0;\n-#endif\n-\n-#else /* HAVE_RECURSIVE_MUTEX */\n-  // In this case we must lock our structure and then see if this\n-  // thread owns the mutex.\n-  pmu = &mu->mutex;\n-  if (pthread_mutex_lock (pmu))\n-    return 1;\n-\n-  int r = mu->thread != pthread_self () || mu->count == 0;\n-#endif /* HAVE_RECURSIVE_MUTEX */\n-\n-  pthread_mutex_unlock (pmu);\n-  return r;\n+  pthread_t self = pthread_self();\n+  if (mu->owner == self)\n+    return 0;\n+  else return 1;\n }\n \n //\n // Condition variables.\n //\n \n-inline void\n-_Jv_CondInit (_Jv_ConditionVariable_t *cv)\n-{\n-  pthread_cond_init (cv, 0);\n-}\n-\n-#ifndef LINUX_THREADS\n-\n-// pthread_cond_destroy does nothing on Linux and it is a win to avoid\n-// defining this macro.\n-\n-#define _Jv_HaveCondDestroy\n-\n-inline void\n-_Jv_CondDestroy (_Jv_ConditionVariable_t *cv)\n-{\n-  pthread_cond_destroy (cv);\n-}\n-\n-#endif /* LINUX_THREADS */\n-\n int _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n \t\t  jlong millis, jint nanos);\n+\t\t  \n+int _Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu);\n \n-inline int\n-_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n-{\n-  return _Jv_PthreadCheckMonitor (mu) || pthread_cond_signal (cv);\n-}\n+int _Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu);\n \n-inline int\n-_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n+inline void\n+_Jv_CondInit (_Jv_ConditionVariable_t *cv)\n {\n-  return _Jv_PthreadCheckMonitor (mu) || pthread_cond_broadcast (cv);\n+  cv->first = NULL;\n }\n \n-\n //\n // Mutexes.\n //\n \n-#ifdef RECURSIVE_MUTEX_IS_DEFAULT\n inline void\n _Jv_MutexInit (_Jv_Mutex_t *mu)\n {\n-  pthread_mutex_init (_Jv_PthreadGetMutex (mu), NULL);\n-#ifdef PTHREAD_MUTEX_IS_STRUCT\n+  pthread_mutex_init (&mu->mutex, NULL);\n+\n   mu->count = 0;\n-#endif\n+  mu->owner = 0;\n }\n-#else\n-void _Jv_MutexInit (_Jv_Mutex_t *mu);\n-#endif\n+\n+int _Jv_MutexLock (_Jv_Mutex_t *mu);\n+int _Jv_MutexUnlock (_Jv_Mutex_t *mu);\n \n #ifndef LINUX_THREADS\n \n@@ -201,53 +125,14 @@ void _Jv_MutexInit (_Jv_Mutex_t *mu);\n \n #define _Jv_HaveMutexDestroy\n \n-#ifdef HAVE_RECURSIVE_MUTEX\n-\n-inline void\n+inline void \n _Jv_MutexDestroy (_Jv_Mutex_t *mu)\n {\n-  pthread_mutex_destroy (_Jv_PthreadGetMutex (mu));\n+  pthread_mutex_destroy (&mu->mutex);\n }\n \n-#else /* HAVE_RECURSIVE_MUTEX */\n-\n-extern void _Jv_MutexDestroy (_Jv_Mutex_t *mu);\n-\n-#endif /* HAVE_RECURSIVE_MUTEX */\n #endif /* LINUX_THREADS */\n \n-#ifdef HAVE_RECURSIVE_MUTEX\n-\n-inline int\n-_Jv_MutexLock (_Jv_Mutex_t *mu)\n-{\n-  int r = pthread_mutex_lock (_Jv_PthreadGetMutex (mu));\n-#ifdef PTHREAD_MUTEX_IS_STRUCT\n-  if (! r)\n-    ++mu->count;\n-#endif\n-  return r;\n-}\n-\n-inline int\n-_Jv_MutexUnlock (_Jv_Mutex_t *mu)\n-{\n-  int r = pthread_mutex_unlock (_Jv_PthreadGetMutex (mu));\n-#ifdef PTHREAD_MUTEX_IS_STRUCT\n-  if (! r)\n-    --mu->count;\n-#endif\n-  return r;\n-}\n-\n-#else /* HAVE_RECURSIVE_MUTEX */\n-\n-extern int _Jv_MutexLock (_Jv_Mutex_t *mu);\n-extern int _Jv_MutexUnlock (_Jv_Mutex_t *mu);\n-\n-#endif /* HAVE_RECURSIVE_MUTEX */\n-\n-\n //\n // Thread creation and manipulation.\n //"}, {"sha": "4938d5faf57a19d15f9ce02db0c5f53848736207", "filename": "libjava/include/win32-threads.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Finclude%2Fwin32-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Finclude%2Fwin32-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32-threads.h?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -54,13 +54,15 @@ int _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n inline int\n _Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n {\n-  return PulseEvent (*cv) ? 0 : GetLastError ();        // FIXME: Map error code?\n+  // FIXME: check for mutex ownership?\n+  return PulseEvent (*cv) ? 0 : _JV_NOT_OWNER;        // FIXME?\n }\n \n inline int\n _Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n {\n-  return PulseEvent (*cv) ? 0 : GetLastError ();        // FIXME: Map error code?\n+  // FIXME: check for mutex ownership?\n+  return PulseEvent (*cv) ? 0 : _JV_NOT_OWNER;        // FIXME?\n }\n \n //"}, {"sha": "a731b0ab252b75492259d87e03c4f5dbf0180f0a", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -79,12 +79,11 @@ public final ThreadGroup getThreadGroup ()\n \n   public static boolean interrupted ()\n   {\n-    return currentThread().isInterrupted_();\n+    return currentThread().isInterrupted (true);\n   }\n \n-  // FIXME: it seems to me that this should be synchronized.\n   // Check the threads interrupted status. Note that this does not clear the\n-  // threads interrupted status (per JDK 1.2 online API documentation).\n+  // thread's interrupted status (per JDK 1.2 online API documentation).\n   public boolean isInterrupted ()\n   {\n     return interrupt_flag;\n@@ -119,11 +118,18 @@ public final native void join (long timeout, int nanos)\n   private static final native void run_ (Object obj);\n   private final native void finish_ ();\n \n-  // Convenience method to check and clear the thread's interrupted status.  \n-  private boolean isInterrupted_ ()\n+  // Check the thread's interrupted status. If clear_flag is true, the \n+  // thread's interrupted status is also cleared.\n+  private boolean isInterrupted (boolean clear_flag)\n   {\n     boolean r = interrupt_flag;\n-    interrupt_flag = false;\n+    if (clear_flag && r)\n+      {\n+\t// Only clear the flag if we saw it as set. Otherwise this could \n+\t// potentially cause us to miss an interrupt in a race condition, \n+\t// because this method is not synchronized.\n+\tinterrupt_flag = false;\n+      }\n     return r;\n   }\n   \n@@ -221,6 +227,8 @@ public Thread (ThreadGroup g, Runnable r, String n)\n     data = null;\n     interrupt_flag = false;\n     alive_flag = false;\n+    startable_flag = true;\n+    \n     if (current != null)\n       {\n \tdaemon_flag = current.isDaemon();\n@@ -267,7 +275,8 @@ public Thread (Runnable r, String n)\n \n   public String toString ()\n   {\n-    return \"Thread[\" + name + \",\" + priority + \",\" + group.getName() + \"]\";\n+    return \"Thread[\" + name + \",\" + priority + \",\" + \n+\t   (group == null ? \"\" : group.getName()) + \"]\";\n   }\n \n   public static native void yield ();\n@@ -280,6 +289,7 @@ public String toString ()\n   private boolean daemon_flag;\n   private boolean interrupt_flag;\n   private boolean alive_flag;\n+  private boolean startable_flag;\n \n   // Our native data.\n   private RawData data;"}, {"sha": "25b29660ae0aef18945db5930c9227ba6f81d2ff", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -198,11 +198,15 @@ java::lang::Object::wait (jlong timeout, jint nanos)\n   if (timeout < 0 || nanos < 0 || nanos > 999999)\n     JvThrow (new IllegalArgumentException);\n   _Jv_SyncInfo *si = (_Jv_SyncInfo *) sync_info;\n-  if (_Jv_CondWait (&si->condition, &si->mutex, timeout, nanos))\n-    JvThrow (new IllegalMonitorStateException(JvNewStringLatin1 \n-                                              (\"current thread not owner\")));\n-  if (Thread::interrupted())\n-    JvThrow (new InterruptedException);\n+  switch (_Jv_CondWait (&si->condition, &si->mutex, timeout, nanos))\n+    {\n+      case _JV_NOT_OWNER:\n+\tJvThrow (new IllegalMonitorStateException (JvNewStringLatin1 \n+                          (\"current thread not owner\")));        \n+      case _JV_INTERRUPTED:\n+\tif (Thread::interrupted ())\n+\t  JvThrow (new InterruptedException);        \n+    }\n }\n \n //"}, {"sha": "9fc30b9e5b026191fefbaf0bc2b23af00aecbcda", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 32, "deletions": 132, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -35,47 +35,16 @@ details.  */\n struct natThread\n {\n   // These are used to interrupt sleep and join calls.  We can share a\n-  // condition variable here since this thread can either be sleeping\n-  // or waiting for a thread exit, but not both.\n-  _Jv_Mutex_t interrupt_mutex;\n-  _Jv_ConditionVariable_t interrupt_cond;\n+  // condition variable here since it only ever gets notified when the thread\n+  // exits.\n+  _Jv_Mutex_t join_mutex;\n+  _Jv_ConditionVariable_t join_cond;\n \n   // This is private data for the thread system layer.\n   _Jv_Thread_t *thread;\n \n   // Each thread has its own JNI object.\n   JNIEnv *jni_env;\n-\n-  // All threads waiting to join this thread are linked together and\n-  // waiting on their respective `interrupt' condition variables.\n-  // When this thread exits, it notifies each such thread by\n-  // signalling the condition.  In this case the `interrupt_flag' is\n-  // not set; this is how the waiting thread knows whether the join\n-  // has failed or whether it should throw an exception.\n-  struct natThread *joiner;\n-\n-  // Chain for waiters.\n-  struct natThread *next;\n-};\n-\n-// We use this for its side effects: it lets us lock a mutex directly\n-// and not lose if an exception is thrown.\n-class locker\n-{\n-private:\n-  _Jv_Mutex_t *mutex;\n-\n-public:\n-  locker (_Jv_Mutex_t *m)\n-    : mutex (m)\n-  {\n-    _Jv_MutexLock (mutex);\n-  }\n-\n-  ~locker ()\n-  {\n-    _Jv_MutexUnlock (mutex);\n-  }\n };\n \n // This is called from the constructor to initialize the native side\n@@ -90,14 +59,12 @@ java::lang::Thread::initialize_native (void)\n   // any \"interesting\" point.\n   natThread *nt = (natThread *) _Jv_AllocBytes (sizeof (natThread));\n   data = reinterpret_cast<gnu::gcj::RawData *> (nt);\n-  _Jv_MutexInit (&nt->interrupt_mutex);\n-  _Jv_CondInit (&nt->interrupt_cond);\n+  _Jv_MutexInit (&nt->join_mutex);\n+  _Jv_CondInit (&nt->join_cond);\n   _Jv_ThreadInitData (&nt->thread, this);\n   // FIXME: if JNI_ENV is set we will want to free it.  It is\n   // malloc()d.\n   nt->jni_env = NULL;\n-  nt->joiner = 0;\n-  nt->next = 0;\n }\n \n jint\n@@ -125,90 +92,33 @@ java::lang::Thread::destroy (void)\n void\n java::lang::Thread::interrupt (void)\n {\n-  interrupt_flag = true;\n-\n-  // Wake up this thread, whether it is sleeping or waiting for\n-  // another thread to exit.\n   natThread *nt = (natThread *) data;\n-  _Jv_MutexLock (&nt->interrupt_mutex);\n-  // Notify the interrupt condition to interrupt sleep() and join() calls.\n-  _Jv_CondNotify (&nt->interrupt_cond, &nt->interrupt_mutex);\n-  // Send a signal to the target thread to interrupt system calls. On Linux,\n-  // this will also interrupt the target thread from *any* _Jv_CondWait call,\n-  // ie wait(). This behaviour is not portable, however.\n   _Jv_ThreadInterrupt (nt->thread);\n-  _Jv_MutexUnlock (&nt->interrupt_mutex);\n }\n \n void\n java::lang::Thread::join (jlong millis, jint nanos)\n {\n-  // FIXME: what if we are trying to join ourselves with no timeout?\n-\n   if (millis < 0 || nanos < 0 || nanos > 999999)\n     _Jv_Throw (new IllegalArgumentException);\n \n   Thread *current = currentThread ();\n-  if (current->isInterrupted_ ())\n-    _Jv_Throw (new InterruptedException);\n \n-  // Update the list of all threads waiting for this thread to exit.\n-  // We grab a mutex when doing this in order to ensure that the\n-  // required state changes are atomic.\n-  _Jv_MonitorEnter (this);\n-  if (! isAlive ())\n-    {\n-      _Jv_MonitorExit (this);\n-      return;\n-    }\n-\n-  // Here `CURR_NT' is the native structure for the currently\n-  // executing thread, while `NT' is the native structure for the\n-  // thread we are trying to join.\n-  natThread *curr_nt = (natThread *) current->data;\n+  // Here `NT' is the native structure for the thread we are trying to join.\n   natThread *nt = (natThread *) data;\n \n-  JvAssert (curr_nt->next == NULL);\n-  // Put thread CURR_NT onto NT's list.  When NT exits, it will\n-  // traverse its list and notify all joiners.\n-  curr_nt->next = nt->joiner;\n-  nt->joiner = curr_nt;\n-  _Jv_MonitorExit (this);\n-\n-\n   // Now wait for: (1) an interrupt, (2) the thread to exit, or (3)\n-  // the timeout to occur.  Use a `locker' object because _Jv_CondWait\n-  // can throw an exception.\n-  {\n-    locker l (&curr_nt->interrupt_mutex);\n-    _Jv_CondWait (&curr_nt->interrupt_cond,\n-\t\t  &curr_nt->interrupt_mutex,\n-\t\t  millis, nanos);\n-  }\n-\n-  // Now the join has completed, one way or another.  Update the\n-  // joiners list to account for this.\n-  _Jv_MonitorEnter (this);\n-  JvAssert (nt->joiner != NULL);\n-  natThread *prev = 0;\n-  natThread *t;\n-  for (t = nt->joiner; t != NULL; t = t->next)\n+  // the timeout to occur. \n+  _Jv_MutexLock (&nt->join_mutex);\n+  if (! isAlive ())\n     {\n-      if (t == curr_nt)\n-\t{\n-\t  if (prev)\n-\t    prev->next = t->next;\n-\t  else\n-\t    nt->joiner = t->next;\n-\t  t->next = 0;\n-\t  break;\n-\t}\n-      prev = t;\n+      _Jv_MutexUnlock (&nt->join_mutex);\n+      return;\n     }\n-  JvAssert (t != NULL);\n-  _Jv_MonitorExit (this);\n+  _Jv_CondWait (&nt->join_cond, &nt->join_mutex, millis, nanos);\n+  _Jv_MutexUnlock (&nt->join_mutex);\n \n-  if (current->isInterrupted_ ())\n+  if (current->isInterrupted (true))\n     _Jv_Throw (new InterruptedException);\n }\n \n@@ -245,43 +155,31 @@ java::lang::Thread::sleep (jlong millis, jint nanos)\n     ++nanos;\n \n   Thread *current = currentThread ();\n-  if (current->isInterrupted_ ())\n-    _Jv_Throw (new InterruptedException);\n \n   // We use a condition variable to implement sleeping so that an\n-  // interrupt can wake us up.\n+  // interrupt can wake us up. \n   natThread *nt = (natThread *) current->data;\n-  {\n-    // Use a locker because _Jv_CondWait can throw an exception.\n-    locker l (&nt->interrupt_mutex);\n-    _Jv_CondWait (&nt->interrupt_cond, &nt->interrupt_mutex,\n-\t\t  millis, nanos);\n-  }\n-\n-  if (current->isInterrupted_ ())\n+  _Jv_MutexLock (&nt->join_mutex);\n+  _Jv_CondWait (&nt->join_cond, &nt->join_mutex, millis, nanos);\n+  _Jv_MutexUnlock (&nt->join_mutex);\n+\n+  if (current->isInterrupted (true))\n     _Jv_Throw (new InterruptedException);\n }\n \n void\n java::lang::Thread::finish_ ()\n {\n-  // Notify all threads waiting to join this this.\n-  _Jv_MonitorEnter (this);\n-  alive_flag = false;\n-\n-  // Note that we don't bother cleaning up the joiner list here.  That\n-  // is taken care of when each thread wakes up again.\n   natThread *nt = (natThread *) data;\n-  for (natThread *t = nt->joiner; t != NULL; t = t->next)\n-    {\n-      _Jv_MutexLock (&t->interrupt_mutex);\n-      _Jv_CondNotify (&t->interrupt_cond, &t->interrupt_mutex);\n-      _Jv_MutexUnlock (&t->interrupt_mutex);\n-    }\n-\n+  \n   group->remove (this);\n-\n-  _Jv_MonitorExit (this);\n+  group = NULL;\n+  \n+  // Signal any threads that are waiting to join() us.\n+  _Jv_MutexLock (&nt->join_mutex);\n+  alive_flag = false;\n+  _Jv_CondNotifyAll (&nt->join_cond, &nt->join_mutex);\n+  _Jv_MutexUnlock (&nt->join_mutex);  \n }\n \n void\n@@ -314,10 +212,12 @@ java::lang::Thread::start (void)\n {\n   JvSynchronize sync (this);\n \n-  if (alive_flag)\n+  // Its illegal to re-start() a thread, even if its dead.\n+  if (!startable_flag)\n     _Jv_Throw (new IllegalThreadStateException);\n \n   alive_flag = true;\n+  startable_flag = false;\n   natThread *nt = (natThread *) data;\n   _Jv_ThreadStart (this, nt->thread, (_Jv_ThreadStartFunc *) &run_);\n }"}, {"sha": "a664ee37060344c41c42a3edb78b48472b443290", "filename": "libjava/posix-threads.cc", "status": "modified", "additions": 207, "deletions": 167, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fposix-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fposix-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix-threads.cc?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -40,7 +40,6 @@ extern \"C\"\n struct starter\n {\n   _Jv_ThreadStartFunc *method;\n-  java::lang::Thread *object;\n   _Jv_Thread_t *data;\n };\n \n@@ -78,203 +77,202 @@ static int non_daemon_count;\n \n \f\n \n+// Wait for the condition variable \"CV\" to be notified. \n+// Return values:\n+// 0: the condition was notified, or the timeout expired.\n+// _JV_NOT_OWNER: the thread does not own the mutex \"MU\".   \n+// _JV_INTERRUPTED: the thread was interrupted. Its interrupted flag is set.   \n int\n _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n \t      jlong millis, jint nanos)\n {\n-  if (_Jv_PthreadCheckMonitor (mu))\n-    return 1;\n+  pthread_t self = pthread_self();\n+  if (mu->owner != self)\n+    return _JV_NOT_OWNER;\n \n-  int r;\n-  pthread_mutex_t *pmu = _Jv_PthreadGetMutex (mu);\n   struct timespec ts;\n-  jlong m, m2, startTime;\n-  bool done_sleeping = false;\n+  jlong m, startTime;\n \n-  if (millis == 0 && nanos == 0)\n-    {\n-#ifdef LINUX_THREADS\n-      // pthread_cond_timedwait can be interrupted by a signal on linux, while\n-      // pthread_cond_wait can not. So pthread_cond_timedwait() forever.\n-      m = java::lang::Long::MAX_VALUE;\n-      ts.tv_sec = LONG_MAX;\n-      ts.tv_nsec = 0;\n-#endif\n-    }\n-  else\n+  if (millis > 0 || nanos > 0)\n     {\n       startTime = java::lang::System::currentTimeMillis();\n       m = millis + startTime;\n       ts.tv_sec = m / 1000; \n       ts.tv_nsec = ((m % 1000) * 1000000) + nanos; \n     }\n \n-  java::lang::Thread *current = _Jv_ThreadCurrent();\n+  _Jv_Thread_t *current = _Jv_ThreadCurrentData ();\n+  java::lang::Thread *current_obj = _Jv_ThreadCurrent ();\n+\n+  // Add this thread to the cv's wait set.\n+  current->next = NULL;\n \n-  do\n+  if (cv->first == NULL)\n+    cv->first = current;\n+  else\n+    for (_Jv_Thread_t *t = cv->first;; t = t->next)\n+      {\n+        if (t->next == NULL)\n+          {\n+            t->next = current;\n+            break;\n+          }\n+      }\n+\n+  pthread_mutex_lock (&current->wait_mutex);\n+  \n+  // Now that we hold the wait mutex, check if this thread has been \n+  // interrupted already.\n+  if (current_obj->interrupt_flag)\n     {\n-      r = EINTR;\n-      // Check to ensure the thread hasn't already been interrupted.\n-      if (!(current->isInterrupted ()))\n+      pthread_mutex_unlock (&current->wait_mutex);\n+      return _JV_INTERRUPTED;\n+    }\n+\n+  // Record the current lock depth, so it can be restored when we re-aquire it.\n+  int count = mu->count;\n+\n+  // Release the monitor mutex.\n+  mu->count = 0;\n+  mu->owner = 0;\n+  pthread_mutex_unlock (&mu->mutex);\n+  \n+  int r = 0;\n+  bool done_sleeping = false;\n+\n+  while (! done_sleeping)\n+    {\n+      if (millis == 0 && nanos == 0)\n+\tr = pthread_cond_wait (&current->wait_cond, &current->wait_mutex);\n+      else\n+\tr = pthread_cond_timedwait (&current->wait_cond, &current->wait_mutex, \n+\t\t\t\t    &ts);\n+\t\t\t\t    \n+      // In older glibc's (prior to 2.1.3), the cond_wait functions may \n+      // spuriously wake up on a signal. Catch that here.\n+      if (r != EINTR)\n+        done_sleeping = true;\n+    }\n+  \n+  // Check for an interrupt *before* unlocking the wait mutex.\n+  jboolean interrupted = current_obj->interrupt_flag;\n+  \n+  pthread_mutex_unlock (&current->wait_mutex);\n+\n+  //  Reaquire the monitor mutex, and restore the lock count.\n+  pthread_mutex_lock (&mu->mutex);\n+  mu->owner = self;\n+  mu->count = count;\n+\n+  // If we were interrupted, or if a timeout occured, remove ourself from\n+  // the cv wait list now. (If we were notified normally, notify() will have\n+  // already taken care of this)\n+  if (r == ETIMEDOUT || interrupted)\n+    {\n+      _Jv_Thread_t *prev = NULL;\n+      for (_Jv_Thread_t *t = cv->first; t != NULL; t = t->next)\n         {\n-#ifdef LINUX_THREADS\t\n-\t  // FIXME: in theory, interrupt() could be called on this thread\n-\t  // between the test above and the wait below, resulting in the \n-\t  // interupt() call failing. I don't see a way to fix this \n-\t  // without significant changes to the implementation.\n-\t  r = pthread_cond_timedwait (cv, pmu, &ts);\n-#else\n-\t  if (millis == 0 && nanos == 0)\n-\t    r = pthread_cond_wait (cv, pmu);\n-\t  else\t  \n-\t    r = pthread_cond_timedwait (cv, pmu, &ts);\t  \n-#endif\n-\t}\n-      \n-      if (r == EINTR)\n-\t{\n-\t  /* We were interrupted by a signal.  Either this is\n-\t     because we were interrupted intentionally (i.e. by\n-\t     Thread.interrupt()) or by the GC if it is\n-\t     signal-based.  */\n-\t  if (current->isInterrupted ())\n+\t  if (t == current)\n \t    {\n-\t      r = 0;\n-              done_sleeping = true;\n-            }\n-\t  else\n-            {\n-\t      /* We were woken up by the GC or another signal.  */\n-\t      m2 = java::lang::System::currentTimeMillis ();\n-\t      if (m2 >= m)\n-\t\t{\n-\t\t  r = 0;\n-\t\t  done_sleeping = true;\n-\t\t}\n+\t      if (prev != NULL)\n+\t\tprev->next = t->next;\n+\t      else\n+\t        cv->first = t->next;\n+\t      t->next = NULL;\n+\t      break;\n \t    }\n+\t  prev = t;\n \t}\n-      else if (r == ETIMEDOUT)\n-\t{\n-\t  /* A timeout is a normal result.  */\n-\t  r = 0;\n-\t  done_sleeping = true;\n-\t}\n-      else\n-\tdone_sleeping = true;\n+      if (interrupted)\n+\treturn _JV_INTERRUPTED;\n     }\n-  while (! done_sleeping);\n-\n-  return r != 0;\n+  \n+  return 0;\n }\n \n-#ifndef RECURSIVE_MUTEX_IS_DEFAULT\n-\n-void\n-_Jv_MutexInit (_Jv_Mutex_t *mu)\n+int\n+_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n {\n-#ifdef HAVE_RECURSIVE_MUTEX\n-  pthread_mutexattr_t *val = NULL;\n-\n-#if defined (HAVE_PTHREAD_MUTEXATTR_SETTYPE)\n-  pthread_mutexattr_t attr;\n-\n-  // If this is slow, then allocate it statically and only initialize\n-  // it once.\n-  pthread_mutexattr_init (&attr);\n-  pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);\n-  val = &attr;\n-#elif defined (HAVE_PTHREAD_MUTEXATTR_SETKIND_NP)\n-  pthread_mutexattr_t attr;\n-  pthread_mutexattr_init (&attr);\n-  pthread_mutexattr_setkind_np (&attr, PTHREAD_MUTEX_RECURSIVE_NP);\n-  val = &attr;\n-#endif\n-\n-  pthread_mutex_init (_Jv_PthreadGetMutex (mu), val);\n-#ifdef PTHREAD_MUTEX_IS_STRUCT\n-  mu->count = 0;\n-#endif\n-\n-#if defined (HAVE_PTHREAD_MUTEXATTR_SETTYPE) || defined (HAVE_PTHREAD_MUTEXATTR_SETKIND_NP)\n-  pthread_mutexattr_destroy (&attr);\n-#endif\n+  if (_Jv_PthreadCheckMonitor (mu))\n+    return _JV_NOT_OWNER;\n \n-#else /* HAVE_RECURSIVE_MUTEX */\n+  _Jv_Thread_t *target;\n+  _Jv_Thread_t *prev = NULL;\n \n-  // No recursive mutex, so simulate one.\n-  pthread_mutex_init (&mu->mutex, NULL);\n-  pthread_mutex_init (&mu->mutex2, NULL);\n-  pthread_cond_init (&mu->cond, 0);\n-  mu->count = 0;\n+  for (target = cv->first; target != NULL; target = target->next)\n+    {\n+      pthread_mutex_lock (&target->wait_mutex);\n \n-#endif /* HAVE_RECURSIVE_MUTEX */\n-}\n+      if (target->thread_obj->interrupt_flag)\n+        {\n+\t  // Don't notify a thread that has already been interrupted.\n+\t  pthread_mutex_unlock (&target->wait_mutex);\n+          prev = target;\n+\t  continue;\n+\t}\n \n-#endif /* not RECURSIVE_MUTEX_IS_DEFAULT */\n+      pthread_cond_signal (&target->wait_cond);\n+      pthread_mutex_unlock (&target->wait_mutex);\n \n-#if ! defined (LINUX_THREADS) && ! defined (HAVE_RECURSIVE_MUTEX)\n+      // Two successive notify() calls should not be delivered to the same \n+      // thread, so we remove the target thread from the cv wait list now.\n+      if (prev == NULL)\n+\tcv->first = target->next;\n+      else\n+        prev->next = target->next;\n+\t\t\n+      target->next = NULL;\n+      \n+      break;\n+    }\n \n-void\n-_Jv_MutexDestroy (_Jv_Mutex_t *mu)\n-{\n-  pthread_mutex_destroy (&mu->mutex);\n-  pthread_mutex_destroy (&mu->mutex2);\n-  pthread_cond_destroy (&mu->cond);\n+  return 0;\n }\n \n int\n-_Jv_MutexLock (_Jv_Mutex_t *mu)\n+_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n {\n-  if (pthread_mutex_lock (&mu->mutex))\n-    return -1;\n-  while (1)\n+  if (_Jv_PthreadCheckMonitor (mu))\n+    return _JV_NOT_OWNER;\n+\n+  _Jv_Thread_t *target;\n+  _Jv_Thread_t *prev = NULL;\n+\n+  for (target = cv->first; target != NULL; target = target->next)\n     {\n-      if (mu->count == 0)\n-\t{\n-\t  // Grab the lock.\n-\t  mu->thread = pthread_self ();\n-\t  mu->count = 1;\n-\t  pthread_mutex_lock (&mu->mutex2);\n-\t  break;\n-\t}\n-      else if (pthread_self () == mu->thread)\n-\t{\n-\t  // Already have the lock.\n-\t  mu->count += 1;\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  // Try to acquire the lock.\n-\t  pthread_cond_wait (&mu->cond, &mu->mutex);\n-\t}\n+      pthread_mutex_lock (&target->wait_mutex);\n+      pthread_cond_signal (&target->wait_cond);\n+      pthread_mutex_unlock (&target->wait_mutex);\n+\n+      if (prev != NULL)\n+\tprev->next = NULL;\n+      prev = target;\n     }\n-  pthread_mutex_unlock (&mu->mutex);\n+  if (prev != NULL)\n+    prev->next = NULL;\n+    \n+  cv->first = NULL;\n+\n   return 0;\n }\n \n-int\n-_Jv_MutexUnlock (_Jv_Mutex_t *mu)\n+void\n+_Jv_ThreadInterrupt (_Jv_Thread_t *data)\n {\n-  if (pthread_mutex_lock (&mu->mutex))\n-    return -1;\n-  int r = 0;\n-  if (mu->count == 0 || pthread_self () != mu->thread)\n-    r = -1;\n-  else\n-    {\n-      mu->count -= 1;\n-      if (! mu->count)\n-\t{\n-\t  pthread_mutex_unlock (&mu->mutex2);\n-\t  pthread_cond_signal (&mu->cond);\n-\t}\n-    }\n-  pthread_mutex_unlock (&mu->mutex);\n-  return r;\n-}\n+  pthread_mutex_lock (&data->wait_mutex);\n \n-#endif /* not LINUX_THREADS and not HAVE_RECURSIVE_MUTEX */\n+  // Set the thread's interrupted flag *after* aquiring its wait_mutex. This\n+  // ensures that there are no races with the interrupt flag being set after \n+  // the waiting thread checks it and before pthread_cond_wait is entered.\n+  data->thread_obj->interrupt_flag = true;\n+\n+  // Interrupt blocking system calls using a signal.\n+//  pthread_kill (data->thread, INTR);\n+  \n+  pthread_cond_signal (&data->wait_cond);\n+  \n+  pthread_mutex_unlock (&data->wait_mutex);\n+}\n \n static void\n handle_intr (int)\n@@ -300,10 +298,14 @@ _Jv_InitThreads (void)\n }\n \n void\n-_Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *)\n+_Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *obj)\n {\n   _Jv_Thread_t *info = new _Jv_Thread_t;\n   info->flags = 0;\n+  info->thread_obj = obj;\n+\n+  pthread_mutex_init (&info->wait_mutex, NULL);\n+  pthread_cond_init (&info->wait_cond, NULL);\n \n   // FIXME register a finalizer for INFO here.\n   // FIXME also must mark INFO somehow.\n@@ -331,10 +333,16 @@ really_start (void *x)\n {\n   struct starter *info = (struct starter *) x;\n \n-  pthread_setspecific (_Jv_ThreadKey, info->object);\n+  pthread_setspecific (_Jv_ThreadKey, info->data->thread_obj);\n   pthread_setspecific (_Jv_ThreadDataKey, info->data);\n-  info->method (info->object);\n \n+  // glibc 2.1.3 doesn't set the value of `thread' until after start_routine\n+  // is called. Since it may need to be accessed from the new thread, work \n+  // around the potential race here by explicitly setting it again.\n+  info->data->thread = pthread_self ();\n+\n+  info->method (info->data->thread_obj);\n+  \n   if (! (info->data->flags & FLAG_DAEMON))\n     {\n       pthread_mutex_lock (&daemon_mutex);\n@@ -343,6 +351,12 @@ really_start (void *x)\n \tpthread_cond_signal (&daemon_cond);\n       pthread_mutex_unlock (&daemon_mutex);\n     }\n+  \n+#ifndef LINUX_THREADS\n+  // Clean up. These calls do nothing on Linux.\n+  pthread_mutex_destroy (&info->data->wait_mutex);\n+  pthread_cond_destroy (&info->data->wait_cond);\n+#endif /* ! LINUX_THREADS */\n \n   return NULL;\n }\n@@ -367,7 +381,6 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n   // FIXME: handle marking the info object for GC.\n   info = (struct starter *) _Jv_AllocBytes (sizeof (struct starter));\n   info->method = meth;\n-  info->object = thread;\n   info->data = data;\n \n   if (! thread->isDaemon())\n@@ -389,6 +402,39 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n     }\n }\n \n+int\n+_Jv_MutexLock (_Jv_Mutex_t *mu)\n+{\n+  pthread_t self = pthread_self ();\n+  if (mu->owner == self)\n+    {\n+      mu->count++;\n+    }\n+  else\n+    {\n+      pthread_mutex_lock (&mu->mutex);\n+      mu->count = 1;\n+      mu->owner = self;\n+    }\n+  return 0;\n+}\n+\n+int\n+_Jv_MutexUnlock (_Jv_Mutex_t *mu)\n+{\n+  if (_Jv_PthreadCheckMonitor (mu))\n+    return _JV_NOT_OWNER;\n+    \n+  mu->count--;\n+\n+  if (mu->count == 0)\n+    {\n+      mu->owner = 0;\n+      pthread_mutex_unlock (&mu->mutex);\n+    }\n+  return 0;\n+}\n+\n void\n _Jv_ThreadWait (void)\n {\n@@ -397,9 +443,3 @@ _Jv_ThreadWait (void)\n     pthread_cond_wait (&daemon_cond, &daemon_mutex);\n   pthread_mutex_unlock (&daemon_mutex);\n }\n-\n-void\n-_Jv_ThreadInterrupt (_Jv_Thread_t *data)\n-{\n-  pthread_kill (data->thread, INTR);\n-}"}, {"sha": "8da274f1a34f87c7dd28ae1e38f558bb5c652338", "filename": "libjava/win32-threads.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fwin32-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390/libjava%2Fwin32-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32-threads.cc?ref=b834f1fa0659d66d4c2d033cdb3d0f2a1f1ce390", "patch": "@@ -69,6 +69,8 @@ _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint n\n   DWORD time;\n   DWORD rval;\n \n+  // FIXME: check for mutex ownership?\n+\n   _Jv_MutexUnlock (mu);\n \n   if((millis == 0) && (nanos > 0))\n@@ -82,9 +84,7 @@ _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint n\n   _Jv_MutexLock (mu);\n \n   if (rval == WAIT_FAILED)\n-    return GetLastError ();       // FIXME: Map to errno?\n-  else if (rval == WAIT_TIMEOUT)\n-    return ETIMEDOUT;\n+    return _JV_NOT_OWNER;       // FIXME?\n   else\n     return 0;\n }"}]}