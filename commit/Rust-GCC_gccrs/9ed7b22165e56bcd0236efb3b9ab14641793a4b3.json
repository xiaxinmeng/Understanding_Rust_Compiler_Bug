{"sha": "9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVkN2IyMjE2NWU1NmJjZDAyMzZlZmIzYjlhYjE0NjQxNzkzYTRiMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-10-22T19:28:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-10-22T19:28:23Z"}, "message": "re PR rtl-optimization/33644 (ICE in local_cprop_pass with -ftrapv for crafty)\n\n\tPR rtl-optimization/33644\n\t* cfgcleanup.c: Do not include dce.h.\n\t* cfgrtl.c (delete_insn_chain_and_edges): Resurrect.\n\t* combine.c (distribute_notes): Delete REG_LIBCALL_ID case.\n\t* dce.c (something_changed): Delete.\n\t(libcall_dead_p): New predicate.\n\t(delete_unmarked_insns): Use it to delete dead libcalls.\n\tDeal with REG_LIBCALL and REG_RETVAL notes.\n\t(prescan_libcall_for_dce): New function.\n\t(prescan_insns_for_dce): Use it to deal with libcalls.\n\t(mark_reg_dependencies): Do nothing special for libcalls.\n\t(dce_process_block): Likewise.\n\t(fast_dce): Delete unused local variable.\n\t(run_fast_dce): Do not return a value.\n\t* dce.h (struct df): Delete.\n\t(run_fast_dce): Adjust prototype.\n\t* optabs.c (libcall_id): Delete.\n\t(maybe_encapsulate_block): Do not emit REG_LIBCALL_ID notes.\n\t(emit_no_conflict_block): Do not look for REG_LIBCALL_ID notes.\n\t* reload1.c (reload): Delete REG_LIBCALL_ID case.\n\t* rtl.h (delete_insn_chain_and_edges): Resurrect prototype.\n\t* see.c (see_update_relevancy): Look for REG_LIBCALL and REG_RETVAL\n\tnotes instead of REG_LIBCALL_ID notes.\n\t* reg-notes.def (LIBCALL_ID): Delete.\n\t* Makefile.in (see.o): Add dce.h dependency.\n\t(cfgcleanup.o): Remove dce.h dependency.\n\nFrom-SVN: r129556", "tree": {"sha": "ce100096d41a38847cdcf3bd954b2e8fbcdd6bd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce100096d41a38847cdcf3bd954b2e8fbcdd6bd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/comments", "author": null, "committer": null, "parents": [{"sha": "6e684eee8d03ef8f75e864d355695b7097c38a9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e684eee8d03ef8f75e864d355695b7097c38a9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e684eee8d03ef8f75e864d355695b7097c38a9f"}], "stats": {"total": 427, "additions": 250, "deletions": 177}, "files": [{"sha": "0e9ca3c5316bb2cf1e59af82e1267c7c1a6d04d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -1,3 +1,32 @@\n+2007-10-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR rtl-optimization/33644\n+\t* cfgcleanup.c: Do not include dce.h.\n+\t* cfgrtl.c (delete_insn_chain_and_edges): Resurrect.\n+\t* combine.c (distribute_notes): Delete REG_LIBCALL_ID case.\n+\t* dce.c (something_changed): Delete.\n+\t(libcall_dead_p): New predicate.\n+\t(delete_unmarked_insns): Use it to delete dead libcalls.\n+\tDeal with REG_LIBCALL and REG_RETVAL notes.\n+\t(prescan_libcall_for_dce): New function.\n+\t(prescan_insns_for_dce): Use it to deal with libcalls.\n+\t(mark_reg_dependencies): Do nothing special for libcalls.\n+\t(dce_process_block): Likewise.\n+\t(fast_dce): Delete unused local variable.\n+\t(run_fast_dce): Do not return a value.\n+\t* dce.h (struct df): Delete.\n+\t(run_fast_dce): Adjust prototype.\n+\t* optabs.c (libcall_id): Delete.\n+\t(maybe_encapsulate_block): Do not emit REG_LIBCALL_ID notes.\n+\t(emit_no_conflict_block): Do not look for REG_LIBCALL_ID notes.\n+\t* reload1.c (reload): Delete REG_LIBCALL_ID case.\n+\t* rtl.h (delete_insn_chain_and_edges): Resurrect prototype.\n+\t* see.c (see_update_relevancy): Look for REG_LIBCALL and REG_RETVAL\n+\tnotes instead of REG_LIBCALL_ID notes.\n+\t* reg-notes.def (LIBCALL_ID): Delete.\n+\t* Makefile.in (see.o): Add dce.h dependency.\n+\t(cfgcleanup.o): Remove dce.h dependency.\n+\n 2007-10-22  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/33855"}, {"sha": "ad62c6ac4ba9c4abc79e4001713e3b4fb9b1ed62", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -2543,7 +2543,7 @@ web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h\n see.o : see.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h \\\n-   $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h $(EXPR_H)\n+   $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h $(EXPR_H) dce.h\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h \\\n@@ -2648,7 +2648,7 @@ cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TIMEVAR_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n    toplev.h insn-config.h cselib.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n    $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) tree-pass.h $(CFGLOOP_H) $(EXPR_H) \\\n-   $(DF_H) dce.h\n+   $(DF_H)\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(FLAGS_H) $(FUNCTION_H) \\\n    $(OBSTACK_H) toplev.h $(TREE_FLOW_H) $(TREE_H) pointer-set.h output.h \\"}, {"sha": "7b2ec0dd76c5c1272df5ca44bda3748a4d2ade35", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -54,7 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"expr.h\"\n #include \"df.h\"\n-#include \"dce.h\"\n \n #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)\n "}, {"sha": "d261b03eb9b669f365fbe3beebc11feeb882ddb3", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -187,6 +187,7 @@ delete_insn (rtx insn)\n }\n \n /* Like delete_insn but also purge dead edges from BB.  */\n+\n rtx\n delete_insn_and_edges (rtx insn)\n {\n@@ -231,6 +232,22 @@ delete_insn_chain (rtx start, rtx finish, bool clear_bb)\n       start = next;\n     }\n }\n+\n+/* Like delete_insn_chain but also purge dead edges from BB.  */\n+\n+void\n+delete_insn_chain_and_edges (rtx first, rtx last)\n+{\n+  bool purge = false;\n+\n+  if (INSN_P (last)\n+      && BLOCK_FOR_INSN (last)\n+      && BB_END (BLOCK_FOR_INSN (last)) == last)\n+    purge = true;\n+  delete_insn_chain (first, last, false);\n+  if (purge)\n+    purge_dead_edges (BLOCK_FOR_INSN (last));\n+}\n \f\n /* Create a new basic block consisting of the instructions between HEAD and END\n    inclusive.  This function is designed to allow fast BB construction - reuses"}, {"sha": "dae0baf8f47cc539a75edccc873703a4f30dcc18", "filename": "gcc/combine.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -12509,15 +12509,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t     to simply delete it.  */\n \t  break;\n \n-\tcase REG_LIBCALL_ID:\n-\t  /* If the insn previously containing this note still exists,\n-\t     put it back where it was.  Otherwise move it to the previous\n-\t     insn.  */\n-\t  if (!NOTE_P (from_insn))\n-\t    place = from_insn;\n-\t  else\n-\t    place = prev_real_insn (from_insn);\n-\t  break;\n \tcase REG_RETVAL:\n \t  /* If the insn previously containing this note still exists,\n \t     put it back where it was.  Otherwise move it to the previous"}, {"sha": "bf8e7a3bc0eb3c39605d49d35a6dd9876e9380d2", "filename": "gcc/dce.c", "status": "modified", "additions": 172, "deletions": 137, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -46,9 +46,6 @@ DEF_VEC_ALLOC_I(int,heap);\n    we don't want to reenter it.  */\n static bool df_in_progress = false;\n \n-/* True if we deleted at least one instruction.  */\n-static bool something_changed;\n-\n /* Instructions that have been marked but whose dependencies have not\n    yet been processed.  */\n static VEC(rtx,heap) *worklist;\n@@ -203,6 +200,62 @@ mark_nonreg_stores (rtx body, rtx insn, bool fast)\n }\n \n \n+/* Return true if the entire libcall sequence starting at INSN is dead.\n+   NOTE is the REG_LIBCALL note attached to INSN.\n+\n+   A libcall sequence is a block of insns with no side-effects, i.e.\n+   that is only used for its return value.  The terminology derives\n+   from that of a call, but a libcall sequence need not contain one.\n+   It is only defined by a pair of REG_LIBCALL/REG_RETVAL notes.\n+\n+   From a dataflow viewpoint, a libcall sequence has the property that\n+   no UD chain can enter it from the outside.  As a consequence, if a\n+   libcall sequence has a dead return value, it is effectively dead.\n+   This is both enforced by CSE (cse_extended_basic_block) and relied\n+   upon by delete_trivially_dead_insns.\n+\n+   However, in practice, the return value business is a tricky one and\n+   only checking the liveness of the last insn is not sufficient to\n+   decide whether the whole sequence is dead (e.g. PR middle-end/19551)\n+   so we check the liveness of every insn starting from the call.  */\n+\n+static bool\n+libcall_dead_p (rtx insn, rtx note)\n+{\n+  rtx last = XEXP (note, 0);\n+\n+  /* Find the call insn.  */\n+  while (insn != last && !CALL_P (insn))\n+    insn = NEXT_INSN (insn);\n+\n+  /* If there is none, do nothing special, since ordinary death handling\n+     can understand these insns.  */\n+  if (!CALL_P (insn))\n+    return false;\n+\n+  /* If this is a call that returns a value via an invisible pointer, the\n+     dataflow engine cannot see it so it has been marked unconditionally.\n+     Skip it unless it has been made the last insn in the libcall, for\n+     example by the combiner, in which case we're left with no easy way\n+     of asserting its liveness.  */\n+  if (!single_set (insn))\n+    {\n+      if (insn == last)\n+\treturn false;\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  while (insn != NEXT_INSN (last))\n+    {\n+      if (INSN_P (insn) && marked_insn_p (insn))\n+\treturn false;\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Delete all REG_EQUAL notes of the registers INSN writes, to prevent\n    bad dangling REG_EQUAL notes. */\n \n@@ -236,116 +289,123 @@ delete_corresponding_reg_eq_notes (rtx insn)\n }\n \n \n-/* Delete every instruction that hasn't been marked.  Clear the insn\n-   from DCE_DF if DF_DELETE is true.  */\n+/* Delete every instruction that hasn't been marked.  */\n \n static void\n delete_unmarked_insns (void)\n {\n   basic_block bb;\n   rtx insn, next;\n \n-  something_changed = false;\n-\n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS_SAFE (bb, insn, next)\n       if (INSN_P (insn))\n \t{\n+\t  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n+\n+\t  /* Always delete no-op moves.  */\n \t  if (noop_move_p (insn))\n+\t    ;\n+\n+\t  /* Try to delete libcall sequences as a whole.  */\n+\t  else if (note && libcall_dead_p (insn, note))\n \t    {\n-\t      /* Note that this code does not handle the case where\n-\t\t the last insn of libcall is deleted.  As it turns out\n-\t\t this case is excluded in the call to noop_move_p.  */\n-\t      rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-\t      if (note && (XEXP (note, 0) != insn))\n-\t\t{\n-\t\t  rtx new_libcall_insn = next_real_insn (insn);\n-\t\t  rtx retval_note = find_reg_note (XEXP (note, 0),\n-\t\t\t\t\t\t   REG_RETVAL, NULL_RTX);\n-\t\t  REG_NOTES (new_libcall_insn)\n-\t\t    = gen_rtx_INSN_LIST (REG_LIBCALL, XEXP (note, 0),\n-\t\t\t\t\t REG_NOTES (new_libcall_insn));\n-\t\t  XEXP (retval_note, 0) = new_libcall_insn;\n-\t\t}\n+\t      rtx last = XEXP (note, 0);\n+\n+\t      if (!dbg_cnt (dce))\n+\t\tcontinue;\n+\n+\t      if (dump_file)\n+\t        fprintf (dump_file, \"DCE: Deleting libcall %d-%d\\n\",\n+\t\t\t INSN_UID (insn), INSN_UID (last));\n+\n+\t      next = NEXT_INSN (last);\n+\t      delete_insn_chain_and_edges (insn, last);\n+\t      continue;\n \t    }\n+\n+\t  /* Otherwise rely only on the DCE algorithm.  */\n \t  else if (marked_insn_p (insn))\n \t    continue;\n \n-\t  /* WARNING, this debugging can itself cause problems if the\n-\t     edge of the counter causes part of a libcall to be\n-\t     deleted but not all of it.  */\n \t  if (!dbg_cnt (dce))\n \t    continue;\n \n \t  if (dump_file)\n \t    fprintf (dump_file, \"DCE: Deleting insn %d\\n\", INSN_UID (insn));\n \n-          /* Before we delete the insn, we have to delete\n-             REG_EQUAL of the destination regs of the deleted insn\n-             to prevent dangling REG_EQUAL. */\n-          delete_corresponding_reg_eq_notes (insn);\n+\t  /* Before we delete the insn we have to delete REG_EQUAL notes\n+\t     for the destination regs in order to avoid dangling notes.  */\n+\t  delete_corresponding_reg_eq_notes (insn);\n \n+\t  /* If we're about to delete the first insn of a libcall, then\n+\t     move the REG_LIBCALL note to the next real insn and update\n+\t     the REG_RETVAL note.  */\n+\t  if (note && (XEXP (note, 0) != insn))\n+\t    {\n+\t      rtx new_libcall_insn = next_real_insn (insn);\n+\t      rtx retval_note = find_reg_note (XEXP (note, 0),\n+\t\t\t\t\t       REG_RETVAL, NULL_RTX);\n+\t      REG_NOTES (new_libcall_insn)\n+\t\t= gen_rtx_INSN_LIST (REG_LIBCALL, XEXP (note, 0),\n+\t\t\t\t     REG_NOTES (new_libcall_insn));\n+\t      XEXP (retval_note, 0) = new_libcall_insn;\n+\t    }\n+\n+\t  /* If the insn contains a REG_RETVAL note and is dead, but the\n+\t     libcall as a whole is not dead, then we want to remove the\n+\t     insn, but not the whole libcall sequence.  However, we also\n+\t     need to remove the dangling REG_LIBCALL note in order to\n+\t     avoid mismatched notes.  We could find a new location for\n+\t     the REG_RETVAL note, but it hardly seems worth the effort.  */\n+\t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n+\t  if (note && (XEXP (note, 0) != insn))\n+\t    {\n+\t      rtx libcall_note\n+\t\t= find_reg_note (XEXP (note, 0), REG_LIBCALL, NULL_RTX);\n+\t      remove_note (XEXP (note, 0), libcall_note);\n+\t    }\n+\n+\t  /* Now delete the insn.  */\n \t  delete_insn_and_edges (insn);\n-\t  something_changed = true;\n \t}\n }\n \n \n-/* Mark all insns using DELETE_PARM in the libcall that contains\n-   START_INSN.  */\n+/* Helper function for prescan_insns_for_dce: prescan the entire libcall\n+   sequence starting at INSN and return the insn following the libcall.\n+   NOTE is the REG_LIBCALL note attached to INSN.  */\n \n-static void \n-mark_libcall (rtx start_insn, bool delete_parm)\n+static rtx\n+prescan_libcall_for_dce (rtx insn, rtx note, bool fast)\n {\n-  rtx note = find_reg_note (start_insn, REG_LIBCALL_ID, NULL_RTX);\n-  int id = INTVAL (XEXP (note, 0));\n-  rtx insn;\n+  rtx last = XEXP (note, 0);\n \n-  mark_insn (start_insn, delete_parm);\n-  insn = NEXT_INSN (start_insn);\n-\n-  /* There are tales, long ago and far away, of the mystical nested\n-     libcall.  No one alive has actually seen one, but other parts of\n-     the compiler support them so we will here.  */\n-  for (insn = NEXT_INSN (start_insn); insn; insn = NEXT_INSN (insn))\n+  /* A libcall is never necessary on its own but we need to mark the stores\n+     to a non-register destination.  */\n+  while (insn != last && !CALL_P (insn))\n     {\n       if (INSN_P (insn))\n-\t{\n-\t  /* Stay in the loop as long as we are in any libcall.  */\n-\t  if ((note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX)))\n-\t    {\n-\t      if (id == INTVAL (XEXP (note, 0)))\n-\t\t{\n-\t\t  mark_insn (insn, delete_parm);\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"matching forward libcall %d[%d]\\n\",\n-\t\t\t     INSN_UID (insn), id);\n-\t\t}\n-\t    }\n-\t  else \n-\t    break;\n-\t}\n+\tmark_nonreg_stores (PATTERN (insn), insn, fast);\n+      insn = NEXT_INSN (insn);\n     }\n-  \n-  for (insn = PREV_INSN (start_insn); insn; insn = PREV_INSN (insn))\n+\n+  /* If this is a call that returns a value via an invisible pointer, the\n+     dataflow engine cannot see it so it has to be marked unconditionally.  */\n+  if (CALL_P (insn) && !single_set (insn))\n+    {\n+      mark_insn (insn, fast);\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  while (insn != NEXT_INSN (last))\n     {\n       if (INSN_P (insn))\n-\t{\n-\t  /* Stay in the loop as long as we are in any libcall.  */\n-\t  if ((note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX)))\n-\t    {\n-\t      if (id == INTVAL (XEXP (note, 0)))\n-\t\t{\n-\t\t  mark_insn (insn, delete_parm);\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"matching backward libcall %d[%d]\\n\",\n-\t\t\t     INSN_UID (insn), id);\n-\t\t}\n-\t    }\n-\t  else \n-\t    break;\n-\t}\n+\tmark_nonreg_stores (PATTERN (insn), insn, fast);\n+      insn = NEXT_INSN (insn);\n     }\n+\n+  return insn;\n }\n \n \n@@ -357,23 +417,23 @@ static void\n prescan_insns_for_dce (bool fast)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx insn, next;\n   \n   if (dump_file)\n     fprintf (dump_file, \"Finding needed instructions:\\n\");\n   \n   FOR_EACH_BB (bb)\n-    FOR_BB_INSNS (bb, insn)\n-    if (INSN_P (insn))\n-      {\n-        rtx note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX);\n-        if (note)\n-          mark_libcall (insn, fast);\n-        else if (deletable_insn_p (insn, fast))\n-          mark_nonreg_stores (PATTERN (insn), insn, fast);\n-        else\n-          mark_insn (insn, fast);\n-      }\n+    FOR_BB_INSNS_SAFE (bb, insn, next)\n+      if (INSN_P (insn))\n+\t{\n+\t  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n+\t  if (note)\n+\t    next = prescan_libcall_for_dce (insn, note, fast);\n+\t  else if (deletable_insn_p (insn, fast))\n+\t    mark_nonreg_stores (PATTERN (insn), insn, fast);\n+\t  else\n+\t    mark_insn (insn, fast);\n+\t}\n \n   if (dump_file)\n     fprintf (dump_file, \"Finished finding needed instructions:\\n\");\n@@ -410,10 +470,6 @@ mark_reg_dependencies (rtx insn)\n   struct df_link *defs;\n   struct df_ref **use_rec;\n \n-  /* If this is part of a libcall, mark the entire libcall.  */\n-  if (find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX))\n-    mark_libcall (insn, false);\n-\n   for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n     {\n       struct df_ref *use = *use_rec;\n@@ -588,42 +644,19 @@ dce_process_block (basic_block bb, bool redo_out)\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (INSN_P (insn))\n       {\n-\t/* If this is a recursive call, the libcall will have already\n-\t   been marked.  */\n-\tif (!marked_insn_p (insn))\n-\t  {\t\n-\t    bool needed = false;\n-\n-\t    /* The insn is needed if there is someone who uses the output.  */\n-\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t      if (bitmap_bit_p (local_live, DF_REF_REGNO (*def_rec))\n-\t\t  || bitmap_bit_p (au, DF_REF_REGNO (*def_rec)))\n-\t\t{\n-\t\t  needed = true;\n-\t\t  break;\n-\t\t}\n+\tbool needed = false;\n+\n+\t/* The insn is needed if there is someone who uses the output.  */\n+\tfor (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t  if (bitmap_bit_p (local_live, DF_REF_REGNO (*def_rec))\n+\t      || bitmap_bit_p (au, DF_REF_REGNO (*def_rec)))\n+\t    {\n+\t      needed = true;\n+\t      break;\n+\t    }\n \t    \n-\t    if (needed)\n-\t      {\n-\t\trtx note = find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX);\n-\n-\t\t/* If we need to mark an insn in the middle of a\n-\t\t   libcall, we need to back up to mark the entire\n-\t\t   libcall.  Given that libcalls are rare, rescanning\n-\t\t   the block should be a reasonable solution to trying\n-\t\t   to figure out how to back up.  */\n-\t\tif (note)\n-\t\t  {\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \"needed libcall %d\\n\", INSN_UID (insn));\n-\t\t    mark_libcall (insn, true);\n-\t\t    BITMAP_FREE (local_live);\n-\t\t    return dce_process_block (bb, false);\n-\t\t  }\n-\t\telse\n-\t\t  mark_insn (insn, true);\n-\t      }\n-\t  }\n+\tif (needed)\n+\t  mark_insn (insn, true);\n \t\n \t/* No matter if the instruction is needed or not, we remove\n \t   any regno in the defs from the live set.  */\n@@ -642,6 +675,7 @@ dce_process_block (basic_block bb, bool redo_out)\n \t  && (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))))\n \tbitmap_clear_bit (local_live, DF_REF_REGNO (def));\n     }\n+\n #ifdef EH_USES\n   /* Process the uses that are live into an exception handler.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n@@ -676,7 +710,7 @@ fast_dce (void)\n   bitmap redo_out = BITMAP_ALLOC (&dce_blocks_bitmap_obstack);\n   bitmap all_blocks = BITMAP_ALLOC (&dce_blocks_bitmap_obstack);\n   bool global_changed = true;\n-  int i, loop_count = 0;\n+  int i;\n \n   prescan_insns_for_dce (true);\n \n@@ -686,6 +720,7 @@ fast_dce (void)\n   while (global_changed)\n     {\n       global_changed = false;\n+\n       for (i = 0; i < n_blocks; i++)\n \t{\n \t  int index = postorder[i];\n@@ -739,9 +774,9 @@ fast_dce (void)\n \n \t  if (old_flag & DF_LR_RUN_DCE)\n \t    df_set_flags (DF_LR_RUN_DCE);\n+\n \t  prescan_insns_for_dce (true);\n \t}\n-      loop_count++;\n     }\n \n   delete_unmarked_insns ();\n@@ -793,22 +828,22 @@ run_fast_df_dce (void)\n }\n \n \n-static bool\n-gate_fast_dce (void)\n+/* Run a fast DCE pass.  */\n+\n+void\n+run_fast_dce (void)\n {\n-  return optimize > 0 && flag_dce;\n+  if (flag_dce)\n+    rest_of_handle_fast_dce ();\n }\n \n \n-/* Run a fast DCE pass and return true if any instructions were deleted.  */\n-\n-bool\n-run_fast_dce (void)\n+static bool\n+gate_fast_dce (void)\n {\n-  return gate_fast_dce () && (rest_of_handle_fast_dce (), something_changed);\n+  return optimize > 0 && flag_dce;\n }\n \n-\n struct tree_opt_pass pass_fast_rtl_dce =\n {\n   \"dce\",                                /* name */"}, {"sha": "2635d49922b8464b6917da6be3db4f70b377578e", "filename": "gcc/dce.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fdce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fdce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.h?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -20,9 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_DCE_H\n #define GCC_DCE_H\n \n-struct df;\n-\n-extern bool run_fast_dce (void);\n+extern void run_fast_dce (void);\n extern void run_fast_df_dce (void);\n \n #endif /* GCC_DCE_H */"}, {"sha": "3344b2cfa66b35658373998f5034ef178cc96cb0", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -99,10 +99,6 @@ static void prepare_float_lib_cmp (rtx *, rtx *, enum rtx_code *,\n \t\t\t\t   enum machine_mode *, int *);\n static rtx expand_unop_direct (enum machine_mode, optab, rtx, rtx, int);\n \n-/* Current libcall id.  It doesn't matter what these are, as long\n-   as they are unique to each libcall that is emitted.  */\n-static HOST_WIDE_INT libcall_id = 0;\n-\n /* Debug facility for use in GDB.  */\n void debug_optab_libfuncs (void);\n \n@@ -3824,12 +3820,6 @@ maybe_encapsulate_block (rtx first, rtx last, rtx equiv)\n \t\t\t\t\t\t REG_NOTES (first));\n \t  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,\n \t\t\t\t\t\tREG_NOTES (last));\n-\t  next = NEXT_INSN (last);\n-\t  for (insn = first; insn != next; insn = NEXT_INSN (insn))\n-\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LIBCALL_ID,\n-\t    \t\t\t\t          GEN_INT (libcall_id),\n-\t\t\t\t\t\t  REG_NOTES (insn));\n-\t  libcall_id++;\n \t}\n     }\n }\n@@ -3890,8 +3880,6 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n \tremove_note (insn, note);\n       if ((note = find_reg_note (insn, REG_RETVAL, NULL)) != NULL)\n \tremove_note (insn, note);\n-      if ((note = find_reg_note (insn, REG_LIBCALL_ID, NULL)) != NULL)\n-\tremove_note (insn, note);\n \n       data.target = target;\n       data.first = insns;\n@@ -4044,8 +4032,6 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n \tremove_note (insn, note);\n       if ((note = find_reg_note (insn, REG_RETVAL, NULL)) != NULL)\n \tremove_note (insn, note);\n-      if ((note = find_reg_note (insn, REG_LIBCALL_ID, NULL)) != NULL)\n-\tremove_note (insn, note);\n \n       next = NEXT_INSN (insn);\n "}, {"sha": "36953242e29857d3017a2511b80442270ee93f31", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -163,7 +163,3 @@ REG_NOTE (CROSSING_JUMP)\n /* This kind of note is generated at each to `setjmp', and similar\n    functions that can return twice.  */\n REG_NOTE (SETJMP)\n-\n-/* This kind of note identifies what libcall id an instruction is part of.  */\n-REG_NOTE (LIBCALL_ID)\n-"}, {"sha": "d0fec9b29af9355fdc2a3b22c25aeb0f5430c080", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -1277,7 +1277,6 @@ reload (rtx first, int global)\n \t\t|| REG_NOTE_KIND (*pnote) == REG_UNUSED\n \t\t|| REG_NOTE_KIND (*pnote) == REG_INC\n \t\t|| REG_NOTE_KIND (*pnote) == REG_RETVAL\n-\t\t|| REG_NOTE_KIND (*pnote) == REG_LIBCALL_ID\n \t\t|| REG_NOTE_KIND (*pnote) == REG_LIBCALL)\n \t      *pnote = XEXP (*pnote, 1);\n \t    else"}, {"sha": "28ab8f60e71f6b8fe1089bb9ed79033607c890db", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -2093,6 +2093,7 @@ extern void emit_insn_at_entry (rtx);\n extern void delete_insn_chain (rtx, rtx, bool);\n extern rtx unlink_insn_chain (rtx, rtx);\n extern rtx delete_insn_and_edges (rtx);\n+extern void delete_insn_chain_and_edges (rtx, rtx);\n extern rtx gen_lowpart_SUBREG (enum machine_mode, rtx);\n extern rtx gen_const_mem (enum machine_mode, rtx);\n extern rtx gen_frame_mem (enum machine_mode, rtx);"}, {"sha": "8191b2d81036e60c8986b74fc74554c72614ba66", "filename": "gcc/see.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -3649,9 +3649,9 @@ see_update_defs_relevancy (rtx insn, struct df_ref *ref,\n \n    The information of the u'th use is stored in use_entry[u] and the\n    information of the d'th definition is stored in def_entry[d].\n-   \n+\n    Currently all the uses are relevant for the optimization except for\n-   uses that are in LIBCALL instructions.  */\n+   uses that are in LIBCALL or RETVAL instructions.  */\n \n static void\n see_update_relevancy (void)\n@@ -3676,13 +3676,12 @@ see_update_relevancy (void)\n \t  unsigned int uid = INSN_UID (insn);\n \t  if (INSN_P (insn))\n \t    {\n-\t      \n-\t      /* If this is an insn in a libcall, do not touch the uses.  */\n-\t      if (find_reg_note (insn, REG_LIBCALL_ID, NULL_RTX))\n+\t      if (find_reg_note (insn, REG_LIBCALL, NULL_RTX)\n+\t\t  || find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t\tet = NOT_RELEVANT;\n \t      else\n \t\tet = RELEVANT_USE;\n-\t      \n+\n \t      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t\t{\n \t\t  struct df_ref *use = *use_rec;"}, {"sha": "01f6cd5b59af1481d0413eb2d44cddee12e4c715", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -1,3 +1,7 @@\n+2007-10-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/pr33644.c: New test.\n+\n 2007-10-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/33372"}, {"sha": "f3f543cbe9911cac70d6aec10fbbab1b264ea827", "filename": "gcc/testsuite/gcc.dg/pr33644.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr33644.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed7b22165e56bcd0236efb3b9ab14641793a4b3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr33644.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr33644.c?ref=9ed7b22165e56bcd0236efb3b9ab14641793a4b3", "patch": "@@ -0,0 +1,19 @@\n+/* PR rtl-optimization/33644 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftrapv\" } */\n+\n+extern char *bar (const char *);\n+\n+int *m, *b;\n+\n+void foo (void)\n+{\n+  int *mv;\n+  int p;\n+  char a[17];\n+\n+  p = bar (a) - a;\n+  for (mv = m; mv < b; mv++)\n+    if (p && ((*mv  & 7) != p))\n+      *mv=0;\n+}"}]}