{"sha": "e46f4d7430c5210465791603735ab219ef263c51", "node_id": "C_kwDOANBUbNoAKGU0NmY0ZDc0MzBjNTIxMDQ2NTc5MTYwMzczNWFiMjE5ZWYyNjNjNTE", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-07-05T21:15:28Z"}, "committer": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-07-06T19:00:09Z"}, "message": "diagnostics: Honor #pragma GCC diagnostic in the preprocessor [PR53431]\n\nAs discussed on PR c++/53431, currently, \"#pragma GCC diagnostic\" does\nnot always take effect for diagnostics generated by libcpp. The reason\nis that libcpp itself does not interpret this pragma and only sends it on\nto the frontend, hence the pragma is only honored if the frontend\narranges for it. The C frontend does process the pragma immediately\n(more or less) after seeing the token, so things work fine there. The PR\npoints out that it doesn't work for C++, because the C++ frontend\ndoesn't handle anything until it has read all the tokens from\nlibcpp. The underlying problem is not C++-specific, though, and for\ninstance, gcc -E has the same issue.\n\nThis commit fixes the PR by adding the concept of an early pragma handler that\ncan be registered by frontends, which gives them a chance to process\ndiagnostic pragmas from libcpp before it is too late for them to take\neffect. The C++ and preprocess-only frontends are modified to use early\npragmas and correct the behavior.\n\ngcc/c-family/ChangeLog:\n\n\tPR preprocessor/53920\n\tPR c++/53431\n\t* c-common.cc (c_option_is_from_cpp_diagnostics): New function.\n\t* c-common.h (c_option_is_from_cpp_diagnostics): Declare.\n\t(c_pp_stream_token): Declare.\n\t* c-ppoutput.cc (init_pp_output): Refactor logic about skipping\n\tpragmas to...\n\t(should_output_pragmas): ...here. New function.\n\t(token_streamer::stream): Support handling early pragmas.\n\t(do_line_change): Likewise.\n\t(c_pp_stream_token): New function.\n\t* c-pragma.cc (struct pragma_diagnostic_data): New helper class.\n\t(pragma_diagnostic_lex_normal): New function. Moved logic for\n\tinterpreting GCC diagnostic pragmas here.\n\t(pragma_diagnostic_lex_pp): New function for parsing diagnostic pragmas\n\tdirectly from libcpp.\n\t(handle_pragma_diagnostic): Refactor into helper function...\n\t(handle_pragma_diagnostic_impl): ...here.  New function.\n\t(handle_pragma_diagnostic_early): New function.\n\t(handle_pragma_diagnostic_early_pp): New function.\n\t(struct pragma_ns_name): Renamed to...\n\t(struct pragma_pp_data): ...this.  Add new \"early_handler\" member.\n\t(c_register_pragma_1): Support early pragmas in the preprocessor.\n\t(c_register_pragma_with_early_handler): New function.\n\t(c_register_pragma): Support the new early handlers in struct\n\tinternal_pragma_handler.\n\t(c_register_pragma_with_data): Likewise.\n\t(c_register_pragma_with_expansion): Likewise.\n\t(c_register_pragma_with_expansion_and_data): Likewise.\n\t(c_invoke_early_pragma_handler): New function.\n\t(c_pp_invoke_early_pragma_handler): New function.\n\t(init_pragma): Add early pragma support for diagnostic pragmas.\n\t* c-pragma.h (struct internal_pragma_handler): Add new early handler\n\tmembers.\n\t(c_register_pragma_with_early_handler): Declare.\n\t(c_invoke_early_pragma_handler): Declare.\n\t(c_pp_invoke_early_pragma_handler): Declare.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/53431\n\t* parser.cc (cp_parser_pragma_kind): Move earlier in the file.\n\t(cp_lexer_handle_early_pragma): New function.\n\t(cp_lexer_new_main): Support parsing and handling early pragmas.\n\t(c_parse_file): Adapt to changes in cp_lexer_new_main.\n\ngcc/testsuite/ChangeLog:\n\n\tPR preprocessor/53920\n\tPR c++/53431\n\t* c-c++-common/pragma-diag-11.c: New test.\n\t* c-c++-common/pragma-diag-12.c: New test.\n\t* c-c++-common/pragma-diag-13.c: New test.", "tree": {"sha": "b30bcd37b4da28ccf92c9c5d93886467cf95e123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b30bcd37b4da28ccf92c9c5d93886467cf95e123"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e46f4d7430c5210465791603735ab219ef263c51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e46f4d7430c5210465791603735ab219ef263c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e46f4d7430c5210465791603735ab219ef263c51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e46f4d7430c5210465791603735ab219ef263c51/comments", "author": null, "committer": null, "parents": [{"sha": "208fbc779c713715da1465a1a2c6710c084c9b05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208fbc779c713715da1465a1a2c6710c084c9b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/208fbc779c713715da1465a1a2c6710c084c9b05"}], "stats": {"total": 648, "additions": 506, "deletions": 142}, "files": [{"sha": "1b8e73f7bc5d88144c3f6ada09ca24f3b463166c", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -6611,6 +6611,20 @@ c_option_controlling_cpp_diagnostic (enum cpp_warning_reason reason)\n   return 0;\n }\n \n+/* Return TRUE if the given option index corresponds to a diagnostic\n+   issued by libcpp.  Linear search seems fine for now.  */\n+bool\n+c_option_is_from_cpp_diagnostics (int option_index)\n+{\n+  for (auto entry = cpp_reason_option_codes; entry->reason != CPP_W_NONE;\n+       ++entry)\n+    {\n+      if (entry->option_code == option_index)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Callback from cpp_diagnostic for PFILE to print diagnostics from the\n    preprocessor.  The diagnostic is of type LEVEL, with REASON set\n    to the reason code if LEVEL is represents a warning, at location"}, {"sha": "c0900848965a30a6da3121d7f10843e611173c26", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -911,6 +911,7 @@ extern tree fold_for_warn (tree);\n extern tree c_common_get_narrower (tree, int *);\n extern bool get_attribute_operand (tree, unsigned HOST_WIDE_INT *);\n extern void c_common_finalize_early_debug (void);\n+extern bool c_option_is_from_cpp_diagnostics (int);\n \n /* Used by convert_and_check; in front ends.  */\n extern tree convert_init (tree, tree);\n@@ -1191,6 +1192,7 @@ extern void preprocess_file (cpp_reader *);\n extern void pp_file_change (const line_map_ordinary *);\n extern void pp_dir_change (cpp_reader *, const char *);\n extern bool check_missing_format_attribute (tree, tree);\n+extern void c_pp_stream_token (cpp_reader *, const cpp_token *, location_t loc);\n \n /* In c-omp.cc  */\n typedef wide_int_bitmask omp_clause_mask;"}, {"sha": "cd38c969ea077adbf17c2539407f582574183d28", "filename": "gcc/c-family/c-ppoutput.cc", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-ppoutput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-ppoutput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ppoutput.cc?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -25,6 +25,8 @@\n #include \"c-pragma.h\"\t\t/* For parse_in.  */\n #include \"file-prefix-map.h\"    /* remap_macro_filename()  */\n \n+class token_streamer;\n+\n /* Encapsulates state used to convert a stream of tokens into a text\n    file.  */\n static struct\n@@ -38,6 +40,8 @@ static struct\n   bool prev_was_system_token;\t/* True if the previous token was a\n \t\t\t\t   system token.*/\n   const char *src_file;\t\t/* Current source file.  */\n+  token_streamer *streamer;     /* Instance of class token_streamer using this\n+\t\t\t\t   object.  */\n } print;\n \n /* Defined and undefined macros being queued for output with -dU at\n@@ -110,6 +114,14 @@ preprocess_file (cpp_reader *pfile)\n     putc ('\\n', print.outf);\n }\n \n+/* Don't emit #pragma or #ident directives if we are processing\n+   assembly language; the assembler may choke on them.  */\n+static bool\n+should_output_pragmas ()\n+{\n+  return cpp_get_options (parse_in)->lang != CLK_ASM;\n+}\n+\n /* Set up the callbacks as appropriate.  */\n void\n init_pp_output (FILE *out_stream)\n@@ -119,9 +131,7 @@ init_pp_output (FILE *out_stream)\n   if (!flag_no_output)\n     {\n       cb->line_change = cb_line_change;\n-      /* Don't emit #pragma or #ident directives if we are processing\n-\t assembly language; the assembler may choke on them.  */\n-      if (cpp_get_options (parse_in)->lang != CLK_ASM)\n+      if (should_output_pragmas ())\n \t{\n \t  cb->ident      = cb_ident;\n \t  cb->def_pragma = cb_def_pragma;\n@@ -163,6 +173,7 @@ init_pp_output (FILE *out_stream)\n   print.first_time = 1;\n   print.src_file = \"\";\n   print.prev_was_system_token = false;\n+  print.streamer = nullptr;\n }\n \n // FIXME: Ideally we'd just turn the entirety of the print struct into\n@@ -183,6 +194,8 @@ class token_streamer\n     in_pragma (false),\n     line_marker_emitted (false)\n     {\n+      gcc_assert (!print.streamer);\n+      print.streamer = this;\n     }\n \n   void begin_pragma () \n@@ -235,7 +248,7 @@ token_streamer::stream (cpp_reader *pfile, const cpp_token *token,\n \t  print.printed = true;\n \t}\n     }\n-  else if (token->flags & PREV_WHITE)\n+  else if (token->flags & PREV_WHITE && token->type != CPP_PRAGMA)\n     {\n       unsigned src_line = LOCATION_LINE (loc);\n \n@@ -252,22 +265,28 @@ token_streamer::stream (cpp_reader *pfile, const cpp_token *token,\n   print.prev = token;\n   if (token->type == CPP_PRAGMA)\n     {\n-      const char *space;\n-      const char *name;\n-\n-      line_marker_emitted = maybe_print_line (token->src_loc);\n-      fputs (\"#pragma \", print.outf);\n-      c_pp_lookup_pragma (token->val.pragma, &space, &name);\n-      if (space)\n-\tfprintf (print.outf, \"%s %s\", space, name);\n-      else\n-\tfprintf (print.outf, \"%s\", name);\n-      print.printed = true;\n       in_pragma = true;\n+      if (should_output_pragmas ())\n+\t{\n+\t  const char *space;\n+\t  const char *name;\n+\n+\t  line_marker_emitted = maybe_print_line (token->src_loc);\n+\t  fputs (\"#pragma \", print.outf);\n+\t  c_pp_lookup_pragma (token->val.pragma, &space, &name);\n+\t  if (space)\n+\t    fprintf (print.outf, \"%s %s\", space, name);\n+\t  else\n+\t    fprintf (print.outf, \"%s\", name);\n+\t  print.printed = true;\n+\t}\n+      if (token->val.pragma >= PRAGMA_FIRST_EXTERNAL)\n+\tc_pp_invoke_early_pragma_handler (token->val.pragma);\n     }\n   else if (token->type == CPP_PRAGMA_EOL)\n     {\n-      maybe_print_line (UNKNOWN_LOCATION);\n+      if (should_output_pragmas ())\n+\tmaybe_print_line (UNKNOWN_LOCATION);\n       in_pragma = false;\n     }\n   else\n@@ -287,9 +306,12 @@ token_streamer::stream (cpp_reader *pfile, const cpp_token *token,\n \t  do_line_change (pfile, token, loc, false);\n \t  print.prev_was_system_token = !!in_system_header_at (loc);\n \t}\n-      cpp_output_token (token, print.outf);\n-      line_marker_emitted = false;\n-      print.printed = true;\n+      if (!in_pragma || should_output_pragmas ())\n+\t{\n+\t  cpp_output_token (token, print.outf);\n+\t  line_marker_emitted = false;\n+\t  print.printed = true;\n+\t}\n     }\n \n   /* CPP_COMMENT tokens and raw-string literal tokens can have\n@@ -561,8 +583,12 @@ do_line_change (cpp_reader *pfile, const cpp_token *token,\n      one space per column greater than 2, since scan_translation_unit\n      will provide a space if PREV_WHITE.  Don't bother trying to\n      reconstruct tabs; we can't get it right in general, and nothing\n-     ought to care.  Some things do care; the fault lies with them.  */\n-  if (!CPP_OPTION (pfile, traditional))\n+     ought to care.  Some things do care; the fault lies with them.\n+\n+     Also do not output the spaces if this is a CPP_PRAGMA token.  In this\n+     case, libcpp has provided the location of the first token after #pragma,\n+     so we would start at the wrong column.  */\n+  if (!CPP_OPTION (pfile, traditional) && token->type != CPP_PRAGMA)\n     {\n       int spaces = LOCATION_COLUMN (src_loc) - 2;\n       print.printed = true;\n@@ -782,6 +808,16 @@ cb_def_pragma (cpp_reader *pfile, location_t line)\n   print.src_line++;\n }\n \n+/* Stream a token as if we had seen it directly ourselves; needed\n+   in case a token was lexed externally, e.g. while processing a\n+   pragma.  */\n+void\n+c_pp_stream_token (cpp_reader *pfile, const cpp_token *tok, location_t loc)\n+{\n+  gcc_assert (print.streamer);\n+  print.streamer->stream (pfile, tok, loc);\n+}\n+\n /* Dump out the hash table.  */\n static int\n dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)"}, {"sha": "62bce2ed0f586d4855ec40756b82c5c2f099c974", "filename": "gcc/c-family/c-pragma.cc", "status": "modified", "additions": 330, "deletions": 95, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-pragma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-pragma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.cc?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -764,139 +764,324 @@ handle_pragma_visibility (cpp_reader *)\n     warning (OPT_Wpragmas, \"junk at end of %<#pragma GCC visibility%>\");\n }\n \n+/* Helper routines for parsing #pragma GCC diagnostic.  */\n+class pragma_diagnostic_data\n+{\n+  pragma_diagnostic_data (const pragma_diagnostic_data &) = delete;\n+  pragma_diagnostic_data& operator= (const pragma_diagnostic_data &) = delete;\n+\n+public:\n+  bool valid;\n+  location_t loc_kind, loc_option;\n+  enum pd_kind_t\n+    {\n+      PK_INVALID,\n+      PK_PUSH,\n+      PK_POP,\n+      PK_IGNORED_ATTRIBUTES,\n+      PK_DIAGNOSTIC,\n+    } pd_kind;\n+  diagnostic_t diagnostic_kind;\n+  const char *kind_str;\n+  const char *option_str;\n+  bool own_option_str;\n+\n+  pragma_diagnostic_data () { clear (); }\n+  void clear ()\n+  {\n+    valid = false;\n+    loc_kind = loc_option = UNKNOWN_LOCATION;\n+    pd_kind = PK_INVALID;\n+    diagnostic_kind = DK_UNSPECIFIED;\n+    kind_str = option_str = nullptr;\n+    own_option_str = false;\n+  }\n+\n+  ~pragma_diagnostic_data ()\n+  {\n+    if (own_option_str && option_str)\n+      XDELETEVEC (const_cast<char *> (option_str));\n+  }\n+\n+  void set_kind (const char *kind_string)\n+  {\n+    kind_str = kind_string;\n+\n+    pd_kind = PK_INVALID;\n+    diagnostic_kind = DK_UNSPECIFIED;\n+    if (strcmp (kind_str, \"push\") == 0)\n+      pd_kind = PK_PUSH;\n+    else if (strcmp (kind_str, \"pop\") == 0)\n+      pd_kind = PK_POP;\n+    else if (strcmp (kind_str, \"ignored_attributes\") == 0)\n+      pd_kind = PK_IGNORED_ATTRIBUTES;\n+    else if (strcmp (kind_str, \"error\") == 0)\n+      {\n+\tpd_kind = PK_DIAGNOSTIC;\n+\tdiagnostic_kind = DK_ERROR;\n+      }\n+    else if (strcmp (kind_str, \"warning\") == 0)\n+      {\n+\tpd_kind = PK_DIAGNOSTIC;\n+\tdiagnostic_kind = DK_WARNING;\n+      }\n+    else if (strcmp (kind_str, \"ignored\") == 0)\n+      {\n+\tpd_kind = PK_DIAGNOSTIC;\n+\tdiagnostic_kind = DK_IGNORED;\n+      }\n+  }\n+\n+  bool needs_option () const\n+  {\n+    return pd_kind == PK_IGNORED_ATTRIBUTES\n+      || pd_kind == PK_DIAGNOSTIC;\n+  }\n+\n+};\n+\n+/* When compiling normally, use pragma_lex () to obtain the needed tokens.\n+   This will call into either the C or C++ frontends as appropriate.  */\n+\n static void\n-handle_pragma_diagnostic(cpp_reader *)\n+pragma_diagnostic_lex_normal (pragma_diagnostic_data *result)\n {\n+  result->clear ();\n   tree x;\n-  location_t loc;\n-  enum cpp_ttype token = pragma_lex (&x, &loc);\n-  if (token != CPP_NAME)\n+  auto ttype = pragma_lex (&x, &result->loc_kind);\n+  if (ttype != CPP_NAME)\n+    return;\n+  result->set_kind (IDENTIFIER_POINTER (x));\n+  if (result->pd_kind == pragma_diagnostic_data::PK_INVALID)\n+    return;\n+\n+  if (result->needs_option ())\n     {\n-      warning_at (loc, OPT_Wpragmas,\n-\t\t  \"missing %<error%>, %<warning%>, %<ignored%>, %<push%>, \"\n-\t\t  \"%<pop%>, or %<ignored_attributes%> after \"\n-\t\t  \"%<#pragma GCC diagnostic%>\");\n-      return;\n+      ttype = pragma_lex (&x, &result->loc_option);\n+      if (ttype != CPP_STRING)\n+\treturn;\n+      result->option_str = TREE_STRING_POINTER (x);\n     }\n \n-  diagnostic_t kind;\n-  const char *kind_string = IDENTIFIER_POINTER (x);\n-  if (strcmp (kind_string, \"error\") == 0)\n-    kind = DK_ERROR;\n-  else if (strcmp (kind_string, \"warning\") == 0)\n-    kind = DK_WARNING;\n-  else if (strcmp (kind_string, \"ignored\") == 0)\n-    kind = DK_IGNORED;\n-  else if (strcmp (kind_string, \"push\") == 0)\n+  result->valid = true;\n+}\n+\n+/* When preprocessing only, pragma_lex () is not available, so obtain the\n+   tokens directly from libcpp.  We also need to inform the token streamer\n+   about all tokens we lex ourselves here, so it outputs them too; this is\n+   done by calling c_pp_stream_token () for each.\n+\n+   ???  If we need to support more pragmas in the future, maybe initialize\n+   this_parser with the pragma tokens and call pragma_lex () instead?  */\n+\n+static void\n+pragma_diagnostic_lex_pp (pragma_diagnostic_data *result)\n+{\n+  result->clear ();\n+\n+  auto tok = cpp_get_token_with_location (parse_in, &result->loc_kind);\n+  c_pp_stream_token (parse_in, tok, result->loc_kind);\n+  if (!(tok->type == CPP_NAME || tok->type == CPP_KEYWORD))\n+    return;\n+  const unsigned char *const kind_u = cpp_token_as_text (parse_in, tok);\n+  result->set_kind ((const char *)kind_u);\n+  if (result->pd_kind == pragma_diagnostic_data::PK_INVALID)\n+    return;\n+\n+  if (result->needs_option ())\n     {\n-      diagnostic_push_diagnostics (global_dc, input_location);\n-      return;\n+      tok = cpp_get_token_with_location (parse_in, &result->loc_option);\n+      c_pp_stream_token (parse_in, tok, result->loc_option);\n+      if (tok->type != CPP_STRING)\n+\treturn;\n+      cpp_string str;\n+      if (!cpp_interpret_string_notranslate (parse_in, &tok->val.str, 1, &str,\n+\t\t\t\t\t     CPP_STRING)\n+\t  || !str.len)\n+\treturn;\n+      result->option_str = (const char *)str.text;\n+      result->own_option_str = true;\n     }\n-  else if (strcmp (kind_string, \"pop\") == 0)\n+\n+  result->valid = true;\n+}\n+\n+/* Handle #pragma GCC diagnostic.  Early mode is used by frontends (such as C++)\n+   that do not process the deferred pragma while they are consuming tokens; they\n+   can use early mode to make sure diagnostics affecting the preprocessor itself\n+   are correctly modified by the #pragma.  */\n+template<bool early, bool is_pp> static void\n+handle_pragma_diagnostic_impl ()\n+{\n+  static const bool want_diagnostics = (is_pp || !early);\n+\n+  pragma_diagnostic_data data;\n+  if (is_pp)\n+    pragma_diagnostic_lex_pp (&data);\n+  else\n+    pragma_diagnostic_lex_normal (&data);\n+\n+  if (!data.kind_str)\n     {\n-      diagnostic_pop_diagnostics (global_dc, input_location);\n+      if (want_diagnostics)\n+\twarning_at (data.loc_kind, OPT_Wpragmas,\n+\t\t    \"missing %<error%>, %<warning%>, %<ignored%>, %<push%>, \"\n+\t\t    \"%<pop%>, or %<ignored_attributes%> after \"\n+\t\t    \"%<#pragma GCC diagnostic%>\");\n       return;\n     }\n-  else if (strcmp (kind_string, \"ignored_attributes\") == 0)\n+\n+  switch (data.pd_kind)\n     {\n-      token = pragma_lex (&x, &loc);\n-      if (token != CPP_STRING)\n-\t{\n-\t  warning_at (loc, OPT_Wpragmas,\n-\t\t      \"missing attribute name after %<#pragma GCC diagnostic \"\n-\t\t      \"ignored_attributes%>\");\n-\t  return;\n-\t}\n-      char *args = xstrdup (TREE_STRING_POINTER (x));\n-      const size_t l = strlen (args);\n-      if (l == 0)\n-\t{\n-\t  warning_at (loc, OPT_Wpragmas, \"missing argument to %<#pragma GCC \"\n-\t\t      \"diagnostic ignored_attributes%>\");\n-\t  free (args);\n+\n+    case pragma_diagnostic_data::PK_PUSH:\n+      diagnostic_push_diagnostics (global_dc, input_location);\n+      return;\n+\n+    case pragma_diagnostic_data::PK_POP:\n+      diagnostic_pop_diagnostics (global_dc, input_location);\n+      return;\n+\n+    case pragma_diagnostic_data::PK_IGNORED_ATTRIBUTES:\n+      {\n+\tif (early)\n \t  return;\n-\t}\n-      else if (args[l - 1] == ',')\n+\tif (!data.option_str)\n+\t  {\n+\t    warning_at (data.loc_option, OPT_Wpragmas,\n+\t\t       \"missing attribute name after %<#pragma GCC diagnostic \"\n+\t\t\t\"ignored_attributes%>\");\n+\t    return;\n+\t  }\n+\tchar *args = xstrdup (data.option_str);\n+\tconst size_t l = strlen (args);\n+\tif (l == 0)\n+\t  {\n+\t    warning_at (data.loc_option, OPT_Wpragmas,\n+\t\t\t\"missing argument to %<#pragma GCC \"\n+\t\t\t\"diagnostic ignored_attributes%>\");\n+\t    free (args);\n+\t    return;\n+\t  }\n+\telse if (args[l - 1] == ',')\n+\t  {\n+\t    warning_at (data.loc_option, OPT_Wpragmas,\n+\t\t\t\"trailing %<,%> in arguments for \"\n+\t\t\t\"%<#pragma GCC diagnostic ignored_attributes%>\");\n+\t    free (args);\n+\t    return;\n+\t  }\n+\tauto_vec<char *> v;\n+\tfor (char *p = strtok (args, \",\"); p; p = strtok (NULL, \",\"))\n+\t  v.safe_push (p);\n+\thandle_ignored_attributes_option (&v);\n+\tfree (args);\n+\treturn;\n+      }\n+\n+    case pragma_diagnostic_data::PK_DIAGNOSTIC:\n+      if (!data.option_str)\n \t{\n-\t  warning_at (loc, OPT_Wpragmas, \"trailing %<,%> in arguments for \"\n-\t\t      \"%<#pragma GCC diagnostic ignored_attributes%>\");\n-\t  free (args);\n+\t  if (want_diagnostics)\n+\t    warning_at (data.loc_option, OPT_Wpragmas,\n+\t\t\t\"missing option after %<#pragma GCC diagnostic%> kind\");\n \t  return;\n \t}\n-      auto_vec<char *> v;\n-      for (char *p = strtok (args, \",\"); p; p = strtok (NULL, \",\"))\n-\tv.safe_push (p);\n-      handle_ignored_attributes_option (&v);\n-      free (args);\n-      return;\n-    }\n-  else\n-    {\n-      warning_at (loc, OPT_Wpragmas,\n-\t\t  \"expected %<error%>, %<warning%>, %<ignored%>, %<push%>, \"\n-\t\t  \"%<pop%>, %<ignored_attributes%> after \"\n-\t\t  \"%<#pragma GCC diagnostic%>\");\n-      return;\n-    }\n+      break;\n \n-  token = pragma_lex (&x, &loc);\n-  if (token != CPP_STRING)\n-    {\n-      warning_at (loc, OPT_Wpragmas,\n-\t\t  \"missing option after %<#pragma GCC diagnostic%> kind\");\n+    default:\n+      if (want_diagnostics)\n+\twarning_at (data.loc_kind, OPT_Wpragmas,\n+\t\t    \"expected %<error%>, %<warning%>, %<ignored%>, %<push%>, \"\n+\t\t    \"%<pop%>, %<ignored_attributes%> after \"\n+\t\t    \"%<#pragma GCC diagnostic%>\");\n       return;\n+\n     }\n \n-  const char *option_string = TREE_STRING_POINTER (x);\n+  gcc_assert (data.pd_kind == pragma_diagnostic_data::PK_DIAGNOSTIC);\n+  gcc_assert (data.valid);\n+\n   unsigned int lang_mask = c_common_option_lang_mask () | CL_COMMON;\n   /* option_string + 1 to skip the initial '-' */\n-  unsigned int option_index = find_opt (option_string + 1, lang_mask);\n+  unsigned int option_index = find_opt (data.option_str + 1, lang_mask);\n+\n+  if (early && !c_option_is_from_cpp_diagnostics (option_index))\n+    return;\n+\n+  const char *arg = NULL;\n+  if (cl_options[option_index].flags & CL_JOINED)\n+    arg = data.option_str + 1 + cl_options[option_index].opt_len;\n+\n   if (option_index == OPT_SPECIAL_unknown)\n     {\n-      auto_diagnostic_group d;\n-      if (warning_at (loc, OPT_Wpragmas,\n-\t\t      \"unknown option after %<#pragma GCC diagnostic%> kind\"))\n+      if (want_diagnostics)\n \t{\n-\t  option_proposer op;\n-\t  const char *hint = op.suggest_option (option_string + 1);\n-\t  if (hint)\n-\t    inform (loc, \"did you mean %<-%s%>?\", hint);\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (data.loc_option, OPT_Wpragmas,\n+\t\t\t\"unknown option after %<#pragma GCC diagnostic%> kind\"))\n+\t    {\n+\t      option_proposer op;\n+\t      const char *hint = op.suggest_option (data.option_str + 1);\n+\t      if (hint)\n+\t\tinform (data.loc_option, \"did you mean %<-%s%>?\", hint);\n+\t    }\n \t}\n       return;\n     }\n   else if (!(cl_options[option_index].flags & CL_WARNING))\n     {\n-      warning_at (loc, OPT_Wpragmas,\n-\t\t  \"%qs is not an option that controls warnings\", option_string);\n+      if (want_diagnostics)\n+\twarning_at (data.loc_option, OPT_Wpragmas,\n+\t\t    \"%qs is not an option that controls warnings\",\n+\t\t    data.option_str);\n       return;\n     }\n   else if (!(cl_options[option_index].flags & lang_mask))\n     {\n-      char *ok_langs = write_langs (cl_options[option_index].flags);\n-      char *bad_lang = write_langs (c_common_option_lang_mask ());\n-      warning_at (loc, OPT_Wpragmas,\n-\t\t  \"option %qs is valid for %s but not for %s\",\n-\t\t  option_string, ok_langs, bad_lang);\n-      free (ok_langs);\n-      free (bad_lang);\n+      if (want_diagnostics)\n+\t{\n+\t  char *ok_langs = write_langs (cl_options[option_index].flags);\n+\t  char *bad_lang = write_langs (c_common_option_lang_mask ());\n+\t  warning_at (data.loc_option, OPT_Wpragmas,\n+\t\t      \"option %qs is valid for %s but not for %s\",\n+\t\t      data.option_str, ok_langs, bad_lang);\n+\t  free (ok_langs);\n+\t  free (bad_lang);\n+\t}\n       return;\n     }\n \n   struct cl_option_handlers handlers;\n   set_default_handlers (&handlers, NULL);\n-  const char *arg = NULL;\n-  if (cl_options[option_index].flags & CL_JOINED)\n-    arg = option_string + 1 + cl_options[option_index].opt_len;\n   /* FIXME: input_location isn't the best location here, but it is\n      what we used to do here before and changing it breaks e.g.\n      PR69543 and PR69558.  */\n-  control_warning_option (option_index, (int) kind,\n-\t\t\t  arg, kind != DK_IGNORED,\n+  control_warning_option (option_index, (int) data.diagnostic_kind,\n+\t\t\t  arg, data.diagnostic_kind != DK_IGNORED,\n \t\t\t  input_location, lang_mask, &handlers,\n \t\t\t  &global_options, &global_options_set,\n \t\t\t  global_dc);\n }\n \n+static void\n+handle_pragma_diagnostic (cpp_reader *)\n+{\n+  handle_pragma_diagnostic_impl<false, false> ();\n+}\n+\n+static void\n+handle_pragma_diagnostic_early (cpp_reader *)\n+{\n+  handle_pragma_diagnostic_impl<true, false> ();\n+}\n+\n+static void\n+handle_pragma_diagnostic_early_pp (cpp_reader *)\n+{\n+  handle_pragma_diagnostic_impl<true, true> ();\n+}\n+\n /*  Parse #pragma GCC target (xxx) to set target specific options.  */\n static void\n handle_pragma_target(cpp_reader *)\n@@ -1332,14 +1517,15 @@ handle_pragma_float_const_decimal64 (cpp_reader *)\n \n static vec<internal_pragma_handler> registered_pragmas;\n \n-struct pragma_ns_name\n+struct pragma_pp_data\n {\n   const char *space;\n   const char *name;\n+  pragma_handler_1arg early_handler;\n };\n \n \n-static vec<pragma_ns_name> registered_pp_pragmas;\n+static vec<pragma_pp_data> registered_pp_pragmas;\n \n struct omp_pragma_def { const char *name; unsigned int id; };\n static const struct omp_pragma_def oacc_pragmas[] = {\n@@ -1452,14 +1638,14 @@ c_register_pragma_1 (const char *space, const char *name,\n \n   if (flag_preprocess_only)\n     {\n-      pragma_ns_name ns_name;\n-\n-      if (!allow_expansion)\n+      if (!(allow_expansion || ihandler.early_handler.handler_1arg))\n \treturn;\n \n-      ns_name.space = space;\n-      ns_name.name = name;\n-      registered_pp_pragmas.safe_push (ns_name);\n+      pragma_pp_data pp_data;\n+      pp_data.space = space;\n+      pp_data.name = name;\n+      pp_data.early_handler = ihandler.early_handler.handler_1arg;\n+      registered_pp_pragmas.safe_push (pp_data);\n       id = registered_pp_pragmas.length ();\n       id += PRAGMA_FIRST_EXTERNAL - 1;\n     }\n@@ -1484,10 +1670,17 @@ c_register_pragma_1 (const char *space, const char *name,\n void\n c_register_pragma (const char *space, const char *name,\n                    pragma_handler_1arg handler)\n+{\n+  c_register_pragma_with_early_handler (space, name, handler, nullptr);\n+}\n+void c_register_pragma_with_early_handler (const char *space, const char *name,\n+\t\t\t\t\t   pragma_handler_1arg handler,\n+\t\t\t\t\t   pragma_handler_1arg early_handler)\n {\n   internal_pragma_handler ihandler;\n \n   ihandler.handler.handler_1arg = handler;\n+  ihandler.early_handler.handler_1arg = early_handler;\n   ihandler.extra_data = false;\n   ihandler.data = NULL;\n   c_register_pragma_1 (space, name, ihandler, false);\n@@ -1504,6 +1697,7 @@ c_register_pragma_with_data (const char *space, const char *name,\n   internal_pragma_handler ihandler;\n \n   ihandler.handler.handler_2arg = handler;\n+  ihandler.early_handler.handler_2arg = nullptr;\n   ihandler.extra_data = true;\n   ihandler.data = data;\n   c_register_pragma_1 (space, name, ihandler, false);\n@@ -1523,6 +1717,7 @@ c_register_pragma_with_expansion (const char *space, const char *name,\n   internal_pragma_handler ihandler;\n \n   ihandler.handler.handler_1arg = handler;\n+  ihandler.early_handler.handler_1arg = nullptr;\n   ihandler.extra_data = false;\n   ihandler.data = NULL;\n   c_register_pragma_1 (space, name, ihandler, true);\n@@ -1544,6 +1739,7 @@ c_register_pragma_with_expansion_and_data (const char *space, const char *name,\n   internal_pragma_handler ihandler;\n \n   ihandler.handler.handler_2arg = handler;\n+  ihandler.early_handler.handler_2arg = nullptr;\n   ihandler.extra_data = true;\n   ihandler.data = data;\n   c_register_pragma_1 (space, name, ihandler, true);\n@@ -1570,6 +1766,38 @@ c_invoke_pragma_handler (unsigned int id)\n     }\n }\n \n+/* In contrast to the normal handler, the early handler is optional.  */\n+void\n+c_invoke_early_pragma_handler (unsigned int id)\n+{\n+  internal_pragma_handler *ihandler;\n+  pragma_handler_1arg handler_1arg;\n+  pragma_handler_2arg handler_2arg;\n+\n+  id -= PRAGMA_FIRST_EXTERNAL;\n+  ihandler = &registered_pragmas[id];\n+  if (ihandler->extra_data)\n+    {\n+      handler_2arg = ihandler->early_handler.handler_2arg;\n+      if (handler_2arg)\n+\thandler_2arg (parse_in, ihandler->data);\n+    }\n+  else\n+    {\n+      handler_1arg = ihandler->early_handler.handler_1arg;\n+      if (handler_1arg)\n+\thandler_1arg (parse_in);\n+    }\n+}\n+\n+void\n+c_pp_invoke_early_pragma_handler (unsigned int id)\n+{\n+  const auto data = &registered_pp_pragmas[id - PRAGMA_FIRST_EXTERNAL];\n+  if (data->early_handler)\n+    data->early_handler (parse_in);\n+}\n+\n /* Set up front-end pragmas.  */\n void\n init_pragma (void)\n@@ -1625,7 +1853,14 @@ init_pragma (void)\n \n   c_register_pragma (\"GCC\", \"visibility\", handle_pragma_visibility);\n \n-  c_register_pragma (\"GCC\", \"diagnostic\", handle_pragma_diagnostic);\n+  if (flag_preprocess_only)\n+    c_register_pragma_with_early_handler (\"GCC\", \"diagnostic\",\n+\t\t\t\t\t  nullptr,\n+\t\t\t\t\t  handle_pragma_diagnostic_early_pp);\n+  else\n+    c_register_pragma_with_early_handler (\"GCC\", \"diagnostic\",\n+\t\t\t\t\t  handle_pragma_diagnostic,\n+\t\t\t\t\t  handle_pragma_diagnostic_early);\n   c_register_pragma (\"GCC\", \"target\", handle_pragma_target);\n   c_register_pragma (\"GCC\", \"optimize\", handle_pragma_optimize);\n   c_register_pragma (\"GCC\", \"push_options\", handle_pragma_push_options);"}, {"sha": "de806a647cd18e10ec545288e7150dc6cf775c54", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -219,7 +219,7 @@ union gen_pragma_handler {\n };\n /* Internally used to keep the data of the handler.  */\n struct internal_pragma_handler {\n-  union gen_pragma_handler handler;\n+  union gen_pragma_handler handler, early_handler;\n   /* Permits to know if handler is a pragma_handler_1arg (extra_data is false)\n      or a pragma_handler_2arg (extra_data is true).  */\n   bool extra_data;\n@@ -242,6 +242,17 @@ extern void c_register_pragma_with_expansion_and_data (const char *space,\n                                                        void *data);\n extern void c_invoke_pragma_handler (unsigned int);\n \n+/* Early pragma handlers run in addition to the normal ones.  They can be used\n+   by frontends such as C++ that may want to process some pragmas during lexing\n+   before they start processing them.  */\n+extern void\n+c_register_pragma_with_early_handler (const char *space, const char *name,\n+\t\t\t\t      pragma_handler_1arg handler,\n+\t\t\t\t      pragma_handler_1arg early_handler);\n+extern void c_invoke_early_pragma_handler (unsigned int);\n+extern void c_pp_invoke_early_pragma_handler (unsigned int);\n+\n+\n extern void maybe_apply_pragma_weak (tree);\n extern void maybe_apply_pending_pragma_weaks (void);\n extern tree maybe_apply_renaming_pragma (tree, tree);"}, {"sha": "bf9ea3685f830ba84157ef90af80cf89c84a441e", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -639,8 +639,61 @@ cp_token_is_module_directive (cp_token *token)\n     || token->keyword == RID__IMPORT;\n }\n \n+/* Return TOKEN's pragma_kind if it is CPP_PRAGMA, otherwise\n+   PRAGMA_NONE.  */\n+\n+static enum pragma_kind\n+cp_parser_pragma_kind (cp_token *token)\n+{\n+  if (token->type != CPP_PRAGMA)\n+    return PRAGMA_NONE;\n+  /* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */\n+  return (enum pragma_kind) TREE_INT_CST_LOW (token->u.value);\n+}\n+\n+/* Handle early pragmas such as #pragma GCC diagnostic, which needs to be done\n+   during preprocessing for the case of preprocessing-related diagnostics.  This\n+   is called immediately after pushing the CPP_PRAGMA_EOL token onto\n+   lexer->buffer.  */\n+\n+static void\n+cp_lexer_handle_early_pragma (cp_lexer *lexer)\n+{\n+  const auto first_token = lexer->buffer->address ();\n+  const auto last_token = first_token + lexer->buffer->length () - 1;\n+\n+  /* Back up to the start of the pragma so pragma_lex () can parse it when\n+     c-pragma lib asks it to.  */\n+  auto begin = last_token;\n+  gcc_assert (begin->type == CPP_PRAGMA_EOL);\n+  while (begin->type != CPP_PRAGMA)\n+    {\n+      if (cp_token_is_module_directive (begin))\n+\treturn;\n+      gcc_assert (begin != first_token);\n+      --begin;\n+    }\n+  gcc_assert (!lexer->next_token);\n+  gcc_assert (!lexer->last_token);\n+  lexer->next_token = begin;\n+  lexer->last_token = last_token;\n+\n+  /* Dispatch it.  */\n+  const unsigned int id\n+    = cp_parser_pragma_kind (cp_lexer_consume_token (lexer));\n+  if (id >= PRAGMA_FIRST_EXTERNAL)\n+    c_invoke_early_pragma_handler (id);\n+\n+  /* Reset to normal state.  */\n+  lexer->next_token = lexer->last_token = nullptr;\n+}\n+\n+/* The parser.  */\n+static cp_parser *cp_parser_new (cp_lexer *);\n+static GTY (()) cp_parser *the_parser;\n+\n /* Create a new main C++ lexer, the lexer that gets tokens from the\n-   preprocessor.  */\n+   preprocessor, and also create the main parser.  */\n \n static cp_lexer *\n cp_lexer_new_main (void)\n@@ -662,13 +715,22 @@ cp_lexer_new_main (void)\n   if (modules_p ())\n     filter = module_token_cdtor (parse_in, filter);\n \n+  /* Create the parser now, so we can use it to handle early pragmas.  */\n+  gcc_assert (!the_parser);\n+  the_parser = cp_parser_new (lexer);\n+\n   /* Get the remaining tokens from the preprocessor.  */\n   while (tok->type != CPP_EOF)\n     {\n       if (filter)\n \t/* Process the previous token.  */\n \tmodule_token_lang (tok->type, tok->keyword, tok->u.value,\n \t\t\t   tok->location, filter);\n+\n+      /* Check for early pragmas that need to be handled now.  */\n+      if (tok->type == CPP_PRAGMA_EOL)\n+\tcp_lexer_handle_early_pragma (lexer);\n+\n       tok = vec_safe_push (lexer->buffer, cp_token ());\n       cp_lexer_get_preprocessor_token (C_LEX_STRING_NO_JOIN, tok);\n     }\n@@ -2131,11 +2193,6 @@ pop_unparsed_function_queues (cp_parser *parser)\n \n /* Prototypes.  */\n \n-/* Constructors and destructors.  */\n-\n-static cp_parser *cp_parser_new\n-  (cp_lexer *);\n-\n /* Routines to parse various constructs.\n \n    Those that return `tree' will return the error_mark_node (rather\n@@ -2898,18 +2955,6 @@ cp_parser_is_keyword (cp_token* token, enum rid keyword)\n   return token->keyword == keyword;\n }\n \n-/* Return TOKEN's pragma_kind if it is CPP_PRAGMA, otherwise\n-   PRAGMA_NONE.  */\n-\n-static enum pragma_kind\n-cp_parser_pragma_kind (cp_token *token)\n-{\n-  if (token->type != CPP_PRAGMA)\n-    return PRAGMA_NONE;\n-  /* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */\n-  return (enum pragma_kind) TREE_INT_CST_LOW (token->u.value);\n-}\n-\n /* Helper function for cp_parser_error.\n    Having peeked a token of kind TOK1_KIND that might signify\n    a conflict marker, peek successor tokens to determine\n@@ -47936,11 +47981,7 @@ cp_parser_transaction_cancel (cp_parser *parser)\n   return stmt;\n }\n \f\n-/* The parser.  */\n-\n-static GTY (()) cp_parser *the_parser;\n \n-\f\n /* Special handling for the first token or line in the file.  The first\n    thing in the file might be #pragma GCC pch_preprocess, which loads a\n    PCH file, which is a GC collection point.  So we need to handle this\n@@ -48435,9 +48476,7 @@ c_parse_file (void)\n \n   /* cp_lexer_new_main is called before doing any GC allocation\n      because tokenization might load a PCH file.  */\n-  cp_lexer *lexer = cp_lexer_new_main ();\n-\n-  the_parser = cp_parser_new (lexer);\n+  cp_lexer_new_main ();\n \n   cp_parser_translation_unit (the_parser);\n   class_decl_loc_t::diag_mismatched_tags ();"}, {"sha": "2eef5c418dfb356e6dd326330ac024f92de74326", "filename": "gcc/testsuite/c-c++-common/pragma-diag-11.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-11.c?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wundef\" } */\n+#pragma GCC diagnostic ignored \"-Wundef\"\n+#if FOO\n+#endif\n+#define P _Pragma (\"GCC diagnostic push\") _Pragma (\"GCC diagnostic warning \\\"-Wundef\\\"\")\n+P\n+#if FOO2 /* { dg-warning \"is not defined\" } */\n+#endif\n+#pragma GCC diagnostic pop\n+#if FOO3\n+#endif\n+int i;"}, {"sha": "0043a4287a04205432f62b853e6d2022fc661918", "filename": "gcc/testsuite/c-c++-common/pragma-diag-12.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-12.c?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-E -Wdate-time\" } */\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdate-time\"\n+const char *date = __DATE__;\n+_Pragma (\"GCC diagnostic pop\");\n+const char *date2 = __DATE__; /* { dg-warning \"__DATE__\" } */\n+/* { dg-final { scan-assembler \"#pragma GCC diagnostic push\" } } */\n+/* { dg-final { scan-assembler \"#pragma GCC diagnostic ignored \\\"-Wdate-time\\\"\" } } */\n+/* { dg-final { scan-assembler \"#pragma GCC diagnostic pop\" } } */"}, {"sha": "d67b36556398efb138002ab1482ee7cb7acc81c5", "filename": "gcc/testsuite/c-c++-common/pragma-diag-13.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e46f4d7430c5210465791603735ab219ef263c51/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpragma-diag-13.c?ref=e46f4d7430c5210465791603735ab219ef263c51", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do compile } */\n+#pragma GCC diagnostic /* { dg-warning \"missing\" } */\n+#pragma GCC diagnostic warn /* { dg-warning \"24:expected\" } */\n+#pragma GCC diagnostic ignored \"-Wfoo\" /* { dg-warning \"32:unknown\" } */"}]}