{"sha": "f3997ccf90496a4519cd8ec8f0985202b79f69d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM5OTdjY2Y5MDQ5NmE0NTE5Y2Q4ZWM4ZjA5ODUyMDJiNzlmNjlkMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-08-05T22:41:30Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-05T22:41:30Z"}, "message": "StringWriter.java: Merged with Classpath.\n\n\t* java/io/StringWriter.java: Merged with Classpath.\n\t* java/io/InputStream.java: Merged with Classpath.\n\t* java/io/OutputStream.java: Merged with Classpath.\n\t* java/io/PushbackInputStream.java: Merged with Classpath.\n\t* java/io/CharArrayReader.java: Merged with Classpath.\n\t* java/io/CharArrayWriter.java: Merged with Classpath.\n\nFrom-SVN: r44652", "tree": {"sha": "c8849c2172460473eb01af96a97ce39792895ecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8849c2172460473eb01af96a97ce39792895ecd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3997ccf90496a4519cd8ec8f0985202b79f69d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3997ccf90496a4519cd8ec8f0985202b79f69d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3997ccf90496a4519cd8ec8f0985202b79f69d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3997ccf90496a4519cd8ec8f0985202b79f69d0/comments", "author": null, "committer": null, "parents": [{"sha": "6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6604e6f38d99e2e38f997d3ddb56a8fef06818b2"}], "stats": {"total": 1158, "additions": 979, "deletions": 179}, "files": [{"sha": "c32cf36d691dee75d172f6b9241d94e61994fc74", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f3997ccf90496a4519cd8ec8f0985202b79f69d0", "patch": "@@ -1,3 +1,12 @@\n+2001-08-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/io/StringWriter.java: Merged with Classpath.\n+\t* java/io/InputStream.java: Merged with Classpath.\n+\t* java/io/OutputStream.java: Merged with Classpath.\n+\t* java/io/PushbackInputStream.java: Merged with Classpath.\n+\t* java/io/CharArrayReader.java: Merged with Classpath.\n+\t* java/io/CharArrayWriter.java: Merged with Classpath.\n+\n 2001-08-02  Tom Tromey  <tromey@redhat.com>\n \n \t* prims.cc (JNI_OnLoad): Don't declare."}, {"sha": "4d4fca7fe65a55c00872af944c3aee524e2b1222", "filename": "libjava/java/io/CharArrayReader.java", "status": "modified", "additions": 211, "deletions": 75, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FCharArrayReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FCharArrayReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FCharArrayReader.java?ref=f3997ccf90496a4519cd8ec8f0985202b79f69d0", "patch": "@@ -1,43 +1,103 @@\n-/* Copyright (C) 1998, 1999, 2001  Free Software Foundation\n+/* CharArrayReader.java -- Read an array of characters as a stream\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n  \n package java.io;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 16, 1998.  \n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct\n- */\n- \n+  * This class permits an array of chars to be read as an input stream.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Warren Levy <warrenl@cygnus.com>\n+  */\n public class CharArrayReader extends Reader\n {\n-  /* An array of chars provided by the creator of the stream. */\n+  /**\n+   * The array that contains the data supplied during read operations\n+   */\n   protected char[] buf;\n \n-  /* Position of the next char in buf to be read. */\n+  /**\n+   * The array index of the next char to be read from the buffer\n+   * <code>buf</code>\n+   */\n   protected int pos;\n \n-  /* The currently marked position in the stream. */\n+  /**\n+   * The currently marked position in the stream.  This defaults to 0, so a\n+   * reset operation on the stream resets it to read from array index 0 in\n+   * the buffer - even if the stream was initially created with an offset\n+   * greater than 0\n+   */\n   protected int markedPos;\n \n-  /* The index in buf one greater than the last valid character. */\n+  /**\n+   * This indicates the maximum number of chars that can be read from this\n+   * stream.  It is the array index of the position after the last valid\n+   * char in the buffer <code>buf</code>\n+   */\n   protected int count;\n \n+  /**\n+   * Create a new CharArrayReader that will read chars from the passed\n+   * in char array.  This stream will read from the beginning to the end\n+   * of the array.  It is identical to calling an overloaded constructor\n+   * as <code>CharArrayReader(buf, 0, buf.length)</code>.\n+   * <p>\n+   * Note that this array is not copied.  If its contents are changed \n+   * while this stream is being read, those changes will be reflected in the\n+   * chars supplied to the reader.  Please use caution in changing the \n+   * contents of the buffer while this stream is open.\n+   *\n+   * @param buffer The char array buffer this stream will read from.\n+  */\n   public CharArrayReader(char[] buffer)\n   {\n     this(buffer, 0, buffer.length);\n   }\n \n+  /**\n+   * Create a new CharArrayReader that will read chars from the passed\n+   * in char array.  This stream will read from position\n+   * <code>offset</code> in the array for a length of\n+   * <code>length</code> chars past <code>offset</code>.  If the\n+   * stream is reset to a position before <code>offset</code> then\n+   * more than <code>length</code> chars can be read from the stream.\n+   * The <code>length</code> value should be viewed as the array index\n+   * one greater than the last position in the buffer to read.\n+   * <p>\n+   * Note that this array is not copied.  If its contents are changed \n+   * while this stream is being read, those changes will be reflected in the\n+   * chars supplied to the reader.  Please use caution in changing the \n+   * contents of the buffer while this stream is open.\n+   *\n+   * @param buffer The char array buffer this stream will read from.\n+   * @param offset The index into the buffer to start reading chars from\n+   * @param length The number of chars to read from the buffer\n+   */\n   public CharArrayReader(char[] buffer, int offset, int length)\n   {\n     super();\n@@ -54,72 +114,130 @@ public CharArrayReader(char[] buffer, int offset, int length)\n     markedPos = pos;\n   }\n \n+  /**\n+   * This method closes the stream.\n+   */\n   public void close()\n   {\n     synchronized (lock)\n-    {\n-      buf = null;\n-    }\n+      {\n+\tbuf = null;\n+      }\n   }\n \n+  /**\n+   * This method sets the mark position in this stream to the current\n+   * position.  Note that the <code>readlimit</code> parameter in this\n+   * method does nothing as this stream is always capable of\n+   * remembering all the chars int it.\n+   * <p>\n+   * Note that in this class the mark position is set by default to\n+   * position 0 in the stream.  This is in constrast to some other\n+   * stream types where there is no default mark position.\n+   *\n+   * @param readAheadLimit The number of chars this stream must\n+   *                       remember.  This parameter is ignored.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void mark(int readAheadLimit) throws IOException\n   {\n     synchronized (lock)\n-    {\n-      if (buf == null)\n-\tthrow new IOException(\"Stream closed\");\n-      // readAheadLimit is ignored per Java Class Lib. book, p. 318.\n-      markedPos = pos;\n-    }\n+      {\n+\tif (buf == null)\n+\t  throw new IOException(\"Stream closed\");\n+\t// readAheadLimit is ignored per Java Class Lib. book, p. 318.\n+\tmarkedPos = pos;\n+      }\n   }\n \n+  /**\n+   * This method overrides the <code>markSupported</code> method in\n+   * <code>Reader</code> in order to return <code>true</code> -\n+   * indicating that this stream class supports mark/reset\n+   * functionality.\n+   *\n+   * @return <code>true</code> to indicate that this class supports\n+   * mark/reset.\n+   */\n   public boolean markSupported()\n   {\n     return true;\n   }\n \n+  /**\n+   * This method reads one char from the stream.  The <code>pos</code>\n+   * counter is advanced to the next char to be read.  The char read\n+   * is returned as an int in the range of 0-65535.  If the stream\n+   * position is already at the end of the buffer, no char is read and\n+   * a -1 is returned in order to indicate the end of the stream.\n+   *\n+   * @return The char read, or -1 if end of stream\n+   */\n   public int read() throws IOException\n   {\n     synchronized (lock)\n-    {\n-      if (buf == null)\n-\tthrow new IOException(\"Stream closed\");\n+      {\n+\tif (buf == null)\n+\t  throw new IOException(\"Stream closed\");\n \n-      if (pos < 0)\n-        throw new ArrayIndexOutOfBoundsException(pos);\n+\tif (pos < 0)\n+\t  throw new ArrayIndexOutOfBoundsException(pos);\n \n-      if (pos < count)\n-        return ((int) buf[pos++]) & 0xFFFF;\n-      return -1;\n-    }\n+\tif (pos < count)\n+\t  return ((int) buf[pos++]) & 0xFFFF;\n+\treturn -1;\n+      }\n   }\n \n+  /**\n+   * This method reads chars from the stream and stores them into a\n+   * caller supplied buffer.  It starts storing the data at index\n+   * <code>offset</code> into the buffer and attempts to read\n+   * <code>len</code> chars.  This method can return before reading\n+   * the number of chars requested if the end of the stream is\n+   * encountered first.  The actual number of chars read is returned.\n+   * If no chars can be read because the stream is already at the end\n+   * of stream position, a -1 is returned.\n+   * <p>\n+   * This method does not block.\n+   *\n+   * @param b The array into which the chars read should be stored.\n+   * @param off The offset into the array to start storing chars\n+   * @param len The requested number of chars to read\n+   *\n+   * @return The actual number of chars read, or -1 if end of stream.\n+   */\n   public int read(char[] b, int off, int len) throws IOException\n   {\n     synchronized (lock)\n-    {\n-      if (buf == null)\n-\tthrow new IOException(\"Stream closed\");\n-\n-      /* Don't need to check pos value, arraycopy will check it. */\n-      if (off < 0 || len < 0 || off + len > b.length)\n-        throw new ArrayIndexOutOfBoundsException();\n-\n-      if (pos >= count)\n-        return -1;\n-\n-      int numChars = Math.min(count - pos, len);\n-      System.arraycopy(buf, pos, b, off, numChars);\n-      pos += numChars;\n-      return numChars;\n-    }\n+      {\n+\tif (buf == null)\n+\t  throw new IOException(\"Stream closed\");\n+\n+\t/* Don't need to check pos value, arraycopy will check it. */\n+\tif (off < 0 || len < 0 || off + len > b.length)\n+\t  throw new ArrayIndexOutOfBoundsException();\n+\n+\tif (pos >= count)\n+\t  return -1;\n+\n+\tint numChars = Math.min(count - pos, len);\n+\tSystem.arraycopy(buf, pos, b, off, numChars);\n+\tpos += numChars;\n+\treturn numChars;\n+      }\n   }\n \n-  /** Return true if more characters are available to be read. \n-    *\n-    * @specnote The JDK 1.3 API docs are wrong here. This method will\n-    *           return false if there are no more characters available.\n-    */\n+  /**\n+   * Return true if more characters are available to be read. \n+   *\n+   * @return <code>true</code> to indicate that this stream is ready\n+   * to be read.\n+   *\n+   * @specnote The JDK 1.3 API docs are wrong here. This method will\n+   *           return false if there are no more characters available.\n+   */\n   public boolean ready() throws IOException\n   {\n     if (buf == null)\n@@ -128,31 +246,49 @@ public boolean ready() throws IOException\n     return (pos < count);\n   }\n \n+  /**\n+   * This method sets the read position in the stream to the mark\n+   * point by setting the <code>pos</code> variable equal to the\n+   * <code>mark</code> variable.  Since a mark can be set anywhere in\n+   * the array, the mark/reset methods int this class can be used to\n+   * provide random search capabilities for this type of stream.\n+   */\n   public void reset() throws IOException\n   {\n     synchronized (lock)\n-    {\n-      if (buf == null)\n-\tthrow new IOException(\"Stream closed\");\n+      {\n+\tif (buf == null)\n+\t  throw new IOException(\"Stream closed\");\n \n-      pos = markedPos;\n-    }\n+\tpos = markedPos;\n+      }\n   }\n \n+  /**\n+   * This method attempts to skip the requested number of chars in the\n+   * input stream.  It does this by advancing the <code>pos</code> value by the\n+   * specified number of chars.  It this would exceed the length of the\n+   * buffer, then only enough chars are skipped to position the stream at\n+   * the end of the buffer.  The actual number of chars skipped is returned.\n+   *\n+   * @param n The requested number of chars to skip\n+   *\n+   * @return The actual number of chars skipped.\n+   */\n   public long skip(long n) throws IOException\n   {\n     synchronized (lock)\n-    {\n-      if (buf == null)\n-\tthrow new IOException(\"Stream closed\");\n-\n-      // Even though the var numChars is a long, in reality it can never\n-      // be larger than an int since the result of subtracting 2 positive\n-      // ints will always fit in an int.  Since we have to return a long\n-      // anyway, numChars might as well just be a long.\n-      long numChars = Math.min((long) (count - pos), n < 0 ? 0L : n);\n-      pos += numChars;\n-      return numChars;\n-    }\n+      {\n+\tif (buf == null)\n+\t  throw new IOException(\"Stream closed\");\n+\n+\t// Even though the var numChars is a long, in reality it can never\n+\t// be larger than an int since the result of subtracting 2 positive\n+\t// ints will always fit in an int.  Since we have to return a long\n+\t// anyway, numChars might as well just be a long.\n+\tlong numChars = Math.min((long) (count - pos), n < 0 ? 0L : n);\n+\tpos += numChars;\n+\treturn numChars;\n+      }\n   }\n }"}, {"sha": "44db842fde5652e97d0c336be0c2f962f538e4fc", "filename": "libjava/java/io/CharArrayWriter.java", "status": "modified", "additions": 154, "deletions": 19, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FCharArrayWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FCharArrayWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FCharArrayWriter.java?ref=f3997ccf90496a4519cd8ec8f0985202b79f69d0", "patch": "@@ -1,43 +1,98 @@\n-// CharArrayWriter.java - Character array output stream.\n+/* CharArrayWriter.java -- Write chars to a buffer\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999, 2001  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-package java.io;\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 25, 1998 \n- */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Complete to 1.1.\n- */\n+package java.io;\n \n+/**\n+  * This class allows data to be written to a char array buffer and\n+  * and then retrieved by an application.   The internal char array\n+  * buffer is dynamically resized to hold all the data written.  Please\n+  * be aware that writing large amounts to data to this stream will\n+  * cause large amounts of memory to be allocated.\n+  * <p>\n+  * The size of the internal buffer defaults to 32 and it is resized\n+  * in increments of 1024 chars.  This behavior can be over-ridden by using the\n+  * following two properties:\n+  * <p>\n+  * <ul>\n+  * <li><xmp>gnu.java.io.CharArrayWriter.initialBufferSize</xmp>\n+  * <li><xmp>gnu.java.io.CharArrayWriter.bufferIncrementSize</xmp>\n+  * </ul>\n+  * <p>\n+  * There is a constructor that specified the initial buffer size and\n+  * that is the preferred way to set that value because it it portable\n+  * across all Java class library implementations.\n+  * <p>\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Tom Tromey <tromey@cygnus.com>\n+  */\n public class CharArrayWriter extends Writer\n {\n+  /**\n+   * The default initial buffer size\n+   */\n+  private static final int DEFAULT_INITIAL_BUFFER_SIZE = 32;\n+\n+  /**\n+   * This method initializes a new <code>CharArrayWriter</code> with\n+   * the default buffer size of 32 chars.  If a different initial\n+   * buffer size is desired, see the constructor\n+   * <code>CharArrayWriter(int size)</code>.\n+   */\n   public CharArrayWriter ()\n   {\n-    this (32);\n+    this (DEFAULT_INITIAL_BUFFER_SIZE);\n   }\n \n+  /**\n+   * This method initializes a new <code>CharArrayWriter</code> with\n+   * a specified initial buffer size.\n+   *\n+   * @param size The initial buffer size in chars\n+   */\n   public CharArrayWriter (int size)\n   {\n     super ();\n     buf = new char[size];\n   }\n \n+  /**\n+   * Closes the stream.  This method is guaranteed not to free the contents\n+   * of the internal buffer, which can still be retrieved.\n+   */\n   public void close ()\n   {\n     closed = true;\n   }\n \n+  /**\n+   * This method flushes all buffered chars to the stream.\n+   */\n   public void flush () throws IOException\n   {\n     synchronized (lock)\n@@ -47,6 +102,11 @@ public void flush () throws IOException\n       }\n   }\n \n+  /**\n+   * This method discards all of the chars that have been written to the\n+   * internal buffer so far by setting the <code>count</code> variable to\n+   * 0.  The internal buffer remains at its currently allocated size.\n+   */\n   public void reset ()\n   {\n     synchronized (lock)\n@@ -58,11 +118,31 @@ public void reset ()\n       }\n   }\n \n+  /**\n+   * This method returns the number of chars that have been written to\n+   * the buffer so far.  This is the same as the value of the protected\n+   * <code>count</code> variable.  If the <code>reset</code> method is\n+   * called, then this value is reset as well.  Note that this method does\n+   * not return the length of the internal buffer, but only the number\n+   * of chars that have been written to it.\n+   *\n+   * @return The number of chars in the internal buffer\n+   *\n+   * @see reset\n+   */\n   public int size ()\n   {\n     return count;\n   }\n \n+  /**\n+   * This method returns a char array containing the chars that have been\n+   * written to this stream so far.  This array is a copy of the valid\n+   * chars in the internal buffer and its length is equal to the number of\n+   * valid chars, not necessarily to the the length of the current \n+   * internal buffer.  Note that since this method allocates a new array,\n+   * it should be used with caution when the internal buffer is very large.\n+   */\n   public char[] toCharArray ()\n   {\n     synchronized (lock)\n@@ -73,6 +153,15 @@ public char[] toCharArray ()\n       }\n   }\n \n+  /**\n+   * Returns the chars in the internal array as a <code>String</code>.  The\n+   * chars in the buffer are converted to characters using the system default\n+   * encoding.  There is an overloaded <code>toString()</code> method that\n+   * allows an application specified character encoding to be used.\n+   *\n+   * @return A <code>String</code> containing the data written to this\n+   *         stream so far\n+   */\n   public String toString ()\n   {\n     synchronized (lock)\n@@ -81,6 +170,12 @@ public String toString ()\n       }\n   }\n \n+  /**\n+   * This method writes the writes the specified char into the internal\n+   * buffer.\n+   *\n+   * @param oneChar The char to be read passed as an int\n+   */\n   public void write (int oneChar) throws IOException\n   {\n     synchronized (lock)\n@@ -93,6 +188,14 @@ public void write (int oneChar) throws IOException\n       }\n   }\n \n+  /**\n+   * This method writes <code>len</code> chars from the passed in array \n+   * <code>buf</code> starting at index <code>offset</code> into that buffer\n+   *\n+   * @param buffer The char array to write data from\n+   * @param offset The index into the buffer to start writing data from\n+   * @param len The number of chars to write\n+   */\n   public void write (char[] buffer, int offset, int len) throws IOException\n   {\n     synchronized (lock)\n@@ -107,6 +210,15 @@ public void write (char[] buffer, int offset, int len) throws IOException\n       }\n   }\n \n+  /**\n+   * This method writes <code>len</code> chars from the passed in\n+   * <code>String</code> <code>buf</code> starting at index\n+   * <code>offset</code> into the internal buffer.\n+   *\n+   * @param str The <code>String</code> to write data from\n+   * @param offset The index into the string to start writing data from\n+   * @param len The number of chars to write\n+   */\n   public void write (String str, int offset, int len) throws IOException\n   {\n     synchronized (lock)\n@@ -121,6 +233,14 @@ public void write (String str, int offset, int len) throws IOException\n       }\n   }\n \n+  /**\n+   * This method writes all the chars that have been written to this stream\n+   * from the internal buffer to the specified <code>Writer</code>.\n+   *\n+   * @param out The <code>Writer</code> to write to\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void writeTo (Writer out) throws IOException\n   {\n     synchronized (lock)\n@@ -129,6 +249,13 @@ public void writeTo (Writer out) throws IOException\n       }\n   }\n \n+  /**\n+   * This private method makes the buffer bigger when we run out of room\n+   * by allocating a larger buffer and copying the valid chars from the\n+   * old array into it.  This is obviously slow and should be avoided by\n+   * application programmers by setting their initial buffer size big\n+   * enough to hold everything if possible.\n+   */\n   private final void resize (int len)\n   {\n     if (count + len >= buf.length)\n@@ -142,10 +269,18 @@ private final void resize (int len)\n       }\n   }\n \n-  // The character buffer.\n+  /**\n+   * The internal buffer where the data written is stored\n+   */\n   protected char[] buf;\n-  // Number of valid characters in buffer.\n+\n+  /**\n+   * The number of chars that have been written to the buffer\n+   */\n   protected int count;\n-  // True if stream is closed.\n+\n+  /**\n+   * True if the stream has been closed.\n+   */\n   private boolean closed;\n }"}, {"sha": "0cf1f4322b2cda61f18c67662e44ff2faf643acf", "filename": "libjava/java/io/InputStream.java", "status": "modified", "additions": 182, "deletions": 25, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FInputStream.java?ref=f3997ccf90496a4519cd8ec8f0985202b79f69d0", "patch": "@@ -1,56 +1,185 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* InputStream.java -- Base class for input\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n  \n package java.io;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 2, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n+  * This abstract class forms the base of the hierarchy of classes that read\n+  * input as a stream of bytes.  It provides a common set of methods for\n+  * reading bytes from streams.  Subclasses implement and extend these\n+  * methods to read bytes from a particular input source such as a file\n+  * or network connection.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Warren Levy <warrenl@cygnus.com>\n+  */\n public abstract class InputStream\n {\n+  /**\n+   * Default, no-arg, public constructor\n+   */\n   public InputStream()\n   {\n   }\n \n+  /**\n+   * This method returns the number of bytes that can be read from this\n+   * stream before a read can block.  A return of 0 indicates that blocking\n+   * might (or might not) occur on the very next read attempt.\n+   * <p>\n+   * This method always returns 0 in this class\n+   *\n+   * @return The number of bytes that can be read before blocking could occur\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int available() throws IOException\n   {\n     return 0;\n   }\n \n+  /**\n+   * This method closes the stream.  Any futher attempts to read from the\n+   * stream may generate an <code>IOException</code>\n+   * <p>\n+   * This method does nothing in this class, but subclasses may override\n+   * this method in order to provide additional functionality.\n+   *\n+   * @exception IOException If an error occurs, which can only happen\n+   * in a subclass\n+   */\n   public void close() throws IOException\n   {\n     // Do nothing\n   }\n \n+  /**\n+   * This method marks a position in the input to which the stream can\n+   * be \"reset\" by calling the <code>reset()</code> method.  The\n+   * parameter @code{readlimit} is the number of bytes that can be read\n+   * from the stream after setting the mark before the mark becomes\n+   * invalid.  For example, if <code>mark()</code> is called with a\n+   * read limit of 10, then when 11 bytes of data are read from the\n+   * stream before the <code>reset()</code> method is called, then the\n+   * mark is invalid and the stream object instance is not required to\n+   * remember the mark.\n+   * <p>\n+   * This method does nothing in this class, but subclasses may override it\n+   * to provide mark/reset functionality.\n+   *\n+   * @param readLimit The number of bytes that can be read before the\n+   *                  mark becomes invalid\n+   */\n   public void mark(int readlimit)\n   {\n     // Do nothing\n   }\n \n+  /**\n+   * This method returns a boolean that indicates whether the mark/reset\n+   * methods are supported in this class.  Those methods can be used to\n+   * remember a specific point in the stream and reset the stream to that\n+   * point.\n+   * <p>\n+   * This method always returns <code>false</code> in this class, but\n+   * subclasses can override this method to return </code>true</code>\n+   * if they support mark/reset functionality.\n+   *\n+   * @return <code>true</code> if mark/reset functionality is\n+   * supported, <code>false</code> otherwise \n+   */\n   public boolean markSupported()\n   {\n     return false;\n   }\n \n+  /**\n+   * This method reads an unsigned byte from the input stream and returns it\n+   * as an int in the range of 0-255.  This method also will return -1 if\n+   * the end of the stream has been reached.\n+   * <p>\n+   * This method will block until the byte can be read.\n+   *\n+   * @return The byte read or -1 if end of stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public abstract int read() throws IOException;\n \n+  /**\n+   * This method reads bytes from a stream and stores them into a caller\n+   * supplied buffer.  This method attempts to completely fill the buffer,\n+   * but can return before doing so.  The actual number of bytes read is\n+   * returned as an int.  A -1 is returned to indicate the end of the stream.\n+   * <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * This method operates by calling an overloaded read method like so:\n+   * <code>read(b, 0, b.length)</code>\n+   *\n+   * @param b The buffer into which the bytes read will be stored.\n+   *\n+   * @return The number of bytes read or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public int read(byte[] b) throws IOException\n   {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * This method read bytes from a stream and stores them into a\n+   * caller supplied buffer.  It starts storing the data at index\n+   * <code>off</code> into the buffer and attempts to read\n+   * <code>len</code> bytes.  This method can return before reading the\n+   * number of bytes requested.  The actual number of bytes read is\n+   * returned as an int.  A -1 is returned to indicate the end of the\n+   * stream.\n+   *  <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * This method operates by calling the single byte <code>read()</code> method\n+   * in a loop until the desired number of bytes are read.  The read loop\n+   * stops short if the end of the stream is encountered or if an IOException\n+   * is encountered on any read operation except the first.  If the first\n+   * attempt to read a bytes fails, the IOException is allowed to propagate\n+   * upward.  And subsequent IOException is caught and treated identically\n+   * to an end of stream condition.  Subclasses can (and should if possible)\n+   * override this method to provide a more efficient implementation.\n+   *\n+   * @param b The array into which the bytes read should be stored\n+   * @param off The offset into the array to start storing bytes\n+   * @param len The requested number of bytes to read\n+   *\n+   * @return The actual number of bytes read, or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public int read(byte[] b, int off, int len) throws IOException\n   {\n     if (off < 0 || len < 0 || off + len > b.length)\n@@ -62,27 +191,55 @@ public int read(byte[] b, int off, int len) throws IOException\n \n     for (i = 0; i < len; ++i)\n       try\n-      {\n-        if ((ch = read()) < 0)\n-\t  return i == 0 ? -1 : i;\t\t// EOF\n-        b[off + i] = (byte) ch;\n-      }\n+\t{\n+\t  if ((ch = read()) < 0)\n+\t    return i == 0 ? -1 : i;\t\t// EOF\n+\t  b[off + i] = (byte) ch;\n+\t}\n       catch (IOException ex)\n-      {\n-        // Only reading the first byte should cause an IOException.\n-\tif (i == 0)\n-\t  throw ex;\n-\treturn i;\n-      }\n+\t{\n+\t  // Only reading the first byte should cause an IOException.\n+\t  if (i == 0)\n+\t    throw ex;\n+\t  return i;\n+\t}\n \n     return i;\n   }\n \n+  /**\n+   * This method resets a stream to the point where the\n+   * <code>mark()</code> method was called.  Any bytes that were read\n+   * after the mark point was set will be re-read during subsequent\n+   * reads.\n+   * <p>\n+   * This method always throws an IOException in this class, but subclasses\n+   * can override this method if they provide mark/reset functionality.\n+   *\n+   * @exception IOException Always thrown for this class\n+   */\n   public void reset() throws IOException\n   {\n     throw new IOException(\"mark/reset not supported\");\n   }\n \n+  /**\n+   * This method skips the specified number of bytes in the stream.  It\n+   * returns the actual number of bytes skipped, which may be less than the\n+   * requested amount.\n+   * <p>\n+   * This method reads and discards bytes into a byte array until the\n+   * specified number of bytes were skipped or until either the end of stream\n+   * is reached or a read attempt returns a short count.  Subclasses can\n+   * override this metho to provide a more efficient implementation where\n+   * one exists.\n+   *\n+   * @param n The requested number of bytes to skip\n+   *\n+   * @return The actual number of bytes skipped.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public long skip(long n) throws IOException\n   {\n     // Throw away n bytes by reading them into a temp byte[]."}, {"sha": "d4d9a190cff71303d48f2291e22ec1a960ba7275", "filename": "libjava/java/io/OutputStream.java", "status": "modified", "additions": 96, "deletions": 15, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FOutputStream.java?ref=f3997ccf90496a4519cd8ec8f0985202b79f69d0", "patch": "@@ -1,34 +1,95 @@\n-// OutputStream.java - Send output bytes to output sink.\n+/* OutputStream.java -- Base class for byte output streams\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-package java.io;\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 24, 1998 \n- */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Complete to version 1.1.\n- */\n+package java.io;\n \n+/**\n+  * This abstract class forms the base of the hierarchy of classes that \n+  * write output as a stream of bytes.  It provides a common set of methods\n+  * for writing bytes to stream.  Subclasses implement and/or extend these\n+  * methods to write bytes in a particular manner or to a particular \n+  * destination such as a file on disk or network connection.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Tom Tromey <tromey@cygnus.com>\n+  */\n public abstract class OutputStream\n {\n+  /**\n+   * This is the default no-argument constructor for this class.  This method\n+   * does nothing in this class.\n+   */\n+  public OutputStream ()\n+  {\n+  }\n+\n+  /**\n+   * This method writes a single byte to the output stream.  The byte written\n+   * is the low eight bits of the <code>int</code> passed and a argument.\n+   * <p>\n+   * Subclasses must provide an implementation of this abstract method\n+   *\n+   * @param b The byte to be written to the output stream, passed as\n+   *          the low eight bits of an <code>int</code> \n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public abstract void write (int b) throws IOException;\n \n+  /**\n+   * This method all the writes bytes from the passed array to the\n+   * output stream.  This method is equivalent to <code>write(b, 0,\n+   * buf.length)</code> which is exactly how it is implemented in this\n+   * class.\n+   *\n+   * @param b The array of bytes to write\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write (byte[] b) throws IOException, NullPointerException\n   {\n     write (b, 0, b.length);\n   }\n \n+  /**\n+   * This method writes <code>len</code> bytes from the specified array\n+   * <code>b</code> starting at index <code>off</code> into the array.\n+   * <p>\n+   * This method in this class calls the single byte <code>write()</code>\n+   * method in a loop until all bytes have been written.  Subclasses should\n+   * override this method if possible in order to provide a more efficent\n+   * implementation.\n+   *\n+   * @param b The array of bytes to write from\n+   * @param off The index into the array to start writing from\n+   * @param len The number of bytes to write\n+   * \n+   * @exception IOException If an error occurs\n+   */\n   public void write (byte[] b, int off, int len)\n     throws IOException, NullPointerException, IndexOutOfBoundsException\n   {\n@@ -38,10 +99,30 @@ public void write (byte[] b, int off, int len)\n       write (b[off + i]);\n   }\n \n+  /**\n+   * This method forces any data that may have been buffered to be written\n+   * to the underlying output device.  Please note that the host environment\n+   * might perform its own buffering unbeknowst to Java.  In that case, a\n+   * write made (for example, to a disk drive) might be cached in OS\n+   * buffers instead of actually being written to disk.\n+   * <p>\n+   * This method in this class does nothing.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void flush () throws IOException\n   {\n   }\n \n+  /**\n+   * This method closes the stream.  Any internal or native resources\n+   * associated with this stream are freed.  Any subsequent attempt to\n+   * access the stream might throw an exception.\n+   * <p>\n+   * This method in this class does nothing.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void close () throws IOException\n   {\n   }"}, {"sha": "94c83ab742f9ed651a21ea996e43828eb087c841", "filename": "libjava/java/io/PushbackInputStream.java", "status": "modified", "additions": 211, "deletions": 27, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FPushbackInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FPushbackInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPushbackInputStream.java?ref=f3997ccf90496a4519cd8ec8f0985202b79f69d0", "patch": "@@ -1,36 +1,86 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* PushbackInputStream.java -- An input stream that can unread bytes\n+   Copyright (C) 1998, 1999, 2001, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n package java.io;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 15, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n+  * This subclass of <code>FilterInputStream</code> provides the ability to \n+  * unread data from a stream.  It maintains an internal buffer of unread\n+  * data that is supplied to the next read operation.  This is conceptually\n+  * similar to mark/reset functionality, except that in this case the \n+  * position to reset the stream to does not need to be known in advance.\n+  * <p>\n+  * The default pushback buffer size one byte, but this can be overridden\n+  * by the creator of the stream.\n+  * <p>\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Warren Levy <warrenl@cygnus.com>\n+  */\n public class PushbackInputStream extends FilterInputStream\n {\n-  /* Internal buffer array for data. */\n+  /**\n+   * This is the default buffer size\n+   */\n+  private static final int DEFAULT_BUFFER_SIZE = 1;\n+\n+  /**\n+   * This is the buffer that is used to store the pushed back data\n+   */\n   protected byte[] buf;\n \n-  /* The current position in the buffer. */\n+  /**\n+   * This is the position in the buffer from which the next byte will be\n+   * read.  Bytes are stored in reverse order in the buffer, starting from\n+   * <code>buf[buf.length - 1]</code> to <code>buf[0]</code>.  Thus when \n+   * <code>pos</code> is 0 the buffer is full and <code>buf.length</code> when \n+   * it is empty\n+   */\n   protected int pos;\n \n+  /**\n+   * This method initializes a <code>PushbackInputStream</code> to\n+   * read from the * specified subordinate <code>InputStream</code>\n+   * with a default pushback buffer * size of 1.\n+   *\n+   * @param in The subordinate stream to read from\n+   */\n   public PushbackInputStream(InputStream in)\n   {\n-    this(in, 1);\n+    this(in, DEFAULT_BUFFER_SIZE);\n   }\n \n+  /**\n+   * This method initializes a <code>PushbackInputStream</code> to\n+   * read from the specified subordinate <code>InputStream</code> with\n+   * the specified buffer size\n+   *\n+   * @param in The subordinate <code>InputStream</code> to read from\n+   * @param size The pushback buffer size to use\n+   */\n   public PushbackInputStream(InputStream in, int size)\n   {\n     super(in);\n@@ -40,31 +90,104 @@ public PushbackInputStream(InputStream in, int size)\n     pos = buf.length;\n   }\n \n+  /**\n+   * This method returns the number of bytes that can be read from this\n+   * stream before a read can block.  A return of 0 indicates that blocking\n+   * might (or might not) occur on the very next read attempt.\n+   * <p>\n+   * This method will return the number of bytes available from the\n+   * pushback buffer plus the number of bytes available from the \n+   * underlying stream.\n+   *\n+   * @return The number of bytes that can be read before blocking could occur\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int available() throws IOException\n   {\n     return pos + super.available();\n   }\n \n-  public void close() throws IOException\n+  /**\n+   * This method closes the stream and releases any associated resources.\n+   * \n+   * @exception IOException If an error occurs.\n+   */\n+  public synchronized void close() throws IOException\n   {\n     buf = null;\n     super.close();\n   }\n \n+  /**\n+   * This method returns <code>false</code> to indicate that it does\n+   * not support mark/reset functionality.\n+   *\n+   * @return This method returns <code>false</code> to indicate that\n+   * this class does not support mark/reset functionality\n+   */\n   public boolean markSupported()\n   {\n     return false;\n   }\n \n-  public int read() throws IOException\n+  /**\n+   * This method always throws an IOException in this class because\n+   * mark/reset functionality is not supported.\n+   *\n+   * @exception IOException Always thrown for this class\n+   */\n+  public void reset() throws IOException\n+  {\n+    throw new IOException(\"Mark not supported in this class\");\n+  }\n+\n+  /**\n+   * This method reads an unsigned byte from the input stream and returns it\n+   * as an int in the range of 0-255.  This method also will return -1 if\n+   * the end of the stream has been reached.  The byte returned will be read\n+   * from the pushback buffer, unless the buffer is empty, in which case\n+   * the byte will be read from the underlying stream.\n+   * <p>\n+   * This method will block until the byte can be read.\n+   *\n+   * @return The byte read or -1 if end of stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public synchronized int read() throws IOException\n   {\n     if (pos < buf.length)\n       return ((int) buf[pos++]) & 0xFF;\n \n     return super.read();\n   }\n \n-  public int read(byte[] b, int off, int len) throws IOException\n+  /**\n+   * This method read bytes from a stream and stores them into a\n+   * caller supplied buffer.  It starts storing the data at index\n+   * <code>offset</code> into the buffer and attempts to read\n+   * <code>len</code> bytes.  This method can return before reading the\n+   * number of bytes requested.  The actual number of bytes read is\n+   * returned as an int.  A -1 is returned to indicate the end of the\n+   * stream.\n+   *  <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * This method first reads bytes from the pushback buffer in order to \n+   * satisfy the read request.  If the pushback buffer cannot provide all\n+   * of the bytes requested, the remaining bytes are read from the \n+   * underlying stream.\n+   *\n+   * @param b The array into which the bytes read should be stored\n+   * @param off The offset into the array to start storing bytes\n+   * @param len The requested number of bytes to read\n+   *\n+   * @return The actual number of bytes read, or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public synchronized int read(byte[] b, int off, int len) throws IOException\n   {\n     if (off < 0 || len < 0 || off + len > b.length)\n       throw new ArrayIndexOutOfBoundsException();\n@@ -80,23 +203,68 @@ public int read(byte[] b, int off, int len) throws IOException\n     return super.read(b, off, len);\n   }\n \n-  public void unread(int b) throws IOException\n+  /**\n+   * This method pushes a single byte of data into the pushback buffer.\n+   * The byte pushed back is the one that will be returned as the first byte\n+   * of the next read.\n+   * <p>\n+   * If the pushback buffer is full, this method throws an exception.\n+   * <p>\n+   * The argument to this method is an <code>int</code>.  Only the low\n+   * eight bits of this value are pushed back.\n+   *\n+   * @param b The byte to be pushed back, passed as an int\n+   *\n+   * @exception IOException If the pushback buffer is full.\n+   */\n+  public synchronized void unread(int b) throws IOException\n   {\n     if (pos <= 0)\n-      throw new IOException();\n+      throw new IOException(\"Insufficient space in pushback buffer\");\n \n     buf[--pos] = (byte) b;\n   }\n \n-  public void unread(byte[] b) throws IOException\n+  /**\n+   * This method pushes all of the bytes in the passed byte array into \n+   * the pushback bfer.  These bytes are pushed in reverse order so that\n+   * the next byte read from the stream after this operation will be\n+   * <code>b[0]</code> followed by <code>b[1]</code>, etc.\n+   * <p>\n+   * If the pushback buffer cannot hold all of the requested bytes, an\n+   * exception is thrown.\n+   *\n+   * @param b The byte array to be pushed back\n+   *\n+   * @exception IOException If the pushback buffer is full\n+   */\n+  public synchronized void unread(byte[] b) throws IOException\n   {\n     unread(b, 0, b.length);\n   }\n \n-  public void unread(byte[] b, int off, int len) throws IOException\n+  /**\n+   * This method pushed back bytes from the passed in array into the\n+   * pushback buffer.  The bytes from <code>b[offset]</code> to\n+   * <cdoe>b[offset + len]</code> are pushed in reverse order so that\n+   * the next byte read from the stream after this operation will be\n+   * <code>b[offset]</code> followed by <code>b[offset + 1]</code>,\n+   * etc.\n+   * <p>\n+   * If the pushback buffer cannot hold all of the requested bytes, an\n+   * exception is thrown.\n+   *\n+   * @param b The byte array to be pushed back\n+   * @param off The index into the array where the bytes to be push start\n+   * @param len The number of bytes to be pushed.\n+   *\n+   * @exception IOException If the pushback buffer is full\n+   */\n+  public synchronized void unread(byte[] b, int off, int len)\n+    throws IOException\n   {\n     if (pos < len)\n-      throw new IOException();\n+      throw new IOException(\"Insufficient space in pushback buffer\");\n \n     // Note the order that these bytes are being added is the opposite\n     // of what would be done if they were added to the buffer one at a time.\n@@ -108,8 +276,24 @@ public void unread(byte[] b, int off, int len) throws IOException\n     pos -= len;\n   }\n \n-  // JDK1.2\n-  public long skip(long n) throws IOException\n+  /**\n+   * This method skips the specified number of bytes in the stream.  It\n+   * returns the actual number of bytes skipped, which may be less than the\n+   * requested amount.\n+   * <p>\n+   * This method first discards bytes from the buffer, then calls the\n+   * <code>skip</code> method on the underlying <code>InputStream</code> to \n+   * skip additional bytes if necessary.\n+   *\n+   * @param num_bytes The requested number of bytes to skip\n+   *\n+   * @return The actual number of bytes skipped.\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @since 1.2\n+   */\n+  public synchronized long skip(long n) throws IOException\n   {\n     final long origN = n;\n "}, {"sha": "10cc3ec307f5ce1ab77a8a0f280b5164befb8b53", "filename": "libjava/java/io/StringWriter.java", "status": "modified", "additions": 116, "deletions": 18, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FStringWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3997ccf90496a4519cd8ec8f0985202b79f69d0/libjava%2Fjava%2Fio%2FStringWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStringWriter.java?ref=f3997ccf90496a4519cd8ec8f0985202b79f69d0", "patch": "@@ -1,80 +1,178 @@\n-// StringWriter.java - StringBuffer output stream\n+/* StringWriter.java -- Writes bytes to a StringBuffer\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-package java.io;\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 25, 1998 \n- */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Complete to 1.2.\n- */\n+package java.io;\n \n+// Wow is this a dumb class.  CharArrayWriter can do all this and\n+// more.  I would redirect all calls to one in fact, but the javadocs say\n+// use a StringBuffer so I will comply.\n+\n+/**\n+  * This class writes chars to an internal <code>StringBuffer</code> that\n+  * can then be used to retrieve a <code>String</code>.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Tom Tromey <tromey@cygnus.com>\n+  */\n public class StringWriter extends Writer\n {\n+  /**\n+   * This is the default size of the buffer if the user doesn't specify it.\n+   * @specnote The JCL Volume 1 says that 16 is the default size.\n+   */\n+  private static final int DEFAULT_BUFFER_SIZE = 16;\n+\n+  /**\n+   * This method closes the stream.  The contents of the internal buffer\n+   * can still be retrieved, but future writes are not guaranteed to work.\n+   */\n   public void close ()\n   {\n     // JCL says this does nothing.  This seems to violate the Writer\n     // contract, in that other methods should still throw an\n     // IOException after a close.  Still, we just follow JCL.\n   }\n \n+  /**\n+   * This method flushes any buffered characters to the underlying output.\n+   * It does nothing in this class.\n+   */\n   public void flush ()\n   {\n   }\n \n+  /**\n+   * This method returns the <code>StringBuffer</code> object that this\n+   * object is writing to.  Note that this is the actual internal buffer, so\n+   * any operations performed on it will affect this stream object.\n+   *\n+   * @return The <code>StringBuffer</code> object being written to\n+   */\n   public StringBuffer getBuffer ()\n   {\n     return buffer;\n   }\n \n+  /**\n+   * This method initializes a new <code>StringWriter</code> to write to a\n+   * <code>StringBuffer</code> initially sized to a default size of 16\n+   * chars.\n+   */\n   public StringWriter ()\n   {\n-    this (16);\n+    this (DEFAULT_BUFFER_SIZE);\n   }\n \n+  /**\n+   * This method initializes a new <code>StringWriter</code> to write to a\n+   * <code>StringBuffer</code> with the specified initial size.\n+   *\n+   * @param size The initial size to make the <code>StringBuffer</code>\n+   */\n   public StringWriter (int size)\n   {\n     super ();\n     buffer = new StringBuffer (size);\n     lock = buffer;\n   }\n \n+  /**\n+   * This method returns the contents of the internal <code>StringBuffer</code>\n+   * as a <code>String</code>.\n+   *\n+   * @return A <code>String</code> representing the chars written to\n+   * this stream. \n+   */\n   public String toString ()\n   {\n     return buffer.toString();\n   }\n \n+  /**\n+   * This method writes a single character to the output, storing it in\n+   * the internal buffer.\n+   *\n+   * @param oneChar The <code>char</code> to write, passed as an int.\n+   */\n   public void write (int oneChar)\n   {\n-    buffer.append((char) oneChar);\n+    buffer.append((char) (oneChar & 0xFFFF));\n   }\n \n+  /**\n+   * This method writes <code>len</code> chars from the specified\n+   * array starting at index <code>offset</code> in that array to this\n+   * stream by appending the chars to the end of the internal buffer.\n+   *\n+   * @param chars The array of chars to write\n+   * @param offset The index into the array to start writing from\n+   * @param len The number of chars to write\n+   */\n   public void write (char[] chars, int offset, int len)\n   {\n     buffer.append(chars, offset, len);\n   }\n \n+  /**\n+   * This method writes the characters in the specified <code>String</code>\n+   * to the stream by appending them to the end of the internal buffer.\n+   *\n+   * @param str The <code>String</code> to write to the stream.\n+   */\n   public void write (String str)\n   {\n     buffer.append(str);\n   }\n \n+  /**\n+   * This method writes out <code>len</code> characters of the specified\n+   * <code>String</code> to the stream starting at character position\n+   * <code>offset</code> into the stream.  This is done by appending the\n+   * characters to the internal buffer.\n+   *\n+   * @param str The <code>String</code> to write characters from\n+   * @param offset The character position to start writing from\n+   * @param len The number of characters to write.\n+   */ \n   public void write (String str, int offset, int len)\n   {\n+//      char[] tmpbuf = new char[len];\n+//      str.getChars(offset, offset+len, tmpbuf, 0);\n+//      buf.append(tmpbuf, 0, tmpbuf.length);\n+    // This implementation assumes that String.substring is more\n+    // efficient than using String.getChars and copying the data\n+    // twice.  For libgcj, this is true.  For Classpath, it is not.\n+    // FIXME.\n     buffer.append(str.substring(offset, offset + len));\n   }\n \n-  // The string buffer.\n+  /**\n+   * This is the <code>StringBuffer</code> that we use to store bytes that\n+   * are written.\n+   */\n   private StringBuffer buffer;\n }"}]}