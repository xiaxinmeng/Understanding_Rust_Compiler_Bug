{"sha": "82443371dbe45090104ee47b52206637f00c3b75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI0NDMzNzFkYmU0NTA5MDEwNGVlNDdiNTIyMDY2MzdmMDBjM2I3NQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-06-23T10:56:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-06-23T10:56:09Z"}, "message": "cpplib.c (struct pragma_entry): New structure.\n\n\t* cpplib.c (struct pragma_entry): New structure.\n\t(pragma_dispatch): Pragma dispatcher.\n\t(top_pragmas, gcc_pragmas): New static variables.\n\t(do_pragma): Use pragma_dispatch.\n\t(do_pragma_gcc): New pragma handler.\n\t* cpp.texi: Update.\n\nFrom-SVN: r34663", "tree": {"sha": "64897139351a8cff8d093f5375b42a9234a1335c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64897139351a8cff8d093f5375b42a9234a1335c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82443371dbe45090104ee47b52206637f00c3b75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82443371dbe45090104ee47b52206637f00c3b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82443371dbe45090104ee47b52206637f00c3b75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82443371dbe45090104ee47b52206637f00c3b75/comments", "author": null, "committer": null, "parents": [{"sha": "7ab923ccffee2b00e18580a21e54cee3f3a0c24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ab923ccffee2b00e18580a21e54cee3f3a0c24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ab923ccffee2b00e18580a21e54cee3f3a0c24c"}], "stats": {"total": 112, "additions": 90, "deletions": 22}, "files": [{"sha": "78d3f0d878689f1468ad2deb0c6aaf7b2e2fffc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82443371dbe45090104ee47b52206637f00c3b75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82443371dbe45090104ee47b52206637f00c3b75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82443371dbe45090104ee47b52206637f00c3b75", "patch": "@@ -1,3 +1,12 @@\n+2000-06-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cpplib.c (struct pragma_entry): New structure.\n+\t(pragma_dispatch): Pragma dispatcher.\n+\t(top_pragmas, gcc_pragmas): New static variables.\n+\t(do_pragma): Use pragma_dispatch.\n+\t(do_pragma_gcc): New pragma handler.\n+\t* cpp.texi: Update.\n+\n 2000-06-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* calls.c (compute_argument_addresses): Force stack slots into"}, {"sha": "20f278df0f1654a039080751eb77d227534ce7de", "filename": "gcc/cpp.texi", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82443371dbe45090104ee47b52206637f00c3b75/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82443371dbe45090104ee47b52206637f00c3b75/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=82443371dbe45090104ee47b52206637f00c3b75", "patch": "@@ -613,13 +613,13 @@ command line.  If the same directory is named by both @samp{-I} and\n @samp{-isystem}, @samp{-I} wins; it is as if the @samp{-isystem} option\n had never been specified at all.\n \n-@findex #pragma system_header\n-There is also a directive, @samp{#pragma system_header}, which tells GCC\n+@findex #pragma GCC system_header\n+There is also a directive, @samp{#pragma GCC system_header}, which tells GCC\n to consider the rest of the current include file a system header, no\n matter where it was found.  Code that comes before the @samp{#pragma} in\n the file will not be affected.\n \n-@samp{#pragma system_header} has no effect in the primary source file.\n+@samp{#pragma GCC system_header} has no effect in the primary source file.\n \n @node Macros, Conditionals, Header Files, Top\n @section Macros\n@@ -1503,24 +1503,28 @@ Recall that a comment counts as whitespace.\n @node Poisoning, Macro Pitfalls, Redefining, Macros\n @subsection Poisoning Macros\n @cindex poisoning macros\n+@findex #pragma GCC poison\n+@findex #pragma poison\n \n Sometimes, there is an identifier that you want to remove completely\n from your program, and make sure that it never creeps back in.  To\n-enforce this, the @samp{#pragma poison} directive can be used.\n-@samp{#pragma poison} is followed by a list of identifiers to poison,\n+enforce this, the @samp{#pragma GCC poison} directive can be used.\n+@samp{#pragma GCC poison} is followed by a list of identifiers to poison,\n and takes effect for the rest of the source.  You cannot @samp{#undef} a\n poisoned identifier or test to see if it's defined with @samp{#ifdef}.\n \n For example,\n \n @example\n-#pragma poison printf sprintf fprintf\n+#pragma GCC poison printf sprintf fprintf\n sprintf(some_string, \"hello\");\n @end example\n \n @noindent\n will produce an error.\n \n+For backwards compatibility @samp{#pragma poison} is also recognized.\n+\n @node Macro Pitfalls,, Poisoning, Macros\n @subsection Pitfalls and Subtleties of Macros\n @cindex problems with macros\n@@ -2637,11 +2641,15 @@ rather than a line of output containing just a @samp{#}.  Supposedly\n some old C programs contain such lines.\n \n @findex #pragma\n+@findex #pragma GCC\n+\n The ANSI standard specifies that the effect of the @samp{#pragma}\n-directive is implementation-defined.  In the GNU C preprocessor,\n-@samp{#pragma} directives are not used, except for @samp{#pragma once}\n-(@pxref{Once-Only}).  However, they are left in the preprocessor output,\n-so they are available to the compilation pass.\n+directive is implementation-defined.  The GNU C preprocessor recognizes\n+some pragmas, and passes unrecognized ones through to the preprocessor\n+output, so they are available to the compilation pass.  GNU C preprocessor\n+pragmas are of the form @samp{#pragma GCC ...}. For backwards\n+compatibility previously supported pragmas are also recognized without\n+the @samp{GCC}, however that use is deprecated.\n \n @findex #ident\n The @samp{#ident} directive is supported for compatibility with certain"}, {"sha": "f6cbd90932c67a1c5d29357e168fbaca8b44a16c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82443371dbe45090104ee47b52206637f00c3b75/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82443371dbe45090104ee47b52206637f00c3b75/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=82443371dbe45090104ee47b52206637f00c3b75", "patch": "@@ -789,11 +789,50 @@ do_ident (pfile)\n \n /* Sub-handlers for the pragmas needing treatment here.\n    They return 1 if the token buffer is to be popped, 0 if not. */\n+struct pragma_entry\n+{\n+  char const *name;\n+  int (*handler) PARAMS ((cpp_reader *));\n+};\n+\n+static int pragma_dispatch             \n+    PARAMS ((cpp_reader *, const struct pragma_entry *, U_CHAR *, size_t));\n static int do_pragma_once\t\tPARAMS ((cpp_reader *));\n static int do_pragma_implementation\tPARAMS ((cpp_reader *));\n static int do_pragma_poison\t\tPARAMS ((cpp_reader *));\n static int do_pragma_system_header\tPARAMS ((cpp_reader *));\n static int do_pragma_default\t\tPARAMS ((cpp_reader *));\n+static int do_pragma_gcc                PARAMS ((cpp_reader *));\n+\n+static const struct pragma_entry top_pragmas[] =\n+{\n+  {\"once\", do_pragma_once},\n+  {\"implementation\", do_pragma_implementation},\n+  {\"poison\", do_pragma_poison},\n+  {\"system_header\", do_pragma_system_header},\n+  {\"GCC\", do_pragma_gcc},\n+  {NULL, do_pragma_default}\n+};\n+\n+static const struct pragma_entry gcc_pragmas[] =\n+{\n+  {\"implementation\", do_pragma_implementation},\n+  {\"poison\", do_pragma_poison},\n+  {\"system_header\", do_pragma_system_header},\n+  {NULL, do_pragma_default}\n+};\n+\n+static int pragma_dispatch (pfile, table, p, len)\n+     cpp_reader *pfile;\n+     const struct pragma_entry *table;\n+     U_CHAR *p;\n+     size_t len;\n+{\n+  for (; table->name; table++)\n+    if (strlen (table->name) == len && !memcmp (p, table->name, len))\n+      return (*table->handler) (pfile);\n+  return (*table->handler) (pfile);\n+}\n \n static int\n do_pragma (pfile)\n@@ -803,6 +842,7 @@ do_pragma (pfile)\n   U_CHAR *buf;\n   int pop;\n   enum cpp_ttype token;\n+  size_t  len;\n \n   here = CPP_WRITTEN (pfile);\n   CPP_PUTS (pfile, \"#pragma \", 8);\n@@ -819,20 +859,10 @@ do_pragma (pfile)\n     }\n \n   buf = pfile->token_buffer + key;\n+  len = CPP_WRITTEN (pfile) - key;\n   CPP_PUTC (pfile, ' ');\n \n-#define tokis(x) !strncmp((char *) buf, x, sizeof(x) - 1)\n-  if (tokis (\"once\"))\n-    pop = do_pragma_once (pfile);\n-  else if (tokis (\"implementation\"))\n-    pop = do_pragma_implementation (pfile);\n-  else if (tokis (\"poison\"))\n-    pop = do_pragma_poison (pfile);\n-  else if (tokis (\"system_header\"))\n-    pop = do_pragma_system_header (pfile);\n-  else\n-    pop = do_pragma_default (pfile);\n-#undef tokis\n+  pop = pragma_dispatch (pfile, top_pragmas, buf, len);\n \n   if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     goto skip;\n@@ -860,6 +890,27 @@ do_pragma_default (pfile)\n   return 0;\n }\n \n+static int\n+do_pragma_gcc (pfile)\n+     cpp_reader *pfile;\n+{\n+  long key;\n+  enum cpp_ttype token;\n+  U_CHAR *buf;\n+  size_t  len;\n+  \n+  key = CPP_WRITTEN (pfile);\n+  token = _cpp_get_directive_token (pfile);\n+  if (token != CPP_NAME)\n+    return token == CPP_VSPACE;\n+\n+  buf = pfile->token_buffer + key;\n+  len = CPP_WRITTEN (pfile) - key;\n+  CPP_PUTC (pfile, ' ');\n+  \n+  return pragma_dispatch (pfile, gcc_pragmas, buf, len);\n+}\n+\n static int\n do_pragma_once (pfile)\n      cpp_reader *pfile;"}]}