{"sha": "9d4c0187c6805870fd437f4973bbf51d1ca064ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ0YzAxODdjNjgwNTg3MGZkNDM3ZjQ5NzNiYmY1MWQxY2EwNjRlYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mitchell@dumbledore.codesourcery.com", "date": "2000-01-11T04:13:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-11T04:13:27Z"}, "message": "class.c (build_vbase_path): Simplify.\n\n\t* class.c (build_vbase_path): Simplify.\n\t(dfs_propagate_binfo_offsets): New function.\n\t(propagate_binfo_offsets): Use it.\n\t(remove_base_field): Simplify.\n\t(dfs_set_offset_for_vbases): Remove.\n\t(dfs_set_offset_for_shared_vbases): New function.\n\t(dfs_set_offset_for_unshared_vbases): Likewise.\n\t(layout_virtual_bases): Use them.\n\t(layout_basetypes): Don't call propagate_binfo_offsets.\n\t* search.c (dfs_get_vbase_types): Clone completely fresh binfos\n\tfor the vbases.\n\nFrom-SVN: r31316", "tree": {"sha": "2871c7aa28318e67ea8d66b2b2c066947132667f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2871c7aa28318e67ea8d66b2b2c066947132667f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d4c0187c6805870fd437f4973bbf51d1ca064ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d4c0187c6805870fd437f4973bbf51d1ca064ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d4c0187c6805870fd437f4973bbf51d1ca064ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d4c0187c6805870fd437f4973bbf51d1ca064ea/comments", "author": null, "committer": null, "parents": [{"sha": "d77249e795d1e9e1e669c80279cef1df12232089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77249e795d1e9e1e669c80279cef1df12232089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d77249e795d1e9e1e669c80279cef1df12232089"}], "stats": {"total": 235, "additions": 108, "deletions": 127}, "files": [{"sha": "00078c6fc56421023b56f3d8ba2422dfef217839", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9d4c0187c6805870fd437f4973bbf51d1ca064ea", "patch": "@@ -1,5 +1,17 @@\n 2000-01-10  Mark Mitchell  <mitchell@dumbledore.codesourcery.com>\n \n+\t* class.c (build_vbase_path): Simplify.\n+\t(dfs_propagate_binfo_offsets): New function.\n+\t(propagate_binfo_offsets): Use it.\n+\t(remove_base_field): Simplify.\n+\t(dfs_set_offset_for_vbases): Remove.\n+\t(dfs_set_offset_for_shared_vbases): New function.\n+\t(dfs_set_offset_for_unshared_vbases): Likewise.\n+\t(layout_virtual_bases): Use them.\n+\t(layout_basetypes): Don't call propagate_binfo_offsets.\n+\t* search.c (dfs_get_vbase_types): Clone completely fresh binfos\n+\tfor the vbases.\n+\t\n \t* class.c (build_base_field): New function, split out from ...\n \t(build_base_fields): ... here.  Use it.  Allocate primary bases\n \tfirst, under the new ABI."}, {"sha": "ddcd17fbc9167a4bd8d053b612c4ec7c8e1b60ba", "filename": "gcc/cp/class.c", "status": "modified", "additions": 92, "deletions": 124, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9d4c0187c6805870fd437f4973bbf51d1ca064ea", "patch": "@@ -138,12 +138,14 @@ static void layout_class_type PROTO((tree, int *, int *, tree *, tree *));\n static void fixup_pending_inline PROTO((struct pending_inline *));\n static void fixup_inline_methods PROTO((tree));\n static void set_primary_base PROTO((tree, int, int *));\n+static void dfs_propagate_binfo_offsets PROTO((tree, tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n static void layout_basetypes PROTO((tree));\n-static tree dfs_set_offset_for_vbases PROTO((tree, void *));\n static void layout_virtual_bases PROTO((tree));\n static void remove_base_field PROTO((tree, tree, tree *));\n static void remove_base_fields PROTO((tree));\n+static void dfs_set_offset_for_shared_vbases PROTO((tree, void *));\n+static void dfs_set_offset_for_unshared_vbases PROTO((tree, void *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -335,16 +337,7 @@ build_vbase_path (code, type, expr, path, nonnull)\n \t}\n     }\n   else\n-    {\n-      if (last_virtual)\n-\t{\n-\t  offset = BINFO_OFFSET (BINFO_FOR_VBASE (last_virtual, \n-\t\t\t\t\t\t  basetype));\n-\t  offset = size_binop (PLUS_EXPR, offset, BINFO_OFFSET (last));\n-\t}\n-      else\n-\toffset = BINFO_OFFSET (last);\n-    }\n+    offset = BINFO_OFFSET (last);\n \n   if (TREE_INT_CST_LOW (offset))\n     {\n@@ -4142,7 +4135,26 @@ fixup_inline_methods (type)\n   CLASSTYPE_INLINE_FRIENDS (type) = NULL_TREE;\n }\n \n-/* Add OFFSET to all base types of T.\n+/* Called from propagate_binfo_offsets via dfs_walk.  */\n+\n+static tree\n+dfs_propagate_binfo_offsets (binfo, data)\n+     tree binfo; \n+     void *data;\n+{\n+  tree offset = (tree) data;\n+\n+  /* Update the BINFO_OFFSET for this base.  */\n+  BINFO_OFFSET (binfo) \n+    = size_binop (PLUS_EXPR, BINFO_OFFSET (binfo), offset);\n+\n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Add OFFSET to all base types of BINFO which is a base in the\n+   hierarchy dominated by T.\n \n    OFFSET, which is a type offset, is number of bytes.\n \n@@ -4154,87 +4166,14 @@ propagate_binfo_offsets (binfo, offset)\n      tree binfo;\n      tree offset;\n {\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  if (flag_new_abi)\n-    {\n-      for (i = 0; i < n_baselinks; ++i)\n-\t{\n-\t  tree base_binfo;\n-\n-\t  /* Figure out which base we're looking at.  */\n-\t  base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-\t  /* Skip non-primary virtual bases.  Their BINFO_OFFSET\n-\t     doesn't matter since they are always reached by using\n-\t     offsets looked up at run-time.  */\n-\t  if (TREE_VIA_VIRTUAL (base_binfo) \n-\t      && i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo)))\n-\t    continue;\n-\n-\t  /* Whatever offset this class used to have in its immediate\n-\t     derived class, it is now at OFFSET more bytes in its\n-\t     final derived class, since the immediate derived class is\n-\t     already at the indicated OFFSET.  */\n-\t  BINFO_OFFSET (base_binfo)\n-\t    = size_binop (PLUS_EXPR, BINFO_OFFSET (base_binfo), offset);\n-\n-\t  propagate_binfo_offsets (base_binfo, offset);\n-\t}\n-    }\n-  else\n-    {\n-      /* This algorithm, used for the old ABI, is neither simple, nor\n-\t general.  For example, it mishandles the case of:\n-       \n-           struct A;\n-\t   struct B : public A;\n-\t   struct C : public B;\n-\t   \n-\t if B is at offset zero in C, but A is not in offset zero in\n-\t B.  In that case, it sets the BINFO_OFFSET for A to zero.\n-\t (This sitution arises in the new ABI if B has virtual\n-\t functions, but A does not.)  Rather than change this\n-\t algorithm, and risking breaking the old ABI, it is preserved\n-\t here.  */\n-      for (i = 0; i < n_baselinks; /* note increment is done in the\n-\t\t\t\t      loop.  */)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n-\t    i += 1;\n-\t  else\n-\t    {\n-\t      int j;\n-\t      tree delta = NULL_TREE;\n-\n-\t      for (j = i+1; j < n_baselinks; j++)\n-\t\tif (! TREE_VIA_VIRTUAL (TREE_VEC_ELT (binfos, j)))\n-\t\t  {\n-\t\t    /* The next basetype offset must take into account\n-\t\t       the space between the classes, not just the\n-\t\t       size of each class.  */\n-\t\t    delta = size_binop (MINUS_EXPR,\n-\t\t\t\t\tBINFO_OFFSET (TREE_VEC_ELT (binfos, \n-\t\t\t\t\t\t\t\t    j)),\n-\t\t\t\t\tBINFO_OFFSET (base_binfo));\n-\t\t    break;\n-\t\t  }\n-\n-\t      BINFO_OFFSET (base_binfo) = offset;\n-\n-\t      propagate_binfo_offsets (base_binfo, offset);\n-\n-\t      /* Go to our next class that counts for offset\n-                 propagation.  */\n-\t      i = j;\n-\t      if (i < n_baselinks)\n-\t\toffset = size_binop (PLUS_EXPR, offset, delta);\n-\t    }\n-\t}\n-    }\n+  dfs_walk (binfo, \n+\t    dfs_propagate_binfo_offsets, \n+\t    dfs_skip_nonprimary_vbases_unmarkedp,\n+\t    offset);\n+  dfs_walk (binfo,\n+\t    dfs_unmark,\n+\t    dfs_skip_nonprimary_vbases_markedp,\n+\t    NULL);\n }\n \n /* Remove *FIELD (which corresponds to the base given by BINFO) from\n@@ -4258,7 +4197,6 @@ remove_base_field (t, binfo, field)\n   offset\n     = size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (*field)),\n \t\t      BITS_PER_UNIT));\n-  BINFO_OFFSET (binfo) = offset;\n   propagate_binfo_offsets (binfo, offset);\n \n   /* Remove this field.  */\n@@ -4317,27 +4255,47 @@ remove_base_fields (t)\n     }\n }\n \n-/* Called via dfs_walk from layout_virtual_bases.  */\n+/* Called via dfs_walk from layout_virtual bases.  */\n \n static tree\n-dfs_set_offset_for_vbases (binfo, data)\n+dfs_set_offset_for_shared_vbases (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  /* If this is a primary virtual base that we have not encountered\n-     before, give it an offset.  */\n-  if (TREE_VIA_VIRTUAL (binfo) \n-      && BINFO_PRIMARY_MARKED_P (binfo)\n-      && !BINFO_MARKED (binfo))\n+  if (TREE_VIA_VIRTUAL (binfo) && BINFO_PRIMARY_MARKED_P (binfo))\n     {\n-      tree vbase;\n+      /* Update the shared copy.  */\n+      tree shared_binfo;\n \n-      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), (tree) data);\n-      BINFO_OFFSET (vbase) = BINFO_OFFSET (binfo);\n-      SET_BINFO_VBASE_MARKED (binfo);\n+      shared_binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), (tree) data);\n+      BINFO_OFFSET (shared_binfo) = BINFO_OFFSET (binfo);\n     }\n \n-  SET_BINFO_MARKED (binfo);\n+  return NULL_TREE;\n+}\n+\n+/* Called via dfs_walk from layout_virtual bases.  */\n+\n+static tree\n+dfs_set_offset_for_unshared_vbases (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  /* If this is a virtual base, make sure it has the same offset as\n+     the shared copy.  If it's a primary base, then we know it's\n+     correct.  */\n+  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+    {\n+      tree t = (tree) data;\n+      tree vbase;\n+      tree offset;\n+      \n+      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), t);\n+      offset = ssize_binop (MINUS_EXPR, \n+\t\t\t    BINFO_OFFSET (vbase),\n+\t\t\t    BINFO_OFFSET (binfo));\n+      propagate_binfo_offsets (binfo, offset);\n+    }\n \n   return NULL_TREE;\n }\n@@ -4357,10 +4315,12 @@ layout_virtual_bases (t)\n   /* Make every class have alignment of at least one.  */\n   TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), BITS_PER_UNIT);\n \n+  /* Go through the virtual bases, allocating space for each virtual\n+     base that is not already a primary base class.  */\n   for (vbase = CLASSTYPE_VBASECLASSES (t); \n        vbase; \n        vbase = TREE_CHAIN (vbase))\n-    if (!BINFO_PRIMARY_MARKED_P (vbase))\n+    if (!BINFO_VBASE_PRIMARY_P (vbase))\n       {\n \t/* This virtual base is not a primary base of any class in the\n \t   hierarchy, so we have to add space for it.  */\n@@ -4375,24 +4335,36 @@ layout_virtual_bases (t)\n \t   appropriately aligned offset.  */\n \tdsize = CEIL (dsize, desired_align) * desired_align;\n \t/* And compute the offset of the virtual base.  */\n-\tBINFO_OFFSET (vbase) = size_int (CEIL (dsize, BITS_PER_UNIT));\n+\tpropagate_binfo_offsets (vbase, \n+\t\t\t\t size_int (CEIL (dsize, BITS_PER_UNIT)));\n \t/* Every virtual baseclass takes a least a UNIT, so that we can\n \t   take it's address and get something different for each base.  */\n \tdsize += MAX (BITS_PER_UNIT,\n \t\t      TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n       }\n \n+  /* Make sure that all of the CLASSTYPE_VBASECLASSES have their\n+     BINFO_OFFSET set correctly.  Those we just allocated certainly\n+     will.  The others are primary baseclasses; we walk the hierarchy\n+     to find the primary copies and update the shared copy.  */\n+  dfs_walk (TYPE_BINFO (t), \n+\t    dfs_set_offset_for_shared_vbases, \n+\t    dfs_unmarked_real_bases_queue_p,\n+\t    t);\n+\n+  /* Now, go through the TYPE_BINFO hierarchy again, setting the\n+     BINFO_OFFSETs correctly for all non-primary copies of the virtual\n+     bases and their direct and indirect bases.  The ambiguity checks\n+     in get_base_distance depend on the BINFO_OFFSETs being set\n+     correctly.  */\n+  dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_unshared_vbases, NULL, t);\n+\n   /* Now, make sure that the total size of the type is a multiple of\n      its alignment.  */\n   dsize = CEIL (dsize, TYPE_ALIGN (t)) * TYPE_ALIGN (t);\n   TYPE_SIZE (t) = size_int (dsize);\n   TYPE_SIZE_UNIT (t) = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (t),\n \t\t\t\t   size_int (BITS_PER_UNIT));\n-\n-  /* Run through the hierarchy now, setting up all the BINFO_OFFSETs\n-     for those virtual base classes that we did not allocate above.  */\n-  dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_vbases, unmarkedp, t);\n-  dfs_walk (TYPE_BINFO (t), dfs_vbase_unmark, markedp, NULL);\n }\n \n /* Finish the work of layout_record, now taking virtual bases into account.\n@@ -4426,17 +4398,13 @@ layout_basetypes (rec)\n      the vbase_types are unshared.  */\n   for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;\n        vbase_types = TREE_CHAIN (vbase_types))\n-    {\n-      propagate_binfo_offsets (vbase_types, BINFO_OFFSET (vbase_types));\n-\n-      if (extra_warnings)\n-\t{\n-\t  tree basetype = BINFO_TYPE (vbase_types);\n-\t  if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n-\t    cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t\tbasetype, rec);\n-\t}\n-    }\n+    if (extra_warnings)\n+      {\n+\ttree basetype = BINFO_TYPE (vbase_types);\n+\tif (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n+\t  cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t      basetype, rec);\n+      }\n }\n \n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate"}, {"sha": "abd6867a0f4cc4b423f443e7c0daf6256f85bb6c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9d4c0187c6805870fd437f4973bbf51d1ca064ea", "patch": "@@ -3046,7 +3046,8 @@ dfs_get_vbase_types (binfo, data)\n \n   if (TREE_VIA_VIRTUAL (binfo) && ! BINFO_VBASE_MARKED (binfo))\n     {\n-      tree new_vbase = make_binfo (integer_zero_node, binfo,\n+      tree new_vbase = make_binfo (integer_zero_node, \n+\t\t\t\t   BINFO_TYPE (binfo),\n \t\t\t\t   BINFO_VTABLE (binfo),\n \t\t\t\t   BINFO_VIRTUALS (binfo));\n       unshare_base_binfos (new_vbase);"}, {"sha": "764bdd6766618e09e66101deb73a90012f120230", "filename": "gcc/testsuite/g++.old-deja/g++.other/ambig2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fambig2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4c0187c6805870fd437f4973bbf51d1ca064ea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fambig2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fambig2.C?ref=9d4c0187c6805870fd437f4973bbf51d1ca064ea", "patch": "@@ -1,5 +1,5 @@\n // Build don't link:\n-// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n \n // We should spot all ambiguities\n@@ -14,7 +14,7 @@ struct D3 : B, C { int m; };\n \n void fn(D0 *d0, D1 *d1, D2 *d2, D3 *d3)\n {\n-  A *a0 = d0;   // ERROR - A is an ambiguous base XFAIL\n+  A *a0 = d0;   // ERROR - A is an ambiguous base\n   A *a1 = d1;   // ERROR - A is an ambiguous base\n   A *a2 = d2;   // ERROR - A is an ambiguous base\n   A *a3 = d3;   // ERROR - A is an ambiguous base"}]}